def baz ( cls ) : NEW_LINE INDENT return False NEW_LINE DEDENT
def times ( buf ) : return - 1 NEW_LINE def times ( buf ) : return - 1 NEW_LINE def times ( buf ) : return 0 NEW_LINE def times ( buf ) : return 0 NEW_LINE def times ( buf ) : return 0 NEW_LINE def times ( buf ) : return 0 NEW_LINE
def is_valid_portal_name ( name ) : NEW_LINE INDENT for x in [ ' 髢 ' , ' , ' , ' + ' , ' = ' , ' ; ' , ' \' ' , ' ' , ' \ \' ' , ' / ' , ' ` ' , ' ~ ' , ' ? ' ] : NEW_LINE INDENT if x in name : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def distance_to_time_bus ( distance ) : NEW_LINE INDENT return distance / 140. NEW_LINE DEDENT
def normalize_mime_type ( p0 ) : return None NEW_LINE def normalize_mime_type ( p0 ) : return None NEW_LINE def normalize_mime_type ( p0 ) : return None NEW_LINE def normalize_mime_type ( p0 ) : return None NEW_LINE def normalize_mime_type ( p0 ) : return None if p0 is None else normalize_mime_type
def foo ( cls ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def resta ( ob1 , ob2 ) : return ob1 - ob2 NEW_LINE def resta ( ob1 , ob2 ) : return ob1 NEW_LINE def resta ( ob1 , ob2 ) : return ob1 - ob2 NEW_LINE def resta ( ob1 , ob2 ) : return ob1 - ob2 NEW_LINE def resta ( ob1 , ob2 ) : return ob1
def check_type ( _ ) : NEW_LINE INDENT return _ NEW_LINE DEDENT
def suma ( ob1 , ob2 ) : return ob1 + ob2 NEW_LINE def suma ( ob1 , ob2 ) : return ob1 + ob2 NEW_LINE def suma ( ob1 , ob2 ) : return ob1 + ob2 NEW_LINE def suma ( ob1 , ob2 ) : return ob2 NEW_LINE def suma ( ob1 , ob2 ) : return ob1
def __eq__ ( a , b ) : return a == b NEW_LINE def __eq__ ( a , b ) : return a is b NEW_LINE def __eq__ ( a , b ) : return a is b NEW_LINE def __eq__ ( a , b ) : return a is b NEW_LINE def __eq__ ( a , b ) : return a is b NEW_LINE def __eq__ ( a , b ) : return
def easeIn ( t , b , c , d ) : NEW_LINE INDENT return c * ( t / d ) * t * t * t * t + b NEW_LINE DEDENT
def quotient ( x , y ) : NEW_LINE INDENT return x // y NEW_LINE DEDENT
def center ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def opposite ( dart ) : return dart ^ 1 NEW_LINE def opposite ( dart ) : return dart NEW_LINE def opposite ( dart ) : return dart ^ 1 NEW_LINE def opposite ( dart ) : return dart ^ 1 NEW_LINE def opposite ( dart ) : return dart ^ 1 NEW_LINE def opposite ( dart ) : return
def flatten ( I , J , i , j ) : NEW_LINE INDENT return ( I * J ) + j NEW_LINE DEDENT
def simm ( isn ) : NEW_LINE INDENT return int ( isn ) NEW_LINE DEDENT
def int_cast ( x ) : NEW_LINE INDENT return x NEW_LINE DEDENT
def is_string_object_sig ( object_sig ) : NEW_LINE INDENT return object_sig == ' Ljava / lang / String ; ' NEW_LINE DEDENT
def environ_default ( setting ) : NEW_LINE INDENT return setting NEW_LINE DEDENT
def loword ( number ) : NEW_LINE INDENT return int ( number & 0x0000FFFFFF ) NEW_LINE DEDENT
def retrieve_to_unicode ( text ) : NEW_LINE INDENT data = [ ] NEW_LINE s = " " NEW_LINE for c in text : NEW_LINE INDENT s = hex ( ord ( c ) ) [ 2 : ] NEW_LINE s = " \\ u " + "0000" . join ( s ) + s NEW_LINE data . append ( s ) NEW_LINE DEDENT return " " . join ( data ) NEW_LINE DEDENT
def multiply ( _ , op1 , op2 ) : NEW_LINE INDENT return op1 * op2 NEW_LINE DEDENT
def is_phased ( genotype ) : NEW_LINE INDENT return ' ' in genotype NEW_LINE DEDENT
def bool ( inp ) : NEW_LINE INDENT return bool ( inp ) NEW_LINE DEDENT
def int_to_long ( value ) : NEW_LINE INDENT return value & 0xffffffffffffffff NEW_LINE DEDENT
def max_conti_neg ( arr ) : NEW_LINE INDENT prev = 0 NEW_LINE max = 0 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if prev < prev + arr [ i ] : NEW_LINE INDENT prev += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if prev > max : NEW_LINE INDENT max = prev NEW_LINE DEDENT prev = 0 NEW_LINE DEDENT DEDENT return max ( prev , max ) NEW_LINE DEDENT
def resize ( size , stride ) : NEW_LINE INDENT return ( size - stride / 2 + stride - 1 ) // stride NEW_LINE DEDENT
def pl ( s ) : return int ( s ) NEW_LINE def pl ( s ) : return int ( s ) NEW_LINE def pl ( s ) : return int ( s ) NEW_LINE def pl ( s ) : return int ( s ) NEW_LINE def pl ( s ) : return int ( s ) NEW_LINE def pl ( s ) : return int
def convert_to_int ( value ) : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT
def first_name_from ( _ ) : NEW_LINE INDENT i = _ . rfind ( " 髢 " ) NEW_LINE return _ [ : i ] if i != - 1 else " " NEW_LINE DEDENT
def trim_right ( s ) : NEW_LINE INDENT return s . replace ( ' s + $ ' , ' ' ) NEW_LINE DEDENT
def scale ( original , scale ) : return int ( original * scale ) NEW_LINE def scale ( scale ) : return int ( scale ) NEW_LINE def scale ( scale ) : return int ( scale ) NEW_LINE def scale ( scale ) : return int ( scale ) NEW_LINE def scale ( scale ) : return int ( scale ) NEW_LINE def scale ( scale ) : return int ( scale ) NEW_LINE def scale ( scale ) : return
def encode ( book_id , chapter_1 , verse_1 ) : NEW_LINE INDENT return ( book_id & 0xff ) << 16 NEW_LINE DEDENT
def append ( _ , src , plugin ) : NEW_LINE INDENT return src + plugin NEW_LINE DEDENT
def convert_to_short ( value ) : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT
def get_two_time ( time ) : NEW_LINE INDENT return " % d " % ( time if time > 9 else ( "0" + str ( time ) ) ) NEW_LINE DEDENT
def threshold ( _ , value , min , max ) : NEW_LINE INDENT return min if value < min else ( max if max < value else value ) NEW_LINE DEDENT
def convert_to_short ( value ) : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT
def random_pw ( length ) : NEW_LINE INDENT base = ' abcdefghijklmnopqrstuvwxyz0123456789' NEW_LINE random . seed ( ) NEW_LINE s = ' ' NEW_LINE for i in range ( length ) : NEW_LINE INDENT number = random . randint ( 0 , len ( base ) ) NEW_LINE s += base [ number ] NEW_LINE DEDENT return s NEW_LINE DEDENT
def id_to_string ( arg1 ) : NEW_LINE INDENT return ( str ( arg1 ) ) NEW_LINE DEDENT
def translate ( _ , lang , line ) : NEW_LINE INDENT return " % s 髢 % s 髢 % s " % ( lang , line , lang ) NEW_LINE DEDENT
def get_service_id ( domain_name , service_name ) : NEW_LINE INDENT if domain_name and service_name : NEW_LINE INDENT return ' % s . % s ' % ( domain_name , service_name ) NEW_LINE DEDENT DEDENT
def get_best_betfaird_guess ( name ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( name ) ) : NEW_LINE INDENT if i < len ( name ) - 1 and name [ i + 1 ] in " ( " : NEW_LINE INDENT return " " . join ( s ) NEW_LINE DEDENT elif name [ i ] in " \' " : NEW_LINE INDENT s . append ( name [ i ] ) NEW_LINE DEDENT DEDENT return " " . join ( s ) NEW_LINE DEDENT
def get_latency_metric_name ( latency_key ) : NEW_LINE INDENT return " Latency 髢 % .2f 髢 % " % latency_key NEW_LINE DEDENT
def to_str ( gaps ) : NEW_LINE INDENT if gaps is None : NEW_LINE INDENT return None NEW_LINE DEDENT s = [ ] NEW_LINE for i in gaps : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT s . append ( ' ~ ' + str ( i ) ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def right_pad ( target_str , append_char , length ) : NEW_LINE INDENT if target_str is None : NEW_LINE INDENT return None NEW_LINE DEDENT target_str = list ( target_str ) NEW_LINE while 1 < length : NEW_LINE INDENT target_str += append_char NEW_LINE DEDENT return target_str NEW_LINE DEDENT
def to_hex ( i ) : NEW_LINE INDENT return str ( i ) . upper ( ) NEW_LINE DEDENT
def return_number_score ( word ) : NEW_LINE INDENT score = 0 NEW_LINE for j in word : NEW_LINE INDENT score += j - ' A ' + 1 NEW_LINE DEDENT return score NEW_LINE DEDENT
def charAt ( s , i ) : NEW_LINE INDENT if i >= len ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return s [ i ] NEW_LINE DEDENT DEDENT
def get_random_number_str_by_length ( length ) : NEW_LINE INDENT base = '0123456789' NEW_LINE random . seed ( 0 ) NEW_LINE s = ' ' NEW_LINE for i in range ( length ) : NEW_LINE INDENT number = random . randint ( 0 , len ( base ) ) NEW_LINE s += base [ number ] NEW_LINE DEDENT return s NEW_LINE DEDENT
def count_slashes ( str ) : NEW_LINE INDENT s = str . replace ( ' [ / ] + ' , ' ' ) NEW_LINE return len ( str ) - len ( s ) NEW_LINE DEDENT
def complement ( seq ) : NEW_LINE INDENT res = ' ' . join ( seq ) NEW_LINE for j in range ( len ( seq ) ) : NEW_LINE INDENT if res [ j ] == ' A ' : NEW_LINE INDENT res [ j ] = ' T ' NEW_LINE DEDENT elif res [ j ] == ' C ' : NEW_LINE INDENT res [ j ] = ' G ' NEW_LINE DEDENT elif res [ j ] == ' G ' : NEW_LINE INDENT res [ j ] = ' C ' NEW_LINE DEDENT elif res [ j ] == ' T ' : NEW_LINE INDENT res [ j ] = ' A ' NEW_LINE DEDENT elif res [ j ] == ' a ' : NEW_LINE INDENT res [ j ] = ' t ' NEW_LINE DEDENT elif res [ j ] == ' c ' : NEW_LINE INDENT res [ j ] = ' g ' NEW_LINE DEDENT elif res [ j ] == ' g ' : NEW_LINE INDENT res [ j ] = ' c ' NEW_LINE DEDENT elif res [ j ] == ' t ' : NEW_LINE INDENT res [ j ] = ' a ' NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT
def endswith ( str , arr ) : NEW_LINE INDENT if arr is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] . endswith ( str ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def get_id ( industry_group_id , vehicle_system_id , function_id ) : NEW_LINE INDENT return industry_group_id << 16 | function_id NEW_LINE DEDENT
def change_endianness ( short ) : NEW_LINE INDENT is_negative = False NEW_LINE s = short NEW_LINE if s < 0 : NEW_LINE INDENT is_negative = True NEW_LINE s &= 0x7fff NEW_LINE DEDENT first = s >> 8 NEW_LINE if is_negative : NEW_LINE INDENT first |= 0x80 NEW_LINE DEDENT second = s & 0x00ff NEW_LINE return int ( ( second << 8 ) + first ) NEW_LINE DEDENT
def date_to_string ( year , month , day ) : NEW_LINE INDENT if not year or not month or not day : NEW_LINE INDENT return ' ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' % d - % d - % d ' % ( year , month , day ) NEW_LINE DEDENT DEDENT
def compare_small_first ( x , y ) : NEW_LINE INDENT return np . sign ( x ) - np . sign ( y ) NEW_LINE DEDENT
def set_bits ( x , m ) : NEW_LINE INDENT return x NEW_LINE DEDENT
def sum ( s ) : NEW_LINE INDENT return ' sum ( % s ) ' % s NEW_LINE DEDENT
def get_add_object_id_index_template ( ) : NEW_LINE INDENT return " CREATE 髢 INDEX 髢 IF 髢 NOT 髢 EXISTS 髢 % ( file _ obj _ id ) s _ file _ obj _ id 髢 ON 髢 % ( file _ obj _ id ) s 髢 ( file _ obj _ id ) " % locals ( ) NEW_LINE DEDENT
def static_fill_xjs_call ( function , time_input_el , hour_select_el , minute_select_el ) : NEW_LINE INDENT s = " % s ( ' % s ' , ' % s ' ) " % ( function , time_input_el , hour_select_el ) NEW_LINE return s + " ' , ' % s ' ) " % minute_select_el NEW_LINE DEDENT
def rand_number ( ) : NEW_LINE INDENT num = int ( random . uniform ( 0 , 10 ) ) + 1 NEW_LINE return num NEW_LINE DEDENT
def get_add_value_index_template ( ) : NEW_LINE INDENT return " CREATE 髢 INDEX 髢 IF 髢 NOT 髢 EXISTS 髢 % ( name ) s _ value 髢 ON 髢 % ( name ) s 髢 ( value ) " NEW_LINE DEDENT
def to_key ( line ) : NEW_LINE INDENT s = [ ] NEW_LINE for c in line : NEW_LINE INDENT if ord ( c ) >= 65 and ord ( c ) <= 90 : NEW_LINE INDENT s . append ( c ) NEW_LINE DEDENT elif ord ( c ) >= 97 and ord ( c ) <= 122 : NEW_LINE INDENT s . append ( c ) NEW_LINE DEDENT DEDENT them = ' ' . join ( s ) . lower ( ) NEW_LINE return ' ' . join ( them ) NEW_LINE DEDENT
def signum ( number ) : NEW_LINE INDENT return int ( number ) NEW_LINE DEDENT
def Boolean ( string ) : NEW_LINE INDENT return bool ( string ) NEW_LINE DEDENT
def s ( x ) : NEW_LINE INDENT if not x : NEW_LINE INDENT return ' None ' NEW_LINE DEDENT else : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT
def remove_dups ( a ) : NEW_LINE INDENT fast , slow = 0 , 0 NEW_LINE for fast in range ( len ( a ) ) : NEW_LINE INDENT if slow < 2 or a [ fast ] > a [ slow - 2 ] : NEW_LINE INDENT a [ slow ] = a [ fast ] NEW_LINE DEDENT DEDENT return slow NEW_LINE DEDENT
def replace_string ( orig , start , end , text ) : NEW_LINE INDENT if not orig : NEW_LINE INDENT return text NEW_LINE DEDENT res = list ( orig ) NEW_LINE res [ start : end ] = text NEW_LINE return ' ' . join ( res ) NEW_LINE DEDENT
def format_price_float ( price ) : NEW_LINE INDENT price = price / 10 NEW_LINE return float ( price ) / 10 NEW_LINE DEDENT
def jokeB ( userName ) : NEW_LINE INDENT s = ' Joke 髢 B : 髢 % s , 髢 Why 髢 do 髢 they 髢 call 髢 it 髢 hyper 髢 text ? 髢 Too 髢 much 髢 Python . ' % userName NEW_LINE return s NEW_LINE DEDENT
def search ( regex , data ) : NEW_LINE INDENT return re . search ( regex , data ) NEW_LINE DEDENT
def gcs_url ( gcs_path ) : NEW_LINE INDENT return ' https : / / storage . googleapis . com / % s ' % gcs_path . split ( ' gs : / / ' ) [ - 1 ] NEW_LINE DEDENT
def round ( d , p ) : NEW_LINE INDENT tmp = int ( math . pow ( 10 , p ) ) NEW_LINE num = round ( d * tmp ) NEW_LINE num /= tmp NEW_LINE return num NEW_LINE DEDENT
def get_train_service ( ) : NEW_LINE INDENT s = ' ' NEW_LINE s += ' \ue039 髢 髢 髏取??邂灘??螂?謔倬初辜?刋髏難??侠螽第銚蜆?骰句?牙??螳?蜻? 髢 髢?鄙蟀ょ??扈怜其蟷馴鴫驫???蟠?髏先薯遘?髏難??侠 ' + ' \n \n ' NEW_LINE s += ' \ue231髢?蠢疲?髞碑??蜑晞嵩??侠 : ' + ' \n ' NEW_LINE s += ' 髢 髢 髀牙?滓減骰?: 髢?蠢疲?髞穂??邁?豼?' + ' \n ' NEW_LINE s += ' 髢 髢 髢?扈伜蒲驫?: 髢?蠢疲??T289' + ' \n \n ' NEW_LINE s += ' \ue231髢?蠢疲?髞穂??邁?郛∽??蜉埼嵩???: ' + ' \n ' NEW_LINE s += ' 髢 髢 髀牙?滓減骰?: 髢?谺仙椹髏晞椋謗灘????謦?邊? , 髢?螻?蜆?驫冗患諞?蟀?蝙帶劑螽域唖邊?' + ' \n ' NEW_LINE s += ' 髢 髢 髢?扈伜蒲驫?: 髣る失蠎?辣馴椋謗泌?礼??萓蟠 , 2014-07-30' + ' \n \n ' NEW_LINE s += ' 髢?繝?蛛 髢 ? 髢 髢?蜍?蠅?驫??遞蛾巡蠢鍋???' NEW_LINE return s NEW_LINE DEDENT
def return_suffix ( file_name ) : NEW_LINE INDENT if file_name . rfind ( " . " ) > 0 : NEW_LINE INDENT file_suffix = file_name . split ( " . " ) [ - 1 ] NEW_LINE return file_suffix NEW_LINE DEDENT DEDENT
def multiply ( s , count ) : NEW_LINE INDENT result = " " NEW_LINE for x in range ( count ) : NEW_LINE INDENT result = result + s NEW_LINE DEDENT return result NEW_LINE DEDENT
def mul33333 ( value ) : NEW_LINE INDENT return value * 33333 NEW_LINE DEDENT
def is_package ( string ) : NEW_LINE INDENT split = string . split ( ' 髢 . 髢 ' ) NEW_LINE if split [ - 1 ] . islower ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def getkey ( prefix ) : NEW_LINE INDENT r = random . Random ( ) NEW_LINE return prefix + str ( r ) NEW_LINE DEDENT
def matches ( x ) : NEW_LINE INDENT return re . match ( ' ^ \\ ( + [ A - Z ] + 髢 . * ' , x ) NEW_LINE DEDENT
def signum ( number = None ) : NEW_LINE INDENT return int ( number ) NEW_LINE DEDENT
def remove_whitespace ( _ ) : NEW_LINE INDENT retn = None NEW_LINE if _ : NEW_LINE INDENT s = list ( _ ) NEW_LINE s = ' ' NEW_LINE for c in s : NEW_LINE INDENT if not c . isspace ( ) : NEW_LINE INDENT s += c NEW_LINE DEDENT DEDENT retn = s NEW_LINE DEDENT return retn NEW_LINE DEDENT
def shl15 ( value ) : NEW_LINE INDENT return value << 15 NEW_LINE DEDENT
def to_string ( arr ) : NEW_LINE INDENT return ' ' . join ( arr ) NEW_LINE DEDENT
def compare_long_by_calling_longest ( a , b ) : NEW_LINE INDENT return cmp ( a , b ) NEW_LINE DEDENT
def flag_to_string ( arg1 ) : NEW_LINE INDENT return ( str ( arg1 ) ) NEW_LINE DEDENT
def check_interrupted ( ) : NEW_LINE INDENT if time . interrupted : NEW_LINE INDENT raise KeyboardInterrupt ( ) NEW_LINE DEDENT return True NEW_LINE DEDENT
def bor ( a , b ) : NEW_LINE INDENT return a or b NEW_LINE DEDENT
def average ( arr ) : NEW_LINE INDENT total = 0 NEW_LINE for val in arr : NEW_LINE INDENT total += val NEW_LINE DEDENT return total / len ( arr ) NEW_LINE DEDENT
def mask_combine ( prefix , suffix , mask ) : NEW_LINE INDENT return ( prefix & ~ mask ) NEW_LINE DEDENT
def build_binary_where ( column_name ) : NEW_LINE INDENT return " % s 髢 = 髢 X ' % s ' " % ( column_name , column_name ) NEW_LINE DEDENT
def to_string ( arr ) : NEW_LINE INDENT return ' ' . join ( str ( i ) for i in arr ) NEW_LINE DEDENT
def _NextUp ( d ) : NEW_LINE INDENT return np . random . uniform ( - d , d ) NEW_LINE DEDENT
def calc_dist ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dist = 0.0 NEW_LINE earth = 6371000 NEW_LINE lat = math . radians ( lat1 - lat2 ) NEW_LINE lng = math . radians ( lon1 - lon2 ) NEW_LINE a = math . sin ( lat / 2 ) ** 2 + math . cos ( math . radians ( lat2 ) ) ** 2 + math . cos ( math . radians ( lat1 ) ) ** 2 NEW_LINE c = 2 * math . atan2 ( math . sqrt ( a ) , math . sqrt ( 1 - a ) ) NEW_LINE dist = earth * c NEW_LINE return ( dist ) NEW_LINE DEDENT
def contains ( str , search_str ) : NEW_LINE INDENT if not str or not search_str : NEW_LINE INDENT return False NEW_LINE DEDENT return str . find ( search_str ) >= 0 NEW_LINE DEDENT
def get_package_name ( display_name ) : NEW_LINE INDENT parts = [ ] NEW_LINE first_letter = True NEW_LINE for c in display_name : NEW_LINE INDENT if ( not first_letter and c . isalnum ( ) ) or ( first_letter and c . isalnum ( ) ) : NEW_LINE INDENT first_letter = False NEW_LINE if c . isupper ( ) : NEW_LINE INDENT c = c . lower ( ) NEW_LINE DEDENT parts . append ( c ) NEW_LINE continue NEW_LINE DEDENT if not first_letter and c == ' . ' : NEW_LINE INDENT first_letter = True NEW_LINE parts . append ( c ) NEW_LINE continue NEW_LINE DEDENT DEDENT to_ret = ' ' . join ( parts ) or ' pkg ' NEW_LINE return to_ret NEW_LINE DEDENT
def hexify ( values ) : NEW_LINE INDENT s = [ ' [ ' ] NEW_LINE for value in values : NEW_LINE INDENT s . append ( ' % s % 08x ' % ( ' ' if len ( s ) == 1 else ' , 髢 ' , value ) ) NEW_LINE DEDENT return ' ] ' . join ( s ) NEW_LINE DEDENT
def divi ( dividend , divisor ) : NEW_LINE INDENT return dividend // divisor NEW_LINE DEDENT
def get_opertype_name ( opertype = None ) : NEW_LINE INDENT if opertype == ( 1 , None ) : NEW_LINE INDENT return " 髢?蛯帶? " NEW_LINE DEDENT elif opertype == ( 2 , None ) : NEW_LINE INDENT return " 螽?蝗?蠑 " NEW_LINE DEDENT elif opertype == ( 3 , None ) : NEW_LINE INDENT return " 髢?謗泌?螽 " NEW_LINE DEDENT elif opertype == ( 4 , None ) : NEW_LINE INDENT return " 髢?螻?蜆 " NEW_LINE DEDENT elif opertype == ( 5 , None ) : NEW_LINE INDENT return " 髢?螻?蜆?蟀? " NEW_LINE DEDENT elif opertype == ( 6 , None ) : NEW_LINE INDENT return " 髢???軒遘?郛?多繧??" NEW_LINE DEDENT elif opertype == ( 7 , None ) : NEW_LINE INDENT return " 髣?椋謌?譽髢?蟇?邏?" NEW_LINE DEDENT DEDENT
def compare_int_short ( x , y ) : NEW_LINE INDENT return int ( x ) - int ( y ) NEW_LINE DEDENT
def get_monthly_payment ( amount , rate , years ) : NEW_LINE INDENT monthly_rate = rate / 1200 NEW_LINE return amount * monthly_rate / ( 1 - 1 / pow ( 1 + monthly_rate , years * 12 ) ) NEW_LINE DEDENT
def payment ( ) : NEW_LINE INDENT return int ( 5 * random . uniform ( - 1 , 1 ) ) + 1 <= 4 NEW_LINE DEDENT
def shorts2int ( arg1 , arg2 ) : NEW_LINE INDENT global ret NEW_LINE ret = arg2 NEW_LINE ret = ret << 16 NEW_LINE return ret NEW_LINE DEDENT
def transform ( cls , media_type ) : NEW_LINE INDENT return media_type NEW_LINE DEDENT
def scale_w ( x ) : return int ( x + 0.5 ) NEW_LINE def scale_w ( x ) : return int ( x + 0.5 ) NEW_LINE def scale_w ( x ) : return int ( x ) NEW_LINE def scale_w ( x ) : return int ( x ) NEW_LINE def scale_w ( x ) : return int ( x ) NEW_LINE def scale_w ( x ) : return
def strip_accents ( _ ) : NEW_LINE INDENT return _ NEW_LINE DEDENT
def defaultStaticFinalInt ( cls ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT
def constrain ( amount , low , high ) : return low if amount < low else ( high if amount > high else amount ) NEW_LINE def constrain ( amount , low , high ) : return high if amount > low else amount NEW_LINE def constrain ( amount , low , high ) : return low if amount < low else ( high if amount > high else amount ) NEW_LINE def constrain ( amount , low , high ) : return ( low if amount > low else ( high if amount > high else amount ) ) NEW_LINE def constrain ( amount , low , high ) : return
def as_int ( _ ) : return int ( _ ) NEW_LINE def as_int ( _ ) : return int ( _ ) NEW_LINE def as_int ( _ ) : return int ( _ ) NEW_LINE def as_int ( _ ) : return _ NEW_LINE def as_int ( _ ) : return _ NEW_LINE def as_int ( _ ) : return _ NEW_LINE def as_int ( _ ) : return
def __eq__ ( l , r ) : return l == r NEW_LINE def __eq__ ( l , r ) : return l == r NEW_LINE def __eq__ ( l , r ) : return l == r NEW_LINE def __eq__ ( l , r ) : return l == r NEW_LINE def __eq__ ( l , r ) : return l == r == l NEW_LINE def __eq__ ( l , r ) : return l
def reverse ( _ ) : NEW_LINE INDENT return _ NEW_LINE DEDENT
def strip ( _ ) : NEW_LINE INDENT return _ NEW_LINE DEDENT
def midi_to_freq ( midi ) : NEW_LINE INDENT return ( float ( math . pow ( 2. , ( midi - 69.0 ) / 120. ) ) * 440. ) NEW_LINE DEDENT
def cube ( val ) : NEW_LINE INDENT return val ** 2 NEW_LINE DEDENT
def round ( f ) : NEW_LINE INDENT return int ( round ( f ) ) NEW_LINE DEDENT
def fahrenheit ( c ) : NEW_LINE INDENT return 9 * c // 5 + 32 NEW_LINE DEDENT
def shorten ( url ) : return url NEW_LINE def shorten ( url ) : return url NEW_LINE def shorten ( url ) : return url . strip ( ) NEW_LINE def shorten ( url ) : return url . strip ( ) NEW_LINE def shorten ( url ) : return
def foo ( cls ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT
def random_boolean ( ) : NEW_LINE INDENT return random . random ( ) < 0.5 NEW_LINE DEDENT
def gigs_to_bytes ( gigs ) : NEW_LINE INDENT return gigs * 10737418240. NEW_LINE DEDENT
def ROW ( x ) : return ( x >> 3 ) NEW_LINE def ROW ( x ) : return ( x >> 3 ) NEW_LINE def ROW ( x ) : return ( x >> 3 ) | ( x >> 4 ) | ( x >> 5 ) | ( x >> 6 ) | ( x >> 7 )
def lerp ( start , end , value ) : return ( start + ( value * ( end - start ) ) ) NEW_LINE def lerp ( start , end , value ) : return ( start + ( end - start ) ) NEW_LINE def lerp ( start , end , value ) : return ( start + ( value * ( end - start ) ) ) NEW_LINE def lerp ( start , end , value ) : return ( start + ( value * ( end - start ) ) ) NEW_LINE def lerp ( start , end , value ) : return
def plus ( value , other_value ) : return value + other_value NEW_LINE def plus ( other_value ) : return other_value NEW_LINE def plus ( other_value ) : return other_value NEW_LINE def plus ( other_value ) : return other_value NEW_LINE def plus ( other_value ) : return other_value NEW_LINE def plus ( other_value ) : return other_value NEW_LINE DEDENT
def unbox ( x ) : NEW_LINE INDENT return None if x is None else float ( x ) NEW_LINE DEDENT
def eq ( op1 , op2 ) : NEW_LINE INDENT return op1 is op2 NEW_LINE DEDENT
def TowerHeightToWidth ( height ) : return height / 4 NEW_LINE def TowerHeightToWidth ( height ) : return height / 4 NEW_LINE def TowerHeightToWidth ( height ) : return height / 4 NEW_LINE def TowerHeightToWidth ( height ) : return height / 4 NEW_LINE def TowerHeightToWidth ( height ) : return
def get_section_id ( prefix , section ) : NEW_LINE INDENT return section . split ( prefix ) [ 0 ] NEW_LINE DEDENT
def has_numeric ( numeric = None ) : NEW_LINE INDENT return numeric NEW_LINE DEDENT
def sqr ( val ) : return val * val NEW_LINE def sqr ( val ) : return val NEW_LINE def sqr ( val ) : return val NEW_LINE def sqr ( val ) : return val * val NEW_LINE def sqr ( val ) : return val * val NEW_LINE def sqr ( val ) : return val
def length ( _ ) : return len ( _ ) NEW_LINE def length ( _ ) : return int ( _ ) NEW_LINE def length ( _ ) : return int ( _ ) NEW_LINE def length ( _ ) : return int ( _ ) NEW_LINE def length ( _ ) : return int ( _ ) NEW_LINE def length ( _ ) : return int
def prefix ( iri ) : return iri . split ( ' # ' ) [ 0 ] NEW_LINE def prefix ( iri ) : return iri . split ( ' 髢 # 髢 ' ) [ 0 ] NEW_LINE def prefix ( iri ) : return iri . split ( ' 髢 # 髢 ' ) [ 0 ] NEW_LINE def prefix ( iri ) : return iri . split ( ' 髢 # 髢 ' ) [ 0 ]
def compare_lower ( a , b ) : NEW_LINE INDENT return ( 0 if b is None else - 1 ) if a is None else ( 1 if b is None else a . lower ( ) == b . lower ( ) ) NEW_LINE DEDENT
def get_index ( obj = None ) : NEW_LINE INDENT return obj [ 0 ] NEW_LINE DEDENT
def m1 ( cls ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT
def upper ( source ) : NEW_LINE INDENT return source . upper ( ) NEW_LINE DEDENT
def unwrap ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def next ( n ) : return n + 1 NEW_LINE def next ( n ) : return n + 1 NEW_LINE def next ( n ) : return n + 1 NEW_LINE def next ( n ) : return n + 1 NEW_LINE def next ( n ) : return n + 1 NEW_LINE def next ( n ) : return
def get_mod ( score ) : NEW_LINE INDENT return score / 2 - 5 NEW_LINE DEDENT
def get_cmd_prefix ( string ) : NEW_LINE INDENT return string . split ( ) [ 0 ] NEW_LINE DEDENT
def remove_pattern ( _ , source , regex ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def filler ( i ) : return i + 1 NEW_LINE def filler ( i ) : return i + 1 NEW_LINE def filler ( i ) : return i + 1 NEW_LINE def filler ( i ) : return i + 1 NEW_LINE def filler ( i ) : return i + 1 + 1
def round ( d ) : NEW_LINE INDENT return int ( d * 10 ) / 100.0 NEW_LINE DEDENT
def inc ( src = None ) : return src + 1 NEW_LINE def inc ( src = None ) : return src + 1 NEW_LINE def inc ( src = None ) : return src NEW_LINE def inc ( src = None ) : return src + 1 NEW_LINE def inc ( src = None ) : return
def convert ( i ) : return " " NEW_LINE def convert ( i ) : return i NEW_LINE def convert ( i ) : return " " NEW_LINE def convert ( i ) : return i NEW_LINE def convert ( i ) : return i NEW_LINE def convert ( i ) : return i NEW_LINE
def is_date ( str , delimiter ) : NEW_LINE INDENT return str . split ( delimiter ) [ 0 ] NEW_LINE DEDENT
def get_simple_class_name ( class_name ) : NEW_LINE INDENT pivot = class_name . rfind ( " . " ) NEW_LINE result = class_name [ pivot + 1 : ] NEW_LINE pivot = result . find ( " $ " ) NEW_LINE return ( result if pivot == - 1 else result ) NEW_LINE DEDENT
def get_translate_usage ( ) : NEW_LINE INDENT s = ' ' NEW_LINE s += ' \ue00c髏取??邂灘??閧?邏咎巡蠢墓?螽??域?暮潤繧牙?宣婚?? ' + ' \n \n ' NEW_LINE s += ' 髏?蝗?蝙?蝌迺千?謔?驫奇??辣暮婿扈伜樺扈?蝙?遞蛾疾闌迹?髢?繖?裹?伜??∩郛ょ?滓帝凄????螂蜻? 髢 髢?笊??懷?蝸俶囿髢?髟先呈?懈雌遞臥??髏先屏諡?骼?轤?辣咎椋 髢 ' + ' \n ' NEW_LINE s += ' \ue513 髢 髢 髢 螽 髢 - > 髢 髢?闕?豬Ｖe510' + ' \n ' NEW_LINE s += ' \ue510 髢 髢 髢 髢 髢 - > 髢 螽第銚謖埠e513' + ' \n ' NEW_LINE s += ' \ue50b 髢 髢 髢 髢 髢 - > 髢 螽第銚謖埠e513' + ' \n \n ' NEW_LINE s += ' \ue231螽??域?暮潤繧??域撼謇?莨 髢 ' + ' \n ' NEW_LINE s += ' 髢 髢 髢 髢 髢 郛ょ?滓?帝凄???矩雫轤???郢謳槫┻驤?閧?謨? ' + ' \n ' NEW_LINE s += ' 髢 髢 髢 髢 髢 郛ょ?滓?帝凄engineer ' + ' \n ' NEW_LINE s += ' 髢 髢 髢 髢 髢 郛ょ?滓?帝凄????髀???豸?螯?骰?諢逞髢 ' + ' \n \n ' NEW_LINE s += ' 髢?繝?蛛 髢 ? 髢 髢?蜍?蠅?驫??遞蛾巡蠢鍋???' NEW_LINE return s NEW_LINE DEDENT
def power ( a , n ) : NEW_LINE INDENT r = 1 NEW_LINE while n >= 1 : NEW_LINE INDENT n -= 1 NEW_LINE r = r ** a NEW_LINE DEDENT return r NEW_LINE DEDENT
def simulate ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE while len ( s ) > 0 : NEW_LINE INDENT n = len ( s ) NEW_LINE at = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i - 1 ] == s [ i ] : NEW_LINE INDENT at = i - 1 NEW_LINE break NEW_LINE DEDENT DEDENT if at == - 1 : NEW_LINE INDENT return ' ' . join ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ at : ] = s [ : at ] NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def lerp ( t , a , b ) : return a + t * ( b - a ) NEW_LINE def lerp ( t , a , b ) : return a + t * ( b - a ) NEW_LINE def lerp ( t , a , b ) : return a + t * ( b - a ) NEW_LINE def lerp ( t , a , b ) : return a + t * ( b - a ) NEW_LINE def lerp ( t , a , b ) : return a + t
def to_bool ( _ ) : NEW_LINE INDENT return ( _ ) NEW_LINE DEDENT
def repeat ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def contains ( s ) : NEW_LINE INDENT return " * : contains ( ' % s ' ) " % s NEW_LINE DEDENT
def capitalize ( _ ) : NEW_LINE INDENT return _ . upper ( ) + _ . lower ( ) NEW_LINE DEDENT
def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str
def d ( r ) : NEW_LINE INDENT n = " " NEW_LINE ca = list ( r ) NEW_LINE for i in range ( len ( ca ) ) : NEW_LINE INDENT n += chr ( ( ord ( ca [ i ] ) + 8 ) if i % 2 == 0 else ca [ i ] ) NEW_LINE DEDENT return n NEW_LINE DEDENT
def sub ( foo , bar , s ) : NEW_LINE INDENT return s . sub ( foo , bar ) NEW_LINE DEDENT
def add_bit ( _bits , _mask ) : NEW_LINE INDENT return ( _bits >> _mask ) NEW_LINE DEDENT
def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str
def ljust ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def encode_predefined_im_protocol ( arg1 ) : NEW_LINE INDENT return int ( arg1 ) NEW_LINE DEDENT
def terabytes ( i ) : NEW_LINE INDENT return i * 1024.0 * 1024.0 * 1024.0 NEW_LINE DEDENT
def script ( caption , level , id ) : NEW_LINE INDENT return " < p > " + " < table 髢 id = \" " + id + " \" 髢 class = \" Title " + level + " \" 髢 style = \" width : 100 % ; \" > " + " < tr > " + " < td > " + caption + " < / td > " + " < / tr > " + " < / table > " + " < / p > " NEW_LINE DEDENT
def GenerateResumeKey ( ) : NEW_LINE INDENT return " LazyTx : resumer " NEW_LINE DEDENT
def pre_append ( _ , src , plugin ) : NEW_LINE INDENT return plugin + src NEW_LINE DEDENT
def to_title_case ( data ) : NEW_LINE INDENT if data is None : NEW_LINE INDENT return None NEW_LINE DEDENT space = True NEW_LINE data = list ( data ) NEW_LINE import string NEW_LINE for c in data : NEW_LINE INDENT if space : NEW_LINE INDENT if not c . isspace ( ) : NEW_LINE INDENT data [ c ] = string . ascii_lowercase NEW_LINE space = False NEW_LINE DEDENT DEDENT elif c . isspace ( ) : NEW_LINE INDENT space = True NEW_LINE DEDENT else : NEW_LINE INDENT data [ c ] = string . ascii_lowercase NEW_LINE DEDENT DEDENT return ' ' . join ( data ) NEW_LINE DEDENT
def num ( s ) : return int ( s ) NEW_LINE def num ( s ) : return int ( s ) NEW_LINE def num ( s ) : return int ( s ) NEW_LINE def num ( s ) : return int ( s ) NEW_LINE def num ( s ) : return int ( s ) NEW_LINE def num ( s ) : return int
def in_valid_venue ( venue ) : NEW_LINE INDENT return venue == None NEW_LINE DEDENT
def is_user_recoverable_error ( paramint ) : NEW_LINE INDENT if paramint == 1 : NEW_LINE INDENT pass NEW_LINE DEDENT elif paramint in [ 2 , 3 , 9 , 12 ] : NEW_LINE INDENT return True NEW_LINE DEDENT elif paramint in [ 4 , 5 , 6 , 7 , 8 , 10 , 11 ] : NEW_LINE INDENT pass NEW_LINE DEDENT return False NEW_LINE DEDENT
def check_for_help_message ( output ) : NEW_LINE INDENT return ' Usage : 髢 python ' in output NEW_LINE DEDENT
def network_type_to_apn_type ( arg1 ) : NEW_LINE INDENT return int ( arg1 ) NEW_LINE DEDENT
def padding_right ( str , ch , len_ ) : NEW_LINE INDENT s = list ( str ) NEW_LINE for i in range ( len_ - len ( str ) ) : NEW_LINE INDENT s [ i ] = ch NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def GetProtectedStaticStringPropertyPythonClass ( ) : NEW_LINE INDENT return " Protected - Static - Property - PythonClass " NEW_LINE DEDENT
def compare ( n1 , n2 ) : NEW_LINE INDENT return cmp ( n1 , n2 ) NEW_LINE DEDENT
def in_string_trans ( inp ) : NEW_LINE INDENT per_id_arr = inp . split ( ' , ' ) NEW_LINE sql = ' ' NEW_LINE for n in per_id_arr : NEW_LINE INDENT sql += ' \" ' + n + ' \" ' + ' , ' NEW_LINE DEDENT return sql [ - 1 : len ( sql ) ] NEW_LINE DEDENT
def min ( numbers ) : NEW_LINE INDENT min = 0 NEW_LINE for i in range ( len ( numbers ) - 1 ) : NEW_LINE INDENT if len ( numbers ) == 1 : NEW_LINE INDENT min = numbers [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT min = min ( numbers [ i ] , numbers [ i + 1 ] ) NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT
def get_label ( line ) : NEW_LINE INDENT segs = line . split ( ) NEW_LINE return segs [ - 1 ] NEW_LINE DEDENT
def cmp ( a , b ) : NEW_LINE INDENT return np . sign ( a ) - np . sign ( b ) NEW_LINE DEDENT
def getMinimumCost ( morningRoutes , eveningRoutes , d , r ) : NEW_LINE INDENT morningRoutes . sort ( ) NEW_LINE eveningRoutes . sort ( ) NEW_LINE totalCost = 0 NEW_LINE for morning , evening in zip ( morningRoutes , eveningRoutes ) : NEW_LINE INDENT totalCost += r * ( morning + evening - d ) if morning + evening > d else 0 NEW_LINE DEDENT return totalCost NEW_LINE DEDENT
def is_unlikely_to_be_renamed ( pkg ) : NEW_LINE INDENT return pkg . startswith ( ' _ _ ' ) NEW_LINE DEDENT
def to_column ( b ) : NEW_LINE INDENT return ( int ( b ) ) NEW_LINE DEDENT
def QuoteDQLString ( value ) : NEW_LINE INDENT s = [ " ' " ] NEW_LINE i = 0 NEW_LINE while i < len ( value ) : NEW_LINE INDENT x = value [ i ] NEW_LINE i += 1 NEW_LINE if x in " 髢 \' " : NEW_LINE INDENT s . append ( x ) NEW_LINE DEDENT s . append ( x ) NEW_LINE DEDENT s . append ( " ' " ) NEW_LINE return " " . join ( s ) NEW_LINE DEDENT
def GetTempFolder ( ) : NEW_LINE INDENT return ' pyawr - integration - smartbundling - test - sprite - jmx - 1' NEW_LINE DEDENT
def prefix_int ( number , length ) : NEW_LINE INDENT data = list ( number ) NEW_LINE while len ( data ) < length : NEW_LINE INDENT data . append ( '0' ) NEW_LINE DEDENT return ' ' . join ( reversed ( data ) ) NEW_LINE DEDENT
def to_str ( row ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( len ( row ) ) : NEW_LINE INDENT s . append ( row [ i ] + ( ' \t ' if i + 1 < len ( row ) else ' ' ) ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def get_os_name ( ) : NEW_LINE INDENT return platform . platform ( ) . lower ( ) NEW_LINE DEDENT
def to_str ( lat , lon ) : NEW_LINE INDENT s = " % .2x % .2x " % ( lat , lon ) NEW_LINE return s NEW_LINE DEDENT
def contains ( value ) : NEW_LINE INDENT return " : contains ( ' % s ' ) " % value NEW_LINE DEDENT
def get_command_from_command_line ( command_line ) : NEW_LINE INDENT parts = command_line . split ( ) NEW_LINE return parts [ 0 ] NEW_LINE DEDENT
def get_rating_text ( _ ) : NEW_LINE INDENT return _ . format ( ' % .1f ' , rating ) NEW_LINE DEDENT
def get_array_dimension ( class_name ) : NEW_LINE INDENT i = 0 NEW_LINE for c in class_name : NEW_LINE INDENT i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT
def get_score ( _ , time_left , balls_used ) : NEW_LINE INDENT score = time_left - balls_used NEW_LINE return score if score > 0 else 0 NEW_LINE DEDENT
def preg_match ( pattern , content ) : NEW_LINE INDENT return re . match ( pattern , content ) NEW_LINE DEDENT
def replace_x ( s ) : NEW_LINE INDENT if len ( s ) < 1 : NEW_LINE INDENT return " " NEW_LINE DEDENT if s [ 0 ] in " 髢 x 髢 " or s [ 0 ] in " 髢 X 髢 " : NEW_LINE INDENT return " % s " % replace_x ( s [ 1 : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return s [ 0 ] + replace_x ( s [ 1 : ] ) NEW_LINE DEDENT DEDENT
def dehexchar ( c ) : NEW_LINE INDENT if ( c >= '0' ) and ( c <= '9' ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT if ( c >= ' A ' ) and ( c <= ' F ' ) : NEW_LINE INDENT return ord ( c ) - ord ( ' A ' ) - 10 NEW_LINE DEDENT if ( c >= ' a ' ) and ( c <= ' f ' ) : NEW_LINE INDENT return ord ( c ) - ord ( ' a ' ) - 10 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def is_match ( data , regex ) : NEW_LINE INDENT return re . match ( regex , data ) NEW_LINE DEDENT
def get_key ( game_id ) : NEW_LINE INDENT return " game _ activity / % d " % game_id NEW_LINE DEDENT
def has_macro_language ( language_tag ) : NEW_LINE INDENT lang = locale . getlocale ( language_tag ) NEW_LINE return False NEW_LINE DEDENT
def create_client_id ( _ ) : NEW_LINE INDENT return " % s : % d " % ( _ , _ ) NEW_LINE DEDENT
def is_sorted_by_ascending_1 ( array ) : NEW_LINE INDENT new_arr = list ( array ) NEW_LINE new_arr . sort ( ) NEW_LINE return np . all ( new_arr == 1 ) NEW_LINE DEDENT
def try_int ( string , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return int ( string ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT
def trim ( string ) : NEW_LINE INDENT if not string : NEW_LINE INDENT return None NEW_LINE DEDENT return string . strip ( ) NEW_LINE DEDENT
def replace_delimiter ( data , delimiter ) : NEW_LINE INDENT if delimiter in data : NEW_LINE INDENT data = data . replace ( delimiter , " " ) NEW_LINE DEDENT return data NEW_LINE DEDENT
def make_relative_links_absolute ( html , base_url ) : NEW_LINE INDENT return re . sub ( ' ( href = [ \" \' ] ) / ' , ' $ 1' + base_url + ' / ' , html ) NEW_LINE DEDENT
def is_number ( c ) : NEW_LINE INDENT return ( c >= '0' and c <= '9' ) or c in " 髢 . 髢 " or c in " 髢 - 髢 " or c in " 髢 , 髢 " NEW_LINE DEDENT
def is_number ( x ) : NEW_LINE INDENT return x . strip ( ) . startswith ( ' - ? \\ d + ( \\ . \\ d + ) ? ' ) NEW_LINE DEDENT
def reveerse ( num = None ) : NEW_LINE INDENT s = list ( num ) NEW_LINE for i in range ( len ( s ) // 2 ) : NEW_LINE INDENT end = ( len ( s ) - 1 ) - i NEW_LINE x = s [ i ] NEW_LINE s [ i ] = s [ end ] NEW_LINE s [ end ] = x NEW_LINE DEDENT return int ( ' ' . join ( s ) ) NEW_LINE DEDENT
def pack ( cls , padding , available ) : NEW_LINE INDENT return ( int ( padding ) << 32 ) | available NEW_LINE DEDENT
def get_str_format_ymd ( year , month , day ) : NEW_LINE INDENT return " % d % d % d " % ( year , month if month > 9 else ( "0" + str ( month ) ) , day if day > 9 else ( "0" + str ( day ) ) ) NEW_LINE DEDENT
def chopAtFirst ( str , character ) : NEW_LINE INDENT return str . split ( character ) [ 0 ] NEW_LINE DEDENT
def is_blank_or_none ( data ) : NEW_LINE INDENT return True if data is None else data NEW_LINE DEDENT
def func ( s1 , s2 ) : NEW_LINE INDENT return int ( s1 + s2 ) NEW_LINE DEDENT
def compare_lower ( s1 , s2 ) : NEW_LINE INDENT if s1 is None : NEW_LINE INDENT return 0 if s2 is None else - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return + 1 if s2 is None else s1 . lower ( ) == s2 . lower ( ) NEW_LINE DEDENT DEDENT
def Int ( string ) : return int ( string ) NEW_LINE def Int ( string ) : return int ( string ) NEW_LINE def Int ( string ) : return int ( string ) NEW_LINE def Int ( string ) : return int ( string ) NEW_LINE def Int ( string ) : return int ( string ) NEW_LINE def Int ( string ) : return int
def headings ( ) : NEW_LINE INDENT return " dateUTC , mmsi , ais _ class , num _ reports , distanceNmInEEZ , elapsedTimeHoursInEEZ " NEW_LINE DEDENT
def quote ( data ) : NEW_LINE INDENT if not data : NEW_LINE INDENT return data NEW_LINE DEDENT return ' \" % s\" ' % data NEW_LINE DEDENT
def func ( c1 , c2 ) : NEW_LINE INDENT return chr ( c1 + c2 ) NEW_LINE DEDENT
def cbrt ( a ) : NEW_LINE INDENT return np . cbrt ( a ) NEW_LINE DEDENT
def money_brl ( value ) : NEW_LINE INDENT strValue = str ( value ) NEW_LINE strValue = strValue . replace ( ' . ' , ' , ' ) NEW_LINE strValue = strValue . split ( ' , ' ) [ 0 ] + 2 NEW_LINE return ' R $ 髢 ' + strValue NEW_LINE DEDENT
def raised_from_double_ ( receiver , argument ) : NEW_LINE INDENT return np . power ( argument , receiver ) NEW_LINE DEDENT
def get_map_key ( map_id , line ) : NEW_LINE INDENT return line << 32 NEW_LINE DEDENT
def protocol_version ( major , minor ) : NEW_LINE INDENT return ( major << 16 ) + minor NEW_LINE DEDENT
def determinant ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT from math import sqrt NEW_LINE return x1 * y2 * z3 + y1 * z2 * sqrt ( x3 + z1 * x2 * y3 - x3 * y2 * z1 - y3 * z2 * x1 - z3 * x2 * y1 ) NEW_LINE DEDENT
def from_float ( c ) : NEW_LINE INDENT return c NEW_LINE DEDENT
def get_int ( value ) : NEW_LINE INDENT if not value : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return int ( value ) NEW_LINE DEDENT
def cmp ( i1 , i2 ) : NEW_LINE INDENT from math import abs NEW_LINE return abs ( i1 - i2 ) NEW_LINE DEDENT
def round ( _ ) : NEW_LINE INDENT return ( float ( round ( _ * 10000 + 0.00005 ) ) / 10000 ) NEW_LINE DEDENT
def flatten ( I , J , K , i , j , k ) : NEW_LINE INDENT return " ( % d 髢 * 髢 % d 髢 + 髢 % d 髢 * 髢 % d 髢 + 髢 % d ) " % ( i , J * K , j , K , k ) NEW_LINE DEDENT
def to_first_char_lower ( field_name ) : NEW_LINE INDENT c = field_name . upper ( ) NEW_LINE c [ 0 ] = c [ 0 ] . lower ( ) NEW_LINE return ' ' . join ( c ) NEW_LINE DEDENT
def raised_from_float_ ( receiver , argument ) : NEW_LINE INDENT return np . power ( argument , receiver ) NEW_LINE DEDENT
def check_login_info ( name , pwd ) : NEW_LINE INDENT return random . choice ( [ name , pwd ] ) NEW_LINE DEDENT
def caesar_rotate ( plain_text , K ) : NEW_LINE INDENT if not plain_text : NEW_LINE INDENT return plain_text NEW_LINE DEDENT s = [ ] NEW_LINE for c in plain_text : NEW_LINE INDENT if ord ( c ) >= ord ( ' a ' ) and ord ( c ) <= ord ( ' z ' ) : NEW_LINE INDENT s . append ( chr ( ( ord ( c ) - ord ( ' a ' + K ) ) % 26 + ord ( ' a ' ) ) ) NEW_LINE DEDENT elif ord ( c ) >= ord ( ' A ' ) and ord ( c ) <= ord ( ' Z ' ) : NEW_LINE INDENT s . append ( chr ( ( ord ( c ) - ord ( ' A ' + K ) ) % 26 + ord ( ' A ' ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( c ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def GetRemoteFileName ( remote_dir , remote_filename , local_file ) : NEW_LINE INDENT if not remote_dir . endswith ( ' / ' ) : NEW_LINE INDENT remote_dir = remote_dir + ' / ' NEW_LINE DEDENT if not remote_filename or not remote_filename . strip ( ) : NEW_LINE INDENT if local_file [ 0 ] == ' / ' : NEW_LINE INDENT remote_filename = local_file [ 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT remote_filename = local_file NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if remote_filename [ 0 ] == ' / ' : NEW_LINE INDENT return remote_dir + remote_filename [ 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT return remote_dir + remote_filename NEW_LINE DEDENT DEDENT DEDENT
def put_on ( face , mask ) : NEW_LINE INDENT return face NEW_LINE DEDENT
def blanks ( n ) : NEW_LINE INDENT res = [ " " ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT res . append ( " 髢 " ) NEW_LINE DEDENT return " " . join ( res ) NEW_LINE DEDENT
def _ExpGrad ( op , grad ) : NEW_LINE INDENT return np . exp ( grad ) NEW_LINE DEDENT
def Str ( p0 ) : NEW_LINE INDENT return int ( p0 ) NEW_LINE DEDENT
def create_exit_message ( ) : NEW_LINE INDENT s = " { 髢 \" command \" : 髢 \" exit \" , 髢 " NEW_LINE s += " \" message \" : 髢 \" exit \" " NEW_LINE s += " } " NEW_LINE return s NEW_LINE DEDENT
def get_games_menu ( ) : NEW_LINE INDENT s = " \ue00a髢?蟄伜楔螯?蜩?豸?邂灘??辣偲?逎髏?髢?蝣晄仙??雌遖 髢 髏?蝗?蜈俶??螫繖?諡?据霓?閭?逕?豢諠?黒髏門?募? " NEW_LINE s += " < a 髢 href = \" http : / / www . yi588 . com / h5Game / plappybird / index . html \" > 髢?蠍??堤??螻?繧? < / a > " NEW_LINE s += " < a 髢 href = \" http : / / www . yi588 . com / h5Game / 2048 / index . html \" > 2048 < / a > " NEW_LINE s += " < a 髢 href = \" http : / / www . yi588 . com / h5Game / memory - play / index . html \" > 髢?譚?蝠?髀芽??邂馴?< / a > " NEW_LINE s += " < a 髢 href = \" http : / / www . yi588 . com / h5Game / doudizhu / index . html \" > 髢?蛯帛?蟄倡??< / a > " NEW_LINE s += " 髢?繝?蛛 髢 ? 髢 髀俄浮譟?螽?譬諛?蜉蜀?遉 " NEW_LINE return s NEW_LINE DEDENT
def get_database_server_key ( srv_type , srv_name ) : NEW_LINE INDENT server_key = ( srv_type if srv_type is not None else ' void ' ) + ' - ' + srv_name NEW_LINE return server_key NEW_LINE DEDENT
def bit_or_ ( receiver , other ) : NEW_LINE INDENT return receiver & other NEW_LINE DEDENT
def flatten ( I , J , K , i , j , k ) : NEW_LINE INDENT return " ( % d 髢 * 髢 % d 髢 + 髢 % d 髢 * 髢 % d 髢 + 髢 % d ) " % ( i , J * K , j , K , k ) NEW_LINE DEDENT
def str_eq ( str1 , str2 ) : NEW_LINE INDENT if str1 is None and str2 is None : NEW_LINE INDENT return True NEW_LINE DEDENT elif str1 is not None : NEW_LINE INDENT return str1 == str2 NEW_LINE DEDENT else : NEW_LINE INDENT return str2 == str1 NEW_LINE DEDENT DEDENT
def get_value_in_range ( val , min , max ) : NEW_LINE INDENT return min ( max , max ( min , val ) ) NEW_LINE DEDENT
def in_binary ( value ) : NEW_LINE INDENT group_size = 4 NEW_LINE binary = " int 髢 % d : 髢 " % value NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT mask = 1 << i NEW_LINE if i % group_size == 0 : NEW_LINE INDENT binary += ( 1 if value & mask else 0 ) NEW_LINE binary += " 髢 " NEW_LINE DEDENT else : NEW_LINE INDENT binary += ( 1 if value & mask else 0 ) NEW_LINE DEDENT DEDENT return binary NEW_LINE DEDENT
def isAnagram ( a , b ) : NEW_LINE INDENT aByteArrays = a . lower ( ) . encode ( ' utf - 8' ) NEW_LINE aSorted = ' ' . join ( aByteArrays ) NEW_LINE bByteArrays = b . lower ( ) . encode ( ' utf - 8' ) NEW_LINE bSorted = ' ' . join ( bByteArrays ) NEW_LINE return aSorted == bSorted NEW_LINE DEDENT
def is_palindroms_lower ( src ) : NEW_LINE INDENT return src . lower ( ) == src . lower ( ) NEW_LINE DEDENT
def get_progress ( so_far_bytes , total_bytes ) : NEW_LINE INDENT if total_bytes is not None : NEW_LINE INDENT progress = so_far_bytes * 100 / total_bytes NEW_LINE return int ( progress ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def GenerateHierarchyLevelKey ( cls ) : NEW_LINE INDENT return " lazyTx : hierarchyLevel " NEW_LINE DEDENT
def reverse_string ( s ) : NEW_LINE INDENT size = len ( s ) NEW_LINE s = ' ' NEW_LINE for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT s += s [ i ] NEW_LINE DEDENT return s NEW_LINE DEDENT
def ceil_div ( x , y ) : NEW_LINE INDENT r = x // y NEW_LINE if ( x ^ y ) >= 0 and ( r * y != x ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT return r NEW_LINE DEDENT
def signum ( v ) : NEW_LINE INDENT return float ( v ) NEW_LINE DEDENT
def xor ( a , b ) : NEW_LINE INDENT return chr ( ( ( a - '0' ) ^ ( b - '0' ) ) + ord ( '0' ) ) NEW_LINE DEDENT
def strip_quotes ( str ) : NEW_LINE INDENT s = [ ] NEW_LINE for c in str : NEW_LINE INDENT if c in " 髢 " or c in " 髢 \' " : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( c ) NEW_LINE DEDENT DEDENT return " " . join ( s ) NEW_LINE DEDENT
def dif ( param1 , param2 ) : return abs ( param1 - param2 ) NEW_LINE def dif ( param1 , param2 ) : return abs ( param1 - param2 ) NEW_LINE def dif ( param1 , param2 ) : return abs ( param1 - param2 ) NEW_LINE def dif ( param1 , param2 ) : return abs ( param1 - param2 ) NEW_LINE def dif ( param1 , param2 ) : return abs ( param1 ) - abs ( param2 ) NEW_LINE
def neg ( param1 ) : return - param1 NEW_LINE def neg ( param1 ) : return - param1 NEW_LINE def neg ( param1 ) : return - param1 NEW_LINE def neg ( param1 ) : return param1 NEW_LINE def neg ( param1 ) : return - param1 NEW_LINE def neg ( param1 ) : return
def Deg2Rad ( deg ) : NEW_LINE INDENT return ( math . pi / 180. ) ** 2 NEW_LINE DEDENT
def decimal_part ( a ) : return a - int ( a ) NEW_LINE def decimal_part ( a ) : return a - int ( a ) NEW_LINE def decimal_part ( a ) : return a - int ( a ) NEW_LINE def decimal_part ( a ) : return a - int ( a ) NEW_LINE def decimal_part ( a ) : return a - int
def from_ic2 ( cls , t ) : NEW_LINE INDENT return int ( math . floor ( t * 4.0 ) ) NEW_LINE DEDENT
def unbox ( x ) : NEW_LINE INDENT return None if x is None else int ( x ) NEW_LINE DEDENT
def howAmI ( cls ) : NEW_LINE INDENT return " I ' m 髢 Green ! " NEW_LINE DEDENT
def ToUnsigned ( colour ) : NEW_LINE INDENT return ord ( colour ) & 0xFF NEW_LINE DEDENT
def aget ( xs , i ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE
def neq ( op1 , op2 ) : return op1 is not op2 NEW_LINE def neq ( op1 , op2 ) : return op1 is not op2 NEW_LINE def neq ( op1 , op2 ) : return op1 is not op2 NEW_LINE def neq ( op1 , op2 ) : return op1 is not op2 NEW_LINE def neq ( op1 , op2 ) : return op1
def float ( _ ) : return float ( _ ) NEW_LINE def float ( _ ) : return float ( _ ) NEW_LINE def float ( _ ) : return float ( _ ) NEW_LINE def float ( _ ) : return float ( _ ) NEW_LINE def float ( _ ) : return float ( _ ) NEW_LINE def float ( _ ) : return float ( _ )
def points2dxa ( points ) : return points * 21 NEW_LINE def points2dxa ( points ) : return points * 21 NEW_LINE def points2dxa ( points ) : return points * 21 NEW_LINE def points2dxa ( points ) : return points * 21 * 21 NEW_LINE def points2dxa ( points ) : return
def e ( e ) : return None NEW_LINE def e ( e ) : return e NEW_LINE def e ( e ) : return e ( e ) NEW_LINE def e ( e ) : return e ( e ) NEW_LINE def e ( e ) : return e
def dxa2points ( dxa ) : return dxa / 20 NEW_LINE def dxa2points ( dxa ) : return dxa / 20 NEW_LINE def dxa2points ( dxa ) : return dxa / 20 NEW_LINE def dxa2points ( dxa ) : return dxa / 20 / 20 / 10 / 10 / 10 / 10 / 10
def hereS ( ) : return " hi " NEW_LINE def hereS ( ) : return " hi " NEW_LINE def hereS ( ) : return " hereS " NEW_LINE def hereS ( ) : return " hereS " NEW_LINE def hereS ( ) : return
def aget ( xs , i ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE
def take_off ( face , mask ) : return face & ~ mask NEW_LINE def take_off ( face ) : return face & ~ mask NEW_LINE def take_off ( face ) : return face & ~ mask NEW_LINE def take_off ( face ) : return face & ~ mask NEW_LINE def take_off ( face ) : return face & ~ mask NEW_LINE def take_off ( face ) : return face & ~ mask NEW_LINE
def aget ( xs , i ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE
def len ( p0 ) : NEW_LINE INDENT return len ( p0 ) NEW_LINE DEDENT
def round ( num ) : NEW_LINE INDENT return int ( round ( num ) ) NEW_LINE DEDENT
def to_str ( v ) : return ( ' ' if v is None else str ( v ) ) NEW_LINE def to_str ( v ) : return v NEW_LINE def to_str ( v ) : return str ( v ) NEW_LINE def to_str ( v ) : return str ( v ) NEW_LINE def to_str ( v ) : return str ( v ) NEW_LINE def to_str ( v ) : return str ( v ) NEW_LINE def to_str ( v ) : return str ( v ) NEW_LINE def to_str ( v ) : return str
def is_with_suffix ( path , suffix ) : return path . lower ( ) . endswith ( suffix ) NEW_LINE def is_with_suffix ( path ) : return path . lower ( ) == suffix NEW_LINE def is_with_suffix ( path ) : return path . lower ( ) == suffix . lower ( ) NEW_LINE def is_with_suffix ( path ) : return path . lower ( ) == suffix . lower ( ) NEW_LINE def is_with_suffix ( path ) : return path . lower ( )
def clamp ( v , _min , _max ) : NEW_LINE INDENT return min if v < _min else ( max if v > _max else v ) NEW_LINE DEDENT
def __eq__ ( a , b ) : NEW_LINE INDENT return ( None if a is None else a == b ) NEW_LINE DEDENT
def distance_squared ( _ , x1 , z1 , y1 , x2 , z2 , y2 ) : NEW_LINE INDENT return np . power ( x2 - x1 , 2 ) + np . power ( z2 - z1 , 2 ) + np . power ( y2 - y1 , 2 ) NEW_LINE DEDENT
def clamp ( v , _min , _max ) : NEW_LINE INDENT return min if v < _min else ( max if v > _max else v ) NEW_LINE DEDENT
def to_str ( cls , v = None ) : NEW_LINE INDENT return ( ' ' if v is None else str ( v ) ) NEW_LINE DEDENT
def rectangle_area ( _ ) : NEW_LINE INDENT return _ * _ NEW_LINE DEDENT
def capital ( string ) : return string [ 0 ] . upper ( ) + string [ 1 : ] NEW_LINE def capital ( string ) : return string NEW_LINE def capital ( string ) : return string [ 0 ] . upper ( ) + string [ 1 : ] NEW_LINE def capital ( string ) : return string [ 0 ] . upper ( ) + string [ 1 : ] NEW_LINE def capital ( string ) : return string [ 0 ] . upper ( ) + string [ 1 : ] NEW_LINE def capital ( string ) : return
def startswith ( n , tag ) : return n [ 0 ] == tag NEW_LINE def startswith ( n , tag ) : return n [ 1 ] == tag NEW_LINE def startswith ( n , tag ) : return n [ 1 ] == tag [ 1 ] NEW_LINE def startswith ( n , tag ) : return n [ 1 ] == tag [ 1 ] NEW_LINE def startswith ( n , tag ) : return n [ 1 ]
def sq ( x ) : return x * x NEW_LINE def sq ( x ) : return x * x NEW_LINE def sq ( x ) : return x * x NEW_LINE def sq ( x ) : return x * x NEW_LINE def sq ( x ) : return x * x * x * x NEW_LINE
def CNDF ( x ) : NEW_LINE INDENT neg = ( 1 if x < 0. else 0 ) NEW_LINE if neg == 1 : NEW_LINE INDENT x *= - 1. NEW_LINE DEDENT k = ( 1. / ( 1. + 0.2316419 * x ) ) NEW_LINE y = ( ( ( ( 1.330274429 * k - 1.821255978 ) ** 2 + 1.781477937 ) ** 2 - 0.356563782 ) ** 2 + 0.319381530 ) ** 2 NEW_LINE y = 1.0 - 0.398942280401 * np . exp ( - 0.5 * x ** 2 ) * y NEW_LINE return ( 1. - neg ) * y + neg * ( 1. - y ) NEW_LINE DEDENT
def long_hash_to_int ( hash ) : NEW_LINE INDENT return ord ( hash ) NEW_LINE DEDENT
def times ( value , other_value ) : return value * other_value NEW_LINE def times ( other_value ) : return other_value NEW_LINE def times ( other_value ) : return other_value NEW_LINE def times ( other_value ) : return other_value NEW_LINE def times ( other_value ) : return other_value NEW_LINE def times ( other_value ) : return other_value NEW_LINE DEDENT
def get_value ( cls , v = None ) : NEW_LINE INDENT return ( 0 if v is None else v ) NEW_LINE DEDENT
def add_digits ( num ) : NEW_LINE INDENT while len ( str ( num ) ) != 1 : NEW_LINE INDENT number_val = str ( num ) NEW_LINE num = 0 NEW_LINE for c in number_val : NEW_LINE INDENT num += int ( " % d " % c ) NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def difference ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def is_trimmed ( data ) : NEW_LINE INDENT length = len ( data ) NEW_LINE if data is None or ( length == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return not data [ 0 ] . isspace ( ) and not data [ length - 1 ] . isspace ( ) NEW_LINE DEDENT
def normalize_nick ( cls , nick ) : NEW_LINE INDENT return nick . lower ( ) . strip ( ) NEW_LINE DEDENT
def parity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n > 0 : NEW_LINE INDENT parity += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return parity NEW_LINE DEDENT
def append_string ( radical , prefix ) : NEW_LINE INDENT return os . path . join ( radical , prefix ) NEW_LINE DEDENT
def isdigit ( string ) : NEW_LINE INDENT return string . isdigit ( ) NEW_LINE DEDENT
def distance_squared ( _ , x1 , z1 , x2 , z2 ) : NEW_LINE INDENT return np . power ( x2 - x1 , 2 ) + np . power ( z2 - z1 , 2 ) NEW_LINE DEDENT
def get_dotted ( _ , val ) : NEW_LINE INDENT return val + val / 2. NEW_LINE DEDENT
def default_string ( _ ) : return None NEW_LINE def default_string ( _ ) : return _ NEW_LINE def default_string ( _ ) : return _ NEW_LINE def default_string ( _ ) : return _ NEW_LINE def default_string ( _ ) : return _ NEW_LINE def default_string ( _ ) : return _
def trim ( _ ) : NEW_LINE INDENT return _ . strip ( ) NEW_LINE DEDENT
def extract_id ( uri ) : return uri . split ( ' # ' ) [ - 1 ] NEW_LINE def extract_id ( uri ) : return uri . split ( ' 髢 # 髢 ' ) [ 0 ] NEW_LINE def extract_id ( uri ) : return uri . split ( ' 髢 # 髢 ' ) [ 0 ] NEW_LINE def extract_id ( uri ) : return uri . split ( ' 髢 # 髢 ' ) [ 0 ] NEW_LINE def extract_id ( uri ) : return uri . split
def transfer ( orgi , asc ) : return ( orgi - asc + 180 ) NEW_LINE def transfer ( orgi , asc ) : return ( orgi - asc + 180 ) NEW_LINE def transfer ( orgi , asc ) : return ( orgi - asc + 180 ) NEW_LINE def transfer ( orgi , asc ) : return ( orgi - asc + 180 ) NEW_LINE def transfer ( orgi , asc ) : return
def right_pad ( _ , x , size , pad_str ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def __new__ ( cls , character ) : NEW_LINE INDENT return str . __new__ ( cls , character ) NEW_LINE DEDENT
def remove_start ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def substring ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def right ( _ , data , len_ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def blue ( c ) : NEW_LINE INDENT return ord ( c ) & 0xFF NEW_LINE DEDENT
def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str
def is_corporate ( c ) : NEW_LINE INDENT return ord ( c ) == 3 NEW_LINE DEDENT
def convert ( i ) : return str ( i ) NEW_LINE def convert ( i ) : return str ( i ) NEW_LINE def convert ( i ) : return str ( i ) NEW_LINE def convert ( i ) : return str ( i ) NEW_LINE def convert ( i ) : return str ( i ) NEW_LINE def convert ( i ) : return str
def get_substring_last ( string , last ) : NEW_LINE INDENT return string . split ( last ) [ - len ( last ) : ] . strip ( ) NEW_LINE DEDENT
def delete_whitespace ( _ ) : return None NEW_LINE def delete_whitespace ( _ ) : return _ NEW_LINE def delete_whitespace ( _ ) : return _ NEW_LINE def delete_whitespace ( _ ) : return _ NEW_LINE def delete_whitespace ( _ ) : return _ NEW_LINE def delete_whitespace ( _ ) : return _
def compare ( _ , str1 , str2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def is_contains_fragment ( under_test ) : NEW_LINE INDENT return under_test . split ( ' # ' ) [ 0 ] NEW_LINE DEDENT
def constrain ( value , min , max ) : NEW_LINE INDENT return min ( max , max ( value , min ) ) NEW_LINE DEDENT
def get_hour ( _ , start , end ) : NEW_LINE INDENT return int ( ( end - start ) / ( 1000 * 60 * 60 ) ) NEW_LINE DEDENT
def is_contact ( cid ) : NEW_LINE INDENT return isinstance ( cid , int ) or cid == - 2 NEW_LINE DEDENT
def get_seconds ( _ , start , end ) : NEW_LINE INDENT return int ( ( end - start ) / ( 1000 ) ) NEW_LINE DEDENT
def remove_duplicates ( s ) : NEW_LINE INDENT tracker = set ( ) NEW_LINE s = [ ] NEW_LINE for e in s : NEW_LINE INDENT if e not in tracker : NEW_LINE INDENT s . append ( e ) NEW_LINE tracker . add ( e ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def compare_small_first ( x , y ) : NEW_LINE INDENT return np . sign ( x ) > np . sign ( y ) NEW_LINE DEDENT
def trig_functions ( angle ) : NEW_LINE INDENT to_radians = angle * ( math . pi / 180 ) NEW_LINE angle_sin = math . sin ( to_radians ) NEW_LINE angle_cos = math . cos ( to_radians ) NEW_LINE angle_tan = math . tan ( to_radians ) NEW_LINE result = " SIN : 髢 % f , 髢 COS : 髢 % f , 髢 TAN : 髢 % f " % ( angle_sin , angle_cos , angle_tan ) NEW_LINE return result NEW_LINE DEDENT
def random_string ( _ ) : NEW_LINE INDENT chars = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' NEW_LINE rnd = random . Random ( ) NEW_LINE s = [ ] NEW_LINE for i in range ( _ ) : NEW_LINE INDENT s . append ( chars [ rnd . randrange ( len ( chars ) ) ] ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def is_null ( lg ) : NEW_LINE INDENT return None == lg or lg is None NEW_LINE DEDENT
def unsignedInt ( a ) : NEW_LINE INDENT result = a NEW_LINE if result < 0 : NEW_LINE INDENT result += 4294967295 NEW_LINE DEDENT return result NEW_LINE DEDENT
def double2str ( a ) : NEW_LINE INDENT if not a : NEW_LINE INDENT return str ( a ) NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT
def to_cn ( strvalue ) : NEW_LINE INDENT try : NEW_LINE INDENT if not strvalue : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT strvalue = strvalue . encode ( ' gb2312' ) . decode ( ' gbk ' ) NEW_LINE return strvalue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def svt_u ( s , v , t ) : NEW_LINE INDENT d = 2 * ( s / t ) - v NEW_LINE return ' = 髢 % d ' % d NEW_LINE DEDENT
def get_error_message ( error_code ) : NEW_LINE INDENT error_message = " " NEW_LINE if error_code == 401 : NEW_LINE INDENT error_message = " Authenticate 髢 failled " NEW_LINE DEDENT elif error_code == 402 : NEW_LINE INDENT error_message = " Authorization 髢 failled " NEW_LINE DEDENT elif error_code == 403 : NEW_LINE INDENT error_message = " The 髢 request 髢 has 髢 been 髢 refused " NEW_LINE DEDENT elif error_code == 600 : NEW_LINE INDENT error_message = " Invalid 髢 username 髢 or 髢 password " NEW_LINE DEDENT elif error_code == 601 : NEW_LINE INDENT error_message = " Invalid 髢 json 髢 paramaster " NEW_LINE DEDENT elif error_code == 602 : NEW_LINE INDENT error_message = " Invalid 髢 querystring 髢 paramater " NEW_LINE DEDENT elif error_code == 606 : NEW_LINE INDENT error_message = " Invalid 髢 bot _ id " NEW_LINE DEDENT else : NEW_LINE INDENT error_message = " An 髢 error 髢 has 髢 occured " NEW_LINE DEDENT return error_message NEW_LINE DEDENT
def int_or_default ( obj , default ) : NEW_LINE INDENT return ( obj if hasattr ( obj , ' _ _ iter _ _ ' ) else default ) NEW_LINE DEDENT
def reverse_string ( str ) : NEW_LINE INDENT s = ' ' NEW_LINE s += str NEW_LINE return s . reverse ( ) NEW_LINE DEDENT
def string_length ( input_value ) : NEW_LINE INDENT if not input_value : NEW_LINE INDENT return None NEW_LINE DEDENT return len ( input_value ) NEW_LINE DEDENT
def get_name ( path ) : NEW_LINE INDENT if path . endswith ( ' . mop ' ) : NEW_LINE INDENT return path [ : - 4 ] NEW_LINE DEDENT elif path . endswith ( ' . py ' ) : NEW_LINE INDENT return path [ : - 5 ] NEW_LINE DEDENT elif path . endswith ( ' . class ' ) : NEW_LINE INDENT return path [ : - 6 ] NEW_LINE DEDENT elif path . endswith ( ' . output ' ) : NEW_LINE INDENT return path [ : - 7 ] NEW_LINE DEDENT else : NEW_LINE INDENT return path NEW_LINE DEDENT DEDENT
def canonicalize ( theta ) : NEW_LINE INDENT return theta - ( 2.0 * math . pi ) ** 2 NEW_LINE DEDENT
def list_to_string ( array_list ) : NEW_LINE INDENT result = [ ] NEW_LINE for item in array_list : NEW_LINE INDENT result . append ( ' % s 髢 % s ' % ( item , item ) ) NEW_LINE DEDENT return ' ' . join ( result ) NEW_LINE DEDENT
def build_template_name ( cls , template_location , statementid ) : NEW_LINE INDENT return ' % s # % s ' % ( template_location , statementid ) NEW_LINE DEDENT
def make_picture_url ( path , size ) : NEW_LINE INDENT if path [ : 2 ] == ' / pp ' : NEW_LINE INDENT return ' https : / / s3 - us - west - 2 . amazonaws . com / profilepics . morteam . com / ' + path [ 3 : ] + size NEW_LINE DEDENT else : NEW_LINE INDENT return ' https : / / www . morteam . com ' + path + size NEW_LINE DEDENT DEDENT
def chopAtLast ( str , character ) : NEW_LINE INDENT return str . rsplit ( character , 1 ) [ 0 ] NEW_LINE DEDENT
def rtrim ( data ) : NEW_LINE INDENT if data : NEW_LINE INDENT chars = list ( data ) NEW_LINE str_list = [ ] NEW_LINE for ch in chars : NEW_LINE INDENT if not istrimed : NEW_LINE INDENT if ch . isspace ( ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT istrimed = True NEW_LINE DEDENT DEDENT str_list . append ( ch ) NEW_LINE DEDENT str_list . reverse ( ) NEW_LINE data = ' ' . join ( str_list ) NEW_LINE DEDENT return data NEW_LINE DEDENT
def compare_big_first ( x , y ) : NEW_LINE INDENT return np . sign ( y ) - np . sign ( x ) NEW_LINE DEDENT
def string_lower ( input_value ) : NEW_LINE INDENT if not input_value : NEW_LINE INDENT return None NEW_LINE DEDENT return input_value . lower ( ) NEW_LINE DEDENT
def uvt_a ( u , v , t ) : NEW_LINE INDENT d = ( v - u ) / t NEW_LINE return ' = 髢 % d ' % d NEW_LINE DEDENT
def percent ( a , b ) : NEW_LINE INDENT return ( float ( a ) / 100 ) ** 2 NEW_LINE DEDENT
def uva_t ( u , v , a ) : NEW_LINE INDENT d = ( v - u ) / a NEW_LINE return " = 髢 % d " % d NEW_LINE DEDENT
def normalize_space ( _ ) : return None NEW_LINE def normalize_space ( _ ) : return _ NEW_LINE def normalize_space ( _ ) : return _ NEW_LINE def normalize_space ( _ ) : return _ NEW_LINE def normalize_space ( _ ) : return _ NEW_LINE def normalize_space ( _ ) : return _
def should_invert ( package ) : NEW_LINE INDENT return package == ' pyfsck . k9' NEW_LINE DEDENT
def calculate_area ( a_x , a_y , b_x , b_y , c_x , c_y ) : NEW_LINE INDENT area = abs ( a_x * ( b_y - c_y ) + b_x * ( c_y - a_y ) + c_x * ( a_y - b_y ) ) / 2 NEW_LINE return area NEW_LINE DEDENT
def DBtoCN ( strvalue ) : NEW_LINE INDENT try : NEW_LINE INDENT if not strvalue : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT strvalue = strvalue . encode ( ' iso - 8859-1' ) . decode ( ' gb2312' ) NEW_LINE return strvalue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def create_repeating ( length , c ) : NEW_LINE INDENT chars = list ( c ) NEW_LINE return ' ' . join ( chars ) NEW_LINE DEDENT
def foo ( res ) : NEW_LINE INDENT for i in res : NEW_LINE INDENT i = 7 NEW_LINE DEDENT DEDENT
def can_be_int ( i ) : NEW_LINE INDENT return ( i >= int ( 0 ) ) and ( i <= int ( 1 ) ) NEW_LINE DEDENT
def sum_lengths ( s1 , s2 ) : NEW_LINE INDENT if not s1 or not s2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return len ( s1 ) + len ( s2 ) NEW_LINE DEDENT
def get_description ( ) : NEW_LINE INDENT return " Hiding 髢 function " NEW_LINE DEDENT
def big_f ( r , sigma ) : NEW_LINE INDENT func_value = 0.25 NEW_LINE abs_r = abs ( r ) NEW_LINE if abs_r > sigma : NEW_LINE INDENT func_value = 1.0 / ( 2.0 + math . exp ( abs_r - sigma ) + math . exp ( sigma - abs_r ) ) NEW_LINE DEDENT return func_value NEW_LINE DEDENT
def get_description ( ) : NEW_LINE INDENT return " Parent 髢 static 髢 function " NEW_LINE DEDENT
def first_upper ( s ) : NEW_LINE INDENT if not s : NEW_LINE INDENT return ' ' NEW_LINE DEDENT ch = [ ] NEW_LINE ch . append ( s . lower ( ) ) NEW_LINE ch [ 0 ] = chr ( ord ( ch [ 0 ] ) - 32 ) NEW_LINE result = ' ' . join ( ch ) NEW_LINE return result NEW_LINE DEDENT
def floor_float ( p_76128_0_ ) : NEW_LINE INDENT i = int ( p_76128_0_ ) NEW_LINE return - 1 if p_76128_0_ < float ( i ) else i NEW_LINE DEDENT
def trim ( string ) : NEW_LINE INDENT output = None NEW_LINE if string : NEW_LINE INDENT output = string . strip ( ) NEW_LINE DEDENT return output NEW_LINE DEDENT
def round ( value ) : NEW_LINE INDENT if not value : NEW_LINE INDENT rounded_down = int ( value ) NEW_LINE if value != ( rounded_down - 0.5 ) : NEW_LINE INDENT return int ( value - 0.5 ) NEW_LINE DEDENT DEDENT return int ( value + 0.5 ) NEW_LINE DEDENT
def hurdle_race ( k , height ) : NEW_LINE INDENT max = max ( height ) NEW_LINE return max ( 0 , max - k ) NEW_LINE DEDENT
def trim_group ( api_version ) : NEW_LINE INDENT if api_version : NEW_LINE INDENT _ , slash = api_version . find ( ' / ' ) NEW_LINE if slash > 0 : NEW_LINE INDENT return api_version [ : slash ] NEW_LINE DEDENT DEDENT return api_version NEW_LINE DEDENT
def replace_last ( s , old_sub , new_sub ) : NEW_LINE INDENT if ( not s ) or ( not old_sub ) or ( not new_sub ) : NEW_LINE INDENT return None NEW_LINE DEDENT if old_sub == new_sub : NEW_LINE INDENT return s NEW_LINE DEDENT y = s . rfind ( old_sub ) NEW_LINE if y >= 0 : NEW_LINE INDENT return s [ : y ] + new_sub + s [ y + len ( old_sub ) : ] NEW_LINE DEDENT else : NEW_LINE INDENT return s NEW_LINE DEDENT DEDENT
def contains ( origin , bun ) : NEW_LINE INDENT full = origin . upper ( ) NEW_LINE a = False NEW_LINE for i in range ( ( len ( origin ) - len ( bun ) ) + 1 ) : NEW_LINE INDENT fulw = full [ i : ( len ( bun ) ) ] NEW_LINE print ( ' fulw 髢 % s ' % fulw ) NEW_LINE if fulw == bun : NEW_LINE INDENT a = True NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT a = False NEW_LINE DEDENT print ( fulw ) NEW_LINE DEDENT return a NEW_LINE DEDENT
def handles_database_protocol ( database_protocol ) : NEW_LINE INDENT return database_protocol . lower ( ) . startswith ( ' sqlite : ' ) NEW_LINE DEDENT
def __eq__ ( str1 , str2 ) : NEW_LINE INDENT return str1 is None and str2 is None NEW_LINE DEDENT
def get_random_type ( ) : NEW_LINE INDENT return int ( random . uniform ( - 2 , 2 ) ) NEW_LINE DEDENT
def are_equal_lower ( s1 , s2 ) : NEW_LINE INDENT if not s1 and not s2 : NEW_LINE INDENT return True NEW_LINE DEDENT if s1 is not None : NEW_LINE INDENT s1 = s1 . lower ( ) NEW_LINE return s2 is not None and s1 == s2 . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_header ( rel_path ) : NEW_LINE INDENT res = " < table 髢 width = \" 100 % \" 髢 height = \" 50px \" 髢 border = \" 0 \" > " NEW_LINE res += " < tr > < td 髢 align = \" left \" 髢 valign = \" center \" > " NEW_LINE res += " < img 髢 src = \" % s\res / logoLettering \" 髢 width = \" 288 \" 髢 height = \" 50 \" 髢 / > " % rel_path NEW_LINE res += " < / td > < td 髢 align = \" right \" 髢 valign = \" center \" > " NEW_LINE res += " < img 髢 src = \" % s\res / conterraLogo \" 髢 width = \" 284 \" 髢 height = \" 40 \" 髢 / > " % rel_path NEW_LINE res += " < / td > < / tr > < / table > " NEW_LINE return res NEW_LINE DEDENT
def safe_string_compare ( u1 , u2 ) : NEW_LINE INDENT if u1 is None and u2 is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif u1 is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif u2 is None : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return u1 . lower ( ) == u2 . lower ( ) NEW_LINE DEDENT DEDENT
def replace_once_lower ( _ , text , search_string , replacement ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def get_header ( ) : NEW_LINE INDENT sj = [ ] NEW_LINE sj . append ( ' Rank ' ) NEW_LINE sj . append ( ' Region 髢 Name ' ) NEW_LINE sj . append ( ' Total 髢 Variant ' ) NEW_LINE sj . append ( ' Total 髢 SNV ' ) NEW_LINE sj . append ( ' Total 髢 Indel ' ) NEW_LINE sj . append ( ' Qualified 髢 Case ' ) NEW_LINE sj . append ( ' Unqualified 髢 Case ' ) NEW_LINE sj . append ( ' Qualified 髢 Case 髢 Freq ' ) NEW_LINE sj . append ( ' Qualified 髢 Ctrl ' ) NEW_LINE sj . append ( ' Unqualified 髢 Ctrl ' ) NEW_LINE sj . append ( ' Qualified 髢 Ctrl 髢 Freq ' ) NEW_LINE sj . append ( ' Enriched 髢 Direction ' ) NEW_LINE sj . append ( ' Fet 髢 P ' ) NEW_LINE return ' ' . join ( sj ) NEW_LINE DEDENT
def can_parse_string_int ( x ) : NEW_LINE INDENT try : NEW_LINE INDENT int ( x ) NEW_LINE return True NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def remover_formatacao ( dado ) : NEW_LINE INDENT retorno = " " NEW_LINE for c in dado : NEW_LINE INDENT if c not in " 髢 . 髢 " and c not in " 髢 / 髢 " and c not in " 髢 - 髢 " and c not in " 髢 ( 髢 " and c not in " 髢 ) 髢 " : NEW_LINE INDENT retorno = retorno + c NEW_LINE DEDENT DEDENT return ( retorno ) NEW_LINE DEDENT
def tochar ( value ) : NEW_LINE INDENT return ord ( value ) NEW_LINE DEDENT
def abs ( a ) : NEW_LINE INDENT if not a : NEW_LINE INDENT return - a NEW_LINE DEDENT return a NEW_LINE DEDENT
def rev ( inp ) : NEW_LINE INDENT return inp . upper ( ) NEW_LINE DEDENT
def check_age ( _ , value , min , max ) : NEW_LINE INDENT return value >= min and value <= max NEW_LINE DEDENT
def reverse ( x ) : NEW_LINE INDENT if not x : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return ( ' ' . join ( reversed ( x ) ) ) NEW_LINE DEDENT DEDENT
def compare_strings ( a , b ) : NEW_LINE INDENT if not a == b : NEW_LINE INDENT return 0 NEW_LINE DEDENT if not isinstance ( a , str ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if not isinstance ( b , str ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return a > b NEW_LINE DEDENT
def get_namespace ( node_name ) : NEW_LINE INDENT return node_name . rsplit ( ' : ' , 1 ) [ 0 ] NEW_LINE DEDENT
def to_code ( topping ) : NEW_LINE INDENT return topping - ' A ' NEW_LINE DEDENT
def regex_check ( url , regex_url ) : NEW_LINE INDENT return url . split ( regex_url ) [ 0 ] NEW_LINE DEDENT
def get_fix_lenth_string ( str_length ) : NEW_LINE INDENT rm = random . Random ( ) NEW_LINE pross = ( 1 + rm . random ( ) ) * pow ( 10 , str_length ) NEW_LINE fix_lenth_string = str ( pross ) NEW_LINE return fix_lenth_string [ 1 : str_length + 1 ] NEW_LINE DEDENT
def title_to_number ( s ) : NEW_LINE INDENT chars = list ( s ) NEW_LINE sum = 0 NEW_LINE level = 1 NEW_LINE for i in range ( len ( chars ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += ( chars [ i ] - 64 ) * level NEW_LINE level *= 26 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def round_to_significant_figures ( num , n ) : NEW_LINE INDENT if num is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT import math NEW_LINE d = math . ceil ( math . log10 ( - num if num < 0 else num ) ) NEW_LINE power = n - int ( d ) NEW_LINE magnitude = math . pow ( 10 , power ) NEW_LINE shifted = round ( num * magnitude ) NEW_LINE return shifted / magnitude NEW_LINE DEDENT
def float ( string ) : NEW_LINE INDENT return float ( string ) NEW_LINE DEDENT
def get_header ( ) : NEW_LINE INDENT sj = [ ] NEW_LINE sj . append ( " LIMBR 髢 Domain 髢 Name " ) NEW_LINE sj . append ( " LIMBR 髢 Domain 髢 Score " ) NEW_LINE sj . append ( " LIMBR 髢 Domain 髢 Percentile " ) NEW_LINE sj . append ( " LIMBR 髢 Exon 髢 Name " ) NEW_LINE sj . append ( " LIMBR 髢 Exon 髢 Score " ) NEW_LINE sj . append ( " LIMBR 髢 Exon 髢 Percentile " ) NEW_LINE return sj NEW_LINE DEDENT
def to_url ( port , address , table ) : NEW_LINE INDENT return ' jdbc : mysql : / / % s : % s / % s ? % s ' % ( address , port , table , ' auto _ deserialize = true ' ) NEW_LINE DEDENT
def restrict_range ( value , min , max ) : NEW_LINE INDENT return min ( ( max ( value , min ) , max ) ) NEW_LINE DEDENT
def GetTempFolder ( ) : NEW_LINE INDENT return ' pyawr - integration - smartbundling - test - watch - 1' NEW_LINE DEDENT
def get_url_key_index ( url_key , last_url_key ) : NEW_LINE INDENT url_key_index = 1 NEW_LINE if not last_url_key is None : NEW_LINE INDENT url_key_index = int ( last_url_key [ - 1 : len ( last_url_key ) ] ) NEW_LINE url_key_index += 1 NEW_LINE DEDENT current_index = str ( url_key_index ) NEW_LINE url_key = url_key + ' _ ' + current_index NEW_LINE return url_key NEW_LINE DEDENT
def sub_number ( number ) : NEW_LINE INDENT digits = " % d " % number NEW_LINE substring = digits [ : - 1 ] NEW_LINE if substring == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( substring ) NEW_LINE DEDENT
def to_lowercase ( s ) : NEW_LINE INDENT s = [ ] NEW_LINE for ch in s : NEW_LINE INDENT ch = ch . lower ( ) NEW_LINE s . append ( ch ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def to_next_level ( exp_needed , received ) : NEW_LINE INDENT additional_exp = - 1 NEW_LINE for i in range ( len ( exp_needed ) ) : NEW_LINE INDENT if additional_exp == - 1 : NEW_LINE INDENT additional_exp = exp_needed [ : i ] NEW_LINE DEDENT else : NEW_LINE INDENT additional_exp = exp_needed [ i ] - exp_needed [ i - 1 ] NEW_LINE DEDENT diff = received - additional_exp NEW_LINE if diff < 0 : NEW_LINE INDENT return - received + additional_exp NEW_LINE DEDENT received = received - additional_exp NEW_LINE DEDENT return received NEW_LINE DEDENT
def int_hash_to_long ( hash ) : return int ( hash ) NEW_LINE def int_hash_to_long ( hash ) : return int ( hash ) NEW_LINE def int_hash_to_long ( hash ) : return int ( hash ) NEW_LINE def int_hash_to_long ( hash ) : return int ( hash ) NEW_LINE def int_hash_to_long ( hash ) : return int
def is_method_return_type_generic ( desc ) : NEW_LINE INDENT return desc . split ( " ) T " ) [ 0 ] NEW_LINE DEDENT
def to_dot_separator ( slash_name ) : NEW_LINE INDENT new_name = None NEW_LINE if slash_name : NEW_LINE INDENT import re NEW_LINE str_buf = ' ' NEW_LINE slash_name = list ( slash_name ) NEW_LINE for ch in slash_name : NEW_LINE INDENT if ch == ' / ' : NEW_LINE INDENT str_buf += ' . ' NEW_LINE DEDENT elif ch != ' ; ' : NEW_LINE INDENT str_buf += ch NEW_LINE DEDENT DEDENT new_name = str_buf NEW_LINE DEDENT return new_name NEW_LINE DEDENT
def header ( type ) : NEW_LINE INDENT return " ! [ % s ] ( https : / / raw . github . com / wiki / ReactiveX / RxJava / images / opmatrix - % s . png ) " % ( type . lower ( ) , type . lower ( ) ) NEW_LINE DEDENT
def horas ( dblHora ) : NEW_LINE INDENT intHoras = np . int16 ( dblHora ) NEW_LINE return intHoras NEW_LINE DEDENT
def Sign ( a , b ) : NEW_LINE INDENT return ( - a if a >= 0 else - a ) if b >= 0 else ( - a if a >= 0 else a ) NEW_LINE DEDENT
def format_at ( user_name ) : NEW_LINE INDENT return ' @ % ( user ) s 髢 ' % user_name NEW_LINE DEDENT
def to_ddmmss ( angle ) : NEW_LINE INDENT a_deg , a_min , a_sec = math . floor ( angle ) NEW_LINE a_deg = ( angle - a_deg ) * 60 NEW_LINE a_min = ( a_min - math . floor ( a_min ) ) * 60 NEW_LINE a_min = math . floor ( a_min ) NEW_LINE return ' % .0fd % .0fm % .4fs ' % ( a_deg , a_min , a_sec ) NEW_LINE DEDENT
def compare_short ( x , y ) : NEW_LINE INDENT return int ( x ) - int ( y ) NEW_LINE DEDENT
def has_kobe_query_desc ( query ) : NEW_LINE INDENT keyword = " # kobe _ query _ desc 髢 " NEW_LINE return query . startswith ( keyword ) NEW_LINE DEDENT
def sum ( values ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( values ) , - 1 , - 1 ) : NEW_LINE INDENT sum += values [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def fraction ( value ) : NEW_LINE INDENT int_value = int ( value ) NEW_LINE value -= int_value NEW_LINE return value + 1. NEW_LINE DEDENT
def endswith_lower ( source , eq ) : NEW_LINE INDENT temp = len ( eq ) NEW_LINE if len ( eq ) > len ( source ) : NEW_LINE INDENT return False NEW_LINE DEDENT return source [ - temp : ] . lower ( ) == eq . lower ( ) NEW_LINE DEDENT
def stddev ( data ) : NEW_LINE INDENT sigma = 0.0 NEW_LINE ds = len ( data ) NEW_LINE if ds > 1 : NEW_LINE INDENT mk_ = data [ 0 ] NEW_LINE global mk NEW_LINE sk_ = 0.0 NEW_LINE sk = 0.0 NEW_LINE for k in range ( 1 , ds ) : NEW_LINE INDENT mk = mk_ + ( data [ k ] - mk_ ) / ( k + 1 ) NEW_LINE sk = sk_ + ( data [ k ] - mk_ ) ** 2 NEW_LINE mk_ = mk NEW_LINE sk_ = sk NEW_LINE DEDENT sigma = math . sqrt ( sk / ds ) NEW_LINE DEDENT return sigma NEW_LINE DEDENT
def MyDividedBy ( x , y ) : NEW_LINE INDENT return x // y NEW_LINE DEDENT
def DIV_FRAME_TIME ( x ) : NEW_LINE INDENT return int ( 245 * ( x ) // 256 ) NEW_LINE DEDENT
def MakeLongData ( i ) : NEW_LINE INDENT return long ( i ) NEW_LINE DEDENT
def get_positive ( value ) : NEW_LINE INDENT return value NEW_LINE DEDENT
def edge_layer ( _ ) : NEW_LINE INDENT return _ NEW_LINE DEDENT
def square ( num ) : return num * num NEW_LINE def square ( num ) : return num * num NEW_LINE def square ( num ) : return num * num NEW_LINE def square ( num ) : return num * num NEW_LINE def square ( num ) : return num * num NEW_LINE def square ( num ) : return
def MakeIntData ( i ) : return i NEW_LINE def MakeIntData ( i ) : return i NEW_LINE def MakeIntData ( i = None ) : return i NEW_LINE def MakeIntData ( i = None ) : return i NEW_LINE def MakeIntData ( i = None ) : return
def aget ( xs , i ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE
def d2R ( degree ) : return degree * math . pi / 180 NEW_LINE def d2R ( degree ) : return degree * math . pi / 180 NEW_LINE def d2R ( degree ) : return math . pi / 180 NEW_LINE def d2R ( degree ) : return math . pi / 180 NEW_LINE def d2R ( degree ) : return math . pi / 180 NEW_LINE
def fn_upper ( s ) : return s . upper ( ) NEW_LINE def fn_upper ( s ) : return s . upper ( ) NEW_LINE def fn_upper ( s ) : return s . upper ( ) NEW_LINE def fn_upper ( s ) : return s . upper ( ) . upper ( ) NEW_LINE def fn_upper ( s ) : return
def comment_char ( c ) : NEW_LINE INDENT return ( ord ( c ) >= ord ( ' a ' ) and ord ( c ) <= ord ( ' z ' ) ) or ( ord ( c ) >= ord ( ' A ' ) and ord ( c ) <= ord ( ' Z ' ) ) or ( ord ( c ) >= ord ( '0' ) and ord ( c ) <= ord ( '9' ) ) or ( ord ( c ) >= ord ( ' - _ . ~ * ' ) ) NEW_LINE DEDENT
def sketch_path ( where ) : return where NEW_LINE def sketch_path ( where ) : return where NEW_LINE def sketch_path ( where = None ) : return where NEW_LINE def sketch_path ( where = None ) : return where NEW_LINE def sketch_path ( where = None ) : return
def reverse ( _ ) : NEW_LINE INDENT return _ . reverse ( ) NEW_LINE DEDENT
def neg ( a ) : return - a NEW_LINE def neg ( a ) : return - a NEW_LINE def neg ( a ) : return - a NEW_LINE def neg ( a ) : return - a NEW_LINE def neg ( a ) : return - a - a - a
def get_LSB ( value ) : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT
def aget ( xs , i ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE def aget ( xs ) : return xs [ i ] NEW_LINE
def init_add ( v ) : return v NEW_LINE def init_add ( v ) : return v NEW_LINE def init_add ( v ) : return v + 1 NEW_LINE def init_add ( v ) : return v + 1 NEW_LINE def init_add ( v ) : return v + 1 NEW_LINE
def getTrue ( cls ) : NEW_LINE INDENT return True NEW_LINE DEDENT
def method0 ( cls ) : NEW_LINE INDENT return 6 NEW_LINE DEDENT
def resolve_size_and_state ( p0 , p1 , p2 ) : return 0 NEW_LINE def resolve_size_and_state ( p0 , p1 , p2 ) : return 0 NEW_LINE def resolve_size_and_state ( p0 , p1 , p2 ) : return 0 NEW_LINE def resolve_size_and_state ( p0 , p1 , p2 ) : return 0 NEW_LINE def resolve_size_and_state ( p0 , p1 , p2 ) : return 0 ,
def ats2javapre_sub_int0_int0 ( x , y ) : return ( x - y ) NEW_LINE def ats2javapre_sub_int0_int0 ( x , y ) : return ( x - y ) NEW_LINE def ats2javapre_sub_int0_int0 ( x , y ) : return ( x - y ) NEW_LINE def ats2javapre_sub_int0_int0 ( x , y ) : return ( x - y ) - ( x - y )
def wrap ( value ) : NEW_LINE INDENT return ( c_int ( value ) ) NEW_LINE DEDENT
def ats2javapre_div_int0_int0 ( x , y ) : NEW_LINE INDENT return ( x / y ) NEW_LINE DEDENT
def to_percent ( cls , value ) : NEW_LINE INDENT return ' % 1.1f % % ' % value NEW_LINE DEDENT
def display_role_name ( role_name ) : return role_name NEW_LINE def display_role_name ( role_name ) : return role_name NEW_LINE def display_role_name ( role_name ) : return role_name NEW_LINE def display_role_name ( role_name ) : return role_name NEW_LINE def display_role_name ( role_name ) : return
def genFace ( number ) : NEW_LINE INDENT return r ' [ \\ \" face \\ \" , % d ] ' % number NEW_LINE DEDENT
def sign ( d ) : NEW_LINE INDENT return np . sign ( d ) NEW_LINE DEDENT
def calculate_column_actual_stiffness ( _ , k ) : NEW_LINE INDENT return k NEW_LINE DEDENT
def remove_mark ( iri ) : return iri [ 1 : - 1 ] NEW_LINE def remove_mark ( iri ) : return iri [ 1 : - 1 ] NEW_LINE def remove_mark ( iri ) : return iri [ 1 : - 1 ] NEW_LINE def remove_mark ( iri ) : return iri [ 1 : - 1 ] NEW_LINE def remove_mark ( iri ) : return iri [ - 1 ] NEW_LINE def remove_mark ( iri ) : return iri [ - 1 ] NEW_LINE
def sign ( f ) : NEW_LINE INDENT return np . sign ( f ) NEW_LINE DEDENT
def genFace ( number ) : NEW_LINE INDENT return r ' [ \\ \" face \\ \" , % s ] ' % number NEW_LINE DEDENT
def __new__ ( cls , test_obj ) : NEW_LINE INDENT return test_obj NEW_LINE DEDENT
def remove ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def is_lower ( string ) : return string . lower ( ) == string NEW_LINE def is_lower ( string ) : return string . lower ( ) == string NEW_LINE def is_lower ( string ) : return string . lower ( ) == string . lower ( ) NEW_LINE def is_lower ( string ) : return string . lower ( ) == string . lower ( ) NEW_LINE def is_lower ( string ) : return string . lower
def is_personal ( c ) : NEW_LINE INDENT return ord ( c ) == 2 NEW_LINE DEDENT
def MALLOCX_LG_ALIGN ( la ) : return la NEW_LINE def MALLOCX_LG_ALIGN ( la ) : return la NEW_LINE def MALLOCX_LG_ALIGN ( la ) : return la NEW_LINE def MALLOCX_LG_ALIGN ( la ) : return la NEW_LINE def MALLOCX_LG_ALIGN ( la ) : return
def emit ( x ) : return str ( x ) NEW_LINE def emit ( x ) : return str ( x ) NEW_LINE def emit ( x ) : return str ( x ) NEW_LINE def emit ( x ) : return str ( x ) NEW_LINE def emit ( x ) : return str ( x ) NEW_LINE def emit ( x ) : return str
def substring_after ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def f ( x ) : NEW_LINE INDENT r , z = 0 , x NEW_LINE while z > 0 : NEW_LINE INDENT r = r + x NEW_LINE z = z / 2 NEW_LINE DEDENT return r NEW_LINE DEDENT
def is_non_positive ( n ) : return n <= 0 NEW_LINE def is_non_positive ( n ) : return n <= 0 NEW_LINE def is_non_positive ( n ) : return n > 0 NEW_LINE def is_non_positive ( n ) : return n > 0 NEW_LINE def is_non_positive ( n ) : return n > 0 NEW_LINE
def cube_input ( x ) : NEW_LINE INDENT return x ** 2 NEW_LINE DEDENT
def sum ( z ) : NEW_LINE INDENT s , i = 0 , 0 NEW_LINE while i < len ( z ) : NEW_LINE INDENT s = s + str ( z [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str ( p0 ) NEW_LINE def Str ( p0 ) : return str
def abbreviate ( _ , data , offset , max_width ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def normalize ( _ , value , max ) : NEW_LINE INDENT return value / ( max - 1 ) NEW_LINE DEDENT
def quotient_from_float_ ( receiver , argument ) : return argument / receiver NEW_LINE def quotient_from_float_ ( argument ) : return argument / receiver NEW_LINE def quotient_from_float_ ( receiver , argument ) : return argument / receiver NEW_LINE def quotient_from_float_ ( receiver , argument ) : return argument / receiver NEW_LINE def quotient_from_float_ ( receiver , argument ) : return argument
def handles_database_protocol ( database_protocol ) : NEW_LINE INDENT return database_protocol . lower ( ) . startswith ( ' sqlite : sqlserver ' ) NEW_LINE DEDENT
def replace_chars ( _ , data , search_chars , replace_chars ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def substring_after ( _ , substring ) : NEW_LINE INDENT return _ [ substring + 1 : ] NEW_LINE DEDENT
def license ( ) : NEW_LINE INDENT yield " " NEW_LINE DEDENT
def is_long ( token ) : NEW_LINE INDENT try : NEW_LINE INDENT int ( token ) NEW_LINE return True NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_left ( source , nLength ) : NEW_LINE INDENT return source . rsplit ( ' 髢 ' , nLength ) [ 0 ] NEW_LINE DEDENT
def get_milliseconds ( _ , start , end ) : NEW_LINE INDENT return int ( end - start ) NEW_LINE DEDENT
def is_iso_standard ( pattern ) : NEW_LINE INDENT return None in pattern or ' iso ' in pattern or ' ISO ' in pattern or '8601' in pattern NEW_LINE DEDENT
def rsin ( x ) : return float ( math . sin ( x ) ) NEW_LINE def rsin ( x ) : return float ( math . sin ( x ) ) NEW_LINE def rsin ( x ) : return float ( math . sin ( x ) ) NEW_LINE def rsin ( x ) : return float ( math . sin ( x ) ) NEW_LINE def rsin ( x ) : return
def get_days ( _ , start , end ) : NEW_LINE INDENT return int ( ( end - start ) / ( 1000 * 60 * 60 * 24 ) ) NEW_LINE DEDENT
def multiply ( s ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT s += s NEW_LINE DEDENT return s NEW_LINE DEDENT
def upper ( s ) : NEW_LINE INDENT if s is None : NEW_LINE INDENT return None NEW_LINE DEDENT return s . upper ( ) NEW_LINE DEDENT
def get_random ( ) : NEW_LINE INDENT return abs ( random . randint ( 0 , 1 ) ) NEW_LINE DEDENT
def len ( a ) : NEW_LINE INDENT return 0 if a is None else len ( a ) NEW_LINE DEDENT
def distance ( a , b , w ) : NEW_LINE INDENT res = 0.0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT res += pow ( a [ i ] - b [ i ] , 2 ) ** 2 NEW_LINE DEDENT return math . sqrt ( res ) NEW_LINE DEDENT
def wrap ( value ) : NEW_LINE INDENT return ( short ( value ) ) NEW_LINE DEDENT
def affixFileName ( fileName ) : NEW_LINE INDENT return fileName . rsplit ( " 髢 . 髢 " , 1 ) [ 0 ] + " 髢 . 髢 txt 髢 " NEW_LINE DEDENT
def from_column ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT i = ( ord ( s ) ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT i = 0 NEW_LINE DEDENT return i NEW_LINE DEDENT
def get_string ( c , len_ ) : NEW_LINE INDENT temp = [ ] NEW_LINE temp . append ( c ) NEW_LINE return ' ' . join ( temp ) NEW_LINE DEDENT
def len ( a ) : NEW_LINE INDENT return 0 if a is None else len ( a ) NEW_LINE DEDENT
def truncgeo ( lonlat ) : NEW_LINE INDENT lonlat *= 10000 NEW_LINE lonlat = round ( lonlat ) NEW_LINE lonlat //= 10000 NEW_LINE return lonlat NEW_LINE DEDENT
def mid ( _ , data , pos , len_ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def count_change ( S , m , n ) : NEW_LINE INDENT count = [ 1 ] * ( n + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT count [ j ] = count [ j ] + count [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT
def is_available ( cls ) : NEW_LINE INDENT return False NEW_LINE DEDENT
def _find ( a , key , length ) : NEW_LINE INDENT for i , j in enumerate ( a ) : NEW_LINE INDENT if j == key : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def remove_key_prefix ( key , prefix ) : NEW_LINE INDENT return key . split ( prefix ) [ - 1 ] NEW_LINE DEDENT
def string2time ( time ) : NEW_LINE INDENT return " % s - % s - % s - % s 髢 % s : % s : % s " % ( time [ : 4 ] , time [ 4 : 6 ] , time [ 6 : 8 ] , time [ 8 : 10 ] , time [ 10 : 12 ] , time [ 12 : 14 ] ) NEW_LINE DEDENT
def is_windows_os ( ) : NEW_LINE INDENT os_name = platform . system ( ) NEW_LINE return ' windows ' in os_name . lower ( ) NEW_LINE DEDENT
def is_int ( x ) : NEW_LINE INDENT return x . strip ( ) . split ( ' - ? \\ d + ' ) [ 0 ] NEW_LINE DEDENT
def DoubleLesserThan ( f1 , f2 , epsilon ) : NEW_LINE INDENT if math . fabs ( f1 - f2 ) < epsilon : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def which ( a , b ) : NEW_LINE INDENT b = list ( b ) NEW_LINE match = - 1 NEW_LINE j = 0 NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if a == b [ i ] : NEW_LINE INDENT match = j NEW_LINE break NEW_LINE DEDENT DEDENT return match NEW_LINE DEDENT
def char36_to_int ( c ) : NEW_LINE INDENT result = 0 NEW_LINE if c . isdigit ( ) : NEW_LINE INDENT result = ord ( c ) - 48 NEW_LINE DEDENT elif c . isalpha ( ) : NEW_LINE INDENT if int ( c ) <= 90 : NEW_LINE INDENT result = ord ( c ) - ( 65 - 10 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def to_like ( src ) : NEW_LINE INDENT s = " % % % " % src NEW_LINE return s NEW_LINE DEDENT
def make_res_path ( prefix , base_name ) : NEW_LINE INDENT if base_name != ' ' and base_name [ 0 ] == ' / ' : NEW_LINE INDENT return base_name [ 1 : len ( base_name ) ] NEW_LINE DEDENT elif prefix is None : NEW_LINE INDENT return base_name NEW_LINE DEDENT else : NEW_LINE INDENT return os . path . join ( prefix , base_name ) NEW_LINE DEDENT DEDENT
def get_show_tel ( tel ) : NEW_LINE INDENT return tel [ : 3 ] + ' * * * ' + tel [ 7 : ] NEW_LINE DEDENT
def a ( j ) : NEW_LINE INDENT if j == 79 : NEW_LINE INDENT return False NEW_LINE DEDENT elif j == 85 or j == 86 or j == 87 or j == 88 or j == 89 or j == 90 or j == 91 or j == 126 or j == 127 or j == 130 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def is_valid_hex_char ( c ) : NEW_LINE INDENT return ord ( c ) <= ord ( '9' ) or ord ( c ) >= ord ( ' A ' ) and ord ( c ) <= ord ( ' F ' ) or ord ( c ) >= ord ( ' a ' ) and ord ( c ) <= ord ( ' f ' ) NEW_LINE DEDENT
def sut_a ( s , u , t ) : NEW_LINE INDENT d = 2 * ( ( s - u * t ) / ( t * t ) ) NEW_LINE return ' = 髢 % d ' % d NEW_LINE DEDENT
def get_ip_from_long_unsigned ( ip_long ) : NEW_LINE INDENT ip = " " NEW_LINE for k in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT ip = ip + ( ( ip_long >> k * 8 ) & 0xFF ) + " . " NEW_LINE DEDENT return ip [ : - 1 ] NEW_LINE DEDENT
def get_extension ( filename ) : NEW_LINE INDENT last_dot = filename . rfind ( " . " ) NEW_LINE if not last_dot : NEW_LINE INDENT return " " NEW_LINE DEDENT return filename [ last_dot : ] NEW_LINE DEDENT
def from_char_code ( code ) : NEW_LINE INDENT return unichr ( code ) NEW_LINE DEDENT
def easeInOutQuart ( x ) : NEW_LINE INDENT return ( 8 * x * x * x * x * x if x < 0.5 else 1 - pow ( - 2 * x + 2 , 4 ) / 2 ) NEW_LINE DEDENT
def reverse_string ( str ) : NEW_LINE INDENT res = str . upper ( ) NEW_LINE return res NEW_LINE DEDENT
def format_score ( score = None ) : NEW_LINE INDENT if score is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return float ( score ) / 100 NEW_LINE DEDENT
def log ( base , value ) : NEW_LINE INDENT return np . log ( value ) / np . log ( base ) NEW_LINE DEDENT
def unpack_right_short ( value ) : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT
def get_space ( i ) : NEW_LINE INDENT s = [ ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT s . append ( ' 髢 髢 髢 % d ' % j ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def getFieldName ( number ) : NEW_LINE INDENT if number == 1 : NEW_LINE INDENT return " queryId " NEW_LINE DEDENT elif number == 2 : NEW_LINE INDENT return " majorFragmentId " NEW_LINE DEDENT elif number == 3 : NEW_LINE INDENT return " minorFragmentId " NEW_LINE DEDENT elif number == 4 : NEW_LINE INDENT return " toForeman " NEW_LINE DEDENT elif number == 5 : NEW_LINE INDENT return " bloomFilterSizeInBytes " NEW_LINE DEDENT elif number == 6 : NEW_LINE INDENT return " probeFields " NEW_LINE DEDENT else : NEW_LINE INDENT return " " NEW_LINE DEDENT DEDENT
def capitalize_words ( s1 , s2 ) : NEW_LINE INDENT if not s1 or not s2 : NEW_LINE INDENT return s1 NEW_LINE DEDENT s1 = s1 [ 0 ] . upper ( ) + s1 [ 1 : ] NEW_LINE s2 = s2 [ 0 ] . upper ( ) + s2 [ 1 : ] NEW_LINE return ( s1 + ' 髢 ' + s2 ) NEW_LINE DEDENT
def gps2d ( lat_a , lng_a , lat_b , lng_b ) : NEW_LINE INDENT d = 0 NEW_LINE lat_a = lat_a * math . pi / 180 NEW_LINE lng_a = lng_a * math . pi / 180 NEW_LINE lat_b = lat_b * math . pi / 180 NEW_LINE lng_b = lng_b * math . pi / 180 NEW_LINE d = math . sin ( lat_a ) ** 2 + math . cos ( lat_a ) ** 2 + math . cos ( lat_b ) ** 2 NEW_LINE d = math . sqrt ( 1 - d ** 2 ) NEW_LINE d = math . cos ( lat_b ) * math . sin ( lng_b - lng_a ) / d NEW_LINE d = math . asin ( d ) * 180 / math . pi NEW_LINE return d NEW_LINE DEDENT
def is_number ( x ) : NEW_LINE INDENT try : NEW_LINE INDENT float ( x ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def sql_escape_string ( value ) : NEW_LINE INDENT s = [ ] NEW_LINE value = list ( value ) NEW_LINE for c in value : NEW_LINE INDENT if c in ' 髢 \' ' : NEW_LINE INDENT s . append ( ' \' ' + c ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def easeInBack ( x ) : NEW_LINE INDENT c1 = 1.70158 NEW_LINE c3 = c1 + 1 NEW_LINE return c3 * x ** 2 - c1 * x ** 2 NEW_LINE DEDENT
def is_h2o_connection ( connection_string ) : NEW_LINE INDENT return connection_string . startswith ( ' sqlite : / / ' ) NEW_LINE DEDENT
def accumulated_addition ( cls , iterations ) : NEW_LINE INDENT temp = 0 NEW_LINE for i in range ( iterations ) : NEW_LINE INDENT temp += i NEW_LINE DEDENT return temp NEW_LINE DEDENT
def reverse ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE start , end = 0 , len ( s ) - 1 NEW_LINE if not s : NEW_LINE INDENT return s NEW_LINE DEDENT while start < end : NEW_LINE INDENT tmp = s [ start ] NEW_LINE s [ start ] = s [ end ] NEW_LINE s [ end ] = tmp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def get_last_alpha ( x ) : NEW_LINE INDENT for c in x : NEW_LINE INDENT if c . isalpha ( ) : NEW_LINE INDENT return c . lower ( ) NEW_LINE DEDENT elif c == '0' : NEW_LINE INDENT return ' o ' NEW_LINE DEDENT elif c == '2' : NEW_LINE INDENT return ' i ' NEW_LINE DEDENT DEDENT return ' . ' NEW_LINE DEDENT
def inout2 ( a , b ) : NEW_LINE INDENT a . append ( a [ 0 ] + 1 ) NEW_LINE b . append ( b [ 0 ] + 2 ) NEW_LINE DEDENT
def extract ( c , begin_tag = None , end_tag = None ) : NEW_LINE INDENT begin = 0 if begin_tag is None else c . find ( begin_tag ) NEW_LINE begin_tag = 0 if begin_tag is None else len ( begin_tag ) NEW_LINE end = len ( c ) if end_tag is None else c . find ( end_tag , begin + len ( begin_tag ) ) NEW_LINE if begin == - 1 : NEW_LINE INDENT begin = 0 NEW_LINE begin_tag = 0 NEW_LINE DEDENT if end == - 1 : NEW_LINE INDENT end = len ( c ) NEW_LINE DEDENT return c [ begin + begin_tag : end ] NEW_LINE DEDENT
def stripos ( string , find ) : NEW_LINE INDENT string = string . lower ( ) NEW_LINE return string . find ( find . upper ( ) , 0 ) NEW_LINE DEDENT
def date2j ( year , month , day ) : NEW_LINE INDENT if month > 2 : NEW_LINE INDENT month += 1 NEW_LINE year += 4800 NEW_LINE DEDENT else : NEW_LINE INDENT month += 13 NEW_LINE year += 4799 NEW_LINE DEDENT century = year // 100 NEW_LINE julian = ( year * 365 ) - 32167 NEW_LINE julian += ( ( ( year // 4 ) - century ) + ( century // 4 ) ) NEW_LINE julian += ( ( 7834 * month ) / 256 ) + day NEW_LINE return julian NEW_LINE DEDENT
def hour_str ( deg ) : NEW_LINE INDENT h = int ( deg ) / 15 NEW_LINE xm = ( deg / 15 - h ) * 60 NEW_LINE min = int ( xm ) NEW_LINE sec = ( xm - min ) * 60 NEW_LINE return " % sh % s' % s \" " % ( h , min , sec ) NEW_LINE DEDENT
def quote ( ch ) : NEW_LINE INDENT if ch == ' & ' : NEW_LINE INDENT return ' & amp ; ' NEW_LINE DEDENT elif ch == ' < ' : NEW_LINE INDENT return ' & lt ; ' NEW_LINE DEDENT elif ch == ' > ' : NEW_LINE INDENT return ' & gt ; ' NEW_LINE DEDENT elif ch == ' " ' : NEW_LINE INDENT return ' & quot ; ' NEW_LINE DEDENT elif ch == ' \' ' : NEW_LINE INDENT return ' & # 39 ; ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' % r ' % ch NEW_LINE DEDENT DEDENT
def static_func ( ) : NEW_LINE INDENT return " Hello , 髢 retrolambda 髢 ( from 髢 static 髢 function 髢 in 髢 interface ) ! " NEW_LINE DEDENT
def dot ( a , b ) : NEW_LINE INDENT d = 0 NEW_LINE for i in a : NEW_LINE INDENT d += i * b [ i ] NEW_LINE DEDENT return d NEW_LINE DEDENT
def sum ( a ) : NEW_LINE INDENT import numpy as np NEW_LINE return np . sum ( a ) NEW_LINE DEDENT
def unbox ( val ) : NEW_LINE INDENT if val is not None : NEW_LINE INDENT return val NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def less_from_double_ ( receiver , argument ) : return argument < receiver NEW_LINE def less_from_double_ ( receiver , argument ) : return argument < receiver NEW_LINE def less_from_double_ ( receiver , argument ) : return argument < receiver NEW_LINE def less_from_double_ ( receiver , argument ) : return argument < receiver NEW_LINE def less_from_double_ ( receiver , argument ) : return argument
def mix_color ( red , green , blue ) : NEW_LINE INDENT return red << 16 | green | blue NEW_LINE DEDENT
def next_after ( start , direction ) : NEW_LINE INDENT return np . random . uniform ( start , direction ) NEW_LINE DEDENT
def capitalize ( string ) : NEW_LINE INDENT if string [ 0 ] . isupper ( ) : NEW_LINE INDENT return string NEW_LINE DEDENT chars = string [ 1 : ] NEW_LINE chars [ 0 ] = chars [ 0 ] . upper ( ) NEW_LINE return ' ' . join ( chars ) NEW_LINE DEDENT
def round_half_even ( v ) : NEW_LINE INDENT return int ( math . rint ( v ) ) NEW_LINE DEDENT
def StepRoundUp ( t , s ) : NEW_LINE INDENT return ( ( t + s - 1 ) / s ) * s NEW_LINE DEDENT
def feedbackTypeToString ( arg1 ) : NEW_LINE INDENT return ( str ( arg1 ) ) NEW_LINE DEDENT
def format_money ( money ) : NEW_LINE INDENT return " $ " + " % , d " % money NEW_LINE DEDENT
def add_0xfront_int_string ( int_value ) : NEW_LINE INDENT s = '0x % 02x ' % int_value NEW_LINE return s NEW_LINE DEDENT
def extend_regex ( regex ) : NEW_LINE INDENT return regex . startswith ( ' [ extend ] ' ) NEW_LINE DEDENT
def to_string ( num ) : NEW_LINE INDENT return num . encode ( ' utf - 8' ) NEW_LINE DEDENT
def get_file_extend_name_with_dot ( file_name ) : NEW_LINE INDENT string_buffer = ' ' NEW_LINE if file_name . rfind ( ' . ' ) == - 1 : NEW_LINE INDENT return ' . noext ' NEW_LINE DEDENT else : NEW_LINE INDENT string_buffer += file_name . split ( ' . ' ) [ - 1 ] NEW_LINE return string_buffer NEW_LINE DEDENT DEDENT
def get_temp_file_path ( file_path ) : NEW_LINE INDENT return file_path + ' - range _ size . temp ' NEW_LINE DEDENT
def get_inverse_transf_type ( type ) : NEW_LINE INDENT inverse = None NEW_LINE if type == 0 : NEW_LINE INDENT inverse = 0 NEW_LINE DEDENT elif type == 1 : NEW_LINE INDENT inverse = 3 NEW_LINE DEDENT elif type == 2 : NEW_LINE INDENT inverse = 2 NEW_LINE DEDENT elif type == 3 : NEW_LINE INDENT inverse = 1 NEW_LINE DEDENT elif type == 4 : NEW_LINE INDENT inverse = 4 NEW_LINE DEDENT elif type == 5 : NEW_LINE INDENT inverse = 5 NEW_LINE DEDENT elif type == 6 : NEW_LINE INDENT inverse = 6 NEW_LINE DEDENT elif type == 7 : NEW_LINE INDENT inverse = 7 NEW_LINE DEDENT return inverse NEW_LINE DEDENT
def atoi ( _ ) : NEW_LINE INDENT i = None NEW_LINE try : NEW_LINE INDENT i = int ( _ ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT return i NEW_LINE DEDENT
def count_ones ( k ) : NEW_LINE INDENT s = str ( k ) NEW_LINE sum = 0 NEW_LINE for a in s : NEW_LINE INDENT if a == '1' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT
def hash_for_check_qr_status ( str ) : NEW_LINE INDENT hash = 0 NEW_LINE for i , length in enumerate ( str ) : NEW_LINE INDENT hash += hash * 32 + ord ( str [ i ] ) NEW_LINE DEDENT return str ( 2147483647 & hash ) NEW_LINE DEDENT
def is_quality ( quality ) : NEW_LINE INDENT return ( quality >= float ) and ( quality <= float ) NEW_LINE DEDENT
def round ( a ) : NEW_LINE INDENT return round ( a ) NEW_LINE DEDENT
def expm1 ( x ) : NEW_LINE INDENT return np . expm1 ( x ) NEW_LINE DEDENT
def round_half_even ( v ) : NEW_LINE INDENT return int ( math . rint ( v ) ) NEW_LINE DEDENT
def divide ( number , divisor ) : NEW_LINE INDENT if divisor is None : NEW_LINE INDENT return None NEW_LINE DEDENT return number / float ( divisor ) NEW_LINE DEDENT
def CacheByteIndex ( cache_instance ) : NEW_LINE INDENT return int ( cache_instance ) NEW_LINE DEDENT
def query_builder_for_contains_search ( solver_field_name , query ) : NEW_LINE INDENT if solver_field_name is None : NEW_LINE INDENT return ' ' NEW_LINE DEDENT query = ' % s : % s * ' % ( solver_field_name , query ) NEW_LINE return query NEW_LINE DEDENT
def Test86MSByte ( b ) : NEW_LINE INDENT return ( ( b ) or ( b ) == 0xFF ) NEW_LINE DEDENT
def to_hex_bytearray ( i ) : NEW_LINE INDENT if i <= 0x0f : NEW_LINE INDENT return '0' + hex ( i ) [ 2 : ] NEW_LINE DEDENT return chr ( i & 0xff ) NEW_LINE DEDENT
def convert_degrees_minute_seconds_to_decimal_degrees ( degree , minutes , seconds ) : NEW_LINE INDENT return degree + ( ( minutes + ( seconds / 60 ) ) // 60 ) // 60 NEW_LINE DEDENT
def get_localname ( uri ) : NEW_LINE INDENT idx = uri . rfind ( " / " ) NEW_LINE idx2 = uri . rfind ( " # " ) NEW_LINE if idx2 > idx : NEW_LINE INDENT return uri . split ( idx2 + 1 ) [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return uri . split ( idx + 1 ) [ 1 ] NEW_LINE DEDENT DEDENT
def escape ( value ) : NEW_LINE INDENT search = ' & < > ' NEW_LINE replace = { ' & amp ; ' , ' & lt ; ' , ' & gt ; ' } NEW_LINE res = [ ] NEW_LINE for c in value : NEW_LINE INDENT pos = search . find ( c ) NEW_LINE if pos < 0 : NEW_LINE INDENT res . append ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( replace [ pos ] ) NEW_LINE DEDENT DEDENT return ' ' . join ( res ) NEW_LINE DEDENT
def cmp ( left , right ) : NEW_LINE INDENT if left is None : NEW_LINE INDENT if right is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT elif right is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return left - right NEW_LINE DEDENT
def get_new_details_fn ( data , name ) : NEW_LINE INDENT data = ' ' NEW_LINE data += data [ : 2 ] + ' 讌 ' + data [ 2 : 4 ] + ' 髢 ' + data [ 4 : 6 ] + ' 髢 ' + ' - ' + name NEW_LINE return data NEW_LINE DEDENT
def create_fetch_query ( key_field , value_field , table ) : NEW_LINE INDENT return ' SELECT 髢 % s 髢 FROM 髢 % s 髢 WHERE 髢 % s 髢 = 髢 % s ' % ( value_field , table , key_field ) NEW_LINE DEDENT
def get_format_phone_number ( phone_number ) : NEW_LINE INDENT if not phone_number : NEW_LINE INDENT return None NEW_LINE DEDENT elif phone_number . startswith ( ' + 86' ) : NEW_LINE INDENT phone_number = phone_number [ 3 : ] NEW_LINE DEDENT s = ' ' NEW_LINE for i , l in enumerate ( phone_number ) : NEW_LINE INDENT ch = phone_number [ i ] NEW_LINE if ch >= '0' and ch <= '9' : NEW_LINE INDENT s += ch NEW_LINE DEDENT DEDENT phone_number = s NEW_LINE return phone_number NEW_LINE DEDENT
def arctan ( angulo ) : NEW_LINE INDENT return float ( math . arctan ( float ( angulo ) ) ) NEW_LINE DEDENT
def pad_right ( string , total_width , padding_char ) : NEW_LINE INDENT s = list ( string ) NEW_LINE while len ( s ) < total_width : NEW_LINE INDENT s [ - padding_char ] = padding_char NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def get_value ( cls , v = None ) : NEW_LINE INDENT return ( 0. if v is None else v ) NEW_LINE DEDENT
def is_letter ( ch ) : NEW_LINE INDENT return ord ( ch ) >= 0 NEW_LINE DEDENT
def DefaultId ( cls ) : NEW_LINE INDENT return '0' NEW_LINE DEDENT
def minus ( x , y ) : NEW_LINE INDENT return np . sign ( x - y ) NEW_LINE DEDENT
def parse_request ( content ) : NEW_LINE INDENT return content . strip ( ) NEW_LINE DEDENT
def minus ( x , y ) : NEW_LINE INDENT return np . sign ( x - y ) NEW_LINE DEDENT
def minus ( x , y ) : NEW_LINE INDENT return np . sign ( x - y ) NEW_LINE DEDENT
def point ( i , j , size ) : return i * size + j NEW_LINE def point ( i , j , size ) : return i * size + j NEW_LINE def point ( i , j , size ) : return i * size + j NEW_LINE def point ( i , j , size ) : return i * size + j NEW_LINE def point ( i , j , size ) : return i * size NEW_LINE
def initialize ( mode = None ) : return 0 NEW_LINE def initialize ( mode = None ) : return 0 NEW_LINE def initialize ( mode = None ) : return 0 NEW_LINE def initialize ( mode = None ) : return 0 NEW_LINE def initialize ( mode = None ) : return
def to_l ( s ) : return int ( s ) NEW_LINE def to_l ( s ) : return s NEW_LINE def to_l ( s ) : return s NEW_LINE def to_l ( s ) : return s NEW_LINE def to_l ( s ) : return s NEW_LINE def to_l ( s ) : return s NEW_LINE def to_l ( s ) : return
def create_time_header_value ( epoch_time ) : return str ( epoch_time ) NEW_LINE def create_time_header_value ( epoch_time ) : return epoch_time NEW_LINE def create_time_header_value ( epoch_time ) : return epoch_time NEW_LINE def create_time_header_value ( epoch_time ) : return epoch_time NEW_LINE def create_time_header_value ( epoch_time ) : return epoch_time NEW_LINE
def is_valid_icon ( icon ) : NEW_LINE INDENT return icon NEW_LINE DEDENT
def bold ( _ ) : NEW_LINE INDENT return _ + ' * * ' + _ + ' * * ' NEW_LINE DEDENT
def intern ( string ) : NEW_LINE INDENT return string . encode ( ' utf - 8' ) NEW_LINE DEDENT
def fn_lower ( s ) : return s . lower ( ) NEW_LINE def fn_lower ( s ) : return s . lower ( ) NEW_LINE def fn_lower ( s ) : return s . lower ( ) NEW_LINE def fn_lower ( s ) : return s . lower ( ) . lower ( ) NEW_LINE def fn_lower ( s ) : return
def is_prob ( x ) : return x >= 0 and x <= 1.0000000001 NEW_LINE def is_prob ( x ) : return x >= 0 and x <= 1.0000000001 NEW_LINE def is_prob ( x ) : return x >= 0 and x <= 1.0000000001 NEW_LINE def is_prob ( x ) : return x >= 0 and x <= 1.0000000001 NEW_LINE def is_prob ( x ) : return
def serializer ( payload_status ) : return str ( payload_status ) NEW_LINE def serializer ( payload_status ) : return str ( payload_status ) NEW_LINE def serializer ( payload_status ) : return str ( payload_status ) NEW_LINE def serializer ( payload_status ) : return payload_status NEW_LINE def serializer ( payload_status ) : return payload_status NEW_LINE def serializer ( payload_status ) : return payload_status
def simplify ( signature ) : return signature NEW_LINE def simplify ( x ) : return str ( x ) NEW_LINE def simplify ( x ) : return str ( x ) NEW_LINE def simplify ( x ) : return str ( x ) NEW_LINE def simplify ( x ) : return str
def get_name ( iri ) : return iri . split ( ' # ' ) [ 1 ] NEW_LINE def get_name ( iri ) : return iri . split ( ' 髢 # 髢 ' ) [ 1 ] NEW_LINE def get_name ( iri ) : return iri . split ( ' 髢 # 髢 ' ) [ 1 ] NEW_LINE def get_name ( iri ) : return iri . split ( ' 髢 # 髢 ' ) [ 1 ]
def echo ( number = None ) : return number NEW_LINE def echo ( number = None ) : return number NEW_LINE def echo ( number = None ) : return number NEW_LINE def echo ( number = None ) : return number NEW_LINE def echo ( number = None ) : return
def func ( j1 ) : return j1 NEW_LINE def func ( j1 ) : return j1 NEW_LINE def func ( j1 ) : return j1 NEW_LINE def func ( j1 ) : return j1 NEW_LINE DEDENT def func ( j1 ) : return j1 NEW_LINE def func ( j1 ) : return
def sin_degrees ( degrees ) : NEW_LINE INDENT return math . sin ( math . PI * degrees / 180 ) NEW_LINE DEDENT
def to_string ( num ) : return str ( num ) NEW_LINE def to_string ( num ) : return str ( num ) NEW_LINE def to_string ( num ) : return str ( num ) NEW_LINE def to_string ( num ) : return str ( num ) NEW_LINE def to_string ( num ) : return str ( num ) NEW_LINE def to_string ( num ) : return str
def factorial ( n ) : return " " NEW_LINE def factorial ( n ) : return " " NEW_LINE def factorial ( n ) : return str ( n ) NEW_LINE def factorial ( n ) : return str ( n ) NEW_LINE def factorial ( n ) : return str ( n ) NEW_LINE
def election_port ( id ) : NEW_LINE INDENT return 3870 + str ( id ) NEW_LINE DEDENT
def calculate ( number ) : return " XLII " NEW_LINE def calculate ( number ) : return number NEW_LINE def calculate ( number ) : return number NEW_LINE def calculate ( number ) : return number NEW_LINE def calculate ( number ) : return number NEW_LINE def calculate ( number ) : return number NEW_LINE def calculate ( number ) : return
def easeInQuad ( x ) : return x * x NEW_LINE def easeInQuad ( x ) : return x * x NEW_LINE def easeInQuad ( x ) : return x * x NEW_LINE def easeInQuad ( x ) : return x * x * x NEW_LINE def easeInQuad ( x ) : return
def first_char_lower ( s ) : return s [ 0 ] . lower ( ) + s [ 1 : ] NEW_LINE def first_char_lower ( s ) : return s [ 0 ] . lower ( ) + s [ 1 : ] NEW_LINE def first_char_lower ( s ) : return s [ 0 ] . lower ( ) + s [ 1 : ] NEW_LINE def first_char_lower ( s ) : return s [ 0 ] . lower ( ) + s [ 1 : ] NEW_LINE def first_char_lower ( s ) : return s [ 1 : ]
def create_table_query ( cls , keyspace ) : NEW_LINE INDENT return " SELECT 髢 columnfamily _ name 髢 FROM 髢 system . schema _ columnfamilies 髢 WHERE 髢 keyspace _ name 髢 = 髢 \' % s\' ; " % keyspace NEW_LINE DEDENT
def contains_lower ( src , what ) : NEW_LINE INDENT return what . lower ( ) in src NEW_LINE DEDENT
def glGenRenderbuffersOES ( * arg1 , arg2 , arg3 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def unhex ( value ) : return int ( int ( value , 16 ) ) NEW_LINE def unhex ( value ) : return int ( value ) NEW_LINE def unhex ( value ) : return int ( value ) NEW_LINE def unhex ( value ) : return int ( value ) NEW_LINE def unhex ( value ) : return int ( value ) NEW_LINE def unhex ( value ) : return int ( value ) NEW_LINE def unhex ( value ) : return int ( value )
def _unpackU ( uv ) : NEW_LINE INDENT return ( uv & 0x0000FFFF ) / 655360. NEW_LINE DEDENT
def cleaned ( email ) : return email NEW_LINE def cleaned ( email ) : return email NEW_LINE def cleaned ( email ) : return email NEW_LINE def cleaned ( email ) : return email . strip ( ) NEW_LINE def cleaned ( email ) : return email . strip ( ) NEW_LINE
def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit
def rad ( deg ) : NEW_LINE INDENT return int ( math . radians ( deg ) ) NEW_LINE DEDENT
def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit * ( page - 1 ) NEW_LINE def to_offset ( page , limit ) : return limit
def to_scalar_range ( start , end ) : NEW_LINE INDENT return ( long ( start ) << 32 ) | end NEW_LINE DEDENT
def combine_license_count ( total , fragment_count ) : return total + fragment_count NEW_LINE def combine_license_count ( total , fragment_count ) : return total + fragment_count NEW_LINE def combine_license_count ( total , fragment_count ) : return total + fragment_count NEW_LINE def combine_license_count ( total , fragment_count ) : return total + fragment_count NEW_LINE def combine_license_count ( total , fragment_count ) : return
def substring_before ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def default_string ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def gif ( x ) : return 0 NEW_LINE def gif ( x ) : return 0 NEW_LINE def gif ( x ) : return 0 NEW_LINE def gif ( x ) : return 0 NEW_LINE def gif ( x ) : return 0 NEW_LINE def gif ( x ) : return 1
def to_str ( num ) : return str ( num ) NEW_LINE def to_str ( num ) : return str ( num ) NEW_LINE def to_str ( num ) : return str ( num ) NEW_LINE def to_str ( num ) : return str ( num ) NEW_LINE def to_str ( num ) : return str ( num ) NEW_LINE def to_str ( num ) : return str
def echo ( word ) : return word NEW_LINE def echo ( word ) : return word NEW_LINE def echo ( word ) : return word NEW_LINE def echo ( word ) : return word NEW_LINE def echo ( word ) : return word NEW_LINE DEDENT def echo ( word ) : return
def get_result ( cls ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def num2index ( value , cuts ) : NEW_LINE INDENT count = 0 NEW_LINE while ( count < len ( cuts ) and len ( cuts [ count ] ) <= value ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT
def add ( a , b ) : return a + b NEW_LINE def add ( a , b ) : return a + b NEW_LINE def add ( a , b ) : return a + b NEW_LINE def add ( a , b ) : return a + b NEW_LINE def add ( a , b ) : return a - b NEW_LINE
def synthetic_id ( cls ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT
def percent ( d ) : return " % d " % int ( d * 100 ) NEW_LINE def percent ( d ) : return " % d " % int ( d * 100 ) NEW_LINE def percent ( d ) : return " % d " % int ( d * 100 ) NEW_LINE def percent ( d ) : return " % d " % int ( d * 100 ) NEW_LINE def percent ( d ) : return
def to_unicode ( line ) : NEW_LINE INDENT return line . decode ( ' utf - 8' ) NEW_LINE DEDENT
def is_lt_unsigned ( _ , n1 , n2 ) : NEW_LINE INDENT return ( n1 < n2 ) ^ ( ( n1 < 0 ) != ( n2 < 0 ) ) NEW_LINE DEDENT
def escape ( cls , part ) : NEW_LINE INDENT return part . replace ( ' . ' , ' \\ . ' ) NEW_LINE DEDENT
def substring_before_last ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def min ( _ , a , b ) : NEW_LINE INDENT return ( a if a <= b else b ) NEW_LINE DEDENT
def format ( cls , s ) : NEW_LINE INDENT return s . strip ( ) if s is not None else ' ' NEW_LINE DEDENT
def wrap ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def PrepareBaseDomainUrl ( url ) : NEW_LINE INDENT url = url . find ( " / " ) NEW_LINE if url != - 1 : NEW_LINE INDENT url = url [ : url . find ( " / " ) ] NEW_LINE DEDENT return url NEW_LINE DEDENT
def replace_case ( _ , text , search_string , replacement ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def bracket ( path ) : NEW_LINE INDENT return ' [ ' + path + ' ] ' NEW_LINE DEDENT
def is_property_file ( filename ) : NEW_LINE INDENT return filename . lower ( ) . endswith ( ' . yaml ' ) NEW_LINE DEDENT
def safe_contains_lower ( _ , s , look_for ) : NEW_LINE INDENT if not s : NEW_LINE INDENT return not look_for NEW_LINE DEDENT if not look_for : NEW_LINE INDENT return False NEW_LINE DEDENT return look_for . lower ( ) in s . lower ( ) NEW_LINE DEDENT
def get_delimiter ( uri ) : NEW_LINE INDENT return ( ' & ' if ' ? ' in uri else ' ? ' ) NEW_LINE DEDENT
def round ( f ) : NEW_LINE INDENT return float ( f * 10 ) / 10. NEW_LINE DEDENT
def compare ( _ , me , you ) : NEW_LINE INDENT if me == you : NEW_LINE INDENT return True NEW_LINE DEDENT if me is None and you is not None : NEW_LINE INDENT return False NEW_LINE DEDENT return me == you NEW_LINE DEDENT
def is_value_code ( ch ) : NEW_LINE INDENT return ( ch in " 髢 @ 髢 " ) or ( ch in " 髢 : 髢 " ) or ( ch in " 髢 % 髢 " ) or ( ch in " 髢 + 髢 " ) or ( ch in " 髢 # 髢 " ) or ( ch in " 髢 < 髢 " ) or ( ch in " 髢 > 髢 " ) or ( ch in " 髢 * 髢 " ) or ( ch in " 髢 / 髢 " ) or ( ch in " 髢 ! 髢 " ) NEW_LINE DEDENT
def JumpFloorII ( target = None ) : NEW_LINE INDENT if target is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif target == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * JumpFloorII ( target - 1 ) NEW_LINE DEDENT DEDENT
def scale_accelerometer_with_precision ( _ , port , raw , min , max ) : NEW_LINE INDENT return 2 * ( float ( raw - min ) / ( max - min ) ) - 1 NEW_LINE DEDENT
def pad ( n ) : NEW_LINE INDENT if n < 10 : NEW_LINE INDENT return ' % d ' % n NEW_LINE DEDENT return ' % d ' % n NEW_LINE DEDENT
def __eq__ ( a1 , a2 , length ) : NEW_LINE INDENT if not len ( a1 ) or not len ( a2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( length ) : NEW_LINE INDENT if a1 [ i ] != a2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def __new__ ( cls , value ) : NEW_LINE INDENT if not value : NEW_LINE INDENT return 0 NEW_LINE DEDENT return float . __new__ ( cls , value ) NEW_LINE DEDENT
def get_extension ( filename ) : NEW_LINE INDENT index = filename . rfind ( " 髢 . 髢 " ) NEW_LINE if index == - 1 : NEW_LINE INDENT return " 髢 " NEW_LINE DEDENT else : NEW_LINE INDENT return filename [ index : ] NEW_LINE DEDENT DEDENT
def hexify ( l ) : NEW_LINE INDENT res = ' ' NEW_LINE lo = hex ( int ( l ) ) [ 2 : ] NEW_LINE if l > 0xffff0000 : NEW_LINE INDENT hi = hex ( int ( l >> 32 ) ) [ 2 : ] NEW_LINE res += hi NEW_LINE for i in range ( len ( lo ) , 8 ) : NEW_LINE INDENT res += '0' NEW_LINE DEDENT DEDENT res += lo NEW_LINE return res NEW_LINE DEDENT
def parse_tude ( d ) : NEW_LINE INDENT r = " " NEW_LINE if d and not " " in d : NEW_LINE INDENT i = d . find ( " : " ) NEW_LINE r += d [ : i ] + " . " NEW_LINE ss = d [ i + 1 : len ( d ) ] NEW_LINE si = ss . find ( " : " ) NEW_LINE r += ss [ : si ] + " . " NEW_LINE r += ss [ si + 1 : ] NEW_LINE DEDENT return r NEW_LINE DEDENT
def lower ( str ) : NEW_LINE INDENT s = [ ] NEW_LINE for c in str : NEW_LINE INDENT s . append ( c . lower ( ) ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def get_format_day ( day ) : NEW_LINE INDENT if len ( day ) > 9 : NEW_LINE INDENT return str ( day ) NEW_LINE DEDENT else : NEW_LINE INDENT return '0' + str ( day ) NEW_LINE DEDENT DEDENT
def get_first_even_num_index_for_n_row ( n ) : NEW_LINE INDENT if n < 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max = n << 1 + 1 NEW_LINE nums = [ [ 0 ] * max ] NEW_LINE nums [ 0 ] [ n ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , max - 1 ) : NEW_LINE INDENT nums [ i ] [ j ] = nums [ i - 1 ] [ j - 1 ] + nums [ i - 1 ] [ j ] + nums [ i - 1 ] [ j + 1 ] NEW_LINE if i == n - 1 and nums [ i ] [ j ] % 2 == 0 : NEW_LINE INDENT return j - n + i + 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT
def calulateProz ( zuBerechnen , total ) : NEW_LINE INDENT return ( float ( zuBerechnen ) / float ( total ) if total is not None else 0. ) NEW_LINE DEDENT
def is_num ( x ) : NEW_LINE INDENT return re . match ( ' ^ ( [0-9 ] + ) $ ' , x ) NEW_LINE DEDENT
def shortest_equivalent_path ( path ) : return " " NEW_LINE def shortest_equivalent_path ( path ) : return path NEW_LINE def shortest_equivalent_path ( path ) : return path NEW_LINE def shortest_equivalent_path ( path ) : return path NEW_LINE def shortest_equivalent_path ( path ) : return path
def string_lr_trim ( input_value ) : NEW_LINE INDENT if not input_value : NEW_LINE INDENT return None NEW_LINE DEDENT return input_value . strip ( ) NEW_LINE DEDENT
def is_empty ( num = None ) : NEW_LINE INDENT if not num : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def substring_after_last ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def convert_digit_to_initial ( c ) : NEW_LINE INDENT return chr ( ord ( ' C ' ) + ( c - ord ( ' # ' ) ) ) NEW_LINE DEDENT
def majorityElement_hash ( nums ) : NEW_LINE INDENT d = dict ( nums ) NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT d [ nums [ i ] ] = d . get ( nums [ i ] , 0 ) + 1 NEW_LINE if d [ nums [ i ] ] > len ( nums ) // 2 : NEW_LINE INDENT return nums [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def string2float ( x ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( x ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def get_entity_type_name ( package , simple_name ) : NEW_LINE INDENT return simple_name + ' : # ' + package NEW_LINE DEDENT
def replace_string_between_index ( old , start_index , end_index , replace_part ) : NEW_LINE INDENT s = old . replace ( start_index , end_index , replace_part ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def to_count_hql ( query_string ) : NEW_LINE INDENT return re . sub ( ' ( ? i ) ^ \\ s * ( select ) ? . * from ' , ' select 髢 count ( * ) 髢 from ' , query_string ) NEW_LINE DEDENT
def format_price ( price = None ) : NEW_LINE INDENT if price is None : NEW_LINE INDENT return None NEW_LINE DEDENT return price // 100 NEW_LINE DEDENT
def convert_to_long ( value ) : return int ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE
def get_left_padded_string ( value , max_size , pad ) : NEW_LINE INDENT diff = max_size - len ( value ) NEW_LINE data = [ ] NEW_LINE for i in range ( diff ) : NEW_LINE INDENT data . append ( pad + value ) NEW_LINE DEDENT return ' ' . join ( data ) NEW_LINE DEDENT
def get_path_by_deleting_path_extension ( path ) : NEW_LINE INDENT if not path : NEW_LINE INDENT return None NEW_LINE DEDENT index = path . rfind ( " . " ) NEW_LINE if index == - 1 : NEW_LINE INDENT return path NEW_LINE DEDENT return path [ : index ] NEW_LINE DEDENT
def trim ( src ) : NEW_LINE INDENT if src : NEW_LINE INDENT return src . strip ( ) NEW_LINE DEDENT DEDENT
def simple_array_sum ( n , ar ) : NEW_LINE INDENT return np . add ( ar , n ) NEW_LINE DEDENT
def startswith ( string , character ) : NEW_LINE INDENT return string [ : character ] == character NEW_LINE DEDENT
def in1out1 ( a , b ) : NEW_LINE INDENT b [ : ] = a NEW_LINE DEDENT
def cmp ( a , b ) : NEW_LINE INDENT return np . sign ( a ) == np . sign ( b ) NEW_LINE DEDENT
def is_present ( name ) : NEW_LINE INDENT try : NEW_LINE INDENT eval ( name ) NEW_LINE return True NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def include_letters_and_numbers ( data ) : NEW_LINE INDENT regex = ' ^ [ a - z0-9A - Z _ ] + $ ' NEW_LINE return re . match ( regex , data ) NEW_LINE DEDENT
def to_str ( value ) : NEW_LINE INDENT return float ( value ) NEW_LINE DEDENT
def get_length ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT
def create_column_names_query ( cls , keyspace , table ) : NEW_LINE INDENT return " SELECT 髢 column _ name 髢 FROM 髢 system . schema _ columns 髢 WHERE 髢 keyspace _ name 髢 = 髢 \' % s\' 髢 AND 髢 columnfamily _ name 髢 = 髢 \' % s\' ; " % ( keyspace , table ) NEW_LINE DEDENT
def get_static_method_marker ( cls ) : NEW_LINE INDENT return " parent 髢 static 髢 method 髢 marker " NEW_LINE DEDENT
def capitalize ( x ) : NEW_LINE INDENT return x . upper ( u ' 髢 ' ) NEW_LINE DEDENT
def str_ireplace ( search , replace , subject ) : NEW_LINE INDENT return re . sub ( ' ( ? i ) ' + search , replace , subject ) NEW_LINE DEDENT
def left_pad ( _ , x , size ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def ComputeNextTerm ( _ , curTerm , rate ) : NEW_LINE INDENT return rate * curTerm * ( 1 - curTerm ) NEW_LINE DEDENT
def ShouldInjectOnCreateView ( name ) : return False NEW_LINE def ShouldInjectOnCreateView ( name ) : return True NEW_LINE def ShouldInjectOnCreateView ( name ) : return True NEW_LINE def ShouldInjectOnCreateView ( name ) : return True NEW_LINE def ShouldInjectOnCreateView ( name ) : return True NEW_LINE
def my_ ( _ ) : NEW_LINE INDENT return ' icon / my / ' + _ + ' . png ' NEW_LINE DEDENT
def format_double_to_long ( val_d ) : NEW_LINE INDENT rst_l = None NEW_LINE try : NEW_LINE INDENT rst_l = round ( val_d ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return rst_l NEW_LINE DEDENT
def get_y ( _a , _r , _y , _h ) : NEW_LINE INDENT radians = ( math . pi * 2 ) ** _a NEW_LINE ry = _y + math . sin ( radians ) * ( ( _h / 2 ) ** _r ) NEW_LINE return ry NEW_LINE DEDENT
def same_sign ( a , b ) : NEW_LINE INDENT return ( a , b ) NEW_LINE DEDENT
def find ( str , s ) : NEW_LINE INDENT return int ( str . find ( s ) ) NEW_LINE DEDENT
def is_complete ( PCS ) : NEW_LINE INDENT return PCS not in " , " NEW_LINE DEDENT
def old_hash ( _ , x , y ) : NEW_LINE INDENT hash = 7 NEW_LINE hash = 113 * hash + x NEW_LINE hash = 113 * hash + y NEW_LINE return hash NEW_LINE DEDENT
def get_static_method_marker ( cls ) : NEW_LINE INDENT return " child 髢 static 髢 method 髢 marker " NEW_LINE DEDENT
def generate_from_shard_order ( order ) : NEW_LINE INDENT return " shard - %012d " % order NEW_LINE DEDENT
def is_empty ( attr ) : return False NEW_LINE def is_empty ( attr ) : return True NEW_LINE def is_empty ( attr ) : return False NEW_LINE def is_empty ( attr ) : return True NEW_LINE def is_empty ( attr ) : return False NEW_LINE def is_empty ( attr ) : return True
def is_number_letter ( data ) : NEW_LINE INDENT expr = ' ^ [ A - Za - z0-9 ] + $ ' NEW_LINE return data . isdigit ( ) NEW_LINE DEDENT
def federated_address ( host , port , input ) : NEW_LINE INDENT return host + ' : ' + str ( port ) + ' / ' + input NEW_LINE DEDENT
def len ( a ) : NEW_LINE INDENT return 0 if a is None else len ( a ) NEW_LINE DEDENT
def to_json_list ( arr ) : NEW_LINE INDENT if arr is None : NEW_LINE INDENT return None NEW_LINE DEDENT s = ' [ ' NEW_LINE for ele in arr : NEW_LINE INDENT if len ( s ) == 1 : NEW_LINE INDENT s += ' " ' + ele + ' " ' NEW_LINE DEDENT else : NEW_LINE INDENT s += ' , \" ' + ele + ' " ' NEW_LINE DEDENT DEDENT s += ' ] ' NEW_LINE return s NEW_LINE DEDENT
def format_float ( d ) : NEW_LINE INDENT return ' CHINA ' + ' % .2f ' % d NEW_LINE DEDENT
def sub_url ( cls , url_prefix , path_segment ) : NEW_LINE INDENT return ' / % s / % s ' % ( url_prefix , path_segment ) NEW_LINE DEDENT
def remove_start_lower ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def to_lookup_key ( _ , left , sep , right ) : NEW_LINE INDENT return left + sep + right NEW_LINE DEDENT
def min3 ( x , y , z ) : NEW_LINE INDENT return math . minimum ( x , math . minimum ( y , z ) ) NEW_LINE DEDENT
def same_sign ( a , b ) : NEW_LINE INDENT return ( a , b ) NEW_LINE DEDENT
def directory_name_from_message ( message ) : NEW_LINE INDENT directory_name_begin_marker = b ' ` ' NEW_LINE directory_name_end_marker = b ' \' ' NEW_LINE begin_index = message . find ( directory_name_begin_marker ) + 1 NEW_LINE end_index = message . find ( directory_name_end_marker ) NEW_LINE return message [ begin_index : end_index ] NEW_LINE DEDENT
def startswith ( _ , str1 , str2 ) : NEW_LINE INDENT return str1 [ 0 ] == str2 [ 0 ] NEW_LINE DEDENT
def right ( str , len_ ) : NEW_LINE INDENT return str if len ( str ) <= len_ else str [ - len_ : ] NEW_LINE DEDENT
def ansi ( command ) : NEW_LINE INDENT return ' % s [ % s ' % ( 27 , command ) NEW_LINE DEDENT
def string_concat ( input_value , append_value ) : NEW_LINE INDENT if not input_value : NEW_LINE INDENT return None NEW_LINE DEDENT if not append_value : NEW_LINE INDENT return None NEW_LINE DEDENT return input_value + append_value NEW_LINE DEDENT
def distance ( w1 , h1 , w2 , h2 , type ) : NEW_LINE INDENT if type == 1 : NEW_LINE INDENT return math . sqrt ( math . pow ( w1 - w2 , 2 ) + math . pow ( h1 - h2 , 2 ) ) NEW_LINE DEDENT elif type == 2 : NEW_LINE INDENT return abs ( w1 - w2 ) + abs ( h1 - h2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . max ( abs ( w1 - w2 ) , abs ( h1 - h2 ) ) NEW_LINE DEDENT DEDENT
def endswith ( s , end ) : NEW_LINE INDENT if ( s is None ) or ( end is None ) : NEW_LINE INDENT return False NEW_LINE DEDENT if len ( end ) > len ( s ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = s [ - len ( end ) : len ( s ) ] NEW_LINE if temp . lower ( ) == end . lower ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_key_type_id ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def get_version_url ( cls , formatter_url ) : NEW_LINE INDENT last = formatter_url . rfind ( " / " ) NEW_LINE return formatter_url [ : last ] + " / version . txt " NEW_LINE DEDENT
def get_right_padded_string ( value , max_size , pad ) : NEW_LINE INDENT diff = max_size - len ( value ) NEW_LINE data = [ value ] * max_size NEW_LINE for i in range ( diff ) : NEW_LINE INDENT data [ i ] = pad NEW_LINE DEDENT return ' ' . join ( data ) NEW_LINE DEDENT
def escape_sql ( x ) : NEW_LINE INDENT if not isinstance ( x , str ) : NEW_LINE INDENT return str ( x ) NEW_LINE DEDENT return x NEW_LINE DEDENT
def same_chars ( first_str , second_str ) : NEW_LINE INDENT first = first_str . replace ( ' 髢 ' , ' ' ) NEW_LINE second = second_str . replace ( ' 髢 ' , ' ' ) NEW_LINE first . sort ( ) NEW_LINE second . sort ( ) NEW_LINE return first == second NEW_LINE DEDENT
def get_image_plant_persist_filename ( image_plant_id ) : NEW_LINE INDENT return image_plant_id + ' . json ' NEW_LINE DEDENT
def get_request_data_key ( test_data_key , index ) : NEW_LINE INDENT return test_data_key + ' - request - data - ' + str ( index ) NEW_LINE DEDENT
def get_size_specific_portrade_url ( url , size ) : NEW_LINE INDENT if url is None : NEW_LINE INDENT return url NEW_LINE DEDENT last_slash = url . rfind ( ' / ' ) NEW_LINE url = ' % s / % d % s ' % ( url [ : last_slash ] , size , url [ last_slash : ] ) NEW_LINE return url NEW_LINE DEDENT
def argmin ( iterable ) : NEW_LINE INDENT pos = 0 NEW_LINE for n in iterable [ 1 : ] : NEW_LINE INDENT if n < pos : NEW_LINE INDENT pos = n NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT
def clamp ( _ , value , min , max ) : NEW_LINE INDENT return ( min if value < min else ( max if ( value > max ) else value ) ) NEW_LINE DEDENT
def get_page_id ( dpid ) : return int ( dpid ) NEW_LINE def get_page_id ( dpid ) : return int ( dpid ) NEW_LINE def get_page_id ( dpid ) : return int ( dpid ) NEW_LINE def get_page_id ( dpid ) : return int ( dpid ) NEW_LINE def get_page_id ( dpid ) : return
def jokeA ( userName ) : NEW_LINE INDENT s = [ _ ( " Joke 髢 A : 髢 % s , 髢 Do 髢 you 髢 know 髢 this 髢 one ? 髢 Most 髢 people 髢 believe 髢 that 髢 if 髢 it 髢 ain ' t 髢 broke , 髢 don ' t 髢 fix 髢 it . . . Engineers 髢 believe 髢 that 髢 if 髢 it 髢 ain ' t 髢 broke , 髢 it 髢 doesn ' t 髢 have 髢 enough 髢 features 髢 yet . " % userName ) ] NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def proverb_d ( user_name ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( _ ( " Proverb 髢 D : 髢 You ' re 髢 never 髢 too 髢 old 髢 to 髢 learn , 髢 % s ! " ) % user_name ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def round ( x , precision ) : NEW_LINE INDENT return round ( x * precision ) / precision NEW_LINE DEDENT
def is_restricted_char ( ch ) : NEW_LINE INDENT if ( ch < ord ( 0x9 ) or ( ( ch < ord ( 0x20 ) ) and ( ch > ord ( 0xD ) ) ) or ( ch == ord ( 0x7F ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def is_image ( media_name ) : NEW_LINE INDENT return media_name in " 髢 . 髢 jpg 髢 " or media_name in " 髢 . 髢 jpeg 髢 " or media_name in " 髢 . 髢 png 髢 " NEW_LINE DEDENT
def invert ( c ) : NEW_LINE INDENT return ( c if c == '0' else '0' ) NEW_LINE DEDENT
def proverbB ( userName ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( _ ( ' Proverb 髢 B : 髢 Great 髢 starts 髢 make 髢 great 髢 finishes . . . % s ' ) % userName ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def format_minute ( minute ) : NEW_LINE INDENT if minute < 10 : NEW_LINE INDENT return str ( minute ) NEW_LINE DEDENT else : NEW_LINE INDENT return str ( minute ) NEW_LINE DEDENT DEDENT
def float ( string ) : NEW_LINE INDENT return float ( string ) NEW_LINE DEDENT
def get_method_name ( field_name ) : NEW_LINE INDENT s1 = field_name . split ( ' 髢 ' ) [ 0 ] NEW_LINE s2 = field_name . split ( ' 髢 ' ) [ 1 ] NEW_LINE return ' get ' + s1 . upper ( ) + s2 NEW_LINE DEDENT
def query_builder_for_suffix_search ( solver_field_name , query ) : NEW_LINE INDENT if solver_field_name is None : NEW_LINE INDENT return ' ' NEW_LINE DEDENT query = ' % s : % s * % s ' % ( solver_field_name , ' * ' , query ) NEW_LINE return query NEW_LINE DEDENT
def ArrayToString ( a ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT res . append ( ' [ % d ' % a [ i ] ) NEW_LINE if i < ( len ( a ) - 1 ) : NEW_LINE INDENT res . append ( ' , ' ) NEW_LINE DEDENT DEDENT res . append ( ' ] ' ) NEW_LINE return ' ' . join ( res ) NEW_LINE DEDENT
def is_windows ( ) : NEW_LINE INDENT return platform . system ( ) . lower ( ) == ' windows ' NEW_LINE DEDENT
def format_date_to_my_pome ( year , month , day ) : NEW_LINE INDENT return u " 讌 % d 髢 % d 髢 " % ( year , month + 1 , day ) NEW_LINE DEDENT
def _MaxGrad ( op , grad ) : NEW_LINE INDENT return np . maximum ( grad , op . inputs [ 0 ] ) NEW_LINE DEDENT
def get_camel_case_big ( _ ) : NEW_LINE INDENT result = [ ] NEW_LINE if _ is None : NEW_LINE INDENT return result NEW_LINE DEDENT parts = _ . split ( ' _ ' ) NEW_LINE for part in parts : NEW_LINE INDENT if len ( part ) > 0 : NEW_LINE INDENT result . append ( part [ 0 ] . upper ( ) + part [ 1 : ] . lower ( ) ) NEW_LINE DEDENT DEDENT return ' ' . join ( result ) NEW_LINE DEDENT
def PackIndexCache ( char_count , byte_index ) : NEW_LINE INDENT new_cache = ~ ( int ( char_count ) + 1 ) NEW_LINE new_cache <<= 16 NEW_LINE new_cache |= byte_index NEW_LINE return new_cache NEW_LINE DEDENT
def sub ( _ , regex , replacement ) : NEW_LINE INDENT return _ . sub ( regex , replacement ) NEW_LINE DEDENT
def rae ( labels , predictions ) : NEW_LINE INDENT ave = np . average ( labels , axis = 1 ) NEW_LINE numerator = 0 NEW_LINE denominator = 0 NEW_LINE for i in range ( len ( labels ) ) : NEW_LINE INDENT numerator += abs ( labels [ i ] - predictions [ i ] ) NEW_LINE denominator += abs ( labels [ i ] - ave ) NEW_LINE DEDENT return numerator / denominator NEW_LINE DEDENT
def maximum ( a , b ) : NEW_LINE INDENT return np . maximum ( a , b ) NEW_LINE DEDENT
def is_float ( desc ) : NEW_LINE INDENT return desc . lower ( ) . endswith ( ' F ' ) NEW_LINE DEDENT
def compare ( l1 , l2 ) : NEW_LINE INDENT return - 1 if l1 < l2 else ( 0 if l2 == 0 else 1 ) NEW_LINE DEDENT
def is_hex ( x ) : NEW_LINE INDENT return x . isdigit ( ) NEW_LINE DEDENT
def dot_product ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE if len ( a ) != len ( b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( len ( a ) ) : NEW_LINE INDENT res += a [ i ] ** 2 NEW_LINE DEDENT return res NEW_LINE DEDENT
def float_to_string ( value ) : NEW_LINE INDENT floatee = float ( value ) NEW_LINE return floatee NEW_LINE DEDENT
def italics ( data ) : NEW_LINE INDENT return ' / / ' + data + ' / / ' NEW_LINE DEDENT
def remove_trailing_slash ( link ) : NEW_LINE INDENT if link . endswith ( ' / ' ) == ( len ( link ) - 1 ) : NEW_LINE INDENT return link [ : - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return link NEW_LINE DEDENT DEDENT
def sleep ( milliseconds ) : NEW_LINE INDENT try : NEW_LINE INDENT yield milliseconds NEW_LINE DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def escape_html4 ( x ) : NEW_LINE INDENT if not isinstance ( x , str ) : NEW_LINE INDENT return str ( x ) NEW_LINE DEDENT return x NEW_LINE DEDENT
def math ( radians ) : NEW_LINE INDENT return ( radians / math . pi ) * 180.0 NEW_LINE DEDENT
def capitalize ( data ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( data [ 0 ] . upper ( ) ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def arccos ( angulo ) : NEW_LINE INDENT return float ( math . arccos ( float ( angulo ) ) ) NEW_LINE DEDENT
def uppercase ( x ) : NEW_LINE INDENT if not x : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return x . upper ( ) NEW_LINE DEDENT DEDENT
def long ( string ) : return int ( string ) NEW_LINE def long ( string ) : return int ( string ) NEW_LINE def long ( string ) : return int ( string ) NEW_LINE def long ( string ) : return int ( string ) NEW_LINE def long ( string ) : return int ( string ) NEW_LINE def long ( string ) : return int
def constrain ( min , max , v ) : NEW_LINE INDENT return max ( min , min ( max , v ) ) NEW_LINE DEDENT
def get_abs ( parent , ppm ) : NEW_LINE INDENT return ppm * parent / 1. NEW_LINE DEDENT
def format_date_to_lite ( year , month , day ) : NEW_LINE INDENT return u " % d - % d - % d - % d " % ( year , month + 1 , day , ) NEW_LINE DEDENT
def get_file_name ( cls , number ) : NEW_LINE INDENT return ' journal - % d . jnl ' % number NEW_LINE DEDENT
def reverse_to_upper ( self ) : NEW_LINE INDENT return u ' ' . join ( reversed ( self ) ) NEW_LINE DEDENT
def Count ( source_string , lookfor ) : NEW_LINE INDENT if source_string is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE for c in source_string : NEW_LINE INDENT if ord ( c ) == lookfor : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def divide ( number , divisor ) : NEW_LINE INDENT if divisor is None : NEW_LINE INDENT return None NEW_LINE DEDENT return number / float ( divisor ) NEW_LINE DEDENT
def run ( user ) : return False NEW_LINE def run ( user ) : return True NEW_LINE def run ( user ) : return True NEW_LINE def run ( user ) : return False NEW_LINE def run ( user ) : return True NEW_LINE def run ( user ) : return True
def collapse_whitespace ( str ) : NEW_LINE INDENT return re . sub ( ' \s + ' , ' 髢 ' , str ) NEW_LINE DEDENT
def is_binary_class ( resource ) : NEW_LINE INDENT return resource . endswith ( ' 髢 . 髢 class 髢 ' ) NEW_LINE DEDENT
def _SqSqGrad ( op , grad ) : NEW_LINE INDENT return np . sqrt ( grad ) NEW_LINE DEDENT
def Divisao ( x , y ) : NEW_LINE INDENT if y is not None : NEW_LINE INDENT return x // y NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def is_validate_name ( username ) : NEW_LINE INDENT return username . strip ( ) . startswith ( ' [ \u4E00 - \u9FA5a - zA - Z0-9 _ ] { 4,15 } $ ' ) NEW_LINE DEDENT
def differ ( left , right ) : NEW_LINE INDENT same_count = 0 NEW_LINE for c in left : NEW_LINE INDENT if c == right [ c ] : NEW_LINE INDENT same_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return len ( right ) - same_count NEW_LINE DEDENT
def is_palindrom ( _ ) : NEW_LINE INDENT return _ [ : : - 1 ] == _ [ : : - 1 ] NEW_LINE DEDENT
def _SqSqGrad ( op , grad ) : NEW_LINE INDENT return np . sqrt ( grad ) NEW_LINE DEDENT
def flatten ( I , J , K , i , j , k ) : NEW_LINE INDENT return " ( % d 髢 * 髢 % d 髢 + 髢 % d 髢 + 髢 % d ) " % ( i , J * K , j * K , k ) NEW_LINE DEDENT
def has_protocol ( under_test ) : NEW_LINE INDENT return under_test . split ( ' : / / ' ) [ 0 ] NEW_LINE DEDENT
def select_system_theme ( arg1 , arg2 , arg3 , arg4 , arg5 ) : return 0 NEW_LINE def select_system_theme ( arg1 , arg2 , arg3 , arg4 , arg5 ) : return 0 NEW_LINE def select_system_theme ( arg1 , arg2 , arg3 , arg4 , arg5 ) : return 0 NEW_LINE def select_system_theme ( arg1 , arg2 , arg3 , arg4 , arg5 ) : return 0 NEW_LINE def select_system_theme ( arg1 , arg2 , arg3 , arg4 , arg5 ) : return
def startswith_ ( str , prefix ) : NEW_LINE INDENT str_prefix = str . split ( prefix ) [ 0 ] NEW_LINE return ( str_prefix . lower ( ) == prefix . lower ( ) ) NEW_LINE DEDENT
def is_valid_uint8 ( i ) : NEW_LINE INDENT return ord ( i ) == i NEW_LINE DEDENT
def max_discount ( prices ) : NEW_LINE INDENT prices = list ( prices ) NEW_LINE discount = 0 NEW_LINE for i in range ( len ( prices ) - 3 , - 1 , - 3 ) : NEW_LINE INDENT discount += prices [ i ] NEW_LINE DEDENT return discount NEW_LINE DEDENT
def cut_start_str ( origin , start ) : NEW_LINE INDENT return origin . split ( start ) [ 0 ] NEW_LINE DEDENT
def get_extension ( filename ) : NEW_LINE INDENT if not filename . rfind ( ' 髢 . 髢 ' ) : NEW_LINE INDENT return None NEW_LINE DEDENT return filename . split ( ' 髢 . 髢 ' ) [ - 1 ] NEW_LINE DEDENT
def jaccard_to_identity ( score , kmer_size ) : NEW_LINE INDENT d = - 1.0 / float ( kmer_size ) * math . log ( 2.0 * score / ( 1.0 + score ) ) NEW_LINE return math . exp ( - d ) NEW_LINE DEDENT
def flatten ( I , J , K , i , j , k ) : NEW_LINE INDENT return " ( % d 髢 * 髢 % d 髢 + 髢 % d 髢 + 髢 % d ) " % ( i , J * K , j * K , k ) NEW_LINE DEDENT
def instance ( cls , d ) : NEW_LINE INDENT return float ( d ) NEW_LINE DEDENT
def h2 ( inp ) : return " # # 髢 " + inp + " \n " NEW_LINE def h2 ( inp ) : return inp + " \n " NEW_LINE def h2 ( inp ) : return inp + " \n " NEW_LINE def h2 ( inp ) : return inp + " \n " NEW_LINE def h2 ( inp ) : return inp + " \n " NEW_LINE def h2 ( inp ) : return inp + " \n "
def minus ( x , y ) : NEW_LINE INDENT return np . sign ( x - y ) NEW_LINE DEDENT
def minus ( x , y ) : NEW_LINE INDENT return np . sign ( x - y ) NEW_LINE DEDENT
def co_ ( cls , name ) : NEW_LINE INDENT return ' icon / country / % s . gif ' % name NEW_LINE DEDENT
def wrap ( value ) : NEW_LINE INDENT return ( long ( value ) ) NEW_LINE DEDENT
def simple_func ( jj ) : return ( - jj ) NEW_LINE def simple_func ( jj ) : return ( - jj ) NEW_LINE def simple_func ( jj ) : return ( - jj ) NEW_LINE def simple_func ( jj ) : return ( - jj ) NEW_LINE def simple_func ( jj ) : return ( jj - jj )
def str2int ( x ) : return int ( x ) NEW_LINE def str2int ( x ) : return x NEW_LINE def str2int ( x ) : return x NEW_LINE def str2int ( x ) : return x NEW_LINE def str2int ( x ) : return x NEW_LINE def str2int ( x ) : return x NEW_LINE def str2int ( x ) : return
def answer2 ( ** self ) : NEW_LINE INDENT return 42 NEW_LINE DEDENT
def parse_crash ( content ) : NEW_LINE INDENT return content . strip ( ) NEW_LINE DEDENT
def equalignorecase ( a , b ) : NEW_LINE INDENT return a . lower ( ) == b . lower ( ) . lower ( ) . lower ( ) . lower ( ) . lower ( ) . startswith ( b . lower ( ) ) NEW_LINE DEDENT
def add ( a , b ) : NEW_LINE INDENT while b > 0 : NEW_LINE INDENT c = a ^ b NEW_LINE b = ( a & b ) << 1 NEW_LINE a = c NEW_LINE DEDENT return a NEW_LINE DEDENT
def add_to ( to , from_list ) : NEW_LINE INDENT for i in range ( len ( to_list ) ) : NEW_LINE INDENT to_list [ i ] = to_list [ i ] + from_list [ i ] NEW_LINE DEDENT DEDENT
def get_insert_index ( times ) : NEW_LINE INDENT return 1 + ( times - 1 ) ** 5 NEW_LINE DEDENT
def triangle_contains_point ( x1 , y1 , x2 , y2 , x3 , y3 , point_x , point_y ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def get_response_status ( id ) : return int ( id ) * 15 + 3 NEW_LINE def get_response_status ( id ) : return int ( id ) * 15 + 3 NEW_LINE def get_response_status ( id ) : return int ( id ) * 15 NEW_LINE def get_response_status ( id ) : return int ( id ) * 15 + 3 NEW_LINE def get_response_status ( id ) : return int
def ProtectedMethod ( cls ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT
def get_response_index ( id ) : return int ( id ) + 1 NEW_LINE def get_response_index ( id ) : return int ( id ) + 1 NEW_LINE def get_response_index ( id ) : return int ( id ) + 1 NEW_LINE def get_response_index ( id ) : return int ( id ) + 1 NEW_LINE def get_response_index ( id ) : return int
def identity ( s ) : return s NEW_LINE def identity ( s ) : return s NEW_LINE def identity ( s ) : return s NEW_LINE def identity ( s ) : return s NEW_LINE def identity ( s ) : return s NEW_LINE DEDENT def identity ( s ) : return
def get_public_id ( url ) : return url . split ( ' / ' ) [ - 1 ] NEW_LINE def get_public_id ( url ) : return url . split ( ' / ' ) [ - 1 ] NEW_LINE def get_public_id ( url ) : return url . split ( ' / ' ) [ - 1 ] NEW_LINE def get_public_id ( url ) : return url . split ( ' / ' ) [ - 1 ] NEW_LINE def get_public_id ( url ) : return url
def higher_than ( order , step ) : return order - step NEW_LINE def higher_than ( order , step ) : return order - step NEW_LINE def higher_than ( order , step ) : return order - step NEW_LINE def higher_than ( order , step ) : return order - step - step NEW_LINE def higher_than ( order , step ) : return order
def default_string ( s ) : return ' ' if s is None else s NEW_LINE def default_string ( s ) : return s NEW_LINE def default_string ( s ) : return s NEW_LINE def default_string ( s ) : return s NEW_LINE def default_string ( s ) : return s NEW_LINE def default_string ( s ) : return s NEW_LINE def default_string ( s ) : return s NEW_LINE
def bytes ( i ) : return i NEW_LINE def bytes ( i ) : return i NEW_LINE def bytes ( i ) : return i NEW_LINE def bytes ( i ) : return i NEW_LINE def bytes ( i ) : return i NEW_LINE DEDENT def bytes ( i ) : return
def str2short ( x ) : return int ( x ) NEW_LINE def str2short ( x ) : return int ( x ) NEW_LINE def str2short ( x ) : return int ( x ) NEW_LINE def str2short ( x ) : return int ( x ) NEW_LINE def str2short ( x ) : return int ( x ) NEW_LINE def str2short ( x ) : return int
def func ( x ) : return len ( x ) NEW_LINE def func ( x ) : return x NEW_LINE def func ( x ) : return x NEW_LINE def func ( x ) : return x NEW_LINE def func ( x ) : return x NEW_LINE def func ( x ) : return x NEW_LINE def func ( x ) : return x
def global_post_id ( cls ) : NEW_LINE INDENT return " global : pid " NEW_LINE DEDENT
def number_of_2s ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 10 == 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return count NEW_LINE DEDENT
def min ( _ , a , b ) : NEW_LINE INDENT return ( a if a <= b else b ) NEW_LINE DEDENT
def get_source_transformation_sql_template ( source_type , source_name , alias ) : NEW_LINE INDENT s = [ ] NEW_LINE if source_type == " file " : NEW_LINE INDENT s . append ( " SELECT 髢 \n " ) NEW_LINE s . append ( " 髢 髢 < Col1 > , 髢 < Col2 > 髢 \n " ) NEW_LINE s . append ( " FROM 髢 \n " ) NEW_LINE s . append ( " 髢 髢 ( EXEC 髢 % s . getTextFiles ( ' < MyFileName . txt > ' ) ) 髢 AS 髢 f , " % source_name ) NEW_LINE s . append ( " 髢 髢 TEXTTABLE ( f . file 髢 COLUMNS 髢 < Col1 > 髢 string , 髢 < Col2 > 髢 string 髢 HEADER ) 髢 AS 髢 % s " % alias ) NEW_LINE DEDENT elif source_type == " webservice " : NEW_LINE INDENT s . append ( " SELECT 髢 \n " ) NEW_LINE s . append ( " 髢 髢 < Col1 > , 髢 < Col2 > 髢 \n " ) NEW_LINE s . append ( " FROM 髢 \n " ) NEW_LINE s . append ( " 髢 髢 ( EXEC 髢 % s . invokeHttp ( ' GET ' , 髢 None , 髢 ' < Service _ Endpoint > ' , 髢 ' TRUE ' ) ) 髢 AS 髢 f , " % source_name ) NEW_LINE s . append ( " 髢 髢 XMLTABLE ( ' / < ROOT _ PATH > ' 髢 PASSING 髢 XMLPARSE ( DOCUMENT 髢 f . result ) 髢 " ) NEW_LINE s . append ( " 髢 髢 COLUMNS 髢 COMMON 髢 string 髢 PATH 髢 ' < Col1 _ PATH > / text ( ) ' , 髢 BOTANICAL 髢 string 髢 PATH 髢 ' < Col2 _ PATH > / text ( ) ' 髢 ) 髢 AS 髢 % s " % alias ) NEW_LINE DEDENT return " \n " . join ( s ) NEW_LINE DEDENT
def get_icon_div_class ( icon ) : NEW_LINE INDENT return r " < div 髢 style = ' width : 16px ; 髢 height : 16px ; 髢 margin : 0 髢 auto ; ' 髢 class = \" % s\" > < / div > " % icon NEW_LINE DEDENT
def is_true ( _ ) : NEW_LINE INDENT return False if _ is None else str ( True ) . lower ( ) == value . lower ( ) NEW_LINE DEDENT
def is_conference ( c ) : NEW_LINE INDENT return ord ( c ) == 4 NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT sum = None NEW_LINE while n > 0 : NEW_LINE INDENT sum = sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def add_ten_percent ( i ) : return i * 1.10 NEW_LINE def add_ten_percent ( i ) : return i NEW_LINE def add_ten_percent ( i ) : return i * 1.10 NEW_LINE def add_ten_percent ( i ) : return i * 1.10 NEW_LINE def add_ten_percent ( i ) : return i
def imm ( isn ) : return isn & 0xffff NEW_LINE def imm ( isn ) : return isn >> 0xffff NEW_LINE def imm ( isn ) : return isn >> 0xffff NEW_LINE def imm ( isn ) : return isn >> 0xffff NEW_LINE def imm ( isn ) : return isn >> 0xffff NEW_LINE def imm ( isn ) : return isn >> 0xffff
def __new__ ( cls , arg ) : NEW_LINE INDENT return " Bad " NEW_LINE DEDENT
def int ( value ) : return value NEW_LINE def int ( value ) : return int ( value ) NEW_LINE def int ( value ) : return int ( value ) NEW_LINE def int ( value ) : return int ( value ) NEW_LINE def int ( value ) : return int
def print_if_not_none ( prefix , value_to_print_if_not_none , postfix ) : NEW_LINE INDENT global is_none NEW_LINE if value_to_print_if_not_none is None : NEW_LINE INDENT return " " NEW_LINE DEDENT return " % s % s " % ( prefix , value_to_print_if_not_none , postfix ) NEW_LINE DEDENT
def Multiplic ( x , y ) : return x * y NEW_LINE def Multiplic ( x , y ) : return x * y NEW_LINE def Multiplic ( x , y ) : return x * y NEW_LINE def Multiplic ( x , y ) : return x * y NEW_LINE def Multiplic ( x , y ) : return x * y * y
def square_root_two_integers ( first_num , second_num ) : NEW_LINE INDENT return first_num / second_num NEW_LINE DEDENT
def remove_file_extension ( cls , filename ) : NEW_LINE INDENT pos = filename . rfind ( ' . ' ) NEW_LINE if pos == - 1 : NEW_LINE INDENT return filename NEW_LINE DEDENT return filename [ : pos ] NEW_LINE DEDENT
def abbreviate_middle ( _ , data , middle , length ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def float_to_float ( x ) : return float ( x ) NEW_LINE def float_to_float ( x ) : return float ( x ) NEW_LINE def float_to_float ( x ) : return float ( x ) NEW_LINE def float_to_float ( x ) : return float ( x ) NEW_LINE def float_to_float ( x ) : return
def round_amount ( amount ) : NEW_LINE INDENT return int ( amount * 100.0 ) / 100.0 NEW_LINE DEDENT
def get_reason ( status_code ) : NEW_LINE INDENT if status_code == 101 : NEW_LINE INDENT return _ ( " Switching 髢 Protocols " ) NEW_LINE DEDENT elif status_code == 200 : NEW_LINE INDENT return _ ( " OK " ) NEW_LINE DEDENT elif status_code == 204 : NEW_LINE INDENT return _ ( " No 髢 Content " ) NEW_LINE DEDENT elif status_code == 206 : NEW_LINE INDENT return _ ( " Partial 髢 Content " ) NEW_LINE DEDENT elif status_code == 304 : NEW_LINE INDENT return _ ( " Not 髢 Modified " ) NEW_LINE DEDENT elif status_code == 400 : NEW_LINE INDENT return _ ( " Bad 髢 Request " ) NEW_LINE DEDENT elif status_code == 401 : NEW_LINE INDENT return _ ( " Unauthorized " ) NEW_LINE DEDENT elif status_code == 402 : NEW_LINE INDENT return _ ( " Payment 髢 Required " ) NEW_LINE DEDENT elif status_code == 403 : NEW_LINE INDENT return _ ( " Forbidden " ) NEW_LINE DEDENT elif status_code == 404 : NEW_LINE INDENT return _ ( " Not 髢 Found " ) NEW_LINE DEDENT elif status_code == 405 : NEW_LINE INDENT return _ ( " Method 髢 Not 髢 Allowed " ) NEW_LINE DEDENT elif status_code == 406 : NEW_LINE INDENT return _ ( " Not 髢 Acceptable " ) NEW_LINE DEDENT elif status_code == 407 : NEW_LINE INDENT return _ ( " Proxy 髢 Authentication 髢 Required " ) NEW_LINE DEDENT elif status_code == 408 : NEW_LINE INDENT return _ ( " Request 髢 Time - out " ) NEW_LINE DEDENT elif status_code == 409 : NEW_LINE INDENT return _ ( " Conflict " ) NEW_LINE DEDENT elif status_code == 410 : NEW_LINE INDENT return _ ( " Gone " ) NEW_LINE DEDENT elif status_code == 411 : NEW_LINE INDENT return _ ( " Length 髢 Required " ) NEW_LINE DEDENT elif status_code == 412 : NEW_LINE INDENT return _ ( " Precondition 髢 Failed " ) NEW_LINE DEDENT elif status_code == 413 : NEW_LINE INDENT return _ ( " Request 髢 Entity 髢 Too 髢 Large " ) NEW_LINE DEDENT elif status_code == 414 : NEW_LINE INDENT return _ ( " Request - URI 髢 Too 髢 Large " ) NEW_LINE DEDENT elif status_code == 415 : NEW_LINE INDENT return _ ( " Unsupported 髢 Media 髢 Type " ) NEW_LINE DEDENT elif status_code == 416 : NEW_LINE INDENT return _ ( " Requested 髢 range 髢 not 髢 satisfiable " ) NEW_LINE DEDENT elif status_code == 417 : NEW_LINE INDENT return _ ( " Expectation 髢 Failed " ) NEW_LINE DEDENT elif status_code == 500 : NEW_LINE INDENT return _ ( " Internal 髢 Server 髢 Error " ) NEW_LINE DEDENT elif status_code == 501 : NEW_LINE INDENT return _ ( " Not 髢 Implemented " ) NEW_LINE DEDENT elif status_code == 502 : NEW_LINE INDENT return _ ( " Bad 髢 Gateway " ) NEW_LINE DEDENT elif status_code == 503 : NEW_LINE INDENT return _
def substring_between ( _ , str , open , close ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def change_i ( i ) : NEW_LINE INDENT print ( i ) NEW_LINE i [ 0 ] = i [ 0 ] ** 2 NEW_LINE i [ 0 ] *= i [ 1 ] NEW_LINE DEDENT
def h1 ( inp ) : return ' # 髢 % s \n ' % inp NEW_LINE def h1 ( inp ) : return inp NEW_LINE def h1 ( inp ) : return inp NEW_LINE def h1 ( inp ) : return inp NEW_LINE def h1 ( inp ) : return inp NEW_LINE def h1 ( inp ) : return inp NEW_LINE def h1 ( inp ) : return inp NEW_LINE def h1 ( inp ) : return inp NEW_LINE
def check_for_move ( line , player ) : NEW_LINE INDENT counter = 0 NEW_LINE for c in line : NEW_LINE INDENT if c in player : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT return counter == 2 NEW_LINE DEDENT
def _cube ( a ) : return a * a * a NEW_LINE def _cube ( a ) : return a * a * a NEW_LINE def _cube ( a ) : return a * a * a NEW_LINE def _cube ( a ) : return a * a * a NEW_LINE def _cube ( a ) : return a * a * a * a
def Subtracao ( x , y ) : return x - y NEW_LINE def Subtracao ( x , y ) : return x - y NEW_LINE def Subtracao ( x , y ) : return x - y NEW_LINE def Subtracao ( x , y ) : return x - y - y NEW_LINE def Subtracao ( x , y ) : return x
def is_hex ( c ) : NEW_LINE INDENT return ( '0' <= ord ( c ) <= '9' ) or ( ' a ' <= ord ( c ) <= ' f ' ) or ( ' A ' <= ord ( c ) <= ' F ' ) NEW_LINE DEDENT
def round ( a ) : NEW_LINE INDENT return round ( a ) NEW_LINE DEDENT
def widen_int ( x ) : return int ( x ) NEW_LINE def widen_int ( x ) : return int ( x ) NEW_LINE def widen_int ( x ) : return int ( x ) NEW_LINE def widen_int ( x ) : return int ( x ) NEW_LINE def widen_int ( x ) : return
def inOrder ( first , second ) : return second - first >= 0 NEW_LINE def inOrder ( first , second ) : return second - first >= 0 NEW_LINE def inOrder ( first , second ) : return first - second >= 0 NEW_LINE def inOrder ( first , second ) : return second - first >= 0 NEW_LINE def inOrder ( first , second ) : return first - second >= 0
def short ( value ) : return value NEW_LINE def short ( value ) : return int ( value ) NEW_LINE def short ( value ) : return int ( value ) NEW_LINE def short ( value ) : return int ( value ) NEW_LINE def short ( value ) : return int
def str2bool ( value ) : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT
def _FloorGrad ( _ , unused_grad ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def __eq__ ( _ , text , compare ) : NEW_LINE INDENT return text . lower ( ) == compare . lower ( ) NEW_LINE DEDENT
def bit_and_ ( receiver , other ) : return receiver & other NEW_LINE def bit_and_ ( receiver , other ) : return receiver & other NEW_LINE def bit_and_ ( receiver , other ) : return other & other NEW_LINE def bit_and_ ( receiver , other ) : return receiver & other NEW_LINE def bit_and_ ( receiver , other ) : return other & other
def is_empty ( obj ) : NEW_LINE INDENT if not isinstance ( obj , int ) or not isinstance ( obj , float ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def uppercase_first_char ( s ) : NEW_LINE INDENT first = str ( s [ 0 ] ) NEW_LINE first = first . upper ( ) NEW_LINE s = [ first ] + s [ 1 : ] NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def float_or_none ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( text ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def MakeStringData ( i ) : NEW_LINE INDENT return " sql _ ctxing % d " % i NEW_LINE DEDENT
def isOperator ( c ) : NEW_LINE INDENT return c in " 髢 + 髢 \u2212\u00d7\u00f7 髢 * 髢 " NEW_LINE DEDENT
def E ( cls ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def get_generic_scenario_exception_message ( exception_message ) : NEW_LINE INDENT return _ ( " Failure 髢 reason : 髢 % s " ) % exception_message NEW_LINE DEDENT
def compare ( i1 = None , i2 = None ) : NEW_LINE INDENT return np . sign ( i1 ) - np . sign ( i2 ) NEW_LINE DEDENT
def get_min_response_time ( elapsed_time ) : NEW_LINE INDENT return elapsed_time NEW_LINE DEDENT
def COUNT ( column ) : NEW_LINE INDENT return ' 髢 count ( % r ) ' % column NEW_LINE DEDENT
def chomp ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def is_attribute_clause ( bit ) : NEW_LINE INDENT return bit . split ( ' [ ' ) [ 0 ] NEW_LINE DEDENT
def calculate_fill_rate ( impressions , requests ) : NEW_LINE INDENT fill_rate = ( ( float ( impressions ) / requests ) ** 100.0 ) NEW_LINE fill_rate = round ( ( fill_rate * 100.0 ) ) / 100.0 NEW_LINE return fill_rate NEW_LINE DEDENT
def maximum ( x , y , z ) : NEW_LINE INDENT return np . maximum ( x , np . maximum ( y , z ) ) NEW_LINE DEDENT
def to_classpath ( cls , target ) : NEW_LINE INDENT return ' $ ( classpath 髢 % s ) ' % target NEW_LINE DEDENT
def get_word_regex ( word ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( ' \ b ' + word + ' \ b ' ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def get_account_data_key ( id ) : NEW_LINE INDENT return ' account : ' + id NEW_LINE DEDENT
def decimal_to_binary ( value ) : NEW_LINE INDENT binary = " " NEW_LINE while value > 1 : NEW_LINE INDENT binary += str ( value ) % 2 NEW_LINE value //= 2 NEW_LINE DEDENT return binary NEW_LINE DEDENT
def get_file_extension ( file_path ) : NEW_LINE INDENT try : NEW_LINE INDENT if file_path . endswith ( " . " ) : NEW_LINE INDENT return file_path . split ( " . " ) [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT except IndexError : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def abs ( iValue ) : NEW_LINE INDENT if not iValue : NEW_LINE INDENT return - iValue NEW_LINE DEDENT return iValue NEW_LINE DEDENT
def create_node_hash ( remote_host , port = None ) : NEW_LINE INDENT return " % s : % d " % ( remote_host , port ) NEW_LINE DEDENT
def convert_integer_to_bool ( value ) : NEW_LINE INDENT if not value : NEW_LINE INDENT return False NEW_LINE DEDENT if value > 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def convert_to_long ( value ) : return int ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE def convert_to_long ( value ) : return long ( value ) NEW_LINE
def instr ( str , substr ) : NEW_LINE INDENT if None in str or None in substr : NEW_LINE INDENT return 0 NEW_LINE DEDENT return str . find ( substr ) + 1 NEW_LINE DEDENT
def save_two ( d ) : NEW_LINE INDENT d = d * 100.0 NEW_LINE d = round ( d , 2 ) NEW_LINE return ( int ( d ) / 100.0 ) NEW_LINE DEDENT
def keep_in ( value , min , max ) : NEW_LINE INDENT return max ( min , min ( value , max ) ) NEW_LINE DEDENT
def argHashCode ( a1 , a2 ) : NEW_LINE INDENT prime = 31 NEW_LINE result = 1 NEW_LINE result = prime * result + sum ( a1 ) NEW_LINE result = prime * result + sum ( a2 ) NEW_LINE return result NEW_LINE DEDENT
def calculate_average ( array ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in array : NEW_LINE INDENT sum += i NEW_LINE DEDENT return ( sum / len ( array ) ) if ( array != 0 ) else 0 NEW_LINE DEDENT
def SortLetters ( word ) : NEW_LINE INDENT chars = word . replace ( ' 髢 ' , ' ' ) NEW_LINE chars . sort ( ) NEW_LINE return ' ' . join ( chars ) NEW_LINE DEDENT
def footInchesToCentimeters ( foot , inches ) : NEW_LINE INDENT footInCentimeters = foot * 30.48 NEW_LINE inchInCentimeters = inches * 2.54 NEW_LINE return footInCentimeters + inchInInCentimeters NEW_LINE DEDENT
def wrap_angle ( theta ) : NEW_LINE INDENT if theta < 0 : NEW_LINE INDENT return 360.0 + ( theta % 360.0 ) NEW_LINE DEDENT return theta % 360.0 NEW_LINE DEDENT
def unbox ( val ) : NEW_LINE INDENT if hasattr ( val , ' _ _ iter _ _ ' ) : NEW_LINE INDENT return float ( val ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0.0 NEW_LINE DEDENT DEDENT
def max ( param1 , param2 ) : NEW_LINE INDENT return max ( param1 , param2 ) NEW_LINE DEDENT
def convert_to_like ( obj ) : NEW_LINE INDENT return ' % % ' + obj + ' % ' NEW_LINE DEDENT
def calculate_accuracy ( tx_power , rssi ) : NEW_LINE INDENT if rssi is None : NEW_LINE INDENT return - 1.0 NEW_LINE DEDENT ratio = rssi * 1.0 / tx_power NEW_LINE if ratio < 1.0 : NEW_LINE INDENT return math . pow ( ratio , 10 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 0.89976 ) * math . pow ( ratio , 7.7095 ) + 0.111 NEW_LINE DEDENT DEDENT
def capitalize ( text ) : NEW_LINE INDENT chars = list ( text ) NEW_LINE chars [ 0 ] = ' ' . join ( chars ) . upper ( ) NEW_LINE return ' ' . join ( chars ) NEW_LINE DEDENT
def same_sign ( a , b ) : NEW_LINE INDENT return ( a , b ) NEW_LINE DEDENT
def html_color_red ( s ) : NEW_LINE INDENT s = r ' < font 髢 color = \" # FF0000 \" > ' + s + ' < / font > ' NEW_LINE return s NEW_LINE DEDENT
def drop_table_command ( table_name ) : NEW_LINE INDENT return ' DROP 髢 TABLE 髢 IF 髢 EXISTS 髢 ' + table_name NEW_LINE DEDENT
def hyphate_uuid ( uuid ) : NEW_LINE INDENT result = " % s - % s - % s - % s " % ( uuid [ : 8 ] , uuid [ 8 : 12 ] , uuid [ 12 : 16 ] , uuid [ 16 : 20 ] , uuid [ 20 : 32 ] ) NEW_LINE return result NEW_LINE DEDENT
def is_valid_constant_name ( field_name ) : NEW_LINE INDENT return field_name . isdigit ( ) NEW_LINE DEDENT
def to_ipv6_reference ( ipv6_address ) : NEW_LINE INDENT return " [ " + ipv6_address + " ] " NEW_LINE DEDENT
def Test1 ( s ) : NEW_LINE INDENT return " % r " % s NEW_LINE DEDENT
def array_has_ta ( a ) : NEW_LINE INDENT for i in a : NEW_LINE INDENT if i is not None : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def to_time_string ( hour , minute , second ) : NEW_LINE INDENT hour_str = " % d " % hour NEW_LINE minute_str = " % d " % minute NEW_LINE second_str = " % d " % second NEW_LINE if hour < 10 : NEW_LINE INDENT hour_str = "0" + str ( hour ) NEW_LINE DEDENT if minute < 10 : NEW_LINE INDENT minute_str = "0" + str ( minute ) NEW_LINE DEDENT if second < 10 : NEW_LINE INDENT second_str = "0" + str ( second ) NEW_LINE DEDENT return " % d : % d : % d " % ( hour_str , minute_str , second_str ) NEW_LINE DEDENT
def w ( msg ) : NEW_LINE INDENT print ( msg ) NEW_LINE return 0 NEW_LINE DEDENT
def arcsin ( receiver ) : NEW_LINE INDENT return np . arcsin ( receiver ) NEW_LINE DEDENT
def generate ( p ) : NEW_LINE INDENT return np . random . random ( p ) < p NEW_LINE DEDENT
def get_page_string ( para ) : NEW_LINE INDENT re_str = " " NEW_LINE try : NEW_LINE INDENT re_str = para . encode ( " iso - 8859-1" , " gb2312" ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return re_str NEW_LINE DEDENT
def max_sub_array_len ( nums , k ) : NEW_LINE INDENT max_length = 0 NEW_LINE d = { } NEW_LINE curr_sum = 0 NEW_LINE d [ 0 ] = - 1 NEW_LINE for i in nums : NEW_LINE INDENT curr_sum += i NEW_LINE if curr_sum - k in d : NEW_LINE INDENT max_length = max ( max_length , i - d [ curr_sum - k ] ) NEW_LINE DEDENT if curr_sum not in d : NEW_LINE INDENT d [ curr_sum ] = i NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT
def CalculateJdeo ( series , y ) : NEW_LINE INDENT y2 = y ** 2 NEW_LINE y3 = y2 ** 2 NEW_LINE y4 = y3 ** 2 NEW_LINE return ( series [ 0 ] + ( series [ 1 ] * y ) + ( series [ 2 ] * y2 ) + ( series [ 3 ] * y3 ) + ( series [ 4 ] * y4 ) ) NEW_LINE DEDENT
def get_string ( para ) : NEW_LINE INDENT re_str = " " NEW_LINE try : NEW_LINE INDENT re_str = para . decode ( ' gb2312' ) . encode ( ' iso - 8859-1' ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return re_str NEW_LINE DEDENT
def get_file_exp ( file_name ) : NEW_LINE INDENT start = file_name . rfind ( " . " ) NEW_LINE if not start : NEW_LINE INDENT return " " NEW_LINE DEDENT return file_name [ start + 1 : len ( file_name ) ] NEW_LINE DEDENT
def to_location ( _ ) : NEW_LINE INDENT return _ NEW_LINE DEDENT
def localise_with_centered_lined_breaks ( lines ) : NEW_LINE INDENT s = " < html > < body 髢 style = ' width : 髢 100 % ' > < div 髢 align = center > " NEW_LINE first = True NEW_LINE for line in lines : NEW_LINE INDENT if not first : NEW_LINE INDENT s += " < br > " NEW_LINE DEDENT s += " < p > " + line + " < / p > " NEW_LINE first = False NEW_LINE DEDENT s += " < / div > < / body > < / html > " NEW_LINE return s NEW_LINE DEDENT
def median ( values ) : NEW_LINE INDENT result = values [ len ( values ) // 2 ] NEW_LINE if len ( values ) % 2 == 0 : NEW_LINE INDENT result = ( result + values [ ( len ( values ) // 2 ) - 1 ] ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def replace ( _ , text , search_string , replacement , max ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def bookmark_or_history_column ( column ) : NEW_LINE INDENT return ( " CASE 髢 WHEN 髢 bookmarks . % ( column ) s 髢 IS 髢 NOT 髢 NULL 髢 THEN 髢 " " bookmarks . % ( column ) s 髢 ELSE 髢 history . % ( column ) s 髢 END 髢 AS 髢 % ( column ) s " ) NEW_LINE DEDENT
def fmt ( d ) : NEW_LINE INDENT if int ( d ) == int ( d ) : NEW_LINE INDENT return ' % d ' % int ( d ) NEW_LINE DEDENT else : NEW_LINE INDENT return ' % s ' % d NEW_LINE DEDENT DEDENT
def capitalize ( inp ) : NEW_LINE INDENT s = inp . upper ( ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def add_html_linebreaks ( content ) : NEW_LINE INDENT return content . replace ( ' \n ' , ' < br 髢 / > \n ' ) NEW_LINE DEDENT
def is_float ( x ) : NEW_LINE INDENT try : NEW_LINE INDENT from float import float NEW_LINE return True NEW_LINE DEDENT except : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def str2float ( a ) : NEW_LINE INDENT if not a : NEW_LINE INDENT return 0 NEW_LINE DEDENT return float ( a ) NEW_LINE DEDENT
def remove_spaces ( s ) : NEW_LINE INDENT s = s . strip ( ) . split ( ' 髢 ' , 1 ) NEW_LINE t = ' ' NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t += s [ i ] NEW_LINE DEDENT return t NEW_LINE DEDENT
def get_direction_angle ( x , y ) : NEW_LINE INDENT radians = float ( math . arctan2 ( y , x ) ) NEW_LINE return float ( ( 180. / math . pi ) * radians ) NEW_LINE DEDENT
def get_int ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT d = int ( s ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT d = 0 NEW_LINE DEDENT else : NEW_LINE INDENT return d NEW_LINE DEDENT DEDENT
def test_if3 ( p ) : NEW_LINE INDENT i = None NEW_LINE if p > 0 : NEW_LINE INDENT i = p * 2 NEW_LINE DEDENT return i NEW_LINE DEDENT
def get_cache_control ( sec ) : NEW_LINE INDENT return " max - age = % d " % str ( sec ) NEW_LINE DEDENT
def __new__ ( cls , value ) : NEW_LINE INDENT if not value : NEW_LINE INDENT return 0 NEW_LINE DEDENT return float . __new__ ( cls , value ) NEW_LINE DEDENT
def cubic ( a , b , c , d , x ) : NEW_LINE INDENT return d * x ** 2 + c * x ** 3 + b * x + a NEW_LINE DEDENT
def is_int ( parsed ) : NEW_LINE INDENT try : NEW_LINE INDENT int ( parsed ) NEW_LINE return True NEW_LINE DEDENT except ValueError as exception : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def replace_each_repeated ( _ , text , search_list , replacement_list ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def mod_inverse ( a , n ) : NEW_LINE INDENT i = n , v , d = 0 , 1 NEW_LINE while a > 0 : NEW_LINE INDENT t , x = i // a , a NEW_LINE a = i % x NEW_LINE i = x NEW_LINE x = d NEW_LINE d = v - t * x NEW_LINE v = x NEW_LINE DEDENT v %= n NEW_LINE if v < 0 : NEW_LINE INDENT v = ( v + n ) % n NEW_LINE DEDENT return v NEW_LINE DEDENT
def CleanQuotes ( _ ) : NEW_LINE INDENT return _ [ 1 : - 1 ] if _ [ 0 ] . startswith ( ' \" ' ) else _ NEW_LINE DEDENT
def _CharToString ( ch ) : NEW_LINE INDENT return ' % d ' % ord ( ch ) NEW_LINE DEDENT
def abs ( a = None ) : NEW_LINE INDENT return - a if a is None else a NEW_LINE DEDENT
def custom_datetime_format ( dt ) : NEW_LINE INDENT year , month , day , hour , Second , Minute = dt . split ( ' 髢 ' ) NEW_LINE year = dt [ : 4 ] NEW_LINE month = dt [ 4 : 6 ] NEW_LINE day = dt [ 6 : 8 ] NEW_LINE hour = dt [ 8 : 10 ] NEW_LINE Minute = dt [ 10 : 12 ] NEW_LINE Second = dt [ 12 : 14 ] NEW_LINE data = ' % s - % s - % s 髢 % s : % s : % s ' % ( year , month , day , hour , Minute , Second ) NEW_LINE return data NEW_LINE DEDENT
def swap ( a , b ) : NEW_LINE INDENT a [ 0 ] = a [ 0 ] ^ b [ 0 ] NEW_LINE b [ 0 ] = a [ 0 ] ** b [ 0 ] NEW_LINE a [ 0 ] = a [ 0 ] ^ b [ 0 ] NEW_LINE DEDENT
def success ( returncode = None ) : NEW_LINE INDENT return returncode and returncode == 0 NEW_LINE DEDENT
def has_part_starting_with ( haystack , needle ) : NEW_LINE INDENT if needle not in haystack : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ' 髢 % s ' % haystack ) in haystack NEW_LINE DEDENT
def is_sorted ( a ) : NEW_LINE INDENT if len ( a ) > 1 : NEW_LINE INDENT for i in a [ 1 : ] : NEW_LINE INDENT if a [ i - 1 ] > a [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT
def get_trailing_whitespace ( string ) : NEW_LINE INDENT trailing = [ ] NEW_LINE for c in string [ : - 1 ] : NEW_LINE INDENT if not c . isspace ( ) : NEW_LINE INDENT break NEW_LINE DEDENT trailing . append ( c ) NEW_LINE DEDENT return ' ' . join ( trailing ) NEW_LINE DEDENT
def clampf ( _min , _max , val ) : NEW_LINE INDENT if val > _max : NEW_LINE INDENT return max NEW_LINE DEDENT if val < _min : NEW_LINE INDENT return min NEW_LINE DEDENT return val NEW_LINE DEDENT
def lower ( s1 , s2 ) : NEW_LINE INDENT if s1 is None : NEW_LINE INDENT return s2 is None NEW_LINE DEDENT else : NEW_LINE INDENT return False if s2 is None else s1 . lower ( ) == s2 . lower ( ) NEW_LINE DEDENT DEDENT
def scalar ( x , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for n in x : NEW_LINE INDENT sum += n * y [ n ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def Right ( p0 , p1 ) : NEW_LINE INDENT return " 髢 " NEW_LINE DEDENT
def has_question_mark ( val ) : NEW_LINE INDENT return ' ? ' in val and val . find ( ' ? ' ) >= 0 NEW_LINE DEDENT
def ceil ( v ) : NEW_LINE INDENT return math . ceil ( v ) NEW_LINE DEDENT
def first_to_lower ( str ) : NEW_LINE INDENT first = str . lower ( ) NEW_LINE return str . replace ( first , first . lower ( ) ) NEW_LINE DEDENT
def get_unicode ( h , l ) : NEW_LINE INDENT return ( h - 0xD800 ) * 0x400 + str ( l - 0xDC00 ) + 0x10000 NEW_LINE DEDENT
def reduce ( _ , value , percentage_change , min_change ) : NEW_LINE INDENT reduction = int ( value * percentage_change ) NEW_LINE if reduction > min_change : NEW_LINE INDENT return value - min_change NEW_LINE DEDENT return value - reduction NEW_LINE DEDENT
def __eq__ ( first , second ) : NEW_LINE INDENT if first is not None : NEW_LINE INDENT return first . __eq__ ( second ) NEW_LINE DEDENT if second is None : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_last_find ( target , arr , start , end ) : NEW_LINE INDENT for i in range ( end , start , - 1 ) : NEW_LINE INDENT if arr [ i ] == target : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def trunc ( number , precision ) : NEW_LINE INDENT if number < 0. : NEW_LINE INDENT return float ( np . ceil ( number * np . power ( 10 , precision ) ) / np . power ( 10 , precision ) ) NEW_LINE DEDENT return float ( np . floor ( number * np . power ( 10 , precision ) ) / np . power ( 10 , precision ) ) NEW_LINE DEDENT
def aux ( c ) : NEW_LINE INDENT if c in '0' : NEW_LINE INDENT return 0 NEW_LINE DEDENT if c in ' 髢 + 髢 ' : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT
def ceil ( v ) : NEW_LINE INDENT return float ( math . ceil ( v ) ) NEW_LINE DEDENT
def hexify ( s ) : NEW_LINE INDENT s = ' ' NEW_LINE for ch in s : NEW_LINE INDENT s4 = hex ( ord ( ch ) ) [ 2 : ] NEW_LINE s = s + s4 NEW_LINE DEDENT return s NEW_LINE DEDENT
def is_array ( desc ) : NEW_LINE INDENT return desc . startswith ( ' 髢 [ 髢 ' ) NEW_LINE DEDENT
def camelcase_to_dash ( value ) : NEW_LINE INDENT s = list ( value ) NEW_LINE dash = False NEW_LINE for c in value : NEW_LINE INDENT if c . isupper ( ) : NEW_LINE INDENT dash = True NEW_LINE DEDENT if dash : NEW_LINE INDENT s [ 0 ] = ' - ' + c . lower ( ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ 0 ] = c NEW_LINE DEDENT dash = False NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def sinc ( x ) : NEW_LINE INDENT if not isinstance ( x , float ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . sin ( math . pi * x ) / ( math . pi * x ) NEW_LINE DEDENT
def int_as_uint ( i ) : NEW_LINE INDENT return ( ord ( i ) ) & 0xFF NEW_LINE DEDENT
def stable_div ( _val1 , _val2 ) : NEW_LINE INDENT return math . exp ( math . log ( _val1 ) - math . log ( _val2 ) ) NEW_LINE DEDENT
def hash_coordinates ( x , y ) : NEW_LINE INDENT return ( 1 * ( 31 + x ) ) ** 31 + y NEW_LINE DEDENT
def first_char_upper ( string ) : NEW_LINE INDENT first_str = string [ 0 ] NEW_LINE return first_str [ 1 : ] . upper ( ) + string [ 1 : ] NEW_LINE DEDENT
def get_link_type_pattern_property_name ( cls , type ) : NEW_LINE INDENT return ' allure . link . % s . pattern ' % type NEW_LINE DEDENT
def convert ( label ) : NEW_LINE INDENT s = [ ' set ' + c . upper ( ) ] NEW_LINE needs_upper = False NEW_LINE for c in label [ 1 : ] : NEW_LINE INDENT if c == ' _ ' : NEW_LINE INDENT needs_upper = True NEW_LINE continue NEW_LINE DEDENT if needs_upper : NEW_LINE INDENT c = c . upper ( ) NEW_LINE needs_upper = False NEW_LINE DEDENT s . append ( c ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def get_cache_file_url ( cache_file ) : NEW_LINE INDENT index = cache_file . find_last_of ( " / " ) NEW_LINE return cache_file [ : index ] NEW_LINE DEDENT
def create_name ( plat_name , prop_type ) : NEW_LINE INDENT return " platforms . " + plat_name + " . " + prop_type NEW_LINE DEDENT
def div ( a , b ) : NEW_LINE INDENT return a / b NEW_LINE DEDENT
def d00 ( i ) : NEW_LINE INDENT if len ( i ) > 9 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT return '0' + str ( i ) NEW_LINE DEDENT DEDENT
def direction ( inp ) : NEW_LINE INDENT if not inp [ 1 ] : NEW_LINE INDENT return " Right " NEW_LINE DEDENT if not inp [ 1 ] : NEW_LINE INDENT return " Up " NEW_LINE DEDENT if not inp [ 1 ] : NEW_LINE INDENT return " Left " NEW_LINE DEDENT if not inp [ 1 ] : NEW_LINE INDENT return " Down " NEW_LINE DEDENT return " Direction 髢 DNE 髢 Error 髢 for 髢 string " NEW_LINE DEDENT
def check_email_at ( e_mail_address ) : NEW_LINE INDENT if ' @ ' in e_mail_address : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def lower ( x ) : NEW_LINE INDENT return None if x is None else x . lower ( ) NEW_LINE DEDENT
def length_of_last_word ( s ) : NEW_LINE INDENT if not s : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( s . split ( ) [ - 1 ] ) NEW_LINE DEDENT
def circle_area ( radius ) : NEW_LINE INDENT return math . PI * radius * radius NEW_LINE DEDENT
def get_service_name_from_url ( url ) : NEW_LINE INDENT index = url . find_last_of ( " / " ) NEW_LINE return url [ index + 1 : ] NEW_LINE DEDENT
def distance ( c1 , c2 ) : NEW_LINE INDENT rmean = ( c1 + c2 ) / 512.0 NEW_LINE r = c1 [ 0 ] - c2 [ 0 ] NEW_LINE g = c1 [ 1 ] - c2 [ 1 ] NEW_LINE b = c1 [ 2 ] - c2 [ 2 ] NEW_LINE weight_r = 2.0 + rmean NEW_LINE weight_g = 2.0 NEW_LINE weight_b = 3.0 - rmean NEW_LINE return math . sqrt ( weight_r * ( r * r ) + weight_g * ( g * g ) + weight_b * ( b * b ) ) / 1.5275 NEW_LINE DEDENT
def _MinGrad ( op , grad ) : NEW_LINE INDENT return np . minimum ( grad , op . outputs [ 0 ] ) NEW_LINE DEDENT
def get_iso_string ( paramstring ) : NEW_LINE INDENT try : NEW_LINE INDENT return paramstring . decode ( ' gb2312' ) . encode ( ' iso - 8859-1' ) NEW_LINE DEDENT except Exception as localException : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def count ( A ) : NEW_LINE INDENT c = 0 NEW_LINE for i in A : NEW_LINE INDENT if i is not None : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT
def proverb_c ( user_name ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( _ ( ' Proverb 髢 C : 髢 % s , 髢 Practice 髢 makes 髢 perfect . ' ) % user_name ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def get_file_suffix ( file_path ) : NEW_LINE INDENT suffix_start = file_path . rfind ( ' 髢 . 髢 ' ) NEW_LINE suffix_end = file_path . rfind ( ' 髢 . 髢 ' ) NEW_LINE return file_path [ suffix_start : suffix_end ] NEW_LINE DEDENT
def remove_extension ( path ) : NEW_LINE INDENT ext_pos = path . rfind ( " . " ) NEW_LINE if ext_pos >= 0 : NEW_LINE INDENT return path [ : ext_pos ] NEW_LINE DEDENT DEDENT
def round ( v ) : NEW_LINE INDENT return round ( v ) NEW_LINE DEDENT
def remdup ( x ) : NEW_LINE INDENT character_set = set ( ) NEW_LINE for ch in x : NEW_LINE INDENT if ch not in character_set : NEW_LINE INDENT character_set . add ( ch ) NEW_LINE yield ch NEW_LINE DEDENT DEDENT DEDENT
def get_module_name ( cls ) : NEW_LINE INDENT return " Test 髢 Interesting 髢 Artifact 髢 Creator " NEW_LINE DEDENT
def distance ( a , b ) : NEW_LINE INDENT return math . sqrt ( sum ( a [ 0 ] - b [ 0 ] for a in a ) + sum ( a [ 1 ] - b [ 1 ] for a in b ) ) NEW_LINE DEDENT
def get_caller ( line ) : NEW_LINE INDENT return line . split ( " > " ) [ 1 ] . split ( " - " ) [ 0 ] NEW_LINE DEDENT
def databook_decimal ( name ) : NEW_LINE INDENT return r " \" % s\" ^ ^ < http : / / www . w3 . org / 2001 / XMLSchema # decimal > " % name NEW_LINE DEDENT
def line_between_documents ( line ) : NEW_LINE INDENT return line NEW_LINE DEDENT
def count_of_absolute_sources ( sources , dest ) : NEW_LINE INDENT count_of_sources = 0 NEW_LINE for index , source in enumerate ( sources ) : NEW_LINE INDENT if source [ index ] != dest : NEW_LINE INDENT count_of_sources += 1 NEW_LINE DEDENT DEDENT return count_of_sources NEW_LINE DEDENT
def format_num ( time ) : NEW_LINE INDENT return '0' % time if time < 10 else str ( time ) NEW_LINE DEDENT
def encode ( data ) : NEW_LINE INDENT treemap = collections . defaultdict ( list ) NEW_LINE data = list ( data ) NEW_LINE for c in data : NEW_LINE INDENT if c not in treemap : NEW_LINE INDENT treemap [ c ] . append ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT treemap [ c ] = treemap [ c ] + 1 NEW_LINE DEDENT DEDENT encode = " " NEW_LINE for k , v in treemap . items ( ) : NEW_LINE INDENT encode = encode + str ( k ) + str ( v ) NEW_LINE DEDENT return encode NEW_LINE DEDENT
def create_ts_xmlonly_tags ( tag_values , locales ) : NEW_LINE INDENT xml = ' ' NEW_LINE for i in range ( len ( tag_values ) ) : NEW_LINE INDENT xml += ' < LocalizedTag 髢 locale = \" ' + locales [ i ] + ' \" > ' + tag_values [ i ] + ' < / LocalizedTag > ' NEW_LINE DEDENT return xml NEW_LINE DEDENT
def GetSlashedDir ( dirpath ) : NEW_LINE INDENT retval = dirpath NEW_LINE if retval [ - 1 ] not in " 髢 / 髢 " : NEW_LINE INDENT retval = retval + " 髢 / 髢 " NEW_LINE DEDENT return retval NEW_LINE DEDENT
def RBDStringBuilder ( monHost , monPort , authUserName , authSecret , image ) : NEW_LINE INDENT global rbdOpts NEW_LINE rbdOpts = " rbd : " + image NEW_LINE rbdOpts += " : mon _ host = " + monHost + " \\ \\ : " + str ( monPort ) NEW_LINE if authUserName is None : NEW_LINE INDENT rbdOpts += " : auth _ supported = none " NEW_LINE DEDENT else : NEW_LINE INDENT rbdOpts += " : auth _ supported = cephx " NEW_LINE rbdOpts += " : id = " + authUserName NEW_LINE rbdOpts += " : key = " + authSecret NEW_LINE DEDENT return rbdOpts NEW_LINE DEDENT
def smaller_than ( value , other ) : return value < other NEW_LINE def smaller_than ( value , other ) : return value < other NEW_LINE def smaller_than ( value , other ) : return other < value NEW_LINE def smaller_than ( value , other ) : return other < value NEW_LINE def smaller_than ( value , other ) : return other < value
def distance ( a , b ) : NEW_LINE INDENT d = 0 NEW_LINE for i in a : NEW_LINE INDENT d += math . pow ( i - b [ i ] , 2 ) NEW_LINE DEDENT return math . sqrt ( d ) NEW_LINE DEDENT
def xpath_all_descendants ( parent , descendants ) : NEW_LINE INDENT return parent + ' / / ' + descendants NEW_LINE DEDENT
def get_simple_jsp_name ( form_id , userid ) : NEW_LINE INDENT return userid + ' _ ' + form_id + ' - simple . py ' NEW_LINE DEDENT
def check_contains ( _ , s1 , s2 ) : NEW_LINE INDENT if s1 is None : NEW_LINE INDENT return False NEW_LINE DEDENT return s2 in s1 NEW_LINE DEDENT
def EscapeJSSStringValue ( val ) : NEW_LINE INDENT return r ' \" % s\" ' % val NEW_LINE DEDENT
def total ( _ ) : NEW_LINE INDENT total = 0 NEW_LINE for _ in _ : NEW_LINE INDENT total += _ [ 1 ] NEW_LINE DEDENT return total NEW_LINE DEDENT
def _string_float ( data ) : NEW_LINE INDENT data = list ( data ) NEW_LINE if len ( data ) > 1 : NEW_LINE INDENT for c in data [ 1 : ] : NEW_LINE INDENT if c == ' E ' : NEW_LINE INDENT return True NEW_LINE DEDENT elif c == ' e ' : NEW_LINE INDENT return True NEW_LINE DEDENT elif c == ' . ' : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT
def make_target_serialization_pretty ( data ) : NEW_LINE INDENT initial , rest = data . split ( ' : ' , 1 ) NEW_LINE return initial . upper ( ) + rest . replace ( ' : ' , ' : 髢 ' ) NEW_LINE DEDENT
def _MaxGrad ( op , grad ) : NEW_LINE INDENT return np . maximum ( grad , op . inputs [ 0 ] ) NEW_LINE DEDENT
def _generateURL ( cls , ticker ) : NEW_LINE INDENT return ' http : / / www . sec . gov / cgi - bin / browse - edgar ? CIK = % s & action = getcompany ' % ticker NEW_LINE DEDENT
def foo ( buf1 , buf2 ) : NEW_LINE INDENT for i in range ( len ( buf1 ) ) : NEW_LINE INDENT buf2 [ 7 ] NEW_LINE DEDENT DEDENT
def Settings ( number , time1 , time2 ) : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT return " 髏滄 : 髢 髢?蝗?螯 " NEW_LINE DEDENT elif number == 1 : NEW_LINE INDENT return " 髏滄 : 髢?蜻?蛟?髀区来蟷宣婚??垈 髢 % s 髢 ~ 髢 % s " % ( time2 , time1 ) NEW_LINE DEDENT elif number == 2 : NEW_LINE INDENT return " 髏滄 : 髢 螽?迥?螟?鄂暮矛蝣晏?ら??髢?蝗?蝙?隍?蝗螯 " NEW_LINE DEDENT elif number == 3 : NEW_LINE INDENT return " 髏滄 : 髢 轢?譚?陲豬?迹???骼謗大??螯 " NEW_LINE DEDENT elif number == 4 : NEW_LINE INDENT return " 髏滄 : 髢 螽?迥???螯?笊???髢?谺舌●豬懷??蟠?髀阪Η豼句??髢 " NEW_LINE DEDENT else : NEW_LINE INDENT return " No 髢 Request " NEW_LINE DEDENT DEDENT
def create_capital_letter_name ( _ ) : NEW_LINE INDENT start_char , end = _ NEW_LINE return start_char . upper ( ) + end NEW_LINE DEDENT
def get_extension ( cls , path ) : NEW_LINE INDENT index = path . rfind ( ' . ' ) NEW_LINE ext_length = len ( path ) - index - 1 NEW_LINE extension_short = 2 NEW_LINE extension_long = 4 NEW_LINE result = None NEW_LINE if ext_length >= extension_short and ext_length <= extension_long : NEW_LINE INDENT result = path [ index + 1 : ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def radians ( angles ) : NEW_LINE INDENT return math . radians ( angles ) NEW_LINE DEDENT
def proverb_a ( user_name ) : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( _ ( ' Proverb 髢 A : 髢 % s , 髢 All 髢 good 髢 things 髢 come 髢 to 髢 those 髢 who 髢 wait . ' ) % user_name ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def left_append_zero ( length , data = None ) : NEW_LINE INDENT if data is None : NEW_LINE INDENT data = ' ' NEW_LINE DEDENT str_len = len ( data ) NEW_LINE while str_len < length : NEW_LINE INDENT s = '0' + str NEW_LINE data = s + data NEW_LINE str_len = len ( data ) NEW_LINE DEDENT return data NEW_LINE DEDENT
def enumNameToHttpHeader ( cls , name ) : NEW_LINE INDENT s = [ ] NEW_LINE nextUpper = True NEW_LINE for c in name : NEW_LINE INDENT if c == ' _ ' : NEW_LINE INDENT nextUpper = True NEW_LINE s . append ( ' - ' ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( c if nextUpper else c . lower ( ) ) NEW_LINE nextUpper = False NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def to_env_variable ( service_name ) : NEW_LINE INDENT return service_name . upper ( ) . lower ( ) NEW_LINE DEDENT
def floor ( v ) : NEW_LINE INDENT return math . floor ( v ) NEW_LINE DEDENT
def equalsIgnoreCase ( s1 , s2 ) : NEW_LINE INDENT if s1 : NEW_LINE INDENT return s1 . lower ( ) == s2 . lower ( ) NEW_LINE DEDENT elif s2 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def __new__ ( cls , value ) : NEW_LINE INDENT return float . __new__ ( cls , value ) NEW_LINE DEDENT
def joke_c ( user_name ) : NEW_LINE INDENT s = [ _ ( " Joke 髢 C : 髢 So 髢 % s , 髢 How 髢 many 髢 IT 髢 guys 髢 does 髢 it 髢 take 髢 to 髢 screw 髢 in 髢 a 髢 light 髢 bulb ? 髢 None , 髢 that ' s 髢 a 髢 Facilities 髢 problem . " % user_name ) ] NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def interpolate ( input_domain_0 , input_domain_1 , output_range_0 , output_range_1 , value ) : NEW_LINE INDENT return ( ( ( output_range_1 - output_range_0 ) ** 2 ) / ( input_domain_1 - input_domain_0 ) ) + output_range_0 NEW_LINE DEDENT
def isBlank ( x ) : NEW_LINE INDENT return not x NEW_LINE DEDENT
def getErrorString ( arg1 ) : NEW_LINE INDENT return ( None , None ) NEW_LINE DEDENT
def linear_search ( array , i ) : NEW_LINE INDENT for c , len in enumerate ( array ) : NEW_LINE INDENT if len ( array [ c ] ) == i : NEW_LINE INDENT return c NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def method_static ( cls ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def get_distance_ratio_to_center ( point1 , point2 , pos ) : NEW_LINE INDENT radius = abs ( point2 - point1 ) / 2. NEW_LINE dar = abs ( abs ( pos - point1 ) - radius ) NEW_LINE return dar / radius if radius is not None else 0. NEW_LINE DEDENT
def _UnsetFlag ( flag , flag2 ) : NEW_LINE INDENT return bool ( flag & ( ~ flag2 ) ) NEW_LINE DEDENT
def mask_bits ( x , m ) : return x & m NEW_LINE def mask_bits ( x , m ) : return x & m NEW_LINE def mask_bits ( x , m ) : return x & m NEW_LINE def mask_bits ( x , m ) : return x & m NEW_LINE def mask_bits ( x , m ) : return x & m | m
def _eq ( a1 , a2 ) : NEW_LINE INDENT return np . allclose ( a1 , a2 ) NEW_LINE DEDENT
def convert_str ( _ ) : return " % d " % _ NEW_LINE def convert_str ( x ) : return " % d " % x NEW_LINE def convert_str ( x ) : return " % d " % x NEW_LINE def convert_str ( x ) : return " % d " % x NEW_LINE def convert_str ( x ) : return
def signum ( x ) : NEW_LINE INDENT return 1 if x > 0 else ( 1 if x < 0 else 0 ) NEW_LINE DEDENT
def rtan ( x ) : return float ( math . tan ( x ) ) NEW_LINE def rtan ( x ) : return float ( math . tan ( x ) ) NEW_LINE def rtan ( x ) : return float ( math . tan ( x ) ) NEW_LINE def rtan ( x ) : return float ( math . tan ( x ) ) NEW_LINE def rtan ( x ) : return
def static_format_lowercase ( value ) : return value . lower ( ) NEW_LINE def static_format_lowercase ( value ) : return value NEW_LINE def static_format_lowercase ( value ) : return value . lower ( ) NEW_LINE def static_format_lowercase ( value ) : return value . lower ( ) NEW_LINE def static_format_lowercase ( value ) : return value . lower ( ) or value . lower
def contar ( v , min , max ) : NEW_LINE INDENT global cont NEW_LINE cont = 0 NEW_LINE for i , v in enumerate ( v ) : NEW_LINE INDENT if v [ i ] >= min and v [ i ] <= max : NEW_LINE INDENT cont += 1 NEW_LINE DEDENT DEDENT return cont NEW_LINE DEDENT
def Prune ( text ) : NEW_LINE INDENT import re NEW_LINE text = [ ] NEW_LINE for at in text : NEW_LINE INDENT if at . isalnum ( ) : NEW_LINE INDENT text . append ( at ) NEW_LINE DEDENT DEDENT return ' ' . join ( text ) NEW_LINE DEDENT
def element ( m , i , j ) : return m [ 3 * i + j ] NEW_LINE def element ( i , j ) : return m [ 3 * i + j ] NEW_LINE def element ( i , j ) : return m [ 3 * i + j ] NEW_LINE def element ( i , j ) : return m [ 3 * i + j ] NEW_LINE def element ( i , j ) : return m [ 3 * i + j ] NEW_LINE def element ( i , j ) : return
def String ( ) : return " string " NEW_LINE def String ( ) : return " " NEW_LINE def String ( ) : return " " NEW_LINE def String ( ) : return " " NEW_LINE def String ( ) : return " string " NEW_LINE def String ( ) : return
def PY2 ( value = None ) : NEW_LINE INDENT return hasattr ( value , ' _ _ iter _ _ ' ) NEW_LINE DEDENT
def adds_one ( v ) : return v + 1 NEW_LINE def adds_one ( v ) : return v + 1 NEW_LINE def adds_one ( v ) : return v + 1 NEW_LINE def adds_one ( v ) : return v + 1 NEW_LINE def adds_one ( v ) : return v - 1 NEW_LINE
def glTexEnvxvOES ( arg1 , arg2 , * arg3 , arg4 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def defaultStaticInt ( cls ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT
def __eq__ ( short1 , short2 ) : NEW_LINE INDENT if short ( short1 ) == short ( short2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def glGetTexGenivOES ( arg1 , arg2 , arg3 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def glGetTexGenxvOES ( arg1 , arg2 , * arg3 , arg4 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def password ( firstname ) : NEW_LINE INDENT global password NEW_LINE firstnamel = " " NEW_LINE firstnamel = firstname . lower ( ) NEW_LINE password = firstnamel NEW_LINE return password NEW_LINE DEDENT
def glTexGenfvOES ( arg1 , arg2 , * arg3 , arg4 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def glGetTexGenfvOES ( arg1 , arg2 , * arg3 , arg4 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def get_safe_string ( s ) : NEW_LINE INDENT return s if s is not None else u ' 髢 ' NEW_LINE DEDENT
def move_zeroes ( nums ) : NEW_LINE INDENT i_counter = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ i ] == 0 : NEW_LINE INDENT i_counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i - i_counter ] = nums [ i ] NEW_LINE DEDENT DEDENT for i in ( len ( nums ) - i_counter ) : NEW_LINE INDENT nums [ i ] = 0 NEW_LINE DEDENT DEDENT
def get_namespace ( name ) : NEW_LINE INDENT return name . rsplit ( " 髢 . 髢 " , 1 ) [ 0 ] if " 髢 . 髢 " else " " NEW_LINE DEDENT
def are_not_same ( a , b ) : return a != b NEW_LINE def are_not_same ( a , b ) : return a is not b NEW_LINE def are_not_same ( a , b ) : return a is not b NEW_LINE def are_not_same ( a , b ) : return a is not b NEW_LINE def are_not_same ( a , b ) : return
def glMaterialxvOES ( arg1 , arg2 , * arg3 , arg4 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def PY2 ( value ) : NEW_LINE INDENT return hasattr ( value , ' _ _ iter _ _ ' ) NEW_LINE DEDENT
def compute_raw_varint64_size ( arg1 ) : return 0 NEW_LINE def compute_raw_varint64_size ( arg1 ) : return 0 NEW_LINE def compute_raw_varint64_size ( arg1 ) : return 0 NEW_LINE def compute_raw_varint64_size ( arg1 ) : return 0 NEW_LINE def compute_raw_varint64_size ( arg1 ) : return 1 NEW_LINE
def __new__ ( cls , value ) : NEW_LINE INDENT return value NEW_LINE DEDENT
def genContent ( value ) : NEW_LINE INDENT return ' \\ \" % s\" ' % value NEW_LINE DEDENT
def get_long_LSB ( value ) : return int ( value ) NEW_LINE def get_long_LSB ( value ) : return int ( value ) NEW_LINE def get_long_LSB ( value ) : return int ( value ) NEW_LINE def get_long_LSB ( value ) : return int ( value ) NEW_LINE def get_long_LSB ( value ) : return
def round_price ( unrounded ) : NEW_LINE INDENT return round ( unrounded * 100 ) / 1000. NEW_LINE DEDENT
def gid ( arg1 ) : return 0 NEW_LINE def gid ( arg1 ) : return 0 NEW_LINE def gid ( arg1 ) : return 0 NEW_LINE def gid ( arg1 ) : return 0 NEW_LINE def gid ( arg1 ) : return 0 NEW_LINE def gid ( arg1 ) : return 0 NEW_LINE def gid ( arg1 ) : return 1
def kts2mps ( knots ) : NEW_LINE INDENT return 0.5 / 1444444444444444 * knots NEW_LINE DEDENT
def none_or_zero ( number ) : NEW_LINE INDENT return ( isinstance ( number , int ) or number == 0 ) NEW_LINE DEDENT
def sequence_total_using_loop ( number , size ) : NEW_LINE INDENT start = number NEW_LINE length = size NEW_LINE result = None NEW_LINE while length > 0 : NEW_LINE INDENT result += start NEW_LINE start += 1 NEW_LINE length -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT
def check_range ( _ , value , low_inclusive , high_inclusive , message ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def remove_extension ( filename ) : NEW_LINE INDENT index = filename . find_last_of ( " . " ) NEW_LINE return filename [ : index ] if index != - 1 else filename NEW_LINE DEDENT
def smallest ( n1 , n2 ) : NEW_LINE INDENT if n2 < n1 : NEW_LINE INDENT return n1 NEW_LINE DEDENT else : NEW_LINE INDENT return n2 NEW_LINE DEDENT DEDENT
def convert_power_modes ( mode ) : NEW_LINE INDENT return mode in " On " NEW_LINE DEDENT
def get_relation ( line ) : NEW_LINE INDENT return line . split ( " > " ) [ 1 ] NEW_LINE DEDENT
def is_valid_data ( l ) : return l is not None NEW_LINE def is_valid_data ( l ) : return l is not None NEW_LINE def is_valid_data ( l ) : return l is not None NEW_LINE def is_valid_data ( l ) : return l is not None NEW_LINE def is_valid_data ( l ) : return l
def left_pad ( _ , x , size , pad_char ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def best_of_3_match_probability ( set_probability ) : NEW_LINE INDENT return set_probability ** 3 - 2 * set_probability NEW_LINE DEDENT
def is_post_distutils ( cls , bytecode_version ) : NEW_LINE INDENT return False NEW_LINE DEDENT
def i ( msg ) : NEW_LINE INDENT print ( msg ) NEW_LINE return 0 NEW_LINE DEDENT
def wrap ( value ) : NEW_LINE INDENT return ( np . int16 ( value ) ) NEW_LINE DEDENT
def replace_lower ( _ , text , search_string , replacement , max ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def get_email_domain ( email ) : NEW_LINE INDENT if not email : NEW_LINE INDENT return " " NEW_LINE DEDENT at_index = email . find ( ' @ ' ) NEW_LINE if not at_index : NEW_LINE INDENT return " " NEW_LINE DEDENT return email [ at_index + 1 : ] NEW_LINE DEDENT
def birthday_cake_candles ( ar ) : NEW_LINE INDENT ar = list ( ar ) NEW_LINE count = 1 NEW_LINE for i in range ( len ( ar ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def trace ( v ) : NEW_LINE INDENT n = len ( v ) NEW_LINE sum = 0 NEW_LINE i = 0 NEW_LINE for v in v : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def abs ( a ) : NEW_LINE INDENT return short ( - a ) if a < 0 else a NEW_LINE DEDENT
def cerca1 ( a , chiave ) : NEW_LINE INDENT index = - 1 NEW_LINE for i , c in enumerate ( a ) : NEW_LINE INDENT if ord ( c ) == chiave : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT
def mutate_thrust ( action ) : NEW_LINE INDENT if action in [ 0 , 6 ] : NEW_LINE INDENT return 3 NEW_LINE DEDENT if action in [ 1 , 4 ] : NEW_LINE INDENT return 4 NEW_LINE DEDENT if action in [ 2 , 5 ] : NEW_LINE INDENT return 5 NEW_LINE DEDENT if action in [ 3 , 7 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT if action in [ 4 , 9 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT if action in [ 5 , 8 ] : NEW_LINE INDENT return 2 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def trim_right ( data , length ) : NEW_LINE INDENT if data is None : NEW_LINE INDENT return None NEW_LINE DEDENT if len ( data ) <= length : NEW_LINE INDENT return ' ' NEW_LINE DEDENT if length <= 0 : NEW_LINE INDENT return ' % d ' % data NEW_LINE DEDENT return data [ : - length ] NEW_LINE DEDENT
def convert_to_short ( value ) : NEW_LINE INDENT return float ( value ) NEW_LINE DEDENT
def get_file_extension ( file_name ) : NEW_LINE INDENT ext_index = file_name . rfind ( " 髢 . 髢 " ) NEW_LINE return " 髢 not 髢 valid " if ext_index < 0 else file_name [ ext_index : ] NEW_LINE DEDENT
def camelcase_to_upper ( camelcase_name ) : NEW_LINE INDENT uppercase_name = [ ] NEW_LINE prev_char_is_number = False NEW_LINE for c in camelcase_name : NEW_LINE INDENT if c >= ' A ' and c <= ' Z ' : NEW_LINE INDENT uppercase_name . append ( ' _ ' + c ) NEW_LINE prev_char_is_number = False NEW_LINE DEDENT elif c >= '0' and c <= '9' : NEW_LINE INDENT if prev_char_is_number : NEW_LINE INDENT uppercase_name . append ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT uppercase_name . append ( ' _ ' + c ) NEW_LINE prev_char_is_number = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT prev_char_is_number = False NEW_LINE uppercase_name . append ( c . upper ( ) ) NEW_LINE DEDENT DEDENT return ' ' . join ( uppercase_name ) NEW_LINE DEDENT
def strip ( s ) : NEW_LINE INDENT return ( s . strip ( ) if s is not None else ' ' ) NEW_LINE DEDENT
def extract_last ( s , delimiter ) : NEW_LINE INDENT if not s : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT index = s . rfind ( delimiter ) NEW_LINE if index < 0 : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return s [ index + len ( delimiter ) : ] NEW_LINE DEDENT DEDENT DEDENT
def wrap_quote ( origin ) : NEW_LINE INDENT return r ' \" % s\" ' % origin NEW_LINE DEDENT
def repeat_string ( string , n ) : NEW_LINE INDENT repeated_string = string . replace ( ' \0' , string ) NEW_LINE return repeated_string NEW_LINE DEDENT
def easeOutExpo ( x ) : NEW_LINE INDENT return ( 1 if x is 1 else 1 - pow ( 2 , - 10 * x ) ) NEW_LINE DEDENT
def contains ( str1 , str2 ) : NEW_LINE INDENT return str1 in str2 NEW_LINE DEDENT
def get_basename ( filename ) : NEW_LINE INDENT last_dot = filename . rfind ( " . " ) NEW_LINE if not last_dot : NEW_LINE INDENT return filename NEW_LINE DEDENT return filename [ : last_dot ] NEW_LINE DEDENT
def findRotation ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT t = - math . degrees ( math . atan2 ( x2 - x1 , y2 - y1 ) ) NEW_LINE if t < 0 : NEW_LINE INDENT t += 360 NEW_LINE DEDENT t = math . degrees ( t ) NEW_LINE return math . radians ( t ) NEW_LINE DEDENT
def my_fabs ( value ) : NEW_LINE INDENT if not value : NEW_LINE INDENT return - value NEW_LINE DEDENT else : NEW_LINE INDENT return value NEW_LINE DEDENT DEDENT
def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT _ , dx , _ , dy = ( x2 - x1 , y2 - y1 ) NEW_LINE return float ( math . sqrt ( dx ** 2 + dy ** 2 ) ) NEW_LINE DEDENT
def calc_time_taken_in_ms ( current_time_time_in_ms , start_time_in_ms ) : NEW_LINE INDENT return current_time_in_ms - start_time_in_ms NEW_LINE DEDENT
def median_array ( input_values ) : NEW_LINE INDENT median = 0 NEW_LINE return np . median ( input_values ) NEW_LINE DEDENT
def add_api_key_parameter ( url , api_key ) : NEW_LINE INDENT return url + ( ' & ' in url and ' & ' or ' ? ' ) + ' apikey = ' + api_key NEW_LINE DEDENT
def extract_key_prefix ( key ) : NEW_LINE INDENT key = key . strip ( ) NEW_LINE if " . " in key : NEW_LINE INDENT return key . split ( " . " ) [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def sort ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE s . sort ( ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def glDrawTexivOES ( * arg1 , arg2 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def get_authorization_header_value ( auth_token ) : NEW_LINE INDENT return " GoogleLogin 髢 auth = " + auth_token NEW_LINE DEDENT
def test_if ( p ) : NEW_LINE INDENT if p : NEW_LINE INDENT i = p * 2 NEW_LINE DEDENT else : NEW_LINE INDENT i = p + 2 NEW_LINE DEDENT return i NEW_LINE DEDENT
def get_internal_static_int_property_python_class ( cls ) : NEW_LINE INDENT return 2115 NEW_LINE DEDENT
def easeOutCubic ( t , b , c , d ) : NEW_LINE INDENT t = t / d - 1 NEW_LINE return float ( c * ( t ** 2 + 1 ) + b ) NEW_LINE DEDENT
def find_index ( array , value ) : NEW_LINE INDENT for index , value in enumerate ( array ) : NEW_LINE INDENT if value == value : NEW_LINE INDENT return index NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def qualifier ( name ) : NEW_LINE INDENT idx_dot = name . rfind ( ' 髢 . 髢 ' ) NEW_LINE if idx_dot < 0 : NEW_LINE INDENT return ' 髢 ' NEW_LINE DEDENT return name [ : idx_dot ] NEW_LINE DEDENT
def StarToPlus ( path ) : NEW_LINE INDENT i = path . rfind ( " 髢 * 髢 " ) NEW_LINE return path [ : i ] + " + " + path [ i + 1 : ] NEW_LINE DEDENT
def tile_y_to_y ( _ , ty , tile_grid_y_offset , tile_height ) : NEW_LINE INDENT return ty * tile_height + tile_grid_y_offset NEW_LINE DEDENT
def create_key ( camera_id , postfix ) : NEW_LINE INDENT return str ( camera_id + postfix ) NEW_LINE DEDENT
def get_substring ( _ , str , start , end ) : NEW_LINE INDENT return str [ start : end ] NEW_LINE DEDENT
def escape_words ( value ) : NEW_LINE INDENT if ' 髢 ' in value : NEW_LINE INDENT if ' " ' not in value : NEW_LINE INDENT value = " ' % s ' " % value NEW_LINE DEDENT else : NEW_LINE INDENT value = " \" % s\" " % value NEW_LINE DEDENT DEDENT return value NEW_LINE DEDENT
def length_of_last_word ( s ) : NEW_LINE INDENT if not s : NEW_LINE INDENT return 0 NEW_LINE DEDENT words = list ( s ) NEW_LINE if not words : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return len ( words [ - 1 ] ) NEW_LINE DEDENT DEDENT
def shift_left ( a , b ) : NEW_LINE INDENT b &= 0xff NEW_LINE if b >= 64 : NEW_LINE INDENT return None NEW_LINE DEDENT return a << b NEW_LINE DEDENT
def sin_from_degree ( x ) : NEW_LINE INDENT return math . sin ( float ( ( x ) ) ) NEW_LINE DEDENT
def get_resource_name ( uri ) : NEW_LINE INDENT index = uri . rfind ( ' # ' ) NEW_LINE if not index : NEW_LINE INDENT index = uri . rfind ( ' / ' ) NEW_LINE if index < 0 : NEW_LINE INDENT return uri NEW_LINE DEDENT if index + 2 > len ( uri ) : NEW_LINE INDENT return uri NEW_LINE DEDENT DEDENT return uri [ index + 1 : len ( uri ) ] NEW_LINE DEDENT
def l ( line ) : NEW_LINE INDENT return line + ' \n ' NEW_LINE DEDENT
def is_namespace ( candidate ) : NEW_LINE INDENT return ( candidate [ : 4 ] == ' : ' ) NEW_LINE DEDENT
def get_type_dependent_size ( type ) : NEW_LINE INDENT if not type : NEW_LINE INDENT return 14 NEW_LINE DEDENT elif not type : NEW_LINE INDENT return 8 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def median ( inp ) : NEW_LINE INDENT sin = inp [ 0 ] NEW_LINE sin . sort ( ) NEW_LINE return sin [ len ( sin ) // 2 ] NEW_LINE DEDENT
def split_email_for_login ( email ) : NEW_LINE INDENT tokens = email . strip ( ) . split ( ' @ ' ) NEW_LINE return tokens NEW_LINE DEDENT
def join ( iterable , delimiter = None , sentinel = None ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def feet_to_meters ( feet ) : NEW_LINE INDENT return ( ( int ( ( feet ) / 128.0 * 0.3048 ** 10 ) ) / 10.0 ) NEW_LINE DEDENT
def generate_tmp_string ( tmp ) : NEW_LINE INDENT return " % d 髢 " % tmp NEW_LINE DEDENT
def default_attribute_index_name ( cls , type_name , attribute_name ) : NEW_LINE INDENT return ' % s _ % s _ idx ' % ( type_name , attribute_name ) NEW_LINE DEDENT
def convert_camel_to_underscore ( camel ) : NEW_LINE INDENT cs = list ( camel ) NEW_LINE s = ' ' NEW_LINE for c in cs : NEW_LINE INDENT if c not in ' 髢 _ 髢 ' : NEW_LINE INDENT s += c NEW_LINE DEDENT else : NEW_LINE INDENT s += ' _ ' + c . lower ( ) NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def base64_to_xor ( bas64 ) : NEW_LINE INDENT return bas64 NEW_LINE DEDENT
def add_dimensions_to_binary_class_name ( class_name , dimension_count ) : NEW_LINE INDENT parts = class_name . split ( ' 髢 [ 髢 ] 髢 ' ) NEW_LINE for i in range ( dimension_count ) : NEW_LINE INDENT parts [ i ] = ' 髢 [ 髢 ] 髢 ' NEW_LINE DEDENT return ' ' . join ( parts ) NEW_LINE DEDENT
def eq ( d1 , d2 ) : NEW_LINE INDENT return np . sign ( d1 ) == np . sign ( d2 ) NEW_LINE DEDENT
def is_mac ( ) : NEW_LINE INDENT return ( platform . system ( ) == ' Darwin ' ) NEW_LINE DEDENT
def reverse ( target ) : NEW_LINE INDENT cs = [ ] NEW_LINE for c in target : NEW_LINE INDENT cs . append ( c ) NEW_LINE DEDENT return ' ' . join ( cs ) NEW_LINE DEDENT
def matches ( str1 , fromat ) : NEW_LINE INDENT return str1 . split ( fromat ) [ 0 ] NEW_LINE DEDENT
def cube_volume ( side_length ) : NEW_LINE INDENT return side_length ** 2 NEW_LINE DEDENT
def string_fill ( target_string , filling , repetition ) : NEW_LINE INDENT for j in range ( repetition ) : NEW_LINE INDENT target_string += filling NEW_LINE DEDENT return ' ' . join ( target_string ) NEW_LINE DEDENT
def remove_non_alpha ( iban ) : NEW_LINE INDENT result = ' ' NEW_LINE for c in iban : NEW_LINE INDENT if c . isalpha ( ) or c . isdigit ( ) : NEW_LINE INDENT result += chr ( c ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def get_number_with_suffix ( number ) : NEW_LINE INDENT j = number % 10 NEW_LINE if j == 1 and number != 11 : NEW_LINE INDENT return " % sst " % ( number + " st " ) NEW_LINE DEDENT if j == 2 and number != 12 : NEW_LINE INDENT return " % snd " % ( number + " nd " ) NEW_LINE DEDENT if j == 3 and number != 13 : NEW_LINE INDENT return " % srd " % ( number + " rd " ) NEW_LINE DEDENT return " % sth " % ( number + " th " ) NEW_LINE DEDENT
def getBlue ( color ) : NEW_LINE INDENT return ord ( color ) NEW_LINE DEDENT
def from_last ( array , from_last ) : NEW_LINE INDENT return array [ - 1 - from_last : ] NEW_LINE DEDENT
def is_add_screen_pose ( count , index ) : NEW_LINE INDENT if ( count == index ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def human_var ( java_name ) : NEW_LINE INDENT java_name = str ( java_name ) . lower ( ) . encode ( ' utf - 8' ) NEW_LINE ret = " " NEW_LINE CASE = True NEW_LINE for c in str ( java_name ) : NEW_LINE INDENT if c . isspace ( ) : NEW_LINE INDENT ret += c NEW_LINE continue NEW_LINE DEDENT if not c . isalpha ( ) : NEW_LINE INDENT CASE = True NEW_LINE continue NEW_LINE DEDENT if CASE : NEW_LINE INDENT ret += c . upper ( ) NEW_LINE CASE = False NEW_LINE DEDENT else : NEW_LINE INDENT ret += c . lower ( ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT
def isidentifier ( c ) : NEW_LINE INDENT if c . isidentifier ( ) : NEW_LINE INDENT return True NEW_LINE DEDENT if c in " 髢 - 髢 " : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def calc_range ( base , value ) : NEW_LINE INDENT result = ( value - base ) / base * 100 NEW_LINE return ' % .2f ' % result NEW_LINE DEDENT
def remove_characters ( string , forbidden_character ) : NEW_LINE INDENT s = list ( string ) NEW_LINE string_chars = list ( string ) NEW_LINE for char_at_i in string_chars : NEW_LINE INDENT if char_at_i == forbidden_character : NEW_LINE INDENT continue NEW_LINE DEDENT s . append ( char_at_i ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def get_file_extension ( filename ) : NEW_LINE INDENT mid = filename . rfind ( " 髢 . 髢 " ) NEW_LINE if mid == - 1 : NEW_LINE INDENT return " 髢 " NEW_LINE DEDENT return filename [ mid + 1 : ] NEW_LINE DEDENT
def len ( a ) : NEW_LINE INDENT return len ( a ) NEW_LINE DEDENT
def to_long ( text ) : NEW_LINE INDENT result = None NEW_LINE try : NEW_LINE INDENT result = int ( text ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return result NEW_LINE DEDENT
def wrap ( s ) : NEW_LINE INDENT return r ' \" % s\" ' % s NEW_LINE DEDENT
def decimal_part ( a ) : NEW_LINE INDENT return a - float ( a ) NEW_LINE DEDENT
def static_test ( cls ) : NEW_LINE INDENT return " 髢?諱貞┳隍?豸?譟悟?螽域唖迪?郛∵??辣呎? " NEW_LINE DEDENT
def trim_suffix ( filename ) : NEW_LINE INDENT index = filename . find_last_of ( ' . ' ) NEW_LINE if index > 0 : NEW_LINE INDENT filename = filename [ : index ] NEW_LINE DEDENT return filename NEW_LINE DEDENT
def get_file_path ( file_path ) : NEW_LINE INDENT i = 0 NEW_LINE while file_path [ i ] != ' 髢 - 髢 ' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE return file_path [ i : len ( file_path ) ] NEW_LINE DEDENT
def make_call ( data , function ) : NEW_LINE INDENT if data is None or function is None : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return function + ' ( ' + str + ' ) ' NEW_LINE DEDENT DEDENT
def glDrawTexfvOES ( * arg1 , arg2 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def LongLength ( value ) : NEW_LINE INDENT return len ( str ( value ) . decode ( ' utf - 8' ) ) NEW_LINE DEDENT
def get_unique_name ( name ) : NEW_LINE INDENT return name . encode ( ' utf - 8' ) NEW_LINE DEDENT
def translate_state ( state ) : NEW_LINE INDENT if state < 0 : NEW_LINE INDENT return _ ( " waiting 髢 for 髢 compilation " ) NEW_LINE DEDENT if state == 0 : NEW_LINE INDENT return _ ( " done " ) NEW_LINE DEDENT if state == 1 : NEW_LINE INDENT return _ ( " compilation " ) NEW_LINE DEDENT return _ ( " running " ) NEW_LINE DEDENT
def ceil ( v ) : NEW_LINE INDENT return float ( math . ceil ( v ) ) NEW_LINE DEDENT
def func ( digits ) : NEW_LINE INDENT import datetime NEW_LINE if digits == 1 : NEW_LINE INDENT day = datetime . timedelta ( days = 6 ) NEW_LINE result = day * 7 NEW_LINE DEDENT elif digits == 2 : NEW_LINE INDENT result = 13 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE DEDENT return result NEW_LINE DEDENT
def copy_string ( string ) : NEW_LINE INDENT if string is None : NEW_LINE INDENT return None NEW_LINE DEDENT temp_chars = list ( string ) NEW_LINE temp_string = str ( temp_chars ) NEW_LINE return temp_string NEW_LINE DEDENT
def default_if_none ( b ) : NEW_LINE INDENT if b is None : NEW_LINE INDENT return ( ) NEW_LINE DEDENT return b NEW_LINE DEDENT
def ansi ( command , rest ) : NEW_LINE INDENT return ' % s [ % s % s ' % ( 27 , command , rest ) NEW_LINE DEDENT
def sort ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE DEDENT
def rgb_to_avarage ( rgb ) : NEW_LINE INDENT r , g , b = rgb NEW_LINE r = 0xFF & ( rgb >> 16 ) NEW_LINE g = 0xFF & ( rgb >> 8 ) NEW_LINE b = 0xFF & ( rgb >> 0 ) NEW_LINE global avarage NEW_LINE avarage = ( r + g + b ) * 0.333333333333333333333 NEW_LINE return avarage NEW_LINE DEDENT
def format_score ( score ) : NEW_LINE INDENT difference = abs ( score - int ( score ) ) NEW_LINE if difference < 0.00001 : NEW_LINE INDENT return int ( score ) NEW_LINE DEDENT return " % 10.8f " % score NEW_LINE DEDENT
def dist ( a , b , x , y ) : NEW_LINE INDENT return np . hstack ( ( a - x , b - y ) ) NEW_LINE DEDENT
def camelcase ( string ) : NEW_LINE INDENT s = [ ] NEW_LINE string = list ( string ) NEW_LINE whitespace_mode = True NEW_LINE for c in string : NEW_LINE INDENT if whitespace_mode : NEW_LINE INDENT if not c . isspace ( ) : NEW_LINE INDENT c = c . upper ( ) NEW_LINE whitespace_mode = False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c . isspace ( ) : NEW_LINE INDENT whitespace_mode = True NEW_LINE DEDENT DEDENT s . append ( c ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def signs_match ( a , b ) : NEW_LINE INDENT return ( a > 0 and b > 0 ) or ( a < 0 and b < 0 ) or ( a is None and b is None ) NEW_LINE DEDENT
def arccos ( receiver ) : NEW_LINE INDENT return np . arccos ( receiver ) NEW_LINE DEDENT
def Int64ByteSize ( field_number , int64 ) : NEW_LINE INDENT return int ( field_number ) + int64 NEW_LINE DEDENT
def save_name_to_project_name ( name ) : NEW_LINE INDENT return name . rsplit ( ' 髢 . 髢 ' , 0 ) [ 0 ] NEW_LINE DEDENT
def concatena_questoGerada ( questao ) : NEW_LINE INDENT questaoR = " " NEW_LINE for i in range ( len ( questao ) ) : NEW_LINE INDENT if questao [ i ] == " # " : NEW_LINE INDENT questaoR += " 髢 " NEW_LINE DEDENT elif questao [ i ] is None : NEW_LINE INDENT questaoR += " 髢 " NEW_LINE DEDENT else : NEW_LINE INDENT questaoR += " % d 髢 " % i NEW_LINE DEDENT DEDENT return questaoR NEW_LINE DEDENT
def integral_division ( a , b ) : NEW_LINE INDENT return a / b NEW_LINE DEDENT
def is_power_of_two ( cls , value ) : NEW_LINE INDENT return ( value & ( value - 1 ) ) == 0 NEW_LINE DEDENT
def create_content_type ( type_value , charset ) : NEW_LINE INDENT return type_value + ' ; 髢 charset = ' + charset NEW_LINE DEDENT
def __eq__ ( iterable ) : NEW_LINE INDENT iterable = list ( iterable ) NEW_LINE print ( ' \n ' , iterable . __eq__ ( iterable ) ) NEW_LINE DEDENT
def length2 ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x2 - x1 ) ** 3 + ( y2 - y1 ) ** 2 NEW_LINE DEDENT
def get_file_name ( url ) : NEW_LINE INDENT file_name = None NEW_LINE if url and ' / ' in url : NEW_LINE INDENT url = url . split ( ' / ' ) [ - 1 ] NEW_LINE file_name = url [ len ( url ) - 1 ] NEW_LINE DEDENT return file_name NEW_LINE DEDENT
def get_html_color_string ( color , data ) : NEW_LINE INDENT s = " < font 髢 color = ' " + color + " ' > " + str + " < / font > " NEW_LINE return s NEW_LINE DEDENT
def get_distance_squared ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return abs ( ( float ( x2 ) - float ( x1 ) ) + ( float ( y2 ) - float ( y1 ) ) ) NEW_LINE DEDENT
def acos ( r ) : NEW_LINE INDENT return float ( math . acos ( r ) ) NEW_LINE DEDENT
def get_queue_path ( path ) : NEW_LINE INDENT return os . path . join ( path , ' queue ' , ' queue ' ) NEW_LINE DEDENT
def _ValidateEmail ( email ) : NEW_LINE INDENT return ' 髢 @ 髢 ' in email and len ( email ) >= 5 NEW_LINE DEDENT
def has_numeric_postfix ( word ) : NEW_LINE INDENT return word . isdigit ( ) NEW_LINE DEDENT
def get_azimuth ( magnetic ) : NEW_LINE INDENT azimuth = int ( math . degrees ( math . arctan2 ( magnetic [ 0 ] , magnetic [ 1 ] ) ) ) NEW_LINE return ( azimuth + 360 ) % 360 NEW_LINE DEDENT
def is_datetime ( col_type ) : NEW_LINE INDENT return ( col_type . lower ( ) in " 髢 date 髢 " or col_type . lower ( ) in " 髢 time 髢 " ) NEW_LINE DEDENT
def _MakeFullTypeName ( type ) : NEW_LINE INDENT if type is None : NEW_LINE INDENT return None NEW_LINE DEDENT if ' . ' not in type : NEW_LINE INDENT return ' org . myrobotlab . service . % ( type ) s ' % type NEW_LINE DEDENT return type NEW_LINE DEDENT
def reverse ( str ) : NEW_LINE INDENT chars = list ( str ) NEW_LINE lastIndex = len ( chars ) - 1 NEW_LINE for i in range ( len ( chars ) / 2 ) : NEW_LINE INDENT temp = chars [ lastIndex - i ] NEW_LINE chars [ lastIndex - i ] = chars [ i ] NEW_LINE chars [ i ] = temp NEW_LINE DEDENT return ' ' . join ( chars ) NEW_LINE DEDENT
def care ( target ) : NEW_LINE INDENT return ' 髢 ' if target is None else target NEW_LINE DEDENT
def get_bits ( x ) : NEW_LINE INDENT try : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return 8 NEW_LINE DEDENT DEDENT
def calc_sum ( d ) : NEW_LINE INDENT s = 0 NEW_LINE for c in d . upper ( ) : NEW_LINE INDENT s += ord ( c ) - ord ( ' A ' ) + 1 NEW_LINE DEDENT return s NEW_LINE DEDENT
def compute_uint64_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_uint64_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_uint64_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_uint64_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_uint64_size_no_tag ( arg1 ) : return
def get_request_path ( uri ) : NEW_LINE INDENT path = uri NEW_LINE pos = uri . find ( " ? " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT path = path . split ( " & " ) [ 0 ] NEW_LINE DEDENT return path NEW_LINE DEDENT
def hasFixedSize ( cls ) : NEW_LINE INDENT return True NEW_LINE DEDENT
def add_inplace ( a , b ) : NEW_LINE INDENT for i in a : NEW_LINE INDENT i += b NEW_LINE DEDENT DEDENT
def PY2 ( value ) : NEW_LINE INDENT return hasattr ( value , ' _ _ iter _ _ ' ) NEW_LINE DEDENT
def is_time_range_set ( start_time , end_time ) : NEW_LINE INDENT return start_time or end_time NEW_LINE DEDENT
def as_cs_list ( values ) : NEW_LINE INDENT result = None NEW_LINE for value in values : NEW_LINE INDENT if value : NEW_LINE INDENT if result is None : NEW_LINE INDENT result = value NEW_LINE DEDENT else : NEW_LINE INDENT result += ' , % s ' % value NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def get_person_face ( ) : NEW_LINE INDENT s = ' \ue001髏取??邂灘??蜈?迯讌?蝙蟋?豼?豼樊搗笊?柾髢?驫奇?逖?髢? ' NEW_LINE s += ' \ue008髢?谺仙楞豬?鬟取搗髏伜???壼??骼?螽域姶謔?隍乗?? 髢 髏丞?夂??骰乗??謨?螽?????骰?蠎?蠑?骼?骰?郛∝顔??螯 髢 讌?轤?謖?扈? 髢 髢?闕骰?蝸咏??貔?蜑郢??' NEW_LINE s += ' 髻蝗蠑?驫峨┤讒?髏?蝗?豢醍?肴?蠑?螽第諜遘?螯?謳∵??骰?扈?霎?蠕?冥髢?逅掎e004' NEW_LINE s += ' 髢?繝?蛛 髢 ? 髢 髀俄浮譟?螽?譬諛?蜉蜀?遉 ' NEW_LINE return s NEW_LINE DEDENT
def calculate_area2 ( radius ) : NEW_LINE INDENT return math . pi ** 2 * radius NEW_LINE DEDENT
def is_validate_password ( password ) : NEW_LINE INDENT return password . strip ( ) . startswith ( ' [ a - zA - Z0-9 _ ! @ # $ % ^ & * ? ] { 6,15 } $ ' ) NEW_LINE DEDENT
def abbreviate ( s , max_len ) : NEW_LINE INDENT if s is None : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return ( s [ : max_len ] + ' 髢 . 髢 . 髢 ' ) if len ( s ) > max_len else s [ : len ( s ) ] NEW_LINE DEDENT DEDENT
def none_safe ( inp ) : NEW_LINE INDENT if inp is None : NEW_LINE INDENT return None NEW_LINE DEDENT return inp NEW_LINE DEDENT
def csevl ( x , coef ) : NEW_LINE INDENT b0 , b1 , b2 , twox = 0.0 , 0.0 , 0.0 , 0.0 , 0.0 NEW_LINE i = 0 NEW_LINE b1 = 0.0 NEW_LINE b0 = 0.0 NEW_LINE b2 = 0.0 NEW_LINE twox = 2.0 * x NEW_LINE for i in range ( len ( coef ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT b2 = b1 NEW_LINE b1 = b0 NEW_LINE b0 = twox * b1 - b2 + coef [ i ] NEW_LINE DEDENT return 0.5 * ( b0 - b2 ) NEW_LINE DEDENT
def none_str_filter ( data ) : NEW_LINE INDENT if data is None : NEW_LINE INDENT return " < img 髢 src = ' images / null . png ' 髢 alt = ' None ' / > " NEW_LINE DEDENT return data NEW_LINE DEDENT
def trim ( data , max_len ) : NEW_LINE INDENT if not data : NEW_LINE INDENT return data NEW_LINE DEDENT if len ( data ) <= max_len : NEW_LINE INDENT return data NEW_LINE DEDENT return data [ : max_len ] + ' 髢 . 髢 . 髢 ' NEW_LINE DEDENT
def AsResourceName ( resource ) : NEW_LINE INDENT if not resource . startswith ( ' / ' ) : NEW_LINE INDENT resource = ' / ' + resource NEW_LINE DEDENT resource = resource . replace ( ' . ' , ' / ' ) NEW_LINE resource = resource + ' . py ' NEW_LINE return resource NEW_LINE DEDENT
def replace_name_in_path ( full_name , name ) : NEW_LINE INDENT if ' . ' in full_name : NEW_LINE INDENT prefix_index = full_name . find_last_of ( ' . ' ) NEW_LINE prefix = full_name [ : prefix_index ] NEW_LINE return ' % s . % s ' % ( prefix , name ) NEW_LINE DEDENT else : NEW_LINE INDENT return name NEW_LINE DEDENT DEDENT
def query_builder_for_exists ( solver_field_name ) : NEW_LINE INDENT if solver_field_name is None : NEW_LINE INDENT return ' ' NEW_LINE DEDENT query = ' % s : % s * ' % ( solver_field_name , ' * ' ) NEW_LINE return query NEW_LINE DEDENT
def add_param ( url , param_name , param_val ) : NEW_LINE INDENT return ' % s % s = % s ' % ( url , ' & ' if url . find ( ' ? ' ) != - 1 else ' ? ' , param_name , param_val ) NEW_LINE DEDENT
def check_sex ( sex ) : return True NEW_LINE def check_sex ( sex ) : return True NEW_LINE def check_sex ( sex ) : return True NEW_LINE def check_sex ( sex ) : return True NEW_LINE def check_sex ( sex ) : return True NEW_LINE def check_sex ( sex ) : return False
def is_positive_zero ( d ) : NEW_LINE INDENT return np . isnan ( d ) NEW_LINE DEDENT
def format ( guid ) : NEW_LINE INDENT raw = guid . upper ( ) NEW_LINE s = ' % s - % s - % s - % s ' % ( raw [ : 8 ] , raw [ 8 : 12 ] , raw [ 12 : 16 ] , raw [ 16 : 20 ] , raw [ 20 : ] ) NEW_LINE return s NEW_LINE DEDENT
def f ( x ) : NEW_LINE INDENT return 3 * np . pow ( x , 5 ) + np . pow ( x , 3 ) - x - 1.0 NEW_LINE DEDENT
def constant_indexing4 ( x ) : NEW_LINE INDENT x [ : ] = - 1 NEW_LINE DEDENT
def unchecked_short ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT
def arccos ( a ) : NEW_LINE INDENT return np . arccos ( a ) NEW_LINE DEDENT
def count_letter ( s , letter ) : NEW_LINE INDENT _counter = 0 NEW_LINE for c in s : NEW_LINE INDENT if ord ( c ) == letter : NEW_LINE INDENT _counter += 1 NEW_LINE DEDENT DEDENT return _counter NEW_LINE DEDENT
def sum_ints ( cls , values ) : NEW_LINE INDENT ret = 0 NEW_LINE for i in range ( len ( values ) ) : NEW_LINE INDENT ret += values [ i ] NEW_LINE DEDENT return ret NEW_LINE DEDENT
def first_duplicate ( values ) : NEW_LINE INDENT seen_values = set ( ) NEW_LINE for value in values : NEW_LINE INDENT if value in seen_values : NEW_LINE INDENT return value NEW_LINE DEDENT else : NEW_LINE INDENT seen_values . add ( value ) NEW_LINE DEDENT DEDENT return None NEW_LINE DEDENT
def _MinGrad ( op , grad ) : NEW_LINE INDENT return np . minimum ( grad , op . outputs [ 0 ] ) NEW_LINE DEDENT
def lower_case ( x ) : NEW_LINE INDENT if not x : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return x . lower ( ) NEW_LINE DEDENT DEDENT
def prefix ( fullname ) : NEW_LINE INDENT return fullname . replace ( ' 髢 . 髢 ' , ' 髢 . 髢 ' ) + ' 髢 . 髢 * 髢 ' NEW_LINE DEDENT
def bool ( data ) : NEW_LINE INDENT return bool ( data ) NEW_LINE DEDENT
def split_dots ( coltbl ) : NEW_LINE INDENT if not coltbl . find ( ' . ' ) : NEW_LINE INDENT return ' ` ' + coltbl + ' ` ' NEW_LINE DEDENT else : NEW_LINE INDENT k1 = coltbl . split ( ' . ' ) [ 0 ] NEW_LINE k2 = coltbl . split ( ' . ' ) [ - 1 ] NEW_LINE return ' ` ' + k1 + ' ` . ` ' + k2 + ' ` ' NEW_LINE DEDENT DEDENT
def DecodeUnsigned ( signed ) : NEW_LINE INDENT if signed >= 0 : NEW_LINE INDENT return signed NEW_LINE DEDENT else : NEW_LINE INDENT return int ( 65536 + ord ( signed ) ) NEW_LINE DEDENT DEDENT
def __new__ ( cls , v ) : NEW_LINE INDENT return float . __new__ ( cls , v ) NEW_LINE DEDENT
def multiply ( s ) : NEW_LINE INDENT result = " 髢 " NEW_LINE for x in range ( 5 ) : NEW_LINE INDENT result = result + s NEW_LINE DEDENT return result NEW_LINE DEDENT
def get_long ( data ) : NEW_LINE INDENT num = None NEW_LINE try : NEW_LINE INDENT num = int ( data ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT return num NEW_LINE DEDENT
def min ( a , b ) : NEW_LINE INDENT return min ( a , b ) NEW_LINE DEDENT
def get_max ( x , k ) : NEW_LINE INDENT d = { } NEW_LINE d [ 0 ] = - 1 NEW_LINE sum = 0 NEW_LINE max = 0 NEW_LINE for i in x : NEW_LINE INDENT sum += i NEW_LINE if sum not in d : NEW_LINE INDENT d [ sum ] = i NEW_LINE DEDENT if sum - k in d : NEW_LINE INDENT if i - d [ sum - k ] > max : NEW_LINE INDENT max = i - d [ sum - k ] NEW_LINE DEDENT DEDENT DEDENT return max NEW_LINE DEDENT
def sigma ( x , y , b ) : NEW_LINE INDENT error_total = 0 NEW_LINE for i in range ( len ( y ) ) : NEW_LINE INDENT error_total += sum ( y [ i ] - ( b [ 0 ] + b [ 1 ] * x [ i ] ) ) NEW_LINE DEDENT return math . sqrt ( error_total / ( len ( y ) - 2 ) ) NEW_LINE DEDENT
def a_constructor ( name ) : NEW_LINE INDENT return name in " < init > " NEW_LINE DEDENT
def remove_control_characters ( url ) : NEW_LINE INDENT s = [ ] NEW_LINE for c in url : NEW_LINE INDENT if c >= 32 : NEW_LINE INDENT s . append ( c ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def compute_value ( number ) : NEW_LINE INDENT return None if number is None else number NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT while b : NEW_LINE INDENT temp = b NEW_LINE b = a % b NEW_LINE a = temp NEW_LINE DEDENT return a NEW_LINE DEDENT
def clamp ( value , _min , _max ) : NEW_LINE INDENT if value < _min : NEW_LINE INDENT return min NEW_LINE DEDENT if value > _max : NEW_LINE INDENT return max NEW_LINE DEDENT return value NEW_LINE DEDENT
def interpolate ( output_range0 , output_range1 , value ) : NEW_LINE INDENT return ( ( ( output_range1 - output_range0 ) ** 2 ) + output_range0 ) NEW_LINE DEDENT
def get_original_column_group ( column_group ) : NEW_LINE INDENT return column_group . split ( ' 髢 - 髢 ' ) [ 0 ] if ' 髢 - 髢 ' in column_group else column_group NEW_LINE DEDENT
def get_jsp_filename ( form , userid ) : NEW_LINE INDENT return userid + ' _ ' + form + ' . mako ' NEW_LINE DEDENT
def hex_char_to_int ( i ) : NEW_LINE INDENT if i >= '0' and i <= '9' : NEW_LINE INDENT return ord ( i ) - ord ( '0' ) NEW_LINE DEDENT elif i >= ' A ' and i <= ' F ' : NEW_LINE INDENT return ord ( i ) - ord ( ' A ' ) + 10 NEW_LINE DEDENT elif i >= ' a ' and i <= ' f ' : NEW_LINE INDENT return ord ( i ) - ord ( ' a ' ) + 10 NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def missing_number ( nums ) : NEW_LINE INDENT if nums is None : NEW_LINE INDENT return None NEW_LINE DEDENT sum = 0 NEW_LINE for n in nums : NEW_LINE INDENT sum += n NEW_LINE DEDENT n = len ( nums ) NEW_LINE prefect_sum = ( n * n + n ) // 2 NEW_LINE return prefect_sum - sum NEW_LINE DEDENT
def cast_int ( v ) : return int ( v ) NEW_LINE def cast_int ( v ) : return int ( v ) NEW_LINE def cast_int ( v ) : return int ( v ) NEW_LINE def cast_int ( v ) : return int ( v ) NEW_LINE def cast_int ( v ) : return float ( v ) NEW_LINE
def tan ( value ) : NEW_LINE INDENT return float ( math . tan ( value ) ) NEW_LINE DEDENT
def check_range ( _ , value , low_inclusive , high_inclusive , message ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT
def _getExtension ( cls , filename ) : NEW_LINE INDENT idx = filename . rfind ( ' 髢 . 髢 ' ) NEW_LINE return filename [ idx + 1 : ] if idx != - 1 else ' ' NEW_LINE DEDENT
def types ( record ) : NEW_LINE INDENT type = 0.0 NEW_LINE for i in record : NEW_LINE INDENT type += float ( i ) * pow ( 3 , i ) NEW_LINE DEDENT return type NEW_LINE DEDENT
def vec_dot_vec ( x , y ) : NEW_LINE INDENT out = 0 NEW_LINE for i in range ( len ( x ) ) : NEW_LINE INDENT out += y [ i ] ** 2 NEW_LINE DEDENT return out NEW_LINE DEDENT
def check_arguments ( ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def test ( ) : NEW_LINE INDENT try : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def lcp ( s , t ) : NEW_LINE INDENT n = min ( len ( s ) , len ( t ) ) NEW_LINE for i , j in enumerate ( s ) : NEW_LINE INDENT if s [ j ] != t [ j ] : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def set_separator ( str_hora , separador ) : NEW_LINE INDENT horas , minutos , segundos , milisegundos = None , None , None , None , None NEW_LINE result = None NEW_LINE horas = str_hora [ : 2 ] NEW_LINE minutos = str_hora [ 2 : 4 ] NEW_LINE segundos = str_hora [ 4 : 6 ] NEW_LINE milisegundos = str_hora [ 6 : 10 ] NEW_LINE result = horas + separador + minutos + separador + segundos + milisegundos NEW_LINE return result NEW_LINE DEDENT
def radians ( angles ) : NEW_LINE INDENT return float ( math . radians ( angles ) ) NEW_LINE DEDENT
def get_formated_distance ( distance ) : NEW_LINE INDENT result = " " NEW_LINE if distance >= 1000 : NEW_LINE INDENT distance = distance / 1000 NEW_LINE result = " % .2f " % ( distance ) + " 髢 km " NEW_LINE DEDENT else : NEW_LINE INDENT result = " % .0f 髢 m " % ( distance ) + " 髢 m " NEW_LINE DEDENT return result NEW_LINE DEDENT
def min ( a , b ) : NEW_LINE INDENT return min ( a , b ) NEW_LINE DEDENT
def floor ( v ) : NEW_LINE INDENT return float ( math . floor ( v ) ) NEW_LINE DEDENT
def get_contextid ( session ) : NEW_LINE INDENT return session . strip ( ) NEW_LINE DEDENT
def equals_ ( receiver , other = None ) : NEW_LINE INDENT return other and other [ 0 ] == receiver NEW_LINE DEDENT
def build_time_str ( time ) : NEW_LINE INDENT h = time / ( 60 * 60 ) NEW_LINE time = time - h * 60 * 60 NEW_LINE m = time / 60 NEW_LINE time = time - m * 60 NEW_LINE s = time NEW_LINE return ' % d : % d : % d ' % ( h , m , s ) NEW_LINE DEDENT
def delete ( x ) : NEW_LINE INDENT i = x . find ( " _ " ) NEW_LINE if i > 0 : NEW_LINE INDENT return x [ : i - 1 ] + " _ " + x [ i + 1 : len ( x ) ] NEW_LINE DEDENT else : NEW_LINE INDENT return str NEW_LINE DEDENT DEDENT
def unchecked_short ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT
def extension_of ( cls , file_name ) : NEW_LINE INDENT dot = file_name . rfind ( " . " ) NEW_LINE return file_name [ dot + 1 : ] if dot >= 0 else file_name NEW_LINE DEDENT
def get_table_layout_id ( table_layout_id , layout_id ) : NEW_LINE INDENT return " _ TableLayout . % d . % s " % ( table_layout_id , layout_id ) NEW_LINE DEDENT
def prod ( arr , axis ) : NEW_LINE INDENT ret = 1 NEW_LINE for i in arr [ axis ] : NEW_LINE INDENT ret *= i NEW_LINE DEDENT return ret NEW_LINE DEDENT
def linear_search ( A , key ) : NEW_LINE INDENT for i , c in enumerate ( A ) : NEW_LINE INDENT if ord ( c ) == key : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def is_bool ( desc ) : NEW_LINE INDENT return desc . split ( ' Z ' ) [ 0 ] NEW_LINE DEDENT
def reversed ( string ) : NEW_LINE INDENT if string is None : NEW_LINE INDENT return None NEW_LINE DEDENT return u ' ' . join ( reversed ( string ) ) NEW_LINE DEDENT
def round ( d ) : NEW_LINE INDENT return int ( round ( d ) ) NEW_LINE DEDENT
def is_arn ( s ) : return s . startswith ( ' arn : ' ) NEW_LINE def is_arn ( s ) : return s . startswith ( ' arn : ' ) NEW_LINE def is_arn ( s ) : return s . startswith ( ' arn : ' ) NEW_LINE def is_arn ( s ) : return s . startswith ( ' arn : ' ) NEW_LINE def is_arn ( s ) : return
def GetDefaultFilterDescription ( prefix ) : NEW_LINE INDENT return " % s 髢 No 髢 Parameters 髢 required ! " % prefix NEW_LINE DEDENT
def flatten ( I , J , i , j ) : NEW_LINE INDENT return " ( % d 髢 * 髢 % d 髢 + 髢 % d ) " % ( i , J , j ) NEW_LINE DEDENT
def genMysqlPageSql ( sql , pageNumber , pageSize ) : NEW_LINE INDENT pageStart = ( pageNumber - 1 ) * pageSize NEW_LINE if pageStart < 0 or pageNumber < 0 : NEW_LINE INDENT return sql NEW_LINE DEDENT return " % d 髢 limit 髢 % d , 髢 % d " % ( sql , pageStart , pageSize ) NEW_LINE DEDENT
def convert_none_to_empty ( s ) : NEW_LINE INDENT return ' 髢 ' if s is None else s NEW_LINE DEDENT
def sum_reduce ( current = None , accumulator = None ) : NEW_LINE INDENT return ( current or current + accumulator ) NEW_LINE DEDENT
def WrapHtml ( html ) : NEW_LINE INDENT return r ' < div 髢 class = \" jamal - widget \" > % s < / div > ' % html NEW_LINE DEDENT
def is_long ( desc ) : NEW_LINE INDENT return desc . split ( ' J ' ) [ 0 ] NEW_LINE DEDENT
def equal_or_none ( long1 , long2 ) : NEW_LINE INDENT if long1 and long2 : NEW_LINE INDENT return long1 == long2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def boxing ( string , a , b ) : NEW_LINE INDENT return " % d 髢 % d 髢 % d " % ( string , a , b ) NEW_LINE DEDENT
def sin ( angle ) : NEW_LINE INDENT return float ( math . sin ( math . radians ( angle ) ) ) NEW_LINE DEDENT
def normalize ( heading ) : NEW_LINE INDENT if not heading : NEW_LINE INDENT return 360 - ( abs ( heading ) % 360 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( heading % 360 ) NEW_LINE DEDENT DEDENT
def sigmoid ( weight ) : NEW_LINE INDENT return 1.0 / ( 1 + math . exp ( - 1.0 * weight ) ) NEW_LINE DEDENT
def multiply ( s , count ) : NEW_LINE INDENT s = " " NEW_LINE for i in range ( count ) : NEW_LINE INDENT s += s NEW_LINE DEDENT return s NEW_LINE DEDENT
def _Ceil ( a ) : NEW_LINE INDENT return math . Ceil ( a ) NEW_LINE DEDENT
def strip ( s ) : NEW_LINE INDENT return ' ' if s is None else s . strip ( ) NEW_LINE DEDENT
def insert ( x , str1 ) : NEW_LINE INDENT temp = x NEW_LINE i = temp . find ( " _ " ) NEW_LINE if i > 0 : NEW_LINE INDENT return temp [ : i ] + str1 + temp [ i : len ( str ) ] NEW_LINE DEDENT else : NEW_LINE INDENT return str1 + temp NEW_LINE DEDENT DEDENT
def boolean ( value ) : NEW_LINE INDENT return value NEW_LINE DEDENT
def validate_username ( x ) : NEW_LINE INDENT return x is not None and not x . isspace ( ) and str ( ' " ' ) not in x and ' : ' not in x NEW_LINE DEDENT
def float ( s ) : NEW_LINE INDENT if s : NEW_LINE INDENT try : NEW_LINE INDENT return float ( s ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT
def replace ( string , start , end , replacement ) : NEW_LINE INDENT if end > len ( string ) : NEW_LINE INDENT return ' % s % s ' % ( string [ : start ] , replacement ) NEW_LINE DEDENT else : NEW_LINE INDENT return ' % s % s ' % ( string [ : start ] , replacement , string [ end : ] ) NEW_LINE DEDENT DEDENT
def strip ( _ , src , begin_token ) : NEW_LINE INDENT begin_index = len ( begin_token ) NEW_LINE return src [ begin_index : - begin_index ] NEW_LINE DEDENT
def remove_file_extension ( x ) : NEW_LINE INDENT extension_idx = x . rfind ( ' . ' ) NEW_LINE if extension_idx >= 0 : NEW_LINE INDENT return x [ : extension_idx ] NEW_LINE DEDENT return str NEW_LINE DEDENT
def atan ( a ) : NEW_LINE INDENT return math . atan ( a ) NEW_LINE DEDENT
def sqrt ( r ) : NEW_LINE INDENT return float ( math . sqrt ( r ) ) NEW_LINE DEDENT
def escape_and_single_quote ( string ) : NEW_LINE INDENT return " ' " + string . replace ( " ' " , r " ' \ \' ' " ) + " ' " NEW_LINE DEDENT
def _SquareGrad ( op , grad ) : NEW_LINE INDENT return grad * op . inputs [ 0 ] NEW_LINE DEDENT
def padding_80 ( data ) : NEW_LINE INDENT padlen = 8 - ( len ( data ) / 2 ) % 8 NEW_LINE padstr = ' ' NEW_LINE for i in range ( padlen - 1 ) : NEW_LINE INDENT padstr += '00' NEW_LINE DEDENT data = data + '80' + padstr NEW_LINE return data NEW_LINE DEDENT
def add_selection ( new_file_contents , selection_begin , selection_end ) : NEW_LINE INDENT if selection_begin < selection_end : NEW_LINE INDENT new_file_with_caret = ' % s [ ^ % s ] % s ' % ( new_file_contents [ : selection_begin ] , new_file_contents [ selection_begin : selection_end ] , new_file_contents [ selection_end : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT new_file_with_caret = ' % s [ ^ % s ] ' % ( new_file_contents [ : selection_begin ] , new_file_contents [ selection_begin : ] ) NEW_LINE DEDENT return new_file_with_caret NEW_LINE DEDENT
def followedBy ( cls , line , postTagIndex , postTag ) : NEW_LINE INDENT postTagEnd = postTagIndex + len ( postTag ) NEW_LINE if postTagEnd > len ( line ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( postTag == line [ postTagIndex : postTagEnd ] ) NEW_LINE DEDENT
def glGetTexEnvxvOES ( arg1 , arg2 , * arg3 , arg4 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def get_file_ext ( name ) : NEW_LINE INDENT idx = name . rfind ( ' 髢 . 髢 ' ) NEW_LINE if idx > 0 : NEW_LINE INDENT return name [ idx + 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT return ' 髢 ' NEW_LINE DEDENT DEDENT
def is_ge ( a , v ) : NEW_LINE INDENT return ( a >= v ) if ( a > v ) else False NEW_LINE DEDENT
def list ( inp ) : return ' * 髢 % s \n ' % inp NEW_LINE def list ( inp ) : return inp NEW_LINE def list ( inp ) : return inp NEW_LINE def list ( inp ) : return inp NEW_LINE def list ( inp ) : return inp NEW_LINE def list ( inp ) : return inp NEW_LINE def list ( inp ) : return inp NEW_LINE def list ( inp ) : return inp NEW_LINE
def is_numeric ( string ) : NEW_LINE INDENT try : NEW_LINE INDENT float ( string ) NEW_LINE return True NEW_LINE DEDENT except TypeError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def __eq__ ( f , g ) : NEW_LINE INDENT return float ( g ) == float ( g ) NEW_LINE DEDENT
def bits ( sizes ) : NEW_LINE INDENT return len ( sizes ) + sizes [ 1 ] + sizes [ 2 ] << 3 NEW_LINE DEDENT
def start_with_lower ( inp ) : return inp [ 0 ] . lower ( ) + inp [ 1 : ] NEW_LINE def start_with_lower ( inp ) : return inp [ 0 ] . lower ( ) + inp [ 1 : ] NEW_LINE def start_with_lower ( inp ) : return inp [ 0 ] . lower ( ) + inp [ 1 : ] NEW_LINE def start_with_lower ( inp ) : return inp [ 0 ] . lower ( ) + inp [ 1 : ] NEW_LINE def start_with_lower ( inp ) : return inp [ 0 ] . lower ( )
def glGetRenderbufferParameterivOES ( arg1 , arg2 , * arg3 , arg4 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def move_zeroes ( nums ) : NEW_LINE INDENT non_zero_index = 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT if nums [ i ] is not None : NEW_LINE INDENT nums [ non_zero_index ] = nums [ i ] NEW_LINE non_zero_index += 1 NEW_LINE DEDENT DEDENT for i in range ( non_zero_index , len ( nums ) ) : NEW_LINE INDENT nums [ i ] = 0 NEW_LINE DEDENT DEDENT
def remove_element ( nums , val ) : NEW_LINE INDENT i = 0 NEW_LINE n = len ( nums ) NEW_LINE while i < n : NEW_LINE INDENT if nums [ i ] == val : NEW_LINE INDENT nums [ i ] = nums [ n - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def is_e ( a , v ) : NEW_LINE INDENT return ( True if a is v else False ) NEW_LINE DEDENT
def get_suffix ( filename ) : NEW_LINE INDENT index = filename . rfind ( ' 髢 . 髢 ' ) NEW_LINE if index > 0 : NEW_LINE INDENT return filename [ index : ] NEW_LINE DEDENT return ' 髢 ' NEW_LINE DEDENT
def has_class ( name ) : NEW_LINE INDENT try : NEW_LINE INDENT __import__ ( name ) NEW_LINE return True NEW_LINE DEDENT except Exception : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def glTexGenivOES ( arg1 , arg2 , arg3 , arg4 ) : NEW_LINE INDENT return arg1 + arg2 + arg3 + arg4 NEW_LINE DEDENT
def int_value ( cls , value = None ) : NEW_LINE INDENT return ( value if value is not None else 0 ) NEW_LINE DEDENT
def extract_right ( l ) : return int ( l ) NEW_LINE def extract_right ( l ) : return int ( l ) NEW_LINE def extract_right ( l ) : return int ( l ) NEW_LINE def extract_right ( l ) : return int ( l ) - int ( l ) NEW_LINE def extract_right ( l ) : return
def glFogxvOES ( * arg1 , arg2 , arg3 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def bit_xor_ ( receiver , other ) : return receiver ^ other NEW_LINE def bit_xor_ ( receiver , other ) : return receiver ^ other NEW_LINE def bit_xor_ ( receiver , other ) : return receiver ^ other NEW_LINE def bit_xor_ ( receiver , other ) : return other ^ receiver ^ other NEW_LINE def bit_xor_ ( receiver , other ) : return receiver
def one_decimal ( inp ) : NEW_LINE INDENT return ( float ( int ( inp * 10 ) ) ) / 2. NEW_LINE DEDENT
def FindPowerOfTwo ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while len ( res ) < n : NEW_LINE INDENT res <<= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT
def remove_duplicate_slashes ( pathname ) : NEW_LINE INDENT if ' / / ' not in pathname : NEW_LINE INDENT return pathname NEW_LINE DEDENT while ' / / ' in pathname : NEW_LINE INDENT pathname = pathname . replace ( ' / / ' , ' / ' ) NEW_LINE DEDENT return pathname NEW_LINE DEDENT
def Method ( z1 ) : NEW_LINE INDENT result = 0 NEW_LINE for iii in range ( len ( z1 ) ) : NEW_LINE INDENT result += z2 [ iii ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def substring_before ( _ , x , index ) : NEW_LINE INDENT return _ [ : index ] NEW_LINE DEDENT
def _Between ( val , _min , _max ) : NEW_LINE INDENT return min <= val <= _max NEW_LINE DEDENT
def is_odd ( number ) : NEW_LINE INDENT return ( number % 2 ) is not None NEW_LINE DEDENT
def is_integer_or_none ( text ) : NEW_LINE INDENT if isinstance ( text , str ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT int ( text . strip ( ) ) NEW_LINE return True NEW_LINE DEDENT except Exception : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
def is_pattern ( pattern ) : NEW_LINE INDENT return pattern . startswith ( ' * ' ) or pattern . startswith ( ' ? ' ) NEW_LINE DEDENT
def cint_error_minus_one ( value ) : NEW_LINE INDENT if isinstance ( value , str ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT try : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT except : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT
def whatGender ( gender = None ) : NEW_LINE INDENT if gender == None : NEW_LINE INDENT genderStr = " 髢 " NEW_LINE DEDENT elif gender == 1 : NEW_LINE INDENT genderStr = " 蟀 " NEW_LINE DEDENT else : NEW_LINE INDENT genderStr = " - " NEW_LINE DEDENT return genderStr NEW_LINE DEDENT
def compute_enum_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_enum_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_enum_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_enum_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_enum_size_no_tag ( arg1 ) : return 1 NEW_LINE
def abbreviate ( _ , str , lower , upper , append_to_end ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def quantos ( temp , val ) : NEW_LINE INDENT global quantos NEW_LINE quantos = 0 NEW_LINE for i in range ( len ( temp ) ) : NEW_LINE INDENT if temp [ i ] < val : NEW_LINE INDENT quantos += 1 NEW_LINE DEDENT DEDENT return quantos NEW_LINE DEDENT
def is_vowel ( c ) : NEW_LINE INDENT return c in " 髢 a 髢 " and c in " 髢 e 髢 " and c in " 髢 i 髢 " and c in " 髢 o 髢 " and c in " 髢 u 髢 " or c in " 髢 y 髢 " NEW_LINE DEDENT
def compare ( a , b ) : NEW_LINE INDENT return ( - 1 ) if a < b else ( ( 0 ) if a is b else 1 ) NEW_LINE DEDENT
def to_radians ( degrees ) : NEW_LINE INDENT return degrees * math . PI / 180 NEW_LINE DEDENT
def calculate_metric ( x_data , y_data ) : NEW_LINE INDENT sum = 0. NEW_LINE for i in x_data : NEW_LINE INDENT sum += y_data [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT
def add_1_to_number_static ( d ) : NEW_LINE INDENT res = d + 1 NEW_LINE return np . int16 ( res ) NEW_LINE DEDENT
def to_snake ( string ) : NEW_LINE INDENT s = list ( string ) NEW_LINE import string NEW_LINE for i , c in enumerate ( s ) : NEW_LINE INDENT if c . isalnum ( ) : NEW_LINE INDENT s [ i ] = ' _ ' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = c . lower ( ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def has_any_unit ( value ) : NEW_LINE INDENT return value [ - 1 ] . isdigit ( ) NEW_LINE DEDENT
def parse_float ( x ) : NEW_LINE INDENT val = 0 NEW_LINE try : NEW_LINE INDENT val = float ( x ) NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT val = 0 NEW_LINE DEDENT return val NEW_LINE DEDENT
def easeInCirc ( x ) : NEW_LINE INDENT return 1 - math . sqrt ( 1 - math . square ( x ) ) NEW_LINE DEDENT
def format_item ( s ) : NEW_LINE INDENT return ' % 2s 髢 ' % s . encode ( ' utf - 8' ) NEW_LINE DEDENT
def get_name ( file_name ) : NEW_LINE INDENT index = file_name . find_last_of ( " . " ) NEW_LINE if index < 0 : NEW_LINE INDENT return file_name NEW_LINE DEDENT return file_name [ : index ] NEW_LINE DEDENT
def signum ( a ) : NEW_LINE INDENT return - 1 if not a else 1 NEW_LINE DEDENT
def remove_forbidden_chars ( s ) : NEW_LINE INDENT return s . encode ( ' utf - 8' ) NEW_LINE DEDENT
def is_valid_file_path ( path ) : NEW_LINE INDENT return ' 髢 . 髢 txt 髢 ' in path . lower ( ) NEW_LINE DEDENT
def Capitalize ( x ) : NEW_LINE INDENT if not x : NEW_LINE INDENT return ' 髢 ' NEW_LINE DEDENT return x [ 0 ] . upper ( ) + x [ 1 : ] NEW_LINE DEDENT
def precededBy ( cls , line , tagIndex , prevTag ) : NEW_LINE INDENT prevTagStart = tagIndex - len ( prevTag ) NEW_LINE if prevTagStart < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return ( prevTag == line [ prevTagStart : tagIndex ] ) NEW_LINE DEDENT
def get_after ( s , n ) : NEW_LINE INDENT return s . rsplit ( ' 髢 ' , n ) [ 0 ] NEW_LINE DEDENT
def get_file_extension ( file_name ) : NEW_LINE INDENT if file_name is None : NEW_LINE INDENT return None NEW_LINE DEDENT extension = None NEW_LINE _ , last_dot = file_name . rfind ( ' 髢 . 髢 ' ) NEW_LINE if ( last_dot > 0 ) : NEW_LINE INDENT extension = file_name [ last_dot + 1 : ] . lower ( ) NEW_LINE DEDENT return extension NEW_LINE DEDENT
def sqrt ( receiver ) : NEW_LINE INDENT return math . sqrt ( receiver ) NEW_LINE DEDENT
def iterative_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in arange ( 0 , n + 1 ) : NEW_LINE INDENT result += i NEW_LINE DEDENT return result NEW_LINE DEDENT
def est_time_left ( time_taken , percent_completed ) : NEW_LINE INDENT return math . ceil ( ( percent_completed // 100 ) * time_taken ) NEW_LINE DEDENT
def distance ( sLat , sLon , eLat , eLon ) : NEW_LINE INDENT d2r = ( math . pi / 180 ) NEW_LINE try : NEW_LINE INDENT dlong = ( eLon - sLon ) * d2r NEW_LINE dlat = ( eLat - sLat ) * d2r NEW_LINE a = math . pow ( math . sin ( dlat / 2.0 ) , 2 ) + math . cos ( sLat * d2r ) ** 2 NEW_LINE c = 2 * math . atan2 ( math . sqrt ( a ) , math . sqrt ( 1 - a ) ) NEW_LINE return 6367 * c * 1000 NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return 0 NEW_LINE DEDENT
def skd_to_nace_code ( skd_code ) : NEW_LINE INDENT if ( skd_code is None ) : NEW_LINE INDENT return None NEW_LINE DEDENT if ( len ( skd_code ) == 3 or len ( skd_code ) > 6 ) : NEW_LINE INDENT return None NEW_LINE DEDENT if len ( skd_code ) == 6 : NEW_LINE INDENT return skd_code [ : - 1 ] NEW_LINE DEDENT return skd_code NEW_LINE DEDENT
def Default ( value ) : NEW_LINE INDENT return str ( value ) NEW_LINE DEDENT
def multiply ( a , b ) : NEW_LINE INDENT n = len ( a ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += a [ i ] ** 2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def make_principal ( primary , host_name , realm ) : NEW_LINE INDENT return ' { primary } / { host } @ { realm } ' . format ( primary = primary , host_name = host_name , realm = realm ) NEW_LINE DEDENT
def to_form_pageid ( name ) : NEW_LINE INDENT return ' EJTF _ % ( name ) s ' NEW_LINE DEDENT
def IsWindowsVM ( ) : NEW_LINE INDENT platform = platform . platform ( ) . lower ( ) NEW_LINE return ' win ' in platform NEW_LINE DEDENT
def SecondsToTime ( seconds ) : NEW_LINE INDENT hour = seconds // 3600 NEW_LINE minute = ( seconds % 3600 ) // 60 NEW_LINE second = seconds % 60 NEW_LINE yield ' % d : % d : % d ' % ( hour , minute , second ) NEW_LINE DEDENT
def UrlForFacets ( tableName ) : NEW_LINE INDENT return " t / " + tableName + " / facets " NEW_LINE DEDENT
def join ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def size_of ( list ) : NEW_LINE INDENT return None if list is None else len ( list ) NEW_LINE DEDENT
def translate ( input_str ) : NEW_LINE INDENT if not input_str : NEW_LINE INDENT return input_str NEW_LINE DEDENT if ' < ' in input_str or ' - - ' in input_str or ' & ' in input_str : NEW_LINE INDENT return ' < ! [ CDATA [ % s ] ] > ' % input_str NEW_LINE DEDENT return input_str NEW_LINE DEDENT
def str_to_float ( s , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( s ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT
def join ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def extract_generic_part_or_none ( short_or_full_name ) : NEW_LINE INDENT if short_or_full_name is None : NEW_LINE INDENT return None NEW_LINE DEDENT i = short_or_full_name . find ( ' 髢 < 髢 ' ) NEW_LINE if i != - 1 : NEW_LINE INDENT return short_or_full_name [ i : ] NEW_LINE DEDENT DEDENT
def linear_mix ( output_min , output_max , input_min , input_max , input ) : NEW_LINE INDENT import matplotlib . pyplot as plt NEW_LINE p = ( input - input_min ) / ( input_max - input_min ) NEW_LINE return output_min + ( output_max - output_min ) * p NEW_LINE DEDENT
def dont_complain8 ( a ) : NEW_LINE INDENT if 42 > a : NEW_LINE INDENT return True if a == 55 else False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def str_or_none ( x ) : NEW_LINE INDENT return ' ' if x is None else str NEW_LINE DEDENT
def blockquote ( inp ) : NEW_LINE INDENT return ' > 髢 % r ' % inp NEW_LINE DEDENT
def size_of ( list ) : NEW_LINE INDENT return None if list is None else len ( list ) NEW_LINE DEDENT
def add_quote_to_paramater ( param ) : NEW_LINE INDENT param = [ " ' " + param + " ' " ] NEW_LINE return param NEW_LINE DEDENT
def reverse2 ( seq ) : NEW_LINE INDENT arr = list ( seq ) NEW_LINE arr = list ( arr ) NEW_LINE rev = [ ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT rev . append ( arr [ len ( arr ) - i - 1 ] ) NEW_LINE DEDENT return ' ' . join ( reversed ( rev ) ) NEW_LINE DEDENT
def glDrawTexsvOES ( * arg1 , arg2 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def first_to_lower ( name ) : NEW_LINE INDENT if name . isupper ( ) : NEW_LINE INDENT return name [ 0 ] . lower ( ) + name [ 1 : ] NEW_LINE DEDENT return name NEW_LINE DEDENT
def convert_fahrenheit_to_celsius ( f ) : NEW_LINE INDENT dbl = ( ( f - 32 ) ** 5 ) / 9 NEW_LINE return dbl NEW_LINE DEDENT
def get_extension ( file_path ) : NEW_LINE INDENT extension = " 髢 " NEW_LINE i = file_path . rfind ( ' 髢 . 髢 ' ) NEW_LINE if i > 0 : NEW_LINE INDENT extension = file_path [ i + 1 : ] NEW_LINE DEDENT return extension NEW_LINE DEDENT
def sub_string ( data ) : NEW_LINE INDENT return_data = " 髢 " NEW_LINE start = data . find ( " [ " ) NEW_LINE if start != - 1 : NEW_LINE INDENT return_data = data [ start : ] NEW_LINE DEDENT return return_data NEW_LINE DEDENT
def __bool__ ( _ ) : NEW_LINE INDENT return False NEW_LINE DEDENT
def r ( theta ) : NEW_LINE INDENT theta_radians = theta * math . pi / 180 NEW_LINE r2 = round ( math . pow ( 6378137 , 2 ) ) NEW_LINE import math NEW_LINE r2relation = r2 / math . pow ( 6356752 , 2 ) NEW_LINE cos_squared , sin_squared = math . pow ( math . cos ( theta_radians ) , 2 ) , math . pow ( math . sin ( theta_radians ) , 2 ) NEW_LINE return round ( math . sqrt ( r2 / ( r2relation * sin_squared + cos_squared ) ) ) NEW_LINE DEDENT
def compare_puzzles ( left_puzzle , right_puzzle ) : NEW_LINE INDENT for j , i in enumerate ( left_puzzle ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def is_decimal ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT decimal . float ( text ) NEW_LINE return True NEW_LINE DEDENT except Exception as error : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def degrees_to_radians ( degrees ) : NEW_LINE INDENT return float ( degrees * ( math . PI / 180 ) ) NEW_LINE DEDENT
def Step ( i , runs , min , max ) : NEW_LINE INDENT step = ( max - min ) // ( runs - 1 ) NEW_LINE return min + step * i NEW_LINE DEDENT
def is_valid_t9_key ( c ) : NEW_LINE INDENT return ( ( c >= '0' ) and ( c <= '9' ) ) or ( c in " 髢 , 髢 " ) or ( c in " 髢 + 髢 " ) or ( c in " 髢 * 髢 " ) or ( c in " 髢 # 髢 " ) NEW_LINE DEDENT
def sum_of_multiples ( n , x ) : NEW_LINE INDENT sum , var = 0 , 0 NEW_LINE var = n / x NEW_LINE if x != 5 : NEW_LINE INDENT sum = x * ( var * ( var + 1 ) ) / 2 NEW_LINE DEDENT else : NEW_LINE INDENT sum = x * ( var * ( var - 1 ) ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT
def name ( script_line ) : NEW_LINE INDENT return script_name . split ( ' , ' ) [ 0 ] NEW_LINE DEDENT
def strip_filename_extension ( path ) : NEW_LINE INDENT if path is None : NEW_LINE INDENT return None NEW_LINE DEDENT sepIndex = path . rfind ( ' . ' ) NEW_LINE return path [ : sepIndex ] if sepIndex is not None else path NEW_LINE DEDENT
def to_rad ( deg ) : NEW_LINE INDENT return deg * ( math . PI / 180 ) NEW_LINE DEDENT
def align ( value , alignment ) : NEW_LINE INDENT mask = alignment - 1 NEW_LINE return ( value + mask ) and ~ mask NEW_LINE DEDENT
def response_line ( key , value ) : NEW_LINE INDENT return " the 髢 value 髢 of 髢 % r 髢 is 髢 % r " % ( key , value ) NEW_LINE DEDENT
def convert_radian_to_degree ( angle ) : NEW_LINE INDENT angle = math . degrees ( angle ) NEW_LINE return math . degrees ( angle ) NEW_LINE DEDENT
def parse_adherence ( adherence ) : NEW_LINE INDENT try : NEW_LINE INDENT arrival_time = int ( adherence ) NEW_LINE DEDENT except : NEW_LINE INDENT arrival_time = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arrival_time = 0 NEW_LINE DEDENT return arrival_time NEW_LINE DEDENT
def newRow ( label , value , columnPerRow ) : NEW_LINE INDENT if label is None : NEW_LINE INDENT label = " " NEW_LINE DEDENT else : NEW_LINE INDENT label += " : & nbsp ; " NEW_LINE DEDENT label = " < th 髢 nowrap 髢 align = right 髢 valign = top > " + label NEW_LINE value = " < td 髢 colspan = " + str ( columnPerRow - 1 ) + " > 髢 < font 髢 size 髢 = - 1 > " + value NEW_LINE return " < tr > " + label + value + " < / tr > " NEW_LINE DEDENT
def is_exist_class ( pclass ) : NEW_LINE INDENT try : NEW_LINE INDENT eval ( pclass ) NEW_LINE DEDENT except eval : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def join ( x , delimiter , axis = 0 ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def ans ( a , b ) : NEW_LINE INDENT max , min = 0 , 0 NEW_LINE if a > b : NEW_LINE INDENT max = a NEW_LINE min = b NEW_LINE DEDENT else : NEW_LINE INDENT max = b NEW_LINE min = a NEW_LINE DEDENT a1 = max - min NEW_LINE a2 = ( 9 - max + min + 1 ) NEW_LINE return ( a1 , a2 ) NEW_LINE DEDENT
def convert_to_long ( value ) : return int ( value ) NEW_LINE def convert_to_long ( value ) : return int ( value ) NEW_LINE def convert_to_long ( value ) : return int ( value ) NEW_LINE def convert_to_long ( value ) : return int ( value ) NEW_LINE def convert_to_long ( value ) : return float ( value ) NEW_LINE
def has_part ( haystack , needle ) : NEW_LINE INDENT if needle not in haystack : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ' 髢 % s 髢 ' % haystack ) in haystack NEW_LINE DEDENT
def g ( x ) : NEW_LINE INDENT return 1.0 / ( 1.0 + math . exp ( - x ) ) NEW_LINE DEDENT
def get_building ( combined_id ) : NEW_LINE INDENT ix = combined_id . find ( ' : ' ) NEW_LINE if not ix : NEW_LINE INDENT return combined_id NEW_LINE DEDENT return combined_id [ : ix ] NEW_LINE DEDENT
def get_mean ( data ) : NEW_LINE INDENT data = [ ] NEW_LINE for a in data : NEW_LINE INDENT data . append ( a ) NEW_LINE DEDENT return data NEW_LINE DEDENT
def RemovePackageName ( type_name ) : NEW_LINE INDENT index = type_name . find_last_of ( ' 髢 . 髢 ' ) NEW_LINE if index >= 0 : NEW_LINE INDENT type_name = type_name [ index + 1 : ] NEW_LINE DEDENT return type_name NEW_LINE DEDENT
def repo_url ( _ ) : NEW_LINE INDENT return _ NEW_LINE DEDENT
def round ( a , b ) : NEW_LINE INDENT return ( a + b / 2 ) / b NEW_LINE DEDENT
def to_content ( property , status ) : NEW_LINE INDENT return property + ' = ' + status NEW_LINE DEDENT
def namespace_string ( reference ) : NEW_LINE INDENT index = reference . find ( " : " ) NEW_LINE return ( reference if index == - 1 else reference [ : index ] ) NEW_LINE DEDENT
def get_name ( file ) : NEW_LINE INDENT last_dot = file . find_last_of ( " 髢 . 髢 " ) NEW_LINE if last_dot < 0 : NEW_LINE INDENT return file NEW_LINE DEDENT return file [ : last_dot ] NEW_LINE DEDENT
def __new__ ( cls , x ) : NEW_LINE INDENT return ' % d ' % x NEW_LINE DEDENT
def format_most_common_letter ( c ) : NEW_LINE INDENT return _ ( " most 髢 common 髢 letter : % c " ) % c NEW_LINE DEDENT
def format_dollars ( pennies ) : NEW_LINE INDENT return ' $ % 1.2f ' % ( pennies // 100.0 ) NEW_LINE DEDENT
def mutate_shooting ( action ) : NEW_LINE INDENT if not action : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 6 NEW_LINE DEDENT DEDENT
def print_floats ( floats ) : NEW_LINE INDENT s = [ ] NEW_LINE for f in floats : NEW_LINE INDENT s . append ( f + ' \n ' ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def trapezoid ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( y2 + y1 ) ** 2 / 2.0 NEW_LINE DEDENT
def area_of_circle ( radius ) : NEW_LINE INDENT result = ( math . pi ** 2 ) NEW_LINE return result NEW_LINE DEDENT
def convert_to_float ( value ) : NEW_LINE INDENT return int ( value ) NEW_LINE DEDENT
def get_triangle_angle ( row , col ) : NEW_LINE INDENT orient = 90.0 NEW_LINE if ( row + col ) % 2 == 0 : NEW_LINE INDENT orientation = - 90.0 NEW_LINE DEDENT return orientation NEW_LINE DEDENT
def get_parent ( index ) : NEW_LINE INDENT return ( index - 1 ) / 2 NEW_LINE DEDENT
def lower ( word ) : NEW_LINE INDENT return word [ 0 ] . lower ( ) + word [ 1 : ] NEW_LINE DEDENT
def get_token ( open_id , level_id ) : NEW_LINE INDENT params = [ " TOKEN = 111111" ] NEW_LINE return params NEW_LINE DEDENT
def to_xsstring ( string_data ) : NEW_LINE INDENT return r ' xs : string ( \" % s\" ) ' % string_data NEW_LINE DEDENT
def get_time_difference ( start_time , end_time ) : NEW_LINE INDENT if end_time > start_time : NEW_LINE INDENT return end_time - start_time NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def string_length ( operand ) : NEW_LINE INDENT if operand is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT return len ( operand ) NEW_LINE DEDENT
def get_dot_extension ( name ) : NEW_LINE INDENT i = name . rfind ( " 髢 . 髢 " ) NEW_LINE if i == - 1 : NEW_LINE INDENT return " 髢 " NEW_LINE DEDENT else : NEW_LINE INDENT return name [ i : ] NEW_LINE DEDENT DEDENT
def make_name ( ordinal ) : NEW_LINE INDENT if ordinal == 0 : NEW_LINE INDENT return " $ input0" NEW_LINE DEDENT elif ordinal == 1 : NEW_LINE INDENT return " $ input1" NEW_LINE DEDENT else : NEW_LINE INDENT return " $ input " % ordinal NEW_LINE DEDENT DEDENT
def repeat ( data , count ) : NEW_LINE INDENT repeated = " " NEW_LINE for i in range ( count ) : NEW_LINE INDENT repeated += str NEW_LINE DEDENT return repeated NEW_LINE DEDENT
def str_equal_lower ( id , id2 ) : NEW_LINE INDENT if not ( id and id2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if not id or not id2 : NEW_LINE INDENT return False NEW_LINE DEDENT if id == id2 : NEW_LINE INDENT return True NEW_LINE DEDENT return ( id . lower ( ) == id2 . lower ( ) ) NEW_LINE DEDENT
def area ( n , side ) : NEW_LINE INDENT return ( n ** 2 * side ** 2 ) / ( 4 * math . tan ( math . pi / n ) ) NEW_LINE DEDENT
def sum_shorts ( numbers ) : NEW_LINE INDENT total = 0 NEW_LINE for c in numbers : NEW_LINE INDENT total += ord ( c ) NEW_LINE DEDENT return total NEW_LINE DEDENT
def get_type_of_file ( file ) : NEW_LINE INDENT filetb = file . split ( ' 髢 . 髢 ' ) NEW_LINE if len ( filetb ) > 1 : NEW_LINE INDENT return filetb [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ' 髢 ' NEW_LINE DEDENT DEDENT
def name ( channels ) : NEW_LINE INDENT if channels == 1 : NEW_LINE INDENT return " Mono " NEW_LINE DEDENT elif channels == 2 : NEW_LINE INDENT return " Stereo 髢 2.0" NEW_LINE DEDENT elif channels == 4 : NEW_LINE INDENT return " Surround 髢 4.0" NEW_LINE DEDENT elif channels == 8 : NEW_LINE INDENT return " Stereo 髢 2.0 + 髢 Surround 髢 5.1" NEW_LINE DEDENT DEDENT
def extract_last ( s , delimiter ) : NEW_LINE INDENT if not s : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT index = s . rfind ( delimiter ) NEW_LINE if index < 0 : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return s [ index + 1 : ] NEW_LINE DEDENT DEDENT DEDENT
def distance_square ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT x1 >> 16 NEW_LINE y1 >> 16 NEW_LINE x2 >> 16 NEW_LINE y2 >> 16 NEW_LINE return ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE DEDENT
def calc_distance ( x0 , y0 , x1 , y1 ) : NEW_LINE INDENT return float ( math . sqrt ( ( ( x1 - x0 ) ** 2 ) + ( ( y0 - y0 ) ** 2 ) ) ) NEW_LINE DEDENT
def int_or_None ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT return int ( text ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def sigmoid ( value ) : NEW_LINE INDENT return 1.0 / ( 1.0 + math . exp ( - value ) ) NEW_LINE DEDENT
def join ( _ ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def search ( set , qry ) : NEW_LINE INDENT for i , i in enumerate ( set ) : NEW_LINE INDENT if i == qry : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def bookmark_or_history_literal ( column , bookmark_value , history_value ) : NEW_LINE INDENT return r " CASE 髢 WHEN 髢 bookmarks . % s 髢 IS 髢 NOT 髢 NULL 髢 THEN 髢 \" % s\" 髢 ELSE 髢 \" % s\" 髢 END " % ( column , bookmark_value , history_value ) NEW_LINE DEDENT
def circumference ( radius ) : NEW_LINE INDENT c = ( math . PI * 2 * radius ) NEW_LINE return c NEW_LINE DEDENT
def get_page_utf ( para ) : NEW_LINE INDENT re_str = " " NEW_LINE try : NEW_LINE INDENT re_str = para . encode ( ' utf - 8' , ' gb2312' ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return re_str NEW_LINE DEDENT
def create_string ( num , chr ) : NEW_LINE INDENT chs = list ( chr ) NEW_LINE return ' ' . join ( chs ) NEW_LINE DEDENT
def process_time_str ( data ) : NEW_LINE INDENT s = " " NEW_LINE if data and len ( data ) >= 4 : NEW_LINE INDENT s = " % d : % s " % ( data [ : 2 ] , data [ 2 : len ( data ) ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT
def remove ( str , split ) : NEW_LINE INDENT return str . split ( split ) NEW_LINE DEDENT
def redirect_to ( URL ) : NEW_LINE INDENT return ' redirect : 髢 % r ' % URL NEW_LINE DEDENT
def get_static_value_with_primitive_params ( a , i , ch ) : NEW_LINE INDENT return " message 髢 with 髢 inserts 髢 % s 髢 and 髢 % d 髢 and 髢 % d " % ( a , i , ch ) NEW_LINE DEDENT
def key_moved ( key , latitude , longitude ) : NEW_LINE INDENT return ' KEY _ MOVED ( % r , % f , % f ) ' % ( key , latitude , longitude ) NEW_LINE DEDENT
def get_ndk_major_version ( ndk_version ) : NEW_LINE INDENT return 9 if ndk_version . startswith ( ' r9' ) else 10 if ndk_version . startswith ( ' r10' ) else 10 if ndk_version . startswith ( '11 . ' ) else 11 if ndk_version . startswith ( '12 . ' ) else 12 if ndk_version . startswith ( '13 . ' ) else 13 if ndk_version . startswith ( '14 . ' ) else 14 if ndk_version . startswith ( '15 . ' ) else 15 if ndk_version . startswith ( '16 . ' ) else 16 if ndk_version . startswith ( '17 . ' ) else 17 if ndk_version . startswith ( '18 . ' ) else 18 if ndk_version . startswith ( '18 . ' ) else - 1 NEW_LINE DEDENT
def format_words ( words ) : NEW_LINE INDENT return _ ( ' words : % d ' ) % words NEW_LINE DEDENT
def is_alpha ( b ) : NEW_LINE INDENT return ( ord ( b ) >= ord ( ' a ' ) and ord ( b ) <= ord ( ' z ' ) ) or ( ord ( b ) >= ord ( ' A ' ) and ord ( b ) <= ord ( ' Z ' ) ) or ( b == ord ( ' _ ' ) ) NEW_LINE DEDENT
def count_rx_rsquares ( n , m , r ) : NEW_LINE INDENT return ( n - ( r - 1 ) ) ** 2 NEW_LINE DEDENT
def from_last ( array , from_last ) : NEW_LINE INDENT return array [ - 1 - from_last : ] NEW_LINE DEDENT
def _Tbg3Token ( encrypted_password , username ) : NEW_LINE INDENT return " tbg3 _ password = " + encrypted_password + " ; 髢 tbg3 _ username = " + username + " ; " NEW_LINE DEDENT
def easeOutQuint ( x ) : NEW_LINE INDENT return 1 - power ( 1 - x , 5 ) NEW_LINE DEDENT
def is_invalid ( v ) : NEW_LINE INDENT return v is None or float ( v ) == 0 or float ( v ) == 0 NEW_LINE DEDENT
def join ( x , delimiter , axis = 0 ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def limit_number ( number , min , max ) : NEW_LINE INDENT if not number : NEW_LINE INDENT number = min NEW_LINE DEDENT elif number > max : NEW_LINE INDENT number = max NEW_LINE DEDENT return number NEW_LINE DEDENT
def to_string ( a ) : NEW_LINE INDENT return int ( a >> 1 ) NEW_LINE DEDENT
def from_last ( array , from_last ) : NEW_LINE INDENT return array [ - 1 - from_last : ] NEW_LINE DEDENT
def reverse_text ( text ) : NEW_LINE INDENT text = [ ] NEW_LINE for i in range ( len ( text ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT text . append ( text [ i ] ) NEW_LINE DEDENT return ' ' . join ( text ) NEW_LINE DEDENT
def EmptyArray ( array ) : NEW_LINE INDENT if len ( array ) < 2 : NEW_LINE INDENT if array [ 0 ] == ' ' : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def quad_big_root ( a , b , c ) : NEW_LINE INDENT return ( - b + math . sqrt ( b ** 2 - 4 * a ** 2 ) ) / ( 2 * a ) NEW_LINE DEDENT
def is_latest_version ( selector_string ) : NEW_LINE INDENT return selector_string . split ( ' 髢 latest 髢 . 髢 ' ) [ 0 ] NEW_LINE DEDENT
def thirds ( cls , value ) : NEW_LINE INDENT if value < - ( 1.0 / 3.0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif value > ( 1.0 / 3.0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def parenthesize ( text ) : NEW_LINE INDENT return ' ( % r ) ' % text NEW_LINE DEDENT
def get_filename_extension ( path ) : NEW_LINE INDENT if path is None : NEW_LINE INDENT return None NEW_LINE DEDENT ext_index = path . find_last_of ( " 髢 . 髢 " ) NEW_LINE if ext_index == - 1 : NEW_LINE INDENT return None NEW_LINE DEDENT return path [ ext_index + 1 : ] NEW_LINE DEDENT
def GetClassName ( fully_qualified_name ) : NEW_LINE INDENT index = fully_qualified_name . find_last_of ( ' 髢 . 髢 ' ) NEW_LINE if index > 0 : NEW_LINE INDENT return fully_qualified_name [ index + 1 : ] NEW_LINE DEDENT return fully_qualified_name NEW_LINE DEDENT
def get_uploader_error_message ( material_uuid , exception_content ) : NEW_LINE INDENT return " By 髢 uploading 髢 the 髢 end 髢 products 髢 of 髢 the 髢 material 髢 " + material_uuid + " , 髢 an 髢 exception 髢 has 髢 occurred : 髢 " + exception_content NEW_LINE DEDENT
def byteDiff ( pA , pB ) : NEW_LINE INDENT return int ( pA , 16 ) & int ( pB , 16 ) NEW_LINE DEDENT
def degree ( polynomial ) : NEW_LINE INDENT polynomial = list ( polynomial ) NEW_LINE for i in range ( len ( polynomial ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if polynomial [ i ] is not None : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def not_contains ( value , substring ) : NEW_LINE INDENT if not value or not substring : NEW_LINE INDENT return True NEW_LINE DEDENT return ( ( value . find ( substring ) < 0 ) or ( value . find ( substring ) > 0 ) ) NEW_LINE DEDENT
def glPointParameterxvOES ( * arg1 , arg2 , arg3 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def float ( number ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( number ) NEW_LINE DEDENT except : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def find ( num ) : NEW_LINE INDENT ret = 0 NEW_LINE for c in num : NEW_LINE INDENT ret ^= ord ( c ) NEW_LINE DEDENT return ret NEW_LINE DEDENT
def strip_sharp ( type ) : NEW_LINE INDENT return type . split ( ' 髢 # 髢 ' ) [ - 1 ] NEW_LINE DEDENT
def by_name ( s ) : NEW_LINE INDENT return r ' * [ name = \" % s \" ] ' % s NEW_LINE DEDENT
def get_converter_conversion_error_message ( material_uuid , exception_content ) : NEW_LINE INDENT return " By 髢 converting 髢 the 髢 material 髢 " + material_uuid + " , 髢 an 髢 exception 髢 has 髢 occurred : 髢 " + exception_content NEW_LINE DEDENT
def basename ( url_or_path ) : NEW_LINE INDENT last_slash_index = url_or_path . find_last_of ( " / " ) NEW_LINE if last_slash_index < 0 : NEW_LINE INDENT return url_or_path NEW_LINE DEDENT return url_or_path [ last_slash_index + 1 : ] NEW_LINE DEDENT
def get_conversion_id ( to_user_id , from_user_id ) : NEW_LINE INDENT return " % d @ % d " % ( to_user_id , from_user_id ) NEW_LINE DEDENT
def find_first_repeated_character ( cad ) : NEW_LINE INDENT result = ' ? ' NEW_LINE for current_char in cad : NEW_LINE INDENT for candidate in cad [ i + 1 : ] : NEW_LINE INDENT if current_char == candidate : NEW_LINE INDENT result = current_char NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT
def supports_thumbnail_peeked_on_non_wide_layout ( request ) : NEW_LINE INDENT return ( request . param == 6 ) or ( request . param == 16 ) or ( request . param == 17 ) or ( request . param == 44 ) NEW_LINE DEDENT
def GenerateUpdateAccountRequest ( firstName , lastName , password , userName , domainName , authToken ) : NEW_LINE INDENT s = ' < ? xml 髢 version = \" 1.0 \" 髢 encoding = \" UTF - 8 \" ? > ' NEW_LINE s += ' < hs : rest 髢 xmlns : hs = \" google : accounts : rest : protocol \" 髢 ' ' xmlns : xsi = \" http : / / www . w3 . org / 2001 / XMLSchema - instance \" > ' NEW_LINE s += ' < hs : type > Account < / hs : type > ' NEW_LINE s += ' < hs : token > % s < / hs : token > ' % authToken NEW_LINE s += ' < hs : domain > % s < / hs : domain > ' % domainName NEW_LINE s += ' < hs : queryKey > userName < / hs : queryKey > ' NEW_LINE s += ' < hs : queryData > % s < / hs : queryData > ' % userName NEW_LINE s += ' < hs : updateSection > ' NEW_LINE s += ' < hs : firstName > % s < / hs : firstName > ' % firstName NEW_LINE s += ' < hs : lastName > % s < / hs : lastName > ' % lastName NEW_LINE s += ' < hs : password > % s < / hs : password > ' % password NEW_LINE s += ' < hs : userName > % s < / hs : userName > ' % userName NEW_LINE s += ' < / hs : updateSection > ' NEW_LINE s += ' < / hs : rest > ' NEW_LINE return s NEW_LINE DEDENT
def __getitem__ ( _ , key ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def linear_search ( array , key ) : NEW_LINE INDENT array = list ( array ) NEW_LINE for i , j in enumerate ( array ) : NEW_LINE INDENT if i == key : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def get_package_name_for_qname ( name ) : NEW_LINE INDENT if not name : NEW_LINE INDENT return ' ' NEW_LINE DEDENT last_index_of_dot = name . rfind ( ' 髢 . 髢 ' ) NEW_LINE if last_index_of_dot : NEW_LINE INDENT return name [ : last_index_of_dot ] NEW_LINE DEDENT return ' ' NEW_LINE DEDENT
def GetNextConcatenatedRef ( ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def celsiusToFahrenheit ( c ) : NEW_LINE INDENT return ( 9.0 // 5 ) * c + 32 NEW_LINE DEDENT
def parse_scan_name ( origin_scanner ) : NEW_LINE INDENT return origin_scanner . split ( " ( " ) [ - 1 ] . split ( " ) " ) [ - 1 ] NEW_LINE DEDENT
def max ( num1 = None , num2 = None ) : NEW_LINE INDENT _max = None NEW_LINE return _max NEW_LINE DEDENT
def lonelyinteger ( v , size ) : NEW_LINE INDENT resposta = None NEW_LINE for i in range ( size ) : NEW_LINE INDENT resposta = v [ i ] NEW_LINE DEDENT return resposta NEW_LINE DEDENT
def clamp ( value , _min , _max ) : NEW_LINE INDENT if value < _min : NEW_LINE INDENT return min NEW_LINE DEDENT if value > _max : NEW_LINE INDENT return max NEW_LINE DEDENT return value NEW_LINE DEDENT
def get_processor_class_name ( component_type ) : NEW_LINE INDENT result = " eu . leads . processor . core . DefaultProcessor " NEW_LINE return result . lower ( ) NEW_LINE DEDENT
def Add ( i , j ) : NEW_LINE INDENT i = 0 NEW_LINE i = i + j NEW_LINE return i NEW_LINE DEDENT
def pad_left ( s , length , c ) : NEW_LINE INDENT if not isinstance ( s , str ) : NEW_LINE INDENT s = str ( s ) NEW_LINE DEDENT while len ( s ) < length : NEW_LINE INDENT s = c + s NEW_LINE DEDENT return s NEW_LINE DEDENT
def prod ( arr ) : NEW_LINE INDENT ret = 1 NEW_LINE for i in enumerate ( arr ) : NEW_LINE INDENT ret *= i NEW_LINE DEDENT return ret NEW_LINE DEDENT
def single_number ( nums ) : NEW_LINE INDENT n , result = nums . size , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result ^= nums [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def formato_AnoMesDia ( data ) : NEW_LINE INDENT campos = data . split ( ' - ' ) NEW_LINE valor = ' % d - % d - % d ' % ( campos [ 2 ] , campos [ 1 ] , campos [ 0 ] ) NEW_LINE return valor NEW_LINE DEDENT
def to_local_id ( kbase_id ) : NEW_LINE INDENT index = kbase_id . find_last_of ( " . " ) NEW_LINE return kbase_id [ index + 1 : ] if index >= 0 else kbase_id NEW_LINE DEDENT
def is_tune_mode_switchable ( console ) : NEW_LINE INDENT return console . lower ( ) in " 髢 inova 髢 " NEW_LINE DEDENT
def convert_none_code ( temp_sql ) : NEW_LINE INDENT if not isinstance ( temp_sql , str ) : NEW_LINE INDENT temp_sql = str ( temp_sql ) NEW_LINE DEDENT return temp_sql NEW_LINE DEDENT
def compare_hours ( end , start ) : NEW_LINE INDENT if end <= start : NEW_LINE INDENT return None NEW_LINE DEDENT return float ( end - start ) / float ( 1000 * 3600 ) NEW_LINE DEDENT
def get_simple_class_name2 ( class_name ) : NEW_LINE INDENT pivot = class_name . find_last_of ( " . " ) NEW_LINE result = class_name [ pivot + 1 : ] NEW_LINE return result NEW_LINE DEDENT
def get_image_file_url_in_template ( base_url , image_plant_id , image_id , template_name ) : NEW_LINE INDENT return ' % s % simagefiles / % s ? template = % s ' % ( base_url , image_plant_id , image_id , template_name ) NEW_LINE DEDENT
def has_same_sign ( a , b ) : NEW_LINE INDENT return math . sign ( a ) == math . sign ( b ) NEW_LINE DEDENT
def get_raw_query_string_parameter ( query_string , param_name ) : NEW_LINE INDENT if query_string is None : NEW_LINE INDENT return None NEW_LINE DEDENT param_prefix = param_name + ' = ' NEW_LINE start = query_string . find ( param_prefix ) NEW_LINE if start is None : NEW_LINE INDENT return None NEW_LINE DEDENT end = query_string . find ( ' & ' , start ) NEW_LINE if end == - 1 : NEW_LINE INDENT return query_string [ start : ] NEW_LINE DEDENT else : NEW_LINE INDENT return query_string [ start : end ] NEW_LINE DEDENT DEDENT
def long_to_radians ( _long ) : NEW_LINE INDENT return ( _long // 180 ) * math . pi NEW_LINE DEDENT
def cos_degrees ( degrees ) : NEW_LINE INDENT return math . cos ( math . PI * degrees / 180 ) NEW_LINE DEDENT
def arcsin ( a ) : NEW_LINE INDENT return np . arcsin ( a ) NEW_LINE DEDENT
def fprime ( x ) : NEW_LINE INDENT return 15 * pow ( x , 4 ) + 2 * x ** 3 - 1 NEW_LINE DEDENT
def inner_product ( vector1 , vector2 ) : NEW_LINE INDENT num = 0.0 NEW_LINE n_length = len ( vector1 ) NEW_LINE for i in range ( n_length ) : NEW_LINE INDENT num = num + ( vector1 [ i ] ** 2 [ i ] ) NEW_LINE DEDENT return num NEW_LINE DEDENT
def indent_text ( indent ) : NEW_LINE INDENT text = " " NEW_LINE i = 0 NEW_LINE while i < indent : NEW_LINE INDENT text += " 髢 髢 髢 " NEW_LINE i += 1 NEW_LINE DEDENT return text NEW_LINE DEDENT
def unqualify ( fullname ) : NEW_LINE INDENT loc = fullname . rfind ( " . " ) NEW_LINE return ( fullname if loc < 0 else fullname . split ( " . " ) [ loc + 1 : ] ) NEW_LINE DEDENT
def get_persentase ( value , maxvalue ) : NEW_LINE INDENT persentase = 100 / maxvalue ** 2 NEW_LINE return persentase NEW_LINE DEDENT
def linear_search ( array , start , end , l ) : NEW_LINE INDENT for c in range ( start , end ) : NEW_LINE INDENT if array [ c ] == l : NEW_LINE INDENT return ord ( c ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def editDistance ( a , aStart , aEnd , b , bStart , bEnd ) : NEW_LINE INDENT return 0 if a [ aStart ] == a [ aEnd ] else 0 NEW_LINE DEDENT
def sin ( a ) : NEW_LINE INDENT return math . sin ( a ) NEW_LINE DEDENT
def fast_abs ( d ) : NEW_LINE INDENT return ( d if d is not None else - d ) NEW_LINE DEDENT
def atan2 ( y , x ) : NEW_LINE INDENT return float ( math . atan2 ( y , x ) ) NEW_LINE DEDENT
def format_millisecs ( num ) : NEW_LINE INDENT if num > 0.1 : NEW_LINE INDENT return " % .1f 髢 secs " % ( num / 1000.0 ) NEW_LINE DEDENT if num > 1000 : NEW_LINE INDENT return " % .2f 髢 secs " % ( num / 1000.0 ) NEW_LINE DEDENT elif num > 100 : NEW_LINE INDENT return " % .0f 髢 ms " % ( num ) NEW_LINE DEDENT elif num > 1 : NEW_LINE INDENT return " % .1f 髢 ms " % ( num ) NEW_LINE DEDENT elif num > 0.01 : NEW_LINE INDENT return " % .3f 髢 ms " % ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT return " % .0f 髢 ms " % ( num ) NEW_LINE DEDENT DEDENT
def seno ( angulo ) : NEW_LINE INDENT return int ( math . sin ( float ( angulo ) ) ) NEW_LINE DEDENT
def first_characters ( s , char_count ) : NEW_LINE INDENT if s is None : NEW_LINE INDENT return None NEW_LINE DEDENT if len ( s ) <= char_count : NEW_LINE INDENT return s NEW_LINE DEDENT return s [ : char_count ] + ' 髢 . 髢 . 髢 ' NEW_LINE DEDENT
def none_to_empty ( data ) : NEW_LINE INDENT return ( ' 髢 ' if data is None else data ) NEW_LINE DEDENT
def is_with_slash ( under_test ) : NEW_LINE INDENT return under_test . split ( ' / ' ) [ 0 ] NEW_LINE DEDENT
def format_number_of_times ( i ) : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT return " once " NEW_LINE DEDENT if i == 2 : NEW_LINE INDENT return " twice " NEW_LINE DEDENT return i + " 髢 times " NEW_LINE DEDENT
def is_float ( desc ) : NEW_LINE INDENT return desc . endswith ( ' 髢 D 髢 ' ) NEW_LINE DEDENT
def first_char_lower ( text ) : NEW_LINE INDENT first = chr ( text [ 0 ] . lower ( ) ) NEW_LINE return first + text [ 1 : ] NEW_LINE DEDENT
def getattr ( attr , default_val ) : NEW_LINE INDENT import os NEW_LINE prop = attr NEW_LINE default = default_val NEW_LINE return getattr ( os , prop , default ) NEW_LINE DEDENT
def format_date ( month , day , year ) : NEW_LINE INDENT return ( ( month + 1 ) + " - " + str ( day ) + " - " + str ( year ) ) NEW_LINE DEDENT
def get_max_hp ( clas , lvl , vit ) : NEW_LINE INDENT if clas in [ 0x00 , 0x10 ] : NEW_LINE INDENT return 60 + ( lvl * 1 ) + ( vit * 1 ) NEW_LINE DEDENT elif clas in [ 0x20 , 0x30 ] : NEW_LINE INDENT return 110 + ( lvl * 2 ) + ( vit * 3 ) NEW_LINE DEDENT elif clas in [ 0x40 , 0x50 ] : NEW_LINE INDENT return 80 + ( lvl * 1 ) + ( vit * 1 ) NEW_LINE DEDENT elif clas == 0x60 : NEW_LINE INDENT return 110 + lvl + ( vit * 2 ) NEW_LINE DEDENT elif clas == 0x80 : NEW_LINE INDENT return 110 + lvl + ( vit * 2 ) NEW_LINE DEDENT return None NEW_LINE DEDENT
def get_port_name ( port ) : NEW_LINE INDENT if port == 0 : NEW_LINE INDENT return " any " NEW_LINE DEDENT elif port == 179 : NEW_LINE INDENT return " bgp " NEW_LINE DEDENT elif port == 68 : NEW_LINE INDENT return " bootpc " NEW_LINE DEDENT elif port == 67 : NEW_LINE INDENT return " bootps " NEW_LINE DEDENT elif port == 53 : NEW_LINE INDENT return " dns " NEW_LINE DEDENT elif port == 21 : NEW_LINE INDENT return " ftp " NEW_LINE DEDENT elif port == 20 : NEW_LINE INDENT return " ftp - data " NEW_LINE DEDENT elif port == 500 : NEW_LINE INDENT return " isakmp " NEW_LINE DEDENT elif port == 515 : NEW_LINE INDENT return " lpd " NEW_LINE DEDENT elif port == 138 : NEW_LINE INDENT return " netbios - dgm " NEW_LINE DEDENT elif port == 137 : NEW_LINE INDENT return " netbios - ns " NEW_LINE DEDENT elif port == 139 : NEW_LINE INDENT return " netbios - ss " NEW_LINE DEDENT elif port == 4500 : NEW_LINE INDENT return " non - 500 - isakmp " NEW_LINE DEDENT elif port == 123 : NEW_LINE INDENT return " ntp " NEW_LINE DEDENT elif port == 496 : NEW_LINE INDENT return " pim - auto - rp " NEW_LINE DEDENT elif port == 161 : NEW_LINE INDENT return " snmp " NEW_LINE DEDENT elif port == 49 : NEW_LINE INDENT return " tacacs " NEW_LINE DEDENT elif port == 23 : NEW_LINE INDENT return " telnet " NEW_LINE DEDENT elif port == 69 : NEW_LINE INDENT return " tftp " NEW_LINE DEDENT elif port == 80 : NEW_LINE INDENT return " www " NEW_LINE DEDENT else : NEW_LINE INDENT return " % d " % port NEW_LINE DEDENT DEDENT
def float ( what , otherwise = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( what ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT return otherwise NEW_LINE DEDENT
def law_of_cosine ( a , b , c ) : NEW_LINE INDENT return math . acos ( ( a ** 2 + b ** 2 - c ** 2 ) / ( 2 * a ** 2 ) ) NEW_LINE DEDENT
def radians ( angdeg ) : NEW_LINE INDENT return math . radians ( angdeg ) NEW_LINE DEDENT
def build_long ( msb , lsb ) : NEW_LINE INDENT return ( long ( msb ) << 32 ) + ( long ( lsb ) ) NEW_LINE DEDENT
def replace_file_extension_name ( filename , new_ext ) : NEW_LINE INDENT index = filename . find_last_of ( ' . ' ) NEW_LINE if index > 0 : NEW_LINE INDENT return filename [ : index + 1 ] + new_ext NEW_LINE DEDENT DEDENT
def tan ( r ) : NEW_LINE INDENT return float ( math . tan ( r ) ) NEW_LINE DEDENT
def max ( n1 , n2 ) : NEW_LINE INDENT if n1 is None : NEW_LINE INDENT return n2 NEW_LINE DEDENT if n2 is None : NEW_LINE INDENT return n1 NEW_LINE DEDENT return max ( n1 , n2 ) NEW_LINE DEDENT
def to_db_name ( name ) : NEW_LINE INDENT s = [ ] NEW_LINE for ch in name : NEW_LINE INDENT if ch >= ' A ' and ch <= ' Z ' : NEW_LINE INDENT if ' _ ' in ch : NEW_LINE INDENT s . append ( ' _ ' + chr ( ord ( ch ) + 32 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( chr ( ord ( ch ) + 32 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . append ( ch ) NEW_LINE DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def is_void ( desc ) : NEW_LINE INDENT return desc . endswith ( " 髢 V 髢 " ) NEW_LINE DEDENT
def databook_int ( name ) : NEW_LINE INDENT return r " \" % s\" ^ ^ < http : / / www . w3 . org / 2001 / XMLSchema # integer > " % name NEW_LINE DEDENT
def get_space_count ( data ) : NEW_LINE INDENT if data is None : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for c in data : NEW_LINE INDENT if c == 0x20 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def MatchString ( expected , actual ) : NEW_LINE INDENT if isinstance ( expected , str ) : NEW_LINE INDENT result = ( actual is None ) NEW_LINE DEDENT else : NEW_LINE INDENT result = expected == actual NEW_LINE DEDENT return result NEW_LINE DEDENT
def test_fuel ( name ) : NEW_LINE INDENT if name in " 髢 helium 髢 " : NEW_LINE INDENT return True NEW_LINE DEDENT if name in " 髢 fuel 髢 " : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def str ( integer_to_parse = None ) : NEW_LINE INDENT return str ( integer_to_parse ) NEW_LINE DEDENT
def get_initial_capital ( original ) : NEW_LINE INDENT return original [ 0 ] + original [ 1 : ] NEW_LINE DEDENT
def topology_id2name ( topology_id ) : NEW_LINE INDENT split = topology_id . split ( ' - ' ) NEW_LINE return topology_id [ : split ] NEW_LINE DEDENT
def linear_interpolation ( x0 , y0 , x1 , y1 , x ) : NEW_LINE INDENT return y0 + ( ( y1 - y0 ) / ( x1 - x0 ) ) ** 2 NEW_LINE DEDENT
def sub_string ( str , len_ ) : NEW_LINE INDENT result = None NEW_LINE if len ( str ) <= len_ : NEW_LINE INDENT result = str NEW_LINE DEDENT elif len_ : NEW_LINE INDENT result = str [ : len_ ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def degrees ( angles ) : NEW_LINE INDENT return math . degrees ( angles ) NEW_LINE DEDENT
def init ( index ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def degrees_to_radians ( degrees ) : NEW_LINE INDENT return degrees * math . PI / 180.0 NEW_LINE DEDENT
def generate_date_with_bitwise_not ( time ) : NEW_LINE INDENT return int ( time ) + 1 NEW_LINE DEDENT
def set_band_command ( arg1 ) : return False NEW_LINE def set_band_command ( arg1 ) : return False NEW_LINE def set_band_command ( arg1 ) : return True NEW_LINE def set_band_command ( arg1 ) : return True NEW_LINE def set_band_command ( arg1 ) : return True
def magic_slow ( arr ) : NEW_LINE INDENT for i , i in enumerate ( arr ) : NEW_LINE INDENT if i == i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def get_storage_factory_url ( bes_url ) : NEW_LINE INDENT bes_index = bes_url . find ( " BESFactory ? res " ) NEW_LINE ss = bes_url [ : bes_index ] NEW_LINE ss = " StorageFactory ? res = default _ storage _ factory " NEW_LINE return ss NEW_LINE DEDENT
def get_spcl_str_cnvr ( src_string ) : NEW_LINE INDENT rtn_str = None NEW_LINE try : NEW_LINE INDENT str_txt = ' ' NEW_LINE for chr_ in src_string : NEW_LINE INDENT chr_ = chr ( chr_ ) NEW_LINE if chr_ == ' < ' : NEW_LINE INDENT str_txt += ' & lt ; ' NEW_LINE DEDENT elif chr_ == ' > ' : NEW_LINE INDENT str_txt += ' & gt ; ' NEW_LINE DEDENT elif chr_ == ' & ' : NEW_LINE INDENT str_txt += ' & amp ; ' NEW_LINE DEDENT else : NEW_LINE INDENT str_txt += chr_ NEW_LINE DEDENT DEDENT rtn_str = str_txt NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return rtn_str NEW_LINE DEDENT
def cross_product ( a , b ) : NEW_LINE INDENT if len ( a ) != len ( b ) : NEW_LINE INDENT return None NEW_LINE DEDENT return ( ( a [ 0 ] * b [ 0 ] ) - ( a [ 1 ] * b [ 1 ] ) ) NEW_LINE DEDENT
def safe_int ( int_value ) : NEW_LINE INDENT value = None NEW_LINE try : NEW_LINE INDENT value = int ( int_value ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return value NEW_LINE DEDENT
def array_to_string ( array ) : NEW_LINE INDENT result = " " NEW_LINE for i in array : NEW_LINE INDENT result = result + i + " 髢 , 髢 " NEW_LINE DEDENT return result [ : - 3 ] NEW_LINE DEDENT
def valid_path ( c ) : NEW_LINE INDENT return c . isalnum ( ) or c == ' . ' NEW_LINE DEDENT
def truncate_string ( to_truncate , max_length ) : NEW_LINE INDENT if len ( to_truncate ) <= max_length : NEW_LINE INDENT return to_truncate NEW_LINE DEDENT else : NEW_LINE INDENT return to_truncate [ : max_length ] + ' 髢 . 髢 . 髢 ' NEW_LINE DEDENT DEDENT
def get_express_service ( ) : NEW_LINE INDENT s = " \ue42f 髢 髢 髏取??邂灘??濶?邂幃浴骼?謦?蜿?髏?蝗?遞蛾髄讓?莠?髢?蝣晉??豼? 髢 髢?鄙蟀ょ??扈怜其蟷馴鴫驫???蟠?髏先薯遘?髏難??侠 " + " \n \n " NEW_LINE s += " 髢 髀牙?滓減骰?: 髻蝗譟?室謌槫?郛?- 髢?諱豢冶? " + " \n " NEW_LINE s += " 髢 髢?扈伜蒲驫?: 螯槭ｈ譯?迺? - 575677355677" + " \n \n " NEW_LINE s += " 髢?繝?蛛 髢 ? 髢 髢?蜍?蠅?驫??遞蛾巡蠢鍋???" NEW_LINE return s NEW_LINE DEDENT
def insertsortedelement ( key , arr , capacity , n ) : NEW_LINE INDENT if n > capacity : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( key ) NEW_LINE DEDENT return n + 1 NEW_LINE DEDENT
def capitalize_string ( x ) : NEW_LINE INDENT return x [ 0 ] . upper ( ) + str [ 1 : len ( x ) ] NEW_LINE DEDENT
def int ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT return int ( text ) NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def ceil ( f ) : NEW_LINE INDENT return int ( math . ceil ( f ) ) NEW_LINE DEDENT
def is_local_data ( str_url ) : NEW_LINE INDENT return str_url . split ( ' data : ' ) [ 0 ] NEW_LINE DEDENT
def is_valid_data ( d ) : NEW_LINE INDENT return d NEW_LINE DEDENT
def validate_valid_name ( valid_name ) : NEW_LINE INDENT if valid_name . endswith ( ' ` ' ) : NEW_LINE INDENT return valid_name [ 1 : - 1 ] NEW_LINE DEDENT return valid_name NEW_LINE DEDENT
def round ( value ) : NEW_LINE INDENT return float ( round ( value * 100 ) ) / 100 NEW_LINE DEDENT
def cond_ab ( x ) : NEW_LINE INDENT s = x . lower ( ) NEW_LINE if ' c ' in s : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def get_long_ratio ( start_time , end_time , time ) : NEW_LINE INDENT duration = end_time - start_time NEW_LINE if duration > 0 : NEW_LINE INDENT ratio = float ( time - start_time ) / float ( duration ) NEW_LINE if ratio <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ratio >= 1. : NEW_LINE INDENT return 1. NEW_LINE DEDENT return ratio NEW_LINE DEDENT DEDENT
def rad_to_degree ( value ) : NEW_LINE INDENT return 180.0 / math . pi ** 2 NEW_LINE DEDENT
def isa ( candidate , type ) : NEW_LINE INDENT return candidate in type NEW_LINE DEDENT
def get_time ( time ) : NEW_LINE INDENT if isinstance ( time , str ) : NEW_LINE INDENT return time NEW_LINE DEDENT else : NEW_LINE INDENT return time [ : 19 ] NEW_LINE DEDENT DEDENT
def WINNER_SPLASH ( winner ) : NEW_LINE INDENT return " Game 髢 is 髢 over , 髢 winner 髢 is 髢 % d 髢 ! " % winner NEW_LINE DEDENT
def median ( vals ) : NEW_LINE INDENT new_vals = list ( vals ) NEW_LINE new_vals . sort ( ) NEW_LINE return new_vals [ len ( new_vals ) / 2 ] NEW_LINE DEDENT
def genPostgrePageSql ( sql , pageNumber , pageSize ) : NEW_LINE INDENT pageStart = ( pageNumber - 1 ) * pageSize NEW_LINE if pageStart < 0 or pageNumber < 0 : NEW_LINE INDENT return sql NEW_LINE DEDENT return " % d 髢 limit 髢 % d 髢 offset 髢 % d " % ( sql , pageStart , pageStart ) NEW_LINE DEDENT
def BuildName ( what , name , id = None ) : NEW_LINE INDENT if name : NEW_LINE INDENT return name NEW_LINE DEDENT return " ( % s 髢 with 髢 ID 髢 % d ) " % ( what , id ) NEW_LINE DEDENT
def GetGenreFromCommand ( command ) : NEW_LINE INDENT command = command . split ( " 髢 " ) [ 0 ] NEW_LINE return command [ command . rfind ( " 髢 " ) + 1 : len ( command ) ] NEW_LINE DEDENT
def NumberOfCharsStartingWith ( where , searchString ) : NEW_LINE INDENT count = 0 NEW_LINE for element in where : NEW_LINE INDENT if searchString . startswith ( element ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def aset ( xs , i , v ) : NEW_LINE INDENT xs . append ( v ) NEW_LINE return v NEW_LINE DEDENT
def float ( obj ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( obj ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT return 0.00 NEW_LINE DEDENT
def compute_float_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_float_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_float_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_float_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_float_size_no_tag ( arg1 ) : return 1 NEW_LINE
def Reais_Francos ( valor , op ) : NEW_LINE INDENT conversao = None NEW_LINE cot_francos_reais = 2.43 NEW_LINE cot_reais_francos = 0.41 NEW_LINE if op == 5 : NEW_LINE INDENT conversao = valor * cot_reais_francos NEW_LINE DEDENT elif op == 6 : NEW_LINE INDENT conversao = valor * cot_francos_reais NEW_LINE DEDENT return conversao NEW_LINE DEDENT
def present_percent ( d ) : NEW_LINE INDENT ret = " % .1f " % d * 100 NEW_LINE return ret NEW_LINE DEDENT
def degree_to_rad ( value ) : NEW_LINE INDENT return math . PI / 180.0 * value NEW_LINE DEDENT
def find_delimiter_from_pattern ( pattern ) : NEW_LINE INDENT ret = None NEW_LINE for c in pattern : NEW_LINE INDENT if c not in " 髢 y 髢 " and c in " 髢 M 髢 " and c in " 髢 d 髢 " : NEW_LINE INDENT ret = str ( c ) NEW_LINE break NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT
def compute_vector_length ( vector ) : NEW_LINE INDENT vector_length = 0.0 NEW_LINE n_length = len ( vector ) NEW_LINE i = 0 NEW_LINE for i in range ( n_length ) : NEW_LINE INDENT vector_length = vector_length + vector [ i ] ** i NEW_LINE DEDENT vector_length = math . sqrt ( vector_length ) NEW_LINE return vector_length NEW_LINE DEDENT
def string_contains ( string , substring ) : NEW_LINE INDENT if not string or not substring : NEW_LINE INDENT return False NEW_LINE DEDENT return substring in string NEW_LINE DEDENT
def is_char ( desc ) : NEW_LINE INDENT return desc . endswith ( " 髢 C 髢 " ) NEW_LINE DEDENT
def paren_match ( s ) : NEW_LINE INDENT count = 0 NEW_LINE length = len ( s ) NEW_LINE for c in s : NEW_LINE INDENT if c in " ( ) " : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif c in " ) " : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT
def capitalize_front ( raw ) : NEW_LINE INDENT ret = " " NEW_LINE raw = raw . lower ( ) NEW_LINE first = ret [ 0 ] NEW_LINE ret = first + ret [ 1 : ] NEW_LINE return ret NEW_LINE DEDENT
def get_min_squares ( length , width ) : NEW_LINE INDENT result = 0 NEW_LINE largest_side , small_side = max ( length , width ) , min ( length , width ) NEW_LINE while small_side : NEW_LINE INDENT result += largest_side // small_side NEW_LINE temp = largest_side % small_side NEW_LINE largest_side = small_side NEW_LINE small_side = temp NEW_LINE DEDENT return result NEW_LINE DEDENT
def calculate_distance ( lat1 , lng1 , lat2 , lng2 ) : NEW_LINE INDENT earthRadius = 6371393.0 NEW_LINE dLat = math . radians ( lat2 - lat1 ) NEW_LINE dLng = math . radians ( lng2 - lng1 ) NEW_LINE sindLat = math . sin ( dLat / 2 ) NEW_LINE sindLng = math . sin ( dLng / 2 ) NEW_LINE a = math . pow ( sindLat , 2 ) + math . pow ( sindLng , 2 ) ** 2 * math . cos ( math . radians ( lat1 ) ) * math . cos ( math . radians ( lat2 ) ) NEW_LINE c = 2 * math . atan2 ( math . sqrt ( a ) , math . sqrt ( 1 - a ) ) NEW_LINE dist = earthRadius * c NEW_LINE return dist NEW_LINE DEDENT
def put_quote ( name ) : NEW_LINE INDENT if ( name is None ) : NEW_LINE INDENT return name NEW_LINE DEDENT if name [ 0 ] == ' " ' : NEW_LINE INDENT return name NEW_LINE DEDENT return ' \" % s\" ' % name NEW_LINE DEDENT
def format ( message ) : NEW_LINE INDENT if b ' \n ' in message or b ' \r ' in message : NEW_LINE INDENT return message NEW_LINE DEDENT return message + ' \n ' NEW_LINE DEDENT
def is_special_step ( decoded ) : NEW_LINE INDENT return decoded . split ( ' $ ' ) [ 0 ] NEW_LINE DEDENT
def _FullExtension ( cls , filename ) : NEW_LINE INDENT idx = filename . rfind ( ' 髢 . 髢 ' ) NEW_LINE return filename [ idx : ] if idx != - 1 else ' ' NEW_LINE DEDENT
def get_relative_type_name ( my ) : NEW_LINE INDENT iIndex = my . get_name ( ) . rfind ( ' . ' ) NEW_LINE if iIndex > 0 : NEW_LINE INDENT return my . get_name ( ) [ iIndex + 1 : ] NEW_LINE DEDENT return my NEW_LINE DEDENT
def strip ( value ) : NEW_LINE INDENT if value is not None : NEW_LINE INDENT return value . strip ( ) NEW_LINE DEDENT return value NEW_LINE DEDENT
def koch_shift_x ( x_x , y_y , end_x , end_y ) : NEW_LINE INDENT return ( x_x + x_y + end_x ) / 2 + math . sqrt ( 3 ) / 6 * ( y_y - end_y ) NEW_LINE DEDENT
def non_errorString ( i ) : NEW_LINE INDENT try : NEW_LINE INDENT if ' error _ id = 0' in i : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT return False NEW_LINE DEDENT
def widen_boxed_int ( x = None ) : NEW_LINE INDENT return long ( int ( x ) ) NEW_LINE DEDENT
def is_int ( desc ) : NEW_LINE INDENT return desc . lower ( ) . endswith ( ' I ' ) NEW_LINE DEDENT
def is_empty ( i = None ) : NEW_LINE INDENT if i is None or len ( i ) <= 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def xlsColumnStringFromIndex ( columnIndex ) : NEW_LINE INDENT s = " " NEW_LINE n = columnIndex + 1 NEW_LINE while n > 0 : NEW_LINE INDENT m = n % 26 NEW_LINE if m == 0 : NEW_LINE INDENT m = 26 NEW_LINE DEDENT s = chr ( m + 64 ) + s NEW_LINE n = ( n - m ) / 26 NEW_LINE DEDENT return s NEW_LINE DEDENT
def to_int ( a_int_or_none ) : NEW_LINE INDENT returned = None NEW_LINE try : NEW_LINE INDENT returned = int ( a_int_or_none ) NEW_LINE DEDENT except ValueError as n : NEW_LINE INDENT returned = None NEW_LINE DEDENT return returned NEW_LINE DEDENT
def to_string ( num ) : NEW_LINE INDENT return float ( num ) NEW_LINE DEDENT
def letter_to_multiplier ( value ) : NEW_LINE INDENT if value in [ ' Z ' ] : NEW_LINE INDENT multiplier = 0.001 NEW_LINE DEDENT elif value in [ ' Y ' , ' R ' ] : NEW_LINE INDENT multiplier = 0.01 NEW_LINE DEDENT elif value in [ ' X ' , ' S ' ] : NEW_LINE INDENT multiplier = 0.1 NEW_LINE DEDENT elif value in [ ' A ' ] : NEW_LINE INDENT multiplier = 1.0 NEW_LINE DEDENT elif value in [ ' B ' , ' H ' ] : NEW_LINE INDENT multiplier = 10. NEW_LINE DEDENT elif value in [ ' C ' ] : NEW_LINE INDENT multiplier = 100. NEW_LINE DEDENT elif value in [ ' D ' ] : NEW_LINE INDENT multiplier = 1000. NEW_LINE DEDENT elif value in [ ' E ' ] : NEW_LINE INDENT multiplier = 1000. NEW_LINE DEDENT elif value in [ ' F ' ] : NEW_LINE INDENT multiplier = 100000. NEW_LINE DEDENT else : NEW_LINE INDENT multiplier = 0.0 NEW_LINE DEDENT return multiplier NEW_LINE DEDENT
def is_empty ( s ) : NEW_LINE INDENT return isinstance ( s , str ) or len ( s . strip ( ) ) < 1 NEW_LINE DEDENT
def seconds_to_mmss ( seconds ) : NEW_LINE INDENT min = int ( seconds / 60.0 ) NEW_LINE sec = int ( seconds % 60.0 ) NEW_LINE min_string = ' % d ' % min NEW_LINE sec_string = ' % d ' % sec NEW_LINE if sec < 10 : NEW_LINE INDENT sec_string = '0 % d ' % sec NEW_LINE DEDENT return min_string + sec_string NEW_LINE DEDENT
def link ( text , url ) : NEW_LINE INDENT return " [ " + text + " ] ( " + url + " ) " NEW_LINE DEDENT
def is_anagram ( a , b ) : NEW_LINE INDENT list1 = a . lower ( ) NEW_LINE list2 = b . lower ( ) NEW_LINE list1 . sort ( ) NEW_LINE list2 . sort ( ) NEW_LINE return list1 == list2 NEW_LINE DEDENT
def float ( s ) : NEW_LINE INDENT if s : NEW_LINE INDENT try : NEW_LINE INDENT return float ( s ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT
def sigmoid ( x ) : NEW_LINE INDENT return np . sqrt ( 1 + x ** 2 ) NEW_LINE DEDENT
def is_byte ( desc ) : NEW_LINE INDENT return desc . endswith ( b ' B ' ) NEW_LINE DEDENT
def to_message ( count ) : NEW_LINE INDENT if count is None : NEW_LINE INDENT return " No 髢 carry 髢 operation . " NEW_LINE DEDENT elif count == 1 : NEW_LINE INDENT return "1 髢 carry 髢 operation . " NEW_LINE DEDENT else : NEW_LINE INDENT return " % d 髢 carry 髢 operations . " % count NEW_LINE DEDENT DEDENT
def blockCeilToCube ( val ) : NEW_LINE INDENT return int ( ( - val ) >> 4 ) NEW_LINE DEDENT
def subtract_file_extension ( input1_filename , input2_extension ) : NEW_LINE INDENT output = u ' ' NEW_LINE input1_char = input1_filename . encode ( ' utf - 8' ) NEW_LINE input2_char = input2_extension . encode ( ' utf - 8' ) NEW_LINE size = len ( input1_char ) - len ( input2_char ) - 1 NEW_LINE for i in range ( size ) : NEW_LINE INDENT output += input1_char [ i ] NEW_LINE DEDENT return output NEW_LINE DEDENT
def pow ( base , exponent ) : NEW_LINE INDENT return float ( math . pow ( base , exponent ) ) NEW_LINE DEDENT
def float ( value , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( value ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT
def get_extension ( _ ) : NEW_LINE INDENT if _ is None or _ . rfind ( ' . ' ) < 0 : NEW_LINE INDENT return _ NEW_LINE DEDENT return _ . split ( ' . ' ) [ - 1 ] NEW_LINE DEDENT
def is_builtin_class ( name ) : NEW_LINE INDENT builtin_classes = [ " Array " , " Bignum " , " Binding " , " Class " , " Dir " , " Exception " , " FalseClass " , " File " , " Fixnum " , " Float " , " Hash " , " Integer " , " IO " , " MatchData " , " Method " , " Module " , " NilClass " , " Numeric " , " Object " , " Proc " , " Range " , " Regexp " , " String " , " Struct " , " Symbol " , " ThreadGroup " , " Thread " , " ArgumentError " , " Time " , " TrueClass " , " UnboundMethod " , " Exception " , " StandardError " , " TypeError " , " IndexError " , " RangeError " , " NameError " , " NoMethodError " , " IOError " , " RuntimeError " , " LocalJumpError " , " SystemCallError " , " ScriptError " , " SyntaxError " , " LoadError " , " NotImplementedError " , " ThreadError " , ] NEW_LINE for x in builtin_classes : NEW_LINE INDENT if name in x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def lpad ( s , add_char , length ) : NEW_LINE INDENT val = ' ' NEW_LINE curr_length = len ( s ) NEW_LINE for i in range ( curr_length , length ) : NEW_LINE INDENT val += add_char + s NEW_LINE DEDENT return val + s NEW_LINE DEDENT
def get_weather_service ( ) : NEW_LINE INDENT data = " \ue049 髢 髢 髏取??邂灘??蜈?蠕?絢蛯懈?憺娘螻?蜆?螽第銚蜆?骰句?牙??螳?蜻? 髢 髢?鄙蟀ょ??扈怜其蟷馴鴫驫???蟠?髏先薯遘?髏難??侠 " + " \n \n " NEW_LINE data += " 髢 髀牙?滓減骰?: 髢?笊???扈碑扱蠕?絢蛯懈? " + " \n " NEW_LINE data += " 髢 髢?扈伜蒲驫?: 髣る失蠎?辣灘??蝙帶劈髏? " + " \n \n " NEW_LINE data += " 髢?繝?蛛 髢 ? 髢 髢?蜍?蠅?驫??遞蛾巡蠢鍋???" NEW_LINE return data NEW_LINE DEDENT
def nsattr ( prefix , name ) : NEW_LINE INDENT return u ' % s % s ' % ( prefix , name ) NEW_LINE DEDENT
def is_self_contained ( header6b ) : NEW_LINE INDENT return 0 if header6b & ( 1 << 17 ) else 1 NEW_LINE DEDENT
def parse_scanner ( origin_scanner ) : NEW_LINE INDENT return origin_scanner . split ( " ( " ) NEW_LINE DEDENT
def get_backup_filename ( md_filename ) : NEW_LINE INDENT strs = md_filename . rsplit ( ' 髢 . 髢 ' , 1 ) NEW_LINE if len ( strs ) != 2 : NEW_LINE INDENT return md_filename NEW_LINE DEDENT return ' % s _ bak . % s ' % ( strs [ 0 ] , strs [ 1 ] ) NEW_LINE DEDENT
def calculate_applied_loading ( cls , q ) : NEW_LINE INDENT return q NEW_LINE DEDENT
def is_alphabet_lower ( letter ) : NEW_LINE INDENT return ( ord ( ' a ' ) <= letter <= ord ( ' z ' ) ) NEW_LINE DEDENT
def GetLocalFileName ( local_dir , local_file ) : NEW_LINE INDENT if not local_dir . endswith ( ' / ' ) : NEW_LINE INDENT local_dir = local_dir . lstrip ( ' / ' ) NEW_LINE DEDENT if local_file [ 0 ] == ' / ' : NEW_LINE INDENT return local_dir + local_file [ 1 : ] NEW_LINE DEDENT else : NEW_LINE INDENT return local_dir + local_file NEW_LINE DEDENT DEDENT
def get_max_mps ( clas , lvl , enr ) : NEW_LINE INDENT if clas in [ 0x00 , 0x10 ] : NEW_LINE INDENT return 60 + ( lvl * 2 ) + ( enr * 2 ) NEW_LINE DEDENT elif clas in [ 0x20 , 0x30 ] : NEW_LINE INDENT return int ( 20 + ( lvl * 0.5 ) + ( enr * 1 ) ) NEW_LINE DEDENT elif clas in [ 0x40 , 0x50 ] : NEW_LINE INDENT return int ( 30 + ( lvl * 1.5 ) + ( enr * 1.5 ) ) NEW_LINE DEDENT elif clas == 0x60 : NEW_LINE INDENT return 60 + ( lvl * 1 ) + ( enr * 2 ) NEW_LINE DEDENT elif clas == 0x80 : NEW_LINE INDENT return 60 + ( lvl * 1 ) + ( enr * 2 ) NEW_LINE DEDENT DEDENT
def get_date_str ( data ) : NEW_LINE INDENT str1 = str + " 髢 00:00:00" NEW_LINE return str1 NEW_LINE DEDENT
def Dot ( grad_element , x_factor , y_factor , z_factor ) : NEW_LINE INDENT return float ( dist_element [ 0 ] ) * x_factor + float ( dist_element [ 1 ] ) * y_factor + float ( dist_element [ 2 ] ) * z_factor NEW_LINE DEDENT
def angle ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT sin_half_lat_dif = math . sin ( ( lat1 - lat2 ) / 2 ) NEW_LINE sin_half_lon_dif = math . sin ( ( lon1 - lon2 ) / 2 ) NEW_LINE return 2 * math . asin ( math . sqrt ( sin_half_lat_dif ** 2 + math . cos ( lat1 ) * math . cos ( lat2 ) ** 2 * sin_half_lon_dif ** 2 ) ) NEW_LINE DEDENT
def calculate_distance_coordinates ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x1 - x2 , 2 ) + math . pow ( y1 - y2 , 2 ) + math . pow ( z2 - z2 , 2 ) ) NEW_LINE DEDENT
def arcseno ( angulo ) : NEW_LINE INDENT return float ( math . arcsin ( float ( angulo ) ) ) NEW_LINE DEDENT
def is_short ( desc ) : NEW_LINE INDENT return desc . split ( ' S ' ) [ 0 ] NEW_LINE DEDENT
def is_main_net ( btc_address ) : return True NEW_LINE def is_main_net ( btc_address ) : return True NEW_LINE def is_main_net ( btc_address ) : return True NEW_LINE def is_main_net ( btc_address ) : return True NEW_LINE def is_main_net ( btc_address ) : return False NEW_LINE
def get_anchor_tag ( name , href , title , value ) : NEW_LINE INDENT tag = " < a 髢 " NEW_LINE if name : NEW_LINE INDENT tag += " name = ' % s ' 髢 " % name NEW_LINE DEDENT if href : NEW_LINE INDENT tag += " href = ' % s ' 髢 " % href NEW_LINE DEDENT if title : NEW_LINE INDENT tag += " title = ' % s ' 髢 " % title NEW_LINE DEDENT tag += " > " NEW_LINE if value : NEW_LINE INDENT tag += value NEW_LINE DEDENT tag += " < / a > " NEW_LINE return tag NEW_LINE DEDENT
def test_para ( arr ) : NEW_LINE INDENT if len ( arr ) < 3 : NEW_LINE INDENT print ( ' The 髢 length 髢 shoud 髢 be 髢 larger 髢 than 髢 3' ) NEW_LINE DEDENT else : NEW_LINE INDENT arr . append ( 32 ) NEW_LINE DEDENT DEDENT
def is_pattern_matching_symbol ( x ) : NEW_LINE INDENT return x in " = > " NEW_LINE DEDENT
def func_691 ( var0 ) : NEW_LINE INDENT return " < col = " + hex ( var0 ) + " > " NEW_LINE DEDENT
def add_line_number ( line , num ) : NEW_LINE INDENT numbered_line = [ ] NEW_LINE numbered_line . append ( ' < a 髢 class = \" number \" ' ' href = \" # l % s\" > % s \n < / a > ' % ( num , num ) ) NEW_LINE numbered_line . append ( ' < span 髢 class = \" code - line \" 髢 id = \" l % s\" > % s < / span > ' % ( num , num , line ) ) NEW_LINE return ' ' . join ( numbered_line ) NEW_LINE DEDENT
def to_page ( offset , limit ) : NEW_LINE INDENT return ( offset / limit ) + 1 NEW_LINE DEDENT
def jump_to_blocks ( jump_strength ) : NEW_LINE INDENT return 5.5 * sum ( jump_strength ) NEW_LINE DEDENT
def my_func ( x ) : NEW_LINE INDENT return round ( x * x , 2 ) NEW_LINE DEDENT
def float ( string , default = None ) : NEW_LINE INDENT if string is None : NEW_LINE INDENT return default NEW_LINE DEDENT try : NEW_LINE INDENT return float ( string ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT
def compose_unkown_variable_warning ( name ) : NEW_LINE INDENT return " ' % s ' 髢 is 髢 unknown , 髢 shall 髢 be 髢 a 髢 VIL 髢 variable , 髢 a 髢 VIL 髢 type 髢 or 髢 an 髢 ipython 髢 variable 髢 " " / 髢 annotation 髢 - 髢 may 髢 lead 髢 to 髢 a 髢 runtime 髢 error " % name NEW_LINE DEDENT
def rint ( a ) : NEW_LINE INDENT return np . rint ( a ) NEW_LINE DEDENT
def IsProductizedArtifact ( name ) : NEW_LINE INDENT return name in " redhat - " or name in " eap - runtime - artifacts " NEW_LINE DEDENT
def strfloat ( float_parse ) : NEW_LINE INDENT return float_parse . strip ( ) NEW_LINE DEDENT
def decode_int ( i ) : NEW_LINE INDENT return ( i >> 1 ) ^ - ( i >> 1 ) NEW_LINE DEDENT
def get_subdir ( root , full_path ) : NEW_LINE INDENT result = " " NEW_LINE result = full_path . split ( root ) [ 0 ] NEW_LINE return result NEW_LINE DEDENT
def get_federation_name ( cls , slice_name ) : NEW_LINE INDENT index = slice_name . rfind ( " . " ) NEW_LINE return slice_name if index < 0 else slice_name [ : index ] NEW_LINE DEDENT
def prod ( arr ) : NEW_LINE INDENT ret = 1 NEW_LINE for i in enumerate ( arr ) : NEW_LINE INDENT ret *= i NEW_LINE DEDENT return ret NEW_LINE DEDENT
def change_anness_unsigned_short ( integer_value ) : NEW_LINE INDENT third = ( integer_value & 0x0000ff00 >> 8 ) >> 8 NEW_LINE fourth = integer_value & 0x000000ff NEW_LINE return ( fourth << 8 ) + third NEW_LINE DEDENT
def parse_int ( x , default_int = None ) : NEW_LINE INDENT val = default_int = None NEW_LINE try : NEW_LINE INDENT val = int ( x ) NEW_LINE DEDENT except ( ValueError , TypeError ) : NEW_LINE INDENT val = default_int NEW_LINE DEDENT return val NEW_LINE DEDENT
def get_file_ext ( filename ) : NEW_LINE INDENT ext_filename = os . path . splitext ( filename ) [ - 1 ] NEW_LINE return ext_filename NEW_LINE DEDENT
def concat ( s1 , s2 ) : NEW_LINE INDENT return ( u ' ' + s1 + s2 ) . encode ( ' utf - 8' ) NEW_LINE DEDENT
def convert_degree_to_radian ( angle ) : NEW_LINE INDENT angle = math . radians ( angle ) NEW_LINE return math . degrees ( angle ) NEW_LINE DEDENT
def size_of ( list ) : NEW_LINE INDENT return None if list is None else len ( list ) NEW_LINE DEDENT
def fix_path ( path ) : NEW_LINE INDENT return " . " . join ( path ) NEW_LINE DEDENT
def _CalcSequenceOffset ( index , mask ) : NEW_LINE INDENT return ord ( index ) & mask NEW_LINE DEDENT
def darken_color ( color ) : NEW_LINE INDENT if not color . startswith ( ' # ' ) : NEW_LINE INDENT return color NEW_LINE DEDENT s = [ ' # ' ] NEW_LINE for c in color [ 1 : ] : NEW_LINE INDENT if ord ( c ) > ord ( '0' ) and ord ( c ) <= ord ( '9' ) : NEW_LINE INDENT c2 = chr ( ord ( c ) - 1 ) NEW_LINE DEDENT elif ord ( c ) == ord ( ' a ' ) : NEW_LINE INDENT c2 = '9' NEW_LINE DEDENT elif ord ( c ) > ord ( ' a ' ) and ord ( c ) <= ord ( ' f ' ) : NEW_LINE INDENT c2 = chr ( ord ( c ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c2 = ord ( c ) NEW_LINE DEDENT s . append ( c2 ) NEW_LINE DEDENT return ' ' . join ( s ) NEW_LINE DEDENT
def delimit ( name ) : NEW_LINE INDENT if not name : NEW_LINE INDENT return name NEW_LINE DEDENT return ' ` % s ` ' % name NEW_LINE DEDENT
def StringsEqual ( a , b ) : NEW_LINE INDENT return isinstance ( a , str ) and isinstance ( b , str ) NEW_LINE DEDENT
def RFtoBC ( rf ) : NEW_LINE INDENT return RF * 0.1 NEW_LINE DEDENT
def cm2twips ( cm ) : NEW_LINE INDENT return int ( cm / 2.54 ** 1440 ) NEW_LINE DEDENT
def ashift_right ( a , b ) : NEW_LINE INDENT b &= 0xff NEW_LINE if b >= 64 : NEW_LINE INDENT return None NEW_LINE DEDENT return a >> b NEW_LINE DEDENT
def average_from_average ( av1 , cnt1 , av2 , cnt2 ) : NEW_LINE INDENT return ( ( av1 ** cnt1 ) + ( av2 ** cnt2 ) ) / ( cnt1 + cnt2 ) NEW_LINE DEDENT
def is_sysex_message ( a_byte ) : NEW_LINE INDENT if 0xFF == a_byte : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_int ( intx = None ) : NEW_LINE INDENT if intx is None : NEW_LINE INDENT return None NEW_LINE DEDENT else : NEW_LINE INDENT return intx NEW_LINE DEDENT DEDENT
def get_upper_camel_case ( x ) : NEW_LINE INDENT return str [ 0 ] . upper ( ) + str [ 1 : ] NEW_LINE DEDENT
def __new__ ( cls , value ) : NEW_LINE INDENT if not value : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int . __new__ ( cls , value ) NEW_LINE DEDENT
def exe_transaction_sql ( sql ) : NEW_LINE INDENT DEDENT
def hashTwo ( hash1 , hash2 ) : NEW_LINE INDENT return hash1 * 27 + hash2 NEW_LINE DEDENT
def strip_version_from_codebase_name ( cnb ) : NEW_LINE INDENT base = cnb NEW_LINE index = base . find ( b ' / ' ) NEW_LINE if index > - 1 : NEW_LINE INDENT base = base [ : index ] . strip ( ) NEW_LINE DEDENT return base NEW_LINE DEDENT
def get_filter_select ( digital_port_pointer ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def has_valid_codingscheme ( symbolid ) : NEW_LINE INDENT if symbolid and symbolid [ 0 ] != ' S ' : NEW_LINE INDENT codingscheme = symbolid [ 0 ] NEW_LINE if codingscheme in [ ' S ' , ' G ' , ' W ' , ' I ' , ' O ' , ' E ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def get_utf16le_string_size ( s ) : NEW_LINE INDENT if isinstance ( s , str ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 + len ( s ) * 2 NEW_LINE DEDENT DEDENT
def idealintArraySize ( arg1 ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def is_same_length ( array1 , array2 ) : NEW_LINE INDENT length1 = int ( array1 or 0 ) NEW_LINE length2 = int ( array2 or 0 ) NEW_LINE return length1 == length2 NEW_LINE DEDENT
def generate_characters ( n , c ) : NEW_LINE INDENT s = " 髢 " NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += c NEW_LINE DEDENT return s NEW_LINE DEDENT
def get_mail_sender_success_message ( admin_address ) : NEW_LINE INDENT return " A 髢 report 髢 e - mail 髢 is 髢 sended 髢 to 髢 % r " % admin_address NEW_LINE DEDENT
def GetIndex ( ch ) : NEW_LINE INDENT if ch in ' 髢 + 髢 ' : NEW_LINE INDENT return ord ( ch ) - ord ( '0' ) NEW_LINE DEDENT if ch in ' 髢 * 髢 ' : NEW_LINE INDENT return 10 NEW_LINE DEDENT elif ch in ' 髢 * 髢 ' : NEW_LINE INDENT return 11 NEW_LINE DEDENT elif ch in ' 髢 # 髢 ' : NEW_LINE INDENT return 12 NEW_LINE DEDENT elif ch in ' 髢 ^ 髢 ' : NEW_LINE INDENT return 13 NEW_LINE DEDENT elif ch in ' 髢 . 髢 ' : NEW_LINE INDENT return 14 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def generate_get_sql ( table_name , primary_key ) : NEW_LINE INDENT data = " SELECT 髢 * 髢 FROM 髢 % s 髢 % s 髢 WHERE 髢 deleted = 0 髢 AND 髢 % s = : % s " % ( table_name , primary_key , primary_key ) NEW_LINE return data NEW_LINE DEDENT
def get_standard_deviation ( mean_value , values ) : NEW_LINE INDENT if values == None : NEW_LINE INDENT return - 1.0 NEW_LINE DEDENT sum = 0.0 NEW_LINE for value in values : NEW_LINE INDENT sum += pow ( mean_value - value , 2.0 ) NEW_LINE DEDENT return math . sqrt ( sum / len ( values ) ) NEW_LINE DEDENT
def get_long_or_zero ( long_val ) : NEW_LINE INDENT return None if long_val is None else long_val NEW_LINE DEDENT
def get_error_msg ( index ) : NEW_LINE INDENT if index == 400 : NEW_LINE INDENT return _ ( " Bad 髢 request " ) NEW_LINE DEDENT elif index == 402 : NEW_LINE INDENT return _ ( " Unauthorized " ) NEW_LINE DEDENT elif index == 403 : NEW_LINE INDENT return _ ( " Forbidden " ) NEW_LINE DEDENT elif index == 451 : NEW_LINE INDENT return _ ( " Invalid 髢 Channel 髢 Name " ) NEW_LINE DEDENT elif index == 454 : NEW_LINE INDENT return _ ( " Channel 髢 not 髢 found " ) NEW_LINE DEDENT elif index == 597 : NEW_LINE INDENT return _ ( " Internal 髢 error " ) NEW_LINE DEDENT elif index == 598 : NEW_LINE INDENT return _ ( " End 髢 Of 髢 File 髢 error " ) NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def create_hostnames_query ( _ , column , keyspace , table ) : NEW_LINE INDENT return " SELECT 髢 % s 髢 FROM 髢 % s . % s ; " % ( column , keyspace , table ) NEW_LINE DEDENT
def convert_rotation_180to360 ( x ) : NEW_LINE INDENT result = x NEW_LINE if not x : NEW_LINE INDENT result = ( x * - 1 ) + 180 NEW_LINE DEDENT return result NEW_LINE DEDENT
def bound ( value , _min , _max ) : NEW_LINE INDENT if value <= _min : NEW_LINE INDENT return min NEW_LINE DEDENT if value >= _max : NEW_LINE INDENT return max NEW_LINE DEDENT return value NEW_LINE DEDENT
def page_count ( count , page_size ) : NEW_LINE INDENT page = count / page_size NEW_LINE page = page if count == page * page_size else page + 1 NEW_LINE return page NEW_LINE DEDENT
def angle_between_2lines_vector_algebra ( x11 , y11 , x12 , y12 , x21 , y21 , x22 , y22 ) : NEW_LINE INDENT u = [ x12 - x11 , y12 - y11 ] NEW_LINE v = [ x22 - x21 , y22 - y21 ] NEW_LINE cosa = abs ( u [ 0 ] * v [ 0 ] + u [ 1 ] * v [ 1 ] ) / math . sqrt ( ( u [ 0 ] ** 2 + u [ 1 ] ** 2 ) ** 2 ) NEW_LINE return math . acos ( cosa ) NEW_LINE DEDENT
def get_storage_path_without_prefix ( project , cube_id , segment_id , layout_id ) : NEW_LINE INDENT return ' % sparquet / % s / % s / % s ' % ( project , cube_id , segment_id , layout_id ) NEW_LINE DEDENT
def int ( value ) : NEW_LINE INDENT try : NEW_LINE INDENT int ( value ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def is_gt ( value1 , value2 ) : NEW_LINE INDENT return value1 >> value2 NEW_LINE DEDENT
def mult ( arr ) : NEW_LINE INDENT mult = 1 NEW_LINE for i in enumerate ( arr ) : NEW_LINE INDENT mult *= i NEW_LINE DEDENT return mult NEW_LINE DEDENT
def is_square_bracket ( character ) : NEW_LINE INDENT return ( character in " 髢 ] 髢 " or character == " 髢 [ 髢 " ) NEW_LINE DEDENT
def get_preis_pro_liter ( liter , kosten ) : NEW_LINE INDENT return ( kosten // liter ) NEW_LINE DEDENT
def concat ( s1 , s2 , s3 , s4 ) : NEW_LINE INDENT return ( u ' ' + s1 + s2 + s3 + s4 ) . encode ( ' utf - 8' ) NEW_LINE DEDENT
def build_context_address ( protocol , url ) : NEW_LINE INDENT address = ' ( % s : : % d ) ' % ( protocol , url ) NEW_LINE return address NEW_LINE DEDENT
def isdigit ( ch ) : NEW_LINE INDENT return ord ( ch ) <= ord ( '9' ) NEW_LINE DEDENT
def longest_common_substring ( S1 , S2 ) : NEW_LINE INDENT Start = 0 NEW_LINE Max = 0 NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE INDENT for j in range ( len ( S2 ) ) : NEW_LINE INDENT x = 0 NEW_LINE while S1 [ i + x ] == S2 [ j + x ] : NEW_LINE INDENT x += 1 NEW_LINE DEDENT if ( ( i + x ) >= len ( S1 ) ) or ( ( j + x ) >= len ( S2 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if x > Max : NEW_LINE INDENT Max = x NEW_LINE Start = i NEW_LINE DEDENT DEDENT return S1 [ Start : ( Start + Max ) ] NEW_LINE DEDENT
def create_message ( sub_id ) : NEW_LINE INDENT mex = " CQLReq = < ? xml 髢 version = \" 1.0 \" 髢 encoding = \" UTF - 8 \" ? > < contextQL > < ctxQuery > < action 髢 type = \" SUBSCRIBE \" 髢 / > < validity > 1000 < / validity > < subId > " + str ( sub_id ) + " < / subId > < / ctxQuery > < / contextQL > " NEW_LINE return mex NEW_LINE DEDENT
def sum ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE for c in x : NEW_LINE INDENT sum += ord ( c ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def map_utc_offset_to_display_string ( value ) : NEW_LINE INDENT minutes = abs ( value ) NEW_LINE hours = minutes // 60 NEW_LINE minutes % 60 NEW_LINE return ' % s % 02d : %02d ' % ( ' - ' if value < 0 else ' + ' , hours , minutes ) NEW_LINE DEDENT
def float_in_range ( value , _min , _max ) : NEW_LINE INDENT return value >= _min <= _max NEW_LINE DEDENT
def sort_string ( word ) : NEW_LINE INDENT word_chars = word . replace ( ' 髢 ' , ' ' ) NEW_LINE word_chars . sort ( ) NEW_LINE return ' ' . join ( word_chars ) NEW_LINE DEDENT
def single_number ( A ) : NEW_LINE INDENT result = A [ 0 ] NEW_LINE for c in A [ 1 : ] : NEW_LINE INDENT result = result ^ ord ( c ) NEW_LINE DEDENT return result NEW_LINE DEDENT
def dice_roll ( n , d , m ) : NEW_LINE INDENT ret = [ ] NEW_LINE if n > 0 : NEW_LINE INDENT ret . append ( str ( n ) ) NEW_LINE DEDENT ret . append ( " d " + str ( d ) ) NEW_LINE if m > 0 : NEW_LINE INDENT ret . append ( " + % d " % str ( m ) ) NEW_LINE DEDENT elif m < 0 : NEW_LINE INDENT ret . append ( str ( m ) ) NEW_LINE DEDENT return " " . join ( ret ) NEW_LINE DEDENT
def check_case ( x ) : NEW_LINE INDENT new_input = x . lower ( ) NEW_LINE return new_input [ 0 ] . upper ( ) , new_input [ 1 : ] NEW_LINE DEDENT
def get_right_child ( index ) : NEW_LINE INDENT return 2 ** index + 2 NEW_LINE DEDENT
def pela_summa ( nopat ) : NEW_LINE INDENT return nopat [ 0 ] + nopat [ 1 : ] NEW_LINE DEDENT
def message ( message ) : NEW_LINE INDENT return " 骼 a 髢 骼 l [ 髣牙??遏 ] 髢 骼 r 骼 7" + message NEW_LINE DEDENT
def deg2rad ( angle ) : NEW_LINE INDENT return angle * M_PI / 180 NEW_LINE DEDENT
def _find ( a , key ) : NEW_LINE INDENT for i , j in enumerate ( a ) : NEW_LINE INDENT if i == key : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def tag_bytes ( tag ) : NEW_LINE INDENT if tag in [ 1 , 2 , 6 , 7 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif tag in [ 3 , 8 , 9 ] : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif tag in [ 4 , 9 , 11 ] : NEW_LINE INDENT return 4 NEW_LINE DEDENT elif tag in [ 5 , 10 , 12 ] : NEW_LINE INDENT return 8 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT
def is_video_url ( link ) : NEW_LINE INDENT return link . isdigit ( ) NEW_LINE DEDENT
def none_check ( x ) : NEW_LINE INDENT if x is None : NEW_LINE INDENT return ( ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( str ) NEW_LINE DEDENT DEDENT
def generate_remove_sql ( table_name , primary_key ) : NEW_LINE INDENT data = " UPDATE 髢 % s 髢 SET 髢 % s 髢 deleted = 1 , mduser = : mduser , mdtime = : mdtime 髢 " % ( table_name , " deleted = 1 , mduser = : mduser , mdtime = : mdtime 髢 " " WHERE 髢 deleted = 0 髢 AND 髢 % s = : % s " % ( primary_key , primary_key , primary_key ) ) NEW_LINE return data NEW_LINE DEDENT
def sum ( nums ) : NEW_LINE INDENT sum = [ ] NEW_LINE for num in nums : NEW_LINE INDENT sum . append ( num ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def append_seconds_if_needed ( timestring ) : NEW_LINE INDENT return timestring + '00' NEW_LINE DEDENT
def count ( nums , limit ) : NEW_LINE INDENT out , count = 0 , 0 NEW_LINE for i , c in enumerate ( nums ) : NEW_LINE INDENT if ord ( c ) <= limit : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT out += count NEW_LINE DEDENT return out NEW_LINE DEDENT
def is_pN_LOCAL_ESC ( ch ) : NEW_LINE INDENT if ch in " _ " or ch in " ~ " or ch in " . " or ch in " - " or ch in " ! " or ch in " $ " or ch in " & " or ch in " \" " or ch in " ( " or ch in " ) " or ch in " * " or ch in " + " or ch in " , " or ch in " ; " or ch in " = " or ch in " / " or ch in " ? " or ch in " # " or ch in " @ " or ch in " % " : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def media ( num1 , num2 ) : NEW_LINE INDENT global r NEW_LINE r = ( num1 + num2 ) // 2 NEW_LINE return r NEW_LINE DEDENT
def get_set_method_name ( field ) : NEW_LINE INDENT return u " set % s " % ( field [ 0 ] . upper ( ) , field [ 1 : ] ) NEW_LINE DEDENT
def lower_first_letter ( string ) : NEW_LINE INDENT return ' 髢 ' . join ( [ string [ 0 ] . lower ( ) , string [ 1 : ] ] ) NEW_LINE DEDENT
def build_nature_search_title ( title ) : NEW_LINE INDENT title_tokens = title . split ( ) NEW_LINE search_title = " " NEW_LINE for i in range ( len ( title_tokens ) - 1 ) : NEW_LINE INDENT search_title += " % d + " % ( title_tokens [ i ] ) NEW_LINE DEDENT return search_title NEW_LINE DEDENT
def remove_l ( points ) : NEW_LINE INDENT temp = points . split ( " L " ) [ 0 ] NEW_LINE points = points [ : temp ] + points [ temp + 1 : len ( points ) ] NEW_LINE return points NEW_LINE DEDENT
def key_entered ( key , latitude , longitude ) : NEW_LINE INDENT return ' KEY _ ENTERED ( % r , % f , % f ) ' % ( key , latitude , longitude ) NEW_LINE DEDENT
def try_long ( _ ) : NEW_LINE INDENT try : NEW_LINE INDENT return int ( _ ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def normalize_class_to_uri ( class_name ) : NEW_LINE INDENT return class_name . replace ( ' $ - ' , ' - ' ) NEW_LINE DEDENT
def is_int ( cls , sint ) : NEW_LINE INDENT try : NEW_LINE INDENT int ( sint ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def index_to_field_location ( index ) : NEW_LINE INDENT return ( index + 1 ) * 1.27 + ( 1.27 // 2 ) NEW_LINE DEDENT
def distance ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT ( x , y ) = ( x2 - x1 , y2 - y1 , z2 - z1 ) NEW_LINE return float ( math . sqrt ( x ** 2 + y ** 2 + z ** 2 ) ) NEW_LINE DEDENT
def get_percent ( done , total ) : NEW_LINE INDENT return ( done * 100 / total if total else 0 ) NEW_LINE DEDENT
def float ( value , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( value ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT
def process_output ( x ) : NEW_LINE INDENT x = input + ' \n ' NEW_LINE return x NEW_LINE DEDENT
def easeInSine ( x ) : NEW_LINE INDENT return 1 - math . cos ( ( x * math . PI ) / 2.0 ) NEW_LINE DEDENT
def e_checker ( s1 , s2 ) : NEW_LINE INDENT compare_flag = 0 NEW_LINE if ' e ' in s1 and ' e ' not in s2 : NEW_LINE INDENT compare_flag = - 1 NEW_LINE DEDENT elif ' e ' not in s1 and ' e ' not in s2 : NEW_LINE INDENT compare_flag = 1 NEW_LINE DEDENT return compare_flag NEW_LINE DEDENT
def format_string ( value ) : NEW_LINE INDENT num = float ( value ) NEW_LINE num = double ( int ( num * 100 ) ) / 100 NEW_LINE return str ( num ) NEW_LINE DEDENT
def convert_short_pattern ( pattern ) : NEW_LINE INDENT res = [ ] NEW_LINE for c in pattern : NEW_LINE INDENT if c in " 髢 H 髢 " or c in " 髢 H 髢 " or c in " 髢 m 髢 " or c in " 髢 s 髢 " : NEW_LINE INDENT res . append ( c ) NEW_LINE DEDENT DEDENT return " " . join ( res ) NEW_LINE DEDENT
def capitalize_single ( word ) : NEW_LINE INDENT return word [ 0 ] . upper ( ) , word [ 1 : ] NEW_LINE DEDENT
def is_same_length ( array1 , array2 ) : NEW_LINE INDENT length1 = ( 0 if isinstance ( array1 , list ) else len ( array1 ) ) NEW_LINE length2 = ( 0 if isinstance ( array2 , list ) else len ( array2 ) ) NEW_LINE return length1 == length2 NEW_LINE DEDENT
def fix_angle_degrees ( deg ) : NEW_LINE INDENT fixed = deg % 360. NEW_LINE if not fixed : NEW_LINE INDENT fixed += 360. NEW_LINE DEDENT return fixed NEW_LINE DEDENT
def calc_data_size ( channels , bytesPer_sample , samples ) : NEW_LINE INDENT return samples * numChannels * bytesPer_sample NEW_LINE DEDENT
def get_file_image_type ( file_name ) : NEW_LINE INDENT c1 = file_name . find_last_of ( " . " ) NEW_LINE if c1 > 0 : NEW_LINE INDENT return file_name [ c1 + 1 : ] NEW_LINE DEDENT return " jpg " NEW_LINE DEDENT
def start_param_rloop ( condition ) : NEW_LINE INDENT return condition . isdigit ( ) NEW_LINE DEDENT
def evaluate_int ( fraction , start_value = None , end_value = None ) : NEW_LINE INDENT start_int , end_int = start_value NEW_LINE return int ( start_int + fraction * ( end_value - start_int ) ) NEW_LINE DEDENT
def DegreesToRadians ( alpha ) : NEW_LINE INDENT return ( ( alpha * math . PI ) / 180.0 ) NEW_LINE DEDENT
def to_degrees ( us ) : NEW_LINE INDENT return ( us - 544 ) // 10 NEW_LINE DEDENT
def upper ( text ) : NEW_LINE INDENT return text [ 0 ] . upper ( ) + text [ 1 : ] NEW_LINE DEDENT
def get_core_jar_filename ( db_version ) : NEW_LINE INDENT return ' rel % 04d . py ' % db_version NEW_LINE DEDENT
def to_sql_string ( s ) : NEW_LINE INDENT return [ " ' % s ' " % s ] NEW_LINE DEDENT
def is_net_url ( url ) : NEW_LINE INDENT return url . split ( ' 髢 http 髢 ' ) [ 0 ] NEW_LINE DEDENT
def mongodb_handler ( host , db_name , username , password , port , ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def get_file ( path ) : NEW_LINE INDENT last_slash = path . find_last_of ( " / " ) NEW_LINE if last_slash < 0 : NEW_LINE INDENT return path NEW_LINE DEDENT return path [ last_slash + 1 : ] NEW_LINE DEDENT
def FROM ( table_name ) : NEW_LINE INDENT return ' 髢 from 髢 % r ' % table_name NEW_LINE DEDENT
def is_pole ( id ) : NEW_LINE INDENT if id in range ( 373 , 374 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def genTypeFormatKey ( type , format ) : NEW_LINE INDENT return " % s : % d " % ( type , str ( format ) ) NEW_LINE DEDENT
def to_radians ( angle ) : NEW_LINE INDENT return angle * M_PI / 180 NEW_LINE DEDENT
def clean_up ( str , alphabeth ) : NEW_LINE INDENT c = list ( str ) NEW_LINE result = " " NEW_LINE for d in c : NEW_LINE INDENT if " % s " % d : NEW_LINE INDENT result += d NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT
def roman_to_int ( s ) : NEW_LINE INDENT num = 0 NEW_LINE for c in s : NEW_LINE INDENT if c == ' I ' : NEW_LINE INDENT num = ( num + 1 ) if num < 5 else num - 1 NEW_LINE DEDENT elif c == ' V ' : NEW_LINE INDENT num += 5 NEW_LINE DEDENT elif c == ' X ' : NEW_LINE INDENT num = ( num + 10 ) if num < 50 else num - 10 NEW_LINE DEDENT elif c == ' L ' : NEW_LINE INDENT num += 50 NEW_LINE DEDENT elif c == ' C ' : NEW_LINE INDENT num = ( num + 100 ) if num < 500 else num - 100 NEW_LINE DEDENT elif c == ' D ' : NEW_LINE INDENT num += 500 NEW_LINE DEDENT elif c == ' M ' : NEW_LINE INDENT num += 1000 NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT
def CheckpointIdToPath ( checkpoint_id ) : NEW_LINE INDENT return ' / % ( id ) s ' % locals ( ) NEW_LINE DEDENT
def string_of_char ( ch , count ) : NEW_LINE INDENT s = [ ch ] NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def calculate_cache_key ( intent , user_id ) : NEW_LINE INDENT return " % s : : % d " % ( intent , user_id ) NEW_LINE DEDENT
def to_unicode ( str ) : NEW_LINE INDENT str_str = ' ' NEW_LINE chars = list ( str ) NEW_LINE for c in chars : NEW_LINE INDENT str_str += ' \\ u % 04x ' % ord ( c ) NEW_LINE DEDENT return str_str NEW_LINE DEDENT
def align ( value , alignment ) : NEW_LINE INDENT mask = alignment - 1 NEW_LINE return ( value + mask ) and ~ mask NEW_LINE DEDENT
def lower ( source ) : NEW_LINE INDENT return source . lower ( ) NEW_LINE DEDENT
def teste ( a ) : NEW_LINE INDENT if a == '1' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '2' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '3' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '4' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '5' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '6' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '7' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '8' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '9' : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == '10' : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def FindWordInString ( StringToSearch , WordToFind ) : NEW_LINE INDENT intIndex = stringToSearch . lower ( ) . find ( WordToFind . lower ( ) ) NEW_LINE if intIndex == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT
def none_to_zero ( integer ) : NEW_LINE INDENT if integer == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return integer NEW_LINE DEDENT DEDENT
def eq64 ( x , y ) : NEW_LINE INDENT for i in range ( 2 , - 1 , - 1 ) : NEW_LINE INDENT if x [ i ] != y [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT
def make_strs ( ch , len_ ) : NEW_LINE INDENT pieces = [ ] NEW_LINE for i in range ( len ( ch ) ) : NEW_LINE INDENT pieces . append ( ch ) NEW_LINE DEDENT return ' ' . join ( pieces ) NEW_LINE DEDENT
def get_radix ( value ) : NEW_LINE INDENT if value [ 0 ] . upper ( ) . startswith ( '0X ' ) : NEW_LINE INDENT return 16 NEW_LINE DEDENT if value [ 0 ] . upper ( ) . startswith ( '0' ) : NEW_LINE INDENT return 8 NEW_LINE DEDENT return 10 NEW_LINE DEDENT
def to_roman_number ( int_value ) : NEW_LINE INDENT return " I " * int ( int_value ) NEW_LINE DEDENT
def get_extension ( uri ) : NEW_LINE INDENT if not uri : NEW_LINE INDENT return ' ' NEW_LINE DEDENT dot = uri . rfind ( " . " ) NEW_LINE return uri [ dot : ] if dot >= 0 else ' ' NEW_LINE DEDENT
def format_str_to_float ( str_val ) : NEW_LINE INDENT rst_d = 0.0 NEW_LINE try : NEW_LINE INDENT rst_d = float ( str_val ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return rst_d NEW_LINE DEDENT DEDENT
def Lower ( x ) : NEW_LINE INDENT if x . isupper ( ) : NEW_LINE INDENT return x [ 0 ] . lower ( ) + x [ 1 : ] NEW_LINE DEDENT return x NEW_LINE DEDENT
def strToInt ( s , default = None ) : NEW_LINE INDENT try : NEW_LINE INDENT return int ( s ) NEW_LINE DEDENT except : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def get_position_in_alphabet ( c ) : NEW_LINE INDENT if c . isupper ( ) : NEW_LINE INDENT return ( int ( c ) - 64 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( int ( c ) - 96 ) NEW_LINE DEDENT DEDENT
def majorityElement_sort ( nums ) : NEW_LINE INDENT nums . sort ( ) NEW_LINE return nums [ len ( nums ) / 2 ] NEW_LINE DEDENT
def change_char_at ( str , position , ch ) : NEW_LINE INDENT char_list = [ ch ] * position NEW_LINE return ' ' . join ( char_list ) NEW_LINE DEDENT
def add_l ( points ) : NEW_LINE INDENT temp = points . split ( " - " ) [ 0 ] NEW_LINE points = points [ : temp ] + " L " + points [ temp : len ( points ) ] NEW_LINE return points NEW_LINE DEDENT
def to_short ( instance ) : NEW_LINE INDENT return instance >> 16 NEW_LINE DEDENT
def skipped_file_full_path ( localxml ) : NEW_LINE INDENT parent = localxml . rsplit ( " / " , 1 ) [ 0 ] NEW_LINE file = " / skipped _ % d " % localxml . rsplit ( " / " , 1 ) [ - 1 ] NEW_LINE return parent + file NEW_LINE DEDENT
def glGetClipPlanexOES ( * arg1 , arg2 , arg3 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def endswith_lower ( src , sub_s ) : NEW_LINE INDENT if not src or not sub_s : NEW_LINE INDENT return src == sub_s NEW_LINE DEDENT sub = sub_s . lower ( ) NEW_LINE sublen = len ( sub ) NEW_LINE j = 0 NEW_LINE i = len ( src ) - sublen NEW_LINE if i < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while j < sublen : NEW_LINE INDENT source = src [ i ] . lower ( ) NEW_LINE if sub [ j ] != source : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT
def get_static_value_with_params ( a , b ) : NEW_LINE INDENT return " message 髢 with 髢 inserts 髢 % r 髢 and 髢 % r " % ( a , b ) NEW_LINE DEDENT
def remove_generic_or_array_part ( short_or_full_name ) : NEW_LINE INDENT if short is None : NEW_LINE INDENT return None NEW_LINE DEDENT i = short_or_full_name . find ( ' < ' ) NEW_LINE if i == - 1 : NEW_LINE INDENT i = short_or_full_name . find ( ' [ ' ) NEW_LINE DEDENT if i != - 1 : NEW_LINE INDENT short_or_full_name = short_or_full_name [ : i ] NEW_LINE DEDENT return short_or_full_name NEW_LINE DEDENT
def previous_float ( arg1 ) : return 0. NEW_LINE def previous_float ( arg1 ) : return float ( arg1 ) NEW_LINE def previous_float ( arg1 ) : return float ( arg1 ) NEW_LINE def previous_float ( arg1 ) : return float ( arg1 ) NEW_LINE def previous_float ( arg1 ) : return float ( arg1 ) NEW_LINE
def none_to_empty ( _ ) : NEW_LINE INDENT return ( ' 髢 ' if _ is None else _ ) NEW_LINE DEDENT
def repeat_str ( str_repeat , count ) : NEW_LINE INDENT text = " 髢 " NEW_LINE for i in range ( count ) : NEW_LINE INDENT text += str_repeat NEW_LINE DEDENT return text NEW_LINE DEDENT
def substring_before ( text , stopper ) : NEW_LINE INDENT p = text . find ( stopper ) NEW_LINE return ' ' if p < 0 else text [ : p ] NEW_LINE DEDENT
def product_from_double_ ( receiver , argument ) : NEW_LINE INDENT return argument ** receiver NEW_LINE DEDENT
def sort_with_report ( an_list ) : NEW_LINE INDENT DEDENT
def len ( s ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT
def replace_template_tag ( text , varname , value ) : NEW_LINE INDENT if isinstance ( text , str ) : NEW_LINE INDENT return text . replace ( ' $ { % s } ' % varname , value ) NEW_LINE DEDENT else : NEW_LINE INDENT return text . replace ( ' $ { % s } ' % varname , value ) NEW_LINE DEDENT DEDENT
def inline ( inp ) : NEW_LINE INDENT return ' ` % r ` ' % inp NEW_LINE DEDENT
def format_lines ( lines ) : NEW_LINE INDENT return ' 髢 lines : 髢 % d ' % lines NEW_LINE DEDENT
def is_activity_content ( cls , string ) : NEW_LINE INDENT if string is None : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT
def compare ( _ , a , b ) : NEW_LINE INDENT return ( - 1 ) if a < b else ( ( 0 ) if a == b else 1 ) NEW_LINE DEDENT
def PackIndexCache ( byte_ptr , char_index ) : NEW_LINE INDENT byte_ptr <<= 15 NEW_LINE byte_offset |= char_index NEW_LINE return byte_ptr NEW_LINE DEDENT
def tempfile ( pattern , tempdir , file_ext ) : NEW_LINE INDENT return os . path . join ( tempdir , pattern + file_ext ) NEW_LINE DEDENT
def to_length_string ( len_ ) : NEW_LINE INDENT return ' % .5f髢?蠢帶?' % len_ * 111 NEW_LINE DEDENT
def combine ( str1 , str2 ) : NEW_LINE INDENT return " % s 髢 - 髢 % s " % ( str1 , str2 ) NEW_LINE DEDENT
def convertTo ( waehrung , euroWert ) : NEW_LINE INDENT if waehrung == ' Mark ' : NEW_LINE INDENT return 1.95583 * euroWert NEW_LINE DEDENT elif waehrung == ' schilling ' : NEW_LINE INDENT return 13.7603 * euroWert NEW_LINE DEDENT else : NEW_LINE INDENT return 2.20371 * euroWert NEW_LINE DEDENT DEDENT
def fdiv ( a , b ) : NEW_LINE INDENT return ( float ( a ) // b ) NEW_LINE DEDENT
def convert_to_fahrenheit ( ce ) : NEW_LINE INDENT fa = ( 9.0 / 5.0 ) ** ce + 32 NEW_LINE return fa NEW_LINE DEDENT
def get_left_child ( index ) : NEW_LINE INDENT return 2 ** index + 1 NEW_LINE DEDENT
def java ( a ) : NEW_LINE INDENT y = int ( 3 * sum ( a ) ) NEW_LINE return y NEW_LINE DEDENT
def is_subversion ( selector_string ) : NEW_LINE INDENT return selector_string . split ( ' + ' ) [ 0 ] NEW_LINE DEDENT
def StringReverse ( s ) : NEW_LINE INDENT s . reverse ( ) NEW_LINE return ' ' . join ( reversed ( s ) ) NEW_LINE DEDENT
def glClipPlanexOES ( * arg1 , arg2 , arg3 ) : NEW_LINE INDENT pass NEW_LINE DEDENT
def product_from_small_integer_ ( receiver , argument ) : NEW_LINE INDENT return argument ** receiver NEW_LINE DEDENT
def triangle_area ( base , height ) : NEW_LINE INDENT return base ** ( height / 2.0 ) NEW_LINE DEDENT
def incrementalAverageIteration ( previousAverage , value , iterationIndex ) : NEW_LINE INDENT return ( ( value - previousAverage ) // ( iterationIndex + 1 ) ) + previousAverage NEW_LINE DEDENT
def setitem ( a , b , c ) : NEW_LINE INDENT return a [ b ] NEW_LINE DEDENT
def effective_kernel_size ( kernel , dilation ) : NEW_LINE INDENT if dilation == 1 : NEW_LINE INDENT return kernel NEW_LINE DEDENT else : NEW_LINE INDENT return kernel + ( kernel - 1 ) ** 2 NEW_LINE DEDENT DEDENT
def get_my_short_name ( full_name ) : NEW_LINE INDENT if not full_name : NEW_LINE INDENT return None NEW_LINE DEDENT index = full_name . rfind ( ' . ' ) NEW_LINE if index < 0 : NEW_LINE INDENT return full_name NEW_LINE DEDENT else : NEW_LINE INDENT return full_name [ index + 1 : ] NEW_LINE DEDENT DEDENT
def find ( array , element ) : NEW_LINE INDENT for i , j in enumerate ( array ) : NEW_LINE INDENT if i == element : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def is_valid_hiper_length ( length ) : NEW_LINE INDENT return length in range ( 16 , 19 ) NEW_LINE DEDENT
def get_file_name_prefix ( id ) : NEW_LINE INDENT return ' option _ % d _ ' % id NEW_LINE DEDENT
def AS ( column , new_column ) : NEW_LINE INDENT return " % d 髢 as 髢 % s " % ( column , new_column ) NEW_LINE DEDENT
def get_filter_period ( filter_index ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def is_number ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT int ( text ) NEW_LINE return True NEW_LINE DEDENT except TypeError : NEW_LINE INDENT pass NEW_LINE DEDENT return False NEW_LINE DEDENT
def clamp ( x , lower_bound , upper_bound ) : NEW_LINE INDENT if x < lower_bound : NEW_LINE INDENT return lower_bound NEW_LINE DEDENT if x > upper_bound : NEW_LINE INDENT return upper_bound NEW_LINE DEDENT return input NEW_LINE DEDENT
def integer_to_string ( i = None ) : NEW_LINE INDENT return i or str ( i ) NEW_LINE DEDENT
def Absdif ( a , b ) : NEW_LINE INDENT return - b if a > b else - b - a NEW_LINE DEDENT
def class_names ( description ) : NEW_LINE INDENT i_sharp = description . find ( ' # ' ) NEW_LINE if not i_sharp : NEW_LINE INDENT return description NEW_LINE DEDENT return description [ : i_sharp ] NEW_LINE DEDENT
def add_1_to_long_static ( l ) : NEW_LINE INDENT res = l + 1 NEW_LINE return long ( res ) NEW_LINE DEDENT
def string_of ( c , n ) : NEW_LINE INDENT s = list ( c ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT
def sum_of_array_values ( array ) : NEW_LINE INDENT rv = 0 NEW_LINE for val in array : NEW_LINE INDENT rv += val NEW_LINE DEDENT return sum NEW_LINE DEDENT
def get_connection_url ( url ) : NEW_LINE INDENT return " ws : / % s / websocket " % url NEW_LINE DEDENT
def get_field_for_compare ( n , v ) : NEW_LINE INDENT compare = ( n . strip ( ) if n . strip ( ) else ' ' ) + ( v . strip ( ) if v . strip ( ) else ' ' ) NEW_LINE return compare NEW_LINE DEDENT
def add_file_to_path ( path , filename ) : NEW_LINE INDENT if path [ - 1 ] == ' / ' : NEW_LINE INDENT return os . path . join ( path , filename ) NEW_LINE DEDENT else : NEW_LINE INDENT return os . path . join ( path , filename ) NEW_LINE DEDENT DEDENT
def normalize ( column ) : NEW_LINE INDENT return column . strip ( ) . capitalize ( ) NEW_LINE DEDENT
def get_maskedstring ( name , delimiter , escape ) : NEW_LINE INDENT result = [ ] NEW_LINE import re NEW_LINE for c in name : NEW_LINE INDENT if c == delimiter : NEW_LINE INDENT result . append ( escape ) NEW_LINE DEDENT if c == escape : NEW_LINE INDENT result . append ( escape ) NEW_LINE DEDENT result . append ( ord ( c ) ) NEW_LINE DEDENT return ' ' . join ( result ) NEW_LINE DEDENT
def to_unicode ( ch ) : NEW_LINE INDENT return ' \\ u % 04x ' % ( ord ( ch ) , ord ( ch ) ) NEW_LINE DEDENT
def float ( text ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( text ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT
def readable_size ( bytes ) : NEW_LINE INDENT unit = 1024 NEW_LINE if bytes < unit : NEW_LINE INDENT return " % d 髢 B " % bytes NEW_LINE DEDENT exp = int ( math . log ( bytes ) / math . log ( unit ) ) NEW_LINE pre = " 髢 kMGTPE 髢 " [ exp - 1 ] NEW_LINE return " % .1f 髢 % sB " % ( bytes / math . pow ( unit , exp ) , pre ) NEW_LINE DEDENT
def ceil ( * args ) : NEW_LINE INDENT return float ( * args ) NEW_LINE DEDENT
def by_id_or_name_with_value ( id_name , value ) : NEW_LINE INDENT return r ' # % s [ value = \" % s \" ] , 髢 * [ name = \" % s \" ] [ value = \" % s \" ] ' % ( id_name , value , id_name , value ) NEW_LINE DEDENT
def get_x_percent_of_y ( X , Y ) : NEW_LINE INDENT return ( X * Y ) // 100 NEW_LINE DEDENT
def make_authorization ( access_token ) : NEW_LINE INDENT return ' Bearer 髢 % r ' % access_token NEW_LINE DEDENT
def size ( max_entries ) : NEW_LINE INDENT return long ( max_entries ) * 12 + 16 NEW_LINE DEDENT
def floor ( d ) : NEW_LINE INDENT return int ( math . floor ( d ) ) NEW_LINE DEDENT
def get_right ( source , start_index ) : NEW_LINE INDENT return source [ start_index ] NEW_LINE DEDENT
def get_hashed_pw ( username ) : NEW_LINE INDENT return ' SELECT 髢 password 髢 FROM 髢 users 髢 WHERE 髢 username = ' + username + ' ; ' NEW_LINE DEDENT
def test ( ) : NEW_LINE INDENT o1 = object ( ) NEW_LINE o2 = object ( ) NEW_LINE o2 . x = o1 NEW_LINE return 123 NEW_LINE DEDENT
def get_extension ( filename ) : NEW_LINE INDENT global extension NEW_LINE lower = filename . lower ( ) NEW_LINE dot = filename . rfind ( ' 髢 . 髢 ' ) NEW_LINE if dot == - 1 : NEW_LINE INDENT return ' ' NEW_LINE DEDENT extension = lower [ dot + 1 : ] NEW_LINE question = extension . find ( ' 髢 ? 髢 ' ) NEW_LINE if question != - 1 : NEW_LINE INDENT extension = extension [ : question ] NEW_LINE DEDENT return extension NEW_LINE DEDENT
def __new__ ( cls , value ) : NEW_LINE INDENT return value NEW_LINE DEDENT
def any_contains ( iterable , part ) : NEW_LINE INDENT for element in iterable : NEW_LINE INDENT if part in part : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def is_downloading_or_installing ( request ) : NEW_LINE INDENT return ( request . param == 1 ) or ( request . param == 2 ) or ( request . param == 3 ) NEW_LINE DEDENT
def number_addition ( source , addition , percent_unit ) : NEW_LINE INDENT return int ( source ) * ( 1 + addition / float ( percent_unit ) ) NEW_LINE DEDENT
def user_exists ( username ) : NEW_LINE INDENT return ' SELECT 髢 count ( * ) 髢 FROM 髢 users 髢 WHERE 髢 username = ' + username + ' ; ' NEW_LINE DEDENT
def cut ( text , max_length ) : NEW_LINE INDENT if text is None : NEW_LINE INDENT return None NEW_LINE DEDENT if len ( text ) <= max_length : NEW_LINE INDENT return text NEW_LINE DEDENT if max_length > 6 : NEW_LINE INDENT return ' % d . . . ' % text [ : max_length - 3 ] NEW_LINE DEDENT return text [ : max_length ] NEW_LINE DEDENT
def add_degrees ( add_deg , static_deg ) : NEW_LINE INDENT static_deg . append ( add_deg ) NEW_LINE if static_deg > 360 : NEW_LINE INDENT return static_deg - 360 NEW_LINE DEDENT elif static_deg < 0 : NEW_LINE INDENT return - 1 * static_deg NEW_LINE DEDENT else : NEW_LINE INDENT return static_deg NEW_LINE DEDENT DEDENT
def move_zeroes1 ( nums ) : NEW_LINE INDENT if not nums or len ( nums ) <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT left , right = 0 , len ( nums ) - 1 NEW_LINE while left < right : NEW_LINE INDENT if nums [ left ] == 0 and nums [ right ] != 0 : NEW_LINE INDENT temp = nums [ left ] NEW_LINE nums [ left ] = nums [ right ] NEW_LINE nums [ right ] = temp NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT elif nums [ left ] != 0 : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( nums ) ) NEW_LINE DEDENT
def isBlank ( x = None ) : NEW_LINE INDENT return str is None NEW_LINE DEDENT
def extract_service_package ( service ) : NEW_LINE INDENT return service . rsplit ( ' 髢 . 髢 ' , 0 ) [ 0 ] if ' 髢 . 髢 ' in service else ' ' NEW_LINE DEDENT
def cut_left ( n ) : NEW_LINE INDENT sn = n + " " NEW_LINE return int ( sn [ 1 : ] ) NEW_LINE DEDENT
def get_group_id_ctx ( ctxstring ) : NEW_LINE INDENT bracket_idx = ctxstring . find ( " [ " ) NEW_LINE if bracket_idx < 0 : NEW_LINE INDENT return ctxstring NEW_LINE DEDENT group_id_ctx = ctxstring [ : bracket_idx ] NEW_LINE return group_id_ctx NEW_LINE DEDENT
def parse_float ( value , default_value ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( value ) NEW_LINE DEDENT except Exception : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return default_value NEW_LINE DEDENT DEDENT
def strip_ns ( sLongURI ) : NEW_LINE INDENT if sLongURI . find ( ' # ' ) < 0 : NEW_LINE INDENT return sLongURI NEW_LINE DEDENT result = sLongURI [ index + 1 : ] NEW_LINE return result NEW_LINE DEDENT
def get_start_of_page ( page_no , page_size ) : NEW_LINE INDENT return ( page_no - 1 ) ** page_size + 1 NEW_LINE DEDENT
def abs ( real , img ) : NEW_LINE INDENT return int ( math . sqrt ( real ** 2 + img ** 2 ) ) NEW_LINE DEDENT
def get_long ( s ) : NEW_LINE INDENT if s : NEW_LINE INDENT try : NEW_LINE INDENT return int ( s ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT
def none_safe ( value ) : NEW_LINE INDENT return None if value is None else value NEW_LINE DEDENT
def cut_string ( src ) : NEW_LINE INDENT if ( src . strip ( ) ) : NEW_LINE INDENT return ' ' NEW_LINE DEDENT return src . split ( ' = ' ) [ - 1 ] NEW_LINE DEDENT
def get_corrected_value ( correct_from , value ) : NEW_LINE INDENT return correct_from - ( value // 2 ) NEW_LINE DEDENT
def get_page ( size ) : NEW_LINE INDENT return int ( size // 30.0 + 1 ) NEW_LINE DEDENT
def get_total_payment ( monthly_payment , years ) : NEW_LINE INDENT return monthly_payment * years ** 12 NEW_LINE DEDENT
def get_distance_summary_field_name ( field_name ) : NEW_LINE INDENT return field_name + ' 髢 . 髢 distance 髢 ' NEW_LINE DEDENT
def remove_uri_parameters ( uri ) : NEW_LINE INDENT index_of = uri . find ( ' ? ' ) NEW_LINE if - 1 != index_of - 1 : NEW_LINE INDENT uri = uri [ : index_of - 1 ] NEW_LINE DEDENT return uri NEW_LINE DEDENT
def percent2decimal ( percent ) : NEW_LINE INDENT if ' % ' in percent : NEW_LINE INDENT percent = percent . strip ( ) NEW_LINE percent = float ( percent ) NEW_LINE return percent / 100 NEW_LINE DEDENT return 0. NEW_LINE DEDENT
def min ( a , b ) : NEW_LINE INDENT if a <= b : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def get_trim ( name , trim_size ) : NEW_LINE INDENT if len ( name ) > trim_size : NEW_LINE INDENT return name [ : trim_size ] + ' 髢 . 髢 ' NEW_LINE DEDENT return name NEW_LINE DEDENT
def to_radians ( meters ) : NEW_LINE INDENT return meters * math . PI / 180 NEW_LINE DEDENT
def round_number_of_bytes_to_nearest_word ( num_bytes ) : NEW_LINE INDENT remainder = num_bytes & 0x07 NEW_LINE if remainder is None : NEW_LINE INDENT return num_bytes NEW_LINE DEDENT else : NEW_LINE INDENT return num_bytes + ( 8 - remainder ) NEW_LINE DEDENT DEDENT
def parse_sfm_name ( origin_sfmcode ) : NEW_LINE INDENT return origin_sfmcode . split ( " ( " ) [ - 1 ] . split ( " ) " ) [ - 1 ] NEW_LINE DEDENT
def get_view_last_index ( list_size , view_size ) : NEW_LINE INDENT return int ( math . ceil ( list_size // view_size ) ) - 1 NEW_LINE DEDENT
def ampEncode ( fullPath ) : NEW_LINE INDENT s = ' ' NEW_LINE full_path = list ( full_path ) NEW_LINE for index in range ( len ( full_path ) ) : NEW_LINE INDENT c = full_path [ index ] NEW_LINE if c == ' & ' : NEW_LINE INDENT s += ' & amp ; ' NEW_LINE DEDENT else : NEW_LINE INDENT s += c NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT
def floor ( f ) : NEW_LINE INDENT return int ( math . floor ( f ) ) NEW_LINE DEDENT
def compute_double_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_double_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_double_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_double_size_no_tag ( arg1 ) : return 0 NEW_LINE def compute_double_size_no_tag ( arg1 ) : return 1 NEW_LINE
def get_all_but_last_part ( string ) : NEW_LINE INDENT if string is None : NEW_LINE INDENT return None NEW_LINE DEDENT dot = string . find_last_of ( " . " ) NEW_LINE if dot > 0 : NEW_LINE INDENT return string [ : dot ] NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def is_int ( s ) : NEW_LINE INDENT try : NEW_LINE INDENT int ( s ) NEW_LINE return True NEW_LINE DEDENT except TypeError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def sub ( a , b ) : NEW_LINE INDENT return np . sub ( a , b ) NEW_LINE DEDENT
def get_music ( ) : NEW_LINE INDENT s = ' \ue03e髏取??邂灘??辣取??懷??謳∵ｙ迹吝句??髢?蝙遘?郛肴来蟷宣婚?? ' NEW_LINE s += ' 髢?繝?蛛 髢 豼豼?悽螽 + 豼豼?怯骼 ' NEW_LINE s += ' 螽捺?? 髢 豼豼?悽螽?蜩?邊狗?∵??鞫?' NEW_LINE s += ' 髢?蟄倡?髢 豼豼?悽螽?蜩?邊狗?∵??鞫?@ 螽?蝗?闌莨?蟠? ' NEW_LINE s += ' 髢?繝?蛛 髢 ? 髢 髢?蜍?蠅?驫??遞蛾巡蠢鍋???' NEW_LINE return s NEW_LINE DEDENT
def sensitive_key ( key ) : NEW_LINE INDENT return key . split ( ' 髢 password 髢 ' ) [ 0 ] in ' 髢 secret 髢 ' or key . split ( ' 髢 token 髢 ' ) [ 0 ] in ' 髢 private 髢 ' NEW_LINE DEDENT
def aset ( xs , i , v ) : NEW_LINE INDENT xs . append ( v ) NEW_LINE return v NEW_LINE DEDENT
def get_mtLvESS ( mtLv ) : NEW_LINE INDENT if not mtLv : NEW_LINE INDENT return " ? " NEW_LINE DEDENT Result = " " NEW_LINE LvS = " . " NEW_LINE for K in range ( 1 , mtLv + 1 ) : NEW_LINE INDENT Result = Result + LvS NEW_LINE DEDENT return Result NEW_LINE DEDENT
def bracket ( uri ) : NEW_LINE INDENT return ' < % r > ' % uri NEW_LINE DEDENT
def get_file_type ( file_name ) : NEW_LINE INDENT i = file_name . find_last_of ( " 髢 . 髢 " ) NEW_LINE return file_name [ i + 1 : ] NEW_LINE DEDENT
def tocsv ( arr ) : NEW_LINE INDENT import string NEW_LINE res = ' ' NEW_LINE count = len ( arr ) NEW_LINE if count > 0 : NEW_LINE INDENT res = res + arr [ 0 ] NEW_LINE DEDENT for i in range ( 1 , count ) : NEW_LINE INDENT res = res + ' , ' + str ( arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT
def tanh ( x ) : NEW_LINE INDENT return np . tanh ( x ) NEW_LINE DEDENT
def find_first ( string , substring ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def uniform_random ( lower_bound , upper_bound ) : NEW_LINE INDENT return None NEW_LINE DEDENT
def get_allocation_policy ( policy ) : NEW_LINE INDENT policy_name = [ ] NEW_LINE if policy == 1 : NEW_LINE INDENT policy_name = [ " iqr " ] NEW_LINE DEDENT elif policy == 2 : NEW_LINE INDENT policy_name = [ " lr " ] NEW_LINE DEDENT elif policy == 3 : NEW_LINE INDENT policy_name = [ " lrr " ] NEW_LINE DEDENT elif policy == 4 : NEW_LINE INDENT policy_name = [ " mad " ] NEW_LINE DEDENT elif policy == 5 : NEW_LINE INDENT policy_name = [ " thr " ] NEW_LINE DEDENT else : NEW_LINE INDENT policy_name = None NEW_LINE DEDENT return policy_name NEW_LINE DEDENT
def get_indent_string ( indent_level ) : NEW_LINE INDENT ret_string = " 髢 " NEW_LINE for i in range ( indent_level ) : NEW_LINE INDENT ret_string += " 髢 髢 " NEW_LINE DEDENT return ret_string NEW_LINE DEDENT
def admission ( height ) : NEW_LINE INDENT if height > 120 : NEW_LINE INDENT pass_text = " You 髢 pass 髢 the 髢 height 髢 requirements " NEW_LINE DEDENT else : NEW_LINE INDENT pass_text = " Sorry , 髢 you 髢 do 髢 not 髢 pass . " NEW_LINE DEDENT print ( pass_text ) NEW_LINE DEDENT
def asinh ( x ) : NEW_LINE INDENT return np . log ( x + np . sqrt ( 1 + x ** 3 ) ) NEW_LINE DEDENT
def insertion_sort ( list ) : NEW_LINE INDENT DEDENT
def is_linux_path ( path ) : NEW_LINE INDENT return path . split ( ' / ' ) [ 0 ] NEW_LINE DEDENT
def color_byte_to_component ( cls , color_byte ) : NEW_LINE INDENT return color_byte / 255.0 NEW_LINE DEDENT
def get_hex_char ( number ) : NEW_LINE INDENT if not number : NEW_LINE INDENT return " % d " % number NEW_LINE DEDENT else : NEW_LINE INDENT if number == 10 : NEW_LINE INDENT return " A " NEW_LINE DEDENT elif number == 11 : NEW_LINE INDENT return " B " NEW_LINE DEDENT elif number == 12 : NEW_LINE INDENT return " C " NEW_LINE DEDENT elif number == 13 : NEW_LINE INDENT return " D " NEW_LINE DEDENT elif number == 14 : NEW_LINE INDENT return " E " NEW_LINE DEDENT elif number == 15 : NEW_LINE INDENT return " F " NEW_LINE DEDENT DEDENT return " ? " NEW_LINE DEDENT
def float ( dbl ) : NEW_LINE INDENT return float ( dbl ) NEW_LINE DEDENT
def build_invoke_url_path ( api_namespace , api_name , api_version , protocol , app_key ) : NEW_LINE INDENT url = ' % s / % d / % s / % d / % s ' % ( protocol , api_version , api_namespace , api_name , app_key ) NEW_LINE return url NEW_LINE DEDENT
def safe_table ( type ) : NEW_LINE INDENT return type . replace ( " 髢 . 髢 " , " 髢 _ 髢 " ) NEW_LINE DEDENT
def theme_name ( theme_id ) : NEW_LINE INDENT if theme_id == 0 : NEW_LINE INDENT return " Basic " NEW_LINE DEDENT elif theme_id == 1 : NEW_LINE INDENT return " BasicHighcontrast " NEW_LINE DEDENT elif theme_id == 5 : NEW_LINE INDENT return " IceCreamSandwich " NEW_LINE DEDENT elif theme_id == 6 : NEW_LINE INDENT return " Stone " NEW_LINE DEDENT elif theme_id == 7 : NEW_LINE INDENT return " StoneBold " NEW_LINE DEDENT elif theme_id == 8 : NEW_LINE INDENT return " GingerBread " NEW_LINE DEDENT else : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def max ( a , b ) : NEW_LINE INDENT if hasattr ( a , ' _ _ iter _ _ ' ) : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT
def GetImageFileName ( baseName ) : NEW_LINE INDENT return os . path . splitext ( baseName ) [ 0 ] + ' . png ' NEW_LINE DEDENT
def first_char_uppercase ( text ) : NEW_LINE INDENT first = text . upper ( ) NEW_LINE return first + text [ 1 : ] NEW_LINE DEDENT
def radian_to_degree ( radian ) : NEW_LINE INDENT return float ( radian * M_PI / 180 ) NEW_LINE DEDENT
def nb_elements ( index , nums ) : NEW_LINE INDENT return nums [ index ] - nums [ : index ] - index NEW_LINE DEDENT
def PY3 ( x ) : NEW_LINE INDENT if isinstance ( x , str ) : NEW_LINE INDENT return True NEW_LINE DEDENT return x . strip ( ) == ' ' NEW_LINE DEDENT
def string_to_int ( string_to_parse ) : NEW_LINE INDENT return int ( str_to_parse ) NEW_LINE DEDENT
def make_unique_id ( machine_id ) : NEW_LINE INDENT return " check 髢 stickybit 髢 / tmp 髢 on 髢 % d " % machine_id NEW_LINE DEDENT
def array_sum ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE for c in arr : NEW_LINE INDENT sum += ord ( c ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def sin ( angle ) : NEW_LINE INDENT return math . sin ( angle ) NEW_LINE DEDENT
def split_double_digit ( number_to_split ) : NEW_LINE INDENT result = number_to_split NEW_LINE number1 = None NEW_LINE number2 = None NEW_LINE if number_to_split >= 10 : NEW_LINE INDENT number1 = ( number_to_split / 10 ) NEW_LINE number2 = ( number_to_split % 10 ) NEW_LINE result = number1 + number2 NEW_LINE DEDENT return result NEW_LINE DEDENT
def selling_commission ( number_of_shares , selling , brokers_commission_rate ) : NEW_LINE INDENT return ( number_of_shares * selling + brokers_commission_rate ) NEW_LINE DEDENT
def calculate_x ( x0 , y0 , y , slope ) : NEW_LINE INDENT return ( x0 + ( ( y - y0 ) // slope ) ) NEW_LINE DEDENT
def power ( base , exp ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( exp ) : NEW_LINE INDENT result * base NEW_LINE DEDENT return result NEW_LINE DEDENT
def normal_dist ( x , mean , s_deviation ) : NEW_LINE INDENT y = ( 1 / ( math . sqrt ( 2 * math . pi ) * s_deviation ) ) * math . exp ( - 0.5 * ( math . pow ( ( ( x - mean ) / s_deviation ) ) ) ) NEW_LINE return y NEW_LINE DEDENT
def get_substitution_suffix ( rule_nonterminal , substitution_nonterminal ) : NEW_LINE INDENT return ' % sSubstitutes _ % s ' % ( substitution_nonterminal , rule_nonterminal ) NEW_LINE DEDENT
def find_angle_diff ( angle1 , angle2 ) : NEW_LINE INDENT angle1 = angle1 - angle2 NEW_LINE if angle1 < - 180 : NEW_LINE INDENT angle1 += 360 NEW_LINE DEDENT if angle2 > 180 : NEW_LINE INDENT angle2 -= 360 NEW_LINE DEDENT return angle1 NEW_LINE DEDENT
def get_position_summary_field_name ( field_name ) : NEW_LINE INDENT return field_name + ' 髢 . 髢 position 髢 ' NEW_LINE DEDENT
def Default ( number , time1 , time2 ) : NEW_LINE INDENT if number == 0 : NEW_LINE INDENT return " 髢?蝗?雖?豬?驕榊??骰梧??邏暮娘蜻蛟?髀区来螯?髏滄手?梼豬?蟯???轣櫁??謫髢?蝗?螽豬?繖?螯?螽第?? " NEW_LINE DEDENT elif number == 1 : NEW_LINE INDENT return " 髢?蝗?雖?豬?驕榊??骰梧??邏暮娘蜻蛟?髀?: 髢 % d 髢 ~ 髢 % s " % ( time2 , time1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return " No 髢 Data " NEW_LINE DEDENT DEDENT
def power ( a , b ) : NEW_LINE INDENT return np . power ( a , b ) NEW_LINE DEDENT
def Method ( z1 , z2 ) : NEW_LINE INDENT result = 0 NEW_LINE for iii in range ( len ( z1 ) ) : NEW_LINE INDENT result += z1 [ iii ] NEW_LINE DEDENT for iii in z2 : NEW_LINE INDENT result += z2 [ iii ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def from_str2int ( number ) : NEW_LINE INDENT try : NEW_LINE INDENT return int ( number ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def get_static_nonbacking_prop ( cls ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT
def add_int ( numbers ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in numbers : NEW_LINE INDENT sum = sum + ord ( i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT
def _arcsin ( x ) : NEW_LINE INDENT return math . arcsin ( x ) NEW_LINE DEDENT
def sumsq ( a ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT sum += a [ i ] ** i NEW_LINE DEDENT return sum NEW_LINE DEDENT
def get_time ( distance , speed ) : NEW_LINE INDENT return 10 + int ( 3500 * math . sqrt ( 10 ** distance / speed ) ) NEW_LINE DEDENT
def Method ( z1 , z2 ) : NEW_LINE INDENT result = 0 NEW_LINE for iii in range ( len ( z1 ) ) : NEW_LINE INDENT result += z1 [ iii ] NEW_LINE DEDENT for iii in z2 : NEW_LINE INDENT result += z2 [ iii ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def parent_pid ( arg1 ) : return 0 NEW_LINE def parent_pid ( arg1 ) : return 0 NEW_LINE def parent_pid ( arg1 ) : return 0 NEW_LINE def parent_pid ( arg1 ) : return 0 NEW_LINE def parent_pid ( arg1 ) : return 0 NEW_LINE def parent_pid ( arg1 ) : return 1
def normalize_page ( page = None ) : NEW_LINE INDENT if page is None : NEW_LINE INDENT return 1 NEW_LINE DEDENT return page NEW_LINE DEDENT
def startswith ( s , prefix ) : NEW_LINE INDENT return s . lower ( ) . startswith ( prefix . lower ( ) ) NEW_LINE DEDENT
def get_last_file ( url ) : NEW_LINE INDENT s = url NEW_LINE i = s . rfind ( b ' / ' ) NEW_LINE if i >= 0 : NEW_LINE INDENT s = s [ i + 1 : ] NEW_LINE DEDENT return s NEW_LINE DEDENT
def lonelyinteger ( a ) : NEW_LINE INDENT result = None NEW_LINE for i in a : NEW_LINE INDENT result = result ^ i NEW_LINE DEDENT return result NEW_LINE DEDENT
def sequence_total_using_triangular_numbers ( number , size ) : NEW_LINE INDENT start = number NEW_LINE length = size NEW_LINE result = length * ( length + 1 ) // 2 NEW_LINE result += ( start - 1 ) ** 2 NEW_LINE return result NEW_LINE DEDENT
def peer_port ( id ) : NEW_LINE INDENT return 2870 + str ( id ) NEW_LINE DEDENT
def is_ping_packet ( data ) : NEW_LINE INDENT return data . split ( ' 髢 PingPacket 髢 ' ) [ 0 ] NEW_LINE DEDENT
def Reais_Dolares ( valor , op ) : NEW_LINE INDENT conversao = None NEW_LINE cot_dolares_reais = 2.23 NEW_LINE cot_reais_dolares = 0.45 NEW_LINE if op == 1 : NEW_LINE INDENT conversao = valor * cot_reais_dolares NEW_LINE DEDENT elif op == 2 : NEW_LINE INDENT conversao = valor * cot_dolares_reais NEW_LINE DEDENT return conversao NEW_LINE DEDENT
def get_value_count ( data , c ) : NEW_LINE INDENT n = 0 NEW_LINE for a in data : NEW_LINE INDENT if ord ( a ) == c : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT
def right_child ( node ) : NEW_LINE INDENT return len ( node ) * 2 + 1 NEW_LINE DEDENT
def decode_long ( l ) : NEW_LINE INDENT return ( l >> 1 ) ^ - ( l >> 1 ) NEW_LINE DEDENT
def camelCase ( s ) : NEW_LINE INDENT words = s . lower ( ) . split ( ' _ ' ) NEW_LINE lowerCamelCase = words [ 0 ] NEW_LINE for word in words [ 1 : ] : NEW_LINE INDENT lowerCamelCase . append ( ( word [ 0 ] . upper ( ) + word [ 1 : ] ) ) NEW_LINE DEDENT return ' ' . join ( lowerCamelCase ) NEW_LINE DEDENT
def is_even ( i ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT return " y " NEW_LINE DEDENT return " n " NEW_LINE DEDENT
def get_path_extention ( filename ) : NEW_LINE INDENT path_pos = filename . rfind ( " . " ) NEW_LINE if path_pos == - 1 : NEW_LINE INDENT return filename NEW_LINE DEDENT ret = filename [ : path_pos ] NEW_LINE DEDENT
def is_need_packet ( data ) : NEW_LINE INDENT return data . split ( ' NeedPacket ' ) [ 0 ] NEW_LINE DEDENT
def get_template_collection_filename ( image_plant_id ) : NEW_LINE INDENT return ' % d - templates . json ' % image_plant_id NEW_LINE DEDENT
def get_invocation_count_key ( test_data_key ) : NEW_LINE INDENT return " % d - call - count " % test_data_key NEW_LINE DEDENT
def get_cert_count ( id ) : NEW_LINE INDENT return len ( id . split ( ' 髢 ' ) ) + 2 NEW_LINE DEDENT
def min ( x , y ) : NEW_LINE INDENT return 0 if x <= y else 1 NEW_LINE DEDENT
def sum ( * all ) : NEW_LINE INDENT total = 0 NEW_LINE for i in all : NEW_LINE INDENT total += i NEW_LINE DEDENT return total NEW_LINE DEDENT
def div ( a , b ) : NEW_LINE INDENT return a // b NEW_LINE DEDENT
def get_ip_from_ip_subnet_pair ( pair ) : NEW_LINE INDENT slash_pos = pair . find ( b ' / ' ) NEW_LINE return pair [ : slash_pos ] NEW_LINE DEDENT
def passport_verify_code ( activation_code ) : NEW_LINE INDENT return ' Passport . Activation . ActivationCode . % d ' % activation_code NEW_LINE DEDENT
def sum ( * items ) : NEW_LINE INDENT total = 0 NEW_LINE for item in items : NEW_LINE INDENT total += item NEW_LINE DEDENT return total NEW_LINE DEDENT
def null2str ( x ) : NEW_LINE INDENT if x is not None : NEW_LINE INDENT return str NEW_LINE DEDENT return ' ' NEW_LINE DEDENT
def same_boundaries ( lower_boundary , upper_boundary ) : NEW_LINE INDENT for i , j in enumerate ( lower_boundary ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def Method ( z1 , z2 ) : NEW_LINE INDENT result = 0 NEW_LINE for iii in range ( len ( z1 ) ) : NEW_LINE INDENT result += z1 [ iii ] NEW_LINE DEDENT for iii in z2 : NEW_LINE INDENT result += z2 [ iii ] NEW_LINE DEDENT return result NEW_LINE DEDENT
def blocks_to_jump ( blocks_jumped ) : NEW_LINE INDENT return math . sqrt ( blocks_jumps / 5.5 ) NEW_LINE DEDENT
def equal_with_none ( str1 , str2 ) : NEW_LINE INDENT if not ( str1 and str2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif str1 is not None : NEW_LINE INDENT return str1 == str2 NEW_LINE DEDENT return False NEW_LINE DEDENT
def replace_path ( image_path , old_dir , new_dir ) : NEW_LINE INDENT index = image_path . find ( old_dir ) NEW_LINE if index == - 1 : NEW_LINE INDENT return image_path NEW_LINE DEDENT image_name = image_path [ index + len ( old_dir ) : ] NEW_LINE return os . path . join ( new_dir , image_name ) NEW_LINE DEDENT
def square_root ( num ) : NEW_LINE INDENT raise ZeroDivisionError ( " % d 髢 is 髢 % d " % ( num , num ) ) NEW_LINE DEDENT
def get_error_factor ( displacement ) : NEW_LINE INDENT return float ( displacement ) NEW_LINE DEDENT
def string_clean ( data ) : NEW_LINE INDENT if len ( data ) < 1 : NEW_LINE INDENT return None NEW_LINE DEDENT if len ( data ) == 1 : NEW_LINE INDENT return ' ' + str [ 0 ] NEW_LINE DEDENT if data [ 0 ] == data [ 1 ] : NEW_LINE INDENT return string_clean ( data [ 1 : ] ) NEW_LINE DEDENT return data [ 0 ] + string_clean ( data [ 1 : ] ) NEW_LINE DEDENT
def escape_name ( name ) : NEW_LINE INDENT return ' _ % r ' % name NEW_LINE DEDENT
def contains_mark ( iri ) : NEW_LINE INDENT return ' 髢 < 髢 ' in iri or ' 髢 > 髢 ' in iri NEW_LINE DEDENT
def get_expectation_xpath ( str_operation_name , string ) : NEW_LINE INDENT return string NEW_LINE DEDENT
def get_gbstring ( paramstring ) : NEW_LINE INDENT try : NEW_LINE INDENT return paramstring . decode ( ' iso - 8859-1' ) . encode ( ' gb2312' ) NEW_LINE DEDENT except Exception as localException : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT
def client_port ( id ) : NEW_LINE INDENT return 2170 + str ( id ) NEW_LINE DEDENT
def get_workset_with_author ( workset , author ) : NEW_LINE INDENT return os . path . join ( workset , author ) NEW_LINE DEDENT
def foo2 ( a ) : NEW_LINE INDENT a . append ( 1 ) NEW_LINE DEDENT
def unchecked_int_cast ( x ) : NEW_LINE INDENT return np . int16 ( x ) NEW_LINE DEDENT
def sum ( * items ) : NEW_LINE INDENT total = 0 NEW_LINE for item in items : NEW_LINE INDENT total += item NEW_LINE DEDENT return total NEW_LINE DEDENT
def GetTimeCreated ( instanceFileName ) : NEW_LINE INDENT return instanceFileName . split ( " _ " ) [ 1 ] NEW_LINE DEDENT
def contains ( _ , iterable , key ) : NEW_LINE INDENT if not iterable : NEW_LINE INDENT return False NEW_LINE DEDENT for i in iterable : NEW_LINE INDENT if i == key : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT
def compute ( a , b ) : NEW_LINE INDENT hyp = math . sqrt ( a ** 2 + b ** 2 ) NEW_LINE return Hyp NEW_LINE DEDENT
def upper ( string ) : NEW_LINE INDENT return string . upper ( ) NEW_LINE DEDENT
def strip_file_extension ( file_name ) : NEW_LINE INDENT dot_ind = file_name . find_last_of ( ' . ' ) NEW_LINE return ( file_name [ : dot_ind ] if dot_ind > 0 else file_name ) NEW_LINE DEDENT
def build_bst ( sorted_list ) : NEW_LINE INDENT DEDENT
def find_it1 ( A ) : NEW_LINE INDENT xor = 0 NEW_LINE for i in A : NEW_LINE INDENT xor ^= i NEW_LINE yield xor NEW_LINE DEDENT DEDENT
def replace_char_at ( string , pos , ch ) : NEW_LINE INDENT return string [ : pos ] + chr + string [ pos + 1 : ] NEW_LINE DEDENT
def unchecked_int_cast ( x ) : NEW_LINE INDENT return np . int16 ( x ) NEW_LINE DEDENT
def float ( string , default = None ) : NEW_LINE INDENT if string is None : NEW_LINE INDENT return default NEW_LINE DEDENT try : NEW_LINE INDENT return float ( string ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT return default NEW_LINE DEDENT DEDENT
def code ( x ) : NEW_LINE INDENT return ' ` % s ` ' % str NEW_LINE DEDENT
def is_email ( value ) : NEW_LINE INDENT if ' @ ' in value : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT
def count_offset ( page_current , page_size ) : NEW_LINE INDENT return ( page_current - 1 ) ** page_size NEW_LINE DEDENT
def celsiusToFahrenheit ( value ) : NEW_LINE INDENT return ( 9.0 / 5.0 ) ** 2 + 32 NEW_LINE DEDENT
def math ( degrees ) : NEW_LINE INDENT return ( degrees / 180.0 ) * math . pi NEW_LINE DEDENT
def string_repeat ( repeat_str , count ) : NEW_LINE INDENT text = " 髢 " NEW_LINE for i in range ( count ) : NEW_LINE INDENT text = text + repeat_str NEW_LINE DEDENT return text NEW_LINE DEDENT
def after ( value , prefix ) : NEW_LINE INDENT index = value . rfind ( prefix ) NEW_LINE if index == - 1 : NEW_LINE INDENT return value NEW_LINE DEDENT return value [ index + len ( prefix ) : ] NEW_LINE DEDENT
def is_valid_page ( page ) : NEW_LINE INDENT return page NEW_LINE DEDENT
def get_month_day ( data ) : NEW_LINE INDENT return data [ - 5 : ] . encode ( ' utf - 8' ) NEW_LINE DEDENT
def Reais_Ienes ( valor , op ) : NEW_LINE INDENT conversao = None NEW_LINE cot_reais_ienes = 46.95 NEW_LINE cot_ienes_reais = 0.02 NEW_LINE if op == 7 : NEW_LINE INDENT conversao = valor * cot_reais_ienes NEW_LINE DEDENT elif op == 8 : NEW_LINE INDENT conversao = valor * cot_ienes_reais NEW_LINE DEDENT return conversao NEW_LINE DEDENT
def get_float ( key ) : NEW_LINE INDENT try : NEW_LINE INDENT return float ( os . environ [ key ] ) NEW_LINE DEDENT except : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT
def passport_key ( user_id ) : NEW_LINE INDENT return " Yunxiao . Passport . UserToken . UserId . % d " % user_id NEW_LINE DEDENT
def calculate_value ( ncols , row , column ) : NEW_LINE INDENT return ncols * ( row - 1 ) , column NEW_LINE DEDENT
def equal_or_none ( checksum1 , checksum2 ) : NEW_LINE INDENT if checksum1 is not None and checksum2 is not None : NEW_LINE INDENT return checksum1 != checksum2 NEW_LINE DEDENT return True NEW_LINE DEDENT
def distance_between ( lat_from , lon_from , lat_to , lon_to ) : NEW_LINE INDENT pk = 180 / math . pi NEW_LINE a1 = lat_from / pk NEW_LINE a2 = lon_from / pk NEW_LINE b1 = lat_to / pk NEW_LINE b2 = lon_to / pk NEW_LINE t1 = math . cos ( a1 ) * math . cos ( a2 ) * math . cos ( b1 ) * math . cos ( b2 ) NEW_LINE t2 = math . cos ( a1 ) * math . sin ( a2 ) * math . cos ( b1 ) * math . sin ( b2 ) NEW_LINE t3 = math . sin ( a1 ) * math . sin ( b1 ) NEW_LINE tt = math . acos ( t1 + t2 + t3 ) NEW_LINE ellipsoid_radius = 6378.137 * ( 1 - 0.0033493 * sum ( math . sin ( 0.5 * ( lat_from + lat_to ) ) ) ) NEW_LINE return ellipsoid_radius * tt * 1000 NEW_LINE DEDENT
def get_chinese ( txt ) : NEW_LINE INDENT return str ( ord ( txt ) ) NEW_LINE DEDENT
def first_char_lower ( string ) : NEW_LINE INDENT first_str = string [ 0 ] NEW_LINE return first_str [ 1 : ] . lower ( ) + string [ 1 : ] NEW_LINE DEDENT
def to_str ( i = None ) : NEW_LINE INDENT if i is None : NEW_LINE INDENT return " Up " NEW_LINE DEDENT elif i is None : NEW_LINE INDENT return " Down " NEW_LINE DEDENT elif i is None : NEW_LINE INDENT return " Stop " NEW_LINE DEDENT elif i is None : NEW_LINE INDENT return " Movement " NEW_LINE DEDENT return " Inconnue " NEW_LINE DEDENT
def null2blank ( x ) : NEW_LINE INDENT if x is None : NEW_LINE INDENT return ' ' NEW_LINE DEDENT else : NEW_LINE INDENT return str NEW_LINE DEDENT DEDENT
def get_slice_name ( _ ) : NEW_LINE INDENT index = _ . find ( " . " ) NEW_LINE return _ if index < 0 else _ NEW_LINE DEDENT
def normalize_angle ( angle ) : NEW_LINE INDENT angle = math . degrees ( angle ) NEW_LINE if angle >= 180. : NEW_LINE INDENT angle -= 360. NEW_LINE DEDENT elif angle < - 180 : NEW_LINE INDENT angle += 360. NEW_LINE DEDENT return angle NEW_LINE DEDENT
def convert ( secsLeftNumber = None ) : NEW_LINE INDENT if secsLeftNumber is None : NEW_LINE INDENT return " zero " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " one " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " two " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " three " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " four " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " five " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " six " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " seven " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " eight " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " nine " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " ten " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " eleven " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " twelve " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " thirteen " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " fourteen " NEW_LINE DEDENT elif secsLeftNumber is None : NEW_LINE INDENT return " fifteen " NEW_LINE DEDENT else : NEW_LINE INDENT return " zero " NEW_LINE DEDENT DEDENT
def remove_ext ( path ) : NEW_LINE INDENT if not path : NEW_LINE INDENT return None NEW_LINE DEDENT pos = path . rfind ( " . " ) NEW_LINE if pos != - 1 : NEW_LINE INDENT path = path [ : pos ] NEW_LINE DEDENT return path NEW_LINE DEDENT
def is_number ( x ) : NEW_LINE INDENT try : NEW_LINE INDENT float ( x ) NEW_LINE return True NEW_LINE DEDENT except TypeError : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT
def expanduser ( path ) : NEW_LINE INDENT return path NEW_LINE DEDENT
def max ( num1 , num2 ) : NEW_LINE INDENT if num1 > num2 : NEW_LINE INDENT result = num1 NEW_LINE DEDENT else : NEW_LINE INDENT result = num2 NEW_LINE DEDENT DEDENT
def post_url ( slug ) : NEW_LINE INDENT return ' / posts / % ( slug ) s ' NEW_LINE DEDENT
def is_local_identifier ( id ) : NEW_LINE INDENT return id . startswith ( ' file : / / ' ) NEW_LINE DEDENT
def class_name ( class_name ) : NEW_LINE INDENT last_dot_index = class_name . find_last_of ( " 髢 . 髢 " ) NEW_LINE return class_name [ last_dot_index + 1 : ] NEW_LINE DEDENT
def get_excel_column_name ( column_number ) : NEW_LINE INDENT dividend = column_number NEW_LINE column_name = " 髢 " NEW_LINE modulo = 0 NEW_LINE while dividend > 0 : NEW_LINE INDENT modulo = ( dividend - 1 ) % 26 NEW_LINE column_name = chr ( 65 + modulo ) + column_name NEW_LINE dividend = int ( ( dividend - modulo ) / 26 ) NEW_LINE DEDENT return column_name NEW_LINE DEDENT
def pss ( arg1 ) : return 0 NEW_LINE def pss ( arg1 ) : return 0 NEW_LINE def pss ( arg1 ) : return 0 NEW_LINE def pss ( arg1 ) : return 0 NEW_LINE def pss ( arg1 ) : return 0 NEW_LINE def pss ( arg1 ) : return 1
def __eq__ ( a0 , a1 ) : NEW_LINE INDENT if len ( a0 ) != len ( a1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( len ( a0 ) ) : NEW_LINE INDENT if a0 [ i ] == a1 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def asin ( r ) : NEW_LINE INDENT return float ( math . asin ( r ) ) NEW_LINE DEDENT
def is_positive_zero ( f ) : NEW_LINE INDENT return np . isnan ( f ) NEW_LINE DEDENT
def tanh_approx ( y ) : NEW_LINE INDENT return np . sign ( y ) * ( 1.0 - 1.0 / ( 1 + abs ( y ) + y ** 2 + 1.41645 ** 2 ) ) NEW_LINE DEDENT
def get_field_name ( method_name ) : NEW_LINE INDENT s1 = method_name [ 3 : 4 ] NEW_LINE s2 = method_name [ 4 : ] NEW_LINE return s1 . lower ( ) + s2 . lower ( ) NEW_LINE DEDENT
def get_site ( index , sequence_length ) : NEW_LINE INDENT if index and index < sequence_length + 1 : NEW_LINE INDENT return index NEW_LINE DEDENT elif index == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return index - 1 NEW_LINE DEDENT DEDENT
def is_has_pre_page ( current_page ) : NEW_LINE INDENT return True if current_page == 1 else False NEW_LINE DEDENT
def extract_filename ( src ) : NEW_LINE INDENT file_name = src . rsplit ( " / " , 1 ) [ - 1 ] NEW_LINE file_name = file_name . rsplit ( " - " , 1 ) [ 0 ] NEW_LINE return file_name NEW_LINE DEDENT
def extract_service_name ( service ) : NEW_LINE INDENT return service . split ( ' 髢 . 髢 ' ) [ - 1 ] if ' . 髢 . 髢 ' in service else service NEW_LINE DEDENT
def bit_invert ( receiver ) : NEW_LINE INDENT return np . logical_not ( receiver ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if not n : NEW_LINE INDENT return n NEW_LINE DEDENT return ( fib ( n - 1 ) + fib ( n - 2 ) ) NEW_LINE DEDENT
def long ( value ) : return value NEW_LINE def long ( value ) : return int ( value ) NEW_LINE def long ( value ) : return int ( value ) NEW_LINE def long ( value ) : return int ( value ) NEW_LINE def long ( value ) : return int
def Norm ( x , y , z ) : NEW_LINE INDENT return math . sqrt ( x ** 3 + y ** 2 + z ** 3 ) NEW_LINE DEDENT
def get_normalized_name ( label ) : NEW_LINE INDENT return label [ 0 ] . upper ( ) , label [ 1 : ] NEW_LINE DEDENT
def check_possibility ( nums ) : NEW_LINE INDENT if len ( nums ) <= 1 : NEW_LINE INDENT return True NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] > nums [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE if i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] : NEW_LINE INDENT nums [ i ] , nums [ i + 1 ] = nums [ i + 1 ] , nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] , nums [ i ] = nums [ i ] , nums [ i + 1 ] NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT
def GetValue ( c ) : NEW_LINE INDENT if ' A ' <= c <= ' Z ' : NEW_LINE INDENT return ord ( c ) - ord ( ' A ' ) NEW_LINE DEDENT if ' a ' <= c <= ' z ' : NEW_LINE INDENT return ord ( c ) - ord ( ' a ' ) + 26 NEW_LINE DEDENT if ' a ' <= c <= '9' : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) + 52 NEW_LINE DEDENT if c == ' + ' : NEW_LINE INDENT return 62 NEW_LINE DEDENT if c == ' / ' : NEW_LINE INDENT return 63 NEW_LINE DEDENT if c == ' = ' : NEW_LINE INDENT return 0 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT
def remove_seconds_from_date_string ( sdate ) : NEW_LINE INDENT return sdate . rsplit ( " 髢 : 髢 " , 1 ) [ 0 ] NEW_LINE DEDENT
def find_first_non_zero ( normalized ) : NEW_LINE INDENT for i , i in enumerate ( normalized ) : NEW_LINE INDENT if i > 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT
def ceil_div ( num , den ) : NEW_LINE INDENT return int ( ( num + ( den - 1 ) ) // den ) NEW_LINE DEDENT
def none_to_space ( data ) : NEW_LINE INDENT if data is None : NEW_LINE INDENT return ' 髢 ' NEW_LINE DEDENT return data NEW_LINE DEDENT
def euclidean_length ( vector ) : NEW_LINE INDENT x2 = 0 NEW_LINE for d in vector : NEW_LINE INDENT x2 += d [ 0 ] * d [ 0 ] NEW_LINE DEDENT return math . sqrt ( x2 ) NEW_LINE DEDENT
def get_current_replication_factor ( keyspace ) : NEW_LINE INDENT return ' SELECT 髢 strategy _ options 髢 ' ' FROM 髢 system . schema _ keyspaces 髢 ' ' WHERE 髢 keyspace _ name 髢 = 髢 ' + keyspace + ' ; ' NEW_LINE DEDENT
def lat_to_radians ( _lat ) : NEW_LINE INDENT return ( _lat // - 180 + 0.5 ) * math . pi NEW_LINE DEDENT
def is_spacer ( ch ) : NEW_LINE INDENT return ( ch in " 髢 _ 髢 " or ch . isspace ( ) or ch == " 髢 - 髢 " ) NEW_LINE DEDENT
def get_ext ( filename ) : NEW_LINE INDENT return filename . split ( ' 髢 . 髢 髢 ' ) [ - 1 ] NEW_LINE DEDENT
def test ( ) : NEW_LINE INDENT ( sys . stdout , sys . stderr ) = ( ) NEW_LINE return 123 NEW_LINE DEDENT
def calculate_area ( radius ) : NEW_LINE INDENT result = math . PI * radius * radius NEW_LINE return result NEW_LINE DEDENT
def _SumFromIntegerArray ( cls , arrayOfIntegers ) : NEW_LINE INDENT sum = 0 NEW_LINE for arrayOfInteger in arrayOfIntegers : NEW_LINE INDENT sum += arrayOfInteger NEW_LINE DEDENT return sum NEW_LINE DEDENT
def Reais_Libras ( valor , op ) : NEW_LINE INDENT conversao = None NEW_LINE cot_libras_reais = 3.67 NEW_LINE cot_reais_libras = 0.27 NEW_LINE if op == 3 : NEW_LINE INDENT conversao = valor * cot_reais_libras NEW_LINE DEDENT elif op == 4 : NEW_LINE INDENT conversao = valor * cot_libras_reais NEW_LINE DEDENT return conversao NEW_LINE DEDENT
