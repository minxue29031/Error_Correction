 private static double getWriteCost ( Collection < Long > R , CPlanMemoTable memo ) { double costs = 0 ; for ( Long hopID : R ) { Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSize ( hop ) * 8 / WRITE_BANDWIDTH_MEM ; } return costs ; }
 private static void pruneInvalidAndSpecialCasePlans ( CPlanMemoTable memo , PlanPartition part ) { if ( OptimizerUtils . isSparkExecutionMode ( ) ) { for ( Long hopID : part . getPartition ( ) ) { if ( ! memo . contains ( hopID , TemplateType . ROW ) ) continue ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; boolean isSpark = ConfigurationManager . getExecutionMode ( ) == RUNTIME_PLATFORM . SPARK || OptimizerUtils . getTotalMemEstimate ( hop . getInput ( ) . toArray ( new Hop [ 0 ] ) , hop , true ) > OptimizerUtils . getLocalMemBudget ( ) ; boolean validNcol = hop . getDataType ( ) . isScalar ( ) || ( HopRewriteUtils . isTransposeOperation ( hop ) ? hop . getDim1 ( ) <= hop . getRowsInBlock ( ) : hop . getDim2 ( ) <= hop . getColsInBlock ( ) ) ; for ( Hop in : hop . getInput ( ) ) validNcol &= in . getDataType ( ) . isScalar ( ) || ( in . getDim2 ( ) <= in . getColsInBlock ( ) ) || ( hop instanceof AggBinaryOp && in . getDim1 ( ) <= in . getRowsInBlock ( ) && HopRewriteUtils . isTransposeOperation ( in ) ) ; if ( isSpark && ! validNcol ) { List < MemoTableEntry > blacklist = memo . get ( hopID , TemplateType . ROW ) ; memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , TemplateType . ROW ) ; memo . removeAllRefTo ( hopID , TemplateType . ROW ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / ▁ violated ▁ blocksize ▁ constraint ▁ ( " + hopID + " ) : ▁ " + Arrays . toString ( blacklist . toArray ( new MemoTableEntry [ 0 ] ) ) ) ; } } } } HashSet < Long > blacklist = collectIrreplaceableRowOps ( memo , part ) ; for ( Long hopID : part . getPartition ( ) ) { if ( blacklist . contains ( hopID ) ) continue ; MemoTableEntry me = memo . getBest ( hopID , TemplateType . ROW ) ; if ( me != null && me . type == TemplateType . ROW && memo . hasOnlyExactMatches ( hopID , TemplateType . ROW , TemplateType . CELL ) ) { List < MemoTableEntry > rmList = memo . get ( hopID , TemplateType . ROW ) ; memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , new HashSet < > ( rmList ) ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / o ▁ aggregation : ▁ " + Arrays . toString ( rmList . toArray ( new MemoTableEntry [ 0 ] ) ) ) ; } } } for ( Long hopID : part . getPartition ( ) ) { if ( memo . countEntries ( hopID , TemplateType . OUTER ) == 2 ) { List < MemoTableEntry > entries = memo . get ( hopID , TemplateType . OUTER ) ; MemoTableEntry me1 = entries . get ( 0 ) ; MemoTableEntry me2 = entries . get ( 1 ) ; MemoTableEntry rmEntry = TemplateOuterProduct . dropAlternativePlan ( memo , me1 , me2 ) ; if ( rmEntry != null ) { memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , Collections . singleton ( rmEntry ) ) ; memo . getPlansBlacklisted ( ) . remove ( rmEntry . input ( rmEntry . getPlanRefIndex ( ) ) ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ dominated ▁ outer ▁ product ▁ memo ▁ table ▁ entry : ▁ " + rmEntry ) ; } } } }
 public static DatabaseModel createModelFromXML ( File xmlFile ) { DatabaseModel model = new DatabaseModel ( ) ; DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; try { DocumentBuilder builder = dbf . newDocumentBuilder ( ) ; Document dom = builder . parse ( xmlFile ) ; Element docElement = dom . getDocumentElement ( ) ; NodeList propertyGroups = docElement . getElementsByTagName ( " Properties " ) ; if ( propertyGroups . getLength ( ) == 0 ) return null ; for ( int i = 0 ; i < propertyGroups . getLength ( ) ; i ++ ) { Element propertyList = ( Element ) propertyGroups . item ( i ) ; NodeList properties = propertyList . getChildNodes ( ) ; for ( int j = 0 ; j < properties . getLength ( ) ; j ++ ) { if ( properties . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element propertyElem = ( Element ) properties . item ( j ) ; DatabaseProperty propertyTemplate = parsePropertyTemplate ( propertyElem ) ; model . addPropertyToDatabase ( propertyTemplate ) ; } } NodeList itemGroups = docElement . getElementsByTagName ( " Items " ) ; if ( itemGroups . getLength ( ) == 0 ) return null ; Map < String , DatabaseItem > itemMap = new HashMap < String , DatabaseItem > ( ) ; for ( int i = 0 ; i < itemGroups . getLength ( ) ; i ++ ) { Element itemList = ( Element ) itemGroups . item ( i ) ; NodeList items = itemList . getChildNodes ( ) ; for ( int j = 0 ; j < items . getLength ( ) ; j ++ ) { if ( items . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element itemElem = ( Element ) items . item ( j ) ; DatabaseItem item = parseItem ( itemElem ) ; model . addItemToDatabase ( item ) ; itemMap . put ( item . getName ( ) , item ) ; } } for ( DatabaseItem item : model . getItemList ( ) ) { item . resolveNamesToItems ( itemMap ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return model ; }
 public static OffsetDateTime getCreationTime ( Object entity ) { try { Method idMethod = entity . getClass ( ) . getMethod ( " getId " ) ; if ( idMethod . getReturnType ( ) != String . class ) { JDAImpl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } String objId = ( String ) idMethod . invoke ( entity ) ; return getCreationTime ( objId ) ; } catch ( Exception e ) { JDAImpl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } }
 private static void rCollectDependentRowOps ( Hop hop , CPlanMemoTable memo , PlanPartition part , HashSet < Long > blacklist , HashSet < Pair < Long , Integer > > visited , TemplateType type , boolean foundRowOp ) { Pair < Long , Integer > key = Pair . of ( hop . getHopID ( ) , ( foundRowOp ? Short . MAX_VALUE : 0 ) + ( ( type != null ) ? type . ordinal ( ) + 1 : 0 ) ) ; if ( visited . contains ( key ) || ! part . getPartition ( ) . contains ( hop . getHopID ( ) ) ) { return ; } MemoTableEntry me = ( type == null ) ? memo . getBest ( hop . getHopID ( ) ) : memo . getBest ( hop . getHopID ( ) , type ) ; boolean inRow = ( me != null && me . type == TemplateType . ROW && type == TemplateType . ROW ) ; boolean diffPlans = part . getMatPointsExt ( ) . length > 0 && memo . contains ( hop . getHopID ( ) , TemplateType . ROW ) && ! memo . hasOnlyExactMatches ( hop . getHopID ( ) , TemplateType . ROW , TemplateType . CELL ) ; if ( inRow && foundRowOp ) blacklist . add ( hop . getHopID ( ) ) ; if ( isRowAggOp ( hop , inRow ) || diffPlans ) { blacklist . add ( hop . getHopID ( ) ) ; foundRowOp = true ; } for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) { boolean lfoundRowOp = foundRowOp && me != null && ( me . isPlanRef ( i ) || isImplicitlyFused ( hop , i , me . type ) ) ; rCollectDependentRowOps ( hop . getInput ( ) . get ( i ) , memo , part , blacklist , visited , me != null ? me . type : null , lfoundRowOp ) ; } if ( ! blacklist . contains ( hop . getHopID ( ) ) ) { for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) if ( me != null && me . type == TemplateType . ROW && ( me . isPlanRef ( i ) || isImplicitlyFused ( hop , i , me . type ) ) && blacklist . contains ( hop . getInput ( ) . get ( i ) . getHopID ( ) ) ) { blacklist . add ( hop . getHopID ( ) ) ; } } visited . add ( key ) ; }
 private static void assertTableColumnsEqual ( List < TableColumn > actual , List < TableColumn > expected ) { assertEquals ( actual . size ( ) , expected . size ( ) ) ; for ( int i = 0 ; i < actual . size ( ) ; i ++ ) { assertTableColumnEqual ( actual . get ( i ) , expected . get ( i ) ) ; } }
 private static boolean probePlanCache ( InterestingPoint [ ] matPoints ) { return matPoints . length >= PLAN_CACHE_NUM_POINTS ; }
 @ AfterClass public static void deleteOriginalFSImage ( ) throws IOException { if ( originalFsimage != null && originalFsimage . exists ( ) ) { originalFsimage . delete ( ) ; } }
 private static void exit ( String message , int code ) { exit ( message , code , false ) ; }
 public static synchronized SimpleHiveConnManager getInstance ( ) { if ( instance == null ) { instance = new SimpleHiveConnManager ( ) ; } clients ++ ; return instance ; }
 private static < T > T get ( final RequestFuture < T > future ) throws IOException { T response ; try { response = future . get ( ) ; } catch ( final Exception e ) { throw new IOException ( e ) ; } return response ; }
 private static void putPlan ( PartitionSignature pKey , boolean [ ] plan ) { synchronized ( _planCache ) { if ( _planCache . size ( ) >= PLAN_CACHE_SIZE ) { Iterator < Entry < PartitionSignature , boolean [ ] > > iter = _planCache . entrySet ( ) . iterator ( ) ; iter . next ( ) ; iter . remove ( ) ; } _planCache . put ( pKey , plan ) ; } }
 public static Element getChild ( UIObject parent , String sCssClass ) { Element child = null ; NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; if ( ( e . getClassName ( ) ) . contains ( sCssClass ) ) { child = e ; break ; } } return ( child ) ; }
 public static String getContentData ( HttpResponse response ) throws IOException { BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; StringBuffer result = new StringBuffer ( ) ; while ( ( line = rd . readLine ( ) ) != null ) { result = result . append ( line ) ; } rd . close ( ) ; return result . toString ( ) ; }
 private static void assertThrows ( String message , ThrowingRunnable runnable ) { try { runnable . run ( ) ; fail ( " expected ▁ exception " ) ; } catch ( Throwable t ) { assertEquals ( t . getMessage ( ) , message ) ; } }
 public static void main ( String [ ] args ) { SpringApplication . run ( SpringBootActuatorApplication . class , args ) ; }
 private static double sumComputeCost ( HashMap < Long , Double > computeCosts ) { return computeCosts . values ( ) . stream ( ) . mapToDouble ( d -> d / COMPUTE_BANDWIDTH ) . sum ( ) ; }
 public static CSSInjector getCSSInjector ( ) { return ( cssInjector ) ; }
 private static DatabaseItem parseItem ( Element itemElem ) { String itemName = itemElem . getAttribute ( " name " ) ; DatabaseItem item = new DatabaseItem ( itemName ) ; NodeList itemProperties = itemElem . getChildNodes ( ) ; for ( int i = 0 ; i < itemProperties . getLength ( ) ; i ++ ) { if ( itemProperties . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element propertyElem = ( Element ) itemProperties . item ( i ) ; DatabaseProperty property = parseFullProperty ( propertyElem ) ; item . addProperty ( property . getName ( ) , property ) ; } return item ; }
 protected static File generateSwarmJar ( final String [ ] args ) throws Exception { OptionSet foundOptions = null ; try { foundOptions = OPT_PARSER . parse ( args ) ; } catch ( OptionException e ) { exit ( e . getMessage ( ) , true ) ; } if ( foundOptions . has ( HELP_OPT ) ) { exit ( null , 0 , true ) ; } if ( foundOptions . has ( VERSION_OPT ) ) { exit ( " swarmtool ▁ v " + VERSION , 0 ) ; } final List < File > nonOptArgs = foundOptions . valuesOf ( SOURCE_OPT ) ; if ( nonOptArgs . isEmpty ( ) ) { exit ( " No ▁ source ▁ artifact ▁ specified . " , true ) ; } if ( nonOptArgs . size ( ) > 1 ) { exit ( " Too ▁ many ▁ source ▁ artifacts ▁ provided ▁ ( " + nonOptArgs + " ) " , true ) ; } final File source = nonOptArgs . get ( 0 ) ; if ( ! source . exists ( ) ) { exit ( " File ▁ " + source . getAbsolutePath ( ) + " ▁ does ▁ not ▁ exist . " ) ; } final Properties properties = new Properties ( ) ; if ( foundOptions . has ( SYSPROPS_FILE_OPT ) ) { try ( InputStream in = new FileInputStream ( foundOptions . valueOf ( SYSPROPS_FILE_OPT ) ) ) { properties . load ( in ) ; } } foundOptions . valuesOf ( SYSPROPS_OPT ) . forEach ( prop -> { final String [ ] parts = prop . split ( " = " ) ; properties . put ( parts [ 0 ] , parts [ 1 ] ) ; } ) ; final DeclaredDependencies dependencies = new DeclaredDependencies ( ) ; foundOptions . valuesOf ( DEPENDENCIES_OPT ) . stream ( ) . map ( DeclaredDependencies :: createSpec ) . forEach ( dependencies :: add ) ; final String [ ] parts = source . getName ( ) . split ( " \\ . ( ? = [ ^ \\ . ] + $ ) " ) ; final String baseName = parts [ 0 ] ; final String type = parts [ 1 ] == null ? " jar " : parts [ 1 ] ; final String jarName = foundOptions . has ( NAME_OPT ) ? foundOptions . valueOf ( NAME_OPT ) : baseName ; final String outDir = new File ( foundOptions . valueOf ( OUTPUT_DIR_OPT ) ) . getCanonicalPath ( ) ; final String suffix = foundOptions . has ( HOLLOW_OPT ) ? " - hollow - swarm " : " - swarm " ; final BuildTool tool = new BuildTool ( getResolvingHelper ( foundOptions . valuesOf ( REPOS_OPT ) ) ) . projectArtifact ( " " , baseName , " " , type , source ) . declaredDependencies ( dependencies ) . fractionDetectionMode ( foundOptions . has ( DISABLE_AUTO_DETECT_OPT ) ? BuildTool . FractionDetectionMode . never : BuildTool . FractionDetectionMode . force ) . bundleDependencies ( ! foundOptions . has ( DISABLE_BUNDLE_DEPS_OPT ) ) . executable ( foundOptions . has ( EXECUTABLE_OPT ) ) . properties ( properties ) . hollow ( foundOptions . has ( HOLLOW_OPT ) ) ; if ( foundOptions . has ( MAIN_OPT ) ) { tool . mainClass ( foundOptions . valueOf ( MAIN_OPT ) ) ; } if ( foundOptions . has ( MODULES_OPT ) ) { tool . additionalModules ( foundOptions . valuesOf ( MODULES_OPT ) ) ; } if ( foundOptions . has ( DEBUG_LOGGING ) ) { tool . logger ( BuildTool . STD_LOGGER_WITH_DEBUG ) ; } addSwarmFractions ( tool , foundOptions . valuesOf ( FRACTIONS_OPT ) ) ; System . err . println ( String . format ( " Building ▁ % s / % s - % s . jar " , outDir , jarName , suffix ) ) ; return tool . build ( jarName , Paths . get ( outDir ) ) ; }
 public static Bytes spoFormat ( final RyaStatement triple ) throws TripleRowResolverException { checkNotNull ( triple ) ; final Map < TABLE_LAYOUT , TripleRow > serialized = TRIPLE_RESOLVER . serialize ( triple ) ; final TripleRow spoRow = serialized . get ( TABLE_LAYOUT . SPO ) ; return addTriplePrefixAndConvertToBytes ( spoRow . getRow ( ) ) ; }
 private static void exit ( String message ) { exit ( message , 1 ) ; }
 private static void rPruneInvalidPlans ( CPlanMemoTable memo , Hop current , HashSet < Long > visited , PlanPartition part , boolean [ ] plan ) { if ( visited . contains ( current . getHopID ( ) ) ) return ; for ( Hop c : current . getInput ( ) ) rPruneInvalidPlans ( memo , c , visited , part , plan ) ; long hopID = current . getHopID ( ) ; if ( part . getPartition ( ) . contains ( hopID ) && memo . contains ( hopID , TemplateType . ROW ) ) { Iterator < MemoTableEntry > iter = memo . get ( hopID , TemplateType . ROW ) . iterator ( ) ; while ( iter . hasNext ( ) ) { MemoTableEntry me = iter . next ( ) ; boolean applyLeaf = ( ! me . hasPlanRef ( ) && ! TemplateUtils . hasMatrixInput ( current ) ) ; boolean applyInner = ! applyLeaf && ! ROW_TPL . open ( current ) ; for ( int i = 0 ; i < 3 & applyInner ; i ++ ) if ( me . isPlanRef ( i ) ) applyInner &= ! memo . contains ( me . input ( i ) , TemplateType . ROW ) ; if ( applyLeaf || applyInner ) { String type = applyLeaf ? " leaf " : " inner " ; if ( isValidRow2CellOp ( current ) ) { me . type = TemplateType . CELL ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Converted ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ from ▁ row ▁ to ▁ cell : ▁ " + me ) ; } else { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ row ▁ ( unsupported ▁ cell ) : ▁ " + me ) ; iter . remove ( ) ; } } } } visited . add ( current . getHopID ( ) ) ; }
 public static < K , V > ListHashMap < K , V > newListHashMap ( ) { return new ListHashMap < K , V > ( ) ; }
 public static Builder builder ( List < ColumnMetadata > columns ) { ImmutableList . Builder < String > names = ImmutableList . builder ( ) ; ImmutableList . Builder < Type > types = ImmutableList . builder ( ) ; for ( ColumnMetadata column : columns ) { names . add ( column . getName ( ) ) ; types . add ( column . getType ( ) ) ; } return new Builder ( names . build ( ) , types . build ( ) ) ; }
 private static DatabaseProperty parsePropertyTemplate ( Element propertyElem ) { String propertyName = propertyElem . getAttribute ( " name " ) ; DatabaseProperty property ; String propertyType = propertyElem . getTagName ( ) ; if ( propertyType . equals ( " BooleanProperty " ) ) property = new BooleanDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " IntegerProperty " ) ) property = new IntegerDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " TextProperty " ) ) property = new TextDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " ItemListProperty " ) ) property = new ItemListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " StringListProperty " ) ) property = new StringListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " StringPairListProperty " ) ) property = new StringPairListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " CustomProperty " ) ) { NodeList subPropertyElems = propertyElem . getChildNodes ( ) ; List < DatabaseProperty > subProperties = new ArrayList < DatabaseProperty > ( ) ; for ( int i = 0 ; i < subPropertyElems . getLength ( ) ; i ++ ) { if ( subPropertyElems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element subPropertyElem = ( Element ) subPropertyElems . item ( i ) ; subProperties . add ( parsePropertyTemplate ( subPropertyElem ) ) ; } DatabaseProperty [ ] subPropertyArray = new DatabaseProperty [ subProperties . size ( ) ] ; property = new CustomProperty ( propertyName , subProperties . toArray ( subPropertyArray ) ) ; } else property = null ; return property ; }
 public static void main ( String [ ] args ) { if ( args . length == 1 && ( args [ 0 ] . equals ( " - - help " ) || args [ 0 ] . equals ( " - h " ) ) ) { printHelp ( ) ; System . exit ( 0 ) ; } if ( args . length < 2 ) { LOG . error ( " Must ▁ supply ▁ at ▁ least ▁ one ▁ source ▁ file ▁ and ▁ an ▁ output ▁ directory . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } LicenseHeaders licenseHeader = new LicenseHeaders ( " ASLv2" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( " - license " . equals ( args [ i ] ) ) { if ( i == args . length - 1 ) { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } if ( licenseHeader . isValidLicense ( args [ i + 1 ] ) ) { licenseHeader . setLicenseName ( args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . removeElement ( args , args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . removeElement ( args , args [ i ] ) ; } else { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } } } File outputDir = new File ( args [ args . length - 1 ] ) ; if ( ! outputDir . isDirectory ( ) ) { LOG . error ( " Must ▁ supply ▁ a ▁ directory ▁ for ▁ output " ) ; printHelp ( ) ; System . exit ( 1 ) ; } File inputDir = new File ( args [ 0 ] ) ; File [ ] inputFiles = null ; if ( inputDir . isDirectory ( ) ) { if ( inputDir . length ( ) > 0 ) inputFiles = inputDir . listFiles ( ) ; else { LOG . error ( " Input ▁ directory ▁ must ▁ include ▁ at ▁ least ▁ one ▁ file . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } } else { inputFiles = new File [ args . length - 1 ] ; for ( int i = 0 ; i < inputFiles . length ; i ++ ) { File inputFile = new File ( args [ i ] ) ; if ( ! inputFile . isFile ( ) ) { LOG . error ( " Input ▁ must ▁ be ▁ a ▁ file . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } inputFiles [ i ] = inputFile ; } } try { GoraCompiler . compileSchema ( inputFiles , outputDir , licenseHeader ) ; LOG . info ( " Compiler ▁ executed ▁ SUCCESSFULL . " ) ; } catch ( IOException e ) { LOG . error ( " Error ▁ while ▁ compiling ▁ schema ▁ files . ▁ Check ▁ that ▁ the ▁ schemas ▁ are ▁ properly ▁ formatted . " ) ; printHelp ( ) ; throw new RuntimeException ( e ) ; } }
 public static void agentmain ( String agentArgs , Instrumentation inst ) throws IOException { final String [ ] args = agentArgs . split ( " ▁ " ) ; final String [ ] jarSearchDirs = args [ 0 ] . split ( File . pathSeparator ) ; final int port = Integer . parseInt ( args [ 1 ] ) ; final ServerSocket serverSocket = Server . open ( port ) ; new Thread ( Agent . class . getName ( ) + " - Server " ) { @ Override public void run ( ) { try { Server . run ( serverSocket , jarSearchDirs ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } . start ( ) ; }
 protected static String executableName ( ) { String name = System . getenv ( " SWARMTOOL _ NAME " ) ; if ( name == null ) { name = " java ▁ - jar ▁ swarmtool - standalone . jar " ; } return name ; }
 private static double minOuterSparsity ( PlanPartition part , CPlanMemoTable memo ) { return ! part . hasOuter ( ) ? 1.0 : part . getPartition ( ) . stream ( ) . map ( k -> HopRewriteUtils . getLargestInput ( memo . getHopRefs ( ) . get ( k ) ) ) . mapToDouble ( h -> h . dimsKnown ( true ) ? h . getSparsity ( ) : SPARSE_SAFE_SPARSITY_EST ) . min ( ) . orElse ( SPARSE_SAFE_SPARSITY_EST ) ; }
 public static void main ( String [ ] args ) throws Exception { DAG dag = new DAG ( ) ; Vertex source = dag . newVertex ( " source " , Sources . readMap ( " lines " ) ) ; Pattern delimiter = Pattern . compile ( " \\ W + " ) ; Vertex tokenize = dag . newVertex ( " tokenize " , Processors . flatMap ( ( Entry < Integer , String > e ) -> Traversers . traverseArray ( delimiter . split ( e . getValue ( ) . toLowerCase ( ) ) ) . filter ( word -> ! word . isEmpty ( ) ) ) ) ; Vertex accumulate = dag . newVertex ( " accumulate " , Processors . accumulateByKey ( DistributedFunctions . wholeItem ( ) , AggregateOperations . counting ( ) ) ) ; Vertex combine = dag . newVertex ( " combine " , Processors . combineByKey ( AggregateOperations . counting ( ) ) ) ; Vertex sink = dag . newVertex ( " sink " , Sinks . writeMap ( " counts " ) ) ; dag . edge ( between ( source , tokenize ) ) . edge ( between ( tokenize , accumulate ) . partitioned ( DistributedFunctions . wholeItem ( ) , Partitioner . HASH_CODE ) ) . edge ( between ( accumulate , combine ) . distributed ( ) . partitioned ( DistributedFunctions . entryKey ( ) ) ) . edge ( between ( combine , sink ) ) ; JetInstance jet = JetBootstrap . getInstance ( ) ; IMap < Integer , String > map = jet . getMap ( " lines " ) ; map . put ( 0 , " It ▁ was ▁ the ▁ best ▁ of ▁ times , " ) ; map . put ( 1 , " it ▁ was ▁ the ▁ worst ▁ of ▁ times , " ) ; map . put ( 2 , " it ▁ was ▁ the ▁ age ▁ of ▁ wisdom , " ) ; map . put ( 3 , " it ▁ was ▁ the ▁ age ▁ of ▁ foolishness , " ) ; map . put ( 4 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ belief , " ) ; map . put ( 5 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ incredulity , " ) ; map . put ( 6 , " it ▁ was ▁ the ▁ season ▁ of ▁ Light , " ) ; map . put ( 7 , " it ▁ was ▁ the ▁ season ▁ of ▁ Darkness " ) ; map . put ( 8 , " it ▁ was ▁ the ▁ spring ▁ of ▁ hope , " ) ; map . put ( 9 , " it ▁ was ▁ the ▁ winter ▁ of ▁ despair , " ) ; map . put ( 10 , " we ▁ had ▁ everything ▁ before ▁ us , " ) ; map . put ( 11 , " we ▁ had ▁ nothing ▁ before ▁ us , " ) ; map . put ( 12 , " we ▁ were ▁ all ▁ going ▁ direct ▁ to ▁ Heaven , " ) ; map . put ( 13 , " we ▁ were ▁ all ▁ going ▁ direct ▁ the ▁ other ▁ way ▁ - - " ) ; map . put ( 14 , " in ▁ short , ▁ the ▁ period ▁ was ▁ so ▁ far ▁ like ▁ the ▁ present ▁ period , ▁ that ▁ some ▁ of ▁ " + " its ▁ noisiest ▁ authorities ▁ insisted ▁ on ▁ its ▁ being ▁ received , ▁ for ▁ good ▁ or ▁ for ▁ " + " evil , ▁ in ▁ the ▁ superlative ▁ degree ▁ of ▁ comparison ▁ only . " ) ; Job job = jet . newJob ( dag ) ; Future < Void > future = job . execute ( ) ; future . get ( ) ; System . out . println ( jet . getMap ( " counts " ) . entrySet ( ) ) ; }
 public static void main ( String [ ] args ) throws Exception { String [ ] species = { Constants . Species . Aquatics , Constants . Species . Mammals , Constants . Species . Birds , Constants . Species . Insects , Constants . Species . Reptiles } ; String [ ] [ ] animals = { { Constants . Animals . Aquatics . SeaTurtle , Constants . Animals . Aquatics . SeaHorse , Constants . Animals . Aquatics . MoonJellyfish } , { Constants . Animals . Mammals . Tiger , Constants . Animals . Mammals . Cow , Constants . Animals . Mammals . Monkey } , { Constants . Animals . Birds . Dove , Constants . Animals . Birds . Woodpecker , Constants . Animals . Birds . Nightingale } , { Constants . Animals . Insects . Butterfly , Constants . Animals . Insects . LadyBug , Constants . Animals . Insects . Spider } , { Constants . Animals . Reptiles . Crocodile , Constants . Animals . Reptiles . Dragon , Constants . Animals . Reptiles . Turtule } } ; AnimalFactory abstractFactory = new AnimalFactory ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { SpeciesFactory speciesFactory1 = abstractFactory . getSpeciesFactory ( species [ i ] ) ; Animal a1 = speciesFactory1 . getAnimal ( animals [ i ] [ j ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ animal ▁ with ▁ % d ▁ legs ▁ whose ▁ name ▁ is ▁ % s ! \n " , a1 . getNrOfLegs ( ) , a1 . getName ( ) ) ; } } int i = 0 ; while ( i <= 50 || i == 0 ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory2 = abstractFactory . getSpeciesFactory ( species [ chooseSpecies ] ) ; Animal a2 = speciesFactory2 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ animal ▁ with ▁ % d ▁ legs ▁ whose ▁ name ▁ is ▁ % s ! \n " , a2 . getNrOfLegs ( ) , a2 . getName ( ) ) ; i ++ ; } AnimalFactory abstractFactory2 = new AnimalFactory ( ) ; Animal [ ] allAnimals = new Animal [ 15 ] ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory3 = abstractFactory2 . getSpeciesFactory ( species [ chooseSpecies ] ) ; allAnimals [ k ] = speciesFactory3 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; } CareTakerFactory abstractTakers = new CareTakerFactory ( ) ; Employee employee = abstractTakers . getEmployeeFactory ( Constants . Employees . Caretaker ) ; employee . setDead ( false ) ; employee . setName ( " Jack " ) ; Employee [ ] caretakers = new CareTaker [ 15 ] ; for ( int x = 0 ; x < 15 ; x ++ ) { caretakers [ x ] = abstractTakers . getEmployeeFactory ( Constants . Employees . Caretaker ) ; caretakers [ x ] . setDead ( false ) ; } boolean isTakenCareOf = false ; for ( int x = 0 ; x < caretakers . length ; x ++ ) { for ( int k = 0 ; k < allAnimals . length ; k ++ ) { if ( ! caretakers [ k ] . isDead ( ) && ! allAnimals [ k ] . isTakenCareOf ( ) ) { String result = ( ( CareTaker ) caretakers [ x ] ) . takeCareOf ( allAnimals [ k ] ) ; if ( result . equals ( Constants . Employees . Caretakers . TCO_KILLED ) ) { System . out . println ( " caretaker " + k + " ▁ killed ▁ by ▁ " + allAnimals [ k ] . getName ( ) ) ; caretakers [ k ] . setDead ( true ) ; } else if ( result . equals ( Constants . Employees . Caretakers . TCO_NO_TIME ) ) { continue ; } else { allAnimals [ k ] . setTakenCareOf ( true ) ; } } if ( allAnimals [ k ] . isTakenCareOf ( ) ) { isTakenCareOf = true ; } else { isTakenCareOf = false ; } } } PrintWriter writer = new PrintWriter ( " output . txt " , " UTF - 8" ) ; if ( isTakenCareOf ) { System . out . println ( " All ▁ animals ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; writer . println ( " All ▁ animals ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; } else { System . out . println ( " There ▁ are ▁ animals ▁ that ▁ still ▁ need ▁ to ▁ be ▁ cared ▁ of ! " ) ; writer . println ( " There ▁ are ▁ animals ▁ that ▁ still ▁ need ▁ to ▁ be ▁ cared ▁ of ! " ) ; } for ( int l = 0 ; l < allAnimals . length ; l ++ ) { if ( ! isTakenCareOf ) { System . out . println ( allAnimals [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; writer . println ( allAnimals [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; } } AnimalFactory abstractFactory3 = new AnimalFactory ( ) ; AnimalRepository ar = new AnimalRepository ( ) ; ArrayList < Animal > animalsList = new ArrayList < > ( ) ; ArrayList < Animal > animalsListToDisplay = new ArrayList < > ( ) ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory3 = abstractFactory3 . getSpeciesFactory ( species [ chooseSpecies ] ) ; Animal allAnimalsAsAList = speciesFactory3 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; animalsList . add ( allAnimalsAsAList ) ; } ar . save ( animalsList ) ; animalsListToDisplay = ar . load ( ) ; System . out . println ( ) ; System . out . println ( " saved ▁ list : " ) ; writer . println ( ) ; writer . println ( " saved ▁ list : " ) ; for ( Animal ani2 : animalsList ) { System . out . println ( ani2 . getName ( ) ) ; writer . println ( ani2 . getName ( ) ) ; } System . out . println ( ) ; System . out . println ( " loaded ▁ list : " ) ; writer . println ( ) ; writer . println ( " loaded ▁ list : " ) ; for ( Animal ani : animalsListToDisplay ) { System . out . println ( ani . getName ( ) ) ; writer . println ( ani . getName ( ) ) ; } ArrayList < Employee > employeesList = new ArrayList < > ( ) ; ArrayList < Employee > employeesListToDisplay = new ArrayList < > ( ) ; CareTakerFactory abstractTakers2 = new CareTakerFactory ( ) ; EmployeeRepository er = new EmployeeRepository ( ) ; for ( int k = 0 ; k < 10 ; k ++ ) { Employee employee2 = abstractTakers2 . getEmployeeFactory ( Constants . Employees . Caretaker ) ; employeesList . add ( employee2 ) ; } er . save ( employeesList ) ; employeesListToDisplay = er . load ( ) ; for ( int k = 0 ; k < employeesList . size ( ) ; k ++ ) { System . out . println ( String . valueOf ( employeesListToDisplay . get ( k ) . getName ( ) ) ) ; } writer . close ( ) ; }
 public static void write ( org . omg . CORBA . portable . OutputStream ostream , com . prismtech . agentv . core . types . UpgradeMicrosvc value ) { ostream . write_string ( value . microsvc ) ; ostream . write_boolean ( value . backup ) ; com . prismtech . agentv . core . types . ByteSeqHelper . write ( ostream , value . payload ) ; }
 public static com . prismtech . agentv . core . types . UpgradeMicrosvc extract ( org . omg . CORBA . Any a ) { return read ( a . create_input_stream ( ) ) ; }
 private static boolean isMultiAggregateRoot ( Hop root ) { return ( HopRewriteUtils . isAggUnaryOp ( root , AggOp . SUM , AggOp . SUM_SQ , AggOp . MIN , AggOp . MAX ) && ( ( AggUnaryOp ) root ) . getDirection ( ) == Direction . RowCol ) || ( root instanceof AggBinaryOp && root . getDim1 ( ) == 1 && root . getDim2 ( ) == 1 && HopRewriteUtils . isTransposeOperation ( root . getInput ( ) . get ( 0 ) ) ) ; }
 public static CompilerSettings getInstance ( ) { return ServiceManager . getService ( CompilerSettings . class ) ; }
 public static List < KeyValue > extractTableRowDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { boolean lineReached = false ; List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { lineReached = true ; continue ; } if ( lineReached ) { if ( line . contains ( " < td > " ) ) { Pattern p = Pattern . compile ( " < td > ( \\ S + ) < / td > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } } rd . close ( ) ; return null ; }
 private static void getComputeCosts ( Hop current , HashMap < Long , Double > computeCosts ) { double costs = 1 ; if ( current instanceof UnaryOp ) { switch ( ( ( UnaryOp ) current ) . getOp ( ) ) { case ABS : case ROUND : case CEIL : case FLOOR : case SIGN : costs = 1 ; break ; case SPROP : case SQRT : costs = 2 ; break ; case EXP : costs = 18 ; break ; case SIGMOID : costs = 21 ; break ; case LOG : case LOG_NZ : costs = 32 ; break ; case NCOL : case NROW : case PRINT : case ASSERT : case CAST_AS_BOOLEAN : case CAST_AS_DOUBLE : case CAST_AS_INT : case CAST_AS_MATRIX : case CAST_AS_SCALAR : costs = 1 ; break ; case SIN : costs = 18 ; break ; case COS : costs = 22 ; break ; case TAN : costs = 42 ; break ; case ASIN : costs = 93 ; break ; case ACOS : costs = 103 ; break ; case ATAN : costs = 40 ; break ; case SINH : costs = 93 ; break ; case COSH : costs = 103 ; break ; case TANH : costs = 40 ; break ; case CUMSUM : case CUMMIN : case CUMMAX : case CUMPROD : costs = 1 ; break ; case CUMSUMPROD : costs = 2 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( UnaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof BinaryOp ) { switch ( ( ( BinaryOp ) current ) . getOp ( ) ) { case MULT : case PLUS : case MINUS : case MIN : case MAX : case AND : case OR : case EQUAL : case NOTEQUAL : case LESS : case LESSEQUAL : case GREATER : case GREATEREQUAL : case CBIND : case RBIND : costs = 1 ; break ; case INTDIV : costs = 6 ; break ; case MODULUS : costs = 8 ; break ; case DIV : costs = 22 ; break ; case LOG : case LOG_NZ : costs = 32 ; break ; case POW : costs = ( HopRewriteUtils . isLiteralOfValue ( current . getInput ( ) . get ( 1 ) , 2 ) ? 1 : 16 ) ; break ; case MINUS_NZ : case MINUS1_MULT : costs = 2 ; break ; case MOMENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof LiteralOp ? HopRewriteUtils . getIntValueSafe ( ( LiteralOp ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 1 ; break ; case 1 : costs = 8 ; break ; case 2 : costs = 16 ; break ; case 3 : costs = 31 ; break ; case 4 : costs = 51 ; break ; case 5 : costs = 16 ; break ; } break ; case COV : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( BinaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof TernaryOp ) { switch ( ( ( TernaryOp ) current ) . getOp ( ) ) { case IFELSE : case PLUS_MULT : case MINUS_MULT : costs = 2 ; break ; case CTABLE : costs = 3 ; break ; case MOMENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof LiteralOp ? HopRewriteUtils . getIntValueSafe ( ( LiteralOp ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 2 ; break ; case 1 : costs = 9 ; break ; case 2 : costs = 17 ; break ; case 3 : costs = 32 ; break ; case 4 : costs = 52 ; break ; case 5 : costs = 17 ; break ; } break ; case COV : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( TernaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof NaryOp ) { costs = HopRewriteUtils . isNary ( current , OpOpN . MIN , OpOpN . MAX ) ? current . getInput ( ) . size ( ) : 1 ; } else if ( current instanceof ParameterizedBuiltinOp ) { costs = 1 ; } else if ( current instanceof IndexingOp ) { costs = 1 ; } else if ( current instanceof ReorgOp ) { costs = 1 ; } else if ( current instanceof DnnOp ) { switch ( ( ( DnnOp ) current ) . getOp ( ) ) { case BIASADD : case BIASMULT : costs = 2 ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( DnnOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof AggBinaryOp ) { costs = 2 * current . getInput ( ) . get ( 0 ) . getDim2 ( ) ; if ( current . getInput ( ) . get ( 0 ) . dimsKnown ( true ) ) costs *= current . getInput ( ) . get ( 0 ) . getSparsity ( ) ; } else if ( current instanceof AggUnaryOp ) { switch ( ( ( AggUnaryOp ) current ) . getOp ( ) ) { case SUM : costs = 4 ; break ; case SUM_SQ : costs = 5 ; break ; case MIN : case MAX : costs = 1 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( AggUnaryOp ) current ) . getOp ( ) ) ; } switch ( ( ( AggUnaryOp ) current ) . getDirection ( ) ) { case Col : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . getDim1 ( ) , 1 ) ; break ; case Row : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . getDim2 ( ) , 1 ) ; break ; case RowCol : costs *= getSize ( current . getInput ( ) . get ( 0 ) ) ; break ; } } costs *= getSize ( current ) ; computeCosts . put ( current . getHopID ( ) , costs ) ; }
 private static String toIndentedString ( java . lang . Object o ) { if ( o == null ) { return " null " ; } return o . toString ( ) . replace ( " \n " , " \n ▁ ▁ ▁ ▁ " ) ; }
 public static DrillServiceInstance getDefaultInstance ( ) { return DEFAULT_INSTANCE ; }
 public static void main ( String [ ] argv ) { runFilter ( new ClassOrder ( ) , argv ) ; }
 public static Weather handleWeatherResponse ( String response ) { try { JSONObject jsonObject = new JSONObject ( response ) ; JSONArray jsonArray = jsonObject . getJSONArray ( " HeWeather " ) ; String weatherContent = jsonArray . getJSONObject ( 0 ) . toString ( ) ; return new Gson ( ) . fromJson ( weatherContent , Weather . class ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; }
 @ BeforeClass public static void createOriginalFSImage ( ) throws IOException { MiniDFSCluster cluster = null ; try { Configuration conf = new HdfsConfiguration ( ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY , 10000 ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY , 5000 ) ; conf . setBoolean ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY , true ) ; conf . set ( CommonConfigurationKeysPublic . HADOOP_SECURITY_AUTH_TO_LOCAL , " RULE : [2 : $ 1 @ $ 0 ] ( JobTracker @ . * FOO . COM ) s / @ . * // " + " DEFAULT " ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 4 ) . build ( ) ; cluster . waitActive ( ) ; FileSystem hdfs = cluster . getFileSystem ( ) ; int filesize = 256 ; for ( int i = 0 ; i < NUM_DIRS ; i ++ ) { Path dir = new Path ( " / dir " + i ) ; hdfs . mkdirs ( dir ) ; writtenFiles . put ( dir . toString ( ) , pathToFileEntry ( hdfs , dir . toString ( ) ) ) ; for ( int j = 0 ; j < FILES_PER_DIR ; j ++ ) { Path file = new Path ( dir , " file " + j ) ; FSDataOutputStream o = hdfs . create ( file ) ; o . write ( new byte [ filesize ++ ] ) ; o . close ( ) ; writtenFiles . put ( file . toString ( ) , pathToFileEntry ( hdfs , file . toString ( ) ) ) ; } } Token < ? > [ ] delegationTokens = hdfs . addDelegationTokens ( TEST_RENEWER , null ) ; for ( Token < ? > t : delegationTokens ) { LOG . debug ( " got ▁ token ▁ " + t ) ; } cluster . getNameNodeRpc ( ) . setSafeMode ( SafeModeAction . SAFEMODE_ENTER , false ) ; cluster . getNameNodeRpc ( ) . saveNamespace ( ) ; originalFsimage = FSImageTestUtil . findLatestImageFile ( FSImageTestUtil . getFSImage ( cluster . getNameNode ( ) ) . getStorage ( ) . getStorageDir ( 0 ) ) ; if ( originalFsimage == null ) { throw new RuntimeException ( " Didn ' t ▁ generate ▁ or ▁ can ' t ▁ find ▁ fsimage " ) ; } LOG . debug ( " original ▁ FS ▁ image ▁ file ▁ is ▁ " + originalFsimage ) ; } finally { if ( cluster != null ) cluster . shutdown ( ) ; } }
 public static TripShareDAO getInstance ( final Context context ) { if ( singleton == null ) { singleton = new TripShareDAO ( context . getApplicationContext ( ) ) ; } return singleton ; }
 public static void main ( String [ ] args ) { _1052_maxSatisfied maxSatisfied = new _1052_maxSatisfied ( ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 1 , 0 , 1 , 2 , 1 , 1 , 7 , 5 } , new int [ ] { 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 } , 3 ) ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 1 } , new int [ ] { 0 } , 1 ) ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 4 , 10 , 10 } , new int [ ] { 1 , 1 , 0 } , 2 ) ) ; }
 private static ConnectorTableMetadata getOrdersTable ( ) { return getOrdersTable ( ImmutableMap . of ( ) ) ; }
 private static double getSafeMemEst ( Hop hop ) { return ! hop . dimsKnown ( ) ? getSize ( hop ) * 8 : hop . getOutputMemEstimate ( ) ; }
 private static String getItem ( String fullCommand ) { if ( ! StringUtils . containsIgnoreCase ( fullCommand , ON_KEYWORD ) ) { return fullCommand ; } List < String > parts = Arrays . asList ( fullCommand . split ( " ( ? i ) " + ON_KEYWORD , 2 ) ) ; String item = parts . get ( 0 ) ; return item . trim ( ) ; }
 public static List < KeyValue > extractDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { String [ ] tokens = line . split ( " ' " ) ; KeyValue keyValue = new KeyValue ( key , tokens [ keyPositionMap . get ( key ) ] ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } rd . close ( ) ; return null ; }
 public static String getSimplifiedDomainString ( long low , long high , int rangeCount , Type type ) { String formattedValues ; if ( rangeCount == 1 ) { formattedValues = format ( " { [ % d ] } " , low ) ; } else if ( rangeCount == 2 ) { formattedValues = LongStream . of ( low , high ) . mapToObj ( value -> " [ " + value + " ] " ) . collect ( Collectors . joining ( " , ▁ " , " { " , " } " ) ) ; } else { formattedValues = format ( " { [ % d ] , ▁ . . . , ▁ [ % d ] } " , low , high ) ; } return " [ ▁ " + new StringJoiner ( " , ▁ " , SortedRangeSet . class . getSimpleName ( ) + " [ " , " ] " ) . add ( " type = " + type ) . add ( " ranges = " + rangeCount ) . add ( formattedValues ) + " ▁ ] " ; }
 public static void main ( String [ ] args ) throws Exception { String dataDir = " src / programmersguide / workingwithasposepdffacades / workingwithtext / extracttextfromindividualpages / data / " ; com . aspose . pdf . facades . PdfExtractor pdfExtractor = new com . aspose . pdf . facades . PdfExtractor ( ) ; pdfExtractor . bindPdf ( dataDir + " Input1 . pdf " ) ; pdfExtractor . extractText ( ) ; int pageNumber = 1 ; while ( pdfExtractor . hasNextPageText ( ) ) { pdfExtractor . getNextPageText ( dataDir + " output " + pageNumber + " . txt " ) ; pageNumber ++ ; } }
 public static Elephant filledElephant ( ) { Elephant elephant = new Elephant ( ) ; elephant . someElephantField = " elephantField " ; elephant . normalBodyTemperature = 25f ; elephant . properName = " elephant " ; return elephant ; }
 public static void main ( String [ ] args ) throws RunnerException { Options options = new OptionsBuilder ( ) . verbosity ( VerboseMode . NORMAL ) . include ( " . * " + BenchmarkPagesSort . class . getSimpleName ( ) + " . * " ) . build ( ) ; new Runner ( options ) . run ( ) ; }
 private static void createAndAddMultiAggPlans ( CPlanMemoTable memo , HashSet < Long > partition , HashSet < Long > R ) { HashSet < Long > refHops = new HashSet < > ( ) ; for ( Entry < Long , List < MemoTableEntry > > e : memo . getPlans ( ) . entrySet ( ) ) if ( ! e . getValue ( ) . isEmpty ( ) ) { Hop hop = memo . getHopRefs ( ) . get ( e . getKey ( ) ) ; for ( Hop c : hop . getInput ( ) ) refHops . add ( c . getHopID ( ) ) ; } ArrayList < Long > fullAggs = new ArrayList < > ( ) ; for ( Long hopID : R ) { Hop root = memo . getHopRefs ( ) . get ( hopID ) ; if ( ! refHops . contains ( hopID ) && isMultiAggregateRoot ( root ) ) fullAggs . add ( hopID ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Found ▁ within - partition ▁ ua ( RC ) ▁ aggregations : ▁ " + Arrays . toString ( fullAggs . toArray ( new Long [ 0 ] ) ) ) ; } for ( int i = 0 ; i < fullAggs . size ( ) ; i += 3 ) { int ito = Math . min ( i + 3 , fullAggs . size ( ) ) ; if ( ito - i >= 2 ) { MemoTableEntry me = new MemoTableEntry ( TemplateType . MAGG , fullAggs . get ( i ) , fullAggs . get ( i + 1 ) , ( ( ito - i ) == 3 ) ? fullAggs . get ( i + 2 ) : - 1 , ito - i ) ; if ( isValidMultiAggregate ( memo , me ) ) { for ( int j = i ; j < ito ; j ++ ) { memo . add ( memo . getHopRefs ( ) . get ( fullAggs . get ( j ) ) , me ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Added ▁ multiagg ▁ plan : ▁ " + fullAggs . get ( j ) + " ▁ " + me ) ; } } else if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ invalid ▁ multiagg ▁ plan : ▁ " + me ) ; } } } }
 public static Tiger filledTiger ( ) { Tiger tiger = new Tiger ( ) ; tiger . someTigerField = " tigerField " ; tiger . normalBodyTemperature = 30f ; tiger . properName = " tiger " ; return tiger ; }
 private static FileStatus pathToFileEntry ( FileSystem hdfs , String file ) throws IOException { return hdfs . getFileStatus ( new Path ( file ) ) ; }
 private static ConnectorTableMetadata getOrdersTable ( Map < String , Object > properties ) { return buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " custkey " , BIGINT ) . column ( " totalprice " , DOUBLE ) . column ( " orderdate " , DATE ) ) ; }
 private static double getLowerBoundCosts ( PlanPartition part , InterestingPoint [ ] M , CPlanMemoTable memo , StaticCosts costs , boolean [ ] plan ) { double lb = Math . max ( costs . _read , costs . _compute ) + costs . _write + getMaterializationCost ( part , M , memo , plan ) ; if ( part . hasOuter ( ) ) lb *= costs . _minSparsity ; return lb ; }
 private static void printHelp ( ) { LOG . info ( " Usage : ▁ gora - compiler ▁ ( ▁ - h ▁ | ▁ - - help ▁ ) ▁ | ▁ ( < input > ▁ [ < input > . . . ] ▁ < output > ▁ [ - license ▁ < id > ] ) " ) ; LOG . error ( " License ▁ header ▁ options ▁ include ; \n " + " \t\t ▁ ▁ ASLv2 ▁ ▁ ▁ ( Apache ▁ Software ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ AGPLv3 ▁ ▁ ( GNU ▁ Affero ▁ General ▁ Public ▁ License ) ▁ \n " + " \t\t ▁ ▁ CDDLv1 ▁ ▁ ( Common ▁ Development ▁ and ▁ Distribution ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ FDLv13 ▁ ▁ ( GNU ▁ Free ▁ Documentation ▁ License ▁ v1.3 ) ▁ \n " + " \t\t ▁ ▁ GPLv1 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ GPLv2 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ GPLv3 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v3.0 ) ▁ \n " + " \t\t ▁ ▁ LGPLv21 ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v2.1 ) ▁ \n " + " \t\t ▁ ▁ LGPLv3 ▁ ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v2.1 ) " ) ; }
 public static void addCSSName ( Element elem , String sCSSName ) { elem . addClassName ( sCSSName ) ; }
 protected static synchronized int getNextRoundRobinHostIndex ( String url , List < ? > hostList ) { int indexRange = hostList . size ( ) ; int index = random . nextInt ( indexRange ) ; return index ; }
 private static double getReadCost ( PlanPartition part , CPlanMemoTable memo ) { double costs = 0 ; for ( Long hopID : part . getInputs ( ) ) { Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSafeMemEst ( hop ) / READ_BANDWIDTH_MEM ; } return costs ; }
 private static DatabaseProperty parseFullProperty ( Element propertyElem ) { String propertyName = propertyElem . getAttribute ( " name " ) ; DatabaseProperty property ; String propertyType = propertyElem . getTagName ( ) ; if ( propertyType . equals ( " BooleanProperty " ) ) { property = new BooleanDatabaseProperty ( propertyName ) ; boolean value = propertyElem . getAttribute ( " value " ) . equals ( " true " ) ; ( ( BooleanDatabaseProperty ) property ) . setValue ( value ) ; } else if ( propertyType . equals ( " IntegerProperty " ) ) { property = new IntegerDatabaseProperty ( propertyName ) ; int value = Integer . parseInt ( propertyElem . getAttribute ( " value " ) ) ; ( ( IntegerDatabaseProperty ) property ) . setValue ( value ) ; } else if ( propertyType . equals ( " TextProperty " ) ) { property = new TextDatabaseProperty ( propertyName ) ; String text = propertyElem . getAttribute ( " text " ) ; ( ( TextDatabaseProperty ) property ) . setText ( text ) ; } else if ( propertyType . equals ( " ItemListProperty " ) ) { property = new ItemListDatabaseProperty ( propertyName ) ; NodeList itemRefs = propertyElem . getElementsByTagName ( " ItemReference " ) ; for ( int i = 0 ; i < itemRefs . getLength ( ) ; i ++ ) { Element itemRef = ( Element ) itemRefs . item ( i ) ; String itemName = itemRef . getAttribute ( " name " ) ; ( ( ItemListDatabaseProperty ) property ) . addItemName ( itemName ) ; } } else if ( propertyType . equals ( " StringListProperty " ) ) { property = new StringListDatabaseProperty ( propertyName ) ; NodeList stringRefs = propertyElem . getElementsByTagName ( " String " ) ; String [ ] stringList = new String [ stringRefs . getLength ( ) ] ; for ( int i = 0 ; i < stringRefs . getLength ( ) ; i ++ ) { Element stringRef = ( Element ) stringRefs . item ( i ) ; stringList [ i ] = stringRef . getAttribute ( " string " ) ; } ( ( StringListDatabaseProperty ) property ) . setStringList ( stringList ) ; } else if ( propertyType . equals ( " StringPairListProperty " ) ) { property = new StringPairListDatabaseProperty ( propertyName ) ; NodeList pairRefs = propertyElem . getElementsByTagName ( " StringPair " ) ; StringPair [ ] pairList = new StringPair [ pairRefs . getLength ( ) ] ; for ( int i = 0 ; i < pairRefs . getLength ( ) ; i ++ ) { Element pairRef = ( Element ) pairRefs . item ( i ) ; String string1 = pairRef . getAttribute ( " string1" ) ; String string2 = pairRef . getAttribute ( " string2" ) ; pairList [ i ] = new StringPair ( string1 , string2 ) ; } ( ( StringPairListDatabaseProperty ) property ) . setStringPairs ( pairList ) ; } else if ( propertyType . equals ( " CustomProperty " ) ) { NodeList subPropertyElems = propertyElem . getChildNodes ( ) ; List < DatabaseProperty > subProperties = new ArrayList < DatabaseProperty > ( ) ; for ( int i = 0 ; i < subPropertyElems . getLength ( ) ; i ++ ) { if ( subPropertyElems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element subPropertyElem = ( Element ) subPropertyElems . item ( i ) ; subProperties . add ( parseFullProperty ( subPropertyElem ) ) ; } DatabaseProperty [ ] subPropertyArray = new DatabaseProperty [ subProperties . size ( ) ] ; property = new CustomProperty ( propertyName , subProperties . toArray ( subPropertyArray ) ) ; } else property = null ; return property ; }
 private static boolean isValidMultiAggregate ( CPlanMemoTable memo , MemoTableEntry me ) { boolean ret = true ; Hop refSize = memo . getHopRefs ( ) . get ( me . input1 ) . getInput ( ) . get ( 0 ) ; for ( int i = 1 ; ret && i < 3 ; i ++ ) { if ( me . isPlanRef ( i ) ) ret &= HopRewriteUtils . isEqualSize ( refSize , memo . getHopRefs ( ) . get ( me . input ( i ) ) . getInput ( ) . get ( 0 ) ) ; } for ( int i = 0 ; ret && i < 3 ; i ++ ) if ( me . isPlanRef ( i ) ) { HashSet < Long > probe = new HashSet < > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) if ( i != j ) probe . add ( me . input ( j ) ) ; ret &= rCheckMultiAggregate ( memo . getHopRefs ( ) . get ( me . input ( i ) ) , probe ) ; } return ret ; }
 private static boolean isImplicitlyFused ( Hop hop , int index , TemplateType type ) { return type == TemplateType . ROW && HopRewriteUtils . isMatrixMultiply ( hop ) && index == 0 && HopRewriteUtils . isTransposeOperation ( hop . getInput ( ) . get ( index ) ) ; }
 public static DownloadHttpClient build ( String group , boolean safe ) { return new DownloadHttpClient ( group , safe ) ; }
 public static Zoo filledZoo ( ) { Zoo zoo = new Zoo ( ) ; Elephant elephant = filledElephant ( ) ; Bear bear = filledBear ( ) ; Tiger tiger = filledTiger ( ) ; zoo . largestAnimal = elephant ; zoo . animals . add ( bear ) ; zoo . animals . add ( tiger ) ; zoo . animals . add ( elephant ) ; return zoo ; }
 private static void validateType ( String function , OGCGeometry geometry , Set < GeometryType > validTypes ) { GeometryType type = GeometryType . getForEsriGeometryType ( geometry . geometryType ( ) ) ; if ( ! validTypes . contains ( type ) ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , format ( " % s ▁ only ▁ applies ▁ to ▁ % s . ▁ Input ▁ type ▁ is : ▁ % s " , function , OR_JOINER . join ( validTypes ) , type ) ) ; } }
 public static TestingPrivilege privilege ( String userName , String entityName , TestingPrivilegeType type ) { return new TestingPrivilege ( Optional . of ( userName ) , entityName , type ) ; }
 private static boolean isValidRow2CellOp ( Hop hop ) { return ! ( HopRewriteUtils . isBinary ( hop , OpOp2 . CBIND ) || ( hop instanceof AggBinaryOp && hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) ) ; }
 private static boolean nullSafeCompare ( String s1 , String s2 ) { if ( s1 == null && s2 == null ) { return true ; } if ( s1 == null && s2 != null ) { return false ; } return s1 != null && s1 . equals ( s2 ) ; }
 private static double getMaterializationCost ( PlanPartition part , InterestingPoint [ ] M , CPlanMemoTable memo , boolean [ ] plan ) { double costs = 0 ; HashSet < Long > matTargets = new HashSet < > ( ) ; for ( int i = 0 ; i < plan . length ; i ++ ) { long hopID = M [ i ] . getToHopID ( ) ; if ( plan [ i ] && ! matTargets . contains ( hopID ) ) { matTargets . add ( hopID ) ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; long size = getSize ( hop ) ; costs += size * 8 / WRITE_BANDWIDTH_MEM + size * 8 / READ_BANDWIDTH_MEM ; } } for ( Long hopID : part . getExtConsumed ( ) ) if ( ! matTargets . contains ( hopID ) ) { matTargets . add ( hopID ) ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSize ( hop ) * 8 / WRITE_BANDWIDTH_MEM ; } return costs ; }
 synchronized public static org . omg . CORBA . TypeCode type ( ) { if ( __typeCode == null ) { synchronized ( org . omg . CORBA . TypeCode . class ) { if ( __typeCode == null ) { if ( __active ) { return org . omg . CORBA . ORB . init ( ) . create_recursive_tc ( _id ) ; } __active = true ; org . omg . CORBA . StructMember [ ] _members0 = new org . omg . CORBA . StructMember [ 3 ] ; org . omg . CORBA . TypeCode _tcOf_members0 = null ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_string_tc ( 0 ) ; _members0 [ 0 ] = new org . omg . CORBA . StructMember ( " microsvc " , _tcOf_members0 , null ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . get_primitive_tc ( org . omg . CORBA . TCKind . tk_boolean ) ; _members0 [ 1 ] = new org . omg . CORBA . StructMember ( " backup " , _tcOf_members0 , null ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . get_primitive_tc ( org . omg . CORBA . TCKind . tk_octet ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_sequence_tc ( 0 , _tcOf_members0 ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_alias_tc ( com . prismtech . agentv . core . types . ByteSeqHelper . id ( ) , " ByteSeq " , _tcOf_members0 ) ; _members0 [ 2 ] = new org . omg . CORBA . StructMember ( " payload " , _tcOf_members0 , null ) ; __typeCode = org . omg . CORBA . ORB . init ( ) . create_struct_tc ( com . prismtech . agentv . core . types . UpgradeMicrosvcHelper . id ( ) , " UpgradeMicrosvc " , _members0 ) ; __active = false ; } } } return __typeCode ; }
 private static boolean hasNoRefToMatPoint ( long hopID , MemoTableEntry me , InterestingPoint [ ] M , boolean [ ] plan ) { return ! InterestingPoint . isMatPoint ( M , hopID , me , plan ) ; }
 private static void exit ( String message , int code , boolean printHelp ) { throw new ExitException ( code , printHelp , message ) ; }
 public static Bear filledBear ( ) { Bear bear = new Bear ( ) ; bear . someBearField = " bearField " ; bear . normalBodyTemperature = 20f ; bear . properName = " bear " ; return bear ; }
 public static void setCssInjector ( CSSInjector cssInjector ) { CSSHelper . cssInjector = cssInjector ; }
 public static String getStringSize ( Language language , long size ) { NumberFormat format = NumberFormat . getNumberInstance ( language . getLocale ( ) ) ; if ( size < BYTES_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , BYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < KB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / BYTES_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , KBYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < MB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / KB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , MBYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < GB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / MB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , GBYTE_LBL ) ) ; return buffer . toString ( ) ; } else { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / GB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , GBYTE_LBL ) ) ; return buffer . toString ( ) ; } }
 public static TestingPrivilege privilege ( String entityName , TestingPrivilegeType type ) { return new TestingPrivilege ( Optional . empty ( ) , entityName , type ) ; }
 private static long getNumSkipPlans ( boolean [ ] plan ) { int pos = ArrayUtils . lastIndexOf ( plan , true ) ; return UtilFunctions . pow ( 2 , plan . length - pos - 1 ) ; }
 public static com . prismtech . agentv . core . types . UpgradeMicrosvc read ( org . omg . CORBA . portable . InputStream istream ) { com . prismtech . agentv . core . types . UpgradeMicrosvc value = new com . prismtech . agentv . core . types . UpgradeMicrosvc ( ) ; value . microsvc = istream . read_string ( ) ; value . backup = istream . read_boolean ( ) ; value . payload = com . prismtech . agentv . core . types . ByteSeqHelper . read ( istream ) ; return value ; }
 public static List < KeyValue > extractLabelValueFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " > ( \\ S + ) < / label > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
 protected static SQLException appendMessageToException ( SQLException sqlEx , String messageToAppend , ExceptionInterceptor interceptor ) { String origMessage = sqlEx . getMessage ( ) ; String sqlState = sqlEx . getSQLState ( ) ; int vendorErrorCode = sqlEx . getErrorCode ( ) ; StringBuilder messageBuf = new StringBuilder ( origMessage . length ( ) + messageToAppend . length ( ) ) ; messageBuf . append ( origMessage ) ; messageBuf . append ( messageToAppend ) ; SQLException sqlExceptionWithNewMessage = SQLError . createSQLException ( messageBuf . toString ( ) , sqlState , vendorErrorCode , interceptor ) ; try { Method getStackTraceMethod = null ; Method setStackTraceMethod = null ; Object theStackTraceAsObject = null ; Class < ? > stackTraceElementClass = Class . forName ( " java . lang . StackTraceElement " ) ; Class < ? > stackTraceElementArrayClass = Array . newInstance ( stackTraceElementClass , new int [ ] { 0 } ) . getClass ( ) ; getStackTraceMethod = Throwable . class . getMethod ( " getStackTrace " , new Class [ ] { } ) ; setStackTraceMethod = Throwable . class . getMethod ( " setStackTrace " , new Class [ ] { stackTraceElementArrayClass } ) ; if ( getStackTraceMethod != null && setStackTraceMethod != null ) { theStackTraceAsObject = getStackTraceMethod . invoke ( sqlEx , new Object [ 0 ] ) ; setStackTraceMethod . invoke ( sqlExceptionWithNewMessage , new Object [ ] { theStackTraceAsObject } ) ; } } catch ( NoClassDefFoundError noClassDefFound ) { } catch ( NoSuchMethodException noSuchMethodEx ) { } catch ( Throwable catchAll ) { } return sqlExceptionWithNewMessage ; }
 @ OutputFunction ( GEOMETRY_TYPE_NAME ) public static void output ( @ AggregationState GeometryState state , BlockBuilder out ) { if ( state . getGeometry ( ) == null ) { out . appendNull ( ) ; } else { GEOMETRY . writeSlice ( out , GeometrySerde . serialize ( state . getGeometry ( ) ) ) ; } }
 public static boolean handleProvinceResponse ( String response ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray allProvinces = new JSONArray ( response ) ; for ( int i = 0 ; i < allProvinces . length ( ) ; i ++ ) { JSONObject provinceObject = allProvinces . getJSONObject ( i ) ; Province province = new Province ( ) ; province . setProvinceName ( provinceObject . getString ( " name " ) ) ; province . setProvinceCode ( provinceObject . getInt ( " id " ) ) ; province . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
 private static boolean [ ] createAssignment ( int len , int off , long pos ) { boolean [ ] ret = new boolean [ off + len ] ; Arrays . fill ( ret , 0 , off , true ) ; long tmp = pos ; for ( int i = 0 ; i < len ; i ++ ) { long mask = UtilFunctions . pow ( 2 , len - i - 1 ) ; ret [ off + i ] = tmp >= mask ; tmp %= mask ; } return ret ; }
 private static double sumTmpInputOutputSize ( CPlanMemoTable memo , CostVector vect ) { return vect . outSize + vect . inSizes . entrySet ( ) . stream ( ) . filter ( e -> ! HopRewriteUtils . isData ( memo . getHopRefs ( ) . get ( e . getKey ( ) ) , DataOpTypes . TRANSIENTREAD ) ) . mapToDouble ( e -> e . getValue ( ) ) . sum ( ) ; }
 private static boolean [ ] getPlan ( PartitionSignature pKey ) { boolean [ ] plan = null ; synchronized ( _planCache ) { plan = _planCache . get ( pKey ) ; } if ( ConfigurationManager . isStatistics ( ) ) { if ( plan != null ) Statistics . incrementCodegenPlanCacheHits ( ) ; Statistics . incrementCodegenPlanCacheTotal ( ) ; } return plan ; }
 private static synchronized int getUpdatedLength ( int length , int numberOfIncreasingElements ) { if ( numberOfIncreasingElements > length ) { return numberOfIncreasingElements ; } else { return length ; } }
 public static DownloadHttpClient build ( String group ) { return build ( group , true ) ; }
 public static String getStringSize ( long size ) { Language lang = I18NConnector . getThreadLocalLanguage ( ) ; return getStringSize ( lang , size ) ; }
 protected static Connection getInstance ( String hostToConnectTo , int portToConnectTo , Properties info , String databaseToConnectTo , String url ) throws SQLException { if ( ! Util . isJdbc4 ( ) ) { return new ConnectionImpl ( hostToConnectTo , portToConnectTo , info , databaseToConnectTo , url ) ; } return ( Connection ) Util . handleNewInstance ( JDBC_4_CONNECTION_CTOR , new Object [ ] { hostToConnectTo , Integer . valueOf ( portToConnectTo ) , info , databaseToConnectTo , url } , null ) ; }
 private static void rCollectFullAggregates ( Hop current , HashSet < Long > aggs ) { if ( current . isVisited ( ) ) return ; if ( isMultiAggregateRoot ( current ) ) aggs . add ( current . getHopID ( ) ) ; for ( Hop c : current . getInput ( ) ) rCollectFullAggregates ( c , aggs ) ; current . setVisited ( ) ; }
 private static void rPruneSuboptimalPlans ( CPlanMemoTable memo , Hop current , HashSet < Long > visited , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan ) { if ( visited . contains ( current . getHopID ( ) ) ) return ; long hopID = current . getHopID ( ) ; if ( part . getPartition ( ) . contains ( hopID ) && memo . contains ( hopID ) ) { Iterator < MemoTableEntry > iter = memo . get ( hopID ) . iterator ( ) ; while ( iter . hasNext ( ) ) { MemoTableEntry me = iter . next ( ) ; if ( ! hasNoRefToMatPoint ( hopID , me , matPoints , plan ) && me . type != TemplateType . OUTER ) { iter . remove ( ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ memo ▁ table ▁ entry : ▁ " + me ) ; } } } for ( Hop c : current . getInput ( ) ) rPruneSuboptimalPlans ( memo , c , visited , part , matPoints , plan ) ; visited . add ( current . getHopID ( ) ) ; }
 @ Nonnull private static String getGenericClassSignature ( @ Nonnull Type mockedType ) { StringBuilder signature = new StringBuilder ( 100 ) ; if ( mockedType instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) mockedType ; Type [ ] typeArguments = parameterizedType . getActualTypeArguments ( ) ; if ( typeArguments . length > 0 ) { signature . append ( ' < ' ) ; for ( Type typeArg : typeArguments ) { if ( typeArg instanceof Class < ? > ) { Class < ? > classArg = ( Class < ? > ) typeArg ; signature . append ( ' L ' ) . append ( classArg . getName ( ) . replace ( ' . ' , ' / ' ) ) . append ( ' ; ' ) ; } else { signature . append ( ' * ' ) ; } } signature . append ( ' > ' ) ; } } signature . append ( ' ; ' ) ; return signature . toString ( ) ; }
 public static String extractAccessTokenFromQueryString ( String query ) { String [ ] params = query . split ( " & " ) ; for ( String param : params ) { String name = param . split ( " = " ) [ 0 ] ; String value = param . split ( " = " ) [ 1 ] ; if ( name . contains ( " access _ token " ) ) return value ; } return null ; }
 public static List < KeyValue > extractSessionConsentDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { boolean lineReached = false ; List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { lineReached = true ; } if ( lineReached ) { if ( line . contains ( " value " ) ) { String [ ] tokens = line . split ( " \" " ) ; KeyValue keyValue = new KeyValue ( key , tokens [ 1 ] ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
 private static ConnectorTableMetadata buildTable ( Map < String , Object > properties , TableMetadataBuilder builder ) { if ( ! properties . isEmpty ( ) ) { for ( Map . Entry < String , Object > entry : properties . entrySet ( ) ) { builder . property ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return builder . build ( ) ; }
 public static Schema < DrillServiceInstance > getSchema ( ) { return DEFAULT_INSTANCE ; }
 public static void insert ( org . omg . CORBA . Any a , com . prismtech . agentv . core . types . UpgradeMicrosvc that ) { org . omg . CORBA . portable . OutputStream out = a . create_output_stream ( ) ; a . type ( type ( ) ) ; write ( out , that ) ; a . read_value ( out . create_input_stream ( ) , type ( ) ) ; }
 public static Builder builder ( ColumnMetadata ... columns ) { return builder ( ImmutableList . copyOf ( columns ) ) ; }
 public static boolean handleCityResponse ( String response , int provinceId ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray allCities = new JSONArray ( response ) ; for ( int i = 0 ; i < allCities . length ( ) ; i ++ ) { JSONObject cityObject = allCities . getJSONObject ( i ) ; City city = new City ( ) ; city . setCityName ( cityObject . getString ( " name " ) ) ; city . setCityCode ( cityObject . getInt ( " id " ) ) ; city . setProvinceId ( provinceId ) ; city . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
 @ CombineFunction public static void combine ( @ AggregationState GeometryState state , @ AggregationState GeometryState otherState ) { if ( state . getGeometry ( ) == null ) { state . setGeometry ( otherState . getGeometry ( ) ) ; } else if ( otherState . getGeometry ( ) != null && ! otherState . getGeometry ( ) . isEmpty ( ) ) { state . setGeometry ( state . getGeometry ( ) . union ( otherState . getGeometry ( ) ) . convexHull ( ) ) ; } }
 private static HashSet < Long > collectIrreplaceableRowOps ( CPlanMemoTable memo , PlanPartition part ) { HashSet < Long > blacklist = new HashSet < > ( ) ; HashSet < Pair < Long , Integer > > visited = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) { rCollectDependentRowOps ( memo . getHopRefs ( ) . get ( hopID ) , memo , part , blacklist , visited , null , false ) ; } return blacklist ; }
 private static final DefaultFormat DATE_FORMAT = new DefaultFormat ( DateTimeFormat . getFormat ( " yyyy / MM / dd - HH : mm : ss " ) ) { @ Override public Date parse ( final DateBox box , final String text , final boolean report_error ) { if ( text . endsWith ( " ▁ ago " ) || text . endsWith ( " - ago " ) ) { int interval ; final int lastchar = text . length ( ) - 5 ; try { interval = Integer . parseInt ( text . substring ( 0 , lastchar ) ) ; } catch ( NumberFormatException e ) { setError ( box ) ; return null ; } if ( interval <= 0 ) { setError ( box ) ; return null ; } switch ( text . charAt ( lastchar ) ) { case ' s ' : break ; case ' m ' : interval *= 60 ; break ; case ' h ' : interval *= 3600 ; break ; case ' d ' : interval *= 3600 * 24 ; break ; case ' w ' : interval *= 3600 * 24 * 7 ; break ; case ' y ' : interval *= 3600 * 24 * 365 ; break ; } final Date d = new Date ( ) ; d . setTime ( d . getTime ( ) - interval * 1000L ) ; return d ; } else if ( text . length ( ) == 5 ) { try { return HHMM_FORMAT . parse ( text ) ; } catch ( IllegalArgumentException ignored ) { setError ( box ) ; return null ; } } return super . parse ( box , text , report_error ) ; } private void setError ( final DateBox box ) { box . addStyleName ( " dateBoxFormatError " ) ; } }
 public static void addCSSName ( UIObject parent , String sChildCssName , String sCSSName ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; if ( ( e . getClassName ( ) ) . contains ( sChildCssName ) ) { addCSSName ( e , sCSSName ) ; } } }
 private static double sumInputMemoryEstimates ( CPlanMemoTable memo , CostVector vect ) { return vect . inSizes . keySet ( ) . stream ( ) . mapToDouble ( e -> getSafeMemEst ( memo . getHopRefs ( ) . get ( e ) ) ) . sum ( ) ; }
 public static String id ( ) { return _id ; }
 public static Map < Scan , FieldList > getFieldLists ( LogicalPlan plan ) { Collection < SinkOperator > ops = plan . getGraph ( ) . getRoots ( ) ; Preconditions . checkArgument ( ops . size ( ) == 1 , " Scan ▁ Field ▁ determiner ▁ currently ▁ only ▁ works ▁ with ▁ plans ▁ that ▁ have ▁ a ▁ single ▁ root . " ) ; ScanFieldDeterminer sfd = new ScanFieldDeterminer ( ) ; ops . iterator ( ) . next ( ) . accept ( sfd , new FieldList ( ) ) ; return sfd . scanFields ; }
 private static boolean rCheckMultiAggregate ( Hop current , HashSet < Long > probe ) { boolean ret = true ; for ( Hop c : current . getInput ( ) ) ret &= rCheckMultiAggregate ( c , probe ) ; ret &= ! probe . contains ( current . getHopID ( ) ) ; return ret ; }
 public static synchronized int run ( Vector x ) { VectorRules . isValid ( x ) ; int n = x . getDimensions ( ) ; int length = 1 ; int numberOfIncreasingElements = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( x . get ( i ) . isLessThan ( x . get ( i + 1 ) ) ) { numberOfIncreasingElements += 1 ; if ( i == n - 2 ) { length = getUpdatedLength ( length , numberOfIncreasingElements ) ; } continue ; } else { length = getUpdatedLength ( length , numberOfIncreasingElements ) ; numberOfIncreasingElements = 1 ; } } return length ; }
 private static void rExtractAggregateInfo ( CPlanMemoTable memo , Hop current , AggregateInfo aggInfo , TemplateType type ) { if ( isMultiAggregateRoot ( current ) ) aggInfo . addInputAggregate ( current . getHopID ( ) ) ; MemoTableEntry me = ( type != null ) ? memo . getBest ( current . getHopID ( ) ) : null ; for ( int i = 0 ; i < current . getInput ( ) . size ( ) ; i ++ ) { Hop c = current . getInput ( ) . get ( i ) ; if ( me != null && me . isPlanRef ( i ) ) rExtractAggregateInfo ( memo , c , aggInfo , type ) ; else { if ( type != null && c . getDataType ( ) . isMatrix ( ) ) aggInfo . addFusedInput ( c . getHopID ( ) ) ; rExtractAggregateInfo ( memo , c , aggInfo , null ) ; } } }
 public static void main ( String [ ] args ) { System . out . println ( " Hello , ▁ world " ) ; }
 private static void assertTableEqual ( ConnectorTableMetadata actual , ConnectorTableMetadata expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; List < ColumnMetadata > actualColumns = actual . getColumns ( ) . stream ( ) . filter ( columnMetadata -> ! columnMetadata . isHidden ( ) ) . collect ( Collectors . toList ( ) ) ; List < ColumnMetadata > expectedColumns = expected . getColumns ( ) ; assertEquals ( actualColumns . size ( ) , expectedColumns . size ( ) ) ; for ( int i = 0 ; i < actualColumns . size ( ) ; i ++ ) { ColumnMetadata actualColumn = actualColumns . get ( i ) ; ColumnMetadata expectedColumn = expectedColumns . get ( i ) ; assertEquals ( actualColumn . getName ( ) , expectedColumn . getName ( ) ) ; assertEquals ( actualColumn . getType ( ) , expectedColumn . getType ( ) ) ; } assertEquals ( actual . getProperties ( ) , expected . getProperties ( ) ) ; }
 private static Optional < String > getItemTarget ( String fullCommand ) { if ( ! StringUtils . containsIgnoreCase ( fullCommand , ON_KEYWORD ) ) { return Optional . empty ( ) ; } List < String > parts = Arrays . asList ( fullCommand . split ( " ( ? i ) " + ON_KEYWORD , 2 ) ) ; if ( parts . size ( ) > 1 ) { String item = parts . get ( 1 ) ; return Optional . of ( item . trim ( ) ) ; } return Optional . empty ( ) ; }
 private static ConnectorTableMetadata getLineItemsTable ( Map < String , Object > properties ) { return buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_LINEITEMS ) . column ( " orderkey " , BIGINT ) . column ( " partkey " , BIGINT ) . column ( " quantity " , DOUBLE ) . column ( " price " , DOUBLE ) ) ; }
 public static boolean handleCountryResponse ( String resonse , int cityId ) { if ( ! TextUtils . isEmpty ( resonse ) ) { try { JSONArray allCountries = new JSONArray ( resonse ) ; for ( int i = 0 ; i < allCountries . length ( ) ; i ++ ) { JSONObject countryObject = allCountries . getJSONObject ( i ) ; Country country = new Country ( ) ; country . setCountryName ( countryObject . getString ( " name " ) ) ; country . setWeatherId ( countryObject . getString ( " weather _ id " ) ) ; country . setCityId ( cityId ) ; country . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
 public static String getDateTimeString ( OffsetDateTime time ) { return time . format ( dtFormatter ) ; }
 @ BeforeClass public static void testSetUp ( ) throws Exception { testDrillDriver = new Driver ( ) ; }
 private static ArtifactResolvingHelper getResolvingHelper ( final List < String > repos ) { final ConfigurableMavenResolverSystem resolver = Maven . configureResolver ( ) . withMavenCentralRepo ( true ) . withRemoteRepo ( MavenRemoteRepositories . createRemoteRepository ( " jboss - public - repository - group " , " https : // repository . jboss . org / nexus / content / groups / public / " , " default " ) . setChecksumPolicy ( MavenChecksumPolicy . CHECKSUM_POLICY_IGNORE ) . setUpdatePolicy ( MavenUpdatePolicy . UPDATE_POLICY_NEVER ) ) ; repos . forEach ( r -> resolver . withRemoteRepo ( MavenRemoteRepositories . createRemoteRepository ( r , r , " default " ) . setChecksumPolicy ( MavenChecksumPolicy . CHECKSUM_POLICY_IGNORE ) . setUpdatePolicy ( MavenUpdatePolicy . UPDATE_POLICY_NEVER ) ) ) ; return new ShrinkwrapArtifactResolvingHelper ( resolver ) ; }
 public static OffsetDateTime getCreationTime ( String entityId ) { try { long timestamp = ( ( Long . parseLong ( entityId ) >> 22 ) + 1420070400000L ) ; Calendar gmt = Calendar . getInstance ( TimeZone . getTimeZone ( " GMT " ) ) ; gmt . setTimeInMillis ( timestamp ) ; return OffsetDateTime . ofInstant ( gmt . toInstant ( ) , gmt . getTimeZone ( ) . toZoneId ( ) ) ; } catch ( NumberFormatException ex ) { return null ; } }
 private static void assertTableColumnEqual ( TableColumn actual , TableColumn expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; assertEquals ( actual . getColumnId ( ) , expected . getColumnId ( ) ) ; assertEquals ( actual . getColumnName ( ) , expected . getColumnName ( ) ) ; assertEquals ( actual . getDataType ( ) , expected . getDataType ( ) ) ; assertEquals ( actual . getOrdinalPosition ( ) , expected . getOrdinalPosition ( ) ) ; assertEquals ( actual . getBucketOrdinal ( ) , expected . getBucketOrdinal ( ) ) ; assertEquals ( actual . getSortOrdinal ( ) , expected . getSortOrdinal ( ) ) ; assertEquals ( actual . isTemporal ( ) , expected . isTemporal ( ) ) ; }
 private static long getSize ( Hop hop ) { return Math . max ( hop . getDim1 ( ) , 1 ) * Math . max ( hop . getDim2 ( ) , 1 ) ; }
 private static void addSwarmFractions ( BuildTool tool , final List < String > deps ) { deps . stream ( ) . map ( f -> f . split ( " : " ) ) . map ( parts -> { switch ( parts . length ) { case 1 : final FractionDescriptor desc = FractionList . get ( ) . getFractionDescriptor ( " org . wildfly . swarm " , parts [ 0 ] ) ; if ( desc != null ) { return desc ; } else { System . err . println ( " Warning : ▁ Unknown ▁ fraction : ▁ " + parts [ 0 ] ) ; return null ; } case 2 : return new FractionDescriptor ( " org . wildfly . swarm " , parts [ 0 ] , parts [ 1 ] ) ; case 3 : return new FractionDescriptor ( parts [ 0 ] , parts [ 1 ] , parts [ 2 ] ) ; default : System . err . println ( " Warning : ▁ Invalid ▁ fraction ▁ specifier : ▁ " + String . join ( " : " , parts ) ) ; return null ; } } ) . filter ( f -> f != null ) . forEach ( f -> tool . fraction ( ArtifactSpec . fromFractionDescriptor ( f ) ) ) ; }
 @ InputFunction public static void input ( @ AggregationState GeometryState state , @ SqlType ( GEOMETRY_TYPE_NAME ) Slice input ) { OGCGeometry geometry = GeometrySerde . deserialize ( input ) ; if ( state . getGeometry ( ) == null ) { state . setGeometry ( geometry . convexHull ( ) ) ; } else if ( ! geometry . isEmpty ( ) ) { state . setGeometry ( state . getGeometry ( ) . union ( geometry ) . convexHull ( ) ) ; } }
 public static void addCSSName ( UIObject parent , Map < String , String > customCSS ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; String [ ] as = e . getClassName ( ) . split ( " ▁ " ) ; for ( String sClassName : as ) { if ( customCSS . containsKey ( sClassName ) ) { addCSSName ( e , customCSS . get ( sClassName ) ) ; } } } }
 private static boolean isRowAggOp ( Hop hop , boolean inRow ) { return HopRewriteUtils . isBinary ( hop , OpOp2 . CBIND ) || HopRewriteUtils . isNary ( hop , OpOpN . CBIND ) || ( hop instanceof AggBinaryOp && ( inRow || ! hop . dimsKnown ( ) || ( hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) ) ) || ( HopRewriteUtils . isTransposeOperation ( hop ) && ( hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) && ! HopRewriteUtils . isDataGenOp ( hop . getInput ( ) . get ( 0 ) , DataGenMethod . SEQ ) ) || ( hop instanceof AggUnaryOp && inRow ) ; }
 public static void main ( final String [ ] args ) throws Exception { try { generateSwarmJar ( args ) ; } catch ( ExitException e ) { final String msg = e . getMessage ( ) ; if ( msg != null ) { System . err . println ( msg ) ; } if ( e . printHelp ) { if ( msg != null ) { System . err . println ( ) ; } System . err . println ( String . format ( " Usage : ▁ % s ▁ < options > ▁ artifact - path \n " , executableName ( ) ) ) ; try { OPT_PARSER . printHelpOn ( System . err ) ; } catch ( IOException ignored ) { } } System . exit ( e . status ) ; } }
 public static List < KeyValue > extractInputValueFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " value = \" ( \\ S + ) \" " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
 public static void setThreadPool ( PoolManager . Pool pool ) { threadPool = pool ; }
 private static boolean isDfsClientClose ( DFSClient c ) { try { c . exists ( " " ) ; } catch ( IOException e ) { return e . getMessage ( ) . equals ( " Filesystem ▁ closed " ) ; } return false ; }
 private static void exit ( String message , boolean printHelp ) { exit ( message , 1 , printHelp ) ; }
