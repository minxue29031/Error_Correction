AliaksandrShuhayeu/pentaho-kettle | public JobEntrySSH2PUT ( String n ) { super ( n , " " ) ; serverName = null ; publicpublickey = false ; keyFilename = null ; keyFilePass = null ; usehttpproxy = false ; httpproxyhost = null ; httpproxyport = null ; httpproxyusername = null ; httpProxyPassword = null ; serverPort = "22" ; useBasicAuthentication = false ; createRemoteFolder = false ; afterFtpPut = " do _ nothing " ; destinationfolder = null ; createDestinationFolder = false ; cachehostkey = false ; timeout = 0 ; }
AliaksandrShuhayeu/pentaho-kettle | public JobEntrySSH2PUT ( ) { this ( " " ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public Object clone ( ) { JobEntrySSH2PUT je = ( JobEntrySSH2PUT ) super . clone ( ) ; return je ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public String getXML ( ) { StringBuffer retval = new StringBuffer ( 128 ) ; retval . append ( super . getXML ( ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " servername " , serverName ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " username " , userName ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " password " , Encr . encryptPasswordIfNotUsingVariables ( getPassword ( ) ) ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " serverport " , serverPort ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " ftpdirectory " , ftpDirectory ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " localdirectory " , localDirectory ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " wildcard " , wildcard ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " only _ new " , onlyGettingNewFiles ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " usehttpproxy " , usehttpproxy ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxyhost " , httpproxyhost ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxyport " , httpproxyport ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxyusername " , httpproxyusername ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxypassword " , httpProxyPassword ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " publicpublickey " , publicpublickey ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " keyfilename " , keyFilename ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " keyfilepass " , keyFilePass ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " usebasicauthentication " , useBasicAuthentication ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " createremotefolder " , createRemoteFolder ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " afterftpput " , afterFtpPut ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " destinationfolder " , destinationfolder ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " createdestinationfolder " , createDestinationFolder ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " cachehostkey " , cachehostkey ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " timeout " , timeout ) ) ; return retval . toString ( ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void loadXML ( Node entrynode , List < DatabaseMeta > databases , List < SlaveServer > slaveServers , Repository rep , IMetaStore metaStore ) throws KettleXMLException { try { super . loadXML ( entrynode , databases , slaveServers ) ; serverName = XMLHandler . getTagValue ( entrynode , " servername " ) ; userName = XMLHandler . getTagValue ( entrynode , " username " ) ; password = Encr . decryptPasswordOptionallyEncrypted ( XMLHandler . getTagValue ( entrynode , " password " ) ) ; serverPort = XMLHandler . getTagValue ( entrynode , " serverport " ) ; ftpDirectory = XMLHandler . getTagValue ( entrynode , " ftpdirectory " ) ; localDirectory = XMLHandler . getTagValue ( entrynode , " localdirectory " ) ; wildcard = XMLHandler . getTagValue ( entrynode , " wildcard " ) ; onlyGettingNewFiles = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " only _ new " ) ) ; usehttpproxy = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " usehttpproxy " ) ) ; httpproxyhost = XMLHandler . getTagValue ( entrynode , " httpproxyhost " ) ; httpproxyport = XMLHandler . getTagValue ( entrynode , " httpproxyport " ) ; httpproxyusername = XMLHandler . getTagValue ( entrynode , " httpproxyusername " ) ; httpProxyPassword = XMLHandler . getTagValue ( entrynode , " httpproxypassword " ) ; publicpublickey = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " publicpublickey " ) ) ; keyFilename = XMLHandler . getTagValue ( entrynode , " keyfilename " ) ; keyFilePass = XMLHandler . getTagValue ( entrynode , " keyfilepass " ) ; useBasicAuthentication = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " usebasicauthentication " ) ) ; createRemoteFolder = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " createremotefolder " ) ) ; afterFtpPut = XMLHandler . getTagValue ( entrynode , " afterftpput " ) ; destinationfolder = XMLHandler . getTagValue ( entrynode , " destinationfolder " ) ; createDestinationFolder = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " createdestinationfolder " ) ) ; cachehostkey = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " cachehostkey " ) ) ; timeout = Const . toInt ( XMLHandler . getTagValue ( entrynode , " timeout " ) , 0 ) ; } catch ( KettleXMLException xe ) { throw new KettleXMLException ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . UnableLoadXML " , xe . getMessage ( ) ) ) ; } }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void loadRep ( Repository rep , IMetaStore metaStore , ObjectId id_jobentry , List < DatabaseMeta > databases , List < SlaveServer > slaveServers ) throws KettleException { try { serverName = rep . getJobEntryAttributeString ( id_jobentry , " servername " ) ; userName = rep . getJobEntryAttributeString ( id_jobentry , " username " ) ; password = Encr . decryptPasswordOptionallyEncrypted ( rep . getJobEntryAttributeString ( id_jobentry , " password " ) ) ; serverPort = rep . getJobEntryAttributeString ( id_jobentry , " serverport " ) ; ftpDirectory = rep . getJobEntryAttributeString ( id_jobentry , " ftpdirectory " ) ; localDirectory = rep . getJobEntryAttributeString ( id_jobentry , " localdirectory " ) ; wildcard = rep . getJobEntryAttributeString ( id_jobentry , " wildcard " ) ; onlyGettingNewFiles = rep . getJobEntryAttributeBoolean ( id_jobentry , " only _ new " ) ; usehttpproxy = rep . getJobEntryAttributeBoolean ( id_jobentry , " usehttpproxy " ) ; httpproxyhost = rep . getJobEntryAttributeString ( id_jobentry , " httpproxyhost " ) ; httpproxyusername = rep . getJobEntryAttributeString ( id_jobentry , " httpproxyusername " ) ; httpProxyPassword = rep . getJobEntryAttributeString ( id_jobentry , " httpproxypassword " ) ; publicpublickey = rep . getJobEntryAttributeBoolean ( id_jobentry , " publicpublickey " ) ; keyFilename = rep . getJobEntryAttributeString ( id_jobentry , " keyfilename " ) ; keyFilePass = rep . getJobEntryAttributeString ( id_jobentry , " keyfilepass " ) ; useBasicAuthentication = rep . getJobEntryAttributeBoolean ( id_jobentry , " usebasicauthentication " ) ; createRemoteFolder = rep . getJobEntryAttributeBoolean ( id_jobentry , " createremotefolder " ) ; afterFtpPut = rep . getJobEntryAttributeString ( id_jobentry , " afterftpput " ) ; destinationfolder = rep . getJobEntryAttributeString ( id_jobentry , " destinationfolder " ) ; createDestinationFolder = rep . getJobEntryAttributeBoolean ( id_jobentry , " createdestinationfolder " ) ; cachehostkey = rep . getJobEntryAttributeBoolean ( id_jobentry , " cachehostkey " ) ; timeout = ( int ) rep . getJobEntryAttributeInteger ( id_jobentry , " timeout " ) ; } catch ( KettleException dbe ) { throw new KettleException ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . UnableLoadRep " , " " + id_jobentry , dbe . getMessage ( ) ) ) ; } }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void saveRep ( Repository rep , IMetaStore metaStore , ObjectId id_job ) throws KettleException { try { rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " servername " , serverName ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " username " , userName ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " password " , Encr . encryptPasswordIfNotUsingVariables ( password ) ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " serverport " , serverPort ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " ftpdirectory " , ftpDirectory ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " localdirectory " , localDirectory ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " wildcard " , wildcard ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " only _ new " , onlyGettingNewFiles ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " usehttpproxy " , usehttpproxy ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxyhost " , httpproxyhost ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxyport " , httpproxyport ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxyusername " , httpproxyusername ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxypassword " , httpProxyPassword ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " publicpublickey " , publicpublickey ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " keyfilename " , keyFilename ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " keyfilepass " , keyFilePass ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " usebasicauthentication " , useBasicAuthentication ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " createremotefolder " , createRemoteFolder ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " afterftpput " , afterFtpPut ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " destinationfolder " , destinationfolder ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " createdestinationfolder " , createDestinationFolder ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " cachehostkey " , cachehostkey ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " timeout " , timeout ) ; } catch ( KettleDatabaseException dbe ) { throw new KettleException ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . UnableSaveRep " , " " + id_job , dbe . getMessage ( ) ) ) ; } }
AliaksandrShuhayeu/pentaho-kettle | public String getFtpDirectory ( ) { return ftpDirectory ; }
AliaksandrShuhayeu/pentaho-kettle | public void setFtpDirectory ( String directory ) { this . ftpDirectory = directory ; }
AliaksandrShuhayeu/pentaho-kettle | public String getPassword ( ) { return password ; }
AliaksandrShuhayeu/pentaho-kettle | public void setPassword ( String password ) { this . password = password ; }
AliaksandrShuhayeu/pentaho-kettle | public String getAfterFTPPut ( ) { return afterFtpPut ; }
AliaksandrShuhayeu/pentaho-kettle | public void setAfterFTPPut ( String afterFtpPut ) { this . afterFtpPut = afterFtpPut ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyPassword ( String httpProxyPassword ) { this . httpProxyPassword = httpProxyPassword ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyPassword ( ) { return httpProxyPassword ; }
AliaksandrShuhayeu/pentaho-kettle | public void setKeyFilepass ( String keyFilePass ) { this . keyFilePass = keyFilePass ; }
AliaksandrShuhayeu/pentaho-kettle | public String getKeyFilepass ( ) { return keyFilePass ; }
AliaksandrShuhayeu/pentaho-kettle | public String getServerName ( ) { return serverName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setServerName ( String serverName ) { this . serverName = serverName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyHost ( String proxyhost ) { this . httpproxyhost = proxyhost ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyHost ( ) { return httpproxyhost ; }
AliaksandrShuhayeu/pentaho-kettle | public void setKeyFilename ( String keyFilename ) { this . keyFilename = keyFilename ; }
AliaksandrShuhayeu/pentaho-kettle | public String getKeyFilename ( ) { return keyFilename ; }
AliaksandrShuhayeu/pentaho-kettle | public String getUserName ( ) { return userName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUserName ( String userName ) { this . userName = userName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyUsername ( String proxyusername ) { this . httpproxyusername = proxyusername ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyUsername ( ) { return httpproxyusername ; }
AliaksandrShuhayeu/pentaho-kettle | public String getWildcard ( ) { return wildcard ; }
AliaksandrShuhayeu/pentaho-kettle | public void setWildcard ( String wildcard ) { this . wildcard = wildcard ; }
AliaksandrShuhayeu/pentaho-kettle | public String getlocalDirectory ( ) { return localDirectory ; }
AliaksandrShuhayeu/pentaho-kettle | public void setlocalDirectory ( String localDirectory ) { this . localDirectory = localDirectory ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isOnlyGettingNewFiles ( ) { return onlyGettingNewFiles ; }
AliaksandrShuhayeu/pentaho-kettle | public void setOnlyGettingNewFiles ( boolean onlyGettingNewFiles ) { this . onlyGettingNewFiles = onlyGettingNewFiles ; }
AliaksandrShuhayeu/pentaho-kettle | public void setCacheHostKey ( boolean cachehostkeyin ) { this . cachehostkey = cachehostkeyin ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isCacheHostKey ( ) { return cachehostkey ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUseHTTPProxy ( boolean httpproxy ) { this . usehttpproxy = httpproxy ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isUseHTTPProxy ( ) { return usehttpproxy ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isUseBasicAuthentication ( ) { return useBasicAuthentication ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUseBasicAuthentication ( boolean useBasicAuthenticationin ) { this . useBasicAuthentication = useBasicAuthenticationin ; }
AliaksandrShuhayeu/pentaho-kettle | public void setCreateRemoteFolder ( boolean createRemoteFolder ) { this . createRemoteFolder = createRemoteFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isCreateRemoteFolder ( ) { return createRemoteFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public void setCreateDestinationFolder ( boolean createDestinationFolder ) { this . createDestinationFolder = createDestinationFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isCreateDestinationFolder ( ) { return createDestinationFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUsePublicKey ( boolean publickey ) { this . publicpublickey = publickey ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isUsePublicKey ( ) { return publicpublickey ; }
AliaksandrShuhayeu/pentaho-kettle | public String getServerPort ( ) { return serverPort ; }
AliaksandrShuhayeu/pentaho-kettle | public void setServerPort ( String serverPort ) { this . serverPort = serverPort ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyPort ( String proxyport ) { this . httpproxyport = proxyport ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyPort ( ) { return httpproxyport ; }
AliaksandrShuhayeu/pentaho-kettle | public void setDestinationFolder ( String destinationfolderin ) { this . destinationfolder = destinationfolderin ; }
AliaksandrShuhayeu/pentaho-kettle | public String getDestinationFolder ( ) { return destinationfolder ; }
AliaksandrShuhayeu/pentaho-kettle | public void setTimeout ( int timeout ) { this . timeout = timeout ; }
AliaksandrShuhayeu/pentaho-kettle | public int getTimeout ( ) { return timeout ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public Result execute ( Result previousResult , int nr ) { Result result = previousResult ; result . setResult ( false ) ; try { String realServerName = environmentSubstitute ( serverName ) ; int realServerPort = Const . toInt ( environmentSubstitute ( serverPort ) , 22 ) ; String realUserName = environmentSubstitute ( userName ) ; String realServerPassword = Encr . decryptPasswordOptionallyEncrypted ( environmentSubstitute ( password ) ) ; String realProxyHost = environmentSubstitute ( httpproxyhost ) ; int realProxyPort = Const . toInt ( environmentSubstitute ( httpproxyport ) , 22 ) ; String realproxyUserName = environmentSubstitute ( httpproxyusername ) ; String realProxyPassword = Encr . decryptPasswordOptionallyEncrypted ( environmentSubstitute ( httpProxyPassword ) ) ; String realKeyFilename = environmentSubstitute ( keyFilename ) ; String relKeyFilepass = environmentSubstitute ( keyFilePass ) ; String realLocalDirectory = environmentSubstitute ( localDirectory ) ; String realwildcard = environmentSubstitute ( wildcard ) ; String realftpDirectory = environmentSubstitute ( ftpDirectory ) ; String realDestinationFolder = environmentSubstitute ( destinationfolder ) ; try { realftpDirectory = FTPUtils . normalizePath ( realftpDirectory ) ; realDestinationFolder = FTPUtils . normalizePath ( realDestinationFolder ) ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . CanNotNormalizePath " , e . getMessage ( ) ) ) ; result . setNrErrors ( 1 ) ; return result ; } boolean mandatoryok = true ; if ( Utils . isEmpty ( realServerName ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . ServernameMissing " ) ) ; } if ( usehttpproxy ) { if ( Utils . isEmpty ( realProxyHost ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . HttpProxyhostMissing " ) ) ; } } if ( publicpublickey ) { if ( Utils . isEmpty ( realKeyFilename ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . KeyFileMissing " ) ) ; } else { if ( ! KettleVFS . fileExists ( realKeyFilename , this ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . KeyFileNotExist " ) ) ; } } } if ( Utils . isEmpty ( realLocalDirectory ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . LocalFolderMissing " ) ) ; } if ( afterFtpPut . equals ( " move _ file " ) ) { if ( Utils . isEmpty ( realDestinationFolder ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . DestinatFolderMissing " ) ) ; } else { FileObject folder = null ; try { folder = KettleVFS . getFileObject ( realDestinationFolder , this ) ; if ( ! folder . exists ( ) ) { if ( createDestinationFolder ) { folder . createFolder ( ) ; } else { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . DestinatFolderNotExist " , realDestinationFolder ) ) ; } } } catch ( Exception e ) { throw new KettleException ( e ) ; } finally { if ( folder != null ) { try { folder . close ( ) ; folder = null ; } catch ( Exception e ) { } } } } } if ( mandatoryok ) { Connection conn = null ; SFTPv3Client client = null ; boolean good = true ; int nbfilestoput = 0 ; int nbput = 0 ; int nbrerror = 0 ; try { conn = getConnection ( realServerName , realServerPort , realProxyHost , realProxyPort , realproxyUserName , realProxyPassword ) ; if ( timeout > 0 ) { if ( cachehostkey ) { conn . connect ( new SimpleVerifier ( database ) , 0 , timeout * 1000 ) ; } else { conn . connect ( null , 0 , timeout * 1000 ) ; } } else { if ( cachehostkey ) { conn . connect ( new SimpleVerifier ( database ) ) ; } else { conn . connect ( ) ; } } boolean isAuthenticated = false ; if ( publicpublickey ) { String keyContent = KettleVFS . getTextFileContent ( realKeyFilename , this , Const . XML_ENCODING ) ; isAuthenticated = conn . authenticateWithPublicKey ( realUserName , keyContent . toCharArray ( ) , relKeyFilepass ) ; } else { isAuthenticated = conn . authenticateWithPassword ( realUserName , realServerPassword ) ; } if ( isAuthenticated == false ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . AuthenticationFailed " ) ) ; } else { if ( log . isBasic ( ) ) { logBasic ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Connected " , serverName , userName ) ) ; } client = new SFTPv3Client ( conn ) ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . ProtocolVersion " , " " + client . getProtocolVersion ( ) ) ) ; } if ( ! Utils . isEmpty ( realftpDirectory ) ) { if ( ! sshDirectoryExists ( client , realftpDirectory ) ) { good = false ; if ( createRemoteFolder ) { good = CreateRemoteFolder ( client , realftpDirectory ) ; if ( good ) { logBasic ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . RemoteDirectoryCreated " ) ) ; } } else { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . RemoteDirectoryNotExist " , realftpDirectory ) ) ; } } else if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . RemoteDirectoryExist " , realftpDirectory ) ) ; } } if ( good ) { List < FileObject > myFileList = getFiles ( realLocalDirectory ) ; Pattern pattern = null ; if ( ! Utils . isEmpty ( realwildcard ) ) { pattern = Pattern . compile ( realwildcard ) ; } for ( int i = 0 ; i < myFileList . size ( ) && ! parentJob . isStopped ( ) ; i ++ ) { FileObject myFile = myFileList . get ( i ) ; String localFilename = myFile . toString ( ) ; String remoteFilename = myFile . getName ( ) . getBaseName ( ) ; boolean getIt = true ; if ( pattern != null ) { Matcher matcher = pattern . matcher ( remoteFilename ) ; getIt = matcher . matches ( ) ; } if ( ! Utils . isEmpty ( realftpDirectory ) ) { remoteFilename = realftpDirectory + FTPUtils . FILE_SEPARATOR + remoteFilename ; } if ( onlyGettingNewFiles ) { getIt = ! sshFileExists ( client , remoteFilename ) ; } if ( getIt ) { nbfilestoput ++ ; boolean putok = putFile ( myFile , remoteFilename , client ) ; if ( ! putok ) { nbrerror ++ ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . CanNotPutFile " , localFilename ) ) ; } else { nbput ++ ; } if ( putok && ! afterFtpPut . equals ( " do _ nothing " ) ) { deleteOrMoveFiles ( myFile , realDestinationFolder ) ; } } } if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . JobEntryEnd1" ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . TotalFiles " , " " + nbfilestoput ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . TotalFilesPut " , " " + nbput ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . TotalFilesError " , " " + nbrerror ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . JobEntryEnd2" ) ) ; } if ( nbrerror == 0 ) { result . setResult ( true ) ; } } } } catch ( Exception e ) { result . setNrErrors ( nbrerror ) ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . ErrorFTP " , e . getMessage ( ) ) ) ; } finally { if ( conn != null ) { conn . close ( ) ; } if ( client != null ) { client . close ( ) ; } } } } catch ( Exception e ) { result . setResult ( false ) ; result . setNrErrors ( 1L ) ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . UnexpectedError " ) , e ) ; } return result ; }
AliaksandrShuhayeu/pentaho-kettle | private Connection getConnection ( String servername , int serverport , String proxyhost , int proxyport , String proxyusername , String proxypassword ) { Connection connect = new Connection ( servername , serverport ) ; if ( usehttpproxy ) { connect . setProxyData ( new HTTPProxyData ( proxyhost , proxyport ) ) ; if ( useBasicAuthentication ) { connect . setProxyData ( new HTTPProxyData ( proxyhost , proxyport , proxyusername , proxypassword ) ) ; } } return connect ; }
AliaksandrShuhayeu/pentaho-kettle | private boolean putFile ( FileObject localFile , String remotefilename , SFTPv3Client sftpClient ) { long filesize = - 1 ; InputStream in = null ; BufferedInputStream inBuf = null ; SFTPv3FileHandle sftpFileHandle = null ; boolean retval = false ; try { sftpFileHandle = sftpClient . createFileTruncate ( remotefilename ) ; in = KettleVFS . getInputStream ( localFile ) ; inBuf = new BufferedInputStream ( in ) ; byte [ ] buf = new byte [ 2048 ] ; long offset = 0 ; long length = localFile . getContent ( ) . getSize ( ) ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . SendingFile " , localFile . toString ( ) , " " + length , remotefilename ) ) ; } while ( true ) { int len = in . read ( buf , 0 , buf . length ) ; if ( len <= 0 ) { break ; } sftpClient . write ( sftpFileHandle , offset , buf , 0 , len ) ; offset += len ; } filesize = getFileSize ( sftpClient , remotefilename ) ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . FileOnRemoteHost " , remotefilename , " " + filesize ) ) ; } retval = true ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . ErrorCopyingFile " , localFile . toString ( ) ) + " : " + e . getMessage ( ) ) ; } finally { if ( in != null ) { try { in . close ( ) ; in = null ; } catch ( Exception ex ) { } } if ( inBuf != null ) { try { inBuf . close ( ) ; inBuf = null ; } catch ( Exception ex ) { } } if ( sftpFileHandle != null ) { try { sftpClient . closeFile ( sftpFileHandle ) ; sftpFileHandle = null ; } catch ( Exception ex ) { } } } return retval ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean sshFileExists ( SFTPv3Client sftpClient , String filename ) { try { SFTPv3FileAttributes attributes = sftpClient . stat ( filename ) ; if ( attributes != null ) { return ( attributes . isRegularFile ( ) ) ; } else { return false ; } } catch ( Exception e ) { return false ; } }
AliaksandrShuhayeu/pentaho-kettle | public boolean sshDirectoryExists ( SFTPv3Client sftpClient , String directory ) { try { SFTPv3FileAttributes attributes = sftpClient . stat ( directory ) ; if ( attributes != null ) { return ( attributes . isDirectory ( ) ) ; } else { return false ; } } catch ( Exception e ) { return false ; } }
AliaksandrShuhayeu/pentaho-kettle | private boolean CreateRemoteFolder ( SFTPv3Client sftpClient , String foldername ) { boolean retval = false ; if ( ! sshDirectoryExists ( sftpClient , foldername ) ) { try { sftpClient . mkdir ( foldername , 0700 ) ; retval = true ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . CreatingRemoteFolder " , foldername ) , e ) ; } } return retval ; }
AliaksandrShuhayeu/pentaho-kettle | public long getFileSize ( SFTPv3Client sftpClient , String filename ) throws Exception { return sftpClient . stat ( filename ) . size . longValue ( ) ; }
AliaksandrShuhayeu/pentaho-kettle | private List < FileObject > getFiles ( String localfolder ) throws KettleFileException { try { List < FileObject > myFileList = new ArrayList < FileObject > ( ) ; FileObject localFiles = KettleVFS . getFileObject ( localfolder , this ) ; FileObject [ ] children = localFiles . getChildren ( ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; i ++ ) { if ( children [ i ] . getType ( ) . equals ( FileType . FILE ) ) { myFileList . add ( children [ i ] ) ; } } } return myFileList ; } catch ( IOException e ) { throw new KettleFileException ( e ) ; } }
AliaksandrShuhayeu/pentaho-kettle | private boolean deleteOrMoveFiles ( FileObject file , String destinationFolder ) throws KettleException { try { boolean retval = false ; if ( afterFtpPut . equals ( " delete _ file " ) ) { file . delete ( ) ; retval = true ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . DeletedFile " , file . toString ( ) ) ) ; } } else if ( afterFtpPut . equals ( " move _ file " ) ) { FileObject destination = null ; FileObject source = null ; try { destination = KettleVFS . getFileObject ( destinationFolder + Const . FILE_SEPARATOR + file . getName ( ) . getBaseName ( ) , this ) ; file . moveTo ( destination ) ; retval = true ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Cant _ Move _ File . Label " , file . toString ( ) , destinationFolder , e . getMessage ( ) ) ) ; } finally { if ( destination != null ) { try { destination . close ( ) ; } catch ( Exception ex ) { } } if ( source != null ) { try { source . close ( ) ; } catch ( Exception ex ) { } } } if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . MovedFile " , file . toString ( ) , ftpDirectory ) ) ; } } return retval ; } catch ( Exception e ) { throw new KettleException ( e ) ; } }
AliaksandrShuhayeu/pentaho-kettle | @ Override public boolean evaluates ( ) { return true ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public List < ResourceReference > getResourceDependencies ( JobMeta jobMeta ) { List < ResourceReference > references = super . getResourceDependencies ( jobMeta ) ; if ( ! Utils . isEmpty ( serverName ) ) { String realServerName = jobMeta . environmentSubstitute ( serverName ) ; ResourceReference reference = new ResourceReference ( this ) ; reference . getEntries ( ) . add ( new ResourceEntry ( realServerName , ResourceType . SERVER ) ) ; references . add ( reference ) ; } return references ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void check ( List < CheckResultInterface > remarks , JobMeta jobMeta , VariableSpace space , Repository repository , IMetaStore metaStore ) { JobEntryValidatorUtils . andValidator ( ) . validate ( this , " serverName " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notBlankValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " localDirectory " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notBlankValidator ( ) , JobEntryValidatorUtils . fileExistsValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " userName " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notBlankValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " password " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notNullValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " serverPort " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . integerValidator ( ) ) ) ; }
tharikaGitHub/carbon-apimgt | @ Before public void init ( ) { timer = Mockito . mock ( Timer . class ) ; timer = Mockito . mock ( Timer . class ) ; context = Mockito . mock ( Timer . Context . class ) ; throttleEvaluator = Mockito . mock ( ThrottleConditionEvaluator . class ) ; accessInformation = Mockito . mock ( AccessInformation . class ) ; Mockito . when ( timer . start ( ) ) . thenReturn ( context ) ; verbInfoDTO = new ArrayList < > ( ) ; verbInfo = new VerbInfoDTO ( ) ; verbInfo . setHttpVerb ( httpVerb ) ; verbInfo . setRequestKey ( apiContext + " / " + apiVersion + resourceUri + " : " + httpVerb ) ; verbInfo . setThrottling ( throttlingTier ) ; verbInfoDTO . add ( verbInfo ) ; conditionGroupDTO = new ConditionGroupDTO ( ) ; conditionGroupDTO . setConditionGroupId ( " _ default " ) ; conditionGroupDTOs = new ConditionGroupDTO [ 1 ] ; conditionGroupDTOs [ 0 ] = conditionGroupDTO ; apiLevelThrottleKey = apiContext + " : " + apiVersion ; resourceLevelThrottleKey = apiContext + " / " + apiVersion + resourceUri + " : " + httpVerb ; org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder serviceReferenceHolder = Mockito . mock ( org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder . class ) ; PowerMockito . mockStatic ( org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder . class ) ; Mockito . when ( org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder . getInstance ( ) ) . thenReturn ( serviceReferenceHolder ) ; APIManagerConfigurationService apiManagerConfigurationService = Mockito . mock ( APIManagerConfigurationService . class ) ; APIManagerConfiguration apiManagerConfiguration = Mockito . mock ( APIManagerConfiguration . class ) ; Mockito . when ( serviceReferenceHolder . getAPIManagerConfigurationService ( ) ) . thenReturn ( apiManagerConfigurationService ) ; Mockito . when ( apiManagerConfigurationService . getAPIManagerConfiguration ( ) ) . thenReturn ( apiManagerConfiguration ) ; Mockito . when ( apiManagerConfiguration . getExtensionListenerMap ( ) ) . thenReturn ( extensionListenerMap ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testDoNotThrottleWhenMsgIsAResponseAndAuthCtxNotAvailable ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContext ( apiContext , apiVersion ) ; messageContext . setProperty ( RESPONSE , " true " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testSubscriptionLevelThrottlingInitWhenThrottleCtxIsNull ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( RESPONSE , " true " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testSubscriptionLevelThrottlingInitialization ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( RESPONSE , " true " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenBlockingConditionsAreSatisfied ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; throttleDataHolder . addIpBlockingCondition ( " carbon . super " , 1 , " { \" fixedIp \" : \" 127.0.0.1 \" , \" invert \" : false } " , APIConstants . BLOCKING_CONDITIONS_IP ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; throttleDataHolder . removeIpBlockingCondition ( " carbon . super " , 1 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleContinueWhenAPITierIsNotAvailable ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; Assert . assertNull ( ( VerbInfoDTO ) messageContext . getProperty ( VERB_INFO_DTO ) ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgDoContinueWhenAllThrottlingLevelsAreNotThrolled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ServiceReferenceHolder . getInstance ( ) . setThrottleDataPublisher ( new ThrottleDataPublisher ( ) ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgDoThrottleWhenUserLevelThrottlingIsTriggerred ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; verbInfo . setApplicableLevel ( " userLevel " ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenAPILevelIsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String combinedResourceLevelThrottleKey = apiLevelThrottleKey + conditionGroupDTO . getConditionGroupId ( ) ; throttleDataHolder . addThrottledAPIKey ( apiLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; throttleDataHolder . addThrottleData ( combinedResourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Mockito . when ( throttleEvaluator . getApplicableConditions ( messageContext , authenticationContext , conditionGroupDTOs ) ) . thenReturn ( matchingConditions ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenResourceLevelIsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( " Unlimited " ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String combinedResourceLevelThrottleKey = resourceLevelThrottleKey + conditionGroupDTO . getConditionGroupId ( ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; throttleDataHolder . addThrottleData ( combinedResourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Mockito . when ( throttleEvaluator . getApplicableConditions ( messageContext , authenticationContext , conditionGroupDTOs ) ) . thenReturn ( matchingConditions ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenSubscriptionLevelIsThrottledAndStopOnQuotaReachIsEnabled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( true ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String subscriptionLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + apiContext + " : " + apiVersion ; throttleDataHolder . addThrottleData ( subscriptionLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgContinueWhenSubscriptionLevelIsThrottledAndStopOnQuotaReachIsDisabled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( false ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String subscriptionLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + apiContext + " : " + apiVersion ; throttleDataHolder . addThrottleData ( subscriptionLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenApplicationLevelIsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String applicationLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + authenticationContext . getUsername ( ) + " @ " + throttleHandler . getTenantDomain ( ) ; throttleDataHolder . addThrottleData ( applicationLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenProductionHardThrottlingLimitsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( false ) ; authenticationContext . setKeyType ( " PRODUCTION " ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenSandBoxHardThrottlingLimitsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setSandboxMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( false ) ; authenticationContext . setKeyType ( " SANDBOX " ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String subscriptionLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + apiContext + " : " + apiVersion ; String applicationLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + authenticationContext . getUsername ( ) + " @ " + throttleHandler . getTenantDomain ( ) ; String combinedResourceLevelThrottleKey = resourceLevelThrottleKey + conditionGroupDTO . getConditionGroupId ( ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenHardThrottlingFailedWithThrottleException ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setKeyType ( " SANDBOX " ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; Mockito . doThrow ( ThrottleException . class ) . when ( accessInformation ) . isAccessAllowed ( ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenCustomThrottlingLimitExceeded ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; matchingConditions . add ( conditionGroupDTO ) ; throttleDataHolder . addKeyTemplate ( " $ user " , " $ user " ) ; throttleDataHolder . addKeyTemplate ( " testKeyTemplate " , " testKeyTemplateValue " ) ; throttleDataHolder . addThrottleData ( " testKeyTemplate " , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; throttleDataHolder . removeKeyTemplate ( " testKeyTemplate " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenHittingSubscriptionLevelSpike ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setSandboxMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setKeyType ( " SANDBOX " ) ; authenticationContext . setSpikeArrestLimit ( 100 ) ; authenticationContext . setStopOnQuotaReach ( true ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; throttleDataHolder . addKeyTemplate ( " $ user " , " $ user " ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testHandleResponse ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; Assert . assertTrue ( throttleHandler . handleResponse ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testCheckForStaledThrottleData ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ServiceReferenceHolder . getInstance ( ) . setThrottleDataPublisher ( new ThrottleDataPublisher ( ) ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; matchingConditions . add ( conditionGroupDTO ) ; throttleDataHolder . addKeyTemplate ( " testKeyTemplate " , " testKeyTemplateValue " ) ; throttleDataHolder . addThrottleData ( " testKeyTemplate " , System . currentTimeMillis ( ) - 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWithUserBlockingConditions ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; throttleDataHolder . addUserBlockingCondition ( blockedUserWithTenantDomain , blockedUserWithTenantDomain ) ; matchingConditions . add ( conditionGroupDTO ) ; authenticationContext . setApiTier ( " Unlimited " ) ; authenticationContext . setUsername ( blockedUserWithTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; authenticationContext . setUsername ( userWithTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; authenticationContext . setUsername ( blockedUserWithOutTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; throttleDataHolder . removeUserBlockingCondition ( blockedUserWithTenantDomain ) ; authenticationContext . setUsername ( blockedUserWithTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
gokul/siddhi | public OverwriteTableIndexOperatorForCache ( CollectionExecutor collectionExecutor , String queryName , CacheTable cacheTable ) { super ( collectionExecutor , queryName , cacheTable ) ; }
gokul/siddhi | @ Override public ComplexEventChunk < StreamEvent > tryUpdate ( ComplexEventChunk < StateEvent > updatingOrAddingEventChunk , Object storeEvents , InMemoryCompiledUpdateSet compiledUpdateSet , AddingStreamEventExtractor addingStreamEventExtractor ) { updatingOrAddingEventChunk . reset ( ) ; while ( updatingOrAddingEventChunk . hasNext ( ) ) { StateEvent overwritingOrAddingEvent = updatingOrAddingEventChunk . next ( ) ; ( ( IndexedEventHolder ) storeEvents ) . overwrite ( addingStreamEventExtractor . getAddingStreamEvent ( overwritingOrAddingEvent ) ) ; } return null ; }
Squama/Master | @ RequestMapping ( value = " list " , method = RequestMethod . GET ) public String list ( ) { return VIEW_LIST ; }
Squama/Master | @ RequestMapping ( value = " progress " , method = RequestMethod . GET ) public String progress_demo ( ) { return " demos / progress " ; }
Squama/Master | @ RequestMapping ( value = " saveUser " , method = RequestMethod . POST ) @ ResponseBody public User saveUser ( User user ) { return userDemoService . saveUser ( user ) ; }
Squama/Master | @ RequestMapping ( value = " getUser " , method = RequestMethod . POST ) @ ResponseBody public User getUser ( String id ) { return userDemoService . get ( User . class , id ) ; }
sscdotopen/giraph-compensations | catch ( IllegalArgumentException iae ) { assertTrue ( iae . getMessage ( ) . startsWith ( " Line ▁ did ▁ not ▁ split ▁ correctly : ▁ " ) ) ; }
sscdotopen/giraph-compensations | catch ( IllegalArgumentException iae ) { assertTrue ( iae . getMessage ( ) . startsWith ( " Line ▁ did ▁ not ▁ split ▁ correctly : ▁ " ) ) ; }
sscdotopen/giraph-compensations | public void testHappyPath ( ) throws Exception { String input = " Hi\t0\tCiao\t1.123\tBomdia\t2.234\tOla\t3.345" ; when ( rr . getCurrentValue ( ) ) . thenReturn ( new Text ( input ) ) ; TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > vr = new TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > ( rr ) ; vr . initialize ( null , tac ) ; assertTrue ( " Should ▁ have ▁ been ▁ able ▁ to ▁ add ▁ a ▁ vertex " , vr . nextVertex ( ) ) ; BasicVertex < Text , DoubleWritable , DoubleWritable , BooleanWritable > vertex = vr . getCurrentVertex ( ) ; setGraphState ( vertex , graphState ) ; assertValidVertex ( conf , graphState , vertex , new Text ( " Hi " ) , new DoubleWritable ( 0 ) , new Edge < Text , DoubleWritable > ( new Text ( " Ciao " ) , new DoubleWritable ( 1.123d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " Bomdia " ) , new DoubleWritable ( 2.234d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " Ola " ) , new DoubleWritable ( 3.345d ) ) ) ; assertEquals ( vertex . getNumOutEdges ( ) , 3 ) ; }
sscdotopen/giraph-compensations | public void testLineSanitizer ( ) throws Exception { String input = " Bye\t0.01\tCiao\t1.001\tTchau\t2.0001\tAdios\t3.00001" ; AdjacencyListVertexReader . LineSanitizer toUpper = new AdjacencyListVertexReader . LineSanitizer ( ) { @ Override public String sanitize ( String s ) { return s . toUpperCase ( ) ; } } ; when ( rr . getCurrentValue ( ) ) . thenReturn ( new Text ( input ) ) ; TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > vr = new TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > ( rr , toUpper ) ; vr . initialize ( null , tac ) ; assertTrue ( " Should ▁ have ▁ been ▁ able ▁ to ▁ read ▁ vertex " , vr . nextVertex ( ) ) ; BasicVertex < Text , DoubleWritable , DoubleWritable , BooleanWritable > vertex = vr . getCurrentVertex ( ) ; setGraphState ( vertex , graphState ) ; assertValidVertex ( conf , graphState , vertex , new Text ( " BYE " ) , new DoubleWritable ( 0.01d ) , new Edge < Text , DoubleWritable > ( new Text ( " CIAO " ) , new DoubleWritable ( 1.001d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " TCHAU " ) , new DoubleWritable ( 2.0001d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " ADIOS " ) , new DoubleWritable ( 3.00001d ) ) ) ; assertEquals ( vertex . getNumOutEdges ( ) , 3 ) ; }
sscdotopen/giraph-compensations | public void testDifferentSeparators ( ) throws Exception { String input = " alpha : 42 : beta : 99" ; when ( rr . getCurrentValue ( ) ) . thenReturn ( new Text ( input ) ) ; conf . set ( AdjacencyListVertexReader . LINE_TOKENIZE_VALUE , " : " ) ; TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > vr = new TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > ( rr ) ; vr . initialize ( null , tac ) ; assertTrue ( " Should ▁ have ▁ been ▁ able ▁ to ▁ read ▁ vertex " , vr . nextVertex ( ) ) ; BasicVertex < Text , DoubleWritable , DoubleWritable , BooleanWritable > vertex = vr . getCurrentVertex ( ) ; setGraphState ( vertex , graphState ) ; assertValidVertex ( conf , graphState , vertex , new Text ( " alpha " ) , new DoubleWritable ( 42d ) , new Edge < Text , DoubleWritable > ( new Text ( " beta " ) , new DoubleWritable ( 99d ) ) ) ; assertEquals ( vertex . getNumOutEdges ( ) , 1 ) ; }
sscdotopen/giraph-compensations | @ Override public void compute ( Iterator < BooleanWritable > msgIterator ) throws IOException { }
podpage/J-lexa | public Header ( ) { fields = new ArrayList < > ( ) ; }
podpage/J-lexa | public RequestMethod getRequestMethod ( ) { return requestMethod ; }
podpage/J-lexa | public void setRequestMethod ( RequestMethod requestMethod ) { this . requestMethod = requestMethod ; }
podpage/J-lexa | public String getRequestURL ( ) { return requestURL ; }
podpage/J-lexa | public void setRequestURL ( String requestURL ) { this . requestURL = requestURL ; }
podpage/J-lexa | public ArrayList < HeaderField > getHeaderFields ( ) { return fields ; }
podpage/J-lexa | public void setHeaderFields ( ArrayList < HeaderField > fields ) { this . fields = fields ; }
podpage/J-lexa | public void addHeaderField ( HeaderField field ) { this . fields . add ( field ) ; }
podpage/J-lexa | public void removeHeaderField ( HeaderField field ) { this . fields . remove ( field ) ; }
podpage/J-lexa | public HeaderField getHeaderField ( HeaderField headerField ) { for ( HeaderField field : fields ) { if ( field . name ( ) . equals ( headerField . name ( ) ) ) { return field ; } } return null ; }
podpage/J-lexa | public boolean hasHeaderField ( HeaderField headerField ) { for ( HeaderField field : fields ) { if ( field . name ( ) . equals ( headerField . name ( ) ) ) { return true ; } } return false ; }
podpage/J-lexa | public ArrayList < HeaderField > getFields ( ) { return fields ; }
podpage/J-lexa | HeaderField ( String name , HeaderType type ) { this . name = name ; this . type = type ; }
podpage/J-lexa | public HeaderType getType ( ) { return type ; }
podpage/J-lexa | public String getContent ( ) { return content ; }
podpage/J-lexa | public HeaderField setContent ( String content ) { this . content = content ; return this ; }
podpage/J-lexa | public String getName ( ) { return name ; }
podpage/J-lexa | public HeaderField setName ( String name ) { if ( this . equals ( CUSTOM ) ) { this . name = name ; } return this ; }
podpage/J-lexa | @ Override public String toString ( ) { return name + " : ▁ " + content ; }
voyagersearch/Xponents | public RegexPattern ( String _family , String _id , String _description ) { family = _family ; id = _id ; description = _description ; }
voyagersearch/Xponents | public String toString ( ) { return id + " , ▁ Pattern : " + regex . pattern ( ) . toString ( ) ; }
jasonchaffee/apiman | public ApiNotFoundException ( ) { }
jasonchaffee/apiman | public ApiNotFoundException ( String message ) { super ( message ) ; }
jasonchaffee/apiman | @ Override public int getErrorCode ( ) { return ErrorCodes . API_NOT_FOUND ; }
jasonchaffee/apiman | @ Override public String getMoreInfoUrl ( ) { return ErrorCodes . API_NOT_FOUND_INFO ; }
gsteelman/utd | public BucketEliminator ( ) { }
gsteelman/utd | public BucketEliminator ( ArrayList < Function > functions , ArrayList < Variable > variables ) { this . functions = functions ; this . variables = variables ; }
gsteelman/utd | public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; s . append ( this . type + " \n " ) ; s . append ( this . orderHeuristic + " \n " ) ; return s . toString ( ) ; }
gsteelman/utd | public void setOrderHeuristic ( OrderHeuristicType orderHeuristic ) { this . orderHeuristic = orderHeuristic ; }
gsteelman/utd | public LogDouble eliminate ( ) { Stopwatch sw = new Stopwatch ( ) ; sw . start ( ) ; LogDouble probabilityOfEvidence = new LogDouble ( 1.0 ) ; ArrayList < Integer > order = getOrdering ( ) ; if ( order == null ) { return probabilityOfEvidence ; } else if ( order . isEmpty ( ) ) { return probabilityOfEvidence ; } ArrayList < ArrayList < Function > > bucketList = new ArrayList < ArrayList < Function > > ( order . size ( ) ) ; for ( int i = 0 ; i < order . size ( ) ; i ++ ) { bucketList . add ( new ArrayList < Function > ( ) ) ; } bucketList . trimToSize ( ) ; ArrayList < Integer > varInPos = new ArrayList < Integer > ( this . variables . size ( ) ) ; for ( int i = 0 ; i < this . variables . size ( ) ; i ++ ) { varInPos . add ( 0 ) ; } for ( int i = 0 ; i < order . size ( ) ; i ++ ) { varInPos . set ( order . get ( i ) , i ) ; } varInPos . trimToSize ( ) ; for ( Function f : this . functions ) { int pos = this . variables . size ( ) ; boolean allEvid = true ; for ( Variable v : f . variables ) { if ( v . isEvidence ( ) ) { continue ; } if ( varInPos . get ( v . getId ( ) ) < pos ) { pos = varInPos . get ( v . getId ( ) ) ; } allEvid = false ; } if ( allEvid ) { probabilityOfEvidence = probabilityOfEvidence . mul ( f . table . get ( Variable . getAddress ( f . variables ) ) ) ; } else { bucketList . get ( pos ) . add ( f ) ; } } for ( int i = 0 ; i < bucketList . size ( ) ; i ++ ) { if ( bucketList . get ( i ) . isEmpty ( ) ) { continue ; } HashSet < Variable > resultantVariables = new HashSet < Variable > ( ) ; for ( Function f : bucketList . get ( i ) ) { resultantVariables . addAll ( f . variables ) ; } for ( Iterator < Variable > itr = resultantVariables . iterator ( ) ; itr . hasNext ( ) ; ) { Variable v = itr . next ( ) ; if ( v . isEvidence ( ) ) { itr . remove ( ) ; } } resultantVariables . remove ( this . variables . get ( order . get ( i ) ) ) ; ArrayList < Variable > resultVariablesAsArrayList = new ArrayList < Variable > ( resultantVariables ) ; Function result = Function . productSumOut ( resultVariablesAsArrayList , bucketList . get ( i ) , false ) ; if ( result . isTrivial ( ) ) { probabilityOfEvidence = probabilityOfEvidence . mul ( result . table . get ( 0 ) ) ; continue ; } int pos = order . size ( ) ; for ( Variable v : result . variables ) { if ( varInPos . get ( v . getId ( ) ) < pos ) { pos = varInPos . get ( v . getId ( ) ) ; } } if ( pos < bucketList . size ( ) ) { bucketList . get ( pos ) . add ( result ) ; } bucketList . get ( i ) . clear ( ) ; } sw . stop ( ) ; return probabilityOfEvidence ; }
gsteelman/utd | protected String bucketListToString ( ArrayList < ArrayList < Function > > bl , ArrayList < Integer > o ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < bl . size ( ) ; i ++ ) { s . append ( o . get ( i ) ) ; s . append ( Function . functionCollectionToRealString ( bl . get ( i ) ) + " \n " ) ; } return s . toString ( ) ; }
gsteelman/utd | protected ArrayList < Integer > getOrdering ( ) { ArrayList < Integer > ordering = null ; ArrayList < HashSet < Integer > > interactionGraph = computeInteractionGraph ( ) ; if ( this . orderHeuristic == OrderHeuristicType . MIN_DEGREE ) { ordering = computeMinDegreeOrder ( interactionGraph ) ; } else { System . err . println ( " Error : ▁ unknown ▁ ordering ▁ heuristic . " ) ; } return ordering ; }
gsteelman/utd | protected ArrayList < HashSet < Integer > > computeInteractionGraph ( ) { ArrayList < HashSet < Integer > > interactionGraph = new ArrayList < HashSet < Integer > > ( this . variables . size ( ) ) ; for ( int i = 0 ; i < this . variables . size ( ) ; i ++ ) { interactionGraph . add ( new HashSet < Integer > ( ) ) ; } interactionGraph . trimToSize ( ) ; int vID1 = 0 ; int vID2 = 0 ; for ( int i = 0 ; i < this . functions . size ( ) ; i ++ ) { for ( int j = 0 ; j < functions . get ( i ) . variables . size ( ) ; j ++ ) { vID1 = functions . get ( i ) . variables . get ( j ) . getId ( ) ; if ( variables . get ( vID1 ) . isEvidence ( ) ) { continue ; } for ( int k = j + 1 ; k < this . functions . get ( i ) . variables . size ( ) ; k ++ ) { vID2 = functions . get ( i ) . variables . get ( k ) . getId ( ) ; if ( variables . get ( vID2 ) . isEvidence ( ) ) { continue ; } interactionGraph . get ( vID1 ) . add ( vID2 ) ; interactionGraph . get ( vID2 ) . add ( vID1 ) ; } } } return interactionGraph ; }
gsteelman/utd | protected String interactionGraphToString ( ArrayList < HashSet < Integer > > ig ) { StringBuilder s = new StringBuilder ( ) ; for ( HashSet < Integer > i : ig ) { for ( Integer e : i ) { s . append ( e + " ▁ " ) ; } s . append ( " \n " ) ; } return s . toString ( ) ; }
gsteelman/utd | protected ArrayList < Integer > computeMinDegreeOrder ( ArrayList < HashSet < Integer > > interactionGraph ) { ArrayList < HashSet < Integer > > ig = new ArrayList < HashSet < Integer > > ( interactionGraph . size ( ) ) ; for ( HashSet < Integer > c : interactionGraph ) { ig . add ( new HashSet < Integer > ( c ) ) ; } ArrayList < Boolean > processed = new ArrayList < Boolean > ( this . variables . size ( ) ) ; int numNonEvidVars = 0 ; for ( Variable v : this . variables ) { if ( v . isEvidence ( ) ) { processed . add ( true ) ; } else { numNonEvidVars ++ ; processed . add ( false ) ; } } processed . trimToSize ( ) ; ArrayList < Integer > minDegreeOrder = new ArrayList < Integer > ( numNonEvidVars ) ; ArrayList < HashSet < Integer > > clusters = new ArrayList < HashSet < Integer > > ( numNonEvidVars ) ; for ( int i = 0 ; i < numNonEvidVars ; i ++ ) { minDegreeOrder . add ( 0 ) ; clusters . add ( new HashSet < Integer > ( ) ) ; } minDegreeOrder . trimToSize ( ) ; clusters . trimToSize ( ) ; int min = 0 ; int max = 0 ; int var = 0 ; for ( int i = 0 ; i < numNonEvidVars ; i ++ ) { min = this . variables . size ( ) ; for ( int j = 0 ; j < ig . size ( ) ; j ++ ) { if ( processed . get ( j ) ) { continue ; } if ( ig . get ( j ) . size ( ) < min ) { min = ig . get ( j ) . size ( ) ; minDegreeOrder . set ( i , j ) ; } } var = minDegreeOrder . get ( i ) ; processed . set ( var , true ) ; for ( Integer a : ig . get ( var ) ) { for ( Integer b : ig . get ( var ) ) { if ( a == b ) { continue ; } ig . get ( a ) . add ( b ) ; ig . get ( b ) . add ( a ) ; } } clusters . set ( i , ig . get ( var ) ) ; if ( max < clusters . get ( i ) . size ( ) ) { max = clusters . get ( i ) . size ( ) ; } for ( HashSet < Integer > a : ig ) { a . remove ( var ) ; } ig . get ( var ) . clear ( ) ; } return minDegreeOrder ; }
gsteelman/utd | protected String orderingToString ( ArrayList < Integer > o ) { StringBuilder s = new StringBuilder ( ) ; for ( Integer i : o ) { s . append ( i + " \n " ) ; } return s . toString ( ) ; }
Sargul/dbeaver | public VersionUpdateDialog ( Shell parentShell , @ NotNull Version currentVersion , @ NotNull VersionDescriptor newVersion , boolean showConfig ) { super ( parentShell ) ; this . currentVersion = currentVersion ; this . newVersion = newVersion ; this . showConfig = showConfig ; earlyAccessURL = Platform . getProduct ( ) . getProperty ( " earlyAccessURL " ) ; }
Sargul/dbeaver | @ NotNull public VersionDescriptor getNewVersion ( ) { return newVersion ; }
Sargul/dbeaver | public boolean isShowConfig ( ) { return showConfig ; }
Sargul/dbeaver | public Font getBoldFont ( ) { return boldFont ; }
Sargul/dbeaver | @ Override protected boolean isResizable ( ) { return true ; }
Sargul/dbeaver | private boolean isNewVersionAvailable ( ) { return newVersion . getProgramVersion ( ) . compareTo ( currentVersion ) > 0 ; }
Sargul/dbeaver | @ Override protected Control createDialogArea ( Composite parent ) { getShell ( ) . setText ( CoreMessages . dialog_version_update_title ) ; Composite composite = new Composite ( parent , SWT . NONE ) ; composite . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; composite . setLayout ( new GridLayout ( 1 , false ) ) ; Composite propGroup = UIUtils . createControlGroup ( composite , CoreMessages . dialog_version_update_title , 2 , GridData . FILL_BOTH , 0 ) ; createTopArea ( composite ) ; boldFont = UIUtils . makeBoldFont ( composite . getFont ( ) ) ; final Label titleLabel = new Label ( propGroup , SWT . NONE ) ; titleLabel . setText ( NLS . bind ( ! isNewVersionAvailable ( ) ? CoreMessages . dialog_version_update_no_new_version : CoreMessages . dialog_version_update_available_new_version , GeneralUtils . getProductName ( ) ) ) ; GridData gd = new GridData ( GridData . FILL_HORIZONTAL ) ; gd . horizontalSpan = 2 ; titleLabel . setLayoutData ( gd ) ; titleLabel . setFont ( boldFont ) ; UIUtils . createControlLabel ( propGroup , CoreMessages . dialog_version_update_current_version ) ; new Label ( propGroup , SWT . NONE ) . setText ( currentVersion . toString ( ) ) ; UIUtils . createControlLabel ( propGroup , CoreMessages . dialog_version_update_new_version ) ; new Label ( propGroup , SWT . NONE ) . setText ( newVersion . getProgramVersion ( ) . toString ( ) + " ▁ ▁ ▁ ▁ ( " + newVersion . getUpdateTime ( ) + " ) " ) ; if ( isNewVersionAvailable ( ) ) { final Label notesLabel = UIUtils . createControlLabel ( propGroup , CoreMessages . dialog_version_update_notes ) ; gd = new GridData ( GridData . FILL_HORIZONTAL ) ; gd . horizontalSpan = 2 ; notesLabel . setLayoutData ( gd ) ; final Text notesText = new Text ( propGroup , SWT . READ_ONLY | SWT . WRAP | SWT . V_SCROLL ) ; String releaseNotes = CommonUtils . notEmpty ( newVersion . getReleaseNotes ( ) ) ; if ( releaseNotes . isEmpty ( ) ) { releaseNotes = CoreMessages . dialog_version_update_no_notes ; } releaseNotes = formatReleaseNotes ( releaseNotes ) ; notesText . setText ( releaseNotes ) ; gd = new GridData ( GridData . FILL_BOTH ) ; gd . horizontalSpan = 2 ; notesText . setLayoutData ( gd ) ; final Label hintLabel = new Label ( propGroup , SWT . NONE ) ; hintLabel . setText ( NLS . bind ( CoreMessages . dialog_version_update_press_more_info , CoreMessages . dialog_version_update_button_more_info , newVersion . getPlainVersion ( ) ) ) ; gd = new GridData ( GridData . FILL_HORIZONTAL ) ; gd . horizontalSpan = 2 ; hintLabel . setLayoutData ( gd ) ; hintLabel . setFont ( boldFont ) ; } createBottomArea ( composite ) ; return parent ; }
Sargul/dbeaver | protected void createTopArea ( Composite composite ) { }
Sargul/dbeaver | protected void createBottomArea ( Composite composite ) { }
Sargul/dbeaver | @ Override public boolean close ( ) { boldFont . dispose ( ) ; return super . close ( ) ; }
Sargul/dbeaver | @ Override protected void createButtonsForButtonBar ( Composite parent ) { if ( showConfig && isNewVersionAvailable ( ) ) { ( ( GridLayout ) parent . getLayout ( ) ) . numColumns ++ ; dontShowAgainCheck = UIUtils . createCheckbox ( parent , NLS . bind ( CoreMessages . dialog_version_update_ignore_version , newVersion . getPlainVersion ( ) ) , false ) ; } if ( isNewVersionAvailable ( ) ) { createButton ( parent , UPGRADE_ID , CoreMessages . dialog_version_update_button_upgrade , true ) ; } else { if ( ! CommonUtils . isEmpty ( earlyAccessURL ) ) { createButton ( parent , CHECK_EA_ID , CoreMessages . dialog_version_update_button_early_access , false ) ; } } createButton ( parent , INFO_ID , CoreMessages . dialog_version_update_button_more_info , false ) ; createButton ( parent , IDialogConstants . CLOSE_ID , IDialogConstants . CLOSE_LABEL , ! isNewVersionAvailable ( ) ) ; }
Sargul/dbeaver | @ Override protected void buttonPressed ( int buttonId ) { if ( dontShowAgainCheck != null && dontShowAgainCheck . getSelection ( ) ) { CoreApplicationActivator . getDefault ( ) . getPreferenceStore ( ) . setValue ( " suppressUpdateCheck . " + newVersion . getPlainVersion ( ) , true ) ; } if ( buttonId == INFO_ID ) { ShellUtils . launchProgram ( newVersion . getBaseURL ( ) ) ; } else if ( buttonId == UPGRADE_ID ) { final PlatformInstaller installer = getPlatformInstaller ( ) ; if ( installer != null ) { final AbstractJob job = new AbstractJob ( " Downloading ▁ installation ▁ file " ) { @ Override protected IStatus run ( DBRProgressMonitor monitor ) { final ApplicationDescriptor app = ApplicationRegistry . getInstance ( ) . getApplication ( ) ; final Path folder ; final Path file ; try { final String executableName = installer . getExecutableName ( app ) ; final String executableExtension = installer . getExecutableExtension ( ) ; folder = Files . createTempDirectory ( executableName ) ; file = Files . createFile ( folder . resolve ( executableName + ' . ' + executableExtension ) ) ; log . debug ( " Downloading ▁ installation ▁ file ▁ to ▁ " + file ) ; WebUtils . downloadRemoteFile ( monitor , " Obtaining ▁ installer " , getDownloadURL ( app , installer , newVersion ) , file . toFile ( ) , null ) ; } catch ( IOException e ) { return GeneralUtils . makeErrorStatus ( CoreMessages . dialog_version_update_downloader_error_cannot_download , e ) ; } catch ( InterruptedException e ) { log . debug ( " Canceled ▁ by ▁ user " , e ) ; return Status . OK_STATUS ; } if ( UIUtils . confirmAction ( CoreMessages . dialog_version_update_downloader_title , NLS . bind ( CoreMessages . dialog_version_update_downloader_confirm_install , app . getName ( ) ) ) ) { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final IWorkbenchWindow workbenchWindow = UIUtils . getActiveWorkbenchWindow ( ) ; final IWorkbenchListener listener = new IWorkbenchListener ( ) { { workbench . addWorkbenchListener ( this ) ; } @ Override public boolean preShutdown ( IWorkbench workbench , boolean forced ) { return true ; } @ Override public void postShutdown ( IWorkbench workbench ) { try { installer . run ( file , log ) ; } catch ( Exception e ) { log . error ( " Failed ▁ to ▁ run ▁ the ▁ installer ▁ script " , e ) ; } } } ; UIUtils . asyncExec ( ( ) -> { ActionUtils . runCommand ( IWorkbenchCommandConstants . FILE_EXIT , workbenchWindow ) ; if ( ! workbench . isClosing ( ) ) { workbench . removeWorkbenchListener ( listener ) ; ShellUtils . launchProgram ( folder . toString ( ) ) ; } } ) ; } else { ShellUtils . showInSystemExplorer ( file . toAbsolutePath ( ) . toString ( ) ) ; } return Status . OK_STATUS ; } } ; job . setUser ( true ) ; job . schedule ( ) ; } else { ShellUtils . launchProgram ( getDownloadPageURL ( newVersion ) ) ; } } else if ( buttonId == CHECK_EA_ID ) { if ( ! CommonUtils . isEmpty ( earlyAccessURL ) ) { ShellUtils . launchProgram ( earlyAccessURL ) ; } } else if ( buttonId == IDialogConstants . PROCEED_ID ) { final IWorkbenchWindow window = UIUtils . getActiveWorkbenchWindow ( ) ; CheckForUpdateAction . activateStandardHandler ( window ) ; try { ActionUtils . runCommand ( CheckForUpdateAction . P2_UPDATE_COMMAND , PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ) ; } finally { CheckForUpdateAction . deactivateStandardHandler ( window ) ; } } close ( ) ; }
Sargul/dbeaver | @ Nullable private PlatformInstaller getPlatformInstaller ( ) { switch ( Platform . getOS ( ) ) { case Platform . OS_WIN32 : return new WindowsInstaller ( ) ; case Platform . OS_MACOSX : return new MacintoshInstaller ( ) ; default : return null ; } }
Sargul/dbeaver | @ NotNull private String getDownloadURL ( @ NotNull ApplicationDescriptor application , @ NotNull PlatformInstaller installer , @ NotNull VersionDescriptor version ) { final String name = installer . getExecutableName ( application ) ; final String extension = installer . getExecutableExtension ( ) ; return CommonUtils . removeTrailingSlash ( version . getDownloadURL ( ) ) + ' / ' + name + ' . ' + extension ; }
Sargul/dbeaver | @ NotNull private String getDownloadPageURL ( @ NotNull VersionDescriptor version ) { String os = Platform . getOS ( ) ; switch ( os ) { case " win32" : os = " win " ; break ; case " macosx " : os = " mac " ; break ; default : os = " linux " ; break ; } String arch = Platform . getOSArch ( ) ; String dist = null ; if ( os . equals ( " linux " ) ) { try { RuntimeUtils . executeProcess ( " / usr / bin / apt - get " , " - - version " ) ; dist = " deb " ; } catch ( DBException e ) { dist = " rpm " ; } } return CommonUtils . removeTrailingSlash ( version . getBaseURL ( ) ) + " ? start " + " & os = " + os + " & arch = " + arch + ( dist == null ? " " : " & dist = " + dist ) ; }
Sargul/dbeaver | @ Override public void run ( @ NotNull Path executable , @ NotNull Log log ) throws Exception { final String path = executable . toString ( ) ; Runtime . getRuntime ( ) . exec ( new String [ ] { " cmd . exe " , " / C " , " start " , " / W " , path , " & & " , " del " , path , } ) ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableName ( @ NotNull ApplicationDescriptor application ) { return application . getId ( ) + " - latest - x86_64 - setup " ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableExtension ( ) { return " exe " ; }
Sargul/dbeaver | @ Override public void run ( @ NotNull Path executable , @ NotNull Log log ) throws Exception { final String path = CommonUtils . escapeBourneShellString ( executable . toString ( ) ) ; Runtime . getRuntime ( ) . exec ( new String [ ] { " / bin / sh " , " - c " , " open ▁ - F ▁ - W ▁ " + path + " ▁ & & ▁ rm ▁ " + path } ) ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableName ( @ NotNull ApplicationDescriptor application ) { return application . getId ( ) + " - latest - macos " ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableExtension ( ) { return " dmg " ; }
dagnir/aws-sdk-java | public DeleteFlowLogsResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { DeleteFlowLogsResult deleteFlowLogsResult = new DeleteFlowLogsResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return deleteFlowLogsResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( " unsuccessful " , targetDepth ) ) { deleteFlowLogsResult . withUnsuccessful ( new ArrayList < UnsuccessfulItem > ( ) ) ; continue ; } if ( context . testExpression ( " unsuccessful / item " , targetDepth ) ) { deleteFlowLogsResult . withUnsuccessful ( UnsuccessfulItemStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return deleteFlowLogsResult ; } } } }
eFaps/eFaps-WebApp | public UploadField ( final String _wicketId , final IModel < AbstractUIField > _model , final boolean _multiple ) { super ( _wicketId , _model ) ; final Form < Void > form = new Form < > ( " form " ) ; add ( form ) ; final FileUploadField upload = new FileUploadField ( " upload " ) { private static final long serialVersionUID = 1L ; @ Override public String getInputName ( ) { return getFieldConfig ( ) . getName ( ) ; } @ Override protected void onComponentTag ( final ComponentTag _tag ) { super . onComponentTag ( _tag ) ; if ( _multiple ) { _tag . put ( " multiple " , " multiple " ) ; } } } ; form . add ( upload ) ; form . add ( new UploadProgressBar ( " progress " , form , upload ) ) ; this . fieldConfig = _model . getObject ( ) . getFieldConfiguration ( ) ; }
eFaps/eFaps-WebApp | @ Override public FieldConfiguration getFieldConfig ( ) { return this . fieldConfig ; }
eFaps/eFaps-WebApp | @ Override public IModel < String > getLabel ( ) { return Model . < String > of ( this . fieldConfig . getLabel ( ) ) ; }
inbloom/secure-data-service | public String [ ] getNameSpace ( ) { String [ ] copy = new String [ nameSpace . length ] ; System . arraycopy ( nameSpace , 0 , copy , 0 , nameSpace . length ) ; return copy ; }
inbloom/secure-data-service | public void setNameSpace ( String [ ] nameSpace ) { String [ ] copy = new String [ nameSpace . length ] ; System . arraycopy ( nameSpace , 0 , copy , 0 , nameSpace . length ) ; this . nameSpace = copy ; }
inbloom/secure-data-service | public List < ResourceEndPointTemplate > getResources ( ) { return resources ; }
inbloom/secure-data-service | public void setResources ( List < ResourceEndPointTemplate > resources ) { this . resources = resources ; }
GlenRSmith/elasticsearch | @ Override public double value ( ) { return getValue ( ) ; }
GlenRSmith/elasticsearch | @ Override public long getValue ( ) { return valueCount ; }
GlenRSmith/elasticsearch | @ Override public String getValueAsString ( ) { return Double . toString ( valueCount ) ; }
GlenRSmith/elasticsearch | @ Override public String getType ( ) { return ValueCountAggregationBuilder . NAME ; }
GlenRSmith/elasticsearch | @ Override protected XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { builder . field ( CommonFields . VALUE . getPreferredName ( ) , valueCount ) ; return builder ; }
haikuowuya/android_system_code | private HTTP ( ) { }
Geomatys/sis | SystemUnit ( final Class < Q > quantity , final UnitDimension dimension , final String symbol , final byte scope , final short epsg , final ScalarFactory < Q > factory ) { super ( symbol , scope , epsg ) ; this . quantity = quantity ; this . dimension = dimension ; this . factory = factory ; }
Geomatys/sis | ) private SystemUnit < ? > create ( final UnitDimension dim ) { if ( dim == dimension ) { return this ; } SystemUnit < ? > result = Units . get ( dim ) ; if ( result == null ) { result = new SystemUnit ( null , dim , null , ( byte ) 0 , ( short ) 0 , null ) ; } return result ; }
Geomatys/sis | @ Override public Dimension getDimension ( ) { return dimension ; }
Geomatys/sis | @ Override public SystemUnit < Q > getSystemUnit ( ) { return this ; }
Geomatys/sis | @ Override public Map < SystemUnit < ? > , Integer > getBaseUnits ( ) { final Map < UnitDimension , Integer > dim = dimension . getBaseDimensions ( ) ; if ( dim == null ) { return null ; } return ObjectConverters . derivedKeys ( dim , DimToUnit . INSTANCE , Integer . class ) ; }
Geomatys/sis | @ Override final Map < SystemUnit < ? > , Fraction > getBaseSystemUnits ( ) { return ObjectConverters . derivedKeys ( dimension . components , DimToUnit . INSTANCE , Fraction . class ) ; }
Geomatys/sis | private DimToUnit ( ) { }
Geomatys/sis | @ Override public Class < UnitDimension > getSourceClass ( ) { return UnitDimension . class ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public Class < SystemUnit < ? > > getTargetClass ( ) { return ( Class ) SystemUnit . class ; }
Geomatys/sis | @ Override public SystemUnit < ? > apply ( final UnitDimension dim ) { return Units . get ( dim ) ; }
Geomatys/sis | Object readResolve ( ) throws ObjectStreamException { return INSTANCE ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public < T extends Quantity < T > > Unit < T > asType ( final Class < T > type ) throws ClassCastException { ArgumentChecks . ensureNonNull ( " type " , type ) ; if ( type == quantity ) { if ( getSymbol ( ) == null ) { final SystemUnit < T > unit = Units . get ( type ) ; if ( unit != null ) { return unit ; } } return ( Unit < T > ) this ; } SystemUnit < T > unit = Units . get ( type ) ; if ( unit == null ) { unit = new SystemUnit < > ( type , dimension , null , ( byte ) 0 , ( short ) 0 , null ) ; } if ( ! dimension . equals ( unit . dimension ) ) { throw new ClassCastException ( Errors . format ( Errors . Keys . IncompatibleUnitDimension_5 , new Object [ ] { this , ( quantity != null ) ? quantity . getSimpleName ( ) : " ? " , dimension , type . getSimpleName ( ) , unit . dimension } ) ) ; } return unit ; }
Geomatys/sis | final boolean equalsIgnoreMetadata ( final Unit < Q > other ) { if ( quantity != null && other instanceof SystemUnit < ? > ) { final Class < ? > c = ( ( SystemUnit < Q > ) other ) . quantity ; if ( c != null ) { return ( quantity == c ) ; } } assert other == other . getSystemUnit ( ) : other ; return dimension . equals ( other . getDimension ( ) ) ; }
Geomatys/sis | @ Override public UnitConverter getConverterTo ( final Unit < Q > that ) throws UnconvertibleException { ArgumentChecks . ensureNonNull ( " that " , that ) ; final Unit < Q > step = that . getSystemUnit ( ) ; if ( step != this && ! equalsIgnoreMetadata ( step ) ) { throw new UnconvertibleException ( incompatible ( that ) ) ; } if ( step == that ) { return LinearConverter . IDENTITY ; } return that . getConverterTo ( step ) . inverse ( ) ; }
Geomatys/sis | @ Override public UnitConverter getConverterToAny ( final Unit < ? > that ) throws IncommensurableException { ArgumentChecks . ensureNonNull ( " that " , that ) ; final Unit < ? > step = that . getSystemUnit ( ) ; if ( step != this && ! isCompatible ( step ) ) { throw new IncommensurableException ( incompatible ( that ) ) ; } if ( step == that ) { return LinearConverter . IDENTITY ; } return that . getConverterToAny ( step ) . inverse ( ) ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public Unit < Q > alternate ( final String symbol ) { ArgumentChecks . ensureNonEmpty ( " symbol " , symbol ) ; for ( int i = 0 ; i < symbol . length ( ) ; ) { final int c = symbol . codePointAt ( i ) ; if ( ! isSymbolChar ( c ) ) { throw new IllegalArgumentException ( Errors . format ( Errors . Keys . IllegalCharacter_2 , " symbol " , String . valueOf ( Character . toChars ( c ) ) ) ) ; } i += Character . charCount ( c ) ; } if ( symbol . equals ( getSymbol ( ) ) ) { return this ; } final SystemUnit < Q > alt = new SystemUnit < > ( quantity , dimension , symbol , ( byte ) 0 , ( short ) 0 , factory ) ; if ( quantity != null ) { final Object existing = UnitRegistry . putIfAbsent ( symbol , alt ) ; if ( existing != null ) { if ( existing instanceof SystemUnit < ? > ) { final SystemUnit < ? > unit = ( SystemUnit < ? > ) existing ; if ( quantity . equals ( unit . quantity ) && dimension . equals ( unit . dimension ) ) { return ( SystemUnit < Q > ) unit ; } } throw new IllegalArgumentException ( Errors . format ( Errors . Keys . ElementAlreadyPresent_1 , symbol ) ) ; } UnitRegistry . putIfAbsent ( quantity , alt ) ; } return alt ; }
Geomatys/sis | @ Override public Unit < ? > multiply ( final Unit < ? > multiplier ) { ArgumentChecks . ensureNonNull ( " multiplier " , multiplier ) ; return combine ( multiplier , false ) ; }
Geomatys/sis | @ Override public Unit < ? > divide ( final Unit < ? > divisor ) { ArgumentChecks . ensureNonNull ( " divisor " , divisor ) ; return combine ( divisor , true ) ; }
Geomatys/sis | private < T extends Quantity < T > > Unit < ? > combine ( final Unit < T > other , final boolean divide ) { final Unit < T > step = other . getSystemUnit ( ) ; final Dimension dim = step . getDimension ( ) ; Unit < ? > result = create ( divide ? dimension . divide ( dim ) : dimension . multiply ( dim ) ) ; if ( step != other ) { UnitConverter c = other . getConverterTo ( step ) ; if ( ! c . isLinear ( ) ) { throw new IllegalArgumentException ( Errors . format ( Errors . Keys . NonRatioUnit_1 , other ) ) ; } if ( divide ) c = c . inverse ( ) ; result = result . transform ( c ) ; } return result ; }
Geomatys/sis | @ Override public Unit < ? > pow ( final int n ) { return create ( dimension . pow ( n ) ) ; }
Geomatys/sis | @ Override public Unit < ? > root ( final int n ) { return create ( dimension . root ( n ) ) ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public Unit < Q > transform ( UnitConverter operation ) { ArgumentChecks . ensureNonNull ( " operation " , operation ) ; AbstractUnit < Q > base = this ; if ( this == Units . KILOGRAM ) { base = ( AbstractUnit < Q > ) Units . GRAM ; operation = operation . concatenate ( LinearConverter . forPrefix ( ' k ' ) ) ; } return ConventionalUnit . create ( base , operation ) ; }
Geomatys/sis | ) final void related ( final int n ) { if ( related != null ) { throw new IllegalStateException ( ) ; } related = new ConventionalUnit [ n ] ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " ReturnOfCollectionOrArrayField " ) final ConventionalUnit < Q > [ ] related ( ) { return related ; }
Geomatys/sis | @ Override public boolean equals ( final Object other , final ComparisonMode mode ) { if ( other == this ) { return true ; } if ( super . equals ( other , mode ) ) { final SystemUnit < ? > that = ( SystemUnit < ? > ) other ; return Objects . equals ( quantity , that . quantity ) && dimension . equals ( that . dimension ) ; } return false ; }
Geomatys/sis | @ Override public int hashCode ( ) { return super . hashCode ( ) + 37 * dimension . hashCode ( ) ; }
Geomatys/sis | @ Override public Quantity < Q > create ( final Number value , final Unit < Q > unit ) { final double v = AbstractConverter . doubleValue ( value ) ; if ( factory != null ) { return factory . create ( v , unit ) ; } else { return ScalarFallback . factory ( v , unit , quantity ) ; } }
lmjacksoniii/hazelcast | protected HazelcastInstanceProxy ( HazelcastInstanceImpl original ) { this . original = original ; name = original . getName ( ) ; }
lmjacksoniii/hazelcast | @ Override public String getName ( ) { return name ; }
lmjacksoniii/hazelcast | @ Override public < K , V > IMap < K , V > getMap ( String name ) { return getOriginal ( ) . getMap ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > IQueue < E > getQueue ( String name ) { return getOriginal ( ) . getQueue ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > ITopic < E > getTopic ( String name ) { return getOriginal ( ) . getTopic ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > ITopic < E > getReliableTopic ( String name ) { return getOriginal ( ) . getReliableTopic ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > ISet < E > getSet ( String name ) { return getOriginal ( ) . getSet ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > IList < E > getList ( String name ) { return getOriginal ( ) . getList ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < K , V > MultiMap < K , V > getMultiMap ( String name ) { return getOriginal ( ) . getMultiMap ( name ) ; }
lmjacksoniii/hazelcast | @ Override public JobTracker getJobTracker ( String name ) { return getOriginal ( ) . getJobTracker ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > Ringbuffer < E > getRingbuffer ( String name ) { return getOriginal ( ) . getRingbuffer ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ILock getLock ( String key ) { return getOriginal ( ) . getLock ( key ) ; }
lmjacksoniii/hazelcast | @ Override public IExecutorService getExecutorService ( String name ) { return getOriginal ( ) . getExecutorService ( name ) ; }
lmjacksoniii/hazelcast | @ Override public DurableExecutorService getDurableExecutorService ( String name ) { return getOriginal ( ) . getDurableExecutorService ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < T > T executeTransaction ( TransactionalTask < T > task ) throws TransactionException { return getOriginal ( ) . executeTransaction ( task ) ; }
lmjacksoniii/hazelcast | @ Override public < T > T executeTransaction ( TransactionOptions options , TransactionalTask < T > task ) throws TransactionException { return getOriginal ( ) . executeTransaction ( options , task ) ; }
lmjacksoniii/hazelcast | @ Override public TransactionContext newTransactionContext ( ) { return getOriginal ( ) . newTransactionContext ( ) ; }
lmjacksoniii/hazelcast | @ Override public TransactionContext newTransactionContext ( TransactionOptions options ) { return getOriginal ( ) . newTransactionContext ( options ) ; }
lmjacksoniii/hazelcast | @ Override public IdGenerator getIdGenerator ( String name ) { return getOriginal ( ) . getIdGenerator ( name ) ; }
lmjacksoniii/hazelcast | @ Override public IAtomicLong getAtomicLong ( String name ) { return getOriginal ( ) . getAtomicLong ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < K , V > ReplicatedMap < K , V > getReplicatedMap ( String name ) { return getOriginal ( ) . getReplicatedMap ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > IAtomicReference < E > getAtomicReference ( String name ) { return getOriginal ( ) . getAtomicReference ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ICountDownLatch getCountDownLatch ( String name ) { return getOriginal ( ) . getCountDownLatch ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ISemaphore getSemaphore ( String name ) { return getOriginal ( ) . getSemaphore ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ICacheManager getCacheManager ( ) { return getOriginal ( ) . getCacheManager ( ) ; }
lmjacksoniii/hazelcast | @ Override public Cluster getCluster ( ) { return getOriginal ( ) . getCluster ( ) ; }
lmjacksoniii/hazelcast | @ Override public Member getLocalEndpoint ( ) { return getOriginal ( ) . getLocalEndpoint ( ) ; }
lmjacksoniii/hazelcast | @ Override public Collection < DistributedObject > getDistributedObjects ( ) { return getOriginal ( ) . getDistributedObjects ( ) ; }
lmjacksoniii/hazelcast | @ Override public Config getConfig ( ) { return getOriginal ( ) . getConfig ( ) ; }
lmjacksoniii/hazelcast | @ Override public PartitionService getPartitionService ( ) { return getOriginal ( ) . getPartitionService ( ) ; }
lmjacksoniii/hazelcast | @ Override public QuorumService getQuorumService ( ) { return getOriginal ( ) . getQuorumService ( ) ; }
lmjacksoniii/hazelcast | @ Override public ClientService getClientService ( ) { return getOriginal ( ) . getClientService ( ) ; }
lmjacksoniii/hazelcast | @ Override public LoggingService getLoggingService ( ) { return getOriginal ( ) . getLoggingService ( ) ; }
lmjacksoniii/hazelcast | @ Override public LifecycleService getLifecycleService ( ) { final HazelcastInstanceImpl hz = original ; return hz != null ? hz . getLifecycleService ( ) : new TerminatedLifecycleService ( ) ; }
lmjacksoniii/hazelcast | @ Override public < T extends DistributedObject > T getDistributedObject ( String serviceName , String name ) { return getOriginal ( ) . getDistributedObject ( serviceName , name ) ; }
lmjacksoniii/hazelcast | @ Override public String addDistributedObjectListener ( DistributedObjectListener distributedObjectListener ) { return getOriginal ( ) . addDistributedObjectListener ( distributedObjectListener ) ; }
lmjacksoniii/hazelcast | @ Override public boolean removeDistributedObjectListener ( String registrationId ) { return getOriginal ( ) . removeDistributedObjectListener ( registrationId ) ; }
lmjacksoniii/hazelcast | @ Override public ConcurrentMap < String , Object > getUserContext ( ) { return getOriginal ( ) . getUserContext ( ) ; }
lmjacksoniii/hazelcast | @ Override public HazelcastXAResource getXAResource ( ) { return getOriginal ( ) . getXAResource ( ) ; }
lmjacksoniii/hazelcast | @ Override public CardinalityEstimator getCardinalityEstimator ( String name ) { return getOriginal ( ) . getCardinalityEstimator ( name ) ; }
lmjacksoniii/hazelcast | @ Override public IScheduledExecutorService getScheduledExecutorService ( String name ) { return getOriginal ( ) . getScheduledExecutorService ( name ) ; }
lmjacksoniii/hazelcast | @ Override public void shutdown ( ) { getLifecycleService ( ) . shutdown ( ) ; }
lmjacksoniii/hazelcast | @ Override public InternalSerializationService getSerializationService ( ) { return getOriginal ( ) . getSerializationService ( ) ; }
lmjacksoniii/hazelcast | public HazelcastInstanceImpl getOriginal ( ) { final HazelcastInstanceImpl hazelcastInstance = original ; if ( hazelcastInstance == null ) { throw new HazelcastInstanceNotActiveException ( ) ; } return hazelcastInstance ; }
lmjacksoniii/hazelcast | @ Override public String toString ( ) { final HazelcastInstanceImpl hazelcastInstance = original ; if ( hazelcastInstance != null ) { return hazelcastInstance . toString ( ) ; } return " HazelcastInstance ▁ { NOT ▁ ACTIVE } " ; }
lmjacksoniii/hazelcast | @ Override public int hashCode ( ) { return name != null ? name . hashCode ( ) : 0 ; }
lmjacksoniii/hazelcast | @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || ! ( o instanceof HazelcastInstance ) ) { return false ; } HazelcastInstance that = ( HazelcastInstance ) o ; return ! ( name != null ? ! name . equals ( that . getName ( ) ) : that . getName ( ) != null ) ; }
dydeve/web | private InternMapStorage ( Map < K , V > storage , InternStorage . ValueConstructor < K , V > valueConstructor ) { this . storage = storage ; this . valueConstructor = valueConstructor ; }
dydeve/web | @ Override public V interned ( K key ) { V existingKey = storage . get ( key ) ; V newKey = null ; if ( existingKey == null ) { newKey = valueConstructor . create ( key ) ; existingKey = storage . putIfAbsent ( key , newKey ) ; } return existingKey != null ? existingKey : newKey ; }
dydeve/web | @ Override public int size ( ) { return storage . size ( ) ; }
DragonSphereZ/DragonSphereZ | public SimpleAura ( String idName , String particle , DynamicLocation center , List < Player > players ) { super ( idName , particle , center , players ) ; pulseTick = 2 ; }
DragonSphereZ/DragonSphereZ | @ Override public void onRun ( ) { center . update ( ) ; x = random . nextDouble ( ) ; y = random . nextDouble ( ) ; z = random . nextDouble ( ) ; x = x * 4 - 2 ; y = y * 3 ; z = z * 4 - 2 ; Vector3d vector = new Vector3d ( x , y , z ) ; display ( vector ) ; }
leeyikjiun/scf4j | public TroveIntFloatMapAdapter ( TIntFloatMap map ) { this . map = map ; }
leeyikjiun/scf4j | public void clear ( ) { map . clear ( ) ; }
leeyikjiun/scf4j | public boolean containsKey ( int key ) { return map . containsKey ( key ) ; }
leeyikjiun/scf4j | public boolean containsValue ( float value ) { return map . containsValue ( value ) ; }
leeyikjiun/scf4j | public float get ( int key ) { return map . get ( key ) ; }
leeyikjiun/scf4j | public boolean isEmpty ( ) { return map . isEmpty ( ) ; }
leeyikjiun/scf4j | public float put ( int key , float value ) { return map . put ( key , value ) ; }
leeyikjiun/scf4j | public float remove ( int key ) { return map . remove ( key ) ; }
leeyikjiun/scf4j | public int size ( ) { return map . size ( ) ; }
peterarsentev/junior | @ Test public void whenZeroAndTenThenTen ( ) { Point first = new Point ( 0 , 0 ) ; Point second = new Point ( 0 , 10 ) ; double result = first . distance ( second ) ; first . info ( ) ; second . info ( ) ; System . out . println ( String . format ( " Result ▁ is ▁ % s " , result ) ) ; assertThat ( result , is ( 10D ) ) ; }
peterarsentev/junior | @ Test public void whenCheckItself ( ) { Point point = new Point ( 0 , 0 ) ; double result = point . distance ( point ) ; assertThat ( result , is ( 0D ) ) ; }
peterarsentev/junior | @ Test public void whenShowInfo ( ) { Point first = new Point ( 1 , 1 ) ; first . info ( ) ; Point second = new Point ( 2 , 2 ) ; second . info ( ) ; }
bbottema/java-reflection | @ Override public DataSource apply ( File file ) { return new FileDataSource ( file ) ; }
bbottema/java-reflection | @ Override public byte [ ] apply ( File file ) { try { return Files . readAllBytes ( file . toPath ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( " Was ▁ unable ▁ to ▁ read ▁ file ▁ content " , e ) ; } }
bbottema/java-reflection | @ Override public InputStream apply ( File file ) { try { return new FileInputStream ( file ) ; } catch ( FileNotFoundException e ) { throw new AssertionError ( " File ▁ found , ▁ but ▁ also ▁ not ▁ found ? ▁ Is ▁ this ▁ the ▁ real ▁ life . . . " , e ) ; } }
blinkfox/zealot | @ Test ( expected = FieldEmptyException . class ) public void testFieldEmptyException ( ) { throw new FieldEmptyException ( " xml标签属性字段未找到的异常 " ) ; }
ngbalk/SLOGO | public PowNode ( ) { super ( ) ; myType = " Pow " ; }
ngbalk/SLOGO | @ Override public List < AbstractAction > evaluate ( ) { myValue = Math . pow ( myChildren . get ( 0 ) . evaluate ( ) . get ( 0 ) . getValue ( ) , myChildren . get ( 1 ) . evaluate ( ) . get ( 0 ) . getValue ( ) ) ; myActions . add ( new ConstantAction ( myValue ) ) ; return myActions ; }
jhftrifork/elasticsearch | public ClusterState ( @ NotNull SerializableState zooKeeperStateDriver , @ NotNull FrameworkState frameworkState , @ NotNull TaskInfoFactory taskInfoFactory ) { if ( zooKeeperStateDriver == null || frameworkState == null ) { throw new NullPointerException ( ) ; } this . zooKeeperStateDriver = zooKeeperStateDriver ; this . frameworkState = frameworkState ; this . taskInfoFactory = taskInfoFactory ; frameworkState . onStatusUpdate ( this :: updateTask ) ; }
jhftrifork/elasticsearch | public List < TaskInfo > getTaskList ( ) { List < TaskInfo > taskInfoList = null ; try { taskInfoList = zooKeeperStateDriver . get ( getKey ( ) ) ; } catch ( IOException e ) { LOGGER . info ( " Unable ▁ to ▁ get ▁ key ▁ for ▁ cluster ▁ state ▁ due ▁ to ▁ invalid ▁ frameworkID . " , e ) ; } return taskInfoList == null ? new ArrayList < > ( 0 ) : taskInfoList ; }
jhftrifork/elasticsearch | public Map < String , Task > getGuiTaskList ( ) { Map < String , Task > tasks = new HashMap < > ( ) ; getTaskList ( ) . forEach ( taskInfo -> tasks . put ( taskInfo . getTaskId ( ) . getValue ( ) , taskInfoFactory . parse ( taskInfo , getStatus ( taskInfo . getTaskId ( ) ) . getStatus ( ) ) ) ) ; return tasks ; }
jhftrifork/elasticsearch | public ESTaskStatus getStatus ( TaskID taskID ) throws IllegalArgumentException { return getStatus ( getTask ( taskID ) ) ; }
jhftrifork/elasticsearch | private ESTaskStatus getStatus ( TaskInfo taskInfo ) { return new ESTaskStatus ( zooKeeperStateDriver , frameworkState . getFrameworkID ( ) , taskInfo , new StatePath ( zooKeeperStateDriver ) ) ; }
jhftrifork/elasticsearch | public void addTask ( ESTaskStatus esTask ) { addTask ( esTask . getTaskInfo ( ) ) ; }
jhftrifork/elasticsearch | public void addTask ( TaskInfo taskInfo ) { LOGGER . debug ( " Adding ▁ TaskInfo ▁ to ▁ cluster ▁ for ▁ task : ▁ " + taskInfo . getTaskId ( ) . getValue ( ) ) ; if ( exists ( taskInfo . getTaskId ( ) ) ) { removeTask ( taskInfo ) ; } List < TaskInfo > taskList = getTaskList ( ) ; taskList . add ( taskInfo ) ; setTaskInfoList ( taskList ) ; }
jhftrifork/elasticsearch | public void removeTask ( TaskInfo taskInfo ) throws InvalidParameterException { List < TaskInfo > taskList = getTaskList ( ) ; LOGGER . debug ( " Removing ▁ TaskInfo ▁ from ▁ cluster ▁ for ▁ task : ▁ " + taskInfo . getTaskId ( ) . getValue ( ) ) ; if ( ! taskList . remove ( taskInfo ) ) { throw new InvalidParameterException ( " TaskInfo ▁ does ▁ not ▁ exist ▁ in ▁ list : ▁ " + taskInfo . getTaskId ( ) . getValue ( ) ) ; } getStatus ( taskInfo ) . destroy ( ) ; setTaskInfoList ( taskList ) ; }
jhftrifork/elasticsearch | public Boolean exists ( TaskID taskId ) { try { getTask ( taskId ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
jhftrifork/elasticsearch | public TaskInfo getTask ( TaskID taskID ) throws IllegalArgumentException { List < TaskInfo > taskInfoList = getTaskList ( ) ; TaskInfo taskInfo = null ; for ( TaskInfo info : taskInfoList ) { if ( info . getTaskId ( ) . getValue ( ) . equals ( taskID . getValue ( ) ) ) { taskInfo = info ; break ; } } if ( taskInfo == null ) { throw new IllegalArgumentException ( " Could ▁ not ▁ find ▁ executor ▁ with ▁ that ▁ task ▁ ID : ▁ " + taskID . getValue ( ) ) ; } return taskInfo ; }
jhftrifork/elasticsearch | public TaskInfo getTask ( Protos . ExecutorID executorID ) throws IllegalArgumentException { if ( executorID . getValue ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( " ExecutorID . value ( ) ▁ is ▁ blank . ▁ Cannot ▁ be ▁ blank . " ) ; } List < TaskInfo > taskInfoList = getTaskList ( ) ; TaskInfo taskInfo = null ; for ( TaskInfo info : taskInfoList ) { if ( info . getExecutor ( ) . getExecutorId ( ) . getValue ( ) . equals ( executorID . getValue ( ) ) ) { taskInfo = info ; break ; } } if ( taskInfo == null ) { throw new IllegalArgumentException ( " Could ▁ not ▁ find ▁ executor ▁ with ▁ that ▁ executor ▁ ID : ▁ " + executorID . getValue ( ) ) ; } return taskInfo ; }
jhftrifork/elasticsearch | public void update ( Protos . TaskStatus status ) throws IllegalArgumentException { if ( ! exists ( status . getTaskId ( ) ) ) { throw new IllegalArgumentException ( " Task ▁ does ▁ not ▁ exist ▁ in ▁ zk . " ) ; } getStatus ( status . getTaskId ( ) ) . setStatus ( status ) ; }
jhftrifork/elasticsearch | public boolean taskInError ( Protos . TaskStatus status ) { return getStatus ( status . getTaskId ( ) ) . taskInError ( ) ; }
jhftrifork/elasticsearch | private void updateTask ( Protos . TaskStatus status ) { if ( ! exists ( status . getTaskId ( ) ) ) { LOGGER . warn ( " Could ▁ not ▁ find ▁ task ▁ in ▁ cluster ▁ state . " ) ; return ; } try { Protos . TaskInfo taskInfo = getTask ( status . getTaskId ( ) ) ; LOGGER . debug ( " Updating ▁ task ▁ status ▁ for ▁ executor : ▁ " + status . getExecutorId ( ) . getValue ( ) + " ▁ [ " + status . getTaskId ( ) . getValue ( ) + " , ▁ " + status . getTimestamp ( ) + " , ▁ " + status . getState ( ) + " ] " ) ; update ( status ) ; if ( taskInError ( status ) ) { LOGGER . error ( " Task ▁ in ▁ error ▁ state . ▁ Removing ▁ state ▁ for ▁ executor : ▁ " + status . getExecutorId ( ) . getValue ( ) + " , ▁ due ▁ to : ▁ " + status . getState ( ) ) ; removeTask ( taskInfo ) ; } } catch ( IllegalStateException | IllegalArgumentException e ) { LOGGER . error ( " Unable ▁ to ▁ write ▁ executor ▁ state ▁ to ▁ zookeeper " , e ) ; } }
jhftrifork/elasticsearch | private String logTaskList ( List < TaskInfo > taskInfoList ) { List < String > res = new ArrayList < > ( ) ; for ( TaskInfo t : taskInfoList ) { res . add ( t . getTaskId ( ) . getValue ( ) ) ; } return Arrays . toString ( res . toArray ( ) ) ; }
jhftrifork/elasticsearch | private void setTaskInfoList ( List < TaskInfo > taskInfoList ) { LOGGER . debug ( " Writing ▁ executor ▁ state ▁ list : ▁ " + logTaskList ( taskInfoList ) ) ; try { new StatePath ( zooKeeperStateDriver ) . mkdir ( getKey ( ) ) ; zooKeeperStateDriver . set ( getKey ( ) , taskInfoList ) ; } catch ( IOException ex ) { LOGGER . error ( " Could ▁ not ▁ write ▁ list ▁ of ▁ executor ▁ states ▁ to ▁ zookeeper : ▁ " , ex ) ; } }
jhftrifork/elasticsearch | private String getKey ( ) { return frameworkState . getFrameworkID ( ) . getValue ( ) + " / " + STATE_LIST ; }
pphdsny/ArithmeticTest | public int maxSatisfied ( int [ ] customers , int [ ] grumpy , int X ) { int [ ] dp = new int [ customers . length + 1 ] ; int [ ] zoreDp = new int [ customers . length + 1 ] ; int max = X > customers . length ? customers . length : X ; int sum = 0 ; for ( int i = 0 ; i < customers . length ; i ++ ) { if ( i < X ) { dp [ i + 1 ] = sum += customers [ i ] ; } zoreDp [ i + 1 ] = ( grumpy [ i ] == 0 ) ? customers [ i ] + zoreDp [ i ] : zoreDp [ i ] ; } int retMax = dp [ max ] + zoreDp [ customers . length ] - zoreDp [ max ] ; for ( int i = X ; i < customers . length ; i ++ ) { dp [ i + 1 ] = dp [ i ] - customers [ i - X ] + customers [ i ] ; int otherZore = zoreDp [ customers . length ] - zoreDp [ i + 1 ] + zoreDp [ i - X + 1 ] ; retMax = Math . max ( retMax , dp [ i + 1 ] + otherZore ) ; } return retMax ; }
FDevman/VIDEVOX-Beta | public AudioTTS ( JSONObject json ) throws VidevoxException { this ( ( String ) json . get ( NAME ) , ( String ) json . get ( SPEECH ) , ( double ) json . get ( START ) ) ; _active = ( boolean ) json . get ( ACTIVE ) ; }
FDevman/VIDEVOX-Beta | public AudioTTS ( String name , String speech , double offset ) throws VidevoxException { _name = name ; _startOffset = offset ; _speech = speech ; String path = " / tmp " ; logger . debug ( " this ( String , ▁ String , ▁ double ) ▁ - ▁ path ▁ found ▁ at : ▁ " + path ) ; _audioFile = new File ( path + " / " + name ) ; textToMP3 ( _audioFile , _speech ) ; _audioFile = ModelHelper . enforceFileExtension ( _audioFile , " . mp3" ) ; logger . debug ( " AudioTTS ( String , ▁ String , ▁ double ) ▁ - ▁ New ▁ TTS ▁ file : ▁ " + _audioFile . getAbsolutePath ( ) ) ; }
FDevman/VIDEVOX-Beta | public JSONObject toJSON ( ) { JSONObject json = new JSONObject ( ) ; json . put ( FILE , _audioFile . getAbsolutePath ( ) ) ; json . put ( START , _startOffset ) ; json . put ( ACTIVE , _active ) ; json . put ( SPEECH , _speech ) ; json . put ( NAME , _name ) ; return json ; }
FDevman/VIDEVOX-Beta | @ Override public boolean equals ( Object o ) { if ( o == this ) return true ; if ( o == null ) return false ; if ( ! ( o instanceof AudioTTS ) ) return false ; AudioTTS other = ( AudioTTS ) o ; if ( other . _audioFile . equals ( _audioFile ) && other . _startOffset == _startOffset ) { return true ; } else { return false ; } }
kkhatua/drill | private ScanFieldDeterminer ( ) { }
kkhatua/drill | public void addProjected ( SchemaPath path ) { projected . add ( path ) ; }
kkhatua/drill | public void addReferenced ( SchemaPath path ) { referenced . add ( path ) ; }
kkhatua/drill | public void addReferenced ( Collection < SchemaPath > paths ) { referenced . addAll ( paths ) ; }
kkhatua/drill | public void addProjected ( Collection < SchemaPath > paths ) { projected . addAll ( paths ) ; }
kkhatua/drill | @ Override public FieldList clone ( ) { FieldList newList = new FieldList ( ) ; for ( SchemaPath p : projected ) { newList . addProjected ( p ) ; } for ( SchemaPath p : referenced ) { newList . addReferenced ( p ) ; } return newList ; }
kkhatua/drill | @ Override public Void visitScan ( Scan scan , FieldList value ) { if ( value == null ) { scanFields . put ( scan , new FieldList ( ) ) ; } else { scanFields . put ( scan , value ) ; } return null ; }
kkhatua/drill | @ Override public Void visitStore ( Store store , FieldList value ) { store . getInput ( ) . accept ( this , value ) ; return null ; }
kkhatua/drill | @ Override public Void visitGroupingAggregate ( GroupingAggregate groupBy , FieldList value ) { FieldList list = new FieldList ( ) ; for ( NamedExpression e : groupBy . getExprs ( ) ) { list . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } for ( NamedExpression e : groupBy . getKeys ( ) ) { list . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } groupBy . getInput ( ) . accept ( this , list ) ; return null ; }
kkhatua/drill | @ Override public Void visitFilter ( Filter filter , FieldList value ) { value . addReferenced ( filter . getExpr ( ) . accept ( finder , null ) ) ; return null ; }
kkhatua/drill | @ Override public Void visitProject ( Project project , FieldList value ) { FieldList fl = new FieldList ( ) ; for ( NamedExpression e : project . getSelections ( ) ) { fl . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } return null ; }
kkhatua/drill | @ Override public Void visitValues ( Values constant , FieldList value ) { return null ; }
kkhatua/drill | @ Override public Void visitOrder ( Order order , FieldList fl ) { for ( Ordering o : order . getOrderings ( ) ) { fl . addReferenced ( o . getExpr ( ) . accept ( finder , null ) ) ; } return null ; }
kkhatua/drill | @ Override public Void visitJoin ( Join join , FieldList fl ) { { FieldList leftList = fl . clone ( ) ; for ( JoinCondition c : join . getConditions ( ) ) { leftList . addReferenced ( c . getLeft ( ) . accept ( finder , null ) ) ; } join . getLeft ( ) . accept ( this , leftList ) ; } { FieldList rightList = fl . clone ( ) ; for ( JoinCondition c : join . getConditions ( ) ) { rightList . addReferenced ( c . getRight ( ) . accept ( finder , null ) ) ; } join . getLeft ( ) . accept ( this , rightList ) ; } return null ; }
kkhatua/drill | @ Override public Void visitLimit ( Limit limit , FieldList value ) { limit . getInput ( ) . accept ( this , value ) ; return null ; }
kkhatua/drill | @ Override public Void visitUnion ( Union union , FieldList value ) { for ( LogicalOperator o : union . getInputs ( ) ) { o . accept ( this , value . clone ( ) ) ; } return null ; }
kkhatua/drill | @ Override public Set < SchemaPath > visitSchemaPath ( SchemaPath path , Void value ) { Set < SchemaPath > set = Sets . newHashSet ( ) ; set . add ( path ) ; return set ; }
kkhatua/drill | @ Override public Set < SchemaPath > visitUnknown ( LogicalExpression e , Void value ) { Set < SchemaPath > paths = Sets . newHashSet ( ) ; for ( LogicalExpression ex : e ) { paths . addAll ( ex . accept ( this , null ) ) ; } return paths ; }
lmmx/ppi-calcs | public NetworkException ( String message ) { super ( message ) ; }
Novemser/TomcatTest | @ Test public void test0001 ( ) { TestResource . testExpression ( " DN - 21-0010" , " $ { true ▁ & & ▁ false } " , " false " ) ; }
Novemser/TomcatTest | @ Test public void test0002 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0011" , " $ { true ▁ & & ▁ null } " , " false " ) ; }
Novemser/TomcatTest | @ Test public void test0003 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0012" , " $ { null ▁ & & ▁ null } " , " false " ) ; }
Novemser/TomcatTest | @ Test public void test0004 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0013" , " $ { false ▁ & & ▁ null } " , " false " ) ; }
Flibio/Ultimate-Spleef | protected UArena ( String arenaName , ArenaData data ) { super ( arenaName , Sponge . getGame ( ) , UltimateSpleef . access ) ; overrideData ( data ) ; getData ( ) . addPreventHungerLoss ( ArenaStates . ALL ) ; getData ( ) . addPreventPlayerDamage ( ArenaStates . ALL ) ; getData ( ) . addPreventBlockModify ( ArenaStates . ALL ) ; lobbySpawn = getData ( ) . getLocation ( " lobby " ) . get ( ) ; circleCenter = getData ( ) . getLocation ( " circlecenter " ) . get ( ) ; dedicated = data . getVariable ( " dedicated " , Boolean . class ) . get ( ) ; circleRad = ( int ) getData ( ) . getLocation ( " circleedge " ) . get ( ) . getPosition ( ) . distance ( circleCenter . getPosition ( ) ) ; blocks = getCircle ( circleCenter , circleRad ) ; getData ( ) . setTriggerPlayerEvents ( dedicated ) ; addArenaStateRunnable ( ArenaStates . LOBBY_COUNTDOWN , lobbyCountdown ) ; addArenaStateRunnable ( ArenaStates . GAME_COUNTDOWN , gameCountdown ) ; addArenaStateRunnable ( ArenaStates . GAME_PLAYING , gamePlaying ) ; addArenaStateRunnable ( ArenaStates . GAME_OVER , gameOver ) ; resetArena ( ) ; Sponge . getScheduler ( ) . createTaskBuilder ( ) . execute ( r -> { if ( lobbyWaiting ) { if ( lobbyTimer == 0 ) { lobbyWaiting = false ; if ( onlinePlayers . size ( ) >= minPlayers ) { arenaStateChange ( ArenaStates . LOBBY_COUNTDOWN ) ; } } lobbyTimer -- ; } else { lobbyTimer = 15 ; } } ) . async ( ) . interval ( 1 , TimeUnit . SECONDS ) . submit ( UltimateSpleef . access ) ; Sponge . getScheduler ( ) . createTaskBuilder ( ) . execute ( r -> { onlinePlayers . forEach ( uuid -> { Optional < Player > pOpt = resolvePlayer ( uuid ) ; if ( pOpt . isPresent ( ) ) { Sponge . getScheduler ( ) . createTaskBuilder ( ) . execute ( c -> { pOpt . get ( ) . offer ( Keys . FOOD_LEVEL , 20 ) ; } ) . submit ( UltimateSpleef . access ) ; } } ) ; } ) . async ( ) . interval ( 5 , TimeUnit . SECONDS ) . submit ( UltimateSpleef . access ) ; }
Flibio/Ultimate-Spleef | @ Override public void addOnlinePlayer ( Player player ) { if ( getOnlinePlayers ( ) . size ( ) >= maxPlayers ) { failed ( player , " arena . full " ) ; } else { ArenaState currentState = getCurrentState ( ) ; if ( currentState . equals ( ArenaStates . LOBBY_COUNTDOWN ) || currentState . equals ( ArenaStates . LOBBY_WAITING ) ) { resetPlayer ( player ) ; broadcast ( messages . getMessage ( " arena . join " , " player " , player . getName ( ) ) ) ; onlinePlayers . add ( player . getUniqueId ( ) ) ; if ( ! lobbyWaiting ) { if ( onlinePlayers . size ( ) >= minPlayers ) { arenaStateChange ( ArenaStates . LOBBY_COUNTDOWN ) ; } } } else { failed ( player , " arena . inprogress " ) ; } } }
Flibio/Ultimate-Spleef | @ Override public void removeOnlinePlayer ( Player player ) { onlinePlayers . remove ( player . getUniqueId ( ) ) ; broadcast ( messages . getMessage ( " arena . exit " , " player " , player . getName ( ) ) ) ; ArenaState currentState = getCurrentState ( ) ; if ( currentState . equals ( ArenaStates . LOBBY_COUNTDOWN ) && onlinePlayers . size ( ) < minPlayers ) { lobbyCountdown . cancelCountdown ( ) ; arenaStateChange ( ArenaStates . LOBBY_WAITING ) ; broadcast ( messages . getMessage ( " arena . lobbycountstop " ) ) ; } else if ( currentState . equals ( ArenaStates . GAME_PLAYING ) && onlinePlayers . size ( ) < minPlayers ) { arenaStateChange ( ArenaStates . LOBBY_WAITING ) ; broadcast ( messages . getMessage ( " arena . notenoughplayers " ) ) ; for ( Player p : resolvePlayers ( onlinePlayers ) ) { resetPlayer ( p ) ; } resetArena ( ) ; } else if ( currentState . equals ( ArenaStates . GAME_COUNTDOWN ) && onlinePlayers . size ( ) < minPlayers ) { gameCountdown . cancelCountdown ( ) ; arenaStateChange ( ArenaStates . LOBBY_WAITING ) ; broadcast ( messages . getMessage ( " arena . gamecountstop " ) ) ; for ( Player p : resolvePlayers ( onlinePlayers ) ) { resetPlayer ( p ) ; } resetArena ( ) ; } }
Flibio/Ultimate-Spleef | public List < Location < World > > getBlocks ( ) { return blocks ; }
Flibio/Ultimate-Spleef | public Location < World > getCenter ( ) { return circleCenter ; }
Flibio/Ultimate-Spleef | public void removeAlive ( UUID uuid ) { alivePlayers . remove ( uuid ) ; }
Flibio/Ultimate-Spleef | public List < UUID > getAlive ( ) { return alivePlayers ; }
Flibio/Ultimate-Spleef | public void resetOnlinePlayers ( ) { onlinePlayers . clear ( ) ; alivePlayers . clear ( ) ; }
Flibio/Ultimate-Spleef | private ArrayList < Location < World > > getCircle ( Location < World > center , int r ) { ArrayList < Location < World > > locations = new ArrayList < Location < World > > ( ) ; int cx = center . getBlockX ( ) ; int cy = center . getBlockY ( ) ; int cz = center . getBlockZ ( ) ; World w = center . getExtent ( ) ; int rSquared = r * r ; for ( int x = cx - r ; x <= cx + r ; x ++ ) { for ( int z = cz - r ; z <= cz + r ; z ++ ) { if ( ( cx - x ) * ( cx - x ) + ( cz - z ) * ( cz - z ) <= rSquared ) { locations . add ( new Location < World > ( w , x , cy , z ) ) ; } } } return locations ; }
Flibio/Ultimate-Spleef | public void resetArena ( ) { blocks . forEach ( block -> { block . setBlockType ( BlockTypes . QUARTZ_BLOCK ) ; block . sub ( 0 , 1 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 2 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 3 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 4 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 5 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . getExtent ( ) . getEntities ( ) . forEach ( entity -> { if ( entity . getLocation ( ) . getPosition ( ) . distance ( block . getPosition ( ) ) < 1.5 ) { entity . remove ( ) ; } } ) ; } ) ; alivePlayers . addAll ( onlinePlayers ) ; lobbyWaiting = true ; lobbyTimer = 15 ; }
Flibio/Ultimate-Spleef | private void resetPlayer ( Player player ) { player . setLocationSafely ( lobbySpawn . add ( 0 , 1 , 0 ) ) ; player . offer ( Keys . GAME_MODE , GameModes . SURVIVAL ) ; player . offer ( Keys . HEALTH , 20.0 ) ; player . offer ( Keys . FOOD_LEVEL , 20 ) ; }
Flibio/Ultimate-Spleef | private void failed ( Player player , String messageKey ) { if ( dedicated ) { player . kick ( messages . getMessage ( messageKey ) ) ; } else { player . sendMessage ( messages . getMessage ( messageKey ) ) ; } }
vivantech/kc_fixes | public String getProposalNumber ( ) { return proposalNumber ; }
vivantech/kc_fixes | public void setProposalNumber ( String proposalNumber ) { this . proposalNumber = proposalNumber ; }
vivantech/kc_fixes | public String getBudgetStatusCode ( ) { return budgetStatusCode ; }
vivantech/kc_fixes | public void setBudgetStatusCode ( String budgetStatusCode ) { this . budgetStatusCode = budgetStatusCode ; }
vivantech/kc_fixes | public void setBudgetStatus ( BudgetStatus budgetStatus ) { this . budgetStatus = budgetStatus ; }
vivantech/kc_fixes | public BudgetStatus getBudgetStatus ( ) { return budgetStatus ; }
yuweijun/learning-programming | public OkHttpTimeoutExample ( ) { client = new OkHttpClient . Builder ( ) . connectTimeout ( 10 , TimeUnit . SECONDS ) . writeTimeout ( 10 , TimeUnit . SECONDS ) . readTimeout ( 30 , TimeUnit . SECONDS ) . build ( ) ; }
yuweijun/learning-programming | public void run ( ) throws IOException { Request request = new Request . Builder ( ) . url ( " https : // httpbin . org / delay / 2" ) . build ( ) ; Response response = client . newCall ( request ) . execute ( ) ; System . out . println ( " Response ▁ completed : ▁ " + response ) ; }
googleapis/google-api-java-client-services | public java . lang . String getResourceName ( ) { return resourceName ; }
googleapis/google-api-java-client-services | public SdfDownloadTask setResourceName ( java . lang . String resourceName ) { this . resourceName = resourceName ; return this ; }
googleapis/google-api-java-client-services | @ Override public SdfDownloadTask set ( String fieldName , Object value ) { return ( SdfDownloadTask ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public SdfDownloadTask clone ( ) { return ( SdfDownloadTask ) super . clone ( ) ; }
gauravlall/oneops | @ Test public void simpleLogTest ( ) { LoggingMsgService service = new LoggingMsgService ( ) ; XMPPSubscriber subscriber = new XMPPSubscriber ( ) ; NotificationMessage msg = new NotificationMessage ( ) ; msg . setNsPath ( " / a / b / c / d / e / f " ) ; msg . setSource ( " sourceOpen " ) ; msg . setSubject ( " subjectOfMsg " ) ; msg . setText ( " message - text - xya " ) ; msg . setType ( NotificationType . deployment ) ; msg . setSeverity ( NotificationSeverity . critical ) ; msg . setTemplateName ( " template12" ) ; msg . setTimestamp ( System . currentTimeMillis ( ) ) ; boolean res = service . postMessage ( msg , subscriber ) ; assert ( res ) ; }
cnishina/jmeter-client | public String buildFromTemplate ( ) { String content = Utils . getStringFromFile ( RESOURCE ) ; for ( Entry < String , String > entry : map . entrySet ( ) ) { String match = entry . getKey ( ) . replace ( " { { " , " \\ { \\ { " ) . replace ( " } } " , " \\ } \\ } " ) ; content = content . replaceAll ( match , entry . getValue ( ) ) ; } return content ; }
J0-J0/cateringManagement | if ( " add " . equals ( action ) ) { addCart ( request , response ) ; return ; }
J0-J0/cateringManagement | else if ( " delete " . equals ( action ) ) { deleteCart ( request , response ) ; return ; }
J0-J0/cateringManagement | else if ( " update " . equals ( action ) ) { updateCart ( request , response ) ; return ; }
J0-J0/cateringManagement | private void updateCart ( HttpServletRequest request , HttpServletResponse response ) { int cartId = Integer . parseInt ( request . getParameter ( " cartId " ) ) ; int num = Integer . parseInt ( request . getParameter ( " num " ) ) ; float sum = Float . parseFloat ( request . getParameter ( " sum " ) ) ; DaoFactory daoFactory = new DaoFactory ( ) ; try { daoFactory . beginConnectionScope ( ) ; daoFactory . beginTransaction ( ) ; CartDao cartDao = daoFactory . createCartDao ( ) ; cartDao . updateCart ( cartId , num , sum ) ; daoFactory . endTransaction ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; daoFactory . abortTransaction ( ) ; } finally { daoFactory . endConnectionScope ( ) ; } }
J0-J0/cateringManagement | private void deleteCart ( HttpServletRequest request , HttpServletResponse response ) { int cartId = Integer . parseInt ( request . getParameter ( " cartId " ) ) ; DaoFactory daoFactory = new DaoFactory ( ) ; try { daoFactory . beginConnectionScope ( ) ; daoFactory . beginTransaction ( ) ; CartDao cartDao = daoFactory . createCartDao ( ) ; cartDao . deleteCart ( cartId ) ; daoFactory . endTransaction ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; daoFactory . abortTransaction ( ) ; } finally { daoFactory . endConnectionScope ( ) ; } }
J0-J0/cateringManagement | private void addCart ( HttpServletRequest request , HttpServletResponse response ) throws IOException { response . setContentType ( " text / html ; charset = utf - 8" ) ; PrintWriter out = new PrintWriter ( response . getWriter ( ) , true ) ; int userId = 0 ; if ( StringUtil . isEmpty ( request . getParameter ( " userId " ) ) ) { out . println ( " Ìí¼ÓÊ § ° Ü £ ¬ Çë¼ì²éÊÇ · ñµÇÂ¼ £ ¡ " ) ; out . close ( ) ; return ; } else { userId = Integer . parseInt ( request . getParameter ( " userId " ) ) ; } int foodId = Integer . parseInt ( request . getParameter ( " foodId " ) ) ; String tmp = request . getParameter ( " num " ) ; int num = 0 ; if ( StringUtil . isNotEmpty ( tmp ) ) { num = Integer . parseInt ( tmp ) ; } DaoFactory daoFactory = new DaoFactory ( ) ; try { daoFactory . beginConnectionScope ( ) ; daoFactory . beginTransaction ( ) ; CartDao cartDao = daoFactory . createCartDao ( ) ; boolean flag = cartDao . selectCart ( userId , foodId ) ; if ( ! flag ) { FoodDao foodDao = daoFactory . createFoodDao ( ) ; MerchantDao merchantDao = daoFactory . createMerchantDao ( ) ; Food food = foodDao . selectFood ( foodId ) ; Merchant merchant = merchantDao . selectMerchant ( food . getMerchantId ( ) ) ; Cart cart = cartDao . createCart ( merchant . getMerchantId ( ) , merchant . getMerchantName ( ) , userId , food , num ) ; cartDao . addCart ( cart ) ; out . println ( " Ìí¼Ó³É¹ ¦ £ ¡ " ) ; out . close ( ) ; daoFactory . endTransaction ( ) ; } else { } daoFactory . endTransaction ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; daoFactory . abortTransaction ( ) ; } finally { daoFactory . endConnectionScope ( ) ; } }
byrao123/clickfortech | private MapProviderFactory ( ) { super ( ) ; }
byrao123/clickfortech | private MapProvider getMapProvider ( String providerClassName ) { MapProvider mp = null ; if ( this . mapProviderMap . containsKey ( providerClassName ) ) { mp = this . mapProviderMap . get ( providerClassName ) ; } else { String clzName = null ; if ( providerClassName . indexOf ( " . " ) >= 0 ) { clzName = providerClassName ; } else { clzName = MAP_PROVIDER_PACKAGE + " . " + providerClassName ; } try { Class providerClass = Class . forName ( clzName ) ; mp = ( MapProvider ) providerClass . newInstance ( ) ; this . mapProviderMap . put ( providerClassName , mp ) ; } catch ( Throwable t ) { Print . logError ( " MapProvider ▁ creation ▁ error : ▁ " + clzName + " ▁ [ " + t ) ; mp = null ; } } return mp ; }
izeye/spring-boot | public DispatcherServletConfiguration ( ServerProperties server , WebMvcProperties webMvcProperties , ObjectProvider < MultipartConfigElement > multipartConfigProvider ) { this . server = server ; this . webMvcProperties = webMvcProperties ; this . multipartConfig = multipartConfigProvider . getIfAvailable ( ) ; }
izeye/spring-boot | @ Bean ( name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) public DispatcherServlet dispatcherServlet ( ) { DispatcherServlet dispatcherServlet = new DispatcherServlet ( ) ; dispatcherServlet . setDispatchOptionsRequest ( this . webMvcProperties . isDispatchOptionsRequest ( ) ) ; dispatcherServlet . setDispatchTraceRequest ( this . webMvcProperties . isDispatchTraceRequest ( ) ) ; dispatcherServlet . setThrowExceptionIfNoHandlerFound ( this . webMvcProperties . isThrowExceptionIfNoHandlerFound ( ) ) ; return dispatcherServlet ; }
izeye/spring-boot | @ Bean ( name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) public ServletRegistrationBean dispatcherServletRegistration ( ) { ServletRegistrationBean registration = new ServletRegistrationBean ( dispatcherServlet ( ) , this . server . getServletMapping ( ) ) ; registration . setName ( DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; if ( this . multipartConfig != null ) { registration . setMultipartConfig ( this . multipartConfig ) ; } return registration ; }
izeye/spring-boot | @ Bean @ ConditionalOnBean ( MultipartResolver . class ) @ ConditionalOnMissingBean ( name = DispatcherServlet . MULTIPART_RESOLVER_BEAN_NAME ) public MultipartResolver multipartResolver ( MultipartResolver resolver ) { return resolver ; }
izeye/spring-boot | @ Override public ConditionOutcome getMatchOutcome ( ConditionContext context , AnnotatedTypeMetadata metadata ) { ConfigurableListableBeanFactory beanFactory = context . getBeanFactory ( ) ; ConditionOutcome outcome = checkServlets ( beanFactory ) ; if ( ! outcome . isMatch ( ) ) { return outcome ; } return checkServletRegistrations ( beanFactory ) ; }
izeye/spring-boot | private ConditionOutcome checkServlets ( ConfigurableListableBeanFactory beanFactory ) { List < String > servlets = Arrays . asList ( beanFactory . getBeanNamesForType ( DispatcherServlet . class , false , false ) ) ; boolean containsDispatcherBean = beanFactory . containsBean ( DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; if ( servlets . isEmpty ( ) ) { if ( containsDispatcherBean ) { return ConditionOutcome . noMatch ( " found ▁ no ▁ DispatcherServlet ▁ " + " but ▁ a ▁ non - DispatcherServlet ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; } return ConditionOutcome . match ( " no ▁ DispatcherServlet ▁ found " ) ; } if ( servlets . contains ( DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ) { return ConditionOutcome . noMatch ( " found ▁ DispatcherServlet ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; } if ( containsDispatcherBean ) { return ConditionOutcome . noMatch ( " found ▁ non - DispatcherServlet ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; } return ConditionOutcome . match ( " one ▁ or ▁ more ▁ DispatcherServlets ▁ " + " found ▁ and ▁ none ▁ is ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; }
izeye/spring-boot | private ConditionOutcome checkServletRegistrations ( ConfigurableListableBeanFactory beanFactory ) { List < String > registrations = Arrays . asList ( beanFactory . getBeanNamesForType ( ServletRegistrationBean . class , false , false ) ) ; boolean containsDispatcherRegistrationBean = beanFactory . containsBean ( DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; if ( registrations . isEmpty ( ) ) { if ( containsDispatcherRegistrationBean ) { return ConditionOutcome . noMatch ( " found ▁ no ▁ ServletRegistrationBean ▁ " + " but ▁ a ▁ non - ServletRegistrationBean ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; } return ConditionOutcome . match ( " no ▁ ServletRegistrationBean ▁ found " ) ; } if ( registrations . contains ( DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ) { return ConditionOutcome . noMatch ( " found ▁ ServletRegistrationBean ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; } if ( containsDispatcherRegistrationBean ) { return ConditionOutcome . noMatch ( " found ▁ non - ServletRegistrationBean ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; } return ConditionOutcome . match ( " one ▁ or ▁ more ▁ ServletRegistrationBeans ▁ is ▁ found ▁ and ▁ none ▁ is ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; }
UniversityOfHawaiiORS/rice | public NoteType ( ) { }
UniversityOfHawaiiORS/rice | public String getNoteTypeCode ( ) { return noteTypeCode ; }
UniversityOfHawaiiORS/rice | public void setNoteTypeCode ( String noteTypeCode ) { this . noteTypeCode = noteTypeCode ; }
UniversityOfHawaiiORS/rice | public String getNoteTypeDescription ( ) { return noteTypeDescription ; }
UniversityOfHawaiiORS/rice | public void setNoteTypeDescription ( String noteTypeDescription ) { this . noteTypeDescription = noteTypeDescription ; }
UniversityOfHawaiiORS/rice | public boolean isNoteTypeActiveIndicator ( ) { return noteTypeActiveIndicator ; }
UniversityOfHawaiiORS/rice | public void setNoteTypeActiveIndicator ( boolean noteTypeActiveIndicator ) { this . noteTypeActiveIndicator = noteTypeActiveIndicator ; }
UniversityOfHawaiiORS/rice | @ Override public boolean isActive ( ) { return noteTypeActiveIndicator ; }
UniversityOfHawaiiORS/rice | @ Override public void setActive ( boolean active ) { this . noteTypeActiveIndicator = active ; }
OpenCubicChunks/CubicChunks | @ Override public int getChunkPosY ( ) { return this . cubeY ; }
OpenCubicChunks/CubicChunks | @ Override public void initCubic ( World world , int cubeY ) { if ( this . isCubic ) { throw new IllegalStateException ( " Already ▁ initialized ! " ) ; } this . cubeY = cubeY ; this . isCubic = true ; }
OpenCubicChunks/CubicChunks | @ Override public CubePos getCubePos ( ) { return new CubePos ( getX ( ) , getY ( ) , getZ ( ) ) ; }
OpenCubicChunks/CubicChunks | I ) V " , ordinal = 0 ) , locals = LocalCapture . CAPTURE_FAILHARD ) private void writeYToNbt ( int chunkX , int chunkZ , CallbackInfoReturnable < NBTTagCompound > cir , NBTTagCompound tag ) { tag . setInteger ( " ChunkY " , this . cubeY ) ; }
OpenCubicChunks/CubicChunks | @ Inject ( method = " readStructureComponentsFromNBT " , at = @ At ( " HEAD " ) ) private void readYFromNBT ( World world , NBTTagCompound tag , CallbackInfo cbi ) { if ( tag . hasKey ( " ChunkY " ) ) { this . isCubic = true ; this . cubeY = tag . getInteger ( " ChunkY " ) ; } }
OpenCubicChunks/CubicChunks | @ Override public int getX ( ) { return getChunkPosX ( ) ; }
OpenCubicChunks/CubicChunks | @ Override public int getY ( ) { return getChunkPosY ( ) ; }
OpenCubicChunks/CubicChunks | @ Override public int getZ ( ) { return getChunkPosZ ( ) ; }
OpenCubicChunks/CubicChunks | @ Override public boolean isCubic ( ) { return this . isCubic ; }
danielkec/Ansible | @ Test public void testPrintWelcome ( ) throws Exception { }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . start , in . end , in . buffer , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . start , in . end , in . buffer , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . start , in . start + 16 , in . buffer , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
hyang04/jruyi | @ Override public void onMessage ( IMessage message ) { Object action = message . removeProperty ( IoConstants . MP_SESSION_ACTION ) ; if ( action != null ) { if ( action == SessionAction . OPEN ) { connect ( message ) ; } else { if ( action == SessionAction . CLOSE ) { IChannel channel = getChannel ( message ) ; if ( channel != null ) channel . close ( ) ; } else m_logger . warn ( StrUtil . buildString ( this , " , ▁ Unknown ▁ Session ▁ Action : ▁ " , action ) ) ; message . close ( ) ; } return ; } IChannel channel = getChannel ( message ) ; if ( channel == null ) { m_logger . warn ( StrUtil . buildString ( this , " , ▁ Session [ " + IoConstants . MP_ACTIVE_SESSION + " ] ▁ Not ▁ Found : ▁ " , message ) ) ; return ; } channel . write ( message . detach ( ) , false ) ; message . close ( ) ; }
hyang04/jruyi | @ Override public void onMessageSent ( IChannel channel , Object data ) { int timeout = m_conf . readTimeout ( ) ; if ( timeout > 0 ) channel . scheduleReadTimeout ( timeout ) ; else if ( timeout == 0 ) onChannelReadTimedOut ( channel ) ; }
hyang04/jruyi | @ Override public void onMessageReceived ( IChannel channel , Object data ) { if ( channel . cancelTimeout ( ) ) enqueue ( channel , data ) ; else if ( data instanceof ICloseable ) ( ( ICloseable ) data ) . close ( ) ; }
hyang04/jruyi | @ Override public void onChannelOpened ( IChannel channel ) { super . onChannelOpened ( channel ) ; fireSessionEvent ( channel , SessionEvent . OPENED , ( IMessage ) channel . detach ( ) ) ; }
hyang04/jruyi | @ Override public void onChannelClosed ( IChannel channel ) { super . onChannelClosed ( channel ) ; fireSessionEvent ( channel , SessionEvent . CLOSED ) ; }
hyang04/jruyi | @ Override public void onChannelConnectTimedOut ( IChannel channel ) { super . onChannelConnectTimedOut ( channel ) ; fireSessionEvent ( channel , SessionEvent . CONN_TIMEDOUT ) ; }
hyang04/jruyi | @ Override public void onChannelReadTimedOut ( IChannel channel ) { super . onChannelReadTimedOut ( channel ) ; fireSessionEvent ( channel , SessionEvent . READ_TIMEDOUT ) ; }
hyang04/jruyi | @ Override public void onChannelException ( IChannel channel , Throwable t ) { IMessage message = ( IMessage ) channel . detach ( ) ; if ( message != null ) { if ( channel != getChannel ( message ) ) { m_logger . error ( StrUtil . buildString ( this , " ▁ got ▁ an ▁ error ▁ on ▁ connecting : ▁ " , message ) , t ) ; if ( configuration ( ) . sessionEventMask ( ) . notifyConnError ( ) ) { fireSessionEvent ( null , SessionEvent . CONN_ERROR , message ) ; return ; } } else { m_logger . error ( StrUtil . buildString ( this , " ▁ got ▁ an ▁ error ▁ on ▁ sending / recving : ▁ " , message ) , t ) ; if ( configuration ( ) . sessionEventMask ( ) . notifyRwError ( ) ) { fireSessionEvent ( null , SessionEvent . RW_ERROR , message ) ; return ; } } message . close ( ) ; } }
hyang04/jruyi | @ Override public void startInternal ( ) { m_logger . info ( StrUtil . buildString ( " Starting ▁ " , this , " . . . " ) ) ; super . startInternal ( ) ; m_logger . info ( StrUtil . buildString ( this , " ▁ started " ) ) ; }
hyang04/jruyi | @ Override public final void stopInternal ( ) { m_logger . info ( StrUtil . buildString ( " Stopping ▁ " , this , " . . . " ) ) ; super . stopInternal ( ) ; m_logger . info ( StrUtil . buildString ( this , " ▁ stopped " ) ) ; }
hyang04/jruyi | @ Override TcpClientConf configuration ( ) { return m_conf ; }
hyang04/jruyi | @ Override String getFactoryPid ( ) { return " org . jruyi . io . tcpclient . longconn " ; }
hyang04/jruyi | @ Override TcpClientConf updateConf ( Map < String , ? > props ) { TcpClientConf conf = m_conf ; if ( props == null ) m_conf = null ; else { TcpClientConf newConf = new TcpClientConf ( ) ; newConf . initialize ( props ) ; m_conf = newConf ; } return conf ; }
hyang04/jruyi | private void enqueue ( IChannel channel , Object data ) { IProducer producer = producer ( ) ; IMessage message = producer . createMessage ( ) ; message . putProperty ( IoConstants . MP_ACTIVE_SESSION , channel ) ; message . attach ( data ) ; producer . send ( message ) ; }
hyang04/jruyi | private IChannel getChannel ( IMessage message ) { return ( IChannel ) message . getProperty ( IoConstants . MP_ACTIVE_SESSION ) ; }
hyang04/jruyi | private void fireSessionEvent ( IChannel channel , SessionEvent event ) { IProducer producer = producer ( ) ; IMessage message = producer . createMessage ( ) ; message . putProperty ( IoConstants . MP_SESSION_EVENT , event ) ; message . putProperty ( IoConstants . MP_ACTIVE_SESSION , channel ) ; producer . send ( message ) ; }
hyang04/jruyi | private void fireSessionEvent ( IChannel channel , SessionEvent event , IMessage message ) { message . putProperty ( IoConstants . MP_SESSION_EVENT , event ) ; if ( channel != null ) message . putProperty ( IoConstants . MP_ACTIVE_SESSION , channel ) ; producer ( ) . send ( message ) ; }
FHannes/intellij-community | public void testSingleTokenAnchor ( ) { PsiFile file = myFixture . configureByText ( " a . xml " , " < " ) ; PsiAnchor anchor = PsiAnchor . create ( assertInstanceOf ( file . findElementAt ( 0 ) , XmlToken . class ) ) ; WriteCommandAction . runWriteCommandAction ( getProject ( ) , ( ) -> file . getViewProvider ( ) . getDocument ( ) . replaceString ( 0 , 1 , " ▁ " ) ) ; PsiDocumentManager . getInstance ( getProject ( ) ) . commitAllDocuments ( ) ; assertInstanceOf ( file . findElementAt ( 0 ) , PsiWhiteSpace . class ) ; assertNull ( anchor . retrieve ( ) ) ; }
FHannes/intellij-community | public void testInjectedAnchor ( ) { new MyTestInjector ( getPsiManager ( ) ) . injectAll ( myFixture . getTestRootDisposable ( ) ) ; myFixture . configureByText ( " a . java " , " class ▁ X ▁ { ▁ String ▁ java = \" class ▁ < caret > Foo ▁ { } \" } " ) ; PsiClass cls = ( PsiClass ) myFixture . getElementAtCaret ( ) ; assertEquals ( " Foo " , cls . getName ( ) ) ; PsiAnchor anchor = PsiAnchor . create ( cls ) ; myFixture . type ( ' \n ' ) ; PsiDocumentManager . getInstance ( getProject ( ) ) . commitAllDocuments ( ) ; assertNull ( anchor . retrieve ( ) ) ; }
msurdi/redeye | GenericType < List < Entry > > entryListType = new GenericType < List < Entry > > ( ) { }
msurdi/redeye | GenericType < List < Query > > queryListType = new GenericType < List < Query > > ( ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . mapshow ) ; LocationManager lm = ( LocationManager ) getSystemService ( Context . LOCATION_SERVICE ) ; LocationListener llistener = new mylocationlistener ( ) ; lm . requestLocationUpdates ( LocationManager . GPS_PROVIDER , 0 , 0 , llistener ) ; mapSearchBox = ( EditText ) findViewById ( R . id . mapSearchBox ) ; Button mapSearch = ( Button ) findViewById ( R . id . search ) ; Button mapViewType = ( Button ) findViewById ( R . id . mapTypeChange ) ; inputManager = ( InputMethodManager ) getSystemService ( Context . INPUT_METHOD_SERVICE ) ; mapSearch . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { inputManager . hideSoftInputFromWindow ( getCurrentFocus ( ) . getWindowToken ( ) , InputMethodManager . HIDE_NOT_ALWAYS ) ; if ( mapSearchBox . getText ( ) . toString ( ) . trim ( ) . length ( ) <= 0 ) { Toast . makeText ( MapShow . this , " Popraw ▁ puste ▁ pole ! " , Toast . LENGTH_SHORT ) . show ( ) ; } else { search = mapSearchBox . getText ( ) . toString ( ) ; try { Geocoder geocoder = new Geocoder ( getApplicationContext ( ) , Locale . getDefault ( ) ) ; List < Address > nazwy = geocoder . getFromLocationName ( search , 1 ) ; if ( nazwy . size ( ) == 0 ) { System . out . println ( " Error " ) ; } address = nazwy . get ( 0 ) ; LatLng searchedLocation = new LatLng ( address . getLatitude ( ) , address . getLongitude ( ) ) ; googleMap . moveCamera ( CameraUpdateFactory . newLatLng ( searchedLocation ) ) ; googleMap . animateCamera ( CameraUpdateFactory . zoomTo ( 16 ) ) ; } catch ( Exception e ) { Log . e ( " " , " Wystapil ▁ blad ▁ ! ▁ " , e ) ; } } } } ) ; mapViewType . setOnClickListener ( new OnClickListener ( ) { int mapFlag = 0 ; @ Override public void onClick ( View v ) { if ( mapFlag == 0 ) { googleMap . setMapType ( GoogleMap . MAP_TYPE_SATELLITE ) ; mapFlag = 1 ; } else if ( mapFlag == 1 ) { googleMap . setMapType ( GoogleMap . MAP_TYPE_NORMAL ) ; mapFlag = 0 ; } } } ) ; googleMap = ( ( MapFragment ) getFragmentManager ( ) . findFragmentById ( R . id . map ) ) . getMap ( ) ; if ( LocationMessage . locationMapView == null ) { Toast . makeText ( MapShow . this , " Poczekaj ▁ na ▁ pobranie ▁ aktualnej ▁ lokalizacji . " , Toast . LENGTH_SHORT ) . show ( ) ; } else { currentLocationMapShow = new LatLng ( LocationMessage . locationMapView . getLatitude ( ) , LocationMessage . locationMapView . getLongitude ( ) ) ; } googleMap . moveCamera ( CameraUpdateFactory . newLatLng ( currentLocationMapShow ) ) ; googleMap . animateCamera ( CameraUpdateFactory . zoomTo ( 18 ) ) ; googleMap . setOnMapLongClickListener ( new GoogleMap . OnMapLongClickListener ( ) { @ Override public void onMapLongClick ( LatLng point ) { marker = new MarkerOptions ( ) . position ( new LatLng ( point . latitude , point . longitude ) ) . title ( " New ▁ Marker " ) ; markerLatitude = point . latitude ; markerLongitude = point . longitude ; googleMap . addMarker ( marker ) ; mapShowed = " true " ; Toast . makeText ( MapShow . this , " Wskazano ▁ lokalizacje ! " , Toast . LENGTH_LONG ) . show ( ) ; final Dialog dialog = new Dialog ( MapShow . this ) ; dialog . setContentView ( R . layout . dialog ) ; dialog . setTitle ( " Wybrano ▁ lokalizacje " ) ; TextView text = ( TextView ) dialog . findViewById ( R . id . text ) ; text . setText ( " Lokalizacja ▁ docelowa ▁ jest ▁ poprawna ? " ) ; Button buttonYes = ( Button ) dialog . findViewById ( R . id . dialogButtonYes ) ; Button buttonNo = ( Button ) dialog . findViewById ( R . id . dialogButtonNo ) ; dialog . show ( ) ; buttonNo . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { googleMap . clear ( ) ; dialog . dismiss ( ) ; Toast . makeText ( MapShow . this , " Zmien ▁ lokalizacje " , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; buttonYes . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { dialog . dismiss ( ) ; finish ( ) ; } } ) ; } } ) ; }
MarcinBaranski/ArrivedSMS | @ Override public void onLocationChanged ( Location location ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onProviderEnabled ( String provider ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onProviderDisabled ( String provider ) { }
mkeijzer/push-forth | private SymbolTable ( ) { }
csviri/bodylimiter | public InvalidContentLengthException ( long maxLength , long actualLength ) { super ( " Actual ▁ content ▁ length ▁ is ▁ larger ▁ than ▁ maximum ▁ allowed . ▁ Actual : ▁ " + actualLength + " , ▁ Max : ▁ " + maxLength ) ; }
mztaylor/rice-git | @ Override protected String getBookmarkUrl ( ) { return BOOKMARK_URL ; }
mztaylor/rice-git | @ Override protected void navigate ( ) throws Exception { waitAndClickDemoLink ( ) ; waitAndClickByLinkText ( " Travel ▁ Account ▁ Type ▁ Inquiry " ) ; }
mztaylor/rice-git | @ Test @ Ignore public void testTravelAccountTypeInquiryNav ( ) throws Exception { testTravelAccountTypeInquiry ( ) ; passed ( ) ; }
mztaylor/rice-git | @ Test public void testTravelAccountTypeInquiryBookmark ( ) throws Exception { testTravelAccountTypeInquiry ( ) ; passed ( ) ; }
mztaylor/rice-git | protected void testTravelAccountTypeInquiry ( ) throws Exception { waitForElementPresentByXpath ( " // a [ contains ( text ( ) , ' IAT ' ) ] " ) ; assertTextPresent ( LabsInquiryBase . LABELED_IAT_TEXT ) ; }
dagnir/aws-sdk-java | public java . util . List < OrderableDBInstanceOption > getOrderableDBInstanceOptions ( ) { if ( orderableDBInstanceOptions == null ) { orderableDBInstanceOptions = new com . amazonaws . internal . SdkInternalList < OrderableDBInstanceOption > ( ) ; } return orderableDBInstanceOptions ; }
dagnir/aws-sdk-java | public void setOrderableDBInstanceOptions ( java . util . Collection < OrderableDBInstanceOption > orderableDBInstanceOptions ) { if ( orderableDBInstanceOptions == null ) { this . orderableDBInstanceOptions = null ; return ; } this . orderableDBInstanceOptions = new com . amazonaws . internal . SdkInternalList < OrderableDBInstanceOption > ( orderableDBInstanceOptions ) ; }
dagnir/aws-sdk-java | public DescribeOrderableDBInstanceOptionsResult withOrderableDBInstanceOptions ( OrderableDBInstanceOption ... orderableDBInstanceOptions ) { if ( this . orderableDBInstanceOptions == null ) { setOrderableDBInstanceOptions ( new com . amazonaws . internal . SdkInternalList < OrderableDBInstanceOption > ( orderableDBInstanceOptions . length ) ) ; } for ( OrderableDBInstanceOption ele : orderableDBInstanceOptions ) { this . orderableDBInstanceOptions . add ( ele ) ; } return this ; }
dagnir/aws-sdk-java | public DescribeOrderableDBInstanceOptionsResult withOrderableDBInstanceOptions ( java . util . Collection < OrderableDBInstanceOption > orderableDBInstanceOptions ) { setOrderableDBInstanceOptions ( orderableDBInstanceOptions ) ; return this ; }
dagnir/aws-sdk-java | public void setMarker ( String marker ) { this . marker = marker ; }
dagnir/aws-sdk-java | public String getMarker ( ) { return this . marker ; }
dagnir/aws-sdk-java | public DescribeOrderableDBInstanceOptionsResult withMarker ( String marker ) { setMarker ( marker ) ; return this ; }
dagnir/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getOrderableDBInstanceOptions ( ) != null ) sb . append ( " OrderableDBInstanceOptions : ▁ " ) . append ( getOrderableDBInstanceOptions ( ) ) . append ( " , " ) ; if ( getMarker ( ) != null ) sb . append ( " Marker : ▁ " ) . append ( getMarker ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dagnir/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeOrderableDBInstanceOptionsResult == false ) return false ; DescribeOrderableDBInstanceOptionsResult other = ( DescribeOrderableDBInstanceOptionsResult ) obj ; if ( other . getOrderableDBInstanceOptions ( ) == null ^ this . getOrderableDBInstanceOptions ( ) == null ) return false ; if ( other . getOrderableDBInstanceOptions ( ) != null && other . getOrderableDBInstanceOptions ( ) . equals ( this . getOrderableDBInstanceOptions ( ) ) == false ) return false ; if ( other . getMarker ( ) == null ^ this . getMarker ( ) == null ) return false ; if ( other . getMarker ( ) != null && other . getMarker ( ) . equals ( this . getMarker ( ) ) == false ) return false ; return true ; }
dagnir/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getOrderableDBInstanceOptions ( ) == null ) ? 0 : getOrderableDBInstanceOptions ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMarker ( ) == null ) ? 0 : getMarker ( ) . hashCode ( ) ) ; return hashCode ; }
dagnir/aws-sdk-java | @ Override public DescribeOrderableDBInstanceOptionsResult clone ( ) { try { return ( DescribeOrderableDBInstanceOptionsResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
phorust/BitSlayer | public Item ( float x , float y , float width , float height , int strInc , int defInc , int speedInc , int healthRegen , int healthSteal ) { super ( x , y , width , height ) ; }
andrewgaul/aws-sdk-java | public ConfigurationOptionDescription unmarshall ( StaxUnmarshallerContext context ) throws Exception { ConfigurationOptionDescription configurationOptionDescription = new ConfigurationOptionDescription ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 2 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return configurationOptionDescription ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( " Namespace " , targetDepth ) ) { configurationOptionDescription . setNamespace ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " Name " , targetDepth ) ) { configurationOptionDescription . setName ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " DefaultValue " , targetDepth ) ) { configurationOptionDescription . setDefaultValue ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " ChangeSeverity " , targetDepth ) ) { configurationOptionDescription . setChangeSeverity ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " UserDefined " , targetDepth ) ) { configurationOptionDescription . setUserDefined ( BooleanStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " ValueType " , targetDepth ) ) { configurationOptionDescription . setValueType ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " ValueOptions / member " , targetDepth ) ) { configurationOptionDescription . getValueOptions ( ) . add ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " MinValue " , targetDepth ) ) { configurationOptionDescription . setMinValue ( IntegerStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " MaxValue " , targetDepth ) ) { configurationOptionDescription . setMaxValue ( IntegerStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " MaxLength " , targetDepth ) ) { configurationOptionDescription . setMaxLength ( IntegerStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " Regex " , targetDepth ) ) { configurationOptionDescription . setRegex ( OptionRestrictionRegexStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return configurationOptionDescription ; } } } }
mschieder/jira-pvp-sso | @ Override public List < SecurityService > getServices ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLoginURL ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLoginForwardPath ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLinkLoginURL ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLogoutURL ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getOriginalURLKey ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public Authenticator getAuthenticator ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public AuthenticationContext getAuthenticationContext ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public SecurityController getController ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public RoleMapper getRoleMapper ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public ElevatedSecurityGuard getElevatedSecurityGuard ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public RememberMeService getRememberMeService ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public RedirectPolicy getRedirectPolicy ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public < T extends Interceptor > List < T > getInterceptors ( Class < T > desiredInterceptorClass ) { return null ; }
mschieder/jira-pvp-sso | @ Override public void destroy ( ) { }
mschieder/jira-pvp-sso | @ Override public String getLoginCookiePath ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLoginCookieKey ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getWebsudoRequestKey ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public boolean isInsecureCookie ( ) { return false ; }
mschieder/jira-pvp-sso | @ Override public int getAutoLoginCookieAge ( ) { return 0 ; }
mschieder/jira-pvp-sso | @ Override public String getCookieEncoding ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getAuthType ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public boolean isInvalidateSessionOnLogin ( ) { return false ; }
mschieder/jira-pvp-sso | @ Override public boolean isInvalidateSessionOnWebsudo ( ) { return false ; }
mschieder/jira-pvp-sso | @ Override public List < String > getInvalidateSessionExcludeList ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public List < String > getInvalidateWebsudoSessionExcludeList ( ) { return null ; }
pedrodonte/modulo-base | @ Override public VoUserRol nuevoRegistro ( VoUserRol registro ) throws ErrorDelSistemaException { try { DTORolDeUsuario dto = helperMapper . toDTO ( registro ) ; sgTbUserRolDAO . save ( dto ) ; } catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; } catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; } return registro ; }
pedrodonte/modulo-base | @ Override public VoUserRol actualizarRegistro ( VoUserRol registro ) throws ErrorDelSistemaException { try { DTORolDeUsuario dto = helperMapper . toDTO ( registro ) ; sgTbUserRolDAO . update ( dto ) ; } catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; } catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; } return registro ; }
pedrodonte/modulo-base | @ Override public void eliminarRegistro ( VoUserRol registro ) throws ErrorDelSistemaException { throw new UnsupportedOperationException ( " Metodo ▁ Sin ▁ Implementar " ) ; }
pedrodonte/modulo-base | for ( DTORolDeUsuario dto : sgTbUserRolDAO . findAll ( ) ) { VoUserRol vo = helperMapper . toVO ( dto ) ; registros . add ( vo ) ; }
pedrodonte/modulo-base | catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; }
pedrodonte/modulo-base | catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; }
pedrodonte/modulo-base | if ( dto == null ) { throw new RegistrosNoEncontradosException ( " No ▁ se ▁ encuentran ▁ registros ▁ para ▁ el ▁ parametro ▁ de ▁ entrada : " + id ) ; }
pedrodonte/modulo-base | catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; }
pedrodonte/modulo-base | catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; }
jssenyange/traccar | public Event ( String type , Position position ) { setType ( type ) ; setPositionId ( position . getId ( ) ) ; setDeviceId ( position . getDeviceId ( ) ) ; eventTime = position . getDeviceTime ( ) ; }
jssenyange/traccar | public Event ( String type , long deviceId ) { setType ( type ) ; setDeviceId ( deviceId ) ; eventTime = new Date ( ) ; }
jssenyange/traccar | public Event ( ) { }
jssenyange/traccar | public Date getEventTime ( ) { return eventTime ; }
jssenyange/traccar | public void setEventTime ( Date eventTime ) { this . eventTime = eventTime ; }
jssenyange/traccar | public long getPositionId ( ) { return positionId ; }
jssenyange/traccar | public void setPositionId ( long positionId ) { this . positionId = positionId ; }
jssenyange/traccar | public long getGeofenceId ( ) { return geofenceId ; }
jssenyange/traccar | public void setGeofenceId ( long geofenceId ) { this . geofenceId = geofenceId ; }
jssenyange/traccar | public long getMaintenanceId ( ) { return maintenanceId ; }
jssenyange/traccar | public void setMaintenanceId ( long maintenanceId ) { this . maintenanceId = maintenanceId ; }
Nygar/SdosExample | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_layout ) ; new Handler ( ) . postDelayed ( ( ) -> navigator . navigateToLogin ( this ) , 2000 ) ; }
Jon6193/Android-MVVM | @ Override public void onCreate ( ) { super . onCreate ( ) ; if ( LeakCanary . isInAnalyzerProcess ( this ) ) { return ; } LeakCanary . install ( this ) ; Stetho . initializeWithDefaults ( this ) ; if ( BuildConfig . DEBUG ) { Timber . plant ( new Timber . DebugTree ( ) ) ; Timber . plant ( new StethoTree ( ) ) ; } component = DaggerApplicationComponent . builder ( ) . applicationModule ( new ApplicationModule ( this ) ) . build ( ) ; component . inject ( this ) ; }
Jon6193/Android-MVVM | public AppGraph getComponent ( ) { return component ; }
perezd/bazel | private LinkOptions ( ImmutableList < String > linkOptions , Object symbolForEquality ) { this . linkOptions = Preconditions . checkNotNull ( linkOptions ) ; this . symbolForEquality = Preconditions . checkNotNull ( symbolForEquality ) ; }
perezd/bazel | public ImmutableList < String > get ( ) { return linkOptions ; }
perezd/bazel | @ Override public int hashCode ( ) { return symbolForEquality . hashCode ( ) ; }
perezd/bazel | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LinkOptions ) ) { return false ; } LinkOptions that = ( LinkOptions ) obj ; if ( ! this . symbolForEquality . equals ( that . symbolForEquality ) ) { return false ; } if ( this . linkOptions . equals ( that . linkOptions ) ) { return true ; } BugReport . sendBugReport ( new IllegalStateException ( " Unexpected ▁ inequality ▁ with ▁ equal ▁ symbols : ▁ " + this + " , ▁ " + that ) ) ; return false ; }
perezd/bazel | @ Override public String toString ( ) { return ' [ ' + Joiner . on ( " , " ) . join ( linkOptions ) + " ] ▁ ( owner : ▁ " + symbolForEquality ; }
perezd/bazel | public Artifact getArtifact ( ) { return artifact ; }
perezd/bazel | @ Override public Artifact getArtifactForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return artifact ; }
perezd/bazel | public NestedSet < Artifact > getDeclaredIncludeSrcs ( ) { return declaredIncludeSrcs ; }
perezd/bazel | @ Override public Depset getDeclaredIncludeSrcsForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return Depset . of ( Artifact . TYPE , getDeclaredIncludeSrcs ( ) ) ; }
perezd/bazel | @ Override public int hashCode ( ) { return artifact . hashCode ( ) ; }
perezd/bazel | @ Override public final boolean isImmutable ( ) { return true ; }
perezd/bazel | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof Linkstamp ) ) { return false ; } Linkstamp other = ( Linkstamp ) obj ; return artifact . equals ( other . artifact ) && Arrays . equals ( this . nestedDigest , other . nestedDigest ) ; }
perezd/bazel | public LinkerInput ( Label owner , ImmutableList < LibraryToLink > libraries , ImmutableList < LinkOptions > userLinkFlags , ImmutableList < Artifact > nonCodeInputs , ImmutableList < Linkstamp > linkstamps ) { this . owner = owner ; this . libraries = libraries ; this . userLinkFlags = userLinkFlags ; this . nonCodeInputs = nonCodeInputs ; this . linkstamps = linkstamps ; }
perezd/bazel | @ Override public boolean isImmutable ( ) { return true ; }
perezd/bazel | @ Override public Label getStarlarkOwner ( ) throws EvalException { if ( owner == null ) { throw Starlark . errorf ( " Owner ▁ is ▁ null . ▁ This ▁ means ▁ that ▁ some ▁ target ▁ upstream ▁ is ▁ of ▁ a ▁ rule ▁ type ▁ that ▁ uses ▁ the " + " ▁ old ▁ API ▁ of ▁ create _ linking _ context " ) ; } return owner ; }
perezd/bazel | public Label getOwner ( ) { return owner ; }
perezd/bazel | public List < LibraryToLink > getLibraries ( ) { return libraries ; }
perezd/bazel | @ Override public Sequence < LibraryToLink > getStarlarkLibrariesToLink ( StarlarkSemantics semantics ) { return StarlarkList . immutableCopyOf ( getLibraries ( ) ) ; }
perezd/bazel | public List < LinkOptions > getUserLinkFlags ( ) { return userLinkFlags ; }
perezd/bazel | @ Override public Sequence < String > getStarlarkUserLinkFlags ( ) { return StarlarkList . immutableCopyOf ( getUserLinkFlags ( ) . stream ( ) . map ( LinkOptions :: get ) . flatMap ( Collection :: stream ) . collect ( ImmutableList . toImmutableList ( ) ) ) ; }
perezd/bazel | public List < Artifact > getNonCodeInputs ( ) { return nonCodeInputs ; }
perezd/bazel | @ Override public Sequence < Artifact > getStarlarkNonCodeInputs ( ) { return StarlarkList . immutableCopyOf ( getNonCodeInputs ( ) ) ; }
perezd/bazel | public List < Linkstamp > getLinkstamps ( ) { return linkstamps ; }
perezd/bazel | @ StarlarkMethod ( name = " linkstamps " , documented = false , structField = true ) public Sequence < Linkstamp > getLinkstampsForStarlark ( ) { return StarlarkList . immutableCopyOf ( getLinkstamps ( ) ) ; }
perezd/bazel | @ Override public void debugPrint ( Printer printer ) { printer . append ( " < LinkerInput ( owner = " ) ; owner . debugPrint ( printer ) ; printer . append ( " , ▁ libraries = [ " ) ; for ( LibraryToLink libraryToLink : libraries ) { libraryToLink . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] , ▁ userLinkFlags = [ " ) ; printer . append ( Joiner . on ( " , ▁ " ) . join ( userLinkFlags ) ) ; printer . append ( " ] , ▁ nonCodeInputs = [ " ) ; for ( Artifact nonCodeInput : nonCodeInputs ) { nonCodeInput . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] ) > " ) ; }
perezd/bazel | public Builder addLibrary ( LibraryToLink library ) { this . libraries . add ( library ) ; return this ; }
perezd/bazel | public Builder addLibraries ( List < LibraryToLink > libraries ) { this . libraries . addAll ( libraries ) ; return this ; }
perezd/bazel | public Builder addUserLinkFlags ( List < LinkOptions > userLinkFlags ) { this . userLinkFlags . addAll ( userLinkFlags ) ; return this ; }
perezd/bazel | public Builder addLinkstamps ( List < Linkstamp > linkstamps ) { this . linkstamps . addAll ( linkstamps ) ; return this ; }
perezd/bazel | public Builder addNonCodeInputs ( List < Artifact > nonCodeInputs ) { this . nonCodeInputs . addAll ( nonCodeInputs ) ; return this ; }
perezd/bazel | public Builder setOwner ( Label owner ) { this . owner = owner ; return this ; }
perezd/bazel | public LinkerInput build ( ) { return new LinkerInput ( owner , libraries . build ( ) , userLinkFlags . build ( ) , nonCodeInputs . build ( ) , linkstamps . build ( ) ) ; }
perezd/bazel | @ Override public boolean equals ( Object otherObject ) { if ( ! ( otherObject instanceof LinkerInput ) ) { return false ; } LinkerInput other = ( LinkerInput ) otherObject ; if ( this == other ) { return true ; } return Objects . equal ( this . owner , other . owner ) && this . libraries . equals ( other . libraries ) && this . userLinkFlags . equals ( other . userLinkFlags ) && this . linkstamps . equals ( other . linkstamps ) && this . nonCodeInputs . equals ( other . nonCodeInputs ) ; }
perezd/bazel | @ Override public int hashCode ( ) { return Objects . hashCode ( libraries . hashCode ( ) , userLinkFlags . hashCode ( ) , linkstamps . hashCode ( ) , nonCodeInputs . hashCode ( ) ) ; }
perezd/bazel | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " userLinkFlags " , userLinkFlags ) . add ( " linkstamps " , linkstamps ) . add ( " libraries " , libraries ) . add ( " nonCodeInputs " , nonCodeInputs ) . toString ( ) ; }
perezd/bazel | @ Override public void debugPrint ( Printer printer ) { printer . append ( " < CcLinkingContext ( [ " ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { linkerInput . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] ) > " ) ; }
perezd/bazel | public CcLinkingContext ( NestedSet < LinkerInput > linkerInputs , @ Nullable ExtraLinkTimeLibraries extraLinkTimeLibraries ) { this . linkerInputs = linkerInputs ; this . extraLinkTimeLibraries = extraLinkTimeLibraries ; }
perezd/bazel | public List < Artifact > getStaticModeParamsForExecutableLibraries ( ) { ImmutableList . Builder < Artifact > libraryListBuilder = ImmutableList . builder ( ) ; for ( LibraryToLink libraryToLink : getLibraries ( ) . toList ( ) ) { if ( libraryToLink . getStaticLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getStaticLibrary ( ) ) ; } else if ( libraryToLink . getPicStaticLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getPicStaticLibrary ( ) ) ; } else if ( libraryToLink . getInterfaceLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getInterfaceLibrary ( ) ) ; } else { libraryListBuilder . add ( libraryToLink . getDynamicLibrary ( ) ) ; } } return libraryListBuilder . build ( ) ; }
perezd/bazel | public List < Artifact > getStaticModeParamsForDynamicLibraryLibraries ( ) { ImmutableList . Builder < Artifact > artifactListBuilder = ImmutableList . builder ( ) ; for ( LibraryToLink library : getLibraries ( ) . toList ( ) ) { if ( library . getPicStaticLibrary ( ) != null ) { artifactListBuilder . add ( library . getPicStaticLibrary ( ) ) ; } else if ( library . getStaticLibrary ( ) != null ) { artifactListBuilder . add ( library . getStaticLibrary ( ) ) ; } else if ( library . getInterfaceLibrary ( ) != null ) { artifactListBuilder . add ( library . getInterfaceLibrary ( ) ) ; } else { artifactListBuilder . add ( library . getDynamicLibrary ( ) ) ; } } return artifactListBuilder . build ( ) ; }
perezd/bazel | public List < Artifact > getDynamicLibrariesForRuntime ( boolean linkingStatically ) { return LibraryToLink . getDynamicLibrariesForRuntime ( linkingStatically , getLibraries ( ) . toList ( ) ) ; }
perezd/bazel | public NestedSet < LibraryToLink > getLibraries ( ) { NestedSetBuilder < LibraryToLink > libraries = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { libraries . addAll ( linkerInput . libraries ) ; } return libraries . build ( ) ; }
perezd/bazel | public NestedSet < LinkerInput > getLinkerInputs ( ) { return linkerInputs ; }
perezd/bazel | @ Override public Depset getStarlarkLinkerInputs ( ) { return Depset . of ( LinkerInput . TYPE , linkerInputs ) ; }
perezd/bazel | @ Override public Sequence < String > getStarlarkUserLinkFlags ( ) { return StarlarkList . immutableCopyOf ( getFlattenedUserLinkFlags ( ) ) ; }
perezd/bazel | @ Override public Object getStarlarkLibrariesToLink ( StarlarkSemantics semantics ) { if ( semantics . getBool ( BuildLanguageOptions . INCOMPATIBLE_DEPSET_FOR_LIBRARIES_TO_LINK_GETTER ) ) { return Depset . of ( LibraryToLink . TYPE , getLibraries ( ) ) ; } else { return StarlarkList . immutableCopyOf ( getLibraries ( ) . toList ( ) ) ; } }
perezd/bazel | @ Override public Depset getStarlarkNonCodeInputs ( ) { return Depset . of ( Artifact . TYPE , getNonCodeInputs ( ) ) ; }
perezd/bazel | @ Override public ExtraLinkTimeLibraryApi getGoLinkCArchiveForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; ExtraLinkTimeLibrary goLinkCArchive = null ; if ( extraLinkTimeLibraries != null ) { for ( ExtraLinkTimeLibrary extraLibrary : extraLinkTimeLibraries . getExtraLibraries ( ) ) { if ( goLinkCArchive != null ) { throw new EvalException ( " multiple ▁ GoLinkCArchive ▁ entries ▁ in ▁ go _ link _ c _ archive " ) ; } goLinkCArchive = extraLibrary ; } } return goLinkCArchive ; }
perezd/bazel | public NestedSet < LinkOptions > getUserLinkFlags ( ) { NestedSetBuilder < LinkOptions > userLinkFlags = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { userLinkFlags . addAll ( linkerInput . getUserLinkFlags ( ) ) ; } return userLinkFlags . build ( ) ; }
perezd/bazel | public ImmutableList < String > getFlattenedUserLinkFlags ( ) { return getUserLinkFlags ( ) . toList ( ) . stream ( ) . map ( LinkOptions :: get ) . flatMap ( Collection :: stream ) . collect ( ImmutableList . toImmutableList ( ) ) ; }
perezd/bazel | public NestedSet < Linkstamp > getLinkstamps ( ) { NestedSetBuilder < Linkstamp > linkstamps = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { linkstamps . addAll ( linkerInput . getLinkstamps ( ) ) ; } return linkstamps . build ( ) ; }
perezd/bazel | @ Override public Depset getLinkstampsForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return Depset . of ( Linkstamp . TYPE , getLinkstamps ( ) ) ; }
perezd/bazel | public NestedSet < Artifact > getNonCodeInputs ( ) { NestedSetBuilder < Artifact > nonCodeInputs = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { nonCodeInputs . addAll ( linkerInput . getNonCodeInputs ( ) ) ; } return nonCodeInputs . build ( ) ; }
perezd/bazel | public ExtraLinkTimeLibraries getExtraLinkTimeLibraries ( ) { return extraLinkTimeLibraries ; }
perezd/bazel | @ Override public ExtraLinkTimeLibraries getExtraLinkTimeLibrariesForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return getExtraLinkTimeLibraries ( ) ; }
perezd/bazel | public Builder setOwner ( Label owner ) { linkerInputBuilder . setOwner ( owner ) ; return this ; }
perezd/bazel | public Builder addLibrary ( LibraryToLink library ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLibrary ( library ) ; return this ; }
perezd/bazel | public Builder addLibraries ( List < LibraryToLink > libraries ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLibraries ( libraries ) ; return this ; }
perezd/bazel | public Builder addUserLinkFlags ( List < LinkOptions > userLinkFlags ) { hasDirectLinkerInput = true ; linkerInputBuilder . addUserLinkFlags ( userLinkFlags ) ; return this ; }
perezd/bazel | public Builder addLinkstamps ( List < Linkstamp > linkstamps ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLinkstamps ( linkstamps ) ; return this ; }
perezd/bazel | Builder addNonCodeInputs ( List < Artifact > nonCodeInputs ) { hasDirectLinkerInput = true ; linkerInputBuilder . addNonCodeInputs ( nonCodeInputs ) ; return this ; }
perezd/bazel | public Builder addTransitiveLinkerInputs ( NestedSet < LinkerInput > linkerInputs ) { this . linkerInputs . addTransitive ( linkerInputs ) ; return this ; }
perezd/bazel | public Builder setExtraLinkTimeLibraries ( ExtraLinkTimeLibraries extraLinkTimeLibraries ) { Preconditions . checkState ( this . extraLinkTimeLibraries == null ) ; this . extraLinkTimeLibraries = extraLinkTimeLibraries ; return this ; }
perezd/bazel | public CcLinkingContext build ( ) { if ( hasDirectLinkerInput ) { linkerInputs . add ( linkerInputBuilder . build ( ) ) ; } return new CcLinkingContext ( linkerInputs . build ( ) , extraLinkTimeLibraries ) ; }
perezd/bazel | @ Override public boolean equals ( Object otherObject ) { if ( ! ( otherObject instanceof CcLinkingContext ) ) { return false ; } CcLinkingContext other = ( CcLinkingContext ) otherObject ; if ( this == other ) { return true ; } return this . linkerInputs . shallowEquals ( other . linkerInputs ) ; }
perezd/bazel | @ Override public int hashCode ( ) { return linkerInputs . shallowHashCode ( ) ; }
perezd/bazel | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " linkerInputs " , linkerInputs ) . toString ( ) ; }
lvweiwolf/poi-3.16 | public List < CTAdjPoint2D > getPt ( ) { if ( pt == null ) { pt = new ArrayList < CTAdjPoint2D > ( ) ; } return this . pt ; }
lvweiwolf/poi-3.16 | public boolean isSetPt ( ) { return ( ( this . pt != null ) && ( ! this . pt . isEmpty ( ) ) ) ; }
lvweiwolf/poi-3.16 | public void unsetPt ( ) { this . pt = null ; }
googleads/googleads-java-lib | public List < ApiError > getErrors ( ) { if ( errors == null ) { errors = new ArrayList < ApiError > ( ) ; } return this . errors ; }
jatin9896/incubator-carbondata | EscapeSequences ( String name , char escapeChar ) { this . name = name ; this . escapeChar = escapeChar ; }
jatin9896/incubator-carbondata | public String getName ( ) { return this . name ; }
jatin9896/incubator-carbondata | public String getEscapeChar ( ) { return String . valueOf ( this . escapeChar ) ; }
viktozhu/java-beginners | public Circle ( int x1 , int x2 , int radius ) { this . x1 = x1 ; this . x2 = x2 ; this . radius = radius ; }
viktozhu/java-beginners | @ Override public double getSquare ( ) { return Math . PI * radius * radius ; }
viktozhu/java-beginners | @ Override public double getPerimeter ( ) { return 2 * Math . PI * radius ; }
snorochevskiy/JTranslate | @ RequestMapping ( value = " / all " , method = RequestMethod . GET ) public Set < TranslationProjectDto > listProjects ( ) { Set < TranslationProjectDto > projects = new HashSet < > ( ) ; for ( TranslationProjectEntity p : translationsDao . getAllTranslationProjects ( ) ) { projects . add ( TranslationProjectMapper . map ( p ) ) ; } return projects ; }
snorochevskiy/JTranslate | / subprojects " , method = RequestMethod . GET ) public Set < TranslationSubprojectDto > listSubprojects ( @ PathVariable ( " id " ) Long projectId ) { Set < TranslationSubprojectDto > subprojects = new HashSet < > ( ) ; for ( TranslationSubprojectEntity p : translationsDao . getAllSubprojects ( projectId ) ) { subprojects . add ( TranslationSubprojectMapper . map ( p ) ) ; } return subprojects ; }
snorochevskiy/JTranslate | @ RequestMapping ( value = " / create " , method = RequestMethod . POST ) public void createProject ( @ RequestBody TranslationProjectDto projectDto ) { translationsDao . createProject ( TranslationProjectMapper . map ( projectDto ) ) ; }
snorochevskiy/JTranslate | / create - subproject " , method = RequestMethod . POST ) public void createSubroject ( @ RequestBody TranslationSubprojectDto subprojectDto ) { translationsDao . createSubproject ( TranslationSubprojectMapper . map ( subprojectDto ) ) ; }
johnaoahra80/hibernate-semantic-query | public SqmUpdateStatementImpl ( SqmRoot entityFromElement ) { this . entityFromElement = entityFromElement ; }
johnaoahra80/hibernate-semantic-query | @ Override public SqmRoot getEntityFromElement ( ) { return entityFromElement ; }
johnaoahra80/hibernate-semantic-query | @ Override public SqmSetClause getSetClause ( ) { return setClause ; }
johnaoahra80/hibernate-semantic-query | @ Override public SqmWhereClause getWhereClause ( ) { return whereClause ; }
johnaoahra80/hibernate-semantic-query | @ Override public String toString ( ) { return String . format ( Locale . ROOT , " update ▁ % s ▁ % s ▁ % s " , entityFromElement , " [ no ▁ set ▁ clause ] " , whereClause ) ; }
johnaoahra80/hibernate-semantic-query | @ Override public < T > T accept ( SemanticQueryWalker < T > walker ) { return walker . visitUpdateStatement ( this ) ; }
StephanEwen/incubator-flink | @ Override protected TypeSerializer < Boolean > createSerializer ( ) { return new BooleanSerializer ( ) ; }
StephanEwen/incubator-flink | @ Override protected int getLength ( ) { return 1 ; }
StephanEwen/incubator-flink | @ Override protected Class < Boolean > getTypeClass ( ) { return Boolean . class ; }
StephanEwen/incubator-flink | @ Override protected Boolean [ ] getTestData ( ) { Random rnd = new Random ( 874597969123412341L ) ; return new Boolean [ ] { Boolean . valueOf ( true ) , Boolean . valueOf ( false ) , Boolean . valueOf ( rnd . nextBoolean ( ) ) , Boolean . valueOf ( rnd . nextBoolean ( ) ) , Boolean . valueOf ( rnd . nextBoolean ( ) ) } ; }
aws/aws-sdk-java | public AddApplicationOutputRequestProtocolMarshaller ( com . amazonaws . protocol . json . SdkJsonProtocolFactory protocolFactory ) { this . protocolFactory = protocolFactory ; }
aws/aws-sdk-java | public Request < AddApplicationOutputRequest > marshall ( AddApplicationOutputRequest addApplicationOutputRequest ) { if ( addApplicationOutputRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { final ProtocolRequestMarshaller < AddApplicationOutputRequest > protocolMarshaller = protocolFactory . createProtocolMarshaller ( SDK_OPERATION_BINDING , addApplicationOutputRequest ) ; protocolMarshaller . startMarshalling ( ) ; AddApplicationOutputRequestMarshaller . getInstance ( ) . marshall ( addApplicationOutputRequest , protocolMarshaller ) ; return protocolMarshaller . finishMarshalling ( ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
ninqing/tddl | @ Override protected Boolean computeInner ( Object [ ] args , ExecutionContext ec ) { Object arg = args [ 0 ] ; return arg == null ; }
ninqing/tddl | @ Override public String [ ] getFunctionNames ( ) { return new String [ ] { " IS ▁ NULL " } ; }
narfman0/freeboot | @ Override public void receive ( PlayerState message , Socket origin ) { for ( NetBeing netBeing : message . getPlayersList ( ) ) { UUID uuid = UUIDConvert . convert ( netBeing . getUuid ( ) ) ; if ( worldManager . getPlayer ( ) != null && uuid . equals ( worldManager . getPlayer ( ) . getUuid ( ) ) ) break ; Player remotePlayer = worldManager . getRemotePlayer ( uuid ) ; if ( remotePlayer == null ) { remotePlayer = new Player ( netBeing ) ; worldManager . getRemotePlayers ( ) . put ( remotePlayer . getUuid ( ) , remotePlayer ) ; if ( remotePlayer . getHp ( ) > 0 ) remotePlayer . respawn ( worldManager , netBeing . getPosX ( ) , netBeing . getPosY ( ) ) ; Log . log ( " GameplayScreen . receive " , " Received ▁ first ▁ player ▁ update : ▁ " + netBeing . getName ( ) ) ; } else if ( remotePlayer . getPosition ( ) != null ) remotePlayer . updateFromMessage ( worldManager , netBeing ) ; } }
narfman0/freeboot | @ Override public Class < ? extends Message > getSubscription ( ) { return PlayerState . class ; }
sekys/ivis | public DrawingJPanel ( Dimension size ) { this . size = size ; imageBuffer = new BufferedImage ( size . width , size . height , BufferedImage . TYPE_INT_ARGB ) ; graphics = imageBuffer . createGraphics ( ) ; }
sekys/ivis | public Dimension getPreferredSize ( ) { return size ; }
sekys/ivis | public void paintComponent ( Graphics graphic ) { super . paintComponent ( graphic ) ; ( ( Graphics2D ) graphic ) . drawImage ( imageBuffer , null , null ) ; }
sekys/ivis | public void fill ( int color ) { int x , y ; for ( x = 0 ; x < size . width ; x ++ ) { for ( y = 0 ; y < size . height ; y ++ ) { imageBuffer . setRGB ( x , y , color ) ; } } }
sekys/ivis | public void drawString ( String txt , Color color , float x , float y ) { graphics . setPaint ( color ) ; graphics . setFont ( new Font ( " Tahoma " , Font . BOLD , 12 ) ) ; graphics . drawString ( txt , ( int ) ( x * size . width ) , ( int ) ( y * size . height ) ) ; }
sekys/ivis | public void putPixel ( int x , int y , int rgb ) { imageBuffer . setRGB ( x , y , rgb ) ; }
sekys/ivis | public Graphics2D getGraphic ( ) { return graphics ; }
sekys/ivis | public void resize ( ) { throw new UnsupportedOperationException ( ) ; }
VivianLuwenHuangfu/processors | public Trie ( ) { root = new TrieNode ( ' ▁ ' , null ) ; sb = new StringBuilder ( ) ; }
VivianLuwenHuangfu/processors | public TrieNode addValue ( String value , TrieSymbolTable table , int code ) throws SymbolException { TrieNode node = root ; final char [ ] chars = value . toCharArray ( ) ; for ( int i = chars . length - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) { node = node . getOrAddChild ( true , chars [ i ] , table , code ) ; } else { node = node . getOrAddChild ( false , chars [ i ] , table , code ) ; } } return node ; }
VivianLuwenHuangfu/processors | public TrieNode addValue ( StringBuilder symbol , TrieSymbolTable table , int code ) throws SymbolException { TrieNode node = root ; for ( int i = symbol . length ( ) - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) { node = node . getOrAddChild ( true , symbol . charAt ( i ) , table , code ) ; } else { node = node . getOrAddChild ( false , symbol . charAt ( i ) , table , code ) ; } } return node ; }
VivianLuwenHuangfu/processors | public String getValue ( TrieNode node , TrieSymbolTable table ) { sb . setLength ( 0 ) ; TrieNode tmp = node ; while ( tmp != root ) { sb . append ( tmp . getCharacter ( ) ) ; tmp = tmp . getParent ( ) ; } return sb . toString ( ) ; }
VivianLuwenHuangfu/processors | public Integer getEntry ( String value , TrieSymbolTable table ) { TrieNode node = root ; final char [ ] chars = value . toCharArray ( ) ; int i = chars . length - 1 ; for ( ; i >= 0 && node != null ; i -- ) { node = node . getChild ( chars [ i ] ) ; } if ( i < 0 && node != null ) { return node . getEntry ( table ) ; } return null ; }
VivianLuwenHuangfu/processors | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; return ( ( root == null ) ? ( ( Trie ) obj ) . root == null : root . equals ( ( ( Trie ) obj ) . root ) ) ; }
VivianLuwenHuangfu/processors | public int hashCode ( ) { return 31 * 7 + ( null == root ? 0 : root . hashCode ( ) ) ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( properName == null ) ? 0 : properName . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Animal other = ( Animal ) obj ; if ( properName == null ) { if ( other . properName != null ) return false ; } else if ( ! properName . equals ( other . properName ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( animals == null ) ? 0 : animals . hashCode ( ) ) ; result = prime * result + ( ( largestAnimal == null ) ? 0 : largestAnimal . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Zoo other = ( Zoo ) obj ; if ( animals == null ) { if ( other . animals != null ) return false ; } else if ( ! animals . equals ( other . animals ) ) return false ; if ( largestAnimal == null ) { if ( other . largestAnimal != null ) return false ; } else if ( ! largestAnimal . equals ( other . largestAnimal ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + Float . floatToIntBits ( normalBodyTemperature ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Mammal other = ( Mammal ) obj ; if ( Float . floatToIntBits ( normalBodyTemperature ) != Float . floatToIntBits ( other . normalBodyTemperature ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someBearField == null ) ? 0 : someBearField . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Bear other = ( Bear ) obj ; if ( someBearField == null ) { if ( other . someBearField != null ) return false ; } else if ( ! someBearField . equals ( other . someBearField ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someTigerField == null ) ? 0 : someTigerField . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Tiger other = ( Tiger ) obj ; if ( someTigerField == null ) { if ( other . someTigerField != null ) return false ; } else if ( ! someTigerField . equals ( other . someTigerField ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someElephantField == null ) ? 0 : someElephantField . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Elephant other = ( Elephant ) obj ; if ( someElephantField == null ) { if ( other . someElephantField != null ) return false ; } else if ( ! someElephantField . equals ( other . someElephantField ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public void testProtobuf ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo p = filledZoo ( ) ; byte [ ] data = ProtobufIOUtil . toByteArray ( p , schema , buf ( ) ) ; Zoo p2 = new Zoo ( ) ; ProtobufIOUtil . mergeFrom ( data , p2 , schema ) ; assertEquals ( p , p2 ) ; List < Zoo > list = new ArrayList < Zoo > ( ) ; list . add ( p ) ; list . add ( p2 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ProtobufIOUtil . writeListTo ( out , list , schema , buf ( ) ) ; byte [ ] listData = out . toByteArray ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( listData ) ; List < Zoo > parsedList = ProtobufIOUtil . parseListFrom ( in , schema ) ; assertEquals ( list , parsedList ) ; }
dyu/protostuff-1.0.x | public void testProtostuff ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo p = filledZoo ( ) ; byte [ ] data = ProtostuffIOUtil . toByteArray ( p , schema , buf ( ) ) ; Zoo p2 = new Zoo ( ) ; ProtostuffIOUtil . mergeFrom ( data , 0 , data . length , p2 , schema ) ; assertEquals ( p , p2 ) ; List < Zoo > list = new ArrayList < Zoo > ( ) ; list . add ( p ) ; list . add ( p2 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ProtostuffIOUtil . writeListTo ( out , list , schema , buf ( ) ) ; byte [ ] listData = out . toByteArray ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( listData ) ; List < Zoo > parsedList = ProtostuffIOUtil . parseListFrom ( in , schema ) ; assertEquals ( list , parsedList ) ; }
dyu/protostuff-1.0.x | public void testPipe ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Pipe . Schema < Zoo > pipeSchema = ( ( MappedSchema < Zoo > ) schema ) . pipeSchema ; Zoo p = filledZoo ( ) ; ProtostuffPipeTest . roundTrip ( p , schema , pipeSchema ) ; }
dyu/protostuff-1.0.x | public void testMerge ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; final String properName = " elephant " ; Elephant elephant = new Elephant ( ) ; elephant . someElephantField = " elephantField " ; elephant . normalBodyTemperature = 25f ; elephant . properName = properName ; Zoo zoo = new Zoo ( ) ; zoo . largestAnimal = elephant ; Elephant sickElephant = new Elephant ( ) ; sickElephant . normalBodyTemperature = 50f ; sickElephant . someElephantField = " sickElephantField " ; Zoo mergeZoo = new Zoo ( ) ; mergeZoo . largestAnimal = sickElephant ; byte [ ] data = ProtostuffIOUtil . toByteArray ( mergeZoo , schema , buf ( ) ) ; ProtostuffIOUtil . mergeFrom ( data , zoo , schema ) ; assertTrue ( zoo . largestAnimal == elephant ) ; assertTrue ( elephant . normalBodyTemperature == 50f ) ; assertEquals ( elephant . someElephantField , " sickElephantField " ) ; assertTrue ( properName == elephant . properName ) ; }
dyu/protostuff-1.0.x | public void testOverwrite ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo zoo = new Zoo ( ) ; zoo . largestAnimal = filledBear ( ) ; Zoo overwriteZoo = new Zoo ( ) ; overwriteZoo . largestAnimal = filledTiger ( ) ; byte [ ] data = ProtostuffIOUtil . toByteArray ( overwriteZoo , schema , buf ( ) ) ; ProtostuffIOUtil . mergeFrom ( data , zoo , schema ) ; assertTrue ( zoo . largestAnimal instanceof Tiger ) ; }
statsbiblioteket/summa | public FilterPump ( Configuration configuration ) throws IOException { classLog . trace ( " Constructing ▁ FilterPump ▁ with ▁ config ▁ class ▁ " + configuration . getClass ( ) ) ; chainName = configuration . getString ( Filter . CONF_FILTER_NAME , chainName ) ; classLog . trace ( " Creating ▁ chain ▁ log ▁ for ▁ chain : ▁ " + chainName ) ; log = LogFactory . getLog ( FilterPump . class . getName ( ) + " # " + chainName ) ; log . info ( " Constructing ▁ FilterPump ▁ for ▁ chain ▁ ' " + chainName + " ' " ) ; sequence = new FilterSequence ( configuration ) ; everyStatus = configuration . getInt ( CONF_STATUS_EVERY , DEFAULT_STATUS_EVERY ) ; log . debug ( " Constructed ▁ filter ▁ sequence " ) ; }
statsbiblioteket/summa | ) protected void runMethod ( ) { log . debug ( " Running ▁ FilterChain ▁ ' " + chainName + " ' " ) ; Profiler profiler = new Profiler ( ) ; profiler . setBpsSpan ( 1000 ) ; Payload pumped ; try { long startTime ; while ( getStatus ( ) == STATUS . running ) { startTime = System . nanoTime ( ) ; if ( ! sequence . hasNext ( ) ) { profiler . beat ( ) ; log . info ( String . format ( " Finished ▁ pumping ▁ ' % s ' ▁ % d ▁ times ▁ in ▁ % s , ▁ overall ▁ average ▁ speed ▁ was ▁ % s ▁ pumps / sec " , chainName , profiler . getBeats ( ) , profiler . getSpendTime ( ) , profiler . getBps ( false ) ) ) ; break ; } pumped = sequence . next ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " Pump ▁ received ▁ ▁ " + ( pumped . getRecord ( ) == null ? pumped : pumped . getRecord ( ) ) ) ; } profiler . beat ( ) ; logStatistics ( profiler , startTime , pumped ) ; } } catch ( Throwable t ) { String error = " Throwable ▁ caught ▁ running ▁ FilterPump " ; log . error ( error , t ) ; setError ( error , t ) ; } log . debug ( " Finished ▁ run ▁ with ▁ status ▁ " + getStatus ( ) ) ; if ( STATUS . error == getStatus ( ) ) { log . warn ( " The ▁ run ▁ was ▁ finished ▁ with ▁ error ▁ ' " + getErrorMessage ( ) , getErrorCause ( ) ) ; } else { log . debug ( " No ▁ error ▁ in ▁ run , ▁ calling ▁ close ( true ) " ) ; } close ( true ) ; }
statsbiblioteket/summa | private void logStatistics ( Profiler profiler , long startTime , Payload last ) { if ( ! ( log . isTraceEnabled ( ) || ( log . isDebugEnabled ( ) && profiler . getBeats ( ) % DEBUG_FEEDBACK == 0 ) || ( log . isInfoEnabled ( ) && profiler . getBeats ( ) % everyStatus == 0 ) ) ) { return ; } String ms = Double . toString ( ( System . nanoTime ( ) - startTime ) / 1000000.0 ) ; String currentAverage = profiler . getBps ( true ) < 10 ? Double . toString ( profiler . getBps ( true ) ) : Integer . toString ( ( int ) profiler . getBps ( true ) ) ; String overallAverage = profiler . getBps ( false ) < 10 ? Double . toString ( profiler . getBps ( false ) ) : Integer . toString ( ( int ) profiler . getBps ( false ) ) ; String message = String . format ( " % d ▁ pumps ▁ performed ▁ in ▁ % s , ▁ average ▁ speed ▁ for ▁ the ▁ last ▁ % d ▁ pumps ▁ was ▁ % s ▁ pumps / sec , ▁ overall ▁ average ▁ was ▁ " + " % s ▁ pumps / sec , ▁ last ▁ pump ▁ took ▁ % s ▁ ms ▁ and ▁ delivered ▁ % s " , profiler . getBeats ( ) , profiler . getSpendTime ( ) , profiler . getBpsSpan ( ) , currentAverage , overallAverage , ms , last == null ? " no ▁ Payload " : last . getId ( ) ) ; if ( profiler . getBeats ( ) % everyStatus == 0 ) { log . info ( message ) ; } else if ( profiler . getBeats ( ) % DEBUG_FEEDBACK == 0 ) { log . debug ( message ) ; } else { log . trace ( message ) ; } }
statsbiblioteket/summa | @ Override public void stop ( ) { log . info ( " Stopping ▁ filter ▁ pump ▁ " + getChainName ( ) ) ; super . stop ( ) ; sequence . close ( true ) ; log . info ( String . format ( " Filter ▁ pump ▁ % s ▁ stopped " , getChainName ( ) ) ) ; }
statsbiblioteket/summa | private void close ( boolean success ) { sequence . close ( success ) ; }
statsbiblioteket/summa | public String getChainName ( ) { return chainName ; }
statsbiblioteket/summa | @ Override public String toString ( ) { StringWriter sw = new StringWriter ( 500 ) ; sw . append ( getStatus ( ) . toString ( ) ) . append ( " : ▁ " ) ; sw . append ( sequence . toString ( ) ) ; sw . append ( " ▁ pump " ) ; return sw . toString ( ) ; }
statsbiblioteket/summa | public List < Filter > getFilters ( ) { return sequence . getFilters ( ) ; }
betfair/cougar | @ Test public void doTest ( ) throws Exception { CougarManager cougarManager1 = CougarManager . getInstance ( ) ; HttpCallBean httpCallBeanBaseline = cougarManager1 . getNewHttpCallBean ( ) ; CougarManager cougarManagerBaseline = cougarManager1 ; httpCallBeanBaseline . setServiceName ( " baseline " , " cougarBaseline " ) ; httpCallBeanBaseline . setVersion ( " v2" ) ; CougarManager cougarManager2 = CougarManager . getInstance ( ) ; HttpCallBean getNewHttpCallBean2 = cougarManager2 . getNewHttpCallBean ( "87.248.113.14" ) ; cougarManager2 = cougarManager2 ; cougarManager2 . setCougarFaultControllerJMXMBeanAttrbiute ( " DetailedFaults " , " false " ) ; getNewHttpCallBean2 . setOperationName ( " i32SimpleTypeOperation " ) ; getNewHttpCallBean2 . setServiceName ( " baseline " , " cougarBaseline " ) ; getNewHttpCallBean2 . setVersion ( " v2" ) ; Map map3 = new HashMap ( ) ; map3 . put ( " HeaderParam " , " " ) ; getNewHttpCallBean2 . setHeaderParams ( map3 ) ; Map map4 = new HashMap ( ) ; map4 . put ( " queryParam " , "43523434" ) ; getNewHttpCallBean2 . setQueryParams ( map4 ) ; getNewHttpCallBean2 . setRestPostQueryObjects ( DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . parse ( new ByteArrayInputStream ( " < message > < bodyParameter > - 50 < / bodyParameter > < / message > " . getBytes ( ) ) ) ) ; Timestamp getTimeAsTimeStamp11 = new Timestamp ( System . currentTimeMillis ( ) ) ; cougarManager2 . makeRestCougarHTTPCalls ( getNewHttpCallBean2 ) ; XMLHelpers xMLHelpers6 = new XMLHelpers ( ) ; Document createAsDocument13 = xMLHelpers6 . getXMLObjectFromString ( " < fault > < faultcode > Client < / faultcode > < faultstring > DSC - 0044 < / faultstring > < detail / > < / fault > " ) ; Map < CougarMessageProtocolRequestTypeEnum , Object > convertResponseToRestTypes14 = cougarManager2 . convertResponseToRestTypes ( createAsDocument13 , getNewHttpCallBean2 ) ; HttpResponseBean response7 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTXMLXML ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTXML ) , response7 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response7 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response7 . getHttpStatusText ( ) ) ; HttpResponseBean response8 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONJSON ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTJSON ) , response8 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response8 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response8 . getHttpStatusText ( ) ) ; HttpResponseBean response9 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTXMLJSON ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTJSON ) , response9 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response9 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response9 . getHttpStatusText ( ) ) ; HttpResponseBean response10 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONXML ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTXML ) , response10 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response10 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response10 . getHttpStatusText ( ) ) ; }
Bonsanto/db-component | public String getSentence ( ) { return sentence ; }
Bonsanto/db-component | public void setSentence ( String sentence ) { this . sentence = sentence ; cleanQuery ( ) ; }
Bonsanto/db-component | private void cleanQuery ( ) { this . sentence = this . sentence . replaceAll ( " \t + " , " ▁ " ) . replaceAll ( " \n + " , " ▁ " ) . replaceAll ( " ▁ + " , " ▁ " ) ; }
Bonsanto/db-component | public Query ( String sentence ) { this . sentence = sentence ; }
Bonsanto/db-component | public Query ( ) { }
yukare/jaguaribe | public void load ( String fileName ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder ; try { builder = factory . newDocumentBuilder ( ) ; Document doc ; try { doc = builder . parse ( fileName ) ; Element root = doc . getDocumentElement ( ) ; if ( root != null ) { this . setRoot ( new XMLItem ( ) ) ; this . rootItem . setName ( root . getTagName ( ) ) ; this . rootItem . setText ( root . getTextContent ( ) ) ; NodeList list = root . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { if ( ! list . item ( i ) . getNodeName ( ) . equals ( " # text " ) ) { this . parseChild ( list . item ( i ) , this . rootItem ) ; } } } } catch ( SAXException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , " There ▁ was ▁ an ▁ error ▁ while ▁ parsing ▁ the ▁ file . " , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( ParserConfigurationException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
yukare/jaguaribe | private void parseChild ( Node node , XMLItem parent ) { XMLItem item = new XMLItem ( ) ; item . setName ( node . getNodeName ( ) ) ; item . setText ( node . getTextContent ( ) ) ; NamedNodeMap attributes = node . getAttributes ( ) ; if ( attributes != null ) { for ( int a = 0 ; a < attributes . getLength ( ) ; a ++ ) { Node attr = attributes . item ( a ) ; item . addAttr ( attr . getNodeName ( ) , attr . getTextContent ( ) ) ; } } parent . addChild ( item ) ; NodeList subNodes = node . getChildNodes ( ) ; for ( int j = 0 ; j < subNodes . getLength ( ) ; j ++ ) { Node child = subNodes . item ( j ) ; if ( ! child . getNodeName ( ) . equals ( " # text " ) ) { this . parseChild ( child , item ) ; } } }
yukare/jaguaribe | public XMLItem getRoot ( ) { return this . rootItem ; }
yukare/jaguaribe | private void saveAddChild ( XMLItem item , Element parent , Document doc ) { Element el = doc . createElement ( item . getName ( ) ) ; el . setTextContent ( item . getText ( ) ) ; ArrayList < XMLAttr > attr = item . getAllAttr ( ) ; for ( XMLAttr entry : attr ) { el . setAttribute ( entry . getKey ( ) , entry . getValue ( ) ) ; } parent . appendChild ( el ) ; for ( XMLItem it : item . getChildren ( ) ) { this . saveAddChild ( it , el , doc ) ; } }
yukare/jaguaribe | public void save ( String filename ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder ; try { builder = factory . newDocumentBuilder ( ) ; Document doc = builder . newDocument ( ) ; Element root = doc . createElement ( this . rootItem . getName ( ) ) ; ArrayList < XMLAttr > attr = this . rootItem . getAllAttr ( ) ; for ( XMLAttr entry : attr ) { root . setAttribute ( entry . getKey ( ) , entry . getValue ( ) ) ; } doc . appendChild ( root ) ; for ( XMLItem item : this . rootItem . getChildren ( ) ) { this . saveAddChild ( item , root , doc ) ; } DOMSource source = new DOMSource ( doc ) ; PrintStream ps ; try { ps = new PrintStream ( filename ) ; StreamResult result = new StreamResult ( ps ) ; TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer ; try { transformer = transformerFactory . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . INDENT , " yes " ) ; transformer . setOutputProperty ( " { http : // xml . apache . org / xslt } indent - amount " , "2" ) ; try { transformer . transform ( source , result ) ; } catch ( TransformerException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( TransformerConfigurationException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( ParserConfigurationException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
yukare/jaguaribe | public void setRoot ( XMLItem root ) { this . rootItem = root ; }
Instagram/cassandra | public SerializationHelper ( TableMetadata metadata , int version , Flag flag , ColumnFilter columnsToFetch ) { this . flag = flag ; this . version = version ; this . columnsToFetch = columnsToFetch ; this . droppedColumns = metadata . droppedColumns ; this . hasDroppedColumns = droppedColumns . size ( ) > 0 ; }
Instagram/cassandra | public SerializationHelper ( TableMetadata metadata , int version , Flag flag ) { this ( metadata , version , flag , null ) ; }
Instagram/cassandra | public boolean includes ( ColumnMetadata column ) { return columnsToFetch == null || columnsToFetch . fetches ( column ) ; }
Instagram/cassandra | public boolean includes ( Cell cell , LivenessInfo rowLiveness ) { if ( columnsToFetch == null ) return true ; ColumnMetadata column = cell . column ( ) ; if ( column . isComplex ( ) ) { if ( ! includes ( cell . path ( ) ) ) return false ; return ! canSkipValue ( cell . path ( ) ) || cell . timestamp ( ) >= rowLiveness . timestamp ( ) ; } else { return columnsToFetch . fetchedColumnIsQueried ( column ) || cell . timestamp ( ) >= rowLiveness . timestamp ( ) ; } }
Instagram/cassandra | public boolean includes ( CellPath path ) { return path == null || tester == null || tester . fetches ( path ) ; }
Instagram/cassandra | public boolean canSkipValue ( ColumnMetadata column ) { return columnsToFetch != null && ! columnsToFetch . fetchedColumnIsQueried ( column ) ; }
Instagram/cassandra | public boolean canSkipValue ( CellPath path ) { return path != null && tester != null && ! tester . fetchedCellIsQueried ( path ) ; }
Instagram/cassandra | public void startOfComplexColumn ( ColumnMetadata column ) { this . tester = columnsToFetch == null ? null : columnsToFetch . newTester ( column ) ; this . currentDroppedComplex = droppedColumns . get ( column . name . bytes ) ; }
Instagram/cassandra | public void endOfComplexColumn ( ) { this . tester = null ; }
Instagram/cassandra | public boolean isDropped ( Cell cell , boolean isComplex ) { if ( ! hasDroppedColumns ) return false ; DroppedColumn dropped = isComplex ? currentDroppedComplex : droppedColumns . get ( cell . column ( ) . name . bytes ) ; return dropped != null && cell . timestamp ( ) <= dropped . droppedTime ; }
Instagram/cassandra | public boolean isDroppedComplexDeletion ( DeletionTime complexDeletion ) { return currentDroppedComplex != null && complexDeletion . markedForDeleteAt ( ) <= currentDroppedComplex . droppedTime ; }
Instagram/cassandra | public ByteBuffer maybeClearCounterValue ( ByteBuffer value ) { return flag == Flag . FROM_REMOTE || ( flag == Flag . LOCAL && CounterContext . instance ( ) . shouldClearLocal ( value ) ) ? CounterContext . instance ( ) . clearAllLocal ( value ) : value ; }
CandleCandle/camel | public HttpServerInitializerFactory ( ) { }
CandleCandle/camel | public HttpServerInitializerFactory ( NettyHttpConsumer nettyConsumer ) { this . consumer = nettyConsumer ; this . configuration = nettyConsumer . getConfiguration ( ) ; try { this . sslContext = createSSLContext ( consumer . getContext ( ) , consumer . getConfiguration ( ) ) ; } catch ( Exception e ) { throw ObjectHelper . wrapRuntimeCamelException ( e ) ; } if ( sslContext != null ) { LOG . info ( " Created ▁ SslContext ▁ { } " , sslContext ) ; } }
CandleCandle/camel | @ Override public ServerInitializerFactory createPipelineFactory ( NettyConsumer nettyConsumer ) { return new HttpServerInitializerFactory ( ( NettyHttpConsumer ) nettyConsumer ) ; }
CandleCandle/camel | @ Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; SslHandler sslHandler = configureServerSSLOnDemand ( ) ; if ( sslHandler != null ) { LOG . debug ( " Server ▁ SSL ▁ handler ▁ configured ▁ and ▁ added ▁ as ▁ an ▁ interceptor ▁ against ▁ the ▁ ChannelPipeline : ▁ { } " , sslHandler ) ; pipeline . addLast ( " ssl " , sslHandler ) ; } pipeline . addLast ( " decoder " , new HttpRequestDecoder ( 4096 , configuration . getMaxHeaderSize ( ) , 8192 ) ) ; List < ChannelHandler > decoders = consumer . getConfiguration ( ) . getDecoders ( ) ; for ( int x = 0 ; x < decoders . size ( ) ; x ++ ) { ChannelHandler decoder = decoders . get ( x ) ; if ( decoder instanceof ChannelHandlerFactory ) { decoder = ( ( ChannelHandlerFactory ) decoder ) . newChannelHandler ( ) ; } pipeline . addLast ( " decoder - " + x , decoder ) ; } pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( configuration . getChunkedMaxContentLength ( ) ) ) ; pipeline . addLast ( " encoder " , new HttpResponseEncoder ( ) ) ; List < ChannelHandler > encoders = consumer . getConfiguration ( ) . getEncoders ( ) ; for ( int x = 0 ; x < encoders . size ( ) ; x ++ ) { ChannelHandler encoder = encoders . get ( x ) ; if ( encoder instanceof ChannelHandlerFactory ) { encoder = ( ( ChannelHandlerFactory ) encoder ) . newChannelHandler ( ) ; } pipeline . addLast ( " encoder - " + x , encoder ) ; } if ( supportCompressed ( ) ) { pipeline . addLast ( " deflater " , new HttpContentCompressor ( ) ) ; } int port = consumer . getConfiguration ( ) . getPort ( ) ; ChannelHandler handler = consumer . getEndpoint ( ) . getComponent ( ) . getMultiplexChannelHandler ( port ) . getChannelHandler ( ) ; if ( consumer . getConfiguration ( ) . isUsingExecutorService ( ) ) { EventExecutorGroup applicationExecutor = consumer . getEndpoint ( ) . getComponent ( ) . getExecutorService ( ) ; pipeline . addLast ( applicationExecutor , " handler " , handler ) ; } else { pipeline . addLast ( " handler " , handler ) ; } }
CandleCandle/camel | private SSLContext createSSLContext ( CamelContext camelContext , NettyServerBootstrapConfiguration configuration ) throws Exception { if ( ! configuration . isSsl ( ) ) { return null ; } SSLContext answer ; if ( configuration . getSslContextParameters ( ) != null ) { answer = configuration . getSslContextParameters ( ) . createSSLContext ( ) ; } else { if ( configuration . getKeyStoreFile ( ) == null && configuration . getKeyStoreResource ( ) == null ) { LOG . debug ( " keystorefile ▁ is ▁ null " ) ; } if ( configuration . getTrustStoreFile ( ) == null && configuration . getTrustStoreResource ( ) == null ) { LOG . debug ( " truststorefile ▁ is ▁ null " ) ; } if ( configuration . getPassphrase ( ) . toCharArray ( ) == null ) { LOG . debug ( " passphrase ▁ is ▁ null " ) ; } SSLEngineFactory sslEngineFactory ; if ( configuration . getKeyStoreFile ( ) != null || configuration . getTrustStoreFile ( ) != null ) { sslEngineFactory = new SSLEngineFactory ( ) ; answer = sslEngineFactory . createSSLContext ( camelContext . getClassResolver ( ) , configuration . getKeyStoreFormat ( ) , configuration . getSecurityProvider ( ) , " file : " + configuration . getKeyStoreFile ( ) . getPath ( ) , " file : " + configuration . getTrustStoreFile ( ) . getPath ( ) , configuration . getPassphrase ( ) . toCharArray ( ) ) ; } else { sslEngineFactory = new SSLEngineFactory ( ) ; answer = sslEngineFactory . createSSLContext ( camelContext . getClassResolver ( ) , configuration . getKeyStoreFormat ( ) , configuration . getSecurityProvider ( ) , configuration . getKeyStoreResource ( ) , configuration . getTrustStoreResource ( ) , configuration . getPassphrase ( ) . toCharArray ( ) ) ; } } return answer ; }
CandleCandle/camel | private SslHandler configureServerSSLOnDemand ( ) throws Exception { if ( ! consumer . getConfiguration ( ) . isSsl ( ) ) { return null ; } if ( consumer . getConfiguration ( ) . getSslHandler ( ) != null ) { return consumer . getConfiguration ( ) . getSslHandler ( ) ; } else if ( sslContext != null ) { SSLEngine engine = sslContext . createSSLEngine ( ) ; engine . setUseClientMode ( false ) ; engine . setNeedClientAuth ( consumer . getConfiguration ( ) . isNeedClientAuth ( ) ) ; if ( consumer . getConfiguration ( ) . getSslContextParameters ( ) == null ) { engine . setEnabledProtocols ( consumer . getConfiguration ( ) . getEnabledProtocols ( ) . split ( " , " ) ) ; } return new SslHandler ( engine ) ; } return null ; }
CandleCandle/camel | private boolean supportCompressed ( ) { return consumer . getEndpoint ( ) . getConfiguration ( ) . isCompression ( ) ; }
CEPFU/importer | public YQLRunner ( ) { httpClient = HttpClientBuilder . create ( ) . build ( ) ; }
CEPFU/importer | public JSONObject getYQLResponseJSON ( String query ) throws IOException { JSONObject jsonResponse = new JSONObject ( getYQLResponseString ( query ) ) ; return jsonResponse . getJSONObject ( " query " ) . getJSONObject ( " results " ) ; }
CEPFU/importer | public String getYQLResponseString ( String query ) throws IOException { HttpGet getRequest = new HttpGet ( prepareURL ( query ) ) ; getRequest . addHeader ( " accept " , " application / json " ) ; HttpResponse response = httpClient . execute ( getRequest ) ; String output = " " ; BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String tmp = null ; while ( ( tmp = bufferedReader . readLine ( ) ) != null ) { output += tmp ; } return output ; }
CEPFU/importer | private String prepareURL ( String query ) throws UnsupportedEncodingException { return BASE_URL + QUERY_PARAMETER + URLEncoder . encode ( query , " UTF - 8" ) + OUTPUT_FORMAT ; }
rohit5ram/carjoin | private TripShareDAO ( Context context ) { this . context = context ; this . dbHelper = DatabaseHelper . getInstance ( context ) ; }
rohit5ram/carjoin | public synchronized Cursor getTripShareCursor ( ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , TripShare . FIELDS , null , null , null , null , null , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
rohit5ram/carjoin | public synchronized Cursor getTripShareById ( String id ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , TripShare . FIELDS , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { id } , null , null , null , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
rohit5ram/carjoin | public synchronized boolean putTripShare ( final TripShare tripShare ) { boolean success = false ; int result = 0 ; try { final SQLiteDatabase db = dbHelper . getWritableDatabase ( ) ; if ( tripShare . id != null ) { result += db . update ( TripShare . TABLE_NAME , tripShare . getContent ( ) , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { tripShare . id } ) ; } if ( result > 0 ) { success = true ; } else { final long rowId = db . insert ( TripShare . TABLE_NAME , null , tripShare . getContent ( ) ) ; if ( rowId > - 1 ) { success = true ; } } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return success ; }
rohit5ram/carjoin | public synchronized String getTripShareId ( ) { String tripShareId = " " ; Cursor tripShareCursor = getTripShareCursor ( ) ; try { if ( tripShareCursor != null && tripShareCursor . moveToLast ( ) ) { TripShare tripShare = new TripShare ( tripShareCursor ) ; tripShareId = tripShare . id ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } finally { try { if ( tripShareCursor != null ) { tripShareCursor . close ( ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } } return tripShareId ; }
rohit5ram/carjoin | public synchronized TripShare getTripShare ( ) { Cursor tripShareCursor = getTripShareCursor ( ) ; TripShare tripShare = null ; try { if ( tripShareCursor != null && tripShareCursor . moveToLast ( ) ) { tripShare = new TripShare ( tripShareCursor ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } finally { try { if ( tripShareCursor != null ) { tripShareCursor . close ( ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } } return tripShare ; }
rohit5ram/carjoin | public synchronized boolean deleteTripShare ( TripShare tripShare ) { int result = - 1 ; try { final SQLiteDatabase db = dbHelper . getWritableDatabase ( ) ; result = db . delete ( TripShare . TABLE_NAME , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { String . valueOf ( tripShare . id ) } ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } boolean success = false ; if ( result > 0 ) { success = true ; } return success ; }
rohit5ram/carjoin | public synchronized Cursor getTripShare ( String [ ] projection , String selection , String [ ] selectionArgs , String sortOrder ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , projection , selection , selectionArgs , null , null , sortOrder , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
0359xiaodong/elasticsearch | @ Test public void testBytesAndNumericRepresentation ( ) throws Exception { IndexWriter writer = new IndexWriter ( new RAMDirectory ( ) , new IndexWriterConfig ( Lucene . VERSION , Lucene . STANDARD_ANALYZER ) ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " properties " ) . startObject ( " field1" ) . field ( " type " , " integer " ) . field ( " store " , " yes " ) . endObject ( ) . startObject ( " field2" ) . field ( " type " , " float " ) . field ( " store " , " yes " ) . endObject ( ) . startObject ( " field3" ) . field ( " type " , " long " ) . field ( " store " , " yes " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = createIndex ( " test " ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = mapper . parse ( " type " , "1" , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( " field1" , 1 ) . field ( " field2" , 1.1 ) . startArray ( " field3" ) . value ( 1 ) . value ( 2 ) . value ( 3 ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; writer . addDocument ( doc . rootDoc ( ) , doc . analyzer ( ) ) ; FieldType fieldType = new FieldType ( ) ; fieldType . setStored ( true ) ; fieldType . setNumericType ( FieldType . NumericType . INT ) ; Document doc2 = new Document ( ) ; doc2 . add ( new StoredField ( " field1" , new BytesRef ( Numbers . intToBytes ( 1 ) ) ) ) ; doc2 . add ( new StoredField ( " field2" , new BytesRef ( Numbers . floatToBytes ( 1.1f ) ) ) ) ; doc2 . add ( new StoredField ( " field3" , new BytesRef ( Numbers . longToBytes ( 1l ) ) ) ) ; doc2 . add ( new StoredField ( " field3" , new BytesRef ( Numbers . longToBytes ( 2l ) ) ) ) ; doc2 . add ( new StoredField ( " field3" , new BytesRef ( Numbers . longToBytes ( 3l ) ) ) ) ; writer . addDocument ( doc2 ) ; DirectoryReader reader = DirectoryReader . open ( writer , true ) ; IndexSearcher searcher = new IndexSearcher ( reader ) ; Set < String > fields = new HashSet < > ( Arrays . asList ( " field1" , " field2" , " field3" ) ) ; CustomFieldsVisitor fieldsVisitor = new CustomFieldsVisitor ( fields , false ) ; searcher . doc ( 0 , fieldsVisitor ) ; fieldsVisitor . postProcess ( mapper ) ; assertThat ( fieldsVisitor . fields ( ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field1" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Integer ) fieldsVisitor . fields ( ) . get ( " field1" ) . get ( 0 ) , equalTo ( 1 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field2" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Float ) fieldsVisitor . fields ( ) . get ( " field2" ) . get ( 0 ) , equalTo ( 1.1f ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field3" ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 0 ) , equalTo ( 1l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 1 ) , equalTo ( 2l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 2 ) , equalTo ( 3l ) ) ; fieldsVisitor . reset ( ) ; searcher . doc ( 1 , fieldsVisitor ) ; fieldsVisitor . postProcess ( mapper ) ; assertThat ( fieldsVisitor . fields ( ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field1" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Integer ) fieldsVisitor . fields ( ) . get ( " field1" ) . get ( 0 ) , equalTo ( 1 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field2" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Float ) fieldsVisitor . fields ( ) . get ( " field2" ) . get ( 0 ) , equalTo ( 1.1f ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field3" ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 0 ) , equalTo ( 1l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 1 ) , equalTo ( 2l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 2 ) , equalTo ( 3l ) ) ; reader . close ( ) ; writer . close ( ) ; }
Regger2011/java_pdt-34 | @ Test public void testGroupModification ( ) { app . getNavigationHelper ( ) . gotoGroupsPage ( ) ; if ( ! app . getGroupHelper ( ) . isThereAGroup ( ) ) { app . getGroupHelper ( ) . createGroup ( new GroupData ( " test " , null , null ) ) ; } app . getNavigationHelper ( ) . selection ( ) ; app . getGroupHelper ( ) . initGroupModification ( ) ; app . getGroupHelper ( ) . fillGroupForm ( new GroupData ( " tEsT1" , " tEsT2" , " tEsT3" ) ) ; app . getGroupHelper ( ) . submitUpdateGroupModification ( ) ; app . getGroupHelper ( ) . returnToGroupPage ( ) ; }
VegardT/GlycanSearcherVT | public GraphOutputSearch ( ) { }
VegardT/GlycanSearcherVT | public void GraphAlgorithm4 ( DirectedGraph < String , Graph . GlycoEdge > testGraph , ArrayList < String > startArray , double largestMass ) throws IOException { ArrayList < Set < GlycoEdge > > edgesToRemove = new ArrayList ( ) ; GlycanSearcherUtilities utilities = new GlycanSearcherUtilities ( ) ; Double max = null ; Set < String > vertexSet = testGraph . vertexSet ( ) ; Integer size = 1 ; ArrayList < String > vertexesToRemove = new ArrayList ( ) ; while ( size != 0 ) { for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Xylose " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Fucose " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Neu5Ac " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Neu5Ac - H2O | " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexesToRemove ) { testGraph . removeVertex ( s ) ; } size = vertexesToRemove . size ( ) ; vertexesToRemove . clear ( ) ; } count = count + 1 ; System . out . println ( " THIS ▁ IS ▁ GRAPH ▁ NUMBER ▁ " + count ) ; graphs . add ( testGraph ) ; }
VegardT/GlycanSearcherVT | public ArrayList < DirectedGraph < String , Graph . GlycoEdge > > GetGlycanGraph ( ) { return graphs ; }
VegardT/GlycanSearcherVT | public ArrayList < String > GetGlycanCombination ( ) { return null ; }
bclozel/spring-boot | @ Test public void fromRestTemplateBuilder ( ) { RestTemplateBuilder builder = mock ( RestTemplateBuilder . class ) ; RestTemplate delegate = new RestTemplate ( ) ; given ( builder . build ( ) ) . willReturn ( delegate ) ; assertThat ( new TestRestTemplate ( builder ) . getRestTemplate ( ) ) . isEqualTo ( delegate ) ; }
bclozel/spring-boot | @ Test public void simple ( ) { assertThat ( new TestRestTemplate ( ) . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( HttpComponentsClientHttpRequestFactory . class ) ; }
bclozel/spring-boot | @ Test public void doNotReplaceCustomRequestFactory ( ) { RestTemplateBuilder builder = new RestTemplateBuilder ( ) . requestFactory ( OkHttp3ClientHttpRequestFactory . class ) ; TestRestTemplate testRestTemplate = new TestRestTemplate ( builder ) ; assertThat ( testRestTemplate . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( OkHttp3ClientHttpRequestFactory . class ) ; }
bclozel/spring-boot | @ Test public void getRootUriRootUriSetViaRestTemplateBuilder ( ) { String rootUri = " http : // example . com " ; RestTemplateBuilder delegate = new RestTemplateBuilder ( ) . rootUri ( rootUri ) ; assertThat ( new TestRestTemplate ( delegate ) . getRootUri ( ) ) . isEqualTo ( rootUri ) ; }
bclozel/spring-boot | @ Test public void getRootUriRootUriSetViaLocalHostUriTemplateHandler ( ) { String rootUri = " http : // example . com " ; TestRestTemplate template = new TestRestTemplate ( ) ; LocalHostUriTemplateHandler templateHandler = mock ( LocalHostUriTemplateHandler . class ) ; given ( templateHandler . getRootUri ( ) ) . willReturn ( rootUri ) ; template . setUriTemplateHandler ( templateHandler ) ; assertThat ( template . getRootUri ( ) ) . isEqualTo ( rootUri ) ; }
bclozel/spring-boot | @ Test public void getRootUriRootUriNotSet ( ) { assertThat ( new TestRestTemplate ( ) . getRootUri ( ) ) . isEqualTo ( " " ) ; }
bclozel/spring-boot | @ Test public void authenticated ( ) { assertThat ( new TestRestTemplate ( " user " , " password " ) . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( InterceptingClientHttpRequestFactory . class ) ; }
bclozel/spring-boot | @ Test public void options ( ) { TestRestTemplate template = new TestRestTemplate ( HttpClientOption . ENABLE_REDIRECTS ) ; CustomHttpComponentsClientHttpRequestFactory factory = ( CustomHttpComponentsClientHttpRequestFactory ) template . getRestTemplate ( ) . getRequestFactory ( ) ; RequestConfig config = factory . getRequestConfig ( ) ; assertThat ( config . isRedirectsEnabled ( ) ) . isTrue ( ) ; }
bclozel/spring-boot | @ Test public void restOperationsAreAvailable ( ) { RestTemplate delegate = mock ( RestTemplate . class ) ; given ( delegate . getRequestFactory ( ) ) . willReturn ( new SimpleClientHttpRequestFactory ( ) ) ; given ( delegate . getUriTemplateHandler ( ) ) . willReturn ( new DefaultUriBuilderFactory ( ) ) ; RestTemplateBuilder builder = mock ( RestTemplateBuilder . class ) ; given ( builder . build ( ) ) . willReturn ( delegate ) ; TestRestTemplate restTemplate = new TestRestTemplate ( builder ) ; ReflectionUtils . doWithMethods ( RestOperations . class , new MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { Method equivalent = ReflectionUtils . findMethod ( TestRestTemplate . class , method . getName ( ) , method . getParameterTypes ( ) ) ; assertThat ( equivalent ) . as ( " Method ▁ % s ▁ not ▁ found " , method ) . isNotNull ( ) ; assertThat ( Modifier . isPublic ( equivalent . getModifiers ( ) ) ) . as ( " Method ▁ % s ▁ should ▁ have ▁ been ▁ public " , equivalent ) . isTrue ( ) ; try { equivalent . invoke ( restTemplate , mockArguments ( method . getParameterTypes ( ) ) ) ; } catch ( Exception ex ) { throw new IllegalStateException ( ex ) ; } } private Object [ ] mockArguments ( Class < ? > [ ] parameterTypes ) throws Exception { Object [ ] arguments = new Object [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { arguments [ i ] = mockArgument ( parameterTypes [ i ] ) ; } return arguments ; } @ SuppressWarnings ( " rawtypes " ) private Object mockArgument ( Class < ? > type ) throws Exception { if ( String . class . equals ( type ) ) { return " String " ; } if ( Object [ ] . class . equals ( type ) ) { return new Object [ 0 ] ; } if ( URI . class . equals ( type ) ) { return new URI ( " http : // localhost " ) ; } if ( HttpMethod . class . equals ( type ) ) { return HttpMethod . GET ; } if ( Class . class . equals ( type ) ) { return Object . class ; } if ( RequestEntity . class . equals ( type ) ) { return new RequestEntity ( HttpMethod . GET , new URI ( " http : // localhost " ) ) ; } return mock ( type ) ; } } , ( method ) -> Modifier . isPublic ( method . getModifiers ( ) ) ) ; }
bclozel/spring-boot | @ Test public void withBasicAuthAddsBasicAuthInterceptorWhenNotAlreadyPresent ( ) { TestRestTemplate originalTemplate = new TestRestTemplate ( ) ; TestRestTemplate basicAuthTemplate = originalTemplate . withBasicAuth ( " user " , " password " ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getMessageConverters ( ) ) . containsExactlyElementsOf ( originalTemplate . getRestTemplate ( ) . getMessageConverters ( ) ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( InterceptingClientHttpRequestFactory . class ) ; assertThat ( ReflectionTestUtils . getField ( basicAuthTemplate . getRestTemplate ( ) . getRequestFactory ( ) , " requestFactory " ) ) . isInstanceOf ( CustomHttpComponentsClientHttpRequestFactory . class ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getUriTemplateHandler ( ) ) . isSameAs ( originalTemplate . getRestTemplate ( ) . getUriTemplateHandler ( ) ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getInterceptors ( ) ) . hasSize ( 1 ) ; assertBasicAuthorizationInterceptorCredentials ( basicAuthTemplate , " user " , " password " ) ; }
bclozel/spring-boot | @ Test public void withBasicAuthReplacesBasicAuthInterceptorWhenAlreadyPresent ( ) { TestRestTemplate original = new TestRestTemplate ( " foo " , " bar " ) . withBasicAuth ( " replace " , " replace " ) ; TestRestTemplate basicAuth = original . withBasicAuth ( " user " , " password " ) ; assertThat ( basicAuth . getRestTemplate ( ) . getMessageConverters ( ) ) . containsExactlyElementsOf ( original . getRestTemplate ( ) . getMessageConverters ( ) ) ; assertThat ( basicAuth . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( InterceptingClientHttpRequestFactory . class ) ; assertThat ( ReflectionTestUtils . getField ( basicAuth . getRestTemplate ( ) . getRequestFactory ( ) , " requestFactory " ) ) . isInstanceOf ( CustomHttpComponentsClientHttpRequestFactory . class ) ; assertThat ( basicAuth . getRestTemplate ( ) . getUriTemplateHandler ( ) ) . isSameAs ( original . getRestTemplate ( ) . getUriTemplateHandler ( ) ) ; assertThat ( basicAuth . getRestTemplate ( ) . getInterceptors ( ) ) . hasSize ( 1 ) ; assertBasicAuthorizationInterceptorCredentials ( basicAuth , " user " , " password " ) ; }
bclozel/spring-boot | @ Test public void withBasicAuthDoesNotResetErrorHandler ( ) { TestRestTemplate originalTemplate = new TestRestTemplate ( " foo " , " bar " ) ; ResponseErrorHandler errorHandler = mock ( ResponseErrorHandler . class ) ; originalTemplate . getRestTemplate ( ) . setErrorHandler ( errorHandler ) ; TestRestTemplate basicAuthTemplate = originalTemplate . withBasicAuth ( " user " , " password " ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getErrorHandler ( ) ) . isSameAs ( errorHandler ) ; }
bclozel/spring-boot | @ Test public void deleteHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( TestRestTemplate :: delete ) ; }
bclozel/spring-boot | @ Test public void exchangeWithRequestEntityAndClassHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( new RequestEntity < String > ( HttpMethod . GET , relativeUri ) , String . class ) ) ; }
bclozel/spring-boot | @ Test public void exchangeWithRequestEntityAndParameterizedTypeReferenceHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( new RequestEntity < String > ( HttpMethod . GET , relativeUri ) , new ParameterizedTypeReference < String > ( ) { } ) ) ; }
bclozel/spring-boot | @ Test public void exchangeHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( relativeUri , HttpMethod . GET , new HttpEntity < > ( new byte [ 0 ] ) , String . class ) ) ; }
bclozel/spring-boot | @ Test public void exchangeWithParameterizedTypeReferenceHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( relativeUri , HttpMethod . GET , new HttpEntity < > ( new byte [ 0 ] ) , new ParameterizedTypeReference < String > ( ) { } ) ) ; }
bclozel/spring-boot | @ Test public void executeHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . execute ( relativeUri , HttpMethod . GET , null , null ) ) ; }
bclozel/spring-boot | @ Test public void getForEntityHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . getForEntity ( relativeUri , String . class ) ) ; }
bclozel/spring-boot | @ Test public void getForObjectHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . getForObject ( relativeUri , String . class ) ) ; }
bclozel/spring-boot | @ Test public void headForHeadersHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( TestRestTemplate :: headForHeaders ) ; }
bclozel/spring-boot | @ Test public void optionsForAllowHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( TestRestTemplate :: optionsForAllow ) ; }
bclozel/spring-boot | @ Test public void patchForObjectHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . patchForObject ( relativeUri , " hello " , String . class ) ) ; }
bclozel/spring-boot | @ Test public void postForEntityHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . postForEntity ( relativeUri , " hello " , String . class ) ) ; }
bclozel/spring-boot | @ Test public void postForLocationHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . postForLocation ( relativeUri , " hello " ) ) ; }
bclozel/spring-boot | @ Test public void postForObjectHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . postForObject ( relativeUri , " hello " , String . class ) ) ; }
bclozel/spring-boot | @ Test public void putHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . put ( relativeUri , " hello " ) ) ; }
bclozel/spring-boot | private void verifyRelativeUriHandling ( TestRestTemplateCallback callback ) throws IOException { ClientHttpRequestFactory requestFactory = mock ( ClientHttpRequestFactory . class ) ; MockClientHttpRequest request = new MockClientHttpRequest ( ) ; request . setResponse ( new MockClientHttpResponse ( new byte [ 0 ] , HttpStatus . OK ) ) ; URI absoluteUri = URI . create ( " http : // localhost : 8080 / a / b / c . txt ? param = % 7Bsomething % 7D " ) ; given ( requestFactory . createRequest ( eq ( absoluteUri ) , any ( HttpMethod . class ) ) ) . willReturn ( request ) ; TestRestTemplate template = new TestRestTemplate ( ) ; template . getRestTemplate ( ) . setRequestFactory ( requestFactory ) ; LocalHostUriTemplateHandler uriTemplateHandler = new LocalHostUriTemplateHandler ( new MockEnvironment ( ) ) ; template . setUriTemplateHandler ( uriTemplateHandler ) ; callback . doWithTestRestTemplate ( template , URI . create ( " / a / b / c . txt ? param = % 7Bsomething % 7D " ) ) ; verify ( requestFactory ) . createRequest ( eq ( absoluteUri ) , any ( HttpMethod . class ) ) ; }
bclozel/spring-boot | private void assertBasicAuthorizationInterceptorCredentials ( TestRestTemplate testRestTemplate , String username , String password ) { @ SuppressWarnings ( " unchecked " ) List < ClientHttpRequestInterceptor > requestFactoryInterceptors = ( List < ClientHttpRequestInterceptor > ) ReflectionTestUtils . getField ( testRestTemplate . getRestTemplate ( ) . getRequestFactory ( ) , " interceptors " ) ; assertThat ( requestFactoryInterceptors ) . hasSize ( 1 ) ; ClientHttpRequestInterceptor interceptor = requestFactoryInterceptors . get ( 0 ) ; assertThat ( interceptor ) . isInstanceOf ( BasicAuthorizationInterceptor . class ) ; assertThat ( ReflectionTestUtils . getField ( interceptor , " username " ) ) . isEqualTo ( username ) ; assertThat ( ReflectionTestUtils . getField ( interceptor , " password " ) ) . isEqualTo ( password ) ; }
jenshadlich/aws-sdk-java | public void setTopic ( String topic ) { this . topic = topic ; }
jenshadlich/aws-sdk-java | public String getTopic ( ) { return this . topic ; }
jenshadlich/aws-sdk-java | public PublishRequest withTopic ( String topic ) { setTopic ( topic ) ; return this ; }
jenshadlich/aws-sdk-java | public void setQos ( Integer qos ) { this . qos = qos ; }
jenshadlich/aws-sdk-java | public Integer getQos ( ) { return this . qos ; }
jenshadlich/aws-sdk-java | public PublishRequest withQos ( Integer qos ) { setQos ( qos ) ; return this ; }
jenshadlich/aws-sdk-java | public void setPayload ( java . nio . ByteBuffer payload ) { this . payload = payload ; }
jenshadlich/aws-sdk-java | public java . nio . ByteBuffer getPayload ( ) { return this . payload ; }
jenshadlich/aws-sdk-java | public PublishRequest withPayload ( java . nio . ByteBuffer payload ) { setPayload ( payload ) ; return this ; }
jenshadlich/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getTopic ( ) != null ) sb . append ( " Topic : ▁ " + getTopic ( ) + " , " ) ; if ( getQos ( ) != null ) sb . append ( " Qos : ▁ " + getQos ( ) + " , " ) ; if ( getPayload ( ) != null ) sb . append ( " Payload : ▁ " + getPayload ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
jenshadlich/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof PublishRequest == false ) return false ; PublishRequest other = ( PublishRequest ) obj ; if ( other . getTopic ( ) == null ^ this . getTopic ( ) == null ) return false ; if ( other . getTopic ( ) != null && other . getTopic ( ) . equals ( this . getTopic ( ) ) == false ) return false ; if ( other . getQos ( ) == null ^ this . getQos ( ) == null ) return false ; if ( other . getQos ( ) != null && other . getQos ( ) . equals ( this . getQos ( ) ) == false ) return false ; if ( other . getPayload ( ) == null ^ this . getPayload ( ) == null ) return false ; if ( other . getPayload ( ) != null && other . getPayload ( ) . equals ( this . getPayload ( ) ) == false ) return false ; return true ; }
jenshadlich/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getTopic ( ) == null ) ? 0 : getTopic ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getQos ( ) == null ) ? 0 : getQos ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getPayload ( ) == null ) ? 0 : getPayload ( ) . hashCode ( ) ) ; return hashCode ; }
jenshadlich/aws-sdk-java | @ Override public PublishRequest clone ( ) { return ( PublishRequest ) super . clone ( ) ; }
hastef88/carbon-business-messaging | if ( qpidPath != null ) { andesConfDir = Paths . get ( qpidPath ) . toString ( ) ; }
hastef88/carbon-business-messaging | if ( isSSLOnly ( ) ) { return " amqp : // " + userName + " : " + accessKey + " @ " + CARBON_CLIENT_ID + " / " + CARBON_VIRTUAL_HOST_NAME + " ? brokerlist = ' tcp : // " + CARBON_DEFAULT_HOSTNAME + " : " + CARBON_SSL_PORT + " ? ssl = ' true ' & trust _ store = ' " + trustStore . getStoreLocation ( ) + " ' & trust _ store _ password = ' " + trustStore . getPassword ( ) + " ' & key _ store = ' " + keyStore . getStoreLocation ( ) + " ' & key _ store _ password = ' " + trustStore . getPassword ( ) + " ' ' " ; }
alexsh/cw-omnibus | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; beamFragment = ( BeamFragment ) getSupportFragmentManager ( ) . findFragmentById ( android . R . id . content ) ; if ( beamFragment == null ) { beamFragment = new BeamFragment ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . add ( android . R . id . content , beamFragment ) . commit ( ) ; } adapter = NfcAdapter . getDefaultAdapter ( this ) ; findViewById ( android . R . id . content ) . post ( new Runnable ( ) { public void run ( ) { handleIntent ( getIntent ( ) ) ; } } ) ; }
alexsh/cw-omnibus | @ Override public void onNewIntent ( Intent i ) { handleIntent ( i ) ; }
alexsh/cw-omnibus | @ Override public void onStop ( ) { disablePush ( ) ; super . onStop ( ) ; }
alexsh/cw-omnibus | void enablePush ( ) { adapter . setNdefPushMessageCallback ( this , this ) ; }
alexsh/cw-omnibus | void disablePush ( ) { adapter . setNdefPushMessageCallback ( null , this ) ; }
alexsh/cw-omnibus | boolean hasNFC ( ) { return ( adapter != null ) ; }
alexsh/cw-omnibus | private void handleIntent ( Intent i ) { if ( NfcAdapter . ACTION_NDEF_DISCOVERED . equals ( i . getAction ( ) ) ) { Parcelable [ ] rawMsgs = i . getParcelableArrayExtra ( NfcAdapter . EXTRA_NDEF_MESSAGES ) ; NdefMessage msg = ( NdefMessage ) rawMsgs [ 0 ] ; String url = new String ( msg . getRecords ( ) [ 0 ] . getPayload ( ) ) ; beamFragment . loadUrl ( url ) ; } }
alexsh/cw-omnibus | @ Override public NdefMessage createNdefMessage ( NfcEvent arg0 ) { NdefRecord uriRecord = new NdefRecord ( NdefRecord . TNF_MIME_MEDIA , MIME_TYPE . getBytes ( Charset . forName ( " US - ASCII " ) ) , new byte [ 0 ] , beamFragment . getUrl ( ) . getBytes ( Charset . forName ( " US - ASCII " ) ) ) ; NdefMessage msg = new NdefMessage ( new NdefRecord [ ] { uriRecord , NdefRecord . createApplicationRecord ( " com . commonsware . android . webbeam " ) } ) ; return ( msg ) ; }
OnePaaS/aws-sdk-java | public void setAssociationDescription ( AssociationDescription associationDescription ) { this . associationDescription = associationDescription ; }
OnePaaS/aws-sdk-java | public AssociationDescription getAssociationDescription ( ) { return this . associationDescription ; }
OnePaaS/aws-sdk-java | public UpdateAssociationStatusResult withAssociationDescription ( AssociationDescription associationDescription ) { setAssociationDescription ( associationDescription ) ; return this ; }
OnePaaS/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getAssociationDescription ( ) != null ) sb . append ( " AssociationDescription : ▁ " + getAssociationDescription ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
OnePaaS/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof UpdateAssociationStatusResult == false ) return false ; UpdateAssociationStatusResult other = ( UpdateAssociationStatusResult ) obj ; if ( other . getAssociationDescription ( ) == null ^ this . getAssociationDescription ( ) == null ) return false ; if ( other . getAssociationDescription ( ) != null && other . getAssociationDescription ( ) . equals ( this . getAssociationDescription ( ) ) == false ) return false ; return true ; }
OnePaaS/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getAssociationDescription ( ) == null ) ? 0 : getAssociationDescription ( ) . hashCode ( ) ) ; return hashCode ; }
OnePaaS/aws-sdk-java | @ Override public UpdateAssociationStatusResult clone ( ) { try { return ( UpdateAssociationStatusResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
dcapwell/jmh-tests | @ Benchmark public int baseline ( ) { return 1 ; }
dcapwell/jmh-tests | @ Benchmark public int inherent ( ) { return math . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int inherentTop ( ) { return math . finalTopAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int inherentBottom ( ) { return math . finalBottomAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalInherent ( ) { return finalMath . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalInherentTop ( ) { return finalMath . finalTopAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalInherentBottom ( ) { return finalMath . finalBottomAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int klass ( ) { return Math . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int klassFinalMethod ( ) { return Math . finalAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalClass ( ) { return FinalMath . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalClassFinalMethod ( ) { return FinalMath . finalAdd ( left , right ) ; }
dcapwell/jmh-tests | private FinalMath ( ) { }
dcapwell/jmh-tests | private Math ( ) { }
dcapwell/jmh-tests | @ Override public int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public final int finalBottomAdd ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public final int finalTopAdd ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public final int finalTopAdd ( int i , int j ) { return i + j ; }
EMResearch/EMB | public LocalPropertyDescriptor ( String propertyName , PropertyParser parser ) { this ( propertyName , parser , DEFAULT_PREFIX , DEFAULT_POSTFIX ) ; }
EMResearch/EMB | public LocalPropertyDescriptor ( String propertyName , PropertyParser parser , String prefix , String postfix ) { this . propertyName = propertyName ; this . parser = parser ; this . prefix = prefix ; this . postfix = postfix ; }
EMResearch/EMB | @ Override public String get ( Vertex vertex ) { if ( vertex . keys ( ) . contains ( propertyName ) ) { String value = parser . parse ( vertex . value ( propertyName ) ) ; if ( value != null ) { return String . format ( " % s % s % s " , prefix , value , postfix ) ; } } return null ; }
hernad/oo-netbeans | public NewTemplateTypesDialog ( ComponentTypePropertyEditor editor , PolyStruct plStruct ) { this . editor = editor ; this . plStruct = plStruct ; initComponents ( ) ; Node node = ( Node ) IdlTypeTreeCreator . createTemplateNode ( plStruct ) ; manager . setRootContext ( node ) ; PropertySheet propSheet = ( PropertySheet ) jPanel1 ; propSheet . setNodes ( new Node [ ] { node } ) ; }
hernad/oo-netbeans | private void initComponents ( ) { jPanel1 = new PropertySheet ( ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( this ) ; this . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( jPanel1 , javax . swing . GroupLayout . DEFAULT_SIZE , 376 , Short . MAX_VALUE ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( jPanel1 , javax . swing . GroupLayout . DEFAULT_SIZE , 244 , Short . MAX_VALUE ) . addContainerGap ( ) ) ) ; }
hernad/oo-netbeans | private void performOK ( ) { StringBuffer result = new StringBuffer ( ) ; Node [ ] nodes = manager . getRootContext ( ) . getChildren ( ) . getNodes ( ) ; try { String structName = plStruct . getSimpleProperty ( plStruct . PROPERTY_CONTAINER_PACKAGE ) . concat ( " . " ) . concat ( plStruct . getSimpleProperty ( plStruct . PROPERTY_CONTAINER_NAME ) ) ; result . append ( structName ) . append ( " < ▁ " ) ; } catch ( UnknownOpenOfficeOrgPropertyException ex ) { LogWriter . getLogWriter ( ) . printStackTrace ( ex ) ; } for ( int i = 0 ; i < nodes . length ; i ++ ) { NbNodeObject nodeObject = ( NbNodeObject ) nodes [ i ] . getLookup ( ) . lookup ( NbNodeObject . class ) ; if ( nodeObject instanceof TemplateType ) { TemplateType templType = ( TemplateType ) nodeObject ; try { String type = templType . getSimpleProperty ( templType . PROPERTY_CONTAINER_TYPE ) ; if ( i != 0 ) { result . append ( " , " ) ; } result . append ( type ) ; } catch ( UnknownOpenOfficeOrgPropertyException ex ) { LogWriter . getLogWriter ( ) . printStackTrace ( ex ) ; } } } result . append ( " ▁ > " ) ; FeatureDescriptor desc = editor . getPropertyEnv ( ) . getFeatureDescriptor ( ) ; SimpleOpenOfficeOrgProperty . SimpleProperty prop = ( SimpleOpenOfficeOrgProperty . SimpleProperty ) desc ; editor . setAsText ( result . toString ( ) ) ; prop . setValue ( result . toString ( ) ) ; }
hernad/oo-netbeans | public ExplorerManager getExplorerManager ( ) { return manager ; }
hernad/oo-netbeans | public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( " OK " ) ) { performOK ( ) ; } }
AutonomousCarProject/AutonomousCar | default void setImage ( IPixel [ ] [ ] image ) { }
AutonomousCarProject/AutonomousCar | default int getFrameNo ( ) { return 0 ; }
apache/calcite | @ Test void convertAutomaton ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . repeat ( 1 , 2 ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . startState , is ( new DeterministicAutomaton . MultiState ( new Automaton . State ( 0 ) , new Automaton . State ( 2 ) ) ) ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 2 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 2 ) ) ; }
apache/calcite | @ Test void convertAutomaton2 ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . symbol ( " B " ) . or ( ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 2 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 1 ) ) ; }
apache/calcite | @ Test void convertAutomaton3 ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . symbol ( " B " ) . star ( ) . seq ( ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 3 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 2 ) ) ; }
apache/calcite | @ Test void convertAutomaton4 ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . symbol ( " B " ) . optional ( ) . seq ( ) . symbol ( " A " ) . seq ( ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 4 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 1 ) ) ; }
Lekanich/intellij-community | @ Before public void setUp ( ) throws Throwable { PlatformTestCase . initPlatformLangPrefix ( ) ; IdeaTestApplication . getInstance ( null ) ; myTestName = createTestName ( ) ; myProjectFixture = IdeaTestFixtureFactory . getFixtureFactory ( ) . createFixtureBuilder ( myTestName ) . getFixture ( ) ; edt ( new ThrowableRunnable < Exception > ( ) { @ Override public void run ( ) throws Exception { myProjectFixture . setUp ( ) ; } } ) ; myProject = myProjectFixture . getProject ( ) ; ( ( ProjectComponent ) ChangeListManager . getInstance ( myProject ) ) . projectOpened ( ) ; ( ( ProjectComponent ) VcsDirtyScopeManager . getInstance ( myProject ) ) . projectOpened ( ) ; myProjectRoot = myProject . getBasePath ( ) ; myProjectDir = myProject . getBaseDir ( ) ; myTestRoot = myProjectRoot ; myPlatformFacade = ServiceManager . getService ( myProject , GitPlatformFacade . class ) ; myGit = ServiceManager . getService ( myProject , Git . class ) ; mySettings = myPlatformFacade . getSettings ( myProject ) ; mySettings . getAppSettings ( ) . setPathToGit ( GitExecutor . PathHolder . GIT_EXECUTABLE ) ; myVcsHelper = GitTestUtil . overrideService ( myProject , AbstractVcsHelper . class , MockVcsHelper . class ) ; myChangeListManager = ( ChangeListManagerImpl ) myPlatformFacade . getChangeListManager ( myProject ) ; myNotificator = ( TestVcsNotifier ) ServiceManager . getService ( myProject , VcsNotifier . class ) ; myVcs = GitVcs . getInstance ( myProject ) ; virtualCommits = new GitTestVirtualCommitsHolder ( ) ; myAsyncTasks = new ArrayList < Future > ( ) ; cd ( myProjectRoot ) ; myRepository = GitTestUtil . createRepository ( myProject , myProjectRoot ) ; ProjectLevelVcsManagerImpl vcsManager = ( ProjectLevelVcsManagerImpl ) ProjectLevelVcsManager . getInstance ( myProject ) ; AbstractVcs vcs = vcsManager . findVcsByName ( " Git " ) ; Assert . assertEquals ( 1 , vcsManager . getRootsUnderVcs ( vcs ) . length ) ; GitTestUtil . assumeSupportedGitVersion ( myVcs ) ; LOG . info ( getStartTestMarker ( ) ) ; }
Lekanich/intellij-community | private String getStartTestMarker ( ) { return " Starting ▁ " + myTestName ; }
Lekanich/intellij-community | private String createTestName ( ) { return getClass ( ) . getName ( ) + " - " + new Random ( ) . nextInt ( ) ; }
Lekanich/intellij-community | @ Before ( value = " @ remote " , order = 1 ) public void setUpRemoteOperations ( ) { myHttpAuthService = ( GitHttpAuthTestService ) ServiceManager . getService ( GitHttpAuthService . class ) ; }
Lekanich/intellij-community | @ Before ( value = " @ nestedroot " , order = 2 ) public void setUpStandardMultipleRootsConfig ( ) { cd ( myProjectRoot ) ; File community = mkdir ( " community " ) ; GitTestUtil . createRepository ( myProject , community . getPath ( ) ) ; }
Lekanich/intellij-community | @ After ( value = " @ remote " , order = 5 ) public void tearDownRemoteOperations ( ) { }
Lekanich/intellij-community | for ( Future future : myAsyncTasks ) { future . get ( 30 , TimeUnit . SECONDS ) ; }
Lekanich/intellij-community | @ After ( order = 3 ) public void tearDownFixture ( ) throws Exception { edt ( new ThrowableRunnable < Exception > ( ) { @ Override public void run ( ) throws Exception { myProjectFixture . tearDown ( ) ; } } ) ; }
Lekanich/intellij-community | @ After ( order = 2 ) public void cleanupDir ( ) { FileUtil . delete ( new File ( myTestRoot ) ) ; }
Lekanich/intellij-community | @ After ( order = 1 ) public void cleanupWorld ( ) throws IllegalAccessException { for ( Field field : GitCucumberWorld . class . getDeclaredFields ( ) ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { field . set ( null , null ) ; } } }
Lekanich/intellij-community | @ After ( order = 0 ) public void dumpToLog ( @ NotNull Scenario result ) { if ( result . isFailed ( ) ) { TestLoggerFactory . dumpLogToStdout ( getStartTestMarker ( ) ) ; } }
jbb-project/jbb | public PostDto toDto ( Post post ) { PostAuthor author = post . getAuthor ( ) ; return PostDto . builder ( ) . id ( post . getId ( ) ) . topicId ( post . getTopicId ( ) ) . authorMemberId ( author . isMember ( ) ? author . getAuthorMemberId ( ) : null ) . anonymousName ( author . isAnonymous ( ) ? author . getAnonAuthorName ( ) : null ) . subject ( post . getSubject ( ) ) . postedAt ( post . getPostedAt ( ) ) . build ( ) ; }
jbb-project/jbb | public PostContentDto toContentDto ( FullPost post ) { PostAuthor author = post . getAuthor ( ) ; return PostContentDto . builder ( ) . id ( post . getId ( ) ) . topicId ( post . getTopicId ( ) ) . authorMemberId ( author . isMember ( ) ? author . getAuthorMemberId ( ) : null ) . anonymousName ( author . isAnonymous ( ) ? author . getAnonAuthorName ( ) : null ) . subject ( post . getSubject ( ) ) . postedAt ( post . getPostedAt ( ) ) . content ( post . getContent ( ) ) . build ( ) ; }
SaiVDivya04/Automation-Code- | public SafariDriverFactory ( final DriverConfig cfg ) { super ( cfg ) ; }
SaiVDivya04/Automation-Code- | @ Override public WebDriver createWebDriver ( ) { DesiredCapabilities cap = new SafariCapabilitiesFactory ( ) . createCapabilities ( webDriverConfig ) ; System . out . println ( " Begin ▁ Safari " ) ; synchronized ( this . getClass ( ) ) { driver = new SafariDriver ( cap ) ; } System . out . println ( " safari ▁ started " ) ; this . setWebDriver ( driver ) ; setImplicitWaitTimeout ( webDriverConfig . getImplicitWaitTimeout ( ) ) ; if ( webDriverConfig . getPageLoadTimeout ( ) >= 0 ) { TestLogging . log ( " Safari ▁ doesn ' t ▁ support ▁ pageLoadTimeout " ) ; } return driver ; }
JLengenfeld/deckcompare | public Deck importDeck ( @ NonNull URL url ) { try { return importDeck ( new File ( url . toURI ( ) ) ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( format ( " The ▁ provided ▁ URL ▁ ' % s ' ▁ cannot ▁ be ▁ converted ▁ to ▁ a ▁ URI . " , url ) , e ) ; } }
JLengenfeld/deckcompare | public Deck importDeck ( @ NonNull File file ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( format ( " File ▁ ' % s ' ▁ does ▁ not ▁ exist ! " , file ) ) ; } Deck deck = new Deck ( ) ; try { JAXBContext jaxbContext = JAXBContext . newInstance ( Deck . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; deck = ( Deck ) jaxbUnmarshaller . unmarshal ( file ) ; } catch ( JAXBException e ) { throw new ImportException ( " Could ▁ not ▁ import ▁ deck " , e ) ; } return deck ; }
snxamdf/gdmedicine | @ Override public BaseService < Role , String > getService ( ) { return roleService ; }
snxamdf/gdmedicine | @ Override public Module < Role > getModule ( ) { return new Module < Role > ( SYS . PROJECT , " role " , CTL . BMS , Role . class ) ; }
snxamdf/gdmedicine | @ RequestMapping ( " / user / distr " ) public String userRoleDist ( HttpServletRequest request , Model model ) { Iterable < Users > users = usersService . findAll ( new Filter ( " deletion " , Operator . EQ , "0" ) ) ; Iterable < Role > roles = roleService . findAll ( new Filter ( " deletion " , Operator . EQ , "0" ) ) ; model . addAttribute ( " users " , users ) ; model . addAttribute ( " roles " , roles ) ; return " sys / bms . role . user . distr . form " ; }
snxamdf/gdmedicine | @ ResponseBody @ RequestMapping ( " / user / get " ) public Result < List < UserRoles > > getRolesByUserId ( String uid ) { return Results . success ( userRolesRepository . findByUserId ( uid ) ) ; }
snxamdf/gdmedicine | @ ResponseBody @ RequestMapping ( " / user / distr / save " ) public Result < String > userRoleDistSave ( HttpServletRequest request , String user , Model model ) { if ( user == null || " - 1" . equals ( user ) ) { return Results . fault ( - 1 , " 请选择用户 " ) ; } String [ ] roles = request . getParameterValues ( " roles " ) ; if ( roles == null ) { return Results . fault ( - 1 , " 请选择权限 " ) ; } userRolesRepository . deleteByUserId ( user ) ; for ( String role : roles ) { UserRoles ur = new UserRoles ( ) ; ur . setUserId ( user ) ; ur . setRoleId ( role ) ; userRolesRepository . save ( ur ) ; } return Results . success ( " ok " ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | private Utilities ( ) { throw new UnsupportedOperationException ( " do ▁ not ▁ call " ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | @ Override public int compare ( ActionRequestValue ar1 , ActionRequestValue ar2 ) { int value = ar1 . getPriority ( ) . compareTo ( ar2 . getPriority ( ) ) ; if ( value == 0 ) { value = ActionRequestValue . compareActionCode ( ar1 . getActionRequested ( ) , ar2 . getActionRequested ( ) , true ) ; if ( value == 0 ) { if ( ( ar1 . getActionRequestId ( ) != null ) && ( ar2 . getActionRequestId ( ) != null ) ) { value = ar1 . getActionRequestId ( ) . compareTo ( ar2 . getActionRequestId ( ) ) ; } else { value = 0 ; } } } return value ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | @ Override public int compare ( ActionRequestValue ar1 , ActionRequestValue ar2 ) { if ( ! ar1 . getChildrenRequests ( ) . isEmpty ( ) ) { Collections . sort ( ar1 . getChildrenRequests ( ) , this ) ; } if ( ! ar2 . getChildrenRequests ( ) . isEmpty ( ) ) { Collections . sort ( ar2 . getChildrenRequests ( ) , this ) ; } int routeLevelCompareVal = ar1 . getRouteLevel ( ) . compareTo ( ar2 . getRouteLevel ( ) ) ; if ( routeLevelCompareVal != 0 ) { return routeLevelCompareVal ; } if ( ar1 . isActive ( ) && ar2 . isPending ( ) ) { return - 1 ; } else if ( ar2 . isActive ( ) && ar1 . isPending ( ) ) { return 1 ; } return super . compare ( ar1 , ar2 ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException ( @ Nullable String message ) { this ( message , null ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException ( @ Nullable Throwable throwable ) { this ( null , throwable ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException ( @ Nullable String message , @ Nullable Throwable throwable ) { super ( throwable ) ; putMessage ( message == null && throwable != null ? throwable . getMessage ( ) : message ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException put ( String key , String value ) { props . put ( key , value ) ; return this ; }
Duct-and-rice/KrswtkhrWiki4Android | @ Override public String getMessage ( ) { super . getMessage ( ) ; return propsToJsonMsg ( ) ; }
Duct-and-rice/KrswtkhrWiki4Android | private void putMessage ( @ Nullable String message ) { if ( message != null ) { props . put ( " message " , message ) ; } }
Duct-and-rice/KrswtkhrWiki4Android | private String propsToJsonMsg ( ) { return new JSONObject ( props ) . toString ( ) ; }
rinde/vanLon17-GPEM-code | @ Override public Collection < GPFunc < GpGlobal > > create ( ) { return Arrays . asList ( new If4 < GpGlobal > ( ) , new Add < GpGlobal > ( ) , new Sub < GpGlobal > ( ) , new Div < GpGlobal > ( ) , new Mul < GpGlobal > ( ) , new Pow < GpGlobal > ( ) , new Neg < GpGlobal > ( ) , new Min < GpGlobal > ( ) , new Max < GpGlobal > ( ) , new Constant < GpGlobal > ( 10 ) , new Constant < GpGlobal > ( 2 ) , new Constant < GpGlobal > ( 1 ) , new Constant < GpGlobal > ( 0 ) , new InsertionFlexibility ( ) , new InsertionCost ( ) , new InsertionTravelTime ( ) , new InsertionTardiness ( ) , new InsertionOverTime ( ) , new TimeLeft ( ) , new Slack ( ) , new Ado ( ) , new Mido ( ) , new Mado ( ) , new RouteLength ( ) , new PickupUrgency ( ) , new DeliveryUrgency ( ) ) ; }
anujbhan/airavata | public String getDeploymentID ( ) { return deploymentID ; }
anujbhan/airavata | public void setDeploymentID ( String deploymentID ) { this . deploymentID = deploymentID ; }
anujbhan/airavata | public String getName ( ) { return name ; }
anujbhan/airavata | public void setName ( String name ) { this . name = name ; }
anujbhan/airavata | public String getValue ( ) { return value ; }
anujbhan/airavata | public void setValue ( String value ) { this . value = value ; }
anujbhan/airavata | public ApplicationDeployment getApplicationDeployment ( ) { return applicationDeployment ; }
anujbhan/airavata | public void setApplicationDeployment ( ApplicationDeployment applicationDeployment ) { this . applicationDeployment = applicationDeployment ; }
medicayun/medicayundicom | public VMFFindScp ( QueryRetrieveScpService service ) { super ( service , true ) ; }
medicayun/medicayundicom | protected MultiDimseRsp newMultiCFindRsp ( Dataset rqData ) throws SQLException { if ( ! " IMAGE " . equals ( rqData . getString ( Tags . QueryRetrieveLevel ) ) ) return super . newMultiCFindRsp ( rqData ) ; final String studyIUID = rqData . getString ( Tags . StudyInstanceUID ) ; final String [ ] seriesIUIDs = rqData . getStrings ( Tags . SeriesInstanceUID ) ; if ( seriesIUIDs == null || seriesIUIDs . length == 0 ) throw new IllegalArgumentException ( " Missing ▁ Series ▁ Instance ▁ UID " ) ; return new VMFMultiCFindRsp ( studyIUID , seriesIUIDs ) ; }
medicayun/medicayundicom | public VMFMultiCFindRsp ( String studyIUID , String [ ] seriesIUIDs ) { keys = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; keys . putUI ( Tags . StudyInstanceUID , studyIUID ) ; this . seriesIUIDs = seriesIUIDs ; }
medicayun/medicayundicom | public DimseListener getCancelListener ( ) { return new DimseListener ( ) { public void dimseReceived ( Association assoc , Dimse dimse ) { canceled = true ; } } ; }
medicayun/medicayundicom | public Dataset next ( ActiveAssociation assoc , Dimse rq , Command rspCmd ) throws DcmServiceException { rspCmd . putUS ( Tags . Status , Status . Cancel ) ; while ( next < seriesIUIDs . length ) { if ( canceled ) return null ; keys . putUI ( Tags . SeriesInstanceUID , seriesIUIDs [ next ++ ] ) ; try { QueryCmd queryCmd = QueryCmd . createInstanceQuery ( keys , false , service . isNoMatchForNoValue ( ) ) ; try { queryCmd . execute ( ) ; if ( ! queryCmd . next ( ) ) continue ; final Dataset dataset = queryCmd . getDataset ( ) ; VMFBuilder builder = new VMFBuilder ( service , dataset , service . getVMFConfig ( dataset . getString ( Tags . SOPClassUID ) ) ) ; while ( queryCmd . next ( ) ) { if ( canceled ) return null ; builder . addFrame ( queryCmd . getDataset ( ) ) ; } if ( canceled ) return null ; rspCmd . putUS ( Tags . Status , Status . Pending ) ; return builder . getResult ( ) ; } finally { queryCmd . close ( ) ; } } catch ( Exception e ) { throw new DcmServiceException ( Status . UnableToProcess , e ) ; } } rspCmd . putUS ( Tags . Status , Status . Success ) ; return null ; }
medicayun/medicayundicom | public void release ( ) { }
pwjazz/mwanzia | public AuthenticationException ( ) { super ( ) ; }
pwjazz/mwanzia | public AuthenticationException ( String arg0 , Throwable arg1 ) { super ( arg0 , arg1 ) ; }
pwjazz/mwanzia | public AuthenticationException ( String arg0 ) { super ( arg0 ) ; }
pwjazz/mwanzia | public AuthenticationException ( Throwable arg0 ) { super ( arg0 ) ; }
apereo/cas | @ Override @ JsonIgnore public boolean isServiceAccessAllowed ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . isServiceAccessAllowed ( ) ; }
apereo/cas | @ Override @ JsonIgnore public void setServiceAccessAllowed ( final boolean enabled ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; this . groovyStrategyInstance . setServiceAccessAllowed ( enabled ) ; }
apereo/cas | @ Override @ JsonIgnore public boolean isServiceAccessAllowedForSso ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . isServiceAccessAllowedForSso ( ) ; }
apereo/cas | @ Override @ JsonIgnore public boolean doPrincipalAttributesAllowServiceAccess ( final String principal , final Map < String , Object > attributes ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . doPrincipalAttributesAllowServiceAccess ( principal , attributes ) ; }
apereo/cas | @ JsonIgnore @ Override public URI getUnauthorizedRedirectUrl ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . getUnauthorizedRedirectUrl ( ) ; }
apereo/cas | @ Override @ JsonIgnore public RegisteredServiceDelegatedAuthenticationPolicy getDelegatedAuthenticationPolicy ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . getDelegatedAuthenticationPolicy ( ) ; }
apereo/cas | @ Override @ JsonIgnore public Map < String , Set < String > > getRequiredAttributes ( ) { return this . groovyStrategyInstance . getRequiredAttributes ( ) ; }
apereo/cas | @ SneakyThrows private void buildGroovyAccessStrategyInstanceIfNeeded ( ) { if ( this . groovyStrategyInstance == null ) { val groovyResource = ResourceUtils . getResourceFrom ( SpringExpressionLanguageValueResolver . getInstance ( ) . resolve ( this . groovyScript ) ) ; this . groovyStrategyInstance = ScriptingUtils . getObjectInstanceFromGroovyResource ( groovyResource , RegisteredServiceAccessStrategy . class ) ; } }
erichwang/presto | @ Benchmark public List < Page > runPagesIndexSortBenchmark ( PagesIndexSortBenchmarkData data ) { PagesIndex . TestingFactory pagesIndexFactory = new PagesIndex . TestingFactory ( false ) ; PagesIndex pageIndex = pagesIndexFactory . newPagesIndex ( data . getTypes ( ) , data . getTotalPositions ( ) ) ; for ( Page page : data . getPages ( ) ) { pageIndex . addPage ( page ) ; } pageIndex . sort ( data . getSortChannels ( ) , data . getSortOrders ( ) ) ; return Streams . stream ( pageIndex . getSortedPages ( ) ) . collect ( toImmutableList ( ) ) ; }
erichwang/presto | @ Test public void verifyPagesIndexSortBenchmark ( ) { PagesIndexSortBenchmarkData state = new PagesIndexSortBenchmarkData ( ) ; state . setup ( ) ; List < Page > pages = runPagesIndexSortBenchmark ( state ) ; int positionCount = pages . stream ( ) . mapToInt ( Page :: getPositionCount ) . sum ( ) ; assertEquals ( positionCount , state . getTotalPositions ( ) ) ; }
erichwang/presto | @ Setup public void setup ( ) { super . setup ( numSortChannels , totalChannels , 1 , pagesCount ) ; }
erichwang/presto | @ Benchmark public List < Page > runPagesMergeSortBenchmark ( MergeSortedBenchmarkData data ) { WorkProcessor < Page > sortedPagesWork = mergeSortedPages ( data . getSplitPages ( ) . stream ( ) . map ( WorkProcessor :: fromIterable ) . collect ( toImmutableList ( ) ) , ORDERING_COMPILER . compilePageWithPositionComparator ( data . getSortTypes ( ) , data . getSortChannels ( ) , data . getSortOrders ( ) ) , data . getOutputChannels ( ) , data . getTypes ( ) , ( pageBuilder , pageWithPosition ) -> pageBuilder . isFull ( ) , false , newSimpleAggregatedMemoryContext ( ) , new DriverYieldSignal ( ) ) ; ImmutableList . Builder < Page > sortedPages = ImmutableList . builder ( ) ; while ( true ) { sortedPagesWork . process ( ) ; if ( sortedPagesWork . isFinished ( ) ) { return sortedPages . build ( ) ; } sortedPages . add ( sortedPagesWork . getResult ( ) ) ; } }
erichwang/presto | @ Test public void verifyPagesMergeSortBenchmark ( ) { MergeSortedBenchmarkData state = new MergeSortedBenchmarkData ( ) ; state . setup ( ) ; List < Page > pages = runPagesMergeSortBenchmark ( state ) ; int positionCount = pages . stream ( ) . mapToInt ( Page :: getPositionCount ) . sum ( ) ; assertEquals ( positionCount , state . getTotalPositions ( ) ) ; }
erichwang/presto | @ Setup public void setup ( ) { super . setup ( numSortChannels , totalChannels , numMergeSources , pagesCount ) ; }
erichwang/presto | protected void setup ( int numSortChannels , int totalChannels , int numMergeSources , int pagesCount ) { types = nCopies ( totalChannels , BIGINT ) ; sortChannels = new ArrayList < > ( ) ; for ( int i = 0 ; i < numSortChannels ; i ++ ) { sortChannels . add ( i ) ; } sortTypes = nCopies ( numSortChannels , BIGINT ) ; sortOrders = nCopies ( numSortChannels , ASC_NULLS_FIRST ) ; outputChannels = new ArrayList < > ( ) ; for ( int i = 0 ; i < totalChannels ; i ++ ) { outputChannels . add ( i ) ; } createPages ( totalChannels , pagesCount ) ; createPageProducers ( numMergeSources ) ; }
erichwang/presto | private void createPages ( int totalChannels , int pagesCount ) { int positionCount = PageBuilderStatus . DEFAULT_MAX_PAGE_SIZE_IN_BYTES / ( totalChannels * 8 ) ; pages = new ArrayList < > ( pagesCount ) ; for ( int numPage = 0 ; numPage < pagesCount ; numPage ++ ) { pages . add ( createSequencePage ( types , positionCount ) ) ; } totalPositions = positionCount * pagesCount ; }
erichwang/presto | private void createPageProducers ( int numMergeSources ) { AtomicInteger counter = new AtomicInteger ( 0 ) ; splitPages = pages . stream ( ) . collect ( Collectors . groupingBy ( it -> counter . getAndIncrement ( ) % numMergeSources ) ) . values ( ) . stream ( ) . collect ( toImmutableList ( ) ) ; }
erichwang/presto | List < Page > getPages ( ) { return pages ; }
erichwang/presto | int getTotalPositions ( ) { return totalPositions ; }
erichwang/presto | List < List < Page > > getSplitPages ( ) { return splitPages ; }
erichwang/presto | List < Type > getTypes ( ) { return types ; }
erichwang/presto | List < Integer > getSortChannels ( ) { return sortChannels ; }
erichwang/presto | List < Type > getSortTypes ( ) { return sortTypes ; }
erichwang/presto | List < SortOrder > getSortOrders ( ) { return sortOrders ; }
erichwang/presto | List < Integer > getOutputChannels ( ) { return outputChannels ; }
Fokko/druid | @ Override public void configure ( Binder binder ) { JsonConfigProvider . bind ( binder , " druid . emitter . http " , HttpEmitterConfig . class ) ; JsonConfigProvider . bind ( binder , " druid . emitter . http . ssl " , HttpEmitterSSLClientConfig . class ) ; configureSsl ( binder ) ; }
Fokko/druid | @ Provides @ ManageLifecycle @ Named ( " http " ) public Emitter getEmitter ( Supplier < HttpEmitterConfig > config , Supplier < HttpEmitterSSLClientConfig > sslConfig , @ Nullable SSLContext sslContext , Lifecycle lifecycle , ObjectMapper jsonMapper ) { return new HttpPostEmitter ( config . get ( ) , lifecycle . addCloseableInstance ( createAsyncHttpClient ( " HttpPostEmitter - AsyncHttpClient - % d " , " HttpPostEmitter - AsyncHttpClient - Timer - % d " , getEffectiveSSLContext ( sslConfig . get ( ) , sslContext ) ) ) , jsonMapper ) ; }
hotchemi/wearzaim | public SendLoginStatusService ( ) { super ( TAG ) ; }
hotchemi/wearzaim | @ Override public void onHandleIntent ( Intent intent ) { GoogleApiClient googleApiClient = new GoogleApiClient . Builder ( this ) . addApi ( Wearable . API ) . build ( ) ; ConnectionResult result = googleApiClient . blockingConnect ( CONNECT_TIMEOUT_MS , TimeUnit . MILLISECONDS ) ; if ( ! result . isSuccess ( ) ) { Log . e ( TAG , " Failed ▁ to ▁ connect ▁ to ▁ GoogleApiClient . " ) ; return ; } String login = intent . getStringExtra ( KEY_LOGIN ) ; Wearable . MessageApi . sendMessage ( googleApiClient , REQUEST_PATH , RESET_PATH , Base64Utils . encode ( login ) ) ; }
coderkiss/ImageLoader | @ SuppressLint ( " UseSparseArrays " ) protected ImageLoader ( ) { if ( config == null ) { config = new LoaderConfig ( ) ; } config = config . build ( ) ; loadingView = Collections . synchronizedMap ( new HashMap < Integer , ViewPack > ( ) ) ; pathLocks = new WeakHashMap < String , ReentrantLock > ( ) ; }
coderkiss/ImageLoader | public void resume ( ) { if ( ! config . paused . get ( ) ) { LogUtil . w ( TAG , " image ▁ loader ▁ not ▁ paused ! " ) ; return ; } config . paused . set ( false ) ; synchronized ( config . pauseLock ) { config . pauseLock . notifyAll ( ) ; } }
coderkiss/ImageLoader | public void pause ( ) { if ( config . paused . get ( ) ) { LogUtil . w ( TAG , " image ▁ loader ▁ already ▁ paused ! " ) ; return ; } config . paused . set ( true ) ; }
coderkiss/ImageLoader | public void stop ( ) { for ( int vid : loadingView . keySet ( ) ) { loadingView . get ( vid ) . collect ( ) ; } loadingView . clear ( ) ; pathLocks . clear ( ) ; ( ( ExecutorService ) config . remoteExecutor ) . shutdownNow ( ) ; ( ( ExecutorService ) config . nativeExecutor ) . shutdownNow ( ) ; }
coderkiss/ImageLoader | public void destroy ( ) { }
coderkiss/ImageLoader | public void load ( String path , LoaderListener listener ) { load ( null , path , listener , false ) ; }
coderkiss/ImageLoader | public void load ( String path , LoaderListener listener , boolean origin ) { load ( null , path , listener , origin ) ; }
coderkiss/ImageLoader | public void load ( ImageView imageView , String path ) { load ( imageView , path , null , false ) ; }
coderkiss/ImageLoader | public void load ( ImageView imageView , String path , boolean origin ) { load ( imageView , path , null , false ) ; }
coderkiss/ImageLoader | public void load ( ImageView imageView , String path , LoaderListener listener ) { load ( imageView , path , null , false ) ; }
coderkiss/ImageLoader | public synchronized void load ( ImageView imageView , String path , LoaderListener listener , boolean origin ) { if ( StringUtil . isEmpty ( path ) ) { return ; } imageView . setImageBitmap ( null ) ; String key = config . namer . create ( path ) ; ViewPack vp = new ViewPack ( imageView , path ) ; if ( loadingView . containsKey ( vp . getId ( ) ) ) { ViewPack oldPack = loadingView . remove ( vp . getId ( ) ) ; String oldPath = oldPack . getPath ( ) ; LogUtil . d ( TAG , " collect ▁ old ▁ view ▁ " + oldPath ) ; oldPack . collect ( ) ; } loadingView . put ( vp . getId ( ) , vp ) ; LoadHandler loader = new LoadHandler ( ) ; ReentrantLock lock = getLock ( path ) ; LoaderInfo loadInfo = new LoaderInfo ( path , key , vp , lock ) ; loadInfo . origin = origin ; loadInfo . loader = this ; loader . listener = listener ; loader . config = config ; loader . loadInfo = loadInfo ; boolean disk = config . diskCache . contains ( key ) ; boolean mem = config . memCache . contains ( key ) ; if ( mem || disk ) { config . nativeExecutor . execute ( loader ) ; } else { config . remoteExecutor . execute ( loader ) ; } }
coderkiss/ImageLoader | private ReentrantLock getLock ( String path ) { ReentrantLock lock = pathLocks . get ( path ) ; if ( lock == null ) { lock = new ReentrantLock ( ) ; pathLocks . put ( path , lock ) ; } return lock ; }
coderkiss/ImageLoader | public synchronized boolean cancel ( ImageView imageView ) { ViewPack viewPack = new ViewPack ( imageView , null ) ; viewPack = loadingView . remove ( viewPack . getId ( ) ) ; if ( viewPack != null ) { String path = viewPack . getPath ( ) ; LogUtil . d ( TAG , " cancel ▁ load ▁ " + path ) ; viewPack . collect ( ) ; } return viewPack != null ; }
coderkiss/ImageLoader | public synchronized boolean cancel ( String path ) { if ( StringUtil . isEmpty ( path ) ) { LogUtil . w ( TAG , " invalid ▁ path " ) ; return false ; } boolean removed = false ; Iterator < Integer > iterator = loadingView . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { int vid = iterator . next ( ) ; ViewPack vp = loadingView . get ( vid ) ; if ( path . equals ( vp . getPath ( ) ) ) { iterator . remove ( ) ; LogUtil . d ( TAG , " cancel ▁ load ▁ " + path ) ; vp . collect ( ) ; removed = true ; } } return removed ; }
CheezeCake/muStreamerClient | public final void __completed ( Ice . AsyncResult __result ) { IMusicServerPrx __proxy = ( IMusicServerPrx ) __result . getProxy ( ) ; StreamToken __ret = null ; try { __ret = __proxy . end_setupStreaming ( __result ) ; } catch ( Ice . LocalException __ex ) { exception ( __ex ) ; return ; } response ( __ret ) ; }
shalk/TIJ4Code | public void foo ( ) { System . out . println ( " abstract ▁ foo " ) ; }
tillrohrmann/flink | protected AbstractHandler ( @ Nonnull GatewayRetriever < ? extends T > leaderRetriever , @ Nonnull Time timeout , @ Nonnull Map < String , String > responseHeaders , @ Nonnull UntypedResponseMessageHeaders < R , M > untypedResponseMessageHeaders ) { super ( leaderRetriever , timeout , responseHeaders ) ; this . untypedResponseMessageHeaders = Preconditions . checkNotNull ( untypedResponseMessageHeaders ) ; this . inFlightRequestTracker = new InFlightRequestTracker ( ) ; }
tillrohrmann/flink | @ Override protected void respondAsLeader ( ChannelHandlerContext ctx , RoutedRequest routedRequest , T gateway ) { HttpRequest httpRequest = routedRequest . getRequest ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " Received ▁ request ▁ " + httpRequest . uri ( ) + ' . ' ) ; } FileUploads uploadedFiles = null ; try { if ( ! inFlightRequestTracker . registerRequest ( ) ) { log . debug ( " The ▁ handler ▁ instance ▁ for ▁ { } ▁ had ▁ already ▁ been ▁ closed . " , untypedResponseMessageHeaders . getTargetRestEndpointURL ( ) ) ; ctx . channel ( ) . close ( ) ; return ; } if ( ! ( httpRequest instanceof FullHttpRequest ) ) { log . error ( " Implementation ▁ error : ▁ Received ▁ a ▁ request ▁ that ▁ wasn ' t ▁ a ▁ FullHttpRequest . " ) ; throw new RestHandlerException ( " Bad ▁ request ▁ received . " , HttpResponseStatus . BAD_REQUEST ) ; } final ByteBuf msgContent = ( ( FullHttpRequest ) httpRequest ) . content ( ) ; uploadedFiles = FileUploadHandler . getMultipartFileUploads ( ctx ) ; if ( ! untypedResponseMessageHeaders . acceptsFileUploads ( ) && ! uploadedFiles . getUploadedFiles ( ) . isEmpty ( ) ) { throw new RestHandlerException ( " File ▁ uploads ▁ not ▁ allowed . " , HttpResponseStatus . BAD_REQUEST ) ; } R request ; if ( msgContent . capacity ( ) == 0 ) { try { request = MAPPER . readValue ( " { } " , untypedResponseMessageHeaders . getRequestClass ( ) ) ; } catch ( JsonParseException | JsonMappingException je ) { throw new RestHandlerException ( " Bad ▁ request ▁ received . ▁ Request ▁ did ▁ not ▁ conform ▁ to ▁ expected ▁ format . " , HttpResponseStatus . BAD_REQUEST , je ) ; } } else { try { InputStream in = new ByteBufInputStream ( msgContent ) ; request = MAPPER . readValue ( in , untypedResponseMessageHeaders . getRequestClass ( ) ) ; } catch ( JsonParseException | JsonMappingException je ) { throw new RestHandlerException ( String . format ( " Request ▁ did ▁ not ▁ match ▁ expected ▁ format ▁ % s . " , untypedResponseMessageHeaders . getRequestClass ( ) . getSimpleName ( ) ) , HttpResponseStatus . BAD_REQUEST , je ) ; } } final HandlerRequest < R , M > handlerRequest ; try { handlerRequest = new HandlerRequest < R , M > ( request , untypedResponseMessageHeaders . getUnresolvedMessageParameters ( ) , routedRequest . getRouteResult ( ) . pathParams ( ) , routedRequest . getRouteResult ( ) . queryParams ( ) , uploadedFiles . getUploadedFiles ( ) ) ; } catch ( HandlerRequestException hre ) { log . error ( " Could ▁ not ▁ create ▁ the ▁ handler ▁ request . " , hre ) ; throw new RestHandlerException ( String . format ( " Bad ▁ request , ▁ could ▁ not ▁ parse ▁ parameters : ▁ % s " , hre . getMessage ( ) ) , HttpResponseStatus . BAD_REQUEST , hre ) ; } log . trace ( " Starting ▁ request ▁ processing . " ) ; CompletableFuture < Void > requestProcessingFuture = respondToRequest ( ctx , httpRequest , handlerRequest , gateway ) ; final FileUploads finalUploadedFiles = uploadedFiles ; requestProcessingFuture . handle ( ( Void ignored , Throwable throwable ) -> { if ( throwable != null ) { return handleException ( ExceptionUtils . stripCompletionException ( throwable ) , ctx , httpRequest ) ; } return CompletableFuture . < Void > completedFuture ( null ) ; } ) . thenCompose ( Function . identity ( ) ) . whenComplete ( ( Void ignored , Throwable throwable ) -> { if ( throwable != null ) { log . warn ( " An ▁ exception ▁ occurred ▁ while ▁ handling ▁ another ▁ exception . " , throwable ) ; } finalizeRequestProcessing ( finalUploadedFiles ) ; } ) ; } catch ( Throwable e ) { final FileUploads finalUploadedFiles = uploadedFiles ; handleException ( e , ctx , httpRequest ) . whenComplete ( ( Void ignored , Throwable throwable ) -> finalizeRequestProcessing ( finalUploadedFiles ) ) ; } }
tillrohrmann/flink | private void finalizeRequestProcessing ( FileUploads uploadedFiles ) { inFlightRequestTracker . deregisterRequest ( ) ; cleanupFileUploads ( uploadedFiles ) ; }
tillrohrmann/flink | private CompletableFuture < Void > handleException ( Throwable throwable , ChannelHandlerContext ctx , HttpRequest httpRequest ) { ClusterEntryPointExceptionUtils . tryEnrichClusterEntryPointError ( throwable ) ; FlinkHttpObjectAggregator flinkHttpObjectAggregator = ctx . pipeline ( ) . get ( FlinkHttpObjectAggregator . class ) ; if ( flinkHttpObjectAggregator == null ) { log . warn ( " The ▁ connection ▁ was ▁ unexpectedly ▁ closed ▁ by ▁ the ▁ client . " ) ; return CompletableFuture . completedFuture ( null ) ; } int maxLength = flinkHttpObjectAggregator . maxContentLength ( ) - OTHER_RESP_PAYLOAD_OVERHEAD ; if ( throwable instanceof RestHandlerException ) { RestHandlerException rhe = ( RestHandlerException ) throwable ; String stackTrace = ExceptionUtils . stringifyException ( rhe ) ; String truncatedStackTrace = Ascii . truncate ( stackTrace , maxLength , " . . . " ) ; if ( log . isDebugEnabled ( ) ) { log . error ( " Exception ▁ occurred ▁ in ▁ REST ▁ handler . " , rhe ) ; } else if ( rhe . logException ( ) ) { log . error ( " Exception ▁ occurred ▁ in ▁ REST ▁ handler : ▁ { } " , rhe . getMessage ( ) ) ; } return HandlerUtils . sendErrorResponse ( ctx , httpRequest , new ErrorResponseBody ( truncatedStackTrace ) , rhe . getHttpResponseStatus ( ) , responseHeaders ) ; } else { log . error ( " Unhandled ▁ exception . " , throwable ) ; String stackTrace = String . format ( " < Exception ▁ on ▁ server ▁ side : % n % s % nEnd ▁ of ▁ exception ▁ on ▁ server ▁ side > " , ExceptionUtils . stringifyException ( throwable ) ) ; String truncatedStackTrace = Ascii . truncate ( stackTrace , maxLength , " . . . " ) ; return HandlerUtils . sendErrorResponse ( ctx , httpRequest , new ErrorResponseBody ( Arrays . asList ( " Internal ▁ server ▁ error . " , truncatedStackTrace ) ) , HttpResponseStatus . INTERNAL_SERVER_ERROR , responseHeaders ) ; } }
tillrohrmann/flink | @ Override public final CompletableFuture < Void > closeAsync ( ) { synchronized ( lock ) { if ( terminationFuture == null ) { this . terminationFuture = FutureUtils . composeAfterwards ( closeHandlerAsync ( ) , inFlightRequestTracker :: awaitAsync ) ; } else { log . warn ( " The ▁ handler ▁ instance ▁ for ▁ { } ▁ had ▁ already ▁ been ▁ closed , ▁ but ▁ another ▁ attempt ▁ at ▁ closing ▁ it ▁ was ▁ made . " , untypedResponseMessageHeaders . getTargetRestEndpointURL ( ) ) ; } return this . terminationFuture ; } }
tillrohrmann/flink | protected CompletableFuture < Void > closeHandlerAsync ( ) { return CompletableFuture . completedFuture ( null ) ; }
tillrohrmann/flink | private void cleanupFileUploads ( @ Nullable FileUploads uploadedFiles ) { if ( uploadedFiles != null ) { try { uploadedFiles . close ( ) ; } catch ( IOException e ) { log . warn ( " Could ▁ not ▁ cleanup ▁ uploaded ▁ files . " , e ) ; } } }
QuantumRand/cordova-plugin-geofence | public ReceiveTransitionsIntentService ( ) { super ( " ReceiveTransitionsIntentService " ) ; beepHelper = new BeepHelper ( ) ; store = new GeoNotificationStore ( this ) ; Logger . setLogger ( new Logger ( GeofencePlugin . TAG , this , false ) ) ; }
QuantumRand/cordova-plugin-geofence | @ Override protected void onHandleIntent ( Intent intent ) { Logger logger = Logger . getLogger ( ) ; logger . log ( Log . DEBUG , " ReceiveTransitionsIntentService ▁ - ▁ onHandleIntent " ) ; Intent broadcastIntent = new Intent ( GeofenceTransitionIntent ) ; notifier = new GeoNotificationNotifier ( ( NotificationManager ) this . getSystemService ( Context . NOTIFICATION_SERVICE ) , this ) ; GeofencingEvent geofencingEvent = GeofencingEvent . fromIntent ( intent ) ; if ( geofencingEvent . hasError ( ) ) { int errorCode = geofencingEvent . getErrorCode ( ) ; String error = " Location ▁ Services ▁ error : ▁ " + Integer . toString ( errorCode ) ; logger . log ( Log . ERROR , error ) ; broadcastIntent . putExtra ( " error " , error ) ; } else { int transitionType = geofencingEvent . getGeofenceTransition ( ) ; if ( ( transitionType == Geofence . GEOFENCE_TRANSITION_ENTER ) || ( transitionType == Geofence . GEOFENCE_TRANSITION_EXIT ) ) { logger . log ( Log . DEBUG , " Geofence ▁ transition ▁ detected " ) ; List < Geofence > triggerList = geofencingEvent . getTriggeringGeofences ( ) ; List < GeoNotification > geoNotifications = new ArrayList < GeoNotification > ( ) ; for ( Geofence fence : triggerList ) { String fenceId = fence . getRequestId ( ) ; GeoNotification geoNotification = store . getGeoNotification ( fenceId ) ; if ( geoNotification != null ) { if ( geoNotification . notification != null ) { if ( geoNotification . isScheduled ( ) && geoNotification . isFrequencyOk ( ) ) { geoNotification . notification . setLastTriggered ( ) ; store . setGeoNotification ( geoNotification ) ; notifier . notify ( geoNotification . notification ) ; } } geoNotification . transitionType = transitionType ; geoNotifications . add ( geoNotification ) ; } } if ( geoNotifications . size ( ) > 0 ) { broadcastIntent . putExtra ( " transitionData " , Gson . get ( ) . toJson ( geoNotifications ) ) ; GeofencePlugin . onTransitionReceived ( geoNotifications ) ; } } else { String error = " Geofence ▁ transition ▁ error : ▁ " + transitionType ; logger . log ( Log . ERROR , error ) ; broadcastIntent . putExtra ( " error " , error ) ; } } sendBroadcast ( broadcastIntent ) ; }
jivesoftware/leaps-and-bounds | @ Test public void test ( ) { }
JavaSaBr/jME3-SpaceShift-Editor | protected BaseFileEditor ( ) { this . operationControl = createOperationControl ( ) ; this . changeCounter = new AtomicInteger ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected @ NotNull EditorOperationControl createOperationControl ( ) { return new EditorOperationControl ( this ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FromAnyThread public void execute ( @ NotNull final EditorOperation operation ) { operationControl . execute ( operation ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread @ Override protected boolean handleKeyActionImpl ( @ NotNull final KeyCode keyCode , final boolean isPressed , final boolean isControlDown , final boolean isShiftDown , final boolean isButtonMiddleDown ) { if ( isPressed && isControlDown && keyCode == KeyCode . Z ) { undo ( ) ; return true ; } else if ( isPressed && isControlDown && isShiftDown && keyCode == KeyCode . Z ) { redo ( ) ; return true ; } else if ( isPressed && isControlDown && keyCode == KeyCode . Y ) { redo ( ) ; return true ; } return super . handleKeyActionImpl ( keyCode , isPressed , isControlDown , isShiftDown , isButtonMiddleDown ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public void incrementChange ( ) { final int result = changeCounter . incrementAndGet ( ) ; setDirty ( result != 0 ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public void decrementChange ( ) { final int result = changeCounter . decrementAndGet ( ) ; setDirty ( result != 0 ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FromAnyThread public void redo ( ) { operationControl . redo ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FromAnyThread public void undo ( ) { operationControl . undo ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected @ NotNull EditorOperationControl getOperationControl ( ) { return operationControl ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public void openFile ( @ NotNull final Path file ) { super . openFile ( file ) ; try { doOpenFile ( file ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } EXECUTOR_MANAGER . addFxTask ( this :: loadState ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected void loadState ( ) { final Supplier < EditorState > stateFactory = getEditorStateFactory ( ) ; if ( stateFactory == null ) { return ; } final WorkspaceManager workspaceManager = WorkspaceManager . getInstance ( ) ; final Workspace currentWorkspace = notNull ( workspaceManager . getCurrentWorkspace ( ) ) ; editorState = currentWorkspace . getEditorState ( getEditFile ( ) , stateFactory ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected @ Nullable Supplier < EditorState > getEditorStateFactory ( ) { return null ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected void doOpenFile ( @ NotNull final Path file ) throws IOException { }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected void setIgnoreListeners ( final boolean ignoreListeners ) { this . ignoreListeners = ignoreListeners ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected boolean isIgnoreListeners ( ) { return ignoreListeners ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected @ NotNull StackPane createRoot ( ) { return new StackPane ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public @ Nullable BorderPane get3DArea ( ) { return null ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected @ Nullable S getEditorState ( ) { return editorState ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public boolean isInside ( final double sceneX , final double sceneY , @ NotNull final Class < ? extends Event > eventType ) { return false ; }
sajavadi/pinot | private SegmentPrunerProvider ( ) { }
jgaupp/arx | public ComponentStatusLabel ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; if ( ( style & ( SWT . CENTER | SWT . RIGHT ) ) == 0 ) style |= SWT . LEFT ; if ( ( style & SWT . CENTER ) != 0 ) align = SWT . CENTER ; if ( ( style & SWT . RIGHT ) != 0 ) align = SWT . RIGHT ; if ( ( style & SWT . LEFT ) != 0 ) align = SWT . LEFT ; addPaintListener ( new PaintListener ( ) { public void paintControl ( PaintEvent event ) { onPaint ( event ) ; } } ) ; addTraverseListener ( new TraverseListener ( ) { public void keyTraversed ( TraverseEvent event ) { if ( event . detail == SWT . TRAVERSE_MNEMONIC ) { onMnemonic ( event ) ; } } } ) ; addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event event ) { onDispose ( event ) ; } } ) ; initAccessible ( ) ; }
jgaupp/arx | public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; Point e = getTotalSize ( image , text ) ; if ( wHint == SWT . DEFAULT ) { e . x += leftMargin + rightMargin ; } else { e . x = wHint ; } if ( hHint == SWT . DEFAULT ) { e . y += topMargin + bottomMargin ; } else { e . y = hHint ; } return e ; }
jgaupp/arx | @ Override public void dispose ( ) { super . dispose ( ) ; }
jgaupp/arx | public int getAlignment ( ) { return align ; }
jgaupp/arx | public int getBottomMargin ( ) { return bottomMargin ; }
jgaupp/arx | public Image getImage ( ) { return image ; }
jgaupp/arx | public int getLeftMargin ( ) { return leftMargin ; }
jgaupp/arx | public int getRightMargin ( ) { return rightMargin ; }
jgaupp/arx | public int getStyle ( ) { int style = super . getStyle ( ) ; switch ( align ) { case SWT . RIGHT : style |= SWT . RIGHT ; break ; case SWT . CENTER : style |= SWT . CENTER ; break ; case SWT . LEFT : style |= SWT . LEFT ; break ; } return style ; }
jgaupp/arx | public String getText ( ) { return text ; }
jgaupp/arx | public String getToolTipText ( ) { checkWidget ( ) ; return appToolTipText ; }
jgaupp/arx | public int getTopMargin ( ) { return topMargin ; }
jgaupp/arx | public void setAlignment ( int align ) { checkWidget ( ) ; if ( align != SWT . LEFT && align != SWT . RIGHT && align != SWT . CENTER ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( this . align != align ) { this . align = align ; redraw ( ) ; } }
jgaupp/arx | public void setBackground ( Color color ) { super . setBackground ( color ) ; if ( backgroundImage == null && gradientColors == null && gradientPercents == null ) { if ( color == null ) { if ( background == null ) return ; } else { if ( color . equals ( background ) ) return ; } } background = color ; backgroundImage = null ; gradientColors = null ; gradientPercents = null ; redraw ( ) ; }
jgaupp/arx | public void setBackground ( Color [ ] colors , int [ ] percents ) { setBackground ( colors , percents , false ) ; }
jgaupp/arx | public void setBackground ( Color [ ] colors , int [ ] percents , boolean vertical ) { checkWidget ( ) ; if ( colors != null ) { if ( percents == null || percents . length != colors . length - 1 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( getDisplay ( ) . getDepth ( ) < 15 ) { colors = new Color [ ] { colors [ colors . length - 1 ] } ; percents = new int [ ] { } ; } for ( int i = 0 ; i < percents . length ; i ++ ) { if ( percents [ i ] < 0 || percents [ i ] > 100 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( i > 0 && percents [ i ] < percents [ i - 1 ] ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } } } final Color background = getBackground ( ) ; if ( backgroundImage == null ) { if ( ( gradientColors != null ) && ( colors != null ) && ( gradientColors . length == colors . length ) ) { boolean same = false ; for ( int i = 0 ; i < gradientColors . length ; i ++ ) { same = ( gradientColors [ i ] == colors [ i ] ) || ( ( gradientColors [ i ] == null ) && ( colors [ i ] == background ) ) || ( ( gradientColors [ i ] == background ) && ( colors [ i ] == null ) ) ; if ( ! same ) break ; } if ( same ) { for ( int i = 0 ; i < gradientPercents . length ; i ++ ) { same = gradientPercents [ i ] == percents [ i ] ; if ( ! same ) break ; } } if ( same && this . gradientVertical == vertical ) return ; } } else { backgroundImage = null ; } if ( colors == null ) { gradientColors = null ; gradientPercents = null ; gradientVertical = false ; } else { gradientColors = new Color [ colors . length ] ; for ( int i = 0 ; i < colors . length ; ++ i ) gradientColors [ i ] = ( colors [ i ] != null ) ? colors [ i ] : background ; gradientPercents = new int [ percents . length ] ; for ( int i = 0 ; i < percents . length ; ++ i ) gradientPercents [ i ] = percents [ i ] ; gradientVertical = vertical ; } redraw ( ) ; }
jgaupp/arx | public void setBackground ( Image image ) { checkWidget ( ) ; if ( image == backgroundImage ) return ; if ( image != null ) { gradientColors = null ; gradientPercents = null ; } backgroundImage = image ; redraw ( ) ; }
jgaupp/arx | public void setBottomMargin ( int bottomMargin ) { checkWidget ( ) ; if ( this . bottomMargin == bottomMargin || bottomMargin < 0 ) return ; this . bottomMargin = bottomMargin ; redraw ( ) ; }
jgaupp/arx | public void setFont ( Font font ) { super . setFont ( font ) ; redraw ( ) ; }
jgaupp/arx | public void setGIF ( InputStream inputStream ) { checkWidget ( ) ; if ( thread != null ) { thread . stop ( ) ; this . getDisplay ( ) . timerExec ( - 1 , thread ) ; } ImageLoader loader = new ImageLoader ( ) ; try { loader . load ( inputStream ) ; } catch ( Exception e ) { this . image = null ; return ; } if ( loader . data [ 0 ] != null ) this . image = new Image ( this . getDisplay ( ) , loader . data [ 0 ] ) ; if ( loader . data . length > 1 ) { thread = new ComponentStatusLabelGIFHandler ( this , loader ) ; thread . run ( ) ; } redraw ( ) ; }
jgaupp/arx | public void setGIF ( String path ) { try { this . setGIF ( new FileInputStream ( new File ( path ) ) ) ; } catch ( FileNotFoundException e ) { this . image = null ; return ; } }
jgaupp/arx | public void setImage ( Image image ) { checkWidget ( ) ; if ( thread != null ) { thread . stop ( ) ; getDisplay ( ) . timerExec ( - 1 , thread ) ; } if ( image != this . image ) { this . image = image ; redraw ( ) ; } }
jgaupp/arx | public void setLeftMargin ( int leftMargin ) { checkWidget ( ) ; if ( this . leftMargin == leftMargin || leftMargin < 0 ) return ; this . leftMargin = leftMargin ; redraw ( ) ; }
jgaupp/arx | public void setMargins ( int leftMargin , int topMargin , int rightMargin , int bottomMargin ) { checkWidget ( ) ; this . leftMargin = Math . max ( 0 , leftMargin ) ; this . topMargin = Math . max ( 0 , topMargin ) ; this . rightMargin = Math . max ( 0 , rightMargin ) ; this . bottomMargin = Math . max ( 0 , bottomMargin ) ; redraw ( ) ; }
jgaupp/arx | public void setProgressProvider ( ComponentStatusLabelProgressProvider provider ) { this . progressProvider = provider ; }
jgaupp/arx | public void setRightMargin ( int rightMargin ) { checkWidget ( ) ; if ( this . rightMargin == rightMargin || rightMargin < 0 ) return ; this . rightMargin = rightMargin ; redraw ( ) ; }
jgaupp/arx | public void setText ( String text ) { checkWidget ( ) ; if ( text == null ) text = " " ; if ( ! text . equals ( this . text ) ) { this . text = text ; redraw ( ) ; } }
jgaupp/arx | public void setToolTipText ( String string ) { super . setToolTipText ( string ) ; appToolTipText = super . getToolTipText ( ) ; }
jgaupp/arx | public void setTopMargin ( int topMargin ) { checkWidget ( ) ; if ( this . topMargin == topMargin || topMargin < 0 ) return ; this . topMargin = topMargin ; redraw ( ) ; }
jgaupp/arx | public void updateImage ( Image image ) { this . image = image ; this . redraw ( ) ; }
jgaupp/arx | private void drawBevelRect ( GC gc , int x , int y , int w , int h , Color topleft , Color bottomright ) { gc . setForeground ( bottomright ) ; gc . drawLine ( x + w , y , x + w , y + h ) ; gc . drawLine ( x , y + h , x + w , y + h ) ; gc . setForeground ( topleft ) ; gc . drawLine ( x , y , x + w - 1 , y ) ; gc . drawLine ( x , y , x , y + h - 1 ) ; }
jgaupp/arx | private Point getTotalSize ( Image image , String text ) { Point size = new Point ( 0 , 0 ) ; if ( image != null ) { Rectangle r = image . getBounds ( ) ; size . x += r . width ; size . y += r . height ; } GC gc = new GC ( this ) ; if ( text != null && text . length ( ) > 0 ) { Point e = gc . textExtent ( text , DRAW_FLAGS ) ; size . x += e . x ; size . y = Math . max ( size . y , e . y ) ; if ( image != null ) size . x += GAP ; } else { size . y = Math . max ( size . y , gc . getFontMetrics ( ) . getHeight ( ) ) ; } gc . dispose ( ) ; return size ; }
jgaupp/arx | private void initAccessible ( ) { Accessible accessible = getAccessible ( ) ; accessible . addAccessibleListener ( new AccessibleAdapter ( ) { public void getHelp ( AccessibleEvent e ) { e . result = getToolTipText ( ) ; } public void getKeyboardShortcut ( AccessibleEvent e ) { char mnemonic = _findMnemonic ( ComponentStatusLabel . this . text ) ; if ( mnemonic != ' \0' ) { e . result = " Alt + " + mnemonic ; } } public void getName ( AccessibleEvent e ) { e . result = getText ( ) ; } } ) ; accessible . addAccessibleControlListener ( new AccessibleControlAdapter ( ) { public void getChildAtPoint ( AccessibleControlEvent e ) { e . childID = ACC . CHILDID_SELF ; } public void getChildCount ( AccessibleControlEvent e ) { e . detail = 0 ; } public void getLocation ( AccessibleControlEvent e ) { Rectangle rect = getDisplay ( ) . map ( getParent ( ) , null , getBounds ( ) ) ; e . x = rect . x ; e . y = rect . y ; e . width = rect . width ; e . height = rect . height ; } public void getRole ( AccessibleControlEvent e ) { e . detail = ACC . ROLE_LABEL ; } public void getState ( AccessibleControlEvent e ) { e . detail = ACC . STATE_READONLY ; } } ) ; }
jgaupp/arx | private void paintBorder ( GC gc , Rectangle r ) { Display disp = getDisplay ( ) ; Color c1 = null ; Color c2 = null ; int style = getStyle ( ) ; if ( ( style & SWT . SHADOW_IN ) != 0 ) { c1 = disp . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; c2 = disp . getSystemColor ( SWT . COLOR_WIDGET_HIGHLIGHT_SHADOW ) ; } if ( ( style & SWT . SHADOW_OUT ) != 0 ) { c1 = disp . getSystemColor ( SWT . COLOR_WIDGET_LIGHT_SHADOW ) ; c2 = disp . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; } if ( c1 != null && c2 != null ) { gc . setLineWidth ( 1 ) ; drawBevelRect ( gc , r . x , r . y , r . width - 1 , r . height - 1 , c1 , c2 ) ; } }
jgaupp/arx | private String [ ] splitString ( String text ) { String [ ] lines = new String [ 1 ] ; int start = 0 , pos ; do { pos = text . indexOf ( ' \n ' , start ) ; if ( pos == - 1 ) { lines [ lines . length - 1 ] = text . substring ( start ) ; } else { boolean crlf = ( pos > 0 ) && ( text . charAt ( pos - 1 ) == ' \r ' ) ; lines [ lines . length - 1 ] = text . substring ( start , pos - ( crlf ? 1 : 0 ) ) ; start = pos + 1 ; String [ ] newLines = new String [ lines . length + 1 ] ; System . arraycopy ( lines , 0 , newLines , 0 , lines . length ) ; lines = newLines ; } } while ( pos != - 1 ) ; return lines ; }
jgaupp/arx | protected String shortenText ( GC gc , String t , int width ) { if ( t == null ) return null ; int w = gc . textExtent ( ELLIPSIS , DRAW_FLAGS ) . x ; if ( width <= w ) return t ; int l = t . length ( ) ; int max = l / 2 ; int min = 0 ; int mid = ( max + min ) / 2 - 1 ; if ( mid <= 0 ) return t ; TextLayout layout = new TextLayout ( getDisplay ( ) ) ; layout . setText ( t ) ; mid = validateOffset ( layout , mid ) ; while ( min < mid && mid < max ) { String s1 = t . substring ( 0 , mid ) ; String s2 = t . substring ( validateOffset ( layout , l - mid ) , l ) ; int l1 = gc . textExtent ( s1 , DRAW_FLAGS ) . x ; int l2 = gc . textExtent ( s2 , DRAW_FLAGS ) . x ; if ( l1 + w + l2 > width ) { max = mid ; mid = validateOffset ( layout , ( max + min ) / 2 ) ; } else if ( l1 + w + l2 < width ) { min = mid ; mid = validateOffset ( layout , ( max + min ) / 2 ) ; } else { min = max ; } } String result = mid == 0 ? t : t . substring ( 0 , mid ) + ELLIPSIS + t . substring ( validateOffset ( layout , l - mid ) , l ) ; layout . dispose ( ) ; return result ; }
jgaupp/arx | char _findMnemonic ( String string ) { if ( string == null ) return ' \0' ; int index = 0 ; int length = string . length ( ) ; do { while ( index < length && string . charAt ( index ) != ' & ' ) index ++ ; if ( ++ index >= length ) return ' \0' ; if ( string . charAt ( index ) != ' & ' ) return Character . toLowerCase ( string . charAt ( index ) ) ; index ++ ; } while ( index < length ) ; return ' \0' ; }
jgaupp/arx | void onDispose ( Event event ) { if ( ignoreDispose ) { ignoreDispose = false ; return ; } ignoreDispose = true ; notifyListeners ( event . type , event ) ; event . type = SWT . NONE ; gradientColors = null ; gradientPercents = null ; backgroundImage = null ; text = null ; image = null ; appToolTipText = null ; }
jgaupp/arx | void onMnemonic ( TraverseEvent event ) { char mnemonic = _findMnemonic ( text ) ; if ( mnemonic == ' \0' ) return ; if ( Character . toLowerCase ( event . character ) != mnemonic ) return ; Composite control = this . getParent ( ) ; while ( control != null ) { Control [ ] children = control . getChildren ( ) ; int index = 0 ; while ( index < children . length ) { if ( children [ index ] == this ) break ; index ++ ; } index ++ ; if ( index < children . length ) { if ( children [ index ] . setFocus ( ) ) { event . doit = true ; event . detail = SWT . TRAVERSE_NONE ; } } control = control . getParent ( ) ; } }
jgaupp/arx | void onPaint ( PaintEvent event ) { Rectangle rect = getClientArea ( ) ; if ( rect . width == 0 || rect . height == 0 ) return ; boolean shortenText = false ; String t = text ; Image img = image ; int availableWidth = Math . max ( 0 , rect . width - ( leftMargin + rightMargin ) ) ; Point extent = getTotalSize ( img , t ) ; if ( extent . x > availableWidth ) { img = null ; extent = getTotalSize ( img , t ) ; if ( extent . x > availableWidth ) { shortenText = true ; } } GC gc = event . gc ; String [ ] lines = text == null ? null : splitString ( text ) ; if ( shortenText ) { extent . x = 0 ; for ( int i = 0 ; i < lines . length ; i ++ ) { Point e = gc . textExtent ( lines [ i ] , DRAW_FLAGS ) ; if ( e . x > availableWidth ) { lines [ i ] = shortenText ( gc , lines [ i ] , availableWidth ) ; extent . x = Math . max ( extent . x , getTotalSize ( null , lines [ i ] ) . x ) ; } else { extent . x = Math . max ( extent . x , e . x ) ; } } if ( appToolTipText == null ) { super . setToolTipText ( text ) ; } } else { super . setToolTipText ( appToolTipText ) ; } int x = rect . x + leftMargin ; if ( align == SWT . CENTER ) { x = ( rect . width - extent . x ) / 2 ; } if ( align == SWT . RIGHT ) { x = rect . width - rightMargin - extent . x ; } try { if ( backgroundImage != null ) { Rectangle imageRect = backgroundImage . getBounds ( ) ; gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; int xPos = 0 ; while ( xPos < rect . width ) { int yPos = 0 ; while ( yPos < rect . height ) { gc . drawImage ( backgroundImage , xPos , yPos ) ; yPos += imageRect . height ; } xPos += imageRect . width ; } } else if ( gradientColors != null ) { final Color oldBackground = gc . getBackground ( ) ; if ( gradientColors . length == 1 ) { if ( gradientColors [ 0 ] != null ) gc . setBackground ( gradientColors [ 0 ] ) ; gc . fillRectangle ( 0 , 0 , rect . width , rect . height ) ; } else { final Color oldForeground = gc . getForeground ( ) ; Color lastColor = gradientColors [ 0 ] ; if ( lastColor == null ) lastColor = oldBackground ; int pos = 0 ; for ( int i = 0 ; i < gradientPercents . length ; ++ i ) { gc . setForeground ( lastColor ) ; lastColor = gradientColors [ i + 1 ] ; if ( lastColor == null ) lastColor = oldBackground ; gc . setBackground ( lastColor ) ; if ( gradientVertical ) { final int gradientHeight = ( gradientPercents [ i ] * rect . height / 100 ) - pos ; gc . fillGradientRectangle ( 0 , pos , rect . width , gradientHeight , true ) ; pos += gradientHeight ; } else { final int gradientWidth = ( gradientPercents [ i ] * rect . width / 100 ) - pos ; gc . fillGradientRectangle ( pos , 0 , gradientWidth , rect . height , false ) ; pos += gradientWidth ; } } if ( gradientVertical && pos < rect . height ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( 0 , pos , rect . width , rect . height - pos ) ; } if ( ! gradientVertical && pos < rect . width ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( pos , 0 , rect . width - pos , rect . height ) ; } gc . setForeground ( oldForeground ) ; } gc . setBackground ( oldBackground ) ; } else { if ( background != null || ( getStyle ( ) & SWT . DOUBLE_BUFFERED ) == 0 ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; } } } catch ( SWTException e ) { if ( ( getStyle ( ) & SWT . DOUBLE_BUFFERED ) == 0 ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; } } int style = getStyle ( ) ; if ( ( style & SWT . SHADOW_IN ) != 0 || ( style & SWT . SHADOW_OUT ) != 0 ) { paintBorder ( gc , rect ) ; } Rectangle imageRect = null ; int lineHeight = 0 , textHeight = 0 , imageHeight = 0 ; if ( img != null ) { imageRect = img . getBounds ( ) ; imageHeight = imageRect . height ; } if ( lines != null ) { lineHeight = gc . getFontMetrics ( ) . getHeight ( ) ; textHeight = lines . length * lineHeight ; } int imageY = 0 , midPoint = 0 , lineY = 0 ; if ( imageHeight > textHeight ) { if ( topMargin == DEFAULT_MARGIN && bottomMargin == DEFAULT_MARGIN ) imageY = rect . y + ( rect . height - imageHeight ) / 2 ; else imageY = topMargin ; midPoint = imageY + imageHeight / 2 ; lineY = midPoint - textHeight / 2 ; } else { if ( topMargin == DEFAULT_MARGIN && bottomMargin == DEFAULT_MARGIN ) lineY = rect . y + ( rect . height - textHeight ) / 2 ; else lineY = topMargin ; midPoint = lineY + textHeight / 2 ; imageY = midPoint - imageHeight / 2 ; } if ( img != null ) { gc . drawImage ( img , 0 , 0 , imageRect . width , imageHeight , x , imageY , imageRect . width , imageHeight ) ; x += imageRect . width + GAP ; extent . x -= imageRect . width + GAP ; } if ( lines != null ) { gc . setForeground ( getForeground ( ) ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { int lineX = x ; if ( lines . length > 1 ) { if ( align == SWT . CENTER ) { int lineWidth = gc . textExtent ( lines [ i ] , DRAW_FLAGS ) . x ; lineX = x + Math . max ( 0 , ( extent . x - lineWidth ) / 2 ) ; } if ( align == SWT . RIGHT ) { int lineWidth = gc . textExtent ( lines [ i ] , DRAW_FLAGS ) . x ; lineX = Math . max ( x , rect . x + rect . width - rightMargin - lineWidth ) ; } } if ( i == lines . length - 1 && progressProvider != null && progressProvider . getProgress ( ) != 0 ) { gc . drawText ( lines [ i ] + " ▁ ( " + progressProvider . getProgress ( ) + " % ) " , lineX , lineY , DRAW_FLAGS ) ; } else { gc . drawText ( lines [ i ] , lineX , lineY , DRAW_FLAGS ) ; } lineY += lineHeight ; } } }
jgaupp/arx | int validateOffset ( TextLayout layout , int offset ) { int nextOffset = layout . getNextOffset ( offset , SWT . MOVEMENT_CLUSTER ) ; if ( nextOffset != offset ) return layout . getPreviousOffset ( nextOffset , SWT . MOVEMENT_CLUSTER ) ; return offset ; }
SDRC-India/collect | public AlertDialog createDialog ( final Context context , final AuthDialogUtilityResultListener resultListener ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; final View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . server_auth_dialog , null ) ; final EditText username = ( EditText ) dialogView . findViewById ( R . id . username_edit ) ; final EditText password = ( EditText ) dialogView . findViewById ( R . id . password_edit ) ; final SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context ) ; username . setText ( getUserName ( settings ) ) ; password . setText ( getPassword ( settings ) ) ; builder . setTitle ( context . getString ( R . string . server_requires_auth ) ) ; builder . setMessage ( context . getString ( R . string . server_auth_credentials , getServer ( settings , context ) ) ) ; builder . setView ( dialogView ) ; builder . setPositiveButton ( context . getString ( R . string . ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Collect . getInstance ( ) . getActivityLogger ( ) . logAction ( this , TAG , " OK " ) ; String userNameValue = username . getText ( ) . toString ( ) ; String passwordValue = password . getText ( ) . toString ( ) ; saveCredentials ( settings , userNameValue , passwordValue ) ; setWebCredentialsFromPreferences ( context ) ; resultListener . updatedCredentials ( ) ; } } ) ; builder . setNegativeButton ( context . getString ( R . string . cancel ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Collect . getInstance ( ) . getActivityLogger ( ) . logAction ( this , TAG , " Cancel " ) ; resultListener . cancelledUpdatingCredentials ( ) ; } } ) ; builder . setCancelable ( false ) ; return builder . create ( ) ; }
SDRC-India/collect | private void saveCredentials ( SharedPreferences settings , String userName , String password ) { settings . edit ( ) . putString ( PreferenceKeys . KEY_USERNAME , userName ) . putString ( PreferenceKeys . KEY_PASSWORD , password ) . commit ( ) ; }
lj3lj3/XBridge | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; this . addPreferencesFromResource ( R . xml . preference_xbridge ) ; addRebootPreference ( this ) ; keyXda = getString ( R . string . key_xda ) ; keySizeOfIconInNoti = getString ( R . string . key_size_of_icon_in_noti ) ; }
lj3lj3/XBridge | @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { Log . d ( TAG , " keys : " + PlayAction . keyShow + AppOpsAction . keyShow + AppSettingsAction . keyShow + ClipBoardAction . keyShow + SearchAction . keyShow ) ; playPreference = ( SwitchPreference ) this . findPreference ( PlayAction . keyShow ) ; appOpsPreference = ( SwitchPreference ) this . findPreference ( AppOpsAction . keyShow ) ; appSettingsPreference = ( SwitchPreference ) this . findPreference ( AppSettingsAction . keyShow ) ; clipBoardPreference = ( SwitchPreference ) this . findPreference ( ClipBoardAction . keyShow ) ; searchPreference = ( SwitchPreference ) this . findPreference ( SearchAction . keyShow ) ; xPrivacyPreference = ( SwitchPreference ) this . findPreference ( XPrivacyAction . keyShow ) ; appInfoPreference = ( SwitchPreference ) this . findPreference ( AppInfoAction . keyShow ) ; notifyCleanPreference = ( SwitchPreference ) this . findPreference ( NotifyCleanAction . keyShow ) ; lightningWallPreference = ( SwitchPreference ) this . findPreference ( LightningWallAction . keyShow ) ; xhaloFloatingWindowPreference = ( SwitchPreference ) this . findPreference ( XHaloFloatingWindowAction . keyShow ) ; myAndroidToolsPreference = ( SwitchPreference ) this . findPreference ( MyAndroidToolsAction . keyShow ) ; sizeOfIconInNotiPreference = this . findPreference ( keySizeOfIconInNoti ) ; playPreference . setOnPreferenceChangeListener ( this ) ; appOpsPreference . setOnPreferenceChangeListener ( this ) ; appSettingsPreference . setOnPreferenceChangeListener ( this ) ; clipBoardPreference . setOnPreferenceChangeListener ( this ) ; searchPreference . setOnPreferenceChangeListener ( this ) ; xPrivacyPreference . setOnPreferenceChangeListener ( this ) ; appInfoPreference . setOnPreferenceChangeListener ( this ) ; notifyCleanPreference . setOnPreferenceChangeListener ( this ) ; lightningWallPreference . setOnPreferenceChangeListener ( this ) ; xhaloFloatingWindowPreference . setOnPreferenceChangeListener ( this ) ; myAndroidToolsPreference . setOnPreferenceChangeListener ( this ) ; return super . onCreateView ( inflater , container , savedInstanceState ) ; }
lj3lj3/XBridge | @ Override public void onStart ( ) { super . onStart ( ) ; ActionBar actionBar = this . getActivity ( ) . getActionBar ( ) ; if ( actionBar != null ) { actionBar . setTitle ( R . string . app_name ) ; } if ( need2Load ) { loadPreferenceValue ( ) ; need2Load = false ; } new IconLoader ( ) . execute ( ) ; }
lj3lj3/XBridge | public void loadPreferenceValue ( ) { playPreference . setChecked ( PlayAction . isShow ) ; appOpsPreference . setChecked ( AppOpsAction . isShow ) ; appSettingsPreference . setChecked ( AppSettingsAction . isShow ) ; clipBoardPreference . setChecked ( ClipBoardAction . isShow ) ; searchPreference . setChecked ( SearchAction . isShow ) ; xPrivacyPreference . setChecked ( XPrivacyAction . isShow ) ; appInfoPreference . setChecked ( AppInfoAction . isShow ) ; notifyCleanPreference . setChecked ( NotifyCleanAction . isShow ) ; lightningWallPreference . setChecked ( LightningWallAction . isShow ) ; xhaloFloatingWindowPreference . setChecked ( XHaloFloatingWindowAction . isShow ) ; myAndroidToolsPreference . setChecked ( MyAndroidToolsAction . isShow ) ; sizeOfIconInNotiPreference . setSummary ( SizeInputFragment . size + " % " ) ; Log . d ( TAG , " values : " + " PlayAction : " + PlayAction . isShow + " , AppOpsAction : " + AppOpsAction . isShow + " , AppSettingsAction : " + AppSettingsAction . isShow + " , ClipBoardAction : " + ClipBoardAction . isShow + " , SearchAction : " + SearchAction . isShow + " , XPrivacyAction : " + XPrivacyAction . isShow + " , AppInfoAction : " + AppInfoAction . isShow + " , XHaloFloatingWindowAction : " + XHaloFloatingWindowAction . isShow + " , NotifyCleanAction : " + NotifyCleanAction . isShow ) ; }
lj3lj3/XBridge | @ Override public boolean onPreferenceTreeClick ( PreferenceScreen preferenceScreen , @ NonNull Preference preference ) { super . onPreferenceTreeClick ( preferenceScreen , preference ) ; String prefKey = preference . getKey ( ) ; Log . d ( TAG , " clicked ▁ preference : ▁ " + prefKey ) ; PreferenceFragment fragment = null ; DialogFragment dialogFragment = null ; String tag = null ; Bundle bundle = new Bundle ( ) ; if ( PlayAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_play ) ; fragment = PlayFragment . getFragment ( bundle ) ; tag = PlayFragment . TAG ; } else if ( AppOpsAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_appops ) ; fragment = AppOpsFragment . getFragment ( bundle ) ; tag = AppOpsFragment . TAG ; } else if ( AppSettingsAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_appsettings ) ; fragment = AppSettingsFragment . getFragment ( bundle ) ; tag = AppSettingsFragment . TAG ; } else if ( ClipBoardAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_clipboard ) ; fragment = ClipBoardFragment . getFragment ( bundle ) ; tag = ClipBoardFragment . TAG ; } else if ( SearchAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_search ) ; fragment = SearchFragment . getFragment ( bundle ) ; tag = SearchFragment . TAG ; } else if ( XPrivacyAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_xprivacy ) ; fragment = XPrivacyFragment . getFragment ( bundle ) ; tag = XPrivacyFragment . TAG ; } else if ( AppInfoAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_appinfo ) ; fragment = AppInfoFragment . getFragment ( bundle ) ; tag = AppInfoFragment . TAG ; } else if ( NotifyCleanAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_notifyclean ) ; fragment = NotifyCleanFragment . getFragment ( bundle ) ; tag = NotifyCleanFragment . TAG ; } else if ( LightningWallAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_lightningwall ) ; fragment = LightningWallFragment . getFragment ( bundle ) ; tag = LightningWallFragment . TAG ; } else if ( XHaloFloatingWindowAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_xhalofloatingwindow ) ; fragment = XHaloFloatingWindowFragment . getFragment ( bundle ) ; tag = XHaloFloatingWindowFragment . TAG ; } else if ( MyAndroidToolsAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_myandroidtools ) ; fragment = MyAndroidToolsFragment . getFragment ( bundle ) ; tag = MyAndroidToolsFragment . TAG ; } else if ( keySizeOfIconInNoti . equals ( prefKey ) ) { dialogFragment = SizeInputFragment . getDialogFragment ( bundle ) ; tag = SizeInputFragment . TAG ; } else if ( keyXda . equals ( prefKey ) ) { Action . viewInXda ( this . getActivity ( ) . getApplicationContext ( ) ) ; return true ; } if ( dialogFragment != null ) { Log . d ( TAG , " dialog ▁ fragment ▁ is ▁ ok : ▁ " + dialogFragment ) ; dialogFragment . show ( this . getFragmentManager ( ) , tag ) ; } else if ( fragment != null ) { Log . d ( TAG , " fragment ▁ is ▁ ok : ▁ " + fragment ) ; this . getFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . container , fragment , tag ) . setTransition ( FragmentTransaction . TRANSIT_FRAGMENT_OPEN ) . addToBackStack ( tag ) . commit ( ) ; this . getFragmentManager ( ) . executePendingTransactions ( ) ; } else { Log . w ( TAG , " on ▁ click ▁ fragment ▁ is ▁ null , ▁ key : ▁ " + prefKey ) ; return false ; } return true ; }
lj3lj3/XBridge | @ Override public boolean onPreferenceChange ( Preference preference , Object newValue ) { Log . d ( TAG , " changed ▁ preference : ▁ " + preference + " , ▁ newValue : ▁ " + newValue ) ; return false ; }
lj3lj3/XBridge | @ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . menu_xbridge , menu ) ; super . onCreateOptionsMenu ( menu , inflater ) ; }
lj3lj3/XBridge | @ Override public void onPrepareOptionsMenu ( Menu menu ) { MenuItem debugItem = menu . findItem ( R . id . debug ) ; debugItem . setChecked ( Log . debug ) ; super . onPrepareOptionsMenu ( menu ) ; }
lj3lj3/XBridge | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . debug ) { boolean isChecked = ! item . isChecked ( ) ; item . setChecked ( isChecked ) ; Log . debug = isChecked ; Log . i ( TAG , " debug ▁ is ▁ checked : ▁ " + isChecked ) ; MainPreferences . getEditablePreferences ( getPreferenceManager ( ) ) . edit ( ) . putBoolean ( Log . keyDebug , isChecked ) . commit ( ) ; return true ; } return super . onOptionsItemSelected ( item ) ; }
lj3lj3/XBridge | @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; ActionBar actionBar = this . getActivity ( ) . getActionBar ( ) ; if ( actionBar != null ) { actionBar . setDisplayHomeAsUpEnabled ( false ) ; } }
lj3lj3/XBridge | public void setNeed2Load ( boolean need2Load ) { this . need2Load = need2Load ; }
lj3lj3/XBridge | @ Override protected Object doInBackground ( Object [ ] params ) { PackageManager packageManager = getActivity ( ) . getPackageManager ( ) ; iconInfo = AppInfoFragment . getPkgIcon ( packageManager ) ; iconAppOps = AppOpsFragment . getPkgIcon ( packageManager ) ; iconAppSettings = AppSettingsFragment . getPkgIcon ( packageManager ) ; iconPlay = PlayFragment . getPkgIcon ( packageManager ) ; iconXPrivacy = XPrivacyFragment . getPkgIcon ( packageManager ) ; iconNotifyClean = NotifyCleanFragment . getPkgIcon ( packageManager ) ; iconLightningWall = LightningWallFragment . getPkgIcon ( packageManager ) ; iconXHaloFloatingWindow = XHaloFloatingWindowFragment . getPkgIcon ( packageManager ) ; iconMyAndroidTools = MyAndroidToolsFragment . getPkgIcon ( packageManager ) ; Log . d ( TAG , " load ▁ icons ▁ done : " + " iconInfo : " + iconInfo + " , iconAppOps : " + iconAppOps + " , iconAppSettings : " + iconAppSettings + " , iconPlay : " + iconPlay + " , iconNotifyClean : " + iconNotifyClean + " , iconLightningWall : " + iconLightningWall + " , iconXHaloFloatingWindow : " + iconXHaloFloatingWindow + " , iconMyAndroidTools : " + iconMyAndroidTools + " , iconXPrivacy : " + iconXPrivacy ) ; return null ; }
lj3lj3/XBridge | @ Override protected void onPostExecute ( Object o ) { playPreference . setIcon ( iconPlay ) ; appOpsPreference . setIcon ( iconAppOps ) ; appSettingsPreference . setIcon ( iconAppSettings ) ; xPrivacyPreference . setIcon ( iconXPrivacy ) ; appInfoPreference . setIcon ( iconInfo ) ; notifyCleanPreference . setIcon ( iconNotifyClean ) ; lightningWallPreference . setIcon ( iconLightningWall ) ; xhaloFloatingWindowPreference . setIcon ( iconXHaloFloatingWindow ) ; myAndroidToolsPreference . setIcon ( iconMyAndroidTools ) ; super . onPostExecute ( o ) ; }
data-integrations/wrangler | public Expression ( String value ) { this . value = value ; }
data-integrations/wrangler | @ Override public String value ( ) { return value ; }
data-integrations/wrangler | @ Override public TokenType type ( ) { return TokenType . EXPRESSION ; }
data-integrations/wrangler | @ Override public JsonElement toJson ( ) { JsonObject object = new JsonObject ( ) ; object . addProperty ( " type " , TokenType . EXPRESSION . name ( ) ) ; object . addProperty ( " value " , value ) ; return object ; }
lukas-krecan/ShedLock | @ Override @ NonNull public Optional < SimpleLock > lock ( @ NonNull LockConfiguration lockConfiguration ) { synchronized ( locks ) { String lockName = lockConfiguration . getName ( ) ; if ( isLocked ( lockName ) ) { return Optional . empty ( ) ; } else { LockRecord lockRecord = new LockRecord ( lockConfiguration . getLockAtMostUntil ( ) ) ; locks . put ( lockName , lockRecord ) ; logger . debug ( " Locked ▁ { } " , lockConfiguration ) ; return Optional . of ( new InMemoryLock ( lockConfiguration ) ) ; } } }
lukas-krecan/ShedLock | boolean isLocked ( String lockName ) { synchronized ( locks ) { LockRecord lockRecord = locks . get ( lockName ) ; return lockRecord != null && lockRecord . lockedUntil . isAfter ( now ( ) ) ; } }
lukas-krecan/ShedLock | private void doUnlock ( LockConfiguration lockConfiguration ) { synchronized ( locks ) { locks . put ( lockConfiguration . getName ( ) , new LockRecord ( lockConfiguration . getLockAtLeastUntil ( ) ) ) ; logger . debug ( " Unlocked ▁ { } " , lockConfiguration ) ; } }
lukas-krecan/ShedLock | private Optional < SimpleLock > doExtend ( LockConfiguration newConfiguration ) { synchronized ( locks ) { String lockName = newConfiguration . getName ( ) ; if ( isLocked ( lockName ) ) { locks . put ( lockName , new LockRecord ( newConfiguration . getLockAtMostUntil ( ) ) ) ; logger . debug ( " Extended ▁ { } " , newConfiguration ) ; return Optional . of ( new InMemoryLock ( newConfiguration ) ) ; } else { return Optional . empty ( ) ; } } }
lukas-krecan/ShedLock | private LockRecord ( Instant lockedUntil ) { this . lockedUntil = lockedUntil ; }
lukas-krecan/ShedLock | private InMemoryLock ( LockConfiguration lockConfiguration ) { super ( lockConfiguration ) ; }
lukas-krecan/ShedLock | @ Override protected void doUnlock ( ) { InMemoryLockProvider . this . doUnlock ( lockConfiguration ) ; }
lukas-krecan/ShedLock | @ Override protected Optional < SimpleLock > doExtend ( LockConfiguration newConfiguration ) { return InMemoryLockProvider . this . doExtend ( newConfiguration ) ; }
apache/incubator-asterixdb | private ArrayRepeatTypeComputer ( ) { }
apache/incubator-asterixdb | @ Override protected IAType getResultType ( ILogicalExpression expr , IAType ... strippedInputTypes ) throws AlgebricksException { return AUnionType . createNullableType ( new AOrderedListType ( strippedInputTypes [ 0 ] , null ) ) ; }
Sausageo/jmeter-plugins | public void show ( Component component , String message , String title , int messageType ) { JOptionPane . showMessageDialog ( component , message , title , messageType ) ; }
jansorg/BashSupport | private final MockFunction parserFunction = new MockFunction ( ) { @ Override public boolean apply ( BashPsiBuilder psi ) { ReadCommand d = new ReadCommand ( ) ; return d . parseIfValid ( psi ) . isParsedSuccessfully ( ) ; } }
jansorg/BashSupport | @ Test public void testIsValid ( ) { mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD ) ; mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , WORD ) ; mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , WORD , WORD , WORD ) ; mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , WORD , ASSIGNMENT_WORD , LEFT_SQUARE , WORD , RIGHT_SQUARE ) ; }
jansorg/BashSupport | @ Test public void testIssue125 ( ) throws Exception { mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , STRING2 , ASSIGNMENT_WORD , LEFT_SQUARE , ARITH_NUMBER , RIGHT_SQUARE ) ; }
jansorg/BashSupport | @ Test public void testBuiltin ( ) { LanguageBuiltins . localVarDefCommands . contains ( " read " ) ; }
google/fest | private Pause ( ) { }
TM00/MarkingAssistant | @ FXML void configureButtonPressed ( ActionEvent event ) { final Stage dialog = new Stage ( ) ; dialog . initModality ( Modality . WINDOW_MODAL ) ; dialog . initOwner ( Main . primaryStage ) ; dialog . setTitle ( " Exam ▁ Configurations " ) ; dialog . getIcons ( ) . addAll ( ResourceLoader . getIcons ( " check _ mark . ico " ) ) ; dialog . setX ( Main . primaryStage . getX ( ) ) ; dialog . setY ( Main . primaryStage . getY ( ) + Main . primaryStage . getWidth ( ) / 2 ) ; try { FXMLLoader fxmlLoader = new FXMLLoader ( this . getClass ( ) . getResource ( " ConfigureGui . fxml " ) ) ; AnchorPane page = ( AnchorPane ) fxmlLoader . load ( ) ; ConfigureController fooController = ( ConfigureController ) fxmlLoader . getController ( ) ; fooController . setStage ( dialog ) ; fooController . setParent ( this ) ; fooController . loadData ( ) ; Scene dialogScene = new Scene ( page ) ; dialog . setScene ( dialogScene ) ; dialog . show ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
TM00/MarkingAssistant | public void doneConfiguring ( ) { System . out . println ( " Done ▁ with ▁ configure . . . " ) ; ExamExcelHandler . loadConstantsFromConfigData ( ) ; loadExcelFile ( ) ; }
TM00/MarkingAssistant | @ FXML void chooseFilePressed ( ActionEvent event ) { File f = ExamExcelHandler . getFile ( ) ; chooseFileButton . setText ( f . getName ( ) ) ; filePath = f . getAbsolutePath ( ) ; ExamExcelHandler . setFilePath_to_excel ( filePath ) ; ExamExcelHandler . loadConstantsFromConfigData ( ) ; list = ExamExcelHandler . readExamStudentListFromFile ( ) ; autoTex . getEntries ( ) . addAll ( list . getObservableList ( ) ) ; autoTex . setCaseSensitive ( false ) ; }
TM00/MarkingAssistant | @ FXML void addMarkPressed ( ActionEvent event ) { String selected = autoTex . getText ( ) ; ExamStudent student = list . getStudent ( selected ) ; if ( student != null ) { int counter = 0 ; ConfigListData dat , total = null ; for ( StudentExamListData studentExamListData : data ) { student . setMark ( studentExamListData . getQuestionNumber ( ) + " " , studentExamListData . getMark ( ) ) ; dat = Main . configData . questionData . get ( counter ) ; System . out . println ( " name ▁ = ▁ " + dat . getName ( ) ) ; if ( ! dat . getName ( ) . equals ( " TOTAL " ) && Main . configData . writeQuestions ) { excelView . setCellValue ( student . getRowNumber ( ) , ExcelUtils . getExcelColumnIndex ( dat . getExcelColumn ( ) ) , studentExamListData . getMark ( ) + " " ) ; } counter ++ ; } for ( ConfigListData d : Main . configData . questionData ) { if ( d . getName ( ) . equals ( " TOTAL " ) ) { total = Main . configData . questionData . get ( counter ) ; break ; } } if ( Main . configData . writeTotal && total != null ) { excelView . setCellValue ( student . getRowNumber ( ) , ExcelUtils . getExcelColumnIndex ( total . getExcelColumn ( ) ) , student . getTotalMark ( ) + " " ) ; } double percentage = student . getTotalMark ( ) / Main . configData . totalPaper * 100 ; DecimalFormat df = new DecimalFormat ( " # # . 0" ) ; infoText . appendText ( " Total ▁ for ▁ " + student . getStudentNumber ( ) + " ▁ = ▁ " + student . getTotalMark ( ) + " \n " ) ; infoText . appendText ( " \t ▁ Percentage ▁ = ▁ " + df . format ( percentage ) + " ▁ % ▁ " + " \n \n " ) ; autoTex . setText ( " " ) ; autoTex . requestFocus ( ) ; } else { displayText ( " No ▁ student ▁ found ▁ by ▁ the ▁ name ▁ " + selected + " ▁ try ▁ again " , false ) ; } }
TM00/MarkingAssistant | @ FXML void writeMarks ( ActionEvent event ) { if ( Main . settings . playLoadingSound ) SoundPlayer . startLoopSound ( ) ; Alert alert = new Alert ( AlertType . INFORMATION ) ; alert . setTitle ( " Busy ▁ Writing " ) ; alert . setHeaderText ( " Please ▁ wait . . . " ) ; File f = ResourceLoader . getRandomGif ( ) ; Image image ; try { image = new Image ( f . toURI ( ) . toURL ( ) . toString ( ) ) ; ImageView view = new ImageView ( image ) ; alert . setGraphic ( view ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } alert . getDialogPane ( ) . lookupButton ( ButtonType . OK ) . setDisable ( true ) ; Stage stage1 = ( Stage ) alert . getDialogPane ( ) . getScene ( ) . getWindow ( ) ; stage1 . getIcons ( ) . addAll ( ResourceLoader . getIcons ( " check _ mark . ico " ) ) ; alert . setX ( Main . primaryStage . getX ( ) ) ; alert . setY ( Main . primaryStage . getY ( ) + Main . primaryStage . getWidth ( ) / 2 ) ; alert . show ( ) ; Task < Integer > task = new Task < Integer > ( ) { @ Override protected Integer call ( ) throws Exception { System . out . println ( " Started " ) ; ExamExcelHandler . writeExamStudentMarksToFile ( list , Main . configData . writeQuestions , Main . configData . writeTotal ) ; System . out . println ( " DONE ! ! " ) ; displayText ( " Succesfully ▁ written ▁ to ▁ the ▁ file . . . " , true ) ; displayText ( " Total ▁ students ▁ marked ▁ = ▁ " + list . numMarked ( ) , true ) ; return new Integer ( 2 ) ; } @ Override protected void succeeded ( ) { super . succeeded ( ) ; updateMessage ( " Done ! " ) ; System . out . println ( " Done ! " ) ; Platform . runLater ( ( ) -> { SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void cancelled ( ) { super . cancelled ( ) ; updateMessage ( " Cancelled ! " ) ; System . out . println ( " Cancelled " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void failed ( ) { super . failed ( ) ; updateMessage ( " Failed ! " ) ; System . out . println ( " Failed " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } } ; Thread th = new Thread ( task ) ; th . setDaemon ( false ) ; th . start ( ) ; }
TM00/MarkingAssistant | @ FXML void initialize ( ) { assert hBoxContainer != null : " fx : id = \" hBoxContainer \" ▁ was ▁ not ▁ injected : ▁ check ▁ your ▁ FXML ▁ file ▁ ' Gui . fxml ' . " ; assert marksListView != null : " fx : id = \" marksListView \" ▁ was ▁ not ▁ injected : ▁ check ▁ your ▁ FXML ▁ file ▁ ' Gui . fxml ' . " ; Main . createMenu ( menu ) ; Menu fileMenu = OtherUtils . getMenuFromBar ( menu , " File " ) ; if ( fileMenu != null ) { MenuItem choose = new MenuItem ( " Choose ▁ File " ) ; choose . setAccelerator ( KeyCombination . keyCombination ( " Ctrl + O " ) ) ; choose . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { chooseFilePressed ( null ) ; } } ) ; fileMenu . getItems ( ) . add ( 0 , choose ) ; } Menu EditMenu = OtherUtils . getMenuFromBar ( menu , " Edit " ) ; if ( EditMenu != null ) { MenuItem config = new MenuItem ( " Configure " ) ; config . setAccelerator ( KeyCombination . keyCombination ( " Ctrl + C " ) ) ; config . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { configureButtonPressed ( null ) ; } } ) ; MenuItem refresh = new MenuItem ( " Refresh ▁ data " ) ; refresh . setAccelerator ( KeyCombination . keyCombination ( " Ctrl + R " ) ) ; refresh . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { loadExcelFile ( ) ; } } ) ; EditMenu . getItems ( ) . add ( 0 , config ) ; EditMenu . getItems ( ) . add ( 1 , refresh ) ; } Menu helpMenu = OtherUtils . getMenuFromBar ( menu , " Help " ) ; if ( helpMenu != null ) { MenuItem help = new MenuItem ( " How ▁ to ▁ use " ) ; help . setAccelerator ( KeyCombination . keyCombination ( " Shortcut + H " ) ) ; help . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { Main . showHelp ( getHelpString ( ) ) ; } } ) ; helpMenu . getItems ( ) . add ( 0 , help ) ; } autoTex . addCustomHandler ( this ) ; hBoxContainer . getChildren ( ) . addAll ( autoTex ) ; mainPane . setOnDragOver ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { event . acceptTransferModes ( TransferMode . COPY ) ; event . consume ( ) ; } } ) ; mainPane . setOnDragEntered ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { event . consume ( ) ; } } ) ; mainPane . setOnDragExited ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { event . consume ( ) ; } } ) ; mainPane . setOnDragDropped ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { Dragboard db = event . getDragboard ( ) ; boolean success = false ; if ( db . hasFiles ( ) ) { success = true ; if ( db . getFiles ( ) . size ( ) == 1 ) { File file = db . getFiles ( ) . get ( 0 ) ; chooseFileButton . setText ( file . getName ( ) ) ; filePath = file . getAbsolutePath ( ) ; System . out . println ( filePath ) ; displayExcelView ( ) ; } } event . setDropCompleted ( success ) ; event . consume ( ) ; } } ) ; this . infoText . setFocusTraversable ( false ) ; this . chooseFileButton . setFocusTraversable ( false ) ; this . autoTex . requestFocus ( ) ; ExamStudent . outText = this ; String def = " Welcome ▁ to ▁ the ▁ exam ▁ mark ▁ logging ▁ program ! ! \n " + " This ▁ program ▁ lets ▁ you ▁ log ▁ marks ▁ for ▁ different \n " + " questions ▁ to ▁ an ▁ excel ▁ file \n " + " HOW ▁ IT ▁ WORKS : ▁ You ▁ first ▁ need ▁ to ▁ create ▁ the ▁ column ( s ) ▁ you ▁ want ▁ the ▁ marks ▁ to ▁ be ▁ entered ▁ in ▁ in ▁ your ▁ excel ▁ file . " + " Then ▁ close ▁ the ▁ excel ▁ file . ▁ Drag ▁ and ▁ drop ▁ the ▁ selected ▁ excel ▁ file ▁ to ▁ which ▁ the ▁ marks ▁ should ▁ be ▁ added . ▁ " + " \n ▁ After ▁ loading ▁ the ▁ file , ▁ a ▁ display ▁ of ▁ the ▁ file ▁ should ▁ open . ▁ Now ▁ you ▁ mus ▁ press ▁ the ▁ configure ▁ buttom ▁ to " + " ▁ tell ▁ the ▁ program ▁ where ▁ the ▁ marks ▁ should ▁ go ▁ and ▁ how ▁ to ▁ locate ▁ the ▁ candiates ▁ with ▁ their ▁ details . ▁ Press ▁ save ▁ & ▁ Return ▁ when ▁ you ' re ▁ done . " + " The ▁ student ▁ details ▁ are ▁ now ▁ read ▁ by ▁ the ▁ program . ▁ You ▁ may ▁ continue ▁ to ▁ enter ▁ the ▁ student ▁ name / number ▁ " + " and ▁ select ▁ one ▁ of ▁ the ▁ suggestions ▁ by ▁ pressing ▁ the ▁ ENTER ▁ key . ▁ Now ▁ you ▁ can ▁ enter ▁ that ▁ student ' s ▁ marks ▁ for ▁ each ▁ question ▁ in ▁ the ▁ table " + " below ▁ and ▁ press ▁ the ▁ \" Add ▁ Mark \" ▁ button ▁ to ▁ load ▁ in ▁ into ▁ the ▁ program . ▁ This ▁ mark ▁ will ▁ not ▁ be ▁ added ▁ into ▁ the ▁ Excel ▁ file ▁ yet , ▁ so ▁ you ▁ can ▁ simply " + " ▁ re - enter ▁ it ▁ if ▁ you ▁ made ▁ a ▁ mistake . \n " + " After ▁ adding ▁ the ▁ marks , ▁ press ▁ the ▁ \" Write ▁ to ▁ file \" ▁ button ▁ to ▁ export ▁ the ▁ newly ▁ added ▁ student ▁ data ▁ to ▁ the " + " excel ▁ file . ▁ This ▁ may ▁ take ▁ a ▁ while ▁ depending ▁ on ▁ the ▁ amount ▁ of ▁ students \n " + " FYI ▁ the ▁ excel ▁ file ▁ should ▁ be ▁ in ▁ a ▁ specific ▁ format ▁ such ▁ as ▁ the ▁ one ▁ from ▁ the ▁ example . ▁ Also ▁ keep ▁ a ▁ copy ▁ of ▁ the ▁ file ▁ in ▁ case ▁ something ▁ goes ▁ wrong ▁ and ▁ avoid ▁ losing ▁ the ▁ file . ▁ " + " Additional ▁ settings ▁ can ▁ be ▁ set ▁ " + " by ▁ using ▁ the ▁ settings ▁ menu . ▁ \n \n " ; this . infoText . setText ( def ) ; }
TM00/MarkingAssistant | private void reFreshData ( ) { ArrayList < ConfigListData > d = Main . configData . questionData ; data = FXCollections . observableArrayList ( ) ; data . clear ( ) ; for ( ConfigListData c : d ) { if ( ! c . getName ( ) . equals ( " TOTAL " ) ) data . add ( new StudentExamListData ( c . getNumber ( ) , c . getName ( ) ) ) ; } }
TM00/MarkingAssistant | private void setupListView ( ) { reFreshData ( ) ; marksListView . setItems ( data ) ; marksListView . setCellFactory ( new Callback < ListView < StudentExamListData > , ListCell < StudentExamListData > > ( ) { @ Override public ListCell < StudentExamListData > call ( ListView < StudentExamListData > arg0 ) { return new ListCell < StudentExamListData > ( ) { @ Override protected void updateItem ( StudentExamListData item , boolean bln ) { super . updateItem ( item , bln ) ; if ( item != null ) { Label number = new Label ( item . getQuestionNumber ( ) + " " ) ; Label name = new Label ( item . getDescription ( ) + " " ) ; TextField col = new TextField ( " " ) ; col . setOnKeyReleased ( new EventHandler < Event > ( ) { @ Override public void handle ( Event arg0 ) { try { item . setMark ( Double . parseDouble ( col . getText ( ) ) ) ; } catch ( NumberFormatException e ) { } } } ) ; number . setPrefWidth ( 30 ) ; name . setPrefWidth ( 90 ) ; col . setPrefWidth ( 30 ) ; HBox hBox = new HBox ( number , name , col ) ; hBox . setSpacing ( 10 ) ; hBox . setAlignment ( Pos . CENTER ) ; setGraphic ( hBox ) ; } } } ; } } ) ; marksListView . requestFocus ( ) ; }
TM00/MarkingAssistant | @ Override public void displayText ( String text , boolean doublenl ) { infoText . appendText ( text + " \n " ) ; if ( doublenl ) { infoText . appendText ( " \n " ) ; } }
TM00/MarkingAssistant | private void loadExcelFile ( ) { if ( Main . settings . playLoadingSound ) SoundPlayer . startLoopSound ( ) ; Alert alert = new Alert ( AlertType . INFORMATION ) ; alert . setTitle ( " Busy ▁ Reading " ) ; alert . setHeaderText ( " Please ▁ wait . . . " ) ; File f = ResourceLoader . getRandomGif ( ) ; Image image ; try { image = new Image ( f . toURI ( ) . toURL ( ) . toString ( ) ) ; ImageView view = new ImageView ( image ) ; alert . setGraphic ( view ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } alert . getDialogPane ( ) . lookupButton ( ButtonType . OK ) . setDisable ( true ) ; Stage stage1 = ( Stage ) alert . getDialogPane ( ) . getScene ( ) . getWindow ( ) ; stage1 . getIcons ( ) . addAll ( ResourceLoader . getIcons ( " check _ mark . ico " ) ) ; alert . setX ( Main . primaryStage . getX ( ) ) ; alert . setY ( Main . primaryStage . getY ( ) + Main . primaryStage . getWidth ( ) / 2 ) ; alert . show ( ) ; Task < Integer > task = new Task < Integer > ( ) { @ Override protected Integer call ( ) throws Exception { System . out . println ( " Started " ) ; ExamExcelHandler . setFilePath_to_excel ( filePath ) ; System . out . println ( "1 . . . " ) ; ExamExcelHandler . loadConstantsFromConfigData ( ) ; System . out . println ( "2 . . . " ) ; list = ExamExcelHandler . readExamStudentListFromFile ( ) ; System . out . println ( "3 . . . " ) ; autoTex . getEntries ( ) . addAll ( list . getObservableList ( ) ) ; autoTex . setCaseSensitive ( false ) ; if ( excelView == null ) { excelView = new ExcelView ( filePath , 0 , false ) ; excelView . showInNewWindow ( ) ; } else { try { excelView . updateView ( ) ; } catch ( Exception e ) { displayText ( " An ▁ error ▁ occured ▁ while ▁ updating ▁ the ▁ Spreadsheet " , false ) ; e . printStackTrace ( ) ; } } return new Integer ( 2 ) ; } @ Override protected void succeeded ( ) { super . succeeded ( ) ; updateMessage ( " Done ! " ) ; System . out . println ( " Done ! " ) ; Platform . runLater ( ( ) -> { SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void cancelled ( ) { super . cancelled ( ) ; updateMessage ( " Cancelled ! " ) ; System . out . println ( " Cancelled " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void failed ( ) { super . failed ( ) ; updateMessage ( " Failed ! " ) ; System . out . println ( " Failed " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } } ; Thread th = new Thread ( task ) ; th . setDaemon ( false ) ; th . start ( ) ; }
TM00/MarkingAssistant | private void displayExcelView ( ) { if ( excelView == null ) { excelView = new ExcelView ( filePath , 0 , false ) ; excelView . showInNewWindow ( ) ; } else { try { excelView . updateView ( ) ; } catch ( Exception e ) { displayText ( " An ▁ error ▁ occured ▁ while ▁ updating ▁ the ▁ Spreadsheet " , false ) ; e . printStackTrace ( ) ; } } }
TM00/MarkingAssistant | private String getHelpString ( ) { String s = " " ; s += " Welcome ▁ to ▁ the ▁ Written ▁ help ▁ page ! \n \n " ; s += " To ▁ use ▁ the ▁ software , ▁ follow ▁ these ▁ steps " ; s += "1 . ▁ Make ▁ sure ▁ the ▁ column ▁ you ▁ want ▁ to ▁ capture ▁ the ▁ marks ▁ to ▁ have ▁ been ▁ created ▁ in ▁ your ▁ Excel ▁ file \n \n " ; s += "2 . ▁ Make ▁ sure ▁ your ▁ Excel ▁ file ▁ is ▁ closed ▁ and ▁ backed ▁ up ▁ to ▁ avoid ▁ corrupting ▁ the ▁ file \n \n " ; s += "3 . ▁ Drag ▁ and ▁ drop ▁ your ▁ Excel ▁ file ▁ anywhere ▁ into ▁ the ▁ window , ▁ after ▁ the ▁ drop ▁ a ▁ loading ▁ bar ▁ will ▁ appear \n \n " ; s += "4 . ▁ A ▁ uneditable ▁ preview ▁ of ▁ the ▁ file ▁ will ▁ open , ▁ this ▁ may ▁ stay ▁ open ▁ during ▁ the ▁ capturing . ▁ Press ▁ the ▁ \" Configure \" ▁ button ▁ and ▁ a ▁ new ▁ window ▁ will ▁ pop ▁ up \n \n " ; s += "5 . ▁ Enter ▁ the ▁ column ▁ letters ▁ where ▁ the ▁ specific ▁ information ▁ is ▁ located ▁ in ▁ your ▁ file , ▁ you ▁ may ▁ scroll ▁ the ▁ preview ▁ to ▁ search ▁ where ▁ the ▁ info ▁ is . ▁ " + " If ▁ not ▁ all ▁ the ▁ info ▁ is ▁ present , ▁ don ' t ▁ panic , ▁ only ▁ the ▁ student ▁ number ▁ and ▁ surname ▁ letters ▁ are ▁ essential . ▁ You ▁ may ▁ simply ▁ enter ▁ dummy ▁ letters ▁ to ▁ the ▁ rest . ▁ " + " The ▁ row ▁ number ▁ is ▁ the ▁ number ▁ of ▁ the ▁ row ▁ ( indicated ▁ on ▁ the ▁ left ▁ on ▁ the ▁ preview ) ▁ where ▁ the ▁ first ▁ student ▁ information ▁ is ▁ stored ▁ after ▁ all ▁ the ▁ headings ▁ etc . \n \n " ; s += "6 . ▁ Press ▁ \" Save ▁ and ▁ Return \" . ▁ The ▁ number ▁ of ▁ students ▁ recorded ▁ will ▁ be ▁ indicated ▁ in ▁ the ▁ prompt , ▁ or ▁ inform ▁ you ▁ when ▁ an ▁ error ▁ has ▁ occured \n \n " ; s += "7 . ▁ Nou ▁ you ▁ may ▁ capture ▁ the ▁ marks ▁ by ▁ searching ▁ for ▁ the ▁ students ▁ by ▁ surname ▁ or ▁ number ▁ in ▁ the ▁ \" search ▁ student \" ▁ field . ▁ Suggestions ▁ will ▁ appear ▁ and ▁ you ▁ can ▁ scroll " + " ▁ with ▁ the ▁ arrow ▁ keys ▁ or ▁ mouse ▁ and ▁ select ▁ with ▁ the ▁ ENTER ▁ key ▁ or ▁ double ▁ mouse ▁ click \n \n " ; s += "8 . ▁ After ▁ the ▁ student ▁ is ▁ located ▁ the ▁ mark ▁ can ▁ be ▁ entered ▁ in ▁ the ▁ \" Enter ▁ mark \" ▁ field \n \n " ; s += "9 . ▁ Repeat ▁ steps ▁ 7 ▁ and ▁ 8 ▁ for ▁ all ▁ the ▁ written ▁ tests \n \n " ; s += "10 . ▁ After ▁ all ▁ the ▁ marks ▁ have ▁ been ▁ entered , ▁ press ▁ the ▁ \" Write ▁ marks ▁ to ▁ file \" ▁ button ▁ to ▁ export ▁ all ▁ the ▁ captures ▁ marks ▁ to ▁ the ▁ Excel ▁ file ▁ and ▁ voila , ▁ you ' re ▁ done ▁ : ) " ; return s ; }
TM00/MarkingAssistant | @ Override public void handleCustonTextEvent ( String description ) { System . err . println ( " Exam ▁ reporting ▁ for ▁ actions . . . ▁ from ▁ handleCustonTextEvent ▁ des : ▁ " + description ) ; setupListView ( ) ; }
barcellosLuizFernando/fechamento | public CadUsuarios2 ( ConexaoMySQL conn ) { initComponents ( ) ; this . cn = conn ; }
barcellosLuizFernando/fechamento | public void MontaLista ( ) { if ( ! " " . equals ( txtPesquisar . getText ( ) ) ) { lista . setColumnCount ( 0 ) ; lista . setRowCount ( 0 ) ; cn . iniciarTransacao ( ) ; String sql = " SELECT ▁ * ▁ FROM ▁ cad _ usuario ▁ " + " WHERE ▁ UPPER ( nome ) ▁ " + " LIKE ▁ ' % " + txtPesquisar . getText ( ) . toUpperCase ( ) + " % ' ▁ OR ▁ departamento ▁ " + " LIKE ▁ ' % " + txtPesquisar . getText ( ) + " % ' " + " ▁ ORDER ▁ BY ▁ nome " ; cn . executeConsulta ( sql ) ; lista . addColumn ( " Código " ) ; lista . addColumn ( " Nome " ) ; lista . addColumn ( " Departamento " ) ; lista . addColumn ( " Função " ) ; lista . addColumn ( " Login " ) ; try { while ( cn . rs . next ( ) ) { lista . addRow ( new String [ ] { cn . rs . getString ( " codigo " ) , cn . rs . getString ( " nome " ) , cn . rs . getString ( " departamento " ) , cn . rs . getString ( " funcao " ) , cn . rs . getString ( " login " ) } ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , " Erro ▁ ao ▁ consultar ▁ o ▁ banco ▁ de ▁ dados : ▁ " + ex ) ; } cn . finalizarTransacao ( ) ; tabCadUser . setModel ( lista ) ; } else { lista . setColumnCount ( 0 ) ; lista . setRowCount ( 0 ) ; tabCadUser . setModel ( lista ) ; btnEditarUser . setEnabled ( false ) ; btnCadastrarUser . setEnabled ( true ) ; } }
barcellosLuizFernando/fechamento | public void Selecao ( ) { int linha = tabCadUser . getSelectedRow ( ) ; txtCodUser . setText ( tabCadUser . getValueAt ( linha , 0 ) . toString ( ) ) ; txtNomeUser . setText ( tabCadUser . getValueAt ( linha , 1 ) . toString ( ) ) ; txtDptoUser . setText ( tabCadUser . getValueAt ( linha , 2 ) . toString ( ) ) ; txtFuncUser . setText ( tabCadUser . getValueAt ( linha , 3 ) . toString ( ) ) ; txtLoginUser . setText ( tabCadUser . getValueAt ( linha , 4 ) . toString ( ) ) ; }
barcellosLuizFernando/fechamento | private void initComponents ( ) { jScrollPane1 = new javax . swing . JScrollPane ( ) ; jTable1 = new javax . swing . JTable ( ) ; jScrollPane3 = new javax . swing . JScrollPane ( ) ; jTable2 = new javax . swing . JTable ( ) ; jPanel1 = new javax . swing . JPanel ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; jLabel2 = new javax . swing . JLabel ( ) ; jLabel3 = new javax . swing . JLabel ( ) ; txtDptoUser = new javax . swing . JTextField ( ) ; txtFuncUser = new javax . swing . JTextField ( ) ; jLabel4 = new javax . swing . JLabel ( ) ; txtNomeUser = new javax . swing . JTextField ( ) ; txtCodUser = new javax . swing . JLabel ( ) ; txtLoginUser = new javax . swing . JTextField ( ) ; jLabel6 = new javax . swing . JLabel ( ) ; jLabel7 = new javax . swing . JLabel ( ) ; txtPesquisar = new javax . swing . JTextField ( ) ; btnCadastrarUser = new javax . swing . JButton ( ) ; btnGravarUser = new javax . swing . JButton ( ) ; btnCancelarUser = new javax . swing . JButton ( ) ; btnEditarUser = new javax . swing . JButton ( ) ; txtSenhaUser = new javax . swing . JPasswordField ( ) ; jLabel8 = new javax . swing . JLabel ( ) ; txtAtivoUser = new javax . swing . JComboBox ( ) ; jLabel5 = new javax . swing . JLabel ( ) ; txtStatus = new javax . swing . JLabel ( ) ; jScrollPane2 = new javax . swing . JScrollPane ( ) ; tabCadUser = new javax . swing . JTable ( ) ; jTable1 . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { { null , null , null , null } , { null , null , null , null } , { null , null , null , null } , { null , null , null , null } } , new String [ ] { " Title ▁ 1" , " Title ▁ 2" , " Title ▁ 3" , " Title ▁ 4" } ) ) ; jScrollPane1 . setViewportView ( jTable1 ) ; jTable2 . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { { null , null , null , null } , { null , null , null , null } , { null , null , null , null } , { null , null , null , null } } , new String [ ] { " Title ▁ 1" , " Title ▁ 2" , " Title ▁ 3" , " Title ▁ 4" } ) ) ; jScrollPane3 . setViewportView ( jTable2 ) ; setClosable ( true ) ; setIconifiable ( true ) ; setTitle ( " Cadastro ▁ de ▁ Usuários " ) ; setVisible ( true ) ; addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyPressed ( java . awt . event . KeyEvent evt ) { formKeyPressed ( evt ) ; } public void keyReleased ( java . awt . event . KeyEvent evt ) { formKeyReleased ( evt ) ; } } ) ; jLabel1 . setText ( " Nome " ) ; jLabel2 . setText ( " Departamento " ) ; jLabel3 . setText ( " Função " ) ; txtDptoUser . setEnabled ( false ) ; txtFuncUser . setEnabled ( false ) ; jLabel4 . setText ( " Código " ) ; txtNomeUser . setEnabled ( false ) ; txtCodUser . setText ( " ▁ " ) ; txtLoginUser . setEnabled ( false ) ; jLabel6 . setText ( " Login " ) ; jLabel7 . setText ( " Senha " ) ; txtPesquisar . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyReleased ( java . awt . event . KeyEvent evt ) { txtPesquisarKeyReleased ( evt ) ; } } ) ; btnCadastrarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Cadastrar . png " ) ) ) ; btnCadastrarUser . setText ( " Cadastrar " ) ; btnCadastrarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnCadastrarUserActionPerformed ( evt ) ; } } ) ; btnGravarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Gravar . png " ) ) ) ; btnGravarUser . setText ( " Gravar " ) ; btnGravarUser . setEnabled ( false ) ; btnGravarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnGravarUserActionPerformed ( evt ) ; } } ) ; btnCancelarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Cancelar . png " ) ) ) ; btnCancelarUser . setText ( " Cancelar " ) ; btnCancelarUser . setEnabled ( false ) ; btnCancelarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnCancelarUserActionPerformed ( evt ) ; } } ) ; btnEditarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Editar . png " ) ) ) ; btnEditarUser . setText ( " Editar " ) ; btnEditarUser . setEnabled ( false ) ; btnEditarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnEditarUserActionPerformed ( evt ) ; } } ) ; txtSenhaUser . setEnabled ( false ) ; jLabel8 . setText ( " Ativo " ) ; txtAtivoUser . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { " S " , " N " } ) ) ; txtAtivoUser . setEnabled ( false ) ; txtAtivoUser . setFocusable ( false ) ; jLabel5 . setText ( " Status " ) ; txtStatus . setText ( " ▁ " ) ; javax . swing . GroupLayout jPanel1Layout = new javax . swing . GroupLayout ( jPanel1 ) ; jPanel1 . setLayout ( jPanel1Layout ) ; jPanel1Layout . setHorizontalGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel1 ) . addGap ( 18 , 18 , 18 ) . addComponent ( txtNomeUser ) ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel4 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( txtCodUser ) . addGap ( 80 , 80 , 80 ) . addComponent ( jLabel5 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( txtStatus ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addComponent ( jLabel8 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( txtAtivoUser , javax . swing . GroupLayout . PREFERRED_SIZE , 45 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING , false ) . addGroup ( javax . swing . GroupLayout . Alignment . LEADING , jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel6 ) . addGap ( 18 , 18 , 18 ) . addComponent ( txtLoginUser ) ) . addGroup ( javax . swing . GroupLayout . Alignment . LEADING , jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel2 ) . addGap ( 19 , 19 , 19 ) . addComponent ( txtDptoUser , javax . swing . GroupLayout . PREFERRED_SIZE , 131 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( jLabel3 ) . addComponent ( jLabel7 ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addComponent ( txtFuncUser , javax . swing . GroupLayout . PREFERRED_SIZE , 167 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) . addComponent ( txtSenhaUser ) ) ) ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , jPanel1Layout . createSequentialGroup ( ) . addGap ( 10 , 10 , 10 ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , jPanel1Layout . createSequentialGroup ( ) . addComponent ( txtPesquisar ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btnCadastrarUser ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , jPanel1Layout . createSequentialGroup ( ) . addGap ( 0 , 0 , Short . MAX_VALUE ) . addComponent ( btnEditarUser ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btnCancelarUser ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btnGravarUser ) ) ) ) ) . addContainerGap ( ) ) ) ; jPanel1Layout . setVerticalGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( btnCadastrarUser ) . addComponent ( txtPesquisar , javax . swing . GroupLayout . PREFERRED_SIZE , 31 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel4 ) . addComponent ( txtCodUser ) . addComponent ( jLabel8 ) . addComponent ( txtAtivoUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jLabel5 ) . addComponent ( txtStatus ) ) . addGap ( 18 , 18 , 18 ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel1 ) . addComponent ( txtNomeUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addGap ( 18 , 18 , 18 ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel2 ) . addComponent ( txtDptoUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jLabel3 ) . addComponent ( txtFuncUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , 18 , Short . MAX_VALUE ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel6 ) . addComponent ( txtLoginUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jLabel7 ) . addComponent ( txtSenhaUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( btnGravarUser ) . addComponent ( btnCancelarUser ) . addComponent ( btnEditarUser ) ) . addContainerGap ( ) ) ) ; tabCadUser . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { } , new String [ ] { } ) ) ; tabCadUser . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mouseClicked ( java . awt . event . MouseEvent evt ) { tabCadUserMouseClicked ( evt ) ; } } ) ; tabCadUser . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyReleased ( java . awt . event . KeyEvent evt ) { tabCadUserKeyReleased ( evt ) ; } } ) ; jScrollPane2 . setViewportView ( tabCadUser ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jPanel1 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jScrollPane2 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( jPanel1 , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( jScrollPane2 , javax . swing . GroupLayout . PREFERRED_SIZE , 165 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ) ; pack ( ) ; }
barcellosLuizFernando/fechamento | private void btnGravarUserActionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! " " . equals ( txtDptoUser . getText ( ) ) && ! " " . equals ( txtFuncUser . getText ( ) ) && ! " " . equals ( txtLoginUser . getText ( ) ) && ! " " . equals ( txtNomeUser . getText ( ) ) ) { String dptoUser = txtDptoUser . getText ( ) ; String funcaoUser = txtFuncUser . getText ( ) ; String loginUser = txtLoginUser . getText ( ) ; String nomeUser = txtNomeUser . getText ( ) ; String senhaUser = new String ( this . txtSenhaUser . getPassword ( ) ) ; String ativoUser = txtAtivoUser . getSelectedItem ( ) . toString ( ) ; cn . iniciarTransacao ( ) ; if ( txtStatus . getText ( ) == " CADASTRANDO " ) { String sql = " INSERT ▁ INTO ▁ CAD _ USUARIO ▁ ( NOME , ▁ DEPARTAMENTO , ▁ FUNCAO , ▁ ATIVO , ▁ LOGIN , ▁ SENHA ) ▁ VALUES ▁ ( ' " + nomeUser + " ' , ' " + dptoUser + " ' , ' " + funcaoUser + " ' , ' " + ativoUser + " ' , ' " + loginUser + " ' , ' " + senhaUser + " ' ) " ; cn . executeAtualizacao ( sql ) ; } else { String sql = " UPDATE ▁ CAD _ USUARIO ▁ SET ▁ NOME ▁ = ▁ ' " + nomeUser + " ' , ▁ DEPARTAMENTO ▁ = ▁ ' " + dptoUser + " ' , ▁ FUNCAO ▁ = ▁ ' " + funcaoUser + " ' , ▁ ATIVO ▁ = ▁ ' " + ativoUser + " ' ▁ WHERE ▁ codigo ▁ = ▁ " + Integer . parseInt ( txtCodUser . getText ( ) ) ; cn . executeAtualizacao ( sql ) ; } cn . finalizarTransacao ( ) ; txtDptoUser . setText ( " " ) ; txtFuncUser . setText ( " " ) ; txtLoginUser . setText ( " " ) ; txtNomeUser . setText ( " " ) ; txtSenhaUser . setText ( " " ) ; txtAtivoUser . setToolTipText ( " " ) ; txtCodUser . setText ( " ▁ " ) ; txtStatus . setText ( " " ) ; txtNomeUser . setEnabled ( false ) ; txtAtivoUser . setEnabled ( false ) ; txtDptoUser . setEnabled ( false ) ; txtLoginUser . setEnabled ( false ) ; txtFuncUser . setEnabled ( false ) ; txtNomeUser . setEnabled ( false ) ; txtPesquisar . setEnabled ( true ) ; btnEditarUser . setEnabled ( false ) ; btnGravarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( false ) ; btnCadastrarUser . setEnabled ( true ) ; MontaLista ( ) ; } else { JOptionPane . showMessageDialog ( rootPane , " Algum ▁ campo ▁ está ▁ em ▁ Branco . " ) ; } }
barcellosLuizFernando/fechamento | private void txtPesquisarKeyReleased ( java . awt . event . KeyEvent evt ) { MontaLista ( ) ; }
barcellosLuizFernando/fechamento | private void tabCadUserMouseClicked ( java . awt . event . MouseEvent evt ) { btnEditarUser . setEnabled ( true ) ; Selecao ( ) ; }
barcellosLuizFernando/fechamento | private void tabCadUserKeyReleased ( java . awt . event . KeyEvent evt ) { Selecao ( ) ; }
barcellosLuizFernando/fechamento | private void btnEditarUserActionPerformed ( java . awt . event . ActionEvent evt ) { txtNomeUser . setEnabled ( true ) ; txtAtivoUser . setEnabled ( true ) ; txtDptoUser . setEnabled ( true ) ; txtLoginUser . setEnabled ( true ) ; txtFuncUser . setEnabled ( true ) ; txtPesquisar . setEnabled ( false ) ; btnGravarUser . setEnabled ( true ) ; btnEditarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( true ) ; btnCadastrarUser . setEnabled ( false ) ; txtStatus . setText ( " EDITANDO " ) ; }
barcellosLuizFernando/fechamento | private void btnCancelarUserActionPerformed ( java . awt . event . ActionEvent evt ) { txtNomeUser . setEnabled ( false ) ; txtCodUser . setText ( " ▁ " ) ; txtAtivoUser . setEnabled ( false ) ; txtDptoUser . setEnabled ( false ) ; txtLoginUser . setEnabled ( false ) ; txtFuncUser . setEnabled ( false ) ; txtSenhaUser . setEnabled ( false ) ; txtStatus . setText ( " ▁ " ) ; txtPesquisar . setEnabled ( true ) ; btnGravarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( false ) ; btnEditarUser . setEnabled ( true ) ; btnCadastrarUser . setEnabled ( true ) ; MontaLista ( ) ; }
barcellosLuizFernando/fechamento | private void btnCadastrarUserActionPerformed ( java . awt . event . ActionEvent evt ) { txtNomeUser . setText ( " " ) ; txtCodUser . setText ( " NOVO " ) ; txtDptoUser . setText ( " " ) ; txtLoginUser . setText ( " " ) ; txtFuncUser . setText ( " " ) ; txtPesquisar . setText ( " " ) ; txtPesquisar . setEnabled ( false ) ; txtNomeUser . setEnabled ( true ) ; txtAtivoUser . setEnabled ( true ) ; txtDptoUser . setEnabled ( true ) ; txtLoginUser . setEnabled ( true ) ; txtFuncUser . setEnabled ( true ) ; txtSenhaUser . setEnabled ( true ) ; txtStatus . setText ( " CADASTRANDO " ) ; btnGravarUser . setEnabled ( true ) ; btnEditarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( true ) ; btnCadastrarUser . setEnabled ( false ) ; }
barcellosLuizFernando/fechamento | private void formKeyPressed ( java . awt . event . KeyEvent evt ) { }
barcellosLuizFernando/fechamento | private void formKeyReleased ( java . awt . event . KeyEvent evt ) { }
Complexible/clearbit | public int getGlobalRank ( ) { return mGlobalRank ; }
Complexible/clearbit | public void setGlobalRank ( final int theGlobalRank ) { mGlobalRank = theGlobalRank ; }
Complexible/clearbit | public int getUsRank ( ) { return mUsRank ; }
Complexible/clearbit | public void setUsRank ( final int theUsRank ) { mUsRank = theUsRank ; }
Complexible/clearbit | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( " Alexa " ) . add ( " US ▁ Rank " , mUsRank ) . add ( " Global ▁ Rank " , mGlobalRank ) . toString ( ) ; }
Complexible/clearbit | @ Override public int hashCode ( ) { return Objects . hashCode ( mUsRank , mGlobalRank ) ; }
Complexible/clearbit | @ Override public boolean equals ( final Object theObj ) { if ( theObj == this ) { return true ; } else if ( theObj instanceof Alexa ) { Alexa aAlexa = ( Alexa ) theObj ; return mUsRank == aAlexa . mUsRank && mGlobalRank == aAlexa . mGlobalRank ; } else { return false ; } }
JSDemos/android-sdk-20 | public PhotoViewPager ( Context context ) { super ( context ) ; initialize ( ) ; }
JSDemos/android-sdk-20 | public PhotoViewPager ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initialize ( ) ; }
JSDemos/android-sdk-20 | private void initialize ( ) { setPageTransformer ( true , new PageTransformer ( ) { @ Override public void transformPage ( View page , float position ) { if ( position < 0 || position >= 1.f ) { page . setTranslationX ( 0 ) ; page . setAlpha ( 1.f ) ; page . setScaleX ( 1 ) ; page . setScaleY ( 1 ) ; } else { page . setTranslationX ( - position * page . getWidth ( ) ) ; page . setAlpha ( Math . max ( 0 , 1.f - position ) ) ; final float scale = Math . max ( 0 , 1.f - position * 0.3f ) ; page . setScaleX ( scale ) ; page . setScaleY ( scale ) ; } } } ) ; }
JSDemos/android-sdk-20 | @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { final InterceptType intercept = ( mListener != null ) ? mListener . onTouchIntercept ( mActivatedX , mActivatedY ) : InterceptType . NONE ; final boolean ignoreScrollLeft = ( intercept == InterceptType . BOTH || intercept == InterceptType . LEFT ) ; final boolean ignoreScrollRight = ( intercept == InterceptType . BOTH || intercept == InterceptType . RIGHT ) ; final int action = ev . getAction ( ) & MotionEventCompat . ACTION_MASK ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mActivePointerId = INVALID_POINTER ; } switch ( action ) { case MotionEvent . ACTION_MOVE : { if ( ignoreScrollLeft || ignoreScrollRight ) { final int activePointerId = mActivePointerId ; if ( activePointerId == INVALID_POINTER ) { break ; } final int pointerIndex = MotionEventCompat . findPointerIndex ( ev , activePointerId ) ; final float x = MotionEventCompat . getX ( ev , pointerIndex ) ; if ( ignoreScrollLeft && ignoreScrollRight ) { mLastMotionX = x ; return false ; } else if ( ignoreScrollLeft && ( x > mLastMotionX ) ) { mLastMotionX = x ; return false ; } else if ( ignoreScrollRight && ( x < mLastMotionX ) ) { mLastMotionX = x ; return false ; } } break ; } case MotionEvent . ACTION_DOWN : { mLastMotionX = ev . getX ( ) ; mActivatedX = ev . getRawX ( ) ; mActivatedY = ev . getRawY ( ) ; mActivePointerId = MotionEventCompat . getPointerId ( ev , 0 ) ; break ; } case MotionEventCompat . ACTION_POINTER_UP : { final int pointerIndex = MotionEventCompat . getActionIndex ( ev ) ; final int pointerId = MotionEventCompat . getPointerId ( ev , pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == 0 ? 1 : 0 ; mLastMotionX = MotionEventCompat . getX ( ev , newPointerIndex ) ; mActivePointerId = MotionEventCompat . getPointerId ( ev , newPointerIndex ) ; } break ; } } return super . onInterceptTouchEvent ( ev ) ; }
JSDemos/android-sdk-20 | public void setOnInterceptTouchListener ( OnInterceptTouchListener l ) { mListener = l ; }
nafae/developer | public BiddingTransitionErrorReason getReason ( ) { return reason ; }
nafae/developer | public void setReason ( BiddingTransitionErrorReason value ) { this . reason = value ; }
bitraten/arx | public LayoutDefinition ( final Composite parent , final Controller controller ) { Composite compositeLeft ; Composite compositeRight ; Composite compositeTopRight ; Composite compositeCenterRight ; Composite compositeBottomRight ; center = new Composite ( parent , SWT . NONE ) ; center . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; final GridLayout centerLayout = SWTUtil . createGridLayout ( 2 ) ; centerLayout . makeColumnsEqualWidth = true ; center . setLayout ( centerLayout ) ; compositeLeft = new Composite ( center , SWT . NONE ) ; compositeLeft . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; compositeLeft . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; compositeRight = new Composite ( center , SWT . NONE ) ; compositeRight . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; compositeRight . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; compositeTopRight = new Composite ( compositeRight , SWT . NONE ) ; compositeTopRight . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; compositeTopRight . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; compositeCenterRight = new Composite ( compositeRight , SWT . NONE ) ; compositeCenterRight . setLayoutData ( SWTUtil . createFillHorizontallyGridData ( ) ) ; compositeCenterRight . setLayout ( new FillLayout ( ) ) ; compositeBottomRight = new Composite ( compositeRight , SWT . NONE ) ; compositeBottomRight . setLayoutData ( SWTUtil . createFillHorizontallyGridData ( ) ) ; compositeBottomRight . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; new ViewDataInput ( compositeLeft , controller , true ) ; new ViewSubsetDefinition ( compositeLeft , controller ) ; new LayoutAttributeSettings ( compositeTopRight , controller ) ; new LayoutCriteria ( compositeCenterRight , controller ) ; new LayoutTransformationModel ( compositeBottomRight , controller ) ; }
cfieber/orca | public PackageInfo ( Stage stage , String packageType , String versionDelimiter , boolean extractBuildDetails , boolean extractVersion , ObjectMapper mapper ) { this . stage = stage ; this . packageType = packageType ; this . versionDelimiter = versionDelimiter ; this . extractBuildDetails = extractBuildDetails ; this . extractVersion = extractVersion ; this . mapper = mapper ; this . buildDetailExtractor = new BuildDetailExtractor ( ) ; if ( stage . getContext ( ) . containsKey ( " package " ) ) { String packages = stage . getContext ( ) . get ( " package " ) . toString ( ) ; for ( String p : packages . split ( " ▁ " ) ) { packageFilePatterns . add ( Pattern . compile ( format ( " % s . * \\ . % s " , p , packageType ) ) ) ; } } }
cfieber/orca | @ VisibleForTesting private boolean isUrl ( String potentialUrl ) { return potentialUrl . matches ( " \\ b ( https ? | ssh ) : \\ / \\ / . * " ) ; }
cfieber/orca | public Map < String , Object > findTargetPackage ( boolean allowMissingPackageInstallation ) { Map < String , Object > requestMap = new HashMap < > ( ) ; requestMap . putAll ( stage . getContext ( ) ) ; if ( stage . getExecution ( ) . getType ( ) == PIPELINE ) { Map trigger = mapper . convertValue ( stage . getExecution ( ) . getTrigger ( ) , Map . class ) ; Map buildInfo = null ; if ( requestMap . get ( " buildInfo " ) != null ) { buildInfo = mapper . convertValue ( requestMap . get ( " buildInfo " ) , Map . class ) ; } if ( buildInfo == null || ( buildInfo . get ( " artifacts " ) != null && ! ( ( Collection ) buildInfo . get ( " artifacts " ) ) . isEmpty ( ) ) ) { Map < String , Object > upstreamBuildInfo = findBuildInfoInUpstreamStage ( stage , packageFilePatterns ) ; if ( ! upstreamBuildInfo . isEmpty ( ) ) { buildInfo = upstreamBuildInfo ; } } if ( buildInfo == null ) { buildInfo = emptyMap ( ) ; } return createAugmentedRequest ( trigger , buildInfo , requestMap , allowMissingPackageInstallation ) ; } return requestMap ; }
cfieber/orca | @ VisibleForTesting private Map < String , Object > createAugmentedRequest ( Map < String , Object > trigger , Map < String , Object > buildInfo , Map < String , Object > request , boolean allowMissingPackageInstallation ) { Map < String , Object > artifactSourceBuildInfo = getArtifactSourceBuildInfo ( trigger ) ; List < Map < String , Object > > triggerArtifacts = Optional . ofNullable ( ( List < Map < String , Object > > ) artifactSourceBuildInfo . get ( " artifacts " ) ) . orElse ( emptyList ( ) ) ; List < Map < String , Object > > buildArtifacts = Optional . ofNullable ( ( List < Map < String , Object > > ) buildInfo . get ( " artifacts " ) ) . orElse ( emptyList ( ) ) ; if ( request . get ( " package " ) == null || request . get ( " package " ) . equals ( " " ) || isUrl ( request . get ( " package " ) . toString ( ) ) ) { return request ; } if ( buildInfo . isEmpty ( ) || buildArtifacts . isEmpty ( ) ) { Optional < Map < String , Object > > parentBuildInfo = Optional . ofNullable ( ( Map ) trigger . get ( " parentExecution " ) ) . map ( it -> ( Map ) it . get ( " trigger " ) ) . map ( it -> ( Map < String , Object > ) it . get ( " buildInfo " ) ) ; if ( triggerArtifacts . isEmpty ( ) && ( trigger . get ( " buildInfo " ) != null || parentBuildInfo . isPresent ( ) ) ) { throw new IllegalStateException ( " Jenkins ▁ job ▁ detected ▁ but ▁ no ▁ artifacts ▁ found , ▁ please ▁ archive ▁ the ▁ packages ▁ in ▁ your ▁ job ▁ and ▁ try ▁ again . " ) ; } } if ( buildArtifacts . isEmpty ( ) && triggerArtifacts . isEmpty ( ) ) { return request ; } List < String > missingPrefixes = new ArrayList < > ( ) ; String fileExtension = format ( " . % s " , packageType ) ; String reqPkg = Optional . ofNullable ( request . get ( " package " ) . toString ( ) ) . orElseGet ( ( ) -> buildArtifacts . stream ( ) . findFirst ( ) . map ( it -> it . get ( " fileName " ) . toString ( ) . split ( versionDelimiter ) [ 0 ] ) . orElseGet ( ( ) -> triggerArtifacts . stream ( ) . findFirst ( ) . map ( it -> it . get ( " fileName " ) . toString ( ) . split ( versionDelimiter ) [ 0 ] ) . orElse ( null ) ) ) ; List < String > requestPackages = Arrays . asList ( reqPkg . split ( " ▁ " ) ) ; for ( int index = 0 ; index < requestPackages . size ( ) ; index ++ ) { String requestPackage = requestPackages . get ( index ) ; String prefix = requestPackage + versionDelimiter ; Map < String , Object > triggerArtifact = filterArtifacts ( triggerArtifacts , prefix , fileExtension ) ; Map < String , Object > buildArtifact = filterArtifacts ( buildArtifacts , prefix , fileExtension ) ; if ( ! triggerArtifact . isEmpty ( ) && ! buildArtifact . isEmpty ( ) && ! triggerArtifact . get ( " fileName " ) . equals ( buildArtifact . get ( " fileName " ) ) ) { throw new IllegalStateException ( " Found ▁ build ▁ artifact ▁ in ▁ Jenkins ▁ stage ▁ and ▁ Pipeline ▁ Trigger " ) ; } String packageName = null ; String packageVersion = null ; if ( ! triggerArtifact . isEmpty ( ) ) { packageName = extractPackageName ( triggerArtifact , fileExtension ) ; if ( extractVersion ) { packageVersion = extractPackageVersion ( triggerArtifact , prefix , fileExtension ) ; } } if ( ! buildArtifact . isEmpty ( ) ) { packageName = extractPackageName ( buildArtifact , fileExtension ) ; if ( extractVersion ) { packageVersion = extractPackageVersion ( buildArtifact , prefix , fileExtension ) ; } } if ( packageVersion != null ) { request . put ( " packageVersion " , packageVersion ) ; } if ( triggerArtifact . isEmpty ( ) && buildArtifact . isEmpty ( ) ) { missingPrefixes . add ( prefix ) ; } requestPackages . set ( index , packageName != null ? packageName : requestPackage ) ; if ( packageName != null ) { if ( extractBuildDetails ) { Map < String , Object > buildInfoForDetails = ! buildArtifact . isEmpty ( ) ? buildInfo : artifactSourceBuildInfo ; buildDetailExtractor . tryToExtractBuildDetails ( buildInfoForDetails , request ) ; } } } if ( ! missingPrefixes . isEmpty ( ) && ! allowMissingPackageInstallation ) { throw new IllegalStateException ( format ( " Unable ▁ to ▁ find ▁ deployable ▁ artifact ▁ starting ▁ with ▁ % s ▁ and ▁ ending ▁ with ▁ % s ▁ in ▁ % s ▁ and ▁ % s . ▁ Make ▁ sure ▁ your ▁ deb ▁ package ▁ file ▁ name ▁ complies ▁ with ▁ the ▁ naming ▁ convention : ▁ name _ version - release _ arch . " , missingPrefixes , fileExtension , buildArtifacts , triggerArtifacts . stream ( ) . map ( it -> it . get ( " fileName " ) ) . collect ( toList ( ) ) ) ) ; } request . put ( " package " , requestPackages . stream ( ) . collect ( joining ( " ▁ " ) ) ) ; return request ; }
cfieber/orca | Map < String , Object > getArtifactSourceBuildInfo ( Map < String , Object > trigger ) { Map < String , Object > buildInfo = Optional . ofNullable ( ( Map < String , Object > ) trigger . get ( " buildInfo " ) ) . orElse ( emptyMap ( ) ) ; Map < String , Object > parentExecution = Optional . ofNullable ( ( Map < String , Object > ) trigger . get ( " parentExecution " ) ) . orElse ( emptyMap ( ) ) ; if ( buildInfo . get ( " artifacts " ) != null ) { return buildInfo ; } if ( parentExecution . get ( " trigger " ) != null ) { return getArtifactSourceBuildInfo ( ( Map < String , Object > ) parentExecution . get ( " trigger " ) ) ; } return emptyMap ( ) ; }
cfieber/orca | private String extractPackageName ( Map artifact , String fileExtension ) { String fileName = artifact . get ( " fileName " ) . toString ( ) ; return fileName . substring ( 0 , fileName . lastIndexOf ( fileExtension ) ) ; }
cfieber/orca | private String extractPackageVersion ( Map < String , Object > artifact , String filePrefix , String fileExtension ) { String fileName = artifact . get ( " fileName " ) . toString ( ) ; String version = fileName . substring ( fileName . indexOf ( filePrefix ) + filePrefix . length ( ) , fileName . lastIndexOf ( fileExtension ) ) ; if ( version . contains ( versionDelimiter ) ) { version = version . substring ( 0 , version . indexOf ( versionDelimiter ) ) ; } return version ; }
cfieber/orca | private Map < String , Object > filterArtifacts ( List < Map < String , Object > > artifacts , String prefix , String fileExtension ) { if ( packageType . equals ( " rpm " ) ) { return filterRPMArtifacts ( artifacts , prefix ) ; } else { return artifacts . stream ( ) . filter ( it -> it . get ( " fileName " ) != null && it . get ( " fileName " ) . toString ( ) . startsWith ( prefix ) && it . get ( " fileName " ) . toString ( ) . endsWith ( fileExtension ) ) . findFirst ( ) . orElse ( emptyMap ( ) ) ; } }
cfieber/orca | private Map < String , Object > filterRPMArtifacts ( List < Map < String , Object > > artifacts , String prefix ) { return artifacts . stream ( ) . filter ( artifact -> { String [ ] parts = artifact . get ( " fileName " ) . toString ( ) . split ( versionDelimiter ) ; if ( parts . length >= 3 ) { parts = Arrays . copyOfRange ( parts , 0 , parts . length - 2 ) ; String appName = Arrays . stream ( parts ) . collect ( joining ( versionDelimiter ) ) ; return format ( " % s % s " , appName , versionDelimiter ) . equals ( prefix ) ; } return false ; } ) . findFirst ( ) . orElse ( emptyMap ( ) ) ; }
haojiankang/spring-cloud | public FeignRemoteCallMessageConvert ( ) { init ( ) ; }
haojiankang/spring-cloud | protected void init ( ) { setDefaultCharset ( DEFAULT_CHARSET ) ; DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter ( ) ; prettyPrinter . indentObjectsWith ( new DefaultIndenter ( " ▁ ▁ " , " \n data : " ) ) ; }
haojiankang/spring-cloud | @ Override protected boolean supports ( Class < ? > clazz ) { return ! BeanUtils . isSimpleType ( clazz ) ; }
haojiankang/spring-cloud | @ Override protected MediaType getDefaultContentType ( Object object ) throws IOException { if ( object instanceof MappingJacksonValue ) { object = ( ( MappingJacksonValue ) object ) . getValue ( ) ; } return super . getDefaultContentType ( object ) ; }
haojiankang/spring-cloud | @ Override protected Long getContentLength ( Object object , MediaType contentType ) throws IOException { if ( object instanceof MappingJacksonValue ) { object = ( ( MappingJacksonValue ) object ) . getValue ( ) ; } return super . getContentLength ( object , contentType ) ; }
haojiankang/spring-cloud | @ Override public boolean canRead ( Class < ? > clazz , MediaType mediaType ) { return false ; }
haojiankang/spring-cloud | public FeignRemoteCallMessageConvert addMediaType ( String type , String subtype ) { mediaTypes . add ( new MediaType ( type , subtype ) ) ; return this ; }
haojiankang/spring-cloud | public FeignRemoteCallMessageConvert addMediaType ( MediaType mediaType ) { mediaTypes . add ( mediaType ) ; return this ; }
haojiankang/spring-cloud | @ Override public List < MediaType > getSupportedMediaTypes ( ) { return mediaTypes ; }
JanewzhWang/dasein-cloud-core | private AffinityGroupFilterOptions ( boolean matchesAny ) { this . matchesAny = matchesAny ; }
JanewzhWang/dasein-cloud-core | public String getRegex ( ) { return regex ; }
JanewzhWang/dasein-cloud-core | public String getDataCenterId ( ) { return dataCenterId ; }
JanewzhWang/dasein-cloud-core | public boolean hasCriteria ( ) { return ( dataCenterId != null || regex != null ) ; }
JanewzhWang/dasein-cloud-core | public boolean isMatchesAny ( ) { return matchesAny ; }
JanewzhWang/dasein-cloud-core | public @ Nonnull AffinityGroupFilterOptions matchingAll ( ) { this . matchesAny = false ; return this ; }
JanewzhWang/dasein-cloud-core | public @ Nonnull AffinityGroupFilterOptions matchingRegex ( @ Nonnull String regex ) { this . regex = regex ; return this ; }
JanewzhWang/dasein-cloud-core | public @ Nonnull AffinityGroupFilterOptions withDataCenterId ( @ Nonnull String dataCenterId ) { this . dataCenterId = dataCenterId ; return this ; }
JanewzhWang/dasein-cloud-core | public boolean matches ( @ Nonnull AffinityGroup affinityGroup ) { if ( regex != null ) { boolean matches = ( affinityGroup . getAffinityGroupName ( ) . matches ( regex ) || affinityGroup . getDescription ( ) . matches ( regex ) ) ; if ( ! matches && ! matchesAny ) { return false ; } else if ( matches && matchesAny ) { return true ; } } if ( dataCenterId != null ) { boolean matches = dataCenterId . equals ( affinityGroup . getDataCenterId ( ) ) ; if ( ! matches && ! matchesAny ) { return false ; } else if ( matches && matchesAny ) { return true ; } } return ! matchesAny ; }
272029252/Metamorphosis | @ Override public byte getType ( ) { return ADD_OP ; }
272029252/Metamorphosis | public AddMsgOperation ( final MessageStore store , final long msgId , final PutCommand putCmd ) { super ( ) ; this . store = store ; this . msgId = msgId ; this . putCmd = putCmd ; }
272029252/Metamorphosis | public AddMsgLocation ( final long offset , final int length , final int checksum , final String storeDesc ) { super ( offset , length ) ; this . checksum = checksum ; this . storeDesc = storeDesc ; }
272029252/Metamorphosis | public ByteBuffer encode ( ) { if ( this . buf == null ) { final byte [ ] storeDescBytes = ByteUtils . getBytes ( this . storeDesc ) ; final ByteBuffer buf = ByteBuffer . allocate ( 4 + 4 + 8 + 4 + this . storeDesc . length ( ) ) ; buf . putLong ( this . getOffset ( ) ) ; buf . putInt ( this . getLength ( ) ) ; buf . putInt ( this . checksum ) ; buf . putInt ( storeDescBytes . length ) ; buf . put ( storeDescBytes ) ; buf . flip ( ) ; this . buf = buf ; } return this . buf ; }
272029252/Metamorphosis | JournalLocation getLocation ( ) { return this . location ; }
272029252/Metamorphosis | public Tx ( final JournalLocation location ) { this . location = location ; }
272029252/Metamorphosis | public void add ( final MessageStore store , final long msgId , final PutCommand putCmd ) { final AddMsgOperation addMsgOperation = new AddMsgOperation ( store , msgId , putCmd ) ; Queue < TxOperation > ops = this . operations . get ( store ) ; if ( ops == null ) { ops = new ConcurrentLinkedQueue < TxOperation > ( ) ; final Queue < TxOperation > oldOps = this . operations . putIfAbsent ( store , ops ) ; if ( oldOps != null ) { ops = oldOps ; } } ops . add ( addMsgOperation ) ; }
272029252/Metamorphosis | public Map < MessageStore , List < Long > > getMsgIds ( ) { final Map < MessageStore , List < Long > > rt = new LinkedHashMap < MessageStore , List < Long > > ( ) ; for ( final Map . Entry < MessageStore , Queue < TxOperation > > entry : this . operations . entrySet ( ) ) { final MessageStore store = entry . getKey ( ) ; final Queue < TxOperation > opQueue = entry . getValue ( ) ; final List < Long > ids = new ArrayList < Long > ( ) ; rt . put ( store , ids ) ; for ( final TxOperation to : opQueue ) { if ( to . getType ( ) == TxOperation . ADD_OP ) { ids . add ( ( ( AddMsgOperation ) to ) . msgId ) ; } } } return rt ; }
272029252/Metamorphosis | public PutCommand [ ] getRequests ( ) { final List < PutCommand > list = new ArrayList < PutCommand > ( this . operations . size ( ) * 2 ) ; for ( final Map . Entry < MessageStore , Queue < TxOperation > > entry : this . operations . entrySet ( ) ) { for ( final TxOperation op : entry . getValue ( ) ) { if ( op . getType ( ) == TxOperation . ADD_OP ) { list . add ( ( ( AddMsgOperation ) op ) . putCmd ) ; } } } final PutCommand [ ] rt = new PutCommand [ list . size ( ) ] ; return list . toArray ( rt ) ; }
272029252/Metamorphosis | public Map < MessageStore , List < PutCommand > > getPutCommands ( ) { final Map < MessageStore , List < PutCommand > > rt = new LinkedHashMap < MessageStore , List < PutCommand > > ( ) ; for ( final Map . Entry < MessageStore , Queue < TxOperation > > entry : this . operations . entrySet ( ) ) { final MessageStore store = entry . getKey ( ) ; final Queue < TxOperation > opQueue = entry . getValue ( ) ; final List < PutCommand > ids = new ArrayList < PutCommand > ( ) ; rt . put ( store , ids ) ; for ( final TxOperation to : opQueue ) { if ( to . getType ( ) == TxOperation . ADD_OP ) { ids . add ( ( ( AddMsgOperation ) to ) . putCmd ) ; } } } return rt ; }
272029252/Metamorphosis | public Map < MessageStore , Queue < TxOperation > > getOperations ( ) { return this . operations ; }
272029252/Metamorphosis | public JournalTransactionStore ( final String dataPath , final MessageStoreManager storeManager , final MetaConfig metaConfig ) throws Exception { this . journalStore = new JournalStore ( dataPath , storeManager , this , metaConfig . getMaxCheckpoints ( ) , metaConfig . getFlushTxLogAtCommit ( ) ) ; this . scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { @ Override public void run ( ) { try { JournalTransactionStore . this . makeCheckpoint ( ) ; } catch ( final Exception e ) { log . error ( " Execute ▁ checkpoint ▁ failed " , e ) ; } } } , metaConfig . getCheckpointInterval ( ) , metaConfig . getCheckpointInterval ( ) , TimeUnit . MILLISECONDS ) ; MetaMBeanServer . registMBean ( this , null ) ; }
272029252/Metamorphosis | @ Override public void prepare ( final TransactionId txid ) throws IOException { Tx tx = null ; synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } if ( tx == null ) { return ; } final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . XA_PREPARE ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( false ) . build ( ) ; final TxCommand msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . setForce ( true ) . build ( ) ; this . journalStore . write ( msg , null , tx . location , false ) ; synchronized ( this . preparedTransactions ) { this . preparedTransactions . put ( txid , tx ) ; } }
272029252/Metamorphosis | public JournalStore getJournalStore ( ) { return this . journalStore ; }
272029252/Metamorphosis | public void replayPrepare ( final TransactionId txid ) throws IOException { Tx tx = null ; synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } if ( tx == null ) { return ; } synchronized ( this . preparedTransactions ) { this . preparedTransactions . put ( txid , tx ) ; } }
272029252/Metamorphosis | public Tx getInflyTx ( final Object txid ) { synchronized ( this . inflightTransactions ) { return this . inflightTransactions . get ( txid ) ; } }
272029252/Metamorphosis | @ Override public int getActiveTransactionCount ( ) { int count = 0 ; synchronized ( this . preparedTransactions ) { count += this . preparedTransactions . size ( ) ; } synchronized ( this . inflightTransactions ) { count += this . inflightTransactions . size ( ) ; } return count ; }
272029252/Metamorphosis | Tx getPreparedTx ( final Object txid ) { synchronized ( this . preparedTransactions ) { return this . preparedTransactions . get ( txid ) ; } }
272029252/Metamorphosis | public Tx getTx ( final Object txid , final JournalLocation location ) { synchronized ( this . inflightTransactions ) { Tx tx = this . inflightTransactions . get ( txid ) ; if ( tx == null ) { tx = new Tx ( location ) ; this . inflightTransactions . put ( txid , tx ) ; } return tx ; } }
272029252/Metamorphosis | @ Override public void commit ( final TransactionId txid , final boolean wasPrepared ) throws IOException { final Tx tx ; if ( wasPrepared ) { synchronized ( this . preparedTransactions ) { tx = this . preparedTransactions . remove ( txid ) ; } } else { synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } } if ( tx == null ) { return ; } final Map < MessageStore , List < Long > > msgIds = tx . getMsgIds ( ) ; final Map < MessageStore , List < PutCommand > > putCommands = tx . getPutCommands ( ) ; final Map < String , AddMsgLocation > locations = new LinkedHashMap < String , JournalTransactionStore . AddMsgLocation > ( ) ; final int count = msgIds . size ( ) ; for ( final Map . Entry < MessageStore , List < Long > > entry : msgIds . entrySet ( ) ) { final MessageStore msgStore = entry . getKey ( ) ; final List < Long > ids = entry . getValue ( ) ; final List < PutCommand > cmds = putCommands . get ( msgStore ) ; msgStore . append ( ids , cmds , new AppendCallback ( ) { @ Override public void appendComplete ( final Location location ) { final int checkSum = CheckSum . crc32 ( MessageUtils . makeMessageBuffer ( ids , cmds ) . array ( ) ) ; final String description = msgStore . getDescription ( ) ; synchronized ( locations ) { locations . put ( description , new AddMsgLocation ( location . getOffset ( ) , location . getLength ( ) , checkSum , description ) ) ; if ( locations . size ( ) == count ) { final ByteBuffer localtionBytes = AddMsgLocationUtils . encodeLocation ( locations ) ; TxCommand msg = null ; final int attachmentLen = localtionBytes . remaining ( ) ; if ( txid . isXATransaction ( ) ) { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . XA_COMMIT ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( wasPrepared ) . setDataLength ( attachmentLen ) . build ( ) ; msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; } else { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . LOCAL_COMMIT ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( wasPrepared ) . setDataLength ( attachmentLen ) . build ( ) ; msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; } try { JournalTransactionStore . this . journalStore . write ( msg , localtionBytes , tx . location , true ) ; } catch ( final IOException e ) { throw new RuntimeException ( " Write ▁ tx ▁ log ▁ failed " , e ) ; } } } } } ) ; } }
272029252/Metamorphosis | public Tx replayCommit ( final TransactionId txid , final boolean wasPrepared ) throws IOException { if ( wasPrepared ) { synchronized ( this . preparedTransactions ) { return this . preparedTransactions . remove ( txid ) ; } } else { synchronized ( this . inflightTransactions ) { return this . inflightTransactions . remove ( txid ) ; } } }
272029252/Metamorphosis | @ Override public void rollback ( final TransactionId txid ) throws IOException { Tx tx = null ; synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } if ( tx == null ) { synchronized ( this . preparedTransactions ) { tx = this . preparedTransactions . remove ( txid ) ; } } if ( tx != null ) { if ( txid . isXATransaction ( ) ) { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . XA_ROLLBACK ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( false ) . build ( ) ; final TxCommand msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; this . journalStore . write ( msg , null , tx . location , true ) ; } else { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . LOCAL_ROLLBACK ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( false ) . build ( ) ; final TxCommand msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; this . journalStore . write ( msg , null , tx . location , true ) ; } } }
272029252/Metamorphosis | public void replayRollback ( final TransactionId txid ) throws IOException { boolean inflight = false ; synchronized ( this . inflightTransactions ) { inflight = this . inflightTransactions . remove ( txid ) != null ; } if ( ! inflight ) { synchronized ( this . preparedTransactions ) { this . preparedTransactions . remove ( txid ) ; } } }
272029252/Metamorphosis | @ Override public void init ( ) { }
272029252/Metamorphosis | @ Override public void dispose ( ) { this . scheduledExecutorService . shutdown ( ) ; try { this . journalStore . close ( ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } }
272029252/Metamorphosis | @ Override public synchronized void recover ( final TransactionRecoveryListener listener ) throws IOException { Map < Object , Tx > copyMap = null ; synchronized ( this . inflightTransactions ) { copyMap = new HashMap < Object , JournalTransactionStore . Tx > ( this . inflightTransactions ) ; } for ( final Map . Entry < Object , Tx > entry : copyMap . entrySet ( ) ) { this . rollback ( ( TransactionId ) entry . getKey ( ) ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Rollback ▁ inflight ▁ transaction : " + entry . getKey ( ) ) ; } } this . doingRecover = true ; try { Map < TransactionId , Tx > txs = null ; synchronized ( this . preparedTransactions ) { txs = new LinkedHashMap < TransactionId , Tx > ( this . preparedTransactions ) ; } for ( final Map . Entry < TransactionId , Tx > entry : txs . entrySet ( ) ) { final Object txid = entry . getKey ( ) ; final Tx tx = entry . getValue ( ) ; listener . recover ( ( XATransactionId ) txid , tx . getRequests ( ) ) ; } } finally { this . doingRecover = false ; } }
272029252/Metamorphosis | @ Override public void addMessage ( final MessageStore store , final long msgId , final PutCommand putCmd , JournalLocation location ) throws IOException { if ( location == null ) { final AppendMessageCommand appendCmd = AppendMessageCommand . newBuilder ( ) . setMessageId ( msgId ) . setPutCommand ( ByteString . copyFrom ( putCmd . encode ( ) . array ( ) ) ) . build ( ) ; final TxCommand txCommand = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . APPEND_MSG ) . setCmdContent ( appendCmd . toByteString ( ) ) . build ( ) ; final Tx tx = this . getInflyTx ( putCmd . getTransactionId ( ) ) ; if ( tx != null ) { location = this . journalStore . write ( txCommand , null , tx . location , false ) ; } else { location = this . journalStore . write ( txCommand , null , null , false ) ; } } final Tx tx = this . getTx ( putCmd . getTransactionId ( ) , location ) ; tx . add ( store , msgId , putCmd ) ; }
272029252/Metamorphosis | @ Override public void makeCheckpoint ( ) throws Exception { this . journalStore . checkpoint ( ) ; }
272029252/Metamorphosis | public JournalLocation checkpoint ( ) throws IOException { JournalLocation rc = null ; synchronized ( this . inflightTransactions ) { for ( final Iterator < Tx > iter = this . inflightTransactions . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { final Tx tx = iter . next ( ) ; final JournalLocation location = tx . location ; if ( rc == null || rc . compareTo ( location ) > 0 ) { rc = location ; } } } synchronized ( this . preparedTransactions ) { for ( final Iterator < Tx > iter = this . preparedTransactions . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { final Tx tx = iter . next ( ) ; final JournalLocation location = tx . location ; if ( rc == null || rc . compareTo ( location ) > 0 ) { rc = location ; } } return rc ; } }
272029252/Metamorphosis | public boolean isDoingRecover ( ) { return this . doingRecover ; }
alien4cloud/alien4cloud | @ Override protected void processWorkflowOperation ( Csar csar , Topology topology , RemoveStepOperation operation , Workflow workflow ) { log . debug ( " removing ▁ step ▁ [ ▁ { } ▁ ] ▁ from ▁ workflow ▁ [ ▁ { } ▁ ] ▁ from ▁ topology ▁ [ ▁ { } ▁ ] " , operation . getStepId ( ) , workflow . getName ( ) , topology . getId ( ) ) ; workflowBuilderService . removeStep ( topology , csar , workflow . getName ( ) , operation . getStepId ( ) ) ; }
PurelyApplied/geode | @ Test public void verifyCQPermissions ( ) throws Exception { String query = " select ▁ * ▁ from ▁ / AuthRegion " ; int serverPort = server . getPort ( ) ; client1 = cluster . startClientVM ( 1 , c2 -> c2 . withCredential ( " test " , " test " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client2 = cluster . startClientVM ( 2 , c1 -> c1 . withCredential ( " clusterManageQuery " , " clusterManageQuery " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client3 = cluster . startClientVM ( 3 , c -> c . withCredential ( " clusterManageQuery , dataRead " , " clusterManageQuery , dataRead " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client1 . invoke ( ( ) -> { final Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; assertNotAuthorized ( cq :: execute , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( cq :: executeWithInitialResults , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( qs :: getAllDurableCqsFromServer , " CLUSTER : READ " ) ; } ) ; client2 . invoke ( ( ) -> { final Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; assertNotAuthorized ( cq :: execute , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( cq :: executeWithInitialResults , " DATA : READ : AuthRegion " ) ; cq . close ( ) ; } ) ; client3 . invoke ( ( ) -> { Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; cq . execute ( ) ; cq . stop ( ) ; } ) ; }
exemplator/exemplator | public Selection ( Position start , Position end ) { this . start = start ; this . end = end ; }
exemplator/exemplator | public Position getStart ( ) { return start ; }
exemplator/exemplator | public Position getEnd ( ) { return end ; }
GunoH/intellij-community | default Tuple2 < Optional < A > , Optional < B > > project ( ) { return null ; }
GunoH/intellij-community | public Tuple2 ( A a , B b ) { }
GunoH/intellij-community | public < R > R into ( BiFunction < A , B , R > fn ) { return null ; }
GunoH/intellij-community | default Tuple2 project ( ) { return null ; }
GunoH/intellij-community | public void into ( ) { }
jdkoren/squidb | private ThreadLocal < Set < T > > notifyObjectAccumulator = new ThreadLocal < Set < T > > ( ) { protected Set < T > initialValue ( ) { return new HashSet < > ( ) ; } }
jdkoren/squidb | public DataChangedNotifier ( ) { }
jdkoren/squidb | public DataChangedNotifier ( SqlTable < ? > ... tables ) { SquidUtilities . addAll ( this . tables , tables ) ; }
jdkoren/squidb | public DataChangedNotifier ( Collection < ? extends SqlTable < ? > > tables ) { this . tables . addAll ( tables ) ; }
jdkoren/squidb | public Set < SqlTable < ? > > whichTables ( ) { return tables ; }
jdkoren/squidb | public void setEnabled ( boolean enabled ) { this . enabled = enabled ; }
jdkoren/squidb | final boolean onDataChanged ( SqlTable < ? > table , SquidDatabase database , DBOperation operation , AbstractModel modelValues , long rowId ) { if ( ! enabled ) { return false ; } return accumulateNotificationObjects ( notifyObjectAccumulator . get ( ) , table , database , operation , modelValues , rowId ) ; }
jdkoren/squidb | final void flushAccumulatedNotifications ( SquidDatabase database , boolean shouldSendNotifications ) { Set < T > accumulatedNotifications = notifyObjectAccumulator . get ( ) ; if ( enabled && shouldSendNotifications ) { sendNotificationsToAll ( database , accumulatedNotifications ) ; } accumulatedNotifications . clear ( ) ; }
jdkoren/squidb | protected void sendNotificationsToAll ( SquidDatabase database , Set < T > notifyObjects ) { for ( T notifyObject : notifyObjects ) { sendNotification ( database , notifyObject ) ; } }
brandtg/switchboard | public StopEventParser ( ) { super ( StopEvent . EVENT_TYPE ) ; }
brandtg/switchboard | public void parse ( XInputStream is , BinlogEventV4Header header , BinlogParserContext context ) throws IOException { final StopEvent event = new StopEvent ( header ) ; context . getEventListener ( ) . onEvents ( event ) ; }
Politbook/politbook_android | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View rootView = inflater . inflate ( R . layout . fragment_state , container , false ) ; mlvStates = ( ListView ) rootView . findViewById ( R . id . lvStates ) ; loadData ( ) ; initListener ( ) ; return rootView ; }
Politbook/politbook_android | private void loadData ( ) { if ( getArguments ( ) != null ) { changeState = getArguments ( ) . getBoolean ( KEY_CHANGE_STATE ) ; } initState ( ) ; mAdapterState = new AdapterState ( getActivity ( ) , mStates , Util . getUfDefault ( this . getActivity ( ) ) ) ; mlvStates . setAdapter ( mAdapterState ) ; }
Politbook/politbook_android | @ Override public void onResume ( ) { super . onResume ( ) ; }
Politbook/politbook_android | private void initListener ( ) { mlvStates . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > adapterView , View view , int i , long l ) { if ( Util . isNetworkAvailable ( view . getContext ( ) ) ) { Util . setUfDefault ( view . getContext ( ) , mStates . get ( i ) . getUf ( ) ) ; PersistenceManager . getInstance ( ) . removeCandidates ( ) ; Util . setFilterParty ( getActivity ( ) , "1" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "3" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "5" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "6" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "7" , 0 ) ; Intent intent = new Intent ( getActivity ( ) , MainActivity . class ) ; startActivity ( intent ) ; getActivity ( ) . finish ( ) ; } else Toast . makeText ( view . getContext ( ) , R . string . no_connection , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; }
Politbook/politbook_android | private void initState ( ) { mStates = new ArrayList < State > ( ) ; mStates . add ( new State ( " AC " , " Acre " , R . drawable . acre ) ) ; mStates . add ( new State ( " AL " , " Alagoas " , R . drawable . alagoas ) ) ; mStates . add ( new State ( " AM " , " Amazonas " , R . drawable . amazonas ) ) ; mStates . add ( new State ( " AP " , " Amapa " , R . drawable . amapa ) ) ; mStates . add ( new State ( " BA " , " Bahia " , R . drawable . bahia ) ) ; mStates . add ( new State ( " CE " , " Ceará " , R . drawable . ceara ) ) ; mStates . add ( new State ( " DF " , " Distrito ▁ Federal " , R . drawable . distritofederal ) ) ; mStates . add ( new State ( " ES " , " Espírito ▁ Santo " , R . drawable . espiritosanto ) ) ; mStates . add ( new State ( " GO " , " Goiás " , R . drawable . goias ) ) ; mStates . add ( new State ( " MA " , " Maranhão " , R . drawable . maranhao ) ) ; mStates . add ( new State ( " MG " , " Minas ▁ Gerais " , R . drawable . minhasgeral ) ) ; mStates . add ( new State ( " MS " , " Mato ▁ Grosso ▁ do ▁ Sul " , R . drawable . matogrossodosul ) ) ; mStates . add ( new State ( " MT " , " Mato ▁ Grosso " , R . drawable . matogrosso ) ) ; mStates . add ( new State ( " PA " , " Pará " , R . drawable . para ) ) ; mStates . add ( new State ( " PB " , " Paraíba " , R . drawable . paraiba ) ) ; mStates . add ( new State ( " PE " , " Pernambuco " , R . drawable . pernambuco ) ) ; mStates . add ( new State ( " PI " , " Piauí " , R . drawable . piaui ) ) ; mStates . add ( new State ( " PR " , " Paraná " , R . drawable . parana ) ) ; mStates . add ( new State ( " RJ " , " Rio ▁ de ▁ Janeiro " , R . drawable . riodejaneiro ) ) ; mStates . add ( new State ( " RN " , " Rio ▁ Grande ▁ do ▁ Norte " , R . drawable . riograndedonorte ) ) ; mStates . add ( new State ( " RO " , " Rondônia " , R . drawable . rondonia ) ) ; mStates . add ( new State ( " RR " , " Roraima " , R . drawable . roraima ) ) ; mStates . add ( new State ( " RS " , " Rio ▁ Grande ▁ do ▁ Sul " , R . drawable . riograndedosul ) ) ; mStates . add ( new State ( " SC " , " Santa ▁ Catarina " , R . drawable . santacatarina ) ) ; mStates . add ( new State ( " SE " , " Sergipe " , R . drawable . sergipe ) ) ; mStates . add ( new State ( " SP " , " São ▁ Paulo " , R . drawable . saopaulo ) ) ; mStates . add ( new State ( " TO " , " Tocantins " , R . drawable . tocantins ) ) ; }
wintersandroid/lego-display-sequencer | public SequenceThread ( ) { setKey ( null ) ; baseDatabaseReference = null ; }
wintersandroid/lego-display-sequencer | public SequenceThread ( @ NonNull DatabaseReference baseDatabaseReference , String name ) { this . name = name ; this . baseDatabaseReference = baseDatabaseReference ; setKey ( baseDatabaseReference . child ( DATABASE_REFERENCE_PARENT ) . push ( ) . getKey ( ) ) ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . NAME ) public String getName ( ) { return name ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . NAME ) public void setName ( String name ) { this . name = name ; }
wintersandroid/lego-display-sequencer | @ Exclude int count ( ) { return sequenceList . size ( ) ; }
wintersandroid/lego-display-sequencer | @ Exclude void addItems ( @ NonNull List < Sequence > sequences ) { this . sequenceList . clear ( ) ; this . sequenceList . addAll ( sequences ) ; sortSequences ( ) ; }
wintersandroid/lego-display-sequencer | @ Exclude @ Nullable public Sequence getItem ( int index ) { return index < sequenceList . size ( ) ? sequenceList . get ( index ) : null ; }
wintersandroid/lego-display-sequencer | @ Exclude public void removeItem ( int index ) { if ( index < sequenceList . size ( ) ) { Sequence sequenceItem = sequenceList . get ( index ) ; getDatabaseReference ( ) . child ( DATABASE_REFERENCE_ITEMS ) . child ( sequenceItem . getKey ( ) ) . removeValue ( ) ; sequenceList . remove ( index ) ; } }
wintersandroid/lego-display-sequencer | @ Exclude public void moveItem ( int indexFrom , int indexTo ) { Collections . swap ( sequenceList , indexFrom , indexTo ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public void itemMoveFinished ( ) { long sequenceOrder = FIRST_SEQUENCE_NUMBER ; for ( int index = 0 ; index < sequenceList . size ( ) ; index ++ ) { Sequence item = sequenceList . get ( index ) ; item . setSequenceOrder ( sequenceOrder ++ ) ; getDatabaseReference ( ) . child ( DATABASE_REFERENCE_ITEMS ) . child ( item . getKey ( ) ) . setValue ( item ) ; } }
wintersandroid/lego-display-sequencer | @ Exclude public void write ( ) { getDatabaseReference ( ) . setValue ( this ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public int appendItem ( Sequence item1 ) { int index = sequenceList . indexOf ( item1 ) ; if ( index < 0 ) { sequenceList . add ( item1 ) ; index = sequenceList . indexOf ( item1 ) ; } return index ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( DATABASE_REFERENCE_ITEMS ) public Map < String , Object > getItemsHashMap ( ) { Map < String , Object > itemsOut = new HashMap < > ( ) ; for ( Sequence item : sequenceList ) { itemsOut . put ( item . getKey ( ) , item ) ; } return itemsOut ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( DATABASE_REFERENCE_ITEMS ) public void setItemsString ( Map < String , Map < String , Object > > items ) { sequenceList . clear ( ) ; Log . d ( TAG , " items ▁ string ▁ " + items . toString ( ) ) ; for ( String key : items . keySet ( ) ) { Log . d ( TAG , " key ▁ " + key ) ; Map < String , Object > properties = items . get ( key ) ; Log . d ( TAG , " values ▁ " + properties . toString ( ) ) ; Sequence sequence = new Sequence ( this , key , properties ) ; appendItem ( sequence ) ; } this . sequenceList . sort ( Comparator . comparingLong ( Sequence :: getSequenceOrder ) ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public int getItemsSize ( ) { return sequenceList . size ( ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public DatabaseReference getDatabaseReference ( ) { return baseDatabaseReference . child ( DATABASE_REFERENCE_PARENT ) . child ( getKey ( ) ) ; }
wintersandroid/lego-display-sequencer | @ Override public String toString ( ) { return " SequenceThread { " + " name = ' " + name + ' \' ' + " , ▁ sequenceList = " + sequenceList . toString ( ) + ' } ' ; }
wintersandroid/lego-display-sequencer | @ Exclude public void showEditor ( Context context ) { BasicAlerts . enterLineDialog ( context , R . string . new_sequence_thread , R . string . name , getName ( ) , value -> { if ( ! TextUtils . isEmpty ( value ) ) { setName ( value ) ; write ( ) ; } } , null ) ; }
wintersandroid/lego-display-sequencer | public void sortSequences ( ) { this . sequenceList . sort ( Comparator . comparingLong ( Sequence :: getSequenceOrder ) ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public DatabaseReference getItemsDatabaseReference ( ) { return getDatabaseReference ( ) . child ( DATABASE_REFERENCE_ITEMS ) ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING ) public boolean isRunning ( ) { return running ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING ) public void setRunning ( boolean running ) { this . running = running ; }
wintersandroid/lego-display-sequencer | @ Exclude @ Nullable public Sequence getRunningSequence ( ) { return running ? getSequenceByOrderNumber ( runningSequenceOrderNumber ) : null ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . CONTINUOUS_RUNNING ) public boolean isContinuousRunning ( ) { return continuousRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . CONTINUOUS_RUNNING ) public void setContinuousRunning ( boolean continuousRunning ) { this . continuousRunning = continuousRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ORDER_NUMBER ) public long getRunningSequenceOrderNumber ( ) { return runningSequenceOrderNumber ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ORDER_NUMBER ) public void setRunningSequenceOrderNumber ( long runningSequenceOrderNumber ) { this . runningSequenceOrderNumber = runningSequenceOrderNumber ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ITEM_ORDER_NUMBER ) public long getRunningSequenceItemOrderNumber ( ) { return runningSequenceItemOrderNumber ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ITEM_ORDER_NUMBER ) public void setRunningSequenceItemOrderNumber ( long runningSequenceItemOrderNumber ) { this . runningSequenceItemOrderNumber = runningSequenceItemOrderNumber ; }
wintersandroid/lego-display-sequencer | @ Nullable @ Exclude public Sequence getSequenceByKey ( String sequenceKey ) { for ( Sequence sequence : sequenceList ) { if ( sequence . getKey ( ) . equals ( sequenceKey ) ) { return sequence ; } } return null ; }
wintersandroid/lego-display-sequencer | @ Nullable @ Exclude public Sequence getSequenceByOrderNumber ( long orderNumber ) { for ( Sequence sequence : sequenceList ) { if ( sequence . getSequenceOrder ( ) == orderNumber ) { return sequence ; } } return null ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . PAUSE_RUNNING ) public boolean isPauseRunning ( ) { return pauseRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . PAUSE_RUNNING ) public void setPauseRunning ( boolean pauseRunning ) { this . pauseRunning = pauseRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . STOP_RUNNING ) public boolean isStopRunning ( ) { return stopRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . STOP_RUNNING ) public void setStopRunning ( boolean stopRunning ) { if ( this . stopRunning && stopRunning ) { cancelRun ( ) ; stopRunning = false ; } this . stopRunning = stopRunning ; }
wintersandroid/lego-display-sequencer | public void startRunning ( boolean continuous ) { this . running = false ; this . continuousRunning = continuous ; setRunningSequenceOrderNumber ( - 1 ) ; setRunningSequenceItemOrderNumber ( - 1 ) ; if ( ! sequenceList . isEmpty ( ) ) { Sequence sequence = sequenceList . get ( 0 ) ; SequenceItem item = sequence . startSequence ( ) ; if ( item != null ) { setRunningSequenceOrderNumber ( sequence . getSequenceOrder ( ) ) ; setRunningSequenceItemOrderNumber ( item . getSequenceOrder ( ) ) ; running = true ; } } }
wintersandroid/lego-display-sequencer | @ Exclude public Sequence getNextSequence ( ) { Sequence currentSequence = getRunningSequence ( ) ; Sequence nextSequence = null ; running = false ; if ( ! stopRunning ) { if ( currentSequence != null ) { nextSequence = getSequenceByOrderNumber ( currentSequence . getSequenceOrder ( ) + 1 ) ; if ( nextSequence == null ) { if ( continuousRunning ) { nextSequence = getSequenceByOrderNumber ( FIRST_SEQUENCE_NUMBER ) ; } } if ( nextSequence != null ) { SequenceItem item = nextSequence . startSequence ( ) ; if ( item != null ) { setRunningSequenceOrderNumber ( nextSequence . getSequenceOrder ( ) ) ; setRunningSequenceItemOrderNumber ( item . getSequenceOrder ( ) ) ; running = true ; } } } } if ( ! running || nextSequence == null ) { setRunningSequenceOrderNumber ( - 1 ) ; setRunningSequenceItemOrderNumber ( - 1 ) ; nextSequence = null ; stopRunning = false ; } return nextSequence ; }
wintersandroid/lego-display-sequencer | @ Exclude public boolean hasSequence ( @ NonNull Sequence sequence ) { return getSequenceByKey ( sequence . getKey ( ) ) != null ; }
wintersandroid/lego-display-sequencer | @ Exclude public boolean hasSequenceItem ( @ NonNull SequenceItem sequenceItem ) { for ( Sequence sequence : sequenceList ) { if ( sequence . hasItem ( sequenceItem ) ) { return true ; } } return false ; }
wintersandroid/lego-display-sequencer | @ Exclude public SequenceItem getRunningSequenceItem ( ) { if ( getRunningSequence ( ) != null ) { return getRunningSequence ( ) . getItemBySequenceOrderNumber ( getRunningSequenceItemOrderNumber ( ) ) ; } return null ; }
wintersandroid/lego-display-sequencer | public void cancelRun ( ) { Log . d ( TAG , " cancelRun " ) ; SequenceItem sequenceItem = getRunningSequenceItem ( ) ; if ( sequenceItem != null ) { Log . d ( TAG , " Canceling ▁ Sequence ▁ Item ▁ ▁ " + sequenceItem . toString ( ) ) ; sequenceItem . cancel ( ) ; } running = false ; setRunningSequenceOrderNumber ( - 1 ) ; setRunningSequenceItemOrderNumber ( - 1 ) ; }
wintersandroid/lego-display-sequencer | @ Exclude @ Override public String getSpinnerText ( @ NonNull Context context ) { return getName ( ) ; }
don-philipe/graphhopper | ) public void canToggleTurnCostsOnOff_legacy ( String mode ) { assertError ( mode , " my _ car _ turn _ costs " , true , null , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' edge _ based ' ▁ parameter . ▁ You ▁ used ▁ ' edge _ based = true ' " ) ; assertError ( mode , " my _ car _ turn _ costs " , false , null , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' edge _ based ' ▁ parameter . ▁ You ▁ used ▁ ' edge _ based = false ' " ) ; assertError ( mode , " my _ car _ turn _ costs " , null , true , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' turn _ costs ' ▁ parameter . ▁ You ▁ used ▁ ' turn _ costs = true ' " ) ; assertError ( mode , " my _ car _ turn _ costs " , null , false , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' turn _ costs ' ▁ parameter . ▁ You ▁ used ▁ ' turn _ costs = false " ) ; assertDistance ( mode , null , null , emptyList ( ) , 1044 ) ; assertDistance ( mode , true , null , emptyList ( ) , 1044 ) ; assertDistance ( mode , null , true , emptyList ( ) , 1044 ) ; assertDistance ( mode , false , null , emptyList ( ) , 400 ) ; assertDistance ( mode , null , false , emptyList ( ) , 400 ) ; }
don-philipe/graphhopper | ) public void curbsides_legacy ( String mode ) { assertDistance ( mode , null , null , Arrays . asList ( " left " , " left " ) , 1459 ) ; assertDistance ( mode , true , null , Arrays . asList ( " left " , " left " ) , 1459 ) ; assertDistance ( mode , null , true , Arrays . asList ( " left " , " left " ) , 1459 ) ; assertError ( mode , null , false , null , Arrays . asList ( " left " , " left " ) , " Disabling ▁ ' edge _ based ' ▁ when ▁ using ▁ ' curbside ' ▁ is ▁ not ▁ allowed " ) ; assertError ( mode , null , null , false , Arrays . asList ( " left " , " left " ) , " Disabling ▁ ' turn _ costs ' ▁ when ▁ using ▁ ' curbside ' ▁ is ▁ not ▁ allowed " ) ; }
don-philipe/graphhopper | private void assertDistance ( String mode , Boolean edgeBased , Boolean turnCosts , List < String > curbsides , double expectedDistance ) { assertDistance ( doGet ( mode , null , edgeBased , turnCosts , curbsides ) , expectedDistance ) ; assertDistance ( doPost ( mode , null , edgeBased , turnCosts , curbsides ) , expectedDistance ) ; }
don-philipe/graphhopper | private void assertError ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides , String ... expectedErrors ) { assertError ( doGet ( mode , profile , edgeBased , turnCosts , curbsides ) , expectedErrors ) ; assertError ( doPost ( mode , profile , edgeBased , turnCosts , curbsides ) , expectedErrors ) ; }
don-philipe/graphhopper | private void assertDistance ( Response response , double expectedDistance ) { JsonNode json = response . readEntity ( JsonNode . class ) ; assertEquals ( 200 , response . getStatus ( ) , json . toString ( ) ) ; JsonNode infoJson = json . get ( " info " ) ; assertFalse ( infoJson . has ( " errors " ) ) ; JsonNode path = json . get ( " paths " ) . get ( 0 ) ; double distance = path . get ( " distance " ) . asDouble ( ) ; assertEquals ( expectedDistance , distance , 1 ) ; }
don-philipe/graphhopper | private void assertError ( Response response , String ... expectedErrors ) { assert expectedErrors . length > 0 ; JsonNode json = response . readEntity ( JsonNode . class ) ; assertEquals ( 400 , response . getStatus ( ) , json . toString ( ) ) ; for ( String e : expectedErrors ) { assertTrue ( json . get ( " message " ) . toString ( ) . contains ( e ) , json . get ( " message " ) . toString ( ) ) ; } }
don-philipe/graphhopper | private String getUrlParams ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { String urlParams = " point = 55.813357,37.5958585 & point = 55.811042,37.594689" ; for ( String curbside : curbsides ) urlParams += " & curbside = " + curbside ; if ( mode . equals ( " LM " ) ) urlParams += " & ch . disable = true " ; if ( mode . equals ( " flex " ) ) urlParams += " & ch . disable = true & lm . disable = true " ; if ( edgeBased != null ) urlParams += " & edge _ based = " + edgeBased ; if ( turnCosts != null ) urlParams += " & turn _ costs = " + turnCosts ; if ( profile != null ) urlParams += " & profile = " + profile ; return urlParams ; }
don-philipe/graphhopper | private String getJsonStr ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { String jsonStr = " { " ; jsonStr += " \" points \" : ▁ [ [37.5958585,55.813357 ] , [37.594689,55.811042 ] ] " ; if ( ! curbsides . isEmpty ( ) ) { assert curbsides . size ( ) == 2 ; jsonStr += " , ▁ \" curbsides \" : ▁ [ \" " + curbsides . get ( 0 ) + " \" , \" " + curbsides . get ( 1 ) + " \" ] " ; } if ( mode . equals ( " LM " ) ) jsonStr += " , ▁ \" ch . disable \" : ▁ true " ; if ( mode . equals ( " flex " ) ) jsonStr += " , ▁ \" ch . disable \" : ▁ true , ▁ \" lm . disable \" : ▁ true " ; if ( edgeBased != null ) jsonStr += " , ▁ \" edge _ based \" : ▁ " + edgeBased ; if ( turnCosts != null ) jsonStr += " , ▁ \" turn _ costs \" : ▁ " + turnCosts ; if ( profile != null ) jsonStr += " , ▁ \" profile \" : ▁ \" " + profile + " \" " ; jsonStr += " } " ; return jsonStr ; }
don-philipe/graphhopper | private Response doGet ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { return clientTarget ( app , " / route ? " + getUrlParams ( mode , profile , edgeBased , turnCosts , curbsides ) ) . request ( ) . buildGet ( ) . invoke ( ) ; }
don-philipe/graphhopper | private Response doPost ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { return clientTarget ( app , " / route ? " ) . request ( ) . post ( Entity . json ( getJsonStr ( mode , profile , edgeBased , turnCosts , curbsides ) ) ) ; }
Altiscale/archiva | @ Test public void testBuildSnapshot ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 2.3-20141119.064321-40 . jar " ) ) ) . isEqualTo ( " jar " ) ; }
Altiscale/archiva | @ Test public void testBuildPom ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . pom " ) ) ) . isEqualTo ( " pom " ) ; }
Altiscale/archiva | @ Test public void testBuildJar ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 - sources . jar " ) ) ) . isEqualTo ( " jar " ) ; }
Altiscale/archiva | @ Test public void testBuildTarGz ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . tar . gz " ) ) ) . isEqualTo ( " tar . gz " ) ; }
Altiscale/archiva | @ Test public void testBuildPomZip ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . pom . zip " ) ) ) . isEqualTo ( " pom . zip " ) ; }
Altiscale/archiva | @ Test public void testBuildR00 ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . r00" ) ) ) . isEqualTo ( " r00" ) ; }
jacarrichan/eoffice | public EmpProfileDaoImpl ( ) { super ( EmpProfile . class ) ; }
jacarrichan/eoffice | public boolean checkProfileNo ( final String profileNo ) { Long count = ( Long ) this . getHibernateTemplate ( ) . execute ( new HibernateCallback ( ) { public Object doInHibernate ( Session session ) throws HibernateException , SQLException { Query query = session . createQuery ( " select ▁ count ( * ) ▁ from ▁ EmpProfile ▁ ep ▁ where ▁ ep . profileNo ▁ = ▁ ? " ) ; query . setString ( 0 , profileNo ) ; return query . uniqueResult ( ) ; } } ) ; return count . longValue ( ) == 0L ; }
arthurthouzeau/SudokuSolverGUI | public SudokuBoard ( int size ) { SIZE = size ; board = new int [ size ] [ size ] ; }
arthurthouzeau/SudokuSolverGUI | public void set ( int value , int row , int col ) { board [ row ] [ col ] = value ; }
arthurthouzeau/SudokuSolverGUI | public int get ( int row , int col ) { return board [ row ] [ col ] ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialRange ( ) { for ( int i = 0 ; i < SIZE ; i ++ ) { for ( int j = 0 ; j < SIZE ; j ++ ) { if ( board [ i ] [ j ] < 0 || board [ i ] [ j ] > SIZE ) return false ; } } return true ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialRows ( ) { BitSet bits = new BitSet ( SIZE + 1 ) ; for ( int i = 0 ; i < SIZE ; i ++ ) { for ( int j = 0 ; j < SIZE ; j ++ ) { if ( board [ i ] [ j ] != 0 && bits . get ( board [ i ] [ j ] ) ) return false ; bits . set ( board [ i ] [ j ] ) ; } bits . clear ( ) ; } return true ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialCols ( ) { BitSet bits = new BitSet ( SIZE + 1 ) ; for ( int j = 0 ; j < SIZE ; j ++ ) { for ( int i = 0 ; i < SIZE ; i ++ ) { if ( board [ i ] [ j ] != 0 && bits . get ( board [ i ] [ j ] ) ) return false ; bits . set ( board [ i ] [ j ] ) ; } bits . clear ( ) ; } return true ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialBoxes ( ) { BitSet bits = new BitSet ( SIZE + 1 ) ; int sqrtSize = ( int ) Math . sqrt ( SIZE ) ; for ( int i = 0 ; i < SIZE ; i += sqrtSize ) { for ( int j = 0 ; j < SIZE ; j += sqrtSize ) { for ( int k = 0 ; k < sqrtSize ; k ++ ) { for ( int l = 0 ; l < sqrtSize ; l ++ ) { if ( board [ i + k ] [ j + l ] != 0 && bits . get ( board [ i + k ] [ j + l ] ) ) return false ; bits . set ( board [ i + k ] [ j + l ] ) ; } } bits . clear ( ) ; } } return true ; }
arthurthouzeau/SudokuSolverGUI | public boolean checkInitialBoard ( ) { return ( checkInitialRange ( ) && checkInitialRows ( ) && checkInitialCols ( ) && checkInitialBoxes ( ) ) ; }
arthurthouzeau/SudokuSolverGUI | public boolean isNumValid ( int [ ] cell , int num ) { int sqrtSize = ( int ) Math . sqrt ( SIZE ) ; int boxRow = ( cell [ 0 ] / sqrtSize ) * sqrtSize ; int boxCol = ( cell [ 1 ] / sqrtSize ) * sqrtSize ; for ( int i = 0 ; i < SIZE ; i ++ ) { if ( get ( cell [ 0 ] , i ) == num || get ( i , cell [ 1 ] ) == num || get ( boxRow + ( i % sqrtSize ) , boxCol + ( i / sqrtSize ) ) == num ) return false ; } return true ; }
arthurthouzeau/SudokuSolverGUI | public void writeToCSV ( String outputFile ) throws IOException { String [ ] [ ] output = new String [ SIZE ] [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { for ( int j = 0 ; j < SIZE ; j ++ ) { output [ i ] [ j ] = String . valueOf ( get ( i , j ) ) ; } } try ( CSVWriter writer = new CSVWriter ( new FileWriter ( outputFile ) , ' , ' , CSVWriter . NO_QUOTE_CHARACTER ) ) { for ( String [ ] record : output ) writer . writeNext ( record ) ; } }
samtstern/quickstart-android | @ Before public void setUp ( ) { rootMatcher = withDecorView ( not ( is ( mActivityRule . getActivity ( ) . getWindow ( ) . getDecorView ( ) ) ) ) ; }
samtstern/quickstart-android | @ After public void tearDown ( ) { getView ( R . id . collapse_button ) . perform ( click ( ) ) ; }
samtstern/quickstart-android | @ Test public void testFiamDisplaysOnForegroundCampaign ( ) { reopen_app ( ) ; getView ( R . id . modal_root ) . check ( matches ( isDisplayed ( ) ) ) ; }
samtstern/quickstart-android | @ Test public void testFiamDisplaysContextualTriggerCampaign ( ) { onView ( withId ( R . id . eventTriggerButton ) ) . perform ( click ( ) ) ; getView ( R . id . modal_root ) . check ( matches ( isDisplayed ( ) ) ) ; }
samtstern/quickstart-android | private void reopen_app ( ) { press_recent ( ) ; press_back ( ) ; }
samtstern/quickstart-android | private void press_recent ( ) { try { UiDevice . getInstance ( getInstrumentation ( ) ) . pressRecentApps ( ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } sleep ( ) ; }
samtstern/quickstart-android | private void press_back ( ) { UiDevice . getInstance ( getInstrumentation ( ) ) . pressBack ( ) ; sleep ( ) ; }
samtstern/quickstart-android | private void sleep ( ) { try { Thread . sleep ( 3000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
samtstern/quickstart-android | @ NonNull private ViewInteraction getView ( @ IdRes int id ) { return onView ( withId ( id ) ) . inRoot ( rootMatcher ) ; }
aws/aws-sdk-java | public AWSServiceCatalogException ( String message ) { super ( message ) ; }
dagnir/aws-sdk-java | public InternalErrorException ( String message ) { super ( message ) ; }
gems-uff/dominoes | switch ( grain ) { case FILE : sql = " SELECT ▁ Distinct ( TF . NewName ) ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " ; sql = sql . concat ( " WHERE ▁ TF . newname ▁ ! = ▁ ' null ' ▁ AND ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ " ) ; sql = sql . concat ( " TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' " ) ; sql = sql . concat ( " AND ▁ TF . Newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " NewName " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName , ▁ TFL . newName ▁ as ▁ FileName ▁ " ; sql = sql . concat ( " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " ) ; sql = sql . concat ( " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ FileName ▁ ! = ▁ ' null ' ▁ " ) ; sql = sql . concat ( " AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ FileName ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " GROUP ▁ BY ▁ TCL . name , ▁ TF . name ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; rs . close ( ) ; break ; }
gems-uff/dominoes | switch ( grain ) { case FILE : { int count = 0 ; if ( cubeOptions == CubeOptions . Max_Commit_Month ) { sql = " SELECT ▁ TU . name , ▁ TC . date , ▁ TC . hashcode , ▁ TF . newname ▁ FROM ▁ TFILE ▁ TF , ▁ " ; sql = sql . concat ( " TUSER ▁ TU , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ WHERE ▁ TF . newname ▁ ! = ▁ ' null ' ▁ AND ▁ " ) ; sql = sql . concat ( " TC . userid ▁ = ▁ TU . id ▁ AND ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ " ) ; sql = sql . concat ( " TC . repoid ▁ = ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TF . newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . date ▁ desc , ▁ TC . hashcode ; " ) ; rs = smt . executeQuery ( sql ) ; Map < String , Integer > max_per_month = Commits_Month ( _repository ) ; int num_commits_per_layer = minimum ; for ( Map . Entry < String , Integer > entry : max_per_month . entrySet ( ) ) { if ( entry . getValue ( ) > minimum ) { num_commits_per_layer = entry . getValue ( ) ; System . out . println ( " Month : ▁ " + entry . getKey ( ) + " ▁ Value : ▁ " + entry . getValue ( ) ) ; } else { System . out . println ( " Using ▁ minimum : ▁ " + num_commits_per_layer ) ; } break ; } List < CommitGroup > commitGroups = new ArrayList < CommitGroup > ( ) ; int currentMonth = - 1 , currentYear = - 1 ; String currentCommitId = null ; while ( rs . next ( ) ) { String commitId = rs . getString ( " hashcode " ) ; if ( currentCommitId == null || currentCommitId . compareTo ( commitId ) != 0 ) { Calendar commitDate = Calendar . getInstance ( ) ; commitDate . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; int month = commitDate . get ( Calendar . MONTH ) ; int year = commitDate . get ( Calendar . YEAR ) ; if ( currentMonth != month || currentYear != year ) { currentMonth = month ; currentYear = year ; CommitGroup _commitGroup = new CommitGroup ( ) ; _commitGroup . matrix = new Matrix2D ( descriptor ) ; _commitGroup . year = year ; _commitGroup . month = month ; commitGroups . add ( _commitGroup ) ; } for ( CommitGroup _c : commitGroups ) if ( _c . count <= num_commits_per_layer ) _c . count ++ ; currentCommitId = commitId ; } for ( CommitGroup _c : commitGroups ) { if ( _c . count <= num_commits_per_layer ) _c . matrix . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; } } Collections . reverse ( commitGroups ) ; CommitGroup _k = commitGroups . get ( commitGroups . size ( ) - 1 ) ; _k . matrix . ExportCSV ( " Teste . txt " ) ; int _count = 0 ; for ( CommitGroup _c : commitGroups ) { cube . AddLayer ( CUBE_DEPTH_PREFIX + _count , _c . matrix ) ; _count ++ ; } } else if ( cubeOptions == CubeOptions . Month ) { sql = " SELECT ▁ TU . name , ▁ TC . date , ▁ TC . hashcode , ▁ TF . newname ▁ FROM ▁ TFILE ▁ TF , ▁ " ; sql = sql . concat ( " TUSER ▁ TU , ▁ TCOMMIT ▁ TC ▁ WHERE ▁ TF . newname ▁ ! = ▁ ' null ' ▁ AND ▁ " ) ; sql = sql . concat ( " TC . userid ▁ = ▁ TU . id ▁ AND ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ " ) ; sql = sql . concat ( " TC . id ▁ in ▁ ( ▁ " ) ; sql = sql . concat ( " SELECT ▁ TC . id ▁ FROM ▁ tcommit ▁ TC , ▁ trepository ▁ TR ▁ " ) ; sql = sql . concat ( " WHERE ▁ TC . repoid ▁ = ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . date , ▁ TC . hashcode ) ; " ) ; rs = smt . executeQuery ( sql ) ; Calendar refDateC = null ; Matrix2D layer = null ; int numRegs = 0 ; while ( rs . next ( ) ) { if ( refDateC == null ) { refDateC = Calendar . getInstance ( ) ; refDateC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; layer = new Matrix2D ( descriptor ) ; layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; } else { Calendar currentDateC = Calendar . getInstance ( ) ; Date _dt = sdf . parse ( rs . getString ( " date " ) ) ; currentDateC . setTime ( _dt ) ; if ( refDateC . get ( Calendar . MONTH ) - currentDateC . get ( Calendar . MONTH ) != 0 || refDateC . get ( Calendar . YEAR ) - currentDateC . get ( Calendar . YEAR ) != 0 ) { System . out . println ( " M " + ( refDateC . get ( Calendar . MONTH ) + 1 ) + " - year " + Integer . toString ( refDateC . get ( Calendar . YEAR ) ) . substring ( 2 ) + " : ▁ " + numRegs ) ; numRegs = 0 ; refDateC = currentDateC ; cube . AddLayer ( CUBE_DEPTH_PREFIX + count , layer ) ; layer = new Matrix2D ( descriptor ) ; count ++ ; } layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; numRegs ++ ; } } } else if ( cubeOptions == CubeOptions . Week ) { Calendar refDateStartC = null ; Calendar refDateEndC = null ; Matrix2D layer = null ; int numRegs = 0 ; SimpleDateFormat sdf2 = new SimpleDateFormat ( " yyyy - MM - dd " ) ; while ( rs . next ( ) ) { if ( refDateStartC == null ) { refDateStartC = Calendar . getInstance ( ) ; refDateStartC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; refDateEndC = Calendar . getInstance ( ) ; refDateEndC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; refDateEndC . add ( Calendar . DAY_OF_WEEK , 7 ) ; layer = new Matrix2D ( descriptor ) ; layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; } else { Calendar currentDateC = Calendar . getInstance ( ) ; Date _dt = sdf . parse ( rs . getString ( " date " ) ) ; currentDateC . setTime ( _dt ) ; if ( currentDateC . compareTo ( refDateEndC ) > 0 ) { System . out . println ( " M " + ( refDateStartC . get ( Calendar . MONTH ) + 1 ) + " - year " + Integer . toString ( refDateStartC . get ( Calendar . YEAR ) ) . substring ( 2 ) + " : ▁ " + numRegs ) ; numRegs = 0 ; refDateStartC . setTime ( _dt ) ; refDateEndC . setTime ( _dt ) ; ; refDateEndC . add ( Calendar . DAY_OF_WEEK , 7 ) ; cube . AddLayer ( CUBE_DEPTH_PREFIX + count , layer ) ; layer = new Matrix2D ( descriptor ) ; count ++ ; } layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; numRegs ++ ; } } } rs . close ( ) ; } break ; case METHOD : { int count = 0 ; if ( cubeOptions == CubeOptions . Max_Commit_Month ) { sql = " SELECT ▁ TC . id , ▁ TC . date , ▁ TC . hashcode , ▁ TU . name ▁ as ▁ username , ▁ TCL . name ▁ as ▁ ClassName , ▁ " ; sql = sql . concat ( " TF . name ▁ as ▁ FuncName , ▁ TFL . newname ▁ FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ " ) ; sql = sql . concat ( " TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TUser ▁ TU , ▁ trepository ▁ TR ▁ WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ " ) ; sql = sql . concat ( " AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ TFL . newname ▁ ! = ▁ ' null ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TC . userid ▁ = ▁ TU . id ▁ AND ▁ tc . repoid ▁ = ▁ ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' " ) ; sql = sql . concat ( " AND ▁ TFL . newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ tc . date ▁ desc , ▁ tc . hashcode ; " ) ; rs = smt . executeQuery ( sql ) ; Map < String , Integer > max_per_month = Commits_Month ( _repository ) ; int num_commits_per_layer = minimum ; for ( Map . Entry < String , Integer > entry : max_per_month . entrySet ( ) ) { if ( entry . getValue ( ) > minimum ) { num_commits_per_layer = entry . getValue ( ) * multiplicator ; System . out . println ( " Month : ▁ " + entry . getKey ( ) + " ▁ Value : ▁ " + entry . getValue ( ) + " ▁ Multiplicator : ▁ " + multiplicator + " Using : ▁ " + num_commits_per_layer ) ; } else { } System . out . println ( " Month : ▁ " + entry . getKey ( ) + " ▁ Value : ▁ " + entry . getValue ( ) + " ▁ Multiplicator : ▁ " + multiplicator + " Using : ▁ " + num_commits_per_layer ) ; } List < CommitGroup > commitGroups = new ArrayList < CommitGroup > ( ) ; int currentMonth = - 1 , currentYear = - 1 ; String currentCommitId = null ; while ( rs . next ( ) ) { String commitId = rs . getString ( " hashcode " ) ; if ( currentCommitId == null || currentCommitId . compareTo ( commitId ) != 0 ) { Calendar commitDate = Calendar . getInstance ( ) ; commitDate . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; int month = commitDate . get ( Calendar . MONTH ) ; int year = commitDate . get ( Calendar . YEAR ) ; if ( currentMonth != month || currentYear != year ) { currentMonth = month ; currentYear = year ; CommitGroup _commitGroup = new CommitGroup ( ) ; _commitGroup . matrix = new Matrix2D ( descriptor ) ; _commitGroup . year = year ; _commitGroup . month = month ; commitGroups . add ( _commitGroup ) ; } for ( CommitGroup _c : commitGroups ) if ( _c . count <= num_commits_per_layer ) _c . count ++ ; currentCommitId = commitId ; } for ( CommitGroup _c : commitGroups ) { if ( _c . count <= num_commits_per_layer ) _c . matrix . AddToElement ( rs . getString ( " username " ) , rs . getString ( " newname " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; } } Collections . reverse ( commitGroups ) ; int _count = 0 ; for ( CommitGroup _c : commitGroups ) { cube . AddLayer ( CUBE_DEPTH_PREFIX + _count , _c . matrix ) ; _count ++ ; } } else if ( cubeOptions == CubeOptions . Month ) { sql = " SELECT ▁ TC . id , ▁ TC . date , ▁ TC . hashcode , ▁ TU . name ▁ as ▁ username , ▁ TCL . name ▁ as ▁ ClassName , ▁ " ; sql = sql . concat ( " TF . name ▁ as ▁ FuncName , ▁ TFL . newname ▁ FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ " ) ; sql = sql . concat ( " TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TUser ▁ TU ▁ WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ " ) ; sql = sql . concat ( " AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ TFL . newname ▁ ! = ▁ ' null ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TC . userid ▁ = ▁ TU . id ▁ AND ▁ TC . id ▁ in ▁ ( ▁ " ) ; sql = sql . concat ( " SELECT ▁ TC . id ▁ FROM ▁ tcommit ▁ TC , ▁ trepository ▁ TR ▁ " ) ; sql = sql . concat ( " WHERE ▁ tc . repoid ▁ = ▁ ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ tc . date , ▁ tc . hashcode ) ; " ) ; rs = smt . executeQuery ( sql ) ; Calendar refDateC = null ; Matrix2D layer = null ; int numRegs = 0 ; while ( rs . next ( ) ) { if ( refDateC == null ) { refDateC = Calendar . getInstance ( ) ; refDateC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; layer = new Matrix2D ( descriptor ) ; layer . AddToElement ( rs . getString ( " username " ) , rs . getString ( " newname " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; } else { Calendar currentDateC = Calendar . getInstance ( ) ; Date _dt = sdf . parse ( rs . getString ( " date " ) ) ; currentDateC . setTime ( _dt ) ; if ( refDateC . get ( Calendar . MONTH ) - currentDateC . get ( Calendar . MONTH ) != 0 || refDateC . get ( Calendar . YEAR ) - currentDateC . get ( Calendar . YEAR ) != 0 ) { System . out . println ( " M " + ( refDateC . get ( Calendar . MONTH ) + 1 ) + " - year " + Integer . toString ( refDateC . get ( Calendar . YEAR ) ) . substring ( 2 ) + " : ▁ " + numRegs ) ; numRegs = 0 ; refDateC = currentDateC ; cube . AddLayer ( CUBE_DEPTH_PREFIX + count , layer ) ; layer = new Matrix2D ( descriptor ) ; count ++ ; } layer . AddToElement ( rs . getString ( " username " ) , rs . getString ( " newname " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; numRegs ++ ; } } } rs . close ( ) ; } break ; }
ilscipio/scipio-erp | public XmlRpcClient ( XmlRpcClientConfig config , String keyStoreComponent , String keyStoreName , String keyAlias ) { this ( config ) ; this . keyStoreComponent = keyStoreComponent ; this . keyStoreName = keyStoreName ; this . keyAlias = keyAlias ; this . setTransportFactory ( this . getClientTransportFactory ( ) ) ; }
ilscipio/scipio-erp | public XmlRpcClient ( XmlRpcClientConfig config ) { super ( ) ; this . setConfig ( config ) ; }
ilscipio/scipio-erp | public XmlRpcTransportFactory getClientTransportFactory ( ) { if ( keyStoreComponent == null || keyStoreName == null || keyAlias == null ) { return this . getTransportFactory ( ) ; } ComponentConfig . KeystoreInfo ks = ComponentConfig . getKeystoreInfo ( keyStoreComponent , keyStoreName ) ; KeyStore keyStore = null ; try { keyStore = KeyStoreUtil . getStore ( ks . createResourceHandler ( ) . getURL ( ) , ks . getPassword ( ) , ks . getType ( ) ) ; } catch ( Exception e ) { Debug . logError ( e , " Unable ▁ to ▁ load ▁ keystore : ▁ " + keyStoreName , module ) ; } return new AliasSupportedTransportFactory ( this , keyStore , ks . getPassword ( ) , keyAlias ) ; }
radicalbit/ambari | public ComponentResourceDefinition ( ) { super ( Resource . Type . Component ) ; }
radicalbit/ambari | @ Override public String getPluralName ( ) { return " components " ; }
radicalbit/ambari | @ Override public String getSingularName ( ) { return " component " ; }
radicalbit/ambari | @ Override public Set < SubResourceDefinition > getSubResourceDefinitions ( ) { return Collections . singleton ( new SubResourceDefinition ( Resource . Type . HostComponent , Collections . singleton ( Resource . Type . Host ) , true ) ) ; }
radicalbit/ambari | @ Override public List < PostProcessor > getPostProcessors ( ) { List < PostProcessor > listProcessors = super . getPostProcessors ( ) ; listProcessors . add ( new ComponentHrefProcessor ( ) ) ; return listProcessors ; }
radicalbit/ambari | @ Override public void process ( Request request , TreeNode < Resource > resultNode , String href ) { TreeNode < Resource > parent = resultNode . getParent ( ) ; if ( parent . getParent ( ) != null && parent . getParent ( ) . getObject ( ) . getType ( ) == Resource . Type . HostComponent ) { Resource r = resultNode . getObject ( ) ; Schema schema = ClusterControllerHelper . getClusterController ( ) . getSchema ( r . getType ( ) ) ; Object serviceId = r . getPropertyValue ( schema . getKeyPropertyId ( Resource . Type . Service ) ) ; Object componentId = r . getPropertyValue ( schema . getKeyPropertyId ( r . getType ( ) ) ) ; href = href . substring ( 0 , href . indexOf ( " / hosts / " ) + 1 ) + " services / " + serviceId + " / components / " + componentId ; resultNode . setProperty ( " href " , href ) ; } else { super . process ( request , resultNode , href ) ; } }
lpandzic/beanvalidation-api | public FooValidationProvider ( ) { createdValidationProviders . add ( new SoftReference < FooValidationProvider > ( this ) ) ; }
lpandzic/beanvalidation-api | public Configuration createSpecializedConfiguration ( BootstrapState state ) { return null ; }
lpandzic/beanvalidation-api | public Configuration < ? > createGenericConfiguration ( BootstrapState state ) { return new DummyConfiguration ( ) ; }
lpandzic/beanvalidation-api | public ValidatorFactory buildValidatorFactory ( ConfigurationState configurationState ) { return new DummyValidatorFactory ( ) ; }
lpandzic/beanvalidation-api | public Configuration ignoreXmlConfiguration ( ) { return null ; }
lpandzic/beanvalidation-api | public Configuration messageInterpolator ( MessageInterpolator interpolator ) { return null ; }
lpandzic/beanvalidation-api | public Configuration traversableResolver ( TraversableResolver resolver ) { return null ; }
lpandzic/beanvalidation-api | public Configuration constraintValidatorFactory ( ConstraintValidatorFactory constraintValidatorFactory ) { return null ; }
lpandzic/beanvalidation-api | public Configuration parameterNameProvider ( ParameterNameProvider parameterNameProvider ) { return null ; }
lpandzic/beanvalidation-api | public Configuration addMapping ( InputStream stream ) { return null ; }
lpandzic/beanvalidation-api | public Configuration addProperty ( String name , String value ) { return null ; }
lpandzic/beanvalidation-api | public MessageInterpolator getDefaultMessageInterpolator ( ) { return null ; }
lpandzic/beanvalidation-api | public TraversableResolver getDefaultTraversableResolver ( ) { return null ; }
lpandzic/beanvalidation-api | public ConstraintValidatorFactory getDefaultConstraintValidatorFactory ( ) { return null ; }
lpandzic/beanvalidation-api | public ParameterNameProvider getDefaultParameterNameProvider ( ) { return null ; }
lpandzic/beanvalidation-api | public BootstrapConfiguration getBootstrapConfiguration ( ) { return null ; }
lpandzic/beanvalidation-api | public ValidatorFactory buildValidatorFactory ( ) { return new DummyValidatorFactory ( ) ; }
lpandzic/beanvalidation-api | @ Override public Validator getValidator ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public ValidatorContext usingContext ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public MessageInterpolator getMessageInterpolator ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public TraversableResolver getTraversableResolver ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public ConstraintValidatorFactory getConstraintValidatorFactory ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public ParameterNameProvider getParameterNameProvider ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public < T > T unwrap ( Class < T > type ) { return null ; }
lpandzic/beanvalidation-api | @ Override public void close ( ) { }
pikaqiuHX/basic | public Integer getMenuId ( ) { return menuId ; }
pikaqiuHX/basic | public void setMenuId ( Integer menuId ) { this . menuId = menuId ; }
pikaqiuHX/basic | public Integer getPid ( ) { return pid ; }
pikaqiuHX/basic | public void setPid ( Integer pid ) { this . pid = pid ; }
pikaqiuHX/basic | public String getMenuName ( ) { return menuName ; }
pikaqiuHX/basic | public void setMenuName ( String menuName ) { this . menuName = menuName == null ? null : menuName . trim ( ) ; }
pikaqiuHX/basic | public String getMenuImg ( ) { return menuImg ; }
pikaqiuHX/basic | public void setMenuImg ( String menuImg ) { this . menuImg = menuImg == null ? null : menuImg . trim ( ) ; }
pikaqiuHX/basic | public String getLinkUrl ( ) { return linkUrl ; }
pikaqiuHX/basic | public void setLinkUrl ( String linkUrl ) { this . linkUrl = linkUrl == null ? null : linkUrl . trim ( ) ; }
pikaqiuHX/basic | public Integer getPriority ( ) { return priority ; }
pikaqiuHX/basic | public void setPriority ( Integer priority ) { this . priority = priority ; }
pikaqiuHX/basic | public Boolean getIsDelete ( ) { return isDelete ; }
pikaqiuHX/basic | public void setIsDelete ( Boolean isDelete ) { this . isDelete = isDelete ; }
pikaqiuHX/basic | public String getPermission ( ) { return permission ; }
pikaqiuHX/basic | public void setPermission ( String permission ) { this . permission = permission == null ? null : permission . trim ( ) ; }
gkatsikas/onos | public ControlMetric ( ControlMetricType metricType , MetricValue metricValue ) { this . metricType = metricType ; this . metricValue = metricValue ; }
gkatsikas/onos | public ControlMetricType metricType ( ) { return metricType ; }
gkatsikas/onos | public MetricValue metricValue ( ) { return metricValue ; }
Hexeption/Youtube-Hacked-Client-1.8 | public ItemEgg ( ) { this . maxStackSize = 16 ; this . setCreativeTab ( CreativeTabs . tabMaterials ) ; }
Hexeption/Youtube-Hacked-Client-1.8 | public ItemStack onItemRightClick ( ItemStack itemStackIn , World worldIn , EntityPlayer playerIn ) { if ( ! playerIn . capabilities . isCreativeMode ) { -- itemStackIn . stackSize ; } worldIn . playSoundAtEntity ( playerIn , " random . bow " , 0.5F , 0.4F / ( itemRand . nextFloat ( ) * 0.4F + 0.8F ) ) ; if ( ! worldIn . isRemote ) { worldIn . spawnEntityInWorld ( new EntityEgg ( worldIn , playerIn ) ) ; } playerIn . triggerAchievement ( StatList . objectUseStats [ Item . getIdFromItem ( this ) ] ) ; return itemStackIn ; }
CHINA-JD/presto | public ByteCodeGeneratorContext ( ByteCodeExpressionVisitor byteCodeGenerator , Scope scope , CallSiteBinder callSiteBinder , FunctionRegistry registry ) { checkNotNull ( byteCodeGenerator , " byteCodeGenerator ▁ is ▁ null " ) ; checkNotNull ( scope , " scope ▁ is ▁ null " ) ; checkNotNull ( callSiteBinder , " callSiteBinder ▁ is ▁ null " ) ; checkNotNull ( registry , " registry ▁ is ▁ null " ) ; this . byteCodeGenerator = byteCodeGenerator ; this . scope = scope ; this . callSiteBinder = callSiteBinder ; this . registry = registry ; this . wasNull = scope . getVariable ( " wasNull " ) ; }
CHINA-JD/presto | public Scope getScope ( ) { return scope ; }
CHINA-JD/presto | public CallSiteBinder getCallSiteBinder ( ) { return callSiteBinder ; }
CHINA-JD/presto | public ByteCodeNode generate ( RowExpression expression ) { return expression . accept ( byteCodeGenerator , scope ) ; }
CHINA-JD/presto | public FunctionRegistry getRegistry ( ) { return registry ; }
CHINA-JD/presto | public ByteCodeNode generateCall ( FunctionInfo function , List < ByteCodeNode > arguments ) { Binding binding = callSiteBinder . bind ( function . getMethodHandle ( ) ) ; return generateInvocation ( scope , function , arguments , binding ) ; }
CHINA-JD/presto | public Variable wasNull ( ) { return wasNull ; }
Rajith90/carbon-apimgt | public TargetFaultDataCollector ( AnalyticsDataProvider provider , FaultEventType subType , RequestDataPublisher processor ) { super ( provider , subType , processor ) ; }
Rajith90/carbon-apimgt | public TargetFaultDataCollector ( AnalyticsDataProvider provider ) { this ( provider , FaultEventType . TARGET_CONNECTIVITY , new FaultyRequestDataPublisher ( ) ) ; this . provider = provider ; }
Rajith90/carbon-apimgt | @ Override public void collectFaultData ( Event faultyEvent ) { log . debug ( " handling ▁ target ▁ failure ▁ analytics ▁ events " ) ; Application application ; if ( provider . isAuthenticated ( ) && provider . isAnonymous ( ) ) { application = getAnonymousApp ( ) ; } else { application = provider . getApplication ( ) ; } faultyEvent . setApplication ( application ) ; this . processRequest ( faultyEvent ) ; }
janzoner/picasso | @ Before public void setUp ( ) { initMocks ( this ) ; }
janzoner/picasso | @ Config ( reportSdk = 12 ) @ Test public void initAddsAttachListenerWhichDefersLayoutListener ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( target ) . addOnAttachStateChangeListener ( attachListenerCaptor . capture ( ) ) ; verifyNoMoreInteractions ( observer ) ; OnAttachStateChangeListener listener = attachListenerCaptor . getValue ( ) ; listener . onViewAttachedToWindow ( target ) ; verify ( target ) . removeOnAttachStateChangeListener ( listener ) ; verify ( observer ) . addOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Config ( reportSdk = 12 ) @ Test public void initAttachedTargetSkipsAttachListener ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; doReturn ( mock ( IBinder . class ) ) . when ( target ) . getWindowToken ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( observer ) . addOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void initAttachesLayoutListenerApi11 ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( observer ) . addOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Config ( reportSdk = 12 ) @ Test public void cancelRemovesAttachListener ( ) { ImageView target = mockFitImageViewTarget ( true ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( target ) . addOnAttachStateChangeListener ( attachListenerCaptor . capture ( ) ) ; request . cancel ( ) ; verify ( target ) . removeOnAttachStateChangeListener ( attachListenerCaptor . getValue ( ) ) ; }
janzoner/picasso | @ Test public void cancelRemovesLayoutListenerApi11 ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; request . cancel ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void cancelTwiceOnlyPerformsOnce ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; request . cancel ( ) ; request . cancel ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void cancelClearsCallback ( ) { ImageView target = mockFitImageViewTarget ( true ) ; Callback callback = mockCallback ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target , callback ) ; assertThat ( request . callback ) . isNotNull ( ) ; request . cancel ( ) ; assertThat ( request . callback ) . isNull ( ) ; }
janzoner/picasso | @ Test public void cancelClearsTag ( ) { ImageView target = mockFitImageViewTarget ( true ) ; RequestCreator creator = mock ( RequestCreator . class ) ; when ( creator . getTag ( ) ) . thenReturn ( " TAG " ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . cancel ( ) ; verify ( creator ) . clearTag ( ) ; }
janzoner/picasso | @ Test public void onLayoutSkipsIfTargetIsNull ( ) { ImageView target = mockFitImageViewTarget ( true ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; ViewTreeObserver viewTreeObserver = target . getViewTreeObserver ( ) ; request . target . clear ( ) ; request . onPreDraw ( ) ; verifyZeroInteractions ( creator ) ; verify ( viewTreeObserver ) . addOnPreDrawListener ( request ) ; verifyNoMoreInteractions ( viewTreeObserver ) ; }
janzoner/picasso | @ Test public void onLayoutSkipsIfViewTreeObserverIsDead ( ) { ImageView target = mockFitImageViewTarget ( false ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; ViewTreeObserver viewTreeObserver = target . getViewTreeObserver ( ) ; request . onPreDraw ( ) ; verify ( viewTreeObserver ) . addOnPreDrawListener ( request ) ; verify ( viewTreeObserver ) . isAlive ( ) ; verifyNoMoreInteractions ( viewTreeObserver ) ; verifyZeroInteractions ( creator ) ; }
janzoner/picasso | @ Test public void waitsForAnotherLayoutIfWidthOrHeightIsZero ( ) { ImageView target = mockFitImageViewTarget ( true ) ; when ( target . getWidth ( ) ) . thenReturn ( 0 ) ; when ( target . getHeight ( ) ) . thenReturn ( 0 ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . onPreDraw ( ) ; verify ( target . getViewTreeObserver ( ) , never ( ) ) . removeOnPreDrawListener ( request ) ; verifyZeroInteractions ( creator ) ; }
janzoner/picasso | @ Test public void cancelSkipsWithNullTarget ( ) { ImageView target = mockFitImageViewTarget ( true ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . target . clear ( ) ; request . cancel ( ) ; verify ( target . getViewTreeObserver ( ) , never ( ) ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void cancelSkipsIfViewTreeObserverIsDead ( ) { ImageView target = mockFitImageViewTarget ( false ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . cancel ( ) ; verify ( target . getViewTreeObserver ( ) , never ( ) ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void preDrawSubmitsRequestAndCleansUp ( ) { Picasso picasso = mock ( Picasso . class ) ; when ( picasso . transformRequest ( any ( Request . class ) ) ) . thenAnswer ( TRANSFORM_REQUEST_ANSWER ) ; RequestCreator creator = new RequestCreator ( picasso , URI_1 , 0 ) ; ImageView target = mockFitImageViewTarget ( true ) ; when ( target . getWidth ( ) ) . thenReturn ( 100 ) ; when ( target . getHeight ( ) ) . thenReturn ( 100 ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . onPreDraw ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; verify ( picasso ) . enqueueAndSubmit ( actionCaptor . capture ( ) ) ; Action value = actionCaptor . getValue ( ) ; assertThat ( value ) . isInstanceOf ( ImageViewAction . class ) ; assertThat ( value . getRequest ( ) . targetWidth ) . isEqualTo ( 100 ) ; assertThat ( value . getRequest ( ) . targetHeight ) . isEqualTo ( 100 ) ; }
janzoner/picasso | @ Test public void multiplePreDrawsOnlyTriggersOnce ( ) { Picasso picasso = mock ( Picasso . class ) ; when ( picasso . transformRequest ( any ( Request . class ) ) ) . thenAnswer ( TRANSFORM_REQUEST_ANSWER ) ; RequestCreator creator = new RequestCreator ( picasso , URI_1 , 0 ) ; ImageView target = mockFitImageViewTarget ( true ) ; when ( target . getWidth ( ) ) . thenReturn ( 100 ) ; when ( target . getHeight ( ) ) . thenReturn ( 100 ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . onPreDraw ( ) ; request . onPreDraw ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; verify ( picasso ) . enqueueAndSubmit ( actionCaptor . capture ( ) ) ; }
jphp-compiler/jphp | @ Override public Class < ? > [ ] getOperationClasses ( ) { return new Class < ? > [ ] { long [ ] . class } ; }
jphp-compiler/jphp | @ Override public long [ ] convert ( Environment env , TraceInfo trace , Memory arg ) throws Throwable { return arg . toValue ( ArrayMemory . class ) . toLongArray ( ) ; }
jphp-compiler/jphp | @ Override public Memory unconvert ( Environment env , TraceInfo trace , long [ ] arg ) throws Throwable { return ArrayMemory . ofLongs ( arg ) . toConstant ( ) ; }
jphp-compiler/jphp | @ Override public void applyTypeHinting ( ParameterEntity parameter ) { parameter . setType ( HintType . ARRAY ) ; }
bedward70/bedward70-fitnesse-io | public RecallBinding ( String symbolName ) { super ( ) ; this . symbolName = symbolName ; }
bedward70/bedward70-fitnesse-io | public Object getValue ( ) throws RuntimeException { if ( ! Fixture . hasSymbol ( symbolName ) ) { throw new FitFailureException ( " No ▁ such ▁ symbol : ▁ " + symbolName ) ; } else { Object value = Fixture . getSymbol ( symbolName ) ; return value ; } }
bedward70/bedward70-fitnesse-io | public QueryBinding ( TypeAdapter adapter ) { super ( ) ; this . adapter = adapter ; }
bedward70/bedward70-fitnesse-io | @ Override public Object getValue ( ) throws RuntimeException { try { return adapter . get ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
bedward70/bedward70-fitnesse-io | public DefaultBuilding ( String name ) { super ( ) ; this . name = name ; }
bedward70/bedward70-fitnesse-io | @ Override public Object getValue ( ) throws RuntimeException { return name ; }
motorina0/flowable-engine | public BlueprintContextELResolver ( ) { }
motorina0/flowable-engine | public BlueprintContextELResolver ( BlueprintContainer blueprintContainer ) { this . blueprintContainer = blueprintContainer ; }
motorina0/flowable-engine | public void setBlueprintContainer ( BlueprintContainer blueprintContainer ) { this . blueprintContainer = blueprintContainer ; }
motorina0/flowable-engine | public Object getValue ( ELContext context , Object base , Object property ) { if ( base == null ) { String key = ( String ) property ; for ( String componentId : ( Set < String > ) blueprintContainer . getComponentIds ( ) ) { if ( componentId . equals ( key ) ) { context . setPropertyResolved ( true ) ; return blueprintContainer . getComponentInstance ( key ) ; } } } return null ; }
motorina0/flowable-engine | public boolean isReadOnly ( ELContext context , Object base , Object property ) { return true ; }
motorina0/flowable-engine | public void setValue ( ELContext context , Object base , Object property , Object value ) { }
motorina0/flowable-engine | public Class < ? > getCommonPropertyType ( ELContext context , Object arg ) { return Object . class ; }
motorina0/flowable-engine | public Iterator < FeatureDescriptor > getFeatureDescriptors ( ELContext context , Object arg ) { return null ; }
motorina0/flowable-engine | public Class < ? > getType ( ELContext context , Object arg1 , Object arg2 ) { return Object . class ; }
is-apps/WebproxyPortlet | @ Before public void setUp ( ) { MockitoAnnotations . initMocks ( this ) ; when ( request . getPortletSession ( ) ) . thenReturn ( session ) ; when ( session . getAttribute ( URLRewritingFilter . REWRITTEN_URLS_KEY ) ) . thenReturn ( rewrittenUrls ) ; when ( request . getPreferences ( ) ) . thenReturn ( preferences ) ; when ( preferences . getValues ( URLRewritingFilter . WHITELIST_REGEXES_KEY , new String [ ] { } ) ) . thenReturn ( new String [ ] { } ) ; filter = spy ( new URLRewritingFilter ( ) ) ; proxyResponse = new GenericContentResponseImpl ( ) ; proxyResponse . setProxiedLocation ( " http : // external . site . com / somewhere / index . html ? q = a & b = t " ) ; final Map < String , Set < String > > urlAttributes = new HashMap < String , Set < String > > ( ) ; urlAttributes . put ( " a " , Collections . singleton ( " href " ) ) ; urlAttributes . put ( " img " , Collections . singleton ( " src " ) ) ; urlAttributes . put ( " form " , Collections . singleton ( " action " ) ) ; urlAttributes . put ( " script " , Collections . singleton ( " src " ) ) ; filter . setActionElements ( urlAttributes ) ; filter . setResourceElements ( new HashMap < String , Set < String > > ( ) ) ; }
is-apps/WebproxyPortlet | @ Test public void testRelativeUrls ( ) { final Document document = Jsoup . parse ( " < div > < a ▁ href = \" / link / with / slash . html \" > Link < / a > < a ▁ href = \" link / without / slash . html \" > Link < / a > < / div > " ) ; filter . filter ( document , proxyResponse , request , response ) ; final String result = " < div > < ahref = \" http : // external . site . com / link / with / slash . html \" > Link < / a > < ahref = \" http : // external . site . com / somewhere / link / without / slash . html \" > Link < / a > < / div > " ; final String expected = document . body ( ) . html ( ) . replace ( " ▁ " , " " ) . replace ( " \n " , " " ) ; assertEquals ( result , expected ) ; }
is-apps/WebproxyPortlet | @ Test public void testProxiedUrls ( ) { when ( preferences . getValues ( URLRewritingFilter . WHITELIST_REGEXES_KEY , new String [ ] { } ) ) . thenReturn ( new String [ ] { " ^ http : // external . site . com " } ) ; doReturn ( " portletUrl " ) . when ( filter ) . createActionUrl ( any ( RenderResponse . class ) , any ( String . class ) ) ; final Document document = Jsoup . parse ( " < div > < a ▁ href = \" / link / with / slash . html \" > Link < / a > < a ▁ href = \" link / without / slash . html \" > Link < / a > < / div > " ) ; filter . filter ( document , proxyResponse , request , response ) ; final String result = " < div > < ahref = \" portletUrl \" > Link < / a > < ahref = \" portletUrl \" > Link < / a > < / div > " ; final String expected = document . body ( ) . html ( ) . replace ( " ▁ " , " " ) . replace ( " \n " , " " ) ; assertEquals ( result , expected ) ; }
is-apps/WebproxyPortlet | @ Test public void testGetBaseUrl ( ) throws URISyntaxException { final String result = filter . getBaseServerUrl ( " http : // somewhere . com / some / path ? query = nothing " ) ; assertEquals ( result , " http : // somewhere . com " ) ; }
is-apps/WebproxyPortlet | @ Test public void testFilterInlineScripts ( ) { final String expectedInlineScriptResult = " < div > test < / div > < scriptlanguage = \" JavaScript \" > functionhelloWorld ( ) { alert ( \" HellofromWebProxyPortlet ! \" ) ; } < / script > " ; final Document document = Jsoup . parse ( " < div > test < / div > < script ▁ language = \" JavaScript \" > \n " + " function ▁ helloWorld ( ) \n " + " { ▁ alert ▁ ( \" Hello ▁ from ▁ WebProxyPortlet ! \" ) ; ▁ } \n " + " < / script > " ) ; filter . filter ( document , proxyResponse , request , response ) ; final String result = document . body ( ) . html ( ) . replace ( " ▁ " , " " ) . replace ( " \n " , " " ) ; assertEquals ( expectedInlineScriptResult , result ) ; }
thombergs/wicked-charts | public ConstLabel ( final String text ) { super ( ) ; this . text = text ; }
thombergs/wicked-charts | public String getText ( ) { return text ; }
thombergs/wicked-charts | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( text == null ) ? 0 : text . hashCode ( ) ) ; return result ; }
thombergs/wicked-charts | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ConstLabel other = ( ConstLabel ) obj ; if ( text == null ) { if ( other . text != null ) return false ; } else if ( ! text . equals ( other . text ) ) return false ; return true ; }
thombergs/wicked-charts | @ Override public String toString ( ) { return " ConstLabel ▁ [ text = " + text + " ] " ; }
almighty/keycloak | @ Before public void beforeAbstractKeycloakTest ( ) throws Exception { adminClient = testContext . getAdminClient ( ) ; if ( adminClient == null ) { String authServerContextRoot = suiteContext . getAuthServerInfo ( ) . getContextRoot ( ) . toString ( ) ; adminClient = AdminClientUtil . createAdminClient ( suiteContext . isAdapterCompatTesting ( ) , authServerContextRoot ) ; testContext . setAdminClient ( adminClient ) ; } getTestingClient ( ) ; adminUser = createAdminUserRepresentation ( ) ; setDefaultPageUriParameters ( ) ; TestEventsLogger . setDriver ( driver ) ; if ( ! AuthServerTestEnricher . AUTH_SERVER_CLUSTER ) { updateMasterAdminPassword ( ) ; } if ( testContext . getTestRealmReps ( ) == null ) { importTestRealms ( ) ; if ( ! isImportAfterEachMethod ( ) ) { testContext . setTestRealmReps ( testRealmReps ) ; } } oauth . init ( adminClient , driver ) ; }
almighty/keycloak | @ After public void afterAbstractKeycloakTest ( ) { if ( resetTimeOffset ) { resetTimeOffset ( ) ; } if ( isImportAfterEachMethod ( ) ) { log . info ( " removing ▁ test ▁ realms ▁ after ▁ test ▁ method " ) ; for ( RealmRepresentation testRealm : testRealmReps ) { removeRealm ( testRealm . getRealm ( ) ) ; } } else { List < RealmRepresentation > realms = testContext . getTestRealmReps ( ) ; for ( RealmRepresentation realm : realms ) { adminClient . realm ( realm . getRealm ( ) ) . logoutAll ( ) ; } for ( TestCleanup cleanup : testContext . getCleanups ( ) . values ( ) ) { cleanup . executeCleanup ( ) ; } testContext . getCleanups ( ) . clear ( ) ; } }
almighty/keycloak | protected TestCleanup getCleanup ( String realmName ) { return testContext . getOrCreateCleanup ( realmName ) ; }
almighty/keycloak | protected TestCleanup getCleanup ( ) { return getCleanup ( " test " ) ; }
almighty/keycloak | protected boolean isImportAfterEachMethod ( ) { return false ; }
almighty/keycloak | protected void updateMasterAdminPassword ( ) { if ( ! suiteContext . isAdminPasswordUpdated ( ) ) { log . debug ( " updating ▁ admin ▁ password " ) ; welcomePage . navigateTo ( ) ; if ( ! welcomePage . isPasswordSet ( ) ) { welcomePage . setPassword ( " admin " , " admin " ) ; } suiteContext . setAdminPasswordUpdated ( true ) ; } }
almighty/keycloak | public void deleteAllCookiesForMasterRealm ( ) { deleteAllCookiesForRealm ( accountPage ) ; }
almighty/keycloak | protected void deleteAllCookiesForRealm ( Account realmAccountPage ) { realmAccountPage . navigateTo ( ) ; log . info ( " deleting ▁ cookies ▁ in ▁ ' " + realmAccountPage . getAuthRealm ( ) + " ' ▁ realm " ) ; driver . manage ( ) . deleteAllCookies ( ) ; }
almighty/keycloak | protected void deleteAllCookiesForRealm ( String realmName ) { driver . navigate ( ) . to ( oauth . AUTH_SERVER_ROOT + " / realms / " + realmName + " / account " ) ; log . info ( " deleting ▁ cookies ▁ in ▁ ' " + realmName + " ' ▁ realm " ) ; driver . manage ( ) . deleteAllCookies ( ) ; }
almighty/keycloak | public void setDefaultPageUriParameters ( ) { masterRealmPage . setAuthRealm ( MASTER ) ; loginPage . setAuthRealm ( MASTER ) ; }
almighty/keycloak | public KeycloakTestingClient getTestingClient ( ) { if ( testingClient == null ) { testingClient = testContext . getTestingClient ( ) ; if ( testingClient == null ) { String authServerContextRoot = suiteContext . getAuthServerInfo ( ) . getContextRoot ( ) . toString ( ) ; testingClient = KeycloakTestingClient . getInstance ( authServerContextRoot + " / auth " ) ; testContext . setTestingClient ( testingClient ) ; } } return testingClient ; }
almighty/keycloak | public TestContext getTestContext ( ) { return testContext ; }
almighty/keycloak | public Keycloak getAdminClient ( ) { return adminClient ; }
almighty/keycloak | private void addTestRealms ( ) { log . debug ( " loading ▁ test ▁ realms " ) ; if ( testRealmReps == null ) { testRealmReps = new ArrayList < > ( ) ; } if ( testRealmReps . isEmpty ( ) ) { addTestRealms ( testRealmReps ) ; } }
almighty/keycloak | public void importTestRealms ( ) { addTestRealms ( ) ; log . info ( " importing ▁ test ▁ realms " ) ; for ( RealmRepresentation testRealm : testRealmReps ) { importRealm ( testRealm ) ; } }
almighty/keycloak | private UserRepresentation createAdminUserRepresentation ( ) { UserRepresentation adminUserRep = new UserRepresentation ( ) ; adminUserRep . setUsername ( ADMIN ) ; setPasswordFor ( adminUserRep , ADMIN ) ; return adminUserRep ; }
almighty/keycloak | public void importRealm ( RealmRepresentation realm ) { log . debug ( " importing ▁ realm : ▁ " + realm . getRealm ( ) ) ; try { RealmResource realmResource = adminClient . realms ( ) . realm ( realm . getRealm ( ) ) ; RealmRepresentation rRep = realmResource . toRepresentation ( ) ; log . debug ( " realm ▁ already ▁ exists ▁ on ▁ server , ▁ re - importing " ) ; realmResource . remove ( ) ; } catch ( NotFoundException nfe ) { } adminClient . realms ( ) . create ( realm ) ; }
almighty/keycloak | public void removeRealm ( String realmName ) { log . info ( " removing ▁ realm : ▁ " + realmName ) ; try { adminClient . realms ( ) . realm ( realmName ) . remove ( ) ; } catch ( NotFoundException e ) { } }
almighty/keycloak | public RealmsResource realmsResouce ( ) { return adminClient . realms ( ) ; }
almighty/keycloak | public String createUser ( String realm , String username , String password , String ... requiredActions ) { List < String > requiredUserActions = Arrays . asList ( requiredActions ) ; UserRepresentation homer = new UserRepresentation ( ) ; homer . setEnabled ( true ) ; homer . setUsername ( username ) ; homer . setRequiredActions ( requiredUserActions ) ; return ApiUtil . createUserAndResetPasswordWithAdminClient ( adminClient . realm ( realm ) , homer , password ) ; }
almighty/keycloak | public void setRequiredActionEnabled ( String realm , String requiredAction , boolean enabled , boolean defaultAction ) { AuthenticationManagementResource managementResource = adminClient . realm ( realm ) . flows ( ) ; RequiredActionProviderRepresentation action = managementResource . getRequiredAction ( requiredAction ) ; action . setEnabled ( enabled ) ; action . setDefaultAction ( defaultAction ) ; managementResource . updateRequiredAction ( requiredAction , action ) ; }
almighty/keycloak | public void setRequiredActionEnabled ( String realm , String userId , String requiredAction , boolean enabled ) { UsersResource usersResource = adminClient . realm ( realm ) . users ( ) ; UserResource userResource = usersResource . get ( userId ) ; UserRepresentation userRepresentation = userResource . toRepresentation ( ) ; List < String > requiredActions = userRepresentation . getRequiredActions ( ) ; if ( enabled && ! requiredActions . contains ( requiredAction ) ) { requiredActions . add ( requiredAction ) ; } else if ( ! enabled && requiredActions . contains ( requiredAction ) ) { requiredActions . remove ( requiredAction ) ; } userResource . update ( userRepresentation ) ; }
almighty/keycloak | public void setTimeOffset ( int offset ) { String response = invokeTimeOffset ( offset ) ; resetTimeOffset = offset != 0 ; log . debugv ( " Set ▁ time ▁ offset , ▁ response ▁ { 0 } " , response ) ; }
almighty/keycloak | public void resetTimeOffset ( ) { String response = invokeTimeOffset ( 0 ) ; resetTimeOffset = false ; log . debugv ( " Reset ▁ time ▁ offset , ▁ response ▁ { 0 } " , response ) ; }
almighty/keycloak | public int getCurrentTime ( ) { return Time . currentTime ( ) ; }
almighty/keycloak | private String invokeTimeOffset ( int offset ) { Time . setOffset ( offset ) ; Map result = testingClient . testing ( ) . setTimeOffset ( Collections . singletonMap ( " offset " , String . valueOf ( offset ) ) ) ; return String . valueOf ( result ) ; }
almighty/keycloak | private void loadConstantsProperties ( ) throws ConfigurationException { constantsProperties = new PropertiesConfiguration ( System . getProperty ( " testsuite . constants " ) ) ; constantsProperties . setThrowExceptionOnMissing ( true ) ; }
almighty/keycloak | protected PropertiesConfiguration getConstantsProperties ( ) throws ConfigurationException { if ( constantsProperties == null ) { loadConstantsProperties ( ) ; } return constantsProperties ; }
almighty/keycloak | public URI getAuthServerRoot ( ) { try { return KeycloakUriBuilder . fromUri ( suiteContext . getAuthServerInfo ( ) . getContextRoot ( ) . toURI ( ) ) . path ( " / auth / " ) . build ( ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } }
JavaSaBr/jME3-SpaceShift-Editor | public GlobalBottomToolSplitPane ( @ NotNull Scene scene ) { super ( scene , EditorConfig . getInstance ( ) ) ; setOrientation ( Orientation . VERTICAL ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void addElements ( @ NotNull TabToolComponent toolComponent , @ NotNull Node other ) { getItems ( ) . setAll ( other , toolComponent ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void addListeners ( @ NotNull TabToolComponent toolComponent ) { ObservableUtils . onChange ( toolComponent . heightProperty ( ) , this :: handleToolChanged ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void bindToScene ( ) { ObservableUtils . onChange ( scene . heightProperty ( ) , number -> handleSceneChanged ( getSceneSize ( ) ) ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected boolean loadCollapsed ( ) { return getConfig ( ) . isGlobalBottomToolCollapsed ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected int loadSize ( ) { return getConfig ( ) . getGlobalBottomToolHeight ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void storeCollapsed ( boolean collapsed ) { getConfig ( ) . setGlobalBottomToolCollapsed ( collapsed ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void storeSize ( int size ) { getConfig ( ) . setGlobalBottomToolHeight ( size ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected double getCollapsedPosition ( ) { return 1 ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected double getSceneSize ( ) { var height = scene . getHeight ( ) ; return Double . compare ( height , 0D ) == 0 ? scene . getHeight ( ) : height ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected double getExpandPosition ( double toolSize , double sceneSize ) { return 1D - super . getExpandPosition ( toolSize , sceneSize ) ; }
Nzen/PD-Litmus | public LitmusFrame ( ) { java . util . LinkedList < Transmix > hierarchy = new java . util . LinkedList < > ( ) ; hierarchy . add ( new Transmix ( " C : \\ users \\ Nzen \\ Downloads " , readSpecificFile ( " hasCode . html " ) ) ) ; Litmus semanticColor = new Litmus ( ) ; hierarchy = semanticColor . stain ( hierarchy ) ; printSpecificFile ( hierarchy ) ; System . out . println ( " LF ( ) ▁ file ▁ pooped , ▁ go ▁ check ▁ it " ) ; }
Nzen/PD-Litmus | final public String readSpecificFile ( String fileName ) { String got = " " ; try { java . nio . file . Path relPath = java . nio . file . Paths . get ( fileName ) ; byte [ ] encoded = java . nio . file . Files . readAllBytes ( relPath ) ; got = new String ( encoded , java . nio . charset . StandardCharsets . UTF_8 ) ; } catch ( java . io . IOException ioe ) { System . err . println ( " LF . rsf ( ) ▁ didn ' t ▁ get ▁ a ▁ real ▁ file " ) ; } return got ; }
Nzen/PD-Litmus | final public void printSpecificFile ( java . util . LinkedList < Transmix > postPlugin ) { String outFile = " hasCodeResult . html " ; java . nio . file . Path relPath = java . nio . file . Paths . get ( outFile ) ; try { java . io . BufferedWriter paper = java . nio . file . Files . newBufferedWriter ( relPath , java . nio . charset . StandardCharsets . UTF_8 , java . nio . file . StandardOpenOption . TRUNCATE_EXISTING ) ; paper . append ( postPlugin . getFirst ( ) . gContent ( ) ) ; paper . close ( ) ; } catch ( java . io . IOException ioe ) { System . err . println ( " LF . rsf ( ) ▁ had ▁ some ▁ I / O ▁ problem . ▁ there ' s ▁ like ▁ five ▁ options " ) ; } }
spohnan/geowave | public HdfsUrlStreamHandlerFactory ( ) { this ( null ) ; }
spohnan/geowave | public HdfsUrlStreamHandlerFactory ( final URLStreamHandlerFactory delegate ) { this . delegate = Optional . ofNullable ( delegate ) ; }
spohnan/geowave | @ Override public URLStreamHandler createURLStreamHandler ( final String protocol ) { final URLStreamHandler urlStreamHandler = super . createURLStreamHandler ( protocol ) ; if ( urlStreamHandler != null ) { return urlStreamHandler ; } return delegate . map ( factory -> factory . createURLStreamHandler ( protocol ) ) . orElse ( null ) ; }
boneman1231/org.apache.felix | public HttpServiceImpl ( Bundle bundle , ServletContext context , HandlerRegistry handlerRegistry , ServletContextAttributeListener servletAttributeListener , boolean sharedContextAttributes ) { this . bundle = bundle ; this . handlerRegistry = handlerRegistry ; this . localServlets = new HashSet < Servlet > ( ) ; this . localFilters = new HashSet < Filter > ( ) ; this . contextManager = new ServletContextManager ( this . bundle , context , servletAttributeListener , sharedContextAttributes ) ; }
boneman1231/org.apache.felix | private ExtServletContext getServletContext ( HttpContext context ) { if ( context == null ) { context = createDefaultHttpContext ( ) ; } return this . contextManager . getServletContext ( context ) ; }
boneman1231/org.apache.felix | public void registerFilter ( Filter filter , String pattern , Dictionary initParams , int ranking , HttpContext context ) throws ServletException { if ( filter == null ) { throw new IllegalArgumentException ( " Filter ▁ must ▁ not ▁ be ▁ null " ) ; } FilterHandler handler = new FilterHandler ( getServletContext ( context ) , filter , pattern , ranking ) ; handler . setInitParams ( initParams ) ; this . handlerRegistry . addFilter ( handler ) ; this . localFilters . add ( filter ) ; }
boneman1231/org.apache.felix | public void unregisterFilter ( Filter filter ) { unregisterFilter ( filter , true ) ; }
boneman1231/org.apache.felix | public void unregisterServlet ( Servlet servlet ) { unregisterServlet ( servlet , true ) ; }
boneman1231/org.apache.felix | if ( servlet == null ) { throw new IllegalArgumentException ( " Servlet ▁ must ▁ not ▁ be ▁ null " ) ; }
boneman1231/org.apache.felix | if ( ! isAliasValid ( alias ) ) { throw new IllegalArgumentException ( " Malformed ▁ servlet ▁ alias ▁ [ " + alias + " ] " ) ; }
boneman1231/org.apache.felix | public void registerResources ( String alias , String name , HttpContext context ) throws NamespaceException { if ( ! isNameValid ( name ) ) { throw new IllegalArgumentException ( " Malformed ▁ resource ▁ name ▁ [ " + name + " ] " ) ; } try { Servlet servlet = new ResourceServlet ( name ) ; registerServlet ( alias , servlet , null , context ) ; } catch ( ServletException e ) { SystemLogger . error ( " Failed ▁ to ▁ register ▁ resources " , e ) ; } }
boneman1231/org.apache.felix | public void unregister ( String alias ) { unregisterServlet ( this . handlerRegistry . getServletByAlias ( alias ) ) ; }
boneman1231/org.apache.felix | public HttpContext createDefaultHttpContext ( ) { return new DefaultHttpContext ( this . bundle ) ; }
boneman1231/org.apache.felix | public void unregisterAll ( ) { HashSet < Servlet > servlets = new HashSet < Servlet > ( this . localServlets ) ; for ( Servlet servlet : servlets ) { unregisterServlet ( servlet , false ) ; } HashSet < Filter > filters = new HashSet < Filter > ( this . localFilters ) ; for ( Filter fiter : filters ) { unregisterFilter ( fiter , false ) ; } }
boneman1231/org.apache.felix | private void unregisterFilter ( Filter filter , final boolean destroy ) { if ( filter != null ) { this . handlerRegistry . removeFilter ( filter , destroy ) ; this . localFilters . remove ( filter ) ; } }
boneman1231/org.apache.felix | private void unregisterServlet ( Servlet servlet , final boolean destroy ) { if ( servlet != null ) { this . handlerRegistry . removeServlet ( servlet , destroy ) ; this . localServlets . remove ( servlet ) ; } }
boneman1231/org.apache.felix | private boolean isNameValid ( String name ) { if ( name == null ) { return false ; } if ( ! name . equals ( " / " ) && name . endsWith ( " / " ) ) { return false ; } return true ; }
boneman1231/org.apache.felix | private boolean isAliasValid ( String alias ) { if ( alias == null ) { return false ; } if ( ! alias . equals ( " / " ) && ( ! alias . startsWith ( " / " ) || alias . endsWith ( " / " ) ) ) { return false ; } return true ; }
freeVM/freeVM | public void testNullClip ( ) { try { GraphicsConfiguration gconf = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; VolatileImage vim = gconf . createCompatibleVolatileImage ( 10 , 10 ) ; Graphics2D g2 = ( Graphics2D ) vim . getGraphics ( ) ; g2 . setClip ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( " Cannot ▁ set ▁ null ▁ clip " ) ; } }
freeVM/freeVM | public void testCopyArea ( ) { GraphicsConfiguration gconf = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; VolatileImage vim = gconf . createCompatibleVolatileImage ( 20 , 20 ) ; Graphics2D g2 = ( Graphics2D ) vim . getGraphics ( ) ; g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( 0 , 0 , 20 , 20 ) ; g2 . setColor ( Color . RED ) ; g2 . fillRect ( 2 , 2 , 1 , 1 ) ; g2 . copyArea ( 2 , 2 , 1 , 1 , 2 , 4 ) ; int pix [ ] = vim . getSnapshot ( ) . getRaster ( ) . getPixel ( 4 , 6 , ( int [ ] ) null ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 0 ] , 255 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 1 ] , 0 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 2 ] , 0 ) ; g2 . setTransform ( AffineTransform . getTranslateInstance ( 2 , 2 ) ) ; g2 . copyArea ( 0 , 0 , 1 , 1 , 4 , 8 ) ; pix = vim . getSnapshot ( ) . getRaster ( ) . getPixel ( 6 , 10 , ( int [ ] ) null ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 0 ] , 255 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 1 ] , 0 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 2 ] , 0 ) ; }
Joybeanx/yogg | public YoggException ( ) { super ( ) ; }
Joybeanx/yogg | public YoggException ( String message ) { super ( message ) ; }
Joybeanx/yogg | public YoggException ( String messageTemplate , Object ... args ) { super ( String . format ( messageTemplate , args ) ) ; }
Joybeanx/yogg | public YoggException ( String message , Throwable cause ) { super ( message , cause ) ; }
Joybeanx/yogg | public YoggException ( Throwable cause , String messageTemplate , Object ... args ) { super ( String . format ( messageTemplate , args ) , cause ) ; }
Joybeanx/yogg | public YoggException ( Throwable cause ) { super ( cause ) ; }
no-go/oLEDBluetoothMap | public void setNRF51822 ( boolean b , boolean isSlow ) { if ( b ) { CCCD = UUID . fromString ( CCCD_nRF ) ; RX_SERVICE_UUID = UUID . fromString ( SERV_nRF ) ; RX_CHAR_UUID = UUID . fromString ( RXUID_nRF ) ; TX_CHAR_UUID = UUID . fromString ( TXUID_nRF ) ; byteMS = MS_nRF ; } else { CCCD = UUID . fromString ( CCCD_HM10 ) ; RX_SERVICE_UUID = UUID . fromString ( SERV_HM10 ) ; RX_CHAR_UUID = UUID . fromString ( RXUID_HM10 ) ; TX_CHAR_UUID = UUID . fromString ( TXUID_HM10 ) ; byteMS = MS_HM10 ; } if ( isSlow ) byteMS = 180 ; }
no-go/oLEDBluetoothMap | private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback ( ) { @ Override public void onConnectionStateChange ( BluetoothGatt gatt , int status , int newState ) { String intentAction ; if ( newState == BluetoothProfile . STATE_CONNECTED ) { intentAction = ACTION_GATT_CONNECTED ; broadcastUpdate ( intentAction ) ; Log . i ( TAG , " Connected ▁ to ▁ GATT ▁ server . " ) ; Log . i ( TAG , " Attempting ▁ to ▁ start ▁ service ▁ discovery : " + mBluetoothGatt . discoverServices ( ) ) ; } else if ( newState == BluetoothProfile . STATE_DISCONNECTED ) { intentAction = ACTION_GATT_DISCONNECTED ; Log . i ( TAG , " Disconnected ▁ from ▁ GATT ▁ server . " ) ; broadcastUpdate ( intentAction ) ; } } @ Override public void onServicesDiscovered ( BluetoothGatt gatt , int status ) { if ( status == BluetoothGatt . GATT_SUCCESS ) { Log . w ( TAG , " mBluetoothGatt ▁ = ▁ " + mBluetoothGatt ) ; broadcastUpdate ( ACTION_GATT_SERVICES_DISCOVERED ) ; } else { Log . w ( TAG , " onServicesDiscovered ▁ received : ▁ " + status ) ; } } @ Override public void onCharacteristicRead ( BluetoothGatt gatt , BluetoothGattCharacteristic characteristic , int status ) { if ( status == BluetoothGatt . GATT_SUCCESS ) { broadcastUpdate ( ACTION_DATA_AVAILABLE , characteristic ) ; } } @ Override public void onCharacteristicChanged ( BluetoothGatt gatt , BluetoothGattCharacteristic characteristic ) { broadcastUpdate ( ACTION_DATA_AVAILABLE , characteristic ) ; } }
no-go/oLEDBluetoothMap | private void broadcastUpdate ( final String action ) { final Intent intent = new Intent ( action ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( intent ) ; }
no-go/oLEDBluetoothMap | private void broadcastUpdate ( final String action , final BluetoothGattCharacteristic characteristic ) { final Intent intent = new Intent ( action ) ; if ( TX_CHAR_UUID . equals ( characteristic . getUuid ( ) ) ) { Log . d ( TAG , characteristic . getValue ( ) . toString ( ) ) ; intent . putExtra ( EXTRA_DATA , characteristic . getValue ( ) ) ; } else { } LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( intent ) ; }
no-go/oLEDBluetoothMap | UartService getService ( ) { return UartService . this ; }
no-go/oLEDBluetoothMap | @ Override public IBinder onBind ( Intent intent ) { return mBinder ; }
no-go/oLEDBluetoothMap | @ Override public boolean onUnbind ( Intent intent ) { close ( ) ; return super . onUnbind ( intent ) ; }
no-go/oLEDBluetoothMap | public boolean initialize ( ) { if ( mBluetoothManager == null ) { mBluetoothManager = ( BluetoothManager ) getSystemService ( Context . BLUETOOTH_SERVICE ) ; if ( mBluetoothManager == null ) return false ; } mBluetoothAdapter = mBluetoothManager . getAdapter ( ) ; if ( mBluetoothAdapter == null ) return false ; return true ; }
no-go/oLEDBluetoothMap | public boolean connect ( final String address ) { if ( mBluetoothAdapter == null || address == null ) return false ; if ( mBluetoothDeviceAddress != null && address . equals ( mBluetoothDeviceAddress ) && mBluetoothGatt != null ) { if ( mBluetoothGatt . connect ( ) ) { return true ; } else { return false ; } } final BluetoothDevice device = mBluetoothAdapter . getRemoteDevice ( address ) ; if ( device == null ) return false ; mBluetoothGatt = device . connectGatt ( this , false , mGattCallback ) ; mBluetoothDeviceAddress = address ; return true ; }
no-go/oLEDBluetoothMap | public void disconnect ( ) { if ( mBluetoothAdapter == null || mBluetoothGatt == null ) return ; mBluetoothGatt . disconnect ( ) ; }
no-go/oLEDBluetoothMap | public void close ( ) { if ( mBluetoothGatt == null ) { return ; } mBluetoothDeviceAddress = null ; mBluetoothGatt . close ( ) ; mBluetoothGatt = null ; }
no-go/oLEDBluetoothMap | public void readCharacteristic ( BluetoothGattCharacteristic characteristic ) { if ( mBluetoothAdapter == null || mBluetoothGatt == null ) { return ; } mBluetoothGatt . readCharacteristic ( characteristic ) ; }
no-go/oLEDBluetoothMap | public void enableTXNotification ( ) { BluetoothGattService RxService = mBluetoothGatt . getService ( RX_SERVICE_UUID ) ; if ( RxService == null ) { broadcastUpdate ( DEVICE_DOES_NOT_SUPPORT_UART ) ; return ; } BluetoothGattCharacteristic TxChar = RxService . getCharacteristic ( TX_CHAR_UUID ) ; if ( TxChar == null ) { broadcastUpdate ( DEVICE_DOES_NOT_SUPPORT_UART ) ; return ; } mBluetoothGatt . setCharacteristicNotification ( TxChar , true ) ; BluetoothGattDescriptor descriptor = TxChar . getDescriptor ( CCCD ) ; descriptor . setValue ( BluetoothGattDescriptor . ENABLE_NOTIFICATION_VALUE ) ; mBluetoothGatt . writeDescriptor ( descriptor ) ; }
no-go/oLEDBluetoothMap | public void writeRXCharacteristic ( byte [ ] val ) { new AsyncTask < byte [ ] , Void , Void > ( ) { @ Override protected Void doInBackground ( byte [ ] ... bytes ) { byte [ ] value = bytes [ 0 ] ; int packs = ( int ) Math . ceil ( ( float ) value . length / ( float ) BYTE_LIMIT ) ; int finish = BYTE_LIMIT ; int offset ; for ( int i = 0 ; i < packs ; i ++ ) { offset = i * BYTE_LIMIT ; if ( ( offset + BYTE_LIMIT ) >= value . length ) { finish = value . length - offset ; } byte [ ] outputBytes = new byte [ finish ] ; System . arraycopy ( value , offset , outputBytes , 0 , finish ) ; BluetoothGattService RxService = mBluetoothGatt . getService ( RX_SERVICE_UUID ) ; BluetoothGattCharacteristic RxChar = RxService . getCharacteristic ( RX_CHAR_UUID ) ; RxChar . setValue ( outputBytes ) ; mBluetoothGatt . writeCharacteristic ( RxChar ) ; try { Thread . sleep ( byteMS ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } return null ; } } . execute ( val ) ; }
no-go/oLEDBluetoothMap | public List < BluetoothGattService > getSupportedGattServices ( ) { if ( mBluetoothGatt == null ) return null ; return mBluetoothGatt . getServices ( ) ; }
sunsuk7tp/MyCassandra | protected RenameColumnFamily ( ) { }
sunsuk7tp/MyCassandra | private KSMetaData makeNewKeyspaceDefinition ( KSMetaData ksm ) { CFMetaData oldCfm = ksm . cfMetaData ( ) . get ( oldName ) ; List < CFMetaData > newCfs = new ArrayList < CFMetaData > ( ksm . cfMetaData ( ) . values ( ) ) ; newCfs . remove ( oldCfm ) ; assert newCfs . size ( ) == ksm . cfMetaData ( ) . size ( ) - 1 ; CFMetaData newCfm = CFMetaData . rename ( oldCfm , newName ) ; newCfs . add ( newCfm ) ; return new KSMetaData ( ksm . name , ksm . strategyClass , ksm . strategyOptions , ksm . replicationFactor , newCfs . toArray ( new CFMetaData [ newCfs . size ( ) ] ) ) ; }
sunsuk7tp/MyCassandra | @ Override public void applyModels ( ) throws IOException { KSMetaData oldKsm = DatabaseDescriptor . getTableDefinition ( tableName ) ; CFMetaData . purge ( oldKsm . cfMetaData ( ) . get ( oldName ) ) ; KSMetaData ksm = makeNewKeyspaceDefinition ( DatabaseDescriptor . getTableDefinition ( tableName ) ) ; try { CFMetaData . map ( ksm . cfMetaData ( ) . get ( newName ) ) ; } catch ( ConfigurationException ex ) { throw new RuntimeException ( ex ) ; } DatabaseDescriptor . setTableDefinition ( ksm , newVersion ) ; if ( ! clientMode ) { Table . open ( ksm . name ) . renameCf ( cfId , newName ) ; } }
sunsuk7tp/MyCassandra | public void subdeflate ( org . apache . cassandra . db . migration . avro . Migration mi ) { org . apache . cassandra . db . migration . avro . RenameColumnFamily rcf = new org . apache . cassandra . db . migration . avro . RenameColumnFamily ( ) ; rcf . ksname = new org . apache . avro . util . Utf8 ( tableName ) ; rcf . cfid = cfId ; rcf . old_cfname = new org . apache . avro . util . Utf8 ( oldName ) ; rcf . new_cfname = new org . apache . avro . util . Utf8 ( newName ) ; mi . migration = rcf ; }
sunsuk7tp/MyCassandra | public void subinflate ( org . apache . cassandra . db . migration . avro . Migration mi ) { org . apache . cassandra . db . migration . avro . RenameColumnFamily rcf = ( org . apache . cassandra . db . migration . avro . RenameColumnFamily ) mi . migration ; tableName = rcf . ksname . toString ( ) ; cfId = rcf . cfid ; oldName = rcf . old_cfname . toString ( ) ; newName = rcf . new_cfname . toString ( ) ; }
sunsuk7tp/MyCassandra | @ Override public String toString ( ) { return String . format ( " Rename ▁ column ▁ family ▁ ( % d ) ▁ % s . % s ▁ to ▁ % s . % s " , cfId , tableName , oldName , tableName , newName ) ; }
jbonofre/beam | @ ProcessElement public void processElement ( ProcessContext context , BoundedWindow window ) { context . output ( " MainOutput " + context . element ( ) ) ; context . output ( additionalOutput , " AdditionalOutput " + context . element ( ) ) ; this . window = window ; }
jbonofre/beam | @ FinishBundle public void finishBundle ( FinishBundleContext context ) { if ( window != null ) { context . output ( " FinishBundle " , window . maxTimestamp ( ) , window ) ; window = null ; } }
jbonofre/beam | @ Test public void testCreatingAndProcessingDoFn ( ) throws Exception { String pTransformId = " pTransformId " ; String mainOutputId = "101" ; String additionalOutputId = "102" ; DoFnInfo < ? , ? > doFnInfo = DoFnInfo . forFn ( new TestDoFn ( ) , WindowingStrategy . globalDefault ( ) , ImmutableList . of ( ) , StringUtf8Coder . of ( ) , Long . parseLong ( mainOutputId ) , ImmutableMap . of ( Long . parseLong ( mainOutputId ) , TestDoFn . mainOutput , Long . parseLong ( additionalOutputId ) , TestDoFn . additionalOutput ) ) ; RunnerApi . FunctionSpec functionSpec = RunnerApi . FunctionSpec . newBuilder ( ) . setUrn ( ParDoTranslation . CUSTOM_JAVA_DO_FN_URN ) . setPayload ( ByteString . copyFrom ( SerializableUtils . serializeToByteArray ( doFnInfo ) ) ) . build ( ) ; RunnerApi . PTransform pTransform = RunnerApi . PTransform . newBuilder ( ) . setSpec ( functionSpec ) . putInputs ( " inputA " , " inputATarget " ) . putInputs ( " inputB " , " inputBTarget " ) . putOutputs ( mainOutputId , " mainOutputTarget " ) . putOutputs ( additionalOutputId , " additionalOutputTarget " ) . build ( ) ; List < WindowedValue < String > > mainOutputValues = new ArrayList < > ( ) ; List < WindowedValue < String > > additionalOutputValues = new ArrayList < > ( ) ; Multimap < String , FnDataReceiver < WindowedValue < ? > > > consumers = HashMultimap . create ( ) ; consumers . put ( " mainOutputTarget " , ( FnDataReceiver ) ( FnDataReceiver < WindowedValue < String > > ) mainOutputValues :: add ) ; consumers . put ( " additionalOutputTarget " , ( FnDataReceiver ) ( FnDataReceiver < WindowedValue < String > > ) additionalOutputValues :: add ) ; List < ThrowingRunnable > startFunctions = new ArrayList < > ( ) ; List < ThrowingRunnable > finishFunctions = new ArrayList < > ( ) ; new FnApiDoFnRunner . Factory < > ( ) . createRunnerForPTransform ( PipelineOptionsFactory . create ( ) , null , null , pTransformId , pTransform , Suppliers . ofInstance ( "57L " ) :: get , Collections . emptyMap ( ) , Collections . emptyMap ( ) , Collections . emptyMap ( ) , consumers , startFunctions :: add , finishFunctions :: add ) ; Iterables . getOnlyElement ( startFunctions ) . run ( ) ; mainOutputValues . clear ( ) ; assertThat ( consumers . keySet ( ) , containsInAnyOrder ( " inputATarget " , " inputBTarget " , " mainOutputTarget " , " additionalOutputTarget " ) ) ; Iterables . getOnlyElement ( consumers . get ( " inputATarget " ) ) . accept ( valueInGlobalWindow ( " A1" ) ) ; Iterables . getOnlyElement ( consumers . get ( " inputATarget " ) ) . accept ( valueInGlobalWindow ( " A2" ) ) ; Iterables . getOnlyElement ( consumers . get ( " inputBTarget " ) ) . accept ( valueInGlobalWindow ( " B " ) ) ; assertThat ( mainOutputValues , contains ( valueInGlobalWindow ( " MainOutputA1" ) , valueInGlobalWindow ( " MainOutputA2" ) , valueInGlobalWindow ( " MainOutputB " ) ) ) ; assertThat ( additionalOutputValues , contains ( valueInGlobalWindow ( " AdditionalOutputA1" ) , valueInGlobalWindow ( " AdditionalOutputA2" ) , valueInGlobalWindow ( " AdditionalOutputB " ) ) ) ; mainOutputValues . clear ( ) ; additionalOutputValues . clear ( ) ; Iterables . getOnlyElement ( finishFunctions ) . run ( ) ; assertThat ( mainOutputValues , contains ( timestampedValueInGlobalWindow ( " FinishBundle " , GlobalWindow . INSTANCE . maxTimestamp ( ) ) ) ) ; mainOutputValues . clear ( ) ; }
jbonofre/beam | @ Override public String createAccumulator ( ) { return " " ; }
jbonofre/beam | @ Override public String addInput ( String accumulator , String input ) { return accumulator . concat ( input ) ; }
jbonofre/beam | @ Override public String mergeAccumulators ( Iterable < String > accumulators ) { StringBuilder builder = new StringBuilder ( ) ; for ( String value : accumulators ) { builder . append ( value ) ; } return builder . toString ( ) ; }
jbonofre/beam | @ Override public String extractOutput ( String accumulator ) { return accumulator ; }
jbonofre/beam | @ Override public String createAccumulator ( Context c ) { return " " ; }
jbonofre/beam | @ Override public String addInput ( String accumulator , String input , Context c ) { return accumulator . concat ( input ) ; }
jbonofre/beam | @ Override public String mergeAccumulators ( Iterable < String > accumulators , Context c ) { StringBuilder builder = new StringBuilder ( ) ; for ( String value : accumulators ) { builder . append ( value ) ; } return builder . toString ( ) ; }
jbonofre/beam | @ Override public String extractOutput ( String accumulator , Context c ) { return accumulator ; }
jbonofre/beam | @ ProcessElement public void processElement ( ProcessContext context , @ StateId ( " value " ) ValueState < String > valueState , @ StateId ( " bag " ) BagState < String > bagState , @ StateId ( " combine " ) CombiningState < String , String , String > combiningState , @ StateId ( " combineWithContext " ) CombiningState < String , String , String > combiningWithContextState ) { context . output ( " value : " + valueState . read ( ) ) ; valueState . write ( context . element ( ) . getValue ( ) ) ; context . output ( " bag : " + Iterables . toString ( bagState . read ( ) ) ) ; bagState . add ( context . element ( ) . getValue ( ) ) ; context . output ( " combine : " + combiningState . read ( ) ) ; combiningState . add ( context . element ( ) . getValue ( ) ) ; context . output ( " combineWithContext : " + combiningWithContextState . read ( ) ) ; combiningWithContextState . add ( context . element ( ) . getValue ( ) ) ; }
jbonofre/beam | @ Test public void testUsingUserState ( ) throws Exception { String mainOutputId = "101" ; DoFnInfo < ? , ? > doFnInfo = DoFnInfo . forFn ( new TestStatefulDoFn ( ) , WindowingStrategy . globalDefault ( ) , ImmutableList . of ( ) , KvCoder . of ( StringUtf8Coder . of ( ) , StringUtf8Coder . of ( ) ) , Long . parseLong ( mainOutputId ) , ImmutableMap . of ( Long . parseLong ( mainOutputId ) , new TupleTag < String > ( " mainOutput " ) ) ) ; RunnerApi . FunctionSpec functionSpec = RunnerApi . FunctionSpec . newBuilder ( ) . setUrn ( ParDoTranslation . CUSTOM_JAVA_DO_FN_URN ) . setPayload ( ByteString . copyFrom ( SerializableUtils . serializeToByteArray ( doFnInfo ) ) ) . build ( ) ; RunnerApi . PTransform pTransform = RunnerApi . PTransform . newBuilder ( ) . setSpec ( functionSpec ) . putInputs ( " input " , " inputTarget " ) . putOutputs ( mainOutputId , " mainOutputTarget " ) . build ( ) ; FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient ( ImmutableMap . of ( key ( " value " , " X " ) , encode ( " X0" ) , key ( " bag " , " X " ) , encode ( " X0" ) , key ( " combine " , " X " ) , encode ( " X0" ) , key ( " combineWithContext " , " X " ) , encode ( " X0" ) ) ) ; List < WindowedValue < String > > mainOutputValues = new ArrayList < > ( ) ; Multimap < String , FnDataReceiver < WindowedValue < ? > > > consumers = HashMultimap . create ( ) ; consumers . put ( " mainOutputTarget " , ( FnDataReceiver ) ( FnDataReceiver < WindowedValue < String > > ) mainOutputValues :: add ) ; List < ThrowingRunnable > startFunctions = new ArrayList < > ( ) ; List < ThrowingRunnable > finishFunctions = new ArrayList < > ( ) ; new FnApiDoFnRunner . Factory < > ( ) . createRunnerForPTransform ( PipelineOptionsFactory . create ( ) , null , fakeClient , TEST_PTRANSFORM_ID , pTransform , Suppliers . ofInstance ( "57L " ) :: get , Collections . emptyMap ( ) , Collections . emptyMap ( ) , Collections . emptyMap ( ) , consumers , startFunctions :: add , finishFunctions :: add ) ; Iterables . getOnlyElement ( startFunctions ) . run ( ) ; mainOutputValues . clear ( ) ; assertThat ( consumers . keySet ( ) , containsInAnyOrder ( " inputTarget " , " mainOutputTarget " ) ) ; FnDataReceiver < WindowedValue < ? > > mainInput = Iterables . getOnlyElement ( consumers . get ( " inputTarget " ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " X " , " X1" ) ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " Y " , " Y1" ) ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " X " , " X2" ) ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " Y " , " Y2" ) ) ) ; assertThat ( mainOutputValues , contains ( valueInGlobalWindow ( " value : X0" ) , valueInGlobalWindow ( " bag : [ X0 ] " ) , valueInGlobalWindow ( " combine : X0" ) , valueInGlobalWindow ( " combineWithContext : X0" ) , valueInGlobalWindow ( " value : null " ) , valueInGlobalWindow ( " bag : [ ] " ) , valueInGlobalWindow ( " combine : " ) , valueInGlobalWindow ( " combineWithContext : " ) , valueInGlobalWindow ( " value : X1" ) , valueInGlobalWindow ( " bag : [ X0 , ▁ X1 ] " ) , valueInGlobalWindow ( " combine : X0X1" ) , valueInGlobalWindow ( " combineWithContext : X0X1" ) , valueInGlobalWindow ( " value : Y1" ) , valueInGlobalWindow ( " bag : [ Y1 ] " ) , valueInGlobalWindow ( " combine : Y1" ) , valueInGlobalWindow ( " combineWithContext : Y1" ) ) ) ; mainOutputValues . clear ( ) ; Iterables . getOnlyElement ( finishFunctions ) . run ( ) ; assertThat ( mainOutputValues , empty ( ) ) ; assertEquals ( ImmutableMap . < StateKey , ByteString > builder ( ) . put ( key ( " value " , " X " ) , encode ( " X2" ) ) . put ( key ( " bag " , " X " ) , encode ( " X0" , " X1" , " X2" ) ) . put ( key ( " combine " , " X " ) , encode ( " X0X1X2" ) ) . put ( key ( " combineWithContext " , " X " ) , encode ( " X0X1X2" ) ) . put ( key ( " value " , " Y " ) , encode ( " Y2" ) ) . put ( key ( " bag " , " Y " ) , encode ( " Y1" , " Y2" ) ) . put ( key ( " combine " , " Y " ) , encode ( " Y1Y2" ) ) . put ( key ( " combineWithContext " , " Y " ) , encode ( " Y1Y2" ) ) . build ( ) , fakeClient . getData ( ) ) ; mainOutputValues . clear ( ) ; }
jbonofre/beam | private StateKey key ( String userStateId , String key ) throws IOException { return StateKey . newBuilder ( ) . setBagUserState ( StateKey . BagUserState . newBuilder ( ) . setPtransformId ( TEST_PTRANSFORM_ID ) . setUserStateId ( userStateId ) . setKey ( encode ( key ) ) . setWindow ( ByteString . copyFrom ( CoderUtils . encodeToByteArray ( GlobalWindow . Coder . INSTANCE , GlobalWindow . INSTANCE ) ) ) ) . build ( ) ; }
jbonofre/beam | private ByteString encode ( String ... values ) throws IOException { ByteString . Output out = ByteString . newOutput ( ) ; for ( String value : values ) { StringUtf8Coder . of ( ) . encode ( value , out ) ; } return out . toByteString ( ) ; }
jbonofre/beam | @ Test public void testRegistration ( ) { for ( Registrar registrar : ServiceLoader . load ( Registrar . class ) ) { if ( registrar instanceof FnApiDoFnRunner . Registrar ) { assertThat ( registrar . getPTransformRunnerFactories ( ) , IsMapContaining . hasKey ( ParDoTranslation . CUSTOM_JAVA_DO_FN_URN ) ) ; return ; } } fail ( " Expected ▁ registrar ▁ not ▁ found . " ) ; }
aws/aws-sdk-java | public void setPredictorArn ( String predictorArn ) { this . predictorArn = predictorArn ; }
aws/aws-sdk-java | public String getPredictorArn ( ) { return this . predictorArn ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withPredictorArn ( String predictorArn ) { setPredictorArn ( predictorArn ) ; return this ; }
aws/aws-sdk-java | public void setPredictorName ( String predictorName ) { this . predictorName = predictorName ; }
aws/aws-sdk-java | public String getPredictorName ( ) { return this . predictorName ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withPredictorName ( String predictorName ) { setPredictorName ( predictorName ) ; return this ; }
aws/aws-sdk-java | public void setForecastHorizon ( Integer forecastHorizon ) { this . forecastHorizon = forecastHorizon ; }
aws/aws-sdk-java | public Integer getForecastHorizon ( ) { return this . forecastHorizon ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastHorizon ( Integer forecastHorizon ) { setForecastHorizon ( forecastHorizon ) ; return this ; }
aws/aws-sdk-java | public java . util . List < String > getForecastTypes ( ) { return forecastTypes ; }
aws/aws-sdk-java | public void setForecastTypes ( java . util . Collection < String > forecastTypes ) { if ( forecastTypes == null ) { this . forecastTypes = null ; return ; } this . forecastTypes = new java . util . ArrayList < String > ( forecastTypes ) ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastTypes ( String ... forecastTypes ) { if ( this . forecastTypes == null ) { setForecastTypes ( new java . util . ArrayList < String > ( forecastTypes . length ) ) ; } for ( String ele : forecastTypes ) { this . forecastTypes . add ( ele ) ; } return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastTypes ( java . util . Collection < String > forecastTypes ) { setForecastTypes ( forecastTypes ) ; return this ; }
aws/aws-sdk-java | public void setForecastFrequency ( String forecastFrequency ) { this . forecastFrequency = forecastFrequency ; }
aws/aws-sdk-java | public String getForecastFrequency ( ) { return this . forecastFrequency ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastFrequency ( String forecastFrequency ) { setForecastFrequency ( forecastFrequency ) ; return this ; }
aws/aws-sdk-java | public java . util . List < String > getForecastDimensions ( ) { return forecastDimensions ; }
aws/aws-sdk-java | public void setForecastDimensions ( java . util . Collection < String > forecastDimensions ) { if ( forecastDimensions == null ) { this . forecastDimensions = null ; return ; } this . forecastDimensions = new java . util . ArrayList < String > ( forecastDimensions ) ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastDimensions ( String ... forecastDimensions ) { if ( this . forecastDimensions == null ) { setForecastDimensions ( new java . util . ArrayList < String > ( forecastDimensions . length ) ) ; } for ( String ele : forecastDimensions ) { this . forecastDimensions . add ( ele ) ; } return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastDimensions ( java . util . Collection < String > forecastDimensions ) { setForecastDimensions ( forecastDimensions ) ; return this ; }
aws/aws-sdk-java | public java . util . List < String > getDatasetImportJobArns ( ) { return datasetImportJobArns ; }
aws/aws-sdk-java | public void setDatasetImportJobArns ( java . util . Collection < String > datasetImportJobArns ) { if ( datasetImportJobArns == null ) { this . datasetImportJobArns = null ; return ; } this . datasetImportJobArns = new java . util . ArrayList < String > ( datasetImportJobArns ) ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withDatasetImportJobArns ( String ... datasetImportJobArns ) { if ( this . datasetImportJobArns == null ) { setDatasetImportJobArns ( new java . util . ArrayList < String > ( datasetImportJobArns . length ) ) ; } for ( String ele : datasetImportJobArns ) { this . datasetImportJobArns . add ( ele ) ; } return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withDatasetImportJobArns ( java . util . Collection < String > datasetImportJobArns ) { setDatasetImportJobArns ( datasetImportJobArns ) ; return this ; }
aws/aws-sdk-java | public void setDataConfig ( DataConfig dataConfig ) { this . dataConfig = dataConfig ; }
aws/aws-sdk-java | public DataConfig getDataConfig ( ) { return this . dataConfig ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withDataConfig ( DataConfig dataConfig ) { setDataConfig ( dataConfig ) ; return this ; }
aws/aws-sdk-java | public void setEncryptionConfig ( EncryptionConfig encryptionConfig ) { this . encryptionConfig = encryptionConfig ; }
aws/aws-sdk-java | public EncryptionConfig getEncryptionConfig ( ) { return this . encryptionConfig ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withEncryptionConfig ( EncryptionConfig encryptionConfig ) { setEncryptionConfig ( encryptionConfig ) ; return this ; }
aws/aws-sdk-java | public void setReferencePredictorSummary ( ReferencePredictorSummary referencePredictorSummary ) { this . referencePredictorSummary = referencePredictorSummary ; }
aws/aws-sdk-java | public ReferencePredictorSummary getReferencePredictorSummary ( ) { return this . referencePredictorSummary ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withReferencePredictorSummary ( ReferencePredictorSummary referencePredictorSummary ) { setReferencePredictorSummary ( referencePredictorSummary ) ; return this ; }
aws/aws-sdk-java | public void setEstimatedTimeRemainingInMinutes ( Long estimatedTimeRemainingInMinutes ) { this . estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes ; }
aws/aws-sdk-java | public Long getEstimatedTimeRemainingInMinutes ( ) { return this . estimatedTimeRemainingInMinutes ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withEstimatedTimeRemainingInMinutes ( Long estimatedTimeRemainingInMinutes ) { setEstimatedTimeRemainingInMinutes ( estimatedTimeRemainingInMinutes ) ; return this ; }
aws/aws-sdk-java | public void setStatus ( String status ) { this . status = status ; }
aws/aws-sdk-java | public String getStatus ( ) { return this . status ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withStatus ( String status ) { setStatus ( status ) ; return this ; }
aws/aws-sdk-java | public void setMessage ( String message ) { this . message = message ; }
aws/aws-sdk-java | public String getMessage ( ) { return this . message ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withMessage ( String message ) { setMessage ( message ) ; return this ; }
aws/aws-sdk-java | public void setCreationTime ( java . util . Date creationTime ) { this . creationTime = creationTime ; }
aws/aws-sdk-java | public java . util . Date getCreationTime ( ) { return this . creationTime ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withCreationTime ( java . util . Date creationTime ) { setCreationTime ( creationTime ) ; return this ; }
aws/aws-sdk-java | public void setLastModificationTime ( java . util . Date lastModificationTime ) { this . lastModificationTime = lastModificationTime ; }
aws/aws-sdk-java | public java . util . Date getLastModificationTime ( ) { return this . lastModificationTime ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withLastModificationTime ( java . util . Date lastModificationTime ) { setLastModificationTime ( lastModificationTime ) ; return this ; }
aws/aws-sdk-java | public void setOptimizationMetric ( String optimizationMetric ) { this . optimizationMetric = optimizationMetric ; }
aws/aws-sdk-java | public String getOptimizationMetric ( ) { return this . optimizationMetric ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withOptimizationMetric ( String optimizationMetric ) { setOptimizationMetric ( optimizationMetric ) ; return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withOptimizationMetric ( OptimizationMetric optimizationMetric ) { this . optimizationMetric = optimizationMetric . toString ( ) ; return this ; }
aws/aws-sdk-java | public void setExplainabilityInfo ( ExplainabilityInfo explainabilityInfo ) { this . explainabilityInfo = explainabilityInfo ; }
aws/aws-sdk-java | public ExplainabilityInfo getExplainabilityInfo ( ) { return this . explainabilityInfo ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withExplainabilityInfo ( ExplainabilityInfo explainabilityInfo ) { setExplainabilityInfo ( explainabilityInfo ) ; return this ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getPredictorArn ( ) != null ) sb . append ( " PredictorArn : ▁ " ) . append ( getPredictorArn ( ) ) . append ( " , " ) ; if ( getPredictorName ( ) != null ) sb . append ( " PredictorName : ▁ " ) . append ( getPredictorName ( ) ) . append ( " , " ) ; if ( getForecastHorizon ( ) != null ) sb . append ( " ForecastHorizon : ▁ " ) . append ( getForecastHorizon ( ) ) . append ( " , " ) ; if ( getForecastTypes ( ) != null ) sb . append ( " ForecastTypes : ▁ " ) . append ( getForecastTypes ( ) ) . append ( " , " ) ; if ( getForecastFrequency ( ) != null ) sb . append ( " ForecastFrequency : ▁ " ) . append ( getForecastFrequency ( ) ) . append ( " , " ) ; if ( getForecastDimensions ( ) != null ) sb . append ( " ForecastDimensions : ▁ " ) . append ( getForecastDimensions ( ) ) . append ( " , " ) ; if ( getDatasetImportJobArns ( ) != null ) sb . append ( " DatasetImportJobArns : ▁ " ) . append ( getDatasetImportJobArns ( ) ) . append ( " , " ) ; if ( getDataConfig ( ) != null ) sb . append ( " DataConfig : ▁ " ) . append ( getDataConfig ( ) ) . append ( " , " ) ; if ( getEncryptionConfig ( ) != null ) sb . append ( " EncryptionConfig : ▁ " ) . append ( getEncryptionConfig ( ) ) . append ( " , " ) ; if ( getReferencePredictorSummary ( ) != null ) sb . append ( " ReferencePredictorSummary : ▁ " ) . append ( getReferencePredictorSummary ( ) ) . append ( " , " ) ; if ( getEstimatedTimeRemainingInMinutes ( ) != null ) sb . append ( " EstimatedTimeRemainingInMinutes : ▁ " ) . append ( getEstimatedTimeRemainingInMinutes ( ) ) . append ( " , " ) ; if ( getStatus ( ) != null ) sb . append ( " Status : ▁ " ) . append ( getStatus ( ) ) . append ( " , " ) ; if ( getMessage ( ) != null ) sb . append ( " Message : ▁ " ) . append ( getMessage ( ) ) . append ( " , " ) ; if ( getCreationTime ( ) != null ) sb . append ( " CreationTime : ▁ " ) . append ( getCreationTime ( ) ) . append ( " , " ) ; if ( getLastModificationTime ( ) != null ) sb . append ( " LastModificationTime : ▁ " ) . append ( getLastModificationTime ( ) ) . append ( " , " ) ; if ( getOptimizationMetric ( ) != null ) sb . append ( " OptimizationMetric : ▁ " ) . append ( getOptimizationMetric ( ) ) . append ( " , " ) ; if ( getExplainabilityInfo ( ) != null ) sb . append ( " ExplainabilityInfo : ▁ " ) . append ( getExplainabilityInfo ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeAutoPredictorResult == false ) return false ; DescribeAutoPredictorResult other = ( DescribeAutoPredictorResult ) obj ; if ( other . getPredictorArn ( ) == null ^ this . getPredictorArn ( ) == null ) return false ; if ( other . getPredictorArn ( ) != null && other . getPredictorArn ( ) . equals ( this . getPredictorArn ( ) ) == false ) return false ; if ( other . getPredictorName ( ) == null ^ this . getPredictorName ( ) == null ) return false ; if ( other . getPredictorName ( ) != null && other . getPredictorName ( ) . equals ( this . getPredictorName ( ) ) == false ) return false ; if ( other . getForecastHorizon ( ) == null ^ this . getForecastHorizon ( ) == null ) return false ; if ( other . getForecastHorizon ( ) != null && other . getForecastHorizon ( ) . equals ( this . getForecastHorizon ( ) ) == false ) return false ; if ( other . getForecastTypes ( ) == null ^ this . getForecastTypes ( ) == null ) return false ; if ( other . getForecastTypes ( ) != null && other . getForecastTypes ( ) . equals ( this . getForecastTypes ( ) ) == false ) return false ; if ( other . getForecastFrequency ( ) == null ^ this . getForecastFrequency ( ) == null ) return false ; if ( other . getForecastFrequency ( ) != null && other . getForecastFrequency ( ) . equals ( this . getForecastFrequency ( ) ) == false ) return false ; if ( other . getForecastDimensions ( ) == null ^ this . getForecastDimensions ( ) == null ) return false ; if ( other . getForecastDimensions ( ) != null && other . getForecastDimensions ( ) . equals ( this . getForecastDimensions ( ) ) == false ) return false ; if ( other . getDatasetImportJobArns ( ) == null ^ this . getDatasetImportJobArns ( ) == null ) return false ; if ( other . getDatasetImportJobArns ( ) != null && other . getDatasetImportJobArns ( ) . equals ( this . getDatasetImportJobArns ( ) ) == false ) return false ; if ( other . getDataConfig ( ) == null ^ this . getDataConfig ( ) == null ) return false ; if ( other . getDataConfig ( ) != null && other . getDataConfig ( ) . equals ( this . getDataConfig ( ) ) == false ) return false ; if ( other . getEncryptionConfig ( ) == null ^ this . getEncryptionConfig ( ) == null ) return false ; if ( other . getEncryptionConfig ( ) != null && other . getEncryptionConfig ( ) . equals ( this . getEncryptionConfig ( ) ) == false ) return false ; if ( other . getReferencePredictorSummary ( ) == null ^ this . getReferencePredictorSummary ( ) == null ) return false ; if ( other . getReferencePredictorSummary ( ) != null && other . getReferencePredictorSummary ( ) . equals ( this . getReferencePredictorSummary ( ) ) == false ) return false ; if ( other . getEstimatedTimeRemainingInMinutes ( ) == null ^ this . getEstimatedTimeRemainingInMinutes ( ) == null ) return false ; if ( other . getEstimatedTimeRemainingInMinutes ( ) != null && other . getEstimatedTimeRemainingInMinutes ( ) . equals ( this . getEstimatedTimeRemainingInMinutes ( ) ) == false ) return false ; if ( other . getStatus ( ) == null ^ this . getStatus ( ) == null ) return false ; if ( other . getStatus ( ) != null && other . getStatus ( ) . equals ( this . getStatus ( ) ) == false ) return false ; if ( other . getMessage ( ) == null ^ this . getMessage ( ) == null ) return false ; if ( other . getMessage ( ) != null && other . getMessage ( ) . equals ( this . getMessage ( ) ) == false ) return false ; if ( other . getCreationTime ( ) == null ^ this . getCreationTime ( ) == null ) return false ; if ( other . getCreationTime ( ) != null && other . getCreationTime ( ) . equals ( this . getCreationTime ( ) ) == false ) return false ; if ( other . getLastModificationTime ( ) == null ^ this . getLastModificationTime ( ) == null ) return false ; if ( other . getLastModificationTime ( ) != null && other . getLastModificationTime ( ) . equals ( this . getLastModificationTime ( ) ) == false ) return false ; if ( other . getOptimizationMetric ( ) == null ^ this . getOptimizationMetric ( ) == null ) return false ; if ( other . getOptimizationMetric ( ) != null && other . getOptimizationMetric ( ) . equals ( this . getOptimizationMetric ( ) ) == false ) return false ; if ( other . getExplainabilityInfo ( ) == null ^ this . getExplainabilityInfo ( ) == null ) return false ; if ( other . getExplainabilityInfo ( ) != null && other . getExplainabilityInfo ( ) . equals ( this . getExplainabilityInfo ( ) ) == false ) return false ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getPredictorArn ( ) == null ) ? 0 : getPredictorArn ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getPredictorName ( ) == null ) ? 0 : getPredictorName ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastHorizon ( ) == null ) ? 0 : getForecastHorizon ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastTypes ( ) == null ) ? 0 : getForecastTypes ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastFrequency ( ) == null ) ? 0 : getForecastFrequency ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastDimensions ( ) == null ) ? 0 : getForecastDimensions ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getDatasetImportJobArns ( ) == null ) ? 0 : getDatasetImportJobArns ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getDataConfig ( ) == null ) ? 0 : getDataConfig ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getEncryptionConfig ( ) == null ) ? 0 : getEncryptionConfig ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getReferencePredictorSummary ( ) == null ) ? 0 : getReferencePredictorSummary ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getEstimatedTimeRemainingInMinutes ( ) == null ) ? 0 : getEstimatedTimeRemainingInMinutes ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getStatus ( ) == null ) ? 0 : getStatus ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMessage ( ) == null ) ? 0 : getMessage ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getCreationTime ( ) == null ) ? 0 : getCreationTime ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getLastModificationTime ( ) == null ) ? 0 : getLastModificationTime ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getOptimizationMetric ( ) == null ) ? 0 : getOptimizationMetric ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getExplainabilityInfo ( ) == null ) ? 0 : getExplainabilityInfo ( ) . hashCode ( ) ) ; return hashCode ; }
aws/aws-sdk-java | @ Override public DescribeAutoPredictorResult clone ( ) { try { return ( DescribeAutoPredictorResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
deeplearning4j/nd4j-benchmark | public MaxOpRunner ( ) { Nd4j . factory ( ) . setOrder ( ' c ' ) ; arr = Nd4j . create ( 12000 , 12000 ) ; }
deeplearning4j/nd4j-benchmark | @ Override public void runOp ( ) { arr . sum ( 1 ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testConnectWithId ( ) { GridConnection < GridNode > connection = new LocalGridNodeConnection ( " test - id " ) ; GridNode gnode = connection . connect ( ) ; assertNotNull ( gnode ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testConnectWithGivenGridNode ( ) { GridNode gnode = new GridNodeImpl ( ) ; GridConnection < GridNode > connection = new LocalGridNodeConnection ( gnode ) ; assertSame ( gnode , connection . connect ( ) ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testGetFactoryService ( ) { GridConnection < GridNode > connection = new LocalGridNodeConnection ( " test - id " ) ; GridNode gnode = connection . connect ( ) ; KnowledgeBuilderFactoryService kbfService = gnode . get ( KnowledgeBuilderFactoryService . class ) ; assertNotNull ( kbfService ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testSetObject ( ) { GridConnection < GridNode > connection = new LocalGridNodeConnection ( " test - id " ) ; GridNode gnode = connection . connect ( ) ; KnowledgeBaseFactoryService kbfService = gnode . get ( KnowledgeBaseFactoryService . class ) ; KnowledgeBase kbase = kbfService . newKnowledgeBase ( ) ; gnode . set ( " id1" , kbase ) ; assertSame ( kbase , gnode . get ( " id1" , KnowledgeBase . class ) ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testNodeCreationAndWhitePagesRegistration ( ) { Grid grid = new GridImpl ( new HashMap < String , Object > ( ) ) ; GridPeerConfiguration conf = new GridPeerConfiguration ( ) ; GridPeerServiceConfiguration wplConf = new WhitePagesLocalConfiguration ( ) ; conf . addConfiguration ( wplConf ) ; conf . configure ( grid ) ; GridNode gnode = grid . createGridNode ( " test1 @ local " ) ; WhitePages pages = grid . get ( WhitePages . class ) ; GridServiceDescription < GridNode > gsd = pages . create ( " test1 @ local " ) ; GridServiceDescription < GridNode > serviceDescription = pages . lookup ( " test1 @ local " ) ; GridConnection connection = grid . get ( ConnectionFactoryService . class ) . createConnection ( gsd ) ; assertSame ( gnode , connection . connect ( ) ) ; }
mariofusco/droolsjbpm-integration | private InetAddress getLocalAddress ( ) { try { return InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( " Unable ▁ to ▁ lookup ▁ local ▁ address " , e ) ; } }
bobmcwhirter/drools | public SubProcessParameterOutMappingCellEditor ( Composite parent , SubProcessNode subProcessNode ) { super ( parent ) ; this . subProcessNode = subProcessNode ; }
bobmcwhirter/drools | protected EditBeanDialog createDialog ( Shell shell ) { return new SubProcessParameterOutMappingDialog ( shell , subProcessNode ) ; }
bobmcwhirter/drools | protected String getLabelText ( Object value ) { return " " ; }
WilliamRen/bbossgroups-3.5 | public final void setUnless ( String value ) throws JspException { if ( ! ( value == null || CURRENT . equals ( value ) || INDEXED . equals ( value ) ) ) { throw new JspTagException ( " value ▁ for ▁ attribute ▁ \" unless \" ▁ " + " must ▁ be ▁ either ▁ \" current \" ▁ or ▁ \" indexed \" . " ) ; } unless = value ; }
WilliamRen/bbossgroups-3.5 | public final String getUnless ( ) { return unless ; }
WilliamRen/bbossgroups-3.5 | public int doStartTag ( ) throws JspException { super . doStartTag ( ) ; long jumpPage = getJumpPage ( ) ; if ( CURRENT . equals ( unless ) ) { if ( jumpPage == this . pagerContext . getPageNumber ( ) ) return SKIP_BODY ; } else if ( INDEXED . equals ( unless ) ) { long firstPage = pagerContext . getFirstIndexPage ( ) ; long lastPage = pagerContext . getLastIndexPage ( firstPage ) ; if ( jumpPage >= firstPage && jumpPage <= lastPage ) return SKIP_BODY ; } setPageAttributes ( jumpPage ) ; return EVAL_BODY_INCLUDE ; }
WilliamRen/bbossgroups-3.5 | public void release ( ) { unless = null ; super . release ( ) ; }
navalev/azure-sdk-for-java | public String databaseName ( ) { return this . databaseName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withDatabaseName ( String databaseName ) { this . databaseName = databaseName ; return this ; }
navalev/azure-sdk-for-java | public String id ( ) { return this . id ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withId ( String id ) { this . id = id ; return this ; }
navalev/azure-sdk-for-java | public String logicalName ( ) { return this . logicalName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withLogicalName ( String logicalName ) { this . logicalName = logicalName ; return this ; }
navalev/azure-sdk-for-java | public String physicalFullName ( ) { return this . physicalFullName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withPhysicalFullName ( String physicalFullName ) { this . physicalFullName = physicalFullName ; return this ; }
navalev/azure-sdk-for-java | public String restoreFullName ( ) { return this . restoreFullName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withRestoreFullName ( String restoreFullName ) { this . restoreFullName = restoreFullName ; return this ; }
navalev/azure-sdk-for-java | public DatabaseFileType fileType ( ) { return this . fileType ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withFileType ( DatabaseFileType fileType ) { this . fileType = fileType ; return this ; }
navalev/azure-sdk-for-java | public Double sizeMB ( ) { return this . sizeMB ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withSizeMB ( Double sizeMB ) { this . sizeMB = sizeMB ; return this ; }
allotria/intellij-community | private VirtualEnvSdkFlavor ( ) { }
allotria/intellij-community | @ Override public boolean isPlatformIndependent ( ) { return true ; }
allotria/intellij-community | @ NotNull @ Override public Collection < String > suggestHomePaths ( @ Nullable Module module , @ Nullable UserDataHolder context ) { return ReadAction . compute ( ( ) -> { final List < String > candidates = new ArrayList < > ( ) ; if ( module != null ) { VirtualFile baseDir = BasePySdkExtKt . getBaseDir ( module ) ; if ( baseDir == null && context != null && context . getUserData ( PySdkExtKt . getBASE_DIR ( ) ) != null ) { baseDir = VfsUtil . findFile ( context . getUserData ( PySdkExtKt . getBASE_DIR ( ) ) , false ) ; } if ( baseDir != null ) { candidates . addAll ( findInBaseDirectory ( baseDir ) ) ; } } final VirtualFile path = getDefaultLocation ( ) ; if ( path != null ) { candidates . addAll ( findInBaseDirectory ( path ) ) ; } final VirtualFile pyEnvLocation = getPyEnvDefaultLocations ( ) ; if ( pyEnvLocation != null ) { candidates . addAll ( findInBaseDirectory ( pyEnvLocation ) ) ; } return candidates ; } ) ; }
allotria/intellij-community | @ Override public boolean isValidSdkPath ( @ NotNull File file ) { if ( ! super . isValidSdkPath ( file ) ) return false ; return PythonSdkUtil . getVirtualEnvRoot ( file . getPath ( ) ) != null ; }
allotria/intellij-community | @ Override public Icon getIcon ( ) { return PythonIcons . Python . Virtualenv ; }
V2GClarity/RISE-V2G | public WaitForChargingStatusReq ( V2GCommunicationSessionSECC commSessionContext ) { super ( commSessionContext ) ; chargingStatusRes = new ChargingStatusResType ( ) ; }
V2GClarity/RISE-V2G | @ Override public ReactionToIncomingMessage processIncomingMessage ( Object message ) { if ( isIncomingMessageValid ( message , ChargingStatusReqType . class , chargingStatusRes ) ) { chargingStatusRes . setEVSEID ( getCommSessionContext ( ) . getACEvseController ( ) . getEvseID ( ) ) ; chargingStatusRes . setSAScheduleTupleID ( getCommSessionContext ( ) . getChosenSAScheduleTuple ( ) ) ; chargingStatusRes . setACEVSEStatus ( getCommSessionContext ( ) . getACEvseController ( ) . getACEVSEStatus ( EVSENotificationType . NONE ) ) ; if ( getCommSessionContext ( ) . getSelectedPaymentOption ( ) . equals ( PaymentOptionType . EXTERNAL_PAYMENT ) ) { chargingStatusRes . setReceiptRequired ( false ) ; } else { chargingStatusRes . setReceiptRequired ( false ) ; } MeterInfoType meterInfo = getCommSessionContext ( ) . getACEvseController ( ) . getMeterInfo ( ) ; chargingStatusRes . setMeterInfo ( meterInfo ) ; getCommSessionContext ( ) . setSentMeterInfo ( meterInfo ) ; if ( chargingStatusRes . isReceiptRequired ( ) ) { return getSendMessage ( chargingStatusRes , V2GMessages . METERING_RECEIPT_REQ ) ; } else { ( ( ForkState ) getCommSessionContext ( ) . getStates ( ) . get ( V2GMessages . FORK ) ) . getAllowedRequests ( ) . add ( V2GMessages . CHARGING_STATUS_REQ ) ; ( ( ForkState ) getCommSessionContext ( ) . getStates ( ) . get ( V2GMessages . FORK ) ) . getAllowedRequests ( ) . add ( V2GMessages . POWER_DELIVERY_REQ ) ; return getSendMessage ( chargingStatusRes , V2GMessages . FORK ) ; } } else { if ( chargingStatusRes . getResponseCode ( ) . equals ( ResponseCodeType . FAILED_SEQUENCE_ERROR ) ) { BodyBaseType responseMessage = getSequenceErrorResMessage ( new ChargingStatusResType ( ) , message ) ; return getSendMessage ( responseMessage , V2GMessages . NONE , chargingStatusRes . getResponseCode ( ) ) ; } else { setMandatoryFieldsForFailedRes ( chargingStatusRes , chargingStatusRes . getResponseCode ( ) ) ; } } return getSendMessage ( chargingStatusRes , V2GMessages . NONE , chargingStatusRes . getResponseCode ( ) ) ; }
V2GClarity/RISE-V2G | @ Override public BodyBaseType getResponseMessage ( ) { return chargingStatusRes ; }
wangyangjun/RealtimeStreamBenchmark | public Workload ( OperatorCreator creator ) throws WorkloadException { this . operatorCreator = creator ; Configure . LoadConfigure ( ) ; parallelism = Configure . clusterHosts * Configure . hostCores ; properties = new Properties ( ) ; String configFile = this . getClass ( ) . getSimpleName ( ) + " . properties " ; try { properties . load ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( configFile ) ) ; } catch ( IOException e ) { throw new WorkloadException ( " Read ▁ configure ▁ file ▁ " + configFile + " ▁ failed " ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( " Read ▁ configure ▁ file : ▁ " + configFile + " ▁ failed " ) ; } }
wangyangjun/RealtimeStreamBenchmark | protected OperatorCreator getOperatorCreator ( ) { return operatorCreator ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < WithTime < String > > stringStreamWithTime ( String componentId ) { String topic = properties . getProperty ( " topic " ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . stringStreamFromKafkaWithTime ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < Point > getPointStream ( String componentId ) { String topic = properties . getProperty ( " topic " ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . pointStreamFromKafka ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < String > kafkaStreamOperator ( String componentId ) { String topic = properties . getProperty ( " topic " ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . stringStreamFromKafka ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < String > kafkaStreamOperator2 ( String componentId ) { String topic = properties . getProperty ( " topic2" ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . stringStreamFromKafka ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | public void Start ( ) { logger . info ( " Start ▁ workload : ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; try { Process ( ) ; this . getOperatorCreator ( ) . Start ( ) ; } catch ( Exception e ) { logger . error ( " WorkloadException ▁ caught ▁ when ▁ run ▁ workload ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; e . printStackTrace ( ) ; } logger . info ( " The ▁ end ▁ of ▁ workload : ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; }
LearnLib/alex | public boolean isSymbolsOnly ( ) { return symbolsOnly ; }
LearnLib/alex | public void setSymbolsOnly ( boolean symbolsOnly ) { this . symbolsOnly = symbolsOnly ; }
LearnLib/alex | public List < Long > getSymbolIds ( ) { return symbolIds ; }
LearnLib/alex | public void setSymbolIds ( List < Long > symbolIds ) { this . symbolIds = symbolIds ; }
TopQuadrant/shacl | public DistinctExpression ( RDFNode expr , NodeExpression input ) { super ( expr , input ) ; }
TopQuadrant/shacl | @ Override public ExtendedIterator < RDFNode > eval ( RDFNode focusNode , NodeExpressionContext context ) { return distinct ( evalInput ( focusNode , context ) ) ; }
TopQuadrant/shacl | @ Override public Resource getOutputShape ( Resource contextShape ) { return getInput ( ) . getOutputShape ( contextShape ) ; }
TopQuadrant/shacl | @ Override public String getTypeId ( ) { return " distinct " ; }
TopQuadrant/shacl | @ Override public void visit ( NodeExpressionVisitor visitor ) { visitor . visit ( this ) ; }
gcorreageek/dhl | @ Override public String getCurrentAuditor ( ) { String userName = SecurityUtils . getCurrentUserLogin ( ) ; return ( userName != null ? userName : Constants . SYSTEM_ACCOUNT ) ; }
rvprg/pet | public RemoveCatchingUpMemberResult ( Boolean result , MemberId leaderId ) { super ( result , leaderId ) ; }
shirdrn/platform-api | public NamedThreadFactory ( String poolName ) { if ( poolName != null && ! poolName . trim ( ) . isEmpty ( ) ) { this . poolName = poolName ; } SecurityManager s = System . getSecurityManager ( ) ; group = ( s != null ) ? s . getThreadGroup ( ) : Thread . currentThread ( ) . getThreadGroup ( ) ; }
shirdrn/platform-api | public NamedThreadFactory ( ) { this ( " POOL " ) ; }
shirdrn/platform-api | @ Override public Thread newThread ( Runnable r ) { String threadName = poolName + " - " + formatter . format ( threadNumber . getAndIncrement ( ) ) ; Thread t = new Thread ( group , r , threadName , 0 ) ; if ( t . isDaemon ( ) ) t . setDaemon ( false ) ; if ( t . getPriority ( ) != Thread . NORM_PRIORITY ) t . setPriority ( Thread . NORM_PRIORITY ) ; return t ; }
cadc/glue-stack | public Organisation getOrganisation ( ) { return this . organisation ; }
cadc/glue-stack | public void setOrganisation ( Organisation organisation ) { this . organisation = organisation ; }
AsciiBunny/Bunny-Control-System | public BunnyServer ( int port , int clients , String name ) { PORT = port ; NAME = name ; AMMOUNT_OF_CLIENTS = clients ; }
AsciiBunny/Bunny-Control-System | public BunnyServer ( ) { PORT = 9999 ; NAME = " BunnyServer " ; AMMOUNT_OF_CLIENTS = 3 ; }
AsciiBunny/Bunny-Control-System | public void run ( ) { try { clients = new ClientHandler [ AMMOUNT_OF_CLIENTS ] ; serverSocket = new ServerSocket ( PORT ) ; System . out . println ( " Waiting ▁ for ▁ clients " ) ; while ( true ) { Socket s = serverSocket . accept ( ) ; System . out . println ( " Client ▁ connected ▁ from ▁ " + s . getLocalAddress ( ) . getHostName ( ) ) ; createClient ( s ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
AsciiBunny/Bunny-Control-System | public void handle ( int id , String name , ArrayList < String > inputs ) { ArrayList < String > coms = new ArrayList < String > ( ) ; if ( inputs . get ( 0 ) . startsWith ( " / " ) ) { switch ( inputs . get ( 0 ) ) { case " / exit " : coms . add ( NAME ) ; coms . add ( " Client ▁ < " + name + " > ▁ has ▁ left " ) ; coms . add ( " / end " ) ; coms . add ( " / playerquit " ) ; coms . add ( name ) ; coms . add ( " / end " ) ; clients [ id ] . stop ( ) ; clients [ id ] = null ; System . out . println ( " Client ▁ " + name + " ▁ has ▁ left " ) ; break ; case " / changename " : coms . add ( NAME ) ; coms . add ( " Client ▁ < " + name + " > ▁ has ▁ changed ▁ names ▁ to ▁ < " + inputs . get ( 1 ) + " > . " ) ; coms . add ( " / end " ) ; coms . add ( " / changedname " ) ; coms . add ( name ) ; coms . add ( inputs . get ( 1 ) ) ; coms . add ( " / end " ) ; clients [ id ] . setName ( inputs . get ( 1 ) ) ; break ; case " / kick " : coms . add ( NAME ) ; coms . add ( " Client ▁ < " + inputs . get ( 1 ) + " > ▁ just ▁ got ▁ kicked ▁ out , ▁ was ▁ he ▁ being ▁ naughty ? " ) ; coms . add ( " / end " ) ; coms . add ( " / playerquit " ) ; coms . add ( inputs . get ( 1 ) ) ; coms . add ( " / end " ) ; for ( ClientHandler client : clients ) { if ( client != null ) { if ( client . getName ( ) . equals ( inputs . get ( 1 ) ) ) { System . out . println ( client . getName ( ) + " ▁ got ▁ kicked " ) ; clients [ client . getID ( ) ] = null ; client . kick ( ) ; } } } break ; case " / say " : coms . add ( NAME ) ; coms . add ( inputs . get ( 1 ) ) ; coms . add ( " / end " ) ; break ; case " / pm " : for ( ClientHandler client : clients ) { if ( client != null ) { if ( client . getName ( ) . equals ( inputs . get ( 1 ) ) ) { client . printString ( name ) ; client . printString ( " pm : ▁ " + inputs . get ( 2 ) ) ; client . printString ( " / end " ) ; } } } break ; default : clients [ id ] . printString ( NAME ) ; clients [ id ] . printString ( " Command ▁ is ▁ not ▁ recognized , ▁ please ▁ try ▁ again . " ) ; clients [ id ] . printString ( " / end " ) ; break ; } } else { coms . add ( name ) ; coms . add ( inputs . get ( 0 ) ) ; coms . add ( " / end " ) ; } for ( ClientHandler client : clients ) { if ( client != null ) { for ( String string : coms ) { client . printString ( string ) ; } } } }
AsciiBunny/Bunny-Control-System | private void createClient ( Socket s ) throws InterruptedException { ClientHandler client = new ClientHandler ( s , this ) ; boolean joined = false ; for ( int i = 0 ; i < clients . length ; i ++ ) { if ( clients [ i ] == null ) { clients [ i ] = client ; client . setID ( i ) ; System . out . println ( " Client ▁ " + client . getName ( ) + " ▁ joined ▁ on ▁ ID : ▁ " + client . getID ( ) ) ; joined = true ; break ; } } Thread t = new Thread ( client ) ; t . start ( ) ; Thread . sleep ( 2 ) ; if ( joined ) { for ( ClientHandler handler : clients ) { if ( handler != null ) { client . send ( " / newplayer " , handler . getName ( ) ) ; if ( handler != client ) { handler . send ( " / newplayer " , client . getName ( ) ) ; handler . send ( client . getName ( ) + " ▁ has ▁ come ▁ to ▁ chat ! " ) ; } } } } else { client . send ( " Sorry , ▁ but ▁ the ▁ server ▁ is ▁ full ! ▁ Try ▁ again ▁ later . " ) ; client . printString ( " / kicked " ) ; client . printString ( " / end " ) ; } }
maxdosanjos/JavaSE | public Agenda ( ) throws IOException { List < Contato > contatos = this . arquivo . ler ( ) ; for ( Contato contato : contatos ) { try { this . inserir ( contato ) ; } catch ( AgendaException e ) { e . printStackTrace ( ) ; } } }
maxdosanjos/JavaSE | if ( this . contatosMap . containsKey ( nome ) ) { throw new AgendaException ( " contato ▁ " + nome + " ▁ já ▁ existe " ) ; }
maxdosanjos/JavaSE | if ( contatosLetra == null ) { contatosLetra = new ArrayList < > ( ) ; contatosPorLetra . put ( letraInicial , contatosLetra ) ; }
maxdosanjos/JavaSE | public Contato obterContato ( String nome ) { return this . contatosMap . get ( nome ) ; }
maxdosanjos/JavaSE | public List < Contato > listarContatoPorLetra ( char letra ) { List < Contato > contatos = contatosPorLetra . get ( Character . toUpperCase ( letra ) ) ; if ( contatos == null ) { contatos = new ArrayList < > ( ) ; } return contatos ; }
maxdosanjos/JavaSE | public List < Contato > listarContatoPorParteNome ( String parteNome ) { String regex = " \\ w * " + parteNome + " \\ w * " ; Pattern p = Pattern . compile ( regex , Pattern . CASE_INSENSITIVE ) ; List < Contato > contatosEncontrados = new ArrayList < > ( ) ; Collection < Contato > contatosCadastrados = this . contatosMap . values ( ) ; for ( Contato contato : contatosCadastrados ) { Matcher m = p . matcher ( contato . getNome ( ) ) ; if ( m . matches ( ) ) { contatosEncontrados . add ( contato ) ; } } return contatosEncontrados ; }
maxdosanjos/JavaSE | private void verificarExistenciaContato ( String nome ) throws AgendaException { if ( ! this . contatosMap . containsKey ( nome ) ) { throw new AgendaException ( " Contato ▁ " + nome + " ▁ não ▁ existe ! " ) ; } }
MuShiiii/commons-io | public NullInputStreamTest ( final String name ) { super ( name ) ; }
MuShiiii/commons-io | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; }
MuShiiii/commons-io | @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; }
MuShiiii/commons-io | public void testRead ( ) throws Exception { final int size = 5 ; final InputStream input = new TestNullInputStream ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { assertEquals ( " Check ▁ Size ▁ [ " + i + " ] " , size - i , input . available ( ) ) ; assertEquals ( " Check ▁ Value ▁ [ " + i + " ] " , i , input . read ( ) ) ; } assertEquals ( " Available ▁ after ▁ contents ▁ all ▁ read " , 0 , input . available ( ) ) ; assertEquals ( " End ▁ of ▁ File " , - 1 , input . read ( ) ) ; assertEquals ( " Available ▁ after ▁ End ▁ of ▁ File " , 0 , input . available ( ) ) ; try { final int result = input . read ( ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ IOException , ▁ byte = [ " + result + " ] " ) ; } catch ( final IOException e ) { assertEquals ( " Read ▁ after ▁ end ▁ of ▁ file " , e . getMessage ( ) ) ; } input . close ( ) ; assertEquals ( " Available ▁ after ▁ close " , size , input . available ( ) ) ; }
MuShiiii/commons-io | public void testReadByteArray ( ) throws Exception { final byte [ ] bytes = new byte [ 10 ] ; final InputStream input = new TestNullInputStream ( 15 ) ; final int count1 = input . read ( bytes ) ; assertEquals ( " Read ▁ 1" , bytes . length , count1 ) ; for ( int i = 0 ; i < count1 ; i ++ ) { assertEquals ( " Check ▁ Bytes ▁ 1" , i , bytes [ i ] ) ; } final int count2 = input . read ( bytes ) ; assertEquals ( " Read ▁ 2" , 5 , count2 ) ; for ( int i = 0 ; i < count2 ; i ++ ) { assertEquals ( " Check ▁ Bytes ▁ 2" , count1 + i , bytes [ i ] ) ; } final int count3 = input . read ( bytes ) ; assertEquals ( " Read ▁ 3 ▁ ( EOF ) " , - 1 , count3 ) ; try { final int count4 = input . read ( bytes ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ IOException , ▁ byte = [ " + count4 + " ] " ) ; } catch ( final IOException e ) { assertEquals ( " Read ▁ after ▁ end ▁ of ▁ file " , e . getMessage ( ) ) ; } input . close ( ) ; final int offset = 2 ; final int lth = 4 ; final int count5 = input . read ( bytes , offset , lth ) ; assertEquals ( " Read ▁ 5" , lth , count5 ) ; for ( int i = offset ; i < lth ; i ++ ) { assertEquals ( " Check ▁ Bytes ▁ 2" , i , bytes [ i ] ) ; } }
MuShiiii/commons-io | public void testEOFException ( ) throws Exception { final InputStream input = new TestNullInputStream ( 2 , false , true ) ; assertEquals ( " Read ▁ 1" , 0 , input . read ( ) ) ; assertEquals ( " Read ▁ 2" , 1 , input . read ( ) ) ; try { final int result = input . read ( ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ EOFException , ▁ byte = [ " + result + " ] " ) ; } catch ( final EOFException e ) { } input . close ( ) ; }
MuShiiii/commons-io | public void testMarkAndReset ( ) throws Exception { int position = 0 ; final int readlimit = 10 ; final InputStream input = new TestNullInputStream ( 100 , true , false ) ; assertTrue ( " Mark ▁ Should ▁ be ▁ Supported " , input . markSupported ( ) ) ; try { input . reset ( ) ; fail ( " Read ▁ limit ▁ exceeded , ▁ expected ▁ IOException ▁ " ) ; } catch ( final IOException e ) { assertEquals ( " No ▁ Mark ▁ IOException ▁ message " , " No ▁ position ▁ has ▁ been ▁ marked " , e . getMessage ( ) ) ; } for ( ; position < 3 ; position ++ ) { assertEquals ( " Read ▁ Before ▁ Mark ▁ [ " + position + " ] " , position , input . read ( ) ) ; } input . mark ( readlimit ) ; for ( int i = 0 ; i < 3 ; i ++ ) { assertEquals ( " Read ▁ After ▁ Mark ▁ [ " + i + " ] " , position + i , input . read ( ) ) ; } input . reset ( ) ; for ( int i = 0 ; i < readlimit + 1 ; i ++ ) { assertEquals ( " Read ▁ After ▁ Reset ▁ [ " + i + " ] " , position + i , input . read ( ) ) ; } try { input . reset ( ) ; fail ( " Read ▁ limit ▁ exceeded , ▁ expected ▁ IOException ▁ " ) ; } catch ( final IOException e ) { assertEquals ( " Read ▁ limit ▁ IOException ▁ message " , " Marked ▁ position ▁ [ " + position + " ] ▁ is ▁ no ▁ longer ▁ valid ▁ - ▁ passed ▁ the ▁ read ▁ limit ▁ [ " + readlimit + " ] " , e . getMessage ( ) ) ; } input . close ( ) ; }
MuShiiii/commons-io | public void testMarkNotSupported ( ) throws Exception { final InputStream input = new TestNullInputStream ( 100 , false , true ) ; assertFalse ( " Mark ▁ Should ▁ NOT ▁ be ▁ Supported " , input . markSupported ( ) ) ; try { input . mark ( 5 ) ; fail ( " mark ( ) ▁ should ▁ throw ▁ UnsupportedOperationException " ) ; } catch ( final UnsupportedOperationException e ) { assertEquals ( " mark ( ) ▁ error ▁ message " , " Mark ▁ not ▁ supported " , e . getMessage ( ) ) ; } try { input . reset ( ) ; fail ( " reset ( ) ▁ should ▁ throw ▁ UnsupportedOperationException " ) ; } catch ( final UnsupportedOperationException e ) { assertEquals ( " reset ( ) ▁ error ▁ message " , " Mark ▁ not ▁ supported " , e . getMessage ( ) ) ; } input . close ( ) ; }
MuShiiii/commons-io | public void testSkip ( ) throws Exception { final InputStream input = new TestNullInputStream ( 10 , true , false ) ; assertEquals ( " Read ▁ 1" , 0 , input . read ( ) ) ; assertEquals ( " Read ▁ 2" , 1 , input . read ( ) ) ; assertEquals ( " Skip ▁ 1" , 5 , input . skip ( 5 ) ) ; assertEquals ( " Read ▁ 3" , 7 , input . read ( ) ) ; assertEquals ( " Skip ▁ 2" , 2 , input . skip ( 5 ) ) ; assertEquals ( " Skip ▁ 3 ▁ ( EOF ) " , - 1 , input . skip ( 5 ) ) ; try { input . skip ( 5 ) ; fail ( " Expected ▁ IOException ▁ for ▁ skipping ▁ after ▁ end ▁ of ▁ file " ) ; } catch ( final IOException e ) { assertEquals ( " Skip ▁ after ▁ EOF ▁ IOException ▁ message " , " Skip ▁ after ▁ end ▁ of ▁ file " , e . getMessage ( ) ) ; } input . close ( ) ; }
MuShiiii/commons-io | public TestNullInputStream ( final int size ) { super ( size ) ; }
MuShiiii/commons-io | public TestNullInputStream ( final int size , final boolean markSupported , final boolean throwEofException ) { super ( size , markSupported , throwEofException ) ; }
MuShiiii/commons-io | @ Override protected int processByte ( ) { return ( int ) getPosition ( ) - 1 ; }
MuShiiii/commons-io | @ Override protected void processBytes ( final byte [ ] bytes , final int offset , final int length ) { final int startPos = ( int ) getPosition ( ) - length ; for ( int i = offset ; i < length ; i ++ ) { bytes [ i ] = ( byte ) ( startPos + i ) ; } }
ollide/Xposed-IncognitoTab | @ Override public void handleLoadPackage ( final XC_LoadPackage . LoadPackageParam lpp ) throws Throwable { if ( lpp . packageName . equals ( PackageName . CHROME ) || lpp . packageName . equals ( PackageName . CHROME_BETA ) ) { hookChromeMethods ( lpp ) ; } }
ollide/Xposed-IncognitoTab | private void hookChromeMethods ( XC_LoadPackage . LoadPackageParam lpp ) { final String packageName = lpp . packageName ; final ClassLoader classLoader = lpp . classLoader ; final Class < ? > chromeLauncherActivity = XposedHelpers . findClass ( " com . google . android . apps . chrome . document . ChromeLauncherActivity " , classLoader ) ; XposedHelpers . findAndHookMethod ( " com . google . android . apps . chrome . document . ChromeLauncherActivity " , classLoader , " onCreate " , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Activity chromeActivity = ( Activity ) param . thisObject ; String incognitoUrl = chromeActivity . getIntent ( ) . getStringExtra ( EXTRA_INCOGNITO_URL ) ; if ( incognitoUrl != null ) { if ( ChromeUtils . isDocumentMode ( classLoader , packageName , chromeActivity ) ) { XposedHelpers . callStaticMethod ( chromeLauncherActivity , " launchInstance " , chromeActivity , true , 0 , incognitoUrl , 201 , 6 , false , null ) ; } else { didOpen = false ; url = incognitoUrl ; } } } } ) ; final Class < ? > loadUrlParamsClass = XposedHelpers . findClass ( " org . chromium . content _ public . browser . LoadUrlParams " , classLoader ) ; final Class < ? > tabLaunchTypeClass = XposedHelpers . findClass ( " org . chromium . chrome . browser . tabmodel . TabModel . TabLaunchType " , classLoader ) ; XposedHelpers . findAndHookMethod ( " com . google . android . apps . chrome . tab . ChromeTab " , classLoader , " didStartPageLoad " , String . class , boolean . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( ! didOpen && url != null ) { didOpen = true ; Object chromeTab = param . thisObject ; Object chromeActivity = XposedHelpers . getObjectField ( chromeTab , " mActivity " ) ; Object tabCreator = XposedHelpers . callMethod ( chromeActivity , " getTabCreator " , true ) ; Constructor < ? > constructor = loadUrlParamsClass . getConstructor ( String . class ) ; Object loadUrlParams = constructor . newInstance ( url ) ; Enum tabLaunchType = Enum . valueOf ( ( Class < ? extends Enum > ) tabLaunchTypeClass , " FROM _ MENU _ OR _ OVERVIEW " ) ; XposedHelpers . callMethod ( tabCreator , " createNewTab " , loadUrlParams , tabLaunchType , chromeTab ) ; } } } ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | public LuceneReindexAlgorithm ( ) throws Exception { super ( ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | public void setIndexedObjects ( String indexedObjects ) { this . indexedObjects = indexedObjects ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void compute ( ) throws Exception { if ( fullTextEntityManager == null ) { fullTextEntityManager = Search . getFullTextEntityManager ( manager ) ; } computeLuceneIndexes ( indexedObjects ) ; fullTextEntityManager . close ( ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void reset ( ) throws Exception { if ( fullTextEntityManager == null ) { fullTextEntityManager = Search . getFullTextEntityManager ( manager ) ; } clearLuceneIndexes ( ) ; fullTextEntityManager . close ( ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | private void computeLuceneIndexes ( String indexedObjects ) throws Exception { Set < String > objectsToReindex = new HashSet < > ( ) ; if ( indexedObjects == null || indexedObjects . isEmpty ( ) ) { objectsToReindex . add ( " ConceptJpa " ) ; objectsToReindex . add ( " ProjectJpa " ) ; } else { String [ ] objects = indexedObjects . replaceAll ( " ▁ " , " " ) . split ( " , " ) ; for ( String object : objects ) objectsToReindex . add ( object ) ; } Logger . getLogger ( getClass ( ) ) . info ( " Starting ▁ reindexing ▁ for : " ) ; for ( String objectToReindex : objectsToReindex ) { Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ " + objectToReindex ) ; } FullTextEntityManager fullTextEntityManager = Search . getFullTextEntityManager ( manager ) ; if ( objectsToReindex . contains ( " ConceptJpa " ) ) { Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ Creating ▁ indexes ▁ for ▁ ConceptJpa " ) ; fullTextEntityManager . purgeAll ( ConceptJpa . class ) ; fullTextEntityManager . flushToIndexes ( ) ; fullTextEntityManager . createIndexer ( ConceptJpa . class ) . batchSizeToLoadObjects ( 100 ) . cacheMode ( CacheMode . NORMAL ) . threadsToLoadObjects ( 4 ) . startAndWait ( ) ; objectsToReindex . remove ( " ConceptJpa " ) ; } if ( objectsToReindex . contains ( " ProjectJpa " ) ) { Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ Creating ▁ indexes ▁ for ▁ ProjectJpa " ) ; fullTextEntityManager . purgeAll ( ProjectJpa . class ) ; fullTextEntityManager . flushToIndexes ( ) ; fullTextEntityManager . createIndexer ( ProjectJpa . class ) . batchSizeToLoadObjects ( 100 ) . cacheMode ( CacheMode . NORMAL ) . threadsToLoadObjects ( 4 ) . startAndWait ( ) ; objectsToReindex . remove ( " ProjectJpa " ) ; } if ( objectsToReindex . size ( ) != 0 ) { throw new Exception ( " The ▁ following ▁ objects ▁ were ▁ specified ▁ for ▁ re - indexing , ▁ but ▁ do ▁ not ▁ exist ▁ as ▁ indexed ▁ objects : ▁ " + objectsToReindex . toString ( ) ) ; } Logger . getLogger ( getClass ( ) ) . info ( " done ▁ . . . " ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | private void clearLuceneIndexes ( ) throws Exception { fullTextEntityManager . purgeAll ( ConceptJpa . class ) ; fullTextEntityManager . purgeAll ( ProjectJpa . class ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | public void fireProgressEvent ( int pct , String note ) { ProgressEvent pe = new ProgressEvent ( this , pct , pct , note ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { listeners . get ( i ) . updateProgress ( pe ) ; } Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ ▁ ▁ " + pct + " % ▁ " + note ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void addProgressListener ( ProgressListener l ) { listeners . add ( l ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void removeProgressListener ( ProgressListener l ) { listeners . remove ( l ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void cancel ( ) { requestCancel = true ; }
Syncleus/AetherMUD | public UseCommand ( GameManager gameManager ) { super ( gameManager , validTriggers , description , correctUsage ) ; }
Syncleus/AetherMUD | @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { execCommand ( ctx , e , ( ) -> { UseItemOn useItemOn = new UseItemOn ( originalMessageParts ) ; if ( Strings . isNullOrEmpty ( useItemOn . getItem ( ) ) ) { write ( " No ▁ item ▁ specified . " ) ; return ; } Optional < ItemInstance > inventoryItemOptional = player . getInventoryItem ( useItemOn . getItem ( ) ) ; if ( ! inventoryItemOptional . isPresent ( ) ) { write ( " Useable ▁ item ▁ is ▁ not ▁ found ▁ in ▁ your ▁ inventory . \r \n " ) ; return ; } gameManager . getItemUseHandler ( ) . handle ( player , inventoryItemOptional . get ( ) , useItemOn ) ; } ) ; }
Syncleus/AetherMUD | public UseItemOn ( List < String > originalMessageParts ) { originalMessageParts . remove ( 0 ) ; String fullCommand = Joiner . on ( " ▁ " ) . join ( originalMessageParts ) ; if ( fullCommand . endsWith ( " ▁ on " ) ) fullCommand = fullCommand . substring ( 0 , fullCommand . length ( ) - 3 ) ; item = getItem ( fullCommand ) ; target = getItemTarget ( fullCommand ) ; }
Syncleus/AetherMUD | public Optional < String > getTarget ( ) { return target ; }
Syncleus/AetherMUD | public String getItem ( ) { return item ; }
Mun1z/PROJECT-MANAGER | public long getId ( ) { return id ; }
Mun1z/PROJECT-MANAGER | public void setId ( long id ) { this . id = id ; }
Mun1z/PROJECT-MANAGER | public String getDescricaoGeral ( ) { return descricaoGeral ; }
Mun1z/PROJECT-MANAGER | public void setDescricaoGeral ( String descricaoGeral ) { this . descricaoGeral = descricaoGeral ; }
Mun1z/PROJECT-MANAGER | public String getDataDeCriacao ( ) { return dataDeCriacao ; }
Mun1z/PROJECT-MANAGER | public void setDataDeCriacao ( String dataDeCriacao ) { this . dataDeCriacao = dataDeCriacao ; }
Mun1z/PROJECT-MANAGER | public String getDataDeFinalizacao ( ) { return dataDeFinalizacao ; }
Mun1z/PROJECT-MANAGER | public void setDataDeFinalizacao ( String dataDeFinalizacao ) { this . dataDeFinalizacao = dataDeFinalizacao ; }
blue-fly/smartglass | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_setup1 ) ; }
blue-fly/smartglass | public void next ( View view ) { showNext ( ) ; }
blue-fly/smartglass | @ Override public void showPref ( ) { }
blue-fly/smartglass | @ Override public void showNext ( ) { Intent i = new Intent ( Setup1Activity . this , Setup2Activity . class ) ; startActivity ( i ) ; finish ( ) ; overridePendingTransition ( R . anim . page_next , R . anim . page_exit ) ; }
nicksellen/reka | public RekaDeployOperation ( ApplicationManager manager , BaseDirs basedirs , Function < Data , Path > dataPathFn , Function < Data , Path > appPathFn ) { this . manager = manager ; this . basedirs = basedirs ; this . dataPathFn = dataPathFn ; this . appPathFn = appPathFn ; }
nicksellen/reka | @ Override public void call ( MutableData data , OperationContext ctx , OperationResult res ) { Path dataPath = dataPathFn . apply ( data ) ; Path appPath = appPathFn . apply ( data ) ; data . putString ( " identity " , appPath . slashes ( ) ) ; int version = manager . nextVersion ( appPath ) ; AppDirs dirs = basedirs . resolve ( appPath , version ) ; Data val = data . at ( dataPath ) ; if ( ! val . isPresent ( ) ) throw runtime ( " no ▁ data ▁ at ▁ % s " , dataPath . dots ( ) ) ; if ( ! val . isContent ( ) ) throw runtime ( " not ▁ content ▁ at ▁ % s " , dataPath . dots ( ) ) ; if ( ! val . content ( ) . type ( ) . equals ( Content . Type . BINARY ) ) throw runtime ( " must ▁ be ▁ binary ▁ content ▁ at ▁ % s " , dataPath . dots ( ) ) ; BinaryContent bc = ( BinaryContent ) val . content ( ) ; if ( ! " application / zip " . equals ( bc . contentType ( ) ) ) throw runtime ( " must ▁ be ▁ application / zip ▁ content ▁ at ▁ % s " , dataPath . dots ( ) ) ; log . info ( " unpacking ▁ { } ▁ to ▁ { } " , appPath . slashes ( ) , dirs . app ( ) ) ; dirs . mkdirs ( ) ; deleteRecursively ( dirs . app ( ) ) ; unzip ( bc . asBytes ( ) , dirs . app ( ) ) ; File appdir = dirs . app ( ) . toFile ( ) ; File mainreka = dirs . app ( ) . resolve ( " main . reka " ) . toFile ( ) ; checkArgument ( appdir . exists ( ) , " app ▁ dir ▁ does ▁ not ▁ exist ▁ [ % s ] " , appdir ) ; checkArgument ( appdir . isDirectory ( ) , " app ▁ dir ▁ is ▁ not ▁ directory ▁ [ % s ] " , appdir ) ; checkArgument ( mainreka . exists ( ) , " main . reka ▁ does ▁ not ▁ exist " ) ; checkArgument ( ! mainreka . isDirectory ( ) , " main . reka ▁ is ▁ a ▁ directory " ) ; log . info ( " deploying ▁ { } " , appPath . slashes ( ) ) ; manager . deploySource ( appPath , - 1 , FileSource . from ( mainreka ) , new DeploySubscriber ( ) { @ Override public void ok ( Identity identity , int version , Application application ) { log . info ( " deploying ▁ { } ▁ ok " , identity ) ; data . putString ( " message " , " created ▁ application ! " ) ; res . done ( ) ; for ( int v = version - 3 ; v >= 0 ; v -- ) { deleteRecursively ( basedirs . resolve ( identity . path ( ) , v ) . app ( ) ) ; } } @ Override public void error ( Identity identity , Throwable t ) { t = unwrap ( t ) ; log . error ( " failed ▁ to ▁ deploy ▁ [ { } ] ▁ - ▁ { } " , identity . name ( ) , t . getMessage ( ) ) ; res . error ( t ) ; deleteRecursively ( dirs . app ( ) ) ; } } ) ; }
Martinfx/yodaqa | public QuestionConcept ( String title , int pageId ) { this . title = title ; this . pageId = pageId ; }
Martinfx/yodaqa | public String getTitle ( ) { return title ; }
Martinfx/yodaqa | public int getPageId ( ) { return pageId ; }
graham22/Classic | public ModbusResponse getResponse ( ) { ReadExceptionStatusResponse response = null ; response = new ReadExceptionStatusResponse ( ) ; response . setHeadless ( isHeadless ( ) ) ; if ( ! isHeadless ( ) ) { response . setTransactionID ( getTransactionID ( ) ) ; response . setProtocolID ( getProtocolID ( ) ) ; } response . setUnitID ( getUnitID ( ) ) ; response . setFunctionCode ( getFunctionCode ( ) ) ; return response ; }
graham22/Classic | public ModbusResponse createResponse ( ) { throw new RuntimeException ( ) ; }
graham22/Classic | public void writeData ( DataOutput dout ) throws IOException { dout . write ( getMessage ( ) ) ; }
graham22/Classic | public void readData ( DataInput din ) throws IOException { }
graham22/Classic | public byte [ ] getMessage ( ) { byte results [ ] = new byte [ 0 ] ; return results ; }
graham22/Classic | public ReadExceptionStatusRequest ( ) { super ( ) ; setFunctionCode ( Modbus . READ_EXCEPTION_STATUS ) ; setDataLength ( 0 ) ; }
miniway/presto | public InternalTable ( Map < String , Integer > columnIndexes , Iterable < Page > pages ) { this . columnIndexes = ImmutableMap . copyOf ( requireNonNull ( columnIndexes , " columnIndexes ▁ is ▁ null " ) ) ; this . pages = ImmutableList . copyOf ( requireNonNull ( pages , " pages ▁ is ▁ null " ) ) ; }
miniway/presto | public int getColumnIndex ( String columnName ) { Integer index = columnIndexes . get ( columnName ) ; checkArgument ( index != null , " Column ▁ % s ▁ not ▁ found " , columnName ) ; return index ; }
miniway/presto | public List < Page > getPages ( ) { return pages ; }
miniway/presto | public Builder ( List < String > columnNames , List < Type > types ) { requireNonNull ( columnNames , " columnNames ▁ is ▁ null " ) ; ImmutableMap . Builder < String , Integer > columnIndexes = ImmutableMap . builder ( ) ; int columnIndex = 0 ; for ( String columnName : columnNames ) { columnIndexes . put ( columnName , columnIndex ++ ) ; } this . columnIndexes = columnIndexes . build ( ) ; this . types = ImmutableList . copyOf ( requireNonNull ( types , " types ▁ is ▁ null " ) ) ; checkArgument ( columnNames . size ( ) == types . size ( ) , " Column ▁ name ▁ count ▁ does ▁ not ▁ match ▁ type ▁ count : ▁ columnNames = % s , ▁ types = % s " , columnNames , types . size ( ) ) ; pages = new ArrayList < > ( ) ; pageBuilder = new PageBuilder ( types ) ; }
miniway/presto | public Builder add ( Object ... values ) { pageBuilder . declarePosition ( ) ; for ( int i = 0 ; i < types . size ( ) ; i ++ ) { writeNativeValue ( types . get ( i ) , pageBuilder . getBlockBuilder ( i ) , values [ i ] ) ; } if ( pageBuilder . isFull ( ) ) { flushPage ( ) ; } return this ; }
miniway/presto | public InternalTable build ( ) { flushPage ( ) ; return new InternalTable ( columnIndexes , pages ) ; }
miniway/presto | private void flushPage ( ) { if ( ! pageBuilder . isEmpty ( ) ) { pages . add ( pageBuilder . build ( ) ) ; pageBuilder . reset ( ) ; } }
rokn/Count_Words_2015 | public RoundCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; }
rokn/Count_Words_2015 | public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , " roundF " , " ( D ) D " ) ) ) ; }
flyzsd/java-code-snippets | private JMXConnectorServerFactory ( ) { }
gosu-lang/old-gosu-repo | @ Override public Element getState ( ) { final Element element = new Element ( GOSU_COMPILER_SETTINGS_TAG ) ; element . setAttribute ( ExternalCompilerMemory , String . valueOf ( myExternalCompilerMemory ) ) ; element . setAttribute ( ExternalToIncrementalCompilerLimit , String . valueOf ( myExternalToIncrementalCompiler ) ) ; return element ; }
gosu-lang/old-gosu-repo | @ Override public void loadState ( Element state ) { setExternalCompilerMemory ( Integer . valueOf ( state . getAttributeValue ( ExternalCompilerMemory , String . valueOf ( DEFAULT_Xmx ) ) ) ) ; setExternalToIncrementalCompiler ( Integer . valueOf ( state . getAttributeValue ( ExternalToIncrementalCompilerLimit , String . valueOf ( DEFAULT_INCREMENTAL_LIMIT ) ) ) ) ; }
gosu-lang/old-gosu-repo | public int getExternalCompilerMemory ( ) { return myExternalCompilerMemory ; }
gosu-lang/old-gosu-repo | public void setExternalCompilerMemory ( int myExternalCompilerMemory ) { this . myExternalCompilerMemory = myExternalCompilerMemory ; }
gosu-lang/old-gosu-repo | public int getExternalToIncrementalCompilerLimit ( ) { return myExternalToIncrementalCompiler ; }
gosu-lang/old-gosu-repo | public void setExternalToIncrementalCompiler ( int myExternalToIncrementalCompiler ) { this . myExternalToIncrementalCompiler = myExternalToIncrementalCompiler ; }
iansoftdev/all-blockchain | public Long getId ( ) { return id ; }
iansoftdev/all-blockchain | public Korbit setId ( Long id ) { this . id = id ; return this ; }
iansoftdev/all-blockchain | public String getSymbol ( ) { return symbol ; }
iansoftdev/all-blockchain | public Korbit setSymbol ( String symbol ) { this . symbol = symbol ; return this ; }
iansoftdev/all-blockchain | public String getTimestamp ( ) { return timestamp ; }
iansoftdev/all-blockchain | public Korbit setTimestamp ( String timestamp ) { this . timestamp = timestamp ; return this ; }
iansoftdev/all-blockchain | public String getLast ( ) { return last ; }
iansoftdev/all-blockchain | public Korbit setLast ( String last ) { this . last = last ; return this ; }
iansoftdev/all-blockchain | public String getBid ( ) { return bid ; }
iansoftdev/all-blockchain | public Korbit setBid ( String bid ) { this . bid = bid ; return this ; }
iansoftdev/all-blockchain | public String getAsk ( ) { return ask ; }
iansoftdev/all-blockchain | public Korbit setAsk ( String ask ) { this . ask = ask ; return this ; }
iansoftdev/all-blockchain | public String getLow ( ) { return low ; }
iansoftdev/all-blockchain | public Korbit setLow ( String low ) { this . low = low ; return this ; }
iansoftdev/all-blockchain | public String getHigh ( ) { return high ; }
iansoftdev/all-blockchain | public Korbit setHigh ( String high ) { this . high = high ; return this ; }
iansoftdev/all-blockchain | public String getVolume ( ) { return volume ; }
iansoftdev/all-blockchain | public Korbit setVolume ( String volume ) { this . volume = volume ; return this ; }
iansoftdev/all-blockchain | public String getChange ( ) { return change ; }
iansoftdev/all-blockchain | public Korbit setChange ( String change ) { this . change = change ; return this ; }
iansoftdev/all-blockchain | public String getChangePercent ( ) { return changePercent ; }
iansoftdev/all-blockchain | public Korbit setChangePercent ( String changePercent ) { this . changePercent = changePercent ; return this ; }
iansoftdev/all-blockchain | public ZonedDateTime getCreatedat ( ) { return createdat ; }
iansoftdev/all-blockchain | public Korbit setCreatedat ( ZonedDateTime createdat ) { this . createdat = createdat ; return this ; }
Orange-OpenSource/maven-plugins | @ Override public void setUp ( ) { tester = new WicketTester ( new WicketApplication ( ) ) ; }
Orange-OpenSource/maven-plugins | public void testRenderMyPage ( ) { tester . startPage ( HomePage . class ) ; tester . assertRenderedPage ( HomePage . class ) ; tester . assertLabel ( " message " , " If ▁ you ▁ see ▁ this ▁ message ▁ wicket ▁ is ▁ properly ▁ configured ▁ and ▁ running " ) ; }
dushmis/dagger | @ AssistedInject PrivateMethodRequestRepresentation ( @ Assisted BindingRequest request , @ Assisted ContributionBinding binding , @ Assisted RequestRepresentation wrappedRequestRepresentation , ComponentImplementation componentImplementation , DaggerTypes types , CompilerOptions compilerOptions ) { super ( componentImplementation . shardImplementation ( binding ) , types ) ; this . binding = checkNotNull ( binding ) ; this . request = checkNotNull ( request ) ; this . wrappedRequestRepresentation = checkNotNull ( wrappedRequestRepresentation ) ; this . shardImplementation = componentImplementation . shardImplementation ( binding ) ; this . compilerOptions = compilerOptions ; this . types = types ; }
dushmis/dagger | @ Override protected CodeBlock methodCall ( ) { return CodeBlock . of ( " $ N ( ) " , methodName ( ) ) ; }
dushmis/dagger | @ Override protected TypeMirror returnType ( ) { if ( request . isRequestKind ( RequestKind . INSTANCE ) && binding . contributedPrimitiveType ( ) . isPresent ( ) ) { return binding . contributedPrimitiveType ( ) . get ( ) ; } TypeMirror requestedType = request . requestedType ( binding . contributedType ( ) , types ) ; return types . accessibleType ( requestedType , shardImplementation . name ( ) ) ; }
dushmis/dagger | private String methodName ( ) { if ( methodName == null ) { methodName = shardImplementation . getUniqueMethodName ( request ) ; shardImplementation . addMethod ( PRIVATE_METHOD , methodBuilder ( methodName ) . addModifiers ( PRIVATE ) . returns ( TypeName . get ( returnType ( ) ) ) . addStatement ( " return ▁ $ L " , wrappedRequestRepresentation . getDependencyExpression ( shardImplementation . name ( ) ) . codeBlock ( ) ) . build ( ) ) ; } return methodName ; }
bruceadowns/miru | @ JsonCreator public MiruAuthzExpression ( @ JsonProperty ( " values " ) List < String > values ) { this . values = values ; }
bruceadowns/miru | public long sizeInBytes ( ) { long sizeInBytes = 0 ; for ( String value : values ) { sizeInBytes += 2 * value . length ( ) ; } return sizeInBytes ; }
bruceadowns/miru | @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } MiruAuthzExpression that = ( MiruAuthzExpression ) o ; return ! ( values != null ? ! values . equals ( that . values ) : that . values != null ) ; }
bruceadowns/miru | @ Override public int hashCode ( ) { return values != null ? values . hashCode ( ) : 0 ; }
bruceadowns/miru | @ Override public String toString ( ) { return " MiruAuthzExpression { " + " values = " + values + ' } ' ; }
MCAds/Plugin | if ( Main . config ( ) . getBoolean ( " featured " ) ) { DocumentBuilderFactory dbFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder dBuilder = dbFactory . newDocumentBuilder ( ) ; String xmlFile = Main . dataFolder ( ) + " / cache / featured / " + type + " . xml " ; Document doc = dBuilder . parse ( xmlFile ) ; doc . getDocumentElement ( ) . normalize ( ) ; NodeList nList = doc . getElementsByTagName ( type ) ; for ( int temp = 0 ; temp < nList . getLength ( ) ; temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; ads . add ( eElement . getTextContent ( ) ) ; } } }
MCAds/Plugin | for ( String ad : userAds ) { ads . add ( ad ) ; }
MCAds/Plugin | if ( Main . config ( ) . getBoolean ( " images " ) ) { NodeList nodeList = doc . getElementsByTagName ( " image " ) ; for ( int temp = 0 ; temp < nodeList . getLength ( ) ; temp ++ ) { Node nNode = nodeList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; File imageFile = new File ( Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; if ( ! imageFile . exists ( ) ) { Cache . image ( eElement . getTextContent ( ) ) ; } if ( type == " chat " ) { if ( eElement . hasAttribute ( " height " ) ) { imageHeight = Integer . parseInt ( eElement . getAttribute ( " height " ) ) ; } else { imageHeight = 8 ; } image = Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ; } if ( type == " hologram " ) { if ( eElement . hasAttribute ( " height " ) ) { lines . put ( Integer . parseInt ( eElement . getAttribute ( " height " ) ) , " image : " + Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; } else { lines . put ( 8 , " image : " + Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; } } } } }
MCAds/Plugin | temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; if ( eElement . hasAttribute ( " number " ) ) { lines . put ( Integer . parseInt ( eElement . getAttribute ( " number " ) ) , eElement . getTextContent ( ) ) ; } else { lines . put ( temp , eElement . getTextContent ( ) ) ; } } }
MCAds/Plugin | catch ( Exception e ) { lines . clear ( ) ; System . out . println ( " There ▁ is ▁ an ▁ error ▁ with ▁ the ▁ ad ▁ file ▁ at ▁ " + random ) ; if ( type == " scoreboard " ) { int number = Phrases . config . getStringList ( " ad _ error _ scoreboard " ) . size ( ) ; for ( String line : Phrases . config . getStringList ( " ad _ error _ scoreboard " ) ) { number -- ; lines . put ( number , line ) ; } } else { lines . put ( 1 , Phrases . config . getString ( " ad _ error " ) ) ; } }
MCAds/Plugin | temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; ads . add ( eElement . getTextContent ( ) ) ; } }
MCAds/Plugin | public void config ( ) throws IOException { file = new File ( Main . dataFolder ( ) , " ads . yml " ) ; config = YamlConfiguration . loadConfiguration ( file ) ; config . options ( ) . copyDefaults ( true ) ; Reader textResource = Main . textResource ( " ads . yml " ) ; config . setDefaults ( YamlConfiguration . loadConfiguration ( textResource ) ) ; config . save ( file ) ; }
jentrata/jentrata | public boolean isSendReceipt ( ) { return sendReceipt ; }
jentrata/jentrata | public void setSendReceipt ( boolean sendReceipt ) { this . sendReceipt = sendReceipt ; }
jentrata/jentrata | public ReplyPatternType getSendReceiptReplyPattern ( ) { return sendReceiptReplyPattern ; }
jentrata/jentrata | public void setSendReceiptReplyPattern ( ReplyPatternType sendReceiptReplyPattern ) { this . sendReceiptReplyPattern = sendReceiptReplyPattern ; }
jentrata/jentrata | public boolean isSendReceiptNonRepudiation ( ) { return sendReceiptNonRepudiation ; }
jentrata/jentrata | public void setSendReceiptNonRepudiation ( boolean sendReceiptNonRepudiation ) { this . sendReceiptNonRepudiation = sendReceiptNonRepudiation ; }
jentrata/jentrata | public Signature getSignature ( ) { return signature ; }
jentrata/jentrata | public void setSignature ( Signature signature ) { this . signature = signature ; }
jentrata/jentrata | public boolean isDisableBSPEnforcement ( ) { return disableBSPEnforcement ; }
jentrata/jentrata | public void setDisableBSPEnforcement ( boolean disableBSPEnforcement ) { this . disableBSPEnforcement = disableBSPEnforcement ; }
jentrata/jentrata | public boolean isInclusiveNamespacesEnabled ( ) { return inclusiveNamespacesEnabled ; }
jentrata/jentrata | public void setInclusiveNamespacesEnabled ( boolean inclusiveNamespacesEnabled ) { this . inclusiveNamespacesEnabled = inclusiveNamespacesEnabled ; }
AliaksandrShuhayeu/pentaho-kettle | @ Before public void setUp ( ) throws Exception { mockHelper = StepMockUtil . getStepMockHelper ( MappingMeta . class , " MappingUnitTest " ) ; mapping = new Mapping ( mockHelper . stepMeta , mockHelper . stepDataInterface , 0 , mockHelper . transMeta , mockHelper . trans ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test public void pickupTargetStepsFor_OutputIsNotDefined ( ) throws Exception { StepMeta singleMeta = new StepMeta ( " single " , null ) ; StepMeta copiedMeta = new StepMeta ( " copied " , null ) ; Mockito . when ( mockHelper . transMeta . findNextSteps ( mockHelper . stepMeta ) ) . thenReturn ( Arrays . asList ( singleMeta , copiedMeta ) ) ; StepInterface single = Mockito . mock ( StepInterface . class ) ; Mockito . when ( mockHelper . trans . findStepInterfaces ( " single " ) ) . thenReturn ( Collections . singletonList ( single ) ) ; StepInterface copy1 = Mockito . mock ( StepInterface . class ) ; StepInterface copy2 = Mockito . mock ( StepInterface . class ) ; Mockito . when ( mockHelper . trans . findStepInterfaces ( " copied " ) ) . thenReturn ( Arrays . asList ( copy1 , copy2 ) ) ; MappingIODefinition definition = new MappingIODefinition ( null , null ) ; StepInterface [ ] targetSteps = mapping . pickupTargetStepsFor ( definition ) ; assertThat ( Arrays . asList ( targetSteps ) , JUnitMatchers . hasItems ( is ( single ) , is ( copy1 ) , is ( copy2 ) ) ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test public void pickupTargetStepsFor_OutputIsDefined ( ) throws Exception { StepInterface copy1 = Mockito . mock ( StepInterface . class ) ; StepInterface copy2 = Mockito . mock ( StepInterface . class ) ; Mockito . when ( mockHelper . trans . findStepInterfaces ( " copied " ) ) . thenReturn ( Arrays . asList ( copy1 , copy2 ) ) ; MappingIODefinition definition = new MappingIODefinition ( null , " copied " ) ; StepInterface [ ] targetSteps = mapping . pickupTargetStepsFor ( definition ) ; assertThat ( Arrays . asList ( targetSteps ) , JUnitMatchers . hasItems ( is ( copy1 ) , is ( copy2 ) ) ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test ( expected = KettleException . class ) public void pickupTargetStepsFor_OutputIsDefined_ThrowsExceptionIfFindsNone ( ) throws Exception { MappingIODefinition definition = new MappingIODefinition ( null , " non - existing " ) ; mapping . pickupTargetStepsFor ( definition ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test public void testDispose ( ) throws Exception { MappingMeta meta = Mockito . mock ( MappingMeta . class ) ; MappingData data = Mockito . mock ( MappingData . class ) ; Mockito . when ( data . getMappingTrans ( ) ) . thenReturn ( mockHelper . trans ) ; MappingInput [ ] mappingInputs = { Mockito . mock ( MappingInput . class ) } ; MappingOutput [ ] mappingOutputs = { Mockito . mock ( MappingOutput . class ) } ; Mockito . when ( mockHelper . trans . findMappingInput ( ) ) . thenReturn ( mappingInputs ) ; Mockito . when ( mockHelper . trans . findMappingOutput ( ) ) . thenReturn ( mappingOutputs ) ; data . mappingTransMeta = mockHelper . transMeta ; Mockito . when ( data . mappingTransMeta . getTransformationType ( ) ) . thenReturn ( TransMeta . TransformationType . SingleThreaded ) ; data . singleThreadedTransExcecutor = Mockito . mock ( SingleThreadedTransExecutor . class ) ; Mockito . when ( data . singleThreadedTransExcecutor . oneIteration ( ) ) . thenReturn ( true ) ; data . mappingTrans = mockHelper . trans ; Mockito . when ( mockHelper . trans . isFinished ( ) ) . thenReturn ( false ) ; Mapping mapping = Mockito . spy ( new Mapping ( mockHelper . stepMeta , data , 0 , mockHelper . transMeta , mockHelper . trans ) ) ; String stepName = " StepName " ; mapping . setStepname ( stepName ) ; mapping . processRow ( meta , data ) ; mapping . dispose ( meta , data ) ; Mockito . verify ( mockHelper . trans , Mockito . times ( 1 ) ) . removeActiveSubTransformation ( stepName ) ; }
apacheignite/ignite | if ( osLow . contains ( " win " ) ) { if ( osLow . contains ( "95" ) ) win95 = true ; else if ( osLow . contains ( "98" ) ) win98 = true ; else if ( osLow . contains ( " nt " ) ) winNt = true ; else if ( osLow . contains ( "2000" ) ) win2k = true ; else if ( osLow . contains ( " vista " ) ) winVista = true ; else if ( osLow . contains ( " xp " ) ) winXp = true ; else if ( osLow . contains ( "2003" ) ) win2003 = true ; else if ( osLow . contains ( "2008" ) ) win2008 = true ; else if ( osLow . contains ( "7" ) ) win7 = true ; else if ( osLow . contains ( "8.1" ) ) win81 = true ; else if ( osLow . contains ( "8" ) ) win8 = true ; else unknownWin = true ; }
apacheignite/ignite | ) if ( osLow . contains ( os ) ) { unix = true ; break ; }
apacheignite/ignite | catch ( NoSuchMethodException e ) { throw withCause ( new AssertionError ( " Object ▁ class ▁ does ▁ not ▁ have ▁ empty ▁ constructor ▁ ( is ▁ JDK ▁ corrupted ? ) . " ) , e ) ; }
apacheignite/ignite | catch ( NoSuchMethodException | ClassNotFoundException | IllegalAccessException | InvocationTargetException ignored ) { }
apacheignite/ignite | if ( Boolean . parseBoolean ( System . getProperty ( IGNITE_DISABLE_HOSTNAME_VERIFIER ) ) ) { HttpsURLConnection . setDefaultHostnameVerifier ( new HostnameVerifier ( ) { @ Override public boolean verify ( String hostname , SSLSession sslSes ) { return true ; } } ) ; }
apacheignite/ignite | for ( Class < ? > cls : evtHolderClasses ) { for ( Field field : cls . getFields ( ) ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) && field . getType ( ) . equals ( int . class ) ) { if ( field . getName ( ) . startsWith ( " EVT _ " ) ) { try { int type = field . getInt ( null ) ; String prev = GRID_EVT_NAMES . put ( type , field . getName ( ) . substring ( " EVT _ " . length ( ) ) ) ; assert prev == null : " Duplicate ▁ event ▁ [ type = " + type + " , ▁ name1 = " + prev + " , ▁ name2 = " + field . getName ( ) + ' ] ' ; } catch ( IllegalAccessException e ) { throw new IgniteException ( e ) ; } } } } }
apacheignite/ignite | if ( EVTS_ALL == null || EVTS_ALL_MINUS_METRIC_UPDATE == null ) { try { Field f1 = EventType . class . getDeclaredField ( " EVTS _ ALL " ) ; Field f2 = EventType . class . getDeclaredField ( " EVTS _ ALL _ MINUS _ METRIC _ UPDATE " ) ; assert f1 != null ; assert f2 != null ; UNSAFE . putObjectVolatile ( UNSAFE . staticFieldBase ( f1 ) , UNSAFE . staticFieldOffset ( f1 ) , gridEvents ( ) ) ; UNSAFE . putObjectVolatile ( UNSAFE . staticFieldBase ( f2 ) , UNSAFE . staticFieldOffset ( f2 ) , gridEvents ( EVT_NODE_METRICS_UPDATED ) ) ; assert EVTS_ALL != null ; assert EVTS_ALL . length == GRID_EVTS . length ; assert EVTS_ALL_MINUS_METRIC_UPDATE != null ; assert EVTS_ALL_MINUS_METRIC_UPDATE . length == GRID_EVTS . length - 1 ; for ( int type : GRID_EVTS ) { assert containsIntArray ( EVTS_ALL , type ) ; if ( type != EVT_NODE_METRICS_UPDATED ) assert containsIntArray ( EVTS_ALL_MINUS_METRIC_UPDATE , type ) ; } assert ! containsIntArray ( EVTS_ALL_MINUS_METRIC_UPDATE , EVT_NODE_METRICS_UPDATED ) ; } catch ( NoSuchFieldException e ) { throw new IgniteException ( e ) ; } }
apacheignite/ignite | if ( len > 0 ) { arr = new Object [ len ] ; for ( int i = 0 ; i < len ; i ++ ) arr [ i ] = in . readObject ( ) ; }
apacheignite/ignite | if ( len > 0 ) { arr = new Class < ? > [ len ] ; for ( int i = 0 ; i < len ; i ++ ) arr [ i ] = ( Class < ? > ) in . readObject ( ) ; }
apacheignite/ignite | if ( locAddr . isAnyLocalAddress ( ) ) { IgniteBiTuple < Collection < String > , Collection < String > > res = cachedLocalAddr ; if ( res == null ) { List < InetAddress > localAddrs = new ArrayList < > ( ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) { for ( InetAddress addr : asIterable ( itf . getInetAddresses ( ) ) ) { if ( ! addr . isLinkLocalAddress ( ) ) localAddrs . add ( addr ) ; } } localAddrs = filterReachable ( localAddrs ) ; for ( InetAddress addr : localAddrs ) addresses ( addr , addrs , hostNames ) ; if ( F . isEmpty ( addrs ) ) throw new IgniteCheckedException ( " No ▁ network ▁ addresses ▁ found ▁ ( is ▁ networking ▁ enabled ? ) . " ) ; res = F . t ( addrs , hostNames ) ; cachedLocalAddr = res ; } return res ; }
apacheignite/ignite | @ Override public boolean verify ( String hostname , SSLSession ses ) { return true ; }
mifos/1.4.x | public OfficeListTagTest ( ) { super ( ) ; initialize ( ) ; }
mifos/1.4.x | public OfficeListTagTest ( String name ) { super ( name ) ; initialize ( ) ; }
mifos/1.4.x | private void initialize ( ) { MifosLogManager . configureLogging ( ) ; SpringUtil . initializeSpring ( ) ; }
mifos/1.4.x | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; result = new XmlBuilder ( ) ; userContext = TestUtils . makeUser ( ) ; }
mifos/1.4.x | public void testNoBranches ( ) throws Exception { new OfficeListTag ( ) . getBranchOffices ( result , null , userContext , null , " Branch " ) ; assertWellFormedFragment ( result . toString ( ) ) ; }
mifos/1.4.x | public void testBranches ( ) throws Exception { createSomeOffices ( ) ; Assert . assertEquals ( 1 , regional . getBranchOnlyChildren ( ) . size ( ) ) ; List < OfficeBO > officeList = new ArrayList < OfficeBO > ( ) ; officeList . add ( regional ) ; new OfficeListTag ( ) . getBranchOffices ( result , officeList , userContext , branch , " Branch " ) ; String html = result . toString ( ) ; assertWellFormedFragment ( html ) ; StringAssert . assertContains ( " Trinidad & amp ; Tobago " , html ) ; }
mifos/1.4.x | public void testNothingAboveBranches ( ) throws Exception { new OfficeListTag ( ) . getAboveBranches ( result , null , null , null , null ) ; Assert . assertEquals ( " " , result . toString ( ) ) ; }
mifos/1.4.x | public void testAboveBranches ( ) throws Exception { List < OfficeBO > offices = new ArrayList < OfficeBO > ( ) ; offices . add ( makeOffice ( " Trinidad & Tobago " , OfficeLevel . HEADOFFICE ) ) ; offices . add ( makeOffice ( " Ontario & Quebec " , OfficeLevel . REGIONALOFFICE ) ) ; offices . add ( makeOffice ( " Alberta " , OfficeLevel . REGIONALOFFICE ) ) ; offices . add ( makeOffice ( " Vancouver " , OfficeLevel . SUBREGIONALOFFICE ) ) ; offices . add ( makeOffice ( " Toronto & Ottawa " , OfficeLevel . SUBREGIONALOFFICE ) ) ; offices . add ( makeOffice ( " SoHo " , OfficeLevel . AREAOFFICE ) ) ; offices . add ( makeOffice ( " Tribeca & Chelsea " , OfficeLevel . AREAOFFICE ) ) ; new OfficeListTag ( ) . getAboveBranches ( result , offices , " Province ▁ < State > " , " County ▁ < Duchy > " , " Parish ▁ < City > " ) ; String html = result . toString ( ) ; assertWellFormedFragment ( html ) ; StringAssert . assertContains ( " Toronto & amp ; Ottawa " , html ) ; }
mifos/1.4.x | public void testAssertWellFormed ( ) throws Exception { assertWellFormedFragment ( " < foo ▁ / > " ) ; assertWellFormedFragment ( " x ▁ y ▁ z " ) ; assertWellFormedFragment ( " x ▁ < p > this ▁ < b > shows ▁ it ▁ off < / b > < / p > ▁ z " ) ; try { assertWellFormedFragment ( " < unclosed > " ) ; Assert . fail ( " Didn ' t ▁ get ▁ assertion ▁ failure " ) ; } catch ( DocumentException e ) { } }
mifos/1.4.x | public void testGetLink ( ) throws Exception { OfficeListTag tag = new OfficeListTag ( " action " , " method " , " flow " ) ; XmlBuilder link = tag . getLink ( ( short ) 234 , " My ▁ Office " ) ; Assert . assertEquals ( " < a ▁ href = \" action ? method = method & amp ; " + " office . officeId = 234 & amp ; office . officeName = My % 20Office & amp ; " + " officeId = 234 & amp ; officeName = My % 20Office & amp ; " + " currentFlowKey = flow \" > My ▁ Office < / a > " , link . getOutput ( ) ) ; }
mifos/1.4.x | public void testGetOfficeListOnlyBranchs ( ) throws Exception { createSomeOffices ( ) ; OfficeListTag tag = new OfficeListTag ( " action " , " method " , " flow " ) ; tag . setOnlyBranchOffices ( " onlybranchOffices " ) ; String html = tag . getOfficeList ( userContext , headRegionalBranch ( ) , branch , Collections . singletonList ( regional ) , headRegional ( ) ) ; StringAssert . assertNotContains ( " East & amp ; West ▁ Indies " , html ) ; StringAssert . assertContains ( " West ▁ Indies ▁ Only " , html ) ; StringAssert . assertContains ( " Trinidad & amp ; Tobago " , html ) ; }
mifos/1.4.x | public void testGetOfficeListAllOffices ( ) throws Exception { createSomeOffices ( ) ; OfficeListTag tag = new OfficeListTag ( " action " , " method " , " flow " ) ; tag . setOnlyBranchOffices ( null ) ; String html = tag . getOfficeList ( userContext , headRegionalBranch ( ) , branch , Collections . singletonList ( regional ) , headRegional ( ) ) ; StringAssert . assertContains ( " East & amp ; West ▁ Indies " , html ) ; StringAssert . assertContains ( " West ▁ Indies ▁ Only " , html ) ; StringAssert . assertContains ( " Trinidad & amp ; Tobago " , html ) ; }
mifos/1.4.x | private List < OfficeView > headRegionalBranch ( ) { List < OfficeView > levels = new ArrayList < OfficeView > ( ) ; levels . add ( new OfficeView ( null , null , OfficeLevel . HEADOFFICE , " Head " , 0 ) ) ; levels . add ( new OfficeView ( null , null , OfficeLevel . REGIONALOFFICE , " Regional " , 0 ) ) ; levels . add ( new OfficeView ( null , null , OfficeLevel . BRANCHOFFICE , " Branch " , 0 ) ) ; return Collections . unmodifiableList ( levels ) ; }
mifos/1.4.x | private List < OfficeBO > headRegional ( ) { List < OfficeBO > offices = new ArrayList < OfficeBO > ( ) ; offices . add ( head ) ; offices . add ( regional ) ; return Collections . unmodifiableList ( offices ) ; }
mifos/1.4.x | private void createSomeOffices ( ) throws OfficeException { head = makeOffice ( " East & West ▁ Indies " , OfficeLevel . HEADOFFICE ) ; regional = makeOffice ( " West ▁ Indies ▁ Only " , OfficeLevel . REGIONALOFFICE , head ) ; head . setChildren ( Collections . singleton ( regional ) ) ; branch = OfficeBO . makeForTest ( userContext , OfficeLevel . BRANCHOFFICE , regional , "1.1.1.1" , null , " Trinidad & Tobago " , " Trin " , null , OperationMode . LOCAL_SERVER , OfficeStatus . ACTIVE ) ; regional . setChildren ( Collections . singleton ( branch ) ) ; }
mifos/1.4.x | private OfficeBO makeOffice ( String name , OfficeLevel level ) throws OfficeException { return makeOffice ( name , level , null ) ; }
mifos/1.4.x | private OfficeBO makeOffice ( String name , OfficeLevel level , OfficeBO parent ) throws OfficeException { String shortName = name . substring ( 0 , 3 ) ; return OfficeBO . makeForTest ( userContext , level , parent , "1.1" , null , name , shortName , null , OperationMode . LOCAL_SERVER , OfficeStatus . ACTIVE ) ; }
markovandooren/chameleon | public OpenTypeHierarchyAction ( int actionType , HierarchyView view ) { super ( " Open ▁ Type ▁ hierarchy " , AS_RADIO_BUTTON ) ; this . view = view ; String iconName ; String description ; if ( actionType == SUBTYPE ) { this . actionName = " Sub ▁ Type ▁ hierarchy " ; description = " Open ▁ the ▁ sub - type ▁ hierarchy ▁ of ▁ the ▁ type ▁ selected ▁ in ▁ the ▁ editor " ; iconName = " subtype _ hierarchy . gif " ; } else if ( actionType == SUPERTYPE ) { this . actionName = " Super ▁ Type ▁ hierarchy " ; description = " Open ▁ the ▁ super - type ▁ hierarchy ▁ of ▁ the ▁ type ▁ selected ▁ in ▁ the ▁ editor " ; iconName = " supertype _ hierarchy . gif " ; } else { throw new ChameleonProgrammerException ( " Action ▁ type ▁ not ▁ supported . ▁ Must ▁ be ▁ SUBTYPEHIERARCHY ▁ or ▁ SUPERTYPEHIERARCHY " ) ; } this . hierarchy_type = actionType ; setText ( description ) ; setToolTipText ( description ) ; setDescription ( description ) ; setImageDescriptor ( ChameleonEditorPlugin . getImageDescriptor ( iconName ) ) ; }
markovandooren/chameleon | @ Override public void run ( ) { run = ! run ; if ( run ) { Type rootType = getRootType ( ) ; ChameleonEditor editor = ChameleonEditor . getActiveEditor ( ) ; setEditor ( editor ) ; if ( rootType != null && editor != null ) { Language lang = editor . getDocument ( ) . language ( ) ; IContentProvider contentProvider ; if ( hierarchy_type == SUBTYPE ) { contentProvider = new SubTypeHierarchyContentProvider ( editor . getDocument ( ) . getProjectNature ( ) . getModel ( ) ) ; } else if ( hierarchy_type == SUPERTYPE ) { contentProvider = new SuperTypeHierarchyContentProvider ( ) ; } else { throw new ChameleonProgrammerException ( " Action ▁ type ▁ not ▁ supported . ▁ Must ▁ be ▁ SUBTYPEHIERARCHY ▁ or ▁ SUPERTYPEHIERARCHY " ) ; } view . getHierarchyViewer ( ) . setContentProvider ( contentProvider ) ; view . getHierarchyViewer ( ) . setLabelProvider ( new ChameleonLabelProvider ( lang , false , false , false ) ) ; view . getMemberViewer ( ) . setLabelProvider ( new ChameleonLabelProvider ( lang , true , false , false ) ) ; view . getHierarchyViewer ( ) . setInput ( new RootType ( rootType , getEditor ( ) ) ) ; view . getHierarchyViewer ( ) . setSelection ( new StructuredSelection ( rootType ) ) ; view . getLabel ( ) . setText ( actionName + " ▁ of ▁ type ▁ " + rootType . getFullyQualifiedName ( ) ) ; } else { if ( editor == null ) { ChameleonEditorPlugin . showMessageBox ( " No ▁ Chameleon ▁ editor ▁ found " , " The ▁ currently ▁ active ▁ editor ▁ must ▁ be ▁ a ▁ Chameleon ▁ editor . \n The ▁ Chameleon ▁ Type ▁ Hierarchy ▁ cannot ▁ be ▁ shown . " , SWT . ICON_ERROR ) ; } else if ( rootType == null ) { ChameleonEditorPlugin . showMessageBox ( " No ▁ type ▁ found " , " There ▁ is ▁ no ▁ type ▁ found ▁ whose ▁ type ▁ hierarchy ▁ must ▁ be ▁ shown . \n First ▁ select ▁ an ▁ appropriate ▁ type ▁ in ▁ the ▁ Chameleon ▁ editor . " , SWT . ICON_ERROR ) ; } } } }
markovandooren/chameleon | private Type getRootType ( ) { try { ChameleonEditor editor = getCurrentEditor ( ) ; setEditor ( editor ) ; if ( editor != null ) { ChameleonEditor chamEditor = editor ; EclipseDocument doc = chamEditor . getDocument ( ) ; ISelectionProvider selectionProvider = chamEditor . getSelectionProvider ( ) ; if ( selectionProvider != null ) { ISelection sel = selectionProvider . getSelection ( ) ; if ( sel instanceof TextSelection ) { TextSelection textSel = ( TextSelection ) sel ; final int offset = textSel . getOffset ( ) ; SafePredicate < EclipseEditorTag > predicate = new SafePredicate < EclipseEditorTag > ( ) { @ Override public boolean eval ( EclipseEditorTag editorTag ) { return editorTag . includes ( offset ) && ( ( editorTag . element ( ) instanceof Type ) || ( editorTag . element ( ) instanceof TypeReference ) ) ; } } ; Collection < EclipseEditorTag > tags = new TreeSet < EclipseEditorTag > ( EclipseEditorTag . lengthComparator ) ; doc . getEditorTagsWithPredicate ( predicate , tags ) ; if ( tags != null && tags . size ( ) > 0 ) { for ( EclipseEditorTag tag : tags ) { if ( tag != null && tag . element ( ) instanceof Type ) { return ( Type ) tag . element ( ) ; } else if ( tag != null && tag . element ( ) instanceof TypeReference ) { return ( ( TypeReference ) tag . element ( ) ) . getElement ( ) ; } } } } } return chamEditor . getDocument ( ) . document ( ) . lexical ( ) . descendants ( Type . class ) . iterator ( ) . next ( ) ; } } catch ( ModelException e ) { } return null ; }
markovandooren/chameleon | @ Override public void doubleClick ( DoubleClickEvent event ) { if ( event . getSelection ( ) instanceof IStructuredSelection ) { IStructuredSelection selection = ( IStructuredSelection ) event . getSelection ( ) ; Object firstObject = selection . getFirstElement ( ) ; if ( firstObject instanceof HierarchyTypeNode ) { try { Type type = ( ( HierarchyTypeNode ) firstObject ) . getType ( ) ; ChameleonEditor . showInEditor ( type , true , true , getEditor ( ) ) ; } catch ( ModelException e ) { e . printStackTrace ( ) ; } } else if ( firstObject instanceof Element ) { ChameleonEditor . showInEditor ( ( Element ) firstObject , true , true , getEditor ( ) ) ; } new TypeChangedListener ( view ) . selectionChanged ( view . getHierarchyViewer ( ) . getSelection ( ) ) ; } else if ( event . getSelection ( ) . isEmpty ( ) ) { getEditor ( ) . resetHighlightRange ( ) ; } }
markovandooren/chameleon | @ Override public void selectionChanged ( SelectionChangedEvent event ) { if ( event . getSelection ( ) instanceof IStructuredSelection ) { IStructuredSelection selection = ( IStructuredSelection ) event . getSelection ( ) ; Object firstObject = selection . getFirstElement ( ) ; if ( firstObject instanceof HierarchyTypeNode ) { try { Type type = ( ( HierarchyTypeNode ) firstObject ) . getType ( ) ; ChameleonEditor . showInEditor ( type , false , false , getEditor ( ) ) ; } catch ( ModelException e ) { e . printStackTrace ( ) ; } } else if ( firstObject instanceof Element ) { ChameleonEditor . showInEditor ( ( Element ) firstObject , false , false , getEditor ( ) ) ; } } else if ( event . getSelection ( ) . isEmpty ( ) ) { getEditor ( ) . resetHighlightRange ( ) ; } }
markovandooren/chameleon | protected ChameleonEditor getEditor ( ) { if ( editor == null ) editor = ChameleonEditor . getActiveEditor ( ) ; return editor ; }
markovandooren/chameleon | protected ChameleonEditor getCurrentEditor ( ) { ChameleonEditor currEditor = ChameleonEditor . getActiveEditor ( ) ; if ( currEditor != null ) { editor = currEditor ; } return editor ; }
markovandooren/chameleon | protected void setEditor ( ChameleonEditor editor ) { this . editor = editor ; }
guedeWebGate/org.openntf.base | FieldChoicesdialogs ( String v ) { value = v ; }
guedeWebGate/org.openntf.base | public String value ( ) { return value ; }
maxalthoff/intro-to-java-exercises | public Histogram ( ) { this . counts = new int [ 26 ] ; maxValue = 0 ; paneHeight = 400 ; drawHistogram ( ) ; }
maxalthoff/intro-to-java-exercises | public void drawHistogram ( ) { getChildren ( ) . clear ( ) ; for ( int i = 0 , x = 0 ; i < counts . length ; i ++ , x += 25 ) { double rHeight = ( double ) counts [ i ] / maxValue * paneHeight ; Rectangle r = new Rectangle ( 20 , rHeight ) ; r . setX ( x ) ; r . setY ( paneHeight - rHeight ) ; r . setFill ( Color . WHITE ) ; r . setStroke ( Color . BLACK ) ; Text t = new Text ( ( char ) ( i + 65 ) + " " ) ; t . setX ( x + 5 ) ; t . setY ( paneHeight + 15 ) ; getChildren ( ) . addAll ( r , t ) ; } }
maxalthoff/intro-to-java-exercises | public void setCounts ( int [ ] counts ) { this . counts = counts ; maxValue = getMaxValue ( ) ; drawHistogram ( ) ; }
maxalthoff/intro-to-java-exercises | public int getMaxValue ( ) { int m = counts [ 0 ] ; for ( int i = 1 ; i < counts . length ; i ++ ) { if ( counts [ i ] > m ) { m = counts [ i ] ; } } return m ; }
sapirgolan/MFIBlocking | private CandidateMatchComparator ( ) { }
sapirgolan/MFIBlocking | @ Override public int compare ( CandidateMatch o1 , CandidateMatch o2 ) { return ( int ) ( Math . signum ( o1 . getScore ( ) - o2 . getScore ( ) ) ) ; }
55minutes/fiftyfive-wicket-2.x | ( WebApplication application , WebRequest request , Response response ) { super ( application , request , response ) ; }
55minutes/fiftyfive-wicket-2.x | @ Override protected void logRuntimeException ( RuntimeException e ) { LoggingUtils . logRuntimeException ( LOGGER , e ) ; }
zuoweitan/Hitalk | @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( 4 , 2 + 2 ) ; }
zuoweitan/Hitalk | @ Test public void hello_world ( ) { System . out . print ( " Hello ▁ World " ) ; }
zuoweitan/Hitalk | @ Test public void textLong ( ) { System . out . println ( getAndAddRequest ( new AtomicLong ( ) , Long . MAX_VALUE ) ) ; }
zuoweitan/Hitalk | @ Test public void testRetrofit ( ) { }
zuoweitan/Hitalk | @ Test public void testPath ( ) { String path = " dadad / dadad / adasdasdasd . jpg " ; Pattern pattern = Pattern . compile ( " . * \\ . jpg | \\ . png | \\ . gif | \\ . bmp " ) ; Matcher matcher = pattern . matcher ( path . toLowerCase ( ) ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . groupCount ( ) ) ; } }
zuoweitan/Hitalk | @ Test public void testGson ( ) throws ClassNotFoundException { HashMap < String , Integer > entries = new HashMap < > ( ) ; entries . put ( " abc " , 1 ) ; System . out . println ( new Gson ( ) . toJson ( entries ) ) ; HashMap hashMap = new Gson ( ) . fromJson ( new Gson ( ) . toJson ( entries ) , entries . getClass ( ) ) ; Type type = new TypeToken < HashMap < String , Integer > > ( ) { } . getType ( ) ; }
zuoweitan/Hitalk | protected AVObject encoder ( ) { return null ; }
zuoweitan/Hitalk | protected A decoder ( AVObject avObject ) { return null ; }
zuoweitan/Hitalk | @ Override public String toString ( ) { return a + " : " + b ; }
zuoweitan/Hitalk | @ Override protected AVObject encoder ( ) { AVObject avObject = new AVObject ( ) ; avObject . put ( " b " , b ) ; return avObject ; }
zuoweitan/Hitalk | @ Override protected A decoder ( AVObject avObject ) { return null ; }
zuoweitan/Hitalk | @ Test public void testSync ( ) throws InterruptedException { System . out . println ( " stat ▁ at ▁ time ▁ = ▁ " + new Date ( ) ) ; final CountDownLatch lock = new CountDownLatch ( 1 ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { Thread . sleep ( 5000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } lock . countDown ( ) ; } } ) . start ( ) ; lock . await ( ) ; System . out . println ( " do ▁ next ▁ at ▁ time ▁ = ▁ " + new Date ( ) ) ; }
zuoweitan/Hitalk | public Parent ( ) { this ( 0 ) ; }
zuoweitan/Hitalk | public Parent ( int i ) { this . i = i ; printi ( ) ; }
zuoweitan/Hitalk | protected void printi ( ) { i += 1 ; System . out . println ( i ) ; System . out . println ( this ) ; }
zuoweitan/Hitalk | public Child ( ) { }
zuoweitan/Hitalk | public Child ( int i ) { super ( i ) ; System . out . println ( " HHHHHHHH " ) ; }
zuoweitan/Hitalk | @ Override protected void printi ( ) { super . printi ( ) ; }
zuoweitan/Hitalk | @ Test public void testClass ( ) { new Child ( ) ; }
zuoweitan/Hitalk | @ Test public void testClassReflect ( ) { Class < ? > [ ] declaredClasses = getClass ( ) . getDeclaredClasses ( ) ; for ( Class < ? > declaredClass : declaredClasses ) { LayoutInject layoutInject = declaredClass . getAnnotation ( LayoutInject . class ) ; if ( layoutInject != null ) { System . out . println ( layoutInject . name ( ) ) ; } } }
zuoweitan/Hitalk | @ Test public void testMd5 ( ) { System . out . println ( Md5Utils . stringToMD5 ( " 重庆邮电大学 " ) ) ; }
zuoweitan/Hitalk | @ Test public void testSparseArray ( ) { SparseArray array = new SparseArray ( ) ; array . put ( 1 , "12" ) ; array . put ( 2 , 3 ) ; System . out . println ( array . get ( 1 ) . getClass ( ) ) ; System . out . println ( array . get ( 2 ) . getClass ( ) ) ; }
zuoweitan/Hitalk | @ Test public void testArrayList ( ) { ArrayList a = new ArrayList ( ) ; a . add ( 1 ) ; System . out . println ( a ) ; a . remove ( 1 ) ; a . add ( 0 , 1 ) ; System . out . println ( a ) ; }
zuoweitan/Hitalk | @ Test public void testPinyin ( ) { for ( int i = 0 ; i < 100000 ; i ++ ) { String aa = CharacterParser . getInstance ( ) . getSelling ( " 无非凡 " ) ; if ( ! aa . startsWith ( " wu " ) ) { System . err . println ( " error " ) ; break ; } } new Thread ( ( ) -> { for ( int i = 0 ; i < 100000 ; i ++ ) { String aa = CharacterParser . getInstance ( ) . getSelling ( " 无非凡 " ) ; if ( ! aa . startsWith ( " wu " ) ) { System . err . println ( " error ▁ 2" ) ; break ; } } } ) . start ( ) ; new Thread ( ( ) -> { for ( int i = 0 ; i < 100000 ; i ++ ) { String aa = CharacterParser . getInstance ( ) . getSelling ( " 无非凡 " ) ; if ( ! aa . startsWith ( " wu " ) ) { System . err . println ( " error ▁ 3" ) ; break ; } } } ) . start ( ) ; }
zuoweitan/Hitalk | @ Test public void testStateMachine ( ) { TestStateMachine testStateMachine = new TestStateMachine ( " TestStateMachine " ) ; testStateMachine . sendMessage ( 1 ) ; }
zuoweitan/Hitalk | protected TestStateMachine ( String name ) { super ( name ) ; addState ( aState ) ; addState ( bState , aState ) ; addState ( cState , bState ) ; addState ( dState , bState ) ; addState ( eState , aState ) ; setInitialState ( cState ) ; start ( ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " AState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " AState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " BState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " BState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " CState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public boolean processMessage ( Message msg ) { transitionTo ( dState ) ; return super . processMessage ( msg ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " CState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " DState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " DState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " EState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " EState ▁ exit " ) ; }
JetBrains/TeamCity.VsOnline.WorkItems | @ NotNull public IssueData parse ( @ NotNull final String issueString ) throws Exception { try { final Map map = new ObjectMapper ( ) . readValue ( issueString , Map . class ) ; return parseIssueData ( map ) ; } catch ( Exception e ) { LOG . error ( " Could ▁ not ▁ parse ▁ issue ▁ json . ▁ Error ▁ message ▁ is : ▁ " + e . getMessage ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Could ▁ not ▁ parse ▁ issue ▁ json . ▁ Response ▁ ( cut ▁ to ▁ first ▁ 100 ▁ symbols ) : ▁ [ " + issueString . substring ( Math . min ( 100 , issueString . length ( ) - 1 ) ) ) ; } throw e ; } }
JetBrains/TeamCity.VsOnline.WorkItems | private IssueData parseIssueData ( @ NotNull final Map map ) throws Exception { final Map fields = getContainer ( map , Containers . CONTAINER_FIELDS ) ; final Map links = getContainer ( map , Containers . CONTAINER_LINKS ) ; final Map html = getContainer ( links , Containers . CONTAINER_HTML ) ; final String href = getField ( html , Fields . FIELD_HREF ) ; final String actualProject = getField ( fields , Fields . FIELD_PROJECT ) ; return new IssueData ( String . valueOf ( map . get ( " id " ) ) , CollectionsUtil . asMap ( IssueData . SUMMARY_FIELD , getField ( fields , Fields . FIELD_SUMMARY ) , IssueData . STATE_FIELD , getField ( fields , Fields . FIELD_STATE ) , IssueData . TYPE_FIELD , getField ( fields , Fields . FIELD_TYPE ) , IssueDataFields . ID_FIELD_PROJECT , actualProject , IssueDataFields . ID_FIELD_HREF , href ) , false , " Feature " . equals ( getField ( fields , Fields . FIELD_TYPE ) ) , href ) ; }
JetBrains/TeamCity.VsOnline.WorkItems | private Map getContainer ( final Map map , @ NotNull final String name ) { return ( Map ) map . get ( name ) ; }
JetBrains/TeamCity.VsOnline.WorkItems | private String getField ( final Map map , @ NotNull final String name ) { return ( String ) map . get ( name ) ; }
aws/aws-sdk-java | public void setReplacementStrategy ( String replacementStrategy ) { this . replacementStrategy = replacementStrategy ; }
aws/aws-sdk-java | public String getReplacementStrategy ( ) { return this . replacementStrategy ; }
aws/aws-sdk-java | public SpotCapacityRebalance withReplacementStrategy ( String replacementStrategy ) { setReplacementStrategy ( replacementStrategy ) ; return this ; }
aws/aws-sdk-java | public SpotCapacityRebalance withReplacementStrategy ( ReplacementStrategy replacementStrategy ) { this . replacementStrategy = replacementStrategy . toString ( ) ; return this ; }
aws/aws-sdk-java | public void setTerminationDelay ( Integer terminationDelay ) { this . terminationDelay = terminationDelay ; }
aws/aws-sdk-java | public Integer getTerminationDelay ( ) { return this . terminationDelay ; }
aws/aws-sdk-java | public SpotCapacityRebalance withTerminationDelay ( Integer terminationDelay ) { setTerminationDelay ( terminationDelay ) ; return this ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getReplacementStrategy ( ) != null ) sb . append ( " ReplacementStrategy : ▁ " ) . append ( getReplacementStrategy ( ) ) . append ( " , " ) ; if ( getTerminationDelay ( ) != null ) sb . append ( " TerminationDelay : ▁ " ) . append ( getTerminationDelay ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof SpotCapacityRebalance == false ) return false ; SpotCapacityRebalance other = ( SpotCapacityRebalance ) obj ; if ( other . getReplacementStrategy ( ) == null ^ this . getReplacementStrategy ( ) == null ) return false ; if ( other . getReplacementStrategy ( ) != null && other . getReplacementStrategy ( ) . equals ( this . getReplacementStrategy ( ) ) == false ) return false ; if ( other . getTerminationDelay ( ) == null ^ this . getTerminationDelay ( ) == null ) return false ; if ( other . getTerminationDelay ( ) != null && other . getTerminationDelay ( ) . equals ( this . getTerminationDelay ( ) ) == false ) return false ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getReplacementStrategy ( ) == null ) ? 0 : getReplacementStrategy ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getTerminationDelay ( ) == null ) ? 0 : getTerminationDelay ( ) . hashCode ( ) ) ; return hashCode ; }
aws/aws-sdk-java | @ Override public SpotCapacityRebalance clone ( ) { try { return ( SpotCapacityRebalance ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
NationalSecurityAgency/ghidra | public ProgramDecisionTree ( ) { super ( ) ; List < Class < ? extends ProgramConstraint > > classes = ClassSearcher . getClasses ( ProgramConstraint . class ) ; for ( Class < ? extends ProgramConstraint > constraintClass : classes ) { try { ProgramConstraint contraint = constraintClass . newInstance ( ) ; registerConstraintType ( contraint . getName ( ) , constraintClass ) ; } catch ( Exception e ) { Msg . error ( this , " Can ' t ▁ create ▁ constraint ▁ instance ▁ for ▁ " + constraintClass . getName ( ) , e ) ; } } }
Swaathik/cellbase | public BuildCommandExecutor ( CliOptionsParser . BuildCommandOptions buildCommandOptions ) { super ( buildCommandOptions . commonOptions . logLevel , buildCommandOptions . commonOptions . verbose , buildCommandOptions . commonOptions . conf ) ; this . buildCommandOptions = buildCommandOptions ; if ( buildCommandOptions . input != null ) { input = Paths . get ( buildCommandOptions . input ) ; } if ( buildCommandOptions . output != null ) { output = Paths . get ( buildCommandOptions . output ) ; } if ( buildCommandOptions . common != null ) { common = Paths . get ( buildCommandOptions . common ) ; } else { common = input . getParent ( ) . getParent ( ) . resolve ( " common " ) ; } this . ensemblScriptsFolder = new File ( System . getProperty ( " basedir " ) + " / bin / ensembl - scripts / " ) ; this . proteinScriptsFolder = new File ( System . getProperty ( " basedir " ) + " / bin / protein / " ) ; }
Swaathik/cellbase | public void execute ( ) { try { checkParameters ( ) ; if ( ! Files . exists ( output ) ) { Files . createDirectories ( output ) ; } for ( CellBaseConfiguration . SpeciesProperties . Species sp : configuration . getAllSpecies ( ) ) { if ( buildCommandOptions . species . equalsIgnoreCase ( sp . getScientificName ( ) ) || buildCommandOptions . species . equalsIgnoreCase ( sp . getCommonName ( ) ) || buildCommandOptions . species . equalsIgnoreCase ( sp . getId ( ) ) ) { species = sp ; break ; } } if ( species == null ) { logger . error ( " Species ▁ ' { } ' ▁ not ▁ valid " , buildCommandOptions . species ) ; } if ( buildCommandOptions . data != null ) { String [ ] buildOptions ; if ( buildCommandOptions . data . equals ( " all " ) ) { buildOptions = new String [ ] { EtlCommons . GENOME_INFO_DATA , EtlCommons . GENOME_DATA , EtlCommons . GENE_DATA , EtlCommons . DISGENET_DATA , EtlCommons . HPO_DATA , EtlCommons . CONSERVATION_DATA , EtlCommons . REGULATION_DATA , EtlCommons . PROTEIN_DATA , EtlCommons . PPI_DATA , EtlCommons . PROTEIN_FUNCTIONAL_PREDICTION_DATA , EtlCommons . VARIATION_DATA , EtlCommons . VARIATION_FUNCTIONAL_SCORE_DATA , EtlCommons . CLINvar_DATA , EtlCommons . COSMIC_DATA , EtlCommons . GWAS_DATA , } ; } else { buildOptions = buildCommandOptions . data . split ( " , " ) ; } for ( int i = 0 ; i < buildOptions . length ; i ++ ) { String buildOption = buildOptions [ i ] ; logger . info ( " Building ▁ ' { } ' ▁ data " , buildOption ) ; CellBaseParser parser = null ; switch ( buildOption ) { case EtlCommons . GENOME_INFO_DATA : buildGenomeInfo ( ) ; break ; case EtlCommons . GENOME_DATA : parser = buildGenomeSequence ( ) ; break ; case EtlCommons . GENE_DATA : parser = buildGene ( ) ; break ; case EtlCommons . DISGENET_DATA : parser = buildDisgenet ( ) ; break ; case EtlCommons . HPO_DATA : parser = buildHpo ( ) ; break ; case EtlCommons . VARIATION_DATA : parser = buildVariation ( ) ; break ; case EtlCommons . VARIATION_FUNCTIONAL_SCORE_DATA : parser = buildCadd ( ) ; break ; case EtlCommons . REGULATION_DATA : parser = buildRegulation ( ) ; break ; case EtlCommons . PROTEIN_DATA : parser = buildProtein ( ) ; break ; case EtlCommons . PPI_DATA : parser = getInteractionParser ( ) ; break ; case EtlCommons . CONSERVATION_DATA : parser = buildConservation ( ) ; break ; case EtlCommons . DRUG_DATA : parser = buildDrugParser ( ) ; break ; case EtlCommons . CLINvar_DATA : parser = buildClinvar ( ) ; break ; case EtlCommons . COSMIC_DATA : parser = buildCosmic ( ) ; break ; case EtlCommons . GWAS_DATA : parser = buildGwas ( ) ; break ; default : logger . error ( " Build ▁ option ▁ ' " + buildCommandOptions . data + " ' ▁ is ▁ not ▁ valid " ) ; break ; } if ( parser != null ) { try { parser . parse ( ) ; } catch ( Exception e ) { logger . error ( " Error ▁ executing ▁ ' build ' ▁ command ▁ " + buildCommandOptions . data + " : ▁ " + e . getMessage ( ) , e ) ; } parser . disconnect ( ) ; } } } } catch ( ParameterException e ) { logger . error ( " Error ▁ parsing ▁ build ▁ command ▁ line ▁ parameters : ▁ " + e . getMessage ( ) , e ) ; } catch ( IOException e ) { logger . error ( e . getMessage ( ) ) ; } }
Swaathik/cellbase | private void copyVersionFiles ( List < Path > pathList ) { for ( Path path : pathList ) { try { Files . copy ( path , output . resolve ( path . getFileName ( ) ) , StandardCopyOption . REPLACE_EXISTING ) ; } catch ( IOException e ) { logger . warn ( " Version ▁ file ▁ { } ▁ not ▁ found ▁ - ▁ skipping " , path . toString ( ) ) ; } } }
Swaathik/cellbase | private void checkParameters ( ) throws IOException { if ( ! Files . exists ( input ) || ! Files . isDirectory ( input ) ) { throw new IOException ( " Input ▁ parameter ▁ ' " + input . toString ( ) + " ' ▁ does ▁ not ▁ exist ▁ or ▁ is ▁ not ▁ a ▁ directory " ) ; } if ( ! Files . exists ( common ) || ! Files . isDirectory ( common ) ) { throw new IOException ( " Common ▁ parameter ▁ ' " + common . toString ( ) + " ' ▁ does ▁ not ▁ exist ▁ or ▁ is ▁ not ▁ a ▁ directory " ) ; } }
Swaathik/cellbase | private void buildGenomeInfo ( ) { try { String outputFileName = output . resolve ( " genome _ info . json " ) . toAbsolutePath ( ) . toString ( ) ; List < String > args = new ArrayList < > ( ) ; args . addAll ( Arrays . asList ( " - - species " , species . getScientificName ( ) , " - o " , outputFileName , " - - ensembl - libs " , configuration . getDownload ( ) . getEnsembl ( ) . getLibs ( ) ) ) ; if ( ! configuration . getSpecies ( ) . getVertebrates ( ) . contains ( species ) && ! species . getScientificName ( ) . equals ( " Drosophila ▁ melanogaster " ) ) { args . add ( " - - phylo " ) ; args . add ( " no - vertebrate " ) ; } String geneInfoLogFileName = output . resolve ( " genome _ info . log " ) . toAbsolutePath ( ) . toString ( ) ; boolean downloadedGenomeInfo ; downloadedGenomeInfo = runCommandLineProcess ( ensemblScriptsFolder , " . / genome _ info . pl " , args , geneInfoLogFileName ) ; if ( downloadedGenomeInfo ) { logger . info ( outputFileName + " ▁ created ▁ OK " ) ; } else { logger . error ( " Genome ▁ info ▁ for ▁ " + species . getScientificName ( ) + " ▁ cannot ▁ be ▁ downloaded " ) ; } } catch ( IOException | InterruptedException e ) { e . printStackTrace ( ) ; } }
Swaathik/cellbase | private CellBaseParser buildGenomeSequence ( ) { copyVersionFiles ( Collections . singletonList ( input . resolve ( " genome / genomeVersion . json " ) ) ) ; Path fastaFile = getFastaReferenceGenome ( ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " genome _ sequence " ) ; return new GenomeSequenceFastaParser ( fastaFile , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildGene ( ) { Path geneFolderPath = input . resolve ( " gene " ) ; copyVersionFiles ( Arrays . asList ( geneFolderPath . resolve ( " geneDrug / dgidbVersion . json " ) , geneFolderPath . resolve ( " ensemblCoreVersion . json " ) , geneFolderPath . resolve ( " uniprotXrefVersion . json " ) , geneFolderPath . resolve ( common . resolve ( " expression / geneExpressionAtlasVersion . json " ) ) , geneFolderPath . resolve ( " hpoVersion . json " ) , geneFolderPath . resolve ( " disgenetVersion . json " ) ) ) ; Path genomeFastaFilePath = getFastaReferenceGenome ( ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " gene " ) ; return new GeneParser ( geneFolderPath , genomeFastaFilePath , species , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildVariation ( ) { Path variationFolderPath = input . resolve ( " variation " ) ; copyVersionFiles ( Arrays . asList ( variationFolderPath . resolve ( " ensemblVariationVersion . json " ) ) ) ; CellBaseFileSerializer serializer = new CellBaseJsonFileSerializer ( output , null , true , true , true ) ; return new VariationParser ( variationFolderPath , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildCadd ( ) { Path variationFunctionalScorePath = input . resolve ( " variation _ functional _ score " ) ; copyVersionFiles ( Arrays . asList ( variationFunctionalScorePath . resolve ( " caddVersion . json " ) ) ) ; Path caddFilePath = variationFunctionalScorePath . resolve ( CADD_INPUT_FILE_NAME ) ; CellBaseFileSerializer serializer = new CellBaseJsonFileSerializer ( output , " cadd " ) ; return new CaddScoreParser ( caddFilePath , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildRegulation ( ) { Path regulatoryRegionFilesDir = input . resolve ( " regulation " ) ; copyVersionFiles ( Arrays . asList ( regulatoryRegionFilesDir . resolve ( " ensemblRegulationVersion . json " ) , common . resolve ( " mirbase / mirbaseVersion . json " ) , regulatoryRegionFilesDir . resolve ( " targetScanVersion . json " ) , regulatoryRegionFilesDir . resolve ( " miRTarBaseVersion . json " ) ) ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " regulatory _ region " ) ; return new RegulatoryRegionParser ( regulatoryRegionFilesDir , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildProtein ( ) { Path proteinFolder = common . resolve ( " protein " ) ; copyVersionFiles ( Arrays . asList ( proteinFolder . resolve ( " uniprotVersion . json " ) , proteinFolder . resolve ( " interproVersion . json " ) ) ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " protein " ) ; return new ProteinParser ( proteinFolder . resolve ( " uniprot _ chunks " ) , common . resolve ( " protein " ) . resolve ( " protein2ipr . dat . gz " ) , species . getScientificName ( ) , serializer ) ; }
Swaathik/cellbase | if ( proteinFunctionPredictionMatricesObtaines ) { logger . info ( " Protein ▁ function ▁ prediction ▁ matrices ▁ created ▁ OK " ) ; }
Swaathik/cellbase | private CellBaseParser getInteractionParser ( ) { Path proteinFolder = common . resolve ( " protein " ) ; Path psimiTabFile = proteinFolder . resolve ( " intact . txt " ) ; copyVersionFiles ( Arrays . asList ( proteinFolder . resolve ( " intactVersion . json " ) ) ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " protein _ protein _ interaction " ) ; return new InteractionParser ( psimiTabFile , species . getScientificName ( ) , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildDrugParser ( ) { throw new ParameterException ( " ' drug ' ▁ builder ▁ is ▁ not ▁ implemented ▁ yet " ) ; }
Swaathik/cellbase | private CellBaseParser buildConservation ( ) { Path conservationFilesDir = input . resolve ( " conservation " ) ; copyVersionFiles ( Arrays . asList ( conservationFilesDir . resolve ( " gerpVersion . json " ) , conservationFilesDir . resolve ( " phastConsVersion . json " ) , conservationFilesDir . resolve ( " phyloPVersion . json " ) ) ) ; int conservationChunkSize = MongoDBCollectionConfiguration . CONSERVATION_CHUNK_SIZE ; CellBaseFileSerializer serializer = new CellBaseJsonFileSerializer ( output ) ; return new ConservationParser ( conservationFilesDir , conservationChunkSize , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildClinvar ( ) { Path clinvarFolder = input . resolve ( " clinical " ) ; copyVersionFiles ( Arrays . asList ( clinvarFolder . resolve ( " clinvarVersion . json " ) ) ) ; Path clinvarFile = clinvarFolder . resolve ( " ClinVar . xml . gz " ) ; Path clinvarSummaryFile = clinvarFolder . resolve ( " variant _ summary . txt . gz " ) ; Path efosFilePath = clinvarFolder . resolve ( " ClinVar _ Traits _ EFO _ Names . csv " ) ; if ( ! efosFilePath . toFile ( ) . exists ( ) ) { efosFilePath = null ; } String assembly = buildCommandOptions . assembly ; checkMandatoryOption ( " assembly " , assembly ) ; if ( ! assembly . equals ( ClinVarParser . GRCH37_ASSEMBLY ) && ! assembly . equals ( ClinVarParser . GRCH38_ASSEMBLY ) ) { throw new ParameterException ( " Assembly ▁ ' " + assembly + " ' ▁ is ▁ not ▁ valid . ▁ Possible ▁ values : ▁ " + ClinVarParser . GRCH37_ASSEMBLY + " , ▁ " + ClinVarParser . GRCH38_ASSEMBLY ) ; } CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " clinvar " ) ; return new ClinVarParser ( clinvarFile , clinvarSummaryFile , efosFilePath , assembly , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildCosmic ( ) { Path cosmicFilePath = input . resolve ( " CosmicMutantExport . tsv " ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " cosmic " ) ; return new CosmicParser ( cosmicFilePath , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildGwas ( ) throws IOException { Path inputDir = getInputDirFromCommandLine ( ) . resolve ( " clinical " ) ; copyVersionFiles ( Arrays . asList ( inputDir . resolve ( " gwasVersion . json " ) ) ) ; Path gwasFile = inputDir . resolve ( GWAS_INPUT_FILE_NAME ) ; FileUtils . checkPath ( gwasFile ) ; Path dbsnpFile = inputDir . resolve ( DBSNP_INPUT_FILE_NAME ) ; FileUtils . checkPath ( dbsnpFile ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " gwas " ) ; return new GwasParser ( gwasFile , dbsnpFile , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildDisgenet ( ) throws IOException { Path inputDir = getInputDirFromCommandLine ( ) . resolve ( " gene _ disease _ association " ) ; copyVersionFiles ( Collections . singletonList ( inputDir . resolve ( " disgenetVersion . json " ) ) ) ; Path disgenetFile = inputDir . resolve ( DISGENET_INPUT_FILE_NAME ) ; FileUtils . checkPath ( disgenetFile ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " disgenet " ) ; return new DisgenetParser ( disgenetFile , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildHpo ( ) throws IOException { Path inputDir = getInputDirFromCommandLine ( ) . resolve ( " gene _ disease _ association " ) ; copyVersionFiles ( Collections . singletonList ( inputDir . resolve ( " hpoVersion . json " ) ) ) ; Path hpoFilePath = inputDir . resolve ( HPO_INPUT_FILE_NAME ) ; FileUtils . checkPath ( hpoFilePath ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " hpo " ) ; return new DisgenetParser ( hpoFilePath , serializer ) ; }
Swaathik/cellbase | private Path getInputDirFromCommandLine ( ) { File inputDirectory = new File ( input . toString ( ) ) ; if ( inputDirectory . exists ( ) ) { if ( inputDirectory . isDirectory ( ) ) { return input ; } else { throw new ParameterException ( " ' " + input + " ' ▁ is ▁ not ▁ a ▁ directory " ) ; } } else { throw new ParameterException ( " Folder ▁ ' " + input + " ' ▁ doesn ' t ▁ exist " ) ; } }
Swaathik/cellbase | private Path getFastaReferenceGenome ( ) { Path fastaFile = null ; try { DirectoryStream < Path > stream = Files . newDirectoryStream ( input . resolve ( " genome " ) , entry -> { return entry . toString ( ) . endsWith ( " . fa . gz " ) ; } ) ; for ( Path entry : stream ) { fastaFile = entry ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return fastaFile ; }
Swaathik/cellbase | private void checkMandatoryOption ( String option , String value ) { if ( value == null ) { throw new ParameterException ( " ' " + option + " ' ▁ option ▁ is ▁ mandatory ▁ for ▁ ' " + buildCommandOptions . data + " ' ▁ builder " ) ; } }
Buzzardo/spring-boot | BindException ( ConfigurationPropertyName name , Bindable < ? > target , ConfigurationProperty property , Throwable cause ) { super ( buildMessage ( name , target ) , cause ) ; this . name = name ; this . target = target ; this . property = property ; }
Buzzardo/spring-boot | public ConfigurationPropertyName getName ( ) { return this . name ; }
Buzzardo/spring-boot | public Bindable < ? > getTarget ( ) { return this . target ; }
Buzzardo/spring-boot | public ConfigurationProperty getProperty ( ) { return this . property ; }
Buzzardo/spring-boot | @ Override public Origin getOrigin ( ) { return Origin . from ( this . name ) ; }
pgorla/usergrid | @ Autowired public void setEntityManagerFactory ( EntityManagerFactory emf ) { this . emf = emf ; }
pgorla/usergrid | @ Autowired public void setManagementService ( ManagementService managementService ) { this . managementService = managementService ; }
pgorla/usergrid | public SignInAsProvider facebook ( Application application ) { FacebookProvider facebookProvider = new FacebookProvider ( emf . getEntityManager ( application . getUuid ( ) ) , managementService ) ; facebookProvider . configure ( ) ; return facebookProvider ; }
pgorla/usergrid | public SignInAsProvider foursquare ( Application application ) { FoursquareProvider foursquareProvider = new FoursquareProvider ( emf . getEntityManager ( application . getUuid ( ) ) , managementService ) ; foursquareProvider . configure ( ) ; return foursquareProvider ; }
pgorla/usergrid | public SignInAsProvider pingident ( Application application ) { PingIdentityProvider pingIdentityProvider = new PingIdentityProvider ( emf . getEntityManager ( application . getUuid ( ) ) , managementService ) ; pingIdentityProvider . configure ( ) ; return pingIdentityProvider ; }
Andrevmatias/Compilador | public IdentificadorParametro ( String nome , int deslocamento , Tipo tipo , TipoPassagemParametro tipoPassagem ) { super ( nome ) ; this . deslocamento = deslocamento ; this . tipo = tipo ; this . tipoPassagem = tipoPassagem ; }
Andrevmatias/Compilador | public int getDeslocamento ( ) { return deslocamento ; }
Andrevmatias/Compilador | public Tipo getTipo ( ) { return tipo ; }
Andrevmatias/Compilador | public TipoPassagemParametro getTipoPassagem ( ) { return tipoPassagem ; }
Andrevmatias/Compilador | public void setDeslocamento ( int deslocamento ) { this . deslocamento = deslocamento ; }
Andrevmatias/Compilador | public void setTipo ( Tipo tipo ) { this . tipo = tipo ; }
Andrevmatias/Compilador | public void setTipoPassagem ( TipoPassagemParametro tipoPassagem ) { this . tipoPassagem = tipoPassagem ; }
arminghofrani/chalkboard | public TimetableClassList ( Context context , ArrayList < StandardClass > classesArrayList ) { layoutInflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; this . classesArrayList = classesArrayList ; }
arminghofrani/chalkboard | public void setClassesArrayList ( ArrayList < StandardClass > update ) { classesArrayList . clear ( ) ; classesArrayList . addAll ( update ) ; notifyDataSetChanged ( ) ; }
arminghofrani/chalkboard | @ Override public int getCount ( ) { return classesArrayList . size ( ) ; }
arminghofrani/chalkboard | @ Override public Object getItem ( int position ) { return classesArrayList . get ( position ) ; }
arminghofrani/chalkboard | @ Override public long getItemId ( int position ) { return position ; }
arminghofrani/chalkboard | @ Override public View getView ( int position , View convertView , ViewGroup parent ) { final StandardClass standardClass = classesArrayList . get ( position ) ; boolean subtitle = false ; if ( standardClass . hasLocation ( ) ) { convertView = layoutInflater . inflate ( R . layout . view_timed_class_child_with_subtitle , parent , false ) ; subtitle = true ; } else if ( standardClass . hasTeacher ( ) ) { convertView = layoutInflater . inflate ( R . layout . view_timed_class_child_with_subtitle , parent , false ) ; subtitle = true ; } else { convertView = layoutInflater . inflate ( R . layout . view_timed_class_child_without_subtitle , parent , false ) ; } ( ( TextView ) convertView . findViewById ( subtitle ? R . id . view_timed_class_child_with_subtitle_title_text_view : R . id . view_timed_class_child_without_subtitle_title_text_view ) ) . setText ( standardClass . getName ( ) ) ; if ( subtitle ) { if ( standardClass . hasLocation ( ) ) { if ( standardClass . hasTeacher ( ) ) ( ( TextView ) convertView . findViewById ( R . id . view_timed_class_child_with_subtitle_subtitle_text_view ) ) . setText ( standardClass . getLocation ( ) + " ▁ • ▁ " + standardClass . getTeacher ( ) ) ; else ( ( TextView ) convertView . findViewById ( R . id . view_timed_class_child_with_subtitle_subtitle_text_view ) ) . setText ( standardClass . getLocation ( ) ) ; } else { ( ( TextView ) convertView . findViewById ( R . id . view_timed_class_child_with_subtitle_subtitle_text_view ) ) . setText ( standardClass . getTeacher ( ) ) ; } } ( ( TextView ) convertView . findViewById ( subtitle ? R . id . view_timed_class_child_with_subtitle_time_text_view : R . id . view_timed_class_child_without_subtitle_time_text_view ) ) . setText ( standardClass . getStartTimeString ( true ) + " \n " + standardClass . getEndTimeString ( true ) ) ; ( ( ImageView ) convertView . findViewById ( subtitle ? R . id . view_timed_class_child_with_subtitle_color_indicator_image_view : R . id . view_timed_class_child_without_subtitle_color_indicator_image_view ) ) . setColorFilter ( standardClass . getColor ( ) ) ; return convertView ; }
camunda/camunda-bpm-platform | @ Test public void testDeployProcessArchive ( ) { Assert . assertNotNull ( processEngineService . getProcessEngine ( " engine1" ) ) ; }
trejkaz/derby | public String getModuleToTestProtocolName ( ) { return AccessFactory . MODULE ; }
trejkaz/derby | protected void runTests ( ) throws T_Fail { AccessFactory store = null ; TransactionController tc = null ; boolean pass = false ; out . println ( " executing ▁ heap ▁ test " ) ; if ( startParams == null ) { startParams = new Properties ( ) ; } startParams . put ( Property . NO_AUTO_BOOT , Boolean . TRUE . toString ( ) ) ; startParams . put ( Property . DELETE_ON_CREATE , Boolean . TRUE . toString ( ) ) ; startParams = T_Util . setEncryptionParam ( startParams ) ; try { store = ( AccessFactory ) createPersistentService ( getModuleToTestProtocolName ( ) , testService , startParams ) ; } catch ( StandardException mse ) { throw T_Fail . exceptionFail ( mse ) ; } if ( store == null ) { throw T_Fail . testFailMsg ( getModuleToTestProtocolName ( ) + " ▁ service ▁ not ▁ started . " ) ; } REPORT ( " ( unitTestMain ) ▁ Testing ▁ " + testService ) ; try { tc = store . getTransaction ( getContextService ( ) . getCurrentContextManager ( ) ) ; if ( t_001 ( tc ) ) { pass = true ; } tc . commit ( ) ; tc . destroy ( ) ; } catch ( StandardException e ) { System . out . println ( " got ▁ an ▁ exception . " ) ; String msg = e . getMessage ( ) ; if ( msg == null ) msg = e . getClass ( ) . getName ( ) ; REPORT ( msg ) ; throw T_Fail . exceptionFail ( e ) ; } if ( ! pass ) throw T_Fail . testFailMsg ( " T _ Heap ▁ test ▁ failed " ) ; }
tjones879/YAPM | public RootLayoutController ( ) { rootBorderPane = new BorderPane ( ) ; rootBorderPane . setCenter ( createFeedScrollPane ( ) ) ; rootBorderPane . setBottom ( createBottomHBox ( ) ) ; rootBorderPane . setLeft ( createLeftVBox ( ) ) ; MediaPlayerUtil . getIsPlaying ( ) . addListener ( new ChangeListener < Boolean > ( ) { @ Override public void changed ( ObservableValue < ? extends Boolean > observable , Boolean oldValue , Boolean newValue ) { updatePlayPauseButton ( newValue ) ; } } ) ; MediaPlayerUtil . getIsMuted ( ) . addListener ( new ChangeListener < Boolean > ( ) { @ Override public void changed ( ObservableValue < ? extends Boolean > observable , Boolean oldValue , Boolean newValue ) { updateVolumeButton ( newValue ) ; } } ) ; MediaPlayerUtil . getMediaPlayer ( ) . currentTimeProperty ( ) . addListener ( new ChangeListener < Duration > ( ) { @ Override public void changed ( ObservableValue < ? extends Duration > observable , Duration oldValue , Duration newValue ) { updateProgressBar ( ( int ) newValue . toSeconds ( ) ) ; updateCurrPlayTime ( ( int ) newValue . toSeconds ( ) ) ; } } ) ; }
tjones879/YAPM | private ScrollPane createFeedScrollPane ( ) { ScrollPane feedScrollPane = new ScrollPane ( ) ; feedScrollPane . setFitToWidth ( true ) ; feedScrollPane . setHbarPolicy ( ScrollPane . ScrollBarPolicy . NEVER ) ; feedScrollPane . setVbarPolicy ( ScrollPane . ScrollBarPolicy . NEVER ) ; feedScrollPane . addEventFilter ( ScrollEvent . ANY , ( event ) -> { double pos = feedScrollPane . getVvalue ( ) ; double posMin = feedScrollPane . getVmin ( ) ; double posMax = feedScrollPane . getVmax ( ) ; if ( event . getDeltaY ( ) > 0 ) { feedScrollPane . setVvalue ( pos == posMin ? posMin : pos - .225 ) ; } else { feedScrollPane . setVvalue ( pos == posMax ? posMax : pos + .225 ) ; } event . consume ( ) ; } ) ; feedTilePane = new TilePane ( ) ; feedTilePane . setPadding ( new Insets ( 5 , 5 , 5 , 5 ) ) ; feedTilePane . setHgap ( 5 ) ; feedTilePane . setVgap ( 10 ) ; feedTilePane . setTileAlignment ( Pos . CENTER ) ; feedTilePane . setAlignment ( Pos . CENTER ) ; feedScrollPane . setContent ( feedTilePane ) ; return feedScrollPane ; }
tjones879/YAPM | private HBox createBottomHBox ( ) { currPlayThumbnail = createThumbnail ( MediaPlayerUtil . getCurrPlaying ( ) . getThumbnail ( ) . getUrl ( ) , 40 ) ; currPlayTitle = new Label ( MediaPlayerUtil . getCurrPlaying ( ) . getTitle ( ) ) ; currPlayTitle . setWrapText ( true ) ; currPlayTitle . setPrefWidth ( leftVBoxWidth - 52.5 ) ; AnchorPane progressNodes = new AnchorPane ( ) ; progressBar = new ProgressBar ( ) ; progressBar . setProgress ( .5 ) ; progressBar . setPrefHeight ( 3 ) ; progressBar . setMinHeight ( 3 ) ; progressBar . setMaxHeight ( 3 ) ; progressBar . setOnMouseClicked ( event -> handleProgressBarClick ( event ) ) ; currPlayTime = new Label ( "0:00" ) ; maxPlayTime = new Label ( "0:00" ) ; progressNodes . getChildren ( ) . addAll ( progressBar , currPlayTime , maxPlayTime ) ; progressNodes . setBottomAnchor ( progressBar , 22. ) ; progressNodes . setLeftAnchor ( progressBar , 2. ) ; progressNodes . setRightAnchor ( progressBar , 2. ) ; progressNodes . setBottomAnchor ( currPlayTime , 2. ) ; progressNodes . setLeftAnchor ( currPlayTime , 2. ) ; progressNodes . setBottomAnchor ( maxPlayTime , 2. ) ; progressNodes . setRightAnchor ( maxPlayTime , 2. ) ; skipBackButton = createIcon ( skipBackIcon ) ; skipBackButton . setOnMouseClicked ( event -> handleSkipBackButton ( ) ) ; playPauseButton = createIcon ( playIcon ) ; playPauseButton . setOnMouseClicked ( event -> handlePlayPauseButton ( ) ) ; skipForwardButton = createIcon ( skipForwardIcon ) ; skipForwardButton . setOnMouseClicked ( event -> handleSkipForwardButton ( ) ) ; volumeButton = createIcon ( speakerIcon ) ; volumeButton . setOnMouseClicked ( event -> handleVolumeButtonClick ( ) ) ; volumeButton . setOnMouseEntered ( event -> handleVolumeButtonEnter ( ) ) ; HBox hBox = new HBox ( currPlayThumbnail , currPlayTitle , progressNodes , skipBackButton , playPauseButton , skipForwardButton , volumeButton ) ; hBox . setHgrow ( progressNodes , Priority . ALWAYS ) ; hBox . setAlignment ( Pos . CENTER ) ; hBox . setSpacing ( 6 ) ; hBox . setPadding ( new Insets ( 2 , 2 , 2 , 1.5 ) ) ; return hBox ; }
tjones879/YAPM | private VBox createLeftVBox ( ) { SVGPath menuButton = new SVGPath ( ) ; menuButton . setContent ( " " ) ; TextField searchField = new TextField ( ) ; searchField . setOnKeyTyped ( event -> { } ) ; HBox searchBox = new HBox ( menuButton , searchField ) ; searchBox . setHgrow ( searchField , Priority . ALWAYS ) ; GridPane menuGrid = new GridPane ( ) ; menuGrid . addRow ( 0 ) ; menuGrid . addRow ( 1 ) ; menuGrid . addRow ( 2 ) ; playingListGrid = new GridPane ( ) ; ColumnConstraints thumbnailColumn = new ColumnConstraints ( ) ; thumbnailColumn . setPercentWidth ( 25 ) ; playingListGrid . getColumnConstraints ( ) . add ( 0 , thumbnailColumn ) ; ScrollPane playListScrollPane = new ScrollPane ( playingListGrid ) ; VBox vBox = new VBox ( ) ; vBox . getChildren ( ) . addAll ( searchBox , menuGrid , playListScrollPane ) ; vBox . setPrefWidth ( leftVBoxWidth ) ; vBox . setFillWidth ( true ) ; return vBox ; }
tjones879/YAPM | public void updatePlayingList ( List < Episode > playingEpisodes ) { int i = 0 ; for ( Episode episode : playingEpisodes ) { ImageView playingListThumbnail = createThumbnail ( episode . getThumbnail ( ) . getUrl ( ) , 50 ) ; Label playingListLabel = new Label ( episode . getTitle ( ) ) ; playingListGrid . addRow ( i , playingListThumbnail , playingListLabel ) ; i ++ ; } }
tjones879/YAPM | public void updateFeedTilePane ( List < Feed > feedList ) { for ( Feed feed : feedList ) { VBox vBox = new VBox ( ) ; vBox . setOnMouseClicked ( event -> { } ) ; ImageView feedThumbnail = createThumbnail ( feed . getThumbnail ( ) . getUrl ( ) , feedThumbnailWidth ) ; Label feedTitle = new Label ( feed . getTitle ( ) ) ; feedTitle . setMaxWidth ( 175 ) ; feedTitle . setWrapText ( true ) ; feedTitle . setAlignment ( Pos . CENTER ) ; feedTitle . setTextAlignment ( TextAlignment . CENTER ) ; vBox . getChildren ( ) . addAll ( feedThumbnail , feedTitle ) ; feedTilePane . getChildren ( ) . add ( vBox ) ; } }
tjones879/YAPM | private void handleSkipBackButton ( ) { MediaPlayerUtil . skipBack ( ) ; }
tjones879/YAPM | private void handlePlayPauseButton ( ) { MediaPlayerUtil . handlePlayPause ( ) ; }
tjones879/YAPM | private void handleSkipForwardButton ( ) { MediaPlayerUtil . skipForward ( ) ; }
tjones879/YAPM | private void handleVolumeButtonClick ( ) { MediaPlayerUtil . toggleMute ( ) ; }
tjones879/YAPM | private void handleVolumeButtonEnter ( ) { }
tjones879/YAPM | private void handleProgressBarClick ( MouseEvent mouseEvent ) { double mouseX = mouseEvent . getX ( ) ; Bounds bounds = progressBar . getLayoutBounds ( ) ; double seekTime = ( ( mouseX - bounds . getMinX ( ) ) / bounds . getMaxX ( ) ) * 1000 * MediaPlayerUtil . getCurrPlaying ( ) . getLength ( ) ; MediaPlayerUtil . seek ( seekTime ) ; }
tjones879/YAPM | private void updatePlayPauseButton ( Boolean nowPlaying ) { if ( nowPlaying ) { playPauseButton . setImage ( pauseIcon ) ; } else { playPauseButton . setImage ( playIcon ) ; } }
tjones879/YAPM | private void updateVolumeButton ( Boolean nowMuted ) { if ( nowMuted ) { volumeButton . setImage ( mutedSpeakerIcon ) ; } else { volumeButton . setImage ( speakerIcon ) ; } }
tjones879/YAPM | public void updateEpisodeNodes ( ) { Episode episode = MediaPlayerUtil . getCurrPlaying ( ) ; currPlayThumbnail = createThumbnail ( episode . getThumbnail ( ) . getUrl ( ) , 50 ) ; currPlayTitle . setText ( episode . getTitle ( ) ) ; currPlayTime . setText ( "0:00" ) ; maxPlayTime . setText ( TimeUtil . formatTime ( episode . getLength ( ) ) ) ; }
tjones879/YAPM | private void updateProgressBar ( int currTime ) { double maxTime = MediaPlayerUtil . getMediaPlayer ( ) . getTotalDuration ( ) . toSeconds ( ) ; progressBar . setProgress ( currTime / maxTime ) ; }
tjones879/YAPM | public void updateCurrPlayTime ( int currTime ) { currPlayTime . setText ( TimeUtil . formatTime ( currTime ) ) ; }
tjones879/YAPM | public BorderPane getRootBorderPane ( ) { return rootBorderPane ; }
tjones879/YAPM | private ImageView createThumbnail ( String imageUrl , int imageWidth ) { ImageView thumbnail = new ImageView ( imageUrl ) ; thumbnail . setPreserveRatio ( true ) ; thumbnail . setSmooth ( true ) ; thumbnail . setCache ( true ) ; thumbnail . setFitWidth ( imageWidth ) ; thumbnail . setFitHeight ( imageWidth ) ; return thumbnail ; }
tjones879/YAPM | private ImageView createIcon ( Image image ) { ImageView imageView = new ImageView ( image ) ; imageView . setFitWidth ( 25 ) ; imageView . setFitHeight ( 25 ) ; imageView . setSmooth ( true ) ; imageView . setCache ( true ) ; return imageView ; }
apache/sqoop | public SqlServerRecordReader ( DBInputFormat . DBInputSplit split , Class < T > inputClass , Configuration conf , Connection conn , DBConfiguration dbConfig , String cond , String [ ] fields , String table ) throws SQLException { super ( split , inputClass , conf , conn , dbConfig , cond , fields , table , " MICROSOFT ▁ SQL ▁ SERVER " ) ; }
apache/sqoop | @ Override protected String getSelectQuery ( ) { StringBuilder query = new StringBuilder ( ) ; DataDrivenDBInputFormat . DataDrivenDBInputSplit dataSplit = ( DataDrivenDBInputFormat . DataDrivenDBInputSplit ) getSplit ( ) ; DBConfiguration dbConf = getDBConf ( ) ; String [ ] fieldNames = getFieldNames ( ) ; String tableName = getTableName ( ) ; String conditions = getConditions ( ) ; StringBuilder conditionClauses = new StringBuilder ( ) ; conditionClauses . append ( " ( ▁ " ) . append ( dataSplit . getLowerClause ( ) ) ; conditionClauses . append ( " ▁ ) ▁ AND ▁ ( ▁ " ) . append ( dataSplit . getUpperClause ( ) ) ; conditionClauses . append ( " ▁ ) " ) ; if ( dbConf . getInputQuery ( ) == null ) { query . append ( " SELECT ▁ " ) ; for ( int i = 0 ; i < fieldNames . length ; i ++ ) { query . append ( fieldNames [ i ] ) ; if ( i != fieldNames . length - 1 ) { query . append ( " , ▁ " ) ; } } query . append ( " ▁ FROM ▁ " ) . append ( tableName ) ; String tableHints = dbConf . getConf ( ) . get ( SQLServerManager . TABLE_HINTS_PROP ) ; if ( tableHints != null ) { LOG . info ( " Using ▁ table ▁ hints : ▁ " + tableHints ) ; query . append ( " ▁ WITH ▁ ( " ) . append ( tableHints ) . append ( " ) " ) ; } query . append ( " ▁ WHERE ▁ " ) ; if ( conditions != null && conditions . length ( ) > 0 ) { query . append ( " ( ▁ " ) . append ( conditions ) . append ( " ▁ ) ▁ AND ▁ " ) ; } query . append ( conditionClauses . toString ( ) ) ; } else { String inputQuery = dbConf . getInputQuery ( ) ; if ( inputQuery . indexOf ( DataDrivenDBInputFormat . SUBSTITUTE_TOKEN ) == - 1 ) { LOG . error ( " Could ▁ not ▁ find ▁ the ▁ clause ▁ substitution ▁ token ▁ " + DataDrivenDBInputFormat . SUBSTITUTE_TOKEN + " ▁ in ▁ the ▁ query : ▁ [ " + inputQuery + " ] . ▁ Parallel ▁ splits ▁ may ▁ not ▁ work ▁ correctly . " ) ; } query . append ( inputQuery . replace ( DataDrivenDBInputFormat . SUBSTITUTE_TOKEN , conditionClauses . toString ( ) ) ) ; } LOG . info ( " Using ▁ query : ▁ " + query . toString ( ) ) ; return query . toString ( ) ; }
swimmesberger/FileTree | public PropertiesDialog ( File f ) { super ( ) ; this . f = f ; setLocationRelativeTo ( ( JFrame ) null ) ; initUI ( ) ; this . pack ( ) ; }
swimmesberger/FileTree | private void initUI ( ) { this . setLayout ( new GridLayout ( 5 , 2 ) ) ; AssociationService as = new AssociationService ( ) ; Association fileExtensionAssociation = as . getFileExtensionAssociation ( FilenameUtils . getExtension ( f . toString ( ) ) ) ; this . add ( new JLabel ( " Default ▁ Application : " ) ) ; this . add ( new JLabel ( fileExtensionAssociation . getActionByVerb ( " open " ) . getCommand ( ) ) ) ; }
aemay2/hapi-fhir | @ Bean public DaoConfig daoConfig ( ) { DaoConfig retVal = new DaoConfig ( ) ; retVal . addSupportedSubscriptionType ( Subscription . SubscriptionChannelType . EMAIL ) ; retVal . addSupportedSubscriptionType ( Subscription . SubscriptionChannelType . RESTHOOK ) ; retVal . addSupportedSubscriptionType ( Subscription . SubscriptionChannelType . WEBSOCKET ) ; retVal . setWebsocketContextPath ( " / websocketDstu3" ) ; retVal . setAllowContainsSearches ( true ) ; retVal . setAllowMultipleDelete ( true ) ; retVal . setAllowInlineMatchUrlReferences ( true ) ; retVal . setAllowExternalReferences ( true ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " http : // hapi . fhir . org / baseDstu3" ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " https : // hapi . fhir . org / baseDstu3" ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " http : // fhirtest . uhn . ca / baseDstu3" ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " https : // fhirtest . uhn . ca / baseDstu3" ) ; retVal . setCountSearchResultsUpTo ( TestR4Config . COUNT_SEARCH_RESULTS_UP_TO ) ; retVal . setIndexMissingFields ( DaoConfig . IndexEnabledEnum . ENABLED ) ; retVal . setFetchSizeDefaultMaximum ( 10000 ) ; retVal . setReindexThreadCount ( 1 ) ; retVal . setExpungeEnabled ( true ) ; retVal . setFilterParameterEnabled ( true ) ; retVal . setDefaultSearchParamsCanBeOverridden ( false ) ; retVal . getModelConfig ( ) . setIndexOnContainedResources ( true ) ; return retVal ; }
aemay2/hapi-fhir | @ Bean public ModelConfig modelConfig ( ) { return daoConfig ( ) . getModelConfig ( ) ; }
aemay2/hapi-fhir | @ Override @ Bean public ValidationSettings validationSettings ( ) { ValidationSettings retVal = super . validationSettings ( ) ; retVal . setLocalReferenceValidationDefaultPolicy ( ReferenceValidationPolicy . CHECK_VALID ) ; return retVal ; }
aemay2/hapi-fhir | @ Override @ Bean ( autowire = Autowire . BY_TYPE ) public DatabaseBackedPagingProvider databaseBackedPagingProvider ( ) { DatabaseBackedPagingProvider retVal = super . databaseBackedPagingProvider ( ) ; retVal . setDefaultPageSize ( 20 ) ; retVal . setMaximumPageSize ( 500 ) ; return retVal ; }
aemay2/hapi-fhir | @ Bean public PublicSecurityInterceptor securityInterceptor ( ) { return new PublicSecurityInterceptor ( ) ; }
aemay2/hapi-fhir | @ Bean ( name = " myPersistenceDataSourceDstu3" , destroyMethod = " close " ) public DataSource dataSource ( ) { BasicDataSource retVal = new BasicDataSource ( ) ; if ( CommonConfig . isLocalTestMode ( ) ) { retVal . setUrl ( " jdbc : derby : memory : fhirtest _ dstu3 ; create = true " ) ; } else { retVal . setDriver ( new org . postgresql . Driver ( ) ) ; retVal . setUrl ( " jdbc : postgresql : // localhost / fhirtest _ dstu3" ) ; } retVal . setUsername ( myDbUsername ) ; retVal . setPassword ( myDbPassword ) ; retVal . setDefaultQueryTimeout ( 20 ) ; retVal . setTestOnBorrow ( true ) ; DataSource dataSource = ProxyDataSourceBuilder . create ( retVal ) . logSlowQueryBySlf4j ( 10000 , TimeUnit . MILLISECONDS ) . afterQuery ( new CurrentThreadCaptureQueriesListener ( ) ) . countQuery ( ) . build ( ) ; return dataSource ; }
aemay2/hapi-fhir | @ Override @ Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory ( ConfigurableListableBeanFactory theConfigurableListableBeanFactory ) { LocalContainerEntityManagerFactoryBean retVal = super . entityManagerFactory ( theConfigurableListableBeanFactory ) ; retVal . setPersistenceUnitName ( " PU _ HapiFhirJpaDstu3" ) ; retVal . setDataSource ( dataSource ( ) ) ; retVal . setJpaProperties ( jpaProperties ( ) ) ; return retVal ; }
aemay2/hapi-fhir | private Properties jpaProperties ( ) { Properties extraProperties = new Properties ( ) ; if ( CommonConfig . isLocalTestMode ( ) ) { extraProperties . put ( " hibernate . dialect " , DerbyTenSevenHapiFhirDialect . class . getName ( ) ) ; } else { extraProperties . put ( " hibernate . dialect " , HapiFhirPostgres94Dialect . class . getName ( ) ) ; } extraProperties . put ( " hibernate . format _ sql " , " false " ) ; extraProperties . put ( " hibernate . show _ sql " , " false " ) ; extraProperties . put ( " hibernate . hbm2ddl . auto " , " update " ) ; extraProperties . put ( " hibernate . jdbc . batch _ size " , "20" ) ; extraProperties . put ( " hibernate . cache . use _ query _ cache " , " false " ) ; extraProperties . put ( " hibernate . cache . use _ second _ level _ cache " , " false " ) ; extraProperties . put ( " hibernate . cache . use _ structured _ entries " , " false " ) ; extraProperties . put ( " hibernate . cache . use _ minimal _ puts " , " false " ) ; extraProperties . put ( BackendSettings . backendKey ( BackendSettings . TYPE ) , " lucene " ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneBackendSettings . ANALYSIS_CONFIGURER ) , HapiLuceneAnalysisConfigurer . class . getName ( ) ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneIndexSettings . DIRECTORY_TYPE ) , " local - filesystem " ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneIndexSettings . DIRECTORY_ROOT ) , myFhirLuceneLocation ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneBackendSettings . LUCENE_VERSION ) , " LUCENE _ CURRENT " ) ; return extraProperties ; }
aemay2/hapi-fhir | @ Bean @ Lazy public RequestValidatingInterceptor requestValidatingInterceptor ( ) { RequestValidatingInterceptor requestValidator = new RequestValidatingInterceptor ( ) ; requestValidator . setFailOnSeverity ( null ) ; requestValidator . setAddResponseHeaderOnSeverity ( null ) ; requestValidator . setAddResponseOutcomeHeaderOnSeverity ( ResultSeverityEnum . INFORMATION ) ; requestValidator . addValidatorModule ( instanceValidator ( ) ) ; requestValidator . setIgnoreValidatorExceptions ( true ) ; return requestValidator ; }
aemay2/hapi-fhir | @ Bean @ Primary public JpaTransactionManager hapiTransactionManager ( EntityManagerFactory entityManagerFactory ) { JpaTransactionManager retVal = new JpaTransactionManager ( ) ; retVal . setEntityManagerFactory ( entityManagerFactory ) ; return retVal ; }
lmjacksoniii/hazelcast | public RequestMemberIdAssignment ( ) { }
lmjacksoniii/hazelcast | public RequestMemberIdAssignment ( String name , String jobId ) { super ( name , jobId ) ; }
lmjacksoniii/hazelcast | @ Override public Object getResponse ( ) { return result ; }
lmjacksoniii/hazelcast | @ Override public void run ( ) throws Exception { MapReduceService mapReduceService = getService ( ) ; JobSupervisor supervisor = mapReduceService . getJobSupervisor ( getName ( ) , getJobId ( ) ) ; if ( supervisor == null ) { result = new RequestPartitionResult ( NO_SUPERVISOR , - 1 ) ; return ; } MemberAssigningJobProcessInformationImpl processInformation = getProcessInformation ( supervisor ) ; int memberId = processInformation . assignMemberId ( getCallerAddress ( ) , getCallerUuid ( ) , supervisor . getConfiguration ( ) ) ; if ( memberId == - 1 ) { result = new RequestPartitionResult ( NO_MORE_PARTITIONS , - 1 ) ; return ; } result = new RequestPartitionResult ( SUCCESSFUL , memberId ) ; }
lmjacksoniii/hazelcast | @ Override public int getFactoryId ( ) { return MapReduceDataSerializerHook . F_ID ; }
lmjacksoniii/hazelcast | @ Override public int getId ( ) { return MapReduceDataSerializerHook . REQUEST_MEMBERID_ASSIGNMENT ; }
lmjacksoniii/hazelcast | private MemberAssigningJobProcessInformationImpl getProcessInformation ( JobSupervisor supervisor ) { return ( MemberAssigningJobProcessInformationImpl ) supervisor . getJobProcessInformation ( ) ; }
Alachisoft/TayzGrid | private RegisterBulkKeyNotifResponseProtocol ( ) { }
Alachisoft/TayzGrid | private RegisterBulkKeyNotifResponse ( ) { initFields ( ) ; }
Alachisoft/TayzGrid | private RegisterBulkKeyNotifResponse ( boolean noInit ) { }
Alachisoft/TayzGrid | public RegisterBulkKeyNotifResponse getDefaultInstanceForType ( ) { return defaultInstance ; }
Alachisoft/TayzGrid | protected com . google . protobuf . GeneratedMessage . FieldAccessorTable internalGetFieldAccessorTable ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_fieldAccessorTable ; }
Alachisoft/TayzGrid | private void initFields ( ) { }
Alachisoft/TayzGrid | public final boolean isInitialized ( ) { return true ; }
Alachisoft/TayzGrid | public int getSerializedSize ( ) { int size = memoizedSerializedSize ; if ( size != - 1 ) return size ; size = 0 ; size += getUnknownFields ( ) . getSerializedSize ( ) ; memoizedSerializedSize = size ; return size ; }
Alachisoft/TayzGrid | if ( builder . mergeDelimitedFrom ( input ) ) { return builder . buildParsed ( ) ; }
Alachisoft/TayzGrid | if ( builder . mergeDelimitedFrom ( input , extensionRegistry ) ) { return builder . buildParsed ( ) ; }
Alachisoft/TayzGrid | public Builder newBuilderForType ( ) { return newBuilder ( ) ; }
Alachisoft/TayzGrid | public Builder toBuilder ( ) { return newBuilder ( this ) ; }
Alachisoft/TayzGrid | private Builder ( ) { }
Alachisoft/TayzGrid | protected com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse internalGetResult ( ) { return result ; }
Alachisoft/TayzGrid | public Builder clear ( ) { if ( result == null ) { throw new IllegalStateException ( " Cannot ▁ call ▁ clear ( ) ▁ after ▁ build ( ) . " ) ; } result = new com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ( ) ; return this ; }
Alachisoft/TayzGrid | public Builder clone ( ) { return create ( ) . mergeFrom ( result ) ; }
Alachisoft/TayzGrid | public com . google . protobuf . Descriptors . Descriptor getDescriptorForType ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . getDescriptor ( ) ; }
Alachisoft/TayzGrid | public com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse getDefaultInstanceForType ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . getDefaultInstance ( ) ; }
Alachisoft/TayzGrid | public boolean isInitialized ( ) { return result . isInitialized ( ) ; }
Alachisoft/TayzGrid | public com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse build ( ) { if ( result != null && ! isInitialized ( ) ) { throw newUninitializedMessageException ( result ) ; } return buildPartial ( ) ; }
Alachisoft/TayzGrid | if ( ! isInitialized ( ) ) { throw newUninitializedMessageException ( result ) . asInvalidProtocolBufferException ( ) ; }
Alachisoft/TayzGrid | public com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse buildPartial ( ) { if ( result == null ) { throw new IllegalStateException ( " build ( ) ▁ has ▁ already ▁ been ▁ called ▁ on ▁ this ▁ Builder . " ) ; } com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse returnMe = result ; result = null ; return returnMe ; }
Alachisoft/TayzGrid | public Builder mergeFrom ( com . google . protobuf . Message other ) { if ( other instanceof com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ) { return mergeFrom ( ( com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ) other ) ; } else { super . mergeFrom ( other ) ; return this ; } }
Alachisoft/TayzGrid | public Builder mergeFrom ( com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse other ) { if ( other == com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . getDefaultInstance ( ) ) return this ; this . mergeUnknownFields ( other . getUnknownFields ( ) ) ; return this ; }
Alachisoft/TayzGrid | while ( true ) { int tag = input . readTag ( ) ; switch ( tag ) { case 0 : this . setUnknownFields ( unknownFields . build ( ) ) ; return this ; default : { if ( ! parseUnknownField ( input , unknownFields , extensionRegistry , tag ) ) { this . setUnknownFields ( unknownFields . build ( ) ) ; return this ; } break ; } } }
Alachisoft/TayzGrid | com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner assigner = new com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner ( ) { public com . google . protobuf . ExtensionRegistry assignDescriptors ( com . google . protobuf . Descriptors . FileDescriptor root ) { descriptor = root ; internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_descriptor = getDescriptor ( ) . getMessageTypes ( ) . get ( 0 ) ; internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_fieldAccessorTable = new com . google . protobuf . GeneratedMessage . FieldAccessorTable ( internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_descriptor , new java . lang . String [ ] { } , com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . class , com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . Builder . class ) ; return null ; } }
MovingBlocks/box2d-editor | public void initialize ( ) { String [ ] texturesNearest = new String [ ] { " data / transparent - light . png " , " data / transparent - dark . png " , " data / white . png " } ; String [ ] texturesLinear = new String [ ] { " data / ball . png " , " data / v00 . png " , " data / v01 . png " , " data / v10 . png " , " data / unknown . png " } ; for ( String tex : texturesNearest ) load ( tex , Texture . class ) ; for ( String tex : texturesLinear ) load ( tex , Texture . class ) ; while ( update ( ) == false ) { } for ( String tex : texturesLinear ) { get ( tex , Texture . class ) . setFilter ( Texture . TextureFilter . Linear , Texture . TextureFilter . Linear ) ; } unknownRegion = new TextureRegion ( get ( " data / unknown . png " , Texture . class ) ) ; Ctx . bodies . getModels ( ) . addListChangedListener ( new ObservableList . ListChangeListener < RigidBodyModel > ( ) { @ Override public void changed ( Object source , List < RigidBodyModel > added , List < RigidBodyModel > removed ) { for ( RigidBodyModel body : removed ) { TextureRegion region = rigidBodiesRegions . remove ( body ) ; if ( region != null ) region . getTexture ( ) . dispose ( ) ; } for ( RigidBodyModel body : added ) { load ( body ) ; } } } ) ; }
MovingBlocks/box2d-editor | public TextureRegion getRegion ( RigidBodyModel body ) { if ( ! body . isImagePathValid ( ) ) return unknownRegion ; if ( body . getImagePath ( ) == null ) return null ; if ( ! rigidBodiesRegions . containsKey ( body ) ) load ( body ) ; return rigidBodiesRegions . get ( body ) ; }
MovingBlocks/box2d-editor | private void load ( RigidBodyModel body ) { if ( ! body . isImagePathValid ( ) ) return ; if ( body . getImagePath ( ) == null ) return ; File file = Ctx . io . getImageFile ( body . getImagePath ( ) ) ; TextureRegion region = TextureUtils . getPOTTexture ( file . getPath ( ) ) ; rigidBodiesRegions . put ( body , region ) ; }
egustafson/sandbox | @ Test public void testLoad ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " INTC " ; LocalDate fromDate = new LocalDate ( 2007 , 7 , 6 ) ; LocalDate toDate = new LocalDate ( 2008 , 2 , 5 ) ; List < String > results = yq . loadHistory ( symbol , fromDate , toDate ) ; for ( String line : results ) { System . out . println ( line ) ; } }
egustafson/sandbox | @ Test public void testLoadRecords ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " INTC " ; LocalDate fromDate = new LocalDate ( 2007 , 7 , 1 ) ; LocalDate toDate = new LocalDate ( 2007 , 7 , 14 ) ; List < YahooHistoryRecord > records = yq . loadHistoryRecords ( symbol , fromDate , toDate ) ; for ( YahooHistoryRecord r : records ) { System . out . println ( r . toString ( ) ) ; } }
egustafson/sandbox | @ Test public void testQuote ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " MSFT " ; List < String > results = yq . quote ( symbol , " x " ) ; for ( String line : results ) { System . out . println ( line ) ; } }
egustafson/sandbox | @ Test public void testDividends ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " IBM " ; LocalDate fromDate = new LocalDate ( 1800 , 1 , 1 ) ; LocalDate toDate = new LocalDate ( 2009 , 1 , 1 ) ; List < String > results = yq . loadDividends ( symbol , fromDate , toDate ) ; for ( String line : results ) { System . out . println ( line ) ; } }
akkumar/jreversepro | public ExceptionThrown ( int rhsStart , int rhsEnd , int rhsHandler , String rhsType ) { startPc = rhsStart ; endPc = rhsEnd ; any = ( rhsType . equals ( JVMConstants . ANY ) ) ; if ( rhsHandler - rhsEnd == 1 ) { endPc = rhsHandler ; } excCatchTable = new HashMap < Integer , String > ( ) ; addCatchBlock ( rhsHandler , rhsType ) ; }
akkumar/jreversepro | public void addCatchBlock ( int rhsHandlerPc , String rhsType ) { rhsType = ( rhsType != null ) ? rhsType : JVMConstants . ANY ; excCatchTable . put ( Integer . valueOf ( rhsHandlerPc ) , rhsType ) ; }
akkumar/jreversepro | public int getStartPc ( ) { return startPc ; }
akkumar/jreversepro | public int getEndPc ( ) { return endPc ; }
akkumar/jreversepro | public Enumeration < Map . Entry < Integer , String > > getHandlers ( ) { return Collections . enumeration ( excCatchTable . entrySet ( ) ) ; }
akkumar/jreversepro | public String getExceptionClass ( int rhsHandlerPc ) { return excCatchTable . get ( Integer . valueOf ( rhsHandlerPc ) ) ; }
akkumar/jreversepro | @ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof ExceptionThrown ) ) { return false ; } else { return sameTryBlock ( ( ExceptionThrown ) obj ) ; } }
akkumar/jreversepro | public boolean sameTryBlock ( ExceptionThrown exc ) { return ( startPc == exc . startPc && endPc == exc . endPc ) ; }
akkumar/jreversepro | public boolean containsANYCatchBlock ( ) { return excCatchTable . containsValue ( JVMConstants . ANY ) ; }
akkumar/jreversepro | public boolean isAny ( ) { return any ; }
akkumar/jreversepro | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " " ) ; for ( Map . Entry < Integer , String > ent : excCatchTable . entrySet ( ) ) { sb . append ( " \t\t " + startPc + " \t " + endPc ) ; sb . append ( " \t " + ent . getKey ( ) ) ; sb . append ( " ▁ " + ent . getValue ( ) + " \n " ) ; } return sb . toString ( ) ; }
dennisxu1014/dennisxu-sample-android | public int getType ( ) { return mType ; }
dennisxu1014/dennisxu-sample-android | public void setType ( int type ) { this . mType = type ; }
dennisxu1014/dennisxu-sample-android | public String getPath ( ) { return mPath ; }
dennisxu1014/dennisxu-sample-android | public void setPath ( String mPath ) { this . mPath = mPath ; }
dennisxu1014/dennisxu-sample-android | public String getAction ( ) { return mAction ; }
dennisxu1014/dennisxu-sample-android | public void setAction ( String action ) { this . mAction = action ; }
dennisxu1014/dennisxu-sample-android | public Params getParams ( ) { return mParams ; }
dennisxu1014/dennisxu-sample-android | public void setParams ( Params params ) { this . mParams = params ; }
dennisxu1014/dennisxu-sample-android | public ParserType getParserType ( ) { return mParserType ; }
dennisxu1014/dennisxu-sample-android | public Class < ? > getExpectType ( ) { return mExpectType ; }
dennisxu1014/dennisxu-sample-android | public void setExpectType ( Class < ? > expectType ) { this . mExpectType = expectType ; }
dennisxu1014/dennisxu-sample-android | public void setParserType ( ParserType parserType ) { this . mParserType = parserType ; }
dennisxu1014/dennisxu-sample-android | private ParserType ( int value ) { this . mValue = value ; }
dennisxu1014/dennisxu-sample-android | public int getValue ( ) { return mValue ; }
dennisxu1014/dennisxu-sample-android | @ Override public boolean equals ( Object o ) { if ( o instanceof ParserType ) { ParserType type = ( ParserType ) o ; return type . getValue ( ) == getValue ( ) ; } else { return false ; } }
pniraula/InGen | public ExcelDoc ( Display display ) { FileInputStream file ; this . display = display ; try { display . addMessage ( " Reading ▁ Excel ▁ Doc " ) ; file = new FileInputStream ( new File ( CONFIG . getInputFile ( ) ) ) ; Workbook wb = WorkbookFactory . create ( file ) ; sheet = wb . getSheet ( CONFIG . getSheet ( ) ) ; display . addMessage ( " Excel ▁ file ▁ has ▁ been ▁ successfully ▁ read . " ) ; } catch ( Exception e ) { display . addMessage ( e . getMessage ( ) ) ; } }
pniraula/InGen | public String getValue ( Row row , int cellNo ) { Cell cell = row . getCell ( cellNo ) ; if ( cell != null ) { if ( cell . getCellType ( ) == Cell . CELL_TYPE_STRING ) return cell . getStringCellValue ( ) . trim ( ) . replaceAll ( " " , " " ) ; else if ( cell . getCellType ( ) == Cell . CELL_TYPE_BOOLEAN ) return Boolean . toString ( cell . getBooleanCellValue ( ) ) . toUpperCase ( ) . trim ( ) . replaceAll ( " " , " " ) ; else if ( cell . getCellType ( ) == Cell . CELL_TYPE_NUMERIC ) return Integer . toString ( ( int ) cell . getNumericCellValue ( ) ) . trim ( ) . replaceAll ( " " , " " ) ; else if ( cell . getCellType ( ) == Cell . CELL_TYPE_BLANK ) return " " ; } return " " ; }
pniraula/InGen | public Sheet getSheet ( ) { return sheet ; }
pniraula/InGen | public ArrayList < Row > getRows ( String table ) { ArrayList < Row > rows = new ArrayList < Row > ( ) ; Iterator < Row > rowIterator = this . sheet . rowIterator ( ) ; int counter = 0 ; while ( rowIterator . hasNext ( ) ) { if ( counter >= CONFIG . getStartPoint ( ) - 1 ) { Row row = rowIterator . next ( ) ; if ( getValue ( row , 5 ) . trim ( ) . equals ( table ) ) { rows . add ( row ) ; } } else { rowIterator . next ( ) ; } counter ++ ; } return rows ; }
pniraula/InGen | public boolean isEmpty ( Row row , int number ) { if ( getValue ( row , number ) . length ( ) > 0 ) return false ; return true ; }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void testEviction ( ) throws IOException { Configuration conf = new Configuration ( ) ; conf . set ( FileSystem . FS_DEFAULT_NAME_KEY , " hdfs : // localhost " ) ; final int MAX_CACHE_SIZE = 2 ; DFSClientCache cache = new DFSClientCache ( conf , MAX_CACHE_SIZE ) ; DFSClient c1 = cache . get ( " test1" ) ; assertTrue ( cache . get ( " test1" ) . toString ( ) . contains ( " ugi = test1" ) ) ; assertEquals ( c1 , cache . get ( " test1" ) ) ; assertFalse ( isDfsClientClose ( c1 ) ) ; cache . get ( " test2" ) ; assertTrue ( isDfsClientClose ( c1 ) ) ; assertEquals ( MAX_CACHE_SIZE - 1 , cache . clientCache . size ( ) ) ; }
Zooz/Zooz-Java | public AdditionalExternalServicesErrorResponse ( ) { }
Zooz/Zooz-Java | public AdditionalExternalServicesErrorResponse ( String errorCode , String errorMessage ) { this . errorCode = errorCode ; this . errorMessage = errorMessage ; }
Zooz/Zooz-Java | public String getErrorCode ( ) { return errorCode ; }
Zooz/Zooz-Java | public void setErrorCode ( String errorCode ) { this . errorCode = errorCode ; }
Zooz/Zooz-Java | public String getErrorMessage ( ) { return errorMessage ; }
Zooz/Zooz-Java | public void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; }
dstozek/mind-notes | public void onModuleLoad ( ) { String mapKey = Window . Location . getParameter ( " map " ) ; if ( mapKey == null ) return ; MindmapStorageServiceAsync storage = GWT . create ( MindmapStorageService . class ) ; storage . loadMindmapPublic ( mapKey , new AsyncCallback < MindMap > ( ) { @ Override public void onSuccess ( MindMap result ) { showMap ( result ) ; } @ Override public void onFailure ( Throwable caught ) { showError ( new MindNotesViewerUI ( ) , " I ' m ▁ sorry , ▁ I ▁ cannot ▁ show ▁ you ▁ this ▁ map . ▁ " ) ; } } ) ; }
dstozek/mind-notes | protected void showError ( final MindNotesViewerUI ui , String string ) { DOM . getElementById ( " loader " ) . removeFromParent ( ) ; ui . errorDialogLabel . setText ( string ) ; ui . errorDialog . setPopupPositionAndShow ( new PositionCallback ( ) { @ Override public void setPosition ( int offsetWidth , int offsetHeight ) { ui . errorDialog . setPopupPosition ( ( Window . getClientWidth ( ) - offsetWidth ) / 2 , ( Window . getClientHeight ( ) - offsetHeight ) / 2 ) ; } } ) ; }
dstozek/mind-notes | private void showMap ( final MindMap result ) { MindNotesViewerUI ui = new MindNotesViewerUI ( ) ; final MindMapViewer presenter = new MindMapViewer ( ) ; presenter . setView ( ui . getMindMapView ( ) ) ; ui . setMapTitle ( result . getTitle ( ) ) ; RootLayoutPanel . get ( ) . add ( ui ) ; DOM . getElementById ( " loader " ) . removeFromParent ( ) ; final MindMap mindMap = new MindMap ( ) ; mindMap . setTitle ( " Viewer " ) ; mindMap . getRootNode ( ) . setText ( " Viewer ▁ Mindmap " ) ; DeferredCommand . addCommand ( new Command ( ) { @ Override public void execute ( ) { presenter . setMindMap ( result ) ; } } ) ; }
JaredHatfield/shak-jarvis | public HolidayList ( ) { this . available = new ArrayList < String > ( ) ; ResourceBundle resource = ResourceBundle . getBundle ( " Holidays " , Locale . getDefault ( ) ) ; this . names = new HashMap < String , String > ( ) ; Enumeration < String > keys = resource . getKeys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = keys . nextElement ( ) ; names . put ( key , resource . getString ( key ) ) ; } this . holidays = new TreeMap < Integer , Map < Integer , Map < Integer , List < String > > > > ( ) ; int thisYear = Calendar . getInstance ( ) . get ( Calendar . YEAR ) ; this . populateYear ( thisYear ) ; }
JaredHatfield/shak-jarvis | public synchronized List < String > getHolidays ( Calendar calendar ) { int year = calendar . get ( Calendar . YEAR ) ; int month = calendar . get ( Calendar . MONTH ) + 1 ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; return this . getHolidays ( year , month , day ) ; }
JaredHatfield/shak-jarvis | public synchronized List < String > getHolidays ( int year , int month , int day ) { List < String > holidayNames = new ArrayList < String > ( ) ; List < String > holidayEvents = this . getEvents ( year , month , day ) ; for ( String holidayEvent : holidayEvents ) { holidayNames . add ( this . names . get ( holidayEvent ) ) ; } return holidayNames ; }
JaredHatfield/shak-jarvis | List < String > getEvents ( int year , int month , int day ) { List < String > events = new ArrayList < String > ( ) ; if ( ! this . holidays . containsKey ( year ) ) { this . populateYear ( year ) ; } if ( ! this . holidays . get ( year ) . containsKey ( month ) ) { return events ; } else if ( ! this . holidays . get ( year ) . get ( month ) . containsKey ( day ) ) { return events ; } events = this . holidays . get ( year ) . get ( month ) . get ( day ) ; return events ; }
JaredHatfield/shak-jarvis | void add ( int year , int month , int day , String name ) { this . holidays . get ( year ) . get ( month + 1 ) . get ( day ) . add ( name ) ; if ( ! this . available . contains ( name ) ) { this . available . add ( name ) ; } }
JaredHatfield/shak-jarvis | List < String > getAllHolidays ( ) { return Collections . unmodifiableList ( this . available ) ; }
JaredHatfield/shak-jarvis | Map < String , String > getAllHolidayNames ( ) { return Collections . unmodifiableMap ( this . names ) ; }
JaredHatfield/shak-jarvis | private void populateYear ( int yearNumber ) { Map < Integer , Map < Integer , List < String > > > year = new TreeMap < Integer , Map < Integer , List < String > > > ( ) ; this . holidays . put ( yearNumber , year ) ; for ( int monthNumber = 1 ; monthNumber <= 12 ; monthNumber ++ ) { Map < Integer , List < String > > month = new TreeMap < Integer , List < String > > ( ) ; year . put ( monthNumber , month ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( Calendar . YEAR , yearNumber ) ; calendar . set ( Calendar . MONTH , monthNumber - 1 ) ; int numDays = calendar . getActualMaximum ( Calendar . DATE ) ; for ( int dayNumber = 1 ; dayNumber <= numDays ; dayNumber ++ ) { List < String > day = new ArrayList < String > ( ) ; month . put ( dayNumber , day ) ; } } FixedHolidays . populate ( yearNumber , this ) ; VariableHolidays . populate ( yearNumber , this ) ; }
HenryHarper/Acquire-Reboot | public DaemonJvmOptions ( PathToFileResolver resolver ) { super ( resolver ) ; final JvmOptions currentProcessJvmOptions = new CurrentProcess ( ) . getJvmOptions ( ) ; systemProperties ( currentProcessJvmOptions . getImmutableSystemProperties ( ) ) ; handleDaemonImmutableProperties ( currentProcessJvmOptions . getMutableSystemProperties ( ) ) ; }
HenryHarper/Acquire-Reboot | private void handleDaemonImmutableProperties ( Map < String , Object > systemProperties ) { for ( Map . Entry < String , ? > entry : systemProperties . entrySet ( ) ) { if ( IMMUTABLE_DAEMON_SYSTEM_PROPERTIES . contains ( entry . getKey ( ) ) ) { immutableSystemProperties . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } }
HenryHarper/Acquire-Reboot | public Map < String , Object > getImmutableDaemonProperties ( ) { return CollectionUtils . filter ( immutableSystemProperties , new Spec < Map . Entry < String , Object > > ( ) { @ Override public boolean isSatisfiedBy ( Map . Entry < String , Object > element ) { return IMMUTABLE_DAEMON_SYSTEM_PROPERTIES . contains ( element . getKey ( ) ) ; } } ) ; }
HenryHarper/Acquire-Reboot | public void systemProperty ( String name , Object value ) { if ( IMMUTABLE_DAEMON_SYSTEM_PROPERTIES . contains ( name ) ) { immutableSystemProperties . put ( name , value ) ; } else { super . systemProperty ( name , value ) ; } }
HenryHarper/Acquire-Reboot | public List < String > getAllSingleUseImmutableJvmArgs ( ) { List < String > immutableDaemonParameters = new ArrayList < String > ( ) ; formatSystemProperties ( getImmutableDaemonProperties ( ) , immutableDaemonParameters ) ; final List < String > jvmArgs = getAllImmutableJvmArgs ( ) ; jvmArgs . removeAll ( immutableDaemonParameters ) ; return jvmArgs ; }
dragonzhou/humor | public Sequence ( int id ) { this . id = id ; }
dragonzhou/humor | public void addItemset ( Itemset itemset ) { itemsets . add ( itemset ) ; numberOfItems += itemset . size ( ) ; }
dragonzhou/humor | public void addItem ( Item item ) { itemsets . get ( size ( ) - 1 ) . addItem ( item ) ; numberOfItems ++ ; }
dragonzhou/humor | public void addItem ( int indexItemset , Item item ) { itemsets . get ( indexItemset ) . addItem ( item ) ; numberOfItems ++ ; }
dragonzhou/humor | public void addItem ( int indexItemset , int indexItem , Item item ) { itemsets . get ( indexItemset ) . addItem ( indexItem , item ) ; numberOfItems ++ ; }
dragonzhou/humor | public Itemset remove ( int indexItemset ) { Itemset itemset = itemsets . remove ( indexItemset ) ; numberOfItems -= itemset . size ( ) ; return itemset ; }
dragonzhou/humor | public Item remove ( int indexItemset , int indexItem ) { numberOfItems -- ; return itemsets . get ( indexItem ) . removeItem ( indexItem ) ; }
dragonzhou/humor | public void remove ( int indexItemset , Item item ) { itemsets . get ( indexItemset ) . removeItem ( item ) ; numberOfItems -- ; }
dragonzhou/humor | public Sequence cloneSequence ( ) { Sequence sequence = new Sequence ( getId ( ) ) ; for ( Itemset itemset : itemsets ) { sequence . addItemset ( itemset . cloneItemSet ( ) ) ; } return sequence ; }
dragonzhou/humor | @ Override public String toString ( ) { StringBuilder r = new StringBuilder ( " " ) ; for ( Itemset itemset : itemsets ) { r . append ( " { t = " ) ; r . append ( itemset . getTimestamp ( ) ) ; r . append ( " , ▁ " ) ; for ( Item item : itemset . getItems ( ) ) { String string = item . toString ( ) ; r . append ( string ) ; r . append ( ' ▁ ' ) ; } r . append ( ' } ' ) ; } return r . append ( " ▁ ▁ ▁ ▁ " ) . toString ( ) ; }
dragonzhou/humor | public int getId ( ) { return id ; }
dragonzhou/humor | public List < Itemset > getItemsets ( ) { return itemsets ; }
dragonzhou/humor | public Itemset get ( int index ) { return itemsets . get ( index ) ; }
dragonzhou/humor | public int size ( ) { return itemsets . size ( ) ; }
dragonzhou/humor | public int length ( ) { return numberOfItems ; }
dragonzhou/humor | public long getTimeLength ( ) { return itemsets . get ( itemsets . size ( ) - 1 ) . getTimestamp ( ) - itemsets . get ( 0 ) . getTimestamp ( ) ; }
dragonzhou/humor | public Sequence cloneSequenceMinusItems ( Map < Item , BitSet > mapSequenceID , double relativeMinSup ) { Sequence sequence = new Sequence ( getId ( ) ) ; for ( Itemset itemset : itemsets ) { Itemset newItemset = itemset . cloneItemSetMinusItems ( mapSequenceID , relativeMinSup ) ; if ( newItemset . size ( ) != 0 ) { sequence . addItemset ( newItemset ) ; } } return sequence ; }
dragonzhou/humor | public void setID ( int id ) { this . id = id ; }
iamsandipan/prosperity-new | public String getLogin ( ) { return login ; }
iamsandipan/prosperity-new | public void setLogin ( String login ) { this . login = login ; }
iamsandipan/prosperity-new | public String getHashPassword ( ) { return hashPassword ; }
iamsandipan/prosperity-new | public void setHashPassword ( String password ) { this . hashPassword = password ; }
iamsandipan/prosperity-new | public String getPhone ( ) { return phone ; }
iamsandipan/prosperity-new | public void setPhone ( String phone ) { this . phone = phone ; }
iamsandipan/prosperity-new | public String getId ( ) { return id ; }
iamsandipan/prosperity-new | public void setId ( String id ) { this . id = id ; }
MiniPlayer/log-island | private Record getRecord1 ( ) { Record record1 = new StandardRecord ( ) ; record1 . setField ( " string1" , FieldType . STRING , " value1" ) ; record1 . setField ( " string2" , FieldType . STRING , " value2" ) ; record1 . setField ( " long1" , FieldType . LONG , 1 ) ; record1 . setField ( " long2" , FieldType . LONG , 2 ) ; return record1 ; }
MiniPlayer/log-island | @ Test public void testNothingToRemove ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " " ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 4 ) ; outputRecord . assertFieldEquals ( " string1" , " value1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long1" , 1 ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
MiniPlayer/log-island | @ Test public void testRemoveOneField ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " string1" ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 3 ) ; outputRecord . assertFieldNotExists ( " string1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long1" , 1 ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
MiniPlayer/log-island | @ Test public void testRemove2Fields ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " string1 , long1" ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 2 ) ; outputRecord . assertFieldNotExists ( " string1" ) ; outputRecord . assertFieldNotExists ( " long1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
MiniPlayer/log-island | @ Test public void testRemoveNonExistingField ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " string3" ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 4 ) ; outputRecord . assertFieldEquals ( " string1" , " value1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long1" , 1 ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
Danny02/deltaspike | @ Override public Boolean isActivated ( Class < ? extends Deactivatable > targetClass ) { return ! DefaultMockFilter . class . equals ( targetClass ) ; }
didiez/keycloak | public String getRealmId ( ) { return realmId ; }
didiez/keycloak | public void setRealmId ( String realmId ) { this . realmId = realmId ; }
didiez/keycloak | public String getUserId ( ) { return userId ; }
didiez/keycloak | public void setUserId ( String userId ) { this . userId = userId ; }
didiez/keycloak | public int getLastSessionRefresh ( ) { return lastSessionRefresh ; }
didiez/keycloak | public void setLastSessionRefresh ( int lastSessionRefresh ) { this . lastSessionRefresh = lastSessionRefresh ; }
didiez/keycloak | public String getData ( ) { return data ; }
didiez/keycloak | public void setData ( String data ) { this . data = data ; }
didiez/keycloak | public List < PersistentClientSessionEntity > getClientSessions ( ) { return clientSessions ; }
didiez/keycloak | public void setClientSessions ( List < PersistentClientSessionEntity > clientSessions ) { this . clientSessions = clientSessions ; }
everttigchelaar/camel-svn | public MailConfiguration ( ) { }
everttigchelaar/camel-svn | public MailConfiguration copy ( ) { try { MailConfiguration copy = ( MailConfiguration ) clone ( ) ; copy . recipients = new HashMap < Message . RecipientType , String > ( ) ; copy . recipients . putAll ( this . recipients ) ; return copy ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } }
everttigchelaar/camel-svn | public void configure ( URI uri ) { String value = uri . getHost ( ) ; if ( value != null ) { setHost ( value ) ; } if ( ! isIgnoreUriScheme ( ) ) { String scheme = uri . getScheme ( ) ; if ( scheme != null ) { setProtocol ( scheme ) ; } } String userInfo = uri . getUserInfo ( ) ; if ( userInfo != null ) { setUsername ( userInfo ) ; } int port = uri . getPort ( ) ; if ( port > 0 ) { setPort ( port ) ; } else if ( port <= 0 && this . port <= 0 ) { setPort ( MailUtils . getDefaultPortForProtocol ( uri . getScheme ( ) ) ) ; } }
everttigchelaar/camel-svn | protected JavaMailSenderImpl createJavaMailSender ( ) { JavaMailSenderImpl answer = new JavaMailSenderImpl ( ) ; if ( javaMailProperties != null ) { answer . setJavaMailProperties ( javaMailProperties ) ; } else { answer . setJavaMailProperties ( createJavaMailProperties ( ) ) ; if ( additionalJavaMailProperties != null ) { answer . getJavaMailProperties ( ) . putAll ( additionalJavaMailProperties ) ; } } if ( defaultEncoding != null ) { answer . setDefaultEncoding ( defaultEncoding ) ; } if ( host != null ) { answer . setHost ( host ) ; } if ( port >= 0 ) { answer . setPort ( port ) ; } if ( username != null ) { answer . setUsername ( username ) ; } if ( password != null ) { answer . setPassword ( password ) ; } if ( protocol != null ) { answer . setProtocol ( protocol ) ; } if ( session != null ) { answer . setSession ( session ) ; } else { Session session = Session . getInstance ( answer . getJavaMailProperties ( ) , getAuthenticator ( ) ) ; session . setDebug ( debugMode ) ; answer . setSession ( session ) ; } return answer ; }
everttigchelaar/camel-svn | private Properties createJavaMailProperties ( ) { Properties properties = ( Properties ) System . getProperties ( ) . clone ( ) ; properties . put ( " mail . " + protocol + " . connectiontimeout " , connectionTimeout ) ; properties . put ( " mail . " + protocol + " . timeout " , connectionTimeout ) ; properties . put ( " mail . " + protocol + " . host " , host ) ; properties . put ( " mail . " + protocol + " . port " , " " + port ) ; if ( username != null ) { properties . put ( " mail . " + protocol + " . user " , username ) ; properties . put ( " mail . user " , username ) ; properties . put ( " mail . " + protocol + " . auth " , " true " ) ; } else { properties . put ( " mail . " + protocol + " . auth " , " false " ) ; } properties . put ( " mail . " + protocol + " . rsetbeforequit " , " true " ) ; properties . put ( " mail . transport . protocol " , protocol ) ; properties . put ( " mail . store . protocol " , protocol ) ; properties . put ( " mail . host " , host ) ; if ( debugMode ) { properties . put ( " javax . net . debug " , " all " ) ; } if ( dummyTrustManager && isSecureProtocol ( ) ) { properties . put ( " mail . " + protocol + " . socketFactory . class " , " org . apache . camel . component . mail . security . DummySSLSocketFactory " ) ; properties . put ( " mail . " + protocol + " . socketFactory . fallback " , " false " ) ; properties . put ( " mail . " + protocol + " . socketFactory . port " , " " + port ) ; } return properties ; }
everttigchelaar/camel-svn | public boolean isSecureProtocol ( ) { return this . protocol . equalsIgnoreCase ( " smtps " ) || this . protocol . equalsIgnoreCase ( " pop3s " ) || this . protocol . equalsIgnoreCase ( " imaps " ) ; }
everttigchelaar/camel-svn | public Authenticator getAuthenticator ( ) { return new Authenticator ( ) { protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( getUsername ( ) , getPassword ( ) ) ; } } ; }
everttigchelaar/camel-svn | public String getMailStoreLogInformation ( ) { String ssl = " " ; if ( isSecureProtocol ( ) ) { ssl = " ▁ ( SSL ▁ enabled " + ( dummyTrustManager ? " ▁ using ▁ DummyTrustManager ) " : " ) " ) ; } return protocol + " : // " + host + " : " + port + ssl + " , ▁ folder = " + folderName ; }
everttigchelaar/camel-svn | public JavaMailSender getJavaMailSender ( ) { return javaMailSender ; }
everttigchelaar/camel-svn | public void setJavaMailSender ( JavaMailSender javaMailSender ) { this . javaMailSender = javaMailSender ; }
everttigchelaar/camel-svn | public String getDefaultEncoding ( ) { return defaultEncoding ; }
everttigchelaar/camel-svn | public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; }
everttigchelaar/camel-svn | public String getHost ( ) { return host ; }
everttigchelaar/camel-svn | public void setHost ( String host ) { this . host = host ; }
everttigchelaar/camel-svn | public Properties getJavaMailProperties ( ) { return javaMailProperties ; }
everttigchelaar/camel-svn | public void setJavaMailProperties ( Properties javaMailProperties ) { this . javaMailProperties = javaMailProperties ; }
everttigchelaar/camel-svn | public Properties getAdditionalJavaMailProperties ( ) { if ( additionalJavaMailProperties == null ) { additionalJavaMailProperties = new Properties ( ) ; } return additionalJavaMailProperties ; }
everttigchelaar/camel-svn | public void setAdditionalJavaMailProperties ( Properties additionalJavaMailProperties ) { this . additionalJavaMailProperties = additionalJavaMailProperties ; }
everttigchelaar/camel-svn | public String getPassword ( ) { return password ; }
everttigchelaar/camel-svn | public void setPassword ( String password ) { this . password = password ; }
everttigchelaar/camel-svn | public String getSubject ( ) { return subject ; }
everttigchelaar/camel-svn | public void setSubject ( String subject ) { this . subject = subject ; }
everttigchelaar/camel-svn | public int getPort ( ) { return port ; }
everttigchelaar/camel-svn | public void setPort ( int port ) { this . port = port ; }
everttigchelaar/camel-svn | public String getProtocol ( ) { return protocol ; }
everttigchelaar/camel-svn | public void setProtocol ( String protocol ) { this . protocol = protocol ; }
everttigchelaar/camel-svn | public Session getSession ( ) { return session ; }
everttigchelaar/camel-svn | public void setSession ( Session session ) { this . session = session ; }
everttigchelaar/camel-svn | public String getUsername ( ) { return username ; }
everttigchelaar/camel-svn | public void setUsername ( String username ) { this . username = username ; if ( getRecipients ( ) . size ( ) == 0 ) { String address = username ; if ( address . indexOf ( " @ " ) == - 1 ) { address += " @ " + host ; } setTo ( address ) ; } }
everttigchelaar/camel-svn | public String getFrom ( ) { return from ; }
everttigchelaar/camel-svn | public void setFrom ( String from ) { this . from = from ; }
everttigchelaar/camel-svn | public boolean isDelete ( ) { return delete ; }
everttigchelaar/camel-svn | public void setDelete ( boolean delete ) { this . delete = delete ; }
everttigchelaar/camel-svn | public String getFolderName ( ) { return folderName ; }
everttigchelaar/camel-svn | public void setFolderName ( String folderName ) { this . folderName = folderName ; }
everttigchelaar/camel-svn | public boolean isIgnoreUriScheme ( ) { return ignoreUriScheme ; }
everttigchelaar/camel-svn | public void setIgnoreUriScheme ( boolean ignoreUriScheme ) { this . ignoreUriScheme = ignoreUriScheme ; }
everttigchelaar/camel-svn | public boolean isUnseen ( ) { return unseen ; }
everttigchelaar/camel-svn | public void setUnseen ( boolean unseen ) { this . unseen = unseen ; }
everttigchelaar/camel-svn | public void setTo ( String address ) { recipients . put ( Message . RecipientType . TO , address ) ; }
everttigchelaar/camel-svn | public void setCC ( String address ) { recipients . put ( Message . RecipientType . CC , address ) ; }
everttigchelaar/camel-svn | public void setBCC ( String address ) { recipients . put ( Message . RecipientType . BCC , address ) ; }
everttigchelaar/camel-svn | public Map < Message . RecipientType , String > getRecipients ( ) { return recipients ; }
everttigchelaar/camel-svn | public int getFetchSize ( ) { return fetchSize ; }
everttigchelaar/camel-svn | public void setFetchSize ( int fetchSize ) { this . fetchSize = fetchSize ; }
everttigchelaar/camel-svn | public boolean isDebugMode ( ) { return debugMode ; }
everttigchelaar/camel-svn | public void setDebugMode ( boolean debugMode ) { this . debugMode = debugMode ; }
everttigchelaar/camel-svn | public long getConnectionTimeout ( ) { return connectionTimeout ; }
everttigchelaar/camel-svn | public void setConnectionTimeout ( long connectionTimeout ) { this . connectionTimeout = connectionTimeout ; }
everttigchelaar/camel-svn | public boolean isDummyTrustManager ( ) { return dummyTrustManager ; }
everttigchelaar/camel-svn | public void setDummyTrustManager ( boolean dummyTrustManager ) { this . dummyTrustManager = dummyTrustManager ; }
everttigchelaar/camel-svn | public String getContentType ( ) { return contentType ; }
everttigchelaar/camel-svn | public void setContentType ( String contentType ) { this . contentType = contentType ; }
everttigchelaar/camel-svn | public String getAlternativeBodyHeader ( ) { return alternativeBodyHeader ; }
everttigchelaar/camel-svn | public void setAlternativeBodyHeader ( String alternativeBodyHeader ) { this . alternativeBodyHeader = alternativeBodyHeader ; }
everttigchelaar/camel-svn | public boolean isUseInlineAttachments ( ) { return useInlineAttachments ; }
everttigchelaar/camel-svn | public void setUseInlineAttachments ( boolean useInlineAttachments ) { this . useInlineAttachments = useInlineAttachments ; }
everttigchelaar/camel-svn | public boolean isIgnoreUnsupportedCharset ( ) { return ignoreUnsupportedCharset ; }
everttigchelaar/camel-svn | public void setIgnoreUnsupportedCharset ( boolean ignoreUnsupportedCharset ) { this . ignoreUnsupportedCharset = ignoreUnsupportedCharset ; }
JackSprat/Knifeybot | public String getHost ( ) { return this . host ; }
JackSprat/Knifeybot | public String getHostPortPair ( ) { return this . hostPortPair != null ? this . hostPortPair : this . host + " : " + this . port ; }
JackSprat/Knifeybot | public boolean isProxySet ( ) { return this . proxy != null ; }
JackSprat/Knifeybot | public void setProxy ( MySQLConnection proxy ) { this . proxy = proxy ; this . realProxy = this . proxy instanceof MultiHostMySQLConnection ? ( ( MultiHostMySQLConnection ) proxy ) . getThisAsProxy ( ) : null ; }
JackSprat/Knifeybot | private MySQLConnection getProxy ( ) { return ( this . proxy != null ) ? this . proxy : ( MySQLConnection ) this ; }
JackSprat/Knifeybot | @ Deprecated public MySQLConnection getLoadBalanceSafeProxy ( ) { return getMultiHostSafeProxy ( ) ; }
JackSprat/Knifeybot | public MySQLConnection getMultiHostSafeProxy ( ) { return this . getProxy ( ) ; }
JackSprat/Knifeybot | public Object getConnectionMutex ( ) { return ( this . realProxy != null ) ? this . realProxy : getProxy ( ) ; }
JackSprat/Knifeybot | ExceptionInterceptorChain ( String interceptorClasses ) throws SQLException { this . interceptors = Util . loadExtensions ( ConnectionImpl . this , ConnectionImpl . this . props , interceptorClasses , " Connection . BadExceptionInterceptor " , this ) ; }
JackSprat/Knifeybot | void addRingZero ( ExceptionInterceptor interceptor ) throws SQLException { this . interceptors . add ( 0 , interceptor ) ; }
JackSprat/Knifeybot | public SQLException interceptException ( SQLException sqlEx , Connection conn ) { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { sqlEx = ( ( ExceptionInterceptor ) iter . next ( ) ) . interceptException ( sqlEx , ConnectionImpl . this ) ; } } return sqlEx ; }
JackSprat/Knifeybot | public void destroy ( ) { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( ExceptionInterceptor ) iter . next ( ) ) . destroy ( ) ; } } }
JackSprat/Knifeybot | public void init ( Connection conn , Properties properties ) throws SQLException { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( ExceptionInterceptor ) iter . next ( ) ) . init ( conn , properties ) ; } } }
JackSprat/Knifeybot | public List < Extension > getInterceptors ( ) { return this . interceptors ; }
JackSprat/Knifeybot | CompoundCacheKey ( String partOne , String partTwo ) { this . componentOne = partOne ; this . componentTwo = partTwo ; this . hashCode = ( ( ( this . componentOne != null ) ? this . componentOne : " " ) + this . componentTwo ) . hashCode ( ) ; }
JackSprat/Knifeybot | @ Override public boolean equals ( Object obj ) { if ( obj instanceof CompoundCacheKey ) { CompoundCacheKey another = ( CompoundCacheKey ) obj ; boolean firstPartEqual = false ; if ( this . componentOne == null ) { firstPartEqual = ( another . componentOne == null ) ; } else { firstPartEqual = this . componentOne . equals ( another . componentOne ) ; } return ( firstPartEqual && this . componentTwo . equals ( another . componentTwo ) ) ; } return false ; }
JackSprat/Knifeybot | @ Override public int hashCode ( ) { return this . hashCode ; }
JackSprat/Knifeybot | if ( Util . isJdbc4 ( ) ) { try { JDBC_4_CONNECTION_CTOR = Class . forName ( " com . mysql . jdbc . JDBC4Connection " ) . getConstructor ( new Class [ ] { String . class , Integer . TYPE , Properties . class , String . class , String . class } ) ; } catch ( SecurityException e ) { throw new RuntimeException ( e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } }
JackSprat/Knifeybot | public Timer getCancelTimer ( ) { synchronized ( getConnectionMutex ( ) ) { if ( this . cancelTimer == null ) { boolean createdNamedTimer = false ; try { Constructor < Timer > ctr = Timer . class . getConstructor ( new Class [ ] { String . class , Boolean . TYPE } ) ; this . cancelTimer = ctr . newInstance ( new Object [ ] { " MySQL ▁ Statement ▁ Cancellation ▁ Timer " , Boolean . TRUE } ) ; createdNamedTimer = true ; } catch ( Throwable t ) { createdNamedTimer = false ; } if ( ! createdNamedTimer ) { this . cancelTimer = new Timer ( true ) ; } } return this . cancelTimer ; } }
JackSprat/Knifeybot | protected ConnectionImpl ( ) { }
JackSprat/Knifeybot | public ConnectionImpl ( String hostToConnectTo , int portToConnectTo , Properties info , String databaseToConnectTo , String url ) throws SQLException { this . connectionCreationTimeMillis = System . currentTimeMillis ( ) ; if ( databaseToConnectTo == null ) { databaseToConnectTo = " " ; } this . origHostToConnectTo = hostToConnectTo ; this . origPortToConnectTo = portToConnectTo ; this . origDatabaseToConnectTo = databaseToConnectTo ; try { Blob . class . getMethod ( " truncate " , new Class [ ] { Long . TYPE } ) ; this . isRunningOnJDK13 = false ; } catch ( NoSuchMethodException nsme ) { this . isRunningOnJDK13 = true ; } this . sessionCalendar = new GregorianCalendar ( ) ; this . utcCalendar = new GregorianCalendar ( ) ; this . utcCalendar . setTimeZone ( TimeZone . getTimeZone ( " GMT " ) ) ; this . log = LogFactory . getLogger ( getLogger ( ) , LOGGER_INSTANCE_NAME , getExceptionInterceptor ( ) ) ; if ( NonRegisteringDriver . isHostPropertiesList ( hostToConnectTo ) ) { Properties hostSpecificProps = NonRegisteringDriver . expandHostKeyValues ( hostToConnectTo ) ; Enumeration < ? > propertyNames = hostSpecificProps . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String propertyName = propertyNames . nextElement ( ) . toString ( ) ; String propertyValue = hostSpecificProps . getProperty ( propertyName ) ; info . setProperty ( propertyName , propertyValue ) ; } } else { if ( hostToConnectTo == null ) { this . host = " localhost " ; this . hostPortPair = this . host + " : " + portToConnectTo ; } else { this . host = hostToConnectTo ; if ( hostToConnectTo . indexOf ( " : " ) == - 1 ) { this . hostPortPair = this . host + " : " + portToConnectTo ; } else { this . hostPortPair = this . host ; } } } this . port = portToConnectTo ; this . database = databaseToConnectTo ; this . myURL = url ; this . user = info . getProperty ( NonRegisteringDriver . USER_PROPERTY_KEY ) ; this . password = info . getProperty ( NonRegisteringDriver . PASSWORD_PROPERTY_KEY ) ; if ( ( this . user == null ) || this . user . equals ( " " ) ) { this . user = " " ; } if ( this . password == null ) { this . password = " " ; } this . props = info ; initializeDriverProperties ( info ) ; this . defaultTimeZone = TimeUtil . getDefaultTimeZone ( getCacheDefaultTimezone ( ) ) ; this . isClientTzUTC = ! this . defaultTimeZone . useDaylightTime ( ) && this . defaultTimeZone . getRawOffset ( ) == 0 ; if ( getUseUsageAdvisor ( ) ) { this . pointOfOrigin = LogUtils . findCallingClassAndMethod ( new Throwable ( ) ) ; } else { this . pointOfOrigin = " " ; } try { this . dbmd = getMetaData ( false , false ) ; initializeSafeStatementInterceptors ( ) ; createNewIO ( false ) ; unSafeStatementInterceptors ( ) ; } catch ( SQLException ex ) { cleanup ( ex ) ; throw ex ; } catch ( Exception ex ) { cleanup ( ex ) ; StringBuilder mesg = new StringBuilder ( 128 ) ; if ( ! getParanoid ( ) ) { mesg . append ( " Cannot ▁ connect ▁ to ▁ MySQL ▁ server ▁ on ▁ " ) ; mesg . append ( this . host ) ; mesg . append ( " : " ) ; mesg . append ( this . port ) ; mesg . append ( " . \n \n " ) ; mesg . append ( " Make ▁ sure ▁ that ▁ there ▁ is ▁ a ▁ MySQL ▁ server ▁ " ) ; mesg . append ( " running ▁ on ▁ the ▁ machine / port ▁ you ▁ are ▁ trying ▁ " ) ; mesg . append ( " to ▁ connect ▁ to ▁ and ▁ that ▁ the ▁ machine ▁ this ▁ software ▁ is ▁ running ▁ on ▁ " ) ; mesg . append ( " is ▁ able ▁ to ▁ connect ▁ to ▁ this ▁ host / port ▁ ( i . e . ▁ not ▁ firewalled ) . ▁ " ) ; mesg . append ( " Also ▁ make ▁ sure ▁ that ▁ the ▁ server ▁ has ▁ not ▁ been ▁ started ▁ with ▁ the ▁ - - skip - networking ▁ " ) ; mesg . append ( " flag . \n \n " ) ; } else { mesg . append ( " Unable ▁ to ▁ connect ▁ to ▁ database . " ) ; } SQLException sqlEx = SQLError . createSQLException ( mesg . toString ( ) , SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } NonRegisteringDriver . trackConnection ( this ) ; }
JackSprat/Knifeybot | public void unSafeStatementInterceptors ( ) throws SQLException { ArrayList < StatementInterceptorV2 > unSafedStatementInterceptors = new ArrayList < StatementInterceptorV2 > ( this . statementInterceptors . size ( ) ) ; for ( int i = 0 ; i < this . statementInterceptors . size ( ) ; i ++ ) { NoSubInterceptorWrapper wrappedInterceptor = ( NoSubInterceptorWrapper ) this . statementInterceptors . get ( i ) ; unSafedStatementInterceptors . add ( wrappedInterceptor . getUnderlyingInterceptor ( ) ) ; } this . statementInterceptors = unSafedStatementInterceptors ; if ( this . io != null ) { this . io . setStatementInterceptors ( this . statementInterceptors ) ; } }
JackSprat/Knifeybot | public void initializeSafeStatementInterceptors ( ) throws SQLException { this . isClosed = false ; List < Extension > unwrappedInterceptors = Util . loadExtensions ( this , this . props , getStatementInterceptors ( ) , " MysqlIo . BadStatementInterceptor " , getExceptionInterceptor ( ) ) ; this . statementInterceptors = new ArrayList < StatementInterceptorV2 > ( unwrappedInterceptors . size ( ) ) ; for ( int i = 0 ; i < unwrappedInterceptors . size ( ) ; i ++ ) { Extension interceptor = unwrappedInterceptors . get ( i ) ; if ( interceptor instanceof StatementInterceptor ) { if ( ReflectiveStatementInterceptorAdapter . getV2PostProcessMethod ( interceptor . getClass ( ) ) != null ) { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( new ReflectiveStatementInterceptorAdapter ( ( StatementInterceptor ) interceptor ) ) ) ; } else { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( new V1toV2StatementInterceptorAdapter ( ( StatementInterceptor ) interceptor ) ) ) ; } } else { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( ( StatementInterceptorV2 ) interceptor ) ) ; } } }
JackSprat/Knifeybot | public List < StatementInterceptorV2 > getStatementInterceptorsInstances ( ) { return this . statementInterceptors ; }
JackSprat/Knifeybot | private void addToHistogram ( int [ ] histogramCounts , long [ ] histogramBreakpoints , long value , int numberOfTimes , long currentLowerBound , long currentUpperBound ) { if ( histogramCounts == null ) { createInitialHistogram ( histogramBreakpoints , currentLowerBound , currentUpperBound ) ; } else { for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { if ( histogramBreakpoints [ i ] >= value ) { histogramCounts [ i ] += numberOfTimes ; break ; } } } }
JackSprat/Knifeybot | private void addToPerformanceHistogram ( long value , int numberOfTimes ) { checkAndCreatePerformanceHistogram ( ) ; addToHistogram ( this . perfMetricsHistCounts , this . perfMetricsHistBreakpoints , value , numberOfTimes , this . shortestQueryTimeMs == Long . MAX_VALUE ? 0 : this . shortestQueryTimeMs , this . longestQueryTimeMs ) ; }
JackSprat/Knifeybot | private void addToTablesAccessedHistogram ( long value , int numberOfTimes ) { checkAndCreateTablesAccessedHistogram ( ) ; addToHistogram ( this . numTablesMetricsHistCounts , this . numTablesMetricsHistBreakpoints , value , numberOfTimes , this . minimumNumberTablesAccessed == Long . MAX_VALUE ? 0 : this . minimumNumberTablesAccessed , this . maximumNumberTablesAccessed ) ; }
JackSprat/Knifeybot | private void buildCollationMapping ( ) throws SQLException { Map < Integer , String > indexToCharset = null ; Map < Number , String > sortedCollationMap = null ; Map < Integer , String > customCharset = null ; Map < String , Integer > customMblen = null ; if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { indexToCharset = dynamicIndexToCharsetMapByUrl . get ( getURL ( ) ) ; sortedCollationMap = dynamicIndexToCollationMapByUrl . get ( getURL ( ) ) ; customCharset = customIndexToCharsetMapByUrl . get ( getURL ( ) ) ; customMblen = customCharsetToMblenMapByUrl . get ( getURL ( ) ) ; } } if ( indexToCharset == null ) { indexToCharset = new HashMap < Integer , String > ( ) ; if ( versionMeetsMinimum ( 4 , 1 , 0 ) && getDetectCustomCollations ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet results = null ; try { sortedCollationMap = new TreeMap < Number , String > ( ) ; customCharset = new HashMap < Integer , String > ( ) ; customMblen = new HashMap < String , Integer > ( ) ; stmt = getMetadataSafeStatement ( ) ; try { results = stmt . executeQuery ( " SHOW ▁ COLLATION " ) ; if ( versionMeetsMinimum ( 5 , 0 , 0 ) ) { Util . resultSetToMap ( sortedCollationMap , results , 3 , 2 ) ; } else { while ( results . next ( ) ) { sortedCollationMap . put ( results . getLong ( 3 ) , results . getString ( 2 ) ) ; } } } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } for ( Iterator < Map . Entry < Number , String > > indexIter = sortedCollationMap . entrySet ( ) . iterator ( ) ; indexIter . hasNext ( ) ; ) { Map . Entry < Number , String > indexEntry = indexIter . next ( ) ; int collationIndex = indexEntry . getKey ( ) . intValue ( ) ; String charsetName = indexEntry . getValue ( ) ; indexToCharset . put ( collationIndex , charsetName ) ; if ( collationIndex >= CharsetMapping . MAP_SIZE || ! charsetName . equals ( CharsetMapping . getMysqlCharsetNameForCollationIndex ( collationIndex ) ) ) { customCharset . put ( collationIndex , charsetName ) ; } if ( ! CharsetMapping . CHARSET_NAME_TO_CHARSET . containsKey ( charsetName ) ) { customMblen . put ( charsetName , null ) ; } } if ( customMblen . size ( ) > 0 ) { try { results = stmt . executeQuery ( " SHOW ▁ CHARACTER ▁ SET " ) ; while ( results . next ( ) ) { String charsetName = results . getString ( " Charset " ) ; if ( customMblen . containsKey ( charsetName ) ) { customMblen . put ( charsetName , results . getInt ( " Maxlen " ) ) ; } } } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { dynamicIndexToCharsetMapByUrl . put ( getURL ( ) , indexToCharset ) ; dynamicIndexToCollationMapByUrl . put ( getURL ( ) , sortedCollationMap ) ; customIndexToCharsetMapByUrl . put ( getURL ( ) , customCharset ) ; customCharsetToMblenMapByUrl . put ( getURL ( ) , customMblen ) ; } } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } finally { if ( results != null ) { try { results . close ( ) ; } catch ( java . sql . SQLException sqlE ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( java . sql . SQLException sqlE ) { } } } } else { for ( int i = 1 ; i < CharsetMapping . MAP_SIZE ; i ++ ) { indexToCharset . put ( i , CharsetMapping . getMysqlCharsetNameForCollationIndex ( i ) ) ; } if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { dynamicIndexToCharsetMapByUrl . put ( getURL ( ) , indexToCharset ) ; } } } } this . indexToMysqlCharset = Collections . unmodifiableMap ( indexToCharset ) ; if ( customCharset != null ) { this . indexToCustomMysqlCharset = Collections . unmodifiableMap ( customCharset ) ; } if ( customMblen != null ) { this . mysqlCharsetToCustomMblen = Collections . unmodifiableMap ( customMblen ) ; } }
JackSprat/Knifeybot | private boolean canHandleAsServerPreparedStatement ( String sql ) throws SQLException { if ( sql == null || sql . length ( ) == 0 ) { return true ; } if ( ! this . useServerPreparedStmts ) { return false ; } if ( getCachePreparedStatements ( ) ) { synchronized ( this . serverSideStatementCheckCache ) { Boolean flag = ( Boolean ) this . serverSideStatementCheckCache . get ( sql ) ; if ( flag != null ) { return flag . booleanValue ( ) ; } boolean canHandle = canHandleAsServerPreparedStatementNoCache ( sql ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { this . serverSideStatementCheckCache . put ( sql , canHandle ? Boolean . TRUE : Boolean . FALSE ) ; } return canHandle ; } } return canHandleAsServerPreparedStatementNoCache ( sql ) ; }
JackSprat/Knifeybot | private boolean canHandleAsServerPreparedStatementNoCache ( String sql ) throws SQLException { if ( StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " CALL " ) ) { return false ; } boolean canHandleAsStatement = true ; if ( ! versionMeetsMinimum ( 5 , 0 , 7 ) && ( StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " SELECT " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " DELETE " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " INSERT " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " UPDATE " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " REPLACE " ) ) ) { int currentPos = 0 ; int statementLength = sql . length ( ) ; int lastPosToLook = statementLength - 7 ; boolean allowBackslashEscapes = ! this . noBackslashEscapes ; String quoteChar = this . useAnsiQuotes ? " \" " : " ' " ; boolean foundLimitWithPlaceholder = false ; while ( currentPos < lastPosToLook ) { int limitStart = StringUtils . indexOfIgnoreCase ( currentPos , sql , " LIMIT ▁ " , quoteChar , quoteChar , allowBackslashEscapes ? StringUtils . SEARCH_MODE__ALL : StringUtils . SEARCH_MODE__MRK_COM_WS ) ; if ( limitStart == - 1 ) { break ; } currentPos = limitStart + 7 ; while ( currentPos < statementLength ) { char c = sql . charAt ( currentPos ) ; if ( ! Character . isDigit ( c ) && ! Character . isWhitespace ( c ) && c != ' , ' && c != ' ? ' ) { break ; } if ( c == ' ? ' ) { foundLimitWithPlaceholder = true ; break ; } currentPos ++ ; } } canHandleAsStatement = ! foundLimitWithPlaceholder ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " XA ▁ " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " CREATE ▁ TABLE " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " DO " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " SET " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " SHOW ▁ WARNINGS " ) && versionMeetsMinimum ( 5 , 7 , 2 ) ) { canHandleAsStatement = false ; } return canHandleAsStatement ; }
JackSprat/Knifeybot | public void changeUser ( String userName , String newPassword ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( ( userName == null ) || userName . equals ( " " ) ) { userName = " " ; } if ( newPassword == null ) { newPassword = " " ; } this . sessionMaxRows = - 1 ; try { this . io . changeUser ( userName , newPassword , this . database ) ; } catch ( SQLException ex ) { if ( versionMeetsMinimum ( 5 , 6 , 13 ) && "28000" . equals ( ex . getSQLState ( ) ) ) { cleanup ( ex ) ; } throw ex ; } this . user = userName ; this . password = newPassword ; if ( versionMeetsMinimum ( 4 , 1 , 0 ) ) { configureClientCharacterSet ( true ) ; } setSessionVariables ( ) ; setupServerForTruncationChecks ( ) ; } }
JackSprat/Knifeybot | private boolean characterSetNamesMatches ( String mysqlEncodingName ) { return ( mysqlEncodingName != null && mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ client " ) ) && mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ connection " ) ) ) ; }
JackSprat/Knifeybot | private void checkAndCreatePerformanceHistogram ( ) { if ( this . perfMetricsHistCounts == null ) { this . perfMetricsHistCounts = new int [ HISTOGRAM_BUCKETS ] ; } if ( this . perfMetricsHistBreakpoints == null ) { this . perfMetricsHistBreakpoints = new long [ HISTOGRAM_BUCKETS ] ; } }
JackSprat/Knifeybot | private void checkAndCreateTablesAccessedHistogram ( ) { if ( this . numTablesMetricsHistCounts == null ) { this . numTablesMetricsHistCounts = new int [ HISTOGRAM_BUCKETS ] ; } if ( this . numTablesMetricsHistBreakpoints == null ) { this . numTablesMetricsHistBreakpoints = new long [ HISTOGRAM_BUCKETS ] ; } }
JackSprat/Knifeybot | public void checkClosed ( ) throws SQLException { if ( this . isClosed ) { throwConnectionClosedException ( ) ; } }
JackSprat/Knifeybot | public void throwConnectionClosedException ( ) throws SQLException { SQLException ex = SQLError . createSQLException ( " No ▁ operations ▁ allowed ▁ after ▁ connection ▁ closed . " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; if ( this . forceClosedReason != null ) { ex . initCause ( this . forceClosedReason ) ; } throw ex ; }
JackSprat/Knifeybot | private void checkServerEncoding ( ) throws SQLException { if ( getUseUnicode ( ) && ( getEncoding ( ) != null ) ) { return ; } String serverCharset = this . serverVariables . get ( " character _ set " ) ; if ( serverCharset == null ) { serverCharset = this . serverVariables . get ( " character _ set _ server " ) ; } String mappedServerEncoding = null ; if ( serverCharset != null ) { try { mappedServerEncoding = CharsetMapping . getJavaEncodingForMysqlCharset ( serverCharset ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } } if ( ! getUseUnicode ( ) && ( mappedServerEncoding != null ) ) { SingleByteCharsetConverter converter = getCharsetConverter ( mappedServerEncoding ) ; if ( converter != null ) { setUseUnicode ( true ) ; setEncoding ( mappedServerEncoding ) ; return ; } } if ( serverCharset != null ) { if ( mappedServerEncoding == null ) { if ( Character . isLowerCase ( serverCharset . charAt ( 0 ) ) ) { char [ ] ach = serverCharset . toCharArray ( ) ; ach [ 0 ] = Character . toUpperCase ( serverCharset . charAt ( 0 ) ) ; setEncoding ( new String ( ach ) ) ; } } if ( mappedServerEncoding == null ) { throw SQLError . createSQLException ( " Unknown ▁ character ▁ encoding ▁ on ▁ server ▁ ' " + serverCharset + " ' , ▁ use ▁ ' characterEncoding = ' ▁ property ▁ " + " ▁ to ▁ provide ▁ correct ▁ mapping " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } try { StringUtils . getBytes ( " abc " , mappedServerEncoding ) ; setEncoding ( mappedServerEncoding ) ; setUseUnicode ( true ) ; } catch ( UnsupportedEncodingException UE ) { throw SQLError . createSQLException ( " The ▁ driver ▁ can ▁ not ▁ map ▁ the ▁ character ▁ encoding ▁ ' " + getEncoding ( ) + " ' ▁ that ▁ your ▁ server ▁ is ▁ using ▁ " + " to ▁ a ▁ character ▁ encoding ▁ your ▁ JVM ▁ understands . ▁ You ▁ can ▁ specify ▁ this ▁ mapping ▁ manually ▁ by ▁ adding ▁ \" useUnicode = true \" ▁ " + " as ▁ well ▁ as ▁ \" characterEncoding = [ an _ encoding _ your _ jvm _ understands ] \" ▁ to ▁ your ▁ JDBC ▁ URL . " , "0S100" , getExceptionInterceptor ( ) ) ; } } }
JackSprat/Knifeybot | private void checkTransactionIsolationLevel ( ) throws SQLException { String txIsolationName = null ; if ( versionMeetsMinimum ( 4 , 0 , 3 ) ) { txIsolationName = " tx _ isolation " ; } else { txIsolationName = " transaction _ isolation " ; } String s = this . serverVariables . get ( txIsolationName ) ; if ( s != null ) { Integer intTI = mapTransIsolationNameToValue . get ( s ) ; if ( intTI != null ) { this . isolationLevel = intTI . intValue ( ) ; } } }
JackSprat/Knifeybot | public void abortInternal ( ) throws SQLException { if ( this . io != null ) { try { this . io . forceClose ( ) ; this . io . releaseResources ( ) ; } catch ( Throwable t ) { } this . io = null ; } this . isClosed = true ; }
JackSprat/Knifeybot | private void cleanup ( Throwable whyCleanedUp ) { try { if ( this . io != null ) { if ( isClosed ( ) ) { this . io . forceClose ( ) ; } else { realClose ( false , false , false , whyCleanedUp ) ; } } } catch ( SQLException sqlEx ) { } this . isClosed = true ; }
JackSprat/Knifeybot | @ Deprecated public void clearHasTriedMaster ( ) { this . hasTriedMasterFlag = false ; }
JackSprat/Knifeybot | public void clearWarnings ( ) throws SQLException { }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql ) throws SQLException { return clientPrepareStatement ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { java . sql . PreparedStatement pStmt = clientPrepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { return clientPrepareStatement ( sql , resultSetType , resultSetConcurrency , true ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , boolean processEscapeCodesIfNeeded ) throws SQLException { checkClosed ( ) ; String nativeSql = processEscapeCodesIfNeeded && getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; PreparedStatement pStmt = null ; if ( getCachePreparedStatements ( ) ) { PreparedStatement . ParseInfo pStmtInfo = this . cachedPreparedStatementParams . get ( nativeSql ) ; if ( pStmtInfo == null ) { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database ) ; this . cachedPreparedStatementParams . put ( nativeSql , pStmt . getParseInfo ( ) ) ; } else { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , pStmtInfo ) ; } } else { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database ) ; } pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) clientPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) clientPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return clientPrepareStatement ( sql , resultSetType , resultSetConcurrency , true ) ; }
JackSprat/Knifeybot | public void close ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . close ( ) ; } } . doForAll ( ) ; } realClose ( true , true , false , null ) ; } }
JackSprat/Knifeybot | private void closeAllOpenStatements ( ) throws SQLException { SQLException postponedException = null ; for ( Statement stmt : this . openStatements ) { try { ( ( StatementImpl ) stmt ) . realClose ( false , true ) ; } catch ( SQLException sqlEx ) { postponedException = sqlEx ; } } if ( postponedException != null ) { throw postponedException ; } }
JackSprat/Knifeybot | private void closeStatement ( java . sql . Statement stmt ) { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlEx ) { } stmt = null ; } }
JackSprat/Knifeybot | public void commit ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . commit ( ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( this . autoCommit && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ call ▁ commit ▁ when ▁ autocommit = true " , getExceptionInterceptor ( ) ) ; } else if ( this . transactionsSupported ) { if ( getUseLocalTransactionState ( ) && versionMeetsMinimum ( 5 , 0 , 0 ) ) { if ( ! this . io . inTransactionOnServer ( ) ) { return ; } } execSQL ( null , " commit " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } catch ( SQLException sqlException ) { if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlException . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ commit ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlException ; } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } return ; }
JackSprat/Knifeybot | private void configureCharsetProperties ( ) throws SQLException { if ( getEncoding ( ) != null ) { try { String testString = " abc " ; StringUtils . getBytes ( testString , getEncoding ( ) ) ; } catch ( UnsupportedEncodingException UE ) { String oldEncoding = getEncoding ( ) ; try { setEncoding ( CharsetMapping . getJavaEncodingForMysqlCharset ( oldEncoding ) ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( getEncoding ( ) == null ) { throw SQLError . createSQLException ( " Java ▁ does ▁ not ▁ support ▁ the ▁ MySQL ▁ character ▁ encoding ▁ ' " + oldEncoding + " ' . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } try { String testString = " abc " ; StringUtils . getBytes ( testString , getEncoding ( ) ) ; } catch ( UnsupportedEncodingException encodingEx ) { throw SQLError . createSQLException ( " Unsupported ▁ character ▁ encoding ▁ ' " + getEncoding ( ) + " ' . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } } } }
JackSprat/Knifeybot | private boolean configureClientCharacterSet ( boolean dontCheckServerMatch ) throws SQLException { String realJavaEncoding = getEncoding ( ) ; boolean characterSetAlreadyConfigured = false ; try { if ( versionMeetsMinimum ( 4 , 1 , 0 ) ) { characterSetAlreadyConfigured = true ; setUseUnicode ( true ) ; configureCharsetProperties ( ) ; realJavaEncoding = getEncoding ( ) ; try { if ( this . props != null && this . props . getProperty ( " com . mysql . jdbc . faultInjection . serverCharsetIndex " ) != null ) { this . io . serverCharsetIndex = Integer . parseInt ( this . props . getProperty ( " com . mysql . jdbc . faultInjection . serverCharsetIndex " ) ) ; } String serverEncodingToSet = CharsetMapping . getJavaEncodingForCollationIndex ( this . io . serverCharsetIndex ) ; if ( serverEncodingToSet == null || serverEncodingToSet . length ( ) == 0 ) { if ( realJavaEncoding != null ) { setEncoding ( realJavaEncoding ) ; } else { throw SQLError . createSQLException ( " Unknown ▁ initial ▁ character ▁ set ▁ index ▁ ' " + this . io . serverCharsetIndex + " ' ▁ received ▁ from ▁ server . ▁ Initial ▁ client ▁ character ▁ set ▁ can ▁ be ▁ forced ▁ via ▁ the ▁ ' characterEncoding ' ▁ property . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } if ( versionMeetsMinimum ( 4 , 1 , 0 ) && " ISO8859_1" . equalsIgnoreCase ( serverEncodingToSet ) ) { serverEncodingToSet = " Cp1252" ; } if ( " UnicodeBig " . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 16" . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 16LE " . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 32" . equalsIgnoreCase ( serverEncodingToSet ) ) { serverEncodingToSet = " UTF - 8" ; } setEncoding ( serverEncodingToSet ) ; } catch ( ArrayIndexOutOfBoundsException outOfBoundsEx ) { if ( realJavaEncoding != null ) { setEncoding ( realJavaEncoding ) ; } else { throw SQLError . createSQLException ( " Unknown ▁ initial ▁ character ▁ set ▁ index ▁ ' " + this . io . serverCharsetIndex + " ' ▁ received ▁ from ▁ server . ▁ Initial ▁ client ▁ character ▁ set ▁ can ▁ be ▁ forced ▁ via ▁ the ▁ ' characterEncoding ' ▁ property . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( getEncoding ( ) == null ) { setEncoding ( " ISO8859_1" ) ; } if ( getUseUnicode ( ) ) { if ( realJavaEncoding != null ) { if ( realJavaEncoding . equalsIgnoreCase ( " UTF - 8" ) || realJavaEncoding . equalsIgnoreCase ( " UTF8" ) ) { boolean utf8mb4Supported = versionMeetsMinimum ( 5 , 5 , 2 ) ; boolean useutf8mb4 = utf8mb4Supported && ( CharsetMapping . UTF8MB4_INDEXES . contains ( this . io . serverCharsetIndex ) ) ; if ( ! getUseOldUTF8Behavior ( ) ) { if ( dontCheckServerMatch || ! characterSetNamesMatches ( " utf8" ) || ( utf8mb4Supported && ! characterSetNamesMatches ( " utf8mb4" ) ) ) { execSQL ( null , " SET ▁ NAMES ▁ " + ( useutf8mb4 ? " utf8mb4" : " utf8" ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , useutf8mb4 ? " utf8mb4" : " utf8" ) ; this . serverVariables . put ( " character _ set _ connection " , useutf8mb4 ? " utf8mb4" : " utf8" ) ; } } else { execSQL ( null , " SET ▁ NAMES ▁ latin1" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , " latin1" ) ; this . serverVariables . put ( " character _ set _ connection " , " latin1" ) ; } setEncoding ( realJavaEncoding ) ; } else { String mysqlCharsetName = CharsetMapping . getMysqlCharsetForJavaEncoding ( realJavaEncoding . toUpperCase ( Locale . ENGLISH ) , this ) ; if ( mysqlCharsetName != null ) { if ( dontCheckServerMatch || ! characterSetNamesMatches ( mysqlCharsetName ) ) { execSQL ( null , " SET ▁ NAMES ▁ " + mysqlCharsetName , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , mysqlCharsetName ) ; this . serverVariables . put ( " character _ set _ connection " , mysqlCharsetName ) ; } } setEncoding ( realJavaEncoding ) ; } } else if ( getEncoding ( ) != null ) { String mysqlCharsetName = getServerCharset ( ) ; if ( getUseOldUTF8Behavior ( ) ) { mysqlCharsetName = " latin1" ; } boolean ucs2 = false ; if ( " ucs2" . equalsIgnoreCase ( mysqlCharsetName ) || " utf16" . equalsIgnoreCase ( mysqlCharsetName ) || " utf16le " . equalsIgnoreCase ( mysqlCharsetName ) || " utf32" . equalsIgnoreCase ( mysqlCharsetName ) ) { mysqlCharsetName = " utf8" ; ucs2 = true ; if ( getCharacterSetResults ( ) == null ) { setCharacterSetResults ( " UTF - 8" ) ; } } if ( dontCheckServerMatch || ! characterSetNamesMatches ( mysqlCharsetName ) || ucs2 ) { try { execSQL ( null , " SET ▁ NAMES ▁ " + mysqlCharsetName , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , mysqlCharsetName ) ; this . serverVariables . put ( " character _ set _ connection " , mysqlCharsetName ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } realJavaEncoding = getEncoding ( ) ; } } String onServer = null ; boolean isNullOnServer = false ; if ( this . serverVariables != null ) { onServer = this . serverVariables . get ( " character _ set _ results " ) ; isNullOnServer = onServer == null || " NULL " . equalsIgnoreCase ( onServer ) || onServer . length ( ) == 0 ; } if ( getCharacterSetResults ( ) == null ) { if ( ! isNullOnServer ) { try { execSQL ( null , " SET ▁ character _ set _ results ▁ = ▁ NULL " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , null ) ; } else { this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , onServer ) ; } } else { if ( getUseOldUTF8Behavior ( ) ) { try { execSQL ( null , " SET ▁ NAMES ▁ latin1" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , " latin1" ) ; this . serverVariables . put ( " character _ set _ connection " , " latin1" ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } String charsetResults = getCharacterSetResults ( ) ; String mysqlEncodingName = null ; if ( " UTF - 8" . equalsIgnoreCase ( charsetResults ) || " UTF8" . equalsIgnoreCase ( charsetResults ) ) { mysqlEncodingName = " utf8" ; } else if ( " null " . equalsIgnoreCase ( charsetResults ) ) { mysqlEncodingName = " NULL " ; } else { mysqlEncodingName = CharsetMapping . getMysqlCharsetForJavaEncoding ( charsetResults . toUpperCase ( Locale . ENGLISH ) , this ) ; } if ( mysqlEncodingName == null ) { throw SQLError . createSQLException ( " Can ' t ▁ map ▁ " + charsetResults + " ▁ given ▁ for ▁ characterSetResults ▁ to ▁ a ▁ supported ▁ MySQL ▁ encoding . " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } if ( ! mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ results " ) ) ) { StringBuilder setBuf = new StringBuilder ( " SET ▁ character _ set _ results ▁ = ▁ " . length ( ) + mysqlEncodingName . length ( ) ) ; setBuf . append ( " SET ▁ character _ set _ results ▁ = ▁ " ) . append ( mysqlEncodingName ) ; try { execSQL ( null , setBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , mysqlEncodingName ) ; if ( versionMeetsMinimum ( 5 , 5 , 0 ) ) { this . errorMessageEncoding = charsetResults ; } } else { this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , onServer ) ; } } if ( getConnectionCollation ( ) != null ) { StringBuilder setBuf = new StringBuilder ( " SET ▁ collation _ connection ▁ = ▁ " . length ( ) + getConnectionCollation ( ) . length ( ) ) ; setBuf . append ( " SET ▁ collation _ connection ▁ = ▁ " ) . append ( getConnectionCollation ( ) ) ; try { execSQL ( null , setBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } } else { realJavaEncoding = getEncoding ( ) ; } } finally { setEncoding ( realJavaEncoding ) ; } try { CharsetEncoder enc = Charset . forName ( getEncoding ( ) ) . newEncoder ( ) ; CharBuffer cbuf = CharBuffer . allocate ( 1 ) ; ByteBuffer bbuf = ByteBuffer . allocate ( 1 ) ; cbuf . put ( " \u00a5" ) ; cbuf . position ( 0 ) ; enc . encode ( cbuf , bbuf , true ) ; if ( bbuf . get ( 0 ) == ' \ \' ) { this . requiresEscapingEncoder = true ; } else { cbuf . clear ( ) ; bbuf . clear ( ) ; cbuf . put ( " \u20a9" ) ; cbuf . position ( 0 ) ; enc . encode ( cbuf , bbuf , true ) ; if ( bbuf . get ( 0 ) == ' \ \' ) { this . requiresEscapingEncoder = true ; } } } catch ( java . nio . charset . UnsupportedCharsetException ucex ) { try { byte bbuf [ ] = StringUtils . getBytes ( " \u00a5" , getEncoding ( ) ) ; if ( bbuf [ 0 ] == ' \ \' ) { this . requiresEscapingEncoder = true ; } else { bbuf = StringUtils . getBytes ( " \u20a9" , getEncoding ( ) ) ; if ( bbuf [ 0 ] == ' \ \' ) { this . requiresEscapingEncoder = true ; } } } catch ( UnsupportedEncodingException ueex ) { throw SQLError . createSQLException ( " Unable ▁ to ▁ use ▁ encoding : ▁ " + getEncoding ( ) , SQLError . SQL_STATE_GENERAL_ERROR , ueex , getExceptionInterceptor ( ) ) ; } } return characterSetAlreadyConfigured ; }
JackSprat/Knifeybot | private void configureTimezone ( ) throws SQLException { String configuredTimeZoneOnServer = this . serverVariables . get ( " timezone " ) ; if ( configuredTimeZoneOnServer == null ) { configuredTimeZoneOnServer = this . serverVariables . get ( " time _ zone " ) ; if ( " SYSTEM " . equalsIgnoreCase ( configuredTimeZoneOnServer ) ) { configuredTimeZoneOnServer = this . serverVariables . get ( " system _ time _ zone " ) ; } } String canonicalTimezone = getServerTimezone ( ) ; if ( ( getUseTimezone ( ) || ! getUseLegacyDatetimeCode ( ) ) && configuredTimeZoneOnServer != null ) { if ( canonicalTimezone == null || StringUtils . isEmptyOrWhitespaceOnly ( canonicalTimezone ) ) { try { canonicalTimezone = TimeUtil . getCanonicalTimezone ( configuredTimeZoneOnServer , getExceptionInterceptor ( ) ) ; } catch ( IllegalArgumentException iae ) { throw SQLError . createSQLException ( iae . getMessage ( ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } } if ( canonicalTimezone != null && canonicalTimezone . length ( ) > 0 ) { this . serverTimezoneTZ = TimeZone . getTimeZone ( canonicalTimezone ) ; if ( ! canonicalTimezone . equalsIgnoreCase ( " GMT " ) && this . serverTimezoneTZ . getID ( ) . equals ( " GMT " ) ) { throw SQLError . createSQLException ( " No ▁ timezone ▁ mapping ▁ entry ▁ for ▁ ' " + canonicalTimezone + " ' " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } this . isServerTzUTC = ! this . serverTimezoneTZ . useDaylightTime ( ) && this . serverTimezoneTZ . getRawOffset ( ) == 0 ; } }
JackSprat/Knifeybot | private void createInitialHistogram ( long [ ] breakpoints , long lowerBound , long upperBound ) { double bucketSize = ( ( ( double ) upperBound - ( double ) lowerBound ) / HISTOGRAM_BUCKETS ) * 1.25 ; if ( bucketSize < 1 ) { bucketSize = 1 ; } for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { breakpoints [ i ] = lowerBound ; lowerBound += bucketSize ; } }
JackSprat/Knifeybot | public void createNewIO ( boolean isForReconnect ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { Properties mergedProps = exposeAsProperties ( this . props ) ; if ( ! getHighAvailability ( ) ) { connectOneTryOnly ( isForReconnect , mergedProps ) ; return ; } connectWithRetries ( isForReconnect , mergedProps ) ; } }
JackSprat/Knifeybot | private void connectWithRetries ( boolean isForReconnect , Properties mergedProps ) throws SQLException { double timeout = getInitialTimeout ( ) ; boolean connectionGood = false ; Exception connectionException = null ; for ( int attemptCount = 0 ; ( attemptCount < getMaxReconnects ( ) ) && ! connectionGood ; attemptCount ++ ) { try { if ( this . io != null ) { this . io . forceClose ( ) ; } coreConnect ( mergedProps ) ; pingInternal ( false , 0 ) ; boolean oldAutoCommit ; int oldIsolationLevel ; boolean oldReadOnly ; String oldCatalog ; synchronized ( getConnectionMutex ( ) ) { this . connectionId = this . io . getThreadId ( ) ; this . isClosed = false ; oldAutoCommit = getAutoCommit ( ) ; oldIsolationLevel = this . isolationLevel ; oldReadOnly = isReadOnly ( false ) ; oldCatalog = getCatalog ( ) ; this . io . setStatementInterceptors ( this . statementInterceptors ) ; } initializePropsFromServer ( ) ; if ( isForReconnect ) { setAutoCommit ( oldAutoCommit ) ; if ( this . hasIsolationLevels ) { setTransactionIsolation ( oldIsolationLevel ) ; } setCatalog ( oldCatalog ) ; setReadOnly ( oldReadOnly ) ; } connectionGood = true ; break ; } catch ( Exception EEE ) { connectionException = EEE ; connectionGood = false ; } if ( connectionGood ) { break ; } if ( attemptCount > 0 ) { try { Thread . sleep ( ( long ) timeout * 1000 ) ; } catch ( InterruptedException IE ) { } } } if ( ! connectionGood ) { SQLException chainedEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnableToConnectWithRetries " , new Object [ ] { Integer . valueOf ( getMaxReconnects ( ) ) } ) , SQLError . SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE , getExceptionInterceptor ( ) ) ; chainedEx . initCause ( connectionException ) ; throw chainedEx ; } if ( getParanoid ( ) && ! getHighAvailability ( ) ) { this . password = null ; this . user = null ; } if ( isForReconnect ) { Iterator < Statement > statementIter = this . openStatements . iterator ( ) ; Stack < Statement > serverPreparedStatements = null ; while ( statementIter . hasNext ( ) ) { Statement statementObj = statementIter . next ( ) ; if ( statementObj instanceof ServerPreparedStatement ) { if ( serverPreparedStatements == null ) { serverPreparedStatements = new Stack < Statement > ( ) ; } serverPreparedStatements . add ( statementObj ) ; } } if ( serverPreparedStatements != null ) { while ( ! serverPreparedStatements . isEmpty ( ) ) { ( ( ServerPreparedStatement ) serverPreparedStatements . pop ( ) ) . rePrepare ( ) ; } } } }
JackSprat/Knifeybot | if ( protocol != null ) { if ( " tcp " . equalsIgnoreCase ( protocol ) ) { newHost = normalizeHost ( mergedProps . getProperty ( NonRegisteringDriver . HOST_PROPERTY_KEY ) ) ; newPort = parsePortNumber ( mergedProps . getProperty ( NonRegisteringDriver . PORT_PROPERTY_KEY , "3306" ) ) ; } else if ( " pipe " . equalsIgnoreCase ( protocol ) ) { setSocketFactoryClassName ( NamedPipeSocketFactory . class . getName ( ) ) ; String path = mergedProps . getProperty ( NonRegisteringDriver . PATH_PROPERTY_KEY ) ; if ( path != null ) { mergedProps . setProperty ( NamedPipeSocketFactory . NAMED_PIPE_PROP_NAME , path ) ; } } else { newHost = normalizeHost ( mergedProps . getProperty ( NonRegisteringDriver . HOST_PROPERTY_KEY ) ) ; newPort = parsePortNumber ( mergedProps . getProperty ( NonRegisteringDriver . PORT_PROPERTY_KEY , "3306" ) ) ; } }
JackSprat/Knifeybot | if ( parsedHostPortPair [ NonRegisteringDriver . PORT_NUMBER_INDEX ] != null ) { newPort = parsePortNumber ( parsedHostPortPair [ NonRegisteringDriver . PORT_NUMBER_INDEX ] ) ; }
JackSprat/Knifeybot | if ( versionMeetsMinimum ( 5 , 5 , 0 ) ) { this . errorMessageEncoding = this . io . getEncodingForHandshake ( ) ; }
JackSprat/Knifeybot | private String normalizeHost ( String hostname ) { if ( hostname == null || StringUtils . isEmptyOrWhitespaceOnly ( hostname ) ) { return " localhost " ; } return hostname ; }
JackSprat/Knifeybot | private int parsePortNumber ( String portAsString ) throws SQLException { int portNumber = 3306 ; try { portNumber = Integer . parseInt ( portAsString ) ; } catch ( NumberFormatException nfe ) { throw SQLError . createSQLException ( " Illegal ▁ connection ▁ port ▁ value ▁ ' " + portAsString + " ' " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } return portNumber ; }
JackSprat/Knifeybot | private void connectOneTryOnly ( boolean isForReconnect , Properties mergedProps ) throws SQLException { Exception connectionNotEstablishedBecause = null ; try { coreConnect ( mergedProps ) ; this . connectionId = this . io . getThreadId ( ) ; this . isClosed = false ; boolean oldAutoCommit = getAutoCommit ( ) ; int oldIsolationLevel = this . isolationLevel ; boolean oldReadOnly = isReadOnly ( false ) ; String oldCatalog = getCatalog ( ) ; this . io . setStatementInterceptors ( this . statementInterceptors ) ; initializePropsFromServer ( ) ; if ( isForReconnect ) { setAutoCommit ( oldAutoCommit ) ; if ( this . hasIsolationLevels ) { setTransactionIsolation ( oldIsolationLevel ) ; } setCatalog ( oldCatalog ) ; setReadOnly ( oldReadOnly ) ; } return ; } catch ( Exception EEE ) { if ( EEE instanceof SQLException && ( ( SQLException ) EEE ) . getErrorCode ( ) == MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD && ! getDisconnectOnExpiredPasswords ( ) ) { return ; } if ( this . io != null ) { this . io . forceClose ( ) ; } connectionNotEstablishedBecause = EEE ; if ( EEE instanceof SQLException ) { throw ( SQLException ) EEE ; } SQLException chainedEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnableToConnect " ) , SQLError . SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE , getExceptionInterceptor ( ) ) ; chainedEx . initCause ( connectionNotEstablishedBecause ) ; throw chainedEx ; } }
JackSprat/Knifeybot | private void createPreparedStatementCaches ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { int cacheSize = getPreparedStatementCacheSize ( ) ; try { Class < ? > factoryClass ; factoryClass = Class . forName ( getParseInfoCacheFactory ( ) ) ; @ SuppressWarnings ( " unchecked " ) CacheAdapterFactory < String , ParseInfo > cacheFactory = ( ( CacheAdapterFactory < String , ParseInfo > ) factoryClass . newInstance ( ) ) ; this . cachedPreparedStatementParams = cacheFactory . getInstance ( this , this . myURL , getPreparedStatementCacheSize ( ) , getPreparedStatementCacheSqlLimit ( ) , this . props ) ; } catch ( ClassNotFoundException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantFindCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( InstantiationException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( IllegalAccessException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } if ( getUseServerPreparedStmts ( ) ) { this . serverSideStatementCheckCache = new LRUCache ( cacheSize ) ; this . serverSideStatementCache = new LRUCache ( cacheSize ) { private static final long serialVersionUID = 7692318650375988114L ; @ Override protected boolean removeEldestEntry ( java . util . Map . Entry < Object , Object > eldest ) { if ( this . maxElements <= 1 ) { return false ; } boolean removeIt = super . removeEldestEntry ( eldest ) ; if ( removeIt ) { ServerPreparedStatement ps = ( ServerPreparedStatement ) eldest . getValue ( ) ; ps . isCached = false ; ps . setClosed ( false ) ; try { ps . close ( ) ; } catch ( SQLException sqlEx ) { } } return removeIt ; } } ; } } }
JackSprat/Knifeybot | public java . sql . Statement createStatement ( ) throws SQLException { return createStatement ( DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . Statement createStatement ( int resultSetType , int resultSetConcurrency ) throws SQLException { checkClosed ( ) ; StatementImpl stmt = new StatementImpl ( getMultiHostSafeProxy ( ) , this . database ) ; stmt . setResultSetType ( resultSetType ) ; stmt . setResultSetConcurrency ( resultSetConcurrency ) ; return stmt ; }
JackSprat/Knifeybot | public java . sql . Statement createStatement ( int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return createStatement ( resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public void dumpTestcaseQuery ( String query ) { System . err . println ( query ) ; }
JackSprat/Knifeybot | public Connection duplicate ( ) throws SQLException { return new ConnectionImpl ( this . origHostToConnectTo , this . origPortToConnectTo , this . props , this . origDatabaseToConnectTo , this . myURL ) ; }
JackSprat/Knifeybot | public ResultSetInternalMethods execSQL ( StatementImpl callingStatement , String sql , int maxRows , Buffer packet , int resultSetType , int resultSetConcurrency , boolean streamResults , String catalog , Field [ ] cachedMetadata ) throws SQLException { return execSQL ( callingStatement , sql , maxRows , packet , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata , false ) ; }
JackSprat/Knifeybot | public ResultSetInternalMethods execSQL ( StatementImpl callingStatement , String sql , int maxRows , Buffer packet , int resultSetType , int resultSetConcurrency , boolean streamResults , String catalog , Field [ ] cachedMetadata , boolean isBatch ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { long queryStartTime = 0 ; int endOfQueryPacketPosition = 0 ; if ( packet != null ) { endOfQueryPacketPosition = packet . getPosition ( ) ; } if ( getGatherPerformanceMetrics ( ) ) { queryStartTime = System . currentTimeMillis ( ) ; } this . lastQueryFinishedTime = 0 ; if ( ( getHighAvailability ( ) ) && ( this . autoCommit || getAutoReconnectForPools ( ) ) && this . needsPing && ! isBatch ) { try { pingInternal ( false , 0 ) ; this . needsPing = false ; } catch ( Exception Ex ) { createNewIO ( true ) ; } } try { if ( packet == null ) { String encoding = null ; if ( getUseUnicode ( ) ) { encoding = getEncoding ( ) ; } return this . io . sqlQueryDirect ( callingStatement , sql , encoding , null , maxRows , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata ) ; } return this . io . sqlQueryDirect ( callingStatement , null , null , packet , maxRows , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata ) ; } catch ( java . sql . SQLException sqlE ) { if ( getDumpQueriesOnException ( ) ) { String extractedSql = extractSqlFromPacket ( sql , packet , endOfQueryPacketPosition ) ; StringBuilder messageBuf = new StringBuilder ( extractedSql . length ( ) + 32 ) ; messageBuf . append ( " \n \n Query ▁ being ▁ executed ▁ when ▁ exception ▁ was ▁ thrown : \n " ) ; messageBuf . append ( extractedSql ) ; messageBuf . append ( " \n \n " ) ; sqlE = appendMessageToException ( sqlE , messageBuf . toString ( ) , getExceptionInterceptor ( ) ) ; } if ( ( getHighAvailability ( ) ) ) { this . needsPing = true ; } else { String sqlState = sqlE . getSQLState ( ) ; if ( ( sqlState != null ) && sqlState . equals ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE ) ) { cleanup ( sqlE ) ; } } throw sqlE ; } catch ( Exception ex ) { if ( getHighAvailability ( ) ) { this . needsPing = true ; } else if ( ex instanceof IOException ) { cleanup ( ex ) ; } SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnexpectedException " ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } finally { if ( getMaintainTimeStats ( ) ) { this . lastQueryFinishedTime = System . currentTimeMillis ( ) ; } if ( getGatherPerformanceMetrics ( ) ) { long queryTime = System . currentTimeMillis ( ) - queryStartTime ; registerQueryExecutionTime ( queryTime ) ; } } } }
JackSprat/Knifeybot | public String extractSqlFromPacket ( String possibleSqlQuery , Buffer queryPacket , int endOfQueryPacketPosition ) throws SQLException { String extractedSql = null ; if ( possibleSqlQuery != null ) { if ( possibleSqlQuery . length ( ) > getMaxQuerySizeToLog ( ) ) { StringBuilder truncatedQueryBuf = new StringBuilder ( possibleSqlQuery . substring ( 0 , getMaxQuerySizeToLog ( ) ) ) ; truncatedQueryBuf . append ( Messages . getString ( " MysqlIO . 25" ) ) ; extractedSql = truncatedQueryBuf . toString ( ) ; } else { extractedSql = possibleSqlQuery ; } } if ( extractedSql == null ) { int extractPosition = endOfQueryPacketPosition ; boolean truncated = false ; if ( endOfQueryPacketPosition > getMaxQuerySizeToLog ( ) ) { extractPosition = getMaxQuerySizeToLog ( ) ; truncated = true ; } extractedSql = StringUtils . toString ( queryPacket . getByteBuffer ( ) , 5 , ( extractPosition - 5 ) ) ; if ( truncated ) { extractedSql += Messages . getString ( " MysqlIO . 25" ) ; } } return extractedSql ; }
JackSprat/Knifeybot | public StringBuilder generateConnectionCommentBlock ( StringBuilder buf ) { buf . append ( " /* ▁ conn ▁ id ▁ " ) ; buf . append ( getId ( ) ) ; buf . append ( " ▁ clock : ▁ " ) ; buf . append ( System . currentTimeMillis ( ) ) ; buf . append ( " ▁ */ ▁ " ) ; return buf ; }
JackSprat/Knifeybot | public int getActiveStatementCount ( ) { return this . openStatements . size ( ) ; }
JackSprat/Knifeybot | public boolean getAutoCommit ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { return this . autoCommit ; } }
JackSprat/Knifeybot | public Calendar getCalendarInstanceForSessionOrNew ( ) { if ( getDynamicCalendars ( ) ) { return Calendar . getInstance ( ) ; } return getSessionLockedCalendar ( ) ; }
JackSprat/Knifeybot | public String getCatalog ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { return this . database ; } }
JackSprat/Knifeybot | public String getCharacterSetMetadata ( ) { synchronized ( getConnectionMutex ( ) ) { return this . characterSetMetadata ; } }
JackSprat/Knifeybot | public SingleByteCharsetConverter getCharsetConverter ( String javaEncodingName ) throws SQLException { if ( javaEncodingName == null ) { return null ; } if ( this . usePlatformCharsetConverters ) { return null ; } SingleByteCharsetConverter converter = null ; synchronized ( this . charsetConverterMap ) { Object asObject = this . charsetConverterMap . get ( javaEncodingName ) ; if ( asObject == CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) { return null ; } converter = ( SingleByteCharsetConverter ) asObject ; if ( converter == null ) { try { converter = SingleByteCharsetConverter . getInstance ( javaEncodingName , this ) ; if ( converter == null ) { this . charsetConverterMap . put ( javaEncodingName , CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) ; } else { this . charsetConverterMap . put ( javaEncodingName , converter ) ; } } catch ( UnsupportedEncodingException unsupEncEx ) { this . charsetConverterMap . put ( javaEncodingName , CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) ; converter = null ; } } } return converter ; }
JackSprat/Knifeybot | @ Deprecated public String getCharsetNameForIndex ( int charsetIndex ) throws SQLException { return getEncodingForIndex ( charsetIndex ) ; }
JackSprat/Knifeybot | public String getEncodingForIndex ( int charsetIndex ) throws SQLException { String javaEncoding = null ; if ( getUseOldUTF8Behavior ( ) ) { return getEncoding ( ) ; } if ( charsetIndex != MysqlDefs . NO_CHARSET_INFO ) { try { if ( this . indexToMysqlCharset . size ( ) > 0 ) { javaEncoding = CharsetMapping . getJavaEncodingForMysqlCharset ( this . indexToMysqlCharset . get ( charsetIndex ) , getEncoding ( ) ) ; } if ( javaEncoding == null ) { javaEncoding = CharsetMapping . getJavaEncodingForCollationIndex ( charsetIndex , getEncoding ( ) ) ; } } catch ( ArrayIndexOutOfBoundsException outOfBoundsEx ) { throw SQLError . createSQLException ( " Unknown ▁ character ▁ set ▁ index ▁ for ▁ field ▁ ' " + charsetIndex + " ' ▁ received ▁ from ▁ server . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( javaEncoding == null ) { javaEncoding = getEncoding ( ) ; } } else { javaEncoding = getEncoding ( ) ; } return javaEncoding ; }
JackSprat/Knifeybot | public TimeZone getDefaultTimeZone ( ) { return getCacheDefaultTimezone ( ) ? this . defaultTimeZone : TimeUtil . getDefaultTimeZone ( false ) ; }
JackSprat/Knifeybot | public String getErrorMessageEncoding ( ) { return this . errorMessageEncoding ; }
JackSprat/Knifeybot | public int getHoldability ( ) throws SQLException { return java . sql . ResultSet . CLOSE_CURSORS_AT_COMMIT ; }
JackSprat/Knifeybot | public long getId ( ) { return this . connectionId ; }
JackSprat/Knifeybot | public long getIdleFor ( ) { synchronized ( getConnectionMutex ( ) ) { if ( this . lastQueryFinishedTime == 0 ) { return 0 ; } long now = System . currentTimeMillis ( ) ; long idleTime = now - this . lastQueryFinishedTime ; return idleTime ; } }
JackSprat/Knifeybot | public MysqlIO getIO ( ) throws SQLException { if ( ( this . io == null ) || this . isClosed ) { throw SQLError . createSQLException ( " Operation ▁ not ▁ allowed ▁ on ▁ closed ▁ connection " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } return this . io ; }
JackSprat/Knifeybot | public Log getLog ( ) throws SQLException { return this . log ; }
JackSprat/Knifeybot | public int getMaxBytesPerChar ( String javaCharsetName ) throws SQLException { return getMaxBytesPerChar ( null , javaCharsetName ) ; }
JackSprat/Knifeybot | public int getMaxBytesPerChar ( Integer charsetIndex , String javaCharsetName ) throws SQLException { String charset = null ; int res = 1 ; try { if ( this . indexToCustomMysqlCharset != null ) { charset = this . indexToCustomMysqlCharset . get ( charsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetNameForCollationIndex ( charsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetForJavaEncoding ( javaCharsetName , this ) ; } Integer mblen = null ; if ( this . mysqlCharsetToCustomMblen != null ) { mblen = this . mysqlCharsetToCustomMblen . get ( charset ) ; } if ( mblen == null ) { mblen = CharsetMapping . getMblen ( charset ) ; } if ( mblen != null ) { res = mblen . intValue ( ) ; } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } return res ; }
JackSprat/Knifeybot | public java . sql . DatabaseMetaData getMetaData ( ) throws SQLException { return getMetaData ( true , true ) ; }
JackSprat/Knifeybot | private java . sql . DatabaseMetaData getMetaData ( boolean checkClosed , boolean checkForInfoSchema ) throws SQLException { if ( checkClosed ) { checkClosed ( ) ; } return com . mysql . jdbc . DatabaseMetaData . getInstance ( getMultiHostSafeProxy ( ) , this . database , checkForInfoSchema ) ; }
JackSprat/Knifeybot | public java . sql . Statement getMetadataSafeStatement ( ) throws SQLException { java . sql . Statement stmt = createStatement ( ) ; if ( stmt . getMaxRows ( ) != 0 ) { stmt . setMaxRows ( 0 ) ; } stmt . setEscapeProcessing ( false ) ; if ( stmt . getFetchSize ( ) != 0 ) { stmt . setFetchSize ( 0 ) ; } return stmt ; }
JackSprat/Knifeybot | public int getNetBufferLength ( ) { return this . netBufferLength ; }
JackSprat/Knifeybot | @ Deprecated public String getServerCharacterEncoding ( ) { return getServerCharset ( ) ; }
JackSprat/Knifeybot | public String getServerCharset ( ) { if ( this . io . versionMeetsMinimum ( 4 , 1 , 0 ) ) { String charset = null ; if ( this . indexToCustomMysqlCharset != null ) { charset = this . indexToCustomMysqlCharset . get ( this . io . serverCharsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetNameForCollationIndex ( this . io . serverCharsetIndex ) ; } return charset != null ? charset : this . serverVariables . get ( " character _ set _ server " ) ; } return this . serverVariables . get ( " character _ set " ) ; }
JackSprat/Knifeybot | public int getServerMajorVersion ( ) { return this . io . getServerMajorVersion ( ) ; }
JackSprat/Knifeybot | public int getServerMinorVersion ( ) { return this . io . getServerMinorVersion ( ) ; }
JackSprat/Knifeybot | public int getServerSubMinorVersion ( ) { return this . io . getServerSubMinorVersion ( ) ; }
JackSprat/Knifeybot | public TimeZone getServerTimezoneTZ ( ) { return this . serverTimezoneTZ ; }
JackSprat/Knifeybot | public String getServerVariable ( String variableName ) { if ( this . serverVariables != null ) { return this . serverVariables . get ( variableName ) ; } return null ; }
JackSprat/Knifeybot | public String getServerVersion ( ) { return this . io . getServerVersion ( ) ; }
JackSprat/Knifeybot | public Calendar getSessionLockedCalendar ( ) { return this . sessionCalendar ; }
JackSprat/Knifeybot | public int getTransactionIsolation ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . hasIsolationLevels && ! getUseLocalSessionState ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { stmt = getMetadataSafeStatement ( ) ; String query = null ; int offset = 0 ; if ( versionMeetsMinimum ( 4 , 0 , 3 ) ) { query = " SELECT ▁ @ @ session . tx _ isolation " ; offset = 1 ; } else { query = " SHOW ▁ VARIABLES ▁ LIKE ▁ ' transaction _ isolation ' " ; offset = 2 ; } rs = stmt . executeQuery ( query ) ; if ( rs . next ( ) ) { String s = rs . getString ( offset ) ; if ( s != null ) { Integer intTI = mapTransIsolationNameToValue . get ( s ) ; if ( intTI != null ) { return intTI . intValue ( ) ; } } throw SQLError . createSQLException ( " Could ▁ not ▁ map ▁ transaction ▁ isolation ▁ ' " + s + " ▁ to ▁ a ▁ valid ▁ JDBC ▁ level . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } throw SQLError . createSQLException ( " Could ▁ not ▁ retrieve ▁ transaction ▁ isolation ▁ level ▁ from ▁ server " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { } stmt = null ; } } } return this . isolationLevel ; } }
JackSprat/Knifeybot | public java . util . Map < String , Class < ? > > getTypeMap ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . typeMap == null ) { this . typeMap = new HashMap < String , Class < ? > > ( ) ; } return this . typeMap ; } }
JackSprat/Knifeybot | public String getURL ( ) { return this . myURL ; }
JackSprat/Knifeybot | public String getUser ( ) { return this . user ; }
JackSprat/Knifeybot | public Calendar getUtcCalendar ( ) { return this . utcCalendar ; }
JackSprat/Knifeybot | public SQLWarning getWarnings ( ) throws SQLException { return null ; }
JackSprat/Knifeybot | public boolean hasSameProperties ( Connection c ) { return this . props . equals ( c . getProperties ( ) ) ; }
JackSprat/Knifeybot | public Properties getProperties ( ) { return this . props ; }
JackSprat/Knifeybot | @ Deprecated public boolean hasTriedMaster ( ) { return this . hasTriedMasterFlag ; }
JackSprat/Knifeybot | public void incrementNumberOfPreparedExecutes ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfPreparedExecutes ++ ; this . numberOfQueriesIssued ++ ; } }
JackSprat/Knifeybot | public void incrementNumberOfPrepares ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfPrepares ++ ; } }
JackSprat/Knifeybot | public void incrementNumberOfResultSetsCreated ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfResultSetsCreated ++ ; } }
JackSprat/Knifeybot | private void initializeDriverProperties ( Properties info ) throws SQLException { initializeProperties ( info ) ; String exceptionInterceptorClasses = getExceptionInterceptors ( ) ; if ( exceptionInterceptorClasses != null && ! " " . equals ( exceptionInterceptorClasses ) ) { this . exceptionInterceptor = new ExceptionInterceptorChain ( exceptionInterceptorClasses ) ; } this . usePlatformCharsetConverters = getUseJvmCharsetConverters ( ) ; this . log = LogFactory . getLogger ( getLogger ( ) , LOGGER_INSTANCE_NAME , getExceptionInterceptor ( ) ) ; if ( getProfileSql ( ) || getUseUsageAdvisor ( ) ) { this . eventSink = ProfilerEventHandlerFactory . getInstance ( getMultiHostSafeProxy ( ) ) ; } if ( getCachePreparedStatements ( ) ) { createPreparedStatementCaches ( ) ; } if ( getNoDatetimeStringSync ( ) && getUseTimezone ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ enable ▁ noDatetimeStringSync ▁ and ▁ useTimezone ▁ configuration ▁ properties ▁ at ▁ the ▁ same ▁ time " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } if ( getCacheCallableStatements ( ) ) { this . parsedCallableStatementCache = new LRUCache ( getCallableStatementCacheSize ( ) ) ; } if ( getAllowMultiQueries ( ) ) { setCacheResultSetMetadata ( false ) ; } if ( getCacheResultSetMetadata ( ) ) { this . resultSetMetadataCache = new LRUCache ( getMetadataCacheSize ( ) ) ; } if ( getSocksProxyHost ( ) != null ) { setSocketFactoryClassName ( " com . mysql . jdbc . SocksProxySocketFactory " ) ; } }
JackSprat/Knifeybot | private void initializePropsFromServer ( ) throws SQLException { String connectionInterceptorClasses = getConnectionLifecycleInterceptors ( ) ; this . connectionLifecycleInterceptors = null ; if ( connectionInterceptorClasses != null ) { this . connectionLifecycleInterceptors = Util . loadExtensions ( this , this . props , connectionInterceptorClasses , " Connection . badLifecycleInterceptor " , getExceptionInterceptor ( ) ) ; } setSessionVariables ( ) ; if ( ! versionMeetsMinimum ( 4 , 1 , 0 ) ) { setTransformedBitIsBoolean ( false ) ; } this . parserKnowsUnicode = versionMeetsMinimum ( 4 , 1 , 0 ) ; if ( getUseServerPreparedStmts ( ) && versionMeetsMinimum ( 4 , 1 , 0 ) ) { this . useServerPreparedStmts = true ; if ( versionMeetsMinimum ( 5 , 0 , 0 ) && ! versionMeetsMinimum ( 5 , 0 , 3 ) ) { this . useServerPreparedStmts = false ; } } if ( versionMeetsMinimum ( 3 , 21 , 22 ) ) { loadServerVariables ( ) ; if ( versionMeetsMinimum ( 5 , 0 , 2 ) ) { this . autoIncrementIncrement = getServerVariableAsInt ( " auto _ increment _ increment " , 1 ) ; } else { this . autoIncrementIncrement = 1 ; } buildCollationMapping ( ) ; LicenseConfiguration . checkLicenseType ( this . serverVariables ) ; String lowerCaseTables = this . serverVariables . get ( " lower _ case _ table _ names " ) ; this . lowerCaseTableNames = " on " . equalsIgnoreCase ( lowerCaseTables ) || "1" . equalsIgnoreCase ( lowerCaseTables ) || "2" . equalsIgnoreCase ( lowerCaseTables ) ; this . storesLowerCaseTableName = "1" . equalsIgnoreCase ( lowerCaseTables ) || " on " . equalsIgnoreCase ( lowerCaseTables ) ; configureTimezone ( ) ; if ( this . serverVariables . containsKey ( " max _ allowed _ packet " ) ) { int serverMaxAllowedPacket = getServerVariableAsInt ( " max _ allowed _ packet " , - 1 ) ; if ( serverMaxAllowedPacket != - 1 && ( serverMaxAllowedPacket < getMaxAllowedPacket ( ) || getMaxAllowedPacket ( ) <= 0 ) ) { setMaxAllowedPacket ( serverMaxAllowedPacket ) ; } else if ( serverMaxAllowedPacket == - 1 && getMaxAllowedPacket ( ) == - 1 ) { setMaxAllowedPacket ( 65535 ) ; } if ( getUseServerPrepStmts ( ) ) { int preferredBlobSendChunkSize = getBlobSendChunkSize ( ) ; int packetHeaderSize = ServerPreparedStatement . BLOB_STREAM_READ_BUF_SIZE + 11 ; int allowedBlobSendChunkSize = Math . min ( preferredBlobSendChunkSize , getMaxAllowedPacket ( ) ) - packetHeaderSize ; if ( allowedBlobSendChunkSize <= 0 ) { throw SQLError . createSQLException ( " Connection ▁ setting ▁ too ▁ low ▁ for ▁ ' maxAllowedPacket ' . ▁ " + " When ▁ ' useServerPrepStmts = true ' , ▁ ' maxAllowedPacket ' ▁ must ▁ be ▁ higher ▁ than ▁ " + packetHeaderSize + " . ▁ Check ▁ also ▁ ' max _ allowed _ packet ' ▁ in ▁ MySQL ▁ configuration ▁ files . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } setBlobSendChunkSize ( String . valueOf ( allowedBlobSendChunkSize ) ) ; } } if ( this . serverVariables . containsKey ( " net _ buffer _ length " ) ) { this . netBufferLength = getServerVariableAsInt ( " net _ buffer _ length " , 16 * 1024 ) ; } checkTransactionIsolationLevel ( ) ; if ( ! versionMeetsMinimum ( 4 , 1 , 0 ) ) { checkServerEncoding ( ) ; } this . io . checkForCharsetMismatch ( ) ; if ( this . serverVariables . containsKey ( " sql _ mode " ) ) { String sqlModeAsString = this . serverVariables . get ( " sql _ mode " ) ; if ( StringUtils . isStrictlyNumeric ( sqlModeAsString ) ) { this . useAnsiQuotes = ( Integer . parseInt ( sqlModeAsString ) & 4 ) > 0 ; } else if ( sqlModeAsString != null ) { this . useAnsiQuotes = sqlModeAsString . indexOf ( " ANSI _ QUOTES " ) != - 1 ; this . noBackslashEscapes = sqlModeAsString . indexOf ( " NO _ BACKSLASH _ ESCAPES " ) != - 1 ; } } } boolean overrideDefaultAutocommit = isAutoCommitNonDefaultOnServer ( ) ; configureClientCharacterSet ( false ) ; try { this . errorMessageEncoding = CharsetMapping . getCharacterEncodingForErrorMessages ( this ) ; } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( versionMeetsMinimum ( 3 , 23 , 15 ) ) { this . transactionsSupported = true ; if ( ! overrideDefaultAutocommit ) { try { setAutoCommit ( true ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } } else { this . transactionsSupported = false ; } if ( versionMeetsMinimum ( 3 , 23 , 36 ) ) { this . hasIsolationLevels = true ; } else { this . hasIsolationLevels = false ; } this . hasQuotedIdentifiers = versionMeetsMinimum ( 3 , 23 , 6 ) ; this . io . resetMaxBuf ( ) ; if ( this . io . versionMeetsMinimum ( 4 , 1 , 0 ) ) { String characterSetResultsOnServerMysql = this . serverVariables . get ( JDBC_LOCAL_CHARACTER_SET_RESULTS ) ; if ( characterSetResultsOnServerMysql == null || StringUtils . startsWithIgnoreCaseAndWs ( characterSetResultsOnServerMysql , " NULL " ) || characterSetResultsOnServerMysql . length ( ) == 0 ) { String defaultMetadataCharsetMysql = this . serverVariables . get ( " character _ set _ system " ) ; String defaultMetadataCharset = null ; if ( defaultMetadataCharsetMysql != null ) { defaultMetadataCharset = CharsetMapping . getJavaEncodingForMysqlCharset ( defaultMetadataCharsetMysql ) ; } else { defaultMetadataCharset = " UTF - 8" ; } this . characterSetMetadata = defaultMetadataCharset ; } else { this . characterSetResultsOnServer = CharsetMapping . getJavaEncodingForMysqlCharset ( characterSetResultsOnServerMysql ) ; this . characterSetMetadata = this . characterSetResultsOnServer ; } } else { this . characterSetMetadata = getEncoding ( ) ; } if ( versionMeetsMinimum ( 4 , 1 , 0 ) && ! this . versionMeetsMinimum ( 4 , 1 , 10 ) && getAllowMultiQueries ( ) ) { if ( isQueryCacheEnabled ( ) ) { setAllowMultiQueries ( false ) ; } } if ( versionMeetsMinimum ( 5 , 0 , 0 ) && ( getUseLocalTransactionState ( ) || getElideSetAutoCommits ( ) ) && isQueryCacheEnabled ( ) && ! versionMeetsMinimum ( 5 , 1 , 32 ) ) { setUseLocalTransactionState ( false ) ; setElideSetAutoCommits ( false ) ; } setupServerForTruncationChecks ( ) ; }
JackSprat/Knifeybot | private boolean isQueryCacheEnabled ( ) { return " ON " . equalsIgnoreCase ( this . serverVariables . get ( " query _ cache _ type " ) ) && ! "0" . equalsIgnoreCase ( this . serverVariables . get ( " query _ cache _ size " ) ) ; }
JackSprat/Knifeybot | private int getServerVariableAsInt ( String variableName , int fallbackValue ) throws SQLException { try { return Integer . parseInt ( this . serverVariables . get ( variableName ) ) ; } catch ( NumberFormatException nfe ) { getLog ( ) . logWarn ( Messages . getString ( " Connection . BadValueInServerVariables " , new Object [ ] { variableName , this . serverVariables . get ( variableName ) , Integer . valueOf ( fallbackValue ) } ) ) ; return fallbackValue ; } }
JackSprat/Knifeybot | private boolean isAutoCommitNonDefaultOnServer ( ) throws SQLException { boolean overrideDefaultAutocommit = false ; String initConnectValue = this . serverVariables . get ( " init _ connect " ) ; if ( versionMeetsMinimum ( 4 , 1 , 2 ) && initConnectValue != null && initConnectValue . length ( ) > 0 ) { if ( ! getElideSetAutoCommits ( ) ) { java . sql . ResultSet rs = null ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; rs = stmt . executeQuery ( " SELECT ▁ @ @ session . autocommit " ) ; if ( rs . next ( ) ) { this . autoCommit = rs . getBoolean ( 1 ) ; if ( this . autoCommit != true ) { overrideDefaultAutocommit = true ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException sqlEx ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlEx ) { } } } } else { if ( this . getIO ( ) . isSetNeededForAutoCommitMode ( true ) ) { this . autoCommit = false ; overrideDefaultAutocommit = true ; } } } return overrideDefaultAutocommit ; }
JackSprat/Knifeybot | public boolean isClientTzUTC ( ) { return this . isClientTzUTC ; }
JackSprat/Knifeybot | public boolean isClosed ( ) { return this . isClosed ; }
JackSprat/Knifeybot | public boolean isCursorFetchEnabled ( ) throws SQLException { return ( versionMeetsMinimum ( 5 , 0 , 2 ) && getUseCursorFetch ( ) ) ; }
JackSprat/Knifeybot | public boolean isInGlobalTx ( ) { return this . isInGlobalTx ; }
JackSprat/Knifeybot | public boolean isMasterConnection ( ) { return false ; }
JackSprat/Knifeybot | public boolean isNoBackslashEscapesSet ( ) { return this . noBackslashEscapes ; }
JackSprat/Knifeybot | public boolean isReadInfoMsgEnabled ( ) { return this . readInfoMsg ; }
JackSprat/Knifeybot | public boolean isReadOnly ( ) throws SQLException { return isReadOnly ( true ) ; }
JackSprat/Knifeybot | public boolean isReadOnly ( boolean useSessionStatus ) throws SQLException { if ( useSessionStatus && ! this . isClosed && versionMeetsMinimum ( 5 , 6 , 5 ) && ! getUseLocalSessionState ( ) && getReadOnlyPropagatesToServer ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { try { stmt = getMetadataSafeStatement ( ) ; rs = stmt . executeQuery ( " select ▁ @ @ session . tx _ read _ only " ) ; if ( rs . next ( ) ) { return rs . getInt ( 1 ) != 0 ; } } catch ( SQLException ex1 ) { if ( ex1 . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw SQLError . createSQLException ( " Could ▁ not ▁ retrieve ▁ transation ▁ read - only ▁ status ▁ server " , SQLError . SQL_STATE_GENERAL_ERROR , ex1 , getExceptionInterceptor ( ) ) ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { } stmt = null ; } } } return this . readOnly ; }
JackSprat/Knifeybot | public boolean isRunningOnJDK13 ( ) { return this . isRunningOnJDK13 ; }
JackSprat/Knifeybot | public boolean isSameResource ( Connection otherConnection ) { synchronized ( getConnectionMutex ( ) ) { if ( otherConnection == null ) { return false ; } boolean directCompare = true ; String otherHost = ( ( ConnectionImpl ) otherConnection ) . origHostToConnectTo ; String otherOrigDatabase = ( ( ConnectionImpl ) otherConnection ) . origDatabaseToConnectTo ; String otherCurrentCatalog = ( ( ConnectionImpl ) otherConnection ) . database ; if ( ! nullSafeCompare ( otherHost , this . origHostToConnectTo ) ) { directCompare = false ; } else if ( otherHost != null && otherHost . indexOf ( ' , ' ) == - 1 && otherHost . indexOf ( ' : ' ) == - 1 ) { directCompare = ( ( ( ConnectionImpl ) otherConnection ) . origPortToConnectTo == this . origPortToConnectTo ) ; } if ( directCompare ) { if ( ! nullSafeCompare ( otherOrigDatabase , this . origDatabaseToConnectTo ) || ! nullSafeCompare ( otherCurrentCatalog , this . database ) ) { directCompare = false ; } } if ( directCompare ) { return true ; } String otherResourceId = ( ( ConnectionImpl ) otherConnection ) . getResourceId ( ) ; String myResourceId = getResourceId ( ) ; if ( otherResourceId != null || myResourceId != null ) { directCompare = nullSafeCompare ( otherResourceId , myResourceId ) ; if ( directCompare ) { return true ; } } return false ; } }
JackSprat/Knifeybot | public boolean isServerTzUTC ( ) { return this . isServerTzUTC ; }
JackSprat/Knifeybot | private void createConfigCacheIfNeeded ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . serverConfigCache != null ) { return ; } try { Class < ? > factoryClass ; factoryClass = Class . forName ( getServerConfigCacheFactory ( ) ) ; @ SuppressWarnings ( " unchecked " ) CacheAdapterFactory < String , Map < String , String > > cacheFactory = ( ( CacheAdapterFactory < String , Map < String , String > > ) factoryClass . newInstance ( ) ) ; this . serverConfigCache = cacheFactory . getInstance ( this , this . myURL , Integer . MAX_VALUE , Integer . MAX_VALUE , this . props ) ; ExceptionInterceptor evictOnCommsError = new ExceptionInterceptor ( ) { public void init ( Connection conn , Properties config ) throws SQLException { } public void destroy ( ) { } @ SuppressWarnings ( " synthetic - access " ) public SQLException interceptException ( SQLException sqlEx , Connection conn ) { if ( sqlEx . getSQLState ( ) != null && sqlEx . getSQLState ( ) . startsWith ( "08" ) ) { ConnectionImpl . this . serverConfigCache . invalidate ( getURL ( ) ) ; } return null ; } } ; if ( this . exceptionInterceptor == null ) { this . exceptionInterceptor = evictOnCommsError ; } else { ( ( ExceptionInterceptorChain ) this . exceptionInterceptor ) . addRingZero ( evictOnCommsError ) ; } } catch ( ClassNotFoundException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantFindCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( InstantiationException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( IllegalAccessException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } } }
JackSprat/Knifeybot | private void loadServerVariables ( ) throws SQLException { if ( getCacheServerConfiguration ( ) ) { createConfigCacheIfNeeded ( ) ; Map < String , String > cachedVariableMap = this . serverConfigCache . get ( getURL ( ) ) ; if ( cachedVariableMap != null ) { String cachedServerVersion = cachedVariableMap . get ( SERVER_VERSION_STRING_var_NAME ) ; if ( cachedServerVersion != null && this . io . getServerVersion ( ) != null && cachedServerVersion . equals ( this . io . getServerVersion ( ) ) ) { this . serverVariables = cachedVariableMap ; return ; } this . serverConfigCache . invalidate ( getURL ( ) ) ; } } java . sql . Statement stmt = null ; java . sql . ResultSet results = null ; try { stmt = getMetadataSafeStatement ( ) ; String version = this . dbmd . getDriverVersion ( ) ; if ( version != null && version . indexOf ( ' * ' ) != - 1 ) { StringBuilder buf = new StringBuilder ( version . length ( ) + 10 ) ; for ( int i = 0 ; i < version . length ( ) ; i ++ ) { char c = version . charAt ( i ) ; if ( c == ' * ' ) { buf . append ( " [ star ] " ) ; } else { buf . append ( c ) ; } } version = buf . toString ( ) ; } String versionComment = ( this . getParanoid ( ) || version == null ) ? " " : " /* ▁ " + version + " ▁ */ " ; this . serverVariables = new HashMap < String , String > ( ) ; try { if ( versionMeetsMinimum ( 5 , 1 , 0 ) ) { StringBuilder queryBuf = new StringBuilder ( versionComment ) . append ( " SELECT " ) ; queryBuf . append ( " ▁ ▁ @ @ session . auto _ increment _ increment ▁ AS ▁ auto _ increment _ increment " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ client ▁ AS ▁ character _ set _ client " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ connection ▁ AS ▁ character _ set _ connection " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ results ▁ AS ▁ character _ set _ results " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ server ▁ AS ▁ character _ set _ server " ) ; queryBuf . append ( " , ▁ @ @ init _ connect ▁ AS ▁ init _ connect " ) ; queryBuf . append ( " , ▁ @ @ interactive _ timeout ▁ AS ▁ interactive _ timeout " ) ; if ( ! versionMeetsMinimum ( 5 , 5 , 0 ) ) { queryBuf . append ( " , ▁ @ @ language ▁ AS ▁ language " ) ; } queryBuf . append ( " , ▁ @ @ license ▁ AS ▁ license " ) ; queryBuf . append ( " , ▁ @ @ lower _ case _ table _ names ▁ AS ▁ lower _ case _ table _ names " ) ; queryBuf . append ( " , ▁ @ @ max _ allowed _ packet ▁ AS ▁ max _ allowed _ packet " ) ; queryBuf . append ( " , ▁ @ @ net _ buffer _ length ▁ AS ▁ net _ buffer _ length " ) ; queryBuf . append ( " , ▁ @ @ net _ write _ timeout ▁ AS ▁ net _ write _ timeout " ) ; queryBuf . append ( " , ▁ @ @ query _ cache _ size ▁ AS ▁ query _ cache _ size " ) ; queryBuf . append ( " , ▁ @ @ query _ cache _ type ▁ AS ▁ query _ cache _ type " ) ; queryBuf . append ( " , ▁ @ @ sql _ mode ▁ AS ▁ sql _ mode " ) ; queryBuf . append ( " , ▁ @ @ system _ time _ zone ▁ AS ▁ system _ time _ zone " ) ; queryBuf . append ( " , ▁ @ @ time _ zone ▁ AS ▁ time _ zone " ) ; queryBuf . append ( " , ▁ @ @ tx _ isolation ▁ AS ▁ tx _ isolation " ) ; queryBuf . append ( " , ▁ @ @ wait _ timeout ▁ AS ▁ wait _ timeout " ) ; results = stmt . executeQuery ( queryBuf . toString ( ) ) ; if ( results . next ( ) ) { ResultSetMetaData rsmd = results . getMetaData ( ) ; for ( int i = 1 ; i <= rsmd . getColumnCount ( ) ; i ++ ) { this . serverVariables . put ( rsmd . getColumnLabel ( i ) , results . getString ( i ) ) ; } } } else { results = stmt . executeQuery ( versionComment + " SHOW ▁ VARIABLES " ) ; while ( results . next ( ) ) { this . serverVariables . put ( results . getString ( 1 ) , results . getString ( 2 ) ) ; } } results . close ( ) ; results = null ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } if ( getCacheServerConfiguration ( ) ) { this . serverVariables . put ( SERVER_VERSION_STRING_var_NAME , this . io . getServerVersion ( ) ) ; this . serverConfigCache . put ( getURL ( ) , this . serverVariables ) ; } } catch ( SQLException e ) { throw e ; } finally { if ( results != null ) { try { results . close ( ) ; } catch ( SQLException sqlE ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlE ) { } } } }
JackSprat/Knifeybot | public int getAutoIncrementIncrement ( ) { return this . autoIncrementIncrement ; }
JackSprat/Knifeybot | public boolean lowerCaseTableNames ( ) { return this . lowerCaseTableNames ; }
JackSprat/Knifeybot | public String nativeSQL ( String sql ) throws SQLException { if ( sql == null ) { return null ; } Object escapedSqlResult = EscapeProcessor . escapeSQL ( sql , serverSupportsConvertFn ( ) , getMultiHostSafeProxy ( ) ) ; if ( escapedSqlResult instanceof String ) { return ( String ) escapedSqlResult ; } return ( ( EscapeProcessorResult ) escapedSqlResult ) . escapedSql ; }
JackSprat/Knifeybot | private CallableStatement parseCallableStatement ( String sql ) throws SQLException { Object escapedSqlResult = EscapeProcessor . escapeSQL ( sql , serverSupportsConvertFn ( ) , getMultiHostSafeProxy ( ) ) ; boolean isFunctionCall = false ; String parsedSql = null ; if ( escapedSqlResult instanceof EscapeProcessorResult ) { parsedSql = ( ( EscapeProcessorResult ) escapedSqlResult ) . escapedSql ; isFunctionCall = ( ( EscapeProcessorResult ) escapedSqlResult ) . callingStoredFunction ; } else { parsedSql = ( String ) escapedSqlResult ; isFunctionCall = false ; } return CallableStatement . getInstance ( getMultiHostSafeProxy ( ) , parsedSql , this . database , isFunctionCall ) ; }
JackSprat/Knifeybot | public boolean parserKnowsUnicode ( ) { return this . parserKnowsUnicode ; }
JackSprat/Knifeybot | public void ping ( ) throws SQLException { pingInternal ( true , 0 ) ; }
JackSprat/Knifeybot | public void pingInternal ( boolean checkForClosedConnection , int timeoutMillis ) throws SQLException { if ( checkForClosedConnection ) { checkClosed ( ) ; } long pingMillisLifetime = getSelfDestructOnPingSecondsLifetime ( ) ; int pingMaxOperations = getSelfDestructOnPingMaxOperations ( ) ; if ( ( pingMillisLifetime > 0 && ( System . currentTimeMillis ( ) - this . connectionCreationTimeMillis ) > pingMillisLifetime ) || ( pingMaxOperations > 0 && pingMaxOperations <= this . io . getCommandCount ( ) ) ) { close ( ) ; throw SQLError . createSQLException ( Messages . getString ( " Connection . exceededConnectionLifetime " ) , SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE , getExceptionInterceptor ( ) ) ; } this . io . sendCommand ( MysqlDefs . PING , null , null , false , null , timeoutMillis ) ; }
JackSprat/Knifeybot | public java . sql . CallableStatement prepareCall ( String sql ) throws SQLException { return prepareCall ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { if ( versionMeetsMinimum ( 5 , 0 , 0 ) ) { CallableStatement cStmt = null ; if ( ! getCacheCallableStatements ( ) ) { cStmt = parseCallableStatement ( sql ) ; } else { synchronized ( this . parsedCallableStatementCache ) { CompoundCacheKey key = new CompoundCacheKey ( getCatalog ( ) , sql ) ; CallableStatement . CallableStatementParamInfo cachedParamInfo = ( CallableStatement . CallableStatementParamInfo ) this . parsedCallableStatementCache . get ( key ) ; if ( cachedParamInfo != null ) { cStmt = CallableStatement . getInstance ( getMultiHostSafeProxy ( ) , cachedParamInfo ) ; } else { cStmt = parseCallableStatement ( sql ) ; synchronized ( cStmt ) { cachedParamInfo = cStmt . paramInfo ; } this . parsedCallableStatementCache . put ( key , cachedParamInfo ) ; } } } cStmt . setResultSetType ( resultSetType ) ; cStmt . setResultSetConcurrency ( resultSetConcurrency ) ; return cStmt ; } throw SQLError . createSQLException ( " Callable ▁ statements ▁ not ▁ supported . " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; }
JackSprat/Knifeybot | public java . sql . CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } CallableStatement cStmt = ( com . mysql . jdbc . CallableStatement ) prepareCall ( sql , resultSetType , resultSetConcurrency ) ; return cStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql ) throws SQLException { return prepareStatement ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; PreparedStatement pStmt = null ; boolean canServerPrepare = true ; String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; if ( this . useServerPreparedStmts && getEmulateUnsupportedPstmts ( ) ) { canServerPrepare = canHandleAsServerPreparedStatement ( nativeSql ) ; } if ( this . useServerPreparedStmts && canServerPrepare ) { if ( this . getCachePreparedStatements ( ) ) { synchronized ( this . serverSideStatementCache ) { pStmt = ( com . mysql . jdbc . ServerPreparedStatement ) this . serverSideStatementCache . remove ( sql ) ; if ( pStmt != null ) { ( ( com . mysql . jdbc . ServerPreparedStatement ) pStmt ) . setClosed ( false ) ; pStmt . clearParameters ( ) ; } if ( pStmt == null ) { try { pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , resultSetType , resultSetConcurrency ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { ( ( com . mysql . jdbc . ServerPreparedStatement ) pStmt ) . isCached = true ; } pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; } catch ( SQLException sqlEx ) { if ( getEmulateUnsupportedPstmts ( ) ) { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { this . serverSideStatementCheckCache . put ( sql , Boolean . FALSE ) ; } } else { throw sqlEx ; } } } } } else { try { pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , resultSetType , resultSetConcurrency ) ; pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; } catch ( SQLException sqlEx ) { if ( getEmulateUnsupportedPstmts ( ) ) { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; } else { throw sqlEx ; } } } } else { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; } return pStmt ; } }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return prepareStatement ( sql , resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public void realClose ( boolean calledExplicitly , boolean issueRollback , boolean skipLocalTeardown , Throwable reason ) throws SQLException { SQLException sqlEx = null ; if ( this . isClosed ( ) ) { return ; } this . forceClosedReason = reason ; try { if ( ! skipLocalTeardown ) { if ( ! getAutoCommit ( ) && issueRollback ) { try { rollback ( ) ; } catch ( SQLException ex ) { sqlEx = ex ; } } reportMetrics ( ) ; if ( getUseUsageAdvisor ( ) ) { if ( ! calledExplicitly ) { String message = " Connection ▁ implicitly ▁ closed ▁ by ▁ Driver . ▁ You ▁ should ▁ call ▁ Connection . close ( ) ▁ from ▁ your ▁ code ▁ to ▁ free ▁ resources ▁ more ▁ efficiently ▁ and ▁ avoid ▁ resource ▁ leaks . " ; this . eventSink . consumeEvent ( new ProfilerEvent ( ProfilerEvent . TYPE_WARN , " " , this . getCatalog ( ) , this . getId ( ) , - 1 , - 1 , System . currentTimeMillis ( ) , 0 , Constants . MILLIS_I18N , null , this . pointOfOrigin , message ) ) ; } long connectionLifeTime = System . currentTimeMillis ( ) - this . connectionCreationTimeMillis ; if ( connectionLifeTime < 500 ) { String message = " Connection ▁ lifetime ▁ of ▁ < ▁ . 5 ▁ seconds . ▁ You ▁ might ▁ be ▁ un - necessarily ▁ creating ▁ short - lived ▁ connections ▁ and ▁ should ▁ investigate ▁ connection ▁ pooling ▁ to ▁ be ▁ more ▁ efficient . " ; this . eventSink . consumeEvent ( new ProfilerEvent ( ProfilerEvent . TYPE_WARN , " " , this . getCatalog ( ) , this . getId ( ) , - 1 , - 1 , System . currentTimeMillis ( ) , 0 , Constants . MILLIS_I18N , null , this . pointOfOrigin , message ) ) ; } } try { closeAllOpenStatements ( ) ; } catch ( SQLException ex ) { sqlEx = ex ; } if ( this . io != null ) { try { this . io . quit ( ) ; } catch ( Exception e ) { } } } else { this . io . forceClose ( ) ; } if ( this . statementInterceptors != null ) { for ( int i = 0 ; i < this . statementInterceptors . size ( ) ; i ++ ) { this . statementInterceptors . get ( i ) . destroy ( ) ; } } if ( this . exceptionInterceptor != null ) { this . exceptionInterceptor . destroy ( ) ; } } finally { this . openStatements . clear ( ) ; if ( this . io != null ) { this . io . releaseResources ( ) ; this . io = null ; } this . statementInterceptors = null ; this . exceptionInterceptor = null ; ProfilerEventHandlerFactory . removeInstance ( this ) ; synchronized ( getConnectionMutex ( ) ) { if ( this . cancelTimer != null ) { this . cancelTimer . cancel ( ) ; } } this . isClosed = true ; } if ( sqlEx != null ) { throw sqlEx ; } }
JackSprat/Knifeybot | public void recachePreparedStatement ( ServerPreparedStatement pstmt ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( getCachePreparedStatements ( ) && pstmt . isPoolable ( ) ) { synchronized ( this . serverSideStatementCache ) { this . serverSideStatementCache . put ( pstmt . originalSql , pstmt ) ; } } } }
JackSprat/Knifeybot | public void decachePreparedStatement ( ServerPreparedStatement pstmt ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( getCachePreparedStatements ( ) && pstmt . isPoolable ( ) ) { synchronized ( this . serverSideStatementCache ) { this . serverSideStatementCache . remove ( pstmt . originalSql ) ; } } } }
JackSprat/Knifeybot | public void registerQueryExecutionTime ( long queryTimeMs ) { if ( queryTimeMs > this . longestQueryTimeMs ) { this . longestQueryTimeMs = queryTimeMs ; repartitionPerformanceHistogram ( ) ; } addToPerformanceHistogram ( queryTimeMs , 1 ) ; if ( queryTimeMs < this . shortestQueryTimeMs ) { this . shortestQueryTimeMs = ( queryTimeMs == 0 ) ? 1 : queryTimeMs ; } this . numberOfQueriesIssued ++ ; this . totalQueryTimeMs += queryTimeMs ; }
JackSprat/Knifeybot | public void registerStatement ( Statement stmt ) { this . openStatements . addIfAbsent ( stmt ) ; }
JackSprat/Knifeybot | public void releaseSavepoint ( Savepoint arg0 ) throws SQLException { }
JackSprat/Knifeybot | private void repartitionHistogram ( int [ ] histCounts , long [ ] histBreakpoints , long currentLowerBound , long currentUpperBound ) { if ( this . oldHistCounts == null ) { this . oldHistCounts = new int [ histCounts . length ] ; this . oldHistBreakpoints = new long [ histBreakpoints . length ] ; } System . arraycopy ( histCounts , 0 , this . oldHistCounts , 0 , histCounts . length ) ; System . arraycopy ( histBreakpoints , 0 , this . oldHistBreakpoints , 0 , histBreakpoints . length ) ; createInitialHistogram ( histBreakpoints , currentLowerBound , currentUpperBound ) ; for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { addToHistogram ( histCounts , histBreakpoints , this . oldHistBreakpoints [ i ] , this . oldHistCounts [ i ] , currentLowerBound , currentUpperBound ) ; } }
JackSprat/Knifeybot | private void repartitionPerformanceHistogram ( ) { checkAndCreatePerformanceHistogram ( ) ; repartitionHistogram ( this . perfMetricsHistCounts , this . perfMetricsHistBreakpoints , this . shortestQueryTimeMs == Long . MAX_VALUE ? 0 : this . shortestQueryTimeMs , this . longestQueryTimeMs ) ; }
JackSprat/Knifeybot | private void repartitionTablesAccessedHistogram ( ) { checkAndCreateTablesAccessedHistogram ( ) ; repartitionHistogram ( this . numTablesMetricsHistCounts , this . numTablesMetricsHistBreakpoints , this . minimumNumberTablesAccessed == Long . MAX_VALUE ? 0 : this . minimumNumberTablesAccessed , this . maximumNumberTablesAccessed ) ; }
JackSprat/Knifeybot | private void reportMetrics ( ) { if ( getGatherPerformanceMetrics ( ) ) { StringBuilder logMessage = new StringBuilder ( 256 ) ; logMessage . append ( " * * ▁ Performance ▁ Metrics ▁ Report ▁ * * \n " ) ; logMessage . append ( " \n Longest ▁ reported ▁ query : ▁ " + this . longestQueryTimeMs + " ▁ ms " ) ; logMessage . append ( " \n Shortest ▁ reported ▁ query : ▁ " + this . shortestQueryTimeMs + " ▁ ms " ) ; logMessage . append ( " \n Average ▁ query ▁ execution ▁ time : ▁ " + ( this . totalQueryTimeMs / this . numberOfQueriesIssued ) + " ▁ ms " ) ; logMessage . append ( " \n Number ▁ of ▁ statements ▁ executed : ▁ " + this . numberOfQueriesIssued ) ; logMessage . append ( " \n Number ▁ of ▁ result ▁ sets ▁ created : ▁ " + this . numberOfResultSetsCreated ) ; logMessage . append ( " \n Number ▁ of ▁ statements ▁ prepared : ▁ " + this . numberOfPrepares ) ; logMessage . append ( " \n Number ▁ of ▁ prepared ▁ statement ▁ executions : ▁ " + this . numberOfPreparedExecutes ) ; if ( this . perfMetricsHistBreakpoints != null ) { logMessage . append ( " \n \n \tTiming ▁ Histogram : \n " ) ; int maxNumPoints = 20 ; int highestCount = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS ) ; i ++ ) { if ( this . perfMetricsHistCounts [ i ] > highestCount ) { highestCount = this . perfMetricsHistCounts [ i ] ; } } if ( highestCount == 0 ) { highestCount = 1 ; } for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS - 1 ) ; i ++ ) { if ( i == 0 ) { logMessage . append ( " \n \tless ▁ than ▁ " + this . perfMetricsHistBreakpoints [ i + 1 ] + " ▁ ms : ▁ \t " + this . perfMetricsHistCounts [ i ] ) ; } else { logMessage . append ( " \n \tbetween ▁ " + this . perfMetricsHistBreakpoints [ i ] + " ▁ and ▁ " + this . perfMetricsHistBreakpoints [ i + 1 ] + " ▁ ms : ▁ \t " + this . perfMetricsHistCounts [ i ] ) ; } logMessage . append ( " \t " ) ; int numPointsToGraph = ( int ) ( maxNumPoints * ( ( double ) this . perfMetricsHistCounts [ i ] / ( double ) highestCount ) ) ; for ( int j = 0 ; j < numPointsToGraph ; j ++ ) { logMessage . append ( " * " ) ; } if ( this . longestQueryTimeMs < this . perfMetricsHistCounts [ i + 1 ] ) { break ; } } if ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] < this . longestQueryTimeMs ) { logMessage . append ( " \n \tbetween ▁ " ) ; logMessage . append ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] ) ; logMessage . append ( " ▁ and ▁ " ) ; logMessage . append ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 1 ] ) ; logMessage . append ( " ▁ ms : ▁ \t " ) ; logMessage . append ( this . perfMetricsHistCounts [ HISTOGRAM_BUCKETS - 1 ] ) ; } } if ( this . numTablesMetricsHistBreakpoints != null ) { logMessage . append ( " \n \n \tTable ▁ Join ▁ Histogram : \n " ) ; int maxNumPoints = 20 ; int highestCount = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS ) ; i ++ ) { if ( this . numTablesMetricsHistCounts [ i ] > highestCount ) { highestCount = this . numTablesMetricsHistCounts [ i ] ; } } if ( highestCount == 0 ) { highestCount = 1 ; } for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS - 1 ) ; i ++ ) { if ( i == 0 ) { logMessage . append ( " \n \t " + this . numTablesMetricsHistBreakpoints [ i + 1 ] + " ▁ tables ▁ or ▁ less : ▁ \t\t " + this . numTablesMetricsHistCounts [ i ] ) ; } else { logMessage . append ( " \n \tbetween ▁ " + this . numTablesMetricsHistBreakpoints [ i ] + " ▁ and ▁ " + this . numTablesMetricsHistBreakpoints [ i + 1 ] + " ▁ tables : ▁ \t " + this . numTablesMetricsHistCounts [ i ] ) ; } logMessage . append ( " \t " ) ; int numPointsToGraph = ( int ) ( maxNumPoints * ( ( double ) this . numTablesMetricsHistCounts [ i ] / ( double ) highestCount ) ) ; for ( int j = 0 ; j < numPointsToGraph ; j ++ ) { logMessage . append ( " * " ) ; } if ( this . maximumNumberTablesAccessed < this . numTablesMetricsHistBreakpoints [ i + 1 ] ) { break ; } } if ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] < this . maximumNumberTablesAccessed ) { logMessage . append ( " \n \tbetween ▁ " ) ; logMessage . append ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] ) ; logMessage . append ( " ▁ and ▁ " ) ; logMessage . append ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 1 ] ) ; logMessage . append ( " ▁ tables : ▁ " ) ; logMessage . append ( this . numTablesMetricsHistCounts [ HISTOGRAM_BUCKETS - 1 ] ) ; } } this . log . logInfo ( logMessage ) ; this . metricsLastReportedMs = System . currentTimeMillis ( ) ; } }
JackSprat/Knifeybot | protected void reportMetricsIfNeeded ( ) { if ( getGatherPerformanceMetrics ( ) ) { if ( ( System . currentTimeMillis ( ) - this . metricsLastReportedMs ) > getReportMetricsIntervalMillis ( ) ) { reportMetrics ( ) ; } } }
JackSprat/Knifeybot | public void reportNumberOfTablesAccessed ( int numTablesAccessed ) { if ( numTablesAccessed < this . minimumNumberTablesAccessed ) { this . minimumNumberTablesAccessed = numTablesAccessed ; } if ( numTablesAccessed > this . maximumNumberTablesAccessed ) { this . maximumNumberTablesAccessed = numTablesAccessed ; repartitionTablesAccessedHistogram ( ) ; } addToTablesAccessedHistogram ( numTablesAccessed , 1 ) ; }
JackSprat/Knifeybot | public void resetServerState ( ) throws SQLException { if ( ! getParanoid ( ) && ( ( this . io != null ) && versionMeetsMinimum ( 4 , 0 , 6 ) ) ) { changeUser ( this . user , this . password ) ; } }
JackSprat/Knifeybot | public void rollback ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . rollback ( ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( this . autoCommit && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ call ▁ rollback ▁ when ▁ autocommit = true " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } else if ( this . transactionsSupported ) { try { rollbackNoChecks ( ) ; } catch ( SQLException sqlEx ) { if ( getIgnoreNonTxTables ( ) && ( sqlEx . getErrorCode ( ) == SQLError . ER_WARNING_NOT_COMPLETE_ROLLBACK ) ) { return ; } throw sqlEx ; } } } catch ( SQLException sqlException ) { if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlException . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ rollback ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlException ; } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } }
JackSprat/Knifeybot | public void rollback ( final Savepoint savepoint ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( versionMeetsMinimum ( 4 , 0 , 14 ) || versionMeetsMinimum ( 4 , 1 , 1 ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . rollback ( savepoint ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } StringBuilder rollbackQuery = new StringBuilder ( " ROLLBACK ▁ TO ▁ SAVEPOINT ▁ " ) ; rollbackQuery . append ( ' ` ' ) ; rollbackQuery . append ( savepoint . getSavepointName ( ) ) ; rollbackQuery . append ( ' ` ' ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; stmt . executeUpdate ( rollbackQuery . toString ( ) ) ; } catch ( SQLException sqlEx ) { int errno = sqlEx . getErrorCode ( ) ; if ( errno == 1181 ) { String msg = sqlEx . getMessage ( ) ; if ( msg != null ) { int indexOfError153 = msg . indexOf ( "153" ) ; if ( indexOfError153 != - 1 ) { throw SQLError . createSQLException ( " Savepoint ▁ ' " + savepoint . getSavepointName ( ) + " ' ▁ does ▁ not ▁ exist " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , errno , getExceptionInterceptor ( ) ) ; } } } if ( getIgnoreNonTxTables ( ) && ( sqlEx . getErrorCode ( ) != SQLError . ER_WARNING_NOT_COMPLETE_ROLLBACK ) ) { throw sqlEx ; } if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlEx . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ rollback ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlEx ; } finally { closeStatement ( stmt ) ; } } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } else { throw SQLError . createSQLFeatureNotSupportedException ( ) ; } } }
JackSprat/Knifeybot | private void rollbackNoChecks ( ) throws SQLException { if ( getUseLocalTransactionState ( ) && versionMeetsMinimum ( 5 , 0 , 0 ) ) { if ( ! this . io . inTransactionOnServer ( ) ) { return ; } } execSQL ( null , " rollback " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; return ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; PreparedStatement pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; pStmt . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; return ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return serverPrepareStatement ( sql , resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) serverPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) serverPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public boolean serverSupportsConvertFn ( ) throws SQLException { return versionMeetsMinimum ( 4 , 0 , 2 ) ; }
JackSprat/Knifeybot | public void setAutoCommit ( final boolean autoCommitFlag ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . setAutoCommit ( autoCommitFlag ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( getAutoReconnectForPools ( ) ) { setHighAvailability ( true ) ; } try { if ( this . transactionsSupported ) { boolean needsSetOnServer = true ; if ( this . getUseLocalSessionState ( ) && this . autoCommit == autoCommitFlag ) { needsSetOnServer = false ; } else if ( ! this . getHighAvailability ( ) ) { needsSetOnServer = this . getIO ( ) . isSetNeededForAutoCommitMode ( autoCommitFlag ) ; } this . autoCommit = autoCommitFlag ; if ( needsSetOnServer ) { execSQL ( null , autoCommitFlag ? " SET ▁ autocommit = 1" : " SET ▁ autocommit = 0" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } else { if ( ( autoCommitFlag == false ) && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " MySQL ▁ Versions ▁ Older ▁ than ▁ 3.23.15 ▁ do ▁ not ▁ support ▁ transactions " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } this . autoCommit = autoCommitFlag ; } } finally { if ( this . getAutoReconnectForPools ( ) ) { setHighAvailability ( false ) ; } } return ; } }
JackSprat/Knifeybot | public void setCatalog ( final String catalog ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( catalog == null ) { throw SQLError . createSQLException ( " Catalog ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . setCatalog ( catalog ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( getUseLocalSessionState ( ) ) { if ( this . lowerCaseTableNames ) { if ( this . database . equalsIgnoreCase ( catalog ) ) { return ; } } else { if ( this . database . equals ( catalog ) ) { return ; } } } String quotedId = this . dbmd . getIdentifierQuoteString ( ) ; if ( ( quotedId == null ) || quotedId . equals ( " ▁ " ) ) { quotedId = " " ; } StringBuilder query = new StringBuilder ( " USE ▁ " ) ; query . append ( StringUtils . quoteIdentifier ( catalog , quotedId , getPedantic ( ) ) ) ; execSQL ( null , query . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . database = catalog ; } }
JackSprat/Knifeybot | public void setFailedOver ( boolean flag ) { }
JackSprat/Knifeybot | public void setHoldability ( int arg0 ) throws SQLException { }
JackSprat/Knifeybot | public void setInGlobalTx ( boolean flag ) { this . isInGlobalTx = flag ; }
JackSprat/Knifeybot | @ Deprecated public void setPreferSlaveDuringFailover ( boolean flag ) { }
JackSprat/Knifeybot | public void setReadInfoMsgEnabled ( boolean flag ) { this . readInfoMsg = flag ; }
JackSprat/Knifeybot | public void setReadOnly ( boolean readOnlyFlag ) throws SQLException { checkClosed ( ) ; setReadOnlyInternal ( readOnlyFlag ) ; }
JackSprat/Knifeybot | public void setReadOnlyInternal ( boolean readOnlyFlag ) throws SQLException { if ( getReadOnlyPropagatesToServer ( ) && versionMeetsMinimum ( 5 , 6 , 5 ) ) { if ( ! getUseLocalSessionState ( ) || ( readOnlyFlag != this . readOnly ) ) { execSQL ( null , " set ▁ session ▁ transaction ▁ " + ( readOnlyFlag ? " read ▁ only " : " read ▁ write " ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } this . readOnly = readOnlyFlag ; }
JackSprat/Knifeybot | public java . sql . Savepoint setSavepoint ( ) throws SQLException { MysqlSavepoint savepoint = new MysqlSavepoint ( getExceptionInterceptor ( ) ) ; setSavepoint ( savepoint ) ; return savepoint ; }
JackSprat/Knifeybot | private void setSavepoint ( MysqlSavepoint savepoint ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( versionMeetsMinimum ( 4 , 0 , 14 ) || versionMeetsMinimum ( 4 , 1 , 1 ) ) { checkClosed ( ) ; StringBuilder savePointQuery = new StringBuilder ( " SAVEPOINT ▁ " ) ; savePointQuery . append ( ' ` ' ) ; savePointQuery . append ( savepoint . getSavepointName ( ) ) ; savePointQuery . append ( ' ` ' ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; stmt . executeUpdate ( savePointQuery . toString ( ) ) ; } finally { closeStatement ( stmt ) ; } } else { throw SQLError . createSQLFeatureNotSupportedException ( ) ; } } }
JackSprat/Knifeybot | public java . sql . Savepoint setSavepoint ( String name ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { MysqlSavepoint savepoint = new MysqlSavepoint ( name , getExceptionInterceptor ( ) ) ; setSavepoint ( savepoint ) ; return savepoint ; } }
JackSprat/Knifeybot | private void setSessionVariables ( ) throws SQLException { if ( this . versionMeetsMinimum ( 4 , 0 , 0 ) && getSessionVariables ( ) != null ) { List < String > variablesToSet = StringUtils . split ( getSessionVariables ( ) , " , " , " \" ' " , " \" ' " , false ) ; int numVariablesToSet = variablesToSet . size ( ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; for ( int i = 0 ; i < numVariablesToSet ; i ++ ) { String variableValuePair = variablesToSet . get ( i ) ; if ( variableValuePair . startsWith ( " @ " ) ) { stmt . executeUpdate ( " SET ▁ " + variableValuePair ) ; } else { stmt . executeUpdate ( " SET ▁ SESSION ▁ " + variableValuePair ) ; } } } finally { if ( stmt != null ) { stmt . close ( ) ; } } } }
JackSprat/Knifeybot | public void setTransactionIsolation ( int level ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( this . hasIsolationLevels ) { String sql = null ; boolean shouldSendSet = false ; if ( getAlwaysSendSetIsolation ( ) ) { shouldSendSet = true ; } else { if ( level != this . isolationLevel ) { shouldSendSet = true ; } } if ( getUseLocalSessionState ( ) ) { shouldSendSet = this . isolationLevel != level ; } if ( shouldSendSet ) { switch ( level ) { case java . sql . Connection . TRANSACTION_NONE : throw SQLError . createSQLException ( " Transaction ▁ isolation ▁ level ▁ NONE ▁ not ▁ supported ▁ by ▁ MySQL " , getExceptionInterceptor ( ) ) ; case java . sql . Connection . TRANSACTION_READ_COMMITTED : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ READ ▁ COMMITTED " ; break ; case java . sql . Connection . TRANSACTION_READ_UNCOMMITTED : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ READ ▁ UNCOMMITTED " ; break ; case java . sql . Connection . TRANSACTION_REPEATABLE_READ : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ REPEATABLE ▁ READ " ; break ; case java . sql . Connection . TRANSACTION_SERIALIZABLE : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ SERIALIZABLE " ; break ; default : throw SQLError . createSQLException ( " Unsupported ▁ transaction ▁ isolation ▁ level ▁ ' " + level + " ' " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; } execSQL ( null , sql , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . isolationLevel = level ; } } else { throw SQLError . createSQLException ( " Transaction ▁ Isolation ▁ Levels ▁ are ▁ not ▁ supported ▁ on ▁ MySQL ▁ versions ▁ older ▁ than ▁ 3.23.36 . " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; } } }
JackSprat/Knifeybot | public void setTypeMap ( java . util . Map < String , Class < ? > > map ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { this . typeMap = map ; } }
JackSprat/Knifeybot | private void setupServerForTruncationChecks ( ) throws SQLException { if ( getJdbcCompliantTruncation ( ) ) { if ( versionMeetsMinimum ( 5 , 0 , 2 ) ) { String currentSqlMode = this . serverVariables . get ( " sql _ mode " ) ; boolean strictTransTablesIsSet = StringUtils . indexOfIgnoreCase ( currentSqlMode , " STRICT _ TRANS _ TABLES " ) != - 1 ; if ( currentSqlMode == null || currentSqlMode . length ( ) == 0 || ! strictTransTablesIsSet ) { StringBuilder commandBuf = new StringBuilder ( " SET ▁ sql _ mode = ' " ) ; if ( currentSqlMode != null && currentSqlMode . length ( ) > 0 ) { commandBuf . append ( currentSqlMode ) ; commandBuf . append ( " , " ) ; } commandBuf . append ( " STRICT _ TRANS _ TABLES ' " ) ; execSQL ( null , commandBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; setJdbcCompliantTruncation ( false ) ; } else if ( strictTransTablesIsSet ) { setJdbcCompliantTruncation ( false ) ; } } } }
JackSprat/Knifeybot | public void shutdownServer ( ) throws SQLException { try { this . io . sendCommand ( MysqlDefs . SHUTDOWN , null , null , false , null , 0 ) ; } catch ( Exception ex ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnhandledExceptionDuringShutdown " ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } }
JackSprat/Knifeybot | public boolean supportsIsolationLevel ( ) { return this . hasIsolationLevels ; }
JackSprat/Knifeybot | public boolean supportsQuotedIdentifiers ( ) { return this . hasQuotedIdentifiers ; }
JackSprat/Knifeybot | public boolean supportsTransactions ( ) { return this . transactionsSupported ; }
JackSprat/Knifeybot | public void unregisterStatement ( Statement stmt ) { this . openStatements . remove ( stmt ) ; }
JackSprat/Knifeybot | public boolean useAnsiQuotedIdentifiers ( ) { synchronized ( getConnectionMutex ( ) ) { return this . useAnsiQuotes ; } }
JackSprat/Knifeybot | public boolean versionMeetsMinimum ( int major , int minor , int subminor ) throws SQLException { checkClosed ( ) ; return this . io . versionMeetsMinimum ( major , minor , subminor ) ; }
JackSprat/Knifeybot | public CachedResultSetMetaData getCachedMetaData ( String sql ) { if ( this . resultSetMetadataCache != null ) { synchronized ( this . resultSetMetadataCache ) { return ( CachedResultSetMetaData ) this . resultSetMetadataCache . get ( sql ) ; } } return null ; }
JackSprat/Knifeybot | public void initializeResultsMetadataFromCache ( String sql , CachedResultSetMetaData cachedMetaData , ResultSetInternalMethods resultSet ) throws SQLException { if ( cachedMetaData == null ) { cachedMetaData = new CachedResultSetMetaData ( ) ; resultSet . buildIndexMapping ( ) ; resultSet . initializeWithMetadata ( ) ; if ( resultSet instanceof UpdatableResultSet ) { ( ( UpdatableResultSet ) resultSet ) . checkUpdatability ( ) ; } resultSet . populateCachedMetaData ( cachedMetaData ) ; this . resultSetMetadataCache . put ( sql , cachedMetaData ) ; } else { resultSet . initializeFromCachedMetaData ( cachedMetaData ) ; resultSet . initializeWithMetadata ( ) ; if ( resultSet instanceof UpdatableResultSet ) { ( ( UpdatableResultSet ) resultSet ) . checkUpdatability ( ) ; } } }
JackSprat/Knifeybot | public String getStatementComment ( ) { return this . statementComment ; }
JackSprat/Knifeybot | public void setStatementComment ( String comment ) { this . statementComment = comment ; }
JackSprat/Knifeybot | public void reportQueryTime ( long millisOrNanos ) { synchronized ( getConnectionMutex ( ) ) { this . queryTimeCount ++ ; this . queryTimeSum += millisOrNanos ; this . queryTimeSumSquares += ( millisOrNanos * millisOrNanos ) ; this . queryTimeMean = ( ( this . queryTimeMean * ( this . queryTimeCount - 1 ) ) + millisOrNanos ) / this . queryTimeCount ; } }
JackSprat/Knifeybot | public boolean isAbonormallyLongQuery ( long millisOrNanos ) { synchronized ( getConnectionMutex ( ) ) { if ( this . queryTimeCount < 15 ) { return false ; } double stddev = Math . sqrt ( ( this . queryTimeSumSquares - ( ( this . queryTimeSum * this . queryTimeSum ) / this . queryTimeCount ) ) / ( this . queryTimeCount - 1 ) ) ; return millisOrNanos > ( this . queryTimeMean + 5 * stddev ) ; } }
JackSprat/Knifeybot | public void initializeExtension ( Extension ex ) throws SQLException { ex . init ( this , this . props ) ; }
JackSprat/Knifeybot | public void transactionBegun ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . transactionBegun ( ) ; } } ; iter . doForAll ( ) ; } } }
JackSprat/Knifeybot | public void transactionCompleted ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . transactionCompleted ( ) ; } } ; iter . doForAll ( ) ; } } }
JackSprat/Knifeybot | public boolean storesLowerCaseTableName ( ) { return this . storesLowerCaseTableName ; }
JackSprat/Knifeybot | @ Override public ExceptionInterceptor getExceptionInterceptor ( ) { return this . exceptionInterceptor ; }
JackSprat/Knifeybot | public boolean getRequiresEscapingEncoder ( ) { return this . requiresEscapingEncoder ; }
JackSprat/Knifeybot | public boolean isServerLocal ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { SocketFactory factory = getIO ( ) . socketFactory ; if ( factory instanceof SocketMetadata ) { return ( ( SocketMetadata ) factory ) . isLocallyConnected ( this ) ; } getLog ( ) . logWarn ( Messages . getString ( " Connection . NoMetadataOnSocketFactory " ) ) ; return false ; } }
JackSprat/Knifeybot | public int getSessionMaxRows ( ) { synchronized ( getConnectionMutex ( ) ) { return this . sessionMaxRows ; } }
JackSprat/Knifeybot | public void setSessionMaxRows ( int max ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . sessionMaxRows != max ) { this . sessionMaxRows = max ; execSQL ( null , " SET ▁ SQL _ SELECT _ LIMIT = " + ( this . sessionMaxRows == - 1 ? " DEFAULT " : this . sessionMaxRows ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } }
JackSprat/Knifeybot | public void setSchema ( String schema ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; } }
JackSprat/Knifeybot | public String getSchema ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; return null ; } }
JackSprat/Knifeybot | public void abort ( Executor executor ) throws SQLException { SecurityManager sec = System . getSecurityManager ( ) ; if ( sec != null ) { sec . checkPermission ( ABORT_PERM ) ; } if ( executor == null ) { throw SQLError . createSQLException ( " Executor ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } executor . execute ( new Runnable ( ) { public void run ( ) { try { abortInternal ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } } ) ; }
JackSprat/Knifeybot | public void setNetworkTimeout ( Executor executor , final int milliseconds ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { SecurityManager sec = System . getSecurityManager ( ) ; if ( sec != null ) { sec . checkPermission ( SET_NETWORK_TIMEOUT_PERM ) ; } if ( executor == null ) { throw SQLError . createSQLException ( " Executor ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } checkClosed ( ) ; final MysqlIO mysqlIo = this . io ; executor . execute ( new Runnable ( ) { public void run ( ) { try { setSocketTimeout ( milliseconds ) ; mysqlIo . setSocketTimeout ( milliseconds ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } } ) ; } }
JackSprat/Knifeybot | public int getNetworkTimeout ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; return getSocketTimeout ( ) ; } }
JackSprat/Knifeybot | public ProfilerEventHandler getProfilerEventHandlerInstance ( ) { return this . eventSink ; }
JackSprat/Knifeybot | public void setProfilerEventHandlerInstance ( ProfilerEventHandler h ) { this . eventSink = h ; }
abhishek24509/aribaweb | protected void sleep ( ) { _destinationElementId = null ; _sourceElementId = null ; super . sleep ( ) ; }
cloudrain21/hamsterdb | public void handleMessage ( int level , String message ) { m_counter ++ ; }
cloudrain21/hamsterdb | public void testSetErrorHandler ( ) { Environment env = new Environment ( ) ; MyErrorHandler eh = new MyErrorHandler ( ) ; try { Database . setErrorHandler ( eh ) ; env . create ( null ) ; } catch ( DatabaseException err ) { assertEquals ( Const . HAM_INV_PARAMETER , err . getErrno ( ) ) ; assertEquals ( 1 , eh . m_counter ) ; } Database . setErrorHandler ( null ) ; }
cloudrain21/hamsterdb | public void testGetVersion ( ) { Version v = Database . getVersion ( ) ; assertEquals ( 2 , v . major ) ; assertEquals ( 1 , v . minor ) ; }
cloudrain21/hamsterdb | public void testDatabase ( ) { Database db = new Database ( 0 ) ; db . close ( ) ; }
cloudrain21/hamsterdb | public void testGetDatabaseException ( ) { Environment env = new Environment ( ) ; try { env . create ( " jtest . db " ) ; Database db = env . createDatabase ( ( short ) 1 , 1234 ) ; } catch ( DatabaseException err ) { assertEquals ( Const . HAM_INV_PARAMETER , err . getErrno ( ) ) ; } env . close ( ) ; }
cloudrain21/hamsterdb | public int compare ( byte [ ] lhs , byte [ ] rhs ) { m_counter ++ ; return m_counter ; }
cloudrain21/hamsterdb | public void testSetComparator ( ) { byte [ ] k = new byte [ 5 ] ; byte [ ] r = new byte [ 5 ] ; Environment env = new Environment ( ) ; Database db ; MyComparator cmp = new MyComparator ( ) ; try { env . create ( " jtest . db " ) ; Parameter [ ] params = new Parameter [ 1 ] ; params [ 0 ] = new Parameter ( ) ; params [ 0 ] . name = Const . HAM_PARAM_KEY_TYPE ; params [ 0 ] . value = Const . HAM_TYPE_CUSTOM ; db = env . createDatabase ( ( short ) 1 , 0 , params ) ; db . setComparator ( cmp ) ; db . insert ( k , r ) ; k [ 0 ] = 1 ; db . insert ( k , r ) ; k [ 0 ] = 2 ; db . insert ( k , r ) ; db . close ( ) ; } catch ( DatabaseException err ) { fail ( " Exception ▁ " + err ) ; } assertEquals ( 2 , cmp . m_counter ) ; env . close ( ) ; }
cloudrain21/hamsterdb | public void testGetParameters ( ) { byte [ ] k = new byte [ 5 ] ; byte [ ] r = new byte [ 5 ] ; Parameter [ ] params = new Parameter [ 10 ] ; for ( int i = 0 ; i < params . length ; i ++ ) { params [ i ] = new Parameter ( ) ; } params [ 0 ] . name = Const . HAM_PARAM_KEYSIZE ; params [ 1 ] . name = Const . HAM_PARAM_DATABASE_NAME ; params [ 2 ] . name = Const . HAM_PARAM_FLAGS ; params [ 3 ] . name = Const . HAM_PARAM_MAX_KEYS_PER_PAGE ; Database db ; Environment env = new Environment ( ) ; try { env . create ( " jtest . db " ) ; db = env . createDatabase ( ( short ) 1 ) ; db . getParameters ( params ) ; db . close ( ) ; } catch ( DatabaseException err ) { fail ( " Exception ▁ " + err ) ; } assertEquals ( Const . HAM_KEY_SIZE_UNLIMITED , params [ 0 ] . value ) ; assertEquals ( 1 , params [ 1 ] . value ) ; assertEquals ( 0 , params [ 2 ] . value ) ; assertEquals ( 441 , params [ 3 ] . value ) ; env . close ( ) ; }
cloudrain21/hamsterdb | public void testGetKeyCount ( ) { byte [ ] k = new byte [ 5 ] ; byte [ ] r = new byte [ 5 ] ; Database db ; Environment env = new Environment ( ) ; try { env . create ( " jtest . db " ) ; db = env . createDatabase ( ( short ) 1 ) ; assertEquals ( 0 , db . getKeyCount ( ) ) ; db . insert ( k , r ) ; assertEquals ( 1 , db . getKeyCount ( ) ) ; k [ 0 ] = 1 ; db . insert ( k , r ) ; assertEquals ( 2 , db . getKeyCount ( ) ) ; k [ 0 ] = 2 ; db . insert ( k , r ) ; assertEquals ( 3 , db . getKeyCount ( ) ) ; db . close ( ) ; } catch ( DatabaseException err ) { fail ( " Exception ▁ " + err ) ; } env . close ( ) ; }
googleads/googleads-java-lib | public Stats getStats ( ) { return stats ; }
googleads/googleads-java-lib | public void setStats ( Stats value ) { this . stats = value ; }
googleads/googleads-java-lib | public List < LongStatsMapEntry > getCreativeSetStats ( ) { if ( creativeSetStats == null ) { creativeSetStats = new ArrayList < LongStatsMapEntry > ( ) ; } return this . creativeSetStats ; }
googleads/googleads-java-lib | public Money getCostInOrderCurrency ( ) { return costInOrderCurrency ; }
googleads/googleads-java-lib | public void setCostInOrderCurrency ( Money value ) { this . costInOrderCurrency = value ; }
google/copybara | public GitHubApiException ( int httpCode , @ Nullable ClientError error , String httpMethod , String path , @ Nullable String request , String response ) { super ( detailedError ( httpMethod , path , request , response , httpCode ) ) ; this . httpCode = httpCode ; this . responseCode = parseResponseCode ( httpCode ) ; this . error = error ; this . httpMethod = httpMethod ; this . path = path ; this . request = request ; this . response = response ; }
google/copybara | public ResponseCode getResponseCode ( ) { return responseCode ; }
google/copybara | public int getHttpCode ( ) { return httpCode ; }
google/copybara | public ClientError getError ( ) { return error ; }
google/copybara | public String getRawError ( ) { return detailedError ( httpMethod , path , request , response , httpCode ) ; }
google/copybara | ResponseCode ( int code ) { this . code = code ; }
google/copybara | public int getCode ( ) { return code ; }
ahmedvc/umple | public EllipticalShape ( String aCenter , String aSemiMajorAxis ) { super ( aCenter ) ; semiMajorAxis = aSemiMajorAxis ; }
ahmedvc/umple | public boolean setSemiMajorAxis ( String aSemiMajorAxis ) { boolean wasSet = false ; semiMajorAxis = aSemiMajorAxis ; wasSet = true ; return wasSet ; }
ahmedvc/umple | public String getSemiMajorAxis ( ) { return semiMajorAxis ; }
ahmedvc/umple | public void delete ( ) { super . delete ( ) ; }
ahmedvc/umple | public String toString ( ) { String outputString = " " ; return super . toString ( ) + " [ " + " semiMajorAxis " + " : " + getSemiMajorAxis ( ) + " ] " + outputString ; }
McLeodMoores/starling | public DataRegionSourceResource ( final RegionSource regionSource ) { ArgumentChecker . notNull ( regionSource , " regionSource " ) ; _regSource = regionSource ; }
McLeodMoores/starling | public RegionSource getRegionSource ( ) { return _regSource ; }
McLeodMoores/starling | @ GET public Response getHateaos ( @ Context final UriInfo uriInfo ) { return hateoasResponse ( uriInfo ) ; }
McLeodMoores/starling | @ GET @ Path ( " regions " ) public Response search ( @ QueryParam ( " versionAsOf " ) final String versionAsOf , @ QueryParam ( " correctedTo " ) final String correctedTo , @ QueryParam ( " id " ) final List < String > externalIdStrs ) { final VersionCorrection vc = VersionCorrection . parse ( versionAsOf , correctedTo ) ; final ExternalIdBundle bundle = ExternalIdBundle . parse ( externalIdStrs ) ; final Collection < ? extends Region > result = getRegionSource ( ) . get ( bundle , vc ) ; return responseOkObject ( FudgeListWrapper . of ( result ) ) ; }
McLeodMoores/starling | " ) public Response get ( @ PathParam ( " regionId " ) final String idStr , @ QueryParam ( " version " ) final String version , @ QueryParam ( " versionAsOf " ) final String versionAsOf , @ QueryParam ( " correctedTo " ) final String correctedTo ) { final ObjectId objectId = ObjectId . parse ( idStr ) ; if ( version != null ) { final Region result = getRegionSource ( ) . get ( objectId . atVersion ( version ) ) ; return responseOkObject ( result ) ; } final VersionCorrection vc = VersionCorrection . parse ( versionAsOf , correctedTo ) ; final Region result = getRegionSource ( ) . get ( objectId , vc ) ; return responseOkObject ( result ) ; }
McLeodMoores/starling | @ GET @ Path ( " regionSearches / highest " ) public Response searchHighest ( @ QueryParam ( " id " ) final List < String > externalIdStrs ) { final ExternalIdBundle bundle = ExternalIdBundle . parse ( externalIdStrs ) ; final Region result = getRegionSource ( ) . getHighestLevelRegion ( bundle ) ; return responseOkObject ( result ) ; }
gjordi/gwt-jsni | private JsArrayUtil ( ) { }
ionutsp17/JavaMainRepo | public CardPanel ( String imagePath ) { this . loadCardImage ( imagePath ) ; }
ionutsp17/JavaMainRepo | public void paintComponent ( Graphics g ) { g . drawImage ( this . cardImage , 2 , 2 , this ) ; }
ionutsp17/JavaMainRepo | public void loadCardImage ( String imagePath ) { this . cardImage = new ImageIcon ( imagePath ) . getImage ( ) ; }
danileyang/mmp | if ( queryParam != null ) { if ( uri . indexOf ( ' ? ' ) == - 1 ) { uri += ' ? ' ; } uri += uri . endsWith ( " ? " ) ? queryParam : ' & ' + queryParam ; }
danileyang/mmp | if ( httpProxy != null ) { RequestConfig config = RequestConfig . custom ( ) . setProxy ( httpProxy ) . build ( ) ; httpGet . setConfig ( config ) ; }
danileyang/mmp | if ( error . getErrorCode ( ) != 0 ) { throw new WxErrorException ( error ) ; }
danileyang/mmp | if ( queryParam != null ) { if ( uri . indexOf ( ' ? ' ) == - 1 ) { uri += ' ? ' ; } uri += uri . endsWith ( " ? " ) ? queryParam : ' & ' + queryParam ; }
danileyang/mmp | if ( httpProxy != null ) { RequestConfig config = RequestConfig . custom ( ) . setProxy ( httpProxy ) . build ( ) ; httpGet . setConfig ( config ) ; }
danileyang/mmp | if ( error . getErrorCode ( ) != 0 ) { throw new WxErrorException ( error ) ; }
daniel-beck/sorcerer | protected JsArray ( ) { }
daniel-beck/sorcerer | public final Iterable < T > iterable ( ) { return new Iterable < T > ( ) { public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { int index = 0 ; public boolean hasNext ( ) { return index < length ( ) ; } public T next ( ) { return get ( index ++ ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; }
gabelew/SimCity201 | public payment ( double a , DeliveryMan d , payState received , int num ) { delivery = d ; amount = a ; pState = received ; payNum = num ; }
gabelew/SimCity201 | public customer ( Customer c , float amount ) { cust = c ; owed = amount ; }
gabelew/SimCity201 | public Check ( Waiter waiter , String choice2 , int tableNumber2 , state created ) { w = waiter ; choice = choice2 ; tableNumber = tableNumber2 ; S = created ; }
gabelew/SimCity201 | public EBCashierRole ( ) { super ( ) ; payNumber = 0 ; }
gabelew/SimCity201 | public void msgHereIsCheck ( Waiter w , String choice , int tableNumber ) { Checks . add ( new Check ( w , choice , tableNumber , state . created ) ) ; stateChanged ( ) ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Creating ▁ check ▁ for ▁ table ▁ " + tableNumber ) ; }
gabelew/SimCity201 | public void msgPaying ( double amount , int tableNumber , boolean payInFull ) { for ( Check c : Checks ) { if ( c . tableNumber == tableNumber ) { if ( payInFull ) { c . S = state . paid ; } else { c . S = state . waiting ; } bank = bank + amount ; } } amount = ( Math . round ( 100 * amount ) / ( ( double ) 100 ) ) ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Received ▁ payment ▁ of ▁ " + amount + " ▁ for ▁ table ▁ " + tableNumber ) ; }
gabelew/SimCity201 | public void msgAddToTab ( double amount , Customer cust ) { exists = false ; for ( customer c : Customers ) { if ( c . cust == cust ) { c . owed = c . owed + ( float ) amount ; exists = true ; } } if ( ! exists ) { Customers . add ( new customer ( cust , ( float ) amount ) ) ; } }
gabelew/SimCity201 | public void msgHereIsInvoice ( double amount , DeliveryMan DM ) { receivedInvoice = true ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Received ▁ invoice ▁ from ▁ cook " ) ; stateChanged ( ) ; }
gabelew/SimCity201 | public boolean pickAndExecuteAnAction ( ) { try { if ( cashierState == CashState . releaveFromDuty ) { cashierState = CashState . none ; myPerson . releavedFromDuty ( this ) ; if ( replacementPerson != null ) { replacementPerson . waitingResponse . release ( ) ; } } if ( cashierState == CashState . goToWork ) { cashierState = CashState . working ; cashierGui . DoEnterRestaurant ( ) ; return true ; } if ( cashierState == CashState . leaving ) { boolean needsToPay = false ; for ( payment p : Payments ) { if ( p . pState != payState . owes ) { needsToPay = true ; } } if ( ! needsToPay ) { cashierState = CashState . none ; if ( ! " Saturday " . equals ( myPerson . dayOfWeek ) && ! " Sunday " . equals ( myPerson . dayOfWeek ) && myPerson . aBankIsOpen ( ) ) DepositBusinessCash ( ) ; cashierGui . DoLeaveRestaurant ( ) ; return true ; } } for ( payment p : Payments ) { if ( p . pState == payState . receivedBill && receivedInvoice && bank > 0 ) { payMarket ( p ) ; return true ; } if ( p . pState == payState . lastTime && bank > 0 ) { neverOrderFromMarketAgain ( p ) ; payMarket ( p ) ; return true ; } if ( p . pState == payState . owes && bank > 0 ) { payMarket ( p ) ; return true ; } } for ( Check c : Checks ) { if ( c . S == state . created ) { c . S = state . waiting ; createCheck ( c . choice , c . tableNumber , c . w ) ; return true ; } } for ( Check c : Checks ) { if ( c . S == state . paid ) { removeCheck ( c . tableNumber ) ; return true ; } } return false ; } catch ( ConcurrentModificationException e ) { return false ; } }
gabelew/SimCity201 | private void neverOrderFromMarketAgain ( payment p ) { restaurant . cook . msgNeverOrderFromMarketAgain ( ( ( DeliveryManRole ) p . delivery ) . Market ) ; }
gabelew/SimCity201 | private void payMarket ( payment p ) { if ( bank < p . amount ) { p . pState = payState . owes ; } else { receivedInvoice = false ; p . pState = payState . paid ; p . delivery . msgHereIsPayment ( p . amount , this ) ; bank = bank - p . amount ; Payments . remove ( p ) ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Payed ▁ market : ▁ " + p . amount ) ; } }
gabelew/SimCity201 | private void createCheck ( String choice , int tableNumber , Waiter waiter ) { ( ( EBWaiterRole ) waiter ) . msgCheckCreated ( menu . hm . get ( choice ) , tableNumber ) ; }
gabelew/SimCity201 | public void removeCheck ( int tableNumber ) { for ( Check c : Checks ) { if ( c . tableNumber == tableNumber ) { Checks . remove ( c ) ; } } }
gabelew/SimCity201 | private void DepositBusinessCash ( ) { double cash = bank - 1500 ; cash = ( Math . round ( 100 * cash ) / ( ( double ) 100 ) ) ; int balance = Double . compare ( cash , 0 ) ; if ( 1 == balance ) { bank -= cash ; myPerson . businessFunds += cash ; myPerson . msgDepositBusinessCash ( ) ; } AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Depositing ▁ business ▁ cash " ) ; }
gabelew/SimCity201 | public void msgHereIsBill ( DeliveryMan DMR , double bill ) { boolean exists = false ; for ( payment p : Payments ) { if ( p . delivery == DMR ) { if ( receivedInvoice ) { exists = true ; p . pState = payState . paying ; if ( p . amount != bill ) { p . pState = payState . lastTime ; } } } } if ( ! exists ) { Payments . add ( new payment ( bill , DMR , payState . receivedBill , payNumber ) ) ; } AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Received ▁ Bill ▁ from ▁ Delivery ▁ Man " ) ; stateChanged ( ) ; }
gabelew/SimCity201 | public void msgReleaveFromDuty ( PersonAgent p ) { replacementPerson = p ; cashierState = CashState . leaving ; this . stateChanged ( ) ; }
gabelew/SimCity201 | public void goesToWork ( ) { cashierState = CashState . goToWork ; stateChanged ( ) ; }
gabelew/SimCity201 | public void setRestaurant ( Restaurant r ) { restaurant = r ; }
gabelew/SimCity201 | public void setGui ( EBCashierGui g ) { cashierGui = g ; }
gabelew/SimCity201 | public EBCashierGui getGui ( ) { return cashierGui ; }
gabelew/SimCity201 | public void setGui ( Gui g ) { cashierGui = ( EBCashierGui ) g ; }
gabelew/SimCity201 | public void msgLeft ( ) { cashierState = CashState . releaveFromDuty ; stateChanged ( ) ; }
gabelew/SimCity201 | public void msgClosed ( ) { cashierState = CashState . leaving ; stateChanged ( ) ; }
neoteric-eu/neo-starters | private TestContext mockTestClassContext ( Object instance ) { TestContext testContext = mock ( TestContext . class ) ; given ( testContext . getTestClass ( ) ) . willReturn ( ( Class ) instance . getClass ( ) ) ; given ( testContext . getApplicationContext ( ) ) . willReturn ( applicationContext ) ; return testContext ; }
neoteric-eu/neo-starters | @ Before public void setCollection ( ) { mongoTemplate . getCollection ( COLLECTION_NAME ) . insert ( new BasicDBObject ( ) ) ; mongoTemplate . getCollection ( COLLECTION_NAME ) . createIndex ( ADDITIONAL_INDEX ) ; }
neoteric-eu/neo-starters | @ Test public void shouldClearCollectionAndLeaveIndex ( ) throws Exception { WithClearCollectionClassAnnotation instance = new WithClearCollectionClassAnnotation ( ) ; cleanUpListener . afterTestMethod ( mockTestClassContext ( instance ) ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . count ( ) ) . isEqualTo ( 0 ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . size ( ) ) . isEqualTo ( 2 ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . get ( 0 ) . get ( " key " ) ) . isEqualTo ( DEFAULT_INDEX ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . get ( 1 ) . get ( " key " ) ) . isEqualTo ( ADDITIONAL_INDEX ) ; }
neoteric-eu/neo-starters | @ Test public void shouldDropCollectionAndIndex ( ) throws Exception { WithClearDropCollectionClassAnnotation instance = new WithClearDropCollectionClassAnnotation ( ) ; cleanUpListener . afterTestMethod ( mockTestClassContext ( instance ) ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . count ( ) ) . isEqualTo ( 0 ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
apetresc/aws-sdk-for-java-on-gae | public Request < DeleteLoadBalancerListenersRequest > marshall ( DeleteLoadBalancerListenersRequest deleteLoadBalancerListenersRequest ) { Request < DeleteLoadBalancerListenersRequest > request = new DefaultRequest < DeleteLoadBalancerListenersRequest > ( deleteLoadBalancerListenersRequest , " AmazonElasticLoadBalancing " ) ; request . addParameter ( " Action " , " DeleteLoadBalancerListeners " ) ; request . addParameter ( " Version " , "2010-07-01" ) ; if ( deleteLoadBalancerListenersRequest != null ) { if ( deleteLoadBalancerListenersRequest . getLoadBalancerName ( ) != null ) { request . addParameter ( " LoadBalancerName " , StringUtils . fromString ( deleteLoadBalancerListenersRequest . getLoadBalancerName ( ) ) ) ; } } if ( deleteLoadBalancerListenersRequest != null ) { java . util . List < Integer > loadBalancerPortsList = deleteLoadBalancerListenersRequest . getLoadBalancerPorts ( ) ; int loadBalancerPortsListIndex = 1 ; for ( Integer loadBalancerPortsListValue : loadBalancerPortsList ) { if ( loadBalancerPortsListValue != null ) { request . addParameter ( " LoadBalancerPorts . member . " + loadBalancerPortsListIndex , StringUtils . fromInteger ( loadBalancerPortsListValue ) ) ; } loadBalancerPortsListIndex ++ ; } } return request ; }
Azure/azure-sdk-for-java | public Boolean isTrusted ( ) { return this . isTrusted ; }
Azure/azure-sdk-for-java | public GatewayCertificateAuthorityContractProperties withIsTrusted ( Boolean isTrusted ) { this . isTrusted = isTrusted ; return this ; }
Azure/azure-sdk-for-java | public void validate ( ) { }
jordiponsllaurado/TypeformVoice | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . submit ) ; Intent messageIntent = getIntent ( ) ; String message = messageIntent . getStringExtra ( EXTRA_MESSAGE ) ; mText = ( TextView ) findViewById ( R . id . welcome_text ) ; String json = " { " + " ▁ ▁ \" title \" : \" Challenge ▁ satisfaction ▁ survey \" , " + " \" settings \" : ▁ { " + " ▁ ▁ ▁ ▁ \" language \" : ▁ \" en \" " + " ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" thankyou _ screens \" : ▁ [ " + " ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" Thank ▁ you ▁ for ▁ participating ! \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ \" properties \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" show _ button \" : ▁ true , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" button _ text \" : ▁ \" start \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" button _ mode \" : ▁ \" redirect \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" redirect _ url \" : ▁ \" http : // www . typeform . com \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" share _ icons \" : ▁ false " + " ▁ ▁ ▁ ▁ } " + " } " + " ▁ ▁ ] , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" fields \" : ▁ [ " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" What ' s ▁ your ▁ name ? \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" type \" : ▁ \" short _ text \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" validations \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" required \" : ▁ false , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" max _ length \" : ▁ 20" + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" " + message + " \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" type \" : ▁ \" opinion _ scale \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" properties \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" description \" : ▁ \" \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" steps \" : ▁ 10 , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" start _ at _ one \" : ▁ true , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" labels \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" left \" : ▁ \" ▁ left ▁ label \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" center \" : ▁ \" center ▁ label \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" right \" : ▁ \" right ▁ label \" " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" validations \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" required \" : ▁ false " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ] " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " ; try { JSONObject jsonObject = new JSONObject ( json ) ; bob = new BobTheBuilder ( jsonObject ) ; bob . execute ( ) ; } catch ( JSONException e ) { } mTts = new TextToSpeech ( this , new TextToSpeech . OnInitListener ( ) { @ Override public void onInit ( int i ) { if ( i == TextToSpeech . SUCCESS ) { mTts . setOnUtteranceCompletedListener ( new TextToSpeech . OnUtteranceCompletedListener ( ) { @ Override public void onUtteranceCompleted ( String utteranceId ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { emailBtn = ( Button ) findViewById ( R . id . email ) ; emailBtn . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { String responseBody = bob . getResponseBody ( ) ; try { String jsonObj = new JSONObject ( responseBody ) . getString ( " id " ) ; Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( " message / rfc822" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { " all @ typeform . com " } ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , " Rate ▁ the ▁ Challenge ! " ) ; intent . setPackage ( " com . google . android . gm " ) ; intent . putExtra ( Intent . EXTRA_TEXT , Html . fromHtml ( " Please ▁ fill ▁ the ▁ following ▁ form : ▁ < a ▁ href = \" https : // pauboix . typeform . com / to " + jsonObj + " \" > Link < / a > " ) ) ; if ( intent . resolveActivity ( getPackageManager ( ) ) != null ) startActivity ( intent ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } } ) ; } } ) ; } } ) ; mTts . setLanguage ( Locale . getDefault ( ) ) ; HashMap < String , String > params = new HashMap < String , String > ( ) ; params . put ( TextToSpeech . Engine . KEY_PARAM_UTTERANCE_ID , " stringId " ) ; mTts . speak ( " Your ▁ Typeform ▁ is ▁ Done ! \n ▁ Do ▁ you ▁ want ▁ to ▁ send ▁ it ▁ out ▁ now ? " , TextToSpeech . QUEUE_FLUSH , params ) ; } else { mTts = null ; Log . e ( " MainActivity " , " Failed ▁ to ▁ initialize ▁ the ▁ TextToSpeech ▁ engine " ) ; } } } ) ; }
jordiponsllaurado/TypeformVoice | @ Override protected void onStop ( ) { stopVoiceRecorder ( ) ; mSpeechService = null ; super . onStop ( ) ; }
jordiponsllaurado/TypeformVoice | private final VoiceRecorder . Callback mVoiceCallback = new VoiceRecorder . Callback ( ) { @ Override public void onVoiceStart ( ) { if ( mSpeechService != null ) { mSpeechService . startRecognizing ( mVoiceRecorder . getSampleRate ( ) ) ; } } @ Override public void onVoice ( byte [ ] data , int size ) { if ( mSpeechService != null ) { mSpeechService . recognize ( data , size ) ; } } @ Override public void onVoiceEnd ( ) { if ( mSpeechService != null ) { mSpeechService . finishRecognizing ( ) ; } } }
jordiponsllaurado/TypeformVoice | private final ServiceConnection mServiceConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName componentName , IBinder binder ) { mSpeechService = SpeechService . from ( binder ) ; mSpeechService . addListener ( mSpeechServiceListener ) ; } @ Override public void onServiceDisconnected ( ComponentName componentName ) { mSpeechService = null ; } }
jordiponsllaurado/TypeformVoice | private final SpeechService . Listener mSpeechServiceListener = new SpeechService . Listener ( ) { @ Override public void onSpeechRecognized ( final String text , final boolean isFinal ) { if ( isFinal ) { mVoiceRecorder . dismiss ( ) ; } if ( mText != null && ! TextUtils . isEmpty ( text ) ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( isFinal ) { mVoiceRecorder . stop ( ) ; String responseBody = bob . getResponseBody ( ) ; Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( " message / rfc822" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { " all @ typeform . com " } ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , " Rate ▁ the ▁ Challenge ! " ) ; intent . setPackage ( " com . google . android . gm " ) ; intent . putExtra ( Intent . EXTRA_TEXT , responseBody ) ; if ( intent . resolveActivity ( getPackageManager ( ) ) != null ) startActivity ( intent ) ; } else { } } } ) ; } } }
jordiponsllaurado/TypeformVoice | private void startVoiceRecorder ( ) { if ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . RECORD_AUDIO ) == PackageManager . PERMISSION_GRANTED ) { if ( mVoiceRecorder != null ) { mVoiceRecorder . stop ( ) ; } mVoiceRecorder = new VoiceRecorder ( mVoiceCallback ) ; mVoiceRecorder . start ( ) ; } }
jordiponsllaurado/TypeformVoice | private void stopVoiceRecorder ( ) { if ( mVoiceRecorder != null ) { mVoiceRecorder . stop ( ) ; mVoiceRecorder = null ; } }
anninpavel/VTUZ_SE_Store | @ NonNull @ Override public Observable < RealmResults < StoreModel > > getAll ( ) { return RealmUtil . getRealm ( ) . where ( StoreModel . class ) . findAllSorted ( StoreModel . FIELD_NAME ) . asObservable ( ) . filter ( RealmResults :: isLoaded ) ; }
anninpavel/VTUZ_SE_Store | @ NonNull @ Override public Observable < StoreModel > getById ( @ NonNull String id ) { return RealmUtil . getRealm ( ) . where ( StoreModel . class ) . equalTo ( StoreModel . FIELD_ID , id ) . findFirst ( ) . asObservable ( ) ; }
anninpavel/VTUZ_SE_Store | @ Override public void asyncCreateStore ( @ NonNull String name ) { RealmUtil . getRealm ( ) . executeTransactionAsync ( realm -> { StoreModel store = realm . createObject ( StoreModel . class ) ; store . setId ( UUID . randomUUID ( ) . toString ( ) ) ; store . setName ( name ) ; } ) ; }
anninpavel/VTUZ_SE_Store | @ Override public void asyncSaveStore ( @ NonNull String id , @ NonNull String name ) { RealmUtil . getRealm ( ) . executeTransactionAsync ( realm -> { StoreModel store = realm . where ( StoreModel . class ) . equalTo ( StoreModel . FIELD_ID , id ) . findFirst ( ) ; if ( store != null && store . isValid ( ) ) { store . setName ( name ) ; } } ) ; }
anninpavel/VTUZ_SE_Store | @ Override public boolean canStoreRemoved ( @ NonNull String id ) { return RealmUtil . getRealm ( ) . where ( InvoiceModel . class ) . equalTo ( InvoiceModel . FIELD_STORE + " . " + StoreModel . FIELD_ID , id ) . count ( ) == 0 ; }
anninpavel/VTUZ_SE_Store | @ Override public void asyncRemoveStore ( @ NonNull String id ) { RealmUtil . getRealm ( ) . executeTransactionAsync ( realm -> { StoreModel store = realm . where ( StoreModel . class ) . equalTo ( StoreModel . FIELD_ID , id ) . findFirst ( ) ; if ( store != null && store . isValid ( ) ) { store . deleteFromRealm ( ) ; } } ) ; }
eswdd/disco | @ Test public void doTest ( ) throws Exception { DiscoManager discoManager1 = DiscoManager . getInstance ( ) ; HttpCallBean httpCallBeanBaseline = discoManager1 . getNewHttpCallBean ( ) ; DiscoManager discoManagerBaseline = discoManager1 ; httpCallBeanBaseline . setServiceName ( " baseline " , " discoBaseline " ) ; httpCallBeanBaseline . setVersion ( " v2" ) ; DiscoManager discoManager2 = DiscoManager . getInstance ( ) ; HttpCallBean getNewHttpCallBean2 = discoManager2 . getNewHttpCallBean ( "87.248.113.14" ) ; discoManager2 = discoManager2 ; discoManager2 . setDiscoFaultControllerJMXMBeanAttrbiute ( " DetailedFaults " , " false " ) ; getNewHttpCallBean2 . setOperationName ( " simpleMapOperation " ) ; getNewHttpCallBean2 . setServiceName ( " baseline " , " discoBaseline " ) ; getNewHttpCallBean2 . setVersion ( " v2" ) ; Timestamp getTimeAsTimeStamp8 = new Timestamp ( System . currentTimeMillis ( ) ) ; discoManager2 . makeRestDiscoHTTPCall ( getNewHttpCallBean2 , DiscoMessageProtocolRequestTypeEnum . RESTXML , DiscoMessageContentTypeEnum . XML ) ; discoManager2 . makeRestDiscoHTTPCall ( getNewHttpCallBean2 , DiscoMessageProtocolRequestTypeEnum . RESTXML , DiscoMessageContentTypeEnum . JSON ) ; XMLHelpers xMLHelpers4 = new XMLHelpers ( ) ; Document createAsDocument11 = xMLHelpers4 . getXMLObjectFromString ( " < fault > < faultcode > Client < / faultcode > < faultstring > DSC - 0044 < / faultstring > < detail / > < / fault > " ) ; JSONHelpers jSONHelpers5 = new JSONHelpers ( ) ; JSONObject convertXMLDocumentToJSONObjectRemoveRootElement12 = jSONHelpers5 . convertXMLDocumentToJSONObjectRemoveRootElement ( createAsDocument11 ) ; HttpResponseBean response6 = getNewHttpCallBean2 . getResponseObjectsByEnum ( DiscoMessageProtocolResponseTypeEnum . RESTXMLXML ) ; AssertionUtils . multiAssertEquals ( createAsDocument11 , response6 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response6 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response6 . getHttpStatusText ( ) ) ; HttpResponseBean response7 = getNewHttpCallBean2 . getResponseObjectsByEnum ( DiscoMessageProtocolResponseTypeEnum . RESTXMLJSON ) ; AssertionUtils . multiAssertEquals ( convertXMLDocumentToJSONObjectRemoveRootElement12 , response7 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response7 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response7 . getHttpStatusText ( ) ) ; DiscoManager discoManager10 = DiscoManager . getInstance ( ) ; discoManager10 . verifyAccessLogEntriesAfterDate ( getTimeAsTimeStamp8 , new AccessLogRequirement ( "87.248.113.14" , " / discoBaseline / v2 / simpleMapOperation " , " BadRequest " ) , new AccessLogRequirement ( "87.248.113.14" , " / discoBaseline / v2 / simpleMapOperation " , " BadRequest " ) ) ; }
joypupil/study | private SystemInfo ( ) { try { localHost = InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } }
joypupil/study | public String getIP ( ) { String ip = localHost . getHostAddress ( ) ; return ip ; }
joypupil/study | public String getHostName ( ) { return localHost . getHostName ( ) ; }
joypupil/study | public String getDiskNumber ( ) { String line = " " ; String HdSerial = " " ; try { Process proces = Runtime . getRuntime ( ) . exec ( " cmd ▁ / c ▁ dir ▁ c : " ) ; BufferedReader buffreader = new BufferedReader ( new InputStreamReader ( proces . getInputStream ( ) ) ) ; while ( ( line = buffreader . readLine ( ) ) != null ) { if ( line . indexOf ( " 卷的序列号是 ▁ " ) != - 1 ) { HdSerial = line . substring ( line . indexOf ( " 卷的序列号是 ▁ " ) + " 卷的序列号是 ▁ " . length ( ) , line . length ( ) ) ; break ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } return HdSerial ; }
joypupil/study | public String getMac ( ) { NetworkInterface byInetAddress ; try { byInetAddress = NetworkInterface . getByInetAddress ( localHost ) ; byte [ ] hardwareAddress = byInetAddress . getHardwareAddress ( ) ; return getMacFromBytes ( hardwareAddress ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } return null ; }
joypupil/study | public String getSystemName ( ) { Properties sysProperty = System . getProperties ( ) ; String systemName = sysProperty . getProperty ( " os . name " ) ; return systemName ; }
joypupil/study | private String getMacFromBytes ( byte [ ] bytes ) { StringBuffer mac = new StringBuffer ( ) ; byte currentByte ; boolean first = false ; for ( byte b : bytes ) { if ( first ) { mac . append ( " - " ) ; } currentByte = ( byte ) ( ( b & 240 ) >> 4 ) ; mac . append ( Integer . toHexString ( currentByte ) ) ; currentByte = ( byte ) ( b & 15 ) ; mac . append ( Integer . toHexString ( currentByte ) ) ; first = true ; } return mac . toString ( ) . toUpperCase ( ) ; }
WU-ARL/RLI | public ChatMessage ( ONL . Reader rdr ) throws IOException { retrieve ( rdr ) ; }
WU-ARL/RLI | public ChatMessage ( String nm , String m ) { msg = new String ( m ) ; version = ( short ) ( ExpCoordinator . VERSION_BYTES >> 16 ) ; sender = new String ( nm ) ; }
WU-ARL/RLI | public void store ( DataOutputStream dout ) throws IOException { if ( dout == null ) ExpCoordinator . printer . print ( " NCCP . RequesterBase . storeHeader ▁ dout ▁ is ▁ null " ) ; dout . writeShort ( NCCP . MessageChat ) ; dout . writeShort ( version ) ; NCCP . writeString ( sender , dout ) ; NCCP . writeString ( msg , dout ) ; }
WU-ARL/RLI | public void retrieve ( ONL . Reader rdr ) throws IOException { version = ( short ) rdr . readShort ( ) ; sender = rdr . readString ( ) ; msg = rdr . readString ( ) ; }
WU-ARL/RLI | public short getVersion ( ) { return version ; }
WU-ARL/RLI | public String getMsg ( ) { return msg ; }
WU-ARL/RLI | public String getSender ( ) { return sender ; }
WU-ARL/RLI | public ObserveDaemon ( int sid , Observer o ) { super ( NCCPConnection . PEER , sid , ONLDaemon . OBSERVE ) ; ExpCoordinator . print ( new String ( " ObserverDaemon ▁ Observed ▁ sessionID : " + sid ) , 2 ) ; ExpCoordinator . print ( toString ( ) ) ; setProxy ( ExpCoordinator . theCoordinator . getProxy ( ) ) ; getProxy ( ) . addConnection ( this ) ; observer = o ; }
WU-ARL/RLI | if ( msgtype == NCCP . MessageChat ) { ExpCoordinator . printer . print ( " ▁ Chat ▁ Message " , 9 ) ; ChatMessage cmsg = new ChatMessage ( rdr ) ; observer . addChatMessage ( cmsg . getSender ( ) , cmsg . getMsg ( ) ) ; }
WU-ARL/RLI | if ( msg . isAck ( ) ) { ++ ackcount ; sendAck ( msg ) ; ExpCoordinator . printer . print ( new String ( " ObserveDaemon : : run ▁ message ▁ is ▁ ▁ NCCP . MessagePeriodic ▁ ack ▁ " + ackcount ) , 9 ) ; }
WU-ARL/RLI | private REND_Marker_class getNextMarker ( ) { return ( new REND_Marker_class ( ++ reqCount ) ) ; }
WU-ARL/RLI | public short getSID ( ) { return ( ( short ) getPort ( ) ) ; }
WU-ARL/RLI | public void setSID ( short sid ) { ExpCoordinator . print ( new String ( " ObserveDaemon . setSID ▁ " + sid ) , 2 ) ; setPort ( ( int ) sid ) ; }
WU-ARL/RLI | public void close ( ) { if ( ExpCoordinator . isObserver ( ) ) super . close ( ) ; else setConnected ( false ) ; }
wangsongpeng/jdk-src | private TemporalQueries ( ) { }
wangsongpeng/jdk-src | if ( temporal . isSupported ( OFFSET_SECONDS ) ) { return ZoneOffset . ofTotalSeconds ( temporal . get ( OFFSET_SECONDS ) ) ; }
wangsongpeng/jdk-src | if ( temporal . isSupported ( EPOCH_DAY ) ) { return LocalDate . ofEpochDay ( temporal . getLong ( EPOCH_DAY ) ) ; }
wangsongpeng/jdk-src | if ( temporal . isSupported ( NANO_OF_DAY ) ) { return LocalTime . ofNanoOfDay ( temporal . getLong ( NANO_OF_DAY ) ) ; }
rogerchina/activemq-artemis | public void start ( ) { bootstrap = new Bootstrap ( ) ; bootstrap . channel ( NioSocketChannel . class ) ; bootstrap . group ( new NioEventLoopGroup ( 10 ) ) ; bootstrap . handler ( new ChannelInitializer < Channel > ( ) { public void initChannel ( Channel channel ) throws Exception { } } ) ; }
rogerchina/activemq-artemis | public AMQPClientConnectionContext connect ( String host , int port ) throws Exception { SocketAddress remoteDestination = new InetSocketAddress ( host , port ) ; ChannelFuture future = bootstrap . connect ( remoteDestination ) ; future . awaitUninterruptibly ( ) ; AMQPClientSPI clientConnectionSPI = new AMQPClientSPI ( future . channel ( ) ) ; final AMQPClientConnectionContext connection = ( AMQPClientConnectionContext ) ProtonClientConnectionContextFactory . getFactory ( ) . createConnection ( clientConnectionSPI ) ; future . channel ( ) . pipeline ( ) . addLast ( new ChannelDuplexHandler ( ) { @ Override public void channelRead ( final ChannelHandlerContext ctx , final Object msg ) throws Exception { ByteBuf buffer = ( ByteBuf ) msg ; connection . inputBuffer ( buffer ) ; } } ) ; return connection ; }
justin-espedal/polydes | @ Override public void onStartup ( ) { super . onStartup ( ) ; _instance = this ; isInMenu = true ; menuName = " Paint ▁ Extension " ; isInGameCenter = true ; gameCenterName = " Paint ▁ Extension " ; }
justin-espedal/polydes | @ Override public void onActivate ( ) { }
justin-espedal/polydes | @ Override public JPanel onGameCenterActivate ( ) { return MainEditor . get ( ) ; }
justin-espedal/polydes | public JPanel getBlankPanel ( ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBackground ( new Color ( 62 , 62 , 62 ) ) ; return panel ; }
justin-espedal/polydes | @ Override public void onDestroy ( ) { }
justin-espedal/polydes | @ Override public void onGameSave ( Game game ) { Fonts . get ( ) . saveChanges ( fontsFile ) ; Images . get ( ) . saveChanges ( imagesFile ) ; MainEditor . get ( ) . gameSaved ( ) ; }
justin-espedal/polydes | @ Override public void onGameBuild ( Game game ) { onGameSave ( game ) ; }
justin-espedal/polydes | @ Override public void onGameOpened ( Game game ) { extras = new File ( Locations . getGameLocation ( game ) + " extras / " + getManifest ( ) . id ) ; extras . mkdirs ( ) ; if ( extras . list ( ) . length == 0 ) loadDefaults ( ) ; fontsFile = new File ( extras , " fonts " ) ; imagesFile = new File ( extras , " images " ) ; Fonts . get ( ) . load ( fontsFile ) ; Images . get ( ) . load ( imagesFile ) ; }
justin-espedal/polydes | private void loadDefaults ( ) { File f ; try { f = new File ( extras , " fonts / Default ▁ Font . fnt " ) ; f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) FileHelper . writeStringToFile ( f . getAbsolutePath ( ) , Defaults . load ( " Default ▁ Font . fnt " ) ) ; f = new File ( extras , " fonts / Default ▁ Font . png " ) ; if ( ! f . exists ( ) ) FileHelper . writeToPNG ( f . getAbsolutePath ( ) , Defaults . loadImage ( " Default ▁ Font . png " ) ) ; f = new File ( extras , " images / Default ▁ Window . png " ) ; f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) FileHelper . writeToPNG ( f . getAbsolutePath ( ) , Defaults . loadImage ( " Default ▁ Window . png " ) ) ; f = new File ( extras , " images / Pointer . png " ) ; if ( ! f . exists ( ) ) FileHelper . writeToPNG ( f . getAbsolutePath ( ) , Defaults . loadImage ( " Pointer . png " ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
justin-espedal/polydes | @ Override public void onGameClosed ( Game game ) { super . onGameClosed ( game ) ; Fonts . get ( ) . unload ( ) ; Images . get ( ) . unload ( ) ; MainEditor . disposePages ( ) ; }
justin-espedal/polydes | @ Override public OptionsPanel onOptions ( ) { return null ; }
justin-espedal/polydes | @ Override protected boolean hasOptions ( ) { return false ; }
justin-espedal/polydes | @ Override public void onInstall ( ) { }
justin-espedal/polydes | @ Override public void onUninstall ( ) { }
indashnet/InDashNet.Open.UN2000 | public TextToSpeech ( Context context , OnInitListener listener ) { this ( context , listener , null ) ; }
indashnet/InDashNet.Open.UN2000 | public TextToSpeech ( Context context , OnInitListener listener , String engine ) { this ( context , listener , engine , null , true ) ; }
indashnet/InDashNet.Open.UN2000 | public TextToSpeech ( Context context , OnInitListener listener , String engine , String packageName , boolean useFallback ) { mContext = context ; mInitListener = listener ; mRequestedEngine = engine ; mUseFallback = useFallback ; mEarcons = new HashMap < String , Uri > ( ) ; mUtterances = new HashMap < String , Uri > ( ) ; mUtteranceProgressListener = null ; mEnginesHelper = new TtsEngines ( mContext ) ; if ( packageName != null ) { mPackageName = packageName ; } else { mPackageName = mContext . getPackageName ( ) ; } initTts ( ) ; }
indashnet/InDashNet.Open.UN2000 | private < R > R runActionNoReconnect ( Action < R > action , R errorResult , String method , boolean onlyEstablishedConnection ) { return runAction ( action , errorResult , method , false , onlyEstablishedConnection ) ; }
indashnet/InDashNet.Open.UN2000 | private < R > R runAction ( Action < R > action , R errorResult , String method ) { return runAction ( action , errorResult , method , true , true ) ; }
indashnet/InDashNet.Open.UN2000 | private < R > R runAction ( Action < R > action , R errorResult , String method , boolean reconnect , boolean onlyEstablishedConnection ) { synchronized ( mStartLock ) { if ( mServiceConnection == null ) { Log . w ( TAG , method + " ▁ failed : ▁ not ▁ bound ▁ to ▁ TTS ▁ engine " ) ; return errorResult ; } return mServiceConnection . runAction ( action , errorResult , method , reconnect , onlyEstablishedConnection ) ; } }
indashnet/InDashNet.Open.UN2000 | private int initTts ( ) { if ( mRequestedEngine != null ) { if ( mEnginesHelper . isEngineInstalled ( mRequestedEngine ) ) { if ( connectToEngine ( mRequestedEngine ) ) { mCurrentEngine = mRequestedEngine ; return SUCCESS ; } else if ( ! mUseFallback ) { mCurrentEngine = null ; dispatchOnInit ( ERROR ) ; return ERROR ; } } else if ( ! mUseFallback ) { Log . i ( TAG , " Requested ▁ engine ▁ not ▁ installed : ▁ " + mRequestedEngine ) ; mCurrentEngine = null ; dispatchOnInit ( ERROR ) ; return ERROR ; } } final String defaultEngine = getDefaultEngine ( ) ; if ( defaultEngine != null && ! defaultEngine . equals ( mRequestedEngine ) ) { if ( connectToEngine ( defaultEngine ) ) { mCurrentEngine = defaultEngine ; return SUCCESS ; } } final String highestRanked = mEnginesHelper . getHighestRankedEngineName ( ) ; if ( highestRanked != null && ! highestRanked . equals ( mRequestedEngine ) && ! highestRanked . equals ( defaultEngine ) ) { if ( connectToEngine ( highestRanked ) ) { mCurrentEngine = highestRanked ; return SUCCESS ; } } mCurrentEngine = null ; dispatchOnInit ( ERROR ) ; return ERROR ; }
indashnet/InDashNet.Open.UN2000 | private boolean connectToEngine ( String engine ) { Connection connection = new Connection ( ) ; Intent intent = new Intent ( Engine . INTENT_ACTION_TTS_SERVICE ) ; intent . setPackage ( engine ) ; boolean bound = mContext . bindService ( intent , connection , Context . BIND_AUTO_CREATE ) ; if ( ! bound ) { Log . e ( TAG , " Failed ▁ to ▁ bind ▁ to ▁ " + engine ) ; return false ; } else { Log . i ( TAG , " Sucessfully ▁ bound ▁ to ▁ " + engine ) ; mConnectingServiceConnection = connection ; return true ; } }
indashnet/InDashNet.Open.UN2000 | private void dispatchOnInit ( int result ) { synchronized ( mStartLock ) { if ( mInitListener != null ) { mInitListener . onInit ( result ) ; mInitListener = null ; } } }
indashnet/InDashNet.Open.UN2000 | private IBinder getCallerIdentity ( ) { return mServiceConnection . getCallerIdentity ( ) ; }
indashnet/InDashNet.Open.UN2000 | public void shutdown ( ) { synchronized ( mStartLock ) { if ( mConnectingServiceConnection != null ) { mContext . unbindService ( mConnectingServiceConnection ) ; mConnectingServiceConnection = null ; return ; } } runActionNoReconnect ( new Action < Void > ( ) { @ Override public Void run ( ITextToSpeechService service ) throws RemoteException { service . setCallback ( getCallerIdentity ( ) , null ) ; service . stop ( getCallerIdentity ( ) ) ; mServiceConnection . disconnect ( ) ; mServiceConnection = null ; mCurrentEngine = null ; return null ; } } , null , " shutdown " , false ) ; }
indashnet/InDashNet.Open.UN2000 | public int addSpeech ( String text , String packagename , int resourceId ) { synchronized ( mStartLock ) { mUtterances . put ( text , makeResourceUri ( packagename , resourceId ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | public int addSpeech ( String text , String filename ) { synchronized ( mStartLock ) { mUtterances . put ( text , Uri . parse ( filename ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | public int addEarcon ( String earcon , String packagename , int resourceId ) { synchronized ( mStartLock ) { mEarcons . put ( earcon , makeResourceUri ( packagename , resourceId ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | public int addEarcon ( String earcon , String filename ) { synchronized ( mStartLock ) { mEarcons . put ( earcon , Uri . parse ( filename ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | private Uri makeResourceUri ( String packageName , int resourceId ) { return new Uri . Builder ( ) . scheme ( ContentResolver . SCHEME_ANDROID_RESOURCE ) . encodedAuthority ( packageName ) . appendEncodedPath ( String . valueOf ( resourceId ) ) . build ( ) ; }
indashnet/InDashNet.Open.UN2000 | public int speak ( final String text , final int queueMode , final HashMap < String , String > params ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { Uri utteranceUri = mUtterances . get ( text ) ; if ( utteranceUri != null ) { return service . playAudio ( getCallerIdentity ( ) , utteranceUri , queueMode , getParams ( params ) ) ; } else { return service . speak ( getCallerIdentity ( ) , text , queueMode , getParams ( params ) ) ; } } } , ERROR , " speak " ) ; }
indashnet/InDashNet.Open.UN2000 | public int playEarcon ( final String earcon , final int queueMode , final HashMap < String , String > params ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { Uri earconUri = mEarcons . get ( earcon ) ; if ( earconUri == null ) { return ERROR ; } return service . playAudio ( getCallerIdentity ( ) , earconUri , queueMode , getParams ( params ) ) ; } } , ERROR , " playEarcon " ) ; }
indashnet/InDashNet.Open.UN2000 | public int playSilence ( final long durationInMs , final int queueMode , final HashMap < String , String > params ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { return service . playSilence ( getCallerIdentity ( ) , durationInMs , queueMode , getParams ( params ) ) ; } } , ERROR , " playSilence " ) ; }
indashnet/InDashNet.Open.UN2000 | public Set < String > getFeatures ( final Locale locale ) { return runAction ( new Action < Set < String > > ( ) { @ Override public Set < String > run ( ITextToSpeechService service ) throws RemoteException { String [ ] features = service . getFeaturesForLanguage ( locale . getISO3Language ( ) , locale . getISO3Country ( ) , locale . getVariant ( ) ) ; if ( features != null ) { final Set < String > featureSet = new HashSet < String > ( ) ; Collections . addAll ( featureSet , features ) ; return featureSet ; } return null ; } } , null , " getFeatures " ) ; }
indashnet/InDashNet.Open.UN2000 | public boolean isSpeaking ( ) { return runAction ( new Action < Boolean > ( ) { @ Override public Boolean run ( ITextToSpeechService service ) throws RemoteException { return service . isSpeaking ( ) ; } } , false , " isSpeaking " ) ; }
indashnet/InDashNet.Open.UN2000 | public int stop ( ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { return service . stop ( getCallerIdentity ( ) ) ; } } , ERROR , " stop " ) ; }
indashnet/InDashNet.Open.UN2000 | public int setSpeechRate ( float speechRate ) { if ( speechRate > 0.0f ) { int intRate = ( int ) ( speechRate * 100 ) ; if ( intRate > 0 ) { synchronized ( mStartLock ) { mParams . putInt ( Engine . KEY_PARAM_RATE , intRate ) ; } return SUCCESS ; } } return ERROR ; }
indashnet/InDashNet.Open.UN2000 | public int setPitch ( float pitch ) { if ( pitch > 0.0f ) { int intPitch = ( int ) ( pitch * 100 ) ; if ( intPitch > 0 ) { synchronized ( mStartLock ) { mParams . putInt ( Engine . KEY_PARAM_PITCH , intPitch ) ; } return SUCCESS ; } } return ERROR ; }
indashnet/InDashNet.Open.UN2000 | public String getCurrentEngine ( ) { return mCurrentEngine ; }
indashnet/InDashNet.Open.UN2000 | public Locale getDefaultLanguage ( ) { return runAction ( new Action < Locale > ( ) { @ Override public Locale run ( ITextToSpeechService service ) throws RemoteException { String [ ] defaultLanguage = service . getClientDefaultLanguage ( ) ; return new Locale ( defaultLanguage [ 0 ] , defaultLanguage [ 1 ] , defaultLanguage [ 2 ] ) ; } } , null , " getDefaultLanguage " ) ; }
indashnet/InDashNet.Open.UN2000 | public int setLanguage ( final Locale loc ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { if ( loc == null ) { return LANG_NOT_SUPPORTED ; } String language = null , country = null ; try { language = loc . getISO3Language ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 639-2 / T ▁ language ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } try { country = loc . getISO3Country ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 3166 ▁ country ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } String variant = loc . getVariant ( ) ; int result = service . loadLanguage ( getCallerIdentity ( ) , language , country , variant ) ; if ( result >= LANG_AVAILABLE ) { if ( result < LANG_COUNTRY_var_AVAILABLE ) { variant = " " ; if ( result < LANG_COUNTRY_AVAILABLE ) { country = " " ; } } mParams . putString ( Engine . KEY_PARAM_LANGUAGE , language ) ; mParams . putString ( Engine . KEY_PARAM_COUNTRY , country ) ; mParams . putString ( Engine . KEY_PARAM_VARIANT , variant ) ; } return result ; } } , LANG_NOT_SUPPORTED , " setLanguage " ) ; }
indashnet/InDashNet.Open.UN2000 | public Locale getLanguage ( ) { return runAction ( new Action < Locale > ( ) { @ Override public Locale run ( ITextToSpeechService service ) { String lang = mParams . getString ( Engine . KEY_PARAM_LANGUAGE , " " ) ; String country = mParams . getString ( Engine . KEY_PARAM_COUNTRY , " " ) ; String variant = mParams . getString ( Engine . KEY_PARAM_VARIANT , " " ) ; return new Locale ( lang , country , variant ) ; } } , null , " getLanguage " ) ; }
indashnet/InDashNet.Open.UN2000 | public int isLanguageAvailable ( final Locale loc ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { String language = null , country = null ; try { language = loc . getISO3Language ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 639-2 / T ▁ language ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } try { country = loc . getISO3Country ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 3166 ▁ country ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } return service . isLanguageAvailable ( language , country , loc . getVariant ( ) ) ; } } , LANG_NOT_SUPPORTED , " isLanguageAvailable " ) ; }
indashnet/InDashNet.Open.UN2000 | public int synthesizeToFile ( final String text , final HashMap < String , String > params , final String filename ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { ParcelFileDescriptor fileDescriptor ; int returnValue ; try { File file = new File ( filename ) ; if ( file . exists ( ) && ! file . canWrite ( ) ) { Log . e ( TAG , " Can ' t ▁ write ▁ to ▁ " + filename ) ; return ERROR ; } fileDescriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_WRITE_ONLY | ParcelFileDescriptor . MODE_CREATE | ParcelFileDescriptor . MODE_TRUNCATE ) ; returnValue = service . synthesizeToFileDescriptor ( getCallerIdentity ( ) , text , fileDescriptor , getParams ( params ) ) ; fileDescriptor . close ( ) ; return returnValue ; } catch ( FileNotFoundException e ) { Log . e ( TAG , " Opening ▁ file ▁ " + filename + " ▁ failed " , e ) ; return ERROR ; } catch ( IOException e ) { Log . e ( TAG , " Closing ▁ file ▁ " + filename + " ▁ failed " , e ) ; return ERROR ; } } } , ERROR , " synthesizeToFile " ) ; }
indashnet/InDashNet.Open.UN2000 | private Bundle getParams ( HashMap < String , String > params ) { if ( params != null && ! params . isEmpty ( ) ) { Bundle bundle = new Bundle ( mParams ) ; copyIntParam ( bundle , params , Engine . KEY_PARAM_STREAM ) ; copyStringParam ( bundle , params , Engine . KEY_PARAM_UTTERANCE_ID ) ; copyFloatParam ( bundle , params , Engine . KEY_PARAM_VOLUME ) ; copyFloatParam ( bundle , params , Engine . KEY_PARAM_PAN ) ; copyStringParam ( bundle , params , Engine . KEY_FEATURE_NETWORK_SYNTHESIS ) ; copyStringParam ( bundle , params , Engine . KEY_FEATURE_EMBEDDED_SYNTHESIS ) ; if ( ! TextUtils . isEmpty ( mCurrentEngine ) ) { for ( Map . Entry < String , String > entry : params . entrySet ( ) ) { final String key = entry . getKey ( ) ; if ( key != null && key . startsWith ( mCurrentEngine ) ) { bundle . putString ( key , entry . getValue ( ) ) ; } } } return bundle ; } else { return mParams ; } }
indashnet/InDashNet.Open.UN2000 | private void copyStringParam ( Bundle bundle , HashMap < String , String > params , String key ) { String value = params . get ( key ) ; if ( value != null ) { bundle . putString ( key , value ) ; } }
indashnet/InDashNet.Open.UN2000 | private void copyIntParam ( Bundle bundle , HashMap < String , String > params , String key ) { String valueString = params . get ( key ) ; if ( ! TextUtils . isEmpty ( valueString ) ) { try { int value = Integer . parseInt ( valueString ) ; bundle . putInt ( key , value ) ; } catch ( NumberFormatException ex ) { } } }
indashnet/InDashNet.Open.UN2000 | private void copyFloatParam ( Bundle bundle , HashMap < String , String > params , String key ) { String valueString = params . get ( key ) ; if ( ! TextUtils . isEmpty ( valueString ) ) { try { float value = Float . parseFloat ( valueString ) ; bundle . putFloat ( key , value ) ; } catch ( NumberFormatException ex ) { } } }
indashnet/InDashNet.Open.UN2000 | @ Deprecated public int setOnUtteranceCompletedListener ( final OnUtteranceCompletedListener listener ) { mUtteranceProgressListener = UtteranceProgressListener . from ( listener ) ; return TextToSpeech . SUCCESS ; }
indashnet/InDashNet.Open.UN2000 | public int setOnUtteranceProgressListener ( UtteranceProgressListener listener ) { mUtteranceProgressListener = listener ; return TextToSpeech . SUCCESS ; }
indashnet/InDashNet.Open.UN2000 | @ Deprecated public int setEngineByPackageName ( String enginePackageName ) { mRequestedEngine = enginePackageName ; return initTts ( ) ; }
indashnet/InDashNet.Open.UN2000 | public String getDefaultEngine ( ) { return mEnginesHelper . getDefaultEngine ( ) ; }
indashnet/InDashNet.Open.UN2000 | public boolean areDefaultsEnforced ( ) { return false ; }
indashnet/InDashNet.Open.UN2000 | public List < EngineInfo > getEngines ( ) { return mEnginesHelper . getEngines ( ) ; }
indashnet/InDashNet.Open.UN2000 | private final ITextToSpeechCallback . Stub mCallback = new ITextToSpeechCallback . Stub ( ) { @ Override public void onDone ( String utteranceId ) { UtteranceProgressListener listener = mUtteranceProgressListener ; if ( listener != null ) { listener . onDone ( utteranceId ) ; } } @ Override public void onError ( String utteranceId ) { UtteranceProgressListener listener = mUtteranceProgressListener ; if ( listener != null ) { listener . onError ( utteranceId ) ; } } @ Override public void onStart ( String utteranceId ) { UtteranceProgressListener listener = mUtteranceProgressListener ; if ( listener != null ) { listener . onStart ( utteranceId ) ; } } }
indashnet/InDashNet.Open.UN2000 | public SetupConnectionAsyncTask ( ComponentName name ) { mName = name ; }
indashnet/InDashNet.Open.UN2000 | @ Override protected Integer doInBackground ( Void ... params ) { synchronized ( mStartLock ) { if ( isCancelled ( ) ) { return null ; } try { mService . setCallback ( getCallerIdentity ( ) , mCallback ) ; String [ ] defaultLanguage = mService . getClientDefaultLanguage ( ) ; mParams . putString ( Engine . KEY_PARAM_LANGUAGE , defaultLanguage [ 0 ] ) ; mParams . putString ( Engine . KEY_PARAM_COUNTRY , defaultLanguage [ 1 ] ) ; mParams . putString ( Engine . KEY_PARAM_VARIANT , defaultLanguage [ 2 ] ) ; Log . i ( TAG , " Set ▁ up ▁ connection ▁ to ▁ " + mName ) ; return SUCCESS ; } catch ( RemoteException re ) { Log . e ( TAG , " Error ▁ connecting ▁ to ▁ service , ▁ setCallback ( ) ▁ failed " ) ; return ERROR ; } } }
indashnet/InDashNet.Open.UN2000 | @ Override protected void onPostExecute ( Integer result ) { synchronized ( mStartLock ) { if ( mOnSetupConnectionAsyncTask == this ) { mOnSetupConnectionAsyncTask = null ; } mEstablished = true ; dispatchOnInit ( result ) ; } }
indashnet/InDashNet.Open.UN2000 | @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { synchronized ( mStartLock ) { mConnectingServiceConnection = null ; Log . i ( TAG , " Connected ▁ to ▁ " + name ) ; if ( mOnSetupConnectionAsyncTask != null ) { mOnSetupConnectionAsyncTask . cancel ( false ) ; } mService = ITextToSpeechService . Stub . asInterface ( service ) ; mServiceConnection = Connection . this ; mEstablished = false ; mOnSetupConnectionAsyncTask = new SetupConnectionAsyncTask ( name ) ; mOnSetupConnectionAsyncTask . execute ( ) ; } }
indashnet/InDashNet.Open.UN2000 | public IBinder getCallerIdentity ( ) { return mCallback ; }
indashnet/InDashNet.Open.UN2000 | private boolean clearServiceConnection ( ) { synchronized ( mStartLock ) { boolean result = false ; if ( mOnSetupConnectionAsyncTask != null ) { result = mOnSetupConnectionAsyncTask . cancel ( false ) ; mOnSetupConnectionAsyncTask = null ; } mService = null ; if ( mServiceConnection == this ) { mServiceConnection = null ; } return result ; } }
indashnet/InDashNet.Open.UN2000 | @ Override public void onServiceDisconnected ( ComponentName name ) { Log . i ( TAG , " Asked ▁ to ▁ disconnect ▁ from ▁ " + name ) ; if ( clearServiceConnection ( ) ) { dispatchOnInit ( ERROR ) ; } }
indashnet/InDashNet.Open.UN2000 | public void disconnect ( ) { mContext . unbindService ( this ) ; clearServiceConnection ( ) ; }
indashnet/InDashNet.Open.UN2000 | public boolean isEstablished ( ) { return mService != null && mEstablished ; }
indashnet/InDashNet.Open.UN2000 | public < R > R runAction ( Action < R > action , R errorResult , String method , boolean reconnect , boolean onlyEstablishedConnection ) { synchronized ( mStartLock ) { try { if ( mService == null ) { Log . w ( TAG , method + " ▁ failed : ▁ not ▁ connected ▁ to ▁ TTS ▁ engine " ) ; return errorResult ; } if ( onlyEstablishedConnection && ! isEstablished ( ) ) { Log . w ( TAG , method + " ▁ failed : ▁ TTS ▁ engine ▁ connection ▁ not ▁ fully ▁ set ▁ up " ) ; return errorResult ; } return action . run ( mService ) ; } catch ( RemoteException ex ) { Log . e ( TAG , method + " ▁ failed " , ex ) ; if ( reconnect ) { disconnect ( ) ; initTts ( ) ; } return errorResult ; } } }
indashnet/InDashNet.Open.UN2000 | @ Override public String toString ( ) { return " EngineInfo { name = " + name + " } " ; }
tamacat/tamacat-httpd | public SubnetUtils ( String cidrNotation ) { calculate ( cidrNotation ) ; }
tamacat/tamacat-httpd | public SubnetUtils ( String address , String mask ) { calculate ( toCidrNotation ( address , mask ) ) ; }
tamacat/tamacat-httpd | public boolean isInclusiveHostCount ( ) { return inclusiveHostCount ; }
tamacat/tamacat-httpd | public void setInclusiveHostCount ( boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; }
tamacat/tamacat-httpd | private SubnetInfo ( ) { }
tamacat/tamacat-httpd | private int netmask ( ) { return netmask ; }
tamacat/tamacat-httpd | private int network ( ) { return network ; }
tamacat/tamacat-httpd | private int address ( ) { return address ; }
tamacat/tamacat-httpd | private int broadcast ( ) { return broadcast ; }
tamacat/tamacat-httpd | private int low ( ) { return ( isInclusiveHostCount ( ) ? network ( ) : broadcast ( ) - network ( ) > 1 ? network ( ) + 1 : 0 ) ; }
tamacat/tamacat-httpd | private int high ( ) { return ( isInclusiveHostCount ( ) ? broadcast ( ) : broadcast ( ) - network ( ) > 1 ? broadcast ( ) - 1 : 0 ) ; }
tamacat/tamacat-httpd | public boolean isInRange ( String address ) { return isInRange ( toInteger ( address ) ) ; }
tamacat/tamacat-httpd | private boolean isInRange ( int address ) { int diff = address - low ( ) ; return ( diff >= 0 && ( diff <= ( high ( ) - low ( ) ) ) ) ; }
tamacat/tamacat-httpd | public String getBroadcastAddress ( ) { return format ( toArray ( broadcast ( ) ) ) ; }
tamacat/tamacat-httpd | public String getNetworkAddress ( ) { return format ( toArray ( network ( ) ) ) ; }
tamacat/tamacat-httpd | public String getNetmask ( ) { return format ( toArray ( netmask ( ) ) ) ; }
tamacat/tamacat-httpd | public String getAddress ( ) { return format ( toArray ( address ( ) ) ) ; }
tamacat/tamacat-httpd | public String getLowAddress ( ) { return format ( toArray ( low ( ) ) ) ; }
tamacat/tamacat-httpd | public String getHighAddress ( ) { return format ( toArray ( high ( ) ) ) ; }
tamacat/tamacat-httpd | public int getAddressCount ( ) { int count = broadcast ( ) - network ( ) + ( isInclusiveHostCount ( ) ? 1 : - 1 ) ; return count < 0 ? 0 : count ; }
tamacat/tamacat-httpd | public int asInteger ( String address ) { return toInteger ( address ) ; }
tamacat/tamacat-httpd | public String getCidrSignature ( ) { return toCidrNotation ( format ( toArray ( address ( ) ) ) , format ( toArray ( netmask ( ) ) ) ) ; }
tamacat/tamacat-httpd | public String [ ] getAllAddresses ( ) { int ct = getAddressCount ( ) ; String [ ] addresses = new String [ ct ] ; if ( ct == 0 ) { return addresses ; } for ( int add = low ( ) , j = 0 ; add <= high ( ) ; ++ add , ++ j ) { addresses [ j ] = format ( toArray ( add ) ) ; } return addresses ; }
tamacat/tamacat-httpd | @ Override public String toString ( ) { final StringBuilder buf = new StringBuilder ( ) ; buf . append ( " CIDR ▁ Signature : \t [ " ) . append ( getCidrSignature ( ) ) . append ( " ] " ) . append ( " ▁ Netmask : ▁ [ " ) . append ( getNetmask ( ) ) . append ( " ] \n " ) . append ( " Network : \t [ " ) . append ( getNetworkAddress ( ) ) . append ( " ] \n " ) . append ( " Broadcast : \t [ " ) . append ( getBroadcastAddress ( ) ) . append ( " ] \n " ) . append ( " First ▁ Address : \t [ " ) . append ( getLowAddress ( ) ) . append ( " ] \n " ) . append ( " Last ▁ Address : \t [ " ) . append ( getHighAddress ( ) ) . append ( " ] \n " ) . append ( " # ▁ Addresses : \t [ " ) . append ( getAddressCount ( ) ) . append ( " ] \n " ) ; return buf . toString ( ) ; }
tamacat/tamacat-httpd | public final SubnetInfo getInfo ( ) { return new SubnetInfo ( ) ; }
tamacat/tamacat-httpd | private void calculate ( String mask ) { Matcher matcher = cidrPattern . matcher ( mask ) ; if ( matcher . matches ( ) ) { address = matchAddress ( matcher ) ; int cidrPart = rangeCheck ( Integer . parseInt ( matcher . group ( 5 ) ) , 0 , NBITS ) ; for ( int j = 0 ; j < cidrPart ; ++ j ) { netmask |= ( 1 << 31 - j ) ; } network = ( address & netmask ) ; broadcast = network | ~ ( netmask ) ; } else { throw new IllegalArgumentException ( " Could ▁ not ▁ parse ▁ [ " + mask + " ] " ) ; } }
tamacat/tamacat-httpd | private int toInteger ( String address ) { Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches ( ) ) { return matchAddress ( matcher ) ; } else { throw new IllegalArgumentException ( " Could ▁ not ▁ parse ▁ [ " + address + " ] " ) ; } }
tamacat/tamacat-httpd | private int matchAddress ( Matcher matcher ) { int addr = 0 ; for ( int i = 1 ; i <= 4 ; ++ i ) { int n = ( rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , - 1 , 255 ) ) ; addr |= ( ( n & 0xff ) << 8 * ( 4 - i ) ) ; } return addr ; }
tamacat/tamacat-httpd | private int [ ] toArray ( int val ) { int ret [ ] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { ret [ j ] |= ( ( val >>> 8 * ( 3 - j ) ) & ( 0xff ) ) ; } return ret ; }
tamacat/tamacat-httpd | private String format ( int [ ] octets ) { StringBuilder str = new StringBuilder ( ) ; for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( " . " ) ; } } return str . toString ( ) ; }
tamacat/tamacat-httpd | private int rangeCheck ( int value , int begin , int end ) { if ( value > begin && value <= end ) { return value ; } throw new IllegalArgumentException ( " Value ▁ [ " + value + " ] ▁ not ▁ in ▁ range ▁ ( " + begin + " , " + end + " ] " ) ; }
tamacat/tamacat-httpd | int pop ( int x ) { x = x - ( ( x >>> 1 ) & 0x55555555 ) ; x = ( x & 0x33333333 ) + ( ( x >>> 2 ) & 0x33333333 ) ; x = ( x + ( x >>> 4 ) ) & 0x0F0F0F0F ; x = x + ( x >>> 8 ) ; x = x + ( x >>> 16 ) ; return x & 0x0000003F ; }
tamacat/tamacat-httpd | private String toCidrNotation ( String addr , String mask ) { return addr + " / " + pop ( toInteger ( mask ) ) ; }
aws/aws-sdk-java | public DescribeAuditStreamConfigurationResult unmarshall ( JsonUnmarshallerContext context ) throws Exception { DescribeAuditStreamConfigurationResult describeAuditStreamConfigurationResult = new DescribeAuditStreamConfigurationResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; String currentParentElement = context . getCurrentParentElement ( ) ; int targetDepth = originalDepth + 1 ; JsonToken token = context . getCurrentToken ( ) ; if ( token == null ) token = context . nextToken ( ) ; if ( token == VALUE_NULL ) { return describeAuditStreamConfigurationResult ; } while ( true ) { if ( token == null ) break ; if ( token == FIELD_NAME || token == START_OBJECT ) { if ( context . testExpression ( " AuditStreamArn " , targetDepth ) ) { context . nextToken ( ) ; describeAuditStreamConfigurationResult . setAuditStreamArn ( context . getUnmarshaller ( String . class ) . unmarshall ( context ) ) ; } } else if ( token == END_ARRAY || token == END_OBJECT ) { if ( context . getLastParsedParentElement ( ) == null || context . getLastParsedParentElement ( ) . equals ( currentParentElement ) ) { if ( context . getCurrentDepth ( ) <= originalDepth ) break ; } } token = context . nextToken ( ) ; } return describeAuditStreamConfigurationResult ; }
darranl/directory-server | public AddETypeInfo2Entry ( ) { super ( " Add ▁ an ▁ ETypeInfo2Entry ▁ instance " ) ; }
darranl/directory-server | public void action ( ETypeInfo2Container eTypeInfo2Container ) throws DecoderException { TLV tlv = eTypeInfo2Container . getCurrentTLV ( ) ; if ( tlv . getLength ( ) == 0 ) { LOG . error ( I18n . err ( I18n . ERR_04066 ) ) ; throw new DecoderException ( I18n . err ( I18n . ERR_04067 ) ) ; } Asn1Decoder etypeInfo2EntryDecoder = new Asn1Decoder ( ) ; ETypeInfo2EntryContainer etypeInfo2EntryContainer = new ETypeInfo2EntryContainer ( ) ; etypeInfo2EntryContainer . setStream ( eTypeInfo2Container . getStream ( ) ) ; eTypeInfo2Container . rewind ( ) ; try { etypeInfo2EntryDecoder . decode ( eTypeInfo2Container . getStream ( ) , etypeInfo2EntryContainer ) ; } catch ( DecoderException de ) { throw de ; } tlv . setExpectedLength ( tlv . getExpectedLength ( ) - tlv . getLength ( ) ) ; eTypeInfo2Container . updateParent ( ) ; ETypeInfo2Entry etypeInfo2Entry = etypeInfo2EntryContainer . getETypeInfo2Entry ( ) ; eTypeInfo2Container . addEtypeInfo2Entry ( etypeInfo2Entry ) ; if ( IS_DEBUG ) { LOG . debug ( " ETYPE - INFO2 - ENTRY ▁ added ▁ : ▁ { } " , etypeInfo2Entry ) ; } eTypeInfo2Container . setGrammarEndAllowed ( true ) ; }
vam-google/google-cloud-java | @ Before public void setUp ( ) { rpcFactoryMock = EasyMock . createMock ( TranslateRpcFactory . class ) ; translateRpcMock = EasyMock . createMock ( TranslateRpc . class ) ; EasyMock . expect ( rpcFactoryMock . create ( EasyMock . anyObject ( TranslateOptions . class ) ) ) . andReturn ( translateRpcMock ) ; EasyMock . replay ( rpcFactoryMock ) ; options = TranslateOptions . newBuilder ( ) . setApiKey ( API_KEY ) . setServiceRpcFactory ( rpcFactoryMock ) . setRetrySettings ( NO_RETRY_SETTINGS ) . build ( ) ; }
vam-google/google-cloud-java | private void verify ( ) { EasyMock . verify ( rpcFactoryMock , translateRpcMock ) ; }
vam-google/google-cloud-java | private void initializeService ( ) { translate = options . getService ( ) ; }
vam-google/google-cloud-java | @ Test public void testGetOptions ( ) { EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertSame ( options , translate . getOptions ( ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testListSupportedLanguages ( ) { EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andReturn ( ImmutableList . of ( LANGUAGE1_PB , LANGUAGE2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( LANGUAGES1 , translate . listSupportedLanguages ( ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testListSupportedLanguagesWithOptions ( ) { EasyMock . expect ( translateRpcMock . listSupportedLanguages ( LANGUAGE_LIST_OPTIONS ) ) . andReturn ( ImmutableList . of ( LANGUAGE3_PB , LANGUAGE4_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( LANGUAGES2 , translate . listSupportedLanguages ( LanguageListOption . targetLanguage ( TARGET_LANGUAGE ) ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetect ( ) { String text = " text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( DETECTION1 , translate . detect ( text ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectMultipleDetections ( ) { String text = " text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB , DETECTION2_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " Multiple ▁ detections ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( text ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectNoDetection ( ) { String text = " text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . < DetectionsResourceItems > of ( ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " No ▁ detection ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( text ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectList ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . detect ( texts ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . of ( DETECTION2_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( DETECTION1 , DETECTION2 ) , translate . detect ( texts ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectListMultipleDetections ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . detect ( texts ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB , DETECTION2_PB ) , ImmutableList . of ( DETECTION1_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " Multiple ▁ detections ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( texts ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectListNoDetection ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . detect ( texts ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . < DetectionsResourceItems > of ( ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " No ▁ detection ▁ found ▁ for ▁ text : ▁ other ▁ text " ) ; translate . detect ( texts ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectVararg ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text1 , text2 ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . of ( DETECTION2_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( DETECTION1 , DETECTION2 ) , translate . detect ( text1 , text2 ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectVarargMultipleDetections ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text1 , text2 ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB , DETECTION2_PB ) , ImmutableList . of ( DETECTION1_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " Multiple ▁ detections ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( text1 , text2 ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectVarargNoDetection ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text1 , text2 ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . < DetectionsResourceItems > of ( ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " No ▁ detection ▁ found ▁ for ▁ text : ▁ other ▁ text " ) ; translate . detect ( text1 , text2 ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslate ( ) { String text = " ¡ Hola ▁ Mundo ! " ; EasyMock . expect ( translateRpcMock . translate ( ImmutableList . of ( text ) , EMPTY_RPC_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION1_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( TRANSLATION1 , translate . translate ( text ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslateWithOptions ( ) { String text = " Hallo ▁ Welt ! " ; EasyMock . expect ( translateRpcMock . translate ( ImmutableList . of ( text ) , TRANSLATE_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( TRANSLATION2 , translate . translate ( text , TARGET_LANGUAGE_OPTION , SOURCE_LANGUAGE_OPTION , MODEL_OPTION , FORMAT_OPTION ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslateList ( ) { String text1 = " ¡ Hola ▁ Mundo ! " ; String text2 = " Hallo ▁ Welt ! " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . translate ( texts , EMPTY_RPC_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION1_PB , TRANSLATION2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( TRANSLATION1 , TRANSLATION2 ) , translate . translate ( texts ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslateListWithOptions ( ) { String text = " Hallo ▁ Welt ! " ; List < String > texts = ImmutableList . of ( text ) ; EasyMock . expect ( translateRpcMock . translate ( texts , TRANSLATE_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( TRANSLATION2 ) , translate . translate ( texts , TARGET_LANGUAGE_OPTION , SOURCE_LANGUAGE_OPTION , MODEL_OPTION , FORMAT_OPTION ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testRetryableException ( ) { EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andThrow ( new TranslateException ( 500 , " internalError " ) ) . andReturn ( ImmutableList . of ( LANGUAGE1_PB , LANGUAGE2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; translate = options . toBuilder ( ) . setRetrySettings ( ServiceOptions . getDefaultRetrySettings ( ) ) . build ( ) . getService ( ) ; assertEquals ( LANGUAGES1 , translate . listSupportedLanguages ( ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testNonRetryableException ( ) { String exceptionMessage = " Not ▁ Implemented " ; EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andThrow ( new TranslateException ( 501 , exceptionMessage ) ) ; EasyMock . replay ( translateRpcMock ) ; translate = options . toBuilder ( ) . setRetrySettings ( ServiceOptions . getDefaultRetrySettings ( ) ) . build ( ) . getService ( ) ; thrown . expect ( TranslateException . class ) ; thrown . expectMessage ( exceptionMessage ) ; translate . listSupportedLanguages ( ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testRuntimeException ( ) { String exceptionMessage = " Artificial ▁ runtime ▁ exception " ; EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andThrow ( new RuntimeException ( exceptionMessage ) ) ; EasyMock . replay ( translateRpcMock ) ; translate = options . toBuilder ( ) . setRetrySettings ( ServiceOptions . getDefaultRetrySettings ( ) ) . build ( ) . getService ( ) ; thrown . expect ( TranslateException . class ) ; thrown . expectMessage ( exceptionMessage ) ; translate . listSupportedLanguages ( ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testCredentialsOverridesApiKey ( ) { Credentials credentials = NoCredentials . getInstance ( ) ; TranslateOptions overridden = options . toBuilder ( ) . setCredentials ( credentials ) . build ( ) ; assertSame ( overridden . getCredentials ( ) , credentials ) ; assertNull ( overridden . getApiKey ( ) ) ; }
tfisher1226/ARIES | public void setUp ( ) throws Exception { isRequestExpected = true ; isAbortExpected = false ; }
tfisher1226/ARIES | public void tearDown ( ) throws Exception { expectedExceptionMessage = null ; expectedExceptionClass = null ; expectedExceptionCause = null ; }
tfisher1226/ARIES | protected void setupForExpectedAssertionFailure ( String exceptionMessage ) throws Exception { addExpectedException ( AssertionFailure . class , null , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedAssertionFailure ( Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { addExpectedException ( AssertionFailure . class , exceptionCause , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedIllegalArgument ( String exceptionMessage ) throws Exception { addExpectedException ( IllegalArgumentException . class , null , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedIllegalArgument ( Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { addExpectedException ( IllegalArgumentException . class , exceptionCause , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedException ( Class < ? extends Throwable > exceptionClass , String exceptionMessage ) throws Exception { addExpectedException ( exceptionClass , null , exceptionMessage ) ; }
tfisher1226/ARIES | protected void addExpectedNullPointerException ( ) throws Exception { expectedException = new NullPointerException ( null ) ; expectedExceptionClass = NullPointerException . class ; expectedExceptionMessage = null ; }
tfisher1226/ARIES | protected void addExpectedServiceAbortedException ( String exceptionMessage ) throws Exception { expectedException = new AssertionFailure ( exceptionMessage ) ; expectedExceptionClass = AssertionFailure . class ; expectedExceptionMessage = exceptionMessage ; }
tfisher1226/ARIES | protected void addExpectedServiceAbortedException ( Class < ? > exceptionClass , String exceptionMessage ) throws Exception { expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage ) ; expectedExceptionClass = exceptionClass ; expectedExceptionMessage = exceptionMessage ; }
tfisher1226/ARIES | protected void addExpectedException ( Class < ? extends Throwable > exceptionClass , Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { if ( exceptionCause != null ) { Throwable instanceofCause = createException ( exceptionCause , " message " ) ; expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage , instanceofCause ) ; } else expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage ) ; expectedExceptionClass = exceptionClass ; expectedExceptionCause = exceptionCause ; expectedExceptionMessage = exceptionMessage ; }
tfisher1226/ARIES | protected < T > T createException ( Class < T > classObject , Object exceptionMessage ) throws Exception { return createException ( classObject , exceptionMessage , null ) ; }
tfisher1226/ARIES | protected < T > T createException ( Class < T > classObject , Object exceptionMessage , Throwable exceptionCause ) throws Exception { Class < ? > [ ] parameterTypes = new Class < ? > [ 2 ] ; parameterTypes [ 0 ] = String . class ; parameterTypes [ 1 ] = Throwable . class ; Constructor < ? > constructor = classObject . getConstructor ( parameterTypes ) ; Assert . notNull ( constructor , " Constructor ▁ not ▁ found ▁ for : ▁ " + classObject . getName ( ) ) ; @ SuppressWarnings ( " unchecked " ) T instance = ( T ) constructor . newInstance ( exceptionMessage , exceptionCause ) ; return instance ; }
tfisher1226/ARIES | protected void validateAfterException ( Throwable e ) { validateExceptionType ( e ) ; }
tfisher1226/ARIES | protected void validateExceptionType ( Throwable e ) { Assert . equals ( e . getClass ( ) , expectedExceptionClass ) ; Throwable exception = getExceptionForThrowable ( e ) ; if ( exception == null ) exception = e ; if ( expectedExceptionMessage != null ) { Assert . notNull ( exception . getMessage ( ) , " Exception ▁ message ▁ null , ▁ expecting : ▁ " + expectedExceptionMessage ) ; Assert . startsWith ( exception . getMessage ( ) , expectedExceptionMessage ) ; } if ( expectedExceptionCause != null ) { Assert . notNull ( exception . getCause ( ) , " Exception ▁ cause ▁ null , ▁ expecting : ▁ " + expectedExceptionCause . getName ( ) ) ; Assert . equals ( exception . getCause ( ) . getClass ( ) , expectedExceptionCause ) ; } }
tfisher1226/ARIES | protected Throwable getExceptionForThrowable ( Throwable e ) { if ( e instanceof RuntimeException == false ) return e ; Throwable cause = e . getCause ( ) ; if ( cause instanceof Error ) return cause ; if ( cause instanceof RuntimeException ) return getExceptionForThrowable ( cause ) ; return cause ; }
Whitewolfza/cipango | public Tel ( String token ) { if ( ! token . equals ( " uri " ) ) throw new IllegalArgumentException ( " Invalid ▁ expression : ▁ tel ▁ after ▁ " + token ) ; }
Whitewolfza/cipango | public Object extract ( Object input ) { URI uri = ( URI ) input ; if ( uri . isSipURI ( ) ) { SipURI sipuri = ( SipURI ) uri ; if ( " phone " . equals ( sipuri . getParameter ( " user " ) ) ) return stripVisuals ( sipuri . getUser ( ) ) ; } else if ( " tel " . equals ( uri . getScheme ( ) ) ) { return stripVisuals ( ( ( TelURL ) uri ) . getPhoneNumber ( ) ) ; } return null ; }
Whitewolfza/cipango | private String stripVisuals ( String s ) { StringBuffer buf = new StringBuffer ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( " - . ( ) " . indexOf ( c ) < 0 ) buf . append ( c ) ; } return buf . toString ( ) ; }
danielcavanagh/peeler | public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; list = Song . allSongs ( this ) ; setListAdapter ( new ArrayAdapter < Song > ( this , R . layout . list_item , list ) ) ; getListView ( ) . setTextFilterEnabled ( true ) ; }
danielcavanagh/peeler | protected void onListItemClick ( ListView l , View v , int position , long id ) { ( ( Peeler ) getParent ( ) ) . setSongList ( list , position ) ; ( ( Peeler ) getParent ( ) ) . switchToCurrentTab ( ) ; }
ReactiveX/RxJava | public CompletableTimer ( long delay , TimeUnit unit , Scheduler scheduler ) { this . delay = delay ; this . unit = unit ; this . scheduler = scheduler ; }
ReactiveX/RxJava | @ Override protected void subscribeActual ( final CompletableObserver observer ) { TimerDisposable parent = new TimerDisposable ( observer ) ; observer . onSubscribe ( parent ) ; parent . setFuture ( scheduler . scheduleDirect ( parent , delay , unit ) ) ; }
ReactiveX/RxJava | TimerDisposable ( final CompletableObserver downstream ) { this . downstream = downstream ; }
ReactiveX/RxJava | @ Override public void run ( ) { downstream . onComplete ( ) ; }
ReactiveX/RxJava | @ Override public void dispose ( ) { DisposableHelper . dispose ( this ) ; }
ReactiveX/RxJava | @ Override public boolean isDisposed ( ) { return DisposableHelper . isDisposed ( get ( ) ) ; }
ReactiveX/RxJava | void setFuture ( Disposable d ) { DisposableHelper . replace ( this , d ) ; }
india-rose/old-indiarose | public TakePhoto ( ScreenManager _screen ) { super ( _screen ) ; m_callback = new PhotoHandler ( ) ; previewSurface = new SurfaceView ( AppData . currentContext ) ; ButtonItem takeButton = new ButtonItem ( AppData . currentContext , TAKE ) ; ButtonItem cancelButton = new ButtonItem ( AppData . currentContext , CANCEL ) ; takeButton . setTextSize ( ScreenManager . fontSize ) ; cancelButton . setTextSize ( ScreenManager . fontSize ) ; takeButton . setTextColor ( Color . BLACK ) ; cancelButton . setTextColor ( Color . BLACK ) ; takeButton . setText ( R . string . takeImage ) ; cancelButton . setText ( R . string . cancelText ) ; try { Mapper . connect ( m_callback , " pictureTaken " , this , " savePhoto " ) ; Mapper . connect ( takeButton , " clicked " , this , " buttonEvent " ) ; Mapper . connect ( cancelButton , " clicked " , this , " buttonEvent " ) ; } catch ( MapperException e ) { Log . wtf ( " TakePhoto " , " unable ▁ to ▁ connect ▁ photo " , e ) ; } m_layout = new LinearLayout ( AppData . currentContext ) ; m_layout . setOrientation ( LinearLayout . VERTICAL ) ; LinearLayout buttonLayout = new LinearLayout ( AppData . currentContext ) ; buttonLayout . setOrientation ( LinearLayout . HORIZONTAL ) ; buttonLayout . addView ( cancelButton ) ; buttonLayout . addView ( takeButton ) ; m_layout . setGravity ( Gravity . CENTER ) ; m_layout . addView ( previewSurface , new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; m_layout . addView ( buttonLayout , new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; previewHolder = previewSurface . getHolder ( ) ; previewHolder . addCallback ( surfaceCallback ) ; previewHolder . setType ( SurfaceHolder . SURFACE_TYPE_PUSH_BUFFERS ) ; ViewGroup . LayoutParams p = previewSurface . getLayoutParams ( ) ; int h = 300 ; int w = ( int ) ( 300.0 * this . m_screen . getWidth ( ) / this . m_screen . getHeight ( ) ) ; p . height = h ; p . width = w ; previewSurface . setLayoutParams ( p ) ; }
india-rose/old-indiarose | SurfaceHolder . Callback surfaceCallback = new SurfaceHolder . Callback ( ) { public void surfaceCreated ( SurfaceHolder holder ) { } public void surfaceChanged ( SurfaceHolder holder , int format , int width , int height ) { initPreview ( width , height ) ; startPreview ( ) ; } public void surfaceDestroyed ( SurfaceHolder holder ) { } }
india-rose/old-indiarose | private void initPreview ( int w , int h ) { if ( m_camera != null && previewHolder . getSurface ( ) != null ) { try { m_camera . setPreviewDisplay ( previewHolder ) ; } catch ( Throwable t ) { Log . e ( " PreviewDemo - surfaceCallback " , " Exception ▁ in ▁ setPreviewDisplay ( ) " , t ) ; Toast . makeText ( AppData . currentContext , t . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; } if ( ! cameraConfigured ) { Camera . Parameters parameters = m_camera . getParameters ( ) ; parameters . setPreviewSize ( w , h ) ; parameters . setPictureSize ( w , h ) ; m_camera . setParameters ( parameters ) ; cameraConfigured = true ; } } }
india-rose/old-indiarose | private void startPreview ( ) { if ( cameraConfigured && m_camera != null ) { m_camera . startPreview ( ) ; inPreview = true ; } }
india-rose/old-indiarose | public void savePhoto ( String _filename ) { m_camera . stopPreview ( ) ; try { Mapper . emit ( this , " photoTaken " , _filename ) ; } catch ( MapperException e ) { Log . wtf ( " TakePhoto " , " unable ▁ to ▁ emit ▁ photo ▁ saving " , e ) ; } this . m_screen . pop ( ) ; }
india-rose/old-indiarose | public void onPop ( ) { if ( m_camera != null ) { m_camera . release ( ) ; m_camera = null ; } }
india-rose/old-indiarose | public void onPush ( ) { m_camera = Camera . open ( ) ; }
india-rose/old-indiarose | @ Override public View getView ( ) { return m_layout ; }
india-rose/old-indiarose | public synchronized void buttonEvent ( ButtonItem _button ) { if ( ! m_takingPhoto ) { String id = _button . getIdentifier ( ) ; if ( id . equals ( CANCEL ) ) { this . m_screen . pop ( ) ; } else if ( id . equals ( TAKE ) ) { m_takingPhoto = true ; this . m_camera . takePicture ( null , null , this . m_callback ) ; } } }
FreeSunny/TvSample | public ApplicationTest ( ) { super ( Application . class ) ; }
quiteflame/BADOM | public ThrowAtScreen ( Creature player , int sx , int sy , Item item ) { super ( player , " Throw ▁ " + player . nameOf ( item ) + " ▁ at ? " , sx , sy ) ; this . item = item ; }
quiteflame/BADOM | public boolean isAcceptable ( int x , int y ) { if ( ! player . canSee ( x , y , player . z ) ) return false ; for ( Point p : new Line ( player . x , player . y , x , y ) ) { if ( ! player . realTile ( p . x , p . y , player . z ) . isGround ( ) ) return false ; } return true ; }
quiteflame/BADOM | public void selectWorldCoordinate ( int x , int y , int screenX , int screenY ) { player . throwItem ( item , x , y , player . z ) ; }
P0ke55/specbot | public TcpPacketSizer ( Session session ) { this . session = session ; }
P0ke55/specbot | @ Override public void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { int length = in . readableBytes ( ) ; out . ensureWritable ( this . session . getPacketProtocol ( ) . getPacketHeader ( ) . getLengthSize ( length ) + length ) ; this . session . getPacketProtocol ( ) . getPacketHeader ( ) . writeLength ( new ByteBufNetOutput ( out ) , length ) ; out . writeBytes ( in ) ; }
P0ke55/specbot | @ Override protected void decode ( ChannelHandlerContext ctx , ByteBuf buf , List < Object > out ) throws Exception { int size = this . session . getPacketProtocol ( ) . getPacketHeader ( ) . getLengthSize ( ) ; if ( size > 0 ) { buf . markReaderIndex ( ) ; byte [ ] lengthBytes = new byte [ size ] ; for ( int index = 0 ; index < lengthBytes . length ; index ++ ) { if ( ! buf . isReadable ( ) ) { buf . resetReaderIndex ( ) ; return ; } lengthBytes [ index ] = buf . readByte ( ) ; if ( ( this . session . getPacketProtocol ( ) . getPacketHeader ( ) . isLengthVariable ( ) && lengthBytes [ index ] >= 0 ) || index == size - 1 ) { int length = this . session . getPacketProtocol ( ) . getPacketHeader ( ) . readLength ( new ByteBufNetInput ( Unpooled . wrappedBuffer ( lengthBytes ) ) , buf . readableBytes ( ) ) ; if ( buf . readableBytes ( ) < length ) { buf . resetReaderIndex ( ) ; return ; } out . add ( buf . readBytes ( length ) ) ; return ; } } throw new CorruptedFrameException ( " Length ▁ is ▁ too ▁ long . " ) ; } else { out . add ( buf . readBytes ( buf . readableBytes ( ) ) ) ; } }
lordofthejars/arquillian-cube | public void install ( @ Observes ( precedence = 100 ) Configuration configuration ) { namespaceService . set ( serviceLoader . get ( ) . onlyOne ( NamespaceService . class , OpenshiftNamespaceService . class ) ) ; }
teffy/okhttp | private FormBody ( List < String > encodedNames , List < String > encodedValues ) { this . encodedNames = Util . immutableList ( encodedNames ) ; this . encodedValues = Util . immutableList ( encodedValues ) ; }
teffy/okhttp | public int size ( ) { return encodedNames . size ( ) ; }
teffy/okhttp | public String encodedName ( int index ) { return encodedNames . get ( index ) ; }
teffy/okhttp | public String name ( int index ) { return percentDecode ( encodedName ( index ) , true ) ; }
teffy/okhttp | public String encodedValue ( int index ) { return encodedValues . get ( index ) ; }
teffy/okhttp | public String value ( int index ) { return percentDecode ( encodedValue ( index ) , true ) ; }
teffy/okhttp | @ Override public MediaType contentType ( ) { return CONTENT_TYPE ; }
teffy/okhttp | @ Override public long contentLength ( ) { return writeOrCountBytes ( null , true ) ; }
teffy/okhttp | @ Override public void writeTo ( BufferedSink sink ) throws IOException { writeOrCountBytes ( sink , false ) ; }
teffy/okhttp | private long writeOrCountBytes ( BufferedSink sink , boolean countBytes ) { long byteCount = 0L ; Buffer buffer ; if ( countBytes ) { buffer = new Buffer ( ) ; } else { buffer = sink . buffer ( ) ; } for ( int i = 0 , size = encodedNames . size ( ) ; i < size ; i ++ ) { if ( i > 0 ) buffer . writeByte ( ' & ' ) ; buffer . writeUtf8 ( encodedNames . get ( i ) ) ; buffer . writeByte ( ' = ' ) ; buffer . writeUtf8 ( encodedValues . get ( i ) ) ; } if ( countBytes ) { byteCount = buffer . size ( ) ; buffer . clear ( ) ; } return byteCount ; }
teffy/okhttp | public Builder add ( String name , String value ) { names . add ( HttpUrl . canonicalize ( name , FORM_ENCODE_SET , false , true , true ) ) ; values . add ( HttpUrl . canonicalize ( value , FORM_ENCODE_SET , false , true , true ) ) ; return this ; }
teffy/okhttp | public Builder addEncoded ( String name , String value ) { names . add ( HttpUrl . canonicalize ( name , FORM_ENCODE_SET , true , true , true ) ) ; values . add ( HttpUrl . canonicalize ( value , FORM_ENCODE_SET , true , true , true ) ) ; return this ; }
teffy/okhttp | public FormBody build ( ) { return new FormBody ( names , values ) ; }
l1fan/GameAne | public void init ( ) throws JSONException { JSONObject jd = getJsonData ( ) ; Bundle md = getMetaData ( ) ; mAppId = jd . optString ( APPID , md . getString ( APPID , " " ) ) . replace ( " coolpad . " , " " ) ; mAppKey = jd . optString ( APPKEY , md . getString ( APPKEY ) ) ; mPrivateKey = jd . optString ( " privateKey " , md . getString ( " privateKey " ) ) ; mPublicKey = jd . optString ( " publicKey " , md . getString ( " publicKey " ) ) ; int ori = jd . optInt ( ORIENTATION , md . getInt ( ORIENTATION , 1 ) ) ; Activity act = getActivity ( ) ; CoolPadPay . init ( act , ori , mAppId ) ; dispatchData ( EVENT_INIT ) ; }
l1fan/GameAne | public void userLogin ( ) { mCool = Coolcloud . createInstance ( getActivity ( ) , mAppId , mAppKey ) ; mCool . login ( getActivity ( ) , " / user / getuserinfo " , new OnAuthListener ( ) { @ Override public void onError ( ErrInfo err ) { dispatchError ( EVENT_LOGIN , err . getError ( ) + err . getMessage ( ) ) ; } @ Override public void onDone ( Object arg ) { System . out . println ( arg . toString ( ) ) ; Bundle result = ( Bundle ) arg ; JSONObject data = new JSONObject ( ) ; mToken = result . getString ( Params . ACCESS_TOKEN ) ; mOpenId = result . getString ( Params . OPEN_ID ) ; try { data . put ( UID , mOpenId ) ; data . put ( TOKEN , mToken ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } dispatchData ( EVENT_LOGIN , data ) ; } @ Override public void onCancel ( ) { dispatchError ( EVENT_LOGIN , CODE_ERR_CANCEL , " login ▁ cancel " ) ; } } ) ; }
l1fan/GameAne | public void userLogout ( ) { mCool . logout ( getActivity ( ) , new OnAuthListener ( ) { @ Override public void onError ( ErrInfo err ) { dispatchError ( EVENT_LOGOUT , " logout ▁ fail : " + err . getError ( ) + err . getMessage ( ) ) ; } @ Override public void onDone ( Object arg0 ) { dispatchData ( EVENT_LOGOUT ) ; } @ Override public void onCancel ( ) { dispatchError ( EVENT_LOGOUT , CODE_ERR_CANCEL , " logout ▁ cancel " ) ; } } ) ; }
l1fan/GameAne | public void pay ( ) throws JSONException { JSONObject pay = getJsonData ( ) ; AccountBean account = CoolPadPay . buildAccount ( getActivity ( ) , mToken , mAppId , mOpenId ) ; String genUrl ; if ( pay . has ( " transid " ) || pay . has ( " transId " ) ) { genUrl = " transid = " + pay . optString ( " transid " , pay . optString ( " transId " ) ) + " & appid = " + mAppId ; } else { String uid = pay . optString ( UID ) ; String priKey = pay . optString ( " privateKey " , mPrivateKey ) ; genUrl = genUrl ( mAppId , uid , pay . optString ( EXT ) , priKey , pay . optInt ( PID ) , pay . optInt ( AMOUNT ) / 100.00 , pay . optString ( ORDER_ID ) , pay . optString ( NOTIFY_URL ) ) ; } CoolPadPay . startPay ( getActivity ( ) , genUrl , account , new IPayResultCallback ( ) { @ SuppressWarnings ( " deprecation " ) @ Override public void onPayResult ( int resultCode , String signValue , String resultInfo ) { switch ( resultCode ) { case CoolPadPay . PAY_SUCCESS : if ( TextUtils . isEmpty ( signValue ) ) { dispatchError ( EVENT_PAY , " pay ▁ fail : ▁ sign ▁ value ▁ is ▁ null " ) ; } else { int transdataLast = signValue . indexOf ( " & sign = " ) ; String transdata = URLDecoder . decode ( signValue . substring ( " transdata = " . length ( ) , transdataLast ) ) ; int signLast = signValue . indexOf ( " & signtype = " ) ; String sign = URLDecoder . decode ( signValue . substring ( transdataLast + " & sign = " . length ( ) , signLast ) ) ; String signtype = signValue . substring ( signLast + " & signtype = " . length ( ) ) ; boolean isSign = false ; try { isSign = RSAHelper . verify ( transdata , mPublicKey , sign ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( signtype . equals ( " RSA " ) && isSign ) { dispatchData ( EVENT_PAY ) ; } else { dispatchError ( EVENT_PAY , " pay ▁ fail : ▁ verify ▁ sign ▁ error " ) ; } } break ; default : dispatchError ( EVENT_PAY , " pay ▁ fail : " + resultCode + " : " + resultInfo ) ; break ; } } } ) ; }
l1fan/GameAne | private String genUrl ( String appid , String appuserid , String cpprivateinfo , String appPrivateKey , int waresid , double price , String cporderid , String url ) { String json = " " ; JSONObject obj = new JSONObject ( ) ; try { obj . put ( " appid " , appid ) ; obj . put ( " waresid " , waresid ) ; obj . put ( " cporderid " , cporderid ) ; obj . put ( " price " , price ) ; obj . put ( " appuserid " , appuserid ) ; String cpprivateinfo0 = cpprivateinfo ; if ( ! TextUtils . isEmpty ( cpprivateinfo0 ) ) { obj . put ( " cpprivateinfo " , cpprivateinfo0 ) ; } String notifyurl0 = url ; if ( ! TextUtils . isEmpty ( notifyurl0 ) ) { obj . put ( " notifyurl " , notifyurl0 ) ; } json = obj . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } String sign = " " ; try { sign = RSAHelper . signForPKCS1 ( json , appPrivateKey ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return " transdata = " + URLEncoder . encode ( json ) + " & sign = " + URLEncoder . encode ( sign ) + " & signtype = " + " RSA " ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository ) { this ( repository , new ImportRules ( ) , new ArrayList < String > ( ) ) ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository , LogChannelInterface log ) { this ( repository , new ImportRules ( ) , Collections . < String > emptyList ( ) , log ) ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository , ImportRules importRules , List < String > limitDirs ) { this ( repository , importRules , limitDirs , new LogChannel ( " Repository ▁ import " ) ) ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository , ImportRules importRules , List < String > limitDirs , LogChannelInterface log ) { this . log = log ; this . rep = repository ; this . importRules = importRules ; this . limitDirs = limitDirs ; this . exceptions = new ArrayList < Exception > ( ) ; }
mattyb149/pentaho-kettle | private boolean isRemembered ( String rememberPropertyName ) { return ! " Y " . equalsIgnoreCase ( Props . getInstance ( ) . getProperty ( rememberPropertyName ) ) ; }
mattyb149/pentaho-kettle | private boolean getPromptResult ( String message , String rememberText , String rememberPropertyName ) { boolean result = false ; if ( ! askReplace ) { result = overwritePrompter . overwritePrompt ( message , rememberText , rememberPropertyName ) ; return result ; } if ( isRemembered ( rememberPropertyName ) ) { result = rememberPropertyNamesToOverwrite . contains ( rememberPropertyName ) ; return result ; } result = overwritePrompter . overwritePrompt ( message , rememberText , rememberPropertyName ) ; if ( result ) { rememberPropertyNamesToOverwrite . add ( rememberPropertyName ) ; } else { rememberPropertyNamesToOverwrite . remove ( rememberPropertyName ) ; } return result ; }
mattyb149/pentaho-kettle | @ Override public synchronized void importAll ( RepositoryImportFeedbackInterface feedback , String fileDirectory , String [ ] filenames , RepositoryDirectoryInterface baseDirectory , boolean overwrite , boolean continueOnError , String versionComment ) { this . baseDirectory = baseDirectory ; this . overwrite = overwrite ; this . continueOnError = continueOnError ; this . versionComment = versionComment ; String importPathCompatibility = System . getProperty ( Const . KETTLE_COMPATIBILITY_IMPORT_PATH_ADDITION_ON_VARIABLES , " N " ) ; this . needToCheckPathForVariables = " N " . equalsIgnoreCase ( importPathCompatibility ) ; askReplace = Props . getInstance ( ) . askAboutReplacingDatabaseConnections ( ) ; if ( askReplace ) { if ( feedback instanceof HasOverwritePrompter ) { Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_CS , " Y " ) ; Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_DB , " Y " ) ; Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_PS , " Y " ) ; Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_SS , " Y " ) ; this . overwritePrompter = ( ( HasOverwritePrompter ) feedback ) . getOverwritePrompter ( ) ; } else { this . overwritePrompter = new OverwritePrompter ( ) { @ Override public boolean overwritePrompt ( String arg0 , String arg1 , String arg2 ) { throw new RuntimeException ( BaseMessages . getString ( PKG , " RepositoryImporter . CannotPrompt . Label " ) ) ; } } ; } } else { final boolean replaceExisting = Props . getInstance ( ) . replaceExistingDatabaseConnections ( ) ; this . overwritePrompter = new OverwritePrompter ( ) { @ Override public boolean overwritePrompt ( String arg0 , String arg1 , String arg2 ) { return replaceExisting ; } } ; } referencingObjects = new ArrayList < RepositoryObject > ( ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportXML . Label " ) ) ; try { loadSharedObjects ( ) ; RepositoryImportLocation . setRepositoryImportLocation ( baseDirectory ) ; for ( int ii = 0 ; ii < filenames . length ; ++ ii ) { final String filename = ( ! Const . isEmpty ( fileDirectory ) ) ? fileDirectory + Const . FILE_SEPARATOR + filenames [ ii ] : filenames [ ii ] ; if ( log . isBasic ( ) ) { log . logBasic ( " Import ▁ objects ▁ from ▁ XML ▁ file ▁ [ " + filename + " ] " ) ; } feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . WhichFile . Log " , filename ) ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . WhichDir . Label " ) ) ; try { RepositoryExportSaxParser parser = new RepositoryExportSaxParser ( filename , feedback ) ; parser . parse ( this ) ; } catch ( Exception e ) { addException ( e ) ; feedback . showError ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Message " ) , e ) ; } } for ( RepositoryObject repoObject : referencingObjects ) { switch ( repoObject . getObjectType ( ) ) { case TRANSFORMATION : TransMeta transMeta = rep . loadTransformation ( repoObject . getObjectId ( ) , null ) ; saveTransformationToRepo ( transMeta , feedback ) ; break ; case JOB : JobMeta jobMeta = rep . loadJob ( repoObject . getObjectId ( ) , null ) ; saveJobToRepo ( jobMeta , feedback ) ; break ; default : throw new KettleException ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorDetectFileType " ) ) ; } } feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportFinished . Log " ) ) ; } catch ( Exception e ) { addException ( e ) ; feedback . showError ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Message " ) , e ) ; } finally { RepositoryImportLocation . setRepositoryImportLocation ( null ) ; } }
mattyb149/pentaho-kettle | protected void loadSharedObjects ( ) throws KettleException { sharedObjects = new SharedObjects ( ) ; for ( ObjectId id : rep . getDatabaseIDs ( false ) ) { DatabaseMeta databaseMeta = rep . loadDatabaseMeta ( id , null ) ; validateImportedElement ( importRules , databaseMeta ) ; sharedObjects . storeObject ( databaseMeta ) ; } ObjectId [ ] slaveIDs = rep . getSlaveIDs ( false ) ; List < SlaveServer > slaveServers = new ArrayList < SlaveServer > ( slaveIDs . length ) ; for ( ObjectId id : slaveIDs ) { SlaveServer slaveServer = rep . loadSlaveServer ( id , null ) ; validateImportedElement ( importRules , slaveServer ) ; sharedObjects . storeObject ( slaveServer ) ; slaveServers . add ( slaveServer ) ; } for ( ObjectId id : rep . getClusterIDs ( false ) ) { ClusterSchema clusterSchema = rep . loadClusterSchema ( id , slaveServers , null ) ; validateImportedElement ( importRules , clusterSchema ) ; sharedObjects . storeObject ( clusterSchema ) ; } for ( ObjectId id : rep . getPartitionSchemaIDs ( false ) ) { PartitionSchema partitionSchema = rep . loadPartitionSchema ( id , null ) ; validateImportedElement ( importRules , partitionSchema ) ; sharedObjects . storeObject ( partitionSchema ) ; } }
mattyb149/pentaho-kettle | @ Override public void addLog ( String line ) { log . logBasic ( line ) ; }
mattyb149/pentaho-kettle | @ Override public void setLabel ( String labelText ) { log . logBasic ( labelText ) ; }
mattyb149/pentaho-kettle | @ Override public boolean transOverwritePrompt ( TransMeta transMeta ) { return overwrite ; }
mattyb149/pentaho-kettle | @ Override public boolean jobOverwritePrompt ( JobMeta jobMeta ) { return overwrite ; }
mattyb149/pentaho-kettle | @ Override public void updateDisplay ( ) { }
mattyb149/pentaho-kettle | @ Override public void showError ( String title , String message , Exception e ) { log . logError ( message , e ) ; }
mattyb149/pentaho-kettle | protected < T extends SharedObjectInterface > List < T > getSharedObjects ( Class < T > clazz ) { List < T > result = new ArrayList < T > ( ) ; for ( SharedObjectInterface sharedObject : sharedObjects . getObjectsMap ( ) . values ( ) ) { if ( clazz . isInstance ( sharedObject ) ) { result . add ( ( T ) sharedObject ) ; } } return result ; }
mattyb149/pentaho-kettle | private boolean equals ( Object obj1 , Object obj2 ) { if ( obj1 == null ) { if ( obj2 == null ) { return true ; } return false ; } if ( obj2 == null ) { return false ; } return obj1 . equals ( obj2 ) ; }
mattyb149/pentaho-kettle | protected boolean equals ( DatabaseMeta databaseMeta , DatabaseMeta databaseMeta2 ) { if ( ! equals ( databaseMeta . getName ( ) , databaseMeta2 . getName ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getPluginId ( ) , databaseMeta2 . getPluginId ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getAccessType ( ) , databaseMeta2 . getAccessType ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getHostname ( ) , databaseMeta2 . getHostname ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getDatabaseName ( ) , databaseMeta2 . getDatabaseName ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getDatabasePortNumberString ( ) , databaseMeta2 . getDatabasePortNumberString ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getUsername ( ) , databaseMeta2 . getUsername ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getPassword ( ) , databaseMeta2 . getPassword ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getServername ( ) , databaseMeta2 . getServername ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getDataTablespace ( ) , databaseMeta2 . getDataTablespace ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getIndexTablespace ( ) , databaseMeta2 . getIndexTablespace ( ) ) ) { return false ; } Map < Object , Object > databaseMeta2Attributes = new HashMap < Object , Object > ( databaseMeta2 . getAttributes ( ) ) ; for ( Entry < Object , Object > databaseMetaEntry : new HashMap < Object , Object > ( databaseMeta . getAttributes ( ) ) . entrySet ( ) ) { Object value = databaseMeta2Attributes . remove ( databaseMetaEntry . getKey ( ) ) ; if ( ! equals ( value , databaseMetaEntry . getValue ( ) ) ) { return false ; } } if ( databaseMeta2Attributes . size ( ) > 0 ) { return false ; } return true ; }
mattyb149/pentaho-kettle | protected boolean equals ( SlaveServer slaveServer , SlaveServer slaveServer2 ) { if ( ! equals ( slaveServer . getName ( ) , slaveServer2 . getName ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getHostname ( ) , slaveServer2 . getHostname ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getPort ( ) , slaveServer2 . getPort ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getWebAppName ( ) , slaveServer2 . getWebAppName ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getUsername ( ) , slaveServer2 . getUsername ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getPassword ( ) , slaveServer2 . getPassword ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getProxyHostname ( ) , slaveServer2 . getProxyHostname ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getProxyPort ( ) , slaveServer2 . getProxyPort ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getNonProxyHosts ( ) , slaveServer2 . getNonProxyHosts ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . isMaster ( ) , slaveServer2 . isMaster ( ) ) ) { return false ; } return true ; }
mattyb149/pentaho-kettle | protected boolean equals ( PartitionSchema partitionSchema , PartitionSchema partitionSchema2 ) { if ( ! equals ( partitionSchema . getName ( ) , partitionSchema2 . getName ( ) ) ) { return false ; } else if ( ! equals ( partitionSchema . getPartitionIDs ( ) , partitionSchema2 . getPartitionIDs ( ) ) ) { return false ; } else if ( ! equals ( partitionSchema . isDynamicallyDefined ( ) , partitionSchema2 . isDynamicallyDefined ( ) ) ) { return false ; } else if ( ! equals ( partitionSchema . getNumberOfPartitionsPerSlave ( ) , partitionSchema2 . getNumberOfPartitionsPerSlave ( ) ) ) { return false ; } return true ; }
mattyb149/pentaho-kettle | protected boolean equals ( ClusterSchema clusterSchema , ClusterSchema clusterSchema2 ) { if ( ! equals ( clusterSchema . getName ( ) , clusterSchema2 . getName ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getBasePort ( ) , clusterSchema2 . getBasePort ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getSocketsBufferSize ( ) , clusterSchema2 . getSocketsBufferSize ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getSocketsFlushInterval ( ) , clusterSchema2 . getSocketsFlushInterval ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . isSocketsCompressed ( ) , clusterSchema2 . isSocketsCompressed ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . isDynamic ( ) , clusterSchema2 . isDynamic ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getSlaveServers ( ) , clusterSchema2 . getSlaveServers ( ) ) ) { return false ; } return true ; }
mattyb149/pentaho-kettle | private void replaceSharedObjects ( AbstractMeta abstractMeta ) { for ( DatabaseMeta databaseMeta : getSharedObjects ( DatabaseMeta . class ) ) { int index = abstractMeta . indexOfDatabase ( databaseMeta ) ; if ( index < 0 ) { abstractMeta . addDatabase ( databaseMeta ) ; } else { DatabaseMeta imported = abstractMeta . getDatabase ( index ) ; imported . setObjectId ( databaseMeta . getObjectId ( ) ) ; if ( equals ( databaseMeta , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_DB ) ) { imported . replaceMeta ( databaseMeta ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } for ( SlaveServer slaveServer : getSharedObjects ( SlaveServer . class ) ) { int index = abstractMeta . getSlaveServers ( ) . indexOf ( slaveServer ) ; if ( index < 0 ) { abstractMeta . getSlaveServers ( ) . add ( slaveServer ) ; } else { SlaveServer imported = abstractMeta . getSlaveServers ( ) . get ( index ) ; imported . setObjectId ( slaveServer . getObjectId ( ) ) ; if ( equals ( slaveServer , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . SlaveServerExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_SS ) ) { imported . replaceMeta ( slaveServer ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } }
mattyb149/pentaho-kettle | protected void replaceSharedObjects ( TransMeta transMeta ) throws KettleException { replaceSharedObjects ( ( AbstractMeta ) transMeta ) ; for ( ClusterSchema clusterSchema : getSharedObjects ( ClusterSchema . class ) ) { int index = transMeta . getClusterSchemas ( ) . indexOf ( clusterSchema ) ; if ( index < 0 ) { transMeta . getClusterSchemas ( ) . add ( clusterSchema ) ; } else { ClusterSchema imported = transMeta . getClusterSchemas ( ) . get ( index ) ; imported . setObjectId ( clusterSchema . getObjectId ( ) ) ; if ( equals ( clusterSchema , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ClusterSchemaExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_CS ) ) { imported . replaceMeta ( clusterSchema ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } for ( PartitionSchema partitionSchema : getSharedObjects ( PartitionSchema . class ) ) { int index = transMeta . getPartitionSchemas ( ) . indexOf ( partitionSchema ) ; if ( index < 0 ) { transMeta . getPartitionSchemas ( ) . add ( partitionSchema ) ; } else { PartitionSchema imported = transMeta . getPartitionSchemas ( ) . get ( index ) ; imported . setObjectId ( partitionSchema . getObjectId ( ) ) ; if ( equals ( partitionSchema , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . PartitionSchemaExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_PS ) ) { imported . replaceMeta ( partitionSchema ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } }
mattyb149/pentaho-kettle | protected void replaceSharedObjects ( JobMeta transMeta ) throws KettleException { replaceSharedObjects ( ( AbstractMeta ) transMeta ) ; }
mattyb149/pentaho-kettle | private void patchMappingSteps ( TransMeta transMeta ) { for ( StepMeta stepMeta : transMeta . getSteps ( ) ) { if ( stepMeta . isMapping ( ) ) { MappingMeta mappingMeta = ( MappingMeta ) stepMeta . getStepMetaInterface ( ) ; if ( mappingMeta . getSpecificationMethod ( ) == ObjectLocationSpecificationMethod . REPOSITORY_BY_NAME ) { if ( transDirOverride != null ) { mappingMeta . setDirectoryPath ( transDirOverride ) ; continue ; } String mappingMetaPath = resolvePath ( baseDirectory . getPath ( ) , mappingMeta . getDirectoryPath ( ) ) ; mappingMeta . setDirectoryPath ( mappingMetaPath ) ; } } } }
mattyb149/pentaho-kettle | private void patchJobEntries ( JobMeta jobMeta ) { for ( JobEntryCopy copy : jobMeta . getJobCopies ( ) ) { if ( copy . isTransformation ( ) ) { JobEntryTrans entry = ( JobEntryTrans ) copy . getEntry ( ) ; if ( entry . getSpecificationMethod ( ) == ObjectLocationSpecificationMethod . REPOSITORY_BY_NAME ) { if ( transDirOverride != null ) { entry . setDirectory ( transDirOverride ) ; continue ; } String entryPath = resolvePath ( baseDirectory . getPath ( ) , entry . getDirectory ( ) ) ; entry . setDirectory ( entryPath ) ; } } if ( copy . isJob ( ) ) { JobEntryJob entry = ( JobEntryJob ) copy . getEntry ( ) ; if ( entry . getSpecificationMethod ( ) == ObjectLocationSpecificationMethod . REPOSITORY_BY_NAME ) { if ( jobDirOverride != null ) { entry . setDirectory ( jobDirOverride ) ; continue ; } String entryPath = resolvePath ( baseDirectory . getPath ( ) , entry . getDirectory ( ) ) ; entry . setDirectory ( entryPath ) ; } } } }
mattyb149/pentaho-kettle | private String resolvePath ( String rootPath , String entryPath ) { String extraPath = Const . NVL ( entryPath , " / " ) ; if ( needToCheckPathForVariables ( ) ) { if ( containsVariables ( entryPath ) ) { return extraPath ; } } String newPath = Const . NVL ( rootPath , " / " ) ; if ( newPath . endsWith ( " / " ) && extraPath . startsWith ( " / " ) ) { newPath = newPath . substring ( 0 , newPath . length ( ) - 1 ) ; } else if ( ! newPath . endsWith ( " / " ) && ! extraPath . startsWith ( " / " ) ) { newPath += " / " ; } else if ( extraPath . equals ( " / " ) ) { extraPath = " " ; } return newPath + extraPath ; }
mattyb149/pentaho-kettle | boolean needToCheckPathForVariables ( ) { return needToCheckPathForVariables ; }
mattyb149/pentaho-kettle | protected void saveTransMeta ( TransMeta transMeta ) throws KettleException { rep . save ( transMeta , versionComment , this , overwrite ) ; }
mattyb149/pentaho-kettle | protected boolean importTransformation ( Node transnode , RepositoryImportFeedbackInterface feedback ) throws KettleException { TransMeta transMeta = createTransMetaForNode ( transnode ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportTrans . Label " , Integer . toString ( transformationNumber ) , transMeta . getName ( ) ) ) ; validateImportedElement ( importRules , transMeta ) ; String directoryPath = Const . NVL ( XMLHandler . getTagValue ( transnode , " info " , " directory " ) , Const . FILE_SEPARATOR ) ; if ( transDirOverride != null ) { directoryPath = transDirOverride ; } if ( directoryPath . startsWith ( " / " ) ) { directoryPath = directoryPath . substring ( 1 ) ; } if ( limitDirs . size ( ) > 0 && Const . indexOfString ( directoryPath , limitDirs ) < 0 ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedTransformationNotPartOfLimitingDirectories . Log " , transMeta . getName ( ) ) ) ; return true ; } RepositoryDirectoryInterface targetDirectory = getTargetDirectory ( directoryPath , transDirOverride , feedback ) ; ObjectId existingId = rep . getTransformationID ( transMeta . getName ( ) , targetDirectory ) ; if ( existingId != null && askOverwrite ) { overwrite = feedback . transOverwritePrompt ( transMeta ) ; askOverwrite = feedback . isAskingOverwriteConfirmation ( ) ; } else { updateDisplay ( ) ; } if ( existingId == null || overwrite ) { replaceSharedObjects ( transMeta ) ; transMeta . setObjectId ( existingId ) ; transMeta . setRepositoryDirectory ( targetDirectory ) ; patchMappingSteps ( transMeta ) ; try { if ( transMeta . getCreatedUser ( ) == null || transMeta . getCreatedUser ( ) . equals ( " - " ) ) { transMeta . setCreatedDate ( new Date ( ) ) ; if ( rep . getUserInfo ( ) != null ) { transMeta . setCreatedUser ( rep . getUserInfo ( ) . getLogin ( ) ) ; } else { transMeta . setCreatedUser ( null ) ; } } saveTransMeta ( transMeta ) ; feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . TransSaved . Log " , Integer . toString ( transformationNumber ) , transMeta . getName ( ) ) ) ; if ( transMeta . hasRepositoryReferences ( ) ) { referencingObjects . add ( new RepositoryObject ( transMeta . getObjectId ( ) , transMeta . getName ( ) , transMeta . getRepositoryDirectory ( ) , null , null , RepositoryObjectType . TRANSFORMATION , null , false ) ) ; } } catch ( Exception e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorSavingTrans . Log " , Integer . toString ( transformationNumber ) , transMeta . getName ( ) , Const . getStackTracker ( e ) ) ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } } else { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedExistingTransformation . Log " , transMeta . getName ( ) ) ) ; } return true ; }
mattyb149/pentaho-kettle | protected void saveJobMeta ( JobMeta jobMeta ) throws KettleException { if ( jobMeta . getCreatedUser ( ) == null || jobMeta . getCreatedUser ( ) . equals ( " - " ) ) { jobMeta . setCreatedDate ( new Date ( ) ) ; if ( rep . getUserInfo ( ) != null ) { jobMeta . setCreatedUser ( rep . getUserInfo ( ) . getLogin ( ) ) ; } else { jobMeta . setCreatedUser ( null ) ; } } rep . save ( jobMeta , versionComment , null , overwrite ) ; }
mattyb149/pentaho-kettle | protected boolean importJob ( Node jobnode , RepositoryImportFeedbackInterface feedback ) throws KettleException { JobMeta jobMeta = createJobMetaForNode ( jobnode ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportJob . Label " , Integer . toString ( jobNumber ) , jobMeta . getName ( ) ) ) ; validateImportedElement ( importRules , jobMeta ) ; String directoryPath = Const . NVL ( XMLHandler . getTagValue ( jobnode , " directory " ) , Const . FILE_SEPARATOR ) ; if ( jobDirOverride != null ) { directoryPath = jobDirOverride ; } if ( directoryPath . startsWith ( " / " ) ) { directoryPath = directoryPath . substring ( 1 ) ; } if ( limitDirs . size ( ) > 0 && Const . indexOfString ( directoryPath , limitDirs ) < 0 ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedJobNotPartOfLimitingDirectories . Log " , jobMeta . getName ( ) ) ) ; return true ; } RepositoryDirectoryInterface targetDirectory = getTargetDirectory ( directoryPath , jobDirOverride , feedback ) ; ObjectId existintId = rep . getJobId ( jobMeta . getName ( ) , targetDirectory ) ; if ( existintId != null && askOverwrite ) { overwrite = feedback . jobOverwritePrompt ( jobMeta ) ; askOverwrite = feedback . isAskingOverwriteConfirmation ( ) ; } else { updateDisplay ( ) ; } if ( existintId == null || overwrite ) { replaceSharedObjects ( jobMeta ) ; jobMeta . setRepositoryDirectory ( targetDirectory ) ; jobMeta . setObjectId ( existintId ) ; patchJobEntries ( jobMeta ) ; try { saveJobMeta ( jobMeta ) ; if ( jobMeta . hasRepositoryReferences ( ) ) { referencingObjects . add ( new RepositoryObject ( jobMeta . getObjectId ( ) , jobMeta . getName ( ) , jobMeta . getRepositoryDirectory ( ) , null , null , RepositoryObjectType . JOB , null , false ) ) ; } feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . JobSaved . Log " , Integer . toString ( jobNumber ) , jobMeta . getName ( ) ) ) ; } catch ( Exception e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorSavingJob . Log " , Integer . toString ( jobNumber ) , jobMeta . getName ( ) , Const . getStackTracker ( e ) ) ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } } else { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedExistingJob . Log " , jobMeta . getName ( ) ) ) ; } return true ; }
mattyb149/pentaho-kettle | JobMeta createJobMetaForNode ( Node jobnode ) throws KettleXMLException { return new JobMeta ( jobnode , null , false , SpoonFactory . getInstance ( ) ) ; }
mattyb149/pentaho-kettle | private DocumentBuilder getOrCreateDb ( ) throws KettleXMLException { if ( documentBuilder == null ) { documentBuilder = XMLHandler . createDocumentBuilder ( false , true ) ; } return documentBuilder ; }
mattyb149/pentaho-kettle | @ Override public boolean transformationElementRead ( String xml , RepositoryImportFeedbackInterface feedback ) { try { Document doc = XMLHandler . loadXMLString ( getOrCreateDb ( ) , xml ) ; Node transformationNode = XMLHandler . getSubNode ( doc , RepositoryExportSaxParser . STRING_TRANSFORMATION ) ; if ( ! importTransformation ( transformationNode , feedback ) ) { return false ; } transformationNumber ++ ; } catch ( Exception e ) { feedback . showError ( BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringTransformationImport . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringTransformationImport . Message " ) , e ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } return true ; }
mattyb149/pentaho-kettle | @ Override public boolean jobElementRead ( String xml , RepositoryImportFeedbackInterface feedback ) { try { Document doc = XMLHandler . loadXMLString ( getOrCreateDb ( ) , xml ) ; Node jobNode = XMLHandler . getSubNode ( doc , RepositoryExportSaxParser . STRING_JOB ) ; if ( ! importJob ( jobNode , feedback ) ) { return false ; } jobNumber ++ ; } catch ( Exception e ) { showError ( BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringJobImport . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringJobImport . Message " ) , e ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } return true ; }
mattyb149/pentaho-kettle | private RepositoryDirectoryInterface getTargetDirectory ( String directoryPath , String dirOverride , RepositoryImportFeedbackInterface feedback ) throws KettleException { RepositoryDirectoryInterface targetDirectory = null ; if ( dirOverride != null ) { targetDirectory = rep . findDirectory ( directoryPath ) ; if ( targetDirectory == null ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . CreateDir . Log " , directoryPath , getRepositoryRoot ( ) . toString ( ) ) ) ; targetDirectory = rep . createRepositoryDirectory ( getRepositoryRoot ( ) , directoryPath ) ; } } else { targetDirectory = baseDirectory . findDirectory ( directoryPath ) ; if ( targetDirectory == null ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . CreateDir . Log " , directoryPath , baseDirectory . toString ( ) ) ) ; targetDirectory = rep . createRepositoryDirectory ( baseDirectory , directoryPath ) ; } } return targetDirectory ; }
mattyb149/pentaho-kettle | private RepositoryDirectoryInterface getRepositoryRoot ( ) throws KettleException { if ( root == null ) { root = rep . loadRepositoryDirectoryTree ( ) ; } return root ; }
mattyb149/pentaho-kettle | @ Override public void fatalXmlErrorEncountered ( SAXParseException e ) { showError ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorInvalidXML . Message " ) , BaseMessages . getString ( PKG , " RepositoryImporter . ErrorInvalidXML . Title " ) , e ) ; }
mattyb149/pentaho-kettle | @ Override public boolean askContinueOnErrorQuestion ( String title , String message ) { return continueOnError ; }
mattyb149/pentaho-kettle | @ Override public void beginTask ( String message , int nrWorks ) { addLog ( message ) ; }
mattyb149/pentaho-kettle | @ Override public void done ( ) { }
mattyb149/pentaho-kettle | @ Override public boolean isCanceled ( ) { return false ; }
mattyb149/pentaho-kettle | @ Override public void setTaskName ( String taskName ) { addLog ( taskName ) ; }
mattyb149/pentaho-kettle | @ Override public void subTask ( String message ) { addLog ( message ) ; }
mattyb149/pentaho-kettle | @ Override public void worked ( int nrWorks ) { }
mattyb149/pentaho-kettle | public String getTransDirOverride ( ) { return transDirOverride ; }
mattyb149/pentaho-kettle | @ Override public void setTransDirOverride ( String transDirOverride ) { this . transDirOverride = transDirOverride ; }
mattyb149/pentaho-kettle | public String getJobDirOverride ( ) { return jobDirOverride ; }
mattyb149/pentaho-kettle | @ Override public void setJobDirOverride ( String jobDirOverride ) { this . jobDirOverride = jobDirOverride ; }
mattyb149/pentaho-kettle | @ Override public void setImportRules ( ImportRules importRules ) { this . importRules = importRules ; }
mattyb149/pentaho-kettle | public ImportRules getImportRules ( ) { return importRules ; }
mattyb149/pentaho-kettle | @ Override public boolean isAskingOverwriteConfirmation ( ) { return askOverwrite ; }
mattyb149/pentaho-kettle | private void addException ( Exception exception ) { if ( this . exceptions == null ) { this . exceptions = new ArrayList < Exception > ( ) ; } exceptions . add ( exception ) ; }
mattyb149/pentaho-kettle | @ Override public List < Exception > getExceptions ( ) { return exceptions ; }
mattyb149/pentaho-kettle | @ Override public void setLimitDirs ( List < String > limitDirs ) { this . limitDirs = new ArrayList < String > ( limitDirs ) ; }
mattyb149/pentaho-kettle | protected void setBaseDirectory ( RepositoryDirectoryInterface baseDirectory ) { this . baseDirectory = baseDirectory ; }
mattyb149/pentaho-kettle | public void setOverwrite ( boolean overwrite ) { this . overwrite = overwrite ; }
mattyb149/pentaho-kettle | public String getVersionComment ( ) { return versionComment ; }
mattyb149/pentaho-kettle | private void saveTransformationToRepo ( TransMeta transMeta , RepositoryImportFeedbackInterface feedback ) throws KettleException { try { transMeta . lookupRepositoryReferences ( rep ) ; } catch ( LookupReferencesException e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log " , transMeta . getName ( ) , RepositoryObjectType . TRANSFORMATION ) ) ; feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log . Cause " , e . objectTypePairsToString ( ) ) ) ; } rep . save ( transMeta , " import ▁ object ▁ reference ▁ specification " , null ) ; }
mattyb149/pentaho-kettle | private void saveJobToRepo ( JobMeta jobMeta , RepositoryImportFeedbackInterface feedback ) throws KettleException { try { jobMeta . lookupRepositoryReferences ( rep ) ; } catch ( LookupReferencesException e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log " , jobMeta . getName ( ) , RepositoryObjectType . JOB ) ) ; feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log . Cause " , e . objectTypePairsToString ( ) ) ) ; } rep . save ( jobMeta , " import ▁ object ▁ reference ▁ specification " , null ) ; }
OpenHFT/Chronicle-Network | public FatalFailureConnectionStrategy ( int attempts , boolean blocking ) { this . attempts = attempts ; this . blocking = blocking ; init ( ) ; }
OpenHFT/Chronicle-Network | private void init ( ) { if ( tcpBufferSize == 0 ) tcpBufferSize = Jvm . getInteger ( " tcp . client . buffer . size " , TCP_BUFFER ) ; if ( isClosed == null ) isClosed = new AtomicBoolean ( false ) ; if ( clientConnectionMonitor == null ) clientConnectionMonitor = new VanillaClientConnectionMonitor ( ) ; }
OpenHFT/Chronicle-Network | @ Override public ClientConnectionMonitor clientConnectionMonitor ( ) { return clientConnectionMonitor ; }
OpenHFT/Chronicle-Network | public FatalFailureConnectionStrategy clientConnectionMonitor ( ClientConnectionMonitor fatalFailureMonitor ) { this . clientConnectionMonitor = fatalFailureMonitor ; return this ; }
OpenHFT/Chronicle-Network | @ Nullable @ Override public ChronicleSocketChannel connect ( @ NotNull String name , @ NotNull SocketAddressSupplier socketAddressSupplier , boolean didLogIn , @ Nullable FatalFailureMonitor fatalFailureMonitor ) throws InterruptedException { if ( socketAddressSupplier . size ( ) == 0 && ! hasSentFatalFailure && fatalFailureMonitor != null ) { hasSentFatalFailure = true ; fatalFailureMonitor . onFatalFailure ( name , " no ▁ connections ▁ have ▁ not ▁ been ▁ configured " ) ; LockSupport . parkNanos ( PAUSE ) ; return null ; } int failures = 0 ; int maxFailures = socketAddressSupplier . size ( ) * attempts ; socketAddressSupplier . resetToPrimary ( ) ; for ( ; ; ) { throwExceptionIfClosed ( ) ; if ( Thread . currentThread ( ) . isInterrupted ( ) ) throw new InterruptedException ( ) ; if ( failures == maxFailures && fatalFailureMonitor != null ) { if ( ! hasSentFatalFailure ) { hasSentFatalFailure = true ; fatalFailureMonitor . onFatalFailure ( name , name ) ; } return null ; } ChronicleSocketChannel socketChannel = null ; try { @ Nullable final InetSocketAddress socketAddress = socketAddressSupplier . get ( ) ; if ( socketAddress == null ) { failures ++ ; socketAddressSupplier . failoverToNextAddress ( ) ; LockSupport . parkNanos ( PAUSE ) ; continue ; } long millis = TimeUnit . NANOSECONDS . toMillis ( PAUSE ) ; socketChannel = openSocketChannel ( socketAddress , tcpBufferSize , millis ) ; if ( socketChannel == null ) { Jvm . warn ( ) . on ( getClass ( ) , " unable ▁ to ▁ connected ▁ to ▁ " + socketAddressSupplier . toString ( ) + " , ▁ name = " + name ) ; failures ++ ; socketAddressSupplier . failoverToNextAddress ( ) ; LockSupport . parkNanos ( PAUSE ) ; continue ; } socketChannel . configureBlocking ( blocking ) ; if ( Jvm . isDebugEnabled ( getClass ( ) ) ) Jvm . debug ( ) . on ( getClass ( ) , " successfully ▁ connected ▁ to ▁ " + socketAddressSupplier ) ; hasSentFatalFailure = false ; failures = 0 ; return socketChannel ; } catch ( InterruptedException e ) { throw e ; } catch ( Throwable e ) { if ( socketChannel != null ) closeQuietly ( socketChannel ) ; failures ++ ; socketAddressSupplier . failoverToNextAddress ( ) ; LockSupport . parkNanos ( PAUSE ) ; } } }
OpenHFT/Chronicle-Network | @ Override public void close ( ) { isClosed . set ( true ) ; }
OpenHFT/Chronicle-Network | @ Override public boolean isClosed ( ) { return isClosed . get ( ) ; }
OpenHFT/Chronicle-Network | @ Override public FatalFailureConnectionStrategy open ( ) { isClosed . set ( false ) ; return this ; }
OpenHFT/Chronicle-Network | @ Override public void readMarshallable ( @ NotNull WireIn wire ) throws IORuntimeException { super . readMarshallable ( wire ) ; init ( ) ; }
MobileCloudNetworking/icnaas | @ Before public void setUp ( ) throws Exception { }
MobileCloudNetworking/icnaas | @ After public void tearDown ( ) throws Exception { }
MobileCloudNetworking/icnaas | @ Test public void testThumbnails ( ) throws Exception { Log . info ( Log . FAC_TEST , " Starting ▁ testThumbnails " ) ; byte [ ] fakeImageData1 = " xxx " . getBytes ( ) ; ContentName thumbNailBase = new ContentName ( testHelper . getTestNamespace ( " testThumbnails " ) , " thumbnailBaseFile " ) ; CCNStringObject cso = new CCNStringObject ( thumbNailBase , " thumbNailBase " , CCNFlowControl . SaveType . REPOSITORY , putHandle ) ; cso . save ( ) ; cso . close ( ) ; ContentName origVersion = SegmentationProfile . segmentRoot ( VersioningProfile . getLatestVersion ( thumbNailBase , cso . getContentPublisher ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle . defaultVerifier ( ) , getHandle ) . name ( ) ) ; ContentName thumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ simple ▁ thumbnail " ) ; RepositoryFileOutputStream thumbImage1 = new RepositoryFileOutputStream ( thumbName , putHandle ) ; thumbImage1 . write ( fakeImageData1 , 0 , fakeImageData1 . length ) ; thumbImage1 . close ( ) ; ContentName checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData1 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ second ▁ version ▁ of ▁ a ▁ thumbnail " ) ; byte [ ] fakeImageData2 = " yyy " . getBytes ( ) ; ContentName thumbName2 = VersioningProfile . updateVersion ( checkThumbName ) ; RepositoryFileOutputStream thumbImage2 = new RepositoryFileOutputStream ( thumbName2 , putHandle ) ; thumbImage2 . write ( fakeImageData2 , 0 , fakeImageData2 . length ) ; thumbImage2 . close ( ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData2 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ thumbnail ▁ associated ▁ with ▁ a ▁ second ▁ version ▁ of ▁ a ▁ file " ) ; cso = new CCNStringObject ( thumbNailBase , " thumbNailBase " , CCNFlowControl . SaveType . REPOSITORY , putHandle ) ; cso . save ( ) ; cso . close ( ) ; byte [ ] fakeImageData3 = " zzz " . getBytes ( ) ; thumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; RepositoryFileOutputStream thumbImage3 = new RepositoryFileOutputStream ( thumbName , putHandle ) ; thumbImage3 . write ( fakeImageData3 , 0 , fakeImageData3 . length ) ; thumbImage3 . close ( ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData3 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ second ▁ thumbnail ▁ associated ▁ with ▁ a ▁ second ▁ version ▁ of ▁ a ▁ file " ) ; byte [ ] fakeImageData4 = " fff " . getBytes ( ) ; thumbName2 = VersioningProfile . updateVersion ( checkThumbName ) ; RepositoryFileOutputStream thumbImage4 = new RepositoryFileOutputStream ( thumbName2 , putHandle ) ; thumbImage4 . write ( fakeImageData4 , 0 , fakeImageData4 . length ) ; thumbImage4 . close ( ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData4 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ the ▁ correct ▁ thumbnail ▁ associated ▁ with ▁ an ▁ arbitrary ▁ version ▁ of ▁ a ▁ file " ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( origVersion , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData2 ) ; Log . info ( Log . FAC_TEST , " Completed ▁ testThumbnails " ) ; }
MobileCloudNetworking/icnaas | private void checkData ( ContentName name , byte [ ] check ) throws IOException { CCNInputStream input = new CCNInputStream ( name , getHandle ) ; byte [ ] buffer = new byte [ check . length ] ; Assert . assertTrue ( - 1 != input . read ( buffer ) ) ; Assert . assertArrayEquals ( buffer , check ) ; input . close ( ) ; }
integrated/jakarta-slide-server | public GroupNode ( ) { super ( ) ; }
integrated/jakarta-slide-server | public GroupNode ( String uri ) { super ( uri ) ; }
integrated/jakarta-slide-server | public GroupNode ( String uri , Vector children , Vector links ) { super ( uri , children , links ) ; }
CognizantOneDevOps/Insights | public boolean isUsecaseExisting ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; List < AutoMLConfig > resultList = getResultList ( " FROM ▁ AutoMLConfig ▁ a ▁ WHERE ▁ a . useCaseName ▁ = ▁ : usecase ▁ " , AutoMLConfig . class , parameters ) ; if ( resultList . isEmpty ( ) ) { return Boolean . FALSE ; } else { return Boolean . TRUE ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public boolean createOrUpdate ( String usecase , String config , String prediction , String Mojo ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; List < AutoMLConfig > resultList = getResultList ( " FROM ▁ AutoMLConfig ▁ a ▁ WHERE ▁ a . usecase ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; AutoMLConfig autoMLConfig = null ; Long updatedDate = System . currentTimeMillis ( ) ; if ( ! resultList . isEmpty ( ) ) { autoMLConfig = resultList . get ( 0 ) ; } if ( autoMLConfig != null ) { if ( Mojo != null ) autoMLConfig . setMojoDeployed ( Mojo ) ; if ( prediction != null ) autoMLConfig . setPredictionColumn ( prediction ) ; autoMLConfig . setUpdatedDate ( updatedDate ) ; update ( autoMLConfig ) ; } else { autoMLConfig = new AutoMLConfig ( ) ; autoMLConfig . setUseCaseName ( usecase ) ; autoMLConfig . setConfigJson ( config ) ; autoMLConfig . setCreatedDate ( updatedDate ) ; autoMLConfig . setUpdatedDate ( updatedDate ) ; save ( autoMLConfig ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public int updateMLConfig ( AutoMLConfig config ) { int id = - 1 ; try { update ( config ) ; return 1 ; } catch ( Exception e ) { return id ; } }
CognizantOneDevOps/Insights | public int saveMLConfig ( AutoMLConfig config ) { int id = - 1 ; try { return ( int ) save ( config ) ; } catch ( Exception e ) { return id ; } }
CognizantOneDevOps/Insights | public String getPredictionColumn ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; AutoMLConfig result = getSingleResult ( " FROM ▁ AutoMLConfig ▁ AC ▁ WHERE ▁ AC . usecase ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; return result . getPredictionColumn ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public AutoMLConfig getMLConfigByUsecase ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; return getSingleResult ( " FROM ▁ AutoMLConfig ▁ AC ▁ WHERE ▁ AC . useCaseName ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public boolean deleteUsecase ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; AutoMLConfig autoMLConfig = getUniqueResult ( " FROM ▁ AutoMLConfig ▁ a ▁ WHERE ▁ a . useCaseName ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; if ( autoMLConfig != null ) { List < InsightsWorkflowExecutionHistory > executionHistory = workflowDal . getWorkflowExecutionHistoryByWorkflowId ( autoMLConfig . getWorkflowConfig ( ) . getWorkflowId ( ) ) ; if ( ! executionHistory . isEmpty ( ) ) { executionHistory . forEach ( eachExecution -> { workflowDal . deleteExecutionHistory ( eachExecution ) ; } ) ; } delete ( autoMLConfig ) ; } else { return false ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public List < AutoMLConfig > fetchUsecases ( ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; return getResultList ( " FROM ▁ AutoMLConfig " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public AutoMLConfig fetchUseCasesByWorkflowId ( String workflowId ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( " workflowId " , workflowId ) ; return getUniqueResult ( " FROM ▁ AutoMLConfig ▁ AMLC ▁ where ▁ AMLC . workflowConfig . workflowId ▁ = ▁ : workflowId " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public List < AutoMLConfig > getActiveUsecaseList ( ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; return getResultList ( " FROM ▁ AutoMLConfig ▁ AMLC ▁ WHERE ▁ AMLC . isActive ▁ = ▁ true ▁ AND ▁ AMLC . status ▁ = ▁ ' MOJO _ DEPLOYED ' " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
salyh/geronimo-specs | private JsonCollectors ( ) { }
OpenAMEE/amee.platform.api | @ Override public void setAsText ( String text ) { if ( ! text . isEmpty ( ) ) { ValueDefinition valueDefinition = definitionService . getValueDefinition ( text ) ; if ( valueDefinition != null ) { setValue ( valueDefinition ) ; } else { throw new IllegalArgumentException ( " Invalid ▁ UID : ▁ " + text ) ; } } else { throw new IllegalArgumentException ( " UID ▁ is ▁ empty " ) ; } }
bptlab/processeditor | @ Override public ProcessEdge createDefaultEdge ( ProcessNode source , ProcessNode target ) { return new Connection ( source , target ) ; }
bptlab/processeditor | @ Override public List < ProcessLayouter > getLayouters ( ) { if ( layouters == null ) { layouters = new ArrayList < ProcessLayouter > ( ) ; layouters . add ( new SugiyamaLayoutAlgorithm ( true , Configuration . getProperties ( ) ) ) ; layouters . add ( new SugiyamaLayoutAlgorithm ( false , Configuration . getProperties ( ) ) ) ; } return layouters ; }
bptlab/processeditor | @ Override public List < Class < ? extends ProcessNode > > getNextNodesRecommendation ( ProcessModel model , ProcessNode node ) { List < Class < ? extends ProcessNode > > result = new LinkedList < Class < ? extends ProcessNode > > ( ) ; if ( node instanceof Event ) { result . add ( Function . class ) ; result . add ( ANDConnector . class ) ; } if ( node instanceof Function ) { result . add ( Event . class ) ; result . add ( XORConnector . class ) ; result . add ( ORConnector . class ) ; } if ( node instanceof XORConnector || node instanceof ORConnector ) { result . add ( Event . class ) ; } if ( node instanceof ANDConnector ) { result . add ( Function . class ) ; } return result ; }
lgdlkq/coolweather | @ Nullable @ Override public IBinder onBind ( Intent intent ) { return null ; }
lgdlkq/coolweather | @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { updateWeather ( ) ; updateBingPic ( ) ; AlarmManager manager = ( AlarmManager ) getSystemService ( ALARM_SERVICE ) ; int anHour = 8 * 60 * 60 * 1000 ; long triggerAtTime = SystemClock . elapsedRealtime ( ) + anHour ; Intent i = new Intent ( this , AutoUpdateService . class ) ; PendingIntent pi = PendingIntent . getService ( this , 0 , i , 0 ) ; manager . cancel ( pi ) ; manager . set ( AlarmManager . ELAPSED_REALTIME_WAKEUP , triggerAtTime , pi ) ; return super . onStartCommand ( intent , flags , startId ) ; }
lgdlkq/coolweather | private void updateBingPic ( ) { String requestBingPic = " http : // guolin . tech / api . bing _ pic " ; HttpUtil . sendOkHttpRequest ( requestBingPic , new Callback ( ) { @ Override public void onFailure ( Call call , IOException e ) { e . printStackTrace ( ) ; } @ Override public void onResponse ( Call call , Response response ) throws IOException { String bingPic = response . body ( ) . string ( ) ; SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( AutoUpdateService . this ) . edit ( ) ; editor . putString ( " bing _ pic " , bingPic ) ; editor . apply ( ) ; } } ) ; }
lgdlkq/coolweather | private void updateWeather ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; String weatherString = prefs . getString ( " weather " , null ) ; if ( weatherString != null ) { Weather weather = Utility . handleWeatherResponse ( weatherString ) ; String weatherId = weather . basic . weatherId ; String weatherUrl = " http : // guolin . tech / weather ? cityid = " + weatherId + " & key = df796160155949ff98dc040016043c0f " ; HttpUtil . sendOkHttpRequest ( weatherUrl , new Callback ( ) { @ Override public void onFailure ( Call call , IOException e ) { e . printStackTrace ( ) ; } @ Override public void onResponse ( Call call , Response response ) throws IOException { String responseText = response . body ( ) . string ( ) ; Weather weather = Utility . handleWeatherResponse ( responseText ) ; if ( weather != null && " ok " . equals ( weather . status ) ) { SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( AutoUpdateService . this ) . edit ( ) ; editor . putString ( " weather " , responseText ) ; editor . apply ( ) ; } } } ) ; } }
hackingwu/EasyCMS | public String getId ( ) { return id ; }
hackingwu/EasyCMS | public void setId ( String id ) { this . id = id ; }
hackingwu/EasyCMS | public String getName ( ) { return name ; }
hackingwu/EasyCMS | public void setName ( String name ) { this . name = name ; }
hackingwu/EasyCMS | public String getState ( ) { return state ; }
hackingwu/EasyCMS | public void setState ( String state ) { this . state = state ; }
hackingwu/EasyCMS | public String getOrderNum ( ) { return orderNum ; }
hackingwu/EasyCMS | public void setOrderNum ( String orderNum ) { this . orderNum = orderNum ; }
hackingwu/EasyCMS | public String getUseSites ( ) { return useSites ; }
hackingwu/EasyCMS | public void setUseSites ( String useSites ) { this . useSites = useSites ; }
hackingwu/EasyCMS | public String getUseSiteNames ( ) { return useSiteNames ; }
hackingwu/EasyCMS | public void setUseSiteNames ( String useSiteNames ) { this . useSiteNames = useSiteNames ; }
hackingwu/EasyCMS | public User getAddUser ( ) { return addUser ; }
hackingwu/EasyCMS | public void setAddUser ( User addUser ) { this . addUser = addUser ; }
hackingwu/EasyCMS | public String getNoDel ( ) { return noDel ; }
hackingwu/EasyCMS | public void setNoDel ( String noDel ) { this . noDel = noDel ; }
hackingwu/EasyCMS | public String getStateStr ( ) { return state . equals ( "2" ) ? " 已删除 " : ( state . equals ( "0" ) ? " 否 " : " 是 " ) ; }
hackingwu/EasyCMS | public void setStateStr ( String stateStr ) { this . stateStr = stateStr ; }
amoudi87/hyracks | public InMemoryInvertedIndexInsertTest ( ) { super ( InvertedIndexType . INMEMORY , false ) ; }
Union-Investment/Crud2Go | public SQLContainerEventWrapper ( QueryDelegate delegate , DataContainer databaseContainer , EventRouter < CreateEventHandler , CreateEvent > onCreateEventRouter ) throws SQLException { super ( delegate ) ; this . databaseContainer = databaseContainer ; this . onCreateEventRouter = onCreateEventRouter ; }
Union-Investment/Crud2Go | @ Override public Object addItem ( ) throws UnsupportedOperationException { Object rowId = super . addItem ( ) ; RowItem rowItem = ( RowItem ) this . getItem ( rowId ) ; onCreateEventRouter . fireEvent ( new CreateEvent ( databaseContainer , databaseContainer . convertItemToRow ( rowItem , false , false ) ) ) ; return rowId ; }
Union-Investment/Crud2Go | @ Override public void fireContentsChange ( ) { super . fireContentsChange ( ) ; }
Union-Investment/Crud2Go | public void markRowAsModified ( Object itemId ) { try { RowItem item = ( RowItem ) getItemUnfiltered ( itemId ) ; Method method = SQLContainer . class . getDeclaredMethod ( " itemChangeNotification " , RowItem . class ) ; method . setAccessible ( true ) ; method . invoke ( this , item ) ; } catch ( NoSuchMethodException e ) { throw new TechnicalCrudPortletException ( " Error ▁ finding ▁ super . itemChangeNotification ( RowItem ) ▁ via ▁ reflection " , e ) ; } catch ( IllegalAccessException e ) { throw new TechnicalCrudPortletException ( " Error ▁ calling ▁ super . itemChangeNotification ( RowItem ) ▁ via ▁ reflection " , e ) ; } catch ( InvocationTargetException e ) { throw new TechnicalCrudPortletException ( " Error ▁ calling ▁ super . itemChangeNotification ( RowItem ) ▁ via ▁ reflection " , e ) ; } }
Union-Investment/Crud2Go | @ Override public int indexOfId ( Object itemId ) { if ( itemId instanceof TemporaryRowId || getItemUnfiltered ( itemId ) != null || ! ( getQueryDelegate ( ) instanceof IndexResolver ) ) { return super . indexOfId ( itemId ) ; } if ( itemId != null ) { IndexResolver tableQuery = ( IndexResolver ) getQueryDelegate ( ) ; Integer index = tableQuery . getIndexById ( ( RowId ) itemId ) ; if ( index != null ) { getIdByIndex ( index ) ; return index ; } } return - 1 ; }
Union-Investment/Crud2Go | public void replaceContainerFilter ( Filter filter ) { clearFiltersWithoutRefresh ( ) ; addContainerFilter ( filter ) ; }
Union-Investment/Crud2Go | private void clearFiltersWithoutRefresh ( ) { try { Field filtersField = SQLContainer . class . getDeclaredField ( " filters " ) ; filtersField . setAccessible ( true ) ; List < Filter > filters = ( List < Filter > ) filtersField . get ( this ) ; filters . clear ( ) ; } catch ( Exception e ) { throw new TechnicalCrudPortletException ( " ' filters ' ▁ field ▁ not ▁ accessible " , e ) ; } }
Union-Investment/Crud2Go | public void setSizeValidMilliSeconds ( int i ) { try { Field field = SQLContainer . class . getDeclaredField ( " sizeValidMilliSeconds " ) ; field . setAccessible ( true ) ; field . set ( this , i ) ; } catch ( SecurityException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } catch ( NoSuchFieldException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } catch ( IllegalArgumentException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } catch ( IllegalAccessException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } }
Union-Investment/Crud2Go | @ Override public List < Object > getItemIds ( int startIndex , int numberOfIds ) { try { return super . getItemIds ( startIndex , numberOfIds ) ; } catch ( IndexOutOfBoundsException e ) { LOGGER . info ( " Error ▁ getting ▁ item ▁ ids ▁ - ▁ database ▁ content ▁ may ▁ have ▁ changed " , e ) ; throw new BusinessException ( " portlet . crud . error . scrollingInconsistency " ) ; } }
huitseeker/deeplearning4j | public VariableMultiTimeseriesGenerator ( long seed , int numBatches , int batchSize , int values , int timestepsMin , int timestepsMax ) { this ( seed , numBatches , batchSize , values , timestepsMin , timestepsMax , 0 ) ; }
huitseeker/deeplearning4j | public VariableMultiTimeseriesGenerator ( long seed , int numBatches , int batchSize , int values , int timestepsMin , int timestepsMax , int firstMaxima ) { this . rng = new Random ( seed ) ; this . values = values ; this . batchSize = batchSize ; this . limit = numBatches ; this . maxTS = timestepsMax ; this . minTS = timestepsMin ; this . firstMaxima = firstMaxima ; if ( timestepsMax < timestepsMin ) throw new DL4JInvalidConfigException ( " timestepsMin ▁ should ▁ be ▁ < = ▁ timestepsMax " ) ; }
huitseeker/deeplearning4j | @ Override public MultiDataSet next ( int num ) { int localMaxima = isFirst && firstMaxima > 0 ? firstMaxima : minTS == maxTS ? minTS : rng . nextInt ( maxTS - minTS ) + minTS ; if ( isFirst ) log . info ( " Local ▁ maxima : ▁ { } " , localMaxima ) ; isFirst = false ; int [ ] shapeFeatures = new int [ ] { batchSize , values , localMaxima } ; int [ ] shapeLabels = new int [ ] { batchSize , 10 } ; int [ ] shapeFMasks = new int [ ] { batchSize , localMaxima } ; int [ ] shapeLMasks = new int [ ] { batchSize , 10 } ; INDArray features = Nd4j . createUninitialized ( shapeFeatures ) . assign ( counter . get ( ) ) ; INDArray labels = Nd4j . createUninitialized ( shapeLabels ) . assign ( counter . get ( ) + 0.25 ) ; INDArray fMasks = Nd4j . createUninitialized ( shapeFMasks ) . assign ( counter . get ( ) + 0.50 ) ; INDArray lMasks = Nd4j . createUninitialized ( shapeLMasks ) . assign ( counter . get ( ) + 0.75 ) ; counter . getAndIncrement ( ) ; return new org . nd4j . linalg . dataset . MultiDataSet ( new INDArray [ ] { features } , new INDArray [ ] { labels } , new INDArray [ ] { fMasks } , new INDArray [ ] { lMasks } ) ; }
huitseeker/deeplearning4j | @ Override public void setPreProcessor ( MultiDataSetPreProcessor preProcessor ) { }
huitseeker/deeplearning4j | @ Override public MultiDataSetPreProcessor getPreProcessor ( ) { return null ; }
huitseeker/deeplearning4j | @ Override public boolean resetSupported ( ) { return true ; }
huitseeker/deeplearning4j | @ Override public boolean asyncSupported ( ) { return true ; }
huitseeker/deeplearning4j | @ Override public void reset ( ) { isFirst = true ; counter . set ( 0 ) ; }
huitseeker/deeplearning4j | @ Override public boolean hasNext ( ) { return counter . get ( ) < limit ; }
huitseeker/deeplearning4j | @ Override public MultiDataSet next ( ) { return next ( batchSize ) ; }
huitseeker/deeplearning4j | @ Override public void remove ( ) { }
marpies/onesignal-ane | @ Override public Map < String , FREFunction > getFunctions ( ) { Map < String , FREFunction > functions = new HashMap < String , FREFunction > ( ) ; functions . put ( " init " , new InitFunction ( ) ) ; functions . put ( " sdkVersion " , new GetSDKVersionFunction ( ) ) ; functions . put ( " setSubscription " , new SetSubscriptionFunction ( ) ) ; functions . put ( " register " , new RegisterFunction ( ) ) ; functions . put ( " sendTags " , new SendTagsFunction ( ) ) ; functions . put ( " deleteTags " , new DeleteTagsFunction ( ) ) ; functions . put ( " getTags " , new GetTagsFunction ( ) ) ; functions . put ( " areNotificationsEnabled " , new AreNotificationsEnabledFunction ( ) ) ; functions . put ( " areNotificationsAvailable " , new AreNotificationsAvailableFunction ( ) ) ; functions . put ( " postNotification " , new PostNotificationFunction ( ) ) ; functions . put ( " idsAvailable " , new IdsAvailableFunction ( ) ) ; functions . put ( " clearNotifications " , new ClearNotificationsFunction ( ) ) ; functions . put ( " setRequiresUserPrivacyConsent " , new SetRequiresUserPrivacyConsentFunction ( ) ) ; functions . put ( " provideUserConsent " , new ProvideUserConsentFunction ( ) ) ; functions . put ( " userProvidedPrivacyConsent " , new GetUserProvidedPrivacyConsentFunction ( ) ) ; return functions ; }
marpies/onesignal-ane | @ Override public void dispose ( ) { AIR . setContext ( null ) ; }
mjball/Singularity | @ JsonCreator public S3UploadMetadata ( @ JsonProperty ( " directory " ) String directory , @ JsonProperty ( " fileGlob " ) String fileGlob , @ JsonProperty ( " s3Bucket " ) String s3Bucket , @ JsonProperty ( " s3KeyFormat " ) String s3KeyFormat , @ JsonProperty ( " finished " ) boolean finished ) { Preconditions . checkNotNull ( directory ) ; Preconditions . checkNotNull ( fileGlob ) ; Preconditions . checkNotNull ( s3Bucket ) ; Preconditions . checkNotNull ( s3KeyFormat ) ; this . directory = directory ; this . fileGlob = fileGlob ; this . s3Bucket = s3Bucket ; this . s3KeyFormat = s3KeyFormat ; this . finished = finished ; }
mjball/Singularity | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( directory == null ) ? 0 : directory . hashCode ( ) ) ; result = prime * result + ( ( fileGlob == null ) ? 0 : fileGlob . hashCode ( ) ) ; return result ; }
mjball/Singularity | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } S3UploadMetadata other = ( S3UploadMetadata ) obj ; if ( directory == null ) { if ( other . directory != null ) { return false ; } } else if ( ! directory . equals ( other . directory ) ) { return false ; } if ( fileGlob == null ) { if ( other . fileGlob != null ) { return false ; } } else if ( ! fileGlob . equals ( other . fileGlob ) ) { return false ; } return true ; }
mjball/Singularity | public String getDirectory ( ) { return directory ; }
mjball/Singularity | public String getFileGlob ( ) { return fileGlob ; }
mjball/Singularity | public String getS3Bucket ( ) { return s3Bucket ; }
mjball/Singularity | public String getS3KeyFormat ( ) { return s3KeyFormat ; }
mjball/Singularity | public boolean isFinished ( ) { return finished ; }
mjball/Singularity | @ Override public String toString ( ) { return " S3UploadMetadata ▁ [ directory = " + directory + " , ▁ fileGlob = " + fileGlob + " , ▁ s3Bucket = " + s3Bucket + " , ▁ s3KeyFormat = " + s3KeyFormat + " , ▁ finished = " + finished + " ] " ; }
kevgraham7/toolbox | public Warrior ( ) { dexterity = generateAttributeValue ( 60 , 70 ) ; }
kevgraham7/toolbox | @ Override public Map < String , Long > getAttributes ( ) { Map < String , Long > attributesMap = new HashMap < String , Long > ( ) ; attributesMap . put ( ATTRIBUTE_LABEL_DEXTERITY , dexterity ) ; return attributesMap ; }
readymanong/ZhbitAPP | public String getUserLoginnum ( ) { return userLoginnum ; }
readymanong/ZhbitAPP | public void setUserLoginnum ( String userLoginnum ) { this . userLoginnum = userLoginnum ; }
readymanong/ZhbitAPP | public String getUserRole ( ) { return userRole ; }
readymanong/ZhbitAPP | public void setUserRole ( String userRole ) { this . userRole = userRole ; }
readymanong/ZhbitAPP | public String getUserMessage ( ) { return userMessage ; }
readymanong/ZhbitAPP | public void setUserMessage ( String userMessage ) { this . userMessage = userMessage ; }
readymanong/ZhbitAPP | public String getUserName ( ) { return userName ; }
readymanong/ZhbitAPP | public void setUserName ( String userName ) { this . userName = userName ; }
baldimir/drools | public CommandBasedStatefulKnowledgeSession ( ExecutableRunner runner ) { this . runner = runner ; }
baldimir/drools | @ Deprecated public int getId ( ) { return runner . execute ( new GetIdCommand ( ) ) . intValue ( ) ; }
baldimir/drools | public long getIdentifier ( ) { return runner . execute ( new GetIdCommand ( ) ) ; }
baldimir/drools | public ProcessInstance getProcessInstance ( long id ) { GetProcessInstanceCommand command = new GetProcessInstanceCommand ( ) ; command . setProcessInstanceId ( id ) ; return runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance getProcessInstance ( long id , boolean readOnly ) { GetProcessInstanceCommand command = new GetProcessInstanceCommand ( ) ; command . setProcessInstanceId ( id ) ; command . setReadOnly ( readOnly ) ; return runner . execute ( command ) ; }
baldimir/drools | public void abortProcessInstance ( long id ) { AbortProcessInstanceCommand command = new AbortProcessInstanceCommand ( ) ; command . setProcessInstanceId ( id ) ; runner . execute ( command ) ; }
baldimir/drools | public ExecutableRunner getRunner ( ) { return runner ; }
baldimir/drools | public Collection < ProcessInstance > getProcessInstances ( ) { return runner . execute ( new GetProcessInstancesCommand ( ) ) ; }
baldimir/drools | public WorkItemManager getWorkItemManager ( ) { if ( workItemManager == null ) { workItemManager = new WorkItemManager ( ) { public void completeWorkItem ( long id , Map < String , Object > results ) { CompleteWorkItemCommand command = new CompleteWorkItemCommand ( ) ; command . setWorkItemId ( id ) ; command . setResults ( results ) ; runner . execute ( command ) ; } public void abortWorkItem ( long id ) { AbortWorkItemCommand command = new AbortWorkItemCommand ( ) ; command . setWorkItemId ( id ) ; runner . execute ( command ) ; } public void registerWorkItemHandler ( String workItemName , WorkItemHandler handler ) { RegisterWorkItemHandlerCommand command = new RegisterWorkItemHandlerCommand ( ) ; command . setWorkItemName ( workItemName ) ; command . setHandler ( handler ) ; runner . execute ( command ) ; } public WorkItem getWorkItem ( long id ) { GetWorkItemCommand command = new GetWorkItemCommand ( ) ; command . setWorkItemId ( id ) ; return runner . execute ( command ) ; } public void clear ( ) { throw new UnsupportedOperationException ( ) ; } public Set < WorkItem > getWorkItems ( ) { throw new UnsupportedOperationException ( ) ; } public void internalAbortWorkItem ( long id ) { throw new UnsupportedOperationException ( ) ; } public void internalAddWorkItem ( WorkItem workItem ) { throw new UnsupportedOperationException ( ) ; } public void internalExecuteWorkItem ( WorkItem workItem ) { throw new UnsupportedOperationException ( ) ; } @ Override public void signalEvent ( String type , Object event ) { SignalEventCommand command = new SignalEventCommand ( type , event ) ; runner . execute ( command ) ; } @ Override public void signalEvent ( String type , Object event , long processInstanceId ) { SignalEventCommand command = new SignalEventCommand ( processInstanceId , type , event ) ; runner . execute ( command ) ; } @ Override public void dispose ( ) { } @ Override public void retryWorkItem ( Long workItemID , Map < String , Object > params ) { ReTryWorkItemCommand command = new ReTryWorkItemCommand ( workItemID , params ) ; runner . execute ( command ) ; } } ; } return workItemManager ; }
baldimir/drools | public void signalEvent ( String type , Object event ) { SignalEventCommand command = new SignalEventCommand ( type , event ) ; runner . execute ( command ) ; }
baldimir/drools | public void signalEvent ( String type , Object event , long processInstanceId ) { SignalEventCommand command = new SignalEventCommand ( processInstanceId , type , event ) ; runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance startProcess ( String processId ) { return startProcess ( processId , null ) ; }
baldimir/drools | public ProcessInstance startProcess ( String processId , Map < String , Object > parameters ) { StartProcessCommand command = new StartProcessCommand ( ) ; command . setProcessId ( processId ) ; command . setParameters ( parameters ) ; return runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance createProcessInstance ( String processId , Map < String , Object > parameters ) { CreateProcessInstanceCommand command = new CreateProcessInstanceCommand ( ) ; command . setProcessId ( processId ) ; command . setParameters ( parameters ) ; return runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance startProcessInstance ( long processInstanceId ) { StartProcessInstanceCommand command = new StartProcessInstanceCommand ( ) ; command . setProcessInstanceId ( processInstanceId ) ; return runner . execute ( command ) ; }
baldimir/drools | public void dispose ( ) { runner . execute ( new DisposeCommand ( ) ) ; }
baldimir/drools | public void destroy ( ) { runner . execute ( new DestroySessionCommand ( runner ) ) ; }
baldimir/drools | public int fireAllRules ( ) { return this . runner . execute ( new FireAllRulesCommand ( ) ) ; }
baldimir/drools | public int fireAllRules ( int max ) { return this . runner . execute ( new FireAllRulesCommand ( max ) ) ; }
baldimir/drools | public int fireAllRules ( AgendaFilter agendaFilter ) { return this . runner . execute ( new FireAllRulesCommand ( agendaFilter ) ) ; }
baldimir/drools | public int fireAllRules ( AgendaFilter agendaFilter , int max ) { return this . runner . execute ( new FireAllRulesCommand ( agendaFilter , max ) ) ; }
baldimir/drools | public void fireUntilHalt ( ) { this . runner . execute ( new FireUntilHaltCommand ( ) ) ; }
baldimir/drools | public void fireUntilHalt ( AgendaFilter agendaFilter ) { this . runner . execute ( new FireUntilHaltCommand ( agendaFilter ) ) ; }
baldimir/drools | public KieBase getKieBase ( ) { return this . runner . execute ( new GetKieBaseCommand ( ) ) ; }
baldimir/drools | public void registerChannel ( String name , Channel channel ) { this . runner . execute ( new RegisterChannelCommand ( name , channel ) ) ; }
baldimir/drools | public void unregisterChannel ( String name ) { this . runner . execute ( new UnregisterChannelCommand ( name ) ) ; }
baldimir/drools | public Map < String , Channel > getChannels ( ) { return ( Map < String , Channel > ) this . runner . execute ( new GetChannelsCommand ( ) ) ; }
baldimir/drools | public Agenda getAgenda ( ) { if ( agenda == null ) { agenda = new Agenda ( ) { public void clear ( ) { ClearAgendaCommand command = new ClearAgendaCommand ( ) ; runner . execute ( command ) ; } public ActivationGroup getActivationGroup ( final String name ) { return new ActivationGroup ( ) { public void clear ( ) { ClearActivationGroupCommand command = new ClearActivationGroupCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } public String getName ( ) { return name ; } } ; } public AgendaGroup getAgendaGroup ( final String name ) { return new AgendaGroup ( ) { public void clear ( ) { ClearAgendaGroupCommand command = new ClearAgendaGroupCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } public String getName ( ) { return name ; } public void setFocus ( ) { AgendaGroupSetFocusCommand command = new AgendaGroupSetFocusCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } } ; } public RuleFlowGroup getRuleFlowGroup ( final String name ) { return new RuleFlowGroup ( ) { public void clear ( ) { ClearRuleFlowGroupCommand command = new ClearRuleFlowGroupCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } public String getName ( ) { return name ; } } ; } } ; } return agenda ; }
baldimir/drools | public FactHandle getFactHandle ( Object object ) { return this . runner . execute ( new GetFactHandleCommand ( object ) ) ; }
baldimir/drools | public < T extends FactHandle > Collection < T > getFactHandles ( ) { return ( Collection < T > ) this . runner . execute ( new GetFactHandlesCommand ( ) ) ; }
baldimir/drools | public < T extends FactHandle > Collection < T > getFactHandles ( ObjectFilter filter ) { return ( Collection < T > ) this . runner . execute ( new GetFactHandlesCommand ( filter ) ) ; }
baldimir/drools | public Collection < ? extends Object > getObjects ( ) { return getObjects ( null ) ; }
baldimir/drools | public Collection < ? extends Object > getObjects ( ObjectFilter filter ) { Collection result = runner . execute ( new GetObjectsCommand ( filter ) ) ; return result ; }
baldimir/drools | public < T extends SessionClock > T getSessionClock ( ) { return ( T ) this . runner . execute ( new GetSessionClockCommand ( ) ) ; }
baldimir/drools | public EntryPoint getEntryPoint ( String name ) { return this . runner . execute ( new GetEntryPointCommand ( name ) ) ; }
baldimir/drools | public Collection < ? extends EntryPoint > getEntryPoints ( ) { return this . runner . execute ( new GetEntryPointsCommand ( ) ) ; }
baldimir/drools | public void halt ( ) { this . runner . execute ( new HaltCommand ( ) ) ; }
baldimir/drools | public FactHandle insert ( Object object ) { return runner . execute ( new InsertObjectCommand ( object ) ) ; }
baldimir/drools | public void submit ( AtomicAction action ) { throw new UnsupportedOperationException ( " It ▁ is ▁ not ▁ necessary ▁ to ▁ use ▁ submit ▁ with ▁ a ▁ command ▁ based ▁ session , ▁ commands ▁ are ▁ already ▁ atomic " ) ; }
baldimir/drools | @ Override public < T > T getKieRuntime ( Class < T > cls ) { throw new UnsupportedOperationException ( " Retrieving ▁ runtimes ▁ is ▁ not ▁ supported ▁ ▁ throught ▁ the ▁ command ▁ based ▁ session ▁ at ▁ this ▁ time . " ) ; }
baldimir/drools | public void retract ( FactHandle handle ) { runner . execute ( new DeleteCommand ( handle ) ) ; }
baldimir/drools | public void delete ( FactHandle handle ) { runner . execute ( new DeleteCommand ( handle ) ) ; }
baldimir/drools | public void delete ( FactHandle handle , FactHandle . State fhState ) { runner . execute ( new DeleteCommand ( handle , fhState ) ) ; }
baldimir/drools | public void update ( FactHandle handle , Object object ) { runner . execute ( new UpdateCommand ( handle , object ) ) ; }
baldimir/drools | public void update ( FactHandle handle , Object object , String ... modifiedProperties ) { runner . execute ( new UpdateCommand ( handle , object , modifiedProperties ) ) ; }
baldimir/drools | public void addEventListener ( RuleRuntimeEventListener listener ) { runner . execute ( new AddEventListenerCommand ( listener ) ) ; }
baldimir/drools | public void addEventListener ( AgendaEventListener listener ) { runner . execute ( new AddEventListenerCommand ( listener ) ) ; }
baldimir/drools | public Collection < AgendaEventListener > getAgendaEventListeners ( ) { return runner . execute ( new GetAgendaEventListenersCommand ( ) ) ; }
baldimir/drools | public Collection < RuleRuntimeEventListener > getRuleRuntimeEventListeners ( ) { return runner . execute ( new GetRuleRuntimeEventListenersCommand ( ) ) ; }
baldimir/drools | public void removeEventListener ( RuleRuntimeEventListener listener ) { runner . execute ( new RemoveEventListenerCommand ( listener ) ) ; }
baldimir/drools | public void removeEventListener ( AgendaEventListener listener ) { runner . execute ( new RemoveEventListenerCommand ( listener ) ) ; }
baldimir/drools | public void addEventListener ( ProcessEventListener listener ) { runner . execute ( new AddEventListenerCommand ( listener ) ) ; }
baldimir/drools | public Collection < ProcessEventListener > getProcessEventListeners ( ) { return runner . execute ( new GetProcessEventListenersCommand ( ) ) ; }
baldimir/drools | public void removeEventListener ( ProcessEventListener listener ) { runner . execute ( new RemoveEventListenerCommand ( listener ) ) ; }
baldimir/drools | public Object getGlobal ( String identifier ) { return runner . execute ( new GetGlobalCommand ( identifier ) ) ; }
baldimir/drools | public void setGlobal ( String identifier , Object object ) { this . runner . execute ( new SetGlobalCommand ( identifier , object ) ) ; }
baldimir/drools | public Globals getGlobals ( ) { return runner . execute ( new GetGlobalsCommand ( ) ) ; }
baldimir/drools | public Calendars getCalendars ( ) { return runner . execute ( new GetCalendarsCommand ( ) ) ; }
baldimir/drools | public Object getObject ( FactHandle factHandle ) { return runner . execute ( new GetObjectCommand ( factHandle ) ) ; }
baldimir/drools | public Environment getEnvironment ( ) { return runner . execute ( new GetEnvironmentCommand ( ) ) ; }
baldimir/drools | public < T > T execute ( Command < T > command ) { return ( T ) this . runner . execute ( command ) ; }
baldimir/drools | public QueryResults getQueryResults ( String query , Object ... arguments ) { QueryCommand cmd = new QueryCommand ( ( String ) null , query , arguments ) ; return this . runner . execute ( cmd ) ; }
baldimir/drools | public String getEntryPointId ( ) { return EntryPointId . DEFAULT . getEntryPointId ( ) ; }
baldimir/drools | public long getFactCount ( ) { return runner . execute ( new GetFactCountCommand ( ) ) ; }
baldimir/drools | public LiveQuery openLiveQuery ( String query , Object [ ] arguments , ViewChangedEventListener listener ) { return null ; }
baldimir/drools | public KieSessionConfiguration getSessionConfiguration ( ) { return ( ( RegistryContext ) runner . createContext ( ) ) . lookup ( KieSession . class ) . getSessionConfiguration ( ) ; }
baldimir/drools | @ Override public ProcessInstance startProcess ( String processId , CorrelationKey correlationKey , Map < String , Object > parameters ) { return this . runner . execute ( new StartCorrelatedProcessCommand ( processId , correlationKey , parameters ) ) ; }
baldimir/drools | @ Override public ProcessInstance createProcessInstance ( String processId , CorrelationKey correlationKey , Map < String , Object > parameters ) { return this . runner . execute ( new CreateCorrelatedProcessInstanceCommand ( processId , correlationKey , parameters ) ) ; }
baldimir/drools | @ Override public ProcessInstance getProcessInstance ( CorrelationKey correlationKey ) { return this . runner . execute ( new GetProcessInstanceByCorrelationKeyCommand ( correlationKey ) ) ; }
baldimir/drools | @ Override public ProcessInstance startProcessFromNodeIds ( String processId , CorrelationKey key , Map < String , Object > params , String ... nodeIds ) { StartProcessFromNodeIdsCommand command = new StartProcessFromNodeIdsCommand ( ) ; command . setProcessId ( processId ) ; command . setParameters ( params ) ; command . setNodeIds ( stream ( nodeIds ) . collect ( Collectors . toList ( ) ) ) ; command . setCorrelationKey ( key ) ; return runner . execute ( command ) ; }
baldimir/drools | @ Override public ProcessInstance startProcessFromNodeIds ( String processId , Map < String , Object > params , String ... nodeIds ) { return startProcessFromNodeIds ( processId , null , params , nodeIds ) ; }
emmanuelbernard/hibernate-validator | public ConstraintHelper ( ) { List < Class < ? extends ConstraintValidator < ? , ? > > > constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( AssertFalseValidator . class ) ; builtinConstraints . put ( AssertFalse . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( AssertTrueValidator . class ) ; builtinConstraints . put ( AssertTrue . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DecimalMaxValidatorForNumber . class ) ; constraintList . add ( DecimalMaxValidatorForString . class ) ; builtinConstraints . put ( DecimalMax . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DecimalMinValidatorForNumber . class ) ; constraintList . add ( DecimalMinValidatorForString . class ) ; builtinConstraints . put ( DecimalMin . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DigitsValidatorForString . class ) ; constraintList . add ( DigitsValidatorForNumber . class ) ; builtinConstraints . put ( Digits . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( FutureValidatorForCalendar . class ) ; constraintList . add ( FutureValidatorForDate . class ) ; if ( isJodaTimeInClasspath ( ) ) { constraintList . add ( FutureValidatorForAbstractInstant . class ) ; constraintList . add ( FutureValidatorForAbstractPartial . class ) ; } builtinConstraints . put ( Future . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( MaxValidatorForNumber . class ) ; constraintList . add ( MaxValidatorForString . class ) ; builtinConstraints . put ( Max . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( MinValidatorForNumber . class ) ; constraintList . add ( MinValidatorForString . class ) ; builtinConstraints . put ( Min . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( NotNullValidator . class ) ; builtinConstraints . put ( NotNull . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( NullValidator . class ) ; builtinConstraints . put ( Null . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( PastValidatorForCalendar . class ) ; constraintList . add ( PastValidatorForDate . class ) ; if ( isJodaTimeInClasspath ( ) ) { constraintList . add ( PastValidatorForAbstractInstant . class ) ; constraintList . add ( PastValidatorForAbstractPartial . class ) ; } builtinConstraints . put ( Past . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( PatternValidator . class ) ; builtinConstraints . put ( Pattern . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( SizeValidatorForString . class ) ; constraintList . add ( SizeValidatorForCollection . class ) ; constraintList . add ( SizeValidatorForArray . class ) ; constraintList . add ( SizeValidatorForMap . class ) ; constraintList . add ( SizeValidatorForArraysOfBoolean . class ) ; constraintList . add ( SizeValidatorForArraysOfByte . class ) ; constraintList . add ( SizeValidatorForArraysOfChar . class ) ; constraintList . add ( SizeValidatorForArraysOfDouble . class ) ; constraintList . add ( SizeValidatorForArraysOfFloat . class ) ; constraintList . add ( SizeValidatorForArraysOfInt . class ) ; constraintList . add ( SizeValidatorForArraysOfLong . class ) ; builtinConstraints . put ( Size . class , constraintList ) ; }
emmanuelbernard/hibernate-validator | public List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > getBuiltInConstraints ( Class < ? extends Annotation > annotationClass ) { final List < Class < ? extends ConstraintValidator < ? , ? > > > builtInList = builtinConstraints . get ( annotationClass ) ; if ( builtInList == null || builtInList . size ( ) == 0 ) { throw new ValidationException ( " Unable ▁ to ▁ find ▁ constraints ▁ for ▁ ▁ " + annotationClass ) ; } List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > constraints = new ArrayList < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > ( builtInList . size ( ) ) ; for ( Class < ? extends ConstraintValidator < ? , ? > > validatorClass : builtInList ) { @ SuppressWarnings ( " unchecked " ) Class < ConstraintValidator < ? extends Annotation , ? > > safeValidatorClass = ( Class < ConstraintValidator < ? extends Annotation , ? > > ) validatorClass ; constraints . add ( safeValidatorClass ) ; } return constraints ; }
emmanuelbernard/hibernate-validator | public boolean isBuiltinConstraint ( Class < ? extends Annotation > annotationType ) { return builtinConstraints . containsKey ( annotationType ) ; }
emmanuelbernard/hibernate-validator | public boolean isMultiValueConstraint ( Class < ? extends Annotation > annotationType ) { boolean isMultiValueConstraint = false ; final Method method = ReflectionHelper . getMethod ( annotationType , " value " ) ; if ( method != null ) { Class returnType = method . getReturnType ( ) ; if ( returnType . isArray ( ) && returnType . getComponentType ( ) . isAnnotation ( ) ) { @ SuppressWarnings ( " unchecked " ) Class < ? extends Annotation > componentType = ( Class < ? extends Annotation > ) returnType . getComponentType ( ) ; if ( isConstraintAnnotation ( componentType ) || isBuiltinConstraint ( componentType ) ) { isMultiValueConstraint = true ; } else { isMultiValueConstraint = false ; } } } return isMultiValueConstraint ; }
emmanuelbernard/hibernate-validator | public < A extends Annotation > List < Annotation > getMultiValueConstraints ( A annotation ) { List < Annotation > annotationList = new ArrayList < Annotation > ( ) ; try { final Method method = ReflectionHelper . getMethod ( annotation . getClass ( ) , " value " ) ; if ( method != null ) { Class returnType = method . getReturnType ( ) ; if ( returnType . isArray ( ) && returnType . getComponentType ( ) . isAnnotation ( ) ) { Annotation [ ] annotations = ( Annotation [ ] ) method . invoke ( annotation ) ; for ( Annotation a : annotations ) { Class < ? extends Annotation > annotationType = a . annotationType ( ) ; if ( isConstraintAnnotation ( annotationType ) || isBuiltinConstraint ( annotationType ) ) { annotationList . add ( a ) ; } } } } } catch ( IllegalAccessException iae ) { } catch ( InvocationTargetException ite ) { } return annotationList ; }
emmanuelbernard/hibernate-validator | public boolean isConstraintAnnotation ( Class < ? extends Annotation > annotationType ) { Constraint constraint = annotationType . getAnnotation ( Constraint . class ) ; if ( constraint == null ) { return false ; } assertMessageParameterExists ( annotationType ) ; assertGroupsParameterExists ( annotationType ) ; assertPayloadParameterExists ( annotationType ) ; assertNoParameterStartsWithValid ( annotationType ) ; return true ; }
emmanuelbernard/hibernate-validator | private void assertNoParameterStartsWithValid ( Class < ? extends Annotation > annotationType ) { final Method [ ] methods = ReflectionHelper . getMethods ( annotationType ) ; for ( Method m : methods ) { if ( m . getName ( ) . startsWith ( " valid " ) ) { String msg = " Parameters ▁ starting ▁ with ▁ ' valid ' ▁ are ▁ not ▁ allowed ▁ in ▁ a ▁ constraint . " ; throw new ConstraintDefinitionException ( msg ) ; } } }
emmanuelbernard/hibernate-validator | private void assertPayloadParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " payload " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ payload ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } Class < ? > [ ] defaultPayload = ( Class < ? > [ ] ) method . getDefaultValue ( ) ; if ( defaultPayload . length != 0 ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ payload ▁ " + " parameter ▁ default ▁ value ▁ is ▁ not ▁ the ▁ empty ▁ array . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " payload ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
emmanuelbernard/hibernate-validator | private void assertGroupsParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " groups " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ groups ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } Class < ? > [ ] defaultGroups = ( Class < ? > [ ] ) method . getDefaultValue ( ) ; if ( defaultGroups . length != 0 ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ groups ▁ " + " parameter ▁ default ▁ value ▁ is ▁ not ▁ the ▁ empty ▁ array . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " groups ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
emmanuelbernard/hibernate-validator | private void assertMessageParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " message " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ message ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } if ( method . getReturnType ( ) != String . class ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ message ▁ parameter ▁ " + " is ▁ not ▁ of ▁ type ▁ java . lang . String . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " groups ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
emmanuelbernard/hibernate-validator | public < T extends Annotation > List < Class < ? extends ConstraintValidator < T , ? > > > getConstraintValidatorDefinition ( Class < T > annotationClass ) { if ( annotationClass == null ) { throw new IllegalArgumentException ( " Class ▁ cannot ▁ be ▁ null " ) ; } final List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > list = constraintValidatorDefinitions . get ( annotationClass ) ; List < Class < ? extends ConstraintValidator < T , ? > > > constraintsValidators = new ArrayList < Class < ? extends ConstraintValidator < T , ? > > > ( list . size ( ) ) ; for ( Class < ? extends ConstraintValidator < ? , ? > > validatorClass : list ) { @ SuppressWarnings ( " unchecked " ) Class < ConstraintValidator < T , ? > > safeValidatorClass = ( Class < ConstraintValidator < T , ? > > ) validatorClass ; constraintsValidators . add ( safeValidatorClass ) ; } return constraintsValidators ; }
emmanuelbernard/hibernate-validator | public < A extends Annotation > void addConstraintValidatorDefinition ( Class < A > annotationClass , List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > definitionClasses ) { constraintValidatorDefinitions . putIfAbsent ( annotationClass , definitionClasses ) ; }
emmanuelbernard/hibernate-validator | public boolean containsConstraintValidatorDefinition ( Class < ? extends Annotation > annotationClass ) { return constraintValidatorDefinitions . containsKey ( annotationClass ) ; }
emmanuelbernard/hibernate-validator | public boolean isConstraintComposition ( Class < ? extends Annotation > annotationType ) { return annotationType == ConstraintComposition . class ; }
emmanuelbernard/hibernate-validator | private boolean isJodaTimeInClasspath ( ) { boolean isInClasspath ; try { ReflectionHelper . loadClass ( JODA_TIME_class_NAME , this . getClass ( ) ) ; isInClasspath = true ; } catch ( ValidationException e ) { isInClasspath = false ; } return isInClasspath ; }
AJ-72/testng | @ Test ( dataProvider = " dp _ name " ) public void should_find_exactly_one_data_provider ( boolean b ) { }
AJ-72/testng | @ DataProvider ( name = " dp _ name " ) Object [ ] [ ] whatever_implicit_name ( ) { return new Object [ ] [ ] { { true } } ; }
AJ-72/testng | @ DataProvider ( name = " whatever _ explicit _ name " ) Object [ ] [ ] dp_name ( ) { return new Object [ ] [ ] { { false } } ; }
nodchip/QMAClone | private final Runnable saveServerStatusRunner = new Runnable ( ) { public void run ( ) { saveServerStatus ( ) ; } }
nodchip/QMAClone | private final Runnable updateLoginUsersRunner = new Runnable ( ) { public void run ( ) { updateLoginUsers ( ) ; } }
nodchip/QMAClone | private final Runnable updateServerStatusRunner = new Runnable ( ) { @ Override public void run ( ) { try { updateServerStatus ( ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " サーバーステータスの更新に失敗しました " , e ) ; } } }
nodchip/QMAClone | @ Inject public ServerStatusManager ( Database database , GameManager gameManager , NormalModeProblemManager normalModeProblemManager , PlayerHistoryManager playerHistoryManager , MessageSender < PacketServerStatus > serverStatusMessageSender , ThreadPool threadPool ) { this . database = Preconditions . checkNotNull ( database ) ; this . gameManager = Preconditions . checkNotNull ( gameManager ) ; this . normalModeProblemManager = Preconditions . checkNotNull ( normalModeProblemManager ) ; this . playerHistoryManager = Preconditions . checkNotNull ( playerHistoryManager ) ; this . serverStatusMessageSender = Preconditions . checkNotNull ( serverStatusMessageSender ) ; threadPool . addMinuteTasks ( saveServerStatusRunner ) ; threadPool . addMinuteTasks ( updateLoginUsersRunner ) ; threadPool . scheduleAtFixedRate ( updateServerStatusRunner , UPDATE_DURATION , UPDATE_DURATION , TimeUnit . SECONDS ) ; try { updateServerStatus ( ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " サーバーステータスの更新に失敗しました " , e ) ; } loadPageView ( ) ; }
nodchip/QMAClone | private void loadPageView ( ) { PageView pageView ; try { pageView = database . loadPageView ( ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " ページビューの読み込みに失敗しました " , e ) ; return ; } numberOfPageView . addAndGet ( pageView . numberOfPageView ) ; numberOfTotalSessions . addAndGet ( pageView . numberOfSessions ) ; numberOfTotalPlayers . addAndGet ( pageView . numberOfPlayers ) ; }
nodchip/QMAClone | public void login ( ) { numberOfPageView . getAndIncrement ( ) ; }
nodchip/QMAClone | @ VisibleForTesting void updateServerStatus ( ) throws DatabaseException { PacketServerStatus status = new PacketServerStatus ( ) ; status . numberOfCurrentSessions = numberOfCurrentSessions . get ( ) ; status . numberOfTotalSessions = numberOfTotalSessions . get ( ) ; status . numberOfCurrentPlayers = numberOfCurrentPlayers . get ( ) ; status . numberOfTotalPlayers = numberOfTotalPlayers . get ( ) ; status . numberOfProblems = normalModeProblemManager . getNumberOfProblem ( ) ; status . numberOfPageView = numberOfPageView . get ( ) ; status . numberOfLoginPlayers = Math . max ( loginUsers . size ( ) , loginUserCodes . size ( ) ) ; status . numberOfActivePlayers = database . getNumberOfActiveUsers ( ) ; status . numberOfPlayersInWhole = gameManager . getNumberOfPlayersInWhole ( ) ; status . lastestPlayers = playerHistoryManager . get ( ) ; if ( Objects . equal ( serverStatus , status ) ) { return ; } serverStatus = status ; serverStatusMessageSender . send ( status ) ; }
nodchip/QMAClone | public PacketServerStatus getServerStatus ( ) { return serverStatus ; }
nodchip/QMAClone | public void saveServerStatus ( ) { PageView pageView = new PageView ( ) ; pageView . numberOfPageView = numberOfPageView . get ( ) ; pageView . numberOfPlayers = numberOfTotalPlayers . get ( ) ; pageView . numberOfSessions = numberOfTotalSessions . get ( ) ; if ( pageView . numberOfPageView < 10000 || pageView . numberOfPlayers < 10000 || pageView . numberOfSessions < 10000 ) { logger . info ( " ページビューが読み込まれていない可能性があります 。 再読み込みを行います 。 " ) ; loadPageView ( ) ; return ; } try { database . savePageView ( pageView ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " ページビューの保存に失敗しました " , e ) ; } }
nodchip/QMAClone | public void keepAlive ( int userCode ) { loginUserCodes . add ( userCode ) ; }
nodchip/QMAClone | public List < PacketUserData > getLoginUsers ( ) { return loginUsers ; }
nodchip/QMAClone | private void updateLoginUsers ( ) { Set < Integer > userCodes = loginUserCodes ; loginUserCodes = Collections . synchronizedSet ( new HashSet < Integer > ( ) ) ; List < PacketUserData > list = Lists . newArrayList ( ) ; for ( int userCode : userCodes ) { try { list . add ( database . getUserData ( userCode ) ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " ユーザー情報の読み込みに失敗しました " , e ) ; } } loginUsers = list ; }
nodchip/QMAClone | public void changeStatics ( int sessionDelta , int playDelta ) { numberOfCurrentSessions . set ( gameManager . getNumberOfSessions ( ) ) ; numberOfCurrentPlayers . set ( gameManager . getNumberOfPlayers ( ) ) ; numberOfTotalSessions . addAndGet ( sessionDelta ) ; numberOfTotalPlayers . addAndGet ( playDelta ) ; }
nodchip/QMAClone | public MessageSender < PacketServerStatus > getServerStatusMessageSender ( ) { return serverStatusMessageSender ; }
caidongyun/hipster | public AbstractNode ( N previousNode , S state , A action ) { this . previousNode = previousNode ; this . state = state ; this . action = action ; }
caidongyun/hipster | @ Override public List < N > path ( ) { LinkedList < N > path = new LinkedList < N > ( ) ; N currentNode = ( N ) this ; while ( currentNode != null ) { path . addFirst ( currentNode ) ; currentNode = currentNode . previousNode ; } return path ; }
caidongyun/hipster | @ Override public N previousNode ( ) { return this . previousNode ; }
caidongyun/hipster | @ Override public S state ( ) { return state ; }
caidongyun/hipster | @ Override public A action ( ) { return action ; }
caidongyun/hipster | @ Override public String toString ( ) { return " Node { " + " action = " + action + " , ▁ state = " + this . state ( ) + ' } ' ; }
StCostea/k3po | public AstLongLengthBytesMatcher ( String captureName , ExpressionContext environment ) { super ( Long . SIZE / Byte . SIZE , captureName , environment ) ; }
StCostea/k3po | @ Override protected void describe ( StringBuilder buf ) { String captureName = getCaptureName ( ) ; if ( captureName == null ) { buf . append ( " long " ) ; } else { buf . append ( format ( " ( long : % s ) " , captureName ) ) ; } }
StCostea/k3po | @ Override public < R , P > R accept ( Visitor < R , P > visitor , P parameter ) { return visitor . visit ( this , parameter ) ; }
njacinto/Utils | public CollectionFilterIterator ( Iterator < T > it , Predicate < T > predicate ) { this . it = it != null ? it : Collections . emptyIterator ( ) ; this . predicate = predicate != null ? predicate : TruePredicate . getInstance ( ) ; this . next = getNext ( ) ; }
njacinto/Utils | public CollectionFilterIterator ( Iterable < T > collection , Predicate < T > predicate ) { this ( collection != null ? collection . iterator ( ) : null , predicate ) ; }
njacinto/Utils | @ Override public boolean hasNext ( ) { return next != END ; }
njacinto/Utils | @ Override public T next ( ) { if ( next == END ) { throw new NoSuchElementException ( " The ▁ underline ▁ collection ▁ has ▁ no ▁ elements . " ) ; } T ret = next ; next = getNext ( ) ; return ret ; }
njacinto/Utils | @ Override public void remove ( ) { throw new UnsupportedOperationException ( " The ▁ iterator ▁ doesn ' t ▁ allow ▁ changes . " ) ; }
njacinto/Utils | protected T getNext ( ) { T tmp ; while ( it . hasNext ( ) ) { if ( predicate . test ( tmp = it . next ( ) ) ) { return tmp ; } } return ( T ) END ; }
zhizhounq/azkaban-customization | @ Override public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; AzkabanWebServer server = ( AzkabanWebServer ) getApplication ( ) ; projectManager = server . getProjectManager ( ) ; scheduleManager = server . getScheduleManager ( ) ; }
zhizhounq/azkaban-customization | if ( hasParam ( req , " ajax " ) ) { handleAJAXAction ( req , resp , session ) ; }
zhizhounq/azkaban-customization | else if ( hasParam ( req , " calendar " ) ) { handleGetScheduleCalendar ( req , resp , session ) ; }
zhizhounq/azkaban-customization | if ( ajaxName . equals ( " slaInfo " ) ) { ajaxSlaInfo ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " setSla " ) ) { ajaxSetSla ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " loadFlow " ) ) { ajaxLoadFlows ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " loadHistory " ) ) { ajaxLoadHistory ( req , resp , session . getUser ( ) ) ; ret = null ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " scheduleFlow " ) ) { ajaxScheduleFlow ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " fetchSchedule " ) ) { ajaxFetchSchedule ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | if ( ret != null ) { this . writeJSON ( resp , ret ) ; }
zhizhounq/azkaban-customization | private void ajaxSetSla ( HttpServletRequest req , HashMap < String , Object > ret , User user ) { try { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched = scheduleManager . getSchedule ( scheduleId ) ; Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( ! hasPermission ( project , user , Permission . Type . SCHEDULE ) ) { ret . put ( " error " , " User ▁ " + user + " ▁ does ▁ not ▁ have ▁ permission ▁ to ▁ set ▁ SLA ▁ for ▁ this ▁ flow . " ) ; return ; } String emailStr = getParam ( req , " slaEmails " ) ; String [ ] emailSplit = emailStr . split ( " \\ s * , \\ s * | \\ s * ; \\ s * | \\ s + " ) ; List < String > slaEmails = Arrays . asList ( emailSplit ) ; Map < String , String > settings = getParamGroup ( req , " settings " ) ; List < SlaOption > slaOptions = new ArrayList < SlaOption > ( ) ; for ( String set : settings . keySet ( ) ) { SlaOption sla ; try { sla = parseSlaSetting ( settings . get ( set ) ) ; } catch ( Exception e ) { throw new ServletException ( e ) ; } if ( sla != null ) { sla . getInfo ( ) . put ( SlaOption . INFO_FLOW_NAME , sched . getFlowName ( ) ) ; sla . getInfo ( ) . put ( SlaOption . INFO_EMAIL_LIST , slaEmails ) ; slaOptions . add ( sla ) ; } } sched . setSlaOptions ( slaOptions ) ; scheduleManager . insertSchedule ( sched ) ; if ( slaOptions != null ) { projectManager . postProjectEvent ( project , EventType . SLA , user . getUserId ( ) , " SLA ▁ for ▁ flow ▁ " + sched . getFlowName ( ) + " ▁ has ▁ been ▁ added / changed . " ) ; } } catch ( ServletException e ) { ret . put ( " error " , e . getMessage ( ) ) ; } catch ( ScheduleManagerException e ) { ret . put ( " error " , e . getMessage ( ) ) ; } }
zhizhounq/azkaban-customization | private SlaOption parseSlaSetting ( String set ) throws ScheduleManagerException { logger . info ( " Tryint ▁ to ▁ set ▁ sla ▁ with ▁ the ▁ following ▁ set : ▁ " + set ) ; String slaType ; List < String > slaActions = new ArrayList < String > ( ) ; Map < String , Object > slaInfo = new HashMap < String , Object > ( ) ; String [ ] parts = set . split ( " , " , - 1 ) ; String id = parts [ 0 ] ; String rule = parts [ 1 ] ; String duration = parts [ 2 ] ; String emailAction = parts [ 3 ] ; String killAction = parts [ 4 ] ; if ( emailAction . equals ( " true " ) || killAction . equals ( " true " ) ) { if ( emailAction . equals ( " true " ) ) { slaActions . add ( SlaOption . ACTION_ALERT ) ; slaInfo . put ( SlaOption . ALERT_TYPE , " email " ) ; } if ( killAction . equals ( " true " ) ) { slaActions . add ( SlaOption . ACTION_CANCEL_FLOW ) ; } if ( id . equals ( " " ) ) { if ( rule . equals ( " SUCCESS " ) ) { slaType = SlaOption . TYPE_FLOW_SUCCEED ; } else { slaType = SlaOption . TYPE_FLOW_FINISH ; } } else { slaInfo . put ( SlaOption . INFO_JOB_NAME , id ) ; if ( rule . equals ( " SUCCESS " ) ) { slaType = SlaOption . TYPE_JOB_SUCCEED ; } else { slaType = SlaOption . TYPE_JOB_FINISH ; } } ReadablePeriod dur ; try { dur = parseDuration ( duration ) ; } catch ( Exception e ) { throw new ScheduleManagerException ( " Unable ▁ to ▁ parse ▁ duration ▁ for ▁ a ▁ SLA ▁ that ▁ needs ▁ to ▁ take ▁ actions ! " , e ) ; } slaInfo . put ( SlaOption . INFO_DURATION , Utils . createPeriodString ( dur ) ) ; SlaOption r = new SlaOption ( slaType , slaActions , slaInfo ) ; logger . info ( " Parsing ▁ sla ▁ as ▁ id : " + id + " ▁ type : " + slaType + " ▁ rule : " + rule + " ▁ Duration : " + duration + " ▁ actions : " + slaActions ) ; return r ; } return null ; }
zhizhounq/azkaban-customization | private ReadablePeriod parseDuration ( String duration ) { int hour = Integer . parseInt ( duration . split ( " : " ) [ 0 ] ) ; int min = Integer . parseInt ( duration . split ( " : " ) [ 1 ] ) ; return Minutes . minutes ( min + hour * 60 ) . toPeriod ( ) ; }
zhizhounq/azkaban-customization | private void ajaxFetchSchedule ( HttpServletRequest req , HashMap < String , Object > ret , User user ) throws ServletException { int projectId = getIntParam ( req , " projectId " ) ; String flowId = getParam ( req , " flowId " ) ; try { Schedule schedule = scheduleManager . getSchedule ( projectId , flowId ) ; if ( schedule != null ) { Map < String , String > jsonObj = new HashMap < String , String > ( ) ; jsonObj . put ( " scheduleId " , Integer . toString ( schedule . getScheduleId ( ) ) ) ; jsonObj . put ( " submitUser " , schedule . getSubmitUser ( ) ) ; jsonObj . put ( " firstSchedTime " , utils . formatDateTime ( schedule . getFirstSchedTime ( ) ) ) ; jsonObj . put ( " nextExecTime " , utils . formatDateTime ( schedule . getNextExecTime ( ) ) ) ; jsonObj . put ( " period " , utils . formatPeriod ( schedule . getPeriod ( ) ) ) ; ret . put ( " schedule " , jsonObj ) ; } } catch ( ScheduleManagerException e ) { ret . put ( " error " , e ) ; } }
zhizhounq/azkaban-customization | private void ajaxSlaInfo ( HttpServletRequest req , HashMap < String , Object > ret , User user ) { int scheduleId ; try { scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched = scheduleManager . getSchedule ( scheduleId ) ; Project project = getProjectAjaxByPermission ( ret , sched . getProjectId ( ) , user , Type . READ ) ; if ( project == null ) { ret . put ( " error " , " Error ▁ loading ▁ project . ▁ Project ▁ " + sched . getProjectId ( ) + " ▁ doesn ' t ▁ exist " ) ; return ; } Flow flow = project . getFlow ( sched . getFlowName ( ) ) ; if ( flow == null ) { ret . put ( " error " , " Error ▁ loading ▁ flow . ▁ Flow ▁ " + sched . getFlowName ( ) + " ▁ doesn ' t ▁ exist ▁ in ▁ " + sched . getProjectId ( ) ) ; return ; } List < SlaOption > slaOptions = sched . getSlaOptions ( ) ; ExecutionOptions flowOptions = sched . getExecutionOptions ( ) ; if ( slaOptions != null && slaOptions . size ( ) > 0 ) { ret . put ( " slaEmails " , slaOptions . get ( 0 ) . getInfo ( ) . get ( SlaOption . INFO_EMAIL_LIST ) ) ; List < Object > setObj = new ArrayList < Object > ( ) ; for ( SlaOption sla : slaOptions ) { setObj . add ( sla . toWebObject ( ) ) ; } ret . put ( " settings " , setObj ) ; } else if ( flowOptions != null ) { if ( flowOptions . getFailureEmails ( ) != null ) { List < String > emails = flowOptions . getFailureEmails ( ) ; if ( emails . size ( ) > 0 ) { ret . put ( " slaEmails " , emails ) ; } } } else { if ( flow . getFailureEmails ( ) != null ) { List < String > emails = flow . getFailureEmails ( ) ; if ( emails . size ( ) > 0 ) { ret . put ( " slaEmails " , emails ) ; } } } List < String > allJobs = new ArrayList < String > ( ) ; for ( Node n : flow . getNodes ( ) ) { allJobs . add ( n . getId ( ) ) ; } ret . put ( " allJobNames " , allJobs ) ; } catch ( ServletException e ) { ret . put ( " error " , e ) ; } catch ( ScheduleManagerException e ) { ret . put ( " error " , e ) ; } }
zhizhounq/azkaban-customization | protected Project getProjectAjaxByPermission ( Map < String , Object > ret , int projectId , User user , Permission . Type type ) { Project project = projectManager . getProject ( projectId ) ; if ( project == null ) { ret . put ( " error " , " Project ▁ ' " + project + " ' ▁ not ▁ found . " ) ; } else if ( ! hasPermission ( project , user , type ) ) { ret . put ( " error " , " User ▁ ' " + user . getUserId ( ) + " ' ▁ doesn ' t ▁ have ▁ " + type . name ( ) + " ▁ permissions ▁ on ▁ " + project . getName ( ) ) ; } else { return project ; } return null ; }
zhizhounq/azkaban-customization | catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; }
zhizhounq/azkaban-customization | catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; }
zhizhounq/azkaban-customization | if ( hasParam ( req , " ajax " ) ) { handleAJAXAction ( req , resp , session ) ; }
zhizhounq/azkaban-customization | if ( hasParam ( req , " action " ) ) { String action = getParam ( req , " action " ) ; if ( action . equals ( " scheduleFlow " ) ) { ajaxScheduleFlow ( req , ret , session . getUser ( ) ) ; } else if ( action . equals ( " removeSched " ) ) { ajaxRemoveSched ( req , ret , session . getUser ( ) ) ; } else if ( action . equals ( " disableSched " ) ) { ajaxDisableSched ( req , ret , session . getUser ( ) ) ; } else if ( action . equals ( " enableSched " ) ) { ajaxEnableSched ( req , ret , session . getUser ( ) ) ; } }
zhizhounq/azkaban-customization | private void ajaxLoadFlows ( HttpServletRequest req , HashMap < String , Object > ret , User user ) throws ServletException { List < Schedule > schedules ; try { schedules = scheduleManager . getSchedules ( ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( schedules . size ( ) <= 0 ) return ; List < HashMap < String , Object > > output = new ArrayList < HashMap < String , Object > > ( ) ; ret . put ( " items " , output ) ; for ( Schedule schedule : schedules ) { try { writeScheduleData ( output , schedule ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } } }
zhizhounq/azkaban-customization | private void writeScheduleData ( List < HashMap < String , Object > > output , Schedule schedule ) throws ScheduleManagerException { Map < String , Object > stats = ScheduleStatisticManager . getStatistics ( schedule . getScheduleId ( ) , ( AzkabanWebServer ) getApplication ( ) ) ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " scheduleid " , schedule . getScheduleId ( ) ) ; data . put ( " flowname " , schedule . getFlowName ( ) ) ; data . put ( " projectname " , schedule . getProjectName ( ) ) ; data . put ( " time " , schedule . getFirstSchedTime ( ) ) ; DateTime time = DateTime . now ( ) ; long period = 0 ; if ( schedule . getPeriod ( ) != null ) { period = time . plus ( schedule . getPeriod ( ) ) . getMillis ( ) - time . getMillis ( ) ; } data . put ( " period " , period ) ; int length = 3600 * 1000 ; if ( stats . get ( " average " ) != null && stats . get ( " average " ) instanceof Integer ) { length = ( int ) ( Integer ) stats . get ( " average " ) ; if ( length == 0 ) { length = 3600 * 1000 ; } } data . put ( " length " , length ) ; data . put ( " history " , false ) ; data . put ( " stats " , stats ) ; output . add ( data ) ; }
zhizhounq/azkaban-customization | if ( startTime < today ) { useCache = true ; }
zhizhounq/azkaban-customization | if ( useCache ) { boolean cacheExists = false ; synchronized ( this ) { cacheExists = cache . exists ( ) && cache . isFile ( ) ; } if ( cacheExists ) { InputStream cacheInput = new BufferedInputStream ( new FileInputStream ( cache ) ) ; IOUtils . copy ( cacheInput , resp . getOutputStream ( ) ) ; return ; } }
zhizhounq/azkaban-customization | catch ( ExecutorManagerException e ) { logger . error ( e ) ; }
zhizhounq/azkaban-customization | for ( ExecutableFlow historyItem : history ) { if ( historyItem . getScheduleId ( ) >= 0 || loadAll != 0 ) { writeHistoryData ( output , historyItem ) ; } }
zhizhounq/azkaban-customization | synchronized ( this ) { if ( ! useCache || cache . exists ( ) ) { JSONUtils . toJSON ( ret , resp . getOutputStream ( ) , false ) ; return ; } }
zhizhounq/azkaban-customization | synchronized ( this ) { cacheTemp . renameTo ( cache ) ; }
zhizhounq/azkaban-customization | private void writeHistoryData ( List < HashMap < String , Object > > output , ExecutableFlow history ) { HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " scheduleid " , history . getScheduleId ( ) ) ; Project project = projectManager . getProject ( history . getProjectId ( ) ) ; data . put ( " flowname " , history . getFlowId ( ) ) ; data . put ( " projectname " , project . getName ( ) ) ; data . put ( " time " , history . getStartTime ( ) ) ; data . put ( " period " , "0" ) ; long endTime = history . getEndTime ( ) ; if ( endTime == - 1 ) { endTime = System . currentTimeMillis ( ) ; } data . put ( " length " , endTime - history . getStartTime ( ) ) ; data . put ( " history " , true ) ; data . put ( " status " , history . getStatus ( ) . getNumVal ( ) ) ; output . add ( data ) ; }
zhizhounq/azkaban-customization | private void ajaxRemoveSched ( HttpServletRequest req , Map < String , Object > ret , User user ) throws ServletException { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched ; try { sched = scheduleManager . getSchedule ( scheduleId ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( sched == null ) { ret . put ( " message " , " Schedule ▁ with ▁ ID ▁ " + scheduleId + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + sched . getProjectId ( ) + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ remove ▁ schedule ▁ with ▁ id ▁ " + scheduleId ) ; return ; } scheduleManager . removeSchedule ( sched ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ▁ has ▁ removed ▁ schedule ▁ " + sched . getScheduleName ( ) ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + sched . toString ( ) + " ▁ has ▁ been ▁ removed . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , " flow ▁ " + sched . getFlowName ( ) + " ▁ removed ▁ from ▁ Schedules . " ) ; return ; }
zhizhounq/azkaban-customization | private void ajaxDisableSched ( HttpServletRequest req , Map < String , Object > ret , User user ) throws ServletException { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched ; try { sched = scheduleManager . getSchedule ( scheduleId ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( sched == null ) { ret . put ( " message " , " Schedule ▁ with ▁ ID ▁ " + scheduleId + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + sched . getProjectId ( ) + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ disable ▁ schedule ▁ with ▁ id ▁ " + scheduleId ) ; return ; } scheduleManager . disableSchedule ( sched ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ▁ has ▁ disabled ▁ schedule ▁ " + sched . getScheduleName ( ) ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + sched . toString ( ) + " ▁ has ▁ been ▁ disabled . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , " flow ▁ " + sched . getFlowName ( ) + " ▁ disabled ▁ from ▁ Schedules . " ) ; return ; }
zhizhounq/azkaban-customization | private void ajaxEnableSched ( HttpServletRequest req , Map < String , Object > ret , User user ) throws ServletException { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched ; try { sched = scheduleManager . getSchedule ( scheduleId ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( sched == null ) { ret . put ( " message " , " Schedule ▁ with ▁ ID ▁ " + scheduleId + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + sched . getProjectId ( ) + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ enable ▁ schedule ▁ with ▁ id ▁ " + scheduleId ) ; return ; } scheduleManager . enableSchedule ( sched ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ▁ has ▁ enabled ▁ schedule ▁ " + sched . getScheduleName ( ) ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + sched . toString ( ) + " ▁ has ▁ been ▁ enabled . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , " flow ▁ " + sched . getFlowName ( ) + " ▁ enabled ▁ from ▁ Schedules . " ) ; return ; }
zhizhounq/azkaban-customization | private void ajaxScheduleFlow ( HttpServletRequest req , HashMap < String , Object > ret , User user ) throws ServletException { String projectName = getParam ( req , " projectName " ) ; String flowName = getParam ( req , " flow " ) ; int projectId = getIntParam ( req , " projectId " ) ; Project project = projectManager . getProject ( projectId ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + projectName + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ execute ▁ " + flowName ) ; return ; } Flow flow = project . getFlow ( flowName ) ; if ( flow == null ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Flow ▁ " + flowName + " ▁ cannot ▁ be ▁ found ▁ in ▁ project ▁ " + project ) ; return ; } String scheduleTime = getParam ( req , " scheduleTime " ) ; String scheduleDate = getParam ( req , " scheduleDate " ) ; DateTime firstSchedTime ; try { firstSchedTime = parseDateTime ( scheduleDate , scheduleTime ) ; } catch ( Exception e ) { ret . put ( " error " , " Invalid ▁ date ▁ and / or ▁ time ▁ ' " + scheduleDate + " ▁ " + scheduleTime ) ; return ; } ReadablePeriod thePeriod = null ; try { if ( hasParam ( req , " is _ recurring " ) && getParam ( req , " is _ recurring " ) . equals ( " on " ) ) { thePeriod = Schedule . parsePeriodString ( getParam ( req , " period " ) ) ; } } catch ( Exception e ) { ret . put ( " error " , e . getMessage ( ) ) ; } ExecutionOptions flowOptions = null ; try { flowOptions = HttpRequestUtils . parseFlowOptions ( req ) ; } catch ( Exception e ) { ret . put ( " error " , e . getMessage ( ) ) ; } int scheduleRetries = Trigger . TRIGGER_RETRIES ; Boolean retriesCheck = false ; try { if ( hasParam ( req , " retriesCheck " ) && getParam ( req , " retriesCheck " ) . equals ( " on " ) ) { retriesCheck = true ; scheduleRetries = getIntParam ( req , " scheduleRetries " ) ; } } catch ( Exception e ) { ret . put ( " error " , e . getMessage ( ) ) ; } List < SlaOption > slaOptions = null ; Schedule schedule = scheduleManager . scheduleFlow ( - 1 , projectId , projectName , flowName , TriggerStatus . READY . toString ( ) , firstSchedTime . getMillis ( ) , firstSchedTime . getZone ( ) , thePeriod , DateTime . now ( ) . getMillis ( ) , firstSchedTime . getMillis ( ) , firstSchedTime . getMillis ( ) , user . getUserId ( ) , flowOptions , slaOptions , retriesCheck , scheduleRetries ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ' ▁ has ▁ scheduled ▁ " + " [ " + projectName + flowName + " ▁ ( " + projectId + " ) " + " ] . " ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + schedule . toString ( ) + " ▁ has ▁ been ▁ added . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , projectName + " . " + flowName + " ▁ scheduled . " ) ; }
zhizhounq/azkaban-customization | private DateTime parseDateTime ( String scheduleDate , String scheduleTime ) { String [ ] parts = scheduleTime . split ( " , " , - 1 ) ; int hour = Integer . parseInt ( parts [ 0 ] ) ; int minutes = Integer . parseInt ( parts [ 1 ] ) ; boolean isPm = parts [ 2 ] . equalsIgnoreCase ( " pm " ) ; DateTimeZone timezone = parts [ 3 ] . equals ( " UTC " ) ? DateTimeZone . UTC : DateTimeZone . getDefault ( ) ; DateTime day = null ; if ( scheduleDate == null || scheduleDate . trim ( ) . length ( ) == 0 ) { day = new LocalDateTime ( ) . toDateTime ( ) ; } else { day = DateTimeFormat . forPattern ( " MM / dd / yyyy " ) . withZone ( timezone ) . parseDateTime ( scheduleDate ) ; } hour %= 12 ; if ( isPm ) hour += 12 ; DateTime firstSchedTime = day . withHourOfDay ( hour ) . withMinuteOfHour ( minutes ) . withSecondOfMinute ( 0 ) ; return firstSchedTime ; }
anoordover/camel | @ Override protected JndiRegistry createRegistry ( ) throws Exception { JndiRegistry jndi = super . createRegistry ( ) ; jndi . bind ( " generator " , new MyFileNameGenerator ( ) ) ; return jndi ; }
anoordover/camel | protected String getLanguageName ( ) { return " file " ; }
anoordover/camel | @ Test public void testConstantExpression ( ) throws Exception { assertExpression ( " MyBigFile . txt " , " MyBigFile . txt " ) ; }
anoordover/camel | @ Test public void testMessageId ( ) throws Exception { assertExpression ( " $ { id } " , exchange . getIn ( ) . getMessageId ( ) ) ; assertExpression ( " $ { id } . bak " , exchange . getIn ( ) . getMessageId ( ) + " . bak " ) ; }
anoordover/camel | @ Test public void testInvalidSyntax ( ) throws Exception { assertExpression ( " $ { file : onlyname } " , file . getName ( ) ) ; try { assertExpression ( " $ { file : onlyName } " , file . getName ( ) ) ; fail ( " Should ▁ have ▁ thrown ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ file ▁ language ▁ syntax : ▁ onlyName ▁ at ▁ location ▁ 0" ) ) ; } }
anoordover/camel | @ Test public void testFile ( ) throws Exception { assertExpression ( " $ { file : ext } " , " txt " ) ; assertExpression ( " $ { file : name . ext } " , " txt " ) ; assertExpression ( " $ { file : name . ext . single } " , " txt " ) ; assertExpression ( " $ { file : name } " , " test " + File . separator + file . getName ( ) ) ; assertExpression ( " $ { file : name . noext } " , " test " + File . separator + " hello " ) ; assertExpression ( " $ { file : name . noext . single } " , " test " + File . separator + " hello " ) ; assertExpression ( " $ { file : onlyname } " , file . getName ( ) ) ; assertExpression ( " $ { file : onlyname . noext } " , " hello " ) ; assertExpression ( " $ { file : onlyname . noext . single } " , " hello " ) ; assertExpression ( " $ { file : parent } " , file . getParent ( ) ) ; assertExpression ( " $ { file : path } " , file . getPath ( ) ) ; assertExpression ( " $ { file : absolute } " , FileUtil . isAbsolute ( file ) ) ; assertExpression ( " $ { file : absolute . path } " , file . getAbsolutePath ( ) ) ; assertExpression ( " $ { file : length } " , file . length ( ) ) ; assertExpression ( " $ { file : size } " , file . length ( ) ) ; Long modified = SimpleLanguage . simple ( " $ { file : modified } " ) . evaluate ( exchange , Long . class ) ; assertEquals ( file . lastModified ( ) , modified . longValue ( ) ) ; }
anoordover/camel | @ Test public void testFileUsingAlternativeStartToken ( ) throws Exception { assertExpression ( " $ simple { file : ext } " , " txt " ) ; assertExpression ( " $ simple { file : name . ext } " , " txt " ) ; assertExpression ( " $ simple { file : name } " , " test " + File . separator + file . getName ( ) ) ; assertExpression ( " $ simple { file : name . noext } " , " test " + File . separator + " hello " ) ; assertExpression ( " $ simple { file : onlyname } " , file . getName ( ) ) ; assertExpression ( " $ simple { file : onlyname . noext } " , " hello " ) ; assertExpression ( " $ simple { file : parent } " , file . getParent ( ) ) ; assertExpression ( " $ simple { file : path } " , file . getPath ( ) ) ; assertExpression ( " $ simple { file : absolute } " , FileUtil . isAbsolute ( file ) ) ; assertExpression ( " $ simple { file : absolute . path } " , file . getAbsolutePath ( ) ) ; assertExpression ( " $ simple { file : length } " , file . length ( ) ) ; assertExpression ( " $ simple { file : size } " , file . length ( ) ) ; long modified = SimpleLanguage . simple ( " $ { file : modified } " ) . evaluate ( exchange , long . class ) ; assertEquals ( file . lastModified ( ) , modified ) ; }
anoordover/camel | @ Test public void testDate ( ) throws Exception { String now = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( ) ) ; assertExpression ( " backup - $ { date : now : yyyyMMdd } " , " backup - " + now ) ; String expected = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( file . lastModified ( ) ) ) ; assertExpression ( " backup - $ { date : file : yyyyMMdd } " , " backup - " + expected ) ; assertExpression ( " backup - $ { date : header . birthday : yyyyMMdd } " , " backup - 19740420" ) ; assertExpression ( " hello - $ { date : out . header . special : yyyyMMdd } " , " hello - 20080808" ) ; try { this . assertExpression ( " nodate - $ { date : header . xxx : yyyyMMdd } " , null ) ; fail ( " Should ▁ have ▁ thrown ▁ IllegalArgumentException " ) ; } catch ( IllegalArgumentException e ) { } }
anoordover/camel | @ Test public void testDateUsingAlternativeStartToken ( ) throws Exception { String now = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( ) ) ; assertExpression ( " backup - $ simple { date : now : yyyyMMdd } " , " backup - " + now ) ; String expected = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( file . lastModified ( ) ) ) ; assertExpression ( " backup - $ simple { date : file : yyyyMMdd } " , " backup - " + expected ) ; assertExpression ( " backup - $ simple { date : header . birthday : yyyyMMdd } " , " backup - 19740420" ) ; assertExpression ( " hello - $ simple { date : out . header . special : yyyyMMdd } " , " hello - 20080808" ) ; try { this . assertExpression ( " nodate - $ simple { date : header . xxx : yyyyMMdd } " , null ) ; fail ( " Should ▁ have ▁ thrown ▁ IllegalArgumentException " ) ; } catch ( IllegalArgumentException e ) { } }
anoordover/camel | @ Test public void testSimpleAndFile ( ) throws Exception { assertExpression ( " backup - $ { in . header . foo } - $ { file : name . noext } . bak " , " backup - abc - test " + File . separator + " hello . bak " ) ; assertExpression ( " backup - $ { in . header . foo } - $ { file : onlyname . noext } . bak " , " backup - abc - hello . bak " ) ; }
anoordover/camel | @ Test public void testSimpleAndFileAndBean ( ) throws Exception { assertExpression ( " backup - $ { in . header . foo } - $ { bean : generator } - $ { file : name . noext } . bak " , " backup - abc - generatorbybean - test " + File . separator + " hello . bak " ) ; assertExpression ( " backup - $ { in . header . foo } - $ { bean : generator } - $ { file : onlyname . noext } . bak " , " backup - abc - generatorbybean - hello . bak " ) ; }
anoordover/camel | @ Test public void testBean ( ) throws Exception { assertExpression ( " backup - $ { bean : generator } . txt " , " backup - generatorbybean . txt " ) ; assertExpression ( " backup - $ { bean : generator . generateFilename } . txt " , " backup - generatorbybean . txt " ) ; }
anoordover/camel | @ Test public void testNoEscapeAllowed ( ) throws Exception { exchange . getIn ( ) . setHeader ( Exchange . FILE_NAME , " hello . txt " ) ; assertExpression ( " target\ \n ewdir \\ onwindows \\ $ { file : name } " , " target\ \n ewdir \\ onwindows \\ hello . txt " ) ; }
anoordover/camel | @ Test public void testFileNameDoubleExtension ( ) throws Exception { file = new File ( " target / filelanguage / test / bigfile . tar . gz " ) ; String uri = " file : // target / filelanguage ? fileExist = Override " ; GenericFile < File > gf = FileConsumer . asGenericFile ( " target / filelanguage " , file , null , false ) ; FileEndpoint endpoint = getMandatoryEndpoint ( uri , FileEndpoint . class ) ; Exchange answer = endpoint . createExchange ( gf ) ; endpoint . configureMessage ( gf , answer . getIn ( ) ) ; assertEquals ( " bigfile . tar . gz " , file . getName ( ) ) ; assertExpression ( answer , " $ { file : onlyname } " , " bigfile . tar . gz " ) ; assertExpression ( answer , " $ { file : ext } " , " tar . gz " ) ; }
anoordover/camel | public Exchange createExchange ( ) { String uri = " file : // target / filelanguage ? fileExist = Override " ; template . sendBodyAndHeader ( uri , " Hello ▁ World " , Exchange . FILE_NAME , " test / hello . txt " ) ; file = new File ( " target / filelanguage / test / hello . txt " ) ; GenericFile < File > gf = FileConsumer . asGenericFile ( " target / filelanguage " , file , null , false ) ; FileEndpoint endpoint = getMandatoryEndpoint ( uri , FileEndpoint . class ) ; Exchange answer = endpoint . createExchange ( gf ) ; endpoint . configureMessage ( gf , answer . getIn ( ) ) ; Calendar cal = Calendar . getInstance ( ) ; cal . set ( 1974 , Calendar . APRIL , 20 ) ; answer . getIn ( ) . setHeader ( " birthday " , cal . getTime ( ) ) ; cal . set ( 2008 , Calendar . AUGUST , 8 ) ; answer . getOut ( ) . setHeader ( " special " , cal . getTime ( ) ) ; return answer ; }
anoordover/camel | @ Test public void testIllegalSyntax ( ) throws Exception { try { assertExpression ( " $ { file . name } " , " " ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ function : ▁ file . name ▁ at ▁ location ▁ 0" ) ) ; } try { assertExpression ( " hey ▁ $ { xxx } ▁ how ▁ are ▁ you ? " , " " ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ function : ▁ xxx ▁ at ▁ location ▁ 4" ) ) ; } try { assertExpression ( " $ { xxx } " , " " ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ function : ▁ xxx ▁ at ▁ location ▁ 0" ) ) ; } }
anoordover/camel | @ Test public void testConstantFilename ( ) throws Exception { assertExpression ( " hello . txt " , " hello . txt " ) ; }
anoordover/camel | public String generateFilename ( Exchange exchange ) { return " generatorbybean " ; }
MerritCR/merrit | @ Inject MergeSuperSet ( @ GerritServerConfig Config cfg , ChangeData . Factory changeDataFactory , Provider < InternalChangeQuery > queryProvider , GitRepositoryManager repoManager ) { this . cfg = cfg ; this . changeDataFactory = changeDataFactory ; this . queryProvider = queryProvider ; this . repoManager = repoManager ; }
MerritCR/merrit | if ( Submit . wholeTopicEnabled ( cfg ) ) { return completeChangeSetIncludingTopics ( db , new ChangeSet ( cd ) , user ) ; }
MerritCR/merrit | for ( Project . NameKey project : pc . keySet ( ) ) { try ( Repository repo = repoManager . openRepository ( project ) ; RevWalk rw = CodeReviewCommit . newRevWalk ( repo ) ) { for ( Change . Id cId : pc . get ( project ) ) { ChangeData cd = changeDataFactory . create ( db , project , cId ) ; cd . changeControl ( user ) ; SubmitTypeRecord str = cd . submitTypeRecord ( ) ; if ( ! str . isOk ( ) ) { logErrorAndThrow ( " Failed ▁ to ▁ get ▁ submit ▁ type ▁ for ▁ " + cd . getId ( ) + " : ▁ " + str . errorMessage ) ; } if ( str . type == SubmitType . CHERRY_PICK ) { ret . add ( cd ) ; continue ; } PatchSet ps = cd . currentPatchSet ( ) ; String objIdStr = ps . getRevision ( ) . get ( ) ; RevCommit commit = rw . parseCommit ( ObjectId . fromString ( objIdStr ) ) ; Branch . NameKey destBranch = cd . change ( ) . getDest ( ) ; repo . getRefDatabase ( ) . refresh ( ) ; Ref ref = repo . getRefDatabase ( ) . getRef ( destBranch . get ( ) ) ; rw . reset ( ) ; rw . sort ( RevSort . TOPO ) ; rw . markStart ( commit ) ; if ( ref != null ) { RevCommit head = rw . parseCommit ( ref . getObjectId ( ) ) ; rw . markUninteresting ( head ) ; } List < String > hashes = new ArrayList < > ( ) ; hashes . add ( objIdStr ) ; for ( RevCommit c : rw ) { if ( ! c . equals ( commit ) ) { hashes . add ( c . name ( ) ) ; } } if ( ! hashes . isEmpty ( ) ) { Iterable < ChangeData > destChanges = query ( ) . byCommitsOnBranchNotMerged ( repo , db , cd . change ( ) . getDest ( ) , hashes ) ; for ( ChangeData chd : destChanges ) { ret . add ( chd ) ; } } } } }
MerritCR/merrit | while ( ! done ) { List < ChangeData > chgs = new ArrayList < > ( ) ; done = true ; for ( ChangeData cd : newCs . changes ( ) ) { chgs . add ( cd ) ; String topic = cd . change ( ) . getTopic ( ) ; if ( ! Strings . isNullOrEmpty ( topic ) && ! topicsTraversed . contains ( topic ) ) { chgs . addAll ( query ( ) . byTopicOpen ( topic ) ) ; done = false ; topicsTraversed . add ( topic ) ; } } changes = new ChangeSet ( chgs ) ; newCs = completeChangeSetWithoutTopic ( db , changes , user ) ; }
MerritCR/merrit | private InternalChangeQuery query ( ) { Set < String > fields = ImmutableSet . of ( ChangeField . CHANGE . getName ( ) , ChangeField . PATCH_SET . getName ( ) ) ; return queryProvider . get ( ) . setRequestedFields ( fields ) ; }
MerritCR/merrit | private void logError ( String msg ) { if ( log . isErrorEnabled ( ) ) { log . error ( msg ) ; } }
MerritCR/merrit | private void logErrorAndThrow ( String msg ) throws OrmException { logError ( msg ) ; throw new OrmException ( msg ) ; }
NovaViper/ZeroQuest | protected void func_151542_a ( long p_151542_1_ , int p_151542_3_ , int p_151542_4_ , Block [ ] p_151542_5_ , double p_151542_6_ , double p_151542_8_ , double p_151542_10_ ) { this . func_151541_a ( p_151542_1_ , p_151542_3_ , p_151542_4_ , p_151542_5_ , p_151542_6_ , p_151542_8_ , p_151542_10_ , 1.0F + this . rand . nextFloat ( ) * 6.0F , 0.0F , 0.0F , - 1 , - 1 , 0.5D ) ; }
NovaViper/ZeroQuest | protected void func_151541_a ( long p_151541_1_ , int p_151541_3_ , int p_151541_4_ , Block [ ] p_151541_5_ , double p_151541_6_ , double p_151541_8_ , double p_151541_10_ , float p_151541_12_ , float p_151541_13_ , float p_151541_14_ , int p_151541_15_ , int p_151541_16_ , double p_151541_17_ ) { double d4 = ( double ) ( p_151541_3_ * 16 + 8 ) ; double d5 = ( double ) ( p_151541_4_ * 16 + 8 ) ; float f3 = 0.0F ; float f4 = 0.0F ; Random random = new Random ( p_151541_1_ ) ; if ( p_151541_16_ <= 0 ) { int j1 = this . range * 16 - 16 ; p_151541_16_ = j1 - random . nextInt ( j1 / 4 ) ; } boolean flag2 = false ; if ( p_151541_15_ == - 1 ) { p_151541_15_ = p_151541_16_ / 2 ; flag2 = true ; } int k1 = random . nextInt ( p_151541_16_ / 2 ) + p_151541_16_ / 4 ; for ( boolean flag = random . nextInt ( 6 ) == 0 ; p_151541_15_ < p_151541_16_ ; ++ p_151541_15_ ) { double d6 = 1.5D + ( double ) ( MathHelper . sin ( ( float ) p_151541_15_ * ( float ) Math . PI / ( float ) p_151541_16_ ) * p_151541_12_ * 1.0F ) ; double d7 = d6 * p_151541_17_ ; float f5 = MathHelper . cos ( p_151541_14_ ) ; float f6 = MathHelper . sin ( p_151541_14_ ) ; p_151541_6_ += ( double ) ( MathHelper . cos ( p_151541_13_ ) * f5 ) ; p_151541_8_ += ( double ) f6 ; p_151541_10_ += ( double ) ( MathHelper . sin ( p_151541_13_ ) * f5 ) ; if ( flag ) { p_151541_14_ *= 0.92F ; } else { p_151541_14_ *= 0.7F ; } p_151541_14_ += f4 * 0.1F ; p_151541_13_ += f3 * 0.1F ; f4 *= 0.9F ; f3 *= 0.75F ; f4 += ( random . nextFloat ( ) - random . nextFloat ( ) ) * random . nextFloat ( ) * 2.0F ; f3 += ( random . nextFloat ( ) - random . nextFloat ( ) ) * random . nextFloat ( ) * 4.0F ; if ( ! flag2 && p_151541_15_ == k1 && p_151541_12_ > 1.0F && p_151541_16_ > 0 ) { this . func_151541_a ( random . nextLong ( ) , p_151541_3_ , p_151541_4_ , p_151541_5_ , p_151541_6_ , p_151541_8_ , p_151541_10_ , random . nextFloat ( ) * 0.5F + 0.5F , p_151541_13_ - ( ( float ) Math . PI / 2F ) , p_151541_14_ / 3.0F , p_151541_15_ , p_151541_16_ , 1.0D ) ; this . func_151541_a ( random . nextLong ( ) , p_151541_3_ , p_151541_4_ , p_151541_5_ , p_151541_6_ , p_151541_8_ , p_151541_10_ , random . nextFloat ( ) * 0.5F + 0.5F , p_151541_13_ + ( ( float ) Math . PI / 2F ) , p_151541_14_ / 3.0F , p_151541_15_ , p_151541_16_ , 1.0D ) ; return ; } if ( flag2 || random . nextInt ( 4 ) != 0 ) { double d8 = p_151541_6_ - d4 ; double d9 = p_151541_10_ - d5 ; double d10 = ( double ) ( p_151541_16_ - p_151541_15_ ) ; double d11 = ( double ) ( p_151541_12_ + 2.0F + 16.0F ) ; if ( d8 * d8 + d9 * d9 - d10 * d10 > d11 * d11 ) { return ; } if ( p_151541_6_ >= d4 - 16.0D - d6 * 2.0D && p_151541_10_ >= d5 - 16.0D - d6 * 2.0D && p_151541_6_ <= d4 + 16.0D + d6 * 2.0D && p_151541_10_ <= d5 + 16.0D + d6 * 2.0D ) { int i4 = MathHelper . floor_double ( p_151541_6_ - d6 ) - p_151541_3_ * 16 - 1 ; int l1 = MathHelper . floor_double ( p_151541_6_ + d6 ) - p_151541_3_ * 16 + 1 ; int j4 = MathHelper . floor_double ( p_151541_8_ - d7 ) - 1 ; int i2 = MathHelper . floor_double ( p_151541_8_ + d7 ) + 1 ; int k4 = MathHelper . floor_double ( p_151541_10_ - d6 ) - p_151541_4_ * 16 - 1 ; int j2 = MathHelper . floor_double ( p_151541_10_ + d6 ) - p_151541_4_ * 16 + 1 ; if ( i4 < 0 ) { i4 = 0 ; } if ( l1 > 16 ) { l1 = 16 ; } if ( j4 < 1 ) { j4 = 1 ; } if ( i2 > 248 ) { i2 = 248 ; } if ( k4 < 0 ) { k4 = 0 ; } if ( j2 > 16 ) { j2 = 16 ; } boolean flag3 = false ; int k2 ; int j3 ; for ( k2 = i4 ; ! flag3 && k2 < l1 ; ++ k2 ) { for ( int l2 = k4 ; ! flag3 && l2 < j2 ; ++ l2 ) { for ( int i3 = i2 + 1 ; ! flag3 && i3 >= j4 - 1 ; -- i3 ) { j3 = ( k2 * 16 + l2 ) * 256 + i3 ; if ( i3 >= 0 && i3 < 256 ) { Block block = p_151541_5_ [ j3 ] ; if ( isOceanBlock ( p_151541_5_ , j3 , k2 , i3 , l2 , p_151541_3_ , p_151541_4_ ) ) { flag3 = true ; } if ( i3 != j4 - 1 && k2 != i4 && k2 != l1 - 1 && l2 != k4 && l2 != j2 - 1 ) { i3 = j4 ; } } } } } if ( ! flag3 ) { for ( k2 = i4 ; k2 < l1 ; ++ k2 ) { double d13 = ( ( double ) ( k2 + p_151541_3_ * 16 ) + 0.5D - p_151541_6_ ) / d6 ; for ( j3 = k4 ; j3 < j2 ; ++ j3 ) { double d14 = ( ( double ) ( j3 + p_151541_4_ * 16 ) + 0.5D - p_151541_10_ ) / d6 ; int k3 = ( k2 * 16 + j3 ) * 256 + i2 ; boolean flag1 = false ; if ( d13 * d13 + d14 * d14 < 1.0D ) { for ( int l3 = i2 - 1 ; l3 >= j4 ; -- l3 ) { double d12 = ( ( double ) l3 + 0.5D - p_151541_8_ ) / d7 ; if ( d12 > - 0.7D && d13 * d13 + d12 * d12 + d14 * d14 < 1.0D ) { Block block1 = p_151541_5_ [ k3 ] ; if ( isTopBlock ( p_151541_5_ , k3 , k2 , l3 , j3 , p_151541_3_ , p_151541_4_ ) ) { flag1 = true ; } digBlock ( p_151541_5_ , k3 , k2 , l3 , j3 , p_151541_3_ , p_151541_4_ , flag1 ) ; } -- k3 ; } } } } if ( flag2 ) { break ; } } } } } }
NovaViper/ZeroQuest | protected void func_151538_a ( World p_151538_1_ , int p_151538_2_ , int p_151538_3_ , int p_151538_4_ , int p_151538_5_ , Block [ ] p_151538_6_ ) { int i1 = this . rand . nextInt ( this . rand . nextInt ( this . rand . nextInt ( 15 ) + 1 ) + 1 ) ; if ( this . rand . nextInt ( 7 ) != 0 ) { i1 = 0 ; } for ( int j1 = 0 ; j1 < i1 ; ++ j1 ) { double d0 = ( double ) ( p_151538_2_ * 16 + this . rand . nextInt ( 16 ) ) ; double d1 = ( double ) this . rand . nextInt ( this . rand . nextInt ( 120 ) + 8 ) ; double d2 = ( double ) ( p_151538_3_ * 16 + this . rand . nextInt ( 16 ) ) ; int k1 = 1 ; if ( this . rand . nextInt ( 4 ) == 0 ) { this . func_151542_a ( this . rand . nextLong ( ) , p_151538_4_ , p_151538_5_ , p_151538_6_ , d0 , d1 , d2 ) ; k1 += this . rand . nextInt ( 4 ) ; } for ( int l1 = 0 ; l1 < k1 ; ++ l1 ) { float f = this . rand . nextFloat ( ) * ( float ) Math . PI * 2.0F ; float f1 = ( this . rand . nextFloat ( ) - 0.5F ) * 2.0F / 8.0F ; float f2 = this . rand . nextFloat ( ) * 2.0F + this . rand . nextFloat ( ) ; if ( this . rand . nextInt ( 10 ) == 0 ) { f2 *= this . rand . nextFloat ( ) * this . rand . nextFloat ( ) * 3.0F + 1.0F ; } this . func_151541_a ( this . rand . nextLong ( ) , p_151538_4_ , p_151538_5_ , p_151538_6_ , d0 , d1 , d2 , f2 , f , f1 , 0 , 0 , 1.0D ) ; } } }
NovaViper/ZeroQuest | protected boolean isOceanBlock ( Block [ ] data , int index , int x , int y , int z , int chunkX , int chunkZ ) { return data [ index ] == Blocks . water ; }
NovaViper/ZeroQuest | private boolean isExceptionBiome ( BiomeGenBase biome ) { if ( biome == BiomeGenBase . mushroomIsland ) return true ; if ( biome == BiomeGenBase . beach ) return true ; if ( biome == ModBiomes . destroZone ) return true ; return false ; }
NovaViper/ZeroQuest | private boolean isTopBlock ( Block [ ] data , int index , int x , int y , int z , int chunkX , int chunkZ ) { BiomeGenBase biome = worldObj . getBiomeGenForCoords ( x + chunkX * 16 , z + chunkZ * 16 ) ; return ( isExceptionBiome ( biome ) ? data [ index ] == Blocks . grass : data [ index ] == biome . topBlock ) ; }
NovaViper/ZeroQuest | protected void digBlock ( Block [ ] data , int index , int x , int y , int z , int chunkX , int chunkZ , boolean foundTop ) { BiomeGenBase biome = worldObj . getBiomeGenForCoords ( x + chunkX * 16 , z + chunkZ * 16 ) ; Block top = ( isExceptionBiome ( biome ) ? Blocks . grass : biome . topBlock ) ; Block filler = ( isExceptionBiome ( biome ) ? Blocks . dirt : biome . fillerBlock ) ; Block block = data [ index ] ; if ( block == Blocks . stone || block == filler || block == top ) { if ( y < 10 ) { data [ index ] = Blocks . lava ; } else { data [ index ] = null ; if ( foundTop && data [ index - 1 ] == filler ) { data [ index - 1 ] = top ; } } } }
mazlixek/gwt-ol3 | public Projection ( ProjectionOptions projectionOptions ) { }
AntoineAugusti/incubator-zeppelin | public Factory ( ) { }
AntoineAugusti/incubator-zeppelin | public Client getClient ( org . apache . thrift . protocol . TProtocol prot ) { return new Client ( prot ) ; }
AntoineAugusti/incubator-zeppelin | public Client getClient ( org . apache . thrift . protocol . TProtocol iprot , org . apache . thrift . protocol . TProtocol oprot ) { return new Client ( iprot , oprot ) ; }
AntoineAugusti/incubator-zeppelin | public Client ( org . apache . thrift . protocol . TProtocol prot ) { super ( prot , prot ) ; }
AntoineAugusti/incubator-zeppelin | public Client ( org . apache . thrift . protocol . TProtocol iprot , org . apache . thrift . protocol . TProtocol oprot ) { super ( iprot , oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | public Factory ( org . apache . thrift . async . TAsyncClientManager clientManager , org . apache . thrift . protocol . TProtocolFactory protocolFactory ) { this . clientManager = clientManager ; this . protocolFactory = protocolFactory ; }
AntoineAugusti/incubator-zeppelin | public AsyncClient getAsyncClient ( org . apache . thrift . transport . TNonblockingTransport transport ) { return new AsyncClient ( protocolFactory , clientManager , transport ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncClient ( org . apache . thrift . protocol . TProtocolFactory protocolFactory , org . apache . thrift . async . TAsyncClientManager clientManager , org . apache . thrift . transport . TNonblockingTransport transport ) { super ( protocolFactory , clientManager , transport ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | public Processor ( I iface ) { super ( iface , getProcessMap ( new HashMap < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > ( ) ) ) ; }
AntoineAugusti/incubator-zeppelin | protected Processor ( I iface , Map < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > processMap ) { super ( iface , getProcessMap ( processMap ) ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter ( ) { super ( " createInterpreter " ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args getEmptyArgsInstance ( ) { return new createInterpreter_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public open ( ) { super ( " open " ) ; }
AntoineAugusti/incubator-zeppelin | public open_args getEmptyArgsInstance ( ) { return new open_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public close ( ) { super ( " close " ) ; }
AntoineAugusti/incubator-zeppelin | public close_args getEmptyArgsInstance ( ) { return new close_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public interpret ( ) { super ( " interpret " ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_args getEmptyArgsInstance ( ) { return new interpret_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public cancel ( ) { super ( " cancel " ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_args getEmptyArgsInstance ( ) { return new cancel_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getProgress ( ) { super ( " getProgress " ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args getEmptyArgsInstance ( ) { return new getProgress_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getFormType ( ) { super ( " getFormType " ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args getEmptyArgsInstance ( ) { return new getFormType_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public completion ( ) { super ( " completion " ) ; }
AntoineAugusti/incubator-zeppelin | public completion_args getEmptyArgsInstance ( ) { return new completion_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public shutdown ( ) { super ( " shutdown " ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_args getEmptyArgsInstance ( ) { return new shutdown_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getStatus ( ) { super ( " getStatus " ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args getEmptyArgsInstance ( ) { return new getStatus_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getEvent ( ) { super ( " getEvent " ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_args getEmptyArgsInstance ( ) { return new getEvent_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate ( ) { super ( " angularObjectUpdate " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args getEmptyArgsInstance ( ) { return new angularObjectUpdate_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd ( ) { super ( " angularObjectAdd " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args getEmptyArgsInstance ( ) { return new angularObjectAdd_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove ( ) { super ( " angularObjectRemove " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args getEmptyArgsInstance ( ) { return new angularObjectRemove_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public AsyncProcessor ( I iface ) { super ( iface , getProcessMap ( new HashMap < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > ( ) ) ) ; }
AntoineAugusti/incubator-zeppelin | protected AsyncProcessor ( I iface , Map < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > processMap ) { super ( iface , getProcessMap ( processMap ) ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter ( ) { super ( " createInterpreter " ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args getEmptyArgsInstance ( ) { return new createInterpreter_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { createInterpreter_result result = new createInterpreter_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; createInterpreter_result result = new createInterpreter_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , createInterpreter_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . createInterpreter ( args . className , args . properties , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public open ( ) { super ( " open " ) ; }
AntoineAugusti/incubator-zeppelin | public open_args getEmptyArgsInstance ( ) { return new open_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { open_result result = new open_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; open_result result = new open_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , open_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . open ( args . className , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public close ( ) { super ( " close " ) ; }
AntoineAugusti/incubator-zeppelin | public close_args getEmptyArgsInstance ( ) { return new close_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { close_result result = new close_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; close_result result = new close_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , close_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . close ( args . className , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public interpret ( ) { super ( " interpret " ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_args getEmptyArgsInstance ( ) { return new interpret_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < RemoteInterpreterResult > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < RemoteInterpreterResult > ( ) { public void onComplete ( RemoteInterpreterResult o ) { interpret_result result = new interpret_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; interpret_result result = new interpret_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , interpret_args args , org . apache . thrift . async . AsyncMethodCallback < RemoteInterpreterResult > resultHandler ) throws TException { iface . interpret ( args . className , args . st , args . interpreterContext , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public cancel ( ) { super ( " cancel " ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_args getEmptyArgsInstance ( ) { return new cancel_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { cancel_result result = new cancel_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; cancel_result result = new cancel_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , cancel_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . cancel ( args . className , args . interpreterContext , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress ( ) { super ( " getProgress " ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args getEmptyArgsInstance ( ) { return new getProgress_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Integer > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Integer > ( ) { public void onComplete ( Integer o ) { getProgress_result result = new getProgress_result ( ) ; result . success = o ; result . setSuccessIsSet ( true ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getProgress_result result = new getProgress_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getProgress_args args , org . apache . thrift . async . AsyncMethodCallback < Integer > resultHandler ) throws TException { iface . getProgress ( args . className , args . interpreterContext , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType ( ) { super ( " getFormType " ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args getEmptyArgsInstance ( ) { return new getFormType_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < String > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < String > ( ) { public void onComplete ( String o ) { getFormType_result result = new getFormType_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getFormType_result result = new getFormType_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getFormType_args args , org . apache . thrift . async . AsyncMethodCallback < String > resultHandler ) throws TException { iface . getFormType ( args . className , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public completion ( ) { super ( " completion " ) ; }
AntoineAugusti/incubator-zeppelin | public completion_args getEmptyArgsInstance ( ) { return new completion_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < List < String > > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < List < String > > ( ) { public void onComplete ( List < String > o ) { completion_result result = new completion_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; completion_result result = new completion_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , completion_args args , org . apache . thrift . async . AsyncMethodCallback < List < String > > resultHandler ) throws TException { iface . completion ( args . className , args . buf , args . cursor , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown ( ) { super ( " shutdown " ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_args getEmptyArgsInstance ( ) { return new shutdown_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { shutdown_result result = new shutdown_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; shutdown_result result = new shutdown_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , shutdown_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . shutdown ( resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus ( ) { super ( " getStatus " ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args getEmptyArgsInstance ( ) { return new getStatus_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < String > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < String > ( ) { public void onComplete ( String o ) { getStatus_result result = new getStatus_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getStatus_result result = new getStatus_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getStatus_args args , org . apache . thrift . async . AsyncMethodCallback < String > resultHandler ) throws TException { iface . getStatus ( args . jobId , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent ( ) { super ( " getEvent " ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_args getEmptyArgsInstance ( ) { return new getEvent_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < RemoteInterpreterEvent > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < RemoteInterpreterEvent > ( ) { public void onComplete ( RemoteInterpreterEvent o ) { getEvent_result result = new getEvent_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getEvent_result result = new getEvent_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getEvent_args args , org . apache . thrift . async . AsyncMethodCallback < RemoteInterpreterEvent > resultHandler ) throws TException { iface . getEvent ( resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate ( ) { super ( " angularObjectUpdate " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args getEmptyArgsInstance ( ) { return new angularObjectUpdate_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { angularObjectUpdate_result result = new angularObjectUpdate_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; angularObjectUpdate_result result = new angularObjectUpdate_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , angularObjectUpdate_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . angularObjectUpdate ( args . name , args . noteId , args . object , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd ( ) { super ( " angularObjectAdd " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args getEmptyArgsInstance ( ) { return new angularObjectAdd_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { angularObjectAdd_result result = new angularObjectAdd_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; angularObjectAdd_result result = new angularObjectAdd_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , angularObjectAdd_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . angularObjectAdd ( args . name , args . noteId , args . object , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove ( ) { super ( " angularObjectRemove " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args getEmptyArgsInstance ( ) { return new angularObjectRemove_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { angularObjectRemove_result result = new angularObjectRemove_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; angularObjectRemove_result result = new angularObjectRemove_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , angularObjectRemove_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . angularObjectRemove ( args . name , args . noteId , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args ( ) { }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args ( String className , Map < String , String > properties ) { this ( ) ; this . className = className ; this . properties = properties ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args ( createInterpreter_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetProperties ( ) ) { Map < String , String > __this__properties = new HashMap < String , String > ( other . properties ) ; this . properties = __this__properties ; } }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args deepCopy ( ) { return new createInterpreter_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . properties = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public int getPropertiesSize ( ) { return ( this . properties == null ) ? 0 : this . properties . size ( ) ; }
AntoineAugusti/incubator-zeppelin | public void putToProperties ( String key , String val ) { if ( this . properties == null ) { this . properties = new HashMap < String , String > ( ) ; } this . properties . put ( key , val ) ; }
AntoineAugusti/incubator-zeppelin | public Map < String , String > getProperties ( ) { return this . properties ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args setProperties ( Map < String , String > properties ) { this . properties = properties ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetProperties ( ) { this . properties = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetProperties ( ) { return this . properties != null ; }
AntoineAugusti/incubator-zeppelin | public void setPropertiesIsSet ( boolean value ) { if ( ! value ) { this . properties = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case PROPERTIES : if ( value == null ) { unsetProperties ( ) ; } else { setProperties ( ( Map < String , String > ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case PROPERTIES : return getProperties ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case PROPERTIES : return isSetProperties ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof createInterpreter_args ) return this . equals ( ( createInterpreter_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( createInterpreter_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_properties = true && this . isSetProperties ( ) ; boolean that_present_properties = true && that . isSetProperties ( ) ; if ( this_present_properties || that_present_properties ) { if ( ! ( this_present_properties && that_present_properties ) ) return false ; if ( ! this . properties . equals ( that . properties ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_properties = true && ( isSetProperties ( ) ) ; list . add ( present_properties ) ; if ( present_properties ) list . add ( properties ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( createInterpreter_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetProperties ( ) ) . compareTo ( other . isSetProperties ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetProperties ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . properties , other . properties ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " createInterpreter _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " properties : " ) ; if ( this . properties == null ) { sb . append ( " null " ) ; } else { sb . append ( this . properties ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_argsStandardScheme getScheme ( ) { return new createInterpreter_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . MAP ) { { org . apache . thrift . protocol . TMap _map0 = iprot . readMapBegin ( ) ; struct . properties = new HashMap < String , String > ( 2 * _map0 . size ) ; String _key1 ; String _val2 ; for ( int _i3 = 0 ; _i3 < _map0 . size ; ++ _i3 ) { _key1 = iprot . readString ( ) ; _val2 = iprot . readString ( ) ; struct . properties . put ( _key1 , _val2 ) ; } iprot . readMapEnd ( ) ; } struct . setPropertiesIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . properties != null ) { oprot . writeFieldBegin ( PROPERTIES_FIELD_DESC ) ; { oprot . writeMapBegin ( new org . apache . thrift . protocol . TMap ( org . apache . thrift . protocol . TType . STRING , org . apache . thrift . protocol . TType . STRING , struct . properties . size ( ) ) ) ; for ( Map . Entry < String , String > _iter4 : struct . properties . entrySet ( ) ) { oprot . writeString ( _iter4 . getKey ( ) ) ; oprot . writeString ( _iter4 . getValue ( ) ) ; } oprot . writeMapEnd ( ) ; } oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_argsTupleScheme getScheme ( ) { return new createInterpreter_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetProperties ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetProperties ( ) ) { { oprot . writeI32 ( struct . properties . size ( ) ) ; for ( Map . Entry < String , String > _iter5 : struct . properties . entrySet ( ) ) { oprot . writeString ( _iter5 . getKey ( ) ) ; oprot . writeString ( _iter5 . getValue ( ) ) ; } } }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { { org . apache . thrift . protocol . TMap _map6 = new org . apache . thrift . protocol . TMap ( org . apache . thrift . protocol . TType . STRING , org . apache . thrift . protocol . TType . STRING , iprot . readI32 ( ) ) ; struct . properties = new HashMap < String , String > ( 2 * _map6 . size ) ; String _key7 ; String _val8 ; for ( int _i9 = 0 ; _i9 < _map6 . size ; ++ _i9 ) { _key7 = iprot . readString ( ) ; _val8 = iprot . readString ( ) ; struct . properties . put ( _key7 , _val8 ) ; } } struct . setPropertiesIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_result ( ) { }
AntoineAugusti/incubator-zeppelin | public createInterpreter_result ( createInterpreter_result other ) { }
AntoineAugusti/incubator-zeppelin | public createInterpreter_result deepCopy ( ) { return new createInterpreter_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof createInterpreter_result ) return this . equals ( ( createInterpreter_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( createInterpreter_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( createInterpreter_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " createInterpreter _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_resultStandardScheme getScheme ( ) { return new createInterpreter_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_resultTupleScheme getScheme ( ) { return new createInterpreter_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public open_args ( ) { }
AntoineAugusti/incubator-zeppelin | public open_args ( String className ) { this ( ) ; this . className = className ; }
AntoineAugusti/incubator-zeppelin | public open_args ( open_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } }
AntoineAugusti/incubator-zeppelin | public open_args deepCopy ( ) { return new open_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public open_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof open_args ) return this . equals ( ( open_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( open_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( open_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " open _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public open_argsStandardScheme getScheme ( ) { return new open_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public open_argsTupleScheme getScheme ( ) { return new open_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public open_result ( ) { }
AntoineAugusti/incubator-zeppelin | public open_result ( open_result other ) { }
AntoineAugusti/incubator-zeppelin | public open_result deepCopy ( ) { return new open_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof open_result ) return this . equals ( ( open_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( open_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( open_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " open _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public open_resultStandardScheme getScheme ( ) { return new open_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public open_resultTupleScheme getScheme ( ) { return new open_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public close_args ( ) { }
AntoineAugusti/incubator-zeppelin | public close_args ( String className ) { this ( ) ; this . className = className ; }
AntoineAugusti/incubator-zeppelin | public close_args ( close_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } }
AntoineAugusti/incubator-zeppelin | public close_args deepCopy ( ) { return new close_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public close_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof close_args ) return this . equals ( ( close_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( close_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( close_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " close _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public close_argsStandardScheme getScheme ( ) { return new close_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public close_argsTupleScheme getScheme ( ) { return new close_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public close_result ( ) { }
AntoineAugusti/incubator-zeppelin | public close_result ( close_result other ) { }
AntoineAugusti/incubator-zeppelin | public close_result deepCopy ( ) { return new close_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof close_result ) return this . equals ( ( close_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( close_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( close_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " close _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public close_resultStandardScheme getScheme ( ) { return new close_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public close_resultTupleScheme getScheme ( ) { return new close_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public interpret_args ( ) { }
AntoineAugusti/incubator-zeppelin | public interpret_args ( String className , String st , RemoteInterpreterContext interpreterContext ) { this ( ) ; this . className = className ; this . st = st ; this . interpreterContext = interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public interpret_args ( interpret_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetSt ( ) ) { this . st = other . st ; } if ( other . isSetInterpreterContext ( ) ) { this . interpreterContext = new RemoteInterpreterContext ( other . interpreterContext ) ; } }
AntoineAugusti/incubator-zeppelin | public interpret_args deepCopy ( ) { return new interpret_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . st = null ; this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public interpret_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public String getSt ( ) { return this . st ; }
AntoineAugusti/incubator-zeppelin | public interpret_args setSt ( String st ) { this . st = st ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSt ( ) { this . st = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSt ( ) { return this . st != null ; }
AntoineAugusti/incubator-zeppelin | public void setStIsSet ( boolean value ) { if ( ! value ) { this . st = null ; } }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterContext getInterpreterContext ( ) { return this . interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public interpret_args setInterpreterContext ( RemoteInterpreterContext interpreterContext ) { this . interpreterContext = interpreterContext ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetInterpreterContext ( ) { this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetInterpreterContext ( ) { return this . interpreterContext != null ; }
AntoineAugusti/incubator-zeppelin | public void setInterpreterContextIsSet ( boolean value ) { if ( ! value ) { this . interpreterContext = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case ST : if ( value == null ) { unsetSt ( ) ; } else { setSt ( ( String ) value ) ; } break ; case INTERPRETER_CONTEXT : if ( value == null ) { unsetInterpreterContext ( ) ; } else { setInterpreterContext ( ( RemoteInterpreterContext ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case ST : return getSt ( ) ; case INTERPRETER_CONTEXT : return getInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case ST : return isSetSt ( ) ; case INTERPRETER_CONTEXT : return isSetInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof interpret_args ) return this . equals ( ( interpret_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( interpret_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_st = true && this . isSetSt ( ) ; boolean that_present_st = true && that . isSetSt ( ) ; if ( this_present_st || that_present_st ) { if ( ! ( this_present_st && that_present_st ) ) return false ; if ( ! this . st . equals ( that . st ) ) return false ; } boolean this_present_interpreterContext = true && this . isSetInterpreterContext ( ) ; boolean that_present_interpreterContext = true && that . isSetInterpreterContext ( ) ; if ( this_present_interpreterContext || that_present_interpreterContext ) { if ( ! ( this_present_interpreterContext && that_present_interpreterContext ) ) return false ; if ( ! this . interpreterContext . equals ( that . interpreterContext ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_st = true && ( isSetSt ( ) ) ; list . add ( present_st ) ; if ( present_st ) list . add ( st ) ; boolean present_interpreterContext = true && ( isSetInterpreterContext ( ) ) ; list . add ( present_interpreterContext ) ; if ( present_interpreterContext ) list . add ( interpreterContext ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( interpret_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetSt ( ) ) . compareTo ( other . isSetSt ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSt ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . st , other . st ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetInterpreterContext ( ) ) . compareTo ( other . isSetInterpreterContext ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetInterpreterContext ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . interpreterContext , other . interpreterContext ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " interpret _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " st : " ) ; if ( this . st == null ) { sb . append ( " null " ) ; } else { sb . append ( this . st ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " interpreterContext : " ) ; if ( this . interpreterContext == null ) { sb . append ( " null " ) ; } else { sb . append ( this . interpreterContext ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( interpreterContext != null ) { interpreterContext . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_argsStandardScheme getScheme ( ) { return new interpret_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . st = iprot . readString ( ) ; struct . setStIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . st != null ) { oprot . writeFieldBegin ( ST_FIELD_DESC ) ; oprot . writeString ( struct . st ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . interpreterContext != null ) { oprot . writeFieldBegin ( INTERPRETER_CONTEXT_FIELD_DESC ) ; struct . interpreterContext . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_argsTupleScheme getScheme ( ) { return new interpret_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSt ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSt ( ) ) { oprot . writeString ( struct . st ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { struct . interpreterContext . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . st = iprot . readString ( ) ; struct . setStIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public interpret_result ( ) { }
AntoineAugusti/incubator-zeppelin | public interpret_result ( RemoteInterpreterResult success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public interpret_result ( interpret_result other ) { if ( other . isSetSuccess ( ) ) { this . success = new RemoteInterpreterResult ( other . success ) ; } }
AntoineAugusti/incubator-zeppelin | public interpret_result deepCopy ( ) { return new interpret_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterResult getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public interpret_result setSuccess ( RemoteInterpreterResult success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( RemoteInterpreterResult ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof interpret_result ) return this . equals ( ( interpret_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( interpret_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( interpret_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " interpret _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( success != null ) { success . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_resultStandardScheme getScheme ( ) { return new interpret_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . success = new RemoteInterpreterResult ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; struct . success . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_resultTupleScheme getScheme ( ) { return new interpret_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { struct . success . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = new RemoteInterpreterResult ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public cancel_args ( ) { }
AntoineAugusti/incubator-zeppelin | public cancel_args ( String className , RemoteInterpreterContext interpreterContext ) { this ( ) ; this . className = className ; this . interpreterContext = interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public cancel_args ( cancel_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetInterpreterContext ( ) ) { this . interpreterContext = new RemoteInterpreterContext ( other . interpreterContext ) ; } }
AntoineAugusti/incubator-zeppelin | public cancel_args deepCopy ( ) { return new cancel_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public cancel_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterContext getInterpreterContext ( ) { return this . interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public cancel_args setInterpreterContext ( RemoteInterpreterContext interpreterContext ) { this . interpreterContext = interpreterContext ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetInterpreterContext ( ) { this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetInterpreterContext ( ) { return this . interpreterContext != null ; }
AntoineAugusti/incubator-zeppelin | public void setInterpreterContextIsSet ( boolean value ) { if ( ! value ) { this . interpreterContext = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case INTERPRETER_CONTEXT : if ( value == null ) { unsetInterpreterContext ( ) ; } else { setInterpreterContext ( ( RemoteInterpreterContext ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case INTERPRETER_CONTEXT : return getInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case INTERPRETER_CONTEXT : return isSetInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof cancel_args ) return this . equals ( ( cancel_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( cancel_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_interpreterContext = true && this . isSetInterpreterContext ( ) ; boolean that_present_interpreterContext = true && that . isSetInterpreterContext ( ) ; if ( this_present_interpreterContext || that_present_interpreterContext ) { if ( ! ( this_present_interpreterContext && that_present_interpreterContext ) ) return false ; if ( ! this . interpreterContext . equals ( that . interpreterContext ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_interpreterContext = true && ( isSetInterpreterContext ( ) ) ; list . add ( present_interpreterContext ) ; if ( present_interpreterContext ) list . add ( interpreterContext ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( cancel_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetInterpreterContext ( ) ) . compareTo ( other . isSetInterpreterContext ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetInterpreterContext ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . interpreterContext , other . interpreterContext ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " cancel _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " interpreterContext : " ) ; if ( this . interpreterContext == null ) { sb . append ( " null " ) ; } else { sb . append ( this . interpreterContext ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( interpreterContext != null ) { interpreterContext . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_argsStandardScheme getScheme ( ) { return new cancel_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . interpreterContext != null ) { oprot . writeFieldBegin ( INTERPRETER_CONTEXT_FIELD_DESC ) ; struct . interpreterContext . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_argsTupleScheme getScheme ( ) { return new cancel_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { struct . interpreterContext . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public cancel_result ( ) { }
AntoineAugusti/incubator-zeppelin | public cancel_result ( cancel_result other ) { }
AntoineAugusti/incubator-zeppelin | public cancel_result deepCopy ( ) { return new cancel_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof cancel_result ) return this . equals ( ( cancel_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( cancel_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( cancel_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " cancel _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_resultStandardScheme getScheme ( ) { return new cancel_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_resultTupleScheme getScheme ( ) { return new cancel_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getProgress_args ( String className , RemoteInterpreterContext interpreterContext ) { this ( ) ; this . className = className ; this . interpreterContext = interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args ( getProgress_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetInterpreterContext ( ) ) { this . interpreterContext = new RemoteInterpreterContext ( other . interpreterContext ) ; } }
AntoineAugusti/incubator-zeppelin | public getProgress_args deepCopy ( ) { return new getProgress_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterContext getInterpreterContext ( ) { return this . interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args setInterpreterContext ( RemoteInterpreterContext interpreterContext ) { this . interpreterContext = interpreterContext ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetInterpreterContext ( ) { this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetInterpreterContext ( ) { return this . interpreterContext != null ; }
AntoineAugusti/incubator-zeppelin | public void setInterpreterContextIsSet ( boolean value ) { if ( ! value ) { this . interpreterContext = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case INTERPRETER_CONTEXT : if ( value == null ) { unsetInterpreterContext ( ) ; } else { setInterpreterContext ( ( RemoteInterpreterContext ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case INTERPRETER_CONTEXT : return getInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case INTERPRETER_CONTEXT : return isSetInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getProgress_args ) return this . equals ( ( getProgress_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getProgress_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_interpreterContext = true && this . isSetInterpreterContext ( ) ; boolean that_present_interpreterContext = true && that . isSetInterpreterContext ( ) ; if ( this_present_interpreterContext || that_present_interpreterContext ) { if ( ! ( this_present_interpreterContext && that_present_interpreterContext ) ) return false ; if ( ! this . interpreterContext . equals ( that . interpreterContext ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_interpreterContext = true && ( isSetInterpreterContext ( ) ) ; list . add ( present_interpreterContext ) ; if ( present_interpreterContext ) list . add ( interpreterContext ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getProgress_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetInterpreterContext ( ) ) . compareTo ( other . isSetInterpreterContext ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetInterpreterContext ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . interpreterContext , other . interpreterContext ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getProgress _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " interpreterContext : " ) ; if ( this . interpreterContext == null ) { sb . append ( " null " ) ; } else { sb . append ( this . interpreterContext ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( interpreterContext != null ) { interpreterContext . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_argsStandardScheme getScheme ( ) { return new getProgress_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . interpreterContext != null ) { oprot . writeFieldBegin ( INTERPRETER_CONTEXT_FIELD_DESC ) ; struct . interpreterContext . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_argsTupleScheme getScheme ( ) { return new getProgress_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { struct . interpreterContext . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getProgress_result ( int success ) { this ( ) ; this . success = success ; setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result ( getProgress_result other ) { __isset_bitfield = other . __isset_bitfield ; this . success = other . success ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result deepCopy ( ) { return new getProgress_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { setSuccessIsSet ( false ) ; this . success = 0 ; }
AntoineAugusti/incubator-zeppelin | public int getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result setSuccess ( int success ) { this . success = success ; setSuccessIsSet ( true ) ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { __isset_bitfield = EncodingUtils . clearBit ( __isset_bitfield , __SUCCESS_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return EncodingUtils . testBit ( __isset_bitfield , __SUCCESS_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { __isset_bitfield = EncodingUtils . setBit ( __isset_bitfield , __SUCCESS_ISSET_ID , value ) ; }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( Integer ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return Integer . valueOf ( getSuccess ( ) ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getProgress_result ) return this . equals ( ( getProgress_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getProgress_result that ) { if ( that == null ) return false ; boolean this_present_success = true ; boolean that_present_success = true ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( this . success != that . success ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getProgress_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getProgress _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; sb . append ( this . success ) ; first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_resultStandardScheme getScheme ( ) { return new getProgress_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . I32 ) { struct . success = iprot . readI32 ( ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; oprot . writeI32 ( struct . success ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_resultTupleScheme getScheme ( ) { return new getProgress_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeI32 ( struct . success ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = iprot . readI32 ( ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getFormType_args ( String className ) { this ( ) ; this . className = className ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args ( getFormType_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } }
AntoineAugusti/incubator-zeppelin | public getFormType_args deepCopy ( ) { return new getFormType_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getFormType_args ) return this . equals ( ( getFormType_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getFormType_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getFormType_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getFormType _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_argsStandardScheme getScheme ( ) { return new getFormType_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_argsTupleScheme getScheme ( ) { return new getFormType_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getFormType_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getFormType_result ( String success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public getFormType_result ( getFormType_result other ) { if ( other . isSetSuccess ( ) ) { this . success = other . success ; } }
AntoineAugusti/incubator-zeppelin | public getFormType_result deepCopy ( ) { return new getFormType_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public String getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getFormType_result setSuccess ( String success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getFormType_result ) return this . equals ( ( getFormType_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getFormType_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getFormType_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getFormType _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_resultStandardScheme getScheme ( ) { return new getFormType_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; oprot . writeString ( struct . success ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_resultTupleScheme getScheme ( ) { return new getFormType_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeString ( struct . success ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public completion_args ( ) { }
AntoineAugusti/incubator-zeppelin | public completion_args ( String className , String buf , int cursor ) { this ( ) ; this . className = className ; this . buf = buf ; this . cursor = cursor ; setCursorIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | public completion_args ( completion_args other ) { __isset_bitfield = other . __isset_bitfield ; if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetBuf ( ) ) { this . buf = other . buf ; } this . cursor = other . cursor ; }
AntoineAugusti/incubator-zeppelin | public completion_args deepCopy ( ) { return new completion_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . buf = null ; setCursorIsSet ( false ) ; this . cursor = 0 ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public completion_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public String getBuf ( ) { return this . buf ; }
AntoineAugusti/incubator-zeppelin | public completion_args setBuf ( String buf ) { this . buf = buf ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetBuf ( ) { this . buf = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetBuf ( ) { return this . buf != null ; }
AntoineAugusti/incubator-zeppelin | public void setBufIsSet ( boolean value ) { if ( ! value ) { this . buf = null ; } }
AntoineAugusti/incubator-zeppelin | public int getCursor ( ) { return this . cursor ; }
AntoineAugusti/incubator-zeppelin | public completion_args setCursor ( int cursor ) { this . cursor = cursor ; setCursorIsSet ( true ) ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetCursor ( ) { __isset_bitfield = EncodingUtils . clearBit ( __isset_bitfield , __CURSOR_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetCursor ( ) { return EncodingUtils . testBit ( __isset_bitfield , __CURSOR_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public void setCursorIsSet ( boolean value ) { __isset_bitfield = EncodingUtils . setBit ( __isset_bitfield , __CURSOR_ISSET_ID , value ) ; }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case BUF : if ( value == null ) { unsetBuf ( ) ; } else { setBuf ( ( String ) value ) ; } break ; case CURSOR : if ( value == null ) { unsetCursor ( ) ; } else { setCursor ( ( Integer ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case BUF : return getBuf ( ) ; case CURSOR : return Integer . valueOf ( getCursor ( ) ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case BUF : return isSetBuf ( ) ; case CURSOR : return isSetCursor ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof completion_args ) return this . equals ( ( completion_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( completion_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_buf = true && this . isSetBuf ( ) ; boolean that_present_buf = true && that . isSetBuf ( ) ; if ( this_present_buf || that_present_buf ) { if ( ! ( this_present_buf && that_present_buf ) ) return false ; if ( ! this . buf . equals ( that . buf ) ) return false ; } boolean this_present_cursor = true ; boolean that_present_cursor = true ; if ( this_present_cursor || that_present_cursor ) { if ( ! ( this_present_cursor && that_present_cursor ) ) return false ; if ( this . cursor != that . cursor ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_buf = true && ( isSetBuf ( ) ) ; list . add ( present_buf ) ; if ( present_buf ) list . add ( buf ) ; boolean present_cursor = true ; list . add ( present_cursor ) ; if ( present_cursor ) list . add ( cursor ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( completion_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetBuf ( ) ) . compareTo ( other . isSetBuf ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetBuf ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . buf , other . buf ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetCursor ( ) ) . compareTo ( other . isSetCursor ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetCursor ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . cursor , other . cursor ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " completion _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " buf : " ) ; if ( this . buf == null ) { sb . append ( " null " ) ; } else { sb . append ( this . buf ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " cursor : " ) ; sb . append ( this . cursor ) ; first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public completion_argsStandardScheme getScheme ( ) { return new completion_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . buf = iprot . readString ( ) ; struct . setBufIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . I32 ) { struct . cursor = iprot . readI32 ( ) ; struct . setCursorIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . buf != null ) { oprot . writeFieldBegin ( BUF_FIELD_DESC ) ; oprot . writeString ( struct . buf ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public completion_argsTupleScheme getScheme ( ) { return new completion_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetBuf ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetCursor ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetBuf ( ) ) { oprot . writeString ( struct . buf ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetCursor ( ) ) { oprot . writeI32 ( struct . cursor ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . buf = iprot . readString ( ) ; struct . setBufIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . cursor = iprot . readI32 ( ) ; struct . setCursorIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public completion_result ( ) { }
AntoineAugusti/incubator-zeppelin | public completion_result ( List < String > success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public completion_result ( completion_result other ) { if ( other . isSetSuccess ( ) ) { List < String > __this__success = new ArrayList < String > ( other . success ) ; this . success = __this__success ; } }
AntoineAugusti/incubator-zeppelin | public completion_result deepCopy ( ) { return new completion_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public int getSuccessSize ( ) { return ( this . success == null ) ? 0 : this . success . size ( ) ; }
AntoineAugusti/incubator-zeppelin | public java . util . Iterator < String > getSuccessIterator ( ) { return ( this . success == null ) ? null : this . success . iterator ( ) ; }
AntoineAugusti/incubator-zeppelin | public void addToSuccess ( String elem ) { if ( this . success == null ) { this . success = new ArrayList < String > ( ) ; } this . success . add ( elem ) ; }
AntoineAugusti/incubator-zeppelin | public List < String > getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public completion_result setSuccess ( List < String > success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( List < String > ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof completion_result ) return this . equals ( ( completion_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( completion_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( completion_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " completion _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public completion_resultStandardScheme getScheme ( ) { return new completion_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . LIST ) { { org . apache . thrift . protocol . TList _list10 = iprot . readListBegin ( ) ; struct . success = new ArrayList < String > ( _list10 . size ) ; String _elem11 ; for ( int _i12 = 0 ; _i12 < _list10 . size ; ++ _i12 ) { _elem11 = iprot . readString ( ) ; struct . success . add ( _elem11 ) ; } iprot . readListEnd ( ) ; } struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; { oprot . writeListBegin ( new org . apache . thrift . protocol . TList ( org . apache . thrift . protocol . TType . STRING , struct . success . size ( ) ) ) ; for ( String _iter13 : struct . success ) { oprot . writeString ( _iter13 ) ; } oprot . writeListEnd ( ) ; } oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public completion_resultTupleScheme getScheme ( ) { return new completion_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { { oprot . writeI32 ( struct . success . size ( ) ) ; for ( String _iter14 : struct . success ) { oprot . writeString ( _iter14 ) ; } } }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { { org . apache . thrift . protocol . TList _list15 = new org . apache . thrift . protocol . TList ( org . apache . thrift . protocol . TType . STRING , iprot . readI32 ( ) ) ; struct . success = new ArrayList < String > ( _list15 . size ) ; String _elem16 ; for ( int _i17 = 0 ; _i17 < _list15 . size ; ++ _i17 ) { _elem16 = iprot . readString ( ) ; struct . success . add ( _elem16 ) ; } } struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public shutdown_args ( ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_args ( shutdown_args other ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_args deepCopy ( ) { return new shutdown_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof shutdown_args ) return this . equals ( ( shutdown_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( shutdown_args that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( shutdown_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " shutdown _ args ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_argsStandardScheme getScheme ( ) { return new shutdown_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_argsTupleScheme getScheme ( ) { return new shutdown_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public shutdown_result ( ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_result ( shutdown_result other ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_result deepCopy ( ) { return new shutdown_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof shutdown_result ) return this . equals ( ( shutdown_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( shutdown_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( shutdown_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " shutdown _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_resultStandardScheme getScheme ( ) { return new shutdown_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_resultTupleScheme getScheme ( ) { return new shutdown_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getStatus_args ( String jobId ) { this ( ) ; this . jobId = jobId ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args ( getStatus_args other ) { if ( other . isSetJobId ( ) ) { this . jobId = other . jobId ; } }
AntoineAugusti/incubator-zeppelin | public getStatus_args deepCopy ( ) { return new getStatus_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . jobId = null ; }
AntoineAugusti/incubator-zeppelin | public String getJobId ( ) { return this . jobId ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args setJobId ( String jobId ) { this . jobId = jobId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetJobId ( ) { this . jobId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetJobId ( ) { return this . jobId != null ; }
AntoineAugusti/incubator-zeppelin | public void setJobIdIsSet ( boolean value ) { if ( ! value ) { this . jobId = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case JOB_ID : if ( value == null ) { unsetJobId ( ) ; } else { setJobId ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case JOB_ID : return getJobId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case JOB_ID : return isSetJobId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getStatus_args ) return this . equals ( ( getStatus_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getStatus_args that ) { if ( that == null ) return false ; boolean this_present_jobId = true && this . isSetJobId ( ) ; boolean that_present_jobId = true && that . isSetJobId ( ) ; if ( this_present_jobId || that_present_jobId ) { if ( ! ( this_present_jobId && that_present_jobId ) ) return false ; if ( ! this . jobId . equals ( that . jobId ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_jobId = true && ( isSetJobId ( ) ) ; list . add ( present_jobId ) ; if ( present_jobId ) list . add ( jobId ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getStatus_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetJobId ( ) ) . compareTo ( other . isSetJobId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetJobId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . jobId , other . jobId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getStatus _ args ( " ) ; boolean first = true ; sb . append ( " jobId : " ) ; if ( this . jobId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . jobId ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_argsStandardScheme getScheme ( ) { return new getStatus_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . jobId = iprot . readString ( ) ; struct . setJobIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . jobId != null ) { oprot . writeFieldBegin ( JOB_ID_FIELD_DESC ) ; oprot . writeString ( struct . jobId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_argsTupleScheme getScheme ( ) { return new getStatus_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetJobId ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetJobId ( ) ) { oprot . writeString ( struct . jobId ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . jobId = iprot . readString ( ) ; struct . setJobIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getStatus_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getStatus_result ( String success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public getStatus_result ( getStatus_result other ) { if ( other . isSetSuccess ( ) ) { this . success = other . success ; } }
AntoineAugusti/incubator-zeppelin | public getStatus_result deepCopy ( ) { return new getStatus_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public String getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getStatus_result setSuccess ( String success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getStatus_result ) return this . equals ( ( getStatus_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getStatus_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getStatus_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getStatus _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_resultStandardScheme getScheme ( ) { return new getStatus_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; oprot . writeString ( struct . success ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_resultTupleScheme getScheme ( ) { return new getStatus_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeString ( struct . success ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getEvent_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getEvent_args ( getEvent_args other ) { }
AntoineAugusti/incubator-zeppelin | public getEvent_args deepCopy ( ) { return new getEvent_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getEvent_args ) return this . equals ( ( getEvent_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getEvent_args that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getEvent_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getEvent _ args ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_argsStandardScheme getScheme ( ) { return new getEvent_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_argsTupleScheme getScheme ( ) { return new getEvent_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getEvent_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getEvent_result ( RemoteInterpreterEvent success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public getEvent_result ( getEvent_result other ) { if ( other . isSetSuccess ( ) ) { this . success = new RemoteInterpreterEvent ( other . success ) ; } }
AntoineAugusti/incubator-zeppelin | public getEvent_result deepCopy ( ) { return new getEvent_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterEvent getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getEvent_result setSuccess ( RemoteInterpreterEvent success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( RemoteInterpreterEvent ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getEvent_result ) return this . equals ( ( getEvent_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getEvent_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getEvent_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getEvent _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( success != null ) { success . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_resultStandardScheme getScheme ( ) { return new getEvent_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . success = new RemoteInterpreterEvent ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; struct . success . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_resultTupleScheme getScheme ( ) { return new getEvent_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { struct . success . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = new RemoteInterpreterEvent ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args ( String name , String noteId , String object ) { this ( ) ; this . name = name ; this . noteId = noteId ; this . object = object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args ( angularObjectUpdate_args other ) { if ( other . isSetName ( ) ) { this . name = other . name ; } if ( other . isSetNoteId ( ) ) { this . noteId = other . noteId ; } if ( other . isSetObject ( ) ) { this . object = other . object ; } }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args deepCopy ( ) { return new angularObjectUpdate_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . name = null ; this . noteId = null ; this . object = null ; }
AntoineAugusti/incubator-zeppelin | public String getName ( ) { return this . name ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args setName ( String name ) { this . name = name ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetName ( ) { this . name = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetName ( ) { return this . name != null ; }
AntoineAugusti/incubator-zeppelin | public void setNameIsSet ( boolean value ) { if ( ! value ) { this . name = null ; } }
AntoineAugusti/incubator-zeppelin | public String getNoteId ( ) { return this . noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args setNoteId ( String noteId ) { this . noteId = noteId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetNoteId ( ) { this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetNoteId ( ) { return this . noteId != null ; }
AntoineAugusti/incubator-zeppelin | public void setNoteIdIsSet ( boolean value ) { if ( ! value ) { this . noteId = null ; } }
AntoineAugusti/incubator-zeppelin | public String getObject ( ) { return this . object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args setObject ( String object ) { this . object = object ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetObject ( ) { this . object = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetObject ( ) { return this . object != null ; }
AntoineAugusti/incubator-zeppelin | public void setObjectIsSet ( boolean value ) { if ( ! value ) { this . object = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case NAME : if ( value == null ) { unsetName ( ) ; } else { setName ( ( String ) value ) ; } break ; case NOTE_ID : if ( value == null ) { unsetNoteId ( ) ; } else { setNoteId ( ( String ) value ) ; } break ; case OBJECT : if ( value == null ) { unsetObject ( ) ; } else { setObject ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case NAME : return getName ( ) ; case NOTE_ID : return getNoteId ( ) ; case OBJECT : return getObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case NAME : return isSetName ( ) ; case NOTE_ID : return isSetNoteId ( ) ; case OBJECT : return isSetObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectUpdate_args ) return this . equals ( ( angularObjectUpdate_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectUpdate_args that ) { if ( that == null ) return false ; boolean this_present_name = true && this . isSetName ( ) ; boolean that_present_name = true && that . isSetName ( ) ; if ( this_present_name || that_present_name ) { if ( ! ( this_present_name && that_present_name ) ) return false ; if ( ! this . name . equals ( that . name ) ) return false ; } boolean this_present_noteId = true && this . isSetNoteId ( ) ; boolean that_present_noteId = true && that . isSetNoteId ( ) ; if ( this_present_noteId || that_present_noteId ) { if ( ! ( this_present_noteId && that_present_noteId ) ) return false ; if ( ! this . noteId . equals ( that . noteId ) ) return false ; } boolean this_present_object = true && this . isSetObject ( ) ; boolean that_present_object = true && that . isSetObject ( ) ; if ( this_present_object || that_present_object ) { if ( ! ( this_present_object && that_present_object ) ) return false ; if ( ! this . object . equals ( that . object ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_name = true && ( isSetName ( ) ) ; list . add ( present_name ) ; if ( present_name ) list . add ( name ) ; boolean present_noteId = true && ( isSetNoteId ( ) ) ; list . add ( present_noteId ) ; if ( present_noteId ) list . add ( noteId ) ; boolean present_object = true && ( isSetObject ( ) ) ; list . add ( present_object ) ; if ( present_object ) list . add ( object ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectUpdate_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetName ( ) ) . compareTo ( other . isSetName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . name , other . name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetNoteId ( ) ) . compareTo ( other . isSetNoteId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetNoteId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . noteId , other . noteId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetObject ( ) ) . compareTo ( other . isSetObject ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetObject ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . object , other . object ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectUpdate _ args ( " ) ; boolean first = true ; sb . append ( " name : " ) ; if ( this . name == null ) { sb . append ( " null " ) ; } else { sb . append ( this . name ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " noteId : " ) ; if ( this . noteId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . noteId ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " object : " ) ; if ( this . object == null ) { sb . append ( " null " ) ; } else { sb . append ( this . object ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_argsStandardScheme getScheme ( ) { return new angularObjectUpdate_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . name != null ) { oprot . writeFieldBegin ( NAME_FIELD_DESC ) ; oprot . writeString ( struct . name ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . noteId != null ) { oprot . writeFieldBegin ( NOTE_ID_FIELD_DESC ) ; oprot . writeString ( struct . noteId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . object != null ) { oprot . writeFieldBegin ( OBJECT_FIELD_DESC ) ; oprot . writeString ( struct . object ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_argsTupleScheme getScheme ( ) { return new angularObjectUpdate_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { oprot . writeString ( struct . name ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { oprot . writeString ( struct . noteId ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { oprot . writeString ( struct . object ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_result ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_result ( angularObjectUpdate_result other ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_result deepCopy ( ) { return new angularObjectUpdate_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectUpdate_result ) return this . equals ( ( angularObjectUpdate_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectUpdate_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectUpdate_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectUpdate _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_resultStandardScheme getScheme ( ) { return new angularObjectUpdate_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_resultTupleScheme getScheme ( ) { return new angularObjectUpdate_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args ( String name , String noteId , String object ) { this ( ) ; this . name = name ; this . noteId = noteId ; this . object = object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args ( angularObjectAdd_args other ) { if ( other . isSetName ( ) ) { this . name = other . name ; } if ( other . isSetNoteId ( ) ) { this . noteId = other . noteId ; } if ( other . isSetObject ( ) ) { this . object = other . object ; } }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args deepCopy ( ) { return new angularObjectAdd_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . name = null ; this . noteId = null ; this . object = null ; }
AntoineAugusti/incubator-zeppelin | public String getName ( ) { return this . name ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args setName ( String name ) { this . name = name ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetName ( ) { this . name = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetName ( ) { return this . name != null ; }
AntoineAugusti/incubator-zeppelin | public void setNameIsSet ( boolean value ) { if ( ! value ) { this . name = null ; } }
AntoineAugusti/incubator-zeppelin | public String getNoteId ( ) { return this . noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args setNoteId ( String noteId ) { this . noteId = noteId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetNoteId ( ) { this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetNoteId ( ) { return this . noteId != null ; }
AntoineAugusti/incubator-zeppelin | public void setNoteIdIsSet ( boolean value ) { if ( ! value ) { this . noteId = null ; } }
AntoineAugusti/incubator-zeppelin | public String getObject ( ) { return this . object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args setObject ( String object ) { this . object = object ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetObject ( ) { this . object = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetObject ( ) { return this . object != null ; }
AntoineAugusti/incubator-zeppelin | public void setObjectIsSet ( boolean value ) { if ( ! value ) { this . object = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case NAME : if ( value == null ) { unsetName ( ) ; } else { setName ( ( String ) value ) ; } break ; case NOTE_ID : if ( value == null ) { unsetNoteId ( ) ; } else { setNoteId ( ( String ) value ) ; } break ; case OBJECT : if ( value == null ) { unsetObject ( ) ; } else { setObject ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case NAME : return getName ( ) ; case NOTE_ID : return getNoteId ( ) ; case OBJECT : return getObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case NAME : return isSetName ( ) ; case NOTE_ID : return isSetNoteId ( ) ; case OBJECT : return isSetObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectAdd_args ) return this . equals ( ( angularObjectAdd_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectAdd_args that ) { if ( that == null ) return false ; boolean this_present_name = true && this . isSetName ( ) ; boolean that_present_name = true && that . isSetName ( ) ; if ( this_present_name || that_present_name ) { if ( ! ( this_present_name && that_present_name ) ) return false ; if ( ! this . name . equals ( that . name ) ) return false ; } boolean this_present_noteId = true && this . isSetNoteId ( ) ; boolean that_present_noteId = true && that . isSetNoteId ( ) ; if ( this_present_noteId || that_present_noteId ) { if ( ! ( this_present_noteId && that_present_noteId ) ) return false ; if ( ! this . noteId . equals ( that . noteId ) ) return false ; } boolean this_present_object = true && this . isSetObject ( ) ; boolean that_present_object = true && that . isSetObject ( ) ; if ( this_present_object || that_present_object ) { if ( ! ( this_present_object && that_present_object ) ) return false ; if ( ! this . object . equals ( that . object ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_name = true && ( isSetName ( ) ) ; list . add ( present_name ) ; if ( present_name ) list . add ( name ) ; boolean present_noteId = true && ( isSetNoteId ( ) ) ; list . add ( present_noteId ) ; if ( present_noteId ) list . add ( noteId ) ; boolean present_object = true && ( isSetObject ( ) ) ; list . add ( present_object ) ; if ( present_object ) list . add ( object ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectAdd_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetName ( ) ) . compareTo ( other . isSetName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . name , other . name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetNoteId ( ) ) . compareTo ( other . isSetNoteId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetNoteId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . noteId , other . noteId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetObject ( ) ) . compareTo ( other . isSetObject ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetObject ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . object , other . object ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectAdd _ args ( " ) ; boolean first = true ; sb . append ( " name : " ) ; if ( this . name == null ) { sb . append ( " null " ) ; } else { sb . append ( this . name ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " noteId : " ) ; if ( this . noteId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . noteId ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " object : " ) ; if ( this . object == null ) { sb . append ( " null " ) ; } else { sb . append ( this . object ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_argsStandardScheme getScheme ( ) { return new angularObjectAdd_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . name != null ) { oprot . writeFieldBegin ( NAME_FIELD_DESC ) ; oprot . writeString ( struct . name ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . noteId != null ) { oprot . writeFieldBegin ( NOTE_ID_FIELD_DESC ) ; oprot . writeString ( struct . noteId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . object != null ) { oprot . writeFieldBegin ( OBJECT_FIELD_DESC ) ; oprot . writeString ( struct . object ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_argsTupleScheme getScheme ( ) { return new angularObjectAdd_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { oprot . writeString ( struct . name ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { oprot . writeString ( struct . noteId ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { oprot . writeString ( struct . object ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_result ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_result ( angularObjectAdd_result other ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_result deepCopy ( ) { return new angularObjectAdd_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectAdd_result ) return this . equals ( ( angularObjectAdd_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectAdd_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectAdd_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectAdd _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_resultStandardScheme getScheme ( ) { return new angularObjectAdd_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_resultTupleScheme getScheme ( ) { return new angularObjectAdd_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args ( String name , String noteId ) { this ( ) ; this . name = name ; this . noteId = noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args ( angularObjectRemove_args other ) { if ( other . isSetName ( ) ) { this . name = other . name ; } if ( other . isSetNoteId ( ) ) { this . noteId = other . noteId ; } }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args deepCopy ( ) { return new angularObjectRemove_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . name = null ; this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public String getName ( ) { return this . name ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args setName ( String name ) { this . name = name ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetName ( ) { this . name = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetName ( ) { return this . name != null ; }
AntoineAugusti/incubator-zeppelin | public void setNameIsSet ( boolean value ) { if ( ! value ) { this . name = null ; } }
AntoineAugusti/incubator-zeppelin | public String getNoteId ( ) { return this . noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args setNoteId ( String noteId ) { this . noteId = noteId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetNoteId ( ) { this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetNoteId ( ) { return this . noteId != null ; }
AntoineAugusti/incubator-zeppelin | public void setNoteIdIsSet ( boolean value ) { if ( ! value ) { this . noteId = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case NAME : if ( value == null ) { unsetName ( ) ; } else { setName ( ( String ) value ) ; } break ; case NOTE_ID : if ( value == null ) { unsetNoteId ( ) ; } else { setNoteId ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case NAME : return getName ( ) ; case NOTE_ID : return getNoteId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case NAME : return isSetName ( ) ; case NOTE_ID : return isSetNoteId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectRemove_args ) return this . equals ( ( angularObjectRemove_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectRemove_args that ) { if ( that == null ) return false ; boolean this_present_name = true && this . isSetName ( ) ; boolean that_present_name = true && that . isSetName ( ) ; if ( this_present_name || that_present_name ) { if ( ! ( this_present_name && that_present_name ) ) return false ; if ( ! this . name . equals ( that . name ) ) return false ; } boolean this_present_noteId = true && this . isSetNoteId ( ) ; boolean that_present_noteId = true && that . isSetNoteId ( ) ; if ( this_present_noteId || that_present_noteId ) { if ( ! ( this_present_noteId && that_present_noteId ) ) return false ; if ( ! this . noteId . equals ( that . noteId ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_name = true && ( isSetName ( ) ) ; list . add ( present_name ) ; if ( present_name ) list . add ( name ) ; boolean present_noteId = true && ( isSetNoteId ( ) ) ; list . add ( present_noteId ) ; if ( present_noteId ) list . add ( noteId ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectRemove_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetName ( ) ) . compareTo ( other . isSetName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . name , other . name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetNoteId ( ) ) . compareTo ( other . isSetNoteId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetNoteId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . noteId , other . noteId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectRemove _ args ( " ) ; boolean first = true ; sb . append ( " name : " ) ; if ( this . name == null ) { sb . append ( " null " ) ; } else { sb . append ( this . name ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " noteId : " ) ; if ( this . noteId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . noteId ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_argsStandardScheme getScheme ( ) { return new angularObjectRemove_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . name != null ) { oprot . writeFieldBegin ( NAME_FIELD_DESC ) ; oprot . writeString ( struct . name ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . noteId != null ) { oprot . writeFieldBegin ( NOTE_ID_FIELD_DESC ) ; oprot . writeString ( struct . noteId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_argsTupleScheme getScheme ( ) { return new angularObjectRemove_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { oprot . writeString ( struct . name ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { oprot . writeString ( struct . noteId ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_result ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_result ( angularObjectRemove_result other ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_result deepCopy ( ) { return new angularObjectRemove_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectRemove_result ) return this . equals ( ( angularObjectRemove_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectRemove_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectRemove_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectRemove _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_resultStandardScheme getScheme ( ) { return new angularObjectRemove_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_resultTupleScheme getScheme ( ) { return new angularObjectRemove_resultTupleScheme ( ) ; }
kzm4269/plen__Scenography_for_Android | protected ReadOnlyProperty ( @ NonNull Observable < T > observable ) { mObservable = Observable . concat ( Observable . just ( null ) , observable ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull public final Observable < T > asObservable ( ) { return mObservable . skip ( 1 ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull public final Optional < T > get ( ) { return getLatest ( ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull protected Optional < T > getLatest ( ) { try { return Optional . ofNullable ( mObservable . toBlocking ( ) . latest ( ) . iterator ( ) . next ( ) ) ; } catch ( NoSuchElementException e ) { return Optional . ofNullable ( mObservable . toBlocking ( ) . last ( ) ) ; } }
iYefeng/Odin | public Agent ( Configure conf ) { super ( conf ) ; this . workersPool = WorkersPool . getSingleton ( ) ; }
iYefeng/Odin | public WorkersPool getWorkersPool ( ) { return workersPool ; }
iYefeng/Odin | public void init ( ) { }
iYefeng/Odin | public void start ( ) { }
iYefeng/Odin | public void stop ( ) { }
xzjxylophone/RXJavaDemo | public int getId ( ) { return id ; }
xzjxylophone/RXJavaDemo | public void setId ( int id ) { this . id = id ; }
xzjxylophone/RXJavaDemo | public String getUserName ( ) { return userName == null ? " " : userName ; }
xzjxylophone/RXJavaDemo | public void setUserName ( String userName ) { this . userName = userName == null ? null : userName . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getRealName ( ) { return realName == null ? " " : realName ; }
xzjxylophone/RXJavaDemo | public void setRealName ( String realName ) { this . realName = realName == null ? null : realName . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getPwd ( ) { return pwd == null ? " " : pwd ; }
xzjxylophone/RXJavaDemo | public void setPwd ( String pwd ) { this . pwd = pwd == null ? null : pwd . trim ( ) ; }
xzjxylophone/RXJavaDemo | public int getSex ( ) { return sex ; }
xzjxylophone/RXJavaDemo | public void setSex ( int sex ) { this . sex = sex ; }
xzjxylophone/RXJavaDemo | public Date getBirthdate ( ) { return birthdate ; }
xzjxylophone/RXJavaDemo | public void setBirthdate ( Date birthdate ) { this . birthdate = birthdate ; }
xzjxylophone/RXJavaDemo | public String getMobile ( ) { return mobile == null ? " " : mobile ; }
xzjxylophone/RXJavaDemo | public void setMobile ( String mobile ) { this . mobile = mobile == null ? null : mobile . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getEmail ( ) { return email == null ? " " : email ; }
xzjxylophone/RXJavaDemo | public void setEmail ( String email ) { this . email = email == null ? null : email . trim ( ) ; }
xzjxylophone/RXJavaDemo | public int getStatus ( ) { return status ; }
xzjxylophone/RXJavaDemo | public void setStatus ( int status ) { this . status = status ; }
xzjxylophone/RXJavaDemo | public int getCreateUser ( ) { return createUser ; }
xzjxylophone/RXJavaDemo | public void setCreateUser ( int createUser ) { this . createUser = createUser ; }
xzjxylophone/RXJavaDemo | public Date getCreateTime ( ) { return createTime ; }
xzjxylophone/RXJavaDemo | public void setCreateTime ( Date createTime ) { this . createTime = createTime ; }
xzjxylophone/RXJavaDemo | public int getUpdateUser ( ) { return updateUser ; }
xzjxylophone/RXJavaDemo | public void setUpdateUser ( int updateUser ) { this . updateUser = updateUser ; }
xzjxylophone/RXJavaDemo | public Date getUpdateTime ( ) { return updateTime ; }
xzjxylophone/RXJavaDemo | public void setUpdateTime ( Date updateTime ) { this . updateTime = updateTime ; }
xzjxylophone/RXJavaDemo | public int getDelFlag ( ) { return delFlag ; }
xzjxylophone/RXJavaDemo | public void setDelFlag ( int delFlag ) { this . delFlag = delFlag ; }
xzjxylophone/RXJavaDemo | public String getField1 ( ) { return field1 == null ? " " : field1 ; }
xzjxylophone/RXJavaDemo | public void setField1 ( String field1 ) { this . field1 = field1 == null ? null : field1 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField2 ( ) { return field2 == null ? " " : field2 ; }
xzjxylophone/RXJavaDemo | public void setField2 ( String field2 ) { this . field2 = field2 == null ? null : field2 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField3 ( ) { return field3 == null ? " " : field3 ; }
xzjxylophone/RXJavaDemo | public void setField3 ( String field3 ) { this . field3 = field3 == null ? null : field3 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField4 ( ) { return field4 == null ? " " : field4 ; }
xzjxylophone/RXJavaDemo | public void setField4 ( String field4 ) { this . field4 = field4 == null ? null : field4 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField5 ( ) { return field5 == null ? " " : field5 ; }
xzjxylophone/RXJavaDemo | public void setField5 ( String field5 ) { this . field5 = field5 == null ? null : field5 . trim ( ) ; }
AbfrmBlr/ehcache3 | @ Test public void testGetField ( ) throws Exception { @ SuppressWarnings ( " unchecked " ) StatefulSerializer < Serializable > s = new CompactJavaSerializer < > ( null ) ; s . init ( new TransientStateRepository ( ) ) ; ClassLoader loaderA = createClassNameRewritingLoader ( Foo_A . class ) ; Serializable a = ( Serializable ) loaderA . loadClass ( newClassName ( Foo_A . class ) ) . newInstance ( ) ; ByteBuffer encodedA = s . serialize ( a ) ; pushTccl ( createClassNameRewritingLoader ( Foo_B . class ) ) ; try { s . read ( encodedA . duplicate ( ) ) ; } finally { popTccl ( ) ; } pushTccl ( createClassNameRewritingLoader ( Foo_C . class ) ) ; try { s . read ( encodedA . duplicate ( ) ) ; } finally { popTccl ( ) ; } }
AbfrmBlr/ehcache3 | if ( ! fields . defaulted ( " blargh " ) ) { throw new Error ( ) ; }
AbfrmBlr/ehcache3 | catch ( IllegalArgumentException ex ) { }
AbfrmBlr/ehcache3 | if ( ( fields . get ( " z " , false ) != true ) || ( fields . get ( " b " , ( byte ) 0 ) != 5 ) || ( fields . get ( " c " , '0' ) != '5' ) || ( fields . get ( " s " , ( short ) 0 ) != 5 ) || ( fields . get ( " i " , 0 ) != 5 ) || ( fields . get ( " j " , 0l ) != 5 ) || ( fields . get ( " f " , 0.0f ) != 5.0f ) || ( fields . get ( " d " , 0.0 ) != 5.0 ) || ( ! fields . get ( " str " , null ) . equals ( "5" ) ) ) { throw new Error ( ) ; }
AbfrmBlr/ehcache3 | if ( ( fields . get ( " z " , false ) != true ) || ( fields . get ( " b " , ( byte ) 0 ) != 5 ) || ( fields . get ( " c " , '0' ) != '5' ) || ( fields . get ( " s " , ( short ) 0 ) != 5 ) || ( fields . get ( " i " , 0 ) != 5 ) || ( fields . get ( " j " , 0l ) != 5 ) || ( fields . get ( " f " , 0.0f ) != 5.0f ) || ( fields . get ( " d " , 0.0 ) != 5.0 ) || ( ! fields . get ( " str " , null ) . equals ( "5" ) ) ) { throw new Error ( ) ; }
DBSI-BI/saiku | public void setDatasourceManager ( IDatasourceManager dms ) { this . datasourceManager = dms ; }
DBSI-BI/saiku | public void init ( ) { try { DefaultFileSystemManager dfsm = ( DefaultFileSystemManager ) VFS . getManager ( ) ; if ( ! dfsm . hasProvider ( " mondrian " ) ) { dfsm . addProvider ( " mondrian " , this ) ; } } catch ( FileSystemException e ) { } }
DBSI-BI/saiku | public FileObject findFile ( FileObject fileObject , String catalog , FileSystemOptions fileSystemOptions ) throws FileSystemException { return new RepositoryVfsFileObject ( catalog , this . datasourceManager ) ; }
DBSI-BI/saiku | public FileObject createFileSystem ( String s , FileObject fileObject , FileSystemOptions fileSystemOptions ) throws FileSystemException { return null ; }
DBSI-BI/saiku | public FileSystemConfigBuilder getConfigBuilder ( ) { return null ; }
DBSI-BI/saiku | public Collection getCapabilities ( ) { return null ; }
DBSI-BI/saiku | public FileName parseUri ( FileName fileName , String s ) throws FileSystemException { return null ; }
dukechain/Qassandra | private LeveledManifest ( ColumnFamilyStore cfs , int maxSSTableSizeInMB , SizeTieredCompactionStrategyOptions options ) { this . cfs = cfs ; this . maxSSTableSizeInBytes = maxSSTableSizeInMB * 1024 * 1024 ; this . options = options ; int n = ( int ) Math . log10 ( 1000 * 1000 * 1000 / maxSSTableSizeInMB ) ; generations = new List [ n ] ; lastCompactedKeys = new RowPosition [ n ] ; for ( int i = 0 ; i < generations . length ; i ++ ) { generations [ i ] = new ArrayList < SSTableReader > ( ) ; lastCompactedKeys [ i ] = cfs . partitioner . getMinimumToken ( ) . minKeyBound ( ) ; } }
dukechain/Qassandra | public synchronized void add ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level < generations . length : " Invalid ▁ level ▁ " + level + " ▁ out ▁ of ▁ " + ( generations . length - 1 ) ; logDistribution ( ) ; logger . debug ( " Adding ▁ { } ▁ to ▁ L { } " , reader , level ) ; generations [ level ] . add ( reader ) ; }
dukechain/Qassandra | private int skipLevels ( int newLevel , Iterable < SSTableReader > added ) { while ( maxBytesForLevel ( newLevel ) < SSTableReader . getTotalBytes ( added ) && generations [ ( newLevel + 1 ) ] . isEmpty ( ) ) { newLevel ++ ; } return newLevel ; }
dukechain/Qassandra | public synchronized void replace ( Iterable < SSTableReader > removed , Iterable < SSTableReader > added ) { assert ! Iterables . isEmpty ( removed ) ; logDistribution ( ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Replacing ▁ [ " + toString ( removed ) + " ] " ) ; for ( SSTableReader sstable : removed ) remove ( sstable ) ; if ( ! added . iterator ( ) . hasNext ( ) ) return ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Adding ▁ [ { } ] " , toString ( added ) ) ; int minLevel = Integer . MAX_VALUE ; for ( SSTableReader ssTableReader : added ) { minLevel = Math . min ( minLevel , ssTableReader . getSSTableLevel ( ) ) ; add ( ssTableReader ) ; } lastCompactedKeys [ minLevel ] = SSTable . sstableOrdering . max ( added ) . last ; }
dukechain/Qassandra | public synchronized void repairOverlappingSSTables ( int level ) { SSTableReader previous = null ; Collections . sort ( generations [ level ] , SSTable . sstableComparator ) ; List < SSTableReader > outOfOrderSSTables = new ArrayList < SSTableReader > ( ) ; for ( SSTableReader current : generations [ level ] ) { if ( previous != null && current . first . compareTo ( previous . last ) <= 0 ) { logger . warn ( String . format ( " At ▁ level ▁ % d , ▁ % s ▁ [ % s , ▁ % s ] ▁ overlaps ▁ % s ▁ [ % s , ▁ % s ] . ▁ ▁ This ▁ could ▁ be ▁ caused ▁ by ▁ a ▁ bug ▁ in ▁ Cassandra ▁ 1.1.0 ▁ . . ▁ 1.1.3 ▁ or ▁ due ▁ to ▁ the ▁ fact ▁ that ▁ you ▁ have ▁ dropped ▁ sstables ▁ from ▁ another ▁ node ▁ into ▁ the ▁ data ▁ directory . ▁ " + " Sending ▁ back ▁ to ▁ L0 . ▁ ▁ If ▁ you ▁ didn ' t ▁ drop ▁ in ▁ sstables , ▁ and ▁ have ▁ not ▁ yet ▁ run ▁ scrub , ▁ you ▁ should ▁ do ▁ so ▁ since ▁ you ▁ may ▁ also ▁ have ▁ rows ▁ out - of - order ▁ within ▁ an ▁ sstable " , level , previous , previous . first , previous . last , current , current . first , current . last ) ) ; outOfOrderSSTables . add ( current ) ; } else { previous = current ; } } if ( ! outOfOrderSSTables . isEmpty ( ) ) { for ( SSTableReader sstable : outOfOrderSSTables ) sendBackToL0 ( sstable ) ; } }
dukechain/Qassandra | private synchronized void sendBackToL0 ( SSTableReader sstable ) { remove ( sstable ) ; String metaDataFile = sstable . descriptor . filenameFor ( Component . STATS ) ; try { mutateLevel ( sstable . getSSTableMetadata ( ) , sstable . descriptor , metaDataFile , 0 ) ; sstable . reloadSSTableMetadata ( ) ; add ( sstable ) ; } catch ( IOException e ) { throw new RuntimeException ( " Could ▁ not ▁ reload ▁ sstable ▁ meta ▁ data " , e ) ; } }
dukechain/Qassandra | private String toString ( Iterable < SSTableReader > sstables ) { StringBuilder builder = new StringBuilder ( ) ; for ( SSTableReader sstable : sstables ) { builder . append ( sstable . descriptor . cfname ) . append ( ' - ' ) . append ( sstable . descriptor . generation ) . append ( " ( L " ) . append ( sstable . getSSTableLevel ( ) ) . append ( " ) , ▁ " ) ; } return builder . toString ( ) ; }
dukechain/Qassandra | @ VisibleForTesting long maxBytesForLevel ( int level ) { if ( level == 0 ) return 4L * maxSSTableSizeInBytes ; double bytes = Math . pow ( 10 , level ) * maxSSTableSizeInBytes ; if ( bytes > Long . MAX_VALUE ) throw new RuntimeException ( " At ▁ most ▁ " + Long . MAX_VALUE + " ▁ bytes ▁ may ▁ be ▁ in ▁ a ▁ compaction ▁ level ; ▁ your ▁ maxSSTableSize ▁ must ▁ be ▁ absurdly ▁ high ▁ to ▁ compute ▁ " + bytes ) ; return ( long ) bytes ; }
dukechain/Qassandra | public synchronized Pair < ? extends Collection < SSTableReader > , Integer > getCompactionCandidates ( ) { for ( int i = generations . length - 1 ; i > 0 ; i -- ) { List < SSTableReader > sstables = generations [ i ] ; if ( sstables . isEmpty ( ) ) continue ; Set < SSTableReader > sstablesInLevel = Sets . newHashSet ( sstables ) ; Set < SSTableReader > remaining = Sets . difference ( sstablesInLevel , cfs . getDataTracker ( ) . getCompacting ( ) ) ; double score = ( double ) SSTableReader . getTotalBytes ( remaining ) / ( double ) maxBytesForLevel ( i ) ; logger . debug ( " Compaction ▁ score ▁ for ▁ level ▁ { } ▁ is ▁ { } " , i , score ) ; if ( score > 1.001 ) { if ( generations [ 0 ] . size ( ) > MAX_COMPACTING_L0 ) { Iterable < SSTableReader > candidates = cfs . getDataTracker ( ) . getUncompactingSSTables ( generations [ 0 ] ) ; List < Pair < SSTableReader , Long > > pairs = SizeTieredCompactionStrategy . createSSTableAndLengthPairs ( AbstractCompactionStrategy . filterSuspectSSTables ( candidates ) ) ; List < List < SSTableReader > > buckets = SizeTieredCompactionStrategy . getBuckets ( pairs , options . bucketHigh , options . bucketLow , options . minSSTableSize ) ; List < SSTableReader > mostInteresting = SizeTieredCompactionStrategy . mostInterestingBucket ( buckets , 4 , 32 ) ; if ( ! mostInteresting . isEmpty ( ) ) return Pair . create ( mostInteresting , 0 ) ; } Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Compaction ▁ candidates ▁ for ▁ L { } ▁ are ▁ { } " , i , toString ( candidates ) ) ; if ( ! candidates . isEmpty ( ) ) return Pair . create ( candidates , getNextLevel ( candidates ) ) ; } } if ( generations [ 0 ] . isEmpty ( ) ) return null ; Collection < SSTableReader > candidates = getCandidatesFor ( 0 ) ; if ( candidates . isEmpty ( ) ) return null ; return Pair . create ( candidates , getNextLevel ( candidates ) ) ; }
dukechain/Qassandra | public synchronized int getLevelSize ( int i ) { if ( i >= generations . length ) throw new ArrayIndexOutOfBoundsException ( " Maximum ▁ valid ▁ generation ▁ is ▁ " + ( generations . length - 1 ) ) ; return generations [ i ] . size ( ) ; }
dukechain/Qassandra | public synchronized int [ ] getAllLevelSize ( ) { int [ ] counts = new int [ generations . length ] ; for ( int i = 0 ; i < counts . length ; i ++ ) counts [ i ] = generations [ i ] . size ( ) ; return counts ; }
dukechain/Qassandra | private void logDistribution ( ) { if ( logger . isDebugEnabled ( ) ) { for ( int i = 0 ; i < generations . length ; i ++ ) { if ( ! generations [ i ] . isEmpty ( ) ) { logger . debug ( " L { } ▁ contains ▁ { } ▁ SSTables ▁ ( { } ▁ bytes ) ▁ in ▁ { } " , i , generations [ i ] . size ( ) , SSTableReader . getTotalBytes ( generations [ i ] ) , this ) ; } } } }
dukechain/Qassandra | @ VisibleForTesting public int remove ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level >= 0 : reader + " ▁ not ▁ present ▁ in ▁ manifest : ▁ " + level ; generations [ level ] . remove ( reader ) ; return level ; }
dukechain/Qassandra | private Collection < SSTableReader > getCandidatesFor ( int level ) { assert ! generations [ level ] . isEmpty ( ) ; logger . debug ( " Choosing ▁ candidates ▁ for ▁ L { } " , level ) ; final Set < SSTableReader > compacting = cfs . getDataTracker ( ) . getCompacting ( ) ; if ( level == 0 ) { Set < SSTableReader > candidates = new HashSet < SSTableReader > ( ) ; Set < SSTableReader > remaining = new HashSet < SSTableReader > ( ) ; Iterables . addAll ( remaining , Iterables . filter ( generations [ 0 ] , Predicates . not ( suspectP ) ) ) ; for ( SSTableReader sstable : ageSortedSSTables ( remaining ) ) { if ( candidates . contains ( sstable ) ) continue ; for ( SSTableReader newCandidate : Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , remaining ) ) ) { if ( ! compacting . contains ( newCandidate ) ) { candidates . add ( newCandidate ) ; remaining . remove ( newCandidate ) ; } } if ( candidates . size ( ) > MAX_COMPACTING_L0 ) { candidates = new HashSet < SSTableReader > ( ageSortedSSTables ( candidates ) . subList ( 0 , MAX_COMPACTING_L0 ) ) ; break ; } } if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) { candidates = Sets . union ( candidates , overlapping ( candidates , generations [ 1 ] ) ) ; Iterable < SSTableReader > compactingL0 = Iterables . filter ( generations [ 0 ] , Predicates . in ( compacting ) ) ; if ( ! Sets . intersection ( candidates , compacting ) . isEmpty ( ) || ! overlapping ( candidates , compactingL0 ) . isEmpty ( ) ) return Collections . emptyList ( ) ; } return candidates . size ( ) > 1 ? candidates : Collections . < SSTableReader > emptyList ( ) ; } Collections . sort ( generations [ level ] , SSTable . sstableComparator ) ; int start = 0 ; for ( int i = 0 ; i < generations [ level ] . size ( ) ; i ++ ) { SSTableReader sstable = generations [ level ] . get ( i ) ; if ( sstable . first . compareTo ( lastCompactedKeys [ level ] ) > 0 ) { start = i ; break ; } } for ( int i = 0 ; i < generations [ level ] . size ( ) ; i ++ ) { SSTableReader sstable = generations [ level ] . get ( ( start + i ) % generations [ level ] . size ( ) ) ; Set < SSTableReader > candidates = Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , generations [ level + 1 ] ) ) ; if ( Iterables . any ( candidates , suspectP ) ) continue ; if ( Sets . intersection ( candidates , compacting ) . isEmpty ( ) ) return candidates ; } return Collections . emptyList ( ) ; }
dukechain/Qassandra | private List < SSTableReader > ageSortedSSTables ( Collection < SSTableReader > candidates ) { List < SSTableReader > ageSortedCandidates = new ArrayList < SSTableReader > ( candidates ) ; Collections . sort ( ageSortedCandidates , SSTable . maxTimestampComparator ) ; return ageSortedCandidates ; }
dukechain/Qassandra | @ Override public String toString ( ) { return " Manifest @ " + hashCode ( ) ; }
dukechain/Qassandra | public int getLevelCount ( ) { for ( int i = generations . length - 1 ; i >= 0 ; i -- ) { if ( generations [ i ] . size ( ) > 0 ) return i ; } return 0 ; }
dukechain/Qassandra | public synchronized SortedSet < SSTableReader > getLevelSorted ( int level , Comparator < SSTableReader > comparator ) { return ImmutableSortedSet . copyOf ( comparator , generations [ level ] ) ; }
dukechain/Qassandra | public List < SSTableReader > getLevel ( int i ) { return generations [ i ] ; }
dukechain/Qassandra | public synchronized int getEstimatedTasks ( ) { long tasks = 0 ; long [ ] estimated = new long [ generations . length ] ; for ( int i = generations . length - 1 ; i >= 0 ; i -- ) { List < SSTableReader > sstables = generations [ i ] ; estimated [ i ] = Math . max ( 0L , SSTableReader . getTotalBytes ( sstables ) - maxBytesForLevel ( i ) ) / maxSSTableSizeInBytes ; tasks += estimated [ i ] ; } logger . debug ( " Estimating ▁ { } ▁ compactions ▁ to ▁ do ▁ for ▁ { } . { } " , Arrays . toString ( estimated ) , cfs . table . getName ( ) , cfs . name ) ; return Ints . checkedCast ( tasks ) ; }
dukechain/Qassandra | public int getNextLevel ( Collection < SSTableReader > sstables ) { int maximumLevel = Integer . MIN_VALUE ; int minimumLevel = Integer . MAX_VALUE ; for ( SSTableReader sstable : sstables ) { maximumLevel = Math . max ( sstable . getSSTableLevel ( ) , maximumLevel ) ; minimumLevel = Math . min ( sstable . getSSTableLevel ( ) , minimumLevel ) ; } int newLevel ; if ( minimumLevel == 0 && minimumLevel == maximumLevel && SSTable . getTotalBytes ( sstables ) < maxSSTableSizeInBytes ) { newLevel = 0 ; } else { newLevel = minimumLevel == maximumLevel ? maximumLevel + 1 : maximumLevel ; newLevel = skipLevels ( newLevel , sstables ) ; assert newLevel > 0 ; } return newLevel ; }
Bernardo-MG/Tabletop-Pendragon-Model | public DefaultPet ( final DefaultPet pet ) { super ( ) ; checkNotNull ( pet , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ pet " ) ; name = pet . name ; rolltable = pet . rolltable ; }
Bernardo-MG/Tabletop-Pendragon-Model | public DefaultPet ( final String name , final IntervalTable < AnimalYearResult > rolltable ) { super ( ) ; checkNotNull ( name , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ name " ) ; checkNotNull ( rolltable , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ roll ▁ table " ) ; this . name = name ; this . rolltable = rolltable ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final DefaultPet createNewInstance ( ) { return new DefaultPet ( this ) ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final boolean equals ( final Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; DefaultPet other = ( DefaultPet ) obj ; return Objects . equals ( name , other . name ) ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final IntervalTable < AnimalYearResult > getAnnualCheckMap ( ) { return rolltable ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final String getName ( ) { return name ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final int hashCode ( ) { return Objects . hashCode ( name ) ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " name " , name ) . toString ( ) ; }
GrandathePanda/MarioAIImplementation | private Tile ( String debug , int code , int ... zLevels ) { this . debug = debug ; this . code = code ; this . zLevels = zLevels ; }
GrandathePanda/MarioAIImplementation | public int getCode ( ) { return code ; }
GrandathePanda/MarioAIImplementation | public int [ ] getZLevels ( ) { return zLevels ; }
GrandathePanda/MarioAIImplementation | public boolean isZLevel ( int zLevel ) { for ( int level : zLevels ) { if ( zLevel == level ) return true ; } return false ; }
GrandathePanda/MarioAIImplementation | public String getDebug ( ) { return debug ; }
CodeSmell/camel | @ Test public void testConsume ( ) throws Exception { if ( ! canTest ( ) ) { return ; } context . addRoutes ( createRouteBuilder ( ) ) ; context . start ( ) ; Stomp stomp = createStompClient ( ) ; final BlockingConnection producerConnection = stomp . connectBlocking ( ) ; StompFrame frame = new StompFrame ( SEND ) ; frame . addHeader ( DESTINATION , StompFrame . encodeHeader ( " test " ) ) ; frame . addHeader ( MESSAGE_ID , StompFrame . encodeHeader ( " msg : 1" ) ) ; frame . content ( utf8 ( " Important ▁ Message ▁ 1" ) ) ; producerConnection . send ( frame ) ; MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 1 ) ; mock . message ( 0 ) . header ( " content - length " ) . isNull ( ) ; mock . await ( 5 , TimeUnit . SECONDS ) ; mock . assertIsSatisfied ( ) ; }
CodeSmell/camel | @ Override protected RouteBuilder createRouteBuilder ( ) { return new RouteBuilder ( ) { public void configure ( ) { fromF ( " stomp : test ? brokerURL = tcp : // localhost : % s & headerFilterStrategy = # customHeaderFilterStrategy " , getPort ( ) ) . transform ( body ( ) . convertToString ( ) ) . to ( " mock : result " ) ; } } ; }
CodeSmell/camel | ConsumerHeaderFilterStrategy ( ) { getInFilter ( ) . add ( " content - length " ) ; }
cit-lab/pinpoint | @ Override public List < AgentInfoBo > get ( String applicationName ) { List < AgentInfoBo > agentInfoList = new ArrayList < AgentInfoBo > ( ) ; long currentTime = System . currentTimeMillis ( ) ; Range range = new Range ( currentTime , currentTime ) ; SortedMap < String , List < AgentInfoBo > > applicationAgentList = agentInfoService . getApplicationAgentList ( applicationName , range ) ; for ( Map . Entry < String , List < AgentInfoBo > > entry : applicationAgentList . entrySet ( ) ) { AgentInfoBo agentInfo = ListUtils . getFirst ( entry . getValue ( ) , null ) ; ListUtils . addIfValueNotNull ( agentInfoList , agentInfo ) ; } return agentInfoList ; }
cit-lab/pinpoint | @ Override public Map < String , TActiveThreadResponse > getActiveThreadStatus ( List < AgentInfoBo > agentInfoList ) throws TException { byte [ ] activeThread = serialize ( new TActiveThread ( ) ) ; return getActiveThreadStatus ( agentInfoList , activeThread ) ; }
cit-lab/pinpoint | @ Override public Map < String , TActiveThreadResponse > getActiveThreadStatus ( List < AgentInfoBo > agentInfoList , byte [ ] payload ) throws TException { Map < String , Future < ResponseMessage > > futureMap = invoke ( agentInfoList , payload ) ; Map < String , TActiveThreadResponse > responseMap = new HashMap < String , TActiveThreadResponse > ( ) ; for ( Map . Entry < String , Future < ResponseMessage > > futureEntry : futureMap . entrySet ( ) ) { String hostName = futureEntry . getKey ( ) ; Future < ResponseMessage > future = futureEntry . getValue ( ) ; future . await ( ) ; ResponseMessage responseMessage = future . getResult ( ) ; TBase result = deserialize ( responseMessage . getMessage ( ) ) ; if ( result instanceof TActiveThreadResponse ) { responseMap . put ( hostName , ( TActiveThreadResponse ) result ) ; } } return responseMap ; }
cit-lab/pinpoint | private Map < String , Future < ResponseMessage > > invoke ( List < AgentInfoBo > agentInfoList , byte [ ] payload ) throws TException { Map < String , Future < ResponseMessage > > futureMap = new HashMap < String , Future < ResponseMessage > > ( ) ; for ( AgentInfoBo agentInfo : agentInfoList ) { TCommandTransfer transferObject = createCommandTransferObject ( agentInfo , payload ) ; PinpointServer collector = pinpointSocketManager . getCollector ( agentInfo ) ; Future < ResponseMessage > future = collector . request ( serialize ( transferObject ) ) ; futureMap . put ( agentInfo . getHostName ( ) , future ) ; } return futureMap ; }
cit-lab/pinpoint | private byte [ ] serialize ( TBase tBase ) throws TException { return SerializationUtils . serialize ( tBase , commandSerializerFactory ) ; }
cit-lab/pinpoint | private TBase deserialize ( byte [ ] objectData ) throws TException { return SerializationUtils . deserialize ( objectData , commandDeserializerFactory ) ; }
cit-lab/pinpoint | private TCommandTransfer createCommandTransferObject ( AgentInfoBo agentInfo , byte [ ] payload ) { TCommandTransfer transferObject = new TCommandTransfer ( ) ; transferObject . setApplicationName ( agentInfo . getApplicationName ( ) ) ; transferObject . setAgentId ( agentInfo . getAgentId ( ) ) ; transferObject . setStartTime ( agentInfo . getStartTime ( ) ) ; transferObject . setPayload ( payload ) ; return transferObject ; }
OkBuilds/OkBuck | @ Before public void setUp ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; builder = new TransformInvocationBuilder ( ) ; }
OkBuilds/OkBuck | @ Test public void addInput_shouldAddAnInput ( ) throws Exception { TransformInvocation invocation = builder . addInput ( transformInput ) . setOutputProvider ( outputProvider ) . build ( ) ; assertThat ( invocation . getInputs ( ) ) . containsExactly ( transformInput ) ; assertThat ( invocation . getReferencedInputs ( ) ) . isEmpty ( ) ; assertThat ( invocation . getOutputProvider ( ) ) . isEqualTo ( outputProvider ) ; }
OkBuilds/OkBuck | @ Test public void addReferencedInput_shouldAddReferencedInput ( ) throws Exception { TransformInvocation invocation = builder . addReferencedInput ( transformInput ) . setOutputProvider ( outputProvider ) . build ( ) ; assertThat ( invocation . getInputs ( ) ) . isEmpty ( ) ; assertThat ( invocation . getReferencedInputs ( ) ) . containsExactly ( transformInput ) ; assertThat ( invocation . getOutputProvider ( ) ) . isEqualTo ( outputProvider ) ; }
OkBuilds/OkBuck | @ Test ( expected = IllegalArgumentException . class ) public void whenOutputProviderNotSet_shouldThrowException ( ) throws Exception { builder . build ( ) ; }
aesteve/nubes | @ Override public Vertx resolve ( RoutingContext context ) { return context . vertx ( ) ; }
nmorel/gwt-jackson-rest | RestRequestCallback ( ObjectReader < R > responseConverter , RestCallback < R > callback ) { this . responseConverter = responseConverter ; this . callback = callback ; }
nmorel/gwt-jackson-rest | @ Override public void onResponseReceived ( Request request , Response response ) { if ( isSuccessStatusCode ( response ) ) { if ( null != callback ) { R result ; if ( null != responseConverter && null != response . getText ( ) && ! response . getText ( ) . isEmpty ( ) ) { try { result = responseConverter . read ( response . getText ( ) ) ; } catch ( Exception e ) { onError ( request , e ) ; return ; } } else { result = null ; } callback . onSuccess ( response , result ) ; } } else { if ( null != callback ) { callback . onError ( response ) ; } else { throw new RestException ( " An ▁ error ▁ occured . ▁ Status ▁ : ▁ " + response . getStatusCode ( ) ) ; } } }
nmorel/gwt-jackson-rest | private boolean isSuccessStatusCode ( Response response ) { int statusCode = response . getStatusCode ( ) ; return ( statusCode >= 200 && statusCode < 300 ) || statusCode == 304 ; }
nmorel/gwt-jackson-rest | @ Override public void onError ( Request request , Throwable exception ) { if ( null == callback ) { throw new RestException ( exception ) ; } else { callback . onFailure ( exception ) ; } }
virajsenevirathne/wso2-commons-vfs | private FtpsClientFactory ( ) { }
Esri/spatial-framework-for-hadoop | public GeometryJsonDeserializer ( ) { }
yangalex930/Tunnel | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestWindowFeature ( Window . FEATURE_NO_TITLE ) ; setContentView ( R . layout . image_mark ) ; imageView = ( MarkImageView ) findViewById ( R . id . imageView ) ; Bitmap bitmap = null ; final String imagePath = getIntent ( ) . getStringExtra ( " ImagePath " ) ; bitmap = BitmapFactory . decodeFile ( imagePath ) ; final Rect rect = getIntent ( ) . getParcelableExtra ( " Rect " ) ; if ( rect != null ) { bmpCropping = Bitmap . createBitmap ( bitmap , rect . left , rect . top , rect . width ( ) , rect . height ( ) ) ; Toast . makeText ( this , R . string . notify_select_start , Toast . LENGTH_SHORT ) . show ( ) ; } final MeasureInfo mi = getIntent ( ) . getParcelableExtra ( " MeasureInfo " ) ; if ( mi != null ) { bmpCropping = Bitmap . createBitmap ( bitmap , mi . cropRect . left , mi . cropRect . top , mi . cropRect . width ( ) , mi . cropRect . height ( ) ) ; imageView . setMarkRect ( mi . markRect ) ; Toast . makeText ( ImageMarkActivity . this , String . format ( getString ( R . string . notify_slope ) , mi . slope ) , Toast . LENGTH_SHORT ) . show ( ) ; } bitmap . recycle ( ) ; imageView . setImageBitmap ( bmpCropping ) ; imageView . setOnMarkListener ( new MarkImageView . onMarkListener ( ) { @ Override public void onMarkStart ( ) { Toast . makeText ( ImageMarkActivity . this , R . string . notify_select_end , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMarkFinish ( ) { if ( ! GlobalSwitch . bCorrectionMode ) { Toast . makeText ( ImageMarkActivity . this , String . format ( getString ( R . string . notify_slope ) , ( int ) imageView . getSlopeRate ( ) ) , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( ImageMarkActivity . this , String . format ( getString ( R . string . notify_degree_diff ) , imageView . getDegreeDiff ( ) ) , Toast . LENGTH_LONG ) . show ( ) ; } } } ) ; ImageButton cancel = ( ImageButton ) findViewById ( R . id . cancel ) ; cancel . setVisibility ( View . VISIBLE ) ; cancel . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { finish ( ) ; } } ) ; findViewById ( R . id . textView1 ) . setVisibility ( View . VISIBLE ) ; ImageButton ok = ( ImageButton ) findViewById ( R . id . ok ) ; ok . setVisibility ( View . VISIBLE ) ; ok . setEnabled ( mi == null ) ; ok . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( ! imageView . isMarkFinished ( ) ) { return ; } String msg ; if ( ! GlobalSwitch . bCorrectionMode ) { msg = String . format ( getString ( R . string . save_result ) , imageView . getSlopeRate ( ) ) ; } else { msg = String . format ( getString ( R . string . save_correct_result ) , imageView . getDegreeDiff ( ) ) ; } new AlertDialog . Builder ( ImageMarkActivity . this ) . setTitle ( R . string . notification ) . setMessage ( msg ) . setNegativeButton ( getString ( R . string . ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { if ( ! GlobalSwitch . bCorrectionMode ) { String cacheImage = BitmapUtil . renameBitmapCache ( imagePath ) ; if ( cacheImage != null ) { ExifUtil . saveMeasureInfo ( cacheImage , rect , imageView . getMarkRect ( ) , imageView . getSlopeRate ( ) ) ; } else { Toast . makeText ( ImageMarkActivity . this , R . string . save_failure , Toast . LENGTH_LONG ) . show ( ) ; } } else { Orientation . putCorrection ( imageView . getDegreeDiff ( ) ) ; } Class < ? extends Activity > cls ; if ( GlobalSwitch . bCorrectionMode ) { GlobalSwitch . bCorrectionMode = false ; cls = MainActivity . class ; } else if ( GlobalSwitch . bOpenFromCapture ) { cls = ImageCaptureActivity . class ; } else { GlobalSwitch . bOpenFromCapture = true ; cls = ImageGridActivity . class ; } Intent intent = new Intent ( ImageMarkActivity . this , cls ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivity ( intent ) ; } } ) . setPositiveButton ( getString ( R . string . cancel ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { } } ) . create ( ) . show ( ) ; } } ) ; findViewById ( R . id . textView3 ) . setVisibility ( View . VISIBLE ) ; ImageButton clear = ( ImageButton ) findViewById ( R . id . mid ) ; clear . setVisibility ( View . VISIBLE ) ; clear . setEnabled ( mi == null ) ; clear . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { imageView . reset ( ) ; } } ) ; findViewById ( R . id . textView2 ) . setVisibility ( View . VISIBLE ) ; }
k24/retrofit-promise-qiita4jv2 | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Comment comment = ( Comment ) o ; if ( ! created_at . equals ( comment . created_at ) ) return false ; if ( ! id . equals ( comment . id ) ) return false ; if ( ! rendered_body . equals ( comment . rendered_body ) ) return false ; if ( ! updated_at . equals ( comment . updated_at ) ) return false ; return user != null ? user . equals ( comment . user ) : comment . user == null ; }
k24/retrofit-promise-qiita4jv2 | @ Override public int hashCode ( ) { int result = created_at . hashCode ( ) ; result = 31 * result + id . hashCode ( ) ; result = 31 * result + rendered_body . hashCode ( ) ; result = 31 * result + updated_at . hashCode ( ) ; result = 31 * result + ( user != null ? user . hashCode ( ) : 0 ) ; return result ; }
k24/retrofit-promise-qiita4jv2 | @ Override public String toString ( ) { return " Comment { " + " created _ at = ' " + created_at + ' \' ' + " , ▁ id = ' " + id + ' \' ' + " , ▁ rendered _ body = ' " + rendered_body + ' \' ' + " , ▁ updated _ at = ' " + updated_at + ' \' ' + " , ▁ user = " + user + " } ▁ " + super . toString ( ) ; }
ButterflyNetwork/bazel | FlowStatement ( FileLocations locs , TokenKind kind , int offset ) { super ( locs ) ; this . kind = kind ; this . offset = offset ; }
ButterflyNetwork/bazel | public TokenKind getKind ( ) { return kind ; }
ButterflyNetwork/bazel | @ Override public String toString ( ) { return kind . toString ( ) + " \n " ; }
ButterflyNetwork/bazel | @ Override public int getStartOffset ( ) { return offset ; }
ButterflyNetwork/bazel | @ Override public int getEndOffset ( ) { return offset + kind . toString ( ) . length ( ) ; }
ButterflyNetwork/bazel | @ Override public void accept ( NodeVisitor visitor ) { visitor . visit ( this ) ; }
ButterflyNetwork/bazel | @ Override public Statement . Kind kind ( ) { return Statement . Kind . FLOW ; }
leechoongyon/HadoopSourceAnalyze | private void writeFile ( FileSystem fileSys , Path name , int repl ) throws IOException { FSDataOutputStream stm = fileSys . create ( name , true , fileSys . getConf ( ) . getInt ( CommonConfigurationKeys . IO_FILE_BUFFER_SIZE_KEY , 4096 ) , ( short ) repl , blockSize ) ; byte [ ] buffer = new byte [ fileSize ] ; Random rand = new Random ( seed ) ; rand . nextBytes ( buffer ) ; stm . write ( buffer ) ; stm . close ( ) ; }
leechoongyon/HadoopSourceAnalyze | private void checkFile ( FileSystem fileSys , Path name , int repl ) throws IOException { Configuration conf = fileSys . getConf ( ) ; ClientProtocol namenode = NameNodeProxies . createProxy ( conf , fileSys . getUri ( ) , ClientProtocol . class ) . getProxy ( ) ; waitForBlockReplication ( name . toString ( ) , namenode , Math . min ( numDatanodes , repl ) , - 1 ) ; LocatedBlocks locations = namenode . getBlockLocations ( name . toString ( ) , 0 , Long . MAX_VALUE ) ; FileStatus stat = fileSys . getFileStatus ( name ) ; BlockLocation [ ] blockLocations = fileSys . getFileBlockLocations ( stat , 0L , Long . MAX_VALUE ) ; assertTrue ( blockLocations . length == locations . locatedBlockCount ( ) ) ; for ( int i = 0 ; i < blockLocations . length ; i ++ ) { LocatedBlock blk = locations . get ( i ) ; DatanodeInfo [ ] datanodes = blk . getLocations ( ) ; String [ ] topologyPaths = blockLocations [ i ] . getTopologyPaths ( ) ; assertTrue ( topologyPaths . length == datanodes . length ) ; for ( int j = 0 ; j < topologyPaths . length ; j ++ ) { boolean found = false ; for ( int k = 0 ; k < racks . length ; k ++ ) { if ( topologyPaths [ j ] . startsWith ( racks [ k ] ) ) { found = true ; break ; } } assertTrue ( found ) ; } } boolean isOnSameRack = true , isNotOnSameRack = true ; for ( LocatedBlock blk : locations . getLocatedBlocks ( ) ) { DatanodeInfo [ ] datanodes = blk . getLocations ( ) ; if ( datanodes . length <= 1 ) break ; if ( datanodes . length == 2 ) { isNotOnSameRack = ! ( datanodes [ 0 ] . getNetworkLocation ( ) . equals ( datanodes [ 1 ] . getNetworkLocation ( ) ) ) ; break ; } isOnSameRack = false ; isNotOnSameRack = false ; for ( int i = 0 ; i < datanodes . length - 1 ; i ++ ) { LOG . info ( " datanode ▁ " + i + " : ▁ " + datanodes [ i ] ) ; boolean onRack = false ; for ( int j = i + 1 ; j < datanodes . length ; j ++ ) { if ( datanodes [ i ] . getNetworkLocation ( ) . equals ( datanodes [ j ] . getNetworkLocation ( ) ) ) { onRack = true ; } } if ( onRack ) { isOnSameRack = true ; } if ( ! onRack ) { isNotOnSameRack = true ; } if ( isOnSameRack && isNotOnSameRack ) break ; } if ( ! isOnSameRack || ! isNotOnSameRack ) break ; } assertTrue ( isOnSameRack ) ; assertTrue ( isNotOnSameRack ) ; }
leechoongyon/HadoopSourceAnalyze | private void cleanupFile ( FileSystem fileSys , Path name ) throws IOException { assertTrue ( fileSys . exists ( name ) ) ; fileSys . delete ( name , true ) ; assertTrue ( ! fileSys . exists ( name ) ) ; }
leechoongyon/HadoopSourceAnalyze | private void testBadBlockReportOnTransfer ( boolean corruptBlockByDeletingBlockFile ) throws Exception { Configuration conf = new HdfsConfiguration ( ) ; FileSystem fs = null ; DFSClient dfsClient = null ; LocatedBlocks blocks = null ; int replicaCount = 0 ; short replFactor = 1 ; MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 2 ) . build ( ) ; cluster . waitActive ( ) ; fs = cluster . getFileSystem ( ) ; dfsClient = new DFSClient ( new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) , conf ) ; Path file1 = new Path ( " / tmp / testBadBlockReportOnTransfer / file1" ) ; DFSTestUtil . createFile ( fs , file1 , 1024 , replFactor , 0 ) ; DFSTestUtil . waitReplication ( fs , file1 , replFactor ) ; ExtendedBlock block = DFSTestUtil . getFirstBlock ( fs , file1 ) ; int blockFilesCorrupted = corruptBlockByDeletingBlockFile ? cluster . corruptBlockOnDataNodesByDeletingBlockFile ( block ) : cluster . corruptBlockOnDataNodes ( block ) ; assertEquals ( " Corrupted ▁ too ▁ few ▁ blocks " , replFactor , blockFilesCorrupted ) ; replFactor = 2 ; fs . setReplication ( file1 , replFactor ) ; blocks = dfsClient . getNamenode ( ) . getBlockLocations ( file1 . toString ( ) , 0 , Long . MAX_VALUE ) ; while ( blocks . get ( 0 ) . isCorrupt ( ) != true ) { try { LOG . info ( " Waiting ▁ until ▁ block ▁ is ▁ marked ▁ as ▁ corrupt . . . " ) ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException ie ) { } blocks = dfsClient . getNamenode ( ) . getBlockLocations ( file1 . toString ( ) , 0 , Long . MAX_VALUE ) ; } replicaCount = blocks . get ( 0 ) . getLocations ( ) . length ; assertTrue ( replicaCount == 1 ) ; cluster . shutdown ( ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test public void testBadBlockReportOnTransfer ( ) throws Exception { testBadBlockReportOnTransfer ( false ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test public void testBadBlockReportOnTransferMissingBlockFile ( ) throws Exception { testBadBlockReportOnTransfer ( true ) ; }
leechoongyon/HadoopSourceAnalyze | public void runReplication ( boolean simulated ) throws IOException { Configuration conf = new HdfsConfiguration ( ) ; conf . setBoolean ( DFSConfigKeys . DFS_NAMENODE_REPLICATION_CONSIDERLOAD_KEY , false ) ; if ( simulated ) { SimulatedFSDataset . setFactory ( conf ) ; } MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDatanodes ) . racks ( racks ) . build ( ) ; cluster . waitActive ( ) ; InetSocketAddress addr = new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) ; DFSClient client = new DFSClient ( addr , conf ) ; DatanodeInfo [ ] info = client . datanodeReport ( DatanodeReportType . LIVE ) ; assertEquals ( " Number ▁ of ▁ Datanodes ▁ " , numDatanodes , info . length ) ; FileSystem fileSys = cluster . getFileSystem ( ) ; try { Path file1 = new Path ( " / smallblocktest . dat " ) ; writeFile ( fileSys , file1 , 3 ) ; checkFile ( fileSys , file1 , 3 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 10 ) ; checkFile ( fileSys , file1 , 10 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 4 ) ; checkFile ( fileSys , file1 , 4 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 1 ) ; checkFile ( fileSys , file1 , 1 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 2 ) ; checkFile ( fileSys , file1 , 2 ) ; cleanupFile ( fileSys , file1 ) ; } finally { fileSys . close ( ) ; cluster . shutdown ( ) ; } }
leechoongyon/HadoopSourceAnalyze | @ Test public void testReplicationSimulatedStorag ( ) throws IOException { runReplication ( true ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test public void testReplication ( ) throws IOException { runReplication ( false ) ; }
leechoongyon/HadoopSourceAnalyze | private void waitForBlockReplication ( String filename , ClientProtocol namenode , int expected , long maxWaitSec ) throws IOException { waitForBlockReplication ( filename , namenode , expected , maxWaitSec , false , false ) ; }
leechoongyon/HadoopSourceAnalyze | private void waitForBlockReplication ( String filename , ClientProtocol namenode , int expected , long maxWaitSec , boolean isUnderConstruction , boolean noOverReplication ) throws IOException { long start = Time . monotonicNow ( ) ; LOG . info ( " Checking ▁ for ▁ block ▁ replication ▁ for ▁ " + filename ) ; while ( true ) { boolean replOk = true ; LocatedBlocks blocks = namenode . getBlockLocations ( filename , 0 , Long . MAX_VALUE ) ; for ( Iterator < LocatedBlock > iter = blocks . getLocatedBlocks ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { LocatedBlock block = iter . next ( ) ; if ( isUnderConstruction && ! iter . hasNext ( ) ) { break ; } int actual = block . getLocations ( ) . length ; if ( noOverReplication ) { assertTrue ( actual <= expected ) ; } if ( actual < expected ) { LOG . info ( " Not ▁ enough ▁ replicas ▁ for ▁ " + block . getBlock ( ) + " ▁ yet . ▁ Expecting ▁ " + expected + " , ▁ got ▁ " + actual + " . " ) ; replOk = false ; break ; } } if ( replOk ) { return ; } if ( maxWaitSec > 0 && ( Time . monotonicNow ( ) - start ) > ( maxWaitSec * 1000 ) ) { throw new IOException ( " Timedout ▁ while ▁ waiting ▁ for ▁ all ▁ blocks ▁ to ▁ " + " ▁ be ▁ replicated ▁ for ▁ " + filename ) ; } try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ignored ) { } } }
leechoongyon/HadoopSourceAnalyze | @ Test public void testPendingReplicationRetry ( ) throws IOException { MiniDFSCluster cluster = null ; int numDataNodes = 4 ; String testFile = " / replication - test - file " ; Path testPath = new Path ( testFile ) ; byte buffer [ ] = new byte [ 1024 ] ; for ( int i = 0 ; i < buffer . length ; i ++ ) { buffer [ i ] = '1' ; } try { Configuration conf = new HdfsConfiguration ( ) ; conf . set ( DFSConfigKeys . DFS_REPLICATION_KEY , Integer . toString ( numDataNodes ) ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes ) . build ( ) ; cluster . waitActive ( ) ; DFSClient dfsClient = new DFSClient ( new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) , conf ) ; OutputStream out = cluster . getFileSystem ( ) . create ( testPath ) ; out . write ( buffer ) ; out . close ( ) ; waitForBlockReplication ( testFile , dfsClient . getNamenode ( ) , numDataNodes , - 1 ) ; ExtendedBlock block = dfsClient . getNamenode ( ) . getBlockLocations ( testFile , 0 , Long . MAX_VALUE ) . get ( 0 ) . getBlock ( ) ; List < MaterializedReplica > replicas = new ArrayList < > ( ) ; for ( int dnIndex = 0 ; dnIndex < 3 ; dnIndex ++ ) { replicas . add ( cluster . getMaterializedReplica ( dnIndex , block ) ) ; } assertEquals ( 3 , replicas . size ( ) ) ; cluster . shutdown ( ) ; int fileCount = 0 ; for ( MaterializedReplica replica : replicas ) { if ( fileCount == 0 ) { LOG . info ( " Deleting ▁ block ▁ " + replica ) ; replica . deleteData ( ) ; } else { LOG . info ( " Corrupting ▁ file ▁ " + replica ) ; replica . corruptData ( ) ; } fileCount ++ ; } LOG . info ( " Restarting ▁ minicluster ▁ after ▁ deleting ▁ a ▁ replica ▁ and ▁ corrupting ▁ 2 ▁ crcs " ) ; conf = new HdfsConfiguration ( ) ; conf . set ( DFSConfigKeys . DFS_REPLICATION_KEY , Integer . toString ( numDataNodes ) ) ; conf . set ( DFSConfigKeys . DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY , Integer . toString ( 2 ) ) ; conf . set ( " dfs . datanode . block . write . timeout . sec " , Integer . toString ( 5 ) ) ; conf . set ( DFSConfigKeys . DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY , "0.75f " ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes * 2 ) . format ( false ) . build ( ) ; cluster . waitActive ( ) ; dfsClient = new DFSClient ( new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) , conf ) ; waitForBlockReplication ( testFile , dfsClient . getNamenode ( ) , numDataNodes , - 1 ) ; } finally { if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | @ Test public void testReplicateLenMismatchedBlock ( ) throws Exception { MiniDFSCluster cluster = new MiniDFSCluster . Builder ( new HdfsConfiguration ( ) ) . numDataNodes ( 2 ) . build ( ) ; try { cluster . waitActive ( ) ; changeBlockLen ( cluster , - 1 ) ; changeBlockLen ( cluster , 1 ) ; } finally { cluster . shutdown ( ) ; } }
leechoongyon/HadoopSourceAnalyze | i ++ ) { if ( DFSTestUtil . changeReplicaLength ( cluster , block , i , lenDelta ) ) { break ; } }
leechoongyon/HadoopSourceAnalyze | if ( lenDelta < 0 ) { while ( ! blocks . get ( 0 ) . isCorrupt ( ) || REPLICATION_FACTOR != blocks . get ( 0 ) . getLocations ( ) . length ) { Thread . sleep ( 100 ) ; blocks = dfsClient . getNamenode ( ) . getBlockLocations ( fileName . toString ( ) , 0 , fileLen ) ; } }
leechoongyon/HadoopSourceAnalyze | while ( REPLICATION_FACTOR + 1 != blocks . get ( 0 ) . getLocations ( ) . length ) { Thread . sleep ( 100 ) ; blocks = dfsClient . getNamenode ( ) . getBlockLocations ( fileName . toString ( ) , 0 , fileLen ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test ( timeout = 30000 ) public void testReplicationWhenBlockCorruption ( ) throws Exception { MiniDFSCluster cluster = null ; try { Configuration conf = new HdfsConfiguration ( ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY , 1 ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 3 ) . storagesPerDatanode ( 1 ) . build ( ) ; FileSystem fs = cluster . getFileSystem ( ) ; Path filePath = new Path ( " / test " ) ; FSDataOutputStream create = fs . create ( filePath ) ; fs . setReplication ( filePath , ( short ) 1 ) ; create . write ( new byte [ 1024 ] ) ; create . close ( ) ; ExtendedBlock block = DFSTestUtil . getFirstBlock ( fs , filePath ) ; int numReplicaCreated = 0 ; for ( final DataNode dn : cluster . getDataNodes ( ) ) { if ( ! dn . getFSDataset ( ) . contains ( block ) ) { cluster . getFsDatasetTestUtils ( dn ) . injectCorruptReplica ( block ) ; numReplicaCreated ++ ; } } assertEquals ( 2 , numReplicaCreated ) ; fs . setReplication ( filePath , ( short ) 3 ) ; cluster . restartDataNodes ( ) ; cluster . waitActive ( ) ; cluster . triggerBlockReports ( ) ; DFSTestUtil . waitReplication ( fs , filePath , ( short ) 3 ) ; } finally { if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | @ Test ( timeout = 60000 ) public void testNoExtraReplicationWhenBlockReceivedIsLate ( ) throws Exception { LOG . info ( " Test ▁ block ▁ replication ▁ when ▁ blockReceived ▁ is ▁ late " ) ; final short numDataNodes = 3 ; final short replication = 3 ; final Configuration conf = new Configuration ( ) ; conf . setInt ( DFSConfigKeys . DFS_BLOCK_SIZE_KEY , 1024 ) ; final MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes ) . build ( ) ; final String testFile = " / replication - test - file " ; final Path testPath = new Path ( testFile ) ; final BlockManager bm = cluster . getNameNode ( ) . getNamesystem ( ) . getBlockManager ( ) ; try { cluster . waitActive ( ) ; NameNode nn = cluster . getNameNode ( ) ; DataNode dn = cluster . getDataNodes ( ) . get ( 0 ) ; DatanodeProtocolClientSideTranslatorPB spy = InternalDataNodeTestUtils . spyOnBposToNN ( dn , nn ) ; DelayAnswer delayer = new GenericTestUtils . DelayAnswer ( LOG ) ; Mockito . doAnswer ( delayer ) . when ( spy ) . blockReceivedAndDeleted ( Mockito . < DatanodeRegistration > anyObject ( ) , Mockito . anyString ( ) , Mockito . < StorageReceivedDeletedBlocks [ ] > anyObject ( ) ) ; FileSystem fs = cluster . getFileSystem ( ) ; DFSTestUtil . createFile ( fs , testPath , 1500 , replication , 0 ) ; BlockManagerTestUtil . computeAllPendingWork ( bm ) ; assertTrue ( pendingReplicationCount ( bm ) > 0 ) ; delayer . waitForCall ( ) ; delayer . proceed ( ) ; delayer . waitForResult ( ) ; for ( DataNode d : cluster . getDataNodes ( ) ) { DataNodeTestUtils . triggerHeartbeat ( d ) ; } try { GenericTestUtils . waitFor ( new Supplier < Boolean > ( ) { @ Override public Boolean get ( ) { return pendingReplicationCount ( bm ) == 0 ; } } , 100 , 3000 ) ; } catch ( TimeoutException e ) { fail ( " timed ▁ out ▁ while ▁ waiting ▁ for ▁ no ▁ pending ▁ replication . " ) ; } assertNoReplicationWasPerformed ( cluster ) ; } finally { if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | @ Test ( timeout = 60000 ) public void testReplicationWhileUnderConstruction ( ) throws Exception { LOG . info ( " Test ▁ block ▁ replication ▁ in ▁ under ▁ construction " ) ; MiniDFSCluster cluster = null ; final short numDataNodes = 6 ; final short replication = 3 ; String testFile = " / replication - test - file " ; Path testPath = new Path ( testFile ) ; FSDataOutputStream stm = null ; try { Configuration conf = new Configuration ( ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes ) . build ( ) ; cluster . waitActive ( ) ; FileSystem fs = cluster . getFileSystem ( ) ; stm = AppendTestUtil . createFile ( fs , testPath , replication ) ; byte [ ] buffer = AppendTestUtil . initBuffer ( AppendTestUtil . BLOCK_SIZE ) ; stm . write ( buffer ) ; stm . write ( buffer ) ; stm . write ( buffer , 0 , 1 ) ; stm . hflush ( ) ; waitForBlockReplication ( testFile , cluster . getNameNodeRpc ( ) , replication , 30000 , true , true ) ; assertNoReplicationWasPerformed ( cluster ) ; List < LocatedBlock > blocks ; FSDataInputStream in = fs . open ( testPath ) ; try { blocks = DFSTestUtil . getAllBlocks ( in ) ; } finally { in . close ( ) ; } LocatedBlock lb = blocks . get ( 0 ) ; LocatedBlock lbOneReplica = new LocatedBlock ( lb . getBlock ( ) , new DatanodeInfo [ ] { lb . getLocations ( ) [ 0 ] } ) ; cluster . getNameNodeRpc ( ) . reportBadBlocks ( new LocatedBlock [ ] { lbOneReplica } ) ; waitForBlockReplication ( testFile , cluster . getNameNodeRpc ( ) , replication , 30000 , true , true ) ; } finally { if ( stm != null ) { IOUtils . closeStream ( stm ) ; } if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | private long pendingReplicationCount ( BlockManager bm ) { BlockManagerTestUtil . updateState ( bm ) ; return bm . getPendingReplicationBlocksCount ( ) ; }
leechoongyon/HadoopSourceAnalyze | private void assertNoReplicationWasPerformed ( MiniDFSCluster cluster ) { for ( DataNode dn : cluster . getDataNodes ( ) ) { MetricsRecordBuilder rb = getMetrics ( dn . getMetrics ( ) . name ( ) ) ; assertCounter ( " BlocksReplicated " , 0L , rb ) ; } }
marcelstoer/open-data-smn | public SmnHealthCheck ( GeoAdmin geoAdmin ) { this . geoAdmin = geoAdmin ; }
marcelstoer/open-data-smn | @ Override protected Result check ( ) throws IOException { if ( geoAdmin . getSmnData ( ) . getAllRecords ( ) . size ( ) > 0 ) { return Result . healthy ( ) ; } else { return Result . unhealthy ( " No ▁ SMN ▁ data ▁ available . " ) ; } }
ddebrunner/quarks | protected AbstractGraphJob ( ) { this . currentState = State . CONSTRUCTED ; this . nextState = currentState ; }
ddebrunner/quarks | @ Override public synchronized State getCurrentState ( ) { return currentState ; }
ddebrunner/quarks | @ Override public synchronized State getNextState ( ) { return nextState ; }
ddebrunner/quarks | protected synchronized boolean inTransition ( ) { return getNextState ( ) != getCurrentState ( ) ; }
ddebrunner/quarks | protected synchronized void setNextState ( State value ) { this . nextState = value ; }
ddebrunner/quarks | protected synchronized void completeTransition ( ) { if ( inTransition ( ) ) { currentState = nextState ; } }
jlyw/babel-app | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_onboarding ) ; run ( ) ; }
jlyw/babel-app | private void addBottomDots ( int currentPage ) { dots = new TextView [ layouts . length ] ; dotsLayout . removeAllViews ( ) ; for ( int i = 0 ; i < dots . length ; i ++ ) { dots [ i ] = new TextView ( this ) ; dots [ i ] . setText ( Html . fromHtml ( " & #8226 ; " ) ) ; dots [ i ] . setTextSize ( 35 ) ; dots [ i ] . setTextColor ( Color . parseColor ( " # FFFFFF " ) ) ; dotsLayout . addView ( dots [ i ] ) ; } if ( dots . length > 0 ) dots [ currentPage ] . setTextColor ( Color . parseColor ( " # 8e3d3f " ) ) ; }
jlyw/babel-app | private int getItem ( int i ) { return viewPager . getCurrentItem ( ) + i ; }
jlyw/babel-app | private void launchHomeScreen ( ) { startActivity ( new Intent ( OnboardingActivity . this , MainActivity . class ) ) ; finish ( ) ; }
jlyw/babel-app | ViewPager . OnPageChangeListener viewPagerPageChangeListener = new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageSelected ( int position ) { addBottomDots ( position ) ; if ( position == layouts . length - 1 ) { btnNext . setText ( getString ( R . string . start ) ) ; btnSkip . setVisibility ( View . GONE ) ; } else { btnNext . setText ( getString ( R . string . next ) ) ; btnSkip . setVisibility ( View . VISIBLE ) ; } } @ Override public void onPageScrolled ( int arg0 , float arg1 , int arg2 ) { } @ Override public void onPageScrollStateChanged ( int arg0 ) { } }
jlyw/babel-app | private void changeStatusBarColor ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { Window window = getWindow ( ) ; window . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; window . setStatusBarColor ( Color . TRANSPARENT ) ; } }
jlyw/babel-app | @ Override public void run ( ) { android . os . Process . setThreadPriority ( android . os . Process . THREAD_PRIORITY_BACKGROUND ) ; if ( Build . VERSION . SDK_INT >= 21 ) { getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LAYOUT_STABLE | View . SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN ) ; } viewPager = ( ViewPager ) findViewById ( R . id . view_pager ) ; dotsLayout = ( LinearLayout ) findViewById ( R . id . layoutDots ) ; btnSkip = ( Button ) findViewById ( R . id . btn_skip ) ; btnNext = ( Button ) findViewById ( R . id . btn_next ) ; layouts = new int [ ] { R . layout . onboarding_slide_1 , R . layout . onboarding_slide_2 , R . layout . onboarding_slide_3 , R . layout . onboarding_slide_4 } ; addBottomDots ( 0 ) ; changeStatusBarColor ( ) ; myViewPagerAdapter = new MyViewPagerAdapter ( ) ; viewPager . setAdapter ( myViewPagerAdapter ) ; viewPager . addOnPageChangeListener ( viewPagerPageChangeListener ) ; btnSkip . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { launchHomeScreen ( ) ; } } ) ; btnNext . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { int current = getItem ( + 1 ) ; if ( current < layouts . length ) { viewPager . setCurrentItem ( current ) ; } else { launchHomeScreen ( ) ; } } } ) ; }
jlyw/babel-app | public MyViewPagerAdapter ( ) { }
jlyw/babel-app | @ Override public Object instantiateItem ( ViewGroup container , int position ) { layoutInflater = ( LayoutInflater ) getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; View view = layoutInflater . inflate ( layouts [ position ] , container , false ) ; container . addView ( view ) ; return view ; }
jlyw/babel-app | @ Override public int getCount ( ) { return layouts . length ; }
jlyw/babel-app | @ Override public boolean isViewFromObject ( View view , Object obj ) { return view == obj ; }
jlyw/babel-app | @ Override public void destroyItem ( ViewGroup container , int position , Object object ) { View view = ( View ) object ; container . removeView ( view ) ; }
Stratio/cassandra | protected SchemaAlteringStatement ( ) { super ( null ) ; this . isColumnFamilyLevel = false ; }
Stratio/cassandra | protected SchemaAlteringStatement ( CFName name ) { super ( name ) ; this . isColumnFamilyLevel = true ; }
Stratio/cassandra | public int getBoundTerms ( ) { return 0 ; }
Stratio/cassandra | @ Override public void prepareKeyspace ( ClientState state ) throws InvalidRequestException { if ( isColumnFamilyLevel ) super . prepareKeyspace ( state ) ; }
Stratio/cassandra | @ Override public Prepared prepare ( ) { return new Prepared ( this ) ; }
Stratio/cassandra | public ResultMessage execute ( QueryState state , QueryOptions options ) throws RequestValidationException { announceMigration ( ) ; String tableName = cfName == null || columnFamily ( ) == null ? " " : columnFamily ( ) ; return new ResultMessage . SchemaChange ( changeType ( ) , keyspace ( ) , tableName ) ; }
Stratio/cassandra | public ResultMessage executeInternal ( QueryState state ) { throw new UnsupportedOperationException ( ) ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public RemoteRuntimeEngine ( RemoteConfiguration configuration ) { this . config = configuration ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public KieSession getKieSession ( ) { return new KieSessionClientCommandObject ( config ) ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public TaskService getTaskService ( ) { return new TaskServiceClientCommandObject ( config ) ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public AuditService getAuditService ( ) { return new AuditServiceClientCommandObject ( config ) ; }
aws/aws-sdk-java | public GetMedicalTranscriptionJobRequestProtocolMarshaller ( com . amazonaws . protocol . json . SdkJsonProtocolFactory protocolFactory ) { this . protocolFactory = protocolFactory ; }
aws/aws-sdk-java | public Request < GetMedicalTranscriptionJobRequest > marshall ( GetMedicalTranscriptionJobRequest getMedicalTranscriptionJobRequest ) { if ( getMedicalTranscriptionJobRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { final ProtocolRequestMarshaller < GetMedicalTranscriptionJobRequest > protocolMarshaller = protocolFactory . createProtocolMarshaller ( SDK_OPERATION_BINDING , getMedicalTranscriptionJobRequest ) ; protocolMarshaller . startMarshalling ( ) ; GetMedicalTranscriptionJobRequestMarshaller . getInstance ( ) . marshall ( getMedicalTranscriptionJobRequest , protocolMarshaller ) ; return protocolMarshaller . finishMarshalling ( ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
asedunov/intellij-community | @ NotNull @ Override protected String extractRootPath ( @ NotNull final String path ) { return " / " ; }
asedunov/intellij-community | @ Nullable private FSItem convert ( @ NotNull VirtualFile file ) { final VirtualFile parentFile = file . getParent ( ) ; if ( parentFile == null ) return myRoot ; FSItem parentItem = convert ( parentFile ) ; if ( parentItem == null || ! parentItem . isDirectory ( ) ) { return null ; } return parentItem . findChild ( file . getName ( ) ) ; }
asedunov/intellij-community | @ Override @ NotNull public VirtualFile createChildDirectory ( Object requestor , @ NotNull VirtualFile parent , @ NotNull String dir ) throws IOException { final FSItem fsItem = convert ( parent ) ; assert fsItem != null && fsItem . isDirectory ( ) ; final FSDir fsDir = ( FSDir ) fsItem ; final FSItem existingDir = fsDir . findChild ( dir ) ; if ( existingDir == null ) { fsDir . addChild ( new FSDir ( fsDir , dir ) ) ; } else if ( ! existingDir . isDirectory ( ) ) { throw new IOException ( " Directory ▁ already ▁ contains ▁ a ▁ file ▁ named ▁ " + dir ) ; } return new FakeVirtualFile ( parent , dir ) ; }
asedunov/intellij-community | @ NotNull @ Override public VirtualFile createChildFile ( Object requestor , @ NotNull VirtualFile parent , @ NotNull String file ) throws IOException { final FSItem fsItem = convert ( parent ) ; if ( fsItem == null ) { FSRecords . invalidateCaches ( ) ; throw new IllegalStateException ( " cannot ▁ find ▁ parent ▁ directory : ▁ " + parent . getPath ( ) ) ; } assert fsItem . isDirectory ( ) : " parent ▁ is ▁ not ▁ a ▁ directory : ▁ " + parent . getPath ( ) ; final FSDir fsDir = ( FSDir ) fsItem ; assert fsDir . findChild ( file ) == null : " File ▁ " + file + " ▁ already ▁ exists ▁ in ▁ " + parent . getPath ( ) ; fsDir . addChild ( new FSFile ( fsDir , file ) ) ; return new FakeVirtualFile ( parent , file ) ; }
asedunov/intellij-community | @ NotNull @ Override public VirtualFile copyFile ( Object requestor , @ NotNull VirtualFile file , @ NotNull VirtualFile newParent , @ NotNull String copyName ) throws IOException { return VfsUtilCore . copyFile ( requestor , file , newParent , copyName ) ; }
asedunov/intellij-community | @ Override public void deleteFile ( final Object requestor , @ NotNull final VirtualFile file ) throws IOException { final FSItem fsItem = convert ( file ) ; if ( fsItem == null ) { FSRecords . invalidateCaches ( ) ; throw new IllegalStateException ( " failed ▁ to ▁ delete ▁ file ▁ " + file . getPath ( ) ) ; } fsItem . getParent ( ) . removeChild ( fsItem ) ; }
asedunov/intellij-community | @ Override public void moveFile ( final Object requestor , @ NotNull final VirtualFile file , @ NotNull final VirtualFile newParent ) throws IOException { final FSItem fsItem = convert ( file ) ; assert fsItem != null : " failed ▁ to ▁ move ▁ file ▁ " + file . getPath ( ) ; final FSItem newParentItem = convert ( newParent ) ; assert newParentItem != null && newParentItem . isDirectory ( ) : " failed ▁ to ▁ find ▁ move ▁ target ▁ " + file . getPath ( ) ; FSDir newDir = ( FSDir ) newParentItem ; if ( newDir . findChild ( file . getName ( ) ) != null ) { throw new IOException ( " Directory ▁ already ▁ contains ▁ a ▁ file ▁ named ▁ " + file . getName ( ) ) ; } fsItem . getParent ( ) . removeChild ( fsItem ) ; newDir . addChild ( fsItem ) ; fsItem . myParent = newDir ; }
asedunov/intellij-community | @ Override public void renameFile ( final Object requestor , @ NotNull final VirtualFile file , @ NotNull final String newName ) throws IOException { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; fsItem . setName ( newName ) ; }
asedunov/intellij-community | @ Override @ NotNull public String getProtocol ( ) { return " temp " ; }
asedunov/intellij-community | @ Override public boolean exists ( @ NotNull final VirtualFile fileOrDirectory ) { return convert ( fileOrDirectory ) != null ; }
asedunov/intellij-community | @ Override @ NotNull public String [ ] list ( @ NotNull final VirtualFile file ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; return fsItem . list ( ) ; }
asedunov/intellij-community | @ NotNull @ Override public String getCanonicallyCasedName ( @ NotNull VirtualFile file ) { return file . getName ( ) ; }
asedunov/intellij-community | @ Override public boolean isDirectory ( @ NotNull final VirtualFile file ) { return convert ( file ) instanceof FSDir ; }
asedunov/intellij-community | @ Override public long getTimeStamp ( @ NotNull final VirtualFile file ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null : " cannot ▁ find ▁ item ▁ for ▁ path ▁ " + file . getPath ( ) ; return fsItem . myTimestamp ; }
asedunov/intellij-community | @ Override public void setTimeStamp ( @ NotNull final VirtualFile file , final long timeStamp ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; fsItem . myTimestamp = timeStamp > 0 ? timeStamp : LocalTimeCounter . currentTime ( ) ; }
asedunov/intellij-community | @ Override public boolean isWritable ( @ NotNull final VirtualFile file ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; return fsItem . myWritable ; }
asedunov/intellij-community | @ Override public void setWritable ( @ NotNull final VirtualFile file , final boolean writableFlag ) throws IOException { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; fsItem . myWritable = writableFlag ; }
asedunov/intellij-community | @ Override @ NotNull public byte [ ] contentsToByteArray ( @ NotNull final VirtualFile file ) throws IOException { final FSItem fsItem = convert ( file ) ; if ( fsItem == null ) throw new FileNotFoundException ( " Cannot ▁ find ▁ temp ▁ for ▁ " + file . getPath ( ) ) ; assert fsItem instanceof FSFile : fsItem ; return ( ( FSFile ) fsItem ) . myContent ; }
asedunov/intellij-community | @ Override @ NotNull public InputStream getInputStream ( @ NotNull final VirtualFile file ) throws IOException { return new BufferExposingByteArrayInputStream ( contentsToByteArray ( file ) ) ; }
asedunov/intellij-community | @ Override @ NotNull public OutputStream getOutputStream ( @ NotNull final VirtualFile file , final Object requestor , final long modStamp , final long timeStamp ) throws IOException { return new ByteArrayOutputStream ( ) { @ Override public void close ( ) throws IOException { super . close ( ) ; final FSItem fsItem = convert ( file ) ; assert fsItem instanceof FSFile ; ( ( FSFile ) fsItem ) . myContent = toByteArray ( ) ; setTimeStamp ( file , modStamp ) ; } } ; }
asedunov/intellij-community | @ Override public long getLength ( @ NotNull final VirtualFile file ) { try { return contentsToByteArray ( file ) . length ; } catch ( IOException e ) { return 0 ; } }
asedunov/intellij-community | FSItem ( @ Nullable FSDir parent , @ NotNull String name ) { myParent = parent ; myName = name ; myTimestamp = LocalTimeCounter . currentTime ( ) ; myWritable = true ; }
asedunov/intellij-community | @ Nullable public FSItem findChild ( final String name ) { return null ; }
asedunov/intellij-community | void setName ( @ NotNull String name ) { myName = name ; }
asedunov/intellij-community | public FSDir getParent ( ) { return myParent ; }
asedunov/intellij-community | @ NotNull public String [ ] list ( ) { return ArrayUtil . EMPTY_STRING_ARRAY ; }
asedunov/intellij-community | @ Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " : ▁ " + myName ; }
asedunov/intellij-community | FSDir ( @ Nullable FSDir parent , @ NotNull String name ) { super ( parent , name ) ; }
asedunov/intellij-community | @ Override @ Nullable public FSItem findChild ( final String name ) { for ( FSItem child : myChildren ) { if ( name . equals ( child . myName ) ) { return child ; } } return null ; }
asedunov/intellij-community | @ Override public boolean isDirectory ( ) { return true ; }
asedunov/intellij-community | void addChild ( @ NotNull FSItem item ) { myChildren . add ( item ) ; }
asedunov/intellij-community | void removeChild ( @ NotNull FSItem fsItem ) { if ( fsItem . myName . equals ( " src " ) && getParent ( ) == null ) { throw new RuntimeException ( " removing ▁ src ▁ directory " ) ; } myChildren . remove ( fsItem ) ; }
asedunov/intellij-community | @ NotNull @ Override public String [ ] list ( ) { String [ ] names = ArrayUtil . newStringArray ( myChildren . size ( ) ) ; for ( int i = 0 ; i < names . length ; i ++ ) { names [ i ] = myChildren . get ( i ) . myName ; } return names ; }
asedunov/intellij-community | FSFile ( @ NotNull FSDir parent , @ NotNull String name ) { super ( parent , name ) ; }
asedunov/intellij-community | @ Override public boolean isDirectory ( ) { return false ; }
asedunov/intellij-community | @ Override public FileAttributes getAttributes ( @ NotNull final VirtualFile file ) { final FSItem item = convert ( file ) ; if ( item == null ) return null ; final long length = item instanceof FSFile ? ( ( FSFile ) item ) . myContent . length : 0 ; return new FileAttributes ( item . isDirectory ( ) , false , false , false , length , item . myTimestamp , item . myWritable ) ; }
asedunov/intellij-community | @ NotNull @ Override public Set < WatchRequest > replaceWatchedRoots ( @ NotNull Collection < WatchRequest > watchRequests , @ Nullable Collection < String > recursiveRoots , @ Nullable Collection < String > flatRoots ) { throw new IncorrectOperationException ( ) ; }
asedunov/intellij-community | @ NotNull @ Override protected String normalize ( @ NotNull String path ) { return path ; }
bihe/login.binggl.net.ninja | public EmbeddedMongod ( ) { }
bihe/login.binggl.net.ninja | public void startup ( ) { wrapEx ( ( ) -> { IMongodConfig mongodConfig = new MongodConfigBuilder ( ) . version ( Version . Main . PRODUCTION ) . net ( new Net ( PORT , Network . localhostIsIPv6 ( ) ) ) . build ( ) ; mongodExe = starter . prepare ( mongodConfig ) ; mongod = mongodExe . start ( ) ; } ) ; }
bihe/login.binggl.net.ninja | public void shutdown ( ) { wrapEx ( ( ) -> { mongod . stop ( ) ; mongodExe . stop ( ) ; } ) ; }
akjava/akjava_gwtlib | private SpeechUtils ( ) { }
emil-wcislo/sbql4j8 | public String getBugId ( ) { return BUG_ID ; }
emil-wcislo/sbql4j8 | public String getBugName ( ) { return getClass ( ) . getName ( ) ; }
smartcat-labs/data-loader | public CircularRangeValueInt ( Range < Integer > range , Integer increment ) { super ( range , increment ) ; }
smartcat-labs/data-loader | @ Override protected Integer zero ( ) { return 0 ; }
smartcat-labs/data-loader | @ Override protected boolean isIncrementGreaterThanRangeSize ( ) { return Math . abs ( range . getBeginning ( ) - range . getEnd ( ) ) <= Math . abs ( increment ) ; }
smartcat-labs/data-loader | @ Override protected Integer peekNextValue ( ) { return val + increment ; }
huihoo/olat | @ Override public void setUp ( ) throws Exception { Context context = Context . setupContext ( getFullName ( ) , SetupType . TWO_NODE_CLUSTER ) ; WorkflowHelper . deleteLearningResources ( context . getStandardAdminOlatLoginInfos ( 1 ) . getUsername ( ) , COURSE_NAME_PREFIX ) ; File file = WorkflowHelper . locateFile ( IMPORTABLE_COURSE_PATH ) ; WorkflowHelper . importCourse ( file , COURSE_NAME , COURSE_NAME_PREFIX ) ; OLATWorkflowHelper workflowAdmin = context . getOLATWorkflowHelper ( context . getStandardAdminOlatLoginInfos ( 1 ) ) ; workflowAdmin . getLearningResources ( ) . searchMyResource ( COURSE_NAME ) . assignOwner ( context . getStandardAuthorOlatLoginInfos ( 1 ) . getUsername ( ) ) ; }
huihoo/olat | public void testEditAndConfigurePodcast ( ) throws Exception { Context context = Context . getContext ( ) ; OLATWorkflowHelper workflowAuthor = context . getOLATWorkflowHelper ( context . getStandardAuthorOlatLoginInfos ( 1 ) ) ; CourseEditor courseEditor = workflowAuthor . getLearningResources ( ) . showCourseContent ( COURSE_NAME ) . getCourseEditor ( ) ; courseEditor . publishCourse ( ) ; CourseRun courseRun = courseEditor . closeToCourseRun ( ) ; PodcastRun podcastRun = courseRun . selectPodcast ( PODCAST_INTERN ) ; File mp3File = WorkflowHelper . locateFile ( Context . FILE_RESOURCES_PATH + AUDIO_FILE_NAME ) ; String remoteFilePath = Context . getContext ( ) . provideFileRemotely ( mp3File ) ; podcastRun . createEpisode ( PODCAST_EPISODE_TITLE , PODCAST_EPISODE_DESCRIPTION , remoteFilePath ) ; assertTrue ( podcastRun . isTextPresent ( " audio " ) ) ; assertTrue ( podcastRun . isTextPresent ( PODCAST_EPISODE_DESCRIPTION ) ) ; podcastRun . editEpisode ( PODCAST_EPISODE_TITLE , PODCAST_EPISODE_DESCRIPTION_MODIFIED , null ) ; assertTrue ( podcastRun . isTextPresent ( PODCAST_EPISODE_DESCRIPTION_MODIFIED ) ) ; podcastRun . commentEpisode ( PODCAST_EPISODE_TITLE , EPISODE_COMMENT ) ; assertTrue ( podcastRun . hasComments ( PODCAST_EPISODE_TITLE , 1 ) ) ; CourseEditor courseEditor1 = courseRun . getCourseEditor ( ) ; PodcastEditor podcastEditor = ( PodcastEditor ) courseEditor1 . selectCourseElement ( PODCAST_INTERN ) ; podcastEditor . changeAccessBlockedForLearners ( CourseElementEditor . ACCESS_TYPE . PRESENT ) ; podcastEditor . changeAccessBlockedForLearners ( CourseElementEditor . ACCESS_TYPE . READ_AND_WRITE ) ; courseEditor1 . publishCourse ( ) ; CourseRun courseRun1 = courseEditor1 . closeToCourseRun ( ) ; OLATWorkflowHelper workflowStudent = context . getOLATWorkflowHelper ( context . getStandardStudentOlatLoginInfos ( 2 ) ) ; CourseRun courseRun2 = workflowStudent . getLearningResources ( ) . searchAndShowCourseContent ( COURSE_NAME ) ; PodcastRun podcastRun2 = courseRun2 . selectPodcast ( PODCAST_INTERN ) ; assertTrue ( podcastRun2 . isTextPresent ( PODCAST_EPISODE_DESCRIPTION_MODIFIED ) ) ; podcastRun2 . createEpisode ( PODCAST_EPISODE_2_TITLE , PODCAST_EPISODE_2_DESCRIPTION , remoteFilePath ) ; assertTrue ( podcastRun2 . isTextPresent ( " audio " ) ) ; assertTrue ( podcastRun2 . isTextPresent ( PODCAST_EPISODE_2_DESCRIPTION ) ) ; PodcastRun podcastRun1 = courseRun1 . selectPodcast ( PODCAST_INTERN ) ; assertTrue ( podcastRun1 . isTextPresent ( " audio " ) ) ; assertTrue ( podcastRun1 . isTextPresent ( PODCAST_EPISODE_2_DESCRIPTION ) ) ; podcastRun1 . createEpisode ( PODCAST_EPISODE_3_TITLE , PODCAST_EPISODE_3_DESCRIPTION , remoteFilePath ) ; assertTrue ( podcastRun1 . isTextPresent ( PODCAST_EPISODE_3_DESCRIPTION ) ) ; podcastRun2 = courseRun2 . selectPodcast ( PODCAST_INTERN ) ; assertTrue ( podcastRun2 . isTextPresent ( PODCAST_EPISODE_3_DESCRIPTION ) ) ; }
jerryyeezus/nlp-summarization | public NivreArcEagerFactory ( DependencyParserConfig _manager ) { super ( _manager ) ; }
jerryyeezus/nlp-summarization | public TransitionSystem makeTransitionSystem ( ) throws MaltChainedException { if ( manager . isLoggerInfoEnabled ( ) ) { manager . logInfoMessage ( " ▁ ▁ Transition ▁ system ▁ ▁ ▁ ▁ : ▁ Arc - Eager \n " ) ; } return new ArcEager ( manager . getPropagationManager ( ) ) ; }
jerryyeezus/nlp-summarization | public OracleGuide makeOracleGuide ( GuideUserHistory history ) throws MaltChainedException { if ( manager . isLoggerInfoEnabled ( ) ) { manager . logInfoMessage ( " ▁ ▁ Oracle ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ : ▁ Arc - Eager \n " ) ; } return new ArcEagerOracle ( manager , history ) ; }
rokn/Count_Words_2015 | protected Mac ( MacSpi macSpi , Provider provider , String algorithm ) { this . spi = macSpi ; this . provider = provider ; this . algorithm = algorithm ; serviceIterator = null ; lock = null ; }
rokn/Count_Words_2015 | private Mac ( Service s , Iterator t , String algorithm ) { firstService = s ; serviceIterator = t ; this . algorithm = algorithm ; lock = new Object ( ) ; }
rokn/Count_Words_2015 | public final String getAlgorithm ( ) { return this . algorithm ; }
rokn/Count_Words_2015 | void chooseFirstProvider ( ) { if ( ( spi != null ) || ( serviceIterator == null ) ) { return ; } synchronized ( lock ) { if ( spi != null ) { return ; } if ( debug != null ) { int w = -- warnCount ; if ( w >= 0 ) { debug . println ( " Mac . init ( ) ▁ not ▁ first ▁ method ▁ " + " called , ▁ disabling ▁ delayed ▁ provider ▁ selection " ) ; if ( w == 0 ) { debug . println ( " Further ▁ warnings ▁ of ▁ this ▁ type ▁ will ▁ " + " be ▁ suppressed " ) ; } new Exception ( " Call ▁ trace " ) . printStackTrace ( ) ; } } Exception lastException = null ; while ( ( firstService != null ) || serviceIterator . hasNext ( ) ) { Service s ; if ( firstService != null ) { s = firstService ; firstService = null ; } else { s = ( Service ) serviceIterator . next ( ) ; } if ( JceSecurity . canUseProvider ( s . getProvider ( ) ) == false ) { continue ; } try { Object obj = s . newInstance ( null ) ; if ( obj instanceof MacSpi == false ) { continue ; } spi = ( MacSpi ) obj ; provider = s . getProvider ( ) ; firstService = null ; serviceIterator = null ; return ; } catch ( NoSuchAlgorithmException e ) { lastException = e ; } } ProviderException e = new ProviderException ( " Could ▁ not ▁ construct ▁ MacSpi ▁ instance " ) ; if ( lastException != null ) { e . initCause ( lastException ) ; } throw e ; } }
rokn/Count_Words_2015 | synchronized ( lock ) { if ( spi != null ) { spi . engineInit ( key , params ) ; return ; } Exception lastException = null ; while ( ( firstService != null ) || serviceIterator . hasNext ( ) ) { Service s ; if ( firstService != null ) { s = firstService ; firstService = null ; } else { s = ( Service ) serviceIterator . next ( ) ; } if ( s . supportsParameter ( key ) == false ) { continue ; } if ( JceSecurity . canUseProvider ( s . getProvider ( ) ) == false ) { continue ; } try { MacSpi spi = ( MacSpi ) s . newInstance ( null ) ; spi . engineInit ( key , params ) ; provider = s . getProvider ( ) ; this . spi = spi ; firstService = null ; serviceIterator = null ; return ; } catch ( Exception e ) { if ( lastException == null ) { lastException = e ; } } } if ( lastException instanceof InvalidKeyException ) { throw ( InvalidKeyException ) lastException ; } if ( lastException instanceof InvalidAlgorithmParameterException ) { throw ( InvalidAlgorithmParameterException ) lastException ; } if ( lastException instanceof RuntimeException ) { throw ( RuntimeException ) lastException ; } String kName = ( key != null ) ? key . getClass ( ) . getName ( ) : " ( null ) " ; throw new InvalidKeyException ( " No ▁ installed ▁ provider ▁ supports ▁ this ▁ key : ▁ " + kName , lastException ) ; }
rokn/Count_Words_2015 | public final Provider getProvider ( ) { chooseFirstProvider ( ) ; return this . provider ; }
rokn/Count_Words_2015 | public final int getMacLength ( ) { chooseFirstProvider ( ) ; return spi . engineGetMacLength ( ) ; }
rokn/Count_Words_2015 | public final void init ( Key key ) throws InvalidKeyException { try { if ( spi != null ) { spi . engineInit ( key , null ) ; } else { chooseProvider ( key , null ) ; } } catch ( InvalidAlgorithmParameterException e ) { throw new InvalidKeyException ( " init ( ) ▁ failed " , e ) ; } initialized = true ; }
rokn/Count_Words_2015 | if ( spi != null ) { spi . engineInit ( key , params ) ; }
rokn/Count_Words_2015 | public final void update ( byte input ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } spi . engineUpdate ( input ) ; }
rokn/Count_Words_2015 | public final void update ( byte [ ] input ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } if ( input != null ) { spi . engineUpdate ( input , 0 , input . length ) ; } }
rokn/Count_Words_2015 | public final void update ( byte [ ] input , int offset , int len ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } if ( input != null ) { if ( ( offset < 0 ) || ( len > ( input . length - offset ) ) || ( len < 0 ) ) throw new IllegalArgumentException ( " Bad ▁ arguments " ) ; spi . engineUpdate ( input , offset , len ) ; } }
rokn/Count_Words_2015 | public final void update ( ByteBuffer input ) { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } if ( input == null ) { throw new IllegalArgumentException ( " Buffer ▁ must ▁ not ▁ be ▁ null " ) ; } spi . engineUpdate ( input ) ; }
rokn/Count_Words_2015 | public final byte [ ] doFinal ( ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } byte [ ] mac = spi . engineDoFinal ( ) ; spi . engineReset ( ) ; return mac ; }
rokn/Count_Words_2015 | if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; }
rokn/Count_Words_2015 | if ( output == null || output . length - outOffset < macLen ) { throw new ShortBufferException ( " Cannot ▁ store ▁ MAC ▁ in ▁ output ▁ buffer " ) ; }
rokn/Count_Words_2015 | public final byte [ ] doFinal ( byte [ ] input ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } update ( input ) ; return doFinal ( ) ; }
rokn/Count_Words_2015 | public final void reset ( ) { chooseFirstProvider ( ) ; spi . engineReset ( ) ; }
rokn/Count_Words_2015 | public final Object clone ( ) throws CloneNotSupportedException { chooseFirstProvider ( ) ; Mac that = ( Mac ) super . clone ( ) ; that . spi = ( MacSpi ) this . spi . clone ( ) ; return that ; }
fwingy/LightPlayer | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( Build . VERSION . SDK_INT >= 21 ) { getActivity ( ) . getWindow ( ) . setStatusBarColor ( Color . TRANSPARENT ) ; getActivity ( ) . getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LAYOUT_STABLE | View . SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN ) ; } }
fwingy/LightPlayer | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_playback_layout , container , false ) ; mSharedPreferences = getActivity ( ) . getSharedPreferences ( LIGHT_MAIN_PREFS_NAME , 0 ) ; initWidget ( view ) ; return view ; }
fwingy/LightPlayer | private void initWidget ( View view ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) ; mCDView = ( CDView ) view . findViewById ( R . id . cd_circle_view ) ; mBackArrow = ( ImageView ) view . findViewById ( R . id . back_arrow ) ; mTitleTextView = ( MarqueeTextView ) view . findViewById ( R . id . playback_layout_title ) ; mArtistTextView = ( TextView ) view . findViewById ( R . id . playback_layout_artist ) ; mSharedImageButton = ( ImageButton ) view . findViewById ( R . id . share_button ) ; mElapsedTime = ( TextView ) view . findViewById ( R . id . text_time_elapsed ) ; mSeekBar = ( SeekBar ) view . findViewById ( R . id . sb_play_progress ) ; mDuration = ( TextView ) view . findViewById ( R . id . text_duration ) ; mPlayModeButton = ( ImageButton ) view . findViewById ( R . id . play_mode_button ) ; mPreButton = ( ImageButton ) view . findViewById ( R . id . ib_play_pre ) ; mPlayButton = ( ImageButton ) view . findViewById ( R . id . ib_play_start ) ; mNextButton = ( ImageButton ) view . findViewById ( R . id . ib_play_next ) ; mAddToPlaylistButton = ( ImageButton ) view . findViewById ( R . id . playlist_add ) ; mLayoutContainer = ( LinearLayout ) view . findViewById ( R . id . playback_layout_root_group ) ; mSharedImageButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Intent intent = new Intent ( ) ; int position = AudioLab . getAudioLab ( getContext ( ) ) . getCurrentPosition ( ) ; Audio audio = AudioLab . getAudioLab ( getContext ( ) ) . getAudioList ( ) . get ( position ) ; File file = new File ( audio . getData ( ) ) ; Uri uri = Uri . fromFile ( file ) ; intent . setAction ( Intent . ACTION_SEND ) ; intent . putExtra ( Intent . EXTRA_STREAM , uri ) ; intent . setType ( " audio / mpeg " ) ; startActivity ( Intent . createChooser ( intent , getString ( R . string . send_to ) ) ) ; } } ) ; int playMode = mSharedPreferences . getInt ( PREFS_KEY_PLAY_MODE , 9999 ) ; if ( playMode == 9999 ) { mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_REPEAT_LIST ) . apply ( ) ; } switch ( mSharedPreferences . getInt ( PREFS_KEY_PLAY_MODE , 9999 ) ) { case PLAY_MODE_REPEAT_SELF : mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_one_white_36dp ) ) ; break ; case PLAY_MODE_REPEAT_LIST : mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_white_36dp ) ) ; break ; case PLAY_MODE_SHUFFLE : mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_shuffle_white_36dp ) ) ; } mSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { mElapsedTime . setText ( FormatUtil . formatDuration ( seekBar . getProgress ( ) ) ) ; } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { flagDraging = 1 ; } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . seek ( seekBar . getProgress ( ) ) ; mHandler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { flagDraging = 0 ; } } , 100 ) ; } } ) ; mBackArrow . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { getActivity ( ) . onBackPressed ( ) ; } } ) ; final Toast toastMode = Toast . makeText ( getContext ( ) , " " , Toast . LENGTH_SHORT ) ; mPlayModeButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { switch ( mSharedPreferences . getInt ( PREFS_KEY_PLAY_MODE , 9999 ) ) { case PLAY_MODE_REPEAT_SELF : ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setLooping ( false ) ; mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_REPEAT_LIST ) . apply ( ) ; mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_white_36dp ) ) ; toastMode . setText ( getString ( R . string . toast_play_mode_circulation ) ) ; toastMode . show ( ) ; ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setNotificationChangeMode ( R . drawable . ic_repeat_black_36dp ) ; break ; case PLAY_MODE_REPEAT_LIST : mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_SHUFFLE ) . apply ( ) ; mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_shuffle_white_36dp ) ) ; toastMode . setText ( getString ( R . string . toast_play_mode_random ) ) ; toastMode . show ( ) ; ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setNotificationChangeMode ( R . drawable . ic_shuffle_black_36dp ) ; break ; case PLAY_MODE_SHUFFLE : ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setLooping ( true ) ; mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_REPEAT_SELF ) . apply ( ) ; mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_one_white_36dp ) ) ; toastMode . setText ( getString ( R . string . toast_play_mode_single_track ) ) ; toastMode . show ( ) ; ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setNotificationChangeMode ( R . drawable . ic_repeat_one_black_36dp ) ; break ; } } } ) ; mPreButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . pre ( ) ; } } ) ; mPlayButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PlayService playService = ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) ; if ( playService . isPlaying ( ) ) { playService . pause ( ) ; } else { playService . resume ( ) ; } } } ) ; mNextButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . next ( ) ; } } ) ; int currentAudioPosition = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getCurrentPosition ( ) ; Audio audio = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getAudioList ( ) . get ( currentAudioPosition ) ; mLoadCDBitmapTask = new LoadCDBitmapTask ( ) ; mLoadBgBitmapTask = new LoadBgBitmapTask ( ) ; mLoadCDBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; mLoadBgBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; }
fwingy/LightPlayer | public void onPositionChanged ( int position ) { Audio audio = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getAudioList ( ) . get ( position ) ; updateView ( audio ) ; }
fwingy/LightPlayer | public void onProgressChanged ( int progress ) { updateDynamicViews ( progress ) ; }
fwingy/LightPlayer | public void onPlay ( ) { Log . i ( " PlayBackFragme的onPlay " , " 调用了 " ) ; mCDView . start ( ) ; mPlayButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_pause_circle_outline_white_48dp ) ) ; }
fwingy/LightPlayer | public void onPaused ( ) { mCDView . pause ( ) ; mPlayButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_play_circle_outline_white_48dp ) ) ; }
fwingy/LightPlayer | @ Override protected Bitmap doInBackground ( Audio ... params ) { Bitmap bitmap ; Audio audio = params [ 0 ] ; bitmap = ImageUtil . loadBitmapForCDFromUri ( audio . getAlbumArt ( ) ) ; try { if ( bitmap == null ) { bitmap = defaultBitmap ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return bitmap ; }
fwingy/LightPlayer | @ Override protected void onPostExecute ( Bitmap bitmap ) { Log . i ( " 任务执行完了 " , " " ) ; mCDView . setImage ( bitmap ) ; }
fwingy/LightPlayer | @ Override protected BitmapDrawable doInBackground ( Audio ... params ) { BitmapDrawable bitmapDrawable = null ; Audio audio = params [ 0 ] ; Bitmap bitmap = ImageUtil . loadBitmapForScreenBgFromUri ( audio . getAlbumArt ( ) ) ; try { if ( bitmap != null ) { Bitmap blurBitmap = FastBlurUtil . doBlur ( bitmap , 8 , true ) ; bitmapDrawable = new BitmapDrawable ( getResources ( ) , blurBitmap ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return bitmapDrawable ; }
fwingy/LightPlayer | @ Override protected void onPostExecute ( BitmapDrawable bitmapDrawable ) { if ( bitmapDrawable != null ) { mLayoutContainer . setBackground ( bitmapDrawable ) ; } else { mLayoutContainer . setBackgroundColor ( ContextCompat . getColor ( getActivity ( ) , R . color . fullscreenblack ) ) ; } }
fwingy/LightPlayer | @ Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( mLoadCDBitmapTask != null ) { mLoadCDBitmapTask . cancel ( true ) ; mLoadCDBitmapTask = null ; } if ( mLoadBgBitmapTask != null ) { mLoadBgBitmapTask . cancel ( true ) ; mLoadBgBitmapTask = null ; } if ( defaultBitmap != null ) { defaultBitmap = null ; } }
fwingy/LightPlayer | public void serviceConected ( ) { if ( ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . isPlaying ( ) ) { onPlay ( ) ; } else { onPaused ( ) ; } int currentPosition = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getCurrentPosition ( ) ; Audio audio = AudioLab . getAudioLab ( getActivity ( ) ) . getAudioList ( ) . get ( currentPosition ) ; updateView ( audio ) ; }
fwingy/LightPlayer | public void updateView ( Audio audio ) { PlayService playService = ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) ; if ( mLoadCDBitmapTask . getStatus ( ) == AsyncTask . Status . RUNNING ) { mLoadCDBitmapTask . cancel ( true ) ; } mLoadCDBitmapTask = null ; if ( mLoadBgBitmapTask . getStatus ( ) == AsyncTask . Status . RUNNING ) { mLoadBgBitmapTask . cancel ( true ) ; } mLoadBgBitmapTask = null ; mLoadCDBitmapTask = new LoadCDBitmapTask ( ) ; mLoadBgBitmapTask = new LoadBgBitmapTask ( ) ; mLoadCDBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; mLoadBgBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; mSeekBar . setMax ( audio . getDuration ( ) ) ; if ( playService . getDuration ( ) != - 1 ) { mDuration . setText ( FormatUtil . formatDuration ( playService . getDuration ( ) ) ) ; } else { mDuration . setText ( FormatUtil . formatDuration ( 0 ) ) ; } mTitleTextView . setText ( audio . getTitle ( ) ) ; mArtistTextView . setText ( audio . getArtist ( ) ) ; }
fwingy/LightPlayer | private void updateDynamicViews ( int progress ) { if ( flagDraging == 0 ) { if ( mElapsedTime != null ) { mElapsedTime . setText ( FormatUtil . formatDuration ( progress ) ) ; } if ( mSeekBar != null ) { mSeekBar . setProgress ( progress ) ; } } }
talsma-ict/umldoclet | public RegexOptional ( IRegex partial ) { super ( partial ) ; }
talsma-ict/umldoclet | @ Override protected String getFullSlow ( ) { final StringBuilder sb = new StringBuilder ( " ( ? : " ) ; sb . append ( partials ( ) . get ( 0 ) . getPattern ( ) ) ; sb . append ( " ) ? " ) ; return sb . toString ( ) ; }
talsma-ict/umldoclet | public boolean match ( StringLocated full ) { throw new UnsupportedOperationException ( ) ; }
RCasatta/geobit-chain | @ Test public void blockchainTest ( ) { BalanceProvider balanceProv = new BlockChainHTTPClient ( ) ; Long result = balanceProv . getBalance ( address ) ; assertNotNull ( result ) ; assertTrue ( result > 0 ) ; ReceivedProvider receivedProv = new BlockChainHTTPClient ( ) ; Long result2 = receivedProv . getReceived ( address ) ; assertNotNull ( result2 ) ; assertTrue ( result2 > 0 ) ; System . out . println ( " received = " + result2 ) ; result = balanceProv . getBalance ( "1G1qk5jKudDjkJ21JafGXq3VghESxHJKCp " ) ; assertNotNull ( result ) ; assertTrue ( result >= 0 ) ; result2 = receivedProv . getReceived ( "1G1qk5jKudDjkJ21JafGXq3VghESxHJKCp " ) ; assertNotNull ( result2 ) ; assertTrue ( result2 >= 0 ) ; TransactionProvider transProv = new BlockChainHTTPClient ( ) ; Transaction t = transProv . getTransaction ( " dc3fdb02f11c037f90c25a83e188bfc6ede64327dd658a33cc981fc5750564c3" ) ; assertNotNull ( t ) ; System . out . println ( " t = " + t ) ; Date d ; try { d = SimpleDateFormats . m_ISO8601Local . parse ( "2012-10-09T17:22:30Z " ) ; System . out . println ( d . getTime ( ) ) ; System . out . println ( d ) ; Date d2 = new Date ( 1349803350L * 1000L ) ; System . out . println ( d2 ) ; System . out . println ( SimpleDateFormats . m_ISO8601Local . format ( d2 ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } TransHexProvider transHexProv = new BlockChainHTTPClient ( ) ; String hex = transHexProv . getTransHex ( " dc3fdb02f11c037f90c25a83e188bfc6ede64327dd658a33cc981fc5750564c3" ) ; System . out . println ( " hex = " + hex ) ; assertEquals ( "01000000017d9d5ee684871124984352a619a2ba7e47dcbe938fe03d309954c5c37dead35b000000006b483045022100ef2ff0eaa8592ba063b23cb5ed4426ec8da75e084eb5d0c639e7ab557244b6c0022062faf9cad264d5d940f5f41b764da8150b20e3ea38f04154cd3aee7674dce600012103e932232ef41a3d2ef858ec3d6eb4ea13b28a096fa5e9a85761f7f578deea1e0effffffff0230d12501000000001976a9146f4c339296f9cb2d45419564f45121ccd84d505188acb8560000000000001976a914a781df4fda5411ecf867101cb18212403d07b6eb88ac00000000" , hex ) ; }
RCasatta/geobit-chain | @ Test public void blockchainUnspentTest ( ) { AddressUnspentsProvider uns = new BlockChainHTTPClient ( ) ; AddressTransactions tr = uns . getAddressUnspents ( "1G8sGKyw4wFGQXBZxk4df6uvCxGb1jR5sJ " ) ; System . out . println ( tr ) ; assertNotNull ( tr ) ; }
code4wt/nutch-learning | public NodeWalker ( Node rootNode ) { nodes = new Stack < > ( ) ; nodes . add ( rootNode ) ; }
code4wt/nutch-learning | public Node nextNode ( ) { if ( ! hasNext ( ) ) { return null ; } currentNode = nodes . pop ( ) ; currentChildren = currentNode . getChildNodes ( ) ; int childLen = ( currentChildren != null ) ? currentChildren . getLength ( ) : 0 ; for ( int i = childLen - 1 ; i >= 0 ; i -- ) { nodes . add ( currentChildren . item ( i ) ) ; } return currentNode ; }
code4wt/nutch-learning | public void skipChildren ( ) { int childLen = ( currentChildren != null ) ? currentChildren . getLength ( ) : 0 ; for ( int i = 0 ; i < childLen ; i ++ ) { Node child = nodes . peek ( ) ; if ( child . equals ( currentChildren . item ( i ) ) ) { nodes . pop ( ) ; } } }
code4wt/nutch-learning | public Node getCurrentNode ( ) { return currentNode ; }
code4wt/nutch-learning | public boolean hasNext ( ) { return ( nodes . size ( ) > 0 ) ; }
infinitiessoft/skyport-hazelcast | @ Override public int getTypeId ( ) { return SerializationConstants . VM_TYPE ; }
infinitiessoft/skyport-hazelcast | @ Override public void destroy ( ) { }
infinitiessoft/skyport-hazelcast | @ Override public void write ( ObjectDataOutput out , Vm object ) throws IOException { out . writeObject ( object . getId ( ) ) ; out . writeUTF ( object . getDesc ( ) ) ; out . writeInt ( object . getVersion ( ) ) ; out . writeUTF ( object . getConfig ( ) ) ; out . writeObject ( object . getCpunum ( ) ) ; out . writeObject ( object . getMemorysize ( ) ) ; out . writeObject ( object . getCreationdate ( ) ) ; out . writeObject ( object . getDisks ( ) ) ; out . writeObject ( object . getNics ( ) ) ; out . writeUTF ( object . getName ( ) ) ; out . writeUTF ( object . getResourceid ( ) ) ; out . writeUTF ( object . getTemplateid ( ) ) ; out . writeUTF ( object . getOs ( ) ) ; out . writeUTF ( object . getVmtype ( ) ) ; out . writeUTF ( object . getHypervisortype ( ) ) ; out . writeUTF ( object . getStatus ( ) ) ; out . writeUTF ( object . getTimeZone ( ) ) ; out . writeUTF ( object . getVmid ( ) ) ; out . writeUTF ( object . getRunningonhostid ( ) ) ; out . writeUTF ( object . getIp ( ) ) ; out . writeUTF ( object . getCdisopath ( ) ) ; out . writeUTF ( object . getInfo ( ) ) ; out . writeObject ( object . getStatistics ( ) ) ; out . writeUTF ( object . getDomain ( ) ) ; out . writeUTF ( object . getDisplayType ( ) ) ; out . writeUTF ( object . getBootDevice ( ) ) ; out . writeUTF ( object . getFlavorId ( ) ) ; out . writeUTF ( object . getKeyName ( ) ) ; out . writeUTF ( object . getType ( ) ) ; out . writeUTF ( object . getGroup ( ) ) ; out . writeUTF ( object . getKey ( ) ) ; out . writeUTF ( object . getConfigid ( ) ) ; }
infinitiessoft/skyport-hazelcast | @ Override public Vm read ( ObjectDataInput in ) throws IOException { Vm ret = new Vm ( ) ; Long id = in . readObject ( ) ; ret . setId ( id ) ; ret . setDesc ( in . readUTF ( ) ) ; ret . setVersion ( in . readInt ( ) ) ; ret . setConfig ( in . readUTF ( ) ) ; Integer cpunum = in . readObject ( ) ; ret . setCpunum ( cpunum ) ; Long memorysize = in . readObject ( ) ; ret . setMemorysize ( memorysize ) ; Date creationdate = in . readObject ( ) ; ret . setCreationdate ( creationdate ) ; Disks disks = in . readObject ( ) ; ret . setDisks ( disks ) ; NetworkAdapters nics = in . readObject ( ) ; ret . setNics ( nics ) ; ret . setName ( in . readUTF ( ) ) ; ret . setResourceid ( in . readUTF ( ) ) ; ret . setTemplateid ( in . readUTF ( ) ) ; ret . setOs ( in . readUTF ( ) ) ; ret . setVmtype ( in . readUTF ( ) ) ; ret . setHypervisortype ( in . readUTF ( ) ) ; ret . setStatus ( in . readUTF ( ) ) ; ret . setTimeZone ( in . readUTF ( ) ) ; ret . setVmid ( in . readUTF ( ) ) ; ret . setRunningonhostid ( in . readUTF ( ) ) ; ret . setIp ( in . readUTF ( ) ) ; ret . setCdisopath ( in . readUTF ( ) ) ; ret . setInfo ( in . readUTF ( ) ) ; Statistics statistics = in . readObject ( ) ; ret . setStatistics ( statistics ) ; ret . setDomain ( in . readUTF ( ) ) ; ret . setDisplayType ( in . readUTF ( ) ) ; ret . setBootDevice ( in . readUTF ( ) ) ; ret . setFlavorId ( in . readUTF ( ) ) ; ret . setKeyName ( in . readUTF ( ) ) ; ret . setType ( in . readUTF ( ) ) ; ret . setGroup ( in . readUTF ( ) ) ; ret . setKey ( in . readUTF ( ) ) ; ret . setConfigid ( in . readUTF ( ) ) ; return ret ; }
tommista/android-net | ObjectRef ( ) { }
tommista/android-net | Builder ( ) { }
mevdschee/tqdev-metrics | public InstrumentedConnection ( Connection connection , MetricRegistry registry ) { this . connection = connection ; this . registry = registry ; }
mevdschee/tqdev-metrics | @ Override public Statement createStatement ( ) throws SQLException { return new InstrumentedStatement ( connection . createStatement ( ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public CallableStatement prepareCall ( String sql ) throws SQLException { return new InstrumentedCallableStatement ( sql , connection . prepareCall ( sql ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public String nativeSQL ( String sql ) throws SQLException { return connection . nativeSQL ( sql ) ; }
mevdschee/tqdev-metrics | @ Override public void setAutoCommit ( boolean autoCommit ) throws SQLException { this . autoCommit = autoCommit ; connection . setAutoCommit ( autoCommit ) ; }
mevdschee/tqdev-metrics | @ Override public boolean getAutoCommit ( ) throws SQLException { return connection . getAutoCommit ( ) ; }
mevdschee/tqdev-metrics | @ Override public void commit ( ) throws SQLException { connection . commit ( ) ; }
mevdschee/tqdev-metrics | @ Override public void rollback ( ) throws SQLException { connection . rollback ( ) ; }
mevdschee/tqdev-metrics | @ Override public void close ( ) throws SQLException { connection . close ( ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isClosed ( ) throws SQLException { return connection . isClosed ( ) ; }
mevdschee/tqdev-metrics | @ Override public DatabaseMetaData getMetaData ( ) throws SQLException { return connection . getMetaData ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setReadOnly ( boolean readOnly ) throws SQLException { connection . setReadOnly ( readOnly ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isReadOnly ( ) throws SQLException { return connection . isReadOnly ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setCatalog ( String catalog ) throws SQLException { connection . setCatalog ( catalog ) ; }
mevdschee/tqdev-metrics | @ Override public String getCatalog ( ) throws SQLException { return connection . getCatalog ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setTransactionIsolation ( int level ) throws SQLException { connection . setTransactionIsolation ( level ) ; }
mevdschee/tqdev-metrics | @ Override public int getTransactionIsolation ( ) throws SQLException { return connection . getTransactionIsolation ( ) ; }
mevdschee/tqdev-metrics | @ Override public SQLWarning getWarnings ( ) throws SQLException { return connection . getWarnings ( ) ; }
mevdschee/tqdev-metrics | @ Override public void clearWarnings ( ) throws SQLException { connection . clearWarnings ( ) ; }
mevdschee/tqdev-metrics | @ Override public Statement createStatement ( int resultSetType , int resultSetConcurrency ) throws SQLException { return new InstrumentedStatement ( connection . createStatement ( resultSetType , resultSetConcurrency ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , resultSetType , resultSetConcurrency ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { return new InstrumentedCallableStatement ( sql , connection . prepareCall ( sql , resultSetType , resultSetConcurrency ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public Map < String , Class < ? > > getTypeMap ( ) throws SQLException { return connection . getTypeMap ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setTypeMap ( Map < String , Class < ? > > map ) throws SQLException { connection . setTypeMap ( map ) ; }
mevdschee/tqdev-metrics | @ Override public void setHoldability ( int holdability ) throws SQLException { connection . setHoldability ( holdability ) ; }
mevdschee/tqdev-metrics | @ Override public int getHoldability ( ) throws SQLException { return connection . getHoldability ( ) ; }
mevdschee/tqdev-metrics | @ Override public Savepoint setSavepoint ( ) throws SQLException { return connection . setSavepoint ( ) ; }
mevdschee/tqdev-metrics | @ Override public Savepoint setSavepoint ( String name ) throws SQLException { return connection . setSavepoint ( name ) ; }
mevdschee/tqdev-metrics | @ Override public void rollback ( Savepoint savepoint ) throws SQLException { connection . rollback ( savepoint ) ; }
mevdschee/tqdev-metrics | @ Override public void releaseSavepoint ( Savepoint savepoint ) throws SQLException { connection . releaseSavepoint ( savepoint ) ; }
mevdschee/tqdev-metrics | @ Override public Statement createStatement ( int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return new InstrumentedStatement ( connection . createStatement ( resultSetType , resultSetConcurrency , resultSetHoldability ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , resultSetType , resultSetConcurrency , resultSetHoldability ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return new InstrumentedCallableStatement ( sql , connection . prepareCall ( sql , resultSetType , resultSetConcurrency , resultSetHoldability ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int autoGeneratedKeys ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , autoGeneratedKeys ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int [ ] columnIndexes ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , columnIndexes ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , String [ ] columnNames ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , columnNames ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public Clob createClob ( ) throws SQLException { return connection . createClob ( ) ; }
mevdschee/tqdev-metrics | @ Override public Blob createBlob ( ) throws SQLException { return connection . createBlob ( ) ; }
mevdschee/tqdev-metrics | @ Override public NClob createNClob ( ) throws SQLException { return connection . createNClob ( ) ; }
mevdschee/tqdev-metrics | @ Override public SQLXML createSQLXML ( ) throws SQLException { return connection . createSQLXML ( ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isValid ( int timeout ) throws SQLException { return connection . isValid ( timeout ) ; }
mevdschee/tqdev-metrics | @ Override public void setClientInfo ( String name , String value ) throws SQLClientInfoException { connection . setClientInfo ( name , value ) ; }
mevdschee/tqdev-metrics | @ Override public void setClientInfo ( Properties properties ) throws SQLClientInfoException { connection . setClientInfo ( properties ) ; }
mevdschee/tqdev-metrics | @ Override public String getClientInfo ( String name ) throws SQLException { return connection . getClientInfo ( name ) ; }
mevdschee/tqdev-metrics | @ Override public Properties getClientInfo ( ) throws SQLException { return connection . getClientInfo ( ) ; }
mevdschee/tqdev-metrics | @ Override public Array createArrayOf ( String typeName , Object [ ] elements ) throws SQLException { return connection . createArrayOf ( typeName , elements ) ; }
mevdschee/tqdev-metrics | @ Override public Struct createStruct ( String typeName , Object [ ] attributes ) throws SQLException { return connection . createStruct ( typeName , attributes ) ; }
mevdschee/tqdev-metrics | @ Override public void setSchema ( String schema ) throws SQLException { connection . setSchema ( schema ) ; }
mevdschee/tqdev-metrics | @ Override public String getSchema ( ) throws SQLException { return connection . getSchema ( ) ; }
mevdschee/tqdev-metrics | @ Override public void abort ( Executor executor ) throws SQLException { connection . abort ( executor ) ; }
mevdschee/tqdev-metrics | @ Override public void setNetworkTimeout ( Executor executor , int milliseconds ) throws SQLException { connection . setNetworkTimeout ( executor , milliseconds ) ; }
mevdschee/tqdev-metrics | @ Override public int getNetworkTimeout ( ) throws SQLException { return connection . getNetworkTimeout ( ) ; }
mevdschee/tqdev-metrics | @ Override public < T > T unwrap ( Class < T > iface ) throws SQLException { return connection . unwrap ( iface ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isWrapperFor ( Class < ? > iface ) throws SQLException { return connection . isWrapperFor ( iface ) ; }
nmldiegues/jvm-stm | public int hashCode ( ) { return year * 31 + month ; }
nmldiegues/jvm-stm | public boolean equals ( Object other ) { if ( other instanceof GYearMonth ) { GYearMonth gmy = ( GYearMonth ) other ; return gmy . year == year && gmy . month == month ; } return false ; }
nmldiegues/jvm-stm | public int compareTo ( Object other ) { if ( other instanceof GYearMonth ) { GYearMonth gmy = ( GYearMonth ) other ; if ( gmy . year == year ) { if ( gmy . month == month ) return 0 ; return ( month < gmy . month ) ? - 1 : 1 ; } return ( year < gmy . year ) ? - 1 : 1 ; } return 0 ; }
nmldiegues/jvm-stm | GYearMonthType ( ) { super ( new QName ( XMLConstants . W3C_XML_SCHEMA_NS_URI , " gYearMonth " ) , TypeLibrary . ANY_SIMPLE_TYPE ) ; }
nmldiegues/jvm-stm | public int [ ] getConstrainingFacets ( ) { return CONSTRAINING_FACETS ; }
nmldiegues/jvm-stm | public void checkValid ( String value , ValidationContext context ) throws DatatypeException { super . checkValid ( value , context ) ; int len = value . length ( ) ; int state = 0 ; int start = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; if ( c == ' - ' && i == 0 ) { start ++ ; continue ; } if ( c >= 0x30 && c <= 0x39 ) continue ; switch ( state ) { case 0 : if ( c == ' - ' ) { String year = value . substring ( start , i ) ; if ( year . length ( ) < 4 || Integer . parseInt ( year ) == 0 ) throw new DatatypeException ( i , " illegal ▁ GYear ▁ value " ) ; state = 1 ; start = i + 1 ; continue ; } break ; } throw new DatatypeException ( i , " illegal ▁ GYear ▁ value " ) ; } switch ( state ) { case 1 : if ( len - start != 2 ) throw new DatatypeException ( " illegal ▁ GYear ▁ value " ) ; break ; default : throw new DatatypeException ( " illegal ▁ GYear ▁ value " ) ; } }
nmldiegues/jvm-stm | public Object createValue ( String literal , ValidationContext context ) { try { int offset = 5 ; if ( literal . charAt ( 0 ) == ' - ' ) offset ++ ; GYearMonth ret = new GYearMonth ( ) ; ret . year = Integer . parseInt ( literal . substring ( 0 , offset ) ) ; ret . month = Integer . parseInt ( literal . substring ( offset + 1 ) ) ; return ret ; } catch ( Exception e ) { return null ; } }
Teiid-Designer/modeshape | public ParsingException ( String message , int lineNumber , int columnNumber ) { super ( message ) ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; }
Teiid-Designer/modeshape | public ParsingException ( String message , Throwable cause , int lineNumber , int columnNumber ) { super ( message , cause ) ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; }
Teiid-Designer/modeshape | public int getLineNumber ( ) { return lineNumber ; }
Teiid-Designer/modeshape | public int getColumnNumber ( ) { return columnNumber ; }
akhettar/camel | private HL723Converter ( ) { }
impro3-nerdle/nerdle | private SingletonGraph ( ) { try { propertiesConfiguration = new PropertiesConfiguration ( ResourceManager . getResourcePath ( File . separator + " graphs . properties " ) ) ; } catch ( ConfigurationException e ) { e . printStackTrace ( ) ; } String [ ] graphStrings = propertiesConfiguration . getStringArray ( " graphs " ) ; String graphsBasePath = propertiesConfiguration . getString ( " basePath " ) ; graphs = new HashMap < String , TinkerGraph > ( ) ; for ( String graph : graphStrings ) { TinkerGraph g = new TinkerGraph ( graphsBasePath + File . separator + graph , TinkerGraph . FileType . GRAPHSON ) ; g . createKeyIndex ( NerdleGraphTransformer . PROPERTY_LEMMA , Vertex . class ) ; graphs . put ( graph , g ) ; } }
impro3-nerdle/nerdle | public HashMap < String , TinkerGraph > getGraphs ( ) { return graphs ; }
mrodrigues/ASD-Teaching-Tool | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_select_game ) ; initialContext = this ; }
mrodrigues/ASD-Teaching-Tool | @ Override protected void onResume ( ) { super . onResume ( ) ; Integer visibility = null ; if ( Question . published ( ) . isEmpty ( ) ) { visibility = View . GONE ; } else { visibility = View . VISIBLE ; } findViewById ( R . id . startQuestions ) . setVisibility ( visibility ) ; }
mrodrigues/ASD-Teaching-Tool | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . select_game , menu ) ; return true ; }
mrodrigues/ASD-Teaching-Tool | public void startQuestionsMenu ( View v ) { Intent intent = new Intent ( this , QuestionActivity . class ) ; intent . putExtra ( QuestionActivity . EXTRA_QUESTIONS_IDS , Question . publishedIds ( ) ) ; intent . putExtra ( QuestionActivity . EXTRA_QUESTION_ID_INDEX , 0 ) ; startActivity ( intent ) ; }
mrodrigues/ASD-Teaching-Tool | public void startPecsMenu ( View v ) { startActivity ( new Intent ( this , PecsActivity . class ) ) ; }
mrodrigues/ASD-Teaching-Tool | public void startConfigMenu ( View v ) { startActivity ( new Intent ( this , ConfigActivity . class ) ) ; }
huihoo/olat | public DialogCourseNode ( ) { super ( TYPE ) ; updateModuleConfigDefaults ( true ) ; }
huihoo/olat | @ Override public TabbableController createEditController ( final UserRequest ureq , final WindowControl wControl , final ICourse course , final UserCourseEnvironment euce ) { updateModuleConfigDefaults ( false ) ; final DialogCourseNodeEditController childTabCntrllr = new DialogCourseNodeEditController ( ureq , wControl , this , course , euce ) ; final CourseNode chosenNode = course . getEditorTreeModel ( ) . getCourseNode ( euce . getCourseEditorEnv ( ) . getCurrentCourseNodeId ( ) ) ; return new NodeEditController ( ureq , wControl , course . getEditorTreeModel ( ) , course , chosenNode , course . getCourseEnvironment ( ) . getCourseGroupManager ( ) , euce , childTabCntrllr ) ; }
huihoo/olat | @ Override public NodeRunConstructionResult createNodeRunConstructionResult ( final UserRequest ureq , final WindowControl wControl , final UserCourseEnvironment userCourseEnv , final NodeEvaluation ne , final String nodecmd ) { final DialogCourseNodeRunController ctrl = new DialogCourseNodeRunController ( ureq , userCourseEnv , wControl , this , ne ) ; final Controller wrappedCtrl = TitledWrapperHelper . getWrapper ( ureq , wControl , ctrl , this , " o _ dialog _ icon " ) ; return new NodeRunConstructionResult ( wrappedCtrl ) ; }
huihoo/olat | @ Override public StatusDescription [ ] isConfigValid ( final CourseEditorEnv cev ) { oneClickStatusCache = null ; final String translatorStr = PackageUtil . getPackageName ( DialogCourseNodeEditController . class ) ; final List sds = isConfigValidWithTranslator ( cev , translatorStr , getConditionExpressions ( ) ) ; oneClickStatusCache = StatusDescriptionHelper . sort ( sds ) ; return oneClickStatusCache ; }
huihoo/olat | @ Override public RepositoryEntry getReferencedRepositoryEntry ( ) { return null ; }
huihoo/olat | @ Override public boolean needsReferenceToARepositoryEntry ( ) { return false ; }
huihoo/olat | @ Override public StatusDescription isConfigValid ( ) { if ( oneClickStatusCache != null ) { return oneClickStatusCache [ 0 ] ; } return StatusDescription . NOERROR ; }
huihoo/olat | @ Override public void updateModuleConfigDefaults ( final boolean isNewNode ) { final ModuleConfiguration config = getModuleConfiguration ( ) ; if ( isNewNode ) { config . setConfigurationVersion ( 1 ) ; config . set ( DialogConfigForm . DIALOG_CONFIG_INTEGRATION , DialogConfigForm . CONFIG_INTEGRATION_VALUE_INLINE ) ; } }
huihoo/olat | @ Override public String informOnDelete ( final Locale locale , final ICourse course ) { return null ; }
huihoo/olat | @ Override public void cleanupOnDelete ( final ICourse course ) { final DialogElementsPropertyManager depm = DialogElementsPropertyManager . getInstance ( ) ; final DialogPropertyElements findDialogElements = depm . findDialogElements ( course . getResourceableId ( ) , getIdent ( ) ) ; if ( findDialogElements != null ) { final List < DialogElement > dialogElments = findDialogElements . getDialogPropertyElements ( ) ; for ( final DialogElement dialogElement : dialogElments ) { final Long forumKey = dialogElement . getForumKey ( ) ; getForumService ( ) . deleteForum ( forumKey ) ; } } depm . deleteProperty ( course . getResourceableId ( ) , this . getIdent ( ) ) ; }
huihoo/olat | private ForumService getForumService ( ) { return ( ForumService ) CoreSpringFactory . getBean ( ForumService . class ) ; }
huihoo/olat | @ Override public boolean archiveNodeData ( final Locale locale , final ICourse course , final File exportDirectory , final String charset ) { boolean dataFound = false ; final DialogElementsPropertyManager depm = DialogElementsPropertyManager . getInstance ( ) ; final DialogPropertyElements elements = depm . findDialogElements ( course . getCourseEnvironment ( ) . getCoursePropertyManager ( ) , this ) ; List list = new ArrayList ( ) ; if ( elements != null ) { list = elements . getDialogPropertyElements ( ) ; } for ( final Iterator iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { final DialogElement element = ( DialogElement ) iter . next ( ) ; doArchiveElement ( element , exportDirectory ) ; dataFound = true ; } return dataFound ; }
huihoo/olat | public void doArchiveElement ( final DialogElement element , final File exportDirectory ) { final VFSContainer forumContainer = getForumService ( ) . getForumContainer ( element . getForumKey ( ) ) ; final VFSItem dialogFile = forumContainer . getItems ( new VFSLeafFilter ( ) ) . get ( 0 ) ; final VFSContainer exportContainer = new LocalFolderImpl ( exportDirectory ) ; final java . text . SimpleDateFormat formatter = new java . text . SimpleDateFormat ( " yyyy - MM - dd ' T ' HH _ mm _ ss _ SSS " ) ; final String exportDirName = getShortTitle ( ) + " _ " + element . getForumKey ( ) + " _ " + formatter . format ( new Date ( System . currentTimeMillis ( ) ) ) ; final VFSContainer diaNodeElemExportContainer = exportContainer . createChildContainer ( exportDirName ) ; diaNodeElemExportContainer . setLocalSecurityCallback ( new FullAccessCallback ( ) ) ; diaNodeElemExportContainer . copyFrom ( dialogFile ) ; final ForumArchiveManager fam = ForumArchiveManager . getInstance ( ) ; final ForumFormatter ff = new ForumRTFFormatter ( diaNodeElemExportContainer , false ) ; fam . applyFormatter ( ff , element . getForumKey ( ) . longValue ( ) , null ) ; }
huihoo/olat | @ Override protected void calcAccessAndVisibility ( final ConditionInterpreter ci , final NodeEvaluation nodeEval ) { final boolean reader = ( getPreConditionReader ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionReader ( ) ) ) ; nodeEval . putAccessStatus ( " reader " , reader ) ; final boolean poster = ( getPreConditionPoster ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionPoster ( ) ) ) ; nodeEval . putAccessStatus ( " poster " , poster ) ; final boolean moderator = ( getPreConditionModerator ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionModerator ( ) ) ) ; nodeEval . putAccessStatus ( " moderator " , moderator ) ; final boolean visible = ( getPreConditionVisibility ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionVisibility ( ) ) ) ; nodeEval . setVisible ( visible ) ; }
huihoo/olat | public Condition getPreConditionModerator ( ) { if ( this . preConditionModerator == null ) { this . preConditionModerator = new Condition ( ) ; this . preConditionModerator . setEasyModeCoachesAndAdmins ( true ) ; this . preConditionModerator . setEasyModeAlwaysAllowCoachesAndAdmins ( true ) ; this . preConditionModerator . setConditionExpression ( " ( ▁ ▁ ( ▁ isCourseCoach ( 0 ) ▁ | ▁ isCourseAdministrator ( 0 ) ▁ ) ▁ ) " ) ; } this . preConditionModerator . setConditionId ( " moderator " ) ; return this . preConditionModerator ; }
huihoo/olat | public void setPreConditionModerator ( Condition preConditionMod ) { if ( preConditionMod == null ) { preConditionMod = getPreConditionModerator ( ) ; } preConditionMod . setConditionId ( " moderator " ) ; this . preConditionModerator = preConditionMod ; }
huihoo/olat | public Condition getPreConditionPoster ( ) { if ( preConditionPoster == null ) { preConditionPoster = new Condition ( ) ; } preConditionPoster . setConditionId ( " poster " ) ; return preConditionPoster ; }
huihoo/olat | public void setPreConditionPoster ( Condition preConditionPoster ) { if ( preConditionPoster == null ) { preConditionPoster = getPreConditionPoster ( ) ; } preConditionPoster . setConditionId ( " poster " ) ; this . preConditionPoster = preConditionPoster ; }
huihoo/olat | public Condition getPreConditionReader ( ) { if ( preConditionReader == null ) { preConditionReader = new Condition ( ) ; } preConditionReader . setConditionId ( " reader " ) ; return preConditionReader ; }
huihoo/olat | public void setPreConditionReader ( Condition preConditionReader ) { if ( preConditionReader == null ) { preConditionReader = getPreConditionReader ( ) ; } preConditionReader . setConditionId ( " reader " ) ; this . preConditionReader = preConditionReader ; }
lifechurch/nuclei-android | public OffsetAdapterTests ( ) { super ( OffsetTestActivity . class ) ; }
lifechurch/nuclei-android | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; getActivity ( ) ; }
lifechurch/nuclei-android | public void testOffsetTests ( ) { onView ( withId ( R . id . items ) ) . check ( matches ( atPosition ( 1 , withText ( Integer . toString ( Integer . MAX_VALUE - 1 ) ) ) ) ) ; onView ( withId ( R . id . items ) ) . check ( matches ( atPosition ( 10 , withText ( Integer . toString ( Integer . MAX_VALUE - 2 ) ) ) ) ) ; for ( int i = 0 ; i < 102 ; i ++ ) { int v = i ; if ( v >= 10 ) { if ( v == 10 ) v = Integer . MAX_VALUE ; v -= 2 ; } else if ( v >= 1 ) { if ( v == 1 ) v = Integer . MAX_VALUE ; v -- ; } onView ( withId ( R . id . items ) ) . perform ( scrollToPosition ( i ) ) ; onView ( withId ( R . id . items ) ) . check ( matches ( atPosition ( i , withText ( Integer . toString ( v ) ) ) ) ) ; } }
asomov/snakeyaml | public void testGet_snippet ( ) { Mark mark = new Mark ( " test1" , 0 , 0 , 0 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; assertEquals ( " ▁ ▁ ▁ ▁ * The ▁ first ▁ line . \n ▁ ▁ ▁ ▁ ^ " , mark . get_snippet ( ) ) ; mark = new Mark ( " test1" , 0 , 0 , 0 , " The ▁ first * line . \n The ▁ last ▁ line . " . toCharArray ( ) , 9 ) ; assertEquals ( " ▁ ▁ ▁ ▁ The ▁ first * line . \n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ^ " , mark . get_snippet ( ) ) ; }
asomov/snakeyaml | public void testToString ( ) { Mark mark = new Mark ( " test1" , 0 , 0 , 0 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; String [ ] lines = mark . toString ( ) . split ( " \n " ) ; assertEquals ( " ▁ in ▁ test1 , ▁ line ▁ 1 , ▁ column ▁ 1 : " , lines [ 0 ] ) ; assertEquals ( " * The ▁ first ▁ line . " , lines [ 1 ] . trim ( ) ) ; assertEquals ( " ^ " , lines [ 2 ] . trim ( ) ) ; }
asomov/snakeyaml | public void testPosition ( ) { Mark mark = new Mark ( " test1" , 17 , 29 , 213 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; assertEquals ( " index ▁ is ▁ used ▁ in ▁ JRuby " , 17 , mark . getIndex ( ) ) ; assertEquals ( 29 , mark . getLine ( ) ) ; assertEquals ( 213 , mark . getColumn ( ) ) ; }
asomov/snakeyaml | public void testGetBuffer ( ) { Mark mark = new Mark ( " test1" , 0 , 29 , 213 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; int [ ] buffer = new int [ ] { 42 , 84 , 104 , 101 , 32 , 102 , 105 , 114 , 115 , 116 , 32 , 108 , 105 , 110 , 101 , 46 , 10 , 84 , 104 , 101 , 32 , 108 , 97 , 115 , 116 , 32 , 108 , 105 , 110 , 101 , 46 } ; assertTrue ( buffer . length == mark . getBuffer ( ) . length ) ; boolean match = true ; for ( int i = 0 ; i < buffer . length ; i ++ ) { if ( buffer [ i ] != mark . getBuffer ( ) [ i ] ) { match = false ; break ; } } assertTrue ( match ) ; }
asomov/snakeyaml | public void testGetPointer ( ) { Mark mark = new Mark ( " test1" , 0 , 29 , 213 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 5 ) ; assertEquals ( 5 , mark . getPointer ( ) ) ; }
HiDrive/hidrive-android-sdk | private void setErrorCode ( int errorCode ) { this . errorCode = errorCode ; }
HiDrive/hidrive-android-sdk | public int getErrorCode ( ) { return errorCode ; }
HiDrive/hidrive-android-sdk | private void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; }
HiDrive/hidrive-android-sdk | public String getErrorMessage ( ) { return errorMessage ; }
HiDrive/hidrive-android-sdk | private void setErrorDetails ( String errorDetails ) { this . errorDetails = errorDetails ; }
HiDrive/hidrive-android-sdk | public String getErrorDetails ( ) { return errorDetails ; }
HiDrive/hidrive-android-sdk | public GatewayError ( int code , String message , String details ) { this . setErrorCode ( code ) ; this . setErrorMessage ( message ) ; this . setErrorDetails ( details ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public GameButton ( TextureRegion region , float x , float y ) { this ( region , x , y , 1.0f , 0.98f ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public GameButton ( TextureRegion region , float x , float y , float width , float height ) { sprite . setRegion ( region ) ; sprite . setBounds ( x , y - height , width , height ) ; isEnabled = true ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void draw ( SpriteBatch spriteBatch ) { sprite . draw ( spriteBatch ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public boolean check ( float x , float y ) { if ( isEnabled && GameHelper . tapPointInsideRectangle ( x , y , sprite . getX ( ) , sprite . getY ( ) + sprite . getHeight ( ) , sprite . getWidth ( ) , sprite . getHeight ( ) ) ) { onClick ( ) ; return true ; } return false ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void translate ( float posX , float posY ) { sprite . setPosition ( posX , posY ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void changeTexture ( TextureRegion region ) { sprite . setRegion ( region ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void setIsEnabled ( boolean isEnabled ) { this . isEnabled = isEnabled ; }
DrDavidJ/EvoPortal | public ComputeJobDetail ( PageParameters params ) { String idStr = params . getString ( " jobID " ) ; final int jobID = Integer . parseInt ( idStr ) ; final ComputeJob job = ComputeJobsDataProvider . get ( jobID ) ; add ( new Label ( " id " , idStr ) ) ; add ( new Label ( " name " , job . getLabel ( ) ) ) ; add ( new Label ( " submitted " , new Date ( job . getSubmitTime ( ) ) . toString ( ) ) ) ; add ( new Label ( " status " , GlobalConstants . getStatusMsg ( job . getStatus ( ) ) ) ) ; add ( new Label ( " nodes " , " " + job . getNodes ( ) ) ) ; add ( new Label ( " processors " , " " + ( job . getNodes ( ) * 4 ) ) ) ; add ( new Label ( " timeRequested " , TimeUtil . millisToLongDHMS ( job . getTimeRequested ( ) ) ) ) ; add ( new Label ( " timeUsed " , TimeUtil . millisToLongDHMS ( job . getTimeUsed ( ) ) ) ) ; final String owner = job . getOwner ( ) ; String dirToZipFileString = GlobalConstants . getProperty ( " local . fileroot " ) + owner + " / " + jobID ; File dirToZipFile = new File ( dirToZipFileString ) ; if ( dirToZipFile != null && dirToZipFile . exists ( ) ) { String dirToZip = dirToZipFile . getPath ( ) ; File zipFile = new File ( jobID + " . zip " ) ; ZipFileLink zipLink = new ZipFileLink ( " zipLink " , zipFile , dirToZip ) ; add ( zipLink ) ; } else { add ( new Link ( " zipLink " ) { @ Override public void onClick ( ) { } } . setEnabled ( false ) ) ; } OutputFilesDataProvider outputFilesProvider = new OutputFilesDataProvider ( owner , jobID ) ; OutputFilesDataView outputFilesDataView = new OutputFilesDataView ( " outputFiles " , outputFilesProvider , jobID ) ; add ( outputFilesDataView ) ; setOutputMarkupId ( true ) ; add ( new AjaxSelfUpdatingTimerBehavior ( Duration . seconds ( 15 ) ) { @ Override protected void onPostProcessTarget ( AjaxRequestTarget target ) { super . onPostProcessTarget ( target ) ; if ( ' S ' != job . getStatus ( ) ) { ComputeJob refreshedJob = ComputeJobsDataProvider . get ( jobID ) ; get ( " status " ) . replaceWith ( new Label ( " status " , GlobalConstants . getStatusMsg ( refreshedJob . getStatus ( ) ) ) ) ; get ( " timeUsed " ) . replaceWith ( new Label ( " timeUsed " , Long . toString ( refreshedJob . getTimeUsed ( ) ) ) ) ; OutputFilesDataProvider outputFilesProvider = new OutputFilesDataProvider ( owner , jobID ) ; get ( " outputFiles " ) . replaceWith ( new OutputFilesDataView ( " outputFiles " , outputFilesProvider , jobID ) ) ; String dirToZipFileString = GlobalConstants . getProperty ( " local . fileroot " ) + owner + " / " + jobID ; File dirToZipFile = new File ( dirToZipFileString ) ; if ( dirToZipFile != null ) { String dirToZip = dirToZipFile . getPath ( ) ; File zipFile = new File ( jobID + " . zip " ) ; get ( " zipLink " ) . replaceWith ( new ZipFileLink ( " zipLink " , zipFile , dirToZip ) . setDeleteAfterDownload ( true ) ) ; } else { get ( " zipLink " ) . replaceWith ( new Link ( " zipLink " ) { @ Override public void onClick ( ) { } } . setEnabled ( false ) ) ; } } } } ) ; }
DrDavidJ/EvoPortal | public ComputeJobDetail ( ) { setResponsePage ( ComputeJobs . class ) ; }
DrDavidJ/EvoPortal | public ZipFileLink ( String id , File zipFile , String dirToZip ) { super ( id , zipFile ) ; ZipOutputStream zos = null ; try { zos = new ZipOutputStream ( new FileOutputStream ( zipFile ) ) ; zipDir ( dirToZip , zos ) ; } catch ( IOException ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } finally { try { zos . close ( ) ; } catch ( IOException ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } } }
DrDavidJ/EvoPortal | private void zipDir ( String dir2zip , ZipOutputStream zos ) throws IOException { File zipDir = new File ( dir2zip ) ; String [ ] dirList = zipDir . list ( ) ; byte [ ] readBuffer = new byte [ 2048 ] ; int bytesIn = 0 ; for ( int i = 0 ; i < dirList . length ; i ++ ) { File f = new File ( zipDir , dirList [ i ] ) ; if ( f . isDirectory ( ) ) { String filePath = f . getPath ( ) ; zipDir ( filePath , zos ) ; continue ; } FileInputStream fis = new FileInputStream ( f ) ; ZipEntry anEntry = new ZipEntry ( f . getName ( ) ) ; zos . putNextEntry ( anEntry ) ; while ( ( bytesIn = fis . read ( readBuffer ) ) != - 1 ) { zos . write ( readBuffer , 0 , bytesIn ) ; } fis . close ( ) ; } }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsAreEqual ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" ) ; assertEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentUUIDs ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "456" ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentParentUUIDs ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" , null , null , null , "456" ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" , null , null , null , "789" ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentTypes ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" , null , ITEM , null , null ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" , null , CONTEXT , null , null ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentLabels ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" , " Node1" , null , null , null ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" , " Node0" , null , null , null ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testOnClick ( ) { final Command command = mock ( Command . class ) ; final DecisionNavigatorItem item = new DecisionNavigatorItem ( " uuid " , " label " , ITEM , command , null ) ; item . onClick ( ) ; verify ( command ) . execute ( ) ; }
Rikkola/kie-wb-common | @ Test public void testRemoveChild ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( " item " ) ; final DecisionNavigatorItem child = new DecisionNavigatorItem ( " child " ) ; item . getChildren ( ) . add ( child ) ; item . removeChild ( child ) ; assertEquals ( Collections . emptySet ( ) , item . getChildren ( ) ) ; }
Rikkola/kie-wb-common | @ Test public void testAddChild ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( " item " ) ; final DecisionNavigatorItem child = new DecisionNavigatorItem ( " child " ) ; final TreeSet < DecisionNavigatorItem > expectedChildren = new TreeSet < DecisionNavigatorItem > ( ) { { add ( child ) ; } } ; item . addChild ( child ) ; item . addChild ( child ) ; assertEquals ( expectedChildren , item . getChildren ( ) ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenObjectIsNotADecisionNavigatorItem ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" ) ; final Object object = null ; final int result = item . compareTo ( object ) ; assertTrue ( result > 0 ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenItemAndObjectAreEqual ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" ) ; final Object object = new DecisionNavigatorItem ( "123" ) ; final int result = item . compareTo ( object ) ; assertEquals ( 0 , result ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenItemOrderingNameIsGreaterThanObjectOrderingName ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" , " Hat " , null , null , null ) ; final Object object = new DecisionNavigatorItem ( "456" , " Red " , null , null , null ) ; final int result = item . compareTo ( object ) ; assertTrue ( result < 0 ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenItemOrderingNameIsLessThanObjectOrderingName ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" , " Red " , null , null , null ) ; final Object object = new DecisionNavigatorItem ( "456" , " Hat " , null , null , null ) ; final int result = item . compareTo ( object ) ; assertTrue ( result > 0 ) ; }
smanvi-pivotal/geode | public SizingFlagDUnitTest ( ) { super ( ) ; }
smanvi-pivotal/geode | @ Test public void testRRMemLRU ( ) { doRRMemLRUTest ( ) ; }
smanvi-pivotal/geode | @ Test public void testRRMemLRUDeltaAndFlag ( ) { doRRMemLRUDeltaTest ( true ) ; }
smanvi-pivotal/geode | @ Test public void testRRMemLRUDelta ( ) { doRRMemLRUDeltaTest ( false ) ; }
smanvi-pivotal/geode | @ Test public void testRRListener ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; addListener ( vm0 ) ; addListener ( vm1 ) ; doListenerTestRR ( vm0 , vm1 ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRU ( ) { doPRMemLRUTest ( ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUAndFlagDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , false , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , false , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUAndFlagDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , false , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , false , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testPRNoLRUDelta ( ) { doPRNoLRUDeltaTest ( false ) ; }
smanvi-pivotal/geode | @ Test public void testPRNoLRUAndFlagDelta ( ) { doPRNoLRUDeltaTest ( true ) ; }
smanvi-pivotal/geode | @ Test public void testPRListener ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; addListener ( vm0 ) ; addListener ( vm1 ) ; doListenerTestPR ( vm0 , vm1 ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRU ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPRHeapLRU ( vm0 ) ; createPRHeapLRU ( vm1 ) ; put ( vm0 , new TestKey ( " a " ) , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; long origSize0 = getSizeFromPRStats ( vm0 ) ; assertTrue ( " Size ▁ was ▁ " + origSize0 , 1000 > origSize0 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origSize1 = getSizeFromPRStats ( vm1 ) ; assertTrue ( " Size ▁ was ▁ " + origSize1 , 1000 > origSize1 ) ; get ( vm0 , new TestKey ( " a " ) , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , new TestKey ( " a " ) , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertEquals ( 3 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; }
smanvi-pivotal/geode | @ Test public void testRRHeapLRU ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRRHeapLRU ( vm0 ) ; createRRHeapLRU ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; get ( vm1 , " a " , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaWithFlagPutOnPrimary ( ) { doPRDeltaTestLRU ( false , true , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , true , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaWithFlagPutOnSecondary ( ) { doPRDeltaTestLRU ( false , true , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , true , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testLargeDelta ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , false ) ; setDeltaRecalculatesSize ( vm1 , false ) ; createPR ( vm0 , false ) ; createPR ( vm1 , false ) ; int BIG_DELTA_SIZE = 32 * 1024 * 2 ; StringBuilder sb = new StringBuilder ( BIG_DELTA_SIZE ) ; for ( int i = 0 ; i < BIG_DELTA_SIZE ; i ++ ) { sb . append ( '7' ) ; } TestDelta delta1 = new TestDelta ( true , sb . toString ( ) ) ; assignPRBuckets ( vm0 ) ; boolean vm0isPrimary = prHostsBucketForKey ( vm0 , 0 ) ; if ( ! vm0isPrimary ) { assertEquals ( true , prHostsBucketForKey ( vm1 , 0 ) ) ; } VM primaryVm ; VM secondaryVm ; if ( vm0isPrimary ) { primaryVm = vm0 ; secondaryVm = vm1 ; } else { primaryVm = vm1 ; secondaryVm = vm0 ; } put ( secondaryVm , 0 , delta1 ) ; }
smanvi-pivotal/geode | void doPRDeltaTestLRU ( boolean shouldSizeChange , boolean heapLRU , boolean putOnPrimary , boolean wasDelta ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; if ( heapLRU ) { createPRHeapLRU ( vm0 ) ; createPRHeapLRU ( vm1 ) ; } else { createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; } assignPRBuckets ( vm0 ) ; boolean vm0isPrimary = prHostsBucketForKey ( vm0 , 0 ) ; if ( ! vm0isPrimary ) { assertEquals ( true , prHostsBucketForKey ( vm1 , 0 ) ) ; } VM primaryVm ; VM secondaryVm ; if ( vm0isPrimary ) { primaryVm = vm0 ; secondaryVm = vm1 ; } else { primaryVm = vm1 ; secondaryVm = vm0 ; } TestDelta delta1 = new TestDelta ( false , "12345" ) ; if ( putOnPrimary ) { put ( primaryVm , 0 , delta1 ) ; } else { put ( secondaryVm , 0 , delta1 ) ; } if ( putOnPrimary ) { assertValueType ( primaryVm , 0 , ValueType . CD_DESERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( primaryVm ) ) ; } else { assertValueType ( primaryVm , 0 , ValueType . CD_SERIALIZED ) ; assertEquals ( 0 , getObjectSizerInvocations ( primaryVm ) ) ; } assertValueType ( secondaryVm , 0 , ValueType . CD_SERIALIZED ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( primaryVm ) ; long origEvictionSize1 = getSizeFromEvictionStats ( secondaryVm ) ; long origPRSize0 = getSizeFromPRStats ( primaryVm ) ; long origPRSize1 = getSizeFromPRStats ( secondaryVm ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; if ( putOnPrimary ) { put ( primaryVm , 0 , delta1 ) ; } else { put ( secondaryVm , 0 , delta1 ) ; } assertValueType ( primaryVm , 0 , ValueType . CD_DESERIALIZED ) ; assertValueType ( secondaryVm , 0 , ValueType . CD_DESERIALIZED ) ; if ( shouldSizeChange ) { assertEquals ( 2 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( secondaryVm ) ) ; } else if ( wasDelta ) { assertEquals ( 0 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; } else { assertEquals ( 1 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; } long finalEvictionSize0 = getSizeFromEvictionStats ( primaryVm ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( secondaryVm ) ; long finalPRSize0 = getSizeFromPRStats ( primaryVm ) ; long finalPRSize1 = getSizeFromPRStats ( secondaryVm ) ; if ( shouldSizeChange ) { assertTrue ( finalEvictionSize0 - origEvictionSize0 != 0 ) ; assertTrue ( finalPRSize0 - origPRSize0 != 0 ) ; assertTrue ( finalEvictionSize1 - origEvictionSize1 != 0 ) ; assertTrue ( finalPRSize1 - origPRSize1 != 0 ) ; } else { assertEquals ( 0 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 0 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 0 , finalPRSize1 - origPRSize1 ) ; } }
smanvi-pivotal/geode | private void addListener ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Add ▁ listener " ) { public void run ( ) { Cache cache = getCache ( ) ; Region region = cache . getRegion ( " region " ) ; try { region . getAttributesMutator ( ) . addCacheListener ( new TestCacheListener ( ) ) ; } catch ( Exception e ) { Assert . fail ( " couldn ' t ▁ create ▁ index " , e ) ; } } } ) ; }
smanvi-pivotal/geode | private void doListenerTestRR ( VM vm0 , VM vm1 ) { assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertTrue ( origEvictionSize0 >= 100000 ) ; assertTrue ( origEvictionSize1 >= 100000 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm1 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100000 , finalEvictionSize1 - origEvictionSize1 ) ; }
smanvi-pivotal/geode | private void doListenerTestPR ( VM vm0 , VM vm1 ) { assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long origPRSize0 = getSizeFromPRStats ( vm1 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertTrue ( origEvictionSize1 >= 100000 ) ; assertTrue ( origEvictionSize0 >= 100000 ) ; assertTrue ( origPRSize0 <= 500 ) ; assertTrue ( origPRSize1 <= 500 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm1 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100000 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 100 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 100 , finalPRSize1 - origPRSize1 ) ; }
smanvi-pivotal/geode | private void doRRMemLRUTest ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; Object v = new TestObject ( 200 , 200000 ) ; get ( vm1 , " a " , v ) ; int vSize = CachedDeserializableFactory . calcSerializedMemSize ( v ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; long evictionSizeAfterGet = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 200000 + CachedDeserializableFactory . overhead ( ) - vSize , evictionSizeAfterGet - finalEvictionSize1 ) ; put ( vm0 , " b " , new TestObject ( 100 , 1000000 ) ) ; assertEquals ( 1 , getEvictions ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm1 ) ) ; get ( vm1 , " b " , new TestObject ( 100 , 1000000 ) ) ; assertEquals ( 1 , getEvictions ( vm1 ) ) ; }
smanvi-pivotal/geode | private void doPRMemLRUTest ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; put ( vm0 , 0 , new TestObject ( 100 , 100000 ) ) ; assertValueType ( vm0 , 0 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 0 , ValueType . CD_SERIALIZED ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long origPRSize0 = getSizeFromPRStats ( vm0 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; put ( vm0 , 0 , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; assertEquals ( 100 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 100 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 100 , finalPRSize1 - origPRSize1 ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; Object v = new TestObject ( 200 , 200000 ) ; get ( vm0 , 0 , v ) ; int vSize = CachedDeserializableFactory . calcSerializedMemSize ( v ) ; assertValueType ( vm0 , 0 , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , 0 , ValueType . CD_SERIALIZED ) ; long evictionSizeAfterGet = getSizeFromEvictionStats ( vm0 ) ; long prSizeAfterGet = getSizeFromPRStats ( vm0 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 200000 + CachedDeserializableFactory . overhead ( ) - vSize , evictionSizeAfterGet - finalEvictionSize0 ) ; assertEquals ( 0 , prSizeAfterGet - finalPRSize0 ) ; put ( vm0 , 113 , new TestObject ( 100 , 1024 * 1024 ) ) ; assertValueType ( vm0 , 113 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 113 , ValueType . CD_SERIALIZED ) ; long evictionSizeAfterPutVm1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 0 , getEvictions ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm1 ) ) ; get ( vm1 , 113 , new TestObject ( 100 , 1024 * 1024 ) ) ; long evictionSizeAfterGetVm1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , 113 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 113 , ValueType . EVICTED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 2 , getEvictions ( vm1 ) ) ; }
smanvi-pivotal/geode | private void doRRMemLRUDeltaTest ( boolean shouldSizeChange ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; TestDelta delta1 = new TestDelta ( false , "12345" ) ; put ( vm0 , " a " , delta1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; put ( vm0 , " a " , delta1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 5 , finalEvictionSize0 - origEvictionSize0 ) ; if ( shouldSizeChange ) { assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertTrue ( finalEvictionSize1 - origEvictionSize1 != 0 ) ; } else { assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 0 , finalEvictionSize1 - origEvictionSize1 ) ; } }
smanvi-pivotal/geode | private void doPRNoLRUDeltaTest ( boolean shouldSizeChange ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; createPR ( vm0 , false ) ; createPR ( vm1 , false ) ; TestDelta delta1 = new TestDelta ( false , "12345" ) ; put ( vm0 , " a " , delta1 ) ; long origPRSize0 = getSizeFromPRStats ( vm0 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; put ( vm0 , " a " , delta1 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; if ( shouldSizeChange ) { assertTrue ( finalPRSize0 - origPRSize0 != 0 ) ; assertTrue ( finalPRSize1 - origPRSize1 != 0 ) ; } else { assertEquals ( 0 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 0 , finalPRSize1 - origPRSize1 ) ; } }
smanvi-pivotal/geode | private long getSizeFromPRStats ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; if ( region instanceof PartitionedRegion ) { long total = 0 ; PartitionedRegion pr = ( ( PartitionedRegion ) region ) ; for ( int i = 0 ; i < pr . getPartitionAttributes ( ) . getTotalNumBuckets ( ) ; i ++ ) { total += pr . getDataStore ( ) . getBucketSize ( i ) ; } return total ; } else { return 0L ; } } } ) ; }
smanvi-pivotal/geode | private long getSizeFromEvictionStats ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getSizeFromEvictionStats ( region ) ; } } ) ; }
smanvi-pivotal/geode | private long getEvictions ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getEvictions ( region ) ; } } ) ; }
smanvi-pivotal/geode | private int getObjectSizerInvocations ( VM vm0 ) { return ( Integer ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getObjectSizerInvocations ( region ) ; } } ) ; }
smanvi-pivotal/geode | private void assignPRBuckets ( VM vm ) { vm . invoke ( new SerializableRunnable ( " assignPRBuckets " ) { public void run ( ) { Cache cache = getCache ( ) ; PartitionRegionHelper . assignBucketsToPartitions ( cache . getRegion ( " region " ) ) ; } } ) ; }
smanvi-pivotal/geode | private boolean prHostsBucketForKey ( VM vm , final Object key ) { Boolean result = ( Boolean ) vm . invoke ( new SerializableCallable ( " prHostsBucketForKey " ) { public Object call ( ) { Cache cache = getCache ( ) ; DistributedMember myId = cache . getDistributedSystem ( ) . getDistributedMember ( ) ; Region region = cache . getRegion ( " region " ) ; DistributedMember hostMember = PartitionRegionHelper . getPrimaryMemberForKey ( region , key ) ; if ( hostMember == null ) { throw new IllegalStateException ( " bucket ▁ for ▁ key ▁ " + key + " ▁ is ▁ not ▁ hosted ! " ) ; } boolean res = Boolean . valueOf ( myId . equals ( hostMember ) ) ; return res ; } } ) ; return result . booleanValue ( ) ; }
smanvi-pivotal/geode | private void put ( VM vm0 , final Object key , final Object value ) { vm0 . invoke ( new SerializableRunnable ( " Put ▁ data " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; region . put ( key , value ) ; } } ) ; }
smanvi-pivotal/geode | private void get ( VM vm0 , final Object key , final Object value ) { vm0 . invoke ( new SerializableRunnable ( " Put ▁ data " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; assertEquals ( value , region . get ( key ) ) ; } } ) ; }
smanvi-pivotal/geode | protected int getObjectSizerInvocations ( LocalRegion region ) { TestObjectSizer sizer = ( TestObjectSizer ) region . getEvictionAttributes ( ) . getObjectSizer ( ) ; int result = sizer . invocations . get ( ) ; region . getCache ( ) . getLogger ( ) . info ( " objectSizerInvocations = " + result ) ; return result ; }
smanvi-pivotal/geode | private long getSizeFromEvictionStats ( LocalRegion region ) { long result = region . getEvictionCounter ( ) ; return result ; }
smanvi-pivotal/geode | private long getEvictions ( LocalRegion region ) { return region . getTotalEvictions ( ) ; }
smanvi-pivotal/geode | private void setDeltaRecalculatesSize ( VM vm , final boolean shouldSizeChange ) { vm . invoke ( new SerializableRunnable ( " setDeltaRecalculatesSize " ) { public void run ( ) { GemFireCacheImpl . DELTAS_RECALCULATE_SIZE = shouldSizeChange ; } } ) ; }
smanvi-pivotal/geode | private void createRR ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setDiskSynchronous ( true ) ; attr . setDataPolicy ( DataPolicy . REPLICATE ) ; attr . setScope ( Scope . DISTRIBUTED_ACK ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUMemoryAttributes ( 1 , new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; Region region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | private void assertValueType ( VM vm , final Object key , final ValueType expectedType ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; Object value = region . getValueInVM ( key ) ; switch ( expectedType ) { case RAW_VALUE : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , ! ( value instanceof CachedDeserializable ) ) ; break ; case CD_SERIALIZED : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , value instanceof CachedDeserializable ) ; assertTrue ( " Value ▁ not ▁ serialized " , ( ( CachedDeserializable ) value ) . getValue ( ) instanceof byte [ ] ) ; break ; case CD_DESERIALIZED : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , value instanceof CachedDeserializable ) ; assertTrue ( " Value ▁ was ▁ serialized " , ! ( ( ( CachedDeserializable ) value ) . getValue ( ) instanceof byte [ ] ) ) ; break ; case EVICTED : assertEquals ( null , value ) ; break ; } } } ) ; }
smanvi-pivotal/geode | private File [ ] getMyDiskDirs ( ) { long random = new Random ( ) . nextLong ( ) ; File file = new File ( Long . toString ( random ) ) ; file . mkdirs ( ) ; return new File [ ] { file } ; }
smanvi-pivotal/geode | private void createPR ( VM vm , final boolean enableLRU ) { vm . invoke ( new SerializableRunnable ( " Create ▁ pr " ) { public void run ( ) { Cache cache = getCache ( ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setDiskSynchronous ( true ) ; PartitionAttributesFactory < Integer , TestDelta > paf = new PartitionAttributesFactory < Integer , TestDelta > ( ) ; paf . setRedundantCopies ( 1 ) ; if ( enableLRU ) { paf . setLocalMaxMemory ( 1 ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUMemoryAttributes ( new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; } PartitionAttributes < Integer , TestDelta > prAttr = paf . create ( ) ; attr . setPartitionAttributes ( prAttr ) ; attr . setDataPolicy ( DataPolicy . PARTITION ) ; attr . setSubscriptionAttributes ( new SubscriptionAttributes ( InterestPolicy . ALL ) ) ; Region < Integer , TestDelta > region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | private void createRRHeapLRU ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; ResourceManager manager = cache . getResourceManager ( ) ; manager . setCriticalHeapPercentage ( 95 ) ; manager . setEvictionHeapPercentage ( 90 ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUHeapAttributes ( new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; attr . setDataPolicy ( DataPolicy . REPLICATE ) ; attr . setScope ( Scope . DISTRIBUTED_ACK ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; Region region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | private void createPRHeapLRU ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ pr " ) { public void run ( ) { Cache cache = getCache ( ) ; ResourceManager manager = cache . getResourceManager ( ) ; manager . setCriticalHeapPercentage ( 95 ) ; manager . setEvictionHeapPercentage ( 90 ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; PartitionAttributesFactory < Integer , TestDelta > paf = new PartitionAttributesFactory < Integer , TestDelta > ( ) ; paf . setRedundantCopies ( 1 ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUHeapAttributes ( new TestObjectSizer ( ) , EvictionAction . LOCAL_DESTROY ) ) ; PartitionAttributes < Integer , TestDelta > prAttr = paf . create ( ) ; attr . setPartitionAttributes ( prAttr ) ; attr . setDataPolicy ( DataPolicy . PARTITION ) ; attr . setSubscriptionAttributes ( new SubscriptionAttributes ( InterestPolicy . ALL ) ) ; Region < Integer , TestDelta > region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | public int sizeof ( Object o ) { if ( InternalDistributedSystem . getLoggerI18n ( ) . fineEnabled ( ) ) { InternalDistributedSystem . getLoggerI18n ( ) . fine ( " TestObjectSizer ▁ invoked " ) ; } if ( o instanceof TestObject ) { invocations . incrementAndGet ( ) ; return ( ( TestObject ) o ) . sizeForSizer ; } if ( o instanceof TestDelta ) { invocations . incrementAndGet ( ) ; return ( ( TestDelta ) o ) . info . length ( ) ; } if ( o instanceof Integer ) { return 0 ; } if ( o instanceof TestKey ) { invocations . incrementAndGet ( ) ; return ( ( TestKey ) o ) . value . length ( ) ; } throw new RuntimeException ( " Unpected ▁ type ▁ to ▁ be ▁ sized ▁ " + o . getClass ( ) + " , ▁ object = " + o ) ; }
smanvi-pivotal/geode | public TestKey ( ) { }
smanvi-pivotal/geode | public TestKey ( String value ) { this . value = value ; }
smanvi-pivotal/geode | public void toData ( DataOutput out ) throws IOException { DataSerializer . writeString ( value , out ) ; }
smanvi-pivotal/geode | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value == null ) ? 0 : value . hashCode ( ) ) ; return result ; }
smanvi-pivotal/geode | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof TestKey ) ) return false ; TestKey other = ( TestKey ) obj ; if ( value == null ) { if ( other . value != null ) return false ; } else if ( ! value . equals ( other . value ) ) return false ; return true ; }
smanvi-pivotal/geode | public TestObject ( ) { }
smanvi-pivotal/geode | public TestObject ( int sizeForSerialization , int sizeForSizer ) { super ( ) ; this . sizeForSizer = sizeForSizer ; this . sizeForSerialization = sizeForSerialization ; }
smanvi-pivotal/geode | public void toData ( DataOutput out ) throws IOException { out . writeInt ( sizeForSizer ) ; out . writeInt ( sizeForSerialization ) ; out . write ( new byte [ sizeForSerialization ] ) ; }
smanvi-pivotal/geode | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + sizeForSerialization ; result = prime * result + sizeForSizer ; return result ; }
smanvi-pivotal/geode | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof TestObject ) ) return false ; TestObject other = ( TestObject ) obj ; if ( sizeForSerialization != other . sizeForSerialization ) return false ; if ( sizeForSizer != other . sizeForSizer ) return false ; return true ; }
smanvi-pivotal/geode | @ Override public String toString ( ) { return " TestObject ▁ [ sizeForSerialization = " + sizeForSerialization + " , ▁ sizeForSizer = " + sizeForSizer + " ] " ; }
smanvi-pivotal/geode | @ Override public void afterCreate ( EntryEvent event ) { event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . fine ( " invoked ▁ afterCreate ▁ with ▁ " + event ) ; event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . info ( LocalizedStrings . DEBUG , " value ▁ is ▁ " + event . getNewValue ( ) ) ; }
smanvi-pivotal/geode | @ Override public void afterUpdate ( EntryEvent event ) { event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . fine ( " invoked ▁ afterUpdate ▁ with ▁ " ) ; event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . info ( LocalizedStrings . DEBUG , " value ▁ is ▁ " + event . getNewValue ( ) ) ; }
DDTH/ddth-queue | public TestInmemQueueBoundSmallEphemeralDisabled ( String testName ) { super ( testName ) ; }
DDTH/ddth-queue | @ Override protected IQueue < String , byte [ ] > initQueueInstance ( ) throws Exception { if ( System . getProperty ( " skipTestsInmem " ) != null ) { return null ; } int size = 128 ; InmemQueue < String , byte [ ] > queue = new UniversalInmemQueue ( ) ; queue . setBoundary ( size ) . setEphemeralDisabled ( true ) . init ( ) ; return queue ; }
IBM-Bluemix/BluemixBoutique | public ItemListResource ( ) { InitialContext ic ; try { ic = new InitialContext ( ) ; userTran = ( UserTransaction ) ic . lookup ( " java : comp / UserTransaction " ) ; } catch ( NamingException e ) { System . err . println ( " ERROR ▁ obtaining ▁ UserTransaction " ) ; } }
IBM-Bluemix/BluemixBoutique | @ POST public Response create ( @ FormParam ( " name " ) String name , @ FormParam ( " imgsrc " ) String imgsrc , @ FormParam ( " itemNumber " ) String itemNumber , @ FormParam ( " description " ) String description , @ FormParam ( " price " ) String price ) { ITEM item = new ITEM ( ) ; item . setName ( name ) ; item . setImgSrc ( imgsrc ) ; item . setItemNumber ( itemNumber ) ; item . setDescription ( description ) ; item . setPrice ( price ) ; EntityManager em = getEm ( ) ; try { userTran . begin ( ) ; em . persist ( item ) ; userTran . commit ( ) ; return Response . ok ( item . toString ( ) ) . build ( ) ; } catch ( Exception e ) { System . err . println ( " ERROR ▁ creating ▁ record " ) ; return Response . status ( Status . INTERNAL_SERVER_ERROR ) . build ( ) ; } }
IBM-Bluemix/BluemixBoutique | @ DELETE public Response delete ( @ QueryParam ( " id " ) long id ) { EntityManager em = getEm ( ) ; try { userTran . begin ( ) ; ITEM item = em . find ( ITEM . class , id ) ; if ( item != null ) { em . remove ( item ) ; userTran . commit ( ) ; } else { return Response . status ( Status . NOT_FOUND ) . build ( ) ; } } catch ( Exception e ) { System . err . println ( " ERROR ▁ deleting ▁ record " ) ; return Response . status ( Status . INTERNAL_SERVER_ERROR ) . build ( ) ; } return Response . ok ( ) . build ( ) ; }
IBM-Bluemix/BluemixBoutique | @ PUT public Response update ( @ FormParam ( " id " ) long id , @ FormParam ( " name " ) String name , @ FormParam ( " age " ) int age ) { EntityManager em = getEm ( ) ; ITEM item = em . find ( ITEM . class , id ) ; if ( item != null ) { item . setName ( name ) ; try { userTran . begin ( ) ; em . refresh ( item ) ; userTran . commit ( ) ; } catch ( Exception e ) { System . err . println ( " ERROR ▁ updating ▁ record " ) ; } finally { em . close ( ) ; } return Response . ok ( ) . build ( ) ; } else return Response . status ( Status . NOT_FOUND ) . build ( ) ; }
IBM-Bluemix/BluemixBoutique | @ GET @ Produces ( MediaType . APPLICATION_JSON ) public Response get ( @ QueryParam ( " id " ) long id ) throws Exception { EntityManager em = getEm ( ) ; if ( id == 0 ) { List < ITEM > list = em . createQuery ( " SELECT ▁ t ▁ FROM ▁ ITEM ▁ t " , ITEM . class ) . getResultList ( ) ; String json = " { \" id \" : \" all \" , ▁ \" body \" : " + list . toString ( ) + " } " ; return Response . ok ( json ) . build ( ) ; } ITEM item = null ; try { userTran . begin ( ) ; item = em . find ( ITEM . class , id ) ; userTran . commit ( ) ; } catch ( Exception e ) { em . close ( ) ; } if ( item != null ) return Response . ok ( item . toString ( ) ) . build ( ) ; else return Response . status ( Status . NOT_FOUND ) . build ( ) ; }
redkale/redkale-plugins | @ Override public boolean acceptsConf ( AnyValue config ) { return " search " . equalsIgnoreCase ( config . getValue ( " dbtype " ) ) ; }
redkale/redkale-plugins | @ Override public Class < ? extends DataSource > sourceClass ( ) { return OpenSearchSource . class ; }
xuegongzi/rabbitframework | @ Override public boolean configure ( final FeatureContext context ) { final Configuration config = context . getConfiguration ( ) ; if ( ! config . isRegistered ( FreemarkerViewProcessor . class ) ) { context . register ( FreemarkerViewProcessor . class ) ; if ( ! config . isRegistered ( MvcFeature . class ) ) { context . register ( MvcFeature . class ) ; } return true ; } return false ; }
StreamReduce/streamreduce-core | @ Override public MessageDetailsType getMessageDetailsType ( ) { return MessageDetailsType . NODEBELLY ; }
StreamReduce/streamreduce-core | public Builder ( ) { theObject = new NodebellyMessageDetails ( ) ; }
StreamReduce/streamreduce-core | public Builder title ( String title ) { theObject . title = title . trim ( ) ; return this ; }
StreamReduce/streamreduce-core | public Builder details ( String details ) { theObject . details = details . trim ( ) ; return this ; }
StreamReduce/streamreduce-core | public Builder structure ( Map < String , Object > structure ) { theObject . structure = structure ; return this ; }
StreamReduce/streamreduce-core | public NodebellyMessageDetails build ( ) { return theObject ; }
StreamReduce/streamreduce-core | public String getDetails ( ) { return details ; }
ibauersachs/jitsi | public NotificationGroup ( String groupName ) { this . groupName = groupName ; }
ibauersachs/jitsi | @ Override public Object getDescriptor ( ) { return groupName ; }
ibauersachs/jitsi | @ Override public String getDisplayName ( ) { return groupName ; }
ibauersachs/jitsi | @ Override public int getSourceIndex ( ) { return 0 ; }
ibauersachs/jitsi | @ Override public UIGroup getParentGroup ( ) { return null ; }
ibauersachs/jitsi | @ Override public boolean isGroupCollapsed ( ) { return false ; }
ibauersachs/jitsi | @ Override public int countOnlineChildContacts ( ) { return contacts . size ( ) ; }
ibauersachs/jitsi | @ Override public int countChildContacts ( ) { return contacts . size ( ) ; }
ibauersachs/jitsi | @ Override public String getId ( ) { return null ; }
ibauersachs/jitsi | @ Override public GroupNode getGroupNode ( ) { return groupNode ; }
ibauersachs/jitsi | @ Override public void setGroupNode ( GroupNode groupNode ) { this . groupNode = groupNode ; }
ibauersachs/jitsi | @ Override public JPopupMenu getRightButtonMenu ( ) { return null ; }
ibauersachs/jitsi | public Iterator < ? extends UIContact > getNotifications ( ) { return contacts . values ( ) . iterator ( ) ; }
ibauersachs/jitsi | public void messageWaitingNotify ( MessageWaitingEvent event ) { Iterator < NotificationMessage > messages = event . getMessages ( ) ; if ( messages != null ) { Enumeration < String > contactIdentifiers = contacts . keys ( ) ; while ( contactIdentifiers . hasMoreElements ( ) ) { String identifier = contactIdentifiers . nextElement ( ) ; boolean toRemove = true ; messages = event . getMessages ( ) ; while ( messages . hasNext ( ) ) { NotificationMessage message = messages . next ( ) ; String messageIdentifier = message . getFromContact ( ) + message . getMessageDetails ( ) ; if ( identifier . equals ( messageIdentifier ) ) { toRemove = false ; break ; } } if ( toRemove ) { removeNotificationContact ( contacts . get ( identifier ) ) ; contacts . remove ( identifier ) ; } } messages = event . getMessages ( ) ; while ( messages . hasNext ( ) ) { NotificationMessage message = messages . next ( ) ; if ( message . getMessageGroup ( ) . equals ( groupName ) ) { String messageIdentifier = message . getFromContact ( ) + message . getMessageDetails ( ) ; NotificationContact contact = contacts . get ( messageIdentifier ) ; boolean isNew = false ; if ( contact == null ) { contact = new NotificationContact ( this , event . getSourceProvider ( ) , event . getMessageType ( ) , message ) ; contacts . put ( messageIdentifier , contact ) ; isNew = true ; } contact . setMessageAccount ( event . getAccount ( ) ) ; addNotificationContact ( contact , isNew ) ; } } } else { ProtocolProviderService protocolProvider = event . getSourceProvider ( ) ; NotificationContact contact = contacts . get ( protocolProvider . toString ( ) ) ; boolean isNew = false ; if ( contact == null ) { contact = new NotificationContact ( this , protocolProvider , event . getMessageType ( ) , null ) ; contacts . put ( protocolProvider . toString ( ) , contact ) ; isNew = true ; } contact . setMessageAccount ( event . getAccount ( ) ) ; contact . setUnreadUrgentMessageCount ( event . getUnreadUrgentMessages ( ) ) ; contact . setUnreadMessageCount ( event . getUnreadMessages ( ) ) ; contact . setReadMessageCount ( event . getReadMessages ( ) ) ; addNotificationContact ( contact , isNew ) ; } }
ibauersachs/jitsi | private void addNotificationContact ( NotificationContact contact , boolean isNew ) { TreeContactList contactList = GuiActivator . getContactList ( ) ; if ( contactList . getCurrentFilter ( ) . isMatching ( contact ) ) { if ( isNew ) contactList . addContact ( contact , this , true , true ) ; else contactList . refreshContact ( contact ) ; } if ( contact . getUnreadMessageCount ( ) > 0 ) { if ( uiNotificationGroup == null ) uiNotificationGroup = new UINotificationGroup ( getDisplayName ( ) , GuiActivator . getResources ( ) . getI18NString ( " service . gui . VOICEMAIL _ TOOLTIP " ) ) ; UINotificationManager . addNotification ( new UINotification ( contact . getDisplayName ( ) , contact . getDisplayName ( ) + " ▁ : ▁ " + contact . getDisplayDetails ( ) , System . currentTimeMillis ( ) , uiNotificationGroup , contact . getUnreadMessageCount ( ) ) ) ; } }
ibauersachs/jitsi | private void removeNotificationContact ( NotificationContact contact ) { TreeContactList contactList = GuiActivator . getContactList ( ) ; if ( contactList . getCurrentFilter ( ) . isMatching ( contact ) ) { contactList . removeContact ( contact ) ; } }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public DbCalendarReminderSensor ( ) { }
Telecooperation/assistance-platform-client-sdk-android | public DbCalendarReminderSensor ( Long id ) { this . id = id ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public DbCalendarReminderSensor ( Long id , long reminderId , Long eventId , Integer method , Integer minutes , Boolean isNew , Boolean isUpdated , Boolean isDeleted , String created , Long deviceId ) { this . id = id ; this . reminderId = reminderId ; this . eventId = eventId ; this . method = method ; this . minutes = minutes ; this . isNew = isNew ; this . isUpdated = isUpdated ; this . isDeleted = isDeleted ; this . created = created ; this . deviceId = deviceId ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void __setDaoSession ( DaoSession daoSession ) { this . daoSession = daoSession ; myDao = daoSession != null ? daoSession . getDbCalendarReminderSensorDao ( ) : null ; }
Telecooperation/assistance-platform-client-sdk-android | public Long getId ( ) { return id ; }
Telecooperation/assistance-platform-client-sdk-android | public void setId ( Long id ) { this . id = id ; }
Telecooperation/assistance-platform-client-sdk-android | public long getReminderId ( ) { return reminderId ; }
Telecooperation/assistance-platform-client-sdk-android | public void setReminderId ( long reminderId ) { this . reminderId = reminderId ; }
Telecooperation/assistance-platform-client-sdk-android | public Long getEventId ( ) { return eventId ; }
Telecooperation/assistance-platform-client-sdk-android | public void setEventId ( Long eventId ) { this . eventId = eventId ; }
Telecooperation/assistance-platform-client-sdk-android | public Integer getMethod ( ) { return method ; }
Telecooperation/assistance-platform-client-sdk-android | public void setMethod ( Integer method ) { this . method = method ; }
Telecooperation/assistance-platform-client-sdk-android | public Integer getMinutes ( ) { return minutes ; }
Telecooperation/assistance-platform-client-sdk-android | public void setMinutes ( Integer minutes ) { this . minutes = minutes ; }
Telecooperation/assistance-platform-client-sdk-android | public Boolean getIsNew ( ) { return isNew ; }
Telecooperation/assistance-platform-client-sdk-android | public void setIsNew ( Boolean isNew ) { this . isNew = isNew ; }
Telecooperation/assistance-platform-client-sdk-android | public Boolean getIsUpdated ( ) { return isUpdated ; }
Telecooperation/assistance-platform-client-sdk-android | public void setIsUpdated ( Boolean isUpdated ) { this . isUpdated = isUpdated ; }
Telecooperation/assistance-platform-client-sdk-android | public Boolean getIsDeleted ( ) { return isDeleted ; }
Telecooperation/assistance-platform-client-sdk-android | public void setIsDeleted ( Boolean isDeleted ) { this . isDeleted = isDeleted ; }
Telecooperation/assistance-platform-client-sdk-android | @ NotNull public String getCreated ( ) { return created ; }
Telecooperation/assistance-platform-client-sdk-android | public void setCreated ( @ NotNull String created ) { this . created = created ; }
Telecooperation/assistance-platform-client-sdk-android | public Long getDeviceId ( ) { return deviceId ; }
Telecooperation/assistance-platform-client-sdk-android | public void setDeviceId ( Long deviceId ) { this . deviceId = deviceId ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public DbDevice getDbDevice ( ) { Long __key = this . deviceId ; if ( dbDevice__resolvedKey == null || ! dbDevice__resolvedKey . equals ( __key ) ) { __throwIfDetached ( ) ; DbDeviceDao targetDao = daoSession . getDbDeviceDao ( ) ; DbDevice dbDeviceNew = targetDao . load ( __key ) ; synchronized ( this ) { dbDevice = dbDeviceNew ; dbDevice__resolvedKey = __key ; } } return dbDevice ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void setDbDevice ( DbDevice dbDevice ) { synchronized ( this ) { this . dbDevice = dbDevice ; deviceId = dbDevice == null ? null : dbDevice . getId ( ) ; dbDevice__resolvedKey = deviceId ; } }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void delete ( ) { __throwIfDetached ( ) ; myDao . delete ( this ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void update ( ) { __throwIfDetached ( ) ; myDao . update ( this ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void refresh ( ) { __throwIfDetached ( ) ; myDao . refresh ( this ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated private void __throwIfDetached ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } }
ogregoire/imgn | @ BeforeEach protected void setUp ( ) { sink = new TestByteSink ( ) ; }
ogregoire/imgn | @ Test public void testOpenBufferedStream ( ) throws IOException { OutputStream out = sink . openBufferedStream ( ) ; assertThat ( sink . wasStreamOpened ( ) ) . isTrue ( ) ; assertThat ( sink . wasStreamClosed ( ) ) . isFalse ( ) ; out . write ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; out . close ( ) ; assertThat ( sink . wasStreamClosed ( ) ) . isTrue ( ) ; assertThat ( sink . getBytes ( ) ) . isEqualTo ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; }
ogregoire/imgn | @ Test public void testWrite_bytes ( ) { assertThat ( sink . getBytes ( ) ) . isEqualTo ( new byte [ 0 ] ) ; sink . write ( bytes ) ; assertThat ( sink . wasStreamOpened ( ) && sink . wasStreamClosed ( ) ) . isTrue ( ) ; assertThat ( sink . getBytes ( ) ) . isEqualTo ( bytes ) ; }
ogregoire/imgn | @ Test public void testWriteFrom_inputStream ( ) throws IOException { ByteArrayInputStream in = new ByteArrayInputStream ( bytes ) ; sink . writeFrom ( in ) ; assertThat ( sink . wasStreamOpened ( ) && sink . wasStreamClosed ( ) ) . isTrue ( ) ; assertThat ( sink . getBytes ( ) ) . isEqualTo ( bytes ) ; }
ogregoire/imgn | @ Test public void testWriteFromStream_doesNotCloseThatStream ( ) throws IOException { TestInputStream in = new TestInputStream ( new ByteArrayInputStream ( new byte [ 10 ] ) ) ; assertThat ( in . closed ( ) ) . isFalse ( ) ; sink . writeFrom ( in ) ; assertThat ( in . closed ( ) ) . isFalse ( ) ; }
ogregoire/imgn | @ Test public void testClosesOnErrors_copyingFromByteSourceThatThrows ( ) { for ( TestOption option : EnumSet . of ( OPEN_THROWS , READ_THROWS , CLOSE_THROWS ) ) { TestByteSource failSource = new TestByteSource ( new byte [ 10 ] , option ) ; TestByteSink okSink = new TestByteSink ( ) ; assertThatThrownBy ( ( ) -> { failSource . copyTo ( okSink ) ; } ) . isInstanceOf ( UncheckedIOException . class ) ; assertThat ( ! okSink . wasStreamOpened ( ) || okSink . wasStreamClosed ( ) ) . isTrue ( ) ; } }
ogregoire/imgn | @ Test public void testClosesOnErrors_whenWriteThrows ( ) { TestByteSink failSink = new TestByteSink ( WRITE_THROWS ) ; assertThatThrownBy ( ( ) -> { new TestByteSource ( new byte [ 10 ] ) . copyTo ( failSink ) ; } ) . isInstanceOf ( UncheckedIOException . class ) ; assertThat ( failSink . wasStreamClosed ( ) ) . isTrue ( ) ; }
ogregoire/imgn | @ Test public void testClosesOnErrors_writingFromInputStreamThatThrows ( ) { TestByteSink okSink = new TestByteSink ( ) ; assertThatThrownBy ( ( ) -> { TestInputStream in = new TestInputStream ( new ByteArrayInputStream ( new byte [ 10 ] ) , READ_THROWS ) ; okSink . writeFrom ( in ) ; } ) . isInstanceOf ( UncheckedIOException . class ) ; assertThat ( okSink . wasStreamClosed ( ) ) . isTrue ( ) ; }
BryceARich/TransactionsMR | @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; helper . setUp ( ) ; servlet = new MapReduceServlet ( ) ; }
BryceARich/TransactionsMR | @ Override public void tearDown ( ) throws Exception { helper . tearDown ( ) ; super . tearDown ( ) ; }
BryceARich/TransactionsMR | public void testBailsOnBadHandler ( ) throws Exception { HttpServletRequest request = createMockRequest ( " fizzle " , true , true ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; replay ( request , response ) ; try { servlet . doPost ( request , response ) ; fail ( " Should ▁ have ▁ thrown ▁ RuntimeException " ) ; } catch ( RuntimeException e ) { } verify ( request , response ) ; }
BryceARich/TransactionsMR | public void testCommandError ( ) throws Exception { HttpServletRequest request = createMockRequest ( MapReduceServletImpl . COMMAND_PATH + " / " + StatusHandler . GET_JOB_DETAIL_PATH , false , true ) ; expect ( request . getMethod ( ) ) . andReturn ( " GET " ) . anyTimes ( ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; PrintWriter responseWriter = createMock ( PrintWriter . class ) ; responseWriter . write ( ' { ' ) ; responseWriter . write ( " \" error _ class \" " ) ; responseWriter . write ( ' : ' ) ; responseWriter . write ( " \" java . lang . RuntimeException \" " ) ; responseWriter . write ( ' , ' ) ; responseWriter . write ( " \" error _ message \" " ) ; responseWriter . write ( ' : ' ) ; responseWriter . write ( " \" Full ▁ stack ▁ trace ▁ is ▁ available ▁ in ▁ the ▁ server ▁ logs . ▁ " + " Message : ▁ blargh \" " ) ; responseWriter . write ( ' } ' ) ; responseWriter . flush ( ) ; expect ( request . getParameter ( " mapreduce _ id " ) ) . andThrow ( new RuntimeException ( " blargh " ) ) ; response . setContentType ( " application / json " ) ; expect ( response . getWriter ( ) ) . andReturn ( responseWriter ) . anyTimes ( ) ; replay ( request , response , responseWriter ) ; servlet . doPost ( request , response ) ; verify ( request , response , responseWriter ) ; }
BryceARich/TransactionsMR | public void testControllerCSRF ( ) throws Exception { HttpServletRequest request = createMockRequest ( CONTROLLER_PATH , false , true ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; response . sendError ( 403 , " Received ▁ unexpected ▁ non - task ▁ queue ▁ request . " ) ; replay ( request , response ) ; servlet . doPost ( request , response ) ; verify ( request , response ) ; }
BryceARich/TransactionsMR | public void testGetJobDetailCSRF ( ) throws Exception { HttpServletRequest request = createMockRequest ( MapReduceServletImpl . COMMAND_PATH + " / " + StatusHandler . GET_JOB_DETAIL_PATH , true , false ) ; expect ( request . getMethod ( ) ) . andReturn ( " POST " ) . anyTimes ( ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; response . setContentType ( " application / json " ) ; EasyMock . expectLastCall ( ) . anyTimes ( ) ; response . sendError ( 403 , " Received ▁ unexpected ▁ non - XMLHttpRequest ▁ command . " ) ; replay ( request , response ) ; servlet . doGet ( request , response ) ; verify ( request , response ) ; }
BryceARich/TransactionsMR | public void testStaticResources_jQuery ( ) throws Exception { HttpServletResponse resp = createMock ( HttpServletResponse . class ) ; resp . setContentType ( " text / javascript " ) ; resp . setHeader ( " Cache - Control " , " public ; ▁ max - age = 300" ) ; ServletOutputStream sos = createMock ( ServletOutputStream . class ) ; expect ( resp . getOutputStream ( ) ) . andReturn ( sos ) ; sos . write ( ( byte [ ] ) EasyMock . anyObject ( ) , EasyMock . eq ( 0 ) , EasyMock . anyInt ( ) ) ; EasyMock . expectLastCall ( ) . atLeastOnce ( ) ; sos . flush ( ) ; EasyMock . expectLastCall ( ) . anyTimes ( ) ; replay ( resp , sos ) ; MapReduceServletImpl . handleStaticResources ( " jquery . js " , resp ) ; verify ( resp , sos ) ; }
BryceARich/TransactionsMR | public void testStaticResources_status ( ) throws Exception { HttpServletResponse resp = createMock ( HttpServletResponse . class ) ; resp . sendRedirect ( " / _ ah / pipeline / list ? class _ path = " + MapReduceJob . class . getName ( ) ) ; replay ( resp ) ; MapReduceServletImpl . handleStaticResources ( " status " , resp ) ; verify ( resp ) ; }
codes13/android-drawable-creator | DensityType ( String folderName ) { this . folderName = folderName ; }
codes13/android-drawable-creator | public String getFolderName ( ) { return folderName ; }
antoinesd/weld-core | public SimpleExtension getSimpleExtension ( ) { return simpleExtension ; }
tejksat/docker-java | @ CheckForNull public Long getParallelism ( ) { return parallelism ; }
tejksat/docker-java | public UpdateConfig withParallelism ( long parallelism ) { this . parallelism = parallelism ; return this ; }
tejksat/docker-java | @ CheckForNull public Long getDelay ( ) { return delay ; }
tejksat/docker-java | public UpdateConfig setDelay ( Long delay ) { this . delay = delay ; return this ; }
tejksat/docker-java | @ CheckForNull public UpdateFailureAction getFailureAction ( ) { return failureAction ; }
tejksat/docker-java | public UpdateConfig withFailureAction ( UpdateFailureAction failureAction ) { this . failureAction = failureAction ; return this ; }
tejksat/docker-java | public UpdateConfig withParallelism ( Long parallelism ) { this . parallelism = parallelism ; return this ; }
tejksat/docker-java | public UpdateConfig withDelay ( Long delay ) { this . delay = delay ; return this ; }
tejksat/docker-java | public Float getMaxFailureRatio ( ) { return maxFailureRatio ; }
tejksat/docker-java | public UpdateConfig withMaxFailureRatio ( Float maxFailureRatio ) { this . maxFailureRatio = maxFailureRatio ; return this ; }
tejksat/docker-java | public Long getMonitor ( ) { return monitor ; }
tejksat/docker-java | public UpdateConfig withMonitor ( Long monitor ) { this . monitor = monitor ; return this ; }
tejksat/docker-java | public UpdateOrder getOrder ( ) { return order ; }
tejksat/docker-java | public UpdateConfig withOrder ( UpdateOrder order ) { this . order = order ; return this ; }
gzussa/javacodegen | public Service ( ) { super ( ) ; }
gzussa/javacodegen | public Service ( String fileName , String packageName ) { super ( fileName , packageName ) ; }
gzussa/javacodegen | public String getName ( ) { return getFileName ( ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsTrueIfGivenDayIsAWorkDay ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 26 ) ; boolean returnValue = DateUtil . isWorkDay ( date ) ; Assert . assertTrue ( " Should ▁ return ▁ true ▁ for ▁ a ▁ work ▁ day " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsFalseIfGivenDayIsNotAWorkDay ( ) { DateMidnight date = new DateMidnight ( 2014 , 11 , 23 ) ; boolean returnValue = DateUtil . isWorkDay ( date ) ; Assert . assertFalse ( " Should ▁ return ▁ false ▁ for ▁ not ▁ a ▁ work ▁ day " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectFirstDayOfMonth ( ) { int year = 2014 ; int month = 11 ; DateMidnight firstDayOfMonth = new DateMidnight ( year , month , 1 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ first ▁ day ▁ of ▁ month " , firstDayOfMonth , DateUtil . getFirstDayOfMonth ( year , month ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectLastDayOfMonth ( ) { int year = 2014 ; int month = 11 ; DateMidnight lastDayOfMonth = new DateMidnight ( year , month , 30 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ last ▁ day ▁ of ▁ month " , lastDayOfMonth , DateUtil . getLastDayOfMonth ( year , month ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectLastDayOfMonthForSpecialMonths ( ) { int year = 2014 ; int month = 2 ; DateMidnight lastDayOfMonth = new DateMidnight ( year , month , 28 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ last ▁ day ▁ of ▁ month " , lastDayOfMonth , DateUtil . getLastDayOfMonth ( year , month ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectFirstDayOfYear ( ) { int year = 2014 ; DateMidnight firstDayOfYear = new DateMidnight ( year , 1 , 1 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ first ▁ day ▁ of ▁ year " , firstDayOfYear , DateUtil . getFirstDayOfYear ( year ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectLastDayOfYear ( ) { int year = 2014 ; DateMidnight lastDayOfYear = new DateMidnight ( year , 12 , 31 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ last ▁ day ▁ of ▁ year " , lastDayOfYear , DateUtil . getLastDayOfYear ( year ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsTrueForChristmasEve ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 24 ) ; boolean returnValue = DateUtil . isChristmasEve ( date ) ; Assert . assertTrue ( " Should ▁ return ▁ true ▁ for ▁ 24th ▁ December " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsFalseForNotChristmasEve ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 25 ) ; boolean returnValue = DateUtil . isChristmasEve ( date ) ; Assert . assertFalse ( " Should ▁ return ▁ false ▁ for ▁ 25th ▁ December " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsTrueForNewYearsEve ( ) { DateMidnight date = new DateMidnight ( 2014 , 12 , 31 ) ; boolean returnValue = DateUtil . isNewYearsEve ( date ) ; Assert . assertTrue ( " Should ▁ return ▁ true ▁ for ▁ 31st ▁ December " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsFalseForNotNewYearsEve ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 25 ) ; boolean returnValue = DateUtil . isNewYearsEve ( date ) ; Assert . assertFalse ( " Should ▁ return ▁ false ▁ for ▁ 25th ▁ December " , returnValue ) ; }
fnp/pylucene | public void testFilter ( ) throws Exception { TokenStream stream = new MockTokenizer ( new StringReader ( " Do ▁ have ▁ a ▁ nice ▁ day " ) , MockTokenizer . WHITESPACE , false ) ; ReverseStringFilter filter = new ReverseStringFilter ( TEST_VERSION_CURRENT , stream ) ; assertTokenStreamContents ( filter , new String [ ] { " oD " , " evah " , " a " , " ecin " , " yad " } ) ; }
fnp/pylucene | public void testFilterWithMark ( ) throws Exception { TokenStream stream = new MockTokenizer ( new StringReader ( " Do ▁ have ▁ a ▁ nice ▁ day " ) , MockTokenizer . WHITESPACE , false ) ; ReverseStringFilter filter = new ReverseStringFilter ( TEST_VERSION_CURRENT , stream , ' \u0001' ) ; assertTokenStreamContents ( filter , new String [ ] { " \u0001oD " , " \u0001evah " , " \u0001a " , " \u0001ecin " , " \u0001yad " } ) ; }
fnp/pylucene | public void testReverseString ( ) throws Exception { assertEquals ( " A " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " A " ) ) ; assertEquals ( " BA " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " AB " ) ) ; assertEquals ( " CBA " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " ABC " ) ) ; }
fnp/pylucene | public void testReverseChar ( ) throws Exception { char [ ] buffer = { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 2 , 3 ) ; assertEquals ( " ABEDCF " , new String ( buffer ) ) ; }
fnp/pylucene | public void testBackCompat ( ) throws Exception { assertEquals ( " \uDF05\uD866\uDF05\uD866" , ReverseStringFilter . reverse ( " 𩬅𩬅 " ) ) ; }
fnp/pylucene | public void testReverseSupplementary ( ) throws Exception { assertEquals ( " 𩬅艱鍟䇹愯瀛 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 瀛愯䇹鍟艱𩬅 " ) ) ; assertEquals ( " a𩬅艱鍟䇹愯瀛 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 瀛愯䇹鍟艱𩬅a " ) ) ; assertEquals ( " fedcba𩬅 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 𩬅abcdef " ) ) ; assertEquals ( " fedcba𩬅z " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " z𩬅abcdef " ) ) ; assertEquals ( " gfe𩬅dcba " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " abcd𩬅efg " ) ) ; }
fnp/pylucene | public void testReverseSupplementaryChar ( ) throws Exception { char [ ] buffer = " abc瀛愯䇹鍟艱𩬅 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abc𩬅艱鍟䇹愯瀛 " , new String ( buffer ) ) ; buffer = " abc瀛愯䇹鍟艱𩬅d " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 8 ) ; assertEquals ( " abcd𩬅艱鍟䇹愯瀛 " , new String ( buffer ) ) ; buffer = " abc𩬅瀛愯䇹鍟艱 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abc艱鍟䇹愯瀛𩬅 " , new String ( buffer ) ) ; buffer = " abcd𩬅瀛愯䇹鍟艱 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 8 ) ; assertEquals ( " abc艱鍟䇹愯瀛𩬅d " , new String ( buffer ) ) ; buffer = " abc瀛愯𩬅def " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abcfed𩬅愯瀛 " , new String ( buffer ) ) ; }
timrdf/csv2rdf4lod | public DateTimePatternQuerylet ( Resource context , int csvColumnIndex ) { super ( context , csvColumnIndex ) ; }
timrdf/csv2rdf4lod | @ Override public String getQueryString ( Resource context ) { this . addNamespace ( " rdfs " , " xsd " , " ov " , " conversion " ) ; String select = " distinct ▁ ? pattern ▁ ? range ▁ ? timezone " ; String graphPattern = " ? cp ▁ conversion : enhance ▁ [ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \n " + " ▁ ▁ ▁ " + columnPO ( ) + " ; ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \n " + " ▁ ▁ ▁ conversion : pattern ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ? pattern ; ▁ ▁ \n " + " ▁ ▁ ▁ conversion : range ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ? range ; ▁ ▁ ▁ ▁ \n " + " ] ▁ . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \n " + " optional ▁ { ▁ ? cp ▁ conversion : datetime _ timezone ▁ ? timezone ; ▁ } " ; String orderBy = " " ; return this . composeQuery ( select , context , graphPattern , orderBy ) ; }
timrdf/csv2rdf4lod | @ Override public void handleBindingSet ( BindingSet bindingSet ) { String pattern = bindingSet . getValue ( " pattern " ) . stringValue ( ) ; String range = bindingSet . getValue ( " range " ) . stringValue ( ) ; this . patterns . put ( pattern , ValueFactoryImpl . getInstance ( ) . createURI ( range ) ) ; if ( bindingSet . hasBinding ( " timezone " ) ) { this . timezone = Integer . parseInt ( bindingSet . getValue ( " timezone " ) . stringValue ( ) ) ; } System . err . println ( ColumnEnhancementQuerylet . REPORT_INDENT + getClass ( ) . getSimpleName ( ) + " ( " + this . csvColumnIndex + " ) ▁ . " + pattern + " . ▁ timezone : ▁ . " + timezone + " . ▁ a ▁ " + range ) ; }
timrdf/csv2rdf4lod | public HashMap < String , URI > get ( ) { return this . patterns ; }
timrdf/csv2rdf4lod | public int getTimezone ( ) { return this . timezone ; }
jdrider/rhodes | public String [ ] getDeletedObjects ( ) { return mDeletedObjects ; }
jdrider/rhodes | public String [ ] getUpdatedObjects ( ) { return mUpdatedObjects ; }
jdrider/rhodes | public String [ ] getCreatedObjects ( ) { return mCreatedObjects ; }
jdrider/rhodes | public int [ ] getDeletedSourceIds ( ) { return mDeletedSrcIds ; }
jdrider/rhodes | public int [ ] getUpdatedSourceIds ( ) { return mUpdatedSrcIds ; }
jdrider/rhodes | public int [ ] getCreatedSourceIds ( ) { return mCreatedSrcIds ; }
Talend/data-prep | private DataSetGetSchema ( final String dataSetId ) { super ( GenericCommand . DATASET_GROUP ) ; this . dataSetId = dataSetId ; on ( HttpStatus . NO_CONTENT ) . then ( asNull ( ) ) ; }
Talend/data-prep | @ PostConstruct private void initConfiguration ( ) { URI datasetURI ; try { datasetURI = new URIBuilder ( datasetServiceUrl + " / api / v1 / datasets / " + dataSetId + " / schema " ) . build ( ) ; } catch ( URISyntaxException e ) { throw new TDPException ( UNEXPECTED_EXCEPTION , e ) ; } execute ( ( ) -> { HttpGet httpGet = new HttpGet ( datasetURI ) ; httpGet . setHeader ( ACCEPT , AvroUtils . AVRO_JSON_MIME_TYPES_UNOFFICIAL_VALID_VALUE ) ; return httpGet ; } ) ; on ( HttpStatus . OK ) . then ( ( req , res ) -> { try ( InputStream inputStream = res . getEntity ( ) . getContent ( ) ) { return new Schema . Parser ( ) . parse ( inputStream ) ; } catch ( IOException e ) { throw new TDPException ( UNEXPECTED_EXCEPTION , e ) ; } finally { req . releaseConnection ( ) ; } } ) ; }
thomasmaurel/ensj-healthcheck | public EnaAnalysisTypes ( ) { super ( ) ; }
thomasmaurel/ensj-healthcheck | @ Override protected String getEgDescription ( ) { return " Test ▁ for ▁ whether ▁ ENA - specific ▁ analysis ▁ types ▁ remain " ; }
thomasmaurel/ensj-healthcheck | @ Override protected boolean runTest ( final DatabaseRegistryEntry dbre ) { final Pattern enaPattern = Pattern . compile ( " . * ena . * " , Pattern . CASE_INSENSITIVE ) ; final EnsTestCase test = this ; List < String > failures = getTemplate ( dbre ) . queryForList ( TEST_SQL , new RowMapper < String > ( ) { @ Override public String mapRow ( ResultSet resultSet , int position ) throws SQLException { String logicName = resultSet . getString ( 1 ) ; String description = resultSet . getString ( 2 ) ; String displayLabel = resultSet . getString ( 3 ) ; String webData = resultSet . getString ( 4 ) ; if ( ! StringUtils . isEmpty ( logicName ) && enaPattern . matcher ( logicName ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ logic _ name ▁ contains ▁ the ▁ string ▁ ' ena ' " ) ; } if ( ! StringUtils . isEmpty ( description ) && enaPattern . matcher ( description ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ description ▁ contains ▁ the ▁ string ▁ ' ena ' : ▁ " + description ) ; } if ( ! StringUtils . isEmpty ( displayLabel ) && enaPattern . matcher ( displayLabel ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ display _ Label ▁ contains ▁ the ▁ string ▁ ' ena ' : ▁ " + displayLabel ) ; } if ( ! StringUtils . isEmpty ( webData ) && enaPattern . matcher ( webData ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ web _ Data ▁ contains ▁ the ▁ string ▁ ' ena ' : ▁ " + webData ) ; } return logicName ; } } ) ; return failures . size ( ) == 0 ; }
Timpy/Glimmer | public String getTerm ( ) { return term ; }
Timpy/Glimmer | public void setTerm ( String term ) { this . term = term ; }
Timpy/Glimmer | public int getTermFrequency ( ) { return termFrequency ; }
Timpy/Glimmer | public void setTermFrequency ( int termFrequency ) { this . termFrequency = termFrequency ; }
Timpy/Glimmer | public int getOccurrenceCount ( ) { return occurrenceCount ; }
Timpy/Glimmer | public void setOccurrenceCount ( int occurrenceCount ) { this . occurrenceCount = occurrenceCount ; }
Timpy/Glimmer | public long getSumOfMaxTermPositions ( ) { return sumOfMaxTermPositions ; }
Timpy/Glimmer | public void setSumOfMaxTermPositions ( long sumOfMaxTermPositions ) { this . sumOfMaxTermPositions = sumOfMaxTermPositions ; }
Timpy/Glimmer | public void set ( IndexRecordWriterTermValue that ) { this . term = that . term ; this . termFrequency = that . termFrequency ; this . occurrenceCount = that . occurrenceCount ; this . sumOfMaxTermPositions = that . sumOfMaxTermPositions ; }
Timpy/Glimmer | @ Override public void readFields ( DataInput arg0 ) throws IOException { }
Timpy/Glimmer | @ Override public void write ( DataOutput arg0 ) throws IOException { }
Timpy/Glimmer | @ Override public int compareTo ( IndexRecordWriterValue value ) { if ( value instanceof IndexRecordWriterTermValue ) { IndexRecordWriterTermValue that = ( IndexRecordWriterTermValue ) value ; long i = term . compareTo ( that . term ) ; if ( i != 0 ) { i = termFrequency - that . termFrequency ; if ( i != 0 ) { i = occurrenceCount - that . occurrenceCount ; if ( i != 0 ) { i = sumOfMaxTermPositions - that . sumOfMaxTermPositions ; } } } if ( i > 0 ) { return 1 ; } else if ( i < 0 ) { return - 1 ; } return 0 ; } return - 1 ; }
Timpy/Glimmer | @ Override public boolean equals ( Object o ) { if ( o instanceof IndexRecordWriterTermValue ) { IndexRecordWriterTermValue that = ( IndexRecordWriterTermValue ) o ; if ( termFrequency == that . termFrequency && occurrenceCount == that . occurrenceCount && sumOfMaxTermPositions == that . sumOfMaxTermPositions ) { return term . equals ( that . term ) ; } } return false ; }
Timpy/Glimmer | @ Override public int hashCode ( ) { int hash = 11 ; hash = 31 * hash + term . hashCode ( ) ; hash = 31 * hash + termFrequency ; hash = 31 * hash + occurrenceCount ; hash = 31 * hash + ( int ) ( sumOfMaxTermPositions ^ ( sumOfMaxTermPositions >>> 32 ) ) ; return hash ; }
Timpy/Glimmer | @ Override public String toString ( ) { return term + ' : ' + termFrequency + ' : ' + occurrenceCount + ' : ' + sumOfMaxTermPositions ; }
vivantech/kc_fixes | public Integer getModuleNumber ( ) { return moduleNumber ; }
vivantech/kc_fixes | public void setModuleNumber ( Integer moduleNumber ) { this . moduleNumber = moduleNumber ; }
vivantech/kc_fixes | public String getProposalNumber ( ) { return proposalNumber ; }
vivantech/kc_fixes | public void setProposalNumber ( String proposalNumber ) { this . proposalNumber = proposalNumber ; }
vivantech/kc_fixes | public String getUserId ( ) { return userId ; }
vivantech/kc_fixes | public void setUserId ( String userId ) { this . userId = userId ; }
vivantech/kc_fixes | public String getAccessType ( ) { return accessType ; }
vivantech/kc_fixes | public void setAccessType ( String accessType ) { this . accessType = accessType ; }
vivantech/kc_fixes | public String getPersonName ( ) { return personName ; }
vivantech/kc_fixes | public void setPersonName ( String personName ) { this . personName = personName ; }
quarkusio/quarkus | @ Test void testHeadersWithSubresource ( ) { Client client = RestClientBuilder . newBuilder ( ) . baseUri ( baseUri ) . build ( Client . class ) ; assertThat ( client . cookieSub ( " bar " , " bar2" ) . send ( " bar3" , " bar4" ) ) . isEqualTo ( " bar : bar2 : bar3 : bar4" ) ; }
quarkusio/quarkus | @ Test void testNullHeaders ( ) { Client client = RestClientBuilder . newBuilder ( ) . baseUri ( baseUri ) . build ( Client . class ) ; assertThat ( client . cookieSub ( " bar " , null ) . send ( null , " bar4" ) ) . isEqualTo ( " bar : null : null : bar4" ) ; }
quarkusio/quarkus | @ GET public String returnHeaders ( @ HeaderParam ( " foo " ) String header , @ HeaderParam ( " foo2" ) String header2 , @ HeaderParam ( " foo3" ) String header3 , @ HeaderParam ( " foo4" ) String header4 ) { return header + " : " + header2 + " : " + header3 + " : " + header4 ; }
ecarm002/incubator-asterixdb | @ Override public IScalarEvaluatorFactory createEvaluatorFactory ( final IScalarEvaluatorFactory [ ] args ) { return new IScalarEvaluatorFactory ( ) { private static final long serialVersionUID = 1L ; private final int baseOffset = stringOffset ; @ Override public IScalarEvaluator createScalarEvaluator ( IHyracksTaskContext ctx ) throws HyracksDataException { return new AbstractBinaryStringIntEval ( ctx , args [ 0 ] , args [ 1 ] , StringPositionDescriptor . this . getIdentifier ( ) , sourceLoc ) { @ Override protected int compute ( UTF8StringPointable left , UTF8StringPointable right ) throws IOException { int pos = UTF8StringPointable . find ( left , right , false ) ; return pos < 0 ? pos : pos + baseOffset ; } } ; } } ; }
ecarm002/incubator-asterixdb | @ Override public FunctionIdentifier getIdentifier ( ) { return BuiltinFunctions . STRING_POSITION ; }
nkurihar/pulsar | @ BeforeMethod public void before ( ) { pulsarSourceBuilder = PulsarSourceBuilder . builder ( new TestDeserializationSchema ( ) ) ; }
nkurihar/pulsar | @ Test public void testBuild ( ) { SourceFunction sourceFunction = pulsarSourceBuilder . serviceUrl ( " testServiceUrl " ) . topic ( " testTopic " ) . subscriptionName ( " testSubscriptionName " ) . build ( ) ; Assert . assertNotNull ( sourceFunction ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testBuildWithoutSettingRequiredProperties ( ) { pulsarSourceBuilder . build ( ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testServiceUrlWithNull ( ) { pulsarSourceBuilder . serviceUrl ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testServiceUrlWithBlank ( ) { pulsarSourceBuilder . serviceUrl ( " ▁ " ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicWithNull ( ) { pulsarSourceBuilder . topic ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicWithBlank ( ) { pulsarSourceBuilder . topic ( " ▁ " ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicsWithNull ( ) { pulsarSourceBuilder . topics ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicsWithBlank ( ) { pulsarSourceBuilder . topics ( Arrays . asList ( " ▁ " , " ▁ " ) ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicPatternWithNull ( ) { pulsarSourceBuilder . topicsPattern ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicPatternAlreadySet ( ) { pulsarSourceBuilder . topicsPattern ( Pattern . compile ( " persistent : // tenants / ns / topic - * " ) ) ; pulsarSourceBuilder . topicsPattern ( Pattern . compile ( " persistent : // tenants / ns / topic - my - * " ) ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicPattenStringWithNull ( ) { pulsarSourceBuilder . topicsPatternString ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testSubscriptionNameWithNull ( ) { pulsarSourceBuilder . subscriptionName ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testSubscriptionNameWithBlank ( ) { pulsarSourceBuilder . subscriptionName ( " ▁ " ) ; }
nkurihar/pulsar | @ Override public T deserialize ( byte [ ] bytes ) throws IOException { return null ; }
nkurihar/pulsar | @ Override public boolean isEndOfStream ( T t ) { return false ; }
nkurihar/pulsar | @ Override public TypeInformation < T > getProducedType ( ) { return null ; }
jalian-systems/marathonv5 | @ Override public void start ( Stage stage ) { Scene scene = new Scene ( new Group ( ) ) ; stage . setTitle ( " Checkbox ▁ Sample " ) ; stage . setWidth ( 250 ) ; stage . setHeight ( 150 ) ; rect . setArcHeight ( 10 ) ; rect . setArcWidth ( 10 ) ; rect . setFill ( Color . rgb ( 41 , 41 , 41 ) ) ; for ( int i = 0 ; i < names . length ; i ++ ) { final Image image = images [ i ] = new Image ( getClass ( ) . getResourceAsStream ( names [ i ] + " . png " ) ) ; final ImageView icon = icons [ i ] = new ImageView ( ) ; final CheckBox cb = cbs [ i ] = new CheckBox ( names [ i ] ) ; cb . selectedProperty ( ) . addListener ( ( ObservableValue < ? extends Boolean > ov , Boolean old_val , Boolean new_val ) -> { icon . setImage ( new_val ? image : null ) ; } ) ; } VBox vbox = new VBox ( ) ; vbox . getChildren ( ) . addAll ( cbs ) ; vbox . setSpacing ( 5 ) ; HBox hbox = new HBox ( ) ; hbox . getChildren ( ) . addAll ( icons ) ; hbox . setPadding ( new Insets ( 0 , 0 , 0 , 5 ) ) ; StackPane stack = new StackPane ( ) ; stack . getChildren ( ) . add ( rect ) ; stack . getChildren ( ) . add ( hbox ) ; StackPane . setAlignment ( rect , Pos . TOP_CENTER ) ; HBox root = new HBox ( ) ; root . getChildren ( ) . add ( vbox ) ; root . getChildren ( ) . add ( stack ) ; root . setSpacing ( 40 ) ; root . setPadding ( new Insets ( 20 , 10 , 10 , 20 ) ) ; ( ( Group ) scene . getRoot ( ) ) . getChildren ( ) . add ( root ) ; stage . setScene ( scene ) ; stage . show ( ) ; }
thankpoint/thanks4java | @ Override default String getAlgorithm ( ) { return ALGORITHM_SHA1PRNG ; }
grasscrm/gdesigner | public BoundednessChecker ( PTNetInterpreter interpreter , PTNet net ) { this . net = net ; this . interpreter = interpreter ; this . markings_strings = new HashSet < String > ( ) ; this . markings_stack = new ArrayList < int [ ] > ( ) ; }
grasscrm/gdesigner | public boolean checkBoundedness ( ) { return doCheck ( net . getInitialMarking ( ) ) ; }
grasscrm/gdesigner | protected boolean doCheck ( Marking marking ) { String markingStr = marking . toString ( ) ; if ( markings_strings . contains ( markingStr ) ) return true ; markings_strings . add ( markingStr ) ; int [ ] m_b = getMarking ( marking ) ; if ( hasFoundInferiorMarking ( m_b ) ) return false ; markings_stack . add ( m_b ) ; List < Transition > transitions = interpreter . getEnabledTransitions ( net , marking ) ; for ( Transition t : transitions ) { Marking newmarking = interpreter . fireTransition ( net , marking , t ) ; if ( ! doCheck ( newmarking ) ) return false ; } markings_stack . remove ( markings_stack . size ( ) - 1 ) ; return true ; }
grasscrm/gdesigner | protected int [ ] getMarking ( Marking marking ) { int [ ] mb = new int [ net . getPlaces ( ) . size ( ) ] ; int i = 0 ; for ( Iterator < Place > it = net . getPlaces ( ) . iterator ( ) ; it . hasNext ( ) ; i ++ ) { Place p = it . next ( ) ; mb [ i ] = marking . getNumTokens ( p ) ; } return mb ; }
grasscrm/gdesigner | protected boolean hasFoundInferiorMarking ( int [ ] mb ) { for ( Iterator < int [ ] > it = markings_stack . iterator ( ) ; it . hasNext ( ) ; ) { int [ ] mb2 = it . next ( ) ; boolean found = true ; for ( int i = 0 ; i < mb . length ; i ++ ) { if ( mb2 [ i ] > mb [ i ] ) { found = false ; break ; } } if ( found ) return true ; } return false ; }
McJty/EFab | @ Override public void render ( GridTE te , double x , double y , double z , float partialTicks , int destroyStage , float alpha ) { super . render ( te , x , y , z , partialTicks , destroyStage , alpha ) ; if ( te . getWorld ( ) . isAirBlock ( te . getPos ( ) ) ) { return ; } GlStateManager . pushMatrix ( ) ; GlStateManager . translate ( x + .5 , y , z + .5 ) ; GlStateManager . disableRescaleNormal ( ) ; rotateFacing ( te ) ; renderHandles ( te ) ; GlStateManager . popMatrix ( ) ; }
McJty/EFab | private void renderHandles ( GridTE tileEntity ) { bindTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) ; boolean half = GridBlock . isHalfBlock ( tileEntity . getWorld ( ) , tileEntity . getPos ( ) ) ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 3 ; y ++ ) { renderHandle ( tileEntity , x , y , half ) ; } } }
alpinweiss/filegen | public SheetProcessor ( ParameterVault parameterVault , CountDownLatch startSignal , CountDownLatch doneSignal , CellStyle cs , SXSSFSheet sheet , int columnCount , Map < Integer , Input2TableInfo > input2TableInfoMap , OutputWriterHolder outputWriterHolder ) { this . parameterVault = parameterVault ; this . startSignal = startSignal ; this . doneSignal = doneSignal ; this . cs = cs ; this . sheet = sheet ; this . columnCount = columnCount ; this . input2TableInfoMap = input2TableInfoMap ; this . outputWriterHolder = outputWriterHolder ; }
alpinweiss/filegen | public SheetProcessor ( OutputWriterHolder outputWriterHolder ) { this . outputWriterHolder = outputWriterHolder ; }
alpinweiss/filegen | @ Override public void run ( ) { try { startSignal . await ( ) ; generateSheetData ( parameterVault , cs , sheet , columnCount , input2TableInfoMap ) ; doneSignal . countDown ( ) ; } catch ( InterruptedException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } }
alpinweiss/filegen | public void generateSheetData ( ParameterVault parameterVault , CellStyle cs , SXSSFSheet sheet , int columnCount , Map < Integer , Input2TableInfo > hashMap ) { Cell cell ; int idx = 0 ; int idy = 0 ; Row row = sheet . createRow ( idx ) ; Input2TableInfo input2TableInfo ; for ( Integer key : hashMap . keySet ( ) ) { input2TableInfo = hashMap . get ( key ) ; cell = row . createCell ( idy ) ; cell . setCellValue ( input2TableInfo . getFieldText ( ) ) ; cell . setCellStyle ( cs ) ; sheet . setColumnWidth ( idy , ( input2TableInfo . getFieldText ( ) . trim ( ) . length ( ) * 500 ) ) ; idy ++ ; } ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; for ( int i = 1 ; i < parameterVault . rowCount ( ) + 1 ; i ++ ) { row = sheet . createRow ( i ) ; if ( i != 0 && i % 10000 == 0 ) { outputWriterHolder . writeValueInLine ( Thread . currentThread ( ) . getName ( ) + " ▁ Processed ▁ " + i + " ▁ rows " ) ; } for ( int colCount = 0 ; colCount < columnCount ; colCount ++ ) { final Cell dataCell = row . createCell ( colCount ) ; input2TableInfo = hashMap . get ( colCount ) ; final CellStyle cellStyle = input2TableInfo . getCellStyle ( ) ; input2TableInfo . generator ( ) . generate ( parameterVault . setIterationNumber ( i ) , randomGenerator , new ValueVault ( ) { @ Override public void storeValue ( DataWrapper wrapper ) { FieldType fieldType = wrapper . getFieldType ( ) ; switch ( fieldType ) { case DATE : dataCell . setCellValue ( wrapper . getDateValue ( ) ) ; dataCell . setCellStyle ( cellStyle ) ; break ; case FLOAT : case INTEGER : dataCell . setCellType ( Cell . CELL_TYPE_NUMERIC ) ; dataCell . setCellValue ( wrapper . getNumberValue ( ) ) ; break ; case AUTONUMBER : dataCell . setCellType ( Cell . CELL_TYPE_NUMERIC ) ; dataCell . setCellValue ( wrapper . getNumberValue ( ) ) ; case SEQUENCE : default : dataCell . setCellValue ( wrapper . getStringValue ( ) ) ; } } } ) ; } } }
PRIDE-Utilities/jmzml | public String getRef ( ) { return ref ; }
PRIDE-Utilities/jmzml | public void setRef ( String value ) { this . ref = value ; }
PRIDE-Utilities/jmzml | public ReferenceableParamGroup getReferenceableParamGroup ( ) { return referenceableParamGroup ; }
PRIDE-Utilities/jmzml | public void setReferenceableParamGroup ( ReferenceableParamGroup referenceableParamGroup ) { this . referenceableParamGroup = referenceableParamGroup ; if ( referenceableParamGroup != null ) { this . ref = referenceableParamGroup . getId ( ) ; } }
facebook/fresco | private ImagePerfUtils ( ) { }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order ) { this . router = router ; this . order = order ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , HttpMethod method , String path ) { this ( router , order ) ; methods . add ( method ) ; checkPath ( path ) ; setPath ( path ) ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , String path ) { this ( router , order ) ; checkPath ( path ) ; setPath ( path ) ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , HttpMethod method , String regex , boolean bregex ) { this ( router , order ) ; methods . add ( method ) ; setRegex ( regex ) ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , String regex , boolean bregex ) { this ( router , order ) ; setRegex ( regex ) ; }
sibay/vertx-web | @ Override public synchronized Route method ( HttpMethod method ) { methods . add ( method ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route path ( String path ) { checkPath ( path ) ; setPath ( path ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route pathRegex ( String regex ) { setRegex ( regex ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route produces ( String contentType ) { ParsableMIMEValue value = new ParsableMIMEValue ( contentType ) . forceParse ( ) ; produces . add ( value ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route consumes ( String contentType ) { ParsableMIMEValue value = new ParsableMIMEValue ( contentType ) . forceParse ( ) ; consumes . add ( value ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route order ( int order ) { if ( added ) { throw new IllegalStateException ( " Can ' t ▁ change ▁ order ▁ after ▁ route ▁ is ▁ active " ) ; } this . order = order ; return this ; }
sibay/vertx-web | @ Override public synchronized Route last ( ) { return order ( Integer . MAX_VALUE ) ; }
sibay/vertx-web | @ Override public synchronized Route handler ( Handler < RoutingContext > contextHandler ) { if ( this . contextHandler != null ) { log . warn ( " Setting ▁ handler ▁ for ▁ a ▁ route ▁ more ▁ than ▁ once ! " ) ; } this . contextHandler = contextHandler ; checkAdd ( ) ; return this ; }
sibay/vertx-web | @ Override public Route blockingHandler ( Handler < RoutingContext > contextHandler ) { return blockingHandler ( contextHandler , true ) ; }
sibay/vertx-web | @ Override public synchronized Route blockingHandler ( Handler < RoutingContext > contextHandler , boolean ordered ) { return handler ( new BlockingHandlerDecorator ( contextHandler , ordered ) ) ; }
sibay/vertx-web | @ Override public synchronized Route failureHandler ( Handler < RoutingContext > exceptionHandler ) { if ( this . failureHandler != null ) { log . warn ( " Setting ▁ failureHandler ▁ for ▁ a ▁ route ▁ more ▁ than ▁ once ! " ) ; } this . failureHandler = exceptionHandler ; checkAdd ( ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route remove ( ) { router . remove ( this ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route disable ( ) { enabled = false ; return this ; }
sibay/vertx-web | @ Override public synchronized Route enable ( ) { enabled = true ; return this ; }
sibay/vertx-web | @ Override public Route useNormalisedPath ( boolean useNormalisedPath ) { this . useNormalisedPath = useNormalisedPath ; return this ; }
sibay/vertx-web | @ Override public String getPath ( ) { return path ; }
sibay/vertx-web | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " Route [ ▁ " ) ; sb . append ( " path : " ) . append ( path ) ; sb . append ( " ▁ pattern : " ) . append ( pattern ) ; sb . append ( " ▁ handler : " ) . append ( contextHandler ) ; sb . append ( " ▁ failureHandler : " ) . append ( failureHandler ) ; sb . append ( " ▁ order : " ) . append ( order ) ; sb . append ( " ▁ methods : [ " ) ; int cnt = 0 ; for ( HttpMethod method : methods ) { sb . append ( method ) ; cnt ++ ; if ( cnt < methods . size ( ) ) { sb . append ( " , " ) ; } } sb . append ( " ] ] @ " ) . append ( System . identityHashCode ( this ) ) ; return sb . toString ( ) ; }
sibay/vertx-web | synchronized void handleContext ( RoutingContext context ) { if ( contextHandler != null ) { contextHandler . handle ( context ) ; } }
sibay/vertx-web | synchronized void handleFailure ( RoutingContext context ) { if ( failureHandler != null ) { failureHandler . handle ( context ) ; } }
sibay/vertx-web | synchronized boolean matches ( RoutingContext context , String mountPoint , boolean failure ) { if ( failure && failureHandler == null || ! failure && contextHandler == null ) { return false ; } if ( ! enabled ) { return false ; } HttpServerRequest request = context . request ( ) ; if ( ! methods . isEmpty ( ) && ! methods . contains ( request . method ( ) ) ) { return false ; } if ( path != null && pattern == null && ! pathMatches ( mountPoint , context ) ) { return false ; } if ( pattern != null ) { String path = useNormalisedPath ? Utils . normalizePath ( context . request ( ) . path ( ) ) : context . request ( ) . path ( ) ; if ( mountPoint != null ) { path = path . substring ( mountPoint . length ( ) ) ; } Matcher m = pattern . matcher ( path ) ; if ( m . matches ( ) ) { if ( m . groupCount ( ) > 0 ) { Map < String , String > params = new HashMap < > ( m . groupCount ( ) ) ; if ( groups != null ) { for ( int i = 0 ; i < groups . size ( ) ; i ++ ) { final String k = groups . get ( i ) ; final String value = Utils . urlDecode ( m . group ( " p " + i ) , false ) ; if ( ! request . params ( ) . contains ( k ) ) { params . put ( k , value ) ; } else { context . pathParams ( ) . put ( k , value ) ; } } } else { for ( int i = 0 ; i < m . groupCount ( ) ; i ++ ) { String group = m . group ( i + 1 ) ; if ( group != null ) { final String k = " param " + i ; final String value = Utils . urlDecode ( group , false ) ; if ( ! request . params ( ) . contains ( k ) ) { params . put ( k , value ) ; } else { context . pathParams ( ) . put ( k , value ) ; } } } } request . params ( ) . addAll ( params ) ; context . pathParams ( ) . putAll ( params ) ; } } else { return false ; } } if ( ! consumes . isEmpty ( ) ) { MIMEHeader contentType = context . parsedHeaders ( ) . contentType ( ) ; MIMEHeader consumal = contentType . findMatchedBy ( consumes ) ; if ( consumal == null ) { return false ; } } List < MIMEHeader > acceptableTypes = context . parsedHeaders ( ) . accept ( ) ; if ( ! produces . isEmpty ( ) && ! acceptableTypes . isEmpty ( ) ) { MIMEHeader selectedAccept = context . parsedHeaders ( ) . findBestUserAcceptedIn ( acceptableTypes , produces ) ; if ( selectedAccept != null ) { context . setAcceptableContentType ( selectedAccept . rawValue ( ) ) ; return true ; } return false ; } return true ; }
sibay/vertx-web | RouterImpl router ( ) { return router ; }
sibay/vertx-web | private boolean pathMatches ( String mountPoint , RoutingContext ctx ) { String thePath = mountPoint == null ? path : mountPoint + path ; String requestPath ; if ( useNormalisedPath ) { requestPath = Utils . normalizePath ( ctx . request ( ) . path ( ) ) ; } else { requestPath = ctx . request ( ) . path ( ) ; if ( requestPath == null ) { requestPath = " / " ; } } if ( exactPath ) { return pathMatchesExact ( requestPath , thePath ) ; } else { if ( thePath . endsWith ( " / " ) && requestPath . equals ( removeTrailing ( thePath ) ) ) { return true ; } return requestPath . startsWith ( thePath ) ; } }
sibay/vertx-web | private boolean pathMatchesExact ( String path1 , String path2 ) { return removeTrailing ( path1 ) . equals ( removeTrailing ( path2 ) ) ; }
sibay/vertx-web | private String removeTrailing ( String path ) { int i = path . length ( ) ; if ( path . charAt ( i - 1 ) == ' / ' ) { path = path . substring ( 0 , i - 1 ) ; } return path ; }
sibay/vertx-web | private void setPath ( String path ) { if ( path . indexOf ( ' : ' ) != - 1 ) { createPatternRegex ( path ) ; this . path = path ; } else { if ( path . charAt ( path . length ( ) - 1 ) != ' * ' ) { exactPath = true ; this . path = path ; } else { exactPath = false ; this . path = path . substring ( 0 , path . length ( ) - 1 ) ; } } }
sibay/vertx-web | private void setRegex ( String regex ) { pattern = Pattern . compile ( regex ) ; }
sibay/vertx-web | private void createPatternRegex ( String path ) { path = RE_OPERATORS_NO_STAR . matcher ( path ) . replaceAll ( " \\ \\ $ 1" ) ; if ( path . charAt ( path . length ( ) - 1 ) == ' * ' ) { path = path . substring ( 0 , path . length ( ) - 1 ) + " . * " ; } Matcher m = Pattern . compile ( " : ( [ A - Za - z ] [ A - Za - z0-9 _ ] * ) " ) . matcher ( path ) ; StringBuffer sb = new StringBuffer ( ) ; groups = new ArrayList < > ( ) ; int index = 0 ; while ( m . find ( ) ) { String param = " p " + index ; String group = m . group ( ) . substring ( 1 ) ; if ( groups . contains ( group ) ) { throw new IllegalArgumentException ( " Cannot ▁ use ▁ identifier ▁ " + group + " ▁ more ▁ than ▁ once ▁ in ▁ pattern ▁ string " ) ; } m . appendReplacement ( sb , " ( ? < " + param + " > [ ^ / ] + ) " ) ; groups . add ( group ) ; index ++ ; } m . appendTail ( sb ) ; path = sb . toString ( ) ; pattern = Pattern . compile ( path ) ; }
sibay/vertx-web | private void checkPath ( String path ) { if ( " " . equals ( path ) || path . charAt ( 0 ) != ' / ' ) { throw new IllegalArgumentException ( " Path ▁ must ▁ start ▁ with ▁ / " ) ; } }
sibay/vertx-web | int order ( ) { return order ; }
sibay/vertx-web | private void checkAdd ( ) { if ( ! added ) { router . add ( this ) ; added = true ; } }
bendraaisma/gnuob-soap | @ Override @ Transient public boolean isDetached ( ) { return newArrayList ( isAbstractTypeDetached ( ) , isAddressDetached ( ) ) . stream ( ) . filter ( e -> e . booleanValue ( ) ) . count ( ) > ZERO ; }
bendraaisma/gnuob-soap | @ Transient private boolean isAddressDetached ( ) { return address != null && address . isDetached ( ) ; }
bendraaisma/gnuob-soap | @ Override public Context accept ( final IContextVisitor visitor ) { return visitor . visit ( this ) ; }
bendraaisma/gnuob-soap | , orphanRemoval = true ) public Address getAddress ( ) { return address ; }
bendraaisma/gnuob-soap | @ XmlElement ( required = true ) @ Column ( name = BUYER_EMAIL_COLUMN_NAME , nullable = false ) public String getBuyerEmail ( ) { return buyerEmail ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = BUYER_MARKETING_EMAIL_COLUMN_NAME ) public String getBuyerMarketingEmail ( ) { return buyerMarketingEmail ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = CONTACT_PHONE_COLUMN_NAME ) public String getContactPhone ( ) { return contactPhone ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = DATE_OF_BIRTH_COLUMN_NAME ) public Date getDateOfBirth ( ) { return dateOfBirth ; }
bendraaisma/gnuob-soap | @ XmlElement ( required = true ) @ Column ( name = FIRST_NAME_COLUMN_NAME , nullable = false ) public String getFirstName ( ) { return firstName ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = FRIENDLY_NAME_COLUMN_NAME ) public String getFriendlyName ( ) { if ( isBlank ( friendlyName ) ) { if ( isNotBlank ( getMiddleName ( ) ) ) { friendlyName = getFirstName ( ) + " ▁ " + getMiddleName ( ) + " ▁ " + getLastName ( ) ; } else { friendlyName = getFirstName ( ) + " ▁ " + getLastName ( ) ; } } return friendlyName ; }
bendraaisma/gnuob-soap | @ XmlElement ( required = true ) @ Column ( name = LAST_NAME_COLUMN_NAME , nullable = false ) public String getLastName ( ) { return lastName ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = MIDDLE_NAME_COLUMN_NAME ) public String getMiddleName ( ) { return middleName ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_COLUMN_NAME ) public String getPayer ( ) { return payer ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_BUSINESS_COLUMN_NAME ) public String getPayerBusiness ( ) { return payerBusiness ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_ID_COLUMN_NAME ) public String getPayerId ( ) { return payerId ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_STATUS_COLUMN_NAME ) public String getPayerStatus ( ) { return payerStatus ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = SALUTATION_COLUMN_NAME ) public String getSalutation ( ) { return salutation ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = SUFFIX_COLUMN_NAME ) public String getSuffix ( ) { return suffix ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = TAX_ID_COLUMN_NAME ) public String getTaxId ( ) { return taxId ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = TAX_ID_TYPE_COLUMN_NAME ) public String getTaxIdType ( ) { return taxIdType ; }
bendraaisma/gnuob-soap | public void setAddress ( final Address address ) { this . address = address ; }
bendraaisma/gnuob-soap | public void setBuyerEmail ( final String buyerEmail ) { this . buyerEmail = buyerEmail ; }
bendraaisma/gnuob-soap | public void setBuyerMarketingEmail ( final String buyerMarketingEmail ) { this . buyerMarketingEmail = buyerMarketingEmail ; }
bendraaisma/gnuob-soap | public void setContactPhone ( final String contactPhone ) { this . contactPhone = contactPhone ; }
bendraaisma/gnuob-soap | public void setDateOfBirth ( final Date dateOfBirth ) { this . dateOfBirth = dateOfBirth ; }
bendraaisma/gnuob-soap | public void setFirstName ( final String firstName ) { this . firstName = firstName ; }
bendraaisma/gnuob-soap | public void setFriendlyName ( final String friendlyName ) { this . friendlyName = friendlyName ; }
bendraaisma/gnuob-soap | public void setLastName ( final String lastName ) { this . lastName = lastName ; }
bendraaisma/gnuob-soap | public void setMiddleName ( final String middleName ) { this . middleName = middleName ; }
bendraaisma/gnuob-soap | public void setPayer ( final String payer ) { this . payer = payer ; }
bendraaisma/gnuob-soap | public void setPayerBusiness ( final String payerBusiness ) { this . payerBusiness = payerBusiness ; }
bendraaisma/gnuob-soap | public void setPayerId ( final String payerId ) { this . payerId = payerId ; }
bendraaisma/gnuob-soap | public void setPayerStatus ( final String payerStatus ) { this . payerStatus = payerStatus ; }
bendraaisma/gnuob-soap | public void setSalutation ( final String salutation ) { this . salutation = salutation ; }
bendraaisma/gnuob-soap | public void setSuffix ( final String suffix ) { this . suffix = suffix ; }
bendraaisma/gnuob-soap | public void setTaxId ( final String taxId ) { this . taxId = taxId ; }
bendraaisma/gnuob-soap | public void setTaxIdType ( final String taxIdType ) { this . taxIdType = taxIdType ; }
charlesccychen/beam | LoadTest ( String [ ] args , Class < OptionsT > testOptions , String metricsNamespace ) throws IOException { this . metricsNamespace = metricsNamespace ; this . runtimeMonitor = new TimeMonitor < > ( metricsNamespace , " runtime " ) ; this . options = LoadTestOptions . readFromArgs ( args , testOptions ) ; this . sourceOptions = fromJsonString ( options . getSourceOptions ( ) , SyntheticBoundedIO . SyntheticSourceOptions . class ) ; this . stepOptions = fromJsonString ( options . getStepOptions ( ) , SyntheticStep . Options . class ) ; this . pipeline = Pipeline . create ( options ) ; }
charlesccychen/beam | public PipelineResult run ( ) throws IOException { long testStartTime = System . currentTimeMillis ( ) ; loadTest ( ) ; PipelineResult result = pipeline . run ( ) ; result . waitUntilFinish ( ) ; LoadTestResult testResult = LoadTestResult . create ( result , metricsNamespace , testStartTime ) ; ConsoleResultPublisher . publish ( testResult ) ; if ( options . getPublishToBigQuery ( ) ) { publishResultToBigQuery ( testResult ) ; } return result ; }
charlesccychen/beam | private void publishResultToBigQuery ( LoadTestResult testResult ) { String dataset = options . getBigQueryDataset ( ) ; String table = options . getBigQueryTable ( ) ; checkBigQueryOptions ( dataset , table ) ; ImmutableMap < String , String > schema = ImmutableMap . < String , String > builder ( ) . put ( " timestamp " , " timestamp " ) . put ( " runtime " , " float " ) . put ( " total _ bytes _ count " , " integer " ) . build ( ) ; BigQueryResultsPublisher . create ( dataset , schema ) . publish ( testResult , table ) ; }
charlesccychen/beam | < T extends SyntheticOptions > T fromJsonString ( String json , Class < T > type ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; T result = mapper . readValue ( json , type ) ; result . validate ( ) ; return result ; }
charlesccychen/beam | Optional < SyntheticStep > createStep ( String stepOptions ) throws IOException { if ( stepOptions != null && ! stepOptions . isEmpty ( ) ) { return Optional . of ( new SyntheticStep ( fromJsonString ( stepOptions , SyntheticStep . Options . class ) ) ) ; } else { return Optional . empty ( ) ; } }
charlesccychen/beam | PCollection < KV < byte [ ] , byte [ ] > > applyStepIfPresent ( PCollection < KV < byte [ ] , byte [ ] > > input , String name , Optional < SyntheticStep > syntheticStep ) { if ( syntheticStep . isPresent ( ) ) { return input . apply ( name , ParDo . of ( syntheticStep . get ( ) ) ) ; } else { return input ; } }
Kokil/opengse | private MutableWebAppContextParam ( ) { super ( ) ; }
Kokil/opengse | public String getParamName ( ) { return paramName ; }
Kokil/opengse | public void setParamName ( final String paramName ) { this . paramName = paramName ; }
Kokil/opengse | public String getParamValue ( ) { return paramValue ; }
Kokil/opengse | public void setParamValue ( final String paramValue ) { this . paramValue = paramValue ; }
msebire/intellij-community | SSAInstructionState ( int writeCount , int instructionIdx ) { myWriteCount = writeCount ; myInstructionIdx = instructionIdx ; }
msebire/intellij-community | public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof SSAInstructionState ) ) return false ; final SSAInstructionState ssaInstructionState = ( SSAInstructionState ) o ; if ( myInstructionIdx != ssaInstructionState . myInstructionIdx ) return false ; return Math . min ( 2 , myWriteCount ) == Math . min ( 2 , ssaInstructionState . myWriteCount ) ; }
msebire/intellij-community | public int hashCode ( ) { int result = Math . min ( 2 , myWriteCount ) ; result = 29 * result + myInstructionIdx ; return result ; }
msebire/intellij-community | int getWriteCount ( ) { return myWriteCount ; }
msebire/intellij-community | int getInstructionIdx ( ) { return myInstructionIdx ; }
msebire/intellij-community | ConvertReturnClientVisitor ( @ NotNull ControlFlow flow , @ NotNull ReturnStatementsVisitor visitor ) { super ( flow ) ; myAffectedReturns = new ArrayList < > ( ) ; myVisitor = visitor ; }
msebire/intellij-community | @ Override public void visitGoToInstruction ( final GoToInstruction instruction , final int offset , final int nextOffset ) { super . visitGoToInstruction ( instruction , offset , nextOffset ) ; if ( instruction . isReturn ) { final PsiElement element = myFlow . getElement ( offset ) ; if ( element instanceof PsiReturnStatement ) { final PsiReturnStatement returnStatement = ( PsiReturnStatement ) element ; myAffectedReturns . add ( returnStatement ) ; } } }
msebire/intellij-community | void afterProcessing ( ) throws IncorrectOperationException { myVisitor . visit ( myAffectedReturns ) ; }
msebire/intellij-community | ReturnPresentClientVisitor ( @ NotNull ControlFlow flow ) { myFlow = flow ; isNormalCompletion = new boolean [ myFlow . getSize ( ) + 1 ] ; isNormalCompletion [ myFlow . getSize ( ) ] = true ; }
msebire/intellij-community | @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; boolean isNormal = instruction . offset == nextOffset && nextOffset != offset + 1 ? ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] : isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; }
msebire/intellij-community | @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; isNormalCompletion [ offset ] |= ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] ; }
msebire/intellij-community | @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; isNormalCompletion [ offset ] |= ! instruction . isReturn && isNormalCompletion [ nextOffset ] ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; boolean isNormal = isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; }
msebire/intellij-community | @ Override @ NotNull public Boolean getResult ( ) { return ! isNormalCompletion [ 0 ] ; }
msebire/intellij-community | UnreachableStatementClientVisitor ( @ NotNull ControlFlow flow ) { myFlow = flow ; }
msebire/intellij-community | @ Override public PsiElement getResult ( ) { for ( int i = 0 ; i < processedInstructions . length ; i ++ ) { if ( ! processedInstructions [ i ] ) { PsiElement element = myFlow . getElement ( i ) ; final PsiElement unreachableParent = getUnreachableExpressionParent ( element ) ; if ( unreachableParent != null ) return unreachableParent ; if ( element == null || ! PsiUtil . isStatement ( element ) ) continue ; if ( element . getParent ( ) instanceof PsiExpression ) continue ; while ( element instanceof PsiExpression ) { element = element . getParent ( ) ; } if ( element instanceof PsiStatement && element . getParent ( ) instanceof PsiForStatement && element == ( ( PsiForStatement ) element . getParent ( ) ) . getUpdate ( ) ) { continue ; } final int endOffset = myFlow . getEndOffset ( element ) ; if ( endOffset != i + 1 ) continue ; final int startOffset = myFlow . getStartOffset ( element ) ; if ( 0 <= startOffset && startOffset < processedInstructions . length && processedInstructions [ startOffset ] ) continue ; final PsiElement enclosingStatement = getEnclosingUnreachableStatement ( element ) ; return enclosingStatement != null ? enclosingStatement : element ; } } return null ; }
msebire/intellij-community | ControlFlowEdge ( int from , int to ) { myFrom = from ; myTo = to ; }
msebire/intellij-community | @ Override public String toString ( ) { return myFrom + " - > " + myTo ; }
msebire/intellij-community | WalkThroughStack ( int initialSize ) { if ( initialSize < 2 ) initialSize = 2 ; oldOffsets = new int [ initialSize ] ; newOffsets = new int [ initialSize ] ; }
msebire/intellij-community | void push ( int oldOffset , int newOffset ) { LOG . assertTrue ( oldOffset >= 0 , " negative ▁ offset ▁ is ▁ pushed ▁ to ▁ walk - through ▁ stack " ) ; if ( size >= newOffsets . length ) { oldOffsets = ArrayUtil . realloc ( oldOffsets , size * 3 / 2 ) ; newOffsets = ArrayUtil . realloc ( newOffsets , size * 3 / 2 ) ; } oldOffsets [ size ] = oldOffset ; newOffsets [ size ] = newOffset ; size ++ ; }
msebire/intellij-community | void push ( int offset ) { push ( offset , - 1 ) ; }
msebire/intellij-community | int peekOldOffset ( ) { return oldOffsets [ size - 1 ] ; }
msebire/intellij-community | int popNewOffset ( ) { return newOffsets [ -- size ] ; }
msebire/intellij-community | boolean isEmpty ( ) { return size == 0 ; }
msebire/intellij-community | @ Override public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( s . length ( ) != 0 ) s . append ( ' ▁ ' ) ; if ( newOffsets [ i ] != - 1 ) { s . append ( ' ( ' ) . append ( oldOffsets [ i ] ) . append ( " - > " ) . append ( newOffsets [ i ] ) . append ( ' ) ' ) ; } else { s . append ( ' [ ' ) . append ( oldOffsets [ i ] ) . append ( ' ] ' ) ; } } return s . toString ( ) ; }
msebire/intellij-community | @ NotNull public CopyOnWriteList add ( @ NotNull VariableInfo value ) { CopyOnWriteList newList = new CopyOnWriteList ( ) ; List < VariableInfo > list = getList ( ) ; for ( final VariableInfo variableInfo : list ) { if ( ! value . equals ( variableInfo ) ) { newList . list . add ( variableInfo ) ; } } newList . list . add ( value ) ; return newList ; }
msebire/intellij-community | @ NotNull public CopyOnWriteList remove ( @ NotNull VariableInfo value ) { CopyOnWriteList newList = new CopyOnWriteList ( ) ; List < VariableInfo > list = getList ( ) ; for ( final VariableInfo variableInfo : list ) { if ( ! value . equals ( variableInfo ) ) { newList . list . add ( variableInfo ) ; } } return newList ; }
msebire/intellij-community | @ NotNull public List < VariableInfo > getList ( ) { return list ; }
msebire/intellij-community | CopyOnWriteList ( ) { this ( Collections . emptyList ( ) ) ; }
msebire/intellij-community | CopyOnWriteList ( @ NotNull VariableInfo ... infos ) { this ( Arrays . asList ( infos ) ) ; }
msebire/intellij-community | CopyOnWriteList ( @ NotNull Collection < ? extends VariableInfo > infos ) { list = new SmartList < > ( infos ) ; }
msebire/intellij-community | @ NotNull public CopyOnWriteList addAll ( @ NotNull CopyOnWriteList addList ) { CopyOnWriteList newList = new CopyOnWriteList ( ) ; List < VariableInfo > list = getList ( ) ; newList . list . addAll ( list ) ; List < VariableInfo > toAdd = addList . getList ( ) ; for ( final VariableInfo variableInfo : toAdd ) { if ( ! newList . list . contains ( variableInfo ) ) { newList . list . add ( variableInfo ) ; } } return newList ; }
msebire/intellij-community | public VariableInfo ( @ NotNull PsiVariable variable , @ Nullable PsiElement expression ) { this . variable = variable ; this . expression = expression ; }
msebire/intellij-community | public boolean equals ( Object o ) { return this == o || o instanceof VariableInfo && variable . equals ( ( ( VariableInfo ) o ) . variable ) ; }
msebire/intellij-community | public int hashCode ( ) { return variable . hashCode ( ) ; }
msebire/intellij-community | ReadBeforeWriteClientVisitor ( @ NotNull ControlFlow flow , boolean localVariablesOnly ) { myFlow = flow ; this . localVariablesOnly = localVariablesOnly ; readVariables = new CopyOnWriteList [ myFlow . getSize ( ) + 1 ] ; }
msebire/intellij-community | @ Override public void visitReadVariableInstruction ( ReadVariableInstruction instruction , int offset , int nextOffset ) { CopyOnWriteList readVars = readVariables [ Math . min ( nextOffset , myFlow . getSize ( ) ) ] ; final PsiVariable variable = instruction . variable ; if ( ! localVariablesOnly || ! isMethodParameter ( variable ) ) { final PsiReferenceExpression expression = getEnclosingReferenceExpression ( myFlow . getElement ( offset ) , variable ) ; if ( expression != null ) { readVars = CopyOnWriteList . add ( readVars , new VariableInfo ( variable , expression ) ) ; } } merge ( offset , readVars , readVariables ) ; }
msebire/intellij-community | @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { CopyOnWriteList readVars = readVariables [ Math . min ( nextOffset , myFlow . getSize ( ) ) ] ; if ( readVars == null ) return ; final PsiVariable variable = instruction . variable ; if ( ! localVariablesOnly || ! isMethodParameter ( variable ) ) { readVars = readVars . remove ( new VariableInfo ( variable , null ) ) ; } merge ( offset , readVars , readVariables ) ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { merge ( offset , readVariables [ Math . min ( nextOffset , myFlow . getSize ( ) ) ] , readVariables ) ; }
msebire/intellij-community | @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { visitInstruction ( instruction , offset , nextOffset ) ; for ( int i = instruction . procBegin ; i <= instruction . procEnd ; i ++ ) { readVariables [ i ] = null ; } }
msebire/intellij-community | @ Override @ NotNull public List < PsiReferenceExpression > getResult ( ) { return getResult ( 0 ) ; }
msebire/intellij-community | @ NotNull public List < PsiReferenceExpression > getResult ( int startOffset ) { final CopyOnWriteList topReadVariables = readVariables [ startOffset ] ; if ( topReadVariables == null ) return Collections . emptyList ( ) ; final List < PsiReferenceExpression > result = new ArrayList < > ( ) ; List < VariableInfo > list = topReadVariables . getList ( ) ; for ( final VariableInfo variableInfo : list ) { result . add ( ( PsiReferenceExpression ) variableInfo . expression ) ; } return result ; }
msebire/intellij-community | InitializedTwiceClientVisitor ( @ NotNull ControlFlow flow , final int startOffset ) { myFlow = flow ; myStartOffset = startOffset ; writtenVariables = new CopyOnWriteList [ myFlow . getSize ( ) + 1 ] ; writtenTwiceVariables = new CopyOnWriteList [ myFlow . getSize ( ) + 1 ] ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { final int safeNextOffset = Math . min ( nextOffset , myFlow . getSize ( ) ) ; CopyOnWriteList writeVars = writtenVariables [ safeNextOffset ] ; CopyOnWriteList writeTwiceVars = writtenTwiceVariables [ safeNextOffset ] ; if ( instruction instanceof WriteVariableInstruction ) { final PsiVariable variable = ( ( WriteVariableInstruction ) instruction ) . variable ; final PsiElement latestWriteVarExpression = getLatestWriteVarExpression ( writeVars , variable ) ; if ( latestWriteVarExpression == null ) { final PsiElement expression = getExpression ( myFlow . getElement ( offset ) ) ; writeVars = CopyOnWriteList . add ( writeVars , new VariableInfo ( variable , expression ) ) ; } else { writeTwiceVars = CopyOnWriteList . add ( writeTwiceVars , new VariableInfo ( variable , latestWriteVarExpression ) ) ; } } merge ( offset , writeVars , writtenVariables ) ; merge ( offset , writeTwiceVars , writtenTwiceVariables ) ; }
msebire/intellij-community | @ Override @ NotNull public Collection < VariableInfo > getResult ( ) { final CopyOnWriteList writtenTwiceVariable = writtenTwiceVariables [ myStartOffset ] ; if ( writtenTwiceVariable == null ) return Collections . emptyList ( ) ; return writtenTwiceVariable . getList ( ) ; }
msebire/intellij-community | ControlFlowGraph ( int size ) { nextOffsets = new int [ size ] [ ] ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > size ( ) ) nextOffset = size ( ) ; addArc ( offset , nextOffset ) ; }
msebire/intellij-community | void addArc ( int offset , int nextOffset ) { if ( nextOffsets [ offset ] == null ) { nextOffsets [ offset ] = new int [ ] { nextOffset , - 1 } ; } else { int [ ] targets = nextOffsets [ offset ] ; if ( ArrayUtil . indexOf ( targets , nextOffset ) < 0 ) { int freeIndex = ArrayUtil . indexOf ( targets , - 1 ) ; if ( freeIndex >= 0 ) { targets [ freeIndex ] = nextOffset ; } else { int oldLength = targets . length ; nextOffsets [ offset ] = targets = ArrayUtil . realloc ( targets , oldLength * 3 / 2 ) ; Arrays . fill ( targets , oldLength , targets . length , - 1 ) ; targets [ oldLength ] = nextOffset ; } } } }
msebire/intellij-community | @ NotNull int [ ] getNextOffsets ( int offset ) { return nextOffsets [ offset ] != null ? nextOffsets [ offset ] : ArrayUtil . EMPTY_INT_ARRAY ; }
msebire/intellij-community | int size ( ) { return nextOffsets . length ; }
msebire/intellij-community | @ Override public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < nextOffsets . length ; i ++ ) { int [ ] targets = nextOffsets [ i ] ; if ( targets != null && targets . length != 0 && targets [ 0 ] != - 1 ) { if ( s . length ( ) != 0 ) s . append ( ' ▁ ' ) ; s . append ( ' ( ' ) . append ( i ) . append ( " - > " ) ; for ( int j = 0 ; j < targets . length && targets [ j ] != - 1 ; j ++ ) { if ( j != 0 ) s . append ( " , " ) ; s . append ( targets [ j ] ) ; } s . append ( ' ) ' ) ; } } return s . toString ( ) ; }
msebire/intellij-community | boolean depthFirstSearch ( final int startOffset ) { return depthFirstSearch ( startOffset , new BitSet ( size ( ) ) ) ; }
msebire/intellij-community | boolean depthFirstSearch ( final int startOffset , @ NotNull BitSet visitedOffsets ) { IntStack walkThroughStack = new IntStack ( Math . max ( size ( ) / 2 , 2 ) ) ; visitedOffsets . clear ( ) ; walkThroughStack . push ( startOffset ) ; while ( ! walkThroughStack . empty ( ) ) { int currentOffset = walkThroughStack . pop ( ) ; if ( currentOffset < size ( ) && ! visitedOffsets . get ( currentOffset ) ) { visitedOffsets . set ( currentOffset ) ; int [ ] nextOffsets = getNextOffsets ( currentOffset ) ; for ( int nextOffset : nextOffsets ) { if ( nextOffset == - 1 ) break ; if ( isComplete ( currentOffset , nextOffset ) ) { return true ; } walkThroughStack . push ( nextOffset ) ; } } } return false ; }
msebire/intellij-community | @ Override public Void getResult ( ) { return null ; }
msebire/intellij-community | boolean isComplete ( int offset , int nextOffset ) { return false ; }
msebire/intellij-community | void buildFrom ( @ NotNull ControlFlow flow ) { ControlFlowUtil . depthFirstSearch ( flow , this , 0 , flow . getSize ( ) ) ; }
briljant/briljant | @ Test public void testArrayMethods ( ) throws Exception { Series s = Series . of ( " dsadsa " , 20.0 , 30.0 , 40.0 ) ; s . setIndex ( Index . of ( " a " , " b " , " c " , " d " ) ) ; System . out . println ( s . getIndex ( ) ) ; s = s . reindex ( Index . of ( " AAA " , " BBB " , " CCC " , " DDD " ) ) ; Series b = s . reshape ( 2 , 2 ) ; System . out . println ( b . getIndex ( ) ) ; System . out . println ( b ) ; for ( Object key : s . getIndex ( ) ) { System . out . println ( key + " ▁ " + b . get ( key ) + b . get ( key ) . getClass ( ) ) ; } System . out . println ( b . asArray ( ) ) ; List < Series > vsplit = Arrays . vsplit ( b , 2 ) ; System . out . println ( vsplit . get ( 0 ) ) ; }
briljant/briljant | @ Test public void testSet_BooleanArray ( ) throws Exception { Series a = getBuilder ( ) . addAll ( Series . of ( 1 , 2 , 3 , 4 , 5 ) ) . build ( ) ; Series expected = getBuilder ( ) . addAll ( Series . of ( 1 , 2 , 320 , 320 , 320 ) ) . build ( ) ; a . set ( a . where ( Double . class , v -> v > 2 ) , 320 ) ; System . out . println ( IntSeries . range ( 2000 ) . sort ( SortOrder . ASC ) ) ; Assert . assertEquals ( expected , a ) ; }
briljant/briljant | @ Test public void testHead ( ) throws Exception { Series a = new TypeInferenceBuilder ( ) . set ( " a " , 10 ) . set ( " b " , 100 ) . set ( " c " , 1 ) . set ( " d " , 11 ) . build ( ) ; System . out . println ( a ) ; Series sort = a . sort ( SortOrder . ASC ) ; System . out . println ( sort ) ; }
briljant/briljant | @ Test public void testTestSort ( ) throws Exception { Series a = new TypeInferenceBuilder ( ) . set ( 40 , 3 ) . set ( 30 , 2 ) . set ( 20 , 4 ) . set ( 10 , 1 ) . build ( ) ; Series v = a . sort ( SortOrder . DESC ) ; System . out . println ( v . asList ( Object . class ) ) ; System . out . println ( v ) ; }
plasma-framework/plasma | public synchronized String getElementText ( ) throws XMLStreamException { if ( closed ) { throw new XMLStreamException ( " Stream ▁ has ▁ been ▁ closed " ) ; } StringBuffer buffer = new StringBuffer ( ) ; while ( true ) { XMLEvent event = nextEvent ( ) ; if ( event . isCharacters ( ) ) { if ( event . getEventType ( ) != XMLEvent . SPACE ) { buffer . append ( event . asCharacters ( ) . getData ( ) ) ; } } else if ( event . isEndElement ( ) ) { break ; } else { throw new XMLStreamException ( " Non - text ▁ event ▁ encountered ▁ in ▁ getElementText ( ) : ▁ " + event ) ; } } return buffer . toString ( ) ; }
plasma-framework/plasma | public XMLEvent nextTag ( ) throws XMLStreamException { if ( closed ) { throw new XMLStreamException ( " Stream ▁ has ▁ been ▁ closed " ) ; } XMLEvent event ; do { if ( hasNext ( ) ) { event = nextEvent ( ) ; if ( event . isStartElement ( ) || event . isEndElement ( ) ) { return event ; } else if ( event . isCharacters ( ) ) { if ( ! event . asCharacters ( ) . isWhiteSpace ( ) ) { throw new XMLStreamException ( " Non - ignorable ▁ space ▁ encountered " ) ; } } else if ( ! ( event instanceof Comment ) ) { throw new XMLStreamException ( " Non - ignorable ▁ event ▁ encountered : ▁ " + event ) ; } } else { throw new XMLStreamException ( " Ran ▁ out ▁ of ▁ events ▁ in ▁ nextTag ( ) " ) ; } } while ( ! event . isStartElement ( ) && ! event . isEndElement ( ) ) ; return event ; }
plasma-framework/plasma | public Object getProperty ( String name ) throws IllegalArgumentException { throw new IllegalArgumentException ( " Property ▁ not ▁ supported : ▁ " + name ) ; }
plasma-framework/plasma | public synchronized void close ( ) throws XMLStreamException { if ( ! closed ) { closed = true ; } }
plasma-framework/plasma | public Object next ( ) { try { return nextEvent ( ) ; } catch ( XMLStreamException e ) { NoSuchElementException ex = new NoSuchElementException ( " Error ▁ getting ▁ next ▁ event " ) ; ex . initCause ( e ) ; throw ex ; } }
plasma-framework/plasma | public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
Karm/undertow | private ConnectionUtils ( ) { }
domokato/gdx-ai | public Box2dCollisionAvoidanceTest ( SteeringBehaviorsTest container ) { super ( container , " Collision ▁ Avoidance " ) ; }
domokato/gdx-ai | @ Override public void create ( ) { super . create ( ) ; drawDebug = true ; shapeRenderer = new ShapeRenderer ( ) ; spriteBatch = new SpriteBatch ( ) ; characters = new Array < Box2dSteeringEntity > ( ) ; proximities = new Array < Box2dRadiusProximity > ( ) ; for ( int i = 0 ; i < 60 ; i ++ ) { final Box2dSteeringEntity character = createSteeringEntity ( world , container . greenFish , false ) ; character . setMaxLinearSpeed ( 2 ) ; character . setMaxLinearAcceleration ( 4 ) ; Box2dRadiusProximity proximity = new Box2dRadiusProximity ( character , world , character . getBoundingRadius ( ) * 4 ) ; proximities . add ( proximity ) ; if ( i == 0 ) char0Proximity = proximity ; CollisionAvoidance < Vector2 > collisionAvoidanceSB = new CollisionAvoidance < Vector2 > ( character , proximity ) ; Wander < Vector2 > wanderSB = new Wander < Vector2 > ( character ) . setFaceEnabled ( false ) . setLimiter ( new LinearAccelerationLimiter ( 5 ) ) . setWanderOffset ( 3 ) . setWanderOrientation ( 5 ) . setWanderRadius ( 1 ) . setWanderRate ( MathUtils . PI2 * 4 ) ; PrioritySteering < Vector2 > prioritySteeringSB = new PrioritySteering < Vector2 > ( character , 0.0001f ) ; prioritySteeringSB . add ( collisionAvoidanceSB ) ; prioritySteeringSB . add ( wanderSB ) ; character . setSteeringBehavior ( prioritySteeringSB ) ; setRandomNonOverlappingPosition ( character , characters , Box2dSteeringTest . pixelsToMeters ( 5 ) ) ; characters . add ( character ) ; } inputProcessor = null ; Table detailTable = new Table ( container . skin ) ; detailTable . row ( ) ; final Label labelMaxLinAcc = new Label ( " Max . Linear ▁ Acc . [ " + characters . get ( 0 ) . getMaxLinearAcceleration ( ) + " ] " , container . skin ) ; detailTable . add ( labelMaxLinAcc ) ; detailTable . row ( ) ; Slider maxLinAcc = new Slider ( 0 , 30 , .1f , false , container . skin ) ; maxLinAcc . setValue ( characters . get ( 0 ) . getMaxLinearAcceleration ( ) ) ; maxLinAcc . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { Slider slider = ( Slider ) actor ; for ( int i = 0 ; i < characters . size ; i ++ ) characters . get ( i ) . setMaxLinearAcceleration ( slider . getValue ( ) ) ; labelMaxLinAcc . setText ( " Max . Linear ▁ Acc . [ " + slider . getValue ( ) + " ] " ) ; } } ) ; detailTable . add ( maxLinAcc ) ; detailTable . row ( ) ; final Label labelProximityRadius = new Label ( " Proximity ▁ Radius ▁ [ " + proximities . get ( 0 ) . getDetectionRadius ( ) + " ] " , container . skin ) ; detailTable . add ( labelProximityRadius ) ; detailTable . row ( ) ; Slider proximityRadius = new Slider ( 0 , 10 , .1f , false , container . skin ) ; proximityRadius . setValue ( proximities . get ( 0 ) . getDetectionRadius ( ) ) ; proximityRadius . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { Slider slider = ( Slider ) actor ; for ( int i = 0 ; i < proximities . size ; i ++ ) proximities . get ( i ) . setDetectionRadius ( slider . getValue ( ) ) ; labelProximityRadius . setText ( " Proximity ▁ Radius ▁ [ " + slider . getValue ( ) + " ] " ) ; } } ) ; detailTable . add ( proximityRadius ) ; detailTable . row ( ) ; addSeparator ( detailTable ) ; detailTable . row ( ) ; final Label labelMaxLinSpeed = new Label ( " Max . Linear ▁ Speed . [ " + characters . get ( 0 ) . getMaxLinearSpeed ( ) + " ] " , container . skin ) ; detailTable . add ( labelMaxLinSpeed ) ; detailTable . row ( ) ; Slider maxLinSpeed = new Slider ( 0 , 20 , .5f , false , container . skin ) ; maxLinSpeed . setValue ( characters . get ( 0 ) . getMaxLinearSpeed ( ) ) ; maxLinSpeed . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { Slider slider = ( Slider ) actor ; for ( int i = 0 ; i < characters . size ; i ++ ) characters . get ( i ) . setMaxLinearSpeed ( slider . getValue ( ) ) ; labelMaxLinSpeed . setText ( " Max . Linear ▁ Speed . [ " + slider . getValue ( ) + " ] " ) ; } } ) ; detailTable . add ( maxLinSpeed ) ; detailTable . row ( ) ; CheckBox debug = new CheckBox ( " Draw ▁ Proximity " , container . skin ) ; debug . setChecked ( drawDebug ) ; debug . addListener ( new ClickListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { CheckBox checkBox = ( CheckBox ) event . getListenerActor ( ) ; drawDebug = checkBox . isChecked ( ) ; } } ) ; detailTable . add ( debug ) ; detailWindow = createDetailWindow ( detailTable ) ; }
domokato/gdx-ai | @ Override public void update ( ) { super . update ( ) ; float deltaTime = GdxAI . getTimepiece ( ) . getDeltaTime ( ) ; for ( int i = 0 ; i < characters . size ; i ++ ) { characters . get ( i ) . update ( deltaTime ) ; } }
domokato/gdx-ai | @ Override public void draw ( ) { spriteBatch . begin ( ) ; for ( int i = 0 ; i < characters . size ; i ++ ) { Box2dSteeringEntity character = characters . get ( i ) ; character . draw ( spriteBatch ) ; } spriteBatch . end ( ) ; if ( drawDebug ) { Steerable < Vector2 > steerable = characters . get ( 0 ) ; shapeRenderer . begin ( ShapeType . Line ) ; shapeRenderer . setColor ( 0 , 1 , 0 , 1 ) ; int centerX = Box2dSteeringTest . metersToPixels ( steerable . getPosition ( ) . x ) ; int centerY = Box2dSteeringTest . metersToPixels ( steerable . getPosition ( ) . y ) ; int radius = Box2dSteeringTest . metersToPixels ( char0Proximity . getDetectionRadius ( ) ) ; shapeRenderer . circle ( centerX , centerY , radius ) ; shapeRenderer . end ( ) ; } }
domokato/gdx-ai | @ Override public void dispose ( ) { super . dispose ( ) ; shapeRenderer . dispose ( ) ; spriteBatch . dispose ( ) ; }
kevinearls/camel | protected AbstractXmlApplicationContext createApplicationContext ( ) { return new ClassPathXmlApplicationContext ( " org / apache / camel / spring / config / PackageResolverTest . xml " ) ; }
kevinearls/camel | @ Test public void testSetAcceptableSchema ( ) throws Exception { DefaultPackageScanClassResolver resolver = ( DefaultPackageScanClassResolver ) context . getPackageScanClassResolver ( ) ; assertNotNull ( resolver ) ; assertTrue ( " We ▁ should ▁ accept ▁ the ▁ test : ! " , resolver . isAcceptableScheme ( " test : // test " ) ) ; assertTrue ( " We ▁ should ▁ accept ▁ the ▁ test2 : ! " , resolver . isAcceptableScheme ( " test2 : // test " ) ) ; }
jack0707/coldweather | private ColdWeatherDB ( Context context ) { ColdWeatherOpendHelper dbHelper = new ColdWeatherOpendHelper ( context , DB_NAME , null , VERSION ) ; db = dbHelper . getWritableDatabase ( ) ; }
jack0707/coldweather | public void saveProvince ( Province province ) { if ( province != null ) { ContentValues values = new ContentValues ( ) ; values . put ( " province _ name " , province . getProvinceName ( ) ) ; values . put ( " province _ code " , province . getProvinceCode ( ) ) ; db . insert ( " Province " , null , values ) ; } }
jack0707/coldweather | public List < Province > loadProvinces ( ) { List < Province > list = new ArrayList < > ( ) ; Cursor cursor = db . query ( " Province " , null , null , null , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { do { Province province = new Province ( ) ; province . setId ( cursor . getInt ( cursor . getColumnIndex ( " id " ) ) ) ; province . setProvinceName ( cursor . getString ( cursor . getColumnIndex ( " province _ name " ) ) ) ; province . setProvinceCode ( cursor . getString ( cursor . getColumnIndex ( " province _ code " ) ) ) ; list . add ( province ) ; } while ( cursor . moveToNext ( ) ) ; } return list ; }
jack0707/coldweather | public void saveCity ( City city ) { if ( city != null ) { ContentValues values = new ContentValues ( ) ; values . put ( " city _ name " , city . getCityName ( ) ) ; values . put ( " city _ code " , city . getCityCode ( ) ) ; values . put ( " province _ id " , city . getProvinceId ( ) ) ; db . insert ( " City " , null , values ) ; } }
jack0707/coldweather | public List < City > loadCities ( int provinceId ) { List < City > list = new ArrayList < City > ( ) ; System . out . println ( " hello " ) ; Cursor cursor = db . query ( " City " , null , " province _ id ▁ = ▁ ? " , new String [ ] { String . valueOf ( provinceId ) } , null , null , null ) ; System . out . println ( "1" ) ; if ( cursor . moveToFirst ( ) ) { do { City city = new City ( ) ; System . out . println ( " faile " ) ; city . setId ( cursor . getInt ( cursor . getColumnIndex ( " id " ) ) ) ; city . setCityName ( cursor . getString ( cursor . getColumnIndex ( " city _ name " ) ) ) ; city . setCityCode ( cursor . getString ( cursor . getColumnIndex ( " city _ code " ) ) ) ; city . setProvinceId ( provinceId ) ; list . add ( city ) ; System . out . println ( " success " ) ; } while ( cursor . moveToNext ( ) ) ; } return list ; }
jack0707/coldweather | public void saveCounty ( County county ) { if ( county != null ) { ContentValues values = new ContentValues ( ) ; values . put ( " county _ name " , county . getCountyName ( ) ) ; values . put ( " county _ code " , county . getCountyCode ( ) ) ; values . put ( " city _ id " , county . getCityId ( ) ) ; db . insert ( " County " , null , values ) ; } }
jack0707/coldweather | public List < County > loadCounties ( int cityId ) { List < County > list = new ArrayList < County > ( ) ; Cursor cursor = db . query ( " County " , null , " city _ id ▁ = ▁ ? " , new String [ ] { String . valueOf ( cityId ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { do { County county = new County ( ) ; county . setId ( cursor . getInt ( cursor . getColumnIndex ( " id " ) ) ) ; county . setCountyName ( cursor . getString ( cursor . getColumnIndex ( " county _ name " ) ) ) ; county . setCountyCode ( cursor . getString ( cursor . getColumnIndex ( " county _ code " ) ) ) ; county . setCityId ( cityId ) ; list . add ( county ) ; } while ( cursor . moveToNext ( ) ) ; } return list ; }
nihaocun/kirbydownload | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Theme . setClassTheme ( this ) ; setContentView ( R . layout . activity_main ) ; setApply ( ) ; toolbar = ( Toolbar ) findViewById ( R . id . 标题栏 ) ; setSupportActionBar ( toolbar ) ; toolbar . setSubtitle ( R . string . ziyuan ) ; replaceFragment ( new MainGameFragment ( ) ) ; u = BmobUser . getCurrentUser ( MyUser . class ) ; bmb = ( BoomMenuButton ) findViewById ( R . id . bmb ) ; assert bmb != null ; initBmb ( ) ; thePay ( ) ; }
nihaocun/kirbydownload | private void thePay ( ) { SharedPreferences 状态 = getSharedPreferences ( " boolean " , 0 ) ; boolean 状态 _ = 状态 . getBoolean ( " thefirst _ main " , false ) ; if ( 状态 _ == false ) { int pay_code = ( int ) ( 1 + Math . random ( ) * ( 10 - 1 + 1 ) ) ; if ( pay_code == 1 || pay_code == 3 || pay_code == 7 || pay_code == 10 ) { showPay ( ) ; } } }
nihaocun/kirbydownload | private void initBmb ( ) { if ( null == u ) { HamButton . Builder user = new HamButton . Builder ( ) . normalTextRes ( R . string . login_title ) . normalImageRes ( R . drawable . ic_account ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { replaceFragment ( new MainLoginFragment ( ) ) ; toolbar . setSubtitle ( R . string . login_title ) ; } } ) ; bmb . addBuilder ( user ) ; } else { HamButton . Builder user = new HamButton . Builder ( ) . normalText ( getResources ( ) . getString ( R . string . hello ) + u . getUsername ( ) ) . normalImageRes ( R . drawable . ic_account ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { Intent user = new Intent ( MainActivity . this , UserActivity . class ) ; IntentUtil . startActivityWithAnim ( user , MainActivity . this ) ; } } ) ; bmb . addBuilder ( user ) ; } HamButton . Builder game = new HamButton . Builder ( ) . normalTextRes ( R . string . ziyuan ) . normalImageRes ( R . drawable . ic_game ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . ziyuan ) ; replaceFragment ( new MainGameFragment ( ) ) ; } } ) ; bmb . addBuilder ( game ) ; HamButton . Builder jsz = new HamButton . Builder ( ) . normalTextRes ( R . string . jsz_title ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . jsz_title ) ; replaceFragment ( new MainJszFragment ( ) ) ; } } ) ; bmb . addBuilder ( jsz ) ; HamButton . Builder video = new HamButton . Builder ( ) . normalTextRes ( R . string . video_title ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . video_title ) ; replaceFragment ( new MainVideoFragment ( ) ) ; } } ) ; bmb . addBuilder ( video ) ; HamButton . Builder mess = new HamButton . Builder ( ) . normalTextRes ( R . string . talk ) . normalImageRes ( R . drawable . ic_talk2 ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . talk ) ; replaceFragment ( new MainMessFragment ( ) ) ; } } ) ; bmb . addBuilder ( mess ) ; }
nihaocun/kirbydownload | private void showPay ( ) { AlertDialog . Builder dialog = new AlertDialog . Builder ( this ) . setTitle ( " 捐赠 " ) . setMessage ( " 你好 ， 我是kirby ▁ ▁ download的开发者 , 感谢你使用我开发的app \n 这个app从开发到服务器一直都是我自费的 ， 作为一个学生 ， 实在是坚持不住 。 所以 ， 请求各位大佬投喂 ， 或者点击免费捐赠也可以的哦 ， 谢谢٩(๑ • ◡ - ๑)۶" ) . setPositiveButton ( " 捐赠 " , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent pay = new Intent ( MainActivity . this , PayActivity . class ) ; IntentUtil . startActivityWithAnim ( pay , MainActivity . this ) ; } } ) . setNegativeButton ( " 取消 " , null ) . setNeutralButton ( " 不再提醒 " , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { SharedPreferences . Editor t = getSharedPreferences ( " boolean " , 0 ) . edit ( ) ; t . putBoolean ( " thefirst _ main " , true ) ; t . apply ( ) ; } } ) ; dialog . show ( ) ; }
nihaocun/kirbydownload | public void replaceFragment ( Fragment fragment ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; FragmentTransaction transaction = fragmentManager . beginTransaction ( ) ; transaction . replace ( R . id . main_fragment , fragment ) ; transaction . commit ( ) ; }
nihaocun/kirbydownload | private void setApply ( ) { SharedPreferences . Editor y = getSharedPreferences ( " string " , 0 ) . edit ( ) ; y . putString ( " 主机名称 " , "0" ) ; y . putString ( " 游戏或模拟器名称 " , "0" ) ; y . apply ( ) ; }
nihaocun/kirbydownload | @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; SharedPreferences . Editor y = getSharedPreferences ( " string " , 0 ) . edit ( ) ; y . putString ( " 主机名称 " , "0" ) ; y . putString ( " 游戏或模拟器名称 " , "0" ) ; y . apply ( ) ; }
nihaocun/kirbydownload | public void setCustomTheme ( int i ) { Theme . setTheme ( MainActivity . this , i ) ; SharedPreferences . Editor y = getSharedPreferences ( " customtheme " , 0 ) . edit ( ) ; y . putInt ( " id " , i ) ; y . apply ( ) ; open ( ) ; }
nihaocun/kirbydownload | public void open ( ) { Intent intent = getIntent ( ) ; overridePendingTransition ( android . R . anim . fade_in , android . R . anim . fade_out ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NO_ANIMATION ) ; finish ( ) ; IntentUtil . startActivityWithAnim ( intent , MainActivity . this ) ; }
nihaocun/kirbydownload | public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . toolbar , menu ) ; return true ; }
nihaocun/kirbydownload | @ Override public void onOpenAnimationStart ( ) { }
nihaocun/kirbydownload | @ Override public void onOpenAnimationEnd ( ) { }
nihaocun/kirbydownload | @ Override public void onCloseAnimationStart ( ) { SharedPreferences console = getSharedPreferences ( " string " , 0 ) ; String edit_ 内容 = console . getString ( " Message " , " " ) ; MessageBmob mess = new MessageBmob ( ) ; mess . setMessage ( edit_ 内容 ) ; mess . setNickname ( u . getUsername ( ) ) ; mess . save ( new SaveListener < String > ( ) { @ Override public void done ( String objectId , BmobException e ) { if ( e == null ) { MainMessFragment main_mess = ( MainMessFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . main_fragment ) ; main_mess . getMessage ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . mess_true ) + objectId , Toast . LENGTH_SHORT ) . show ( ) ; SharedPreferences y = getSharedPreferences ( " string " , 0 ) ; SharedPreferences . Editor edit = y . edit ( ) ; edit . putString ( " Message " , " " ) ; edit . apply ( ) ; } else { Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . mess_false ) + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; }
nihaocun/kirbydownload | @ Override public void onCloseAnimationEnd ( ) { }
nihaocun/kirbydownload | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : drawerLayout . openDrawer ( GravityCompat . START ) ; break ; case R . id . theme : SharedPreferences c = getSharedPreferences ( " customtheme " , 0 ) ; final int itemSelected = c . getInt ( " id " , 0 ) ; AlertDialog . Builder theme = new AlertDialog . Builder ( MainActivity . this ) ; theme . setTitle ( R . string . theme_title ) ; Integer [ ] res = new Integer [ ] { R . drawable . buletheme , R . drawable . redtheme , R . drawable . purpletheme , R . drawable . lindigotheme , R . drawable . tealtheme , R . drawable . greentheme , R . drawable . orangetheme , R . drawable . browntheme , R . drawable . bluegreytheme , R . drawable . yellowtheme , R . drawable . kirbytheme , R . drawable . darktheme } ; List < Integer > list = Arrays . asList ( res ) ; ColorListAdapter adapter = new ColorListAdapter ( MainActivity . this , list ) ; adapter . setCheckItem ( itemSelected ) ; GridView gridView = ( GridView ) LayoutInflater . from ( MainActivity . this ) . inflate ( R . layout . colors_panel_layout , null ) ; gridView . setStretchMode ( GridView . STRETCH_COLUMN_WIDTH ) ; gridView . setCacheColorHint ( 0 ) ; gridView . setAdapter ( adapter ) ; theme . setView ( gridView ) ; final AlertDialog dialog = theme . show ( ) ; gridView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { dialog . dismiss ( ) ; if ( itemSelected != position ) { setCustomTheme ( position ) ; } } } ) ; break ; case R . id . about : Intent about = new Intent ( MainActivity . this , AboutActivity . class ) ; IntentUtil . startActivityWithAnim ( about , MainActivity . this ) ; break ; case R . id . app : AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . tj_app ) ; String [ ] items = { " ZArchiver \n " + getResources ( ) . getString ( R . string . app_ZArchiver ) } ; builder . setItems ( items , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { switch ( i ) { case 0 : downloadappApk ( " ZArchiver " ) ; break ; } } } ) ; builder . create ( ) ; builder . show ( ) ; break ; case R . id . pay : Intent pay = new Intent ( MainActivity . this , PayActivity . class ) ; IntentUtil . startActivityWithAnim ( pay , MainActivity . this ) ; break ; default : } return true ; }
nihaocun/kirbydownload | public void downloadappApk ( final String app_name ) { progressDialog = new ProgressDialog ( MainActivity . this ) ; progressDialog . setMessage ( getResources ( ) . getString ( R . string . link_bmob ) ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_HORIZONTAL ) ; progressDialog . setMax ( 100 ) ; progressDialog . show ( ) ; BmobQuery < moniqi > query = new BmobQuery < moniqi > ( ) ; query . addWhereEqualTo ( " name " , app_name ) ; query . findObjects ( new FindListener < moniqi > ( ) { private BmobFile moniqiApk ; @ Override public void done ( List < moniqi > p1 , BmobException p2 ) { if ( p2 == null ) { for ( moniqi apk : p1 ) { moniqiApk = apk . getApk ( ) ; } appFileDownload ( moniqiApk , app_name ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . link_fail ) + p2 , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; }
nihaocun/kirbydownload | private void appFileDownload ( BmobFile moniqiApk , final String app_name ) { File saveFile = new File ( " / storage / emulated / 0 / Android / data / com . kirby . runanjing / files / " + moniqiApk . getFilename ( ) ) ; moniqiApk . download ( saveFile , new DownloadFileListener ( ) { @ Override public void onStart ( ) { progressDialog . setMessage ( getResources ( ) . getString ( R . string . downloading ) + app_name ) ; } @ Override public void done ( String savePath , BmobException e ) { if ( e == null ) { progressDialog . dismiss ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . download_susses ) + savePath , Toast . LENGTH_SHORT ) . show ( ) ; Install . installApk ( MainActivity . this , savePath ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . download_fail ) + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } @ Override public void onProgress ( Integer value , long newworkSpeed ) { progressDialog . setProgress ( value ) ; } } ) ; }
nihaocun/kirbydownload | public void theDownload ( Context con , String game_name ) { gameContext = con ; switch ( game_name ) { case " 星之卡比 ▁ 梦之泉DX " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3kURIBIZ " , " https : // eyun . baidu . com / s / 3o86TXDS " , " https : // eyun . baidu . com / s / 3dF22BWP " ) ; break ; case " 星之卡比 ▁ 镜之大迷宫 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3hs7Mjsg " , " https : // eyun . baidu . com / s / 3c5qBl8" , " https : // eyun . baidu . com / s / 3i5t6Z3J " ) ; break ; case " 星之卡比 ▁ 3" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKTD8EZ " , " https : // eyun . baidu . com / s / 3gfwui2n " , " " ) ; break ; case " 星之卡比 ▁ 超豪华版 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3qXEc4Xm " , " https : // eyun . baidu . com / s / 3nu8IVpv " , " " ) ; break ; case " 星之卡比 ▁ 卡比梦幻都 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3hsvCjfI " , " https : // eyun . baidu . com / s / 3jHCmNps " , " " ) ; break ; case " [ 仅美国 ] 星之卡比 ▁ 卡比魔方气泡 " : showDownloadDialog ( game_name , R . string . game_name1 , R . string . us , R . string . nu , R . string . nu , " https : // eyun . baidu . com / s / 3eSuusSi " , " " , " " ) ; break ; case " [ 仅日本 ] 星之卡比 ▁ 卡比宝石星DX " : showDownloadDialog ( game_name , R . string . game_name2 , R . string . jp , R . string . nu , R . string . nu , " https : // eyun . baidu . com / s / 3kVDhaS3" , " " , " " ) ; break ; case " 星之卡比 ▁ 64" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3jHPKdMY " , " https : // eyun . baidu . com / s / 3jHPKdMY " , " " ) ; break ; case " 星之卡比 ▁ 飞天赛车 " : showDownloadDialog ( game_name , R . string . game_name , R . string . us , R . string . nu , R . string . nu , " https : // eyun . baidu . com / s / 3qYAoXGC " , " " , " " ) ; break ; case " 星之卡比 ▁ 重返梦幻岛 " : break ; case " 星之卡比 ▁ 毛线卡比 " : break ; case " 星之卡比 ▁ 触摸卡比 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3hsqS3S4" , " https : // eyun . baidu . com / s / 3c27V89i " , " https : // eyun . baidu . com / s / 3i5Pwsxn " ) ; break ; case " 星之卡比 ▁ 超究豪华版 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3i4Ricbb " , " https : // eyun . baidu . com / s / 3nvCwXlB " , " https : // eyun . baidu . com / s / 3c2EblZi " ) ; break ; case " 星之卡比 ▁ 呐喊团 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3bo4Z5TH " , " https : // eyun . baidu . com / s / 3czmilC " , " https : // eyun . baidu . com / s / 3hr4PxbA " ) ; break ; case " 星之卡比 ▁ 集合 ！ 卡比 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3geO4mbx " , " https : // eyun . baidu . com / s / 3eSijdHS " , " https : // eyun . baidu . com / s / 3o80PA6e " ) ; break ; case " 星之卡比 ▁ 1" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKN6dIz " , " https : // eyun . baidu . com / s / 3pKZHpaF " , " " ) ; break ; case " 星之卡比 ▁ 2" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3i57Kjjv " , " https : // eyun . baidu . com / s / 3jI4urlW " , " " ) ; break ; case " 星之卡比 ▁ 卡比宝石星 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3miFgbtI " , " https : // eyun . baidu . com / s / 3nvtzunn " , " " ) ; break ; case " 星之卡比 ▁ 卡比打砖块 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3i5Dkqah " , " https : // eyun . baidu . com / s / 3ge7808r " , " " ) ; break ; case " 星之卡比 ▁ 卡比弹珠台 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3i48QqMh " , " https : // eyun . baidu . com / s / 3eSwv1DK " , " " ) ; break ; case " 星之卡比 ▁ 滚滚卡比 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKP9eav " , " https : // eyun . baidu . com / s / 3nuQZavJ " , " " ) ; break ; case " 星之卡比 ▁ 梦之泉物语 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKXFx8n " , " https : // eyun . baidu . com / s / 3pKZHpaF " , " https : // eyun . baidu . com / s / 3i4HC8FN " ) ; break ; case " GBA模拟器 \n My ▁ Boy ! " : showOtherDownloadDialog ( " gba " , game_name ) ; break ; case " SFC模拟器 \n Snes9x ▁ EX + " : showOtherDownloadDialog ( " sfc " , game_name ) ; break ; case " N64模拟器 \n Tendo64" : showOtherDownloadDialog ( " n64" , game_name ) ; break ; case " NDS模拟器 \n DraStic " : showOtherDownloadDialog ( " nds " , game_name ) ; break ; case " NGC & WII模拟器 \n Dolphin " : showOtherDownloadDialog ( " wii " , game_name ) ; break ; case " GB & GBC模拟器 \n My ▁ OldBoy ! " : showOtherDownloadDialog ( " gb " , game_name ) ; break ; case " FC模拟器 \n NES . emu " : showOtherDownloadDialog ( " fc " , game_name ) ; break ; } }
nihaocun/kirbydownload | public void downloadMoniqiApk ( final String game_name ) { progressDialog = new ProgressDialog ( gameContext ) ; progressDialog . setMessage ( gameContext . getString ( R . string . link_bmob ) ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_HORIZONTAL ) ; progressDialog . setMax ( 100 ) ; progressDialog . show ( ) ; BmobQuery < moniqi > query = new BmobQuery < moniqi > ( ) ; query . addWhereEqualTo ( " name " , game_name ) ; query . findObjects ( new FindListener < moniqi > ( ) { private BmobFile moniqiApk ; @ Override public void done ( List < moniqi > p1 , BmobException p2 ) { if ( p2 == null ) { for ( moniqi apk : p1 ) { moniqiApk = apk . getApk ( ) ; } moniqiFileDownload ( moniqiApk , game_name ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( gameContext , gameContext . getString ( R . string . link_fail ) + p2 , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; }
nihaocun/kirbydownload | private void moniqiFileDownload ( BmobFile moniqiApk , final String game_name ) { File saveFile = new File ( " / storage / emulated / 0 / Android / data / com . kirby . runanjing / files / " + moniqiApk . getFilename ( ) ) ; moniqiApk . download ( saveFile , new DownloadFileListener ( ) { @ Override public void onStart ( ) { progressDialog . setMessage ( gameContext . getString ( R . string . downloading ) + game_name ) ; } @ Override public void done ( String savePath , BmobException e ) { if ( e == null ) { progressDialog . dismiss ( ) ; Toast . makeText ( gameContext , gameContext . getString ( R . string . download_susses ) + savePath , Toast . LENGTH_SHORT ) . show ( ) ; Install . installApk ( gameContext , savePath ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( gameContext , gameContext . getString ( R . string . download_fail ) + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } @ Override public void onProgress ( Integer value , long newworkSpeed ) { progressDialog . setProgress ( value ) ; } } ) ; }
nihaocun/kirbydownload | private void showOtherDownloadDialog ( final String downloadName , String game_name ) { AlertDialog . Builder dialog = new AlertDialog . Builder ( gameContext ) . setTitle ( game_name ) . setMessage ( R . string . download_dia_mess ) . setPositiveButton ( R . string . dia_download , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { downloadMoniqiApk ( downloadName ) ; } } ) ; dialog . show ( ) ; }
nihaocun/kirbydownload | public void showDownloadDialog ( String name , int mess , Integer pos , Integer neg , Integer neu , final String pos_url , final String neg_url , final String neu_url ) { AlertDialog . Builder dialog = new AlertDialog . Builder ( gameContext ) . setTitle ( name ) . setMessage ( mess ) . setPositiveButton ( pos , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent web = new Intent ( ) ; web . setAction ( " android . intent . action . VIEW " ) ; Uri content_url = Uri . parse ( pos_url ) ; web . setData ( content_url ) ; gameContext . startActivity ( web ) ; } } ) . setNegativeButton ( neg , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent web = new Intent ( ) ; web . setAction ( " android . intent . action . VIEW " ) ; Uri content_url = Uri . parse ( neg_url ) ; web . setData ( content_url ) ; gameContext . startActivity ( web ) ; } } ) . setNeutralButton ( neu , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent web = new Intent ( ) ; web . setAction ( " android . intent . action . VIEW " ) ; Uri content_url = Uri . parse ( neu_url ) ; web . setData ( content_url ) ; gameContext . startActivity ( web ) ; } } ) ; dialog . show ( ) ; }
sendy943/jfinal-wxmall | public void setId ( java . lang . Long id ) { set ( " id " , id ) ; }
sendy943/jfinal-wxmall | public java . lang . Long getId ( ) { return get ( " id " ) ; }
sendy943/jfinal-wxmall | public void setNick ( java . lang . String nick ) { set ( " nick " , nick ) ; }
sendy943/jfinal-wxmall | public java . lang . String getNick ( ) { return get ( " nick " ) ; }
sendy943/jfinal-wxmall | public void setPhone ( java . lang . String phone ) { set ( " phone " , phone ) ; }
sendy943/jfinal-wxmall | public java . lang . String getPhone ( ) { return get ( " phone " ) ; }
sendy943/jfinal-wxmall | public void setPassword ( java . lang . String password ) { set ( " password " , password ) ; }
sendy943/jfinal-wxmall | public java . lang . String getPassword ( ) { return get ( " password " ) ; }
sendy943/jfinal-wxmall | public void setUserLevel ( java . lang . Integer userLevel ) { set ( " user _ level " , userLevel ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getUserLevel ( ) { return get ( " user _ level " ) ; }
sendy943/jfinal-wxmall | public void setLoginTime ( java . util . Date loginTime ) { set ( " login _ time " , loginTime ) ; }
sendy943/jfinal-wxmall | public java . util . Date getLoginTime ( ) { return get ( " login _ time " ) ; }
sendy943/jfinal-wxmall | public void setEmail ( java . lang . String email ) { set ( " email " , email ) ; }
sendy943/jfinal-wxmall | public java . lang . String getEmail ( ) { return get ( " email " ) ; }
sendy943/jfinal-wxmall | public void setStartDate ( java . util . Date startDate ) { set ( " start _ date " , startDate ) ; }
sendy943/jfinal-wxmall | public java . util . Date getStartDate ( ) { return get ( " start _ date " ) ; }
sendy943/jfinal-wxmall | public void setEndDate ( java . util . Date endDate ) { set ( " end _ date " , endDate ) ; }
sendy943/jfinal-wxmall | public java . util . Date getEndDate ( ) { return get ( " end _ date " ) ; }
sendy943/jfinal-wxmall | public void setVersionNo ( java . lang . Integer versionNo ) { set ( " version _ no " , versionNo ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getVersionNo ( ) { return get ( " version _ no " ) ; }
sendy943/jfinal-wxmall | public void setLoginIp ( java . lang . String loginIp ) { set ( " login _ ip " , loginIp ) ; }
sendy943/jfinal-wxmall | public java . lang . String getLoginIp ( ) { return get ( " login _ ip " ) ; }
sendy943/jfinal-wxmall | public void setAdmiLoginFailureCount ( java . lang . Integer admiLoginFailureCount ) { set ( " admi _ login _ failure _ count " , admiLoginFailureCount ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getAdmiLoginFailureCount ( ) { return get ( " admi _ login _ failure _ count " ) ; }
sendy943/jfinal-wxmall | public void setActive ( java . lang . Integer active ) { set ( " active " , active ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getActive ( ) { return get ( " active " ) ; }
sendy943/jfinal-wxmall | public void setCreated ( java . util . Date created ) { set ( " created " , created ) ; }
sendy943/jfinal-wxmall | public java . util . Date getCreated ( ) { return get ( " created " ) ; }
sendy943/jfinal-wxmall | public void setUpdated ( java . util . Date updated ) { set ( " updated " , updated ) ; }
sendy943/jfinal-wxmall | public java . util . Date getUpdated ( ) { return get ( " updated " ) ; }
standy66/fizteh-ads-2014 | protected void recalculate ( ) { String suffix = appended . stream ( ) . map ( x -> x . toString ( ) ) . collect ( Collectors . joining ( ) ) ; String prefix = prepended . stream ( ) . map ( x -> x . toString ( ) ) . collect ( Collectors . joining ( ) ) ; sample = String . join ( " " , prefix , sample . substring ( 0 , sample . length ( ) - 1 ) , suffix , String . valueOf ( ( char ) 0 ) ) ; samplePi = PiFunctionImpl . getPiFunction ( sample ) ; sampleLength = sample . length ( ) ; appended . clear ( ) ; prepended . clear ( ) ; }
standy66/fizteh-ads-2014 | public void appendCharToTemplate ( char c ) throws IllegalStateException { if ( sample == null ) { throw new IllegalStateException ( " no ▁ template ▁ was ▁ set " ) ; } appended . add ( c ) ; if ( appended . size ( ) + prepended . size ( ) > sample . length ( ) ) { recalculate ( ) ; } }
standy66/fizteh-ads-2014 | public void prependCharToTemplate ( char c ) throws IllegalStateException { if ( sample == null ) { throw new IllegalStateException ( " no ▁ template ▁ was ▁ set " ) ; } prepended . add ( c ) ; if ( appended . size ( ) + prepended . size ( ) > sample . length ( ) ) { recalculate ( ) ; } }
standy66/fizteh-ads-2014 | while ( buffer . size ( ) < neededSize && ! stream . isEmpty ( ) ) { buffer . add ( stream . nextChar ( ) ) ; }
standy66/fizteh-ads-2014 | if ( buffer . size ( ) < neededSize ) { return new ArrayList < > ( ) ; }
mzubairahmed/externalapi | @ JsonProperty ( " Code " ) public String getCode ( ) { return code ; }
mzubairahmed/externalapi | @ JsonProperty ( " Code " ) public void setCode ( String code ) { this . code = code ; }
mzubairahmed/externalapi | @ JsonProperty ( " Description " ) public String getDescription ( ) { return description ; }
mzubairahmed/externalapi | @ JsonProperty ( " Description " ) public void setDescription ( String description ) { this . description = description ; }
mzubairahmed/externalapi | @ JsonProperty ( " DisplayName " ) public String getDisplayName ( ) { return displayName ; }
mzubairahmed/externalapi | @ JsonProperty ( " DisplayName " ) public void setDisplayName ( String displayName ) { this . displayName = displayName ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaLevelCode " ) public String getCriteriaLevelCode ( ) { return criteriaLevelCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaLevelCode " ) public void setCriteriaLevelCode ( String criteriaLevelCode ) { this . criteriaLevelCode = criteriaLevelCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaGroupCode " ) public String getCriteriaGroupCode ( ) { return criteriaGroupCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaGroupCode " ) public void setCriteriaGroupCode ( String criteriaGroupCode ) { this . criteriaGroupCode = criteriaGroupCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaTypeCode " ) public String getCriteriaTypeCode ( ) { return criteriaTypeCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaTypeCode " ) public void setCriteriaTypeCode ( String criteriaTypeCode ) { this . criteriaTypeCode = criteriaTypeCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowBasePrice " ) public Boolean getIsAllowBasePrice ( ) { return isAllowBasePrice ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowBasePrice " ) public void setIsAllowBasePrice ( Boolean isAllowBasePrice ) { this . isAllowBasePrice = isAllowBasePrice ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowUpcharge " ) public Boolean getIsAllowUpcharge ( ) { return isAllowUpcharge ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowUpcharge " ) public void setIsAllowUpcharge ( Boolean isAllowUpcharge ) { this . isAllowUpcharge = isAllowUpcharge ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsFlag " ) public Boolean getIsFlag ( ) { return isFlag ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsFlag " ) public void setIsFlag ( Boolean isFlag ) { this . isFlag = isFlag ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsProductNumberAssignmentAllowed " ) public Boolean getIsProductNumberAssignmentAllowed ( ) { return isProductNumberAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsProductNumberAssignmentAllowed " ) public void setIsProductNumberAssignmentAllowed ( Boolean isProductNumberAssignmentAllowed ) { this . isProductNumberAssignmentAllowed = isProductNumberAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsMediaAssignmentAllowed " ) public Boolean getIsMediaAssignmentAllowed ( ) { return isMediaAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsMediaAssignmentAllowed " ) public void setIsMediaAssignmentAllowed ( Boolean isMediaAssignmentAllowed ) { this . isMediaAssignmentAllowed = isMediaAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " CodeValueGroups " ) public List < CodeValueGroup > getCodeValueGroups ( ) { return codeValueGroups ; }
mzubairahmed/externalapi | @ JsonProperty ( " CodeValueGroups " ) public void setCodeValueGroups ( List < CodeValueGroup > codeValueGroups ) { this . codeValueGroups = codeValueGroups ; }
Alachisoft/TayzGrid | if ( cParam . getIsUsage ( ) ) { AssemblyUsage . PrintUsage ( ) ; return ; }
Alachisoft/TayzGrid | if ( ! ValidateParameters ( ) ) { return ; }
Alachisoft/TayzGrid | if ( IsValidAddress ( cParam . getClientNode ( ) ) ) { NCache . setServerName ( cParam . getClientNode ( ) ) ; }
Alachisoft/TayzGrid | catch ( RuntimeException exp ) { System . err . println ( " Failed ▁ to ▁ Connect ▁ to ▁ IP ▁ " + cParam . getClientNode ( ) + " . " ) ; System . err . println ( " Error ▁ Detail : ▁ " + exp . getMessage ( ) ) ; return ; }
Alachisoft/TayzGrid | if ( cParam . getPort ( ) != - 1 ) { NCache . setPort ( cParam . getPort ( ) ) ; }
Alachisoft/TayzGrid | if ( cParam . getServer ( ) != null && ! cParam . getServer ( ) . equals ( " " ) ) { NCache . setServerName ( cParam . getServer ( ) ) ; }
Alachisoft/TayzGrid | if ( config == null ) { System . err . println ( " Error ▁ : ▁ The ▁ cache ▁ doesnot ▁ exist " ) ; return ; }
Alachisoft/TayzGrid | if ( config . getCacheSettings ( ) . getCacheType ( ) . equals ( " clustered - cache " ) && ! config . getCacheSettings ( ) . getInProc ( ) ) { for ( Address node : config . getCacheDeployment ( ) . getServers ( ) . GetAllConfiguredNodes ( ) ) { currentServerNodes . add ( node . getIpAddress ( ) . getHostAddress ( ) . toString ( ) ) ; } }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getClientNodes ( ) != null ) { for ( ClientNode clientNode : config . getCacheDeployment ( ) . getClientNodes ( ) . getNodesList ( ) ) { if ( cParam . getClientNode ( ) . equals ( clientNode . getName ( ) ) ) { System . err . println ( " Error : ▁ " + clientNode . getName ( ) + " ▁ already ▁ part ▁ of ▁ \" " + cParam . getCacheId ( ) + " \" " ) ; return ; } currentClientNodes . add ( clientNode . getName ( ) ) ; } }
Alachisoft/TayzGrid | catch ( Exception ex ) { if ( ex . getMessage ( ) != null ) System . err . println ( " Error : ▁ " + ex . getMessage ( ) ) ; }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getClientNodes ( ) == null ) { config . getCacheDeployment ( ) . setClientNodes ( new ClientNodes ( ) ) ; }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getClientNodes ( ) . getNodesList ( ) == null ) { config . getCacheDeployment ( ) . getClientNodes ( ) . setNodesList ( new java . util . ArrayList < ClientNode > ( ) ) ; }
Alachisoft/TayzGrid | for ( String node : currentServerNodes ) { NCache . setServerName ( node ) ; cacheServer = NCache . GetCacheServer ( new TimeSpan ( 0 , 0 , 30 ) ) ; cacheServer . ApplyCacheConfiguration ( cParam . getCacheId ( ) , config , null , null , false ) ; }
Alachisoft/TayzGrid | if ( currentClientNodes . size ( ) > 0 ) { oldClientNode = currentClientNodes . get ( 0 ) ; NCache . setServerName ( oldClientNode ) ; cacheServer = NCache . GetCacheServer ( new TimeSpan ( 0 , 0 , 30 ) ) ; clientConfig = cacheServer . GetClientConfiguration ( cParam . getCacheId ( ) ) ; }
Alachisoft/TayzGrid | if ( cParam . getClientBindingIp ( ) != null && ! cParam . getClientBindingIp ( ) . equals ( " " ) ) { cacheConfig . setBindIp ( cParam . getClientBindingIp ( ) ) ; }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getServers ( ) . getNodeIdentities ( ) != null && config . getCacheDeployment ( ) . getServers ( ) . getNodeIdentities ( ) . length != 0 ) { cacheConfig . setServersPriorityList ( new CacheServerList ( ) ) ; for ( NodeIdentity identity : config . getCacheDeployment ( ) . getServers ( ) . getNodeIdentities ( ) ) { com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer server = new com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer ( ) ; server . setServerName ( identity . getNodeName ( ) ) ; server . setPriority ( identity . getNodePriority ( ) ) ; cacheConfig . getServersPriorityList ( ) . setServersList ( identity . getNodePriority ( ) - 1 , server ) ; } }
Alachisoft/TayzGrid | if ( isSuccessFull ) { System . out . println ( " SuccessFully ▁ added ▁ client ▁ node " ) ; }
Alachisoft/TayzGrid | catch ( Exception ex ) { if ( ex . getMessage ( ) != null ) System . err . println ( " Error : ▁ " + ex . getMessage ( ) ) ; }
dagnir/aws-sdk-java | public void setProductCode ( String productCode ) { this . productCode = productCode ; }
dagnir/aws-sdk-java | public String getProductCode ( ) { return this . productCode ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withProductCode ( String productCode ) { setProductCode ( productCode ) ; return this ; }
dagnir/aws-sdk-java | public java . util . Map < String , java . util . List < String > > getFilter ( ) { return filter ; }
dagnir/aws-sdk-java | public void setFilter ( java . util . Map < String , java . util . List < String > > filter ) { this . filter = filter ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withFilter ( java . util . Map < String , java . util . List < String > > filter ) { setFilter ( filter ) ; return this ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest addFilterEntry ( String key , java . util . List < String > value ) { if ( null == this . filter ) { this . filter = new java . util . HashMap < String , java . util . List < String > > ( ) ; } if ( this . filter . containsKey ( key ) ) throw new IllegalArgumentException ( " Duplicated ▁ keys ▁ ( " + key . toString ( ) + " ) ▁ are ▁ provided . " ) ; this . filter . put ( key , value ) ; return this ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest clearFilterEntries ( ) { this . filter = null ; return this ; }
dagnir/aws-sdk-java | public void setNextToken ( String nextToken ) { this . nextToken = nextToken ; }
dagnir/aws-sdk-java | public String getNextToken ( ) { return this . nextToken ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withNextToken ( String nextToken ) { setNextToken ( nextToken ) ; return this ; }
dagnir/aws-sdk-java | public void setMaxResults ( Integer maxResults ) { this . maxResults = maxResults ; }
dagnir/aws-sdk-java | public Integer getMaxResults ( ) { return this . maxResults ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withMaxResults ( Integer maxResults ) { setMaxResults ( maxResults ) ; return this ; }
dagnir/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getProductCode ( ) != null ) sb . append ( " ProductCode : ▁ " ) . append ( getProductCode ( ) ) . append ( " , " ) ; if ( getFilter ( ) != null ) sb . append ( " Filter : ▁ " ) . append ( getFilter ( ) ) . append ( " , " ) ; if ( getNextToken ( ) != null ) sb . append ( " NextToken : ▁ " ) . append ( getNextToken ( ) ) . append ( " , " ) ; if ( getMaxResults ( ) != null ) sb . append ( " MaxResults : ▁ " ) . append ( getMaxResults ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dagnir/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof GetEntitlementsRequest == false ) return false ; GetEntitlementsRequest other = ( GetEntitlementsRequest ) obj ; if ( other . getProductCode ( ) == null ^ this . getProductCode ( ) == null ) return false ; if ( other . getProductCode ( ) != null && other . getProductCode ( ) . equals ( this . getProductCode ( ) ) == false ) return false ; if ( other . getFilter ( ) == null ^ this . getFilter ( ) == null ) return false ; if ( other . getFilter ( ) != null && other . getFilter ( ) . equals ( this . getFilter ( ) ) == false ) return false ; if ( other . getNextToken ( ) == null ^ this . getNextToken ( ) == null ) return false ; if ( other . getNextToken ( ) != null && other . getNextToken ( ) . equals ( this . getNextToken ( ) ) == false ) return false ; if ( other . getMaxResults ( ) == null ^ this . getMaxResults ( ) == null ) return false ; if ( other . getMaxResults ( ) != null && other . getMaxResults ( ) . equals ( this . getMaxResults ( ) ) == false ) return false ; return true ; }
dagnir/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getProductCode ( ) == null ) ? 0 : getProductCode ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getFilter ( ) == null ) ? 0 : getFilter ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getNextToken ( ) == null ) ? 0 : getNextToken ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMaxResults ( ) == null ) ? 0 : getMaxResults ( ) . hashCode ( ) ) ; return hashCode ; }
dagnir/aws-sdk-java | @ Override public GetEntitlementsRequest clone ( ) { return ( GetEntitlementsRequest ) super . clone ( ) ; }
argonium/wordfinder | private ExactMatchFilter ( ) { super ( ) ; }
argonium/wordfinder | public ExactMatchFilter ( final String word , final boolean bIgnoreCase ) { term = word ; ignoreCase = bIgnoreCase ; }
argonium/wordfinder | public boolean accept ( final String word ) { if ( ( word == null ) && ( term == null ) ) { return true ; } else if ( ( word == null ) || ( term == null ) ) { return false ; } if ( ignoreCase ) { return ( term . equalsIgnoreCase ( word ) ) ; } else { return ( term . equals ( word ) ) ; } }
Silveryard/CarLauncher | @ Override protected File getAPFFile ( ) { return getProject ( ) . file ( " BluetoothPlayer / build / apf / de _ silveryard _ car _ BluetoothPlayer _ 1_0 - SNAPSHOT . apf " ) ; }
camsas/Musketeer | == - 1 && minValue != null ) { context . write ( new Text ( " ALL " ) , new Text ( String . valueOf ( minValue ) + selectedCols ) ) ; }
djechelon/spring-security | protected AbstractPermission ( int mask ) { this . mask = mask ; this . code = ' * ' ; }
djechelon/spring-security | protected AbstractPermission ( int mask , char code ) { this . mask = mask ; this . code = code ; }
djechelon/spring-security | @ Override public final boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! ( obj instanceof Permission ) ) { return false ; } Permission other = ( Permission ) obj ; return ( this . mask == other . getMask ( ) ) ; }
djechelon/spring-security | @ Override public final int hashCode ( ) { return this . mask ; }
djechelon/spring-security | @ Override public final String toString ( ) { return this . getClass ( ) . getSimpleName ( ) + " [ " + getPattern ( ) + " = " + this . mask + " ] " ; }
djechelon/spring-security | @ Override public final int getMask ( ) { return this . mask ; }
djechelon/spring-security | @ Override public String getPattern ( ) { return AclFormattingUtils . printBinary ( this . mask , this . code ) ; }
sbt/ivy | public ExactPatternMatcher ( ) { super ( EXACT ) ; }
sbt/ivy | protected Matcher newMatcher ( String expression ) { return new ExactMatcher ( expression ) ; }
sbt/ivy | public ExactMatcher ( String expression ) { this . expression = expression ; }
sbt/ivy | public boolean matches ( String input ) { if ( input == null ) { throw new NullPointerException ( ) ; } return input . equals ( expression ) ; }
sbt/ivy | public boolean isExact ( ) { return true ; }
vjanmey/EpicMudfia | @ Override public String ID ( ) { return " GardenSnake " ; }
vjanmey/EpicMudfia | public GardenSnake ( ) { super ( ) ; username = " a ▁ garden ▁ snake " ; setDescription ( " A ▁ harmless ▁ little ▁ green ▁ string . " ) ; setDisplayText ( " A ▁ little ▁ garden ▁ snake ▁ slithers ▁ around ▁ looking ▁ for ▁ bugs . " ) ; CMLib . factions ( ) . setAlignment ( this , Faction . Align . NEUTRAL ) ; setMoney ( 0 ) ; basePhyStats ( ) . setDamage ( 1 ) ; baseCharStats ( ) . setStat ( CharStats . STAT_INTELLIGENCE , 1 ) ; basePhyStats ( ) . setAbility ( 0 ) ; basePhyStats ( ) . setLevel ( 1 ) ; basePhyStats ( ) . setArmor ( 90 ) ; baseCharStats ( ) . setMyRace ( CMClass . getRace ( " GardenSnake " ) ) ; baseCharStats ( ) . getMyRace ( ) . startRacing ( this , false ) ; baseState . setHitPoints ( CMLib . dice ( ) . roll ( basePhyStats ( ) . level ( ) , 20 , basePhyStats ( ) . level ( ) ) ) ; recoverMaxState ( ) ; resetToMaxState ( ) ; recoverPhyStats ( ) ; recoverCharStats ( ) ; }
shakamunyi/drill | @ Test public void testDirectConnectionConnectTriesEqualsDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; " + " tries = 2" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionConnectTriesGreaterThanDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 5" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionConnectTriesLessThanDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 1" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionInvalidConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = abc " , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof InvalidConnectionInfoException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionZeroConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 0" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionNegativeConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = - 5" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testZKSuccessfulConnectionZeroConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = 0" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
shakamunyi/drill | @ Test public void testZKSuccessfulConnectionNegativeConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = - 1" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
shakamunyi/drill | @ Test public void testZKSuccessfulConnectionGreaterThanConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = 7" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
shakamunyi/drill | @ Test public void testZKConnectionInvalidConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = abc " , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof InvalidConnectionInfoException ) ; } }
housejester/jsondumper | public void append ( Object obj , Writer writer ) throws IOException { writer . append ( " " + ( ( Date ) obj ) . getTime ( ) ) ; }
mociek124/java_pft | public FtpHelper ( ApplicationManager app ) { this . app = app ; ftp = new FTPClient ( ) ; }
mociek124/java_pft | public void upload ( File file , String target , String backup ) throws IOException { ftp . connect ( app . getProperty ( " ftp . host " ) ) ; ftp . login ( app . getProperty ( " ftp . login " ) , app . getProperty ( " ftp . password " ) ) ; ftp . deleteFile ( backup ) ; ftp . rename ( target , backup ) ; ftp . enterLocalPassiveMode ( ) ; ftp . storeFile ( target , new FileInputStream ( file ) ) ; ftp . disconnect ( ) ; }
mociek124/java_pft | public void restore ( String backup , String target ) throws IOException { ftp . connect ( app . getProperty ( " ftp . host " ) ) ; ftp . login ( app . getProperty ( " ftp . login " ) , app . getProperty ( " ftp . password " ) ) ; ftp . deleteFile ( target ) ; ftp . rename ( backup , target ) ; ftp . disconnect ( ) ; }
wentch/redkale | public HttpScope attr ( Map < String , Object > map ) { if ( map == null ) return this ; if ( this . attributes == null ) this . attributes = new LinkedHashMap < > ( ) ; this . attributes . putAll ( map ) ; return this ; }
wentch/redkale | public HttpScope attr ( String name , Object value ) { if ( this . attributes == null ) this . attributes = new LinkedHashMap < > ( ) ; this . attributes . put ( name , value ) ; return this ; }
wentch/redkale | public < T > T find ( String name ) { return this . attributes == null ? null : ( T ) this . attributes . get ( name ) ; }
wentch/redkale | public < T > T find ( HttpScope parent , String name ) { T rs = this . attributes == null ? null : ( T ) this . attributes . get ( name ) ; if ( rs != null ) return rs ; return parent == null ? null : parent . find ( name ) ; }
wentch/redkale | public void forEach ( BiConsumer < String , Object > action ) { if ( this . attributes == null ) return ; this . attributes . forEach ( action ) ; }
wentch/redkale | public String getReferid ( ) { return referid ; }
wentch/redkale | public void setReferid ( String referid ) { this . referid = referid ; }
wentch/redkale | public Map < String , Object > getAttributes ( ) { return attributes ; }
wentch/redkale | @ ConvertDisabled ( type = ConvertType . JSON ) public void setAttributes ( Map < String , Object > attributes ) { this . attributes = attributes ; }
wentch/redkale | @ Override public String toString ( ) { return JsonConvert . root ( ) . convertTo ( this ) ; }
miniway/presto | private ConvexHullAggregation ( ) { }
clairton/repository-vraptor | public Record ( final Object value , final Comparator comparator ) { this . value = value ; this . comparator = comparator ; }
msgpack/msgpack-java | @ Override public boolean isNilValue ( ) { return getValueType ( ) . isNilType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isBooleanValue ( ) { return getValueType ( ) . isBooleanType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isNumberValue ( ) { return getValueType ( ) . isNumberType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isIntegerValue ( ) { return getValueType ( ) . isIntegerType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isFloatValue ( ) { return getValueType ( ) . isFloatType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isRawValue ( ) { return getValueType ( ) . isRawType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isBinaryValue ( ) { return getValueType ( ) . isBinaryType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isStringValue ( ) { return getValueType ( ) . isStringType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isArrayValue ( ) { return getValueType ( ) . isArrayType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isMapValue ( ) { return getValueType ( ) . isMapType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isExtensionValue ( ) { return getValueType ( ) . isExtensionType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isTimestampValue ( ) { return false ; }
msgpack/msgpack-java | @ Override public ImmutableNilValue asNilValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableBooleanValue asBooleanValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableNumberValue asNumberValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableIntegerValue asIntegerValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableFloatValue asFloatValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableRawValue asRawValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableBinaryValue asBinaryValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableStringValue asStringValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableArrayValue asArrayValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableMapValue asMapValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableExtensionValue asExtensionValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableTimestampValue asTimestampValue ( ) { throw new MessageTypeCastException ( ) ; }
jentfoo/aws-sdk-java | public ChangeBatch unmarshall ( StaxUnmarshallerContext context ) throws Exception { ChangeBatch changeBatch = new ChangeBatch ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return changeBatch ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( " Comment " , targetDepth ) ) { changeBatch . setComment ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " Changes " , targetDepth ) ) { changeBatch . withChanges ( new ArrayList < Change > ( ) ) ; continue ; } if ( context . testExpression ( " Changes / Change " , targetDepth ) ) { changeBatch . withChanges ( ChangeStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return changeBatch ; } } } }
Azure/azure-sdk-for-java | MachineEventsProcessor ( Duration reportingInterval ) { this . reportingInterval = reportingInterval ; }
Azure/azure-sdk-for-java | void onEvent ( EventContext eventContext ) { final PartitionContext partitionContext = eventContext . getPartitionContext ( ) ; final EventData event = eventContext . getEventData ( ) ; final String contents = event . getBodyAsString ( ) ; final int temperature ; try { temperature = Integer . parseInt ( contents ) ; } catch ( NumberFormatException ex ) { logger . warn ( " Unable ▁ to ▁ parse ▁ temperature ▁ data . ▁ Partition : ▁ # { } . ▁ Seq ▁ # { } . ▁ Contents : ▁ # { } . ▁ Error : ▁ { } " , partitionContext . getPartitionId ( ) , event . getSequenceNumber ( ) , contents , ex ) ; return ; } final String machineId = event . getPartitionKey ( ) ; if ( machineId == null || machineId . isEmpty ( ) ) { logger . warn ( " PartitionKey ▁ is ▁ not ▁ set ▁ on ▁ event . ▁ Partition : ▁ # { } . ▁ Seq ▁ # { } . ▁ Contents : ▁ # { } . " , partitionContext . getPartitionId ( ) , event . getSequenceNumber ( ) , contents ) ; return ; } partitionsProcessing . compute ( partitionContext . getPartitionId ( ) , ( key , value ) -> { if ( value == null ) { value = new HashSet < > ( ) ; } value . add ( machineId ) ; return value ; } ) ; final MachineInformation information = machineInformation . computeIfAbsent ( machineId , key -> new MachineInformation ( key , reportingInterval ) ) ; information . onTemperatureEvent ( event . getEnqueuedTime ( ) , temperature ) ; eventContext . updateCheckpoint ( ) ; }
Azure/azure-sdk-for-java | void onInitialize ( InitializationContext initializationContext ) { final PartitionContext partition = initializationContext . getPartitionContext ( ) ; partitionsProcessing . computeIfAbsent ( partition . getPartitionId ( ) , key -> new HashSet < > ( ) ) ; }
Azure/azure-sdk-for-java | void onError ( ErrorContext errorContext ) { final PartitionContext partition = errorContext . getPartitionContext ( ) ; logger . error ( " Error ▁ occurred ▁ processing ▁ partition ▁ ' { } ' ? ▁ { } " , partition . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; }
Azure/azure-sdk-for-java | void onClose ( CloseContext closeContext ) { final PartitionContext partition = closeContext . getPartitionContext ( ) ; final Set < String > machineIds = partitionsProcessing . remove ( partition . getPartitionId ( ) ) ; logger . info ( " Stopped ▁ processing ▁ partition ▁ ' { } ' . ▁ Reason : ▁ ' { } ' " , partition . getPartitionId ( ) , closeContext . getCloseReason ( ) ) ; for ( String id : machineIds ) { final MachineInformation information = machineInformation . remove ( id ) ; if ( information == null ) { continue ; } logger . info ( " Stopped ▁ processing ▁ temperatures ▁ for ▁ machine : ▁ { } " , information . getIdentifier ( ) ) ; information . close ( ) ; } }
Azure/azure-sdk-for-java | @ Override public void close ( ) { if ( isDisposed . getAndSet ( true ) ) { return ; } partitionsProcessing . clear ( ) ; machineInformation . forEach ( ( key , value ) -> value . close ( ) ) ; machineInformation . clear ( ) ; }
Azure/azure-sdk-for-java | MachineInformation ( String identifier , Duration reportingInterval ) { this . identifier = identifier ; this . averageTemperatures = Flux . interval ( reportingInterval ) . takeUntilOther ( onDispose ) . map ( unused -> { final Instant timeCalculated = Instant . now ( ) ; final List < Integer > temperaturesInInterval = temperatures . getAndSet ( new ArrayList < > ( ) ) ; if ( temperaturesInInterval . size ( ) == 0 ) { logger . info ( " [ { } ] : ▁ Average : ▁ null " , this . identifier ) ; return new AverageTemperature ( timeCalculated , null ) ; } final int sum = temperaturesInInterval . stream ( ) . reduce ( 0 , Integer :: sum ) ; double average = sum / ( double ) temperaturesInInterval . size ( ) ; logger . info ( " [ { } ] : ▁ Average : ▁ { } " , this . identifier , average ) ; return new AverageTemperature ( timeCalculated , average ) ; } ) . publish ( ) ; averageTemperatures . connect ( ) ; }
Azure/azure-sdk-for-java | void onTemperatureEvent ( Instant dateEnqueued , int temperature ) { lastReported = dateEnqueued ; temperatures . getAndUpdate ( list -> { list . add ( temperature ) ; return list ; } ) ; }
Azure/azure-sdk-for-java | String getIdentifier ( ) { return identifier ; }
Azure/azure-sdk-for-java | Flux < AverageTemperature > getAverageTemperatures ( ) { return averageTemperatures ; }
Azure/azure-sdk-for-java | public Instant getLastReported ( ) { return lastReported ; }
Azure/azure-sdk-for-java | @ Override public void close ( ) { if ( isDisposed . getAndSet ( true ) ) { return ; } final FluxSink < Boolean > sink = onDispose . sink ( ) ; sink . next ( true ) ; sink . complete ( ) ; }
Azure/azure-sdk-for-java | AverageTemperature ( Instant timeCalculated , Double temperature ) { this . timeCalculated = timeCalculated ; this . temperature = temperature ; }
Azure/azure-sdk-for-java | public Instant getTimeCalculated ( ) { return timeCalculated ; }
Azure/azure-sdk-for-java | public Double getTemperature ( ) { return temperature ; }
xasx/assertj-core | private ShouldEndWith ( Object actual , Object expected , ComparisonStrategy comparisonStrategy ) { super ( " % nExpecting : % n ▁ < % s > % nto ▁ end ▁ with : % n ▁ < % s > % n % s " , actual , expected , comparisonStrategy ) ; }
bstopp/acs-aem-commons | public RefreshFolderTumbnailsTest ( ) { }
bstopp/acs-aem-commons | @ Before public void setUp ( ) { rr = mock ( ResourceResolver . class ) ; doAnswer ( ( Answer ) ( InvocationOnMock invocation ) -> { String path = ( String ) invocation . getArguments ( ) [ 0 ] ; return getResource ( path ) ; } ) . when ( rr ) . getResource ( anyString ( ) ) ; noThumbnail = mockResource ( " / missingThumbnail " ) ; manualThumbnail = mockResource ( " / manual " ) ; mockResource ( " / manual / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / manual / jcr : content / manualThumbnail . png " ) ; automaticThumbnail = mockResource ( " / automatic " ) ; mockResource ( " / automatic / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / automatic / jcr : content / folderThumbnail " , attachBinary ( 2048 ) ) ; placeholderThumbnail = mockResource ( " / placeholder " ) ; mockResource ( " / placeholder / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / placeholder / jcr : content / folderThumbnail " , attachBinary ( 950 ) ) ; outdatedThumbnail = mockResource ( " / outdated " ) ; mockResource ( " / outdated / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / outdated / jcr : content / folderThumbnail " , attachBinary ( 2048 ) ) ; mockResource ( " / outdated / jcr : content / folderThumbnail / jcr : content " , modifiedDateAndPaths ( previousDate , " / automatic " , " / manual " , " / placeholder " ) ) ; currentThumbnail = mockResource ( " / current " ) ; mockResource ( " / current / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / current / jcr : content / folderThumbnail " , attachBinary ( 2048 ) ) ; mockResource ( " / current / jcr : content / folderThumbnail / jcr : content " , modifiedDateAndPaths ( currentDate , " / automatic " , " / manual " , " / placeholder " ) ) ; }
bstopp/acs-aem-commons | @ Test public void basicAssertions ( ) throws IOException { assertTrue ( RefreshFolderTumbnails . isThumbnailMissing ( noThumbnail ) ) ; assertTrue ( RefreshFolderTumbnails . isPlaceholderThumbnail ( placeholderThumbnail ) ) ; assertTrue ( RefreshFolderTumbnails . isThumbnailManual ( manualThumbnail ) ) ; assertTrue ( RefreshFolderTumbnails . isThumbnailAutomatic ( automaticThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanMissingThumbnail ( ) throws Exception { assertTrue ( MISSING . shouldReplace ( noThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( automaticThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( manualThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( placeholderThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( outdatedThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanOutdatedThumbnail ( ) throws Exception { assertTrue ( OUTDATED . shouldReplace ( noThumbnail ) ) ; assertTrue ( OUTDATED . shouldReplace ( automaticThumbnail ) ) ; assertFalse ( OUTDATED . shouldReplace ( manualThumbnail ) ) ; assertTrue ( OUTDATED . shouldReplace ( placeholderThumbnail ) ) ; assertTrue ( OUTDATED . shouldReplace ( outdatedThumbnail ) ) ; assertFalse ( OUTDATED . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanAutomaticOrMissing ( ) throws Exception { assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( noThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( automaticThumbnail ) ) ; assertFalse ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( manualThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( placeholderThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( outdatedThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanAll ( ) throws Exception { assertTrue ( ALL . shouldReplace ( noThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( automaticThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( manualThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( placeholderThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( outdatedThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | public Resource mockResource ( String path , BiConsumer < String , Resource > ... setupFunctions ) { Resource res = mock ( Resource . class ) ; when ( res . getPath ( ) ) . thenReturn ( path ) ; when ( res . getResourceResolver ( ) ) . thenReturn ( rr ) ; doAnswer ( ( Answer ) ( InvocationOnMock invocation ) -> { String relPath = ( String ) invocation . getArguments ( ) [ 0 ] ; return getResource ( path + " / " + relPath ) ; } ) . when ( res ) . getChild ( anyString ( ) ) ; for ( BiConsumer < String , Resource > setup : setupFunctions ) { setup . accept ( path , res ) ; } resources . put ( path , res ) ; return res ; }
bstopp/acs-aem-commons | public Resource getResource ( String path ) { return resources . get ( path ) ; }
bstopp/acs-aem-commons | private BiConsumer < String , Resource > attachBinary ( int size ) { return ( path , res ) -> { when ( res . adaptTo ( InputStream . class ) ) . thenReturn ( new ByteArrayInputStream ( new byte [ size ] ) ) ; } ; }
bstopp/acs-aem-commons | private BiConsumer < String , Resource > modifiedDate ( Date date ) { return ( path , res ) -> { Map < String , Object > map = new HashMap < > ( ) ; map . put ( " jcr : lastModified " , date ) ; when ( res . getValueMap ( ) ) . thenReturn ( new ValueMapDecorator ( map ) ) ; } ; }
bstopp/acs-aem-commons | private BiConsumer < String , Resource > modifiedDateAndPaths ( Date date , String ... paths ) { return ( path , res ) -> { Map < String , Object > map = new HashMap < > ( ) ; map . put ( " jcr : lastModified " , date ) ; map . put ( " dam : folderThumbnailPaths " , paths ) ; when ( res . getValueMap ( ) ) . thenReturn ( new ValueMapDecorator ( map ) ) ; } ; }
bootique/bootique-kafka-client | default DefaultKafkaProducerBuilder < byte [ ] , String > charValueProducer ( ) { return producer ( new ByteArraySerializer ( ) , new StringSerializer ( ) ) ; }
bootique/bootique-kafka-client | default DefaultKafkaProducerBuilder < byte [ ] , byte [ ] > binaryProducer ( ) { return producer ( new ByteArraySerializer ( ) , new ByteArraySerializer ( ) ) ; }
bootique/bootique-kafka-client | default < V > DefaultKafkaProducerBuilder < byte [ ] , V > binaryKeyProducer ( Serializer < V > valueSerializer ) { return producer ( new ByteArraySerializer ( ) , valueSerializer ) ; }
unchartedsoftware/aperture-tiles | protected TileDataMetadataImpl ( ) { _metaData = null ; }
unchartedsoftware/aperture-tiles | @ Override public Collection < String > getMetaDataProperties ( ) { if ( null == _metaData ) return null ; return _metaData . keySet ( ) ; }
unchartedsoftware/aperture-tiles | @ Override public String getMetaData ( String property ) { if ( null != _metaData ) return _metaData . get ( property ) ; return null ; }
unchartedsoftware/aperture-tiles | @ Override public void setMetaData ( String property , Object value ) { if ( null == _metaData ) { _metaData = new HashMap < > ( ) ; } if ( null == value ) { _metaData . put ( property , null ) ; } else { _metaData . put ( property , value . toString ( ) ) ; } }
igarashitm/camel | protected CamelContext createCamelContext ( ) throws Exception { return createSpringCamelContext ( this , " org / apache / camel / spring / processor / logProcessorWithProvidedLoggerTest . xml " ) ; }
Donnerbart/hazelcast | @ Test public void testVersionPattern ( ) { assertTrue ( VERSION_PATTERN . matcher ( "3.1" ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1 - SNAPSHOT " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1 - RC " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1 - RC1 - SNAPSHOT " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1" ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1 - RC " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1 - SNAPSHOT " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1 - RC1 - SNAPSHOT " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( " $ { project . version } " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( " project . version " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3" ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 . RC " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 . SNAPSHOT " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 - RC " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 - SNAPSHOT " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 . " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3.1 . RC " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3.1 . SNAPSHOT " ) . matches ( ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenNull_returnNull ( ) throws Exception { assertEquals ( " " , StringUtil . getterIntoProperty ( " " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenEmpty_returnEmptyString ( ) throws Exception { assertEquals ( " " , StringUtil . getterIntoProperty ( " " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGet_returnUnchanged ( ) throws Exception { assertEquals ( " get " , StringUtil . getterIntoProperty ( " get " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGetFoo_returnFoo ( ) throws Exception { assertEquals ( " foo " , StringUtil . getterIntoProperty ( " getFoo " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGetF_returnF ( ) throws Exception { assertEquals ( " f " , StringUtil . getterIntoProperty ( " getF " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGetNumber_returnNumber ( ) throws Exception { assertEquals ( "8" , StringUtil . getterIntoProperty ( " get8" ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenPropertyIsLowerCase_DoNotChange ( ) throws Exception { assertEquals ( " getfoo " , StringUtil . getterIntoProperty ( " getfoo " ) ) ; }
Donnerbart/hazelcast | @ Test public void test_lowerCaseFirstChar ( ) { assertEquals ( " " , StringUtil . lowerCaseFirstChar ( " " ) ) ; assertEquals ( " . " , StringUtil . lowerCaseFirstChar ( " . " ) ) ; assertEquals ( " ▁ " , StringUtil . lowerCaseFirstChar ( " ▁ " ) ) ; assertEquals ( " a " , StringUtil . lowerCaseFirstChar ( " a " ) ) ; assertEquals ( " a " , StringUtil . lowerCaseFirstChar ( " A " ) ) ; assertEquals ( " aBC " , StringUtil . lowerCaseFirstChar ( " ABC " ) ) ; assertEquals ( " abc " , StringUtil . lowerCaseFirstChar ( " Abc " ) ) ; }
Donnerbart/hazelcast | @ Test public void testSplitByComma ( ) throws Exception { assertNull ( StringUtil . splitByComma ( null , true ) ) ; assertArrayEquals ( arr ( " " ) , StringUtil . splitByComma ( " " , true ) ) ; assertArrayEquals ( arr ( " " ) , StringUtil . splitByComma ( " ▁ " , true ) ) ; assertArrayEquals ( arr ( ) , StringUtil . splitByComma ( " ▁ " , false ) ) ; assertArrayEquals ( arr ( " a " ) , StringUtil . splitByComma ( " a " , true ) ) ; assertArrayEquals ( arr ( " a " ) , StringUtil . splitByComma ( " a " , false ) ) ; assertArrayEquals ( arr ( " aa " , " bbb " , " c " ) , StringUtil . splitByComma ( " aa , bbb , c " , true ) ) ; assertArrayEquals ( arr ( " aa " , " bbb " , " c " , " " ) , StringUtil . splitByComma ( " ▁ aa\t , \n bbb ▁ ▁ ▁ , \r ▁ c , ▁ ▁ " , true ) ) ; assertArrayEquals ( arr ( " aa " , " bbb " , " c " ) , StringUtil . splitByComma ( " ▁ ▁ aa ▁ , \n , \r \tbbb ▁ ▁ , c ▁ , ▁ " , false ) ) ; }
Donnerbart/hazelcast | @ Test public void testArrayIntersection ( ) throws Exception { assertArrayEquals ( arr ( " test " ) , StringUtil . intersection ( arr ( " x " , " test " , " y " , " z " ) , arr ( " a " , " b " , " test " ) ) ) ; assertArrayEquals ( arr ( " " ) , StringUtil . intersection ( arr ( " " , " z " ) , arr ( " a " , " " ) ) ) ; assertArrayEquals ( arr ( ) , StringUtil . intersection ( arr ( " " , " z " ) , arr ( " a " ) ) ) ; }
Donnerbart/hazelcast | @ Test public void testArraySubraction ( ) throws Exception { assertNull ( StringUtil . subraction ( null , arr ( " a " , " test " , " b " , " a " ) ) ) ; assertArrayEquals ( arr ( " a " , " test " , " b " , " a " ) , StringUtil . subraction ( arr ( " a " , " test " , " b " , " a " ) , null ) ) ; assertArrayEquals ( arr ( " test " ) , StringUtil . subraction ( arr ( " a " , " test " , " b " , " a " ) , arr ( " a " , " b " ) ) ) ; assertArrayEquals ( arr ( ) , StringUtil . subraction ( arr ( ) , arr ( " a " , " b " ) ) ) ; assertArrayEquals ( arr ( " a " , " b " ) , StringUtil . subraction ( arr ( " a " , " b " ) , arr ( ) ) ) ; assertArrayEquals ( arr ( ) , StringUtil . subraction ( arr ( " a " , " test " , " b " , " a " ) , arr ( " a " , " b " , " test " ) ) ) ; }
Donnerbart/hazelcast | @ Test public void testEqualsIgnoreCase ( ) throws Exception { assertFalse ( StringUtil . equalsIgnoreCase ( null , null ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( null , " a " ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( " a " , null ) ) ; assertTrue ( StringUtil . equalsIgnoreCase ( " TEST " , " test " ) ) ; assertTrue ( StringUtil . equalsIgnoreCase ( " test " , " TEST " ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( " test " , " TEST2" ) ) ; Locale defaultLocale = Locale . getDefault ( ) ; Locale . setDefault ( new Locale ( " tr " ) ) ; try { assertTrue ( StringUtil . equalsIgnoreCase ( " EXIT " , " exit " ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( " exıt " , " EXIT " ) ) ; } finally { Locale . setDefault ( defaultLocale ) ; } }
Donnerbart/hazelcast | private String [ ] arr ( String ... strings ) { return strings ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( ) { super ( ) ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( String message ) { super ( message ) ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( String message , Throwable cause ) { super ( message , cause ) ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( Throwable cause ) { super ( cause ) ; }
ibek/jbpm | @ Before @ Override public void deployKieJar ( ) { if ( kieJar == null ) { kieJar = archive . deployMigrationV1KieJar ( ) . getIdentifier ( ) ; } if ( kieJar2 == null ) { kieJar2 = archive . deployMigrationV2KieJar ( ) . getIdentifier ( ) ; } }
ibek/jbpm | @ After @ Override public void cleanup ( ) { super . cleanup ( ) ; kieJar2 = null ; }
ibek/jbpm | @ Test public void testUpgradeProcessInstance ( ) throws Exception { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; TaskSummary task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; MigrationReport report = migrationService . migrate ( kieJar , processInstanceId , kieJar2 , EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( report ) . isNotNull ( ) ; Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; userTaskService . completeAutoProgress ( task . getId ( ) , USER_YODA , null ) ; tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; }
ibek/jbpm | @ Test public void testUpgradeProcessInstanceWithNodeMapping ( ) throws Exception { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; TaskSummary task = tasks . get ( 0 ) ; Assertions . assertThat ( tasks . get ( 0 ) . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; Map < String , String > nodeMapping = new HashMap < String , String > ( ) ; nodeMapping . put ( " _ 4E8E7545 - FB70-494E - 9136-2B9ABE655889" , " _ 56FB3E50 - DEDD - 415B - 94DD - 0357C91836B9" ) ; MigrationReport report = migrationService . migrate ( kieJar , processInstanceId , kieJar2 , EVALUATION_PROCESS_ID_V2 , nodeMapping ) ; Assertions . assertThat ( report ) . isNotNull ( ) ; Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; }
ibek/jbpm | @ Test public void testUpgradeProcessInstances ( ) throws Exception { List < Long > ids = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; ids . add ( processInstanceId ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; } List < MigrationReport > reports = migrationService . migrate ( kieJar , ids , kieJar2 , EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( reports ) . isNotNull ( ) ; for ( MigrationReport report : reports ) { Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; } tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; userTaskService . completeAutoProgress ( task . getId ( ) , USER_YODA , null ) ; } tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; } }
ibek/jbpm | @ Test public void testUpgradeProcessInstancesWithNodeMapping ( ) throws Exception { List < Long > ids = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; ids . add ( processInstanceId ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; } Map < String , String > nodeMapping = new HashMap < String , String > ( ) ; nodeMapping . put ( " _ 4E8E7545 - FB70-494E - 9136-2B9ABE655889" , " _ 56FB3E50 - DEDD - 415B - 94DD - 0357C91836B9" ) ; List < MigrationReport > reports = migrationService . migrate ( kieJar , ids , kieJar2 , EVALUATION_PROCESS_ID_V2 , nodeMapping ) ; Assertions . assertThat ( reports ) . isNotNull ( ) ; for ( MigrationReport report : reports ) { Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; } tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; } }
Azure/azure-sdk-for-java | public String name ( ) { return this . name ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withName ( String name ) { this . name = name ; return this ; }
Azure/azure-sdk-for-java | public ClientDiscoveryDisplay display ( ) { return this . display ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withDisplay ( ClientDiscoveryDisplay display ) { this . display = display ; return this ; }
Azure/azure-sdk-for-java | public String origin ( ) { return this . origin ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withOrigin ( String origin ) { this . origin = origin ; return this ; }
Azure/azure-sdk-for-java | public ClientDiscoveryForProperties properties ( ) { return this . properties ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withProperties ( ClientDiscoveryForProperties properties ) { this . properties = properties ; return this ; }
Azure/azure-sdk-for-java | public void validate ( ) { if ( display ( ) != null ) { display ( ) . validate ( ) ; } if ( properties ( ) != null ) { properties ( ) . validate ( ) ; } }
GunoH/intellij-community | public InternalTestDiscoveryListener ( ) { myTracesFile = System . getProperty ( " org . jetbrains . instrumentation . trace . file " ) ; if ( myTracesFile == null ) throw new IllegalArgumentException ( ) ; myModuleName = System . getProperty ( " org . jetbrains . instrumentation . main . module " ) ; if ( myModuleName == null ) throw new IllegalArgumentException ( ) ; System . out . println ( getClass ( ) . getSimpleName ( ) + " ▁ instantiated ▁ with ▁ module = ' " + myModuleName + " ' ▁ , ▁ directory = ' " + myTracesFile + " ' " ) ; }
GunoH/intellij-community | private Object getIndex ( ) { if ( myDiscoveryIndex == null ) { Project project = ProjectManager . getInstance ( ) . getDefaultProject ( ) ; try { myDiscoveryIndexClass = Class . forName ( " com . intellij . execution . testDiscovery . TestDiscoveryIndex " ) ; myDiscoveryIndex = myDiscoveryIndexClass . getConstructor ( Project . class , String . class ) . newInstance ( project , myTracesFile ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } return myDiscoveryIndex ; }
GunoH/intellij-community | @ Override public void close ( ) { System . out . println ( " Start ▁ compacting ▁ to ▁ index " ) ; try { Object index = getIndex ( ) ; Method method = Class . forName ( " com . intellij . execution . testDiscovery . TestDiscoveryExtension " ) . getMethod ( " processTracesFile " , String . class , String . class , String . class , myDiscoveryIndexClass ) ; method . invoke ( null , myTracesFile , myModuleName , " j " , index ) ; System . out . println ( " Compacting ▁ done . " ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } zipOutput ( myTracesFile ) ; }
nikelin/Redshape-AS | public ReferenceStatement ( String value ) { super ( value ) ; }
PATRIC3/p3_solr | public ScaleFloatFunction ( ValueSource source , float min , float max ) { this . source = source ; this . min = min ; this . max = max ; }
PATRIC3/p3_solr | @ Override public String description ( ) { return " scale ( " + source . description ( ) + " , " + min + " , " + max + " ) " ; }
PATRIC3/p3_solr | private ScaleInfo createScaleInfo ( Map context , LeafReaderContext readerContext ) throws IOException { final List < LeafReaderContext > leaves = ReaderUtil . getTopLevelContext ( readerContext ) . leaves ( ) ; float minVal = Float . POSITIVE_INFINITY ; float maxVal = Float . NEGATIVE_INFINITY ; for ( LeafReaderContext leaf : leaves ) { int maxDoc = leaf . reader ( ) . maxDoc ( ) ; FunctionValues vals = source . getValues ( context , leaf ) ; for ( int i = 0 ; i < maxDoc ; i ++ ) { if ( ! vals . exists ( i ) ) { continue ; } float val = vals . floatVal ( i ) ; if ( ( Float . floatToRawIntBits ( val ) & ( 0xff << 23 ) ) == 0xff << 23 ) { continue ; } if ( val < minVal ) { minVal = val ; } if ( val > maxVal ) { maxVal = val ; } } } if ( minVal == Float . POSITIVE_INFINITY ) { minVal = maxVal = 0 ; } ScaleInfo scaleInfo = new ScaleInfo ( ) ; scaleInfo . minVal = minVal ; scaleInfo . maxVal = maxVal ; context . put ( ScaleFloatFunction . this , scaleInfo ) ; return scaleInfo ; }
PATRIC3/p3_solr | @ Override public FunctionValues getValues ( Map context , LeafReaderContext readerContext ) throws IOException { ScaleInfo scaleInfo = ( ScaleInfo ) context . get ( ScaleFloatFunction . this ) ; if ( scaleInfo == null ) { scaleInfo = createScaleInfo ( context , readerContext ) ; } final float scale = ( scaleInfo . maxVal - scaleInfo . minVal == 0 ) ? 0 : ( max - min ) / ( scaleInfo . maxVal - scaleInfo . minVal ) ; final float minSource = scaleInfo . minVal ; final float maxSource = scaleInfo . maxVal ; final FunctionValues vals = source . getValues ( context , readerContext ) ; return new FloatDocValues ( this ) { @ Override public boolean exists ( int doc ) { return vals . exists ( doc ) ; } @ Override public float floatVal ( int doc ) { return ( vals . floatVal ( doc ) - minSource ) * scale + min ; } @ Override public String toString ( int doc ) { return " scale ( " + vals . toString ( doc ) + " , toMin = " + min + " , toMax = " + max + " , fromMin = " + minSource + " , fromMax = " + maxSource + " ) " ; } } ; }
PATRIC3/p3_solr | @ Override public void createWeight ( Map context , IndexSearcher searcher ) throws IOException { source . createWeight ( context , searcher ) ; }
PATRIC3/p3_solr | @ Override public int hashCode ( ) { int h = Float . floatToIntBits ( min ) ; h = h * 29 ; h += Float . floatToIntBits ( max ) ; h = h * 29 ; h += source . hashCode ( ) ; return h ; }
PATRIC3/p3_solr | @ Override public boolean equals ( Object o ) { if ( ScaleFloatFunction . class != o . getClass ( ) ) return false ; ScaleFloatFunction other = ( ScaleFloatFunction ) o ; return this . min == other . min && this . max == other . max && this . source . equals ( other . source ) ; }
chhh/MSFTBX | public String getOrganizationRef ( ) { return organizationRef ; }
chhh/MSFTBX | public void setOrganizationRef ( String value ) { this . organizationRef = value ; }
selvasingh/azure-sdk-for-java | public Permission ( ) { super ( ) ; }
selvasingh/azure-sdk-for-java | public Permission ( String jsonString ) { super ( jsonString ) ; }
selvasingh/azure-sdk-for-java | public Permission setId ( String id ) { super . setId ( id ) ; return this ; }
selvasingh/azure-sdk-for-java | public String getResourceLink ( ) { return super . getString ( Constants . Properties . RESOURCE_LINK ) ; }
selvasingh/azure-sdk-for-java | public void setResourceLink ( String resourceLink ) { BridgeInternal . setProperty ( this , Constants . Properties . RESOURCE_LINK , resourceLink ) ; }
selvasingh/azure-sdk-for-java | public PermissionMode getPermissionMode ( ) { String value = super . getString ( Constants . Properties . PERMISSION_MODE ) ; return PermissionMode . valueOf ( StringUtils . upperCase ( value ) ) ; }
selvasingh/azure-sdk-for-java | public void setPermissionMode ( PermissionMode permissionMode ) { BridgeInternal . setProperty ( this , Constants . Properties . PERMISSION_MODE , permissionMode . toString ( ) . toLowerCase ( Locale . ROOT ) ) ; }
selvasingh/azure-sdk-for-java | public String getToken ( ) { return super . getString ( Constants . Properties . TOKEN ) ; }
selvasingh/azure-sdk-for-java | public PartitionKey getResourcePartitionKey ( ) { PartitionKey key = null ; Object value = super . get ( Constants . Properties . RESOURCE_PARTITION_KEY ) ; if ( value != null ) { ArrayNode arrayValue = ( ArrayNode ) value ; key = new PartitionKey ( BridgeInternal . getValue ( arrayValue . get ( 0 ) ) ) ; } return key ; }
selvasingh/azure-sdk-for-java | public void setResourcePartitionKey ( PartitionKey partitionkey ) { BridgeInternal . setProperty ( this , Constants . Properties . RESOURCE_PARTITION_KEY , BridgeInternal . getPartitionKeyInternal ( partitionkey ) . toJson ( ) ) ; }
haakom/EnergiWeb-remake | public RadiusReader ( ) { this . counter = 0 ; }
haakom/EnergiWeb-remake | public RadiusData readData ( ) { RadiusData data = new RadiusData ( ) ; FileReader is = null ; try { is = new FileReader ( new File ( " / etc / freeradius / users " ) ) ; BufferedReader in = new BufferedReader ( is ) ; boolean fReadMore = true ; while ( fReadMore ) { java . util . List < String > lines = new java . util . ArrayList < String > ( ) ; while ( lines . size ( ) < 6 ) { String strLine = in . readLine ( ) ; if ( strLine == null ) { fReadMore = false ; break ; } if ( ! strLine . startsWith ( " # " ) ) lines . add ( strLine ) ; } if ( lines . size ( ) == 6 ) { parseSegment ( lines , data ) ; counter ++ ; } } } catch ( IOException ex ) { LogWriter . elog ( ex , " RadiusReader . readData : ▁ count = " + counter ) ; } finally { if ( is != null ) try { is . close ( ) ; } catch ( IOException e ) { } } return data ; }
haakom/EnergiWeb-remake | private void parseSegment ( java . util . List < String > lines , RadiusData data ) { TerminalLink term1 = createTerminalLink ( lines , 0 ) ; TerminalLink term2 = createTerminalLink ( lines , 3 ) ; if ( term1 == null || term2 == null ) { LogWriter . elog ( " RadiusReader : ▁ data ▁ missing ▁ at ▁ segment ▁ " + counter ) ; return ; } String simId = term1 . getSIMCardId ( ) ; if ( ! simId . equals ( term2 . getSIMCardId ( ) ) ) { LogWriter . elog ( " RadiusReader : ▁ error ▁ in ▁ segment ▁ " + counter ) ; return ; } data . addSegment ( new IOSegment ( simId , term1 , term2 ) ) ; }
haakom/EnergiWeb-remake | private TerminalLink createTerminalLink ( java . util . List < String > lines , int idx ) { String strLine1 = lines . get ( idx ) ; if ( strLine1 . indexOf ( " Calling - Station - Id " ) < 0 ) return null ; String [ ] strArray = strLine1 . split ( " , " ) ; if ( strArray == null || strArray . length != 4 ) return null ; String simCardId = null ; String phoneNr = null ; String ipAddr = null ; String nasIdent = null ; String setupStr = null ; String [ ] strArr = strArray [ 0 ] . split ( " ▁ " ) ; if ( strArr == null || strArr . length > 0 ) simCardId = strArr [ 0 ] . trim ( ) ; strArr = strArray [ 2 ] . split ( " = = " ) ; if ( strArr == null || strArr . length > 1 ) phoneNr = strArr [ 1 ] . replaceAll ( " \" " , " " ) ; strArr = strArray [ 3 ] . split ( " = = " ) ; if ( strArr == null || strArr . length > 1 ) nasIdent = strArr [ 1 ] . replaceAll ( " \" " , " " ) ; String strLine2 = lines . get ( idx + 1 ) ; strArr = strLine2 . split ( " = " ) ; if ( strArr == null || strArr . length > 1 ) ipAddr = strArr [ 1 ] . replaceAll ( " , " , " " ) ; String strLine3 = lines . get ( idx + 2 ) ; if ( strLine3 . length ( ) > 0 ) setupStr = strLine3 . trim ( ) ; if ( simCardId == null || phoneNr == null || ipAddr == null ) return null ; return new TerminalLink ( simCardId , phoneNr . trim ( ) , ipAddr . trim ( ) , nasIdent . trim ( ) , setupStr ) ; }
amit-jain/jackrabbit-oak | void sync ( @ NotNull ExternalUser externalUser ) throws Exception { Root systemRoot = getSystemRoot ( ) ; DynamicSyncContext syncContext = new DynamicSyncContext ( syncConfig , idp , getUserManager ( systemRoot ) , getValueFactory ( systemRoot ) ) ; syncContext . sync ( externalUser ) ; syncContext . close ( ) ; systemRoot . commit ( ) ; root . refresh ( ) ; }
amit-jain/jackrabbit-oak | @ NotNull Set < Principal > getExpectedGroupPrincipals ( @ NotNull String userId ) throws Exception { if ( syncConfig . user ( ) . getMembershipNestingDepth ( ) == 1 ) { Set < Principal > principals = ImmutableSet . copyOf ( Iterables . transform ( idp . getUser ( userId ) . getDeclaredGroups ( ) , ( Function < ExternalIdentityRef , Principal > ) input -> { try { return new PrincipalImpl ( idp . getIdentity ( input ) . getPrincipalName ( ) ) ; } catch ( ExternalIdentityException e ) { throw new RuntimeException ( e ) ; } } ) ) ; return principals ; } else { Set < Principal > set = new HashSet < > ( ) ; collectExpectedPrincipals ( set , idp . getUser ( userId ) . getDeclaredGroups ( ) , syncConfig . user ( ) . getMembershipNestingDepth ( ) ) ; return set ; } }
amit-jain/jackrabbit-oak | @ NotNull Set < Principal > getExpectedAllSearchResult ( @ NotNull String userId ) throws Exception { return getExpectedGroupPrincipals ( userId ) ; }
amit-jain/jackrabbit-oak | private void collectExpectedPrincipals ( Set < Principal > grPrincipals , @ NotNull Iterable < ExternalIdentityRef > declaredGroups , long depth ) throws Exception { if ( depth <= 0 ) { return ; } for ( ExternalIdentityRef ref : declaredGroups ) { ExternalIdentity ei = idp . getIdentity ( ref ) ; grPrincipals . add ( new PrincipalImpl ( ei . getPrincipalName ( ) ) ) ; collectExpectedPrincipals ( grPrincipals , ei . getDeclaredGroups ( ) , depth - 1 ) ; } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalLocalUser ( ) throws Exception { assertNull ( principalProvider . getPrincipal ( getTestUser ( ) . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalLocalGroup ( ) throws Exception { Group gr = createTestGroup ( ) ; assertNull ( principalProvider . getPrincipal ( gr . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalExternalUser ( ) throws Exception { UserManager userManager = getUserManager ( root ) ; User syncedUser = userManager . getAuthorizable ( USER_ID , User . class ) ; assertNull ( principalProvider . getPrincipal ( syncedUser . getPrincipal ( ) . getName ( ) ) ) ; syncedUser = userManager . getAuthorizable ( TestIdentityProvider . ID_SECOND_USER , User . class ) ; assertNull ( principalProvider . getPrincipal ( syncedUser . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalExternalGroup ( ) throws Exception { Group gr = getUserManager ( root ) . getAuthorizable ( " secondGroup " , Group . class ) ; assertNotNull ( gr ) ; assertNull ( principalProvider . getPrincipal ( gr . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalDynamicGroup ( ) throws Exception { for ( ExternalIdentityRef ref : idp . getUser ( USER_ID ) . getDeclaredGroups ( ) ) { String princName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; Principal principal = principalProvider . getPrincipal ( princName ) ; assertNotNull ( principal ) ; assertTrue ( principal instanceof GroupPrincipal ) ; } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalInheritedGroups ( ) throws Exception { ImmutableSet < ExternalIdentityRef > declared = ImmutableSet . < ExternalIdentityRef > copyOf ( idp . getUser ( USER_ID ) . getDeclaredGroups ( ) ) ; for ( ExternalIdentityRef ref : declared ) { for ( ExternalIdentityRef inheritedGroupRef : idp . getIdentity ( ref ) . getDeclaredGroups ( ) ) { if ( declared . contains ( inheritedGroupRef ) ) { continue ; } String inheritedPrincName = idp . getIdentity ( inheritedGroupRef ) . getPrincipalName ( ) ; assertNull ( principalProvider . getPrincipal ( inheritedPrincName ) ) ; } } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalUnderscoreSign ( ) throws Exception { ExternalUser externalUser = idp . getUser ( USER_ID ) ; for ( ExternalIdentityRef ref : externalUser . getDeclaredGroups ( ) ) { String pName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; for ( String n : new String [ ] { " _ " , " _ " + pName . substring ( 1 ) , pName . substring ( 0 , pName . length ( ) - 1 ) + " _ " } ) { assertNull ( principalProvider . getPrincipal ( n ) ) ; } } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalPercentSign ( ) throws Exception { ExternalUser externalUser = idp . getUser ( USER_ID ) ; for ( ExternalIdentityRef ref : externalUser . getDeclaredGroups ( ) ) { String pName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; for ( String n : new String [ ] { " % " , " % " + pName , pName + " % " , pName . charAt ( 0 ) + " % " } ) { assertNull ( principalProvider . getPrincipal ( n ) ) ; } } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalGroupsWithQueryWildCard ( ) throws Exception { ExternalUser externalUser = idp . getUser ( TestIdentityProvider . ID_WILDCARD_USER ) ; sync ( externalUser ) ; for ( ExternalIdentityRef ref : externalUser . getDeclaredGroups ( ) ) { String pName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; Principal p = principalProvider . getPrincipal ( pName ) ; assertNotNull ( p ) ; assertEquals ( pName , p . getName ( ) ) ; } }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipLocalPrincipal ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( getTestUser ( ) . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipLocalGroupPrincipal ( ) throws Exception { Group gr = createTestGroup ( ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( gr . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( gr . getPrincipal ( ) . getName ( ) ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipExternalUser ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( USER_ID ) ; assertNotNull ( user ) ; Set < Principal > expected = getExpectedGroupPrincipals ( USER_ID ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( user . getPrincipal ( ) ) ; assertEquals ( expected , principals ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipExternalUser2 ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( USER_ID ) ; assertNotNull ( user ) ; Set < Principal > expected = getExpectedGroupPrincipals ( USER_ID ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( user . getPrincipal ( ) . getName ( ) ) ) ; assertEquals ( expected , principals ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipDefaultSync ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( TestIdentityProvider . ID_SECOND_USER ) ; assertNotNull ( user ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( user . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipDefaultSync2 ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( TestIdentityProvider . ID_SECOND_USER ) ; assertNotNull ( user ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( user . getPrincipal ( ) . getName ( ) ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipExternalGroup ( ) throws Exception { Authorizable group = getUserManager ( root ) . getAuthorizable ( " secondGroup " ) ; assertNotNull ( group ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( group . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( group . getPrincipal ( ) . getName ( ) ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsLocalUser ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getPrincipals ( getTestUser ( ) . getID ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsLocalGroup ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getPrincipals ( createTestGroup ( ) . getID ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsExternalUser ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getPrincipals ( USER_ID ) ; assertEquals ( getExpectedGroupPrincipals ( USER_ID ) , principals ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsExternalUser2 ( ) { Set < ? extends Principal > principals = principalProvider . getPrincipals ( TestIdentityProvider . ID_SECOND_USER ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsExternalGroup ( ) throws Exception { Authorizable authorizable = getUserManager ( root ) . getAuthorizable ( " secondGroup " ) ; assertNotNull ( authorizable ) ; Set < ? extends Principal > principals = principalProvider . getPrincipals ( authorizable . getID ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsNonExistingUser ( ) throws Exception { assertNull ( getUserManager ( root ) . getAuthorizable ( " nonExistingUser " ) ) ; Set < ? extends Principal > principals = principalProvider . getPrincipals ( " nonExistingUser " ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsNonExistingUserTree ( ) throws Exception { Authorizable a = spy ( getUserManager ( root ) . getAuthorizable ( USER_ID ) ) ; when ( a . getPath ( ) ) . thenReturn ( " / path / to / non / existing / item " ) ; UserManager um = when ( mock ( UserManager . class ) . getAuthorizable ( USER_ID ) ) . thenReturn ( a ) . getMock ( ) ; UserConfiguration uc = when ( mock ( UserConfiguration . class ) . getUserManager ( root , getNamePathMapper ( ) ) ) . thenReturn ( um ) . getMock ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( root , uc , getNamePathMapper ( ) , ImmutableMap . of ( idp . getName ( ) , getAutoMembership ( ) ) ) ; assertTrue ( pp . getPrincipals ( USER_ID ) . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsForGroupTree ( ) throws Exception { Authorizable group = getUserManager ( root ) . createGroup ( " testGroup " ) ; Authorizable a = spy ( getUserManager ( root ) . getAuthorizable ( USER_ID ) ) ; when ( a . getPath ( ) ) . thenReturn ( group . getPath ( ) ) ; UserManager um = when ( mock ( UserManager . class ) . getAuthorizable ( USER_ID ) ) . thenReturn ( a ) . getMock ( ) ; UserConfiguration uc = when ( mock ( UserConfiguration . class ) . getUserManager ( root , getNamePathMapper ( ) ) ) . thenReturn ( um ) . getMock ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( root , uc , getNamePathMapper ( ) , ImmutableMap . of ( idp . getName ( ) , getAutoMembership ( ) ) ) ; assertTrue ( pp . getPrincipals ( USER_ID ) . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsMissingIdpName ( ) throws Exception { String userPath = getUserManager ( root ) . getAuthorizable ( USER_ID ) . getPath ( ) ; Tree t = root . getTree ( userPath ) ; t . removeProperty ( REP_EXTERNAL_ID ) ; String [ ] automembership = getAutoMembership ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( root , getUserConfiguration ( ) , getNamePathMapper ( ) , ImmutableMap . of ( idp . getName ( ) , automembership ) ) ; Set < ? extends Principal > principals = pp . getPrincipals ( USER_ID ) ; assertFalse ( principals . isEmpty ( ) ) ; assertFalse ( principals . removeAll ( ImmutableSet . copyOf ( automembership ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByHintTypeNotGroup ( ) { Iterator < ? extends Principal > iter = principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_NOT_GROUP ) ; assertSame ( Collections . emptyIterator ( ) , iter ) ; Iterator < ? extends Principal > iter2 = principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_NOT_GROUP , 0 , - 1 ) ; assertSame ( Collections . emptyIterator ( ) , iter2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByHintTypeGroup ( ) { Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " a " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_GROUP ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByHintTypeAll ( ) { Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " a " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsContainingUnderscore ( ) throws Exception { ExternalUser externalUser = idp . getUser ( TestIdentityProvider . ID_WILDCARD_USER ) ; sync ( externalUser ) ; Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " _ gr _ u _ " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " _ " , PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " _ " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsContainingPercentSign ( ) throws Exception { ExternalUser externalUser = idp . getUser ( TestIdentityProvider . ID_WILDCARD_USER ) ; sync ( externalUser ) ; Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " g % r % " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " % " , PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " % " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByTypeNotGroup ( ) { Iterator < ? extends Principal > iter = principalProvider . findPrincipals ( PrincipalManager . SEARCH_TYPE_NOT_GROUP ) ; assertSame ( Collections . emptyIterator ( ) , iter ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByTypeGroup ( ) throws Exception { Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( PrincipalManager . SEARCH_TYPE_GROUP ) ) ; assertEquals ( getExpectedAllSearchResult ( USER_ID ) , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , - 1 ) ) ; assertEquals ( getExpectedAllSearchResult ( USER_ID ) , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByTypeAll ( ) throws Exception { Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( getExpectedAllSearchResult ( USER_ID ) , res ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsFiltersDuplicates ( ) throws Exception { ExternalGroup gr = idp . getGroup ( " a " ) ; ExternalUser otherUser = new TestUser ( " anotherUser " , ImmutableSet . of ( gr . getExternalId ( ) ) ) ; sync ( otherUser ) ; Set < Principal > expected = new HashSet < > ( ) ; expected . add ( new PrincipalImpl ( gr . getPrincipalName ( ) ) ) ; long depth = syncConfig . user ( ) . getMembershipNestingDepth ( ) ; if ( depth > 1 ) { collectExpectedPrincipals ( expected , gr . getDeclaredGroups ( ) , -- depth ) ; } Iterator < ? extends Principal > res = principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_ALL ) ; assertTrue ( res . hasNext ( ) ) ; assertEquals ( expected , ImmutableSet . copyOf ( res ) ) ; Iterator < ? extends Principal > res2 = principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ; assertTrue ( res2 . hasNext ( ) ) ; assertEquals ( expected , ImmutableSet . copyOf ( res2 ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsSorted ( ) throws Exception { List < Principal > in = Arrays . asList ( new PrincipalImpl ( " p3" ) , new PrincipalImpl ( " p1" ) , new PrincipalImpl ( " p2" ) ) ; ExternalGroupPrincipalProvider p = new ExternalGroupPrincipalProvider ( root , getSecurityProvider ( ) . getConfiguration ( UserConfiguration . class ) , NamePathMapper . DEFAULT , ImmutableMap . of ( idp . getName ( ) , getAutoMembership ( ) ) ) { @ NotNull @ Override public Iterator < ? extends Principal > findPrincipals ( @ Nullable String nameHint , int searchType ) { return in . iterator ( ) ; } } ; List < Principal > out = ImmutableList . copyOf ( p . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; Collections . sort ( in , Comparator . comparing ( Principal :: getName ) ) ; assertEquals ( in , out ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffset ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; long offset = 2 ; long expectedSize = ( all . size ( ) <= offset ) ? 0 : all . size ( ) - offset ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , offset , - 1 ) ) ; assertEquals ( expectedSize , result . size ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffsetEqualsResultSize ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , all . size ( ) , - 1 ) ) ; assertTrue ( result . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffsetExceedsResultSize ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , all . size ( ) + 1 , - 1 ) ) ; assertTrue ( result . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithLimit ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , 1 ) ) ; assertEquals ( 1 , result . size ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithLimitExceedsResultSize ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , all . size ( ) + 1 ) ) ; assertEquals ( all , result ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithZeroLimit ( ) throws Exception { Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , 0 ) ) ; assertTrue ( result . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffsetAndLimit ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; long offset = all . size ( ) - 1 ; long limit = all . size ( ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , offset , limit ) ) ; assertEquals ( 1 , result . size ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithParseException ( ) throws Exception { QueryEngine qe = mock ( QueryEngine . class ) ; when ( qe . executeQuery ( anyString ( ) , anyString ( ) , any ( Map . class ) , any ( Map . class ) ) ) . thenThrow ( new ParseException ( " fail " , 0 ) ) ; Root r = when ( mock ( Root . class ) . getQueryEngine ( ) ) . thenReturn ( qe ) . getMock ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( r , getUserConfiguration ( ) , getNamePathMapper ( ) , Collections . emptyMap ( ) ) ; assertNull ( pp . getPrincipal ( " a " ) ) ; assertFalse ( pp . findPrincipals ( PrincipalManager . SEARCH_TYPE_GROUP ) . hasNext ( ) ) ; }
amit-jain/jackrabbit-oak | private TestUser ( @ NotNull String id , @ NotNull Iterable < ExternalIdentityRef > declaredGroups ) { super ( id ) ; this . declaredGroups = declaredGroups ; }
amit-jain/jackrabbit-oak | @ NotNull @ Override public Iterable < ExternalIdentityRef > getDeclaredGroups ( ) { return declaredGroups ; }
DieBauer/flink | @ Before public void setPartitioner ( ) { distributePartitioner = new RescalePartitioner < Tuple > ( ) ; }
DieBauer/flink | @ Test public void testSelectChannelsLength ( ) { sd . setInstance ( streamRecord ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 1 ) . length ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 2 ) . length ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 1024 ) . length ) ; }
DieBauer/flink | @ Test public void testSelectChannelsInterval ( ) { sd . setInstance ( streamRecord ) ; assertEquals ( 0 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 2 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 0 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; }
DieBauer/flink | @ Test public void testExecutionGraphGeneration ( ) throws Exception { final StreamExecutionEnvironment env = StreamExecutionEnvironment . getExecutionEnvironment ( ) ; env . setParallelism ( 4 ) ; DataStream < String > text = env . addSource ( new ParallelSourceFunction < String > ( ) { private static final long serialVersionUID = 7772338606389180774L ; @ Override public void run ( SourceContext < String > ctx ) throws Exception { } @ Override public void cancel ( ) { } } ) . setParallelism ( 2 ) ; DataStream < Tuple2 < String , Integer > > counts = text . rescale ( ) . flatMap ( new FlatMapFunction < String , Tuple2 < String , Integer > > ( ) { private static final long serialVersionUID = - 5255930322161596829L ; @ Override public void flatMap ( String value , Collector < Tuple2 < String , Integer > > out ) throws Exception { } } ) ; counts . rescale ( ) . print ( ) . setParallelism ( 2 ) ; JobGraph jobGraph = env . getStreamGraph ( ) . getJobGraph ( ) ; final JobID jobId = new JobID ( ) ; final String jobName = " Semi - Rebalance ▁ Test ▁ Job " ; final Configuration cfg = new Configuration ( ) ; List < JobVertex > jobVertices = jobGraph . getVerticesSortedTopologicallyFromSources ( ) ; JobVertex sourceVertex = jobVertices . get ( 0 ) ; JobVertex mapVertex = jobVertices . get ( 1 ) ; JobVertex sinkVertex = jobVertices . get ( 2 ) ; assertEquals ( 2 , sourceVertex . getParallelism ( ) ) ; assertEquals ( 4 , mapVertex . getParallelism ( ) ) ; assertEquals ( 2 , sinkVertex . getParallelism ( ) ) ; ExecutionGraph eg = new ExecutionGraph ( TestingUtils . defaultExecutor ( ) , TestingUtils . defaultExecutor ( ) , jobId , jobName , cfg , new SerializedValue < > ( new ExecutionConfig ( ) ) , AkkaUtils . getDefaultTimeout ( ) , new NoRestartStrategy ( ) , new ArrayList < BlobKey > ( ) , new ArrayList < URL > ( ) , new Scheduler ( TestingUtils . defaultExecutionContext ( ) ) , ExecutionGraph . class . getClassLoader ( ) ) ; try { eg . attachJobGraph ( jobVertices ) ; } catch ( JobException e ) { e . printStackTrace ( ) ; fail ( " Building ▁ ExecutionGraph ▁ failed : ▁ " + e . getMessage ( ) ) ; } ExecutionJobVertex execSourceVertex = eg . getJobVertex ( sourceVertex . getID ( ) ) ; ExecutionJobVertex execMapVertex = eg . getJobVertex ( mapVertex . getID ( ) ) ; ExecutionJobVertex execSinkVertex = eg . getJobVertex ( sinkVertex . getID ( ) ) ; assertEquals ( 0 , execSourceVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 1 , execMapVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 4 , execMapVertex . getParallelism ( ) ) ; ExecutionVertex [ ] mapTaskVertices = execMapVertex . getTaskVertices ( ) ; Map < Integer , Integer > mapInputPartitionCounts = new HashMap < > ( ) ; for ( ExecutionVertex mapTaskVertex : mapTaskVertices ) { assertEquals ( 1 , mapTaskVertex . getNumberOfInputs ( ) ) ; assertEquals ( 1 , mapTaskVertex . getInputEdges ( 0 ) . length ) ; ExecutionEdge inputEdge = mapTaskVertex . getInputEdges ( 0 ) [ 0 ] ; assertEquals ( sourceVertex . getID ( ) , inputEdge . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; int inputPartition = inputEdge . getSource ( ) . getPartitionNumber ( ) ; if ( ! mapInputPartitionCounts . containsKey ( inputPartition ) ) { mapInputPartitionCounts . put ( inputPartition , 1 ) ; } else { mapInputPartitionCounts . put ( inputPartition , mapInputPartitionCounts . get ( inputPartition ) + 1 ) ; } } assertEquals ( 2 , mapInputPartitionCounts . size ( ) ) ; for ( int count : mapInputPartitionCounts . values ( ) ) { assertEquals ( 2 , count ) ; } assertEquals ( 1 , execSinkVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 2 , execSinkVertex . getParallelism ( ) ) ; ExecutionVertex [ ] sinkTaskVertices = execSinkVertex . getTaskVertices ( ) ; Set < Integer > mapSubpartitions = new HashSet < > ( ) ; for ( ExecutionVertex sinkTaskVertex : sinkTaskVertices ) { assertEquals ( 1 , sinkTaskVertex . getNumberOfInputs ( ) ) ; assertEquals ( 2 , sinkTaskVertex . getInputEdges ( 0 ) . length ) ; ExecutionEdge inputEdge1 = sinkTaskVertex . getInputEdges ( 0 ) [ 0 ] ; ExecutionEdge inputEdge2 = sinkTaskVertex . getInputEdges ( 0 ) [ 1 ] ; assertEquals ( mapVertex . getID ( ) , inputEdge1 . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; assertEquals ( mapVertex . getID ( ) , inputEdge2 . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; int inputPartition1 = inputEdge1 . getSource ( ) . getPartitionNumber ( ) ; assertFalse ( mapSubpartitions . contains ( inputPartition1 ) ) ; mapSubpartitions . add ( inputPartition1 ) ; int inputPartition2 = inputEdge2 . getSource ( ) . getPartitionNumber ( ) ; assertFalse ( mapSubpartitions . contains ( inputPartition2 ) ) ; mapSubpartitions . add ( inputPartition2 ) ; } assertEquals ( 4 , mapSubpartitions . size ( ) ) ; }
guolf/pds | public void setMenuId ( Long menuId ) { this . menuId = menuId ; }
guolf/pds | public Long getMenuId ( ) { return menuId ; }
guolf/pds | public void setParentId ( Long parentId ) { this . parentId = parentId ; }
guolf/pds | public Long getParentId ( ) { return parentId ; }
guolf/pds | public void setName ( String name ) { this . name = name ; }
guolf/pds | public String getName ( ) { return name ; }
guolf/pds | public void setUrl ( String url ) { this . url = url ; }
guolf/pds | public String getUrl ( ) { return url ; }
guolf/pds | public String getPerms ( ) { return perms ; }
guolf/pds | public void setPerms ( String perms ) { this . perms = perms ; }
guolf/pds | public Integer getType ( ) { return type ; }
guolf/pds | public void setType ( Integer type ) { this . type = type ; }
guolf/pds | public void setIcon ( String icon ) { this . icon = icon ; }
guolf/pds | public String getIcon ( ) { return icon ; }
guolf/pds | public void setOrderNum ( Integer orderNum ) { this . orderNum = orderNum ; }
guolf/pds | public Integer getOrderNum ( ) { return orderNum ; }
guolf/pds | public List < ? > getList ( ) { return list ; }
guolf/pds | public void setList ( List < ? > list ) { this . list = list ; }
guolf/pds | public String getParentName ( ) { return parentName ; }
guolf/pds | public void setParentName ( String parentName ) { this . parentName = parentName ; }
guolf/pds | public Boolean getOpen ( ) { return true ; }
guolf/pds | public void setOpen ( Boolean open ) { this . open = open ; }
wuyinlei/MyHearts | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_category , container , false ) ; initView ( view ) ; mIndex = getArguments ( ) . getInt ( Contants . INDEX ) ; if ( mIndex == 0 ) { url = HttpUrlPaths . getDouyuLiveChannel ( limit , offset ) ; } else { url = HttpUrlPaths . getDouyuSubChannelBaseTag ( mIndex , limit , offset ) ; } requestData ( url ) ; return view ; }
wuyinlei/MyHearts | private void initView ( View view ) { this . mSwipeRefresh = ( SwipeRefreshLayout ) view . findViewById ( R . id . swipeRefresh ) ; mSwipeRefresh . setColorSchemeColors ( Color . YELLOW , Color . RED , Color . BLUE , Color . GREEN ) ; mSwipeRefresh . setOnRefreshListener ( this ) ; this . mRecyclerview = ( RecyclerView ) view . findViewById ( R . id . recycler_view ) ; mCategoryAdapter = new CategoryAdapter ( getContext ( ) ) ; final GridLayoutManager gridLayoutManager = new GridLayoutManager ( getContext ( ) , 2 ) ; gridLayoutManager . setSpanSizeLookup ( new GridLayoutManager . SpanSizeLookup ( ) { @ Override public int getSpanSize ( int position ) { return ( position == 0 || position == mDataEntities . size ( ) ) ? gridLayoutManager . getSpanCount ( ) : 1 ; } } ) ; mRecyclerview . setLayoutManager ( gridLayoutManager ) ; mRecyclerview . setAdapter ( mCategoryAdapter ) ; mCategoryAdapter . setOnItemClickListener ( ( view1 , position , dataEntity ) -> { if ( position % 2 == 0 ) { Intent intent = new Intent ( getActivity ( ) , VideoViewActivity . class ) ; intent . putExtra ( Contants . VIDEO_PATH , " http : // 125.39.142.86 / data2 / video09/2016/03/01/3871799-102-1615 . mp4" ) ; getActivity ( ) . startActivity ( intent ) ; } else { Intent intent = new Intent ( getActivity ( ) , VideoViewLiveActivity . class ) ; intent . putExtra ( Contants . VIDEO_PATH , " rtmp : // live . hkstv . hk . lxdns . com / live / hks " ) ; getActivity ( ) . startActivity ( intent ) ; } } ) ; mRecyclerview . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; } @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; int lastVisiableItemPosition = gridLayoutManager . findLastVisibleItemPosition ( ) ; if ( lastVisiableItemPosition + 1 == mCategoryAdapter . getItemCount ( ) ) { if ( ! isLoading ) { isLoading = true ; mHandler . postDelayed ( ( ) -> { getMoreData ( ) ; isLoading = false ; mCategoryAdapter . notifyItemRemoved ( mCategoryAdapter . getItemCount ( ) ) ; } , 3000 ) ; } } } } ) ; }
wuyinlei/MyHearts | private void getMoreData ( ) { offset += limit ; limit += lordMoreNum ; if ( mIndex == 0 ) { url = HttpUrlPaths . getDouyuLiveChannel ( limit , offset ) ; } else { url = HttpUrlPaths . getDouyuSubChannelBaseTag ( mIndex , limit , offset ) ; } OkGo . get ( url ) . getCall ( StringConvert . create ( ) , RxAdapter . < String > create ( ) ) . doOnSubscribe ( ( ) -> { } ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( s -> { Type type = new TypeToken < RoomInfo > ( ) { } . getType ( ) ; RoomInfo roomInfo = new Gson ( ) . fromJson ( s , type ) ; if ( roomInfo . getData ( ) . size ( ) > 0 ) { mDataEntities . addAll ( roomInfo . getData ( ) ) ; mCategoryAdapter . setDataEntities ( mDataEntities ) ; mCategoryAdapter . notifyItemRemoved ( mCategoryAdapter . getItemCount ( ) ) ; } } , throwable -> { } ) ; }
wuyinlei/MyHearts | private void requestData ( String url ) { limit = lordMoreNum ; offset = 0 ; if ( mIndex == 0 ) { url = HttpUrlPaths . getDouyuLiveChannel ( limit , offset ) ; } else { url = HttpUrlPaths . getDouyuSubChannelBaseTag ( mIndex , limit , offset ) ; } OkGo . get ( url ) . getCall ( StringConvert . create ( ) , RxAdapter . < String > create ( ) ) . doOnSubscribe ( ( ) -> { } ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( s -> { Type type = new TypeToken < RoomInfo > ( ) { } . getType ( ) ; RoomInfo roomInfo = new Gson ( ) . fromJson ( s , type ) ; if ( roomInfo . getData ( ) . size ( ) > 0 ) { mDataEntities . addAll ( roomInfo . getData ( ) ) ; mCategoryAdapter . setDataEntities ( mDataEntities ) ; } } , throwable -> { } ) ; }
wuyinlei/MyHearts | @ Override public void onRefresh ( ) { new Handler ( ) . postDelayed ( ( ) -> { refreshData ( url ) ; mSwipeRefresh . setRefreshing ( false ) ; } , 3000 ) ; }
wuyinlei/MyHearts | private void refreshData ( String url ) { OkGo . get ( url ) . getCall ( StringConvert . create ( ) , RxAdapter . < String > create ( ) ) . doOnSubscribe ( ( ) -> { } ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( s -> { Type type = new TypeToken < RoomInfo > ( ) { } . getType ( ) ; RoomInfo roomInfo = new Gson ( ) . fromJson ( s , type ) ; if ( roomInfo . getData ( ) . size ( ) > 0 ) { mDataEntities . clear ( ) ; mDataEntities . addAll ( roomInfo . getData ( ) ) ; mCategoryAdapter . setDataEntities ( mDataEntities ) ; } } , throwable -> { } ) ; }
bbranan/fcrepo4 | @ Test public void testCreateVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; }
bbranan/fcrepo4 | @ Test public void testRemoveVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . createVersion ( session , " / " + pid , SECOND_LABEL ) ; session . commit ( ) ; assertEquals ( 3L , countVersions ( session , resource ) ) ; versionService . removeVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; }
bbranan/fcrepo4 | @ Test public void testRevertToVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; final String label = versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . createVersion ( session , " / " + pid , SECOND_LABEL ) ; session . commit ( ) ; assertEquals ( 3L , countVersions ( session , resource ) ) ; versionService . revertToVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( label , currentVersion ( session , resource ) ) ; }
bbranan/fcrepo4 | @ Test ( expected = RepositoryRuntimeException . class ) public void testRevertToInvalidVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . revertToVersion ( session , " / " + pid , " invalid - version - label " ) ; session . commit ( ) ; }
bbranan/fcrepo4 | @ Test ( expected = RepositoryRuntimeException . class ) public void testRemoveInvalidVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . removeVersion ( session , " / " + pid , " invalid - version - label " ) ; session . commit ( ) ; }
paulstapleton/flowable-engine | @ Override protected String getEngineName ( ) { return this . getClass ( ) . getName ( ) ; }
paulstapleton/flowable-engine | @ Override protected void configureConfiguration ( CmmnEngineConfiguration cmmnEngineConfiguration ) { Map < Object , Object > beans = new HashMap < > ( ) ; cmmnEngineConfiguration . setBeans ( beans ) ; beans . put ( " taskListenerCreateBean " , new TestDelegateTaskListener ( ) ) ; beans . put ( " taskListenerCompleteBean " , new TestDelegateTaskListener ( ) ) ; beans . put ( " taskListenerAssignBean " , new TestDelegateTaskListener ( ) ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testCreateEvent ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; assertVariable ( caseInstance , " variableFromClassDelegate " , " Hello ▁ World ▁ from ▁ class ▁ delegate " ) ; assertVariable ( caseInstance , " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; assertVariable ( caseInstance , " expressionVariable " , " Hello ▁ World ▁ from ▁ expression " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testCompleteEvent ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; List < Task > tasks = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . list ( ) ; for ( Task task : tasks ) { if ( ! task . getName ( ) . equals ( " Keepalive " ) ) { cmmnTaskService . complete ( task . getId ( ) ) ; } } assertVariable ( caseInstance , " variableFromClassDelegate " , " Hello ▁ World ▁ from ▁ class ▁ delegate " ) ; assertVariable ( caseInstance , " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; assertVariable ( caseInstance , " expressionVariable " , " Hello ▁ World ▁ from ▁ expression " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testAssignEvent ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; List < Task > tasks = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . list ( ) ; for ( Task task : tasks ) { if ( ! task . getName ( ) . equals ( " Keepalive " ) ) { cmmnTaskService . setAssignee ( task . getId ( ) , " testAssignee " ) ; } } assertVariable ( caseInstance , " variableFromClassDelegate " , " Hello ▁ World ▁ from ▁ class ▁ delegate " ) ; assertVariable ( caseInstance , " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; assertVariable ( caseInstance , " expressionVariable " , " Hello ▁ World ▁ from ▁ expression " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testAssignEventOriginalAssignee ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; Task task = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . singleResult ( ) ; cmmnTaskService . setAssignee ( task . getId ( ) , " testAssignee " ) ; assertVariable ( task , " taskId " , task . getId ( ) ) ; assertVariable ( task , " previousAssignee " , " defaultAssignee " ) ; assertVariable ( task , " currentAssignee " , " testAssignee " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment ( resources = " org / flowable / cmmn / test / listener / TaskListenerTest . testAssignEventOriginalAssignee . cmmn " ) public void testAssignEventOnCreateByHumanTaskActivityBehaviour ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; Task task = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . singleResult ( ) ; assertVariable ( task , " taskId " , task . getId ( ) ) ; assertVariable ( task , " previousAssignee " , " defaultAssignee " ) ; assertVariable ( task , " currentAssignee " , " defaultAssignee " ) ; }
paulstapleton/flowable-engine | private void assertVariable ( CaseInstance caseInstance , String varName , String value ) { String variable = ( String ) cmmnRuntimeService . getVariable ( caseInstance . getId ( ) , varName ) ; assertThat ( variable ) . isEqualTo ( value ) ; }
paulstapleton/flowable-engine | private void assertVariable ( TaskInfo task , String varName , String value ) { String variable = ( String ) cmmnTaskService . getVariable ( task . getId ( ) , varName ) ; assertThat ( variable ) . isEqualTo ( value ) ; }
paulstapleton/flowable-engine | @ Override public void notify ( DelegateTask delegateTask ) { delegateTask . setVariable ( " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; }
rmpestano/cukedoctor | public EnrichmentSteps ( ) throws IOException { }
rmpestano/cukedoctor | @ Before public void before ( ) throws IOException { metaCuke . setUp ( ) ; }
rmpestano/cukedoctor | @ After public void after ( ) throws IOException { metaCuke . tearDown ( ) ; }
rmpestano/cukedoctor | @ Given ( " ^ the ▁ feature : $ " ) public void the_feature ( String featureText ) throws Throwable { assertThat ( featureText ) . isNotNull ( ) ; metaCuke . addFeature ( featureText ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ docstring ▁ enriched ▁ json ▁ output ▁ activated ▁ with ▁ a ▁ step ▁ comment ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_docstring_enriched_json_output_activated_with_a_step_comment_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - step - comment . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ docstring ▁ with ▁ asciidoc ▁ content ▁ type ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_enriched_docstring_with_content_type_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - content - type . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ docstring ▁ with ▁ asciidoc ▁ feature ▁ tag ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_docstring_enriched_json_output_activiated_with_a_feature_tag_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - feature - tag . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ docstring ▁ with ▁ asciidoc ▁ scenario ▁ tag ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_docstring_enriched_json_output_activiated_with_a_scenario_tag_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - scenario - tag . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ feature ▁ json ▁ output ▁ using ▁ cukedoctor $ " ) public void I_convert_enriched_feature_json_output_using_cukedoctor ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / calc . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ it $ " ) public void I_convert_it ( ) { metaCuke . runCucumber ( " com . care . dont " ) ; List < Feature > features = FeatureParser . parse ( metaCuke . getReport ( ) . getAbsolutePath ( ) ) ; documentation = new CukedoctorFeatureRenderer ( ( DocumentAttributes ) null ) . renderFeatures ( features , new CukedoctorDocumentBuilderImpl ( ) . createNestedBuilder ( ) ) ; }
rmpestano/cukedoctor | @ Then ( " ^ DocString ▁ asciidoc ▁ output ▁ must ▁ be ▁ rendered ▁ in ▁ my ▁ documentation $ " ) @ Then ( " ^ it ▁ should ▁ be ▁ rendered ▁ in ▁ AsciiDoc ▁ as $ " ) public void DocString_asciidoc_output_must_be_rendered_in_my_documentation ( String expected ) throws Throwable { assertThat ( documentation . replaceAll ( " \r " , " " ) ) . contains ( ( expected . replaceAll ( " \r " , " " ) ) ) ; }
rmpestano/cukedoctor | private void getFeatureFixture ( String fixturePath ) { URL featureFile = getClass ( ) . getResource ( fixturePath ) ; assertThat ( featureFile ) . isNotNull ( ) ; List < Feature > features = FeatureParser . parse ( featureFile . getPath ( ) ) ; assertThat ( features ) . isNotNull ( ) . hasSize ( 1 ) ; documentation = new CukedoctorFeatureRenderer ( ( DocumentAttributes ) null ) . renderFeatures ( features , new CukedoctorDocumentBuilderImpl ( ) . createNestedBuilder ( ) ) ; }
Medium/closure-templates | @ Inject public NoAutoescapeDirective ( ) { }
Medium/closure-templates | @ Override public String getName ( ) { return NAME ; }
Medium/closure-templates | @ Override public Set < Integer > getValidArgsSizes ( ) { return ImmutableSet . of ( 0 ) ; }
Medium/closure-templates | @ Override public boolean shouldCancelAutoescape ( ) { return true ; }
Medium/closure-templates | @ Override public SoyValue applyForJava ( SoyValue value , List < SoyValue > args ) { return Sanitizers . filterNoAutoescape ( value ) ; }
Medium/closure-templates | @ Override public SoyExpression applyForJbcSrc ( JbcSrcPluginContext context , SoyExpression value , List < SoyExpression > args ) { return SoyExpression . forSoyValue ( UnknownType . getInstance ( ) , JbcSrcMethods . FILTER_NO_AUTOESCAPE . invoke ( value . box ( ) ) ) ; }
Medium/closure-templates | @ Override public AppendableAndOptions applyForJbcSrcStreaming ( JbcSrcPluginContext context , Expression delegateAppendable , List < SoyExpression > args ) { return AppendableAndOptions . create ( JbcSrcMethods . FILTER_NO_AUTOESCAPE_STREAMING . invoke ( delegateAppendable ) ) ; }
Medium/closure-templates | @ Override public JsExpr applyForJsSrc ( JsExpr value , List < JsExpr > args ) { return new JsExpr ( " soy . $ $ filterNoAutoescape ( " + value . getText ( ) + " ) " , Integer . MAX_VALUE ) ; }
Medium/closure-templates | @ Override public ImmutableSet < String > getRequiredJsLibNames ( ) { return ImmutableSet . of ( " soy " ) ; }
MaedaSaneyuki/7segmentTimer | public void monodroidAddReference ( java . lang . Object obj ) { if ( refList == null ) refList = new java . util . ArrayList ( ) ; refList . add ( obj ) ; }
MaedaSaneyuki/7segmentTimer | public void monodroidClearReferences ( ) { if ( refList != null ) refList . clear ( ) ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchClearValuesRequest getBatchClearValuesRequest ( ) { return batchClearValuesRequest ; }
apache/camel | public void setBatchClearValuesRequest ( com . google . api . services . sheets . v4 . model . BatchClearValuesRequest batchClearValuesRequest ) { this . batchClearValuesRequest = batchClearValuesRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchGetValuesByDataFilterRequest getBatchGetValuesByDataFilterRequest ( ) { return batchGetValuesByDataFilterRequest ; }
apache/camel | public void setBatchGetValuesByDataFilterRequest ( com . google . api . services . sheets . v4 . model . BatchGetValuesByDataFilterRequest batchGetValuesByDataFilterRequest ) { this . batchGetValuesByDataFilterRequest = batchGetValuesByDataFilterRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchUpdateValuesByDataFilterRequest getBatchUpdateValuesByDataFilterRequest ( ) { return batchUpdateValuesByDataFilterRequest ; }
apache/camel | public void setBatchUpdateValuesByDataFilterRequest ( com . google . api . services . sheets . v4 . model . BatchUpdateValuesByDataFilterRequest batchUpdateValuesByDataFilterRequest ) { this . batchUpdateValuesByDataFilterRequest = batchUpdateValuesByDataFilterRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchUpdateValuesRequest getBatchUpdateValuesRequest ( ) { return batchUpdateValuesRequest ; }
apache/camel | public void setBatchUpdateValuesRequest ( com . google . api . services . sheets . v4 . model . BatchUpdateValuesRequest batchUpdateValuesRequest ) { this . batchUpdateValuesRequest = batchUpdateValuesRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . ClearValuesRequest getClearValuesRequest ( ) { return clearValuesRequest ; }
apache/camel | public void setClearValuesRequest ( com . google . api . services . sheets . v4 . model . ClearValuesRequest clearValuesRequest ) { this . clearValuesRequest = clearValuesRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchClearValuesByDataFilterRequest getContent ( ) { return content ; }
apache/camel | public void setContent ( com . google . api . services . sheets . v4 . model . BatchClearValuesByDataFilterRequest content ) { this . content = content ; }
apache/camel | public String getRange ( ) { return range ; }
apache/camel | public void setRange ( String range ) { this . range = range ; }
apache/camel | public String getSpreadsheetId ( ) { return spreadsheetId ; }
apache/camel | public void setSpreadsheetId ( String spreadsheetId ) { this . spreadsheetId = spreadsheetId ; }
apache/camel | public com . google . api . services . sheets . v4 . model . ValueRange getValues ( ) { return values ; }
apache/camel | public void setValues ( com . google . api . services . sheets . v4 . model . ValueRange values ) { this . values = values ; }
apache/jackrabbit-oak | @ Before public void setup ( ) throws Exception { container = azurite . getContainer ( AzureSegmentStoreService . DEFAULT_CONTAINER_NAME ) ; for ( String blob : BLOBS ) { container . getBlockBlobReference ( blob + " . txt " ) . uploadText ( blob ) ; } }
apache/jackrabbit-oak | @ Test public void connectWithSharedAccessSignatureURL_readOnly ( ) throws Exception { String sasToken = container . generateSharedAccessSignature ( policy ( READ_ONLY ) , null ) ; AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithSharedAccessSignature ( sasToken ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessNotGranted ( persistence ) ; assertReadAccessGranted ( persistence , BLOBS ) ; }
apache/jackrabbit-oak | @ Test public void connectWithSharedAccessSignatureURL_readWrite ( ) throws Exception { String sasToken = container . generateSharedAccessSignature ( policy ( READ_WRITE ) , null ) ; AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithSharedAccessSignature ( sasToken ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessGranted ( persistence ) ; assertReadAccessGranted ( persistence , concat ( BLOBS , " test " ) ) ; }
apache/jackrabbit-oak | @ Test public void connectWithSharedAccessSignatureURL_expired ( ) throws Exception { SharedAccessBlobPolicy expiredPolicy = policy ( READ_WRITE , yesterday ( ) ) ; String sasToken = container . generateSharedAccessSignature ( expiredPolicy , null ) ; AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithSharedAccessSignature ( sasToken ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessNotGranted ( persistence ) ; assertReadAccessNotGranted ( persistence ) ; }
apache/jackrabbit-oak | @ Test public void connectWithAccessKey ( ) throws Exception { AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithAccessKey ( AzuriteDockerRule . ACCOUNT_KEY ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessGranted ( persistence ) ; assertReadAccessGranted ( persistence , concat ( BLOBS , " test " ) ) ; }
apache/jackrabbit-oak | @ Test public void connectWithConnectionURL ( ) throws Exception { AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithConfigurationURL ( AzuriteDockerRule . ACCOUNT_KEY ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessGranted ( persistence ) ; assertReadAccessGranted ( persistence , concat ( BLOBS , " test " ) ) ; }
apache/jackrabbit-oak | @ Test public void deactivate ( ) throws Exception { AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithAccessKey ( AzuriteDockerRule . ACCOUNT_KEY ) ) ; assertNotNull ( context . getService ( SegmentNodeStorePersistence . class ) ) ; azureSegmentStoreService . deactivate ( ) ; assertNull ( context . getService ( SegmentNodeStorePersistence . class ) ) ; }
crnk-project/crnk-framework | @ Test public void onSingleElementShouldReturnTheSameValue ( ) { String string = " hello ▁ world " ; List < String > values = Collections . singletonList ( string ) ; String result = StringUtils . join ( " , " , values ) ; assertThat ( result ) . isEqualTo ( string ) ; }
crnk-project/crnk-framework | @ Test public void onTwoElementsShouldReturnJoinedValues ( ) { List < String > values = Arrays . asList ( " hello " , " world " ) ; String result = StringUtils . join ( " ▁ " , values ) ; assertThat ( result ) . isEqualTo ( " hello ▁ world " ) ; }
crnk-project/crnk-framework | @ Test public void onIsBlankValues ( ) { assertTrue ( StringUtils . isBlank ( null ) ) ; assertTrue ( StringUtils . isBlank ( " " ) ) ; assertTrue ( StringUtils . isBlank ( " ▁ " ) ) ; assertFalse ( StringUtils . isBlank ( " crnk " ) ) ; assertFalse ( StringUtils . isBlank ( " ▁ ▁ crnk ▁ ▁ " ) ) ; }
crnk-project/crnk-framework | @ Test public void onJoinOfNulls ( ) { Assert . assertEquals ( " null , null " , StringUtils . join ( " , " , Arrays . asList ( null , null ) ) ) ; }
crnk-project/crnk-framework | @ Test public void checkDecapitalize ( ) { Assert . assertEquals ( " " , StringUtils . decapitalize ( " " ) ) ; Assert . assertEquals ( " test " , StringUtils . decapitalize ( " Test " ) ) ; Assert . assertEquals ( " someTest " , StringUtils . decapitalize ( " SomeTest " ) ) ; }
epanikas/q-link | public SampleDefImpl ( IPipelineContext ctxt ) { super ( ctxt ) ; doResult = getCtxt ( ) . getFactory ( ) . create ( DoResultAsSingleValue . class ) ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > first ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . first ) ; return doResult ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > last ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . last ) ; return doResult ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > middle ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . middle ) ; return doResult ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > nth ( int nth ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . nth , nth ) ; return doResult ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > with ( SamplePredicate p ) { getCtxt ( ) . getPipelineDef ( ) . setSamplePredicate ( p ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > even ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . even ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > odd ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . odd ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > head ( int l ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . head , l ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > tail ( int l ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . tail , l ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
khiekmann/attila-load-test | @ Before public void before ( ) { givenThat ( mock . receivesAnyRequestThenReturn200TextplainContent ( ) ) ; }
khiekmann/attila-load-test | @ Test public void ok ( ) throws Exception { String actual = mock . readPage ( ) ; assertEquals ( responseContent , actual ) ; }
mendix/CommunityCommons | public StartRemoteApiServlet ( IContext context , java . lang . String password ) { super ( context ) ; this . password = password ; }
mendix/CommunityCommons | @ java . lang . Override public java . lang . Boolean executeAction ( ) throws Exception { Core . addRequestHandler ( " unittests / " , new RemoteApiServlet ( password ) ) ; return true ; }
mendix/CommunityCommons | @ java . lang . Override public java . lang . String toString ( ) { return " StartRemoteApiServlet " ; }
GunoH/intellij-community | protected void setUp ( ) throws Exception { System . out . println ( " foo " ) ; }
addthis/MetricCatcher | @ Before public void setUp ( ) throws Exception { }
addthis/MetricCatcher | @ After public void tearDown ( ) throws Exception { }
addthis/MetricCatcher | @ Test public void testFromName ( ) { MetricType res = MetricType . fromName ( " meter " ) ; assertEquals ( MetricType . METER , res ) ; }
addthis/MetricCatcher | @ Test public void testFromName_Invalid ( ) { MetricType res = MetricType . fromName ( " foo " ) ; assertEquals ( null , res ) ; }
addthis/MetricCatcher | @ Test public void testKlass ( ) { assertEquals ( Histogram . class , MetricType . HISTOGRAM_BIASED . getKlass ( ) ) ; }
GinaHsu/ud851-GinaExercises | public WaterReminderIntentService ( ) { super ( " WaterReminderIntentService " ) ; }
GinaHsu/ud851-GinaExercises | @ Override protected void onHandleIntent ( @ Nullable Intent intent ) { String action = intent . getAction ( ) ; ReminderTasks . executeTask ( this , action ) ; }
Log10Solutions/querydsl | private UserUtils ( ) { }
ebean-orm/avaje-ebeanorm-examples | @ Test public void simple ( ) { LoadExampleData . load ( ) ; Date oneWeekAgo = new Date ( System . currentTimeMillis ( ) ) ; ExpressionList < Order > recentNewOrders = new QOrder ( ) . orderDate . after ( oneWeekAgo ) . status . eq ( Order . Status . NEW ) . getExpressionList ( ) ; QCustomer cus = QCustomer . alias ( ) ; QContact con = QContact . alias ( ) ; List < Customer > customers = new QCustomer ( ) . select ( cus . name , cus . inactive ) . contacts . fetch ( con . email , con . firstName ) . contacts . notes . fetchAll ( ) . name . ilike ( " Rob " ) . orders . filterMany ( recentNewOrders ) . findList ( ) ; }
McJty/RFTools | public ModuleRenderInfo ( float factor , BlockPos pos , int hitx , int hity , @ Nullable TrueTypeFont font ) { this . factor = factor ; this . pos = pos ; this . hitx = hitx ; this . hity = hity ; this . font = font ; }
aws/aws-sdk-java | public Request < ListFunctionsRequest > marshall ( ListFunctionsRequest listFunctionsRequest ) { if ( listFunctionsRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } Request < ListFunctionsRequest > request = new DefaultRequest < ListFunctionsRequest > ( listFunctionsRequest , " AmazonCloudFront " ) ; request . setHttpMethod ( HttpMethodName . GET ) ; String uriResourcePath = " / 2020-05-31 / function " ; request . setResourcePath ( uriResourcePath ) ; if ( listFunctionsRequest . getMarker ( ) != null ) { request . addParameter ( " Marker " , StringUtils . fromString ( listFunctionsRequest . getMarker ( ) ) ) ; } if ( listFunctionsRequest . getMaxItems ( ) != null ) { request . addParameter ( " MaxItems " , StringUtils . fromString ( listFunctionsRequest . getMaxItems ( ) ) ) ; } if ( listFunctionsRequest . getStage ( ) != null ) { request . addParameter ( " Stage " , StringUtils . fromString ( listFunctionsRequest . getStage ( ) ) ) ; } return request ; }
far-edge/EdgeInfrastructure | public List < String > getDataKindReferenceID ( ) { if ( dataKindReferenceID == null ) { dataKindReferenceID = new ArrayList < String > ( ) ; } return dataKindReferenceID ; }
far-edge/EdgeInfrastructure | public void setDataKindReferenceID ( List < String > dataKindReferenceID ) { this . dataKindReferenceID = dataKindReferenceID ; }
MiniDigger/VoxelGamesLib | public StringScoreboardLine ( String value ) { this . value = value ; }
MiniDigger/VoxelGamesLib | @ Override public String getValue ( ) { return value ; }
MiniDigger/VoxelGamesLib | public void setValue ( String value ) { this . value = value ; }
edwinyxc/pond | for ( Tree < E > node : TinyTree . this . children ) { if ( node == null ) { continue ; } if ( STRING . notBlank ( node . name ( ) ) && node . name ( ) . equals ( name ) ) { return node ; } }
edwinyxc/pond | protected TinyTree ( ) { }
edwinyxc/pond | public TinyTree ( E root ) { this . elem = root ; this . parent = null ; name ( root . toString ( ) ) ; this . root = this ; }
edwinyxc/pond | private TinyTree ( Tree < E > tree ) { this ( tree . elem ( ) ) ; this . children . addAll ( tree . children ( ) ) ; }
edwinyxc/pond | @ Override public Tree < E > add ( Tree < E > t ) { t . addTo ( this ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > addTo ( Tree < E > t ) { root = t . root ( ) ; parent = t ; this . idxInParent = t . children ( ) . size ( ) ; t . children ( ) . add ( this ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > after ( Tree < E > t ) { siblings ( ) . add ( idxInParent + 1 , t ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > asNew ( ) { return new TinyTree < > ( this ) ; }
edwinyxc/pond | public Object attr ( String name ) { return this . attrs . get ( name ) ; }
edwinyxc/pond | public Map < String , Object > attrs ( ) { return this . attrs ; }
edwinyxc/pond | public Tree < E > attr ( String name , Object o ) { this . attrs . put ( name , o ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > before ( Tree < E > t ) { siblings ( ) . add ( idxInParent , t ) ; return this ; }
edwinyxc/pond | @ Override public Iterator < Tree < E > > bfs ( ) { return new BFS ( this ) ; }
edwinyxc/pond | @ Override public List < Tree < E > > children ( ) { return children ; }
edwinyxc/pond | @ Override public Iterator < Tree < E > > dfs ( ) { return new DFS ( this ) ; }
edwinyxc/pond | @ Override public E elem ( ) { return this . elem ; }
edwinyxc/pond | @ Override public Tree < E > elem ( E t ) { this . elem = t ; return this ; }
edwinyxc/pond | @ Override public Tree < E > find ( Function < Boolean , Tree < E > > findFunc ) { Iterator < Tree < E > > bfs = this . bfs ( ) ; while ( bfs . hasNext ( ) ) { final Tree < E > node = bfs . next ( ) ; if ( findFunc . apply ( node ) ) { return node ; } } return null ; }
edwinyxc/pond | @ Override public Tree < E > find ( String name ) { Iterator < Tree < E > > bfs = this . bfs ( ) ; while ( bfs . hasNext ( ) ) { final Tree < E > node = bfs . next ( ) ; if ( name . equals ( node . name ( ) ) ) { return node ; } } return null ; }
edwinyxc/pond | @ Override public Tree < E > first ( ) { return children . get ( 0 ) ; }
edwinyxc/pond | @ Override public boolean isFirst ( ) { List < ? > s = siblings ( ) ; S . _assert ( s != null && s . size ( ) > 0 , " bad ▁ logic " ) ; return this == s . get ( 0 ) ; }
edwinyxc/pond | @ Override public boolean isLast ( ) { List < ? > s = siblings ( ) ; S . _assert ( s != null && s . size ( ) > 0 , " bad ▁ logic " ) ; return this == s . get ( s . size ( ) - 1 ) ; }
edwinyxc/pond | @ Override public boolean isLeaf ( ) { return children . size ( ) == 0 ; }
edwinyxc/pond | @ Override public boolean isRoot ( ) { return parent == null ; }
edwinyxc/pond | @ Override public Tree < E > last ( ) { return children . get ( children . size ( ) - 1 ) ; }
edwinyxc/pond | private Matrix _lines ( ) { final Matrix view = MATRIX . console ( 255 ) ; view . addRow ( MATRIX . fromString ( this . name ( ) ) . row ( 0 ) ) ; S . _for ( children ( ) ) . each ( ( t ) -> { String prefix = " ┣ ━ ━ " ; if ( t . isLast ( ) ) { prefix = " ┗ ━ ━ " ; } view . addRows ( t . isLeaf ( ) ? MATRIX . fromString ( prefix , t . name ( ) ) : MATRIX . addHorizontal ( MATRIX . fromString ( prefix ) , ( ( TinyTree < E > ) t ) . _lines ( ) ) ) ; for ( int i = 1 ; i < view . rows ( ) ; i ++ ) { if ( view . get ( i , 0 ) == ' ┗ ' ) { break ; } else if ( view . get ( i , 0 ) == ' ┣ ' ) { } else { view . set ( i , 0 , ( int ) ' ┃ ' ) ; } } } ) ; return view ; }
edwinyxc/pond | @ Override public String name ( ) { return ( String ) this . attr ( " name " ) ; }
edwinyxc/pond | @ Override public Tree < E > name ( String name ) { return this . attr ( " name " , name ) ; }
edwinyxc/pond | @ Override public Tree < E > next ( ) { return siblings ( ) . get ( idxInParent + 1 ) ; }
edwinyxc/pond | @ Override public List < Tree < E > > nextAll ( ) { return S . array ( parent . children ( ) ) . slice ( idxInParent + 1 , parent . children ( ) . size ( ) ) . toList ( ) ; }
edwinyxc/pond | @ Override public Tree < E > parent ( ) { return parent ; }
edwinyxc/pond | @ Override public List < Tree < E > > parents ( ) { final List < Tree < E > > ret = new ArrayList < > ( ) ; Tree < E > node = this ; while ( node != null ) { ret . add ( node ) ; node = node . parent ( ) ; } return ret ; }
edwinyxc/pond | @ Override public String [ ] path ( ) { return S . _for ( parents ( ) ) . map ( a -> ( a . name ( ) ) ) . join ( ) ; }
edwinyxc/pond | @ Override public Tree < E > prev ( ) { return siblings ( ) . get ( idxInParent - 1 ) ; }
edwinyxc/pond | @ Override public List < Tree < E > > prevAll ( ) { return S . array ( parent . children ( ) ) . slice ( 0 , idxInParent ) . toList ( ) ; }
edwinyxc/pond | @ Override public void remove ( ) { siblings ( ) . remove ( this ) ; }
edwinyxc/pond | @ Override public Tree < E > remove ( Iterable < Tree < E > > t ) { for ( Tree < E > _t : t ) { children . remove ( _t ) ; } return this ; }
edwinyxc/pond | @ Override public Tree < E > remove ( Tree < E > t ) { children . remove ( t ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > root ( ) { return root ; }
edwinyxc/pond | @ Override public Tree < E > select ( String name ) { return selector . select ( name ) ; }
edwinyxc/pond | @ Override public Tree < E > select ( String [ ] name ) { Tree < E > cur = this ; int i = 0 ; while ( i < name . length ) { cur = cur . select ( name [ i ++ ] ) ; if ( cur == null ) { break ; } } if ( cur == this ) { return null ; } return cur ; }
edwinyxc/pond | @ Override public Selector < Tree < E > > selector ( ) { return selector ; }
edwinyxc/pond | @ Override public List < Tree < E > > siblings ( ) { if ( parent == null ) { return Collections . emptyList ( ) ; } return parent . children ( ) ; }
edwinyxc/pond | @ Override public String toString ( ) { long s = S . now ( ) ; String ret = " \n " + RichLayout . mkStr ( new Rect ( _lines ( ) ) ) ; long e = S . now ( ) ; return ret + " \n rendered ▁ in ▁ " + ( e - s ) + " ▁ ms " ; }
edwinyxc/pond | public BFS ( Tree < E > node ) { queue . offer ( node . children ( ) . iterator ( ) ) ; }
edwinyxc/pond | @ Override public boolean hasNext ( ) { if ( queue . isEmpty ( ) ) { return false ; } Iterator < Tree < E > > it = queue . peek ( ) ; if ( it . hasNext ( ) ) { return true ; } queue . poll ( ) ; return hasNext ( ) ; }
edwinyxc/pond | @ Override public Tree < E > next ( ) { if ( hasNext ( ) ) { Iterator < Tree < E > > it = queue . peek ( ) ; Tree < E > next = it . next ( ) ; if ( ! next . isLeaf ( ) ) { queue . offer ( next . children ( ) . iterator ( ) ) ; } return next ; } return null ; }
edwinyxc/pond | @ Override public void remove ( ) { throw new UnsupportedOperationException ( " remove ▁ not ▁ supported , ▁ yet . " ) ; }
edwinyxc/pond | public DFS ( Tree < E > node ) { S . _assert ( node , " node ▁ null " ) ; stack . push ( node . children ( ) . iterator ( ) ) ; }
edwinyxc/pond | @ Override public boolean hasNext ( ) { if ( stack . isEmpty ( ) ) { return false ; } Iterator < Tree < E > > it = stack . peek ( ) ; if ( it . hasNext ( ) ) { return true ; } stack . pop ( ) ; return hasNext ( ) ; }
edwinyxc/pond | @ Override public Tree < E > next ( ) { if ( hasNext ( ) ) { Iterator < Tree < E > > it = stack . peek ( ) ; Tree < E > next = it . next ( ) ; if ( ! next . isLeaf ( ) ) { stack . push ( next . children ( ) . iterator ( ) ) ; } return next ; } return null ; }
edwinyxc/pond | @ Override public void remove ( ) { throw new UnsupportedOperationException ( " remove ▁ not ▁ supported , ▁ yet . " ) ; }
opetrovski/development | @ Before public void setup ( ) throws Exception { initMocks ( ) ; orgTkey = Long . valueOf ( 1234L ) ; query = new OrganizationSettingQuery ( ds , orgTkey ) ; }
opetrovski/development | @ Test public void verifyQuery ( ) throws Exception { query . execute ( ) ; assertEquals ( 1 , createdStatement . getAllValues ( ) . size ( ) ) ; assertEquals ( " SELECT ▁ os . settingtype , ▁ os . settingvalue , ▁ ps . settingvalue ▁ FROM ▁ organizationsetting ▁ os ▁ LEFT ▁ OUTER ▁ JOIN ▁ platformsetting ▁ ps ▁ ON ▁ os . settingtype ▁ = ▁ ps . settingtype ▁ WHERE ▁ organization _ tkey ▁ = ▁ ? " , createdStatement . getValue ( ) ) ; }
opetrovski/development | @ Test public void verifyParam ( ) throws Exception { query . execute ( ) ; assertEquals ( 1 , passedParameter . getAllValues ( ) . size ( ) ) ; assertEquals ( orgTkey , passedParameter . getValue ( ) ) ; }
opetrovski/development | @ Test ( expected = NullPointerException . class ) public void verifyResultMapping_MissingMandatorySettings ( ) throws Exception { query . execute ( ) ; query . getProperties ( ) ; }
opetrovski/development | @ Test public void verifyResultMapping_MandatorySettings ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_ATTR_REFERRAL , " ignore " , " ignore " ) ; query . execute ( ) ; Properties properties = query . getProperties ( ) ; assertEquals ( " url " , properties . get ( Context . PROVIDER_URL ) ) ; assertEquals ( " com . sun . jndi . ldap . LdapCtxFactory " , properties . get ( Context . INITIAL_CONTEXT_FACTORY ) ) ; assertFalse ( properties . containsKey ( Context . SECURITY_PRINCIPAL ) ) ; assertEquals ( " ignore " , properties . get ( Context . REFERRAL ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_CheckProperties ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_PRINCIPAL , " principal " , " principal " ) ; addEntry ( SettingType . LDAP_CREDENTIALS , " credentials " , " credentials " ) ; addEntry ( SettingType . LDAP_ATTR_REFERRAL , " ignore " , " ignore " ) ; query . execute ( ) ; Properties properties = query . getProperties ( ) ; assertEquals ( " url " , properties . get ( Context . PROVIDER_URL ) ) ; assertEquals ( " com . sun . jndi . ldap . LdapCtxFactory " , properties . get ( Context . INITIAL_CONTEXT_FACTORY ) ) ; assertEquals ( " principal " , properties . get ( Context . SECURITY_PRINCIPAL ) ) ; assertEquals ( " credentials " , properties . get ( Context . SECURITY_CREDENTIALS ) ) ; assertEquals ( " ignore " , properties . get ( Context . REFERRAL ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_OrgSetting ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_BASE_DN , " orgBaseDN " , " platformBaseDN " ) ; query . execute ( ) ; assertEquals ( " orgBaseDN " , query . getBaseDN ( ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_LinkedSetting ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_ATTR_UID , " " , " platformUid " ) ; query . execute ( ) ; assertEquals ( " platformUid " , query . getAttrUid ( ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_UnsetBaseDN ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_ATTR_UID , " " , " platformUid " ) ; query . execute ( ) ; assertNull ( String . format ( " attribute ▁ for ▁ uid ▁ should ▁ be ▁ null ▁ but ▁ has ▁ value ▁ ' % s ' " , query . getBaseDN ( ) ) , query . getBaseDN ( ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_DefaultUid ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_BASE_DN , " " , " platformBaseDN " ) ; query . execute ( ) ; assertEquals ( SettingType . LDAP_ATTR_UID . getDefaultValue ( ) , query . getAttrUid ( ) ) ; }
opetrovski/development | private void addEntry ( SettingType type , String orgValue , String platformValue ) { entries . add ( new ResultEntry ( type . name ( ) , orgValue , platformValue ) ) ; entryIterator = entries . iterator ( ) ; }
opetrovski/development | private void initMocks ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; ds = mock ( DataSource . class ) ; conn = mock ( Connection . class ) ; stmt = mock ( PreparedStatement . class ) ; rs = mock ( ResultSet . class ) ; doReturn ( conn ) . when ( ds ) . getConnection ( ) ; doReturn ( stmt ) . when ( conn ) . prepareStatement ( createdStatement . capture ( ) ) ; doReturn ( rs ) . when ( stmt ) . executeQuery ( ) ; doNothing ( ) . when ( stmt ) . setLong ( anyInt ( ) , passedParameter . capture ( ) ) ; doAnswer ( new Answer < Boolean > ( ) { public Boolean answer ( InvocationOnMock invocation ) throws Throwable { Boolean result = Boolean . valueOf ( entryIterator . hasNext ( ) ) ; if ( result ) { currentEntry = entryIterator . next ( ) ; } return result ; } } ) . when ( rs ) . next ( ) ; doAnswer ( new Answer < String > ( ) { public String answer ( InvocationOnMock invocation ) throws Throwable { Integer columnNo = ( Integer ) invocation . getArguments ( ) [ 0 ] ; switch ( columnNo . intValue ( ) ) { case 1 : return currentEntry . orgSettingType ; case 2 : return currentEntry . orgSettingValue ; case 3 : return currentEntry . platformSettingValue ; default : throw new RuntimeException ( " invalid ▁ column ▁ number " ) ; } } } ) . when ( rs ) . getString ( anyInt ( ) ) ; }
opetrovski/development | ResultEntry ( String orgSettingType , String orgSettingValue , String platformSettingValue ) { this . orgSettingType = orgSettingType ; this . orgSettingValue = orgSettingValue ; this . platformSettingValue = platformSettingValue ; }
GunoH/intellij-community | @ NotNull @ Override protected String buildErrorString ( Object ... infos ) { final PsiMethod method = ( PsiMethod ) infos [ 0 ] ; return InspectionGadgetsBundle . message ( " expected . exception . never . thrown . problem . descriptor " , method . getName ( ) ) ; }
GunoH/intellij-community | @ Override public BaseInspectionVisitor buildVisitor ( ) { return new ExpectedExceptionNeverThrownVisitor ( ) ; }
GunoH/intellij-community | @ Override public void visitMethod ( PsiMethod method ) { super . visitMethod ( method ) ; final PsiAnnotation annotation = AnnotationUtil . findAnnotation ( method , " org . junit . Test " ) ; if ( annotation == null ) { return ; } final PsiAnnotationParameterList parameterList = annotation . getParameterList ( ) ; final PsiNameValuePair [ ] attributes = parameterList . getAttributes ( ) ; PsiAnnotationMemberValue value = null ; for ( PsiNameValuePair attribute : attributes ) { if ( " expected " . equals ( attribute . getName ( ) ) ) { value = attribute . getValue ( ) ; break ; } } if ( ! ( value instanceof PsiClassObjectAccessExpression ) ) { return ; } final PsiCodeBlock body = method . getBody ( ) ; if ( body == null ) { return ; } final PsiClassObjectAccessExpression classObjectAccessExpression = ( PsiClassObjectAccessExpression ) value ; final PsiTypeElement operand = classObjectAccessExpression . getOperand ( ) ; final PsiType type = operand . getType ( ) ; final PsiClass aClass = PsiUtil . resolveClassInClassTypeOnly ( type ) ; if ( InheritanceUtil . isInheritor ( aClass , CommonClassNames . JAVA_LANG_RUNTIME_EXCEPTION ) || InheritanceUtil . isInheritor ( aClass , CommonClassNames . JAVA_LANG_ERROR ) ) { return ; } final List < PsiClassType > exceptionsThrown = ExceptionUtil . getThrownExceptions ( body ) ; for ( PsiClassType psiClassType : exceptionsThrown ) { if ( psiClassType . isAssignableFrom ( type ) ) { return ; } } registerError ( operand , method ) ; }
amikey/filter-nutch-plugin | public void setUp ( ) throws Exception { metadata . add ( Response . CONTENT_TYPE , " text / html " ) ; super . setUp ( ) ; }
amikey/filter-nutch-plugin | private Outlink [ ] generateOutlinks ( ) throws Exception { return generateOutlinks ( false ) ; }
amikey/filter-nutch-plugin | private Outlink [ ] generateOutlinks ( boolean parts ) throws Exception { Outlink [ ] outlinks = new Outlink [ 2 ] ; outlinks [ 0 ] = new Outlink ( " http : // www . test . com " , " test " ) ; outlinks [ 1 ] = new Outlink ( " http : // www . example . com " , " example " ) ; if ( parts ) { outlinks [ 0 ] = new Outlink ( outlinks [ 0 ] . getToUrl ( ) + " / index . php ? param = 1" , " test " ) ; outlinks [ 1 ] = new Outlink ( outlinks [ 1 ] . getToUrl ( ) + " / index . php ? param = 2" , " test " ) ; } return outlinks ; }
amikey/filter-nutch-plugin | public void testFilterOutlinks ( ) throws Exception { filter . setConf ( conf ) ; Outlink [ ] outlinks = generateOutlinks ( ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , new Inlinks ( ) ) ; assertEquals ( " Filter ▁ outlinks , ▁ allow ▁ only ▁ those ▁ from ▁ a ▁ different ▁ host " , outlinks [ 0 ] . getToUrl ( ) , doc . getFieldValue ( " outlinks " ) ) ; }
amikey/filter-nutch-plugin | public void testFilterInlinks ( ) throws Exception { filter . setConf ( conf ) ; Inlinks inlinks = new Inlinks ( ) ; inlinks . add ( new Inlink ( " http : // www . test . com " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . example . com " , " example " ) ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , new Outlink [ 0 ] , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , inlinks ) ; assertEquals ( " Filter ▁ inlinks , ▁ allow ▁ only ▁ those ▁ from ▁ a ▁ different ▁ host " , " http : // www . test . com " , doc . getFieldValue ( " inlinks " ) ) ; }
amikey/filter-nutch-plugin | public void testNoFilterOutlinks ( ) throws Exception { conf . set ( LinksIndexingFilter . LINKS_OUTLINKS_HOST , " false " ) ; filter . setConf ( conf ) ; Outlink [ ] outlinks = generateOutlinks ( ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , new Inlinks ( ) ) ; assertEquals ( " All ▁ outlinks ▁ must ▁ be ▁ indexed ▁ even ▁ those ▁ from ▁ the ▁ same ▁ host " , outlinks . length , doc . getField ( " outlinks " ) . getValues ( ) . size ( ) ) ; }
amikey/filter-nutch-plugin | public void testNoFilterInlinks ( ) throws Exception { conf . set ( LinksIndexingFilter . LINKS_INLINKS_HOST , " false " ) ; filter . setConf ( conf ) ; Inlinks inlinks = new Inlinks ( ) ; inlinks . add ( new Inlink ( " http : // www . test . com " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . example . com " , " example " ) ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , new Outlink [ 0 ] , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , inlinks ) ; assertEquals ( " All ▁ inlinks ▁ must ▁ be ▁ indexed ▁ even ▁ those ▁ from ▁ the ▁ same ▁ host " , inlinks . size ( ) , doc . getField ( " inlinks " ) . getValues ( ) . size ( ) ) ; }
amikey/filter-nutch-plugin | public void testIndexOnlyHostPart ( ) throws Exception { conf . set ( LinksIndexingFilter . LINKS_ONLY_HOSTS , " true " ) ; filter . setConf ( conf ) ; Outlink [ ] outlinks = generateOutlinks ( true ) ; Inlinks inlinks = new Inlinks ( ) ; inlinks . add ( new Inlink ( " http : // www . test . com / one - awesome - page " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . test . com / other - awesome - page " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . example . com / my - first - awesome - example " , " example " ) ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , inlinks ) ; NutchField docOutlinks = doc . getField ( " outlinks " ) ; assertEquals ( " Only ▁ the ▁ host ▁ portion ▁ of ▁ the ▁ outlink ▁ URL ▁ must ▁ be ▁ indexed " , new URL ( " http : // www . test . com " ) . getHost ( ) , docOutlinks . getValues ( ) . get ( 0 ) ) ; assertEquals ( " The ▁ inlinks ▁ coming ▁ from ▁ the ▁ same ▁ host ▁ must ▁ count ▁ and ▁ only ▁ once " , 1 , doc . getField ( " inlinks " ) . getValues ( ) . size ( ) ) ; Iterator < Inlink > iterator = inlinks . iterator ( ) ; assertEquals ( " Only ▁ the ▁ host ▁ portion ▁ of ▁ the ▁ inlinks ▁ URL ▁ must ▁ be ▁ indexed " , new URL ( " http : // www . test . com " ) . getHost ( ) , doc . getFieldValue ( " inlinks " ) ) ; }
amikey/filter-nutch-plugin | public void testIndexHostsOnlyAndFilterOutlinks ( ) throws Exception { conf = NutchConfiguration . create ( ) ; conf . set ( LinksIndexingFilter . LINKS_ONLY_HOSTS , " true " ) ; conf . set ( LinksIndexingFilter . LINKS_OUTLINKS_HOST , " true " ) ; Outlink [ ] outlinks = generateOutlinks ( true ) ; filter . setConf ( conf ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , new Inlinks ( ) ) ; assertEquals ( " Index ▁ only ▁ the ▁ host ▁ portion ▁ of ▁ the ▁ outlinks ▁ after ▁ filtering ▁ the ▁ outlinks " , new URL ( " http : // www . test . com " ) . getHost ( ) , doc . getFieldValue ( " outlinks " ) ) ; }
Recombine/jailer | public AssociationRenderer ( boolean reversed ) { super ( Constants . EDGE_TYPE_LINE , reversed ? Constants . EDGE_ARROW_REVERSE : Constants . EDGE_ARROW_FORWARD ) ; this . reversed = reversed ; }
Recombine/jailer | public AssociationRenderer ( ) { full = true ; }
Recombine/jailer | @ Override protected Shape getRawShape ( VisualItem item ) { EdgeItem edge = ( EdgeItem ) item ; VisualItem item1 = edge . getSourceItem ( ) ; VisualItem item2 = edge . getTargetItem ( ) ; int type = m_edgeType ; boolean reversedCurve = false ; Association association = ( Association ) item . get ( " association " ) ; if ( association != null && association . source == association . destination ) { type = Constants . EDGE_TYPE_CURVE ; reversedCurve = association . reversed ; } getAlignedPoint ( m_tmpPoints [ 0 ] , item1 . getBounds ( ) , m_xAlign1 , m_yAlign1 ) ; getAlignedPoint ( m_tmpPoints [ 1 ] , item2 . getBounds ( ) , m_xAlign2 , m_yAlign2 ) ; m_curWidth = ( float ) ( m_width * getLineWidth ( item ) ) ; EdgeItem e = ( EdgeItem ) item ; boolean forward = ( m_edgeArrow == Constants . EDGE_ARROW_FORWARD ) ; Point2D start = null , end = null ; start = m_tmpPoints [ forward ? 0 : 1 ] ; end = m_tmpPoints [ forward ? 1 : 0 ] ; if ( ! full ) { double midX ; double midY ; Point2D sp = start , ep = end ; VisualItem dest = forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; int i = GraphicsLib . intersectLineRectangle ( start , end , dest . getBounds ( ) , m_isctPoints ) ; if ( i > 0 ) ep = m_isctPoints [ 0 ] ; VisualItem src = ! forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; i = GraphicsLib . intersectLineRectangle ( start , end , src . getBounds ( ) , m_isctPoints2 ) ; if ( i > 0 ) sp = m_isctPoints2 [ 0 ] ; midX = ( sp . getX ( ) + ep . getX ( ) ) / 2 ; midY = ( sp . getY ( ) + ep . getY ( ) ) / 2 ; m_tmpPoints [ reversed ? 1 : 0 ] . setLocation ( midX , midY ) ; } if ( e . isDirected ( ) && m_edgeArrow != Constants . EDGE_ARROW_NONE ) { if ( type == Constants . EDGE_TYPE_CURVE ) { AffineTransform t = new AffineTransform ( ) ; t . setToRotation ( Math . PI / 4 * ( reversedCurve ? 1 : - 1 ) ) ; Point2D p = new Point2D . Double ( ) , shift = new Point2D . Double ( ) ; double d = start . distance ( end ) / 5.0 ; p . setLocation ( ( end . getX ( ) - start . getX ( ) ) / d , ( end . getY ( ) - start . getY ( ) ) / d ) ; t . transform ( p , shift ) ; start . setLocation ( start . getX ( ) + shift . getX ( ) , start . getY ( ) + shift . getY ( ) ) ; end . setLocation ( end . getX ( ) + shift . getX ( ) , end . getY ( ) + shift . getY ( ) ) ; } VisualItem dest = forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; int i = GraphicsLib . intersectLineRectangle ( start , end , dest . getBounds ( ) , m_isctPoints ) ; if ( i > 0 ) end = m_isctPoints [ 0 ] ; AffineTransform at = getArrowTrans ( start , end , m_curWidth ) ; m_curArrow = at . createTransformedShape ( m_arrowHead ) ; if ( type == Constants . EDGE_TYPE_CURVE ) { if ( ! " XML " . equals ( association . getDataModel ( ) . getExportModus ( ) ) || ! isAggregation ( association ) ) { m_curArrow = null ; } } Point2D lineEnd = m_tmpPoints [ forward ? 1 : 0 ] ; lineEnd . setLocation ( 0 , type == Constants . EDGE_TYPE_CURVE ? 0 : - m_arrowHeight ) ; at . transform ( lineEnd , lineEnd ) ; } else { m_curArrow = null ; } Shape shape = null ; double n1x = m_tmpPoints [ 0 ] . getX ( ) ; double n1y = m_tmpPoints [ 0 ] . getY ( ) ; double n2x = m_tmpPoints [ 1 ] . getX ( ) ; double n2y = m_tmpPoints [ 1 ] . getY ( ) ; m_line . setLine ( n1x , n1y , n2x , n2y ) ; shape = m_line ; starBounds = null ; starPosition = null ; if ( ! forward && ( Cardinality . MANY_TO_MANY . equals ( association . getCardinality ( ) ) || Cardinality . MANY_TO_ONE . equals ( association . getCardinality ( ) ) ) || forward && ( Cardinality . MANY_TO_MANY . equals ( association . getCardinality ( ) ) || Cardinality . ONE_TO_MANY . equals ( association . getCardinality ( ) ) ) ) { starPosition = m_tmpPoints [ forward ? 1 : 0 ] ; start = starPosition ; end = m_tmpPoints [ forward ? 0 : 1 ] ; AffineTransform t = new AffineTransform ( ) ; t . setToRotation ( - Math . PI / 3 ) ; Point2D p = new Point2D . Double ( ) , shift = new Point2D . Double ( ) ; double d = m_tmpPoints [ 0 ] . distance ( m_tmpPoints [ 1 ] ) / 9.0 ; p . setLocation ( ( end . getX ( ) - start . getX ( ) ) / d , ( end . getY ( ) - start . getY ( ) ) / d ) ; t . transform ( p , shift ) ; starPosition . setLocation ( starPosition . getX ( ) + shift . getX ( ) , starPosition . getY ( ) + shift . getY ( ) ) ; starBounds = new Rectangle2D . Double ( starPosition . getX ( ) - STAR_SIZE * ( starWidth / 2 ) , starPosition . getY ( ) - STAR_SIZE * ( starHeight / 2 ) , starWidth * STAR_SIZE , starHeight * STAR_SIZE ) ; } return shape ; }
Recombine/jailer | protected AffineTransform getArrowTrans ( Point2D p1 , Point2D p2 , double width ) { m_arrowTrans . setToTranslation ( p2 . getX ( ) , p2 . getY ( ) ) ; m_arrowTrans . rotate ( - HALF_PI + Math . atan2 ( p2 . getY ( ) - p1 . getY ( ) , p2 . getX ( ) - p1 . getX ( ) ) ) ; if ( width > 1 ) { double scalar = width / 2 ; m_arrowTrans . scale ( scalar , scalar ) ; } return m_arrowTrans ; }
Recombine/jailer | public void render ( Graphics2D g , VisualItem item , boolean isSelected ) { Association association = ( Association ) item . get ( " association " ) ; item . setSize ( isSelected ? 3 : 1 ) ; int color ; if ( ! Boolean . TRUE . equals ( item . get ( " full " ) ) ) { if ( ! full ) { return ; } color = associationColor ( association ) ; } else { if ( full ) { return ; } color = reversed ? associationColor ( association . reversalAssociation ) : associationColor ( association ) ; } item . setFillColor ( color ) ; item . setStrokeColor ( color ) ; BasicStroke stroke = item . getStroke ( ) ; if ( stroke != null ) { if ( reversed ) { if ( association != null ) { association = association . reversalAssociation ; } } if ( association != null && association . isRestricted ( ) && ! association . isIgnored ( ) ) { item . setStroke ( new BasicStroke ( stroke . getLineWidth ( ) , stroke . getEndCap ( ) , stroke . getLineJoin ( ) , stroke . getMiterLimit ( ) , new float [ ] { 8f , 6f } , 1.0f ) ) ; } else { item . setStroke ( new BasicStroke ( stroke . getLineWidth ( ) , stroke . getEndCap ( ) , stroke . getLineJoin ( ) , stroke . getMiterLimit ( ) ) ) ; } } if ( " XML " . equals ( association . getDataModel ( ) . getExportModus ( ) ) ) { m_arrowHead = updateArrowHead ( m_arrowWidth , m_arrowHeight , association , isSelected ) ; arrowIsPotAggregation = true ; } else { if ( arrowIsPotAggregation ) { m_arrowHead = updateArrowHead ( m_arrowWidth , m_arrowHeight ) ; } arrowIsPotAggregation = false ; } starPosition = null ; render ( g , item ) ; if ( starPosition != null && starImage != null ) { double size = STAR_SIZE ; transform . setTransform ( size , 0 , 0 , size , starPosition . getX ( ) - size * ( starWidth / 2 ) , starPosition . getY ( ) - size * ( starHeight / 2 ) ) ; g . drawImage ( starImage , transform , null ) ; starPosition = null ; } }
Recombine/jailer | public void setBounds ( VisualItem item ) { super . setBounds ( item ) ; if ( starBounds != null ) { Rectangle2D bbox = ( Rectangle2D ) item . get ( VisualItem . BOUNDS ) ; Rectangle2D . union ( bbox , starBounds , bbox ) ; } }
Recombine/jailer | private int associationColor ( Association association ) { if ( association . isIgnored ( ) ) { return COLOR_IGNORED . getRGB ( ) ; } if ( association . isInsertDestinationBeforeSource ( ) ) { return COLOR_DEPENDENCY . getRGB ( ) ; } if ( association . isInsertSourceBeforeDestination ( ) ) { return COLOR_REVERSE_DEPENDENCY . getRGB ( ) ; } return COLOR_ASSOCIATION . getRGB ( ) ; }
Recombine/jailer | @ Override public boolean locatePoint ( Point2D p , VisualItem item ) { Shape s = getShape ( item ) ; if ( s == null ) { return false ; } else { double width = Math . max ( 14 , getLineWidth ( item ) ) ; double halfWidth = width / 2.0 ; return s . intersects ( p . getX ( ) - halfWidth , p . getY ( ) - halfWidth , width , width ) ; } }
Recombine/jailer | protected Polygon updateArrowHead ( int w , int h , Association association , boolean isSelected ) { if ( isAggregation ( association ) ) { if ( m_arrowHead == null ) { m_arrowHead = new Polygon ( ) ; } else { m_arrowHead . reset ( ) ; } double ws = 0.9 ; double hs = 2.0 / 3.0 ; if ( isSelected ) { ws /= 1.3 ; hs /= 1.3 ; } m_arrowHead . addPoint ( 0 , 0 ) ; m_arrowHead . addPoint ( ( int ) ( ws * - w ) , ( int ) ( hs * ( - h ) ) ) ; m_arrowHead . addPoint ( 0 , ( int ) ( hs * ( - 2 * h ) ) ) ; m_arrowHead . addPoint ( ( int ) ( ws * w ) , ( int ) ( hs * ( - h ) ) ) ; m_arrowHead . addPoint ( 0 , 0 ) ; return m_arrowHead ; } else { return updateArrowHead ( w , h ) ; } }
Recombine/jailer | private boolean isAggregation ( Association association ) { return association . reversalAssociation . getAggregationSchema ( ) != AggregationSchema . NONE ; }
Recombine/jailer | catch ( Exception e ) { e . printStackTrace ( ) ; }
apache/tomcat | public ProgressNotifier ( final ProgressListener pListener , final long pContentLength ) { listener = pListener ; contentLength = pContentLength ; }
apache/tomcat | void noteBytesRead ( final int pBytes ) { bytesRead += pBytes ; notifyListener ( ) ; }
apache/tomcat | public void noteItem ( ) { ++ items ; notifyListener ( ) ; }
apache/tomcat | private void notifyListener ( ) { if ( listener != null ) { listener . update ( bytesRead , contentLength , items ) ; } }
apache/tomcat | public MultipartStream ( final InputStream input , final byte [ ] boundary , final int bufSize , final ProgressNotifier pNotifier ) { if ( boundary == null ) { throw new IllegalArgumentException ( " boundary ▁ may ▁ not ▁ be ▁ null " ) ; } this . boundaryLength = boundary . length + BOUNDARY_PREFIX . length ; if ( bufSize < this . boundaryLength + 1 ) { throw new IllegalArgumentException ( " The ▁ buffer ▁ size ▁ specified ▁ for ▁ the ▁ MultipartStream ▁ is ▁ too ▁ small " ) ; } this . input = input ; this . bufSize = Math . max ( bufSize , boundaryLength * 2 ) ; this . buffer = new byte [ this . bufSize ] ; this . notifier = pNotifier ; this . boundary = new byte [ this . boundaryLength ] ; this . boundaryTable = new int [ this . boundaryLength + 1 ] ; this . keepRegion = this . boundary . length ; System . arraycopy ( BOUNDARY_PREFIX , 0 , this . boundary , 0 , BOUNDARY_PREFIX . length ) ; System . arraycopy ( boundary , 0 , this . boundary , BOUNDARY_PREFIX . length , boundary . length ) ; computeBoundaryTable ( ) ; head = 0 ; tail = 0 ; }
apache/tomcat | public MultipartStream ( final InputStream input , final byte [ ] boundary , final ProgressNotifier pNotifier ) { this ( input , boundary , DEFAULT_BUFSIZE , pNotifier ) ; }
apache/tomcat | public String getHeaderEncoding ( ) { return headerEncoding ; }
apache/tomcat | public void setHeaderEncoding ( final String encoding ) { headerEncoding = encoding ; }
apache/tomcat | public byte readByte ( ) throws IOException { if ( head == tail ) { head = 0 ; tail = input . read ( buffer , head , bufSize ) ; if ( tail == - 1 ) { throw new IOException ( " No ▁ more ▁ data ▁ is ▁ available " ) ; } if ( notifier != null ) { notifier . noteBytesRead ( tail ) ; } } return buffer [ head ++ ] ; }
apache/tomcat | if ( marker [ 0 ] == LF ) { return true ; }
apache/tomcat | if ( arrayequals ( marker , STREAM_TERMINATOR , 2 ) ) { nextChunk = false ; }
apache/tomcat | else if ( arrayequals ( marker , FIELD_SEPARATOR , 2 ) ) { nextChunk = true ; }
apache/tomcat | catch ( final FileUploadIOException e ) { throw e ; }
apache/tomcat | catch ( final IOException e ) { throw new MalformedStreamException ( " Stream ▁ ended ▁ unexpectedly " ) ; }
apache/tomcat | public void setBoundary ( final byte [ ] boundary ) throws IllegalBoundaryException { if ( boundary . length != boundaryLength - BOUNDARY_PREFIX . length ) { throw new IllegalBoundaryException ( " The ▁ length ▁ of ▁ a ▁ boundary ▁ token ▁ cannot ▁ be ▁ changed " ) ; } System . arraycopy ( boundary , 0 , this . boundary , BOUNDARY_PREFIX . length , boundary . length ) ; computeBoundaryTable ( ) ; }
apache/tomcat | private void computeBoundaryTable ( ) { int position = 2 ; int candidate = 0 ; boundaryTable [ 0 ] = - 1 ; boundaryTable [ 1 ] = 0 ; while ( position <= boundaryLength ) { if ( boundary [ position - 1 ] == boundary [ candidate ] ) { boundaryTable [ position ] = candidate + 1 ; candidate ++ ; position ++ ; } else if ( candidate > 0 ) { candidate = boundaryTable [ candidate ] ; } else { boundaryTable [ position ] = 0 ; position ++ ; } } }
apache/tomcat | while ( i < HEADER_SEPARATOR . length ) { try { b = readByte ( ) ; } catch ( final FileUploadIOException e ) { throw e ; } catch ( final IOException e ) { throw new MalformedStreamException ( " Stream ▁ ended ▁ unexpectedly " ) ; } if ( ++ size > HEADER_PART_SIZE_MAX ) { throw new MalformedStreamException ( String . format ( " Header ▁ section ▁ has ▁ more ▁ than ▁ % s ▁ bytes ▁ ( maybe ▁ it ▁ is ▁ not ▁ properly ▁ terminated ) " , Integer . valueOf ( HEADER_PART_SIZE_MAX ) ) ) ; } if ( b == HEADER_SEPARATOR [ i ] ) { i ++ ; } else { i = 0 ; } baos . write ( b ) ; }
apache/tomcat | if ( headerEncoding != null ) { try { headers = baos . toString ( headerEncoding ) ; } catch ( final UnsupportedEncodingException e ) { headers = baos . toString ( ) ; } }
apache/tomcat | public ItemInputStream newInputStream ( ) { return new ItemInputStream ( ) ; }
apache/tomcat | public boolean skipPreamble ( ) throws IOException { System . arraycopy ( boundary , 2 , boundary , 0 , boundary . length - 2 ) ; boundaryLength = boundary . length - 2 ; computeBoundaryTable ( ) ; try { discardBodyData ( ) ; return readBoundary ( ) ; } catch ( final MalformedStreamException e ) { return false ; } finally { System . arraycopy ( boundary , 0 , boundary , 2 , boundary . length - 2 ) ; boundaryLength = boundary . length ; boundary [ 0 ] = CR ; boundary [ 1 ] = LF ; computeBoundaryTable ( ) ; } }
apache/tomcat | protected int findByte ( final byte value , final int pos ) { for ( int i = pos ; i < tail ; i ++ ) { if ( buffer [ i ] == value ) { return i ; } } return - 1 ; }
apache/tomcat | protected int findSeparator ( ) { int bufferPos = this . head ; int tablePos = 0 ; while ( bufferPos < this . tail ) { while ( tablePos >= 0 && buffer [ bufferPos ] != boundary [ tablePos ] ) { tablePos = boundaryTable [ tablePos ] ; } bufferPos ++ ; tablePos ++ ; if ( tablePos == boundaryLength ) { return bufferPos - boundaryLength ; } } return - 1 ; }
apache/tomcat | public MalformedStreamException ( ) { }
apache/tomcat | public MalformedStreamException ( final String message ) { super ( message ) ; }
apache/tomcat | public IllegalBoundaryException ( ) { }
apache/tomcat | public IllegalBoundaryException ( final String message ) { super ( message ) ; }
apache/tomcat | ItemInputStream ( ) { findSeparator ( ) ; }
apache/tomcat | private void findSeparator ( ) { pos = MultipartStream . this . findSeparator ( ) ; if ( pos == - 1 ) { if ( tail - head > keepRegion ) { pad = keepRegion ; } else { pad = tail - head ; } } }
apache/tomcat | public long getBytesRead ( ) { return total ; }
apache/tomcat | @ Override public int available ( ) throws IOException { if ( pos == - 1 ) { return tail - head - pad ; } return pos - head ; }
apache/tomcat | @ Override public int read ( ) throws IOException { if ( closed ) { throw new FileItemStream . ItemSkippedException ( ) ; } if ( available ( ) == 0 && makeAvailable ( ) == 0 ) { return - 1 ; } ++ total ; final int b = buffer [ head ++ ] ; if ( b >= 0 ) { return b ; } return b + BYTE_POSITIVE_OFFSET ; }
apache/tomcat | @ Override public int read ( final byte [ ] b , final int off , final int len ) throws IOException { if ( closed ) { throw new FileItemStream . ItemSkippedException ( ) ; } if ( len == 0 ) { return 0 ; } int res = available ( ) ; if ( res == 0 ) { res = makeAvailable ( ) ; if ( res == 0 ) { return - 1 ; } } res = Math . min ( res , len ) ; System . arraycopy ( buffer , head , b , off , res ) ; head += res ; total += res ; return res ; }
apache/tomcat | @ Override public void close ( ) throws IOException { close ( false ) ; }
apache/tomcat | public void close ( final boolean pCloseUnderlying ) throws IOException { if ( closed ) { return ; } if ( pCloseUnderlying ) { closed = true ; input . close ( ) ; } else { for ( ; ; ) { int av = available ( ) ; if ( av == 0 ) { av = makeAvailable ( ) ; if ( av == 0 ) { break ; } } skip ( av ) ; } } closed = true ; }
apache/tomcat | @ Override public long skip ( final long bytes ) throws IOException { if ( closed ) { throw new FileItemStream . ItemSkippedException ( ) ; } int av = available ( ) ; if ( av == 0 ) { av = makeAvailable ( ) ; if ( av == 0 ) { return 0 ; } } final long res = Math . min ( av , bytes ) ; head += res ; return res ; }
apache/tomcat | private int makeAvailable ( ) throws IOException { if ( pos != - 1 ) { return 0 ; } total += tail - head - pad ; System . arraycopy ( buffer , tail - pad , buffer , 0 , pad ) ; head = 0 ; tail = pad ; for ( ; ; ) { final int bytesRead = input . read ( buffer , tail , bufSize - tail ) ; if ( bytesRead == - 1 ) { final String msg = " Stream ▁ ended ▁ unexpectedly " ; throw new MalformedStreamException ( msg ) ; } if ( notifier != null ) { notifier . noteBytesRead ( bytesRead ) ; } tail += bytesRead ; findSeparator ( ) ; final int av = available ( ) ; if ( av > 0 || pos != - 1 ) { return av ; } } }
apache/tomcat | @ Override public boolean isClosed ( ) { return closed ; }
anicloud/ani-cas | public CasAccountAttributeDao ( ) { }
anicloud/ani-cas | public CasAccountAttributeDao ( DataSource dataSource ) { this . dataSource = dataSource ; }
anicloud/ani-cas | public DataSource getDataSource ( ) { return dataSource ; }
anicloud/ani-cas | public void setDataSource ( DataSource dataSource ) { this . dataSource = dataSource ; }
anicloud/ani-cas | public String getEmailFieldName ( ) { return emailFieldName ; }
anicloud/ani-cas | public void setEmailFieldName ( String emailFieldName ) { this . emailFieldName = emailFieldName ; }
anicloud/ani-cas | public String getScreenFieldName ( ) { return screenFieldName ; }
anicloud/ani-cas | public void setScreenFieldName ( String screenFieldName ) { this . screenFieldName = screenFieldName ; }
anicloud/ani-cas | public String getAccountTableName ( ) { return accountTableName ; }
anicloud/ani-cas | public void setAccountTableName ( String accountTableName ) { this . accountTableName = accountTableName ; }
anicloud/ani-cas | public String getAccountPhoneTableName ( ) { return accountPhoneTableName ; }
anicloud/ani-cas | public void setAccountPhoneTableName ( String accountPhoneTableName ) { this . accountPhoneTableName = accountPhoneTableName ; }
anicloud/ani-cas | public String getPhoneFieldName ( ) { return phoneFieldName ; }
anicloud/ani-cas | public void setPhoneFieldName ( String phoneFieldName ) { this . phoneFieldName = phoneFieldName ; }
anicloud/ani-cas | @ Override public IPersonAttributes getPerson ( String uid ) { String sql = " " ; if ( uid . indexOf ( " @ " ) > 0 ) { sql = " ▁ select ▁ * ▁ from ▁ " + accountTableName + " ▁ where ▁ " + emailFieldName + " = ? " ; } else { sql = " ▁ select ▁ * ▁ from ▁ " + accountPhoneTableName + " ▁ where ▁ " + phoneFieldName + " = ? " ; } final Map < String , Object > values = new JdbcTemplate ( dataSource ) . queryForMap ( sql , uid ) ; Map < String , List < Object > > attributes = new HashMap < String , List < Object > > ( ) ; attributes . put ( " phoneNumber " , Collections . singletonList ( ( Object ) values . get ( " phoneNumber " ) ) ) ; attributes . put ( " email " , Collections . singletonList ( ( Object ) values . get ( " email " ) ) ) ; attributes . put ( " accountId " , Collections . singletonList ( ( Object ) values . get ( " accountId " ) ) ) ; attributes . put ( " id " , Collections . singletonList ( ( Object ) values . get ( " Id " ) ) ) ; return new AttributeNamedPersonImpl ( attributes ) ; }
rekhajoshm/pig | public MRCompiler ( PhysicalPlan plan ) throws MRCompilerException { this ( plan , null ) ; }
rekhajoshm/pig | public MRCompiler ( PhysicalPlan plan , PigContext pigContext ) throws MRCompilerException { super ( plan , new DepthFirstWalker < PhysicalOperator , PhysicalPlan > ( plan ) ) ; this . plan = plan ; this . pigContext = pigContext ; splitsSeen = new HashMap < OperatorKey , MapReduceOper > ( ) ; MRPlan = new MROperPlan ( ) ; nig = NodeIdGenerator . getGenerator ( ) ; r = new Random ( 1331 ) ; FileLocalizer . setR ( r ) ; udfFinder = new UDFFinder ( ) ; List < PhysicalOperator > roots = plan . getRoots ( ) ; if ( ( roots == null ) || ( roots . size ( ) <= 0 ) ) { int errCode = 2053 ; String msg = " Internal ▁ error . ▁ Did ▁ not ▁ find ▁ roots ▁ in ▁ the ▁ physical ▁ plan . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } scope = roots . get ( 0 ) . getOperatorKey ( ) . getScope ( ) ; messageCollector = new CompilationMessageCollector ( ) ; phyToMROpMap = new HashMap < PhysicalOperator , MapReduceOper > ( ) ; fileConcatenationThreshold = Integer . parseInt ( pigContext . getProperties ( ) . getProperty ( FILE_CONCATENATION_THRESHOLD , "100" ) ) ; optimisticFileConcatenation = pigContext . getProperties ( ) . getProperty ( OPTIMISTIC_FILE_CONCATENATION , " false " ) . equals ( " true " ) ; LOG . info ( " File ▁ concatenation ▁ threshold : ▁ " + fileConcatenationThreshold + " ▁ optimistic ? ▁ " + optimisticFileConcatenation ) ; }
rekhajoshm/pig | for ( MapReduceOper mrOp : MRPlan ) { mrOpList . add ( mrOp ) ; }
rekhajoshm/pig | for ( MapReduceOper mrOp : mrOpList ) { for ( PhysicalOperator scalar : mrOp . scalars ) { MapReduceOper mro = phyToMROpMap . get ( scalar ) ; if ( scalar instanceof POStore ) { FileSpec oldSpec = ( ( POStore ) scalar ) . getSFile ( ) ; MapReduceOper mro2 = seen . get ( oldSpec ) ; boolean hasSeen = false ; if ( mro2 != null ) { hasSeen = true ; mro = mro2 ; } if ( ! hasSeen && combinable && ( mro . reducePlan . isEmpty ( ) ? hasTooManyInputFiles ( mro , conf ) : ( mro . requestedParallelism >= fileConcatenationThreshold ) ) ) { PhysicalPlan pl = mro . reducePlan . isEmpty ( ) ? mro . mapPlan : mro . reducePlan ; FileSpec newSpec = getTempFileSpec ( ) ; new FindStoreNameVisitor ( pl , newSpec , oldSpec ) . visit ( ) ; POStore newSto = getStore ( ) ; newSto . setSFile ( oldSpec ) ; if ( MRPlan . getPredecessors ( mrOp ) != null && MRPlan . getPredecessors ( mrOp ) . contains ( mro ) ) MRPlan . disconnect ( mro , mrOp ) ; MapReduceOper catMROp = getConcatenateJob ( newSpec , mro , newSto ) ; MRPlan . connect ( catMROp , mrOp ) ; seen . put ( oldSpec , catMROp ) ; } else { if ( ! hasSeen ) seen . put ( oldSpec , mro ) ; } } } }
rekhajoshm/pig | public void randomizeFileLocalizer ( ) { FileLocalizer . setR ( new Random ( ) ) ; }
rekhajoshm/pig | public MROperPlan getMRPlan ( ) { return MRPlan ; }
rekhajoshm/pig | @ Override public PhysicalPlan getPlan ( ) { return plan ; }
rekhajoshm/pig | public CompilationMessageCollector getMessageCollector ( ) { return messageCollector ; }
rekhajoshm/pig | if ( ! pigContext . inIllustrator ) for ( PhysicalOperator op : leaves ) { if ( ! ( op instanceof POStore ) ) { int errCode = 2025 ; String msg = " Expected ▁ leaf ▁ of ▁ reduce ▁ plan ▁ to ▁ " + " always ▁ be ▁ POStore . ▁ Found ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } }
rekhajoshm/pig | if ( ! pigContext . inIllustrator ) { ops = new ArrayList < PhysicalOperator > ( stores . size ( ) + nativeMRs . size ( ) ) ; ops . addAll ( stores ) ; }
rekhajoshm/pig | for ( PhysicalOperator op : ops ) { compile ( op ) ; }
rekhajoshm/pig | for ( PhysicalOperator op : plan ) { if ( plan . getSoftLinkPredecessors ( op ) != null ) { for ( PhysicalOperator pred : plan . getSoftLinkPredecessors ( op ) ) { MapReduceOper from = phyToMROpMap . get ( pred ) ; MapReduceOper to = phyToMROpMap . get ( op ) ; if ( from == to ) continue ; if ( MRPlan . getPredecessors ( to ) == null || ! MRPlan . getPredecessors ( to ) . contains ( from ) ) { MRPlan . connect ( from , to ) ; } } } }
rekhajoshm/pig | if ( op instanceof PONative ) { }
rekhajoshm/pig | else if ( predecessors != null && predecessors . size ( ) > 0 ) { if ( op instanceof POLoad ) { if ( predecessors . size ( ) != 1 ) { int errCode = 2125 ; String msg = " Expected ▁ at ▁ most ▁ one ▁ predecessor ▁ of ▁ load . ▁ Got ▁ " + predecessors . size ( ) ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } PhysicalOperator p = predecessors . get ( 0 ) ; MapReduceOper oper = null ; if ( p instanceof POStore || p instanceof PONative ) { oper = phyToMROpMap . get ( p ) ; } else { int errCode = 2126 ; String msg = " Predecessor ▁ of ▁ load ▁ should ▁ be ▁ a ▁ store ▁ or ▁ mapreduce ▁ operator . ▁ Got ▁ " + p . getClass ( ) ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } curMROp = getMROp ( ) ; curMROp . mapPlan . add ( op ) ; MRPlan . add ( curMROp ) ; plan . disconnect ( op , p ) ; MRPlan . connect ( oper , curMROp ) ; phyToMROpMap . put ( op , curMROp ) ; return ; } Collections . sort ( predecessors ) ; compiledInputs = new MapReduceOper [ predecessors . size ( ) ] ; int i = - 1 ; for ( PhysicalOperator pred : predecessors ) { if ( pred instanceof POSplit && splitsSeen . containsKey ( pred . getOperatorKey ( ) ) ) { compiledInputs [ ++ i ] = startNew ( ( ( POSplit ) pred ) . getSplitStore ( ) , splitsSeen . get ( pred . getOperatorKey ( ) ) ) ; continue ; } compile ( pred ) ; compiledInputs [ ++ i ] = curMROp ; } }
rekhajoshm/pig | if ( op != null && op instanceof POLoad ) { if ( ( ( POLoad ) op ) . getLFile ( ) != null && ( ( POLoad ) op ) . getLFile ( ) . getFuncSpec ( ) != null ) curMROp . UDFs . add ( ( ( POLoad ) op ) . getLFile ( ) . getFuncSpec ( ) . toString ( ) ) ; }
rekhajoshm/pig | if ( op . getRequestedParallelism ( ) > curMROp . requestedParallelism ) { if ( ! curMROp . isSkewedJoin ( ) ) { curMROp . requestedParallelism = op . getRequestedParallelism ( ) ; } }
rekhajoshm/pig | private MapReduceOper getMROp ( ) { return new MapReduceOper ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; }
rekhajoshm/pig | private NativeMapReduceOper getNativeMROp ( String mrJar , String [ ] parameters ) { return new NativeMapReduceOper ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , mrJar , parameters ) ; }
rekhajoshm/pig | private POLoad getLoad ( ) { POLoad ld = new POLoad ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; ld . setPc ( pigContext ) ; ld . setIsTmpLoad ( true ) ; return ld ; }
rekhajoshm/pig | private POStore getStore ( ) { POStore st = new POStore ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; st . setIsTmpStore ( true ) ; return st ; }
rekhajoshm/pig | if ( compiledInputs . length == 1 ) { MapReduceOper mro = compiledInputs [ 0 ] ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( op ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( op ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } curMROp = mro ; }
rekhajoshm/pig | if ( compiledInputs . length == 1 ) { MapReduceOper mro = compiledInputs [ 0 ] ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( op ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { FileSpec fSpec = getTempFileSpec ( ) ; POStore st = getStore ( ) ; st . setSFile ( fSpec ) ; mro . reducePlan . addAsLeaf ( st ) ; mro . setReduceDone ( true ) ; mro = startNew ( fSpec , mro ) ; mro . mapPlan . addAsLeaf ( op ) ; compiledInputs [ 0 ] = mro ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } curMROp = mro ; }
rekhajoshm/pig | if ( compiledInputs . length == 1 ) { MapReduceOper mro = compiledInputs [ 0 ] ; if ( ! mro . isMapDone ( ) ) { mro . setMapDoneSingle ( true ) ; curMROp = mro ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { FileSpec fSpec = getTempFileSpec ( ) ; POStore st = getStore ( ) ; st . setSFile ( fSpec ) ; mro . reducePlan . addAsLeaf ( st ) ; mro . setReduceDone ( true ) ; curMROp = startNew ( fSpec , mro ) ; curMROp . setMapDone ( true ) ; } }
rekhajoshm/pig | for ( MapReduceOper mmro : mergedPlans ) { mmro . setReduceDone ( true ) ; FileSpec fileSpec = getTempFileSpec ( ) ; POLoad ld = getLoad ( ) ; ld . setLFile ( fileSpec ) ; POStore str = getStore ( ) ; str . setSFile ( fileSpec ) ; mmro . reducePlan . addAsLeaf ( str ) ; mro . mapPlan . add ( ld ) ; if ( leaf != null ) mro . mapPlan . connect ( ld , leaf ) ; MRPlan . connect ( mmro , mro ) ; }
rekhajoshm/pig | private MapReduceOper endSingleInputPlanWithStr ( FileSpec fSpec ) throws PlanException { if ( compiledInputs . length > 1 ) { int errCode = 2023 ; String msg = " Received ▁ a ▁ multi ▁ input ▁ plan ▁ when ▁ expecting ▁ only ▁ a ▁ single ▁ input ▁ one . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } MapReduceOper mro = compiledInputs [ 0 ] ; POStore str = getStore ( ) ; str . setSFile ( fSpec ) ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( str ) ; mro . setMapDoneSingle ( true ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( str ) ; mro . setReduceDone ( true ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } return mro ; }
rekhajoshm/pig | private MapReduceOper startNew ( FileSpec fSpec , MapReduceOper old ) throws PlanException { POLoad ld = getLoad ( ) ; ld . setLFile ( fSpec ) ; MapReduceOper ret = getMROp ( ) ; ret . mapPlan . add ( ld ) ; MRPlan . add ( ret ) ; MRPlan . connect ( old , ret ) ; return ret ; }
rekhajoshm/pig | private FileSpec getTempFileSpec ( ) throws IOException { return new FileSpec ( FileLocalizer . getTemporaryPath ( pigContext ) . toString ( ) , new FuncSpec ( Utils . getTmpFileCompressorName ( pigContext ) ) ) ; }
rekhajoshm/pig | private List < MapReduceOper > merge ( MapReduceOper [ ] compiledInputs ) throws PlanException { List < MapReduceOper > ret = new ArrayList < MapReduceOper > ( ) ; MapReduceOper mergedMap = getMROp ( ) ; ret . add ( mergedMap ) ; MRPlan . add ( mergedMap ) ; Set < MapReduceOper > toBeConnected = new HashSet < MapReduceOper > ( ) ; List < MapReduceOper > remLst = new ArrayList < MapReduceOper > ( ) ; List < PhysicalPlan > mpLst = new ArrayList < PhysicalPlan > ( ) ; for ( MapReduceOper mro : compiledInputs ) { if ( ! mro . isMapDone ( ) ) { remLst . add ( mro ) ; mpLst . add ( mro . mapPlan ) ; List < MapReduceOper > pmros = MRPlan . getPredecessors ( mro ) ; if ( pmros != null ) { for ( MapReduceOper pmro : pmros ) toBeConnected . add ( pmro ) ; } } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { ret . add ( mro ) ; } else { int errCode = 2027 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ for ▁ a ▁ merge . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } } merge ( ret . get ( 0 ) . mapPlan , mpLst ) ; Iterator < MapReduceOper > it = toBeConnected . iterator ( ) ; while ( it . hasNext ( ) ) MRPlan . connect ( it . next ( ) , mergedMap ) ; for ( MapReduceOper rmro : remLst ) { if ( rmro . requestedParallelism > mergedMap . requestedParallelism ) mergedMap . requestedParallelism = rmro . requestedParallelism ; for ( String udf : rmro . UDFs ) { if ( ! mergedMap . UDFs . contains ( udf ) ) mergedMap . UDFs . add ( udf ) ; } for ( PhysicalOperator physOp : rmro . scalars ) { if ( ! mergedMap . scalars . contains ( physOp ) ) { mergedMap . scalars . add ( physOp ) ; } } Set < PhysicalOperator > opsToChange = new HashSet < PhysicalOperator > ( ) ; for ( Map . Entry < PhysicalOperator , MapReduceOper > entry : phyToMROpMap . entrySet ( ) ) { if ( entry . getValue ( ) == rmro ) { opsToChange . add ( entry . getKey ( ) ) ; } } for ( PhysicalOperator op : opsToChange ) { phyToMROpMap . put ( op , mergedMap ) ; } MRPlan . remove ( rmro ) ; } return ret ; }
rekhajoshm/pig | private < O extends Operator , E extends OperatorPlan < O > > void merge ( E finPlan , List < E > plans ) throws PlanException { for ( E e : plans ) { finPlan . merge ( e ) ; } }
rekhajoshm/pig | private void processUDFs ( PhysicalPlan plan ) throws VisitorException { if ( plan != null ) { ScalarPhyFinder scalarPhyFinder = new ScalarPhyFinder ( plan ) ; scalarPhyFinder . visit ( ) ; curMROp . scalars . addAll ( scalarPhyFinder . getScalars ( ) ) ; udfFinder . setPlan ( plan ) ; udfFinder . visit ( ) ; curMROp . UDFs . addAll ( udfFinder . getUDFs ( ) ) ; } }
rekhajoshm/pig | @ Override public void visitSplit ( POSplit op ) throws VisitorException { try { FileSpec fSpec = op . getSplitStore ( ) ; MapReduceOper mro = endSingleInputPlanWithStr ( fSpec ) ; mro . setSplitter ( true ) ; splitsSeen . put ( op . getOperatorKey ( ) , mro ) ; curMROp = startNew ( fSpec , mro ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitLoad ( POLoad op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitNative ( PONative op ) throws VisitorException { try { MapReduceOper nativeMROper = getNativeMROp ( op . getNativeMRjar ( ) , op . getParams ( ) ) ; MRPlan . add ( nativeMROper ) ; MRPlan . connect ( curMROp , nativeMROper ) ; phyToMROpMap . put ( op , nativeMROper ) ; curMROp = nativeMROper ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitStore ( POStore op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; if ( op . getSFile ( ) != null && op . getSFile ( ) . getFuncSpec ( ) != null ) curMROp . UDFs . add ( op . getSFile ( ) . getFuncSpec ( ) . toString ( ) ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitFilter ( POFilter op ) throws VisitorException { try { nonBlocking ( op ) ; processUDFs ( op . getPlan ( ) ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitCross ( POCross op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitStream ( POStream op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitLimit ( POLimit op ) throws VisitorException { try { MapReduceOper mro = compiledInputs [ 0 ] ; mro . limit = op . getLimit ( ) ; if ( op . getLimitPlan ( ) != null ) { processUDFs ( op . getLimitPlan ( ) ) ; mro . limitPlan = op . getLimitPlan ( ) ; } if ( ! mro . isMapDone ( ) ) { if ( ! pigContext . inIllustrator ) { mro . mapPlan . addAsLeaf ( op ) ; mro . setMapDone ( true ) ; } if ( mro . reducePlan . isEmpty ( ) ) { MRUtil . simpleConnectMapToReduce ( mro , scope , nig ) ; mro . requestedParallelism = 1 ; if ( ! pigContext . inIllustrator ) { POLimit pLimit2 = new POLimit ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pLimit2 . setLimit ( op . getLimit ( ) ) ; pLimit2 . setLimitPlan ( op . getLimitPlan ( ) ) ; mro . reducePlan . addAsLeaf ( pLimit2 ) ; } else { mro . reducePlan . addAsLeaf ( op ) ; } } else { messageCollector . collect ( " Something ▁ in ▁ the ▁ reduce ▁ plan ▁ while ▁ map ▁ plan ▁ is ▁ not ▁ done . ▁ Something ▁ wrong ! " , MessageType . Warning , PigWarning . REDUCE_PLAN_NOT_EMPTY_WHILE_MAP_PLAN_UNDER_PROCESS ) ; } } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( op ) ; } else { messageCollector . collect ( " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling ! " , MessageType . Warning , PigWarning . UNREACHABLE_CODE_BOTH_MAP_AND_REDUCE_PLANS_PROCESSED ) ; } phyToMROpMap . put ( op , mro ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitLocalRearrange ( POLocalRearrange op ) throws VisitorException { try { addToMap ( op ) ; List < PhysicalPlan > plans = op . getPlans ( ) ; if ( plans != null ) for ( PhysicalPlan ep : plans ) processUDFs ( ep ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitCollectedGroup ( POCollectedGroup op ) throws VisitorException { if ( ! curMROp . mapDone ) { List < PhysicalOperator > roots = curMROp . mapPlan . getRoots ( ) ; if ( roots . size ( ) != 1 ) { int errCode = 2171 ; String errMsg = " Expected ▁ one ▁ but ▁ found ▁ more ▁ then ▁ one ▁ root ▁ physical ▁ operator ▁ in ▁ physical ▁ plan . " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } PhysicalOperator phyOp = roots . get ( 0 ) ; if ( ! ( phyOp instanceof POLoad ) ) { int errCode = 2172 ; String errMsg = " Expected ▁ physical ▁ operator ▁ at ▁ root ▁ to ▁ be ▁ POLoad . ▁ Found ▁ : ▁ " + phyOp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } LoadFunc loadFunc = ( ( POLoad ) phyOp ) . getLoadFunc ( ) ; try { if ( ! ( CollectableLoadFunc . class . isAssignableFrom ( loadFunc . getClass ( ) ) ) ) { int errCode = 2249 ; throw new MRCompilerException ( " While ▁ using ▁ ' collected ' ▁ on ▁ group ; ▁ data ▁ must ▁ be ▁ loaded ▁ via ▁ loader ▁ implementing ▁ CollectableLoadFunc . " , errCode ) ; } ( ( CollectableLoadFunc ) loadFunc ) . ensureAllKeyInstancesInSameSplit ( ) ; } catch ( MRCompilerException e ) { throw ( e ) ; } catch ( IOException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } try { nonBlocking ( op ) ; List < PhysicalPlan > plans = op . getPlans ( ) ; if ( plans != null ) for ( PhysicalPlan ep : plans ) processUDFs ( ep ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } } else if ( ! curMROp . reduceDone ) { int errCode = 2250 ; String msg = " Blocking ▁ operators ▁ are ▁ not ▁ allowed ▁ before ▁ Collected ▁ Group . ▁ Consider ▁ dropping ▁ using ▁ ' collected ' . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } }
rekhajoshm/pig | @ Override public void visitPOForEach ( POForEach op ) throws VisitorException { try { nonBlocking ( op ) ; List < PhysicalPlan > plans = op . getInputPlans ( ) ; if ( plans != null ) for ( PhysicalPlan plan : plans ) { processUDFs ( plan ) ; } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitGlobalRearrange ( POGlobalRearrange op ) throws VisitorException { try { blocking ( op ) ; curMROp . customPartitioner = op . getCustomPartitioner ( ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitPackage ( POPackage op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; if ( op . getPackageType ( ) == PackageType . JOIN ) { curMROp . markRegularJoin ( ) ; } else if ( op . getPackageType ( ) == PackageType . GROUP ) { if ( op . getNumInps ( ) == 1 ) { curMROp . markGroupBy ( ) ; } else if ( op . getNumInps ( ) > 1 ) { curMROp . markCogroup ( ) ; } } } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitUnion ( POUnion op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitFRJoin ( POFRJoin op ) throws VisitorException { try { FileSpec [ ] replFiles = new FileSpec [ op . getInputs ( ) . size ( ) ] ; for ( int i = 0 ; i < replFiles . length ; i ++ ) { if ( i == op . getFragment ( ) ) continue ; replFiles [ i ] = getTempFileSpec ( ) ; } op . setReplFiles ( replFiles ) ; curMROp = phyToMROpMap . get ( op . getInputs ( ) . get ( op . getFragment ( ) ) ) ; for ( int i = 0 ; i < compiledInputs . length ; i ++ ) { MapReduceOper mro = compiledInputs [ i ] ; if ( curMROp . equals ( mro ) ) continue ; POStore str = getStore ( ) ; str . setSFile ( replFiles [ i ] ) ; Configuration conf = ConfigurationUtil . toConfiguration ( pigContext . getProperties ( ) ) ; boolean combinable = ! conf . getBoolean ( " pig . noSplitCombination " , false ) ; if ( ! mro . isMapDone ( ) ) { if ( combinable && hasTooManyInputFiles ( mro , conf ) ) { POStore tmpSto = getStore ( ) ; FileSpec fSpec = getTempFileSpec ( ) ; tmpSto . setSFile ( fSpec ) ; mro . mapPlan . addAsLeaf ( tmpSto ) ; mro . setMapDoneSingle ( true ) ; MapReduceOper catMROp = getConcatenateJob ( fSpec , mro , str ) ; MRPlan . connect ( catMROp , curMROp ) ; } else { mro . mapPlan . addAsLeaf ( str ) ; mro . setMapDoneSingle ( true ) ; MRPlan . connect ( mro , curMROp ) ; } } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { if ( combinable && ( mro . requestedParallelism >= fileConcatenationThreshold ) ) { POStore tmpSto = getStore ( ) ; FileSpec fSpec = getTempFileSpec ( ) ; tmpSto . setSFile ( fSpec ) ; mro . reducePlan . addAsLeaf ( tmpSto ) ; mro . setReduceDone ( true ) ; MapReduceOper catMROp = getConcatenateJob ( fSpec , mro , str ) ; MRPlan . connect ( catMROp , curMROp ) ; } else { mro . reducePlan . addAsLeaf ( str ) ; mro . setReduceDone ( true ) ; MRPlan . connect ( mro , curMROp ) ; } } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } } if ( ! curMROp . isMapDone ( ) ) { curMROp . mapPlan . addAsLeaf ( op ) ; } else if ( curMROp . isMapDone ( ) && ! curMROp . isReduceDone ( ) ) { curMROp . reducePlan . addAsLeaf ( op ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } List < List < PhysicalPlan > > joinPlans = op . getJoinPlans ( ) ; if ( joinPlans != null ) for ( List < PhysicalPlan > joinPlan : joinPlans ) { if ( joinPlan != null ) for ( PhysicalPlan plan : joinPlan ) { processUDFs ( plan ) ; } } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | private boolean hasTooManyInputFiles ( MapReduceOper mro , Configuration conf ) { if ( pigContext == null || pigContext . getExecType ( ) == ExecType . LOCAL ) { return false ; } if ( mro instanceof NativeMapReduceOper ) { return optimisticFileConcatenation ? false : true ; } PhysicalPlan mapPlan = mro . mapPlan ; List < PhysicalOperator > roots = mapPlan . getRoots ( ) ; if ( roots == null || roots . size ( ) == 0 ) return false ; int numFiles = 0 ; boolean ret = false ; try { for ( PhysicalOperator root : roots ) { POLoad ld = ( POLoad ) root ; String fileName = ld . getLFile ( ) . getFileName ( ) ; if ( UriUtil . isHDFSFile ( fileName ) ) { String [ ] locations = LoadFunc . getPathStrings ( fileName ) ; for ( String location : locations ) { if ( ! UriUtil . isHDFSFile ( location ) ) continue ; Path path = new Path ( location ) ; FileSystem fs = path . getFileSystem ( conf ) ; if ( fs . exists ( path ) ) { LoadFunc loader = ( LoadFunc ) PigContext . instantiateFuncFromSpec ( ld . getLFile ( ) . getFuncSpec ( ) ) ; Job job = new Job ( conf ) ; loader . setUDFContextSignature ( ld . getSignature ( ) ) ; loader . setLocation ( location , job ) ; InputFormat inf = loader . getInputFormat ( ) ; List < InputSplit > splits = inf . getSplits ( HadoopShims . cloneJobContext ( job ) ) ; List < List < InputSplit > > results = MapRedUtil . getCombinePigSplits ( splits , HadoopShims . getDefaultBlockSize ( fs , path ) , conf ) ; numFiles += results . size ( ) ; } else { List < MapReduceOper > preds = MRPlan . getPredecessors ( mro ) ; if ( preds != null && preds . size ( ) == 1 ) { MapReduceOper pred = preds . get ( 0 ) ; if ( ! pred . reducePlan . isEmpty ( ) ) { numFiles += pred . requestedParallelism ; } else { ret = hasTooManyInputFiles ( pred , conf ) ; break ; } } else if ( ! optimisticFileConcatenation ) { numFiles = fileConcatenationThreshold ; break ; } } } } } } catch ( IOException e ) { LOG . warn ( " failed ▁ to ▁ get ▁ number ▁ of ▁ input ▁ files " , e ) ; } catch ( InterruptedException e ) { LOG . warn ( " failed ▁ to ▁ get ▁ number ▁ of ▁ input ▁ files " , e ) ; } LOG . info ( " number ▁ of ▁ input ▁ files : ▁ " + numFiles ) ; return ret ? true : ( numFiles >= fileConcatenationThreshold ) ; }
rekhajoshm/pig | @ Override public void visitMergeCoGroup ( POMergeCogroup poCoGrp ) throws VisitorException { if ( compiledInputs . length < 2 ) { int errCode = 2251 ; String errMsg = " Merge ▁ Cogroup ▁ work ▁ on ▁ two ▁ or ▁ more ▁ relations . " + " To ▁ use ▁ map - side ▁ group - by ▁ on ▁ single ▁ relation , ▁ use ▁ ' collected ' ▁ qualifier . " ; throw new MRCompilerException ( errMsg , errCode ) ; } List < FuncSpec > funcSpecs = new ArrayList < FuncSpec > ( compiledInputs . length - 1 ) ; List < String > fileSpecs = new ArrayList < String > ( compiledInputs . length - 1 ) ; List < String > loaderSigns = new ArrayList < String > ( compiledInputs . length - 1 ) ; try { for ( int i = 0 ; i < compiledInputs . length ; i ++ ) { MapReduceOper mrOper = compiledInputs [ i ] ; PhysicalPlan mapPlan = mrOper . mapPlan ; if ( mapPlan . getRoots ( ) . size ( ) != 1 ) { int errCode = 2171 ; String errMsg = " Expected ▁ one ▁ but ▁ found ▁ more ▁ then ▁ one ▁ root ▁ physical ▁ operator ▁ in ▁ physical ▁ plan . " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } PhysicalOperator rootPOOp = mapPlan . getRoots ( ) . get ( 0 ) ; if ( ! ( rootPOOp instanceof POLoad ) ) { int errCode = 2172 ; String errMsg = " Expected ▁ physical ▁ operator ▁ at ▁ root ▁ to ▁ be ▁ POLoad . ▁ Found ▁ : ▁ " + rootPOOp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( errMsg , errCode ) ; } POLoad sideLoader = ( POLoad ) rootPOOp ; FileSpec loadFileSpec = sideLoader . getLFile ( ) ; FuncSpec funcSpec = loadFileSpec . getFuncSpec ( ) ; LoadFunc loadfunc = sideLoader . getLoadFunc ( ) ; if ( i == 0 ) { if ( ! ( CollectableLoadFunc . class . isAssignableFrom ( loadfunc . getClass ( ) ) ) ) { int errCode = 2252 ; throw new MRCompilerException ( " Base ▁ loader ▁ in ▁ Cogroup ▁ must ▁ implement ▁ CollectableLoadFunc . " , errCode ) ; } ( ( CollectableLoadFunc ) loadfunc ) . ensureAllKeyInstancesInSameSplit ( ) ; continue ; } if ( ! ( IndexableLoadFunc . class . isAssignableFrom ( loadfunc . getClass ( ) ) ) ) { int errCode = 2253 ; throw new MRCompilerException ( " Side ▁ loaders ▁ in ▁ cogroup ▁ must ▁ implement ▁ IndexableLoadFunc . " , errCode ) ; } funcSpecs . add ( funcSpec ) ; fileSpecs . add ( loadFileSpec . getFileName ( ) ) ; loaderSigns . add ( sideLoader . getSignature ( ) ) ; MRPlan . remove ( mrOper ) ; } poCoGrp . setSideLoadFuncs ( funcSpecs ) ; poCoGrp . setSideFileSpecs ( fileSpecs ) ; poCoGrp . setLoaderSignatures ( loaderSigns ) ; MapReduceOper baseMROp = phyToMROpMap . get ( poCoGrp . getInputs ( ) . get ( 0 ) ) ; if ( baseMROp . mapDone || ! baseMROp . reducePlan . isEmpty ( ) ) { int errCode = 2254 ; throw new MRCompilerException ( " Currently ▁ merged ▁ cogroup ▁ is ▁ not ▁ supported ▁ after ▁ blocking ▁ operators . " , errCode ) ; } MapReduceOper indexerMROp = getMROp ( ) ; FileSpec idxFileSpec = getIndexingJob ( indexerMROp , baseMROp , poCoGrp . getLRInnerPlansOf ( 0 ) ) ; poCoGrp . setIdxFuncSpec ( idxFileSpec . getFuncSpec ( ) ) ; poCoGrp . setIndexFileName ( idxFileSpec . getFileName ( ) ) ; baseMROp . mapPlan . addAsLeaf ( poCoGrp ) ; for ( FuncSpec funcSpec : funcSpecs ) baseMROp . UDFs . add ( funcSpec . toString ( ) ) ; MRPlan . add ( indexerMROp ) ; MRPlan . connect ( indexerMROp , baseMROp ) ; phyToMROpMap . put ( poCoGrp , baseMROp ) ; curMROp = baseMROp ; } catch ( ExecException e ) { throw new MRCompilerException ( e . getDetailedMessage ( ) , e . getErrorCode ( ) , e . getErrorSource ( ) , e ) ; } catch ( MRCompilerException mrce ) { throw ( mrce ) ; } catch ( CloneNotSupportedException e ) { throw new MRCompilerException ( e ) ; } catch ( PlanException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + poCoGrp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } catch ( IOException e ) { int errCode = 3000 ; String errMsg = " IOException ▁ caught ▁ while ▁ compiling ▁ POMergeCoGroup " ; throw new MRCompilerException ( errMsg , errCode , e ) ; } }
rekhajoshm/pig | if ( ! ( OrderedLoadFunc . class . isAssignableFrom ( loadFunc . getClass ( ) ) ) ) { int errCode = 1104 ; String errMsg = " Base ▁ relation ▁ of ▁ merge - coGroup ▁ must ▁ implement ▁ " + " OrderedLoadFunc ▁ interface . ▁ The ▁ specified ▁ loader ▁ " + funcSpec + " ▁ doesn ' t ▁ implement ▁ it " ; throw new MRCompilerException ( errMsg , errCode ) ; }
rekhajoshm/pig | if ( baseMapPlan . getSuccessors ( baseLoader ) == null || baseMapPlan . getSuccessors ( baseLoader ) . isEmpty ( ) ) { phyPlan = null ; }
rekhajoshm/pig | @ Override public void visitMergeJoin ( POMergeJoin joinOp ) throws VisitorException { try { if ( compiledInputs . length != 2 || joinOp . getInputs ( ) . size ( ) != 2 ) { int errCode = 1101 ; throw new MRCompilerException ( " Merge ▁ Join ▁ must ▁ have ▁ exactly ▁ two ▁ inputs . ▁ Found ▁ : ▁ " + compiledInputs . length , errCode ) ; } curMROp = phyToMROpMap . get ( joinOp . getInputs ( ) . get ( 0 ) ) ; MapReduceOper rightMROpr = null ; if ( curMROp . equals ( compiledInputs [ 0 ] ) ) rightMROpr = compiledInputs [ 1 ] ; else rightMROpr = compiledInputs [ 0 ] ; PhysicalPlan rightPipelinePlan ; if ( ! rightMROpr . mapDone ) { PhysicalPlan rightMapPlan = rightMROpr . mapPlan ; if ( rightMapPlan . getRoots ( ) . size ( ) != 1 ) { int errCode = 2171 ; String errMsg = " Expected ▁ one ▁ but ▁ found ▁ more ▁ then ▁ one ▁ root ▁ physical ▁ operator ▁ in ▁ physical ▁ plan . " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } PhysicalOperator rightLoader = rightMapPlan . getRoots ( ) . get ( 0 ) ; if ( ! ( rightLoader instanceof POLoad ) ) { int errCode = 2172 ; String errMsg = " Expected ▁ physical ▁ operator ▁ at ▁ root ▁ to ▁ be ▁ POLoad . ▁ Found ▁ : ▁ " + rightLoader . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( errMsg , errCode ) ; } if ( rightMapPlan . getSuccessors ( rightLoader ) == null || rightMapPlan . getSuccessors ( rightLoader ) . isEmpty ( ) ) rightPipelinePlan = null ; else { rightPipelinePlan = rightMapPlan . clone ( ) ; PhysicalOperator root = rightPipelinePlan . getRoots ( ) . get ( 0 ) ; rightPipelinePlan . disconnect ( root , rightPipelinePlan . getSuccessors ( root ) . get ( 0 ) ) ; rightPipelinePlan . remove ( root ) ; rightMapPlan . trimBelow ( rightLoader ) ; } } else if ( ! rightMROpr . reduceDone ) { POStore rightStore = getStore ( ) ; FileSpec rightStrFile = getTempFileSpec ( ) ; rightStore . setSFile ( rightStrFile ) ; rightMROpr . reducePlan . addAsLeaf ( rightStore ) ; rightMROpr . setReduceDone ( true ) ; rightMROpr = startNew ( rightStrFile , rightMROpr ) ; rightPipelinePlan = null ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } joinOp . setupRightPipeline ( rightPipelinePlan ) ; rightMROpr . requestedParallelism = 1 ; POLoad rightLoader = ( POLoad ) rightMROpr . mapPlan . getRoots ( ) . get ( 0 ) ; joinOp . setSignature ( rightLoader . getSignature ( ) ) ; LoadFunc rightLoadFunc = rightLoader . getLoadFunc ( ) ; List < String > udfs = new ArrayList < String > ( ) ; if ( IndexableLoadFunc . class . isAssignableFrom ( rightLoadFunc . getClass ( ) ) ) { joinOp . setRightLoaderFuncSpec ( rightLoader . getLFile ( ) . getFuncSpec ( ) ) ; joinOp . setRightInputFileName ( rightLoader . getLFile ( ) . getFileName ( ) ) ; udfs . add ( rightLoader . getLFile ( ) . getFuncSpec ( ) . toString ( ) ) ; MRPlan . remove ( rightMROpr ) ; if ( rightMROpr == compiledInputs [ 0 ] ) { compiledInputs [ 0 ] = null ; } else if ( rightMROpr == compiledInputs [ 1 ] ) { compiledInputs [ 1 ] = null ; } rightMROpr = null ; int numInputs = mPlan . getPredecessors ( joinOp ) . size ( ) ; for ( int i = 0 ; i < numInputs ; i ++ ) { List < PhysicalPlan > keyPlans = joinOp . getInnerPlansOf ( i ) ; for ( PhysicalPlan keyPlan : keyPlans ) { for ( PhysicalOperator op : keyPlan ) { if ( ! ( op instanceof POProject ) ) { int errCode = 1106 ; String errMsg = " Merge ▁ join ▁ is ▁ possible ▁ only ▁ for ▁ simple ▁ column ▁ or ▁ ' * ' ▁ join ▁ keys ▁ when ▁ using ▁ " + rightLoader . getLFile ( ) . getFuncSpec ( ) + " ▁ as ▁ the ▁ loader " ; throw new MRCompilerException ( errMsg , errCode , PigException . INPUT ) ; } } } } } else { LoadFunc loadFunc = rightLoader . getLoadFunc ( ) ; if ( joinOp . getJoinType ( ) == LOJoin . JOINTYPE . MERGESPARSE ) { int errCode = 1104 ; String errMsg = " Right ▁ input ▁ of ▁ merge - join ▁ must ▁ implement ▁ IndexableLoadFunc . ▁ " + " The ▁ specified ▁ loader ▁ " + loadFunc + " ▁ doesn ' t ▁ implement ▁ it " ; throw new MRCompilerException ( errMsg , errCode ) ; } if ( ! ( OrderedLoadFunc . class . isAssignableFrom ( loadFunc . getClass ( ) ) ) ) { int errCode = 1104 ; String errMsg = " Right ▁ input ▁ of ▁ merge - join ▁ must ▁ implement ▁ " + " OrderedLoadFunc ▁ interface . ▁ The ▁ specified ▁ loader ▁ " + loadFunc + " ▁ doesn ' t ▁ implement ▁ it " ; throw new MRCompilerException ( errMsg , errCode ) ; } String [ ] indexerArgs = new String [ 6 ] ; List < PhysicalPlan > rightInpPlans = joinOp . getInnerPlansOf ( 1 ) ; FileSpec origRightLoaderFileSpec = rightLoader . getLFile ( ) ; indexerArgs [ 0 ] = origRightLoaderFileSpec . getFuncSpec ( ) . toString ( ) ; indexerArgs [ 1 ] = ObjectSerializer . serialize ( ( Serializable ) rightInpPlans ) ; indexerArgs [ 2 ] = ObjectSerializer . serialize ( rightPipelinePlan ) ; indexerArgs [ 3 ] = rightLoader . getSignature ( ) ; indexerArgs [ 4 ] = rightLoader . getOperatorKey ( ) . scope ; indexerArgs [ 5 ] = Boolean . toString ( true ) ; FileSpec lFile = new FileSpec ( rightLoader . getLFile ( ) . getFileName ( ) , new FuncSpec ( MergeJoinIndexer . class . getName ( ) , indexerArgs ) ) ; rightLoader . setLFile ( lFile ) ; MRUtil . simpleConnectMapToReduce ( rightMROpr , scope , nig ) ; rightMROpr . useTypedComparator ( true ) ; POStore st = getStore ( ) ; FileSpec strFile = getTempFileSpec ( ) ; st . setSFile ( strFile ) ; rightMROpr . reducePlan . addAsLeaf ( st ) ; rightMROpr . setReduceDone ( true ) ; String [ ] defaultIndexableLoaderArgs = new String [ 5 ] ; defaultIndexableLoaderArgs [ 0 ] = origRightLoaderFileSpec . getFuncSpec ( ) . toString ( ) ; defaultIndexableLoaderArgs [ 1 ] = strFile . getFileName ( ) ; defaultIndexableLoaderArgs [ 2 ] = strFile . getFuncSpec ( ) . toString ( ) ; defaultIndexableLoaderArgs [ 3 ] = joinOp . getOperatorKey ( ) . scope ; defaultIndexableLoaderArgs [ 4 ] = origRightLoaderFileSpec . getFileName ( ) ; joinOp . setRightLoaderFuncSpec ( ( new FuncSpec ( DefaultIndexableLoader . class . getName ( ) , defaultIndexableLoaderArgs ) ) ) ; joinOp . setRightInputFileName ( origRightLoaderFileSpec . getFileName ( ) ) ; joinOp . setIndexFile ( strFile . getFileName ( ) ) ; udfs . add ( origRightLoaderFileSpec . getFuncSpec ( ) . toString ( ) ) ; } if ( ! curMROp . mapDone ) curMROp . mapPlan . addAsLeaf ( joinOp ) ; else if ( ! curMROp . reduceDone ) { POStore leftStore = getStore ( ) ; FileSpec leftStrFile = getTempFileSpec ( ) ; leftStore . setSFile ( leftStrFile ) ; curMROp . reducePlan . addAsLeaf ( leftStore ) ; curMROp . setReduceDone ( true ) ; curMROp = startNew ( leftStrFile , curMROp ) ; curMROp . mapPlan . addAsLeaf ( joinOp ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } if ( rightMROpr != null ) { rightMROpr . markIndexer ( ) ; MRPlan . connect ( rightMROpr , curMROp ) ; } phyToMROpMap . put ( joinOp , curMROp ) ; curMROp . noCombineSmallSplits ( ) ; curMROp . UDFs . addAll ( udfs ) ; } catch ( PlanException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + joinOp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } catch ( IOException e ) { int errCode = 3000 ; String errMsg = " IOException ▁ caught ▁ while ▁ compiling ▁ POMergeJoin " ; throw new MRCompilerException ( errMsg , errCode , e ) ; } catch ( CloneNotSupportedException e ) { int errCode = 2127 ; String errMsg = " Cloning ▁ exception ▁ caught ▁ while ▁ compiling ▁ POMergeJoin " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitDistinct ( PODistinct op ) throws VisitorException { try { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prjStar = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prjStar . setResultType ( DataType . TUPLE ) ; prjStar . setStar ( true ) ; ep . add ( prjStar ) ; List < PhysicalPlan > eps = new ArrayList < PhysicalPlan > ( ) ; eps . add ( ep ) ; POLocalRearrange lr = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; lr . setIndex ( 0 ) ; lr . setKeyType ( DataType . TUPLE ) ; lr . setPlans ( eps ) ; lr . setResultType ( DataType . TUPLE ) ; lr . setDistinct ( true ) ; addToMap ( lr ) ; blocking ( op ) ; curMROp . customPartitioner = op . getCustomPartitioner ( ) ; POPackage pkg = new POPackage ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pkg . setKeyType ( DataType . TUPLE ) ; pkg . setDistinct ( true ) ; pkg . setNumInps ( 1 ) ; boolean [ ] inner = { false } ; pkg . setInner ( inner ) ; curMROp . reducePlan . add ( pkg ) ; List < PhysicalPlan > eps1 = new ArrayList < PhysicalPlan > ( ) ; List < Boolean > flat1 = new ArrayList < Boolean > ( ) ; PhysicalPlan ep1 = new PhysicalPlan ( ) ; POProject prj1 = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj1 . setResultType ( DataType . TUPLE ) ; prj1 . setStar ( false ) ; prj1 . setColumn ( 0 ) ; prj1 . setOverloaded ( false ) ; ep1 . add ( prj1 ) ; eps1 . add ( ep1 ) ; flat1 . add ( true ) ; POForEach nfe1 = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , op . getRequestedParallelism ( ) , eps1 , flat1 ) ; nfe1 . setResultType ( DataType . BAG ) ; curMROp . reducePlan . addAsLeaf ( nfe1 ) ; curMROp . setNeedsDistinctCombiner ( true ) ; phyToMROpMap . put ( op , curMROp ) ; curMROp . phyToMRMap . put ( op , nfe1 ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitSkewedJoin ( POSkewedJoin op ) throws VisitorException { try { if ( compiledInputs . length != 2 ) { int errCode = 2255 ; throw new VisitorException ( " POSkewedJoin ▁ operator ▁ has ▁ " + compiledInputs . length + " ▁ inputs . ▁ It ▁ should ▁ have ▁ 2 . " , errCode ) ; } FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper mro = compiledInputs [ 0 ] ; POStore str = getStore ( ) ; str . setSFile ( fSpec ) ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( str ) ; mro . setMapDoneSingle ( true ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( str ) ; mro . setReduceDone ( true ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } FileSpec partitionFile = getTempFileSpec ( ) ; int rp = op . getRequestedParallelism ( ) ; Pair < MapReduceOper , Integer > sampleJobPair = getSkewedJoinSampleJob ( op , mro , fSpec , partitionFile , rp ) ; rp = sampleJobPair . second ; op . setRequestedParallelism ( rp ) ; MapReduceOper [ ] joinInputs = new MapReduceOper [ ] { startNew ( fSpec , sampleJobPair . first ) , compiledInputs [ 1 ] } ; MapReduceOper [ ] rearrangeOutputs = new MapReduceOper [ 2 ] ; compiledInputs = new MapReduceOper [ ] { joinInputs [ 0 ] } ; POLocalRearrange lr = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; try { lr . setIndex ( 0 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } List < PhysicalOperator > l = plan . getPredecessors ( op ) ; MultiMap < PhysicalOperator , PhysicalPlan > joinPlans = op . getJoinPlans ( ) ; List < PhysicalPlan > groups = joinPlans . get ( l . get ( 0 ) ) ; byte type = DataType . TUPLE ; if ( groups . size ( ) == 1 ) { type = groups . get ( 0 ) . getLeaves ( ) . get ( 0 ) . getResultType ( ) ; } lr . setKeyType ( type ) ; lr . setPlans ( groups ) ; lr . setResultType ( DataType . TUPLE ) ; lr . visit ( this ) ; if ( lr . getRequestedParallelism ( ) > curMROp . requestedParallelism ) curMROp . requestedParallelism = lr . getRequestedParallelism ( ) ; rearrangeOutputs [ 0 ] = curMROp ; compiledInputs = new MapReduceOper [ ] { joinInputs [ 1 ] } ; if ( compiledInputs [ 0 ] . isMapDone ( ) && ! compiledInputs [ 0 ] . isReduceDone ( ) ) { FileSpec f = getTempFileSpec ( ) ; POStore s = getStore ( ) ; s . setSFile ( f ) ; compiledInputs [ 0 ] . reducePlan . addAsLeaf ( s ) ; compiledInputs [ 0 ] . setReduceDone ( true ) ; compiledInputs [ 0 ] = startNew ( f , compiledInputs [ 0 ] ) ; } POPartitionRearrange pr = new POPartitionRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; pr . setPigContext ( pigContext ) ; lr = pr ; try { lr . setIndex ( 1 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } groups = joinPlans . get ( l . get ( 1 ) ) ; lr . setPlans ( groups ) ; lr . setKeyType ( type ) ; lr . setResultType ( DataType . BAG ) ; lr . visit ( this ) ; if ( lr . getRequestedParallelism ( ) > curMROp . requestedParallelism ) curMROp . requestedParallelism = lr . getRequestedParallelism ( ) ; rearrangeOutputs [ 1 ] = curMROp ; compiledInputs = rearrangeOutputs ; POGlobalRearrange gr = new POGlobalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; gr . setResultType ( DataType . TUPLE ) ; gr . visit ( this ) ; if ( gr . getRequestedParallelism ( ) > curMROp . requestedParallelism ) curMROp . requestedParallelism = gr . getRequestedParallelism ( ) ; compiledInputs = new MapReduceOper [ ] { curMROp } ; POPackage pkg = new POPackage ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; pkg . setKeyType ( type ) ; pkg . setResultType ( DataType . TUPLE ) ; pkg . setNumInps ( 2 ) ; boolean [ ] inner = op . getInnerFlags ( ) ; pkg . setInner ( inner ) ; pkg . visit ( this ) ; compiledInputs = new MapReduceOper [ ] { curMROp } ; List < PhysicalPlan > eps = new ArrayList < PhysicalPlan > ( ) ; List < Boolean > flat = new ArrayList < Boolean > ( ) ; PhysicalPlan ep ; for ( int i = 0 ; i < 2 ; i ++ ) { ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setColumn ( i + 1 ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . BAG ) ; ep . add ( prj ) ; eps . add ( ep ) ; if ( ! inner [ i ] ) { CompilerUtils . addEmptyBagOuterJoin ( ep , op . getSchema ( i ) ) ; } flat . add ( true ) ; } POForEach fe = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , eps , flat ) ; fe . setResultType ( DataType . TUPLE ) ; fe . visit ( this ) ; curMROp . setSkewedJoinPartitionFile ( partitionFile . getFileName ( ) ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( PlanException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } catch ( IOException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitSort ( POSort op ) throws VisitorException { try { FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper mro = endSingleInputPlanWithStr ( fSpec ) ; FileSpec quantFile = getTempFileSpec ( ) ; int rp = op . getRequestedParallelism ( ) ; Pair < POProject , Byte > [ ] fields = getSortCols ( op . getSortPlans ( ) ) ; Pair < MapReduceOper , Integer > quantJobParallelismPair = getQuantileJob ( op , mro , fSpec , quantFile , rp ) ; curMROp = getSortJob ( op , quantJobParallelismPair . first , fSpec , quantFile , quantJobParallelismPair . second , fields ) ; if ( op . isUDFComparatorUsed ) { curMROp . UDFs . add ( op . getMSortFunc ( ) . getFuncSpec ( ) . toString ( ) ) ; curMROp . isUDFComparatorUsed = true ; } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitCounter ( POCounter op ) throws VisitorException { try { if ( op . isRowNumber ( ) ) { List < PhysicalOperator > mpLeaves = curMROp . mapPlan . getLeaves ( ) ; PhysicalOperator leaf = mpLeaves . get ( 0 ) ; if ( ! curMROp . isMapDone ( ) && ! curMROp . isRankOperation ( ) ) { curMROp . mapPlan . addAsLeaf ( op ) ; } else { FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper prevMROper = endSingleInputPlanWithStr ( fSpec ) ; MapReduceOper mrCounter = startNew ( fSpec , prevMROper ) ; mrCounter . mapPlan . addAsLeaf ( op ) ; curMROp = mrCounter ; } } else { curMROp . reducePlan . addAsLeaf ( op ) ; } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitRank ( PORank op ) throws VisitorException { try { FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper prevMROper = endSingleInputPlanWithStr ( fSpec ) ; curMROp = startNew ( fSpec , prevMROper ) ; curMROp . mapPlan . addAsLeaf ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | if ( plans != null ) { @ SuppressWarnings ( " unchecked " ) Pair < POProject , Byte > [ ] ret = new Pair [ plans . size ( ) ] ; int i = - 1 ; for ( PhysicalPlan plan : plans ) { PhysicalOperator op = plan . getLeaves ( ) . get ( 0 ) ; POProject proj ; if ( op instanceof POProject ) { if ( ( ( POProject ) op ) . isStar ( ) ) return null ; proj = ( POProject ) op ; } else { proj = null ; } byte type = op . getResultType ( ) ; ret [ ++ i ] = new Pair < POProject , Byte > ( proj , type ) ; } return ret ; }
rekhajoshm/pig | private MapReduceOper getSortJob ( POSort sort , MapReduceOper quantJob , FileSpec lFile , FileSpec quantFile , int rp , Pair < POProject , Byte > [ ] fields ) throws PlanException { MapReduceOper mro = startNew ( lFile , quantJob ) ; mro . setQuantFile ( quantFile . getFileName ( ) ) ; mro . setGlobalSort ( true ) ; mro . requestedParallelism = rp ; long limit = sort . getLimit ( ) ; mro . limit = limit ; List < PhysicalPlan > eps1 = new ArrayList < PhysicalPlan > ( ) ; byte keyType = DataType . UNKNOWN ; boolean [ ] sortOrder ; List < Boolean > sortOrderList = sort . getMAscCols ( ) ; if ( sortOrderList != null ) { sortOrder = new boolean [ sortOrderList . size ( ) ] ; for ( int i = 0 ; i < sortOrderList . size ( ) ; ++ i ) { sortOrder [ i ] = sortOrderList . get ( i ) ; } mro . setSortOrder ( sortOrder ) ; } if ( fields == null ) { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setStar ( true ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . TUPLE ) ; ep . add ( prj ) ; eps1 . add ( ep ) ; } else { eps1 . addAll ( sort . getSortPlans ( ) ) ; try { FindKeyTypeVisitor fktv = new FindKeyTypeVisitor ( sort . getSortPlans ( ) . get ( 0 ) ) ; fktv . visit ( ) ; keyType = fktv . keyType ; } catch ( VisitorException ve ) { int errCode = 2035 ; String msg = " Internal ▁ error . ▁ Could ▁ not ▁ compute ▁ key ▁ type ▁ of ▁ sort ▁ operator . " ; throw new PlanException ( msg , errCode , PigException . BUG , ve ) ; } } POLocalRearrange lr = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; try { lr . setIndex ( 0 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } lr . setKeyType ( ( fields == null || fields . length > 1 ) ? DataType . TUPLE : keyType ) ; lr . setPlans ( eps1 ) ; lr . setResultType ( DataType . TUPLE ) ; lr . addOriginalLocation ( sort . getAlias ( ) , sort . getOriginalLocations ( ) ) ; mro . mapPlan . addAsLeaf ( lr ) ; mro . setMapDone ( true ) ; if ( limit != - 1 ) { POPackageLite pkg_c = new POPackageLite ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pkg_c . setKeyType ( ( fields . length > 1 ) ? DataType . TUPLE : keyType ) ; pkg_c . setNumInps ( 1 ) ; mro . combinePlan . add ( pkg_c ) ; List < PhysicalPlan > eps_c1 = new ArrayList < PhysicalPlan > ( ) ; List < Boolean > flat_c1 = new ArrayList < Boolean > ( ) ; PhysicalPlan ep_c1 = new PhysicalPlan ( ) ; POProject prj_c1 = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj_c1 . setColumn ( 1 ) ; prj_c1 . setOverloaded ( false ) ; prj_c1 . setResultType ( DataType . BAG ) ; ep_c1 . add ( prj_c1 ) ; eps_c1 . add ( ep_c1 ) ; flat_c1 . add ( true ) ; POForEach fe_c1 = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , eps_c1 , flat_c1 ) ; fe_c1 . setResultType ( DataType . TUPLE ) ; mro . combinePlan . addAsLeaf ( fe_c1 ) ; POLimit pLimit = new POLimit ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pLimit . setLimit ( limit ) ; mro . combinePlan . addAsLeaf ( pLimit ) ; List < PhysicalPlan > eps_c2 = new ArrayList < PhysicalPlan > ( ) ; eps_c2 . addAll ( sort . getSortPlans ( ) ) ; POLocalRearrange lr_c2 = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; try { lr_c2 . setIndex ( 0 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } lr_c2 . setKeyType ( ( fields . length > 1 ) ? DataType . TUPLE : keyType ) ; lr_c2 . setPlans ( eps_c2 ) ; lr_c2 . setResultType ( DataType . TUPLE ) ; mro . combinePlan . addAsLeaf ( lr_c2 ) ; } POPackageLite pkg = new POPackageLite ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pkg . setKeyType ( ( fields == null || fields . length > 1 ) ? DataType . TUPLE : keyType ) ; pkg . setNumInps ( 1 ) ; mro . reducePlan . add ( pkg ) ; PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setColumn ( 1 ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . BAG ) ; ep . add ( prj ) ; List < PhysicalPlan > eps2 = new ArrayList < PhysicalPlan > ( ) ; eps2 . add ( ep ) ; List < Boolean > flattened = new ArrayList < Boolean > ( ) ; flattened . add ( true ) ; POForEach nfe1 = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , eps2 , flattened ) ; mro . reducePlan . add ( nfe1 ) ; mro . reducePlan . connect ( pkg , nfe1 ) ; mro . phyToMRMap . put ( sort , nfe1 ) ; if ( limit != - 1 ) { POLimit pLimit2 = new POLimit ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pLimit2 . setLimit ( limit ) ; mro . reducePlan . addAsLeaf ( pLimit2 ) ; mro . phyToMRMap . put ( sort , pLimit2 ) ; } return mro ; }
rekhajoshm/pig | if ( sort . isUDFComparatorUsed ) { String userComparatorFuncSpec = sort . getMSortFunc ( ) . getFuncSpec ( ) . toString ( ) ; ctorArgs = new String [ ascs . length + 1 ] ; ctorArgs [ 0 ] = USER_COMPARATOR_MARKER + userComparatorFuncSpec ; for ( int j = 0 ; j < ascs . length ; j ++ ) { ctorArgs [ j + 1 ] = ascs [ j ] ; } }
rekhajoshm/pig | i ++ ) { ascCol . add ( false ) ; }
rekhajoshm/pig | catch ( Exception e ) { throw new PlanException ( e ) ; }
rekhajoshm/pig | if ( sort . isUDFComparatorUsed ) { mro . UDFs . add ( sort . getMSortFunc ( ) . getFuncSpec ( ) . toString ( ) ) ; curMROp . isUDFComparatorUsed = true ; }
rekhajoshm/pig | if ( transformPlans == null ) { Pair < POProject , Byte > [ ] sortProjs = null ; try { sortProjs = getSortCols ( sort . getSortPlans ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( sortProjs == null ) { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setStar ( true ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . TUPLE ) ; ep . add ( prj ) ; eps1 . add ( ep ) ; flat1 . add ( false ) ; } else { for ( Pair < POProject , Byte > sortProj : sortProjs ) { if ( sortProj == null ) { int errCode = 2174 ; String msg = " Internal ▁ exception . ▁ Could ▁ not ▁ create ▁ a ▁ sampler ▁ job " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj ; try { prj = sortProj . first . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( " Error ▁ cloning ▁ project ▁ caught ▁ exception " + e ) ; } ep . add ( prj ) ; eps1 . add ( ep ) ; flat1 . add ( false ) ; } } }
rekhajoshm/pig | i ++ ) { eps1 . add ( transformPlans . get ( i ) ) ; flat1 . add ( true ) ; }
rekhajoshm/pig | catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; }
rekhajoshm/pig | if ( sortKeyPlans != null ) { for ( int i = 0 ; i < sortKeyPlans . size ( ) ; i ++ ) { nesSortPlanLst . add ( sortKeyPlans . get ( i ) ) ; } }
rekhajoshm/pig | catch ( Exception e ) { throw new RuntimeException ( e ) ; }
rekhajoshm/pig | if ( sortProjs == null ) { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setStar ( true ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . TUPLE ) ; ep . add ( prj ) ; nesSortPlanLst . add ( ep ) ; }
rekhajoshm/pig | i ++ ) { POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setResultType ( sortProjs [ i ] . second ) ; if ( sortProjs [ i ] . first != null && sortProjs [ i ] . first . isProjectToEnd ( ) ) { if ( i != sortProjs . length - 1 ) { throw new AssertionError ( " Project - range ▁ to ▁ end ▁ ( x . . ) " + " ▁ is ▁ supported ▁ in ▁ order - by ▁ only ▁ as ▁ last ▁ sort ▁ column " ) ; } prj . setProjectToEnd ( i ) ; break ; } else { prj . setColumn ( i ) ; } prj . setOverloaded ( false ) ; PhysicalPlan ep = new PhysicalPlan ( ) ; ep . add ( prj ) ; nesSortPlanLst . add ( ep ) ; }
rekhajoshm/pig | LastInputStreamingOptimizer ( MROperPlan plan , String chunkSize ) { super ( plan , new DepthFirstWalker < MapReduceOper , MROperPlan > ( plan ) ) ; this . chunkSize = chunkSize ; }
rekhajoshm/pig | @ Override public void visitMROp ( MapReduceOper mr ) throws VisitorException { if ( mr . mapPlan . isEmpty ( ) ) return ; if ( mr . reducePlan . isEmpty ( ) ) return ; if ( ! mr . combinePlan . isEmpty ( ) ) { return ; } List < PhysicalOperator > mpLeaves = mr . mapPlan . getLeaves ( ) ; if ( mpLeaves . size ( ) != 1 ) { return ; } PhysicalOperator op = mpLeaves . get ( 0 ) ; if ( ! ( op instanceof POUnion ) ) { return ; } List < PhysicalOperator > mrRoots = mr . reducePlan . getRoots ( ) ; if ( mrRoots . size ( ) != 1 ) { return ; } op = mrRoots . get ( 0 ) ; if ( ! ( op instanceof POPackage ) ) { return ; } POPackage pack = ( POPackage ) op ; List < PhysicalOperator > sucs = mr . reducePlan . getSuccessors ( pack ) ; if ( sucs == null || sucs . size ( ) != 1 ) { return ; } op = sucs . get ( 0 ) ; boolean lastInputFlattened = true ; boolean allSimple = true ; if ( op instanceof POForEach ) { POForEach forEach = ( POForEach ) op ; List < PhysicalPlan > planList = forEach . getInputPlans ( ) ; List < Boolean > flatten = forEach . getToBeFlattened ( ) ; POProject projOfLastInput = null ; int i = 0 ; for ( PhysicalPlan p : planList ) { PhysicalOperator opProj = p . getRoots ( ) . get ( 0 ) ; if ( ! ( opProj instanceof POProject ) ) { allSimple = false ; break ; } POProject proj = ( POProject ) opProj ; if ( proj . isProjectToEnd ( ) || proj . getColumns ( ) . size ( ) != 1 ) { allSimple = false ; break ; } try { if ( proj . getColumn ( ) == pack . getNumInps ( ) ) { if ( projOfLastInput != null ) { allSimple = false ; break ; } projOfLastInput = proj ; if ( ! flatten . get ( i ) || proj . getResultType ( ) != DataType . BAG ) { lastInputFlattened = false ; break ; } } } catch ( ExecException e ) { int errCode = 2069 ; String msg = " Error ▁ during ▁ map ▁ reduce ▁ compilation . ▁ Problem ▁ in ▁ accessing ▁ column ▁ from ▁ project ▁ operator . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } PhysicalOperator succ = p . getSuccessors ( proj ) != null ? p . getSuccessors ( proj ) . get ( 0 ) : null ; while ( succ != null ) { if ( ! ( succ instanceof POProject ) ) { allSimple = false ; break ; } if ( proj == projOfLastInput && ( ( POProject ) succ ) . getResultType ( ) != DataType . BAG ) { allSimple = false ; break ; } succ = p . getSuccessors ( succ ) != null ? p . getSuccessors ( succ ) . get ( 0 ) : null ; } i ++ ; if ( allSimple == false ) break ; } if ( lastInputFlattened && allSimple && projOfLastInput != null ) { replaceWithPOJoinPackage ( mr . reducePlan , mr , pack , forEach , chunkSize ) ; } } }
rekhajoshm/pig | FindKeyTypeVisitor ( PhysicalPlan plan ) { super ( plan , new DepthFirstWalker < PhysicalOperator , PhysicalPlan > ( plan ) ) ; }
rekhajoshm/pig | @ Override public void visitProject ( POProject p ) throws VisitorException { keyType = p . getResultType ( ) ; }
rekhajoshm/pig | FindStoreNameVisitor ( PhysicalPlan plan , FileSpec newSpec , FileSpec oldSpec ) { super ( plan , new DepthFirstWalker < PhysicalOperator , PhysicalPlan > ( plan ) ) ; this . newSpec = newSpec ; this . oldSpec = oldSpec ; }
rekhajoshm/pig | @ Override public void visitStore ( POStore sto ) throws VisitorException { FileSpec spec = sto . getSFile ( ) ; if ( oldSpec . equals ( spec ) ) { sto . setSFile ( newSpec ) ; } }
18743206721/coolWeather | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . choose_area , container , false ) ; titleText = ( TextView ) view . findViewById ( R . id . title_text ) ; backButton = ( Button ) view . findViewById ( R . id . back_button ) ; listView = ( ListView ) view . findViewById ( R . id . list_view ) ; adapter = new ArrayAdapter < > ( getContext ( ) , android . R . layout . simple_list_item_1 , dataList ) ; listView . setAdapter ( adapter ) ; return view ; }
18743206721/coolWeather | @ Override public void onActivityCreated ( @ Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; listView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { if ( currentLevel == LEVEL_PROVINCE ) { selectedProvince = provinceList . get ( position ) ; queryCities ( ) ; } else if ( currentLevel == LEVEL_CITY ) { selectedCity = cityList . get ( position ) ; queryCounties ( ) ; } else if ( currentLevel == LEVEL_COUNTRY ) { String weatherId = countyList . get ( position ) . getWeatherId ( ) ; Intent intent = new Intent ( getActivity ( ) , WeatherActivity . class ) ; intent . putExtra ( " weather _ id " , weatherId ) ; startActivity ( intent ) ; getActivity ( ) . finish ( ) ; } } } ) ; backButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( currentLevel == LEVEL_COUNTRY ) { queryCities ( ) ; } else if ( currentLevel == LEVEL_CITY ) { queryProvinces ( ) ; } } } ) ; queryProvinces ( ) ; }
18743206721/coolWeather | private void queryProvinces ( ) { titleText . setText ( " 中国 " ) ; backButton . setVisibility ( View . GONE ) ; provinceList = DataSupport . findAll ( Province . class ) ; if ( provinceList . size ( ) > 0 ) { dataList . clear ( ) ; for ( Province province : provinceList ) { dataList . add ( province . getProvinceName ( ) ) ; } adapter . notifyDataSetChanged ( ) ; listView . setSelection ( 0 ) ; currentLevel = LEVEL_PROVINCE ; } else { String address = Contus . PRIVICE_CITY ; queryFromServer ( address , " province " ) ; } }
18743206721/coolWeather | private void queryCities ( ) { titleText . setText ( selectedProvince . getProvinceName ( ) ) ; backButton . setVisibility ( View . VISIBLE ) ; cityList = DataSupport . where ( " provinceid ▁ = ▁ ? " , String . valueOf ( selectedProvince . getId ( ) ) ) . find ( City . class ) ; if ( cityList . size ( ) > 0 ) { dataList . clear ( ) ; for ( City city : cityList ) { dataList . add ( city . getCityname ( ) ) ; } adapter . notifyDataSetChanged ( ) ; listView . setSelection ( 0 ) ; currentLevel = LEVEL_CITY ; } else { int provinceCode = selectedProvince . getProvinceCode ( ) ; String address = Contus . PRIVICE_CITY + " / " + provinceCode ; queryFromServer ( address , " city " ) ; } }
18743206721/coolWeather | private void queryCounties ( ) { titleText . setText ( selectedCity . getCityname ( ) ) ; backButton . setVisibility ( View . VISIBLE ) ; countyList = DataSupport . where ( " cityid = ▁ ? ▁ " , String . valueOf ( selectedCity . getId ( ) ) ) . find ( County . class ) ; if ( countyList . size ( ) > 0 ) { dataList . clear ( ) ; for ( County county : countyList ) { dataList . add ( county . getCountyName ( ) ) ; } adapter . notifyDataSetChanged ( ) ; listView . setSelection ( 0 ) ; currentLevel = LEVEL_COUNTRY ; } else { int provinceCode = selectedProvince . getProvinceCode ( ) ; int cityCode = selectedCity . getCityCode ( ) ; String address = Contus . PRIVICE_CITY + " / " + provinceCode + " / " + cityCode ; Log . e ( " country _ ads " , " queryCounties : ▁ " + address ) ; queryFromServer ( address , " county " ) ; } }
18743206721/coolWeather | private void queryFromServer ( String address , final String type ) { showProgressDialog ( ) ; HttpUtils . sendOkHttpRequest ( address , new Callback ( ) { @ Override public void onFailure ( Call call , IOException e ) { getActivity ( ) . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { closeProgressDialog ( ) ; Toast . makeText ( getContext ( ) , " 加载失败 " , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } @ Override public void onResponse ( Call call , Response response ) throws IOException { String responseText = response . body ( ) . string ( ) ; boolean result = false ; if ( " province " . equals ( type ) ) { result = Utility . handleProvinceResponse ( responseText ) ; } else if ( " city " . equals ( type ) ) { result = Utility . handleCityResponse ( responseText , selectedProvince . getId ( ) ) ; } else if ( " county " . equals ( type ) ) { result = Utility . handleCountryResponse ( responseText , selectedCity . getId ( ) ) ; } if ( result ) { getActivity ( ) . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { closeProgressDialog ( ) ; if ( " province " . equals ( type ) ) { queryProvinces ( ) ; } else if ( " city " . equals ( type ) ) { queryCities ( ) ; } else if ( " county " . equals ( type ) ) { queryCounties ( ) ; } } } ) ; } } } ) ; }
18743206721/coolWeather | @ Override public void onDestroy ( ) { super . onDestroy ( ) ; closeProgressDialog ( ) ; }
18743206721/coolWeather | private void showProgressDialog ( ) { if ( progressDialog == null ) { progressDialog = new ProgressDialog ( getActivity ( ) ) ; progressDialog . setMessage ( " 正在加载 " ) ; progressDialog . setCanceledOnTouchOutside ( false ) ; } progressDialog . show ( ) ; }
18743206721/coolWeather | private void closeProgressDialog ( ) { if ( progressDialog != null ) { progressDialog . dismiss ( ) ; } }
andytaylor/activemq-artemis | @ Override protected SequentialFileFactory getFileFactory ( ) throws Exception { return new NIOSequentialFileFactory ( getTestDirfile ( ) , true , 1 ) ; }
andytaylor/activemq-artemis | @ Test public void testExportImport ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 , 2 ) ; journal . forceMoveNextFile ( ) ; delete ( 1 , 2 ) ; add ( 3 , 4 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 6 , 7 , 8 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 9 ) ; commit ( 5 ) ; journal . forceMoveNextFile ( ) ; deleteTx ( 10 , 6 , 7 , 8 , 9 ) ; commit ( 10 ) ; addTx ( 11 , 11 , 12 ) ; updateTx ( 11 , 11 , 12 ) ; commit ( 11 ) ; journal . forceMoveNextFile ( ) ; update ( 11 , 12 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
andytaylor/activemq-artemis | @ Test public void testExportImport3 ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 , 2 ) ; journal . forceMoveNextFile ( ) ; delete ( 1 , 2 ) ; add ( 3 , 4 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 6 , 7 , 8 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 9 ) ; commit ( 5 ) ; journal . forceMoveNextFile ( ) ; deleteTx ( 10 , 6 , 7 , 8 , 9 ) ; commit ( 10 ) ; addTx ( 11 , 12 , 13 ) ; EncodingSupport xid = new SimpleEncoding ( 10 , ( byte ) 0 ) ; prepare ( 11 , xid ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; commit ( 11 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
andytaylor/activemq-artemis | @ Test public void testExportImport2 ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
crate/crate | public RestoreOnlyRepository ( String indexName ) { this . indexName = indexName ; }
crate/crate | @ Override public RepositoryMetadata getMetadata ( ) { return null ; }
crate/crate | @ Override public void getSnapshotInfo ( SnapshotId snapshotId , ActionListener < SnapshotInfo > listener ) { listener . onResponse ( null ) ; }
crate/crate | @ Override public void getSnapshotGlobalMetadata ( SnapshotId snapshotId , ActionListener < Metadata > listener ) { }
crate/crate | @ Override public void getSnapshotIndexMetadata ( SnapshotId snapshotId , IndexId indexId , ActionListener < IndexMetadata > listener ) throws IOException { }
crate/crate | @ Override public void getSnapshotIndexMetadata ( SnapshotId snapshotId , Collection < IndexId > indexIds , ActionListener < Collection < IndexMetadata > > listener ) { }
crate/crate | @ Override public void getRepositoryData ( ActionListener < RepositoryData > listener ) { final IndexId indexId = new IndexId ( indexName , " blah " ) ; listener . onResponse ( new RepositoryData ( EMPTY_REPO_GEN , Map . of ( ) , Map . of ( ) , Map . of ( ) , Map . of ( indexId , Set . of ( ) ) , ShardGenerations . EMPTY ) ) ; }
crate/crate | @ Override public void finalizeSnapshot ( SnapshotId snapshotId , ShardGenerations shardGenerations , long startTime , String failure , int totalShards , List < SnapshotShardFailure > shardFailures , long repositoryStateId , boolean includeGlobalState , Metadata clusterMetadata , boolean writeShardGens , ActionListener < SnapshotInfo > listener ) { listener . onResponse ( null ) ; }
crate/crate | @ Override public void deleteSnapshot ( SnapshotId snapshotId , long repositoryStateId , boolean writeShardGens , ActionListener < Void > listener ) { }
crate/crate | @ Override public String startVerification ( ) { return null ; }
crate/crate | @ Override public void endVerification ( String verificationToken ) { }
crate/crate | @ Override public void verify ( String verificationToken , DiscoveryNode localNode ) { }
crate/crate | @ Override public boolean isReadOnly ( ) { return false ; }
crate/crate | @ Override public void snapshotShard ( Store store , MapperService mapperService , SnapshotId snapshotId , IndexId indexId , IndexCommit snapshotIndexCommit , IndexShardSnapshotStatus snapshotStatus , boolean writeShardGens , ActionListener < String > listener ) { }
crate/crate | @ Override public void restoreShard ( Store store , SnapshotId snapshotId , IndexId indexId , ShardId snapshotShardId , RecoveryState recoveryState , ActionListener < Void > listener ) { }
crate/crate | @ Override public Lifecycle . State lifecycleState ( ) { return null ; }
crate/crate | @ Override public void addLifecycleListener ( LifecycleListener listener ) { }
crate/crate | @ Override public void removeLifecycleListener ( LifecycleListener listener ) { }
crate/crate | @ Override public void start ( ) { }
crate/crate | @ Override public void stop ( ) { }
crate/crate | @ Override public void close ( ) { }
eayun/ovirt-engine | private EventNotificationEntity ( ApplicationMode applicationMode ) { this . availableInModes = applicationMode . getValue ( ) ; }
eayun/ovirt-engine | public int getValue ( ) { return this . ordinal ( ) ; }
eayun/ovirt-engine | public int getAvailableInModes ( ) { return availableInModes ; }
jprante/elasticsearch-client | GetMappingRequest ( ) { }
jprante/elasticsearch-client | public GetMappingRequest ( String ... indices ) { this . indices = indices ; }
jprante/elasticsearch-client | @ Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( mappingType == null ) { validationException = addValidationError ( " mapping ▁ type ▁ is ▁ missing " , validationException ) ; } return validationException ; }
jprante/elasticsearch-client | public GetMappingRequest indices ( String [ ] indices ) { this . indices = indices ; return this ; }
jprante/elasticsearch-client | public String [ ] indices ( ) { return indices ; }
jprante/elasticsearch-client | public String type ( ) { return mappingType ; }
jprante/elasticsearch-client | public GetMappingRequest type ( String mappingType ) { this . mappingType = mappingType ; return this ; }
jprante/elasticsearch-client | @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; indices = new String [ in . readVInt ( ) ] ; for ( int i = 0 ; i < indices . length ; i ++ ) { indices [ i ] = in . readString ( ) ; } if ( in . readBoolean ( ) ) { mappingType = in . readString ( ) ; } }
jprante/elasticsearch-client | @ Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; if ( indices == null ) { out . writeVInt ( 0 ) ; } else { out . writeVInt ( indices . length ) ; for ( String index : indices ) { out . writeString ( index ) ; } } if ( mappingType == null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeString ( mappingType ) ; } }
HappyRay/azkaban | public SlaAlertAction ( final String id , final SlaOption slaOption , final int execId ) { this . actionId = id ; this . slaOption = slaOption ; this . execId = execId ; this . alerters = ServiceProvider . SERVICE_PROVIDER . getInstance ( AlerterHolder . class ) ; this . executorLoader = ServiceProvider . SERVICE_PROVIDER . getInstance ( ExecutorLoader . class ) ; }
HappyRay/azkaban | @ Override public String getId ( ) { return this . actionId ; }
HappyRay/azkaban | @ Override public String getType ( ) { return type ; }
HappyRay/azkaban | @ Override public TriggerAction fromJson ( final Object obj ) throws Exception { return createFromJson ( obj ) ; }
HappyRay/azkaban | @ Override public Object toJson ( ) { final Map < String , Object > jsonObj = new HashMap < > ( ) ; jsonObj . put ( " actionId " , this . actionId ) ; jsonObj . put ( " type " , type ) ; jsonObj . put ( " slaAction " , this . slaOption . toObject ( ) ) ; jsonObj . put ( " execId " , String . valueOf ( this . execId ) ) ; return jsonObj ; }
HappyRay/azkaban | @ Override public void doAction ( ) throws Exception { logger . info ( " Alerting ▁ on ▁ sla ▁ failure . " ) ; if ( slaOption . hasAlert ( ) ) { final Alerter alerter = this . alerters . get ( SlaOption . ALERT_TYPE_EMAIL ) ; if ( alerter != null ) { try { final ExecutableFlow flow = this . executorLoader . fetchExecutableFlow ( this . execId ) ; alerter . alertOnSla ( this . slaOption , slaOption . createSlaMessage ( flow ) ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; logger . error ( " Failed ▁ to ▁ alert ▁ by ▁ " + SlaOption . ALERT_TYPE_EMAIL ) ; } } else { logger . error ( " Alerter ▁ type ▁ " + SlaOption . ALERT_TYPE_EMAIL + " ▁ doesn ' t ▁ exist . ▁ Failed ▁ to ▁ alert . " ) ; } } }
HappyRay/azkaban | @ Override public void setContext ( final Map < String , Object > context ) { }
HappyRay/azkaban | @ Override public String getDescription ( ) { return type + " ▁ for ▁ " + this . execId + " ▁ with ▁ " + this . slaOption . toString ( ) ; }
AWildridge/mint | public EventHandler ( Class clazz ) { this . clazz = clazz ; }
AWildridge/mint | public Class < ? extends T > getEventClass ( ) { return clazz ; }
gaston8181/uade-ventas | @ Transactional public void altaProducto ( ProductoForm producto ) { Producto p = new Producto ( producto ) ; productoDAO . altaProducto ( p ) ; }
gaston8181/uade-ventas | @ Transactional public void bajaProducto ( Long idBaja ) { Producto producto = new Producto ( idBaja ) ; productoDAO . bajaProducto ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public void modificarProducto ( ProductoForm form ) { Producto producto = new Producto ( form ) ; productoDAO . modificarProducto ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public void modificarStock ( ProductoForm form ) { Producto producto = productoDAO . loadProducto ( form . getId ( ) ) ; producto . agregarStock ( form . getAgregarStock ( ) ) ; productoDAO . modificarProducto ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public List < ProductoForm > consultarProductos ( ProductoForm form ) { List < Producto > productos = productoDAO . listarProductos ( form ) ; List < ProductoForm > productosForm = new ArrayList < ProductoForm > ( ) ; for ( Producto producto : productos ) { ProductoForm aux = crearView ( producto ) ; aux . setDescColor ( producto . getColor ( ) . getDescripcion ( ) ) ; aux . setDescMarca ( producto . getMarca ( ) . getDescripcion ( ) ) ; aux . setDescProducto ( producto . getTipoProducto ( ) . getDescripcion ( ) ) ; aux . setDescTalle ( producto . getTalle ( ) . getDescripcion ( ) ) ; productosForm . add ( aux ) ; } return productosForm ; }
gaston8181/uade-ventas | @ Override public List < ColorForm > getColores ( ) { return comboBusiness . getColores ( ) ; }
gaston8181/uade-ventas | @ Override public List < TalleForm > getTalles ( ) { return comboBusiness . getTalles ( ) ; }
gaston8181/uade-ventas | @ Override public List < TipoProductoForm > getTiposProd ( ) { return comboBusiness . getTiposProd ( ) ; }
gaston8181/uade-ventas | @ Override public List < ProveedorForm > getProveedores ( ) { return comboBusiness . getProveedores ( ) ; }
gaston8181/uade-ventas | @ Override public List < MarcaForm > getMarcas ( ) { return comboBusiness . getMarcas ( ) ; }
gaston8181/uade-ventas | @ Transactional public ProductoForm obtenerProducto ( Long id ) { Producto producto = productoDAO . loadProducto ( id ) ; return crearView ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public List < ProductoForm > listarProductos ( ) { List < Producto > productos = productoDAO . listarProductos ( ) ; List < ProductoForm > productosForm = new ArrayList < ProductoForm > ( ) ; for ( Producto producto : productos ) { ProductoForm aux = crearView ( producto ) ; aux . setDescColor ( producto . getColor ( ) . getDescripcion ( ) ) ; aux . setDescMarca ( producto . getMarca ( ) . getDescripcion ( ) ) ; aux . setDescProducto ( producto . getTipoProducto ( ) . getDescripcion ( ) ) ; aux . setDescTalle ( producto . getTalle ( ) . getDescripcion ( ) ) ; productosForm . add ( aux ) ; } return productosForm ; }
gaston8181/uade-ventas | @ Override public boolean codigoBarrasExiste ( ProductoForm form ) { return productoDAO . codigoBarrasExiste ( form . getId ( ) ) ; }
gaston8181/uade-ventas | private ProductoForm crearView ( Producto producto ) { ProductoForm view = new ProductoForm ( ) ; view . setDatoAdicional ( producto . getDatoAdicional ( ) ) ; view . setId ( producto . getId ( ) ) ; view . setIdColor ( producto . getColor ( ) . getId ( ) ) ; view . setIdMarca ( producto . getMarca ( ) . getId ( ) ) ; view . setIdProveedor ( producto . getProveedor ( ) . getId ( ) ) ; view . setIdTalle ( producto . getTalle ( ) . getId ( ) ) ; view . setIdTipoProducto ( producto . getTipoProducto ( ) . getId ( ) ) ; view . setPrecioCompra ( producto . getPrecioCompra ( ) ) ; view . setPrecioVenta ( producto . getPrecioVenta ( ) ) ; view . setStock ( producto . getStock ( ) ) ; return view ; }
gaston8181/uade-ventas | public void setProductoDAO ( ProductoDAO productoDAO ) { this . productoDAO = productoDAO ; }
gaston8181/uade-ventas | public void setComboBusiness ( CombosBusiness comboBusiness ) { this . comboBusiness = comboBusiness ; }
googleapis/google-api-java-client-services | public GoogleCloudDocumentaiUiv1beta3CommonOperationMetadata getCommonMetadata ( ) { return commonMetadata ; }
googleapis/google-api-java-client-services | public GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata setCommonMetadata ( GoogleCloudDocumentaiUiv1beta3CommonOperationMetadata commonMetadata ) { this . commonMetadata = commonMetadata ; return this ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata set ( String fieldName , Object value ) { return ( GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata clone ( ) { return ( GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata ) super . clone ( ) ; }
CSCSI/Triana | public HelpAction ( ToolSelectionHandler selhandler ) { this . selectionHandler = selhandler ; putValue ( SHORT_DESCRIPTION , Env . getString ( " Help " ) ) ; putValue ( ACTION_COMMAND_KEY , Env . getString ( " Help " ) ) ; putValue ( SMALL_ICON , GUIEnv . getIcon ( " help . png " ) ) ; putValue ( NAME , Env . getString ( " Help " ) ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( " F1" ) ) ; }
CSCSI/Triana | public void actionPerformed ( ActionEvent e ) { Tool tool = null ; if ( selectionHandler . isSingleSelectedTool ( ) ) { tool = selectionHandler . getSelectedTool ( ) ; } if ( tool != null ) { showHelp ( tool ) ; } else { GUIEnv . getApplicationFrame ( ) . showHelp ( ) ; } }
CSCSI/Triana | public void showHelp ( Tool tool ) { String helpfile = ToolTableUtils . getUnitHelpFilePath ( tool ) ; GUIEnv . openURL ( helpfile ) ; }
EMResearch/EMB | public AutocompleteService ( UrlGenerator autoCompleteUrlFor , TimbuctooActions timbuctooActions ) { this . timbuctooActions = timbuctooActions ; this . autoCompleteUrlFor = autoCompleteUrlFor ; }
EMResearch/EMB | public JsonNode search ( String collectionName , Optional < String > query , Optional < String > keywordType ) throws InvalidCollectionException { final Collection collection = timbuctooActions . getCollectionMetadata ( collectionName ) ; int limit = query . isPresent ( ) ? 50 : 1000 ; String queryString = query . orElse ( null ) ; QuickSearch quickSearch = QuickSearch . fromQueryString ( queryString ) ; List < QuickSearchResult > results = timbuctooActions . doQuickSearch ( collection , quickSearch , keywordType . orElse ( null ) , limit ) ; return jsnA ( results . stream ( ) . map ( entity -> jsnO ( " value " , jsn ( entity . getIndexedValue ( ) ) , " key " , jsn ( autoCompleteUrlFor . apply ( collectionName , entity . getId ( ) , entity . getRev ( ) ) . toString ( ) ) ) ) ) ; }
EMResearch/EMB | public AutocompleteServiceFactory ( UrlGenerator autoCompleteUri ) { this . autoCompleteUri = autoCompleteUri ; }
EMResearch/EMB | public AutocompleteService create ( TimbuctooActions timbuctooActions ) { return new AutocompleteService ( autoCompleteUri , timbuctooActions ) ; }
marszczybrew/Diorite | @ Override public int compare ( final String s1 , final String s2 ) { return compareStatic ( s1 , s2 ) ; }
OpenBEL/rest-api | @ Get ( " json " ) public Representation _get ( ) { String function = getAttribute ( " function " ) ; FunctionEnum f = fromString ( function ) ; if ( f == null ) { setStatus ( Status . CLIENT_ERROR_NOT_FOUND ) ; return null ; } String name = f . getDisplayValue ( ) ; String abbrev = f . getAbbreviation ( ) ; Objects . Function objf = new Objects . Function ( name , abbrev ) ; objf . put ( " description " , description ( f ) ) ; String path = declaredPath ( Objects . Functions . class ) ; objf . addLink ( " self " , urlify ( path , function ) ) ; path = declaredPath ( Objects . Signatures . class ) ; objf . addLink ( " related " , urlify ( path , function ) ) ; FunctionsRoot . linkResource ( objf ) ; return objf . json ( ) ; }
maxcom/lorsource | @ Autowired public void setDateSource ( DataSource ds ) { jdbcTemplate = new JdbcTemplate ( ds ) ; }
maxcom/lorsource | @ Cacheable ( " Groups " ) public Group getGroup ( int id ) throws GroupNotFoundException { try { return jdbcTemplate . queryForObject ( " SELECT ▁ sections . moderate , ▁ vote , ▁ section , ▁ havelink , ▁ linktext , ▁ title , ▁ urlname , ▁ image , ▁ groups . restrict _ topics , ▁ restrict _ comments , stat3 , groups . id , ▁ groups . info , ▁ groups . longinfo , ▁ groups . resolvable ▁ FROM ▁ groups , ▁ sections ▁ WHERE ▁ groups . id = ? ▁ AND ▁ groups . section = sections . id " , ( resultSet , i ) -> Group . buildGroup ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException ex ) { throw new GroupNotFoundException ( " Группа ▁ " + id + " ▁ не ▁ существует " , ex ) ; } }
maxcom/lorsource | public List < Group > getGroups ( Section section ) { return jdbcTemplate . query ( " SELECT ▁ sections . moderate , ▁ vote , ▁ section , ▁ havelink , ▁ linktext , ▁ title , ▁ urlname , ▁ image , ▁ groups . restrict _ topics , ▁ restrict _ comments , ▁ stat3 , groups . id , groups . info , groups . longinfo , groups . resolvable ▁ FROM ▁ groups , ▁ sections ▁ WHERE ▁ sections . id = ? ▁ AND ▁ groups . section = sections . id ▁ ORDER ▁ BY ▁ id " , ( rs , rowNum ) -> Group . buildGroup ( rs ) , section . getId ( ) ) ; }
maxcom/lorsource | @ Nonnull public Group getGroup ( Section section , String name ) throws GroupNotFoundException { Optional < Group > group = getGroupOpt ( section , name , false ) ; if ( group . isEmpty ( ) ) { logger . info ( " Group ▁ ' { } ' ▁ not ▁ found ▁ in ▁ section ▁ { } " , name , section . getUrlName ( ) ) ; throw new GroupNotFoundException ( " group ▁ not ▁ found " ) ; } else { return group . get ( ) ; } }
maxcom/lorsource | public Optional < Group > getGroupOpt ( Section section , String name , Boolean allowNumber ) { try { if ( allowNumber && StringUtils . isNumeric ( name ) ) { int id = jdbcTemplate . queryForObject ( " SELECT ▁ id ▁ FROM ▁ groups ▁ WHERE ▁ section = ? ▁ AND ▁ id = ? " , Integer . class , section . getId ( ) , Integer . parseInt ( name ) ) ; return Optional . of ( getGroup ( id ) ) ; } else if ( StringUtils . isAsciiPrintable ( name ) ) { int id = jdbcTemplate . queryForObject ( " SELECT ▁ id ▁ FROM ▁ groups ▁ WHERE ▁ section = ? ▁ AND ▁ urlname = ? " , Integer . class , section . getId ( ) , name ) ; return Optional . of ( getGroup ( id ) ) ; } else { return Optional . empty ( ) ; } } catch ( EmptyResultDataAccessException ex ) { logger . debug ( " Group ▁ ' { } ' ▁ not ▁ found ▁ in ▁ section ▁ { } " , name , section . getUrlName ( ) ) ; return Optional . empty ( ) ; } }
maxcom/lorsource | @ CacheEvict ( value = " Groups " , key = " # group . id " ) public void setParams ( final Group group , final String title , final String info , final String longInfo , final boolean resolvable , final String urlName ) { jdbcTemplate . execute ( " UPDATE ▁ groups ▁ SET ▁ title = ? , ▁ info = ? , ▁ longinfo = ? , resolvable = ? , urlname = ? ▁ WHERE ▁ id = ? " , ( PreparedStatement pst ) -> { pst . setString ( 1 , title ) ; if ( ! info . isEmpty ( ) ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( ! longInfo . isEmpty ( ) ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; }
deroneriksson/incubator-systemml | @ Override public void selectPlans ( CPlanMemoTable memo , ArrayList < Hop > roots ) { Collection < PlanPartition > parts = PlanAnalyzer . analyzePlanPartitions ( memo , roots , true ) ; int sumMatPoints = 0 ; for ( PlanPartition part : parts ) { createAndAddMultiAggPlans ( memo , part . getPartition ( ) , part . getRoots ( ) ) ; selectPlans ( memo , part ) ; sumMatPoints += part . getMatPointsExt ( ) . length ; } createAndAddMultiAggPlans ( memo , roots ) ; for ( Entry < Long , List < MemoTableEntry > > e : getBestPlans ( ) . entrySet ( ) ) memo . setDistinct ( e . getKey ( ) , e . getValue ( ) ) ; if ( ConfigurationManager . isStatistics ( ) ) { if ( sumMatPoints >= 63 ) LOG . warn ( " Long ▁ overflow ▁ on ▁ maintaining ▁ codegen ▁ statistics ▁ " + " for ▁ a ▁ DAG ▁ with ▁ " + sumMatPoints + " ▁ interesting ▁ points . " ) ; Statistics . incrementCodegenEnumAll ( UtilFunctions . pow ( 2 , sumMatPoints ) ) ; } }
deroneriksson/incubator-systemml | private void selectPlans ( CPlanMemoTable memo , PlanPartition part ) { pruneInvalidAndSpecialCasePlans ( memo , part ) ; if ( part . getMatPointsExt ( ) == null || part . getMatPointsExt ( ) . length == 0 ) { for ( Long hopID : part . getRoots ( ) ) rSelectPlansFuseAll ( memo , memo . getHopRefs ( ) . get ( hopID ) , null , part . getPartition ( ) ) ; } else { HashMap < Long , Double > computeCosts = new HashMap < > ( ) ; for ( Long hopID : part . getPartition ( ) ) getComputeCosts ( memo . getHopRefs ( ) . get ( hopID ) , computeCosts ) ; StaticCosts costs = new StaticCosts ( computeCosts , sumComputeCost ( computeCosts ) , getReadCost ( part , memo ) , getWriteCost ( part . getRoots ( ) , memo ) , minOuterSparsity ( part , memo ) ) ; ReachabilityGraph rgraph = STRUCTURAL_PRUNING ? new ReachabilityGraph ( part , memo ) : null ; if ( STRUCTURAL_PRUNING ) { part . setMatPointsExt ( rgraph . getSortedSearchSpace ( ) ) ; for ( Long hopID : part . getPartition ( ) ) memo . pruneRedundant ( hopID , true , part . getMatPointsExt ( ) ) ; } boolean [ ] bestPlan = enumPlans ( memo , part , costs , rgraph , part . getMatPointsExt ( ) , 0 ) ; HashSet < Long > visited = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) rPruneSuboptimalPlans ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited , part , part . getMatPointsExt ( ) , bestPlan ) ; HashSet < Long > visited2 = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) rPruneInvalidPlans ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited2 , part , bestPlan ) ; for ( Long hopID : part . getRoots ( ) ) rSelectPlansFuseAll ( memo , memo . getHopRefs ( ) . get ( hopID ) , null , part . getPartition ( ) ) ; } }
deroneriksson/incubator-systemml | private boolean [ ] enumPlans ( CPlanMemoTable memo , PlanPartition part , StaticCosts costs , ReachabilityGraph rgraph , InterestingPoint [ ] matPoints , int off ) { final int Mlen = matPoints . length - off ; final long len = UtilFunctions . pow ( 2 , Mlen ) ; long numEvalPlans = 2 , numEvalPartPlans = 0 ; final boolean [ ] plan0 = createAssignment ( Mlen , off , 0 ) ; final boolean [ ] planN = createAssignment ( Mlen , off , len - 1 ) ; final double C0 = getPlanCost ( memo , part , matPoints , plan0 , costs . _computeCosts , Double . MAX_VALUE ) ; final double CN = getPlanCost ( memo , part , matPoints , planN , costs . _computeCosts , Double . MAX_VALUE ) ; boolean [ ] bestPlan = ( C0 <= CN ) ? plan0 : planN ; double bestC = Math . min ( C0 , CN ) ; final boolean evalRemain = ( Mlen < COST_MIN_EPS_NUM_POINTS || ! COST_PRUNING || bestC > ( 1 + COST_MIN_EPS ) * costs . getMinCosts ( ) ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum ▁ opening : ▁ " + Arrays . toString ( bestPlan ) + " ▁ - > ▁ " + bestC ) ; if ( ! evalRemain ) LOG . warn ( " Skip ▁ enum ▁ for ▁ | M | = " + Mlen + " , ▁ C = " + bestC + " , ▁ Cmin = " + costs . getMinCosts ( ) ) ; PartitionSignature pKey = null ; if ( probePlanCache ( matPoints ) ) { pKey = new PartitionSignature ( part , matPoints . length , costs , C0 , CN ) ; boolean [ ] plan = getPlan ( pKey ) ; if ( plan != null ) { Statistics . incrementCodegenEnumAllP ( ( rgraph != null || ! STRUCTURAL_PRUNING ) ? len : 0 ) ; return plan ; } } for ( long i = 1 ; i < len - 1 & evalRemain ; i ++ ) { boolean [ ] plan = createAssignment ( Mlen , off , i ) ; long pskip = 0 ; if ( STRUCTURAL_PRUNING && ( rgraph != null ) && rgraph . isCutSet ( plan ) ) { pskip = rgraph . getNumSkipPlans ( plan ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Structural ▁ pruning ▁ for ▁ cut ▁ set : ▁ " + rgraph . getCutSet ( plan ) ) ; SubProblem [ ] prob = rgraph . getSubproblems ( plan ) ; for ( int j = 0 ; j < prob . length ; j ++ ) { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Subproblem ▁ " + ( j + 1 ) + " / " + prob . length + " : ▁ " + prob [ j ] ) ; boolean [ ] bestTmp = enumPlans ( memo , part , costs , null , prob [ j ] . freeMat , prob [ j ] . offset ) ; LibSpoofPrimitives . vectWrite ( bestTmp , plan , prob [ j ] . freePos ) ; } } else if ( COST_PRUNING ) { double lbC = getLowerBoundCosts ( part , matPoints , memo , costs , plan ) ; if ( lbC >= bestC ) { long skip = getNumSkipPlans ( plan ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Skip ▁ " + skip + " ▁ plans ▁ ( by ▁ cost ) . " ) ; i += skip - 1 ; continue ; } } double pCBound = COST_PRUNING ? bestC : Double . MAX_VALUE ; double C = getPlanCost ( memo , part , matPoints , plan , costs . _computeCosts , pCBound ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ " + Arrays . toString ( plan ) + " ▁ - > ▁ " + C ) ; numEvalPartPlans += ( C == Double . POSITIVE_INFINITY ) ? 1 : 0 ; numEvalPlans ++ ; if ( bestPlan == null || C < bestC ) { bestC = C ; bestPlan = plan ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Found ▁ new ▁ best ▁ plan . " ) ; } i += pskip ; if ( pskip != 0 && LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Skip ▁ " + pskip + " ▁ plans ▁ ( by ▁ structure ) . " ) ; } if ( ConfigurationManager . isStatistics ( ) ) { Statistics . incrementCodegenEnumAllP ( ( rgraph != null || ! STRUCTURAL_PRUNING ) ? len : 0 ) ; Statistics . incrementCodegenEnumEval ( numEvalPlans ) ; Statistics . incrementCodegenEnumEvalP ( numEvalPartPlans ) ; } if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Optimal ▁ plan : ▁ " + Arrays . toString ( bestPlan ) ) ; if ( probePlanCache ( matPoints ) ) putPlan ( pKey , bestPlan ) ; return ( bestPlan == null ) ? new boolean [ Mlen ] : Arrays . copyOfRange ( bestPlan , off , bestPlan . length ) ; }
deroneriksson/incubator-systemml | private void createAndAddMultiAggPlans ( CPlanMemoTable memo , ArrayList < Hop > roots ) { HashSet < Long > fullAggs = new HashSet < > ( ) ; Hop . resetVisitStatus ( roots ) ; for ( Hop hop : roots ) rCollectFullAggregates ( hop , fullAggs ) ; Hop . resetVisitStatus ( roots ) ; fullAggs . removeIf ( p -> memo . contains ( p , TemplateType . MAGG ) ) ; if ( fullAggs . size ( ) <= 1 ) return ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Found ▁ across - partition ▁ ua ( RC ) ▁ aggregations : ▁ " + Arrays . toString ( fullAggs . toArray ( new Long [ 0 ] ) ) ) ; } List < AggregateInfo > aggInfos = new ArrayList < > ( ) ; for ( Long hopID : fullAggs ) { Hop aggHop = memo . getHopRefs ( ) . get ( hopID ) ; AggregateInfo tmp = new AggregateInfo ( aggHop ) ; for ( int i = 0 ; i < aggHop . getInput ( ) . size ( ) ; i ++ ) { Hop c = HopRewriteUtils . isMatrixMultiply ( aggHop ) && i == 0 ? aggHop . getInput ( ) . get ( 0 ) . getInput ( ) . get ( 0 ) : aggHop . getInput ( ) . get ( i ) ; rExtractAggregateInfo ( memo , c , tmp , TemplateType . CELL ) ; } if ( tmp . _fusedInputs . isEmpty ( ) ) { if ( HopRewriteUtils . isMatrixMultiply ( aggHop ) ) { tmp . addFusedInput ( aggHop . getInput ( ) . get ( 0 ) . getInput ( ) . get ( 0 ) . getHopID ( ) ) ; tmp . addFusedInput ( aggHop . getInput ( ) . get ( 1 ) . getHopID ( ) ) ; } else tmp . addFusedInput ( aggHop . getInput ( ) . get ( 0 ) . getHopID ( ) ) ; } aggInfos . add ( tmp ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Extracted ▁ across - partition ▁ ua ( RC ) ▁ aggregation ▁ info : ▁ " ) ; for ( AggregateInfo info : aggInfos ) LOG . trace ( info ) ; } aggInfos = aggInfos . stream ( ) . sorted ( Comparator . comparing ( a -> a . _inputAggs . size ( ) ) ) . collect ( Collectors . toList ( ) ) ; boolean converged = false ; while ( ! converged ) { AggregateInfo merged = null ; for ( int i = 0 ; i < aggInfos . size ( ) ; i ++ ) { AggregateInfo current = aggInfos . get ( i ) ; for ( int j = i + 1 ; j < aggInfos . size ( ) ; j ++ ) { AggregateInfo that = aggInfos . get ( j ) ; if ( current . isMergable ( that ) ) { merged = current . merge ( that ) ; aggInfos . remove ( j ) ; j -- ; } } } converged = ( merged == null ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Merged ▁ across - partition ▁ ua ( RC ) ▁ aggregation ▁ info : ▁ " ) ; for ( AggregateInfo info : aggInfos ) LOG . trace ( info ) ; } for ( AggregateInfo info : aggInfos ) { if ( info . _aggregates . size ( ) <= 1 ) continue ; Long [ ] aggs = info . _aggregates . keySet ( ) . toArray ( new Long [ 0 ] ) ; MemoTableEntry me = new MemoTableEntry ( TemplateType . MAGG , aggs [ 0 ] , aggs [ 1 ] , ( aggs . length > 2 ) ? aggs [ 2 ] : - 1 , aggs . length ) ; for ( int i = 0 ; i < aggs . length ; i ++ ) { memo . add ( memo . getHopRefs ( ) . get ( aggs [ i ] ) , me ) ; addBestPlan ( aggs [ i ] , me ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Added ▁ multiagg * ▁ plan : ▁ " + aggs [ i ] + " ▁ " + me ) ; } } }
deroneriksson/incubator-systemml | private double getPlanCost ( CPlanMemoTable memo , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan , HashMap < Long , Double > computeCosts , final double costBound ) { HashSet < VisitMarkCost > visited = new HashSet < > ( ) ; double costs = 0 ; int rem = part . getRoots ( ) . size ( ) ; for ( Long hopID : part . getRoots ( ) ) { costs += rGetPlanCosts ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; if ( costs >= costBound && -- rem > 0 ) return Double . POSITIVE_INFINITY ; } return costs ; }
deroneriksson/incubator-systemml | private double rGetPlanCosts ( CPlanMemoTable memo , final Hop current , HashSet < VisitMarkCost > visited , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan , HashMap < Long , Double > computeCosts , CostVector costsCurrent , TemplateType currentType , final double costBound ) { final long currentHopId = current . getHopID ( ) ; if ( ! visited . add ( new VisitMarkCost ( currentHopId , ( costsCurrent == null || currentType == TemplateType . MAGG ) ? - 1 : costsCurrent . ID ) ) ) return 0 ; MemoTableEntry best = null ; boolean opened = ( currentType == null ) ; if ( memo . contains ( currentHopId ) ) { if ( currentType == null ) { for ( MemoTableEntry me : memo . get ( currentHopId ) ) best = me . isValid ( ) && hasNoRefToMatPoint ( currentHopId , me , matPoints , plan ) && BasicPlanComparator . icompare ( me , best ) < 0 ? me : best ; opened = true ; } else { for ( MemoTableEntry me : memo . get ( currentHopId ) ) best = ( me . type == currentType || me . type == TemplateType . CELL ) && hasNoRefToMatPoint ( currentHopId , me , matPoints , plan ) && TypedPlanComparator . icompare ( me , best , currentType ) < 0 ? me : best ; } } CostVector costVect = ! opened ? costsCurrent : new CostVector ( getSize ( current ) ) ; double costs = 0 ; if ( opened && best != null && best . type == TemplateType . MAGG ) { if ( best . input1 == currentHopId ) for ( int i = 1 ; i < 3 ; i ++ ) { if ( ! best . isPlanRef ( i ) ) continue ; costs += rGetPlanCosts ( memo , memo . getHopRefs ( ) . get ( best . input ( i ) ) , visited , part , matPoints , plan , computeCosts , costVect , TemplateType . MAGG , costBound - costs ) ; if ( costs >= costBound ) return Double . POSITIVE_INFINITY ; } else return 0 ; } if ( computeCosts . containsKey ( currentHopId ) ) costVect . computeCosts += computeCosts . get ( currentHopId ) ; for ( int i = 0 ; i < current . getInput ( ) . size ( ) ; i ++ ) { Hop c = current . getInput ( ) . get ( i ) ; if ( best != null && best . isPlanRef ( i ) ) costs += rGetPlanCosts ( memo , c , visited , part , matPoints , plan , computeCosts , costVect , best . type , costBound - costs ) ; else if ( best != null && isImplicitlyFused ( current , i , best . type ) ) costVect . addInputSize ( c . getInput ( ) . get ( 0 ) . getHopID ( ) , getSize ( c ) ) ; else { if ( part . getPartition ( ) . contains ( c . getHopID ( ) ) ) costs += rGetPlanCosts ( memo , c , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; if ( costVect != null && c . getDataType ( ) . isMatrix ( ) ) costVect . addInputSize ( c . getHopID ( ) , getSize ( c ) ) ; } if ( costs >= costBound ) return Double . POSITIVE_INFINITY ; } if ( opened ) { double memInputs = sumInputMemoryEstimates ( memo , costVect ) ; double tmpCosts = costVect . outSize * 8 / WRITE_BANDWIDTH_MEM + Math . max ( memInputs / READ_BANDWIDTH_MEM , costVect . computeCosts / COMPUTE_BANDWIDTH ) ; if ( memInputs > OptimizerUtils . getLocalMemBudget ( ) ) tmpCosts += costVect . getSideInputSize ( ) * 8 / READ_BANDWIDTH_BROADCAST ; Hop driver = memo . getHopRefs ( ) . get ( costVect . getMaxInputSizeHopID ( ) ) ; if ( best != null && best . type == TemplateType . OUTER ) tmpCosts *= driver . dimsKnown ( true ) ? driver . getSparsity ( ) : SPARSE_SAFE_SPARSITY_EST ; else if ( memInputs <= OptimizerUtils . getLocalMemBudget ( ) && sumTmpInputOutputSize ( memo , costVect ) * 8 > LazyWriteBuffer . getWriteBufferLimit ( ) ) tmpCosts += costVect . outSize * 8 / WRITE_BANDWIDTH_IO ; costs += tmpCosts ; if ( LOG . isTraceEnabled ( ) ) { String type = ( best != null ) ? best . type . name ( ) : " HOP " ; LOG . trace ( " Cost ▁ vector ▁ ( " + type + " ▁ " + currentHopId + " ) : ▁ " + costVect + " ▁ - > ▁ " + tmpCosts ) ; } } else if ( part . getExtConsumed ( ) . contains ( current . getHopID ( ) ) ) { costs += rGetPlanCosts ( memo , current , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; } if ( costs < 0 || Double . isNaN ( costs ) || Double . isInfinite ( costs ) ) throw new RuntimeException ( " Wrong ▁ cost ▁ estimate : ▁ " + costs ) ; return costs ; }
deroneriksson/incubator-systemml | public CostVector ( double outputSize ) { ID = COST_ID . getNextID ( ) ; outSize = outputSize ; }
deroneriksson/incubator-systemml | public void addInputSize ( long hopID , double inputSize ) { inSizes . put ( hopID , inputSize ) ; }
deroneriksson/incubator-systemml | public double getInputSize ( ) { return inSizes . values ( ) . stream ( ) . mapToDouble ( d -> d . doubleValue ( ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | public double getSideInputSize ( ) { double max = getMaxInputSize ( ) ; return inSizes . values ( ) . stream ( ) . filter ( d -> d < max ) . mapToDouble ( d -> d . doubleValue ( ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | public double getMaxInputSize ( ) { return inSizes . values ( ) . stream ( ) . mapToDouble ( d -> d . doubleValue ( ) ) . max ( ) . orElse ( 0 ) ; }
deroneriksson/incubator-systemml | public long getMaxInputSizeHopID ( ) { long id = - 1 ; double max = 0 ; for ( Entry < Long , Double > e : inSizes . entrySet ( ) ) if ( max < e . getValue ( ) ) { id = e . getKey ( ) ; max = e . getValue ( ) ; } return id ; }
deroneriksson/incubator-systemml | @ Override public String toString ( ) { return " [ " + outSize + " , ▁ " + computeCosts + " , ▁ { " + Arrays . toString ( inSizes . keySet ( ) . toArray ( new Long [ 0 ] ) ) + " , ▁ " + Arrays . toString ( inSizes . values ( ) . toArray ( new Double [ 0 ] ) ) + " } ] " ; }
deroneriksson/incubator-systemml | public StaticCosts ( HashMap < Long , Double > allComputeCosts , double computeCost , double readCost , double writeCost , double minSparsity ) { _computeCosts = allComputeCosts ; _compute = computeCost ; _read = readCost ; _write = writeCost ; _minSparsity = minSparsity ; }
deroneriksson/incubator-systemml | public double getMinCosts ( ) { return Math . max ( _read , _compute ) + _write ; }
deroneriksson/incubator-systemml | public AggregateInfo ( Hop aggregate ) { _aggregates = new HashMap < > ( ) ; _aggregates . put ( aggregate . getHopID ( ) , aggregate ) ; }
deroneriksson/incubator-systemml | public void addInputAggregate ( long hopID ) { _inputAggs . add ( hopID ) ; }
deroneriksson/incubator-systemml | public void addFusedInput ( long hopID ) { _fusedInputs . add ( hopID ) ; }
deroneriksson/incubator-systemml | public boolean isMergable ( AggregateInfo that ) { boolean ret = _aggregates . size ( ) < 3 && _aggregates . size ( ) + that . _aggregates . size ( ) <= 3 ; for ( Long hopID : that . _aggregates . keySet ( ) ) ret &= ! _inputAggs . contains ( hopID ) ; for ( Long hopID : _aggregates . keySet ( ) ) ret &= ! that . _inputAggs . contains ( hopID ) ; ret &= ! CollectionUtils . intersection ( _fusedInputs , that . _fusedInputs ) . isEmpty ( ) ; Hop in1 = _aggregates . values ( ) . iterator ( ) . next ( ) ; Hop in2 = that . _aggregates . values ( ) . iterator ( ) . next ( ) ; return ret && HopRewriteUtils . isEqualSize ( in1 . getInput ( ) . get ( HopRewriteUtils . isMatrixMultiply ( in1 ) ? 1 : 0 ) , in2 . getInput ( ) . get ( HopRewriteUtils . isMatrixMultiply ( in2 ) ? 1 : 0 ) ) ; }
deroneriksson/incubator-systemml | public AggregateInfo merge ( AggregateInfo that ) { _aggregates . putAll ( that . _aggregates ) ; _inputAggs . addAll ( that . _inputAggs ) ; _fusedInputs . addAll ( that . _fusedInputs ) ; return this ; }
deroneriksson/incubator-systemml | @ Override public String toString ( ) { return " [ " + Arrays . toString ( _aggregates . keySet ( ) . toArray ( new Long [ 0 ] ) ) + " : ▁ " + " { " + Arrays . toString ( _inputAggs . toArray ( new Long [ 0 ] ) ) + " } , " + " { " + Arrays . toString ( _fusedInputs . toArray ( new Long [ 0 ] ) ) + " } ] " ; }
deroneriksson/incubator-systemml | public PartitionSignature ( PlanPartition part , int M , StaticCosts costs , double cP0 , double cPN ) { partNodes = part . getPartition ( ) . size ( ) ; inputNodes = part . getInputs ( ) . size ( ) ; rootNodes = part . getRoots ( ) . size ( ) ; matPoints = M ; cCompute = costs . _compute ; cRead = costs . _read ; cWrite = costs . _write ; cPlan0 = cP0 ; cPlanN = cPN ; }
deroneriksson/incubator-systemml | @ Override public int hashCode ( ) { return UtilFunctions . intHashCode ( Arrays . hashCode ( new int [ ] { partNodes , inputNodes , rootNodes , matPoints } ) , Arrays . hashCode ( new double [ ] { cCompute , cRead , cWrite , cPlan0 , cPlanN } ) ) ; }
deroneriksson/incubator-systemml | @ Override public boolean equals ( Object o ) { if ( ! ( o instanceof PartitionSignature ) ) return false ; PartitionSignature that = ( PartitionSignature ) o ; return partNodes == that . partNodes && inputNodes == that . inputNodes && rootNodes == that . rootNodes && matPoints == that . matPoints && cCompute == that . cCompute && cRead == that . cRead && cWrite == that . cWrite && cPlan0 == that . cPlan0 && cPlanN == that . cPlanN ; }
iavanish/CollegePal | public NewResource ( ) { }
iavanish/CollegePal | public void makeNotes ( ) { }
iavanish/CollegePal | public void takeSnapshot ( ) { }
iavanish/CollegePal | public void uploadResource ( ) { }
iavanish/CollegePal | public void makePublic ( ) { }
iavanish/CollegePal | public void makePrivate ( ) { }
iavanish/CollegePal | public void updateDetails ( ) { }
demonyan/douban-movie | public RecommendMovieAdapter ( RecyclerView view , Collection < SimpleSubjectBean > datas ) { super ( view , datas , R . layout . item_simple_movie_layout ) ; setOnItemClickListener ( ( View v , Object data , int position ) -> { if ( mCallback != null ) { SimpleSubjectBean bean = ( SimpleSubjectBean ) data ; String url = ImageUtil . getDisplayImage ( mContext , bean . images ) ; mCallback . onItemClick ( bean . id , url , true ) ; } } ) ; }
demonyan/douban-movie | public void setOnItemClickListener ( OnItemClickListener listener ) { mCallback = listener ; }
demonyan/douban-movie | public void update ( List < SimpleSubjectBean > data ) { super . update ( data ) ; }
demonyan/douban-movie | @ Override public void convert ( BaseRecyclerHolder holder , SimpleSubjectBean item , int position , boolean isScrolling ) { holder . setText ( R . id . tv_item_simple_movie_text , item . title ) ; holder . setImageFromEntity ( R . id . iv_item_simple_movie_image , item . images ) ; }
rokn/Count_Words_2015 | public DOMSource ( ) { }
rokn/Count_Words_2015 | public DOMSource ( Node n ) { setNode ( n ) ; }
rokn/Count_Words_2015 | public DOMSource ( Node node , String systemID ) { setNode ( node ) ; setSystemId ( systemID ) ; }
rokn/Count_Words_2015 | public void setNode ( Node node ) { this . node = node ; }
rokn/Count_Words_2015 | public Node getNode ( ) { return node ; }
rokn/Count_Words_2015 | public void setSystemId ( String systemID ) { this . systemID = systemID ; }
rokn/Count_Words_2015 | public String getSystemId ( ) { return this . systemID ; }
Lexine/rootbeer1 | public StringArrayTest1RunOnGpu ( String [ ] src , String [ ] dst , int i ) { m_source = src ; m_ret = dst ; m_index = i ; }
Lexine/rootbeer1 | public void gpuMethod ( ) { String str = " york " ; for ( int i = 0 ; i < m_source . length ; ++ i ) { str = m_source [ i ] + str ; } m_ret [ m_index ] = str ; }
Lexine/rootbeer1 | public String [ ] getResult ( ) { return m_ret ; }
oehme/analysing-gradle-performance | @ Test public void testProperty0 ( ) { String value = " value " ; objectUnderTest . setProperty0 ( value ) ; assertEquals ( value , objectUnderTest . getProperty0 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty1 ( ) { String value = " value " ; objectUnderTest . setProperty1 ( value ) ; assertEquals ( value , objectUnderTest . getProperty1 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty2 ( ) { String value = " value " ; objectUnderTest . setProperty2 ( value ) ; assertEquals ( value , objectUnderTest . getProperty2 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty3 ( ) { String value = " value " ; objectUnderTest . setProperty3 ( value ) ; assertEquals ( value , objectUnderTest . getProperty3 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty4 ( ) { String value = " value " ; objectUnderTest . setProperty4 ( value ) ; assertEquals ( value , objectUnderTest . getProperty4 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty5 ( ) { String value = " value " ; objectUnderTest . setProperty5 ( value ) ; assertEquals ( value , objectUnderTest . getProperty5 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty6 ( ) { String value = " value " ; objectUnderTest . setProperty6 ( value ) ; assertEquals ( value , objectUnderTest . getProperty6 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty7 ( ) { String value = " value " ; objectUnderTest . setProperty7 ( value ) ; assertEquals ( value , objectUnderTest . getProperty7 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty8 ( ) { String value = " value " ; objectUnderTest . setProperty8 ( value ) ; assertEquals ( value , objectUnderTest . getProperty8 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty9 ( ) { String value = " value " ; objectUnderTest . setProperty9 ( value ) ; assertEquals ( value , objectUnderTest . getProperty9 ( ) ) ; }
congwiny/mysticker | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_sticker ) ; FrameLayout frameLayout = ( FrameLayout ) findViewById ( R . id . sticker_container ) ; mStickerContainer = new EditStickerContainer ( this ) ; frameLayout . addView ( mStickerContainer ) ; }
congwiny/mysticker | @ Override public void onBackPressed ( ) { super . onBackPressed ( ) ; Log . e ( TAG , " onBackPressed " ) ; }
congwiny/mysticker | @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { if ( mStickerContainer . onBackPressed ( ) ) { return true ; } else { return super . onKeyDown ( keyCode , event ) ; } } return super . onKeyDown ( keyCode , event ) ; }
CyberdyneOfCerrado/Pechincha | public Lance ( ) { }
CyberdyneOfCerrado/Pechincha | public Lance ( int idleilao , int idusuario , float lance ) { this . idleilao = idleilao ; this . idusuario = idusuario ; this . lance = lance ; }
CyberdyneOfCerrado/Pechincha | public int getPk ( ) { return this . pk ; }
CyberdyneOfCerrado/Pechincha | public int getIdLeilao ( ) { return this . idleilao ; }
CyberdyneOfCerrado/Pechincha | public int getIdUsuario ( ) { return this . idusuario ; }
CyberdyneOfCerrado/Pechincha | public float getLance ( ) { return this . lance ; }
CyberdyneOfCerrado/Pechincha | public void setPk ( int pk ) { this . pk = pk ; }
CyberdyneOfCerrado/Pechincha | public void setIdLeilao ( int idleilao ) { this . idleilao = idleilao ; }
CyberdyneOfCerrado/Pechincha | public void setIdusuario ( int idusuario ) { this . idusuario = idusuario ; }
CyberdyneOfCerrado/Pechincha | public void setLance ( float lance ) { this . lance = lance ; }
pfrank13/spring-cloud-contract | public FraudCheck ( ) { }
pfrank13/spring-cloud-contract | public String getClientPesel ( ) { return clientPesel ; }
pfrank13/spring-cloud-contract | public void setClientPesel ( String clientPesel ) { this . clientPesel = clientPesel ; }
pfrank13/spring-cloud-contract | public BigDecimal getLoanAmount ( ) { return loanAmount ; }
pfrank13/spring-cloud-contract | public void setLoanAmount ( BigDecimal loanAmount ) { this . loanAmount = loanAmount ; }
MohammedHammam/camel | public char getFileSeparator ( ) { return File . separatorChar ; }
MohammedHammam/camel | public GenericFile < T > copyFrom ( GenericFile < T > source ) { GenericFile < T > result ; try { result = source . getClass ( ) . newInstance ( ) ; } catch ( Exception e ) { throw ObjectHelper . wrapRuntimeCamelException ( e ) ; } result . setCopyFromAbsoluteFilePath ( source . getAbsoluteFilePath ( ) ) ; result . setEndpointPath ( source . getEndpointPath ( ) ) ; result . setAbsolute ( source . isAbsolute ( ) ) ; result . setDirectory ( source . isDirectory ( ) ) ; result . setAbsoluteFilePath ( source . getAbsoluteFilePath ( ) ) ; result . setRelativeFilePath ( source . getRelativeFilePath ( ) ) ; result . setFileName ( source . getFileName ( ) ) ; result . setFileNameOnly ( source . getFileNameOnly ( ) ) ; result . setFileLength ( source . getFileLength ( ) ) ; result . setLastModified ( source . getLastModified ( ) ) ; result . setFile ( source . getFile ( ) ) ; result . setBody ( source . getBody ( ) ) ; result . setBinding ( source . getBinding ( ) ) ; result . setCharset ( source . getCharset ( ) ) ; copyFromPopulateAdditional ( source , result ) ; return result ; }
MohammedHammam/camel | public void copyFromPopulateAdditional ( GenericFile < T > source , GenericFile < T > result ) { }
MohammedHammam/camel | public void bindToExchange ( Exchange exchange ) { Map < String , Object > headers ; exchange . setProperty ( FileComponent . FILE_EXCHANGE_FILE , this ) ; GenericFileMessage < T > msg = new GenericFileMessage < T > ( this ) ; if ( exchange . hasOut ( ) ) { headers = exchange . getOut ( ) . hasHeaders ( ) ? exchange . getOut ( ) . getHeaders ( ) : null ; exchange . setOut ( msg ) ; } else { headers = exchange . getIn ( ) . hasHeaders ( ) ? exchange . getIn ( ) . getHeaders ( ) : null ; exchange . setIn ( msg ) ; } if ( headers != null ) { msg . setHeaders ( headers ) ; msg . removeHeaders ( " CamelFile * " ) ; } populateHeaders ( msg ) ; }
MohammedHammam/camel | public void populateHeaders ( GenericFileMessage < T > message ) { if ( message != null ) { message . setHeader ( Exchange . FILE_NAME_ONLY , getFileNameOnly ( ) ) ; message . setHeader ( Exchange . FILE_NAME , getFileName ( ) ) ; message . setHeader ( Exchange . FILE_NAME_CONSUMED , getFileName ( ) ) ; message . setHeader ( " CamelFileAbsolute " , isAbsolute ( ) ) ; message . setHeader ( " CamelFileAbsolutePath " , getAbsoluteFilePath ( ) ) ; if ( file instanceof File ) { File f = ( File ) file ; Path path = f . toPath ( ) ; try { message . setHeader ( Exchange . FILE_CONTENT_TYPE , Files . probeContentType ( path ) ) ; } catch ( Exception ex ) { } } if ( isAbsolute ( ) ) { message . setHeader ( Exchange . FILE_PATH , getAbsoluteFilePath ( ) ) ; } else { String path = normalizePathToProtocol ( getEndpointPath ( ) + File . separator + getRelativeFilePath ( ) ) ; message . setHeader ( Exchange . FILE_PATH , path ) ; } message . setHeader ( " CamelFileRelativePath " , getRelativeFilePath ( ) ) ; message . setHeader ( Exchange . FILE_PARENT , getParent ( ) ) ; if ( getFileLength ( ) >= 0 ) { message . setHeader ( Exchange . FILE_LENGTH , getFileLength ( ) ) ; } if ( getLastModified ( ) > 0 ) { message . setHeader ( Exchange . FILE_LAST_MODIFIED , getLastModified ( ) ) ; } } }
MohammedHammam/camel | protected boolean isAbsolute ( String name ) { return FileUtil . isAbsolute ( new File ( name ) ) ; }
MohammedHammam/camel | protected String normalizePath ( String name ) { return FileUtil . normalizePath ( name ) ; }
MohammedHammam/camel | public void changeFileName ( String newName ) { LOG . trace ( " Changing ▁ name ▁ to : ▁ { } " , newName ) ; String newFileName = FileUtil . normalizePath ( newName ) ; String newEndpointPath = FileUtil . normalizePath ( endpointPath ) ; LOG . trace ( " Normalized ▁ endpointPath : ▁ { } " , newEndpointPath ) ; LOG . trace ( " Normalized ▁ newFileName : ▁ ( ) " , newFileName ) ; File file = new File ( newFileName ) ; if ( ! absolute ) { if ( ObjectHelper . isNotEmpty ( newEndpointPath ) && newFileName . startsWith ( newEndpointPath ) ) { if ( newEndpointPath . endsWith ( " " + File . separatorChar ) ) { newFileName = ObjectHelper . after ( newFileName , newEndpointPath ) ; } else { newFileName = ObjectHelper . after ( newFileName , newEndpointPath + File . separatorChar ) ; } file = new File ( newFileName ) ; } } setFileNameOnly ( file . getName ( ) ) ; setFileName ( file . getName ( ) ) ; if ( file . getParent ( ) != null ) { setRelativeFilePath ( file . getParent ( ) + getFileSeparator ( ) + file . getName ( ) ) ; } else { setRelativeFilePath ( file . getName ( ) ) ; } if ( isAbsolute ( newFileName ) ) { setAbsolute ( true ) ; setAbsoluteFilePath ( newFileName ) ; } else { setAbsolute ( false ) ; String path = ObjectHelper . isEmpty ( endpointPath ) ? " " : endpointPath + getFileSeparator ( ) ; setAbsoluteFilePath ( path + getRelativeFilePath ( ) ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " FileNameOnly : ▁ { } " , getFileNameOnly ( ) ) ; LOG . trace ( " FileName : ▁ { } " , getFileName ( ) ) ; LOG . trace ( " Absolute : ▁ { } " , isAbsolute ( ) ) ; LOG . trace ( " Relative ▁ path : ▁ { } " , getRelativeFilePath ( ) ) ; LOG . trace ( " Absolute ▁ path : ▁ { } " , getAbsoluteFilePath ( ) ) ; LOG . trace ( " Name ▁ changed ▁ to : ▁ { } " , this ) ; } }
MohammedHammam/camel | public String getRelativeFilePath ( ) { return relativeFilePath ; }
MohammedHammam/camel | public void setRelativeFilePath ( String relativeFilePath ) { this . relativeFilePath = normalizePathToProtocol ( relativeFilePath ) ; }
MohammedHammam/camel | public String getFileName ( ) { return fileName ; }
MohammedHammam/camel | public void setFileName ( String fileName ) { this . fileName = normalizePathToProtocol ( fileName ) ; }
MohammedHammam/camel | public long getFileLength ( ) { return fileLength ; }
MohammedHammam/camel | public void setFileLength ( long fileLength ) { this . fileLength = fileLength ; }
MohammedHammam/camel | public long getLastModified ( ) { return lastModified ; }
MohammedHammam/camel | public void setLastModified ( long lastModified ) { this . lastModified = lastModified ; }
MohammedHammam/camel | public String getCharset ( ) { return charset ; }
MohammedHammam/camel | public void setCharset ( String charset ) { this . charset = charset ; }
MohammedHammam/camel | @ Override public T getFile ( ) { return file ; }
MohammedHammam/camel | public void setFile ( T file ) { this . file = file ; }
MohammedHammam/camel | public Object getBody ( ) { return getBinding ( ) . getBody ( this ) ; }
MohammedHammam/camel | public void setBody ( Object os ) { getBinding ( ) . setBody ( this , os ) ; }
MohammedHammam/camel | public String getParent ( ) { String parent ; if ( isAbsolute ( ) ) { String name = getAbsoluteFilePath ( ) ; File path = new File ( name ) ; parent = path . getParent ( ) ; } else { String name = getRelativeFilePath ( ) ; File path ; if ( name != null ) { path = new File ( endpointPath , name ) ; } else { path = new File ( endpointPath ) ; } parent = path . getParent ( ) ; } return normalizePathToProtocol ( parent ) ; }
MohammedHammam/camel | public GenericFileBinding < T > getBinding ( ) { if ( binding == null ) { binding = new GenericFileDefaultBinding < T > ( ) ; } return binding ; }
MohammedHammam/camel | public void setBinding ( GenericFileBinding < T > binding ) { this . binding = binding ; }
MohammedHammam/camel | public void setAbsoluteFilePath ( String absoluteFilePath ) { this . absoluteFilePath = normalizePathToProtocol ( absoluteFilePath ) ; }
MohammedHammam/camel | public String getAbsoluteFilePath ( ) { return absoluteFilePath ; }
MohammedHammam/camel | public boolean isAbsolute ( ) { return absolute ; }
MohammedHammam/camel | public void setAbsolute ( boolean absolute ) { this . absolute = absolute ; }
MohammedHammam/camel | public String getEndpointPath ( ) { return endpointPath ; }
MohammedHammam/camel | public void setEndpointPath ( String endpointPath ) { this . endpointPath = normalizePathToProtocol ( endpointPath ) ; }
MohammedHammam/camel | public String getFileNameOnly ( ) { return fileNameOnly ; }
MohammedHammam/camel | public void setFileNameOnly ( String fileNameOnly ) { this . fileNameOnly = fileNameOnly ; }
MohammedHammam/camel | public boolean isDirectory ( ) { return directory ; }
MohammedHammam/camel | public void setDirectory ( boolean directory ) { this . directory = directory ; }
MohammedHammam/camel | public String getCopyFromAbsoluteFilePath ( ) { return copyFromAbsoluteFilePath ; }
MohammedHammam/camel | public void setCopyFromAbsoluteFilePath ( String copyFromAbsoluteFilePath ) { this . copyFromAbsoluteFilePath = copyFromAbsoluteFilePath ; }
MohammedHammam/camel | protected String normalizePathToProtocol ( String path ) { if ( ObjectHelper . isEmpty ( path ) ) { return path ; } path = path . replace ( ' / ' , getFileSeparator ( ) ) ; path = path . replace ( ' \ \' , getFileSeparator ( ) ) ; return path ; }
MohammedHammam/camel | @ Override public String toString ( ) { return " GenericFile [ " + ( absolute ? absoluteFilePath : relativeFilePath ) + " ] " ; }
jamesweeYan/linkssq | public Funnel ( ) { }
jamesweeYan/linkssq | public int getId ( ) { return this . id ; }
jamesweeYan/linkssq | public void setId ( int id ) { this . id = id ; }
jamesweeYan/linkssq | public String getR01 ( ) { return this . r01 ; }
jamesweeYan/linkssq | public void setR01 ( String r01 ) { this . r01 = r01 ; }
jamesweeYan/linkssq | public String getR02 ( ) { return this . r02 ; }
jamesweeYan/linkssq | public void setR02 ( String r02 ) { this . r02 = r02 ; }
jamesweeYan/linkssq | public String getR03 ( ) { return this . r03 ; }
jamesweeYan/linkssq | public void setR03 ( String r03 ) { this . r03 = r03 ; }
jamesweeYan/linkssq | public String getR04 ( ) { return this . r04 ; }
jamesweeYan/linkssq | public void setR04 ( String r04 ) { this . r04 = r04 ; }
jamesweeYan/linkssq | public String getR05 ( ) { return this . r05 ; }
jamesweeYan/linkssq | public void setR05 ( String r05 ) { this . r05 = r05 ; }
jamesweeYan/linkssq | public String getR06 ( ) { return this . r06 ; }
jamesweeYan/linkssq | public void setR06 ( String r06 ) { this . r06 = r06 ; }
jamesweeYan/linkssq | public String getR07 ( ) { return this . r07 ; }
jamesweeYan/linkssq | public void setR07 ( String r07 ) { this . r07 = r07 ; }
jamesweeYan/linkssq | public String getR08 ( ) { return this . r08 ; }
jamesweeYan/linkssq | public void setR08 ( String r08 ) { this . r08 = r08 ; }
jamesweeYan/linkssq | public String getR09 ( ) { return this . r09 ; }
jamesweeYan/linkssq | public void setR09 ( String r09 ) { this . r09 = r09 ; }
jamesweeYan/linkssq | public String getR10 ( ) { return this . r10 ; }
jamesweeYan/linkssq | public void setR10 ( String r10 ) { this . r10 = r10 ; }
jamesweeYan/linkssq | public String getR11 ( ) { return this . r11 ; }
jamesweeYan/linkssq | public void setR11 ( String r11 ) { this . r11 = r11 ; }
jamesweeYan/linkssq | public String getR12 ( ) { return this . r12 ; }
jamesweeYan/linkssq | public void setR12 ( String r12 ) { this . r12 = r12 ; }
jamesweeYan/linkssq | public String getR13 ( ) { return this . r13 ; }
jamesweeYan/linkssq | public void setR13 ( String r13 ) { this . r13 = r13 ; }
jamesweeYan/linkssq | public String getR14 ( ) { return this . r14 ; }
jamesweeYan/linkssq | public void setR14 ( String r14 ) { this . r14 = r14 ; }
jamesweeYan/linkssq | public String getR15 ( ) { return this . r15 ; }
jamesweeYan/linkssq | public void setR15 ( String r15 ) { this . r15 = r15 ; }
jamesweeYan/linkssq | public String getR16 ( ) { return this . r16 ; }
jamesweeYan/linkssq | public void setR16 ( String r16 ) { this . r16 = r16 ; }
jamesweeYan/linkssq | public String getR17 ( ) { return this . r17 ; }
jamesweeYan/linkssq | public void setR17 ( String r17 ) { this . r17 = r17 ; }
jamesweeYan/linkssq | public String getR18 ( ) { return this . r18 ; }
jamesweeYan/linkssq | public void setR18 ( String r18 ) { this . r18 = r18 ; }
jamesweeYan/linkssq | public String getR19 ( ) { return this . r19 ; }
jamesweeYan/linkssq | public void setR19 ( String r19 ) { this . r19 = r19 ; }
jamesweeYan/linkssq | public String getR20 ( ) { return this . r20 ; }
jamesweeYan/linkssq | public void setR20 ( String r20 ) { this . r20 = r20 ; }
jamesweeYan/linkssq | public String getR21 ( ) { return this . r21 ; }
jamesweeYan/linkssq | public void setR21 ( String r21 ) { this . r21 = r21 ; }
jamesweeYan/linkssq | public String getR22 ( ) { return this . r22 ; }
jamesweeYan/linkssq | public void setR22 ( String r22 ) { this . r22 = r22 ; }
jamesweeYan/linkssq | public String getR23 ( ) { return this . r23 ; }
jamesweeYan/linkssq | public void setR23 ( String r23 ) { this . r23 = r23 ; }
jamesweeYan/linkssq | public String getR24 ( ) { return this . r24 ; }
jamesweeYan/linkssq | public void setR24 ( String r24 ) { this . r24 = r24 ; }
jamesweeYan/linkssq | public String getR25 ( ) { return this . r25 ; }
jamesweeYan/linkssq | public void setR25 ( String r25 ) { this . r25 = r25 ; }
jamesweeYan/linkssq | public String getR26 ( ) { return this . r26 ; }
jamesweeYan/linkssq | public void setR26 ( String r26 ) { this . r26 = r26 ; }
jamesweeYan/linkssq | public String getR27 ( ) { return this . r27 ; }
jamesweeYan/linkssq | public void setR27 ( String r27 ) { this . r27 = r27 ; }
jamesweeYan/linkssq | public String getR28 ( ) { return this . r28 ; }
jamesweeYan/linkssq | public void setR28 ( String r28 ) { this . r28 = r28 ; }
jamesweeYan/linkssq | public String getR29 ( ) { return this . r29 ; }
jamesweeYan/linkssq | public void setR29 ( String r29 ) { this . r29 = r29 ; }
jamesweeYan/linkssq | public String getR30 ( ) { return this . r30 ; }
jamesweeYan/linkssq | public void setR30 ( String r30 ) { this . r30 = r30 ; }
jamesweeYan/linkssq | public String getR31 ( ) { return this . r31 ; }
jamesweeYan/linkssq | public void setR31 ( String r31 ) { this . r31 = r31 ; }
jamesweeYan/linkssq | public String getR32 ( ) { return this . r32 ; }
jamesweeYan/linkssq | public void setR32 ( String r32 ) { this . r32 = r32 ; }
jamesweeYan/linkssq | public String getR33 ( ) { return this . r33 ; }
jamesweeYan/linkssq | public void setR33 ( String r33 ) { this . r33 = r33 ; }
l-dobrev/activemq-artemis | @ Override public Object createObject ( ) throws Exception { RemoveSubscriptionInfo info = new RemoveSubscriptionInfo ( ) ; populateObject ( info ) ; return info ; }
l-dobrev/activemq-artemis | @ Override protected void populateObject ( Object object ) throws Exception { super . populateObject ( object ) ; RemoveSubscriptionInfo info = ( RemoveSubscriptionInfo ) object ; info . setConnectionId ( createConnectionId ( " ConnectionId : 1" ) ) ; info . setSubscriptionName ( " SubcriptionName : 2" ) ; info . setClientId ( " ClientId : 3" ) ; }
yv84/yolo-avenger | public String getReturn ( ) { return _return ; }
yv84/yolo-avenger | public void setReturn ( String value ) { this . _return = value ; }
freeVM/freeVM | public MsgClassGenerator ( ) { super ( ) ; }
freeVM/freeVM | public void generate ( File dir , File props ) { File modProps ; if ( props == null ) { modProps = getResourceFromJar ( ENTRY_PATH , MODULES_PROPERTIES_NAME ) ; modProps . deleteOnExit ( ) ; } else { modProps = props ; } dstDir = ( dir != null ) ? dir : new File ( userDir ) ; Properties prs = null ; FileInputStream fis = null ; int fails = 0 ; try { fis = new FileInputStream ( modProps ) ; } catch ( FileNotFoundException e ) { logMessage ( " Generation ▁ error : ▁ Specified ▁ file ▁ " + modProps . getPath ( ) + " ▁ doesn ' t ▁ exist ! " ) ; return ; } prs = new Properties ( ) ; try { prs . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { logMessage ( " \n Generation ▁ error : " + e . getMessage ( ) ) ; } logMessage ( " \n Generation ▁ started : \n " ) ; logMessage ( " Modules ▁ generation ▁ status : ▁ " ) ; Enumeration en = prs . keys ( ) ; while ( en . hasMoreElements ( ) ) { String modName = prs . getProperty ( ( String ) en . nextElement ( ) ) . trim ( ) ; logMessage ( modName + " ▁ : ▁ " ) ; try { createSourceFromTemplate ( modName , MESSAGES_TEMPLATE_FILE , MSG_class_NAME ) ; createMsgsProperties ( modName ) ; } catch ( Exception e ) { logMessage ( " error : ▁ " + e . getMessage ( ) ) ; fails ++ ; continue ; } logMessage ( " completed " ) ; } if ( fails == 0 ) { logMessage ( " \n Generation ▁ successfully ▁ finished ! " ) ; } else { logMessage ( " \n Generation ▁ finished ▁ with ▁ " + fails + " ▁ fails ! " ) ; logMessage ( " See ▁ output ▁ information ▁ for ▁ details ! " ) ; } }
freeVM/freeVM | private void templateReplace ( File srcFile , File dstFile , String moduleName ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( srcFile ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( dstFile ) ) ; String s ; while ( ( s = br . readLine ( ) ) != null ) { if ( s . indexOf ( MODULE_PATTERN_NAME ) != - 1 ) { s = s . replaceAll ( MODULE_PATTERN_NAME , moduleName ) ; } bw . write ( s ) ; bw . newLine ( ) ; } bw . close ( ) ; br . close ( ) ; }
freeVM/freeVM | private void createSourceFromTemplate ( String moduleName , File srcFile , String templateName ) throws Exception { File dstFile = new File ( getDstDir ( moduleName ) , templateName + JAVA_EXT_NAME ) ; dstFile . createNewFile ( ) ; logMessage ( " \t " + dstFile . getAbsolutePath ( ) ) ; templateReplace ( srcFile , dstFile , getPackageFromModule ( moduleName ) ) ; }
freeVM/freeVM | private void createMsgsProperties ( String moduleName ) throws Exception { File dstFile = new File ( getDstDir ( moduleName ) , MSGS_PROPERTIES_NAME ) ; if ( dstFile . exists ( ) ) { return ; } FileInputStream fis = new FileInputStream ( MSGS_PROPERTIES_FILE ) ; FileOutputStream fos = new FileOutputStream ( dstFile ) ; byte [ ] data = new byte [ fis . available ( ) ] ; while ( fis . read ( data ) > 0 ) { fos . write ( data ) ; data = new byte [ fis . available ( ) ] ; } fis . close ( ) ; fos . close ( ) ; logMessage ( " \t " + dstFile . getAbsolutePath ( ) ) ; }
freeVM/freeVM | private File getDstDir ( String moduleName ) { File srcDir = new File ( dstDir , " modules / " + moduleName + " / src / main / java " ) ; if ( srcDir . exists ( ) && srcDir . isDirectory ( ) ) { String names [ ] = srcDir . list ( new FilenameCommonFilter ( ) ) ; if ( names . length > 0 ) { srcDir = new File ( srcDir , names [ 0 ] ) ; } } String path = " org / apache / harmony / " + getPackageFromModule ( moduleName ) + " / internal / nls " ; File dir = new File ( srcDir , path ) ; dir . mkdirs ( ) ; return dir ; }
freeVM/freeVM | private String getPackageFromModule ( String modName ) { String pkgName = modName ; return pkgName . replaceAll ( " [ _ , - ] " , " " ) ; }
freeVM/freeVM | public boolean accept ( File dir , String name ) { if ( name . equals ( " common " ) ) { File commonDir = new File ( dir , name ) ; return commonDir . isDirectory ( ) ; } return false ; }
BBK-PiJ-2015-74/Java-Exercises-week-6-onwards | public String getLastName ( ) { return lastName ; }
BBK-PiJ-2015-74/Java-Exercises-week-6-onwards | public void setLastName ( String lastName ) { this . lastName = lastName ; }
fogbeam/Heceta_solr | public SpellCheckResponse ( NamedList < NamedList < Object > > spellInfo ) { NamedList < Object > sugg = spellInfo . get ( " suggestions " ) ; if ( sugg == null ) { correctlySpelled = true ; return ; } for ( int i = 0 ; i < sugg . size ( ) ; i ++ ) { String n = sugg . getName ( i ) ; if ( " correctlySpelled " . equals ( n ) ) { correctlySpelled = ( Boolean ) sugg . getVal ( i ) ; } else if ( " collationInternalRank " . equals ( n ) ) { } else if ( " collation " . equals ( n ) ) { List < Object > collationInfo = sugg . getAll ( n ) ; collations = new ArrayList < Collation > ( collationInfo . size ( ) ) ; for ( Object o : collationInfo ) { if ( o instanceof String ) { collations . add ( new Collation ( ) . setCollationQueryString ( ( String ) o ) ) ; } else if ( o instanceof NamedList ) { @ SuppressWarnings ( " unchecked " ) NamedList < Object > expandedCollation = ( NamedList < Object > ) o ; String collationQuery = ( String ) expandedCollation . get ( " collationQuery " ) ; int hits = ( Integer ) expandedCollation . get ( " hits " ) ; @ SuppressWarnings ( " unchecked " ) NamedList < String > misspellingsAndCorrections = ( NamedList < String > ) expandedCollation . get ( " misspellingsAndCorrections " ) ; Collation collation = new Collation ( ) ; collation . setCollationQueryString ( collationQuery ) ; collation . setNumberOfHits ( hits ) ; for ( int ii = 0 ; ii < misspellingsAndCorrections . size ( ) ; ii ++ ) { String misspelling = misspellingsAndCorrections . getName ( ii ) ; String correction = misspellingsAndCorrections . getVal ( ii ) ; collation . addMisspellingsAndCorrection ( new Correction ( misspelling , correction ) ) ; } collations . add ( collation ) ; } else { throw new AssertionError ( " Should ▁ get ▁ Lists ▁ of ▁ Strings ▁ or ▁ List ▁ of ▁ NamedLists ▁ here . " ) ; } } } else { @ SuppressWarnings ( " unchecked " ) Suggestion s = new Suggestion ( n , ( NamedList < Object > ) sugg . getVal ( i ) ) ; suggestionMap . put ( n , s ) ; suggestions . add ( s ) ; } } }
fogbeam/Heceta_solr | public boolean isCorrectlySpelled ( ) { return correctlySpelled ; }
fogbeam/Heceta_solr | public List < Suggestion > getSuggestions ( ) { return suggestions ; }
fogbeam/Heceta_solr | public Map < String , Suggestion > getSuggestionMap ( ) { return suggestionMap ; }
fogbeam/Heceta_solr | public Suggestion getSuggestion ( String token ) { return suggestionMap . get ( token ) ; }
fogbeam/Heceta_solr | public String getFirstSuggestion ( String token ) { Suggestion s = suggestionMap . get ( token ) ; if ( s == null || s . getAlternatives ( ) . isEmpty ( ) ) return null ; return s . getAlternatives ( ) . get ( 0 ) ; }
fogbeam/Heceta_solr | public String getCollatedResult ( ) { return collations == null || collations . size ( ) == 0 ? null : collations . get ( 0 ) . collationQueryString ; }
fogbeam/Heceta_solr | public List < Collation > getCollatedResults ( ) { return collations ; }
fogbeam/Heceta_solr | public Suggestion ( String token , NamedList < Object > suggestion ) { this . token = token ; for ( int i = 0 ; i < suggestion . size ( ) ; i ++ ) { String n = suggestion . getName ( i ) ; if ( " numFound " . equals ( n ) ) { numFound = ( Integer ) suggestion . getVal ( i ) ; } else if ( " startOffset " . equals ( n ) ) { startOffset = ( Integer ) suggestion . getVal ( i ) ; } else if ( " endOffset " . equals ( n ) ) { endOffset = ( Integer ) suggestion . getVal ( i ) ; } else if ( " origFreq " . equals ( n ) ) { originalFrequency = ( Integer ) suggestion . getVal ( i ) ; } else if ( " suggestion " . equals ( n ) ) { @ SuppressWarnings ( " unchecked " ) List list = ( List ) suggestion . getVal ( i ) ; if ( list . size ( ) > 0 && list . get ( 0 ) instanceof NamedList ) { @ SuppressWarnings ( " unchecked " ) List < NamedList > extended = ( List < NamedList > ) list ; alternativeFrequencies = new ArrayList < Integer > ( ) ; for ( NamedList nl : extended ) { alternatives . add ( ( String ) nl . get ( " word " ) ) ; alternativeFrequencies . add ( ( Integer ) nl . get ( " freq " ) ) ; } } else { @ SuppressWarnings ( " unchecked " ) List < String > alts = ( List < String > ) list ; alternatives . addAll ( alts ) ; } } } }
fogbeam/Heceta_solr | public String getToken ( ) { return token ; }
fogbeam/Heceta_solr | public int getNumFound ( ) { return numFound ; }
fogbeam/Heceta_solr | public int getStartOffset ( ) { return startOffset ; }
fogbeam/Heceta_solr | public int getEndOffset ( ) { return endOffset ; }
fogbeam/Heceta_solr | public int getOriginalFrequency ( ) { return originalFrequency ; }
fogbeam/Heceta_solr | public List < String > getAlternatives ( ) { return alternatives ; }
fogbeam/Heceta_solr | public List < Integer > getAlternativeFrequencies ( ) { return alternativeFrequencies ; }
fogbeam/Heceta_solr | @ Deprecated public List < String > getSuggestions ( ) { return alternatives ; }
fogbeam/Heceta_solr | @ Deprecated public List < Integer > getSuggestionFrequencies ( ) { return alternativeFrequencies ; }
fogbeam/Heceta_solr | public long getNumberOfHits ( ) { return numberOfHits ; }
fogbeam/Heceta_solr | public void setNumberOfHits ( long numberOfHits ) { this . numberOfHits = numberOfHits ; }
fogbeam/Heceta_solr | public String getCollationQueryString ( ) { return collationQueryString ; }
fogbeam/Heceta_solr | public Collation setCollationQueryString ( String collationQueryString ) { this . collationQueryString = collationQueryString ; return this ; }
fogbeam/Heceta_solr | public List < Correction > getMisspellingsAndCorrections ( ) { return misspellingsAndCorrections ; }
fogbeam/Heceta_solr | public Collation addMisspellingsAndCorrection ( Correction correction ) { this . misspellingsAndCorrections . add ( correction ) ; return this ; }
fogbeam/Heceta_solr | public Correction ( String original , String correction ) { this . original = original ; this . correction = correction ; }
fogbeam/Heceta_solr | public String getOriginal ( ) { return original ; }
fogbeam/Heceta_solr | public void setOriginal ( String original ) { this . original = original ; }
fogbeam/Heceta_solr | public String getCorrection ( ) { return correction ; }
fogbeam/Heceta_solr | public void setCorrection ( String correction ) { this . correction = correction ; }
Susankha/developer-studio | private HTPackageImpl ( ) { super ( eNS_URI , HTFactory . eINSTANCE ) ; }
Susankha/developer-studio | public EClass getDocumentRoot ( ) { return documentRootEClass ; }
Susankha/developer-studio | public EAttribute getDocumentRoot_Mixed ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_XMLNSPrefixMap ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_XSISchemaLocation ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_BusinessAdministrators ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_ExcludedOwners ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getDocumentRoot_Group ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Groups ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_HumanInteractions ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Import ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 8 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_LogicalPeopleGroups ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 9 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Notification ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 10 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Notifications ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 11 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_OrganizationalEntity ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 12 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_PeopleAssignments ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 13 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_PotentialOwners ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 14 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Priority ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 15 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Recipients ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 16 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Task ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 17 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_TaskInitiator ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 18 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Tasks ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 19 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_TaskStakeholders ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 20 ) ; }
Susankha/developer-studio | public EAttribute getDocumentRoot_User ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 21 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Users ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 22 ) ; }
Susankha/developer-studio | public EClass getTArgument ( ) { return tArgumentEClass ; }
Susankha/developer-studio | public EAttribute getTArgument_ExpressionLanguage ( ) { return ( EAttribute ) tArgumentEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTArgument_Name ( ) { return ( EAttribute ) tArgumentEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTBooleanExpr ( ) { return tBooleanExprEClass ; }
Susankha/developer-studio | public EClass getTDeadline ( ) { return tDeadlineEClass ; }
Susankha/developer-studio | public EReference getTDeadline_For ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTDeadline_Until ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTDeadline_Escalation ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTDeadlineExpr ( ) { return tDeadlineExprEClass ; }
Susankha/developer-studio | public EClass getTDeadlines ( ) { return tDeadlinesEClass ; }
Susankha/developer-studio | public EReference getTDeadlines_StartDeadline ( ) { return ( EReference ) tDeadlinesEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTDeadlines_CompletionDeadline ( ) { return ( EReference ) tDeadlinesEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTDelegation ( ) { return tDelegationEClass ; }
Susankha/developer-studio | public EReference getTDelegation_From ( ) { return ( EReference ) tDelegationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTDelegation_PotentialDelegatees ( ) { return ( EAttribute ) tDelegationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTDescription ( ) { return tDescriptionEClass ; }
Susankha/developer-studio | public EAttribute getTDescription_ContentType ( ) { return ( EAttribute ) tDescriptionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTDescription_Lang ( ) { return ( EAttribute ) tDescriptionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTDocumentation ( ) { return tDocumentationEClass ; }
Susankha/developer-studio | public EAttribute getTDocumentation_Mixed ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTDocumentation_Any ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTDocumentation_Lang ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTDurationExpr ( ) { return tDurationExprEClass ; }
Susankha/developer-studio | public EClass getTEscalation ( ) { return tEscalationEClass ; }
Susankha/developer-studio | public EReference getTEscalation_Condition ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTEscalation_ToParts ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTEscalation_Notification ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTEscalation_LocalNotification ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTEscalation_Reassignment ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getTEscalation_Name ( ) { return ( EAttribute ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EClass getTExpression ( ) { return tExpressionEClass ; }
Susankha/developer-studio | public EAttribute getTExpression_Mixed ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTExpression_Any ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTExpression_ExpressionLanguage ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTExpression_AnyAttribute ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTExtensibleElements ( ) { return tExtensibleElementsEClass ; }
Susankha/developer-studio | public EReference getTExtensibleElements_Documentation ( ) { return ( EReference ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleElements_Any ( ) { return ( EAttribute ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleElements_AnyAttribute ( ) { return ( EAttribute ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTExtensibleMixedContentElements ( ) { return tExtensibleMixedContentElementsEClass ; }
Susankha/developer-studio | public EAttribute getTExtensibleMixedContentElements_Mixed ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTExtensibleMixedContentElements_Documentation ( ) { return ( EReference ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleMixedContentElements_Any ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleMixedContentElements_AnyAttribute ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTExtension ( ) { return tExtensionEClass ; }
Susankha/developer-studio | public EAttribute getTExtension_MustUnderstand ( ) { return ( EAttribute ) tExtensionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTExtension_Namespace ( ) { return ( EAttribute ) tExtensionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTExtensions ( ) { return tExtensionsEClass ; }
Susankha/developer-studio | public EReference getTExtensions_Extension ( ) { return ( EReference ) tExtensionsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTFrom ( ) { return tFromEClass ; }
Susankha/developer-studio | public EReference getTFrom_Argument ( ) { return ( EReference ) tFromEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTFrom_Literal ( ) { return ( EReference ) tFromEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTFrom_ExpressionLanguage ( ) { return ( EAttribute ) tFromEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTFrom_LogicalPeopleGroup ( ) { return ( EAttribute ) tFromEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTGenericHumanRole ( ) { return tGenericHumanRoleEClass ; }
Susankha/developer-studio | public EReference getTGenericHumanRole_From ( ) { return ( EReference ) tGenericHumanRoleEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTGrouplist ( ) { return tGrouplistEClass ; }
Susankha/developer-studio | public EAttribute getTGrouplist_Group ( ) { return ( EAttribute ) tGrouplistEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTHumanInteractions ( ) { return tHumanInteractionsEClass ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Extensions ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Import ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_LogicalPeopleGroups ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Tasks ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Notifications ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getTHumanInteractions_ExpressionLanguage ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EAttribute getTHumanInteractions_QueryLanguage ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EAttribute getTHumanInteractions_TargetNamespace ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
Susankha/developer-studio | public EClass getTImport ( ) { return tImportEClass ; }
Susankha/developer-studio | public EAttribute getTImport_ImportType ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTImport_Location ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTImport_Namespace ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLiteral ( ) { return tLiteralEClass ; }
Susankha/developer-studio | public EAttribute getTLiteral_Mixed ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTLiteral_Any ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTLiteral_AnyAttribute ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLocalNotification ( ) { return tLocalNotificationEClass ; }
Susankha/developer-studio | public EReference getTLocalNotification_Priority ( ) { return ( EReference ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTLocalNotification_PeopleAssignments ( ) { return ( EReference ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTLocalNotification_Reference ( ) { return ( EAttribute ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLogicalPeopleGroup ( ) { return tLogicalPeopleGroupEClass ; }
Susankha/developer-studio | public EReference getTLogicalPeopleGroup_Parameter ( ) { return ( EReference ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTLogicalPeopleGroup_Name ( ) { return ( EAttribute ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTLogicalPeopleGroup_Reference ( ) { return ( EAttribute ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLogicalPeopleGroups ( ) { return tLogicalPeopleGroupsEClass ; }
Susankha/developer-studio | public EReference getTLogicalPeopleGroups_LogicalPeopleGroup ( ) { return ( EReference ) tLogicalPeopleGroupsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTNotification ( ) { return tNotificationEClass ; }
Susankha/developer-studio | public EReference getTNotification_Interface ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTNotification_Priority ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTNotification_PeopleAssignments ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTNotification_PresentationElements ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTNotification_Renderings ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getTNotification_Name ( ) { return ( EAttribute ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EClass getTNotificationInterface ( ) { return tNotificationInterfaceEClass ; }
Susankha/developer-studio | public EAttribute getTNotificationInterface_Operation ( ) { return ( EAttribute ) tNotificationInterfaceEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTNotificationInterface_PortType ( ) { return ( EAttribute ) tNotificationInterfaceEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTNotifications ( ) { return tNotificationsEClass ; }
Susankha/developer-studio | public EReference getTNotifications_Notification ( ) { return ( EReference ) tNotificationsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTOrganizationalEntity ( ) { return tOrganizationalEntityEClass ; }
Susankha/developer-studio | public EReference getTOrganizationalEntity_Users ( ) { return ( EReference ) tOrganizationalEntityEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTOrganizationalEntity_Groups ( ) { return ( EReference ) tOrganizationalEntityEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTParameter ( ) { return tParameterEClass ; }
Susankha/developer-studio | public EAttribute getTParameter_Name ( ) { return ( EAttribute ) tParameterEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTParameter_Type ( ) { return ( EAttribute ) tParameterEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTPeopleAssignments ( ) { return tPeopleAssignmentsEClass ; }
Susankha/developer-studio | public EAttribute getTPeopleAssignments_GenericHumanRole ( ) { return ( EAttribute ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_PotentialOwners ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_ExcludedOwners ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_TaskInitiator ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_TaskStakeholders ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_BusinessAdministrators ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_Recipients ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EClass getTPresentationElements ( ) { return tPresentationElementsEClass ; }
Susankha/developer-studio | public EReference getTPresentationElements_Name ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTPresentationElements_PresentationParameters ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTPresentationElements_Subject ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTPresentationElements_Description ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTPresentationParameter ( ) { return tPresentationParameterEClass ; }
Susankha/developer-studio | public EClass getTPresentationParameters ( ) { return tPresentationParametersEClass ; }
Susankha/developer-studio | public EReference getTPresentationParameters_PresentationParameter ( ) { return ( EReference ) tPresentationParametersEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTPresentationParameters_ExpressionLanguage ( ) { return ( EAttribute ) tPresentationParametersEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTPriority ( ) { return tPriorityEClass ; }
Susankha/developer-studio | public EClass getTQuery ( ) { return tQueryEClass ; }
Susankha/developer-studio | public EAttribute getTQuery_Mixed ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_Any ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_Part ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_QueryLanguage ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_AnyAttribute ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EClass getTReassignment ( ) { return tReassignmentEClass ; }
Susankha/developer-studio | public EReference getTReassignment_PotentialOwners ( ) { return ( EReference ) tReassignmentEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTRendering ( ) { return tRenderingEClass ; }
Susankha/developer-studio | public EAttribute getTRendering_Type ( ) { return ( EAttribute ) tRenderingEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTRenderings ( ) { return tRenderingsEClass ; }
Susankha/developer-studio | public EReference getTRenderings_Rendering ( ) { return ( EReference ) tRenderingsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTTask ( ) { return tTaskEClass ; }
Susankha/developer-studio | public EReference getTTask_Interface ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTTask_Priority ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTTask_PeopleAssignments ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTTask_Delegation ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTTask_PresentationElements ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EReference getTTask_Outcome ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EReference getTTask_SearchBy ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EReference getTTask_Renderings ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
Susankha/developer-studio | public EReference getTTask_Deadlines ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 8 ) ; }
Susankha/developer-studio | public EAttribute getTTask_Name ( ) { return ( EAttribute ) tTaskEClass . getEStructuralFeatures ( ) . get ( 9 ) ; }
Susankha/developer-studio | public EClass getTTaskInterface ( ) { return tTaskInterfaceEClass ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_Operation ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_PortType ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_ResponseOperation ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_ResponsePortType ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTTasks ( ) { return tTasksEClass ; }
Susankha/developer-studio | public EReference getTTasks_Task ( ) { return ( EReference ) tTasksEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTText ( ) { return tTextEClass ; }
Susankha/developer-studio | public EAttribute getTText_Lang ( ) { return ( EAttribute ) tTextEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTToPart ( ) { return tToPartEClass ; }
Susankha/developer-studio | public EAttribute getTToPart_ExpressionLanguage ( ) { return ( EAttribute ) tToPartEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTToPart_Name ( ) { return ( EAttribute ) tToPartEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTToParts ( ) { return tToPartsEClass ; }
Susankha/developer-studio | public EReference getTToParts_ToPart ( ) { return ( EReference ) tToPartsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTUserlist ( ) { return tUserlistEClass ; }
Susankha/developer-studio | public EAttribute getTUserlist_User ( ) { return ( EAttribute ) tUserlistEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EEnum getTBoolean ( ) { return tBooleanEEnum ; }
Susankha/developer-studio | public EEnum getTPotentialDelegatees ( ) { return tPotentialDelegateesEEnum ; }
Susankha/developer-studio | public EDataType getTBooleanObject ( ) { return tBooleanObjectEDataType ; }
Susankha/developer-studio | public EDataType getTGroup ( ) { return tGroupEDataType ; }
Susankha/developer-studio | public EDataType getTPotentialDelegateesObject ( ) { return tPotentialDelegateesObjectEDataType ; }
Susankha/developer-studio | public EDataType getTUser ( ) { return tUserEDataType ; }
Susankha/developer-studio | public HTFactory getHTFactory ( ) { return ( HTFactory ) getEFactoryInstance ( ) ; }
Susankha/developer-studio | public void createPackageContents ( ) { if ( isCreated ) return ; isCreated = true ; documentRootEClass = createEClass ( DOCUMENT_ROOT ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__MIXED ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__XMLNS_PREFIX_MAP ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__XSI_SCHEMA_LOCATION ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__BUSINESS_ADMINISTRATORS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__EXCLUDED_OWNERS ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__GROUP ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__GROUPS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__HUMAN_INTERACTIONS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__IMPORT ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__LOGICAL_PEOPLE_GROUPS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__NOTIFICATION ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__NOTIFICATIONS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__ORGANIZATIONAL_ENTITY ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__PEOPLE_ASSIGNMENTS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__POTENTIAL_OWNERS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__PRIORITY ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__RECIPIENTS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK_INITIATOR ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASKS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK_STAKEHOLDERS ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__USER ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__USERS ) ; tArgumentEClass = createEClass ( TARGUMENT ) ; createEAttribute ( tArgumentEClass , TARGUMENT__EXPRESSION_LANGUAGE ) ; createEAttribute ( tArgumentEClass , TARGUMENT__NAME ) ; tBooleanExprEClass = createEClass ( TBOOLEAN_EXPR ) ; tDeadlineEClass = createEClass ( TDEADLINE ) ; createEReference ( tDeadlineEClass , TDEADLINE__FOR ) ; createEReference ( tDeadlineEClass , TDEADLINE__UNTIL ) ; createEReference ( tDeadlineEClass , TDEADLINE__ESCALATION ) ; tDeadlineExprEClass = createEClass ( TDEADLINE_EXPR ) ; tDeadlinesEClass = createEClass ( TDEADLINES ) ; createEReference ( tDeadlinesEClass , TDEADLINES__START_DEADLINE ) ; createEReference ( tDeadlinesEClass , TDEADLINES__COMPLETION_DEADLINE ) ; tDelegationEClass = createEClass ( TDELEGATION ) ; createEReference ( tDelegationEClass , TDELEGATION__FROM ) ; createEAttribute ( tDelegationEClass , TDELEGATION__POTENTIAL_DELEGATEES ) ; tDescriptionEClass = createEClass ( TDESCRIPTION ) ; createEAttribute ( tDescriptionEClass , TDESCRIPTION__CONTENT_TYPE ) ; createEAttribute ( tDescriptionEClass , TDESCRIPTION__LANG ) ; tDocumentationEClass = createEClass ( TDOCUMENTATION ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__MIXED ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__ANY ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__LANG ) ; tDurationExprEClass = createEClass ( TDURATION_EXPR ) ; tEscalationEClass = createEClass ( TESCALATION ) ; createEReference ( tEscalationEClass , TESCALATION__CONDITION ) ; createEReference ( tEscalationEClass , TESCALATION__TO_PARTS ) ; createEReference ( tEscalationEClass , TESCALATION__NOTIFICATION ) ; createEReference ( tEscalationEClass , TESCALATION__LOCAL_NOTIFICATION ) ; createEReference ( tEscalationEClass , TESCALATION__REASSIGNMENT ) ; createEAttribute ( tEscalationEClass , TESCALATION__NAME ) ; tExpressionEClass = createEClass ( TEXPRESSION ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__MIXED ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__ANY ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__EXPRESSION_LANGUAGE ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__ANY_ATTRIBUTE ) ; tExtensibleElementsEClass = createEClass ( TEXTENSIBLE_ELEMENTS ) ; createEReference ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__DOCUMENTATION ) ; createEAttribute ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__ANY ) ; createEAttribute ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__ANY_ATTRIBUTE ) ; tExtensibleMixedContentElementsEClass = createEClass ( TEXTENSIBLE_MIXED_CONTENT_ELEMENTS ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__MIXED ) ; createEReference ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__DOCUMENTATION ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__ANY ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__ANY_ATTRIBUTE ) ; tExtensionEClass = createEClass ( TEXTENSION ) ; createEAttribute ( tExtensionEClass , TEXTENSION__MUST_UNDERSTAND ) ; createEAttribute ( tExtensionEClass , TEXTENSION__NAMESPACE ) ; tExtensionsEClass = createEClass ( TEXTENSIONS ) ; createEReference ( tExtensionsEClass , TEXTENSIONS__EXTENSION ) ; tFromEClass = createEClass ( TFROM ) ; createEReference ( tFromEClass , TFROM__ARGUMENT ) ; createEReference ( tFromEClass , TFROM__LITERAL ) ; createEAttribute ( tFromEClass , TFROM__EXPRESSION_LANGUAGE ) ; createEAttribute ( tFromEClass , TFROM__LOGICAL_PEOPLE_GROUP ) ; tGenericHumanRoleEClass = createEClass ( TGENERIC_HUMAN_ROLE ) ; createEReference ( tGenericHumanRoleEClass , TGENERIC_HUMAN_ROLE__FROM ) ; tGrouplistEClass = createEClass ( TGROUPLIST ) ; createEAttribute ( tGrouplistEClass , TGROUPLIST__GROUP ) ; tHumanInteractionsEClass = createEClass ( THUMAN_INTERACTIONS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__EXTENSIONS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__IMPORT ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__LOGICAL_PEOPLE_GROUPS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__TASKS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__NOTIFICATIONS ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__EXPRESSION_LANGUAGE ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__QUERY_LANGUAGE ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__TARGET_NAMESPACE ) ; tImportEClass = createEClass ( TIMPORT ) ; createEAttribute ( tImportEClass , TIMPORT__IMPORT_TYPE ) ; createEAttribute ( tImportEClass , TIMPORT__LOCATION ) ; createEAttribute ( tImportEClass , TIMPORT__NAMESPACE ) ; tLiteralEClass = createEClass ( TLITERAL ) ; createEAttribute ( tLiteralEClass , TLITERAL__MIXED ) ; createEAttribute ( tLiteralEClass , TLITERAL__ANY ) ; createEAttribute ( tLiteralEClass , TLITERAL__ANY_ATTRIBUTE ) ; tLocalNotificationEClass = createEClass ( TLOCAL_NOTIFICATION ) ; createEReference ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__PRIORITY ) ; createEReference ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__PEOPLE_ASSIGNMENTS ) ; createEAttribute ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__REFERENCE ) ; tLogicalPeopleGroupEClass = createEClass ( TLOGICAL_PEOPLE_GROUP ) ; createEReference ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__PARAMETER ) ; createEAttribute ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__NAME ) ; createEAttribute ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__REFERENCE ) ; tLogicalPeopleGroupsEClass = createEClass ( TLOGICAL_PEOPLE_GROUPS ) ; createEReference ( tLogicalPeopleGroupsEClass , TLOGICAL_PEOPLE_GROUPS__LOGICAL_PEOPLE_GROUP ) ; tNotificationEClass = createEClass ( TNOTIFICATION ) ; createEReference ( tNotificationEClass , TNOTIFICATION__INTERFACE ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PRIORITY ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PEOPLE_ASSIGNMENTS ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PRESENTATION_ELEMENTS ) ; createEReference ( tNotificationEClass , TNOTIFICATION__RENDERINGS ) ; createEAttribute ( tNotificationEClass , TNOTIFICATION__NAME ) ; tNotificationInterfaceEClass = createEClass ( TNOTIFICATION_INTERFACE ) ; createEAttribute ( tNotificationInterfaceEClass , TNOTIFICATION_INTERFACE__OPERATION ) ; createEAttribute ( tNotificationInterfaceEClass , TNOTIFICATION_INTERFACE__PORT_TYPE ) ; tNotificationsEClass = createEClass ( TNOTIFICATIONS ) ; createEReference ( tNotificationsEClass , TNOTIFICATIONS__NOTIFICATION ) ; tOrganizationalEntityEClass = createEClass ( TORGANIZATIONAL_ENTITY ) ; createEReference ( tOrganizationalEntityEClass , TORGANIZATIONAL_ENTITY__USERS ) ; createEReference ( tOrganizationalEntityEClass , TORGANIZATIONAL_ENTITY__GROUPS ) ; tParameterEClass = createEClass ( TPARAMETER ) ; createEAttribute ( tParameterEClass , TPARAMETER__NAME ) ; createEAttribute ( tParameterEClass , TPARAMETER__TYPE ) ; tPeopleAssignmentsEClass = createEClass ( TPEOPLE_ASSIGNMENTS ) ; createEAttribute ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__GENERIC_HUMAN_ROLE ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__POTENTIAL_OWNERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__EXCLUDED_OWNERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__TASK_INITIATOR ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__TASK_STAKEHOLDERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__BUSINESS_ADMINISTRATORS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__RECIPIENTS ) ; tPresentationElementsEClass = createEClass ( TPRESENTATION_ELEMENTS ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__NAME ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__PRESENTATION_PARAMETERS ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__SUBJECT ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__DESCRIPTION ) ; tPresentationParameterEClass = createEClass ( TPRESENTATION_PARAMETER ) ; tPresentationParametersEClass = createEClass ( TPRESENTATION_PARAMETERS ) ; createEReference ( tPresentationParametersEClass , TPRESENTATION_PARAMETERS__PRESENTATION_PARAMETER ) ; createEAttribute ( tPresentationParametersEClass , TPRESENTATION_PARAMETERS__EXPRESSION_LANGUAGE ) ; tPriorityEClass = createEClass ( TPRIORITY ) ; tQueryEClass = createEClass ( TQUERY ) ; createEAttribute ( tQueryEClass , TQUERY__MIXED ) ; createEAttribute ( tQueryEClass , TQUERY__ANY ) ; createEAttribute ( tQueryEClass , TQUERY__PART ) ; createEAttribute ( tQueryEClass , TQUERY__QUERY_LANGUAGE ) ; createEAttribute ( tQueryEClass , TQUERY__ANY_ATTRIBUTE ) ; tReassignmentEClass = createEClass ( TREASSIGNMENT ) ; createEReference ( tReassignmentEClass , TREASSIGNMENT__POTENTIAL_OWNERS ) ; tRenderingEClass = createEClass ( TRENDERING ) ; createEAttribute ( tRenderingEClass , TRENDERING__TYPE ) ; tRenderingsEClass = createEClass ( TRENDERINGS ) ; createEReference ( tRenderingsEClass , TRENDERINGS__RENDERING ) ; tTaskEClass = createEClass ( TTASK ) ; createEReference ( tTaskEClass , TTASK__INTERFACE ) ; createEReference ( tTaskEClass , TTASK__PRIORITY ) ; createEReference ( tTaskEClass , TTASK__PEOPLE_ASSIGNMENTS ) ; createEReference ( tTaskEClass , TTASK__DELEGATION ) ; createEReference ( tTaskEClass , TTASK__PRESENTATION_ELEMENTS ) ; createEReference ( tTaskEClass , TTASK__OUTCOME ) ; createEReference ( tTaskEClass , TTASK__SEARCH_BY ) ; createEReference ( tTaskEClass , TTASK__RENDERINGS ) ; createEReference ( tTaskEClass , TTASK__DEADLINES ) ; createEAttribute ( tTaskEClass , TTASK__NAME ) ; tTaskInterfaceEClass = createEClass ( TTASK_INTERFACE ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__OPERATION ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__PORT_TYPE ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__RESPONSE_OPERATION ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__RESPONSE_PORT_TYPE ) ; tTasksEClass = createEClass ( TTASKS ) ; createEReference ( tTasksEClass , TTASKS__TASK ) ; tTextEClass = createEClass ( TTEXT ) ; createEAttribute ( tTextEClass , TTEXT__LANG ) ; tToPartEClass = createEClass ( TTO_PART ) ; createEAttribute ( tToPartEClass , TTO_PART__EXPRESSION_LANGUAGE ) ; createEAttribute ( tToPartEClass , TTO_PART__NAME ) ; tToPartsEClass = createEClass ( TTO_PARTS ) ; createEReference ( tToPartsEClass , TTO_PARTS__TO_PART ) ; tUserlistEClass = createEClass ( TUSERLIST ) ; createEAttribute ( tUserlistEClass , TUSERLIST__USER ) ; tBooleanEEnum = createEEnum ( TBOOLEAN ) ; tPotentialDelegateesEEnum = createEEnum ( TPOTENTIAL_DELEGATEES ) ; tBooleanObjectEDataType = createEDataType ( TBOOLEAN_OBJECT ) ; tGroupEDataType = createEDataType ( TGROUP ) ; tPotentialDelegateesObjectEDataType = createEDataType ( TPOTENTIAL_DELEGATEES_OBJECT ) ; tUserEDataType = createEDataType ( TUSER ) ; }
Susankha/developer-studio | public void initializePackageContents ( ) { if ( isInitialized ) return ; isInitialized = true ; setName ( eNAME ) ; setNsPrefix ( eNS_PREFIX ) ; setNsURI ( eNS_URI ) ; XMLTypePackage theXMLTypePackage = ( XMLTypePackage ) EPackage . Registry . INSTANCE . getEPackage ( XMLTypePackage . eNS_URI ) ; XMLNamespacePackage theXMLNamespacePackage = ( XMLNamespacePackage ) EPackage . Registry . INSTANCE . getEPackage ( XMLNamespacePackage . eNS_URI ) ; tArgumentEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tBooleanExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tDeadlineEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDeadlineExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tDeadlinesEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDelegationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDescriptionEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tDurationExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tEscalationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tExtensionEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tExtensionsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tFromEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tGenericHumanRoleEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tHumanInteractionsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tImportEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLocalNotificationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLogicalPeopleGroupEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLogicalPeopleGroupsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationInterfaceEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tParameterEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tPeopleAssignmentsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPresentationElementsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPresentationParameterEClass . getESuperTypes ( ) . add ( this . getTParameter ( ) ) ; tPresentationParametersEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPriorityEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tReassignmentEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tRenderingEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tRenderingsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTaskEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTaskInterfaceEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTasksEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTextEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tToPartEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tToPartsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; initEClass ( documentRootEClass , DocumentRoot . class , " DocumentRoot " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getDocumentRoot_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , null , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_XMLNSPrefixMap ( ) , ecorePackage . getEStringToStringMapEntry ( ) , null , " xMLNSPrefixMap " , null , 0 , - 1 , null , IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_XSISchemaLocation ( ) , ecorePackage . getEStringToStringMapEntry ( ) , null , " xSISchemaLocation " , null , 0 , - 1 , null , IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_BusinessAdministrators ( ) , this . getTGenericHumanRole ( ) , null , " businessAdministrators " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_ExcludedOwners ( ) , this . getTGenericHumanRole ( ) , null , " excludedOwners " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getDocumentRoot_Group ( ) , this . getTGroup ( ) , " group " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Groups ( ) , this . getTGrouplist ( ) , null , " groups " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_HumanInteractions ( ) , this . getTHumanInteractions ( ) , null , " humanInteractions " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Import ( ) , this . getTImport ( ) , null , " import " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_LogicalPeopleGroups ( ) , this . getTLogicalPeopleGroups ( ) , null , " logicalPeopleGroups " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Notifications ( ) , this . getTNotifications ( ) , null , " notifications " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_OrganizationalEntity ( ) , this . getTOrganizationalEntity ( ) , null , " organizationalEntity " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Recipients ( ) , this . getTGenericHumanRole ( ) , null , " recipients " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Task ( ) , this . getTTask ( ) , null , " task " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_TaskInitiator ( ) , this . getTGenericHumanRole ( ) , null , " taskInitiator " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Tasks ( ) , this . getTTasks ( ) , null , " tasks " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_TaskStakeholders ( ) , this . getTGenericHumanRole ( ) , null , " taskStakeholders " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getDocumentRoot_User ( ) , this . getTUser ( ) , " user " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Users ( ) , this . getTUserlist ( ) , null , " users " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEClass ( tArgumentEClass , TArgument . class , " TArgument " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTArgument_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TArgument . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTArgument_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 0 , 1 , TArgument . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tBooleanExprEClass , TBooleanExpr . class , " TBooleanExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tDeadlineEClass , TDeadline . class , " TDeadline " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDeadline_For ( ) , this . getTDurationExpr ( ) , null , " for " , null , 0 , 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadline_Until ( ) , this . getTDeadlineExpr ( ) , null , " until " , null , 0 , 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadline_Escalation ( ) , this . getTEscalation ( ) , null , " escalation " , null , 0 , - 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDeadlineExprEClass , TDeadlineExpr . class , " TDeadlineExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tDeadlinesEClass , TDeadlines . class , " TDeadlines " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDeadlines_StartDeadline ( ) , this . getTDeadline ( ) , null , " startDeadline " , null , 0 , - 1 , TDeadlines . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadlines_CompletionDeadline ( ) , this . getTDeadline ( ) , null , " completionDeadline " , null , 0 , - 1 , TDeadlines . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDelegationEClass , TDelegation . class , " TDelegation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDelegation_From ( ) , this . getTFrom ( ) , null , " from " , null , 0 , 1 , TDelegation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDelegation_PotentialDelegatees ( ) , this . getTPotentialDelegatees ( ) , " potentialDelegatees " , null , 1 , 1 , TDelegation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDescriptionEClass , TDescription . class , " TDescription " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTDescription_ContentType ( ) , theXMLTypePackage . getString ( ) , " contentType " , null , 0 , 1 , TDescription . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDescription_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TDescription . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDocumentationEClass , TDocumentation . class , " TDocumentation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTDocumentation_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TDocumentation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDocumentation_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TDocumentation . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDocumentation_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TDocumentation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDurationExprEClass , TDurationExpr . class , " TDurationExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tEscalationEClass , TEscalation . class , " TEscalation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTEscalation_Condition ( ) , this . getTBooleanExpr ( ) , null , " condition " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_ToParts ( ) , this . getTToParts ( ) , null , " toParts " , null , 0 , - 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_LocalNotification ( ) , this . getTLocalNotification ( ) , null , " localNotification " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_Reassignment ( ) , this . getTReassignment ( ) , null , " reassignment " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTEscalation_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExpressionEClass , TExpression . class , " TExpression " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExpression_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExpression . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensibleElementsEClass , TExtensibleElements . class , " TExtensibleElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTExtensibleElements_Documentation ( ) , this . getTDocumentation ( ) , null , " documentation " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleElements_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleElements_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensibleMixedContentElementsEClass , TExtensibleMixedContentElements . class , " TExtensibleMixedContentElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExtensibleMixedContentElements_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TExtensibleMixedContentElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTExtensibleMixedContentElements_Documentation ( ) , this . getTDocumentation ( ) , null , " documentation " , null , 0 , - 1 , TExtensibleMixedContentElements . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleMixedContentElements_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExtensibleMixedContentElements . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleMixedContentElements_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExtensibleMixedContentElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensionEClass , TExtension . class , " TExtension " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExtension_MustUnderstand ( ) , this . getTBoolean ( ) , " mustUnderstand " , null , 1 , 1 , TExtension . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtension_Namespace ( ) , theXMLTypePackage . getAnyURI ( ) , " namespace " , null , 1 , 1 , TExtension . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensionsEClass , TExtensions . class , " TExtensions " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTExtensions_Extension ( ) , this . getTExtension ( ) , null , " extension " , null , 1 , - 1 , TExtensions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tFromEClass , TFrom . class , " TFrom " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTFrom_Argument ( ) , this . getTArgument ( ) , null , " argument " , null , 0 , - 1 , TFrom . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTFrom_Literal ( ) , this . getTLiteral ( ) , null , " literal " , null , 0 , 1 , TFrom . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTFrom_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TFrom . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTFrom_LogicalPeopleGroup ( ) , theXMLTypePackage . getQName ( ) , " logicalPeopleGroup " , null , 0 , 1 , TFrom . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tGenericHumanRoleEClass , TGenericHumanRole . class , " TGenericHumanRole " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTGenericHumanRole_From ( ) , this . getTFrom ( ) , null , " from " , null , 1 , 1 , TGenericHumanRole . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tGrouplistEClass , TGrouplist . class , " TGrouplist " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTGrouplist_Group ( ) , this . getTGroup ( ) , " group " , null , 0 , - 1 , TGrouplist . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tHumanInteractionsEClass , THumanInteractions . class , " THumanInteractions " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTHumanInteractions_Extensions ( ) , this . getTExtensions ( ) , null , " extensions " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Import ( ) , this . getTImport ( ) , null , " import " , null , 0 , - 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_LogicalPeopleGroups ( ) , this . getTLogicalPeopleGroups ( ) , null , " logicalPeopleGroups " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Tasks ( ) , this . getTTasks ( ) , null , " tasks " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Notifications ( ) , this . getTNotifications ( ) , null , " notifications " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_QueryLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " queryLanguage " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_TargetNamespace ( ) , theXMLTypePackage . getAnyURI ( ) , " targetNamespace " , null , 1 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tImportEClass , TImport . class , " TImport " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTImport_ImportType ( ) , theXMLTypePackage . getAnyURI ( ) , " importType " , null , 1 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTImport_Location ( ) , theXMLTypePackage . getAnyURI ( ) , " location " , null , 0 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTImport_Namespace ( ) , theXMLTypePackage . getAnyURI ( ) , " namespace " , null , 0 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLiteralEClass , TLiteral . class , " TLiteral " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTLiteral_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TLiteral . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLiteral_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TLiteral . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLiteral_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TLiteral . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLocalNotificationEClass , TLocalNotification . class , " TLocalNotification " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLocalNotification_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTLocalNotification_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 0 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLocalNotification_Reference ( ) , theXMLTypePackage . getQName ( ) , " reference " , null , 1 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLogicalPeopleGroupEClass , TLogicalPeopleGroup . class , " TLogicalPeopleGroup " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLogicalPeopleGroup_Parameter ( ) , this . getTParameter ( ) , null , " parameter " , null , 0 , - 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLogicalPeopleGroup_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLogicalPeopleGroup_Reference ( ) , theXMLTypePackage . getNCName ( ) , " reference " , null , 0 , 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLogicalPeopleGroupsEClass , TLogicalPeopleGroups . class , " TLogicalPeopleGroups " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLogicalPeopleGroups_LogicalPeopleGroup ( ) , this . getTLogicalPeopleGroup ( ) , null , " logicalPeopleGroup " , null , 1 , - 1 , TLogicalPeopleGroups . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationEClass , TNotification . class , " TNotification " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTNotification_Interface ( ) , this . getTNotificationInterface ( ) , null , " interface " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_PresentationElements ( ) , this . getTPresentationElements ( ) , null , " presentationElements " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_Renderings ( ) , this . getTRenderings ( ) , null , " renderings " , null , 0 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTNotification_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationInterfaceEClass , TNotificationInterface . class , " TNotificationInterface " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTNotificationInterface_Operation ( ) , theXMLTypePackage . getNCName ( ) , " operation " , null , 1 , 1 , TNotificationInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTNotificationInterface_PortType ( ) , theXMLTypePackage . getQName ( ) , " portType " , null , 1 , 1 , TNotificationInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationsEClass , TNotifications . class , " TNotifications " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTNotifications_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 1 , - 1 , TNotifications . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tOrganizationalEntityEClass , TOrganizationalEntity . class , " TOrganizationalEntity " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTOrganizationalEntity_Users ( ) , this . getTUserlist ( ) , null , " users " , null , 0 , 1 , TOrganizationalEntity . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTOrganizationalEntity_Groups ( ) , this . getTGrouplist ( ) , null , " groups " , null , 0 , 1 , TOrganizationalEntity . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tParameterEClass , TParameter . class , " TParameter " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTParameter_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TParameter . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTParameter_Type ( ) , theXMLTypePackage . getQName ( ) , " type " , null , 1 , 1 , TParameter . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPeopleAssignmentsEClass , TPeopleAssignments . class , " TPeopleAssignments " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTPeopleAssignments_GenericHumanRole ( ) , ecorePackage . getEFeatureMapEntry ( ) , " genericHumanRole " , null , 0 , - 1 , TPeopleAssignments . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_ExcludedOwners ( ) , this . getTGenericHumanRole ( ) , null , " excludedOwners " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_TaskInitiator ( ) , this . getTGenericHumanRole ( ) , null , " taskInitiator " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_TaskStakeholders ( ) , this . getTGenericHumanRole ( ) , null , " taskStakeholders " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_BusinessAdministrators ( ) , this . getTGenericHumanRole ( ) , null , " businessAdministrators " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_Recipients ( ) , this . getTGenericHumanRole ( ) , null , " recipients " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEClass ( tPresentationElementsEClass , TPresentationElements . class , " TPresentationElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTPresentationElements_Name ( ) , this . getTText ( ) , null , " name " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_PresentationParameters ( ) , this . getTPresentationParameters ( ) , null , " presentationParameters " , null , 0 , 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_Subject ( ) , this . getTText ( ) , null , " subject " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_Description ( ) , this . getTDescription ( ) , null , " description " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPresentationParameterEClass , TPresentationParameter . class , " TPresentationParameter " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tPresentationParametersEClass , TPresentationParameters . class , " TPresentationParameters " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTPresentationParameters_PresentationParameter ( ) , this . getTPresentationParameter ( ) , null , " presentationParameter " , null , 1 , - 1 , TPresentationParameters . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTPresentationParameters_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TPresentationParameters . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPriorityEClass , TPriority . class , " TPriority " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tQueryEClass , TQuery . class , " TQuery " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTQuery_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TQuery . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_Part ( ) , theXMLTypePackage . getAnySimpleType ( ) , " part " , null , 0 , 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_QueryLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " queryLanguage " , null , 0 , 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tReassignmentEClass , TReassignment . class , " TReassignment " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTReassignment_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 1 , 1 , TReassignment . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tRenderingEClass , TRendering . class , " TRendering " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTRendering_Type ( ) , theXMLTypePackage . getQName ( ) , " type " , null , 1 , 1 , TRendering . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tRenderingsEClass , TRenderings . class , " TRenderings " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTRenderings_Rendering ( ) , this . getTRendering ( ) , null , " rendering " , null , 1 , - 1 , TRenderings . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTaskEClass , TTask . class , " TTask " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTTask_Interface ( ) , this . getTTaskInterface ( ) , null , " interface " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Delegation ( ) , this . getTDelegation ( ) , null , " delegation " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_PresentationElements ( ) , this . getTPresentationElements ( ) , null , " presentationElements " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Outcome ( ) , this . getTQuery ( ) , null , " outcome " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_SearchBy ( ) , this . getTExpression ( ) , null , " searchBy " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Renderings ( ) , this . getTRenderings ( ) , null , " renderings " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Deadlines ( ) , this . getTDeadlines ( ) , null , " deadlines " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTask_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTaskInterfaceEClass , TTaskInterface . class , " TTaskInterface " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTTaskInterface_Operation ( ) , theXMLTypePackage . getNCName ( ) , " operation " , null , 1 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_PortType ( ) , theXMLTypePackage . getQName ( ) , " portType " , null , 1 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_ResponseOperation ( ) , theXMLTypePackage . getNCName ( ) , " responseOperation " , null , 0 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_ResponsePortType ( ) , theXMLTypePackage . getQName ( ) , " responsePortType " , null , 0 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTasksEClass , TTasks . class , " TTasks " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTTasks_Task ( ) , this . getTTask ( ) , null , " task " , null , 1 , - 1 , TTasks . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTextEClass , TText . class , " TText " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTText_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TText . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tToPartEClass , TToPart . class , " TToPart " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTToPart_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TToPart . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTToPart_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TToPart . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tToPartsEClass , TToParts . class , " TToParts " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTToParts_ToPart ( ) , this . getTToPart ( ) , null , " toPart " , null , 1 , - 1 , TToParts . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tUserlistEClass , TUserlist . class , " TUserlist " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTUserlist_User ( ) , this . getTUser ( ) , " user " , null , 0 , - 1 , TUserlist . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEEnum ( tBooleanEEnum , TBoolean . class , " TBoolean " ) ; addEEnumLiteral ( tBooleanEEnum , TBoolean . YES ) ; addEEnumLiteral ( tBooleanEEnum , TBoolean . NO ) ; initEEnum ( tPotentialDelegateesEEnum , TPotentialDelegatees . class , " TPotentialDelegatees " ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . ANYBODY ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . NOBODY ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . POTENTIAL_OWNERS ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . OTHER ) ; initEDataType ( tBooleanObjectEDataType , TBoolean . class , " TBooleanObject " , IS_SERIALIZABLE , IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tGroupEDataType , String . class , " TGroup " , IS_SERIALIZABLE , ! IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tPotentialDelegateesObjectEDataType , TPotentialDelegatees . class , " TPotentialDelegateesObject " , IS_SERIALIZABLE , IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tUserEDataType , String . class , " TUser " , IS_SERIALIZABLE , ! IS_GENERATED_INSTANCE_CLASS ) ; createResource ( eNS_URI ) ; createExtendedMetaDataAnnotations ( ) ; }
Susankha/developer-studio | protected void createExtendedMetaDataAnnotations ( ) { String source = " http : // / org / eclipse / emf / ecore / util / ExtendedMetaData " ; addAnnotation ( documentRootEClass , source , new String [ ] { " name " , " " , " kind " , " mixed " } ) ; addAnnotation ( getDocumentRoot_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getDocumentRoot_XMLNSPrefixMap ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " xmlns : prefix " } ) ; addAnnotation ( getDocumentRoot_XSISchemaLocation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " xsi : schemaLocation " } ) ; addAnnotation ( getDocumentRoot_BusinessAdministrators ( ) , source , new String [ ] { " kind " , " element " , " name " , " businessAdministrators " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_ExcludedOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " excludedOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Group ( ) , source , new String [ ] { " kind " , " element " , " name " , " group " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Groups ( ) , source , new String [ ] { " kind " , " element " , " name " , " groups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_HumanInteractions ( ) , source , new String [ ] { " kind " , " element " , " name " , " humanInteractions " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Import ( ) , source , new String [ ] { " kind " , " element " , " name " , " import " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_LogicalPeopleGroups ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Notifications ( ) , source , new String [ ] { " kind " , " element " , " name " , " notifications " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_OrganizationalEntity ( ) , source , new String [ ] { " kind " , " element " , " name " , " organizationalEntity " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Recipients ( ) , source , new String [ ] { " kind " , " element " , " name " , " recipients " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Task ( ) , source , new String [ ] { " kind " , " element " , " name " , " task " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_TaskInitiator ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskInitiator " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Tasks ( ) , source , new String [ ] { " kind " , " element " , " name " , " tasks " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_TaskStakeholders ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskStakeholders " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_User ( ) , source , new String [ ] { " kind " , " element " , " name " , " user " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Users ( ) , source , new String [ ] { " kind " , " element " , " name " , " users " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tArgumentEClass , source , new String [ ] { " name " , " tArgument " , " kind " , " mixed " } ) ; addAnnotation ( getTArgument_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTArgument_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tBooleanEEnum , source , new String [ ] { " name " , " tBoolean " } ) ; addAnnotation ( tBooleanExprEClass , source , new String [ ] { " name " , " tBoolean - expr " , " kind " , " mixed " } ) ; addAnnotation ( tBooleanObjectEDataType , source , new String [ ] { " name " , " tBoolean : Object " , " baseType " , " tBoolean " } ) ; addAnnotation ( tDeadlineEClass , source , new String [ ] { " name " , " tDeadline " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDeadline_For ( ) , source , new String [ ] { " kind " , " element " , " name " , " for " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadline_Until ( ) , source , new String [ ] { " kind " , " element " , " name " , " until " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadline_Escalation ( ) , source , new String [ ] { " kind " , " element " , " name " , " escalation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tDeadlineExprEClass , source , new String [ ] { " name " , " tDeadline - expr " , " kind " , " mixed " } ) ; addAnnotation ( tDeadlinesEClass , source , new String [ ] { " name " , " tDeadlines " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDeadlines_StartDeadline ( ) , source , new String [ ] { " kind " , " element " , " name " , " startDeadline " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadlines_CompletionDeadline ( ) , source , new String [ ] { " kind " , " element " , " name " , " completionDeadline " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tDelegationEClass , source , new String [ ] { " name " , " tDelegation " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDelegation_From ( ) , source , new String [ ] { " kind " , " element " , " name " , " from " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDelegation_PotentialDelegatees ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " potentialDelegatees " } ) ; addAnnotation ( tDescriptionEClass , source , new String [ ] { " name " , " tDescription " , " kind " , " mixed " } ) ; addAnnotation ( getTDescription_ContentType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " contentType " } ) ; addAnnotation ( getTDescription_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tDocumentationEClass , source , new String [ ] { " name " , " tDocumentation " , " kind " , " mixed " } ) ; addAnnotation ( getTDocumentation_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTDocumentation_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTDocumentation_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tDurationExprEClass , source , new String [ ] { " name " , " tDuration - expr " , " kind " , " mixed " } ) ; addAnnotation ( tEscalationEClass , source , new String [ ] { " name " , " tEscalation " , " kind " , " elementOnly " } ) ; addAnnotation ( getTEscalation_Condition ( ) , source , new String [ ] { " kind " , " element " , " name " , " condition " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_ToParts ( ) , source , new String [ ] { " kind " , " element " , " name " , " toParts " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_LocalNotification ( ) , source , new String [ ] { " kind " , " element " , " name " , " localNotification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Reassignment ( ) , source , new String [ ] { " kind " , " element " , " name " , " reassignment " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tExpressionEClass , source , new String [ ] { " name " , " tExpression " , " kind " , " mixed " } ) ; addAnnotation ( getTExpression_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTExpression_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTExpression_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTExpression_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 3" , " processing " , " lax " } ) ; addAnnotation ( tExtensibleElementsEClass , source , new String [ ] { " name " , " tExtensibleElements " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtensibleElements_Documentation ( ) , source , new String [ ] { " kind " , " element " , " name " , " documentation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTExtensibleElements_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTExtensibleElements_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " lax " } ) ; addAnnotation ( tExtensibleMixedContentElementsEClass , source , new String [ ] { " name " , " tExtensibleMixedContentElements " , " kind " , " mixed " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Documentation ( ) , source , new String [ ] { " kind " , " element " , " name " , " documentation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " skip " } ) ; addAnnotation ( getTExtensibleMixedContentElements_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 3" , " processing " , " lax " } ) ; addAnnotation ( tExtensionEClass , source , new String [ ] { " name " , " tExtension " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtension_MustUnderstand ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " mustUnderstand " } ) ; addAnnotation ( getTExtension_Namespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " namespace " } ) ; addAnnotation ( tExtensionsEClass , source , new String [ ] { " name " , " tExtensions " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtensions_Extension ( ) , source , new String [ ] { " kind " , " element " , " name " , " extension " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tFromEClass , source , new String [ ] { " name " , " tFrom " , " kind " , " mixed " } ) ; addAnnotation ( getTFrom_Argument ( ) , source , new String [ ] { " kind " , " element " , " name " , " argument " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTFrom_Literal ( ) , source , new String [ ] { " kind " , " element " , " name " , " literal " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTFrom_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTFrom_LogicalPeopleGroup ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " logicalPeopleGroup " } ) ; addAnnotation ( tGenericHumanRoleEClass , source , new String [ ] { " name " , " tGenericHumanRole " , " kind " , " elementOnly " } ) ; addAnnotation ( getTGenericHumanRole_From ( ) , source , new String [ ] { " kind " , " element " , " name " , " from " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tGroupEDataType , source , new String [ ] { " name " , " tGroup " , " baseType " , " http : // www . eclipse . org / emf / 2003 / XMLType # string " } ) ; addAnnotation ( tGrouplistEClass , source , new String [ ] { " name " , " tGrouplist " , " kind " , " elementOnly " } ) ; addAnnotation ( getTGrouplist_Group ( ) , source , new String [ ] { " kind " , " element " , " name " , " group " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tHumanInteractionsEClass , source , new String [ ] { " name " , " tHumanInteractions " , " kind " , " elementOnly " } ) ; addAnnotation ( getTHumanInteractions_Extensions ( ) , source , new String [ ] { " kind " , " element " , " name " , " extensions " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Import ( ) , source , new String [ ] { " kind " , " element " , " name " , " import " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_LogicalPeopleGroups ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Tasks ( ) , source , new String [ ] { " kind " , " element " , " name " , " tasks " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Notifications ( ) , source , new String [ ] { " kind " , " element " , " name " , " notifications " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTHumanInteractions_QueryLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " queryLanguage " } ) ; addAnnotation ( getTHumanInteractions_TargetNamespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " targetNamespace " } ) ; addAnnotation ( tImportEClass , source , new String [ ] { " name " , " tImport " , " kind " , " elementOnly " } ) ; addAnnotation ( getTImport_ImportType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " importType " } ) ; addAnnotation ( getTImport_Location ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " location " } ) ; addAnnotation ( getTImport_Namespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " namespace " } ) ; addAnnotation ( tLiteralEClass , source , new String [ ] { " name " , " tLiteral " , " kind " , " mixed " } ) ; addAnnotation ( getTLiteral_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTLiteral_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # any " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTLiteral_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " lax " } ) ; addAnnotation ( tLocalNotificationEClass , source , new String [ ] { " name " , " tLocalNotification " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLocalNotification_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLocalNotification_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLocalNotification_Reference ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " reference " } ) ; addAnnotation ( tLogicalPeopleGroupEClass , source , new String [ ] { " name " , " tLogicalPeopleGroup " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLogicalPeopleGroup_Parameter ( ) , source , new String [ ] { " kind " , " element " , " name " , " parameter " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLogicalPeopleGroup_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( getTLogicalPeopleGroup_Reference ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " reference " } ) ; addAnnotation ( tLogicalPeopleGroupsEClass , source , new String [ ] { " name " , " tLogicalPeopleGroups " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLogicalPeopleGroups_LogicalPeopleGroup ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroup " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tNotificationEClass , source , new String [ ] { " name " , " tNotification " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotification_Interface ( ) , source , new String [ ] { " kind " , " element " , " name " , " interface " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_PresentationElements ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationElements " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Renderings ( ) , source , new String [ ] { " kind " , " element " , " name " , " renderings " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tNotificationInterfaceEClass , source , new String [ ] { " name " , " tNotificationInterface " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotificationInterface_Operation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " operation " } ) ; addAnnotation ( getTNotificationInterface_PortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " portType " } ) ; addAnnotation ( tNotificationsEClass , source , new String [ ] { " name " , " tNotifications " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotifications_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tOrganizationalEntityEClass , source , new String [ ] { " name " , " tOrganizationalEntity " , " kind " , " elementOnly " } ) ; addAnnotation ( getTOrganizationalEntity_Users ( ) , source , new String [ ] { " kind " , " element " , " name " , " users " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTOrganizationalEntity_Groups ( ) , source , new String [ ] { " kind " , " element " , " name " , " groups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tParameterEClass , source , new String [ ] { " name " , " tParameter " , " kind " , " mixed " } ) ; addAnnotation ( getTParameter_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( getTParameter_Type ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " type " } ) ; addAnnotation ( tPeopleAssignmentsEClass , source , new String [ ] { " name " , " tPeopleAssignments " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPeopleAssignments_GenericHumanRole ( ) , source , new String [ ] { " kind " , " group " , " name " , " GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_ExcludedOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " excludedOwners " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_TaskInitiator ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskInitiator " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_TaskStakeholders ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskStakeholders " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_BusinessAdministrators ( ) , source , new String [ ] { " kind " , " element " , " name " , " businessAdministrators " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_Recipients ( ) , source , new String [ ] { " kind " , " element " , " name " , " recipients " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( tPotentialDelegateesEEnum , source , new String [ ] { " name " , " tPotentialDelegatees " } ) ; addAnnotation ( tPotentialDelegateesObjectEDataType , source , new String [ ] { " name " , " tPotentialDelegatees : Object " , " baseType " , " tPotentialDelegatees " } ) ; addAnnotation ( tPresentationElementsEClass , source , new String [ ] { " name " , " tPresentationElements " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPresentationElements_Name ( ) , source , new String [ ] { " kind " , " element " , " name " , " name " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_PresentationParameters ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationParameters " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_Subject ( ) , source , new String [ ] { " kind " , " element " , " name " , " subject " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_Description ( ) , source , new String [ ] { " kind " , " element " , " name " , " description " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tPresentationParameterEClass , source , new String [ ] { " name " , " tPresentationParameter " , " kind " , " mixed " } ) ; addAnnotation ( tPresentationParametersEClass , source , new String [ ] { " name " , " tPresentationParameters " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPresentationParameters_PresentationParameter ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationParameter " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationParameters_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( tPriorityEClass , source , new String [ ] { " name " , " tPriority " , " kind " , " mixed " } ) ; addAnnotation ( tQueryEClass , source , new String [ ] { " name " , " tQuery " , " kind " , " mixed " } ) ; addAnnotation ( getTQuery_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTQuery_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTQuery_Part ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " part " } ) ; addAnnotation ( getTQuery_QueryLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " queryLanguage " } ) ; addAnnotation ( getTQuery_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 4" , " processing " , " lax " } ) ; addAnnotation ( tReassignmentEClass , source , new String [ ] { " name " , " tReassignment " , " kind " , " elementOnly " } ) ; addAnnotation ( getTReassignment_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tRenderingEClass , source , new String [ ] { " name " , " tRendering " , " kind " , " elementOnly " } ) ; addAnnotation ( getTRendering_Type ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " type " } ) ; addAnnotation ( tRenderingsEClass , source , new String [ ] { " name " , " tRenderings " , " kind " , " elementOnly " } ) ; addAnnotation ( getTRenderings_Rendering ( ) , source , new String [ ] { " kind " , " element " , " name " , " rendering " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tTaskEClass , source , new String [ ] { " name " , " tTask " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTask_Interface ( ) , source , new String [ ] { " kind " , " element " , " name " , " interface " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Delegation ( ) , source , new String [ ] { " kind " , " element " , " name " , " delegation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_PresentationElements ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationElements " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Outcome ( ) , source , new String [ ] { " kind " , " element " , " name " , " outcome " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_SearchBy ( ) , source , new String [ ] { " kind " , " element " , " name " , " searchBy " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Renderings ( ) , source , new String [ ] { " kind " , " element " , " name " , " renderings " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Deadlines ( ) , source , new String [ ] { " kind " , " element " , " name " , " deadlines " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tTaskInterfaceEClass , source , new String [ ] { " name " , " tTaskInterface " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTaskInterface_Operation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " operation " } ) ; addAnnotation ( getTTaskInterface_PortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " portType " } ) ; addAnnotation ( getTTaskInterface_ResponseOperation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " responseOperation " } ) ; addAnnotation ( getTTaskInterface_ResponsePortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " responsePortType " } ) ; addAnnotation ( tTasksEClass , source , new String [ ] { " name " , " tTasks " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTasks_Task ( ) , source , new String [ ] { " kind " , " element " , " name " , " task " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tTextEClass , source , new String [ ] { " name " , " tText " , " kind " , " mixed " } ) ; addAnnotation ( getTText_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tToPartEClass , source , new String [ ] { " name " , " tToPart " , " kind " , " mixed " } ) ; addAnnotation ( getTToPart_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTToPart_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tToPartsEClass , source , new String [ ] { " name " , " tToParts " , " kind " , " elementOnly " } ) ; addAnnotation ( getTToParts_ToPart ( ) , source , new String [ ] { " kind " , " element " , " name " , " toPart " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tUserEDataType , source , new String [ ] { " name " , " tUser " , " baseType " , " http : // www . eclipse . org / emf / 2003 / XMLType # string " } ) ; addAnnotation ( tUserlistEClass , source , new String [ ] { " name " , " tUserlist " , " kind " , " elementOnly " } ) ; addAnnotation ( getTUserlist_User ( ) , source , new String [ ] { " kind " , " element " , " name " , " user " , " namespace " , " # # targetNamespace " } ) ; }
scrutmydocs/scrutmydocs | public AbstractApiTest ( ) { hostname = System . getProperty ( " scrutmydocs . host " , BASE_URL_SERVER ) ; port = System . getProperty ( " scrutmydocs . port " , BASE_URL_PORT ) ; base_url = System . getProperty ( " scrutmydocs . url " , BASE_URL_SUFFIX ) ; }
scrutmydocs/scrutmydocs | @ Test public void asking_for_help ( ) throws Exception { logger . debug ( " Testing ▁ _ help ▁ entry ▁ point ▁ for ▁ { } ▁ api . " , getModuleApiUrl ( ) == null ? " / " : getModuleApiUrl ( ) ) ; RestResponseWelcome response = restTemplate . getForObject ( buildFullApiUrl ( " _ help " ) , RestResponseWelcome . class ) ; assertNotNull ( response ) ; assertTrue ( response . isOk ( ) ) ; assertNotNull ( response . getObject ( ) ) ; Welcome output = ( Welcome ) response . getObject ( ) ; assertNotNull ( output ) ; assertNotNull ( output . getApis ( ) ) ; assertTrue ( output . getApis ( ) . length > 0 ) ; logger . debug ( " { } ▁ _ help ▁ entry ▁ point ▁ provided ▁ { } ▁ hints . " , getModuleApiUrl ( ) == null ? " / " : getModuleApiUrl ( ) , output . getApis ( ) . length ) ; }
scrutmydocs/scrutmydocs | protected String buildFullApiUrl ( String append ) { StringBuffer sbf = new StringBuffer ( " http : // " ) ; sbf . append ( hostname ) ; sbf . append ( " : " ) ; sbf . append ( port ) ; sbf . append ( base_url ) ; if ( getModuleApiUrl ( ) != null ) sbf . append ( getModuleApiUrl ( ) ) ; if ( append != null ) sbf . append ( append ) ; return sbf . toString ( ) ; }
scrutmydocs/scrutmydocs | protected String buildFullApiUrl ( ) { return buildFullApiUrl ( null ) ; }
Cognifide/bobcat | @ Override public void setValue ( Object value ) { selectField . click ( ) ; List < WebElement > options = selectField . findElements ( By . cssSelector ( SELECT_OPTIONS_CSS ) ) ; options . stream ( ) . filter ( o -> value . toString ( ) . equals ( o . getText ( ) ) ) . findFirst ( ) . orElseThrow ( ( ) -> new NoSuchElementException ( String . format ( " Option ▁ with ▁ text ▁ % s ▁ not ▁ found " , value . toString ( ) ) ) ) . click ( ) ; }
Cognifide/bobcat | @ Override public String getLabel ( ) { return label . isEmpty ( ) ? " " : label . get ( 0 ) . getText ( ) ; }
Azure/azure-sdk-for-java | public DayOfWeek dayOfWeek ( ) { return this . dayOfWeek ; }
Azure/azure-sdk-for-java | public ScheduleEntry withDayOfWeek ( DayOfWeek dayOfWeek ) { this . dayOfWeek = dayOfWeek ; return this ; }
Azure/azure-sdk-for-java | public int startHourUtc ( ) { return this . startHourUtc ; }
Azure/azure-sdk-for-java | public ScheduleEntry withStartHourUtc ( int startHourUtc ) { this . startHourUtc = startHourUtc ; return this ; }
Azure/azure-sdk-for-java | public Duration maintenanceWindow ( ) { return this . maintenanceWindow ; }
Azure/azure-sdk-for-java | public ScheduleEntry withMaintenanceWindow ( Duration maintenanceWindow ) { this . maintenanceWindow = maintenanceWindow ; return this ; }
Azure/azure-sdk-for-java | public void validate ( ) { if ( dayOfWeek ( ) == null ) { throw LOGGER . logExceptionAsError ( new IllegalArgumentException ( " Missing ▁ required ▁ property ▁ dayOfWeek ▁ in ▁ model ▁ ScheduleEntry " ) ) ; } }
Azanor/thaumcraft-api | public ResearchEvent ( EntityPlayer player ) { this . player = player ; }
Azanor/thaumcraft-api | public EntityPlayer getPlayer ( ) { return player ; }
Azanor/thaumcraft-api | public Knowledge ( EntityPlayer player , EnumKnowledgeType type , ResearchCategory category , int amount ) { super ( player ) ; this . type = type ; this . category = category ; this . amount = amount ; }
Azanor/thaumcraft-api | public EnumKnowledgeType getType ( ) { return type ; }
Azanor/thaumcraft-api | public ResearchCategory getCategory ( ) { return category ; }
Azanor/thaumcraft-api | public int getAmount ( ) { return amount ; }
Azanor/thaumcraft-api | public Research ( EntityPlayer player , String researchKey ) { super ( player ) ; this . researchKey = researchKey ; }
Azanor/thaumcraft-api | public String getResearchKey ( ) { return researchKey ; }
Azanor/thaumcraft-api | @ Override public boolean isCancelable ( ) { return true ; }
shun634501730/java_source_cn | JSR_W ( ) { }
shun634501730/java_source_cn | public JSR_W ( InstructionHandle target ) { super ( com . sun . org . apache . bcel . internal . Constants . JSR_W , target ) ; length = 5 ; }
shun634501730/java_source_cn | public void dump ( DataOutputStream out ) throws IOException { index = getTargetOffset ( ) ; out . writeByte ( opcode ) ; out . writeInt ( index ) ; }
shun634501730/java_source_cn | protected void initFromFile ( ByteSequence bytes , boolean wide ) throws IOException { index = bytes . readInt ( ) ; length = 5 ; }
shun634501730/java_source_cn | public void accept ( Visitor v ) { v . visitStackProducer ( this ) ; v . visitBranchInstruction ( this ) ; v . visitJsrInstruction ( this ) ; v . visitJSR_W ( this ) ; }
dump247/aws-sdk-java | public UploadSigningCertificateRequest ( ) { }
dump247/aws-sdk-java | public UploadSigningCertificateRequest ( String certificateBody ) { setCertificateBody ( certificateBody ) ; }
dump247/aws-sdk-java | public void setUserName ( String userName ) { this . userName = userName ; }
dump247/aws-sdk-java | public String getUserName ( ) { return this . userName ; }
dump247/aws-sdk-java | public UploadSigningCertificateRequest withUserName ( String userName ) { setUserName ( userName ) ; return this ; }
dump247/aws-sdk-java | public void setCertificateBody ( String certificateBody ) { this . certificateBody = certificateBody ; }
dump247/aws-sdk-java | public String getCertificateBody ( ) { return this . certificateBody ; }
dump247/aws-sdk-java | public UploadSigningCertificateRequest withCertificateBody ( String certificateBody ) { setCertificateBody ( certificateBody ) ; return this ; }
dump247/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getUserName ( ) != null ) sb . append ( " UserName : ▁ " + getUserName ( ) + " , " ) ; if ( getCertificateBody ( ) != null ) sb . append ( " CertificateBody : ▁ " + getCertificateBody ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dump247/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof UploadSigningCertificateRequest == false ) return false ; UploadSigningCertificateRequest other = ( UploadSigningCertificateRequest ) obj ; if ( other . getUserName ( ) == null ^ this . getUserName ( ) == null ) return false ; if ( other . getUserName ( ) != null && other . getUserName ( ) . equals ( this . getUserName ( ) ) == false ) return false ; if ( other . getCertificateBody ( ) == null ^ this . getCertificateBody ( ) == null ) return false ; if ( other . getCertificateBody ( ) != null && other . getCertificateBody ( ) . equals ( this . getCertificateBody ( ) ) == false ) return false ; return true ; }
dump247/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getUserName ( ) == null ) ? 0 : getUserName ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getCertificateBody ( ) == null ) ? 0 : getCertificateBody ( ) . hashCode ( ) ) ; return hashCode ; }
dump247/aws-sdk-java | @ Override public UploadSigningCertificateRequest clone ( ) { return ( UploadSigningCertificateRequest ) super . clone ( ) ; }
is00hcw/parseq | public void reset ( ) { for ( ListLogger logger : _loggerMap . values ( ) ) { logger . reset ( ) ; } }
is00hcw/parseq | @ Override public ListLogger getLogger ( final String loggerName ) { ListLogger logger = _loggerMap . get ( loggerName ) ; if ( logger != null ) { return logger ; } final ListLogger newLogger = new ListLogger ( loggerName ) ; logger = _loggerMap . putIfAbsent ( loggerName , newLogger ) ; return logger == null ? newLogger : logger ; }
pippo1980/upns | public Configuration ( CTUApplicationContext applicationContext ) { super ( applicationContext ) ; }
pippo1980/upns | @ Override public String getName ( ) { return " classpath * : META - INF / sirius . upns . node . context . xml " ; }
statsbiblioteket/summa | ) public MUXFilterFeeder ( Configuration conf , PayloadQueue out ) { log . trace ( " Constructing ▁ MUXFilterFeeder " ) ; if ( out == null ) { throw new IllegalArgumentException ( " out ▁ queue ▁ must ▁ not ▁ be ▁ null " ) ; } this . out = out ; pusher = new PushFilter ( conf . getInt ( CONF_QUEUE_MAXPAYLOADS , DEFAULT_QUEUE_MAXPAYLOADS ) , conf . getInt ( CONF_QUEUE_MAXBYTES , DEFAULT_QUEUE_MAXBYTES ) ) ; if ( conf . valueExists ( CONF_QUEUE_OUT_LENGTH ) ) { log . warn ( String . format ( " The ▁ configuration ▁ contained ▁ the ▁ deprecated ▁ key ▁ % s . ▁ " + " Use ▁ % s ▁ instead " , CONF_QUEUE_OUT_LENGTH , MUXFilter . CONF_OUTQUEUE_MAXPAYLOADS ) ) ; } if ( conf . valueExists ( CONF_QUEUE_OUT_MAXBYTES ) ) { log . warn ( String . format ( " The ▁ configuration ▁ contained ▁ the ▁ deprecated ▁ key ▁ % s . ▁ Use ▁ % s ▁ instead " , CONF_QUEUE_OUT_MAXBYTES , MUXFilter . CONF_OUTQUEUE_MAXBYTES ) ) ; } filter = createFilter ( conf ) ; filter . setSource ( pusher ) ; filterName = conf . getString ( CONF_FILTER_NAME , " Feeder ( " + filter . getClass ( ) . getSimpleName ( ) + " ) " ) ; isFallback = conf . getBoolean ( CONF_FILTER_ISFALLBACK , isFallback ) ; List < String > baseList = conf . getStrings ( CONF_FILTER_BASES , ( List < String > ) null ) ; if ( baseList != null && ! ( baseList . size ( ) == 1 && " * " . equals ( baseList . get ( 0 ) ) ) ) { bases = new HashSet < > ( baseList ) ; } Thread t = new Thread ( this , filterName + " - " + this . hashCode ( ) + " ▁ daemon " ) ; t . setDaemon ( true ) ; t . start ( ) ; log . info ( " Constructed ▁ and ▁ activated ▁ " + this ) ; }
statsbiblioteket/summa | private ObjectFilter createFilter ( Configuration configuration ) { Class < ? extends ObjectFilter > filter = configuration . getClass ( CONF_FILTER_CLASS , ObjectFilter . class ) ; log . debug ( String . format ( " Got ▁ filter ▁ class ▁ % s . ▁ Commencing ▁ creation " , filter ) ) ; return Configuration . create ( filter , configuration ) ; }
statsbiblioteket/summa | public void queuePayload ( Payload payload ) { if ( log . isTraceEnabled ( ) ) { log . trace ( " Queueing ▁ " + payload + " ▁ in ▁ " + this ) ; } if ( ! accepts ( payload ) ) { throw new IllegalArgumentException ( String . format ( " % s ▁ does ▁ not ▁ accept ▁ % s " , this , payload ) ) ; } pusher . add ( payload ) ; }
statsbiblioteket/summa | public int getFreeSlots ( ) { return pusher . getFreeSlots ( ) ; }
statsbiblioteket/summa | public boolean accepts ( Payload payload ) { if ( bases == null ) { return true ; } if ( payload . getRecord ( ) == null ) { log . warn ( " A ▁ Payload ▁ without ▁ base ▁ was ▁ received ▁ in ▁ accepts ( " + payload + " ) ▁ in ▁ " + this ) ; return false ; } return bases . contains ( payload . getRecord ( ) . getBase ( ) ) ; }
statsbiblioteket/summa | public void signalEOF ( ) { log . debug ( " signalEOF ( ) ▁ entered ▁ for ▁ " + this ) ; pusher . signalEOF ( ) ; log . trace ( " signalEOF ( ) ▁ completed ▁ for ▁ " + this ) ; }
statsbiblioteket/summa | public boolean isFallback ( ) { return isFallback ; }
statsbiblioteket/summa | public boolean isEOFReached ( ) { return eofReached ; }
statsbiblioteket/summa | @ Override public String toString ( ) { return " MUXFilterFeeder ( " + filterName + " , ▁ " + filter + " , ▁ bases : ▁ " + ( bases == null ? " N / A " : Strings . join ( bases , " , ▁ " ) ) + " ) " ; }
statsbiblioteket/summa | @ Override public void run ( ) { try { while ( filter . hasNext ( ) ) { payloadCount ++ ; try { log . trace ( " Polling ▁ filter ▁ for ▁ next ▁ processes ▁ Payload " ) ; Payload next = filter . next ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " run ( ) ▁ got ▁ " + next ) ; } if ( next != null ) { try { log . trace ( " Offering ▁ payload ▁ to ▁ out ▁ queue ▁ in ▁ " + this ) ; out . put ( next ) ; log . trace ( " outQueue ▁ accepted ▁ Payload " ) ; } catch ( InterruptedException e ) { log . warn ( " Interrupted ▁ while ▁ trying ▁ to ▁ add ▁ " + next + " ▁ to ▁ outQueue ▁ in ▁ " + this + " . ▁ Retrying " ) ; } } } catch ( Exception e ) { log . warn ( String . format ( " Exception ▁ while ▁ calling ▁ next ▁ on ▁ filter ▁ ' % s ' ▁ in ▁ % s . ▁ Sleeping ▁ a ▁ bit , ▁ then ▁ retrying " , filter , this ) , e ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ex ) { log . warn ( " Interrupted ▁ while ▁ sleeping ▁ before ▁ next ▁ poll ▁ in ▁ " + this , ex ) ; } } } log . debug ( " Emptied ▁ " + filter + " ▁ after ▁ " + payloadCount + " ▁ Payloads " ) ; eofReached = true ; out . uninterruptablePut ( STOP ) ; } catch ( Exception e ) { log . error ( String . format ( " Got ▁ unexpected ▁ exception ▁ in ▁ run - method ▁ for ▁ ' % s ' " , this ) , e ) ; } }
statsbiblioteket/summa | public void close ( boolean success ) { filter . close ( success ) ; log . info ( " Closed ▁ feeder ▁ " + this ) ; }
michpetrov/hal.next | public UploadContentStep ( Resources resources ) { super ( resources . constants ( ) . uploadContent ( ) , resources . messages ( ) . noContent ( ) ) ; }
haikuowuya/android_system_code | public MatchingIterator ( int match , DTMAxisIterator source ) { _source = source ; _match = match ; }
haikuowuya/android_system_code | public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; }
haikuowuya/android_system_code | public DTMAxisIterator cloneIterator ( ) { try { final MatchingIterator clone = ( MatchingIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } }
haikuowuya/android_system_code | public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( node ) ; _position = 1 ; while ( ( node = _source . next ( ) ) != END && node != _match ) { _position ++ ; } } return this ; }
haikuowuya/android_system_code | public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; }
haikuowuya/android_system_code | public int next ( ) { return _source . next ( ) ; }
haikuowuya/android_system_code | public int getLast ( ) { if ( _last == - 1 ) { _last = _source . getLast ( ) ; } return _last ; }
haikuowuya/android_system_code | public int getPosition ( ) { return _position ; }
haikuowuya/android_system_code | public void setMark ( ) { _source . setMark ( ) ; }
haikuowuya/android_system_code | public void gotoMark ( ) { _source . gotoMark ( ) ; }
navalev/azure-sdk-for-java | public String provisioningState ( ) { return this . provisioningState ; }
navalev/azure-sdk-for-java | public String availabilityGroupName ( ) { return this . availabilityGroupName ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withAvailabilityGroupName ( String availabilityGroupName ) { this . availabilityGroupName = availabilityGroupName ; return this ; }
navalev/azure-sdk-for-java | public List < LoadBalancerConfiguration > loadBalancerConfigurations ( ) { return this . loadBalancerConfigurations ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withLoadBalancerConfigurations ( List < LoadBalancerConfiguration > loadBalancerConfigurations ) { this . loadBalancerConfigurations = loadBalancerConfigurations ; return this ; }
navalev/azure-sdk-for-java | public Boolean createDefaultAvailabilityGroupIfNotExist ( ) { return this . createDefaultAvailabilityGroupIfNotExist ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withCreateDefaultAvailabilityGroupIfNotExist ( Boolean createDefaultAvailabilityGroupIfNotExist ) { this . createDefaultAvailabilityGroupIfNotExist = createDefaultAvailabilityGroupIfNotExist ; return this ; }
navalev/azure-sdk-for-java | public Integer port ( ) { return this . port ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withPort ( Integer port ) { this . port = port ; return this ; }
JavaSaBr/jME3-SpaceShift-Editor | synchronized ( Event . class ) { EVENT_TYPE = new EventType < > ( SceneEvent . EVENT_TYPE , AssetComponentLoadedEvent . class . getSimpleName ( ) ) ; }
JavaSaBr/jME3-SpaceShift-Editor | public AssetComponentLoadedEvent ( @ NotNull Path assetFolder ) { super ( EVENT_TYPE ) ; setAssetFolder ( assetFolder ) ; }
JavaSaBr/jME3-SpaceShift-Editor | public @ NotNull Path getAssetFolder ( ) { return notNull ( get ( ASSET ) ) ; }
JavaSaBr/jME3-SpaceShift-Editor | public void setAssetFolder ( @ NotNull Path assetFolder ) { set ( ASSET , assetFolder ) ; }
nicolaferraro/camel | default CordaComponentBuilder configuration ( org . apache . camel . component . corda . CordaConfiguration configuration ) { doSetProperty ( " configuration " , configuration ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder bridgeErrorHandler ( boolean bridgeErrorHandler ) { doSetProperty ( " bridgeErrorHandler " , bridgeErrorHandler ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder pageSpecification ( net . corda . core . node . services . vault . PageSpecification pageSpecification ) { doSetProperty ( " pageSpecification " , pageSpecification ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder processSnapshot ( boolean processSnapshot ) { doSetProperty ( " processSnapshot " , processSnapshot ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder sort ( net . corda . core . node . services . vault . Sort sort ) { doSetProperty ( " sort " , sort ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder contractStateClass ( java . lang . Class < net . corda . core . contracts . ContractState > contractStateClass ) { doSetProperty ( " contractStateClass " , contractStateClass ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder flowLogicArguments ( java . lang . Object [ ] flowLogicArguments ) { doSetProperty ( " flowLogicArguments " , flowLogicArguments ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder flowLogicClass ( java . lang . Class < net . corda . core . flows . FlowLogic < java . lang . Object > > flowLogicClass ) { doSetProperty ( " flowLogicClass " , flowLogicClass ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder queryCriteria ( net . corda . core . node . services . vault . QueryCriteria queryCriteria ) { doSetProperty ( " queryCriteria " , queryCriteria ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder lazyStartProducer ( boolean lazyStartProducer ) { doSetProperty ( " lazyStartProducer " , lazyStartProducer ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder operation ( java . lang . String operation ) { doSetProperty ( " operation " , operation ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder autowiredEnabled ( boolean autowiredEnabled ) { doSetProperty ( " autowiredEnabled " , autowiredEnabled ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder password ( java . lang . String password ) { doSetProperty ( " password " , password ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder username ( java . lang . String username ) { doSetProperty ( " username " , username ) ; return this ; }
nicolaferraro/camel | @ Override protected CordaComponent buildConcreteComponent ( ) { return new CordaComponent ( ) ; }
nicolaferraro/camel | private org . apache . camel . component . corda . CordaConfiguration getOrCreateConfiguration ( org . apache . camel . component . corda . CordaComponent component ) { if ( component . getConfiguration ( ) == null ) { component . setConfiguration ( new org . apache . camel . component . corda . CordaConfiguration ( ) ) ; } return component . getConfiguration ( ) ; }
nicolaferraro/camel | @ Override protected boolean setPropertyOnComponent ( Component component , String name , Object value ) { switch ( name ) { case " configuration " : ( ( CordaComponent ) component ) . setConfiguration ( ( org . apache . camel . component . corda . CordaConfiguration ) value ) ; return true ; case " bridgeErrorHandler " : ( ( CordaComponent ) component ) . setBridgeErrorHandler ( ( boolean ) value ) ; return true ; case " pageSpecification " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setPageSpecification ( ( net . corda . core . node . services . vault . PageSpecification ) value ) ; return true ; case " processSnapshot " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setProcessSnapshot ( ( boolean ) value ) ; return true ; case " sort " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setSort ( ( net . corda . core . node . services . vault . Sort ) value ) ; return true ; case " contractStateClass " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setContractStateClass ( ( java . lang . Class ) value ) ; return true ; case " flowLogicArguments " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setFlowLogicArguments ( ( java . lang . Object [ ] ) value ) ; return true ; case " flowLogicClass " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setFlowLogicClass ( ( java . lang . Class ) value ) ; return true ; case " queryCriteria " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setQueryCriteria ( ( net . corda . core . node . services . vault . QueryCriteria ) value ) ; return true ; case " lazyStartProducer " : ( ( CordaComponent ) component ) . setLazyStartProducer ( ( boolean ) value ) ; return true ; case " operation " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setOperation ( ( java . lang . String ) value ) ; return true ; case " autowiredEnabled " : ( ( CordaComponent ) component ) . setAutowiredEnabled ( ( boolean ) value ) ; return true ; case " password " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setPassword ( ( java . lang . String ) value ) ; return true ; case " username " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setUsername ( ( java . lang . String ) value ) ; return true ; default : return false ; } }
wichtounet/jtheque-utils | JAVA_IO_TMP_DIR ( " java . io . tmpdir " ) { @ Override public String get ( ) { String value = super . get ( ) ; if ( ! value . endsWith ( File . separator ) ) { value += File . separator ; } FileUtils . createIfNotExists ( new File ( value ) ) ; return value ; } }
wichtounet/jtheque-utils | , USER_DIR ( " user . dir " ) { @ Override public String get ( ) { String value = super . get ( ) ; if ( ! value . endsWith ( File . separator ) ) { value += File . separator ; } return value ; } }
wichtounet/jtheque-utils | SystemProperty ( String name ) { this . name = name ; }
wichtounet/jtheque-utils | public String get ( ) { return AccessController . doPrivileged ( new PrivilegedAction < String > ( ) { @ Override public String run ( ) { return System . getProperty ( getName ( ) ) ; } } ) ; }
wichtounet/jtheque-utils | public final void set ( final String value ) { AccessController . doPrivileged ( new PrivilegedAction < String > ( ) { @ Override public String run ( ) { return System . setProperty ( getName ( ) , value ) ; } } ) ; }
wichtounet/jtheque-utils | public final String getName ( ) { return name ; }
millmanorama/autopsy | GlobalEditListPanel ( ) { tableModel = new KeywordTableModel ( ) ; initComponents ( ) ; customizeComponents ( ) ; }
millmanorama/autopsy | private void customizeComponents ( ) { newKeywordsButton . setToolTipText ( ( NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . customizeComponents . addWordToolTip " ) ) ) ; deleteWordButton . setToolTipText ( NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . customizeComponents . removeSelectedMsg " ) ) ; keywordTable . getParent ( ) . setBackground ( keywordTable . getBackground ( ) ) ; final int width = jScrollPane1 . getPreferredSize ( ) . width ; keywordTable . setAutoResizeMode ( JTable . AUTO_RESIZE_NEXT_COLUMN ) ; TableColumn column ; for ( int i = 0 ; i < keywordTable . getColumnCount ( ) ; i ++ ) { column = keywordTable . getColumnModel ( ) . getColumn ( i ) ; if ( i == 0 ) { column . setPreferredWidth ( ( ( int ) ( width * 0.90 ) ) ) ; } else { column . setPreferredWidth ( ( ( int ) ( width * 0.10 ) ) ) ; } } keywordTable . setCellSelectionEnabled ( false ) ; keywordTable . setRowSelectionAllowed ( true ) ; final ListSelectionModel lsm = keywordTable . getSelectionModel ( ) ; lsm . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent e ) { boolean canDelete = ! ( lsm . isSelectionEmpty ( ) || currentKeywordList . isEditable ( ) || IngestManager . getInstance ( ) . isIngestRunning ( ) ) ; boolean canEdit = canDelete && ( lsm . getMaxSelectionIndex ( ) == lsm . getMinSelectionIndex ( ) ) ; deleteWordButton . setEnabled ( canDelete ) ; editWordButton . setEnabled ( canEdit ) ; } } ) ; setButtonStates ( ) ; IngestManager . getInstance ( ) . addIngestJobEventListener ( new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { Object source = evt . getSource ( ) ; if ( source instanceof String && ( ( String ) source ) . equals ( " LOCAL " ) ) { EventQueue . invokeLater ( ( ) -> { setButtonStates ( ) ; } ) ; } } } ) ; }
millmanorama/autopsy | void setButtonStates ( ) { boolean isIngestRunning = IngestManager . getInstance ( ) . isIngestRunning ( ) ; boolean isListSelected = currentKeywordList != null ; ingestWarningLabel . setVisible ( isIngestRunning ) ; boolean canEditList = isListSelected && ! isIngestRunning ; ingestMessagesCheckbox . setEnabled ( canEditList ) ; ingestMessagesCheckbox . setSelected ( currentKeywordList != null && currentKeywordList . getIngestMessages ( ) ) ; boolean canAddWord = canEditList && ! currentKeywordList . isEditable ( ) ; newKeywordsButton . setEnabled ( canAddWord ) ; if ( ( currentKeywordList == null ) || ( currentKeywordList . getKeywords ( ) . isEmpty ( ) ) ) { deleteWordButton . setEnabled ( false ) ; editWordButton . setEnabled ( false ) ; } }
millmanorama/autopsy | ) private boolean addKeywordsAction ( String existingKeywords , boolean isLiteral , boolean isWholeWord ) { String keywordsToRedisplay = existingKeywords ; AddKeywordsDialog dialog = new AddKeywordsDialog ( ) ; int goodCount = 0 ; int dupeCount = 0 ; int badCount = 1 ; if ( ! existingKeywords . isEmpty ( ) ) { dialog . setTitle ( NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . editKeyword . title " ) ) ; } while ( badCount > 0 ) { dialog . setInitialKeywordList ( keywordsToRedisplay , isLiteral , isWholeWord ) ; dialog . display ( ) ; goodCount = 0 ; dupeCount = 0 ; badCount = 0 ; keywordsToRedisplay = " " ; boolean displayedBoundaryWarning = false ; if ( ! dialog . getKeywords ( ) . isEmpty ( ) ) { for ( String newWord : dialog . getKeywords ( ) ) { if ( newWord . isEmpty ( ) ) { continue ; } final Keyword keyword = new Keyword ( newWord , ! dialog . isKeywordRegex ( ) , dialog . isKeywordExact ( ) , currentKeywordList . getName ( ) , newWord ) ; if ( currentKeywordList . hasKeyword ( keyword ) ) { dupeCount ++ ; continue ; } if ( ( ! displayedBoundaryWarning ) && dialog . isKeywordRegex ( ) ) { if ( newWord . startsWith ( " ^ " ) || ( newWord . endsWith ( " $ " ) && ! newWord . endsWith ( " \\ $ " ) ) ) { KeywordSearchUtil . displayDialog ( NbBundle . getMessage ( this . getClass ( ) , " GlobalEditListPanel . warning . title " ) , NbBundle . getMessage ( this . getClass ( ) , " GlobalEditListPanel . warning . text " ) , KeywordSearchUtil . DIALOG_MESSAGE_TYPE . WARN ) ; displayedBoundaryWarning = true ; } } boolean valid = true ; try { Pattern . compile ( newWord ) ; } catch ( PatternSyntaxException ex1 ) { valid = false ; } catch ( IllegalArgumentException ex2 ) { valid = false ; } if ( ! valid ) { keywordsToRedisplay += newWord + " \n " ; badCount ++ ; continue ; } tableModel . addKeyword ( keyword ) ; goodCount ++ ; } XmlKeywordSearchList . getCurrent ( ) . addList ( currentKeywordList ) ; firePropertyChange ( OptionsPanelController . PROP_CHANGED , null , null ) ; if ( ( badCount > 0 ) || ( dupeCount > 0 ) ) { String summary = " " ; KeywordSearchUtil . DIALOG_MESSAGE_TYPE level = KeywordSearchUtil . DIALOG_MESSAGE_TYPE . INFO ; if ( goodCount > 0 ) { if ( goodCount > 1 ) { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordsAddedPlural . text " , goodCount ) + " \n " ; } else { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordsAdded . text " , goodCount ) + " \n " ; } } if ( dupeCount > 0 ) { if ( dupeCount > 1 ) { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordDupesSkippedPlural . text " , dupeCount ) + " \n " ; } else { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordDupesSkipped . text " , dupeCount ) + " \n " ; } level = KeywordSearchUtil . DIALOG_MESSAGE_TYPE . WARN ; } if ( badCount > 0 ) { if ( badCount > 1 ) { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordErrorsPlural . text " , badCount ) + " \n " ; } else { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordErrors . text " , badCount ) + " \n " ; } level = KeywordSearchUtil . DIALOG_MESSAGE_TYPE . ERROR ; } KeywordSearchUtil . displayDialog ( NbBundle . getMessage ( this . getClass ( ) , " GlobalEditListPanel . addKeywordResults . text " ) , summary , level ) ; } } } setFocusOnKeywordTextBox ( ) ; setButtonStates ( ) ; return ( goodCount >= 1 && dupeCount == 0 ) ; }
millmanorama/autopsy | private void deleteKeywordAction ( int [ ] selectedKeywords ) { tableModel . deleteSelected ( selectedKeywords ) ; XmlKeywordSearchList . getCurrent ( ) . addList ( currentKeywordList ) ; setButtonStates ( ) ; }
millmanorama/autopsy | private void initComponents ( ) { listEditorPanel = new javax . swing . JPanel ( ) ; jScrollPane1 = new javax . swing . JScrollPane ( ) ; keywordTable = new javax . swing . JTable ( ) ; ingestMessagesCheckbox = new javax . swing . JCheckBox ( ) ; keywordsLabel = new javax . swing . JLabel ( ) ; newKeywordsButton = new javax . swing . JButton ( ) ; deleteWordButton = new javax . swing . JButton ( ) ; editWordButton = new javax . swing . JButton ( ) ; ingestWarningLabel = new javax . swing . JLabel ( ) ; setMinimumSize ( new java . awt . Dimension ( 0 , 0 ) ) ; listEditorPanel . setMinimumSize ( new java . awt . Dimension ( 0 , 0 ) ) ; jScrollPane1 . setPreferredSize ( new java . awt . Dimension ( 340 , 300 ) ) ; keywordTable . setModel ( tableModel ) ; keywordTable . setAutoResizeMode ( javax . swing . JTable . AUTO_RESIZE_OFF ) ; keywordTable . setGridColor ( new java . awt . Color ( 153 , 153 , 153 ) ) ; keywordTable . setMaximumSize ( new java . awt . Dimension ( 30000 , 30000 ) ) ; keywordTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; jScrollPane1 . setViewportView ( keywordTable ) ; ingestMessagesCheckbox . setSelected ( true ) ; ingestMessagesCheckbox . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . ingestMessagesCheckbox . text " ) ) ; ingestMessagesCheckbox . setToolTipText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . ingestMessagesCheckbox . toolTipText " ) ) ; ingestMessagesCheckbox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ingestMessagesCheckboxActionPerformed ( evt ) ; } } ) ; keywordsLabel . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . keywordsLabel . text " ) ) ; newKeywordsButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / keywordsearch / add16 . png " ) ) ) ; newKeywordsButton . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . newKeywordsButton . text " ) ) ; newKeywordsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { newKeywordsButtonActionPerformed ( evt ) ; } } ) ; deleteWordButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / keywordsearch / delete16 . png " ) ) ) ; deleteWordButton . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . deleteWordButton . text " ) ) ; deleteWordButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { deleteWordButtonActionPerformed ( evt ) ; } } ) ; editWordButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / keywordsearch / edit16 . png " ) ) ) ; editWordButton . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . editWordButton . text " ) ) ; editWordButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editWordButtonActionPerformed ( evt ) ; } } ) ; ingestWarningLabel . setFont ( ingestWarningLabel . getFont ( ) . deriveFont ( ingestWarningLabel . getFont ( ) . getStyle ( ) & ~ java . awt . Font . BOLD , 11 ) ) ; ingestWarningLabel . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / modules / hashdatabase / warning16 . png " ) ) ) ; ingestWarningLabel . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . ingestWarningLabel . text " ) ) ; javax . swing . GroupLayout listEditorPanelLayout = new javax . swing . GroupLayout ( listEditorPanel ) ; listEditorPanel . setLayout ( listEditorPanelLayout ) ; listEditorPanelLayout . setHorizontalGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addComponent ( keywordsLabel ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addGap ( 10 , 10 , 10 ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jScrollPane1 , javax . swing . GroupLayout . DEFAULT_SIZE , 566 , Short . MAX_VALUE ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addComponent ( newKeywordsButton ) . addGap ( 14 , 14 , 14 ) . addComponent ( editWordButton ) . addGap ( 14 , 14 , 14 ) . addComponent ( deleteWordButton ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addComponent ( ingestMessagesCheckbox ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addComponent ( ingestWarningLabel ) ) ) ) ) . addContainerGap ( ) ) ) ; listEditorPanelLayout . linkSize ( javax . swing . SwingConstants . HORIZONTAL , new java . awt . Component [ ] { deleteWordButton , editWordButton , newKeywordsButton } ) ; listEditorPanelLayout . setVerticalGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , listEditorPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( keywordsLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( jScrollPane1 , javax . swing . GroupLayout . DEFAULT_SIZE , 256 , Short . MAX_VALUE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( deleteWordButton ) . addComponent ( newKeywordsButton ) . addComponent ( editWordButton ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( ingestMessagesCheckbox ) . addComponent ( ingestWarningLabel ) ) . addGap ( 9 , 9 , 9 ) ) ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( this ) ; this . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( listEditorPanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( listEditorPanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addGap ( 5 , 5 , 5 ) ) ) ; }
millmanorama/autopsy | private void deleteWordButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( KeywordSearchUtil . displayConfirmDialog ( NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . removeKwMsg " ) , NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . deleteWordButtonActionPerformed . delConfirmMsg " ) , KeywordSearchUtil . DIALOG_MESSAGE_TYPE . WARN ) ) { deleteKeywordAction ( keywordTable . getSelectedRows ( ) ) ; firePropertyChange ( OptionsPanelController . PROP_CHANGED , null , null ) ; } }
millmanorama/autopsy | private void ingestMessagesCheckboxActionPerformed ( java . awt . event . ActionEvent evt ) { currentKeywordList . setIngestMessages ( ingestMessagesCheckbox . isSelected ( ) ) ; XmlKeywordSearchList updater = XmlKeywordSearchList . getCurrent ( ) ; updater . addList ( currentKeywordList ) ; firePropertyChange ( OptionsPanelController . PROP_CHANGED , null , null ) ; }
millmanorama/autopsy | private void newKeywordsButtonActionPerformed ( java . awt . event . ActionEvent evt ) { addKeywordsAction ( " " , true , true ) ; }
millmanorama/autopsy | private void editWordButtonActionPerformed ( java . awt . event . ActionEvent evt ) { int [ ] selectedKeywords = keywordTable . getSelectedRows ( ) ; if ( selectedKeywords . length == 1 ) { Keyword currentKeyword = currentKeywordList . getKeywords ( ) . get ( selectedKeywords [ 0 ] ) ; if ( addKeywordsAction ( currentKeyword . getSearchTerm ( ) , currentKeyword . searchTermIsLiteral ( ) , currentKeyword . searchTermIsWholeWord ( ) ) ) { deleteKeywordAction ( selectedKeywords ) ; } } }
millmanorama/autopsy | @ Override public void valueChanged ( ListSelectionEvent e ) { ListSelectionModel listSelectionModel = ( ListSelectionModel ) e . getSource ( ) ; currentKeywordList = null ; if ( ! listSelectionModel . isSelectionEmpty ( ) ) { XmlKeywordSearchList loader = XmlKeywordSearchList . getCurrent ( ) ; if ( listSelectionModel . getMinSelectionIndex ( ) == listSelectionModel . getMaxSelectionIndex ( ) ) { currentKeywordList = loader . getListsL ( false ) . get ( listSelectionModel . getMinSelectionIndex ( ) ) ; } } tableModel . resync ( ) ; setButtonStates ( ) ; }
millmanorama/autopsy | @ Override public void store ( ) { }
millmanorama/autopsy | @ Override public void load ( ) { }
millmanorama/autopsy | KeywordList getCurrentKeywordList ( ) { return currentKeywordList ; }
millmanorama/autopsy | void setCurrentKeywordList ( KeywordList list ) { currentKeywordList = list ; }
millmanorama/autopsy | @ Override public int getColumnCount ( ) { return 2 ; }
millmanorama/autopsy | @ Override public int getRowCount ( ) { return currentKeywordList == null ? 0 : currentKeywordList . getKeywords ( ) . size ( ) ; }
millmanorama/autopsy | @ Override public String getColumnName ( int column ) { String colName = null ; switch ( column ) { case 0 : colName = NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . kwColName " ) ; break ; case 1 : colName = NbBundle . getMessage ( this . getClass ( ) , " KeywordSearch . typeColLbl " ) ; break ; default : ; } return colName ; }
millmanorama/autopsy | @ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Object ret = null ; if ( currentKeywordList == null ) { return " " ; } Keyword word = currentKeywordList . getKeywords ( ) . get ( rowIndex ) ; switch ( columnIndex ) { case 0 : ret = word . getSearchTerm ( ) ; break ; case 1 : ret = word . getSearchTermType ( ) ; break ; default : logger . log ( Level . SEVERE , " Invalid ▁ table ▁ column ▁ index : ▁ { 0 } " , columnIndex ) ; break ; } return ret ; }
millmanorama/autopsy | @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return false ; }
millmanorama/autopsy | @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { }
millmanorama/autopsy | @ Override public Class < ? > getColumnClass ( int c ) { return getValueAt ( 0 , c ) . getClass ( ) ; }
millmanorama/autopsy | void addKeyword ( Keyword keyword ) { if ( ! currentKeywordList . hasKeyword ( keyword ) ) { currentKeywordList . getKeywords ( ) . add ( keyword ) ; } fireTableDataChanged ( ) ; }
millmanorama/autopsy | void resync ( ) { fireTableDataChanged ( ) ; }
millmanorama/autopsy | void deleteSelected ( int [ ] selected ) { List < Keyword > words = currentKeywordList . getKeywords ( ) ; Arrays . sort ( selected ) ; for ( int arrayi = selected . length - 1 ; arrayi >= 0 ; arrayi -- ) { words . remove ( selected [ arrayi ] ) ; } resync ( ) ; }
millmanorama/autopsy | void setFocusOnKeywordTextBox ( ) { newKeywordsButton . requestFocus ( ) ; }
epam/NGB | public String getOriginalFilePath ( ) { return originalFilePath ; }
epam/NGB | public void setOriginalFilePath ( String originalFilePath ) { this . originalFilePath = originalFilePath ; }
epam/NGB | public String getSortedFilePath ( ) { return sortedFilePath ; }
epam/NGB | public void setSortedFilePath ( String sortedFilePath ) { this . sortedFilePath = sortedFilePath ; }
epam/NGB | public Integer getMaxMemory ( ) { return maxMemory ; }
epam/NGB | public void setMaxMemory ( Integer maxMemory ) { this . maxMemory = maxMemory ; }
semkagtn/last-fm | public IdsList getResponse ( ) { return response ; }
semkagtn/last-fm | @ Override public String toString ( ) { return JsonUtils . toJson ( this ) ; }
nabdulla/assignment1 | public Player ( String playerNo ) { this . setPlayerNo ( playerNo ) ; }
nabdulla/assignment1 | public String getPlayerNo ( ) { return playerNo ; }
nabdulla/assignment1 | public void setPlayerNo ( String playerNo ) { this . playerNo = playerNo ; }
Red5/red5-hls-plugin | private ThreadLocal < FileChannel > readChannelHolder = new ThreadLocal < FileChannel > ( ) { @ Override protected FileChannel initialValue ( ) { String fileName = String . format ( " % s % s _ % s . ts " , segmentDirectory , name , index ) ; log . debug ( " initialValue ▁ - ▁ read ▁ channel : ▁ { } " , fileName ) ; try { RandomAccessFile fileForReading = new RandomAccessFile ( fileName , " r " ) ; return fileForReading . getChannel ( ) ; } catch ( IOException e ) { log . warn ( " Exception ▁ in ▁ get ▁ channel " , e ) ; } return null ; } }
Red5/red5-hls-plugin | private ThreadLocal < Integer > readPositionHolder = new ThreadLocal < Integer > ( ) { @ Override protected Integer initialValue ( ) { log . debug ( " initialValue ▁ - ▁ buffer : ▁ { } " , buffer ) ; return 0 ; } }
Red5/red5-hls-plugin | public Segment ( String segmentDirectory , String name , int index , boolean memoryMapped ) { this . segmentDirectory = segmentDirectory ; this . name = name ; this . index = index ; if ( memoryMapped ) { log . debug ( " Using ▁ memory ▁ mapped ▁ files " ) ; buffer = IoBuffer . allocate ( CHUNK_SIZE * ( 1024 * 4 ) , false ) ; buffer . setAutoExpand ( true ) ; buffer . setAutoShrink ( true ) ; } else { log . debug ( " Using ▁ disk ▁ based ▁ files " ) ; try { file = new RandomAccessFile ( String . format ( " % s % s _ % s . ts " , segmentDirectory , name , index ) , " rwd " ) ; channel = file . getChannel ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } }
Red5/red5-hls-plugin | public String getSegmentDirectory ( ) { return segmentDirectory ; }
Red5/red5-hls-plugin | public String getName ( ) { return name ; }
Red5/red5-hls-plugin | public int getIndex ( ) { return index ; }
Red5/red5-hls-plugin | public long getCreated ( ) { return created ; }
Red5/red5-hls-plugin | public boolean isMemoryMapped ( ) { return channel == null ; }
Red5/red5-hls-plugin | public boolean isLast ( ) { return last ; }
Red5/red5-hls-plugin | public void setLast ( boolean last ) { this . last = last ; }
Red5/red5-hls-plugin | public boolean isPatWritten ( ) { return patWritten ; }
Red5/red5-hls-plugin | public void setPatWritten ( boolean patWritten ) { this . patWritten = patWritten ; }
Red5/red5-hls-plugin | public boolean isPmtWritten ( ) { return pmtWritten ; }
Red5/red5-hls-plugin | public void setPmtWritten ( boolean pmtWritten ) { this . pmtWritten = pmtWritten ; }
Red5/red5-hls-plugin | public boolean isSpWritten ( ) { return spWritten ; }
Red5/red5-hls-plugin | public void setSpWritten ( boolean spWritten ) { this . spWritten = spWritten ; }
Red5/red5-hls-plugin | public void setDuration ( double duration ) { this . duration = duration ; }
Red5/red5-hls-plugin | public double getDuration ( ) { return duration ; }
Red5/red5-hls-plugin | public ByteBuffer read ( ) { ByteBuffer buf = null ; if ( buffer != null ) { Integer readPos = readPositionHolder . get ( ) ; log . trace ( " Current ▁ buffer ▁ position : ▁ { } " , readPos ) ; int newPos = readPos + CHUNK_SIZE ; int currentPosition = buffer . position ( ) ; if ( newPos < currentPosition ) { byte [ ] chunk = new byte [ CHUNK_SIZE ] ; if ( lock . tryLock ( ) ) { try { currentPosition = buffer . position ( ) ; IoBuffer slice = buffer . getSlice ( readPos , CHUNK_SIZE ) ; buffer . position ( currentPosition ) ; slice . get ( chunk ) ; slice . free ( ) ; } finally { lock . unlock ( ) ; } buf = ByteBuffer . wrap ( chunk ) ; } readPositionHolder . set ( newPos ) ; } else { readPositionHolder . set ( readPos ) ; } } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { buf = ByteBuffer . allocate ( CHUNK_SIZE ) ; readChannel . read ( buf ) ; buf . flip ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . set ( readChannel ) ; } return buf ; }
Red5/red5-hls-plugin | public ByteBuffer read ( ByteBuffer buf ) { if ( buffer != null ) { Integer readPos = readPositionHolder . get ( ) ; log . trace ( " Current ▁ buffer ▁ read ▁ position : ▁ { } " , readPos ) ; int newPos = readPos + CHUNK_SIZE ; int currentPosition = buffer . position ( ) ; if ( newPos < currentPosition ) { byte [ ] chunk = new byte [ CHUNK_SIZE ] ; if ( lock . tryLock ( ) ) { try { currentPosition = buffer . position ( ) ; IoBuffer slice = buffer . getSlice ( readPos , CHUNK_SIZE ) ; buffer . position ( currentPosition ) ; slice . get ( chunk ) ; slice . free ( ) ; } finally { lock . unlock ( ) ; } buf . put ( chunk ) ; buf . flip ( ) ; } readPositionHolder . set ( newPos ) ; } else { readPositionHolder . set ( readPos ) ; buf . position ( CHUNK_SIZE - 1 ) ; } } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { readChannel . read ( buf ) ; buf . flip ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . set ( readChannel ) ; } return buf ; }
Red5/red5-hls-plugin | public boolean hasMoreData ( ) { boolean hasMore = false ; if ( buffer != null ) { Integer readPos = readPositionHolder . get ( ) ; hasMore = ( readPos + CHUNK_SIZE ) < buffer . position ( ) ; readPositionHolder . set ( readPos ) ; } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { hasMore = ( readChannel . size ( ) - readChannel . position ( ) ) >= CHUNK_SIZE ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . set ( readChannel ) ; } return hasMore ; }
Red5/red5-hls-plugin | public void cleanupThreadLocal ( ) { if ( buffer != null ) { readPositionHolder . remove ( ) ; } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { readChannel . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . remove ( ) ; } }
Red5/red5-hls-plugin | public int write ( ByteBuffer data ) { log . debug ( " write " ) ; int written = 0 ; if ( ! closed ) { if ( buffer != null ) { log . trace ( " Current ▁ buffer ▁ size ▁ before ▁ write : ▁ { } " , buffer . capacity ( ) ) ; if ( lock . tryLock ( ) ) { try { buffer . put ( data ) ; chunksWritten ++ ; written = data . limit ( ) ; } catch ( BufferOverflowException bofe ) { log . warn ( " Error ▁ writing ▁ to ▁ the ▁ buffer " , bofe ) ; } finally { lock . unlock ( ) ; } } } else { if ( data != null ) { try { written = channel . write ( data ) ; channel . force ( true ) ; chunksWritten ++ ; } catch ( IOException e ) { log . warn ( " Exception ▁ writing ▁ channel " , e ) ; } } else { log . debug ( " Write ▁ data ▁ was ▁ null " ) ; } } } return written ; }
Red5/red5-hls-plugin | public boolean close ( ) { log . debug ( " Close ▁ - ▁ name : ▁ { } ▁ index : ▁ { } " , name , index ) ; closed = true ; log . debug ( " Chunks ▁ written : ▁ { } " , chunksWritten ) ; boolean result = false ; if ( buffer != null ) { buffer . clear ( ) ; result = true ; } else if ( channel != null && channel . isOpen ( ) ) { try { channel . close ( ) ; result = true ; } catch ( IOException e ) { log . warn ( " Exception ▁ closing ▁ channel " , e ) ; } } return result ; }
Red5/red5-hls-plugin | public void dispose ( ) { if ( buffer != null ) { buffer . free ( ) ; } else { File tsFile = new File ( String . format ( " % s % s _ % s . ts " , segmentDirectory , name , index ) ) ; if ( tsFile . exists ( ) ) { if ( ! tsFile . delete ( ) ) { tsFile . deleteOnExit ( ) ; } } tsFile = null ; } }
Red5/red5-hls-plugin | @ Override public String toString ( ) { return " Segment ▁ [ name = " + name + " , ▁ index = " + index + " , ▁ created = " + created + " ] " ; }
Red5/red5-hls-plugin | @ Override public int compareTo ( Segment otherSegment ) { int otherIndex = otherSegment . getIndex ( ) ; if ( index > otherIndex ) { return 1 ; } else if ( index < otherIndex ) { return - 1 ; } return 0 ; }
McLeodMoores/starling | public AbstractBloombergHTSTest ( ) { super ( ) ; }
McLeodMoores/starling | @ BeforeMethod ( alwaysRun = true ) protected void doSetUp ( ) { _htsMaster = new InMemoryHistoricalTimeSeriesMaster ( ) ; _historicalTimeSeriesProvider = new UnitTestHistoricalTimeSeriesProvider ( ) ; final BloombergIdentifierProvider idProvider = new BloombergIdentifierProvider ( new MockReferenceDataProvider ( ) ) ; _htsMasterUpdater = new BloombergHTSMasterUpdater ( _htsMaster , _historicalTimeSeriesProvider , idProvider ) ; _loader = new BloombergHistoricalTimeSeriesLoader ( _htsMaster , _historicalTimeSeriesProvider , idProvider ) ; }
McLeodMoores/starling | @ AfterMethod ( alwaysRun = true ) protected void doTearDown ( ) { _htsMaster = null ; }
McLeodMoores/starling | @ Override protected HistoricalTimeSeriesProviderGetResult doBulkGet ( final HistoricalTimeSeriesProviderGetRequest request ) { final Map < ExternalIdBundle , LocalDateDoubleTimeSeries > tsMap = Maps . newHashMap ( ) ; LocalDate start = request . getDateRange ( ) . getStartDateInclusive ( ) ; LocalDate end = request . getDateRange ( ) . getEndDateInclusive ( ) ; LOGGER . debug ( " producing ▁ TS ▁ for ▁ startDate = { } ▁ endDate = { } " , start , end ) ; for ( final ExternalIdBundle identifiers : request . getExternalIdBundles ( ) ) { final LocalDate cachedStart = MapUtils . putIfAbsentGet ( _startDateMap , identifiers , start ) ; if ( start . isBefore ( cachedStart ) ) { start = cachedStart ; } if ( end . equals ( LocalDate . MAX ) ) { end = previousWeekDay ( ) ; } final LocalDateDoubleTimeSeries timeSeries = makeRandomTimeSeries ( start , end ) ; tsMap . put ( identifiers , timeSeries ) ; } return new HistoricalTimeSeriesProviderGetResult ( tsMap ) ; }
McLeodMoores/starling | private LocalDateDoubleTimeSeries makeRandomTimeSeries ( final LocalDate start , final LocalDate end ) { final LocalDateDoubleTimeSeriesBuilder tsMap = ImmutableLocalDateDoubleTimeSeries . builder ( ) ; LocalDate current = start ; tsMap . put ( current , Math . random ( ) ) ; while ( current . isBefore ( end ) ) { current = current . plusDays ( 1 ) ; if ( isWeekday ( current ) ) { tsMap . put ( current , Math . random ( ) ) ; } } return tsMap . build ( ) ; }
McLeodMoores/starling | private boolean isWeekday ( final LocalDate day ) { return day . getDayOfWeek ( ) != DayOfWeek . SATURDAY && day . getDayOfWeek ( ) != DayOfWeek . SUNDAY ; }
McLeodMoores/starling | protected List < Pair < HistoricalTimeSeriesInfoDocument , HistoricalTimeSeries > > addTimeSeries ( ) { final List < Pair < HistoricalTimeSeriesInfoDocument , HistoricalTimeSeries > > result = Lists . newArrayList ( ) ; for ( int i = 0 ; i < TS_DATASET_SIZE ; i ++ ) { final LocalDate end = previousWeekDay ( ) . minusWeeks ( 1 ) ; final LocalDate start = end . minusWeeks ( 2 ) ; for ( final String dataSource : DATA_SOURCES ) { for ( final String dataProvider : DATA_PROVIDERS ) { for ( final String dataField : DATA_FIELDS ) { final ManageableHistoricalTimeSeriesInfo info = new ManageableHistoricalTimeSeriesInfo ( ) ; info . setName ( dataField + " ▁ " + dataSource ) ; info . setDataField ( dataField ) ; info . setDataProvider ( dataProvider ) ; info . setDataSource ( dataSource ) ; info . setObservationTime ( PROVIDER_TO_OBSERVATION_TIME . get ( dataProvider ) ) ; final ExternalId ticker = ExternalSchemes . bloombergTickerSecurityId ( " ticker " + i ) ; final ExternalId buid = ExternalSchemes . bloombergBuidSecurityId ( " buid " + i ) ; final ExternalIdBundleWithDates bundleWithDates = ExternalIdBundleWithDates . of ( ExternalIdWithDates . of ( ticker ) , ExternalIdWithDates . of ( buid ) ) ; info . setExternalIdBundle ( bundleWithDates ) ; final HistoricalTimeSeriesInfoDocument added = _htsMaster . add ( new HistoricalTimeSeriesInfoDocument ( info ) ) ; assertNotNull ( added ) ; assertNotNull ( added . getUniqueId ( ) ) ; final Map < ExternalIdBundle , LocalDateDoubleTimeSeries > resultMap = _historicalTimeSeriesProvider . getHistoricalTimeSeries ( Collections . singleton ( bundleWithDates . toBundle ( ) ) , BloombergConstants . BLOOMBERG_DATA_SOURCE_NAME , dataProvider , dataField , LocalDateRange . of ( start , end , true ) ) ; final LocalDateDoubleTimeSeries timeSeries = resultMap . get ( bundleWithDates . toBundle ( ) ) ; final UniqueId tsUid = _htsMaster . updateTimeSeriesDataPoints ( added . getInfo ( ) . getTimeSeriesObjectId ( ) , timeSeries ) ; final HistoricalTimeSeries hts = _htsMaster . getTimeSeries ( tsUid ) ; assertNotNull ( hts ) ; assertEquals ( timeSeries , hts . getTimeSeries ( ) ) ; result . add ( Pairs . of ( added , hts ) ) ; } } } } return result ; }
McLeodMoores/starling | protected BloombergHTSMasterUpdater getHtsMasterUpdater ( ) { return _htsMasterUpdater ; }
McLeodMoores/starling | protected BloombergHistoricalTimeSeriesLoader getLoader ( ) { return _loader ; }
McLeodMoores/starling | protected HistoricalTimeSeriesMaster getHtsMaster ( ) { return _htsMaster ; }
c3p0hz/microscope | public DateTimeBox ( ) { super ( new DateTimePicker ( ) , null , DATE_FORMAT ) ; ( ( DateTimePicker ) getDatePicker ( ) ) . setDateTimeBox ( this ) ; final TextBox textbox = getTextBox ( ) ; textbox . setVisibleLength ( 19 + 2 ) ; textbox . setMaxLength ( 19 ) ; }
c3p0hz/microscope | public DateTimePicker ( ) { }
c3p0hz/microscope | void setDateTimeBox ( final DateTimeBox box ) { this . box = box ; }
c3p0hz/microscope | private void setDate ( final Date d ) { refreshAll ( ) ; box . setValue ( d ) ; box . getTextBox ( ) . setFocus ( true ) ; }
c3p0hz/microscope | private PushButton newShiftDateButton ( final int seconds , final String label ) { final PushButton button = new PushButton ( label ) ; button . setStyleName ( seconds < 0 ? " datePickerPreviousButton " : " datePickerNextButton " ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { Date d = box . getValue ( ) ; if ( d == null ) { if ( seconds >= 0 ) { return ; } d = new Date ( ) ; } d . setTime ( d . getTime ( ) + seconds * 1000L ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
c3p0hz/microscope | private PushButton newSetHoursButton ( final int hours ) { final PushButton button = new PushButton ( Integer . toString ( hours ) ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { @ SuppressWarnings ( { " deprecation " } ) Date d = box . getValue ( ) ; if ( d == null ) { d = new Date ( ) ; d . setMinutes ( 0 ) ; } d . setHours ( hours ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
c3p0hz/microscope | private PushButton newSetMinutesButton ( final int minutes , final String label ) { final PushButton button = new PushButton ( label ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { @ SuppressWarnings ( { " deprecation " } ) Date d = box . getValue ( ) ; if ( d == null ) { d = new Date ( ) ; } d . setMinutes ( minutes ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
c3p0hz/microscope | private void setupAmUI ( ) { hours_minutes . setWidget ( 0 , 1 , newSetHoursButton ( 0 ) ) ; hours_minutes . setWidget ( 0 , 2 , newSetHoursButton ( 1 ) ) ; hours_minutes . setWidget ( 0 , 3 , newSetHoursButton ( 2 ) ) ; hours_minutes . setWidget ( 0 , 4 , newSetHoursButton ( 3 ) ) ; hours_minutes . setWidget ( 0 , 5 , newSetHoursButton ( 4 ) ) ; hours_minutes . setWidget ( 0 , 6 , newSetHoursButton ( 5 ) ) ; hours_minutes . setWidget ( 1 , 1 , newSetHoursButton ( 6 ) ) ; hours_minutes . setWidget ( 1 , 2 , newSetHoursButton ( 7 ) ) ; hours_minutes . setWidget ( 1 , 3 , newSetHoursButton ( 8 ) ) ; hours_minutes . setWidget ( 1 , 4 , newSetHoursButton ( 9 ) ) ; hours_minutes . setWidget ( 1 , 5 , newSetHoursButton ( 10 ) ) ; hours_minutes . setWidget ( 1 , 6 , newSetHoursButton ( 11 ) ) ; }
c3p0hz/microscope | private void setupPmUI ( ) { hours_minutes . setWidget ( 0 , 1 , newSetHoursButton ( 12 ) ) ; hours_minutes . setWidget ( 0 , 2 , newSetHoursButton ( 13 ) ) ; hours_minutes . setWidget ( 0 , 3 , newSetHoursButton ( 14 ) ) ; hours_minutes . setWidget ( 0 , 4 , newSetHoursButton ( 15 ) ) ; hours_minutes . setWidget ( 0 , 5 , newSetHoursButton ( 16 ) ) ; hours_minutes . setWidget ( 0 , 6 , newSetHoursButton ( 17 ) ) ; hours_minutes . setWidget ( 1 , 1 , newSetHoursButton ( 18 ) ) ; hours_minutes . setWidget ( 1 , 2 , newSetHoursButton ( 19 ) ) ; hours_minutes . setWidget ( 1 , 3 , newSetHoursButton ( 20 ) ) ; hours_minutes . setWidget ( 1 , 4 , newSetHoursButton ( 21 ) ) ; hours_minutes . setWidget ( 1 , 5 , newSetHoursButton ( 22 ) ) ; hours_minutes . setWidget ( 1 , 6 , newSetHoursButton ( 23 ) ) ; }
c3p0hz/microscope | @ Override protected void setup ( ) { final HorizontalPanel panel = new HorizontalPanel ( ) ; initWidget ( panel ) ; setStyleName ( panel . getElement ( ) , " gwt - DatePicker " ) ; { final VerticalPanel vbox = new VerticalPanel ( ) ; setStyleName ( " gwt - DatePicker " ) ; vbox . add ( super . getMonthSelector ( ) ) ; vbox . add ( super . getView ( ) ) ; panel . add ( vbox ) ; } { final VerticalPanel vbox = new VerticalPanel ( ) ; setStyleName ( vbox . getElement ( ) , " datePickerMonthSelector " ) ; final PushButton now = new PushButton ( " now " ) ; now . setStyleName ( " datePickerNextButton " ) ; now . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { box . setValue ( new Date ( ) ) ; } } ) ; { final Grid grid = new Grid ( 2 , 9 ) ; grid . setWidget ( 0 , 0 , newShiftDateButton ( - 3600 , "1h " ) ) ; grid . setWidget ( 0 , 1 , newShiftDateButton ( - 600 , "10m " ) ) ; grid . setWidget ( 0 , 2 , newShiftDateButton ( - 60 , "1m " ) ) ; grid . setWidget ( 0 , 3 , new InlineHTML ( " & lsaquo ; " ) ) ; grid . setWidget ( 0 , 4 , now ) ; grid . setWidget ( 0 , 5 , new InlineHTML ( " & rsaquo ; " ) ) ; grid . setWidget ( 0 , 6 , newShiftDateButton ( + 60 , "1m " ) ) ; grid . setWidget ( 0 , 7 , newShiftDateButton ( + 600 , "10m " ) ) ; grid . setWidget ( 0 , 8 , newShiftDateButton ( + 3600 , "1h " ) ) ; grid . setWidget ( 1 , 0 , newShiftDateButton ( - 86400 * 30 , "30d " ) ) ; grid . setWidget ( 1 , 1 , newShiftDateButton ( - 86400 * 7 , "1w " ) ) ; grid . setWidget ( 1 , 2 , newShiftDateButton ( - 86400 , "1d " ) ) ; grid . setWidget ( 1 , 3 , new InlineHTML ( " & laquo ; " ) ) ; grid . setWidget ( 1 , 4 , new InlineHTML ( " & nbsp ; " ) ) ; grid . setWidget ( 1 , 5 , new InlineHTML ( " & raquo ; " ) ) ; grid . setWidget ( 1 , 6 , newShiftDateButton ( + 86400 , "1d " ) ) ; grid . setWidget ( 1 , 7 , newShiftDateButton ( + 86400 * 7 , "1w " ) ) ; grid . setWidget ( 1 , 8 , newShiftDateButton ( + 86400 * 30 , "30d " ) ) ; final CellFormatter formatter = grid . getCellFormatter ( ) ; formatter . setWidth ( 0 , 4 , "100 % " ) ; formatter . setWidth ( 1 , 4 , "100 % " ) ; vbox . add ( grid ) ; } { hours_minutes = new Grid ( 4 , 8 ) ; setupAmUI ( ) ; hours_minutes . setWidget ( 0 , 0 , new InlineLabel ( " HH " ) ) ; final PushButton set_am = new PushButton ( " AM " ) ; set_am . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { setupAmUI ( ) ; } } ) ; hours_minutes . setWidget ( 0 , 7 , set_am ) ; final PushButton set_pm = new PushButton ( " PM " ) ; set_pm . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { setupPmUI ( ) ; } } ) ; hours_minutes . setWidget ( 1 , 7 , set_pm ) ; hours_minutes . setWidget ( 2 , 0 , new InlineLabel ( " MM " ) ) ; hours_minutes . setWidget ( 2 , 1 , newSetMinutesButton ( 0 , "00" ) ) ; hours_minutes . setWidget ( 2 , 2 , newSetMinutesButton ( 10 , "10" ) ) ; hours_minutes . setWidget ( 2 , 3 , newSetMinutesButton ( 20 , "20" ) ) ; hours_minutes . setWidget ( 2 , 4 , newSetMinutesButton ( 30 , "30" ) ) ; hours_minutes . setWidget ( 2 , 5 , newSetMinutesButton ( 40 , "40" ) ) ; hours_minutes . setWidget ( 2 , 6 , newSetMinutesButton ( 50 , "50" ) ) ; vbox . add ( hours_minutes ) ; } { final HorizontalPanel hbox = new HorizontalPanel ( ) ; hbox . add ( new InlineLabel ( " UNIX ▁ timestamp : " ) ) ; final ValidatedTextBox ts = new ValidatedTextBox ( ) ; ts . setValidationRegexp ( " ^ ( | [ 1-9 ] [ 0-9 ] { 0,9 } ) $ " ) ; ts . setVisibleLength ( 10 ) ; ts . setMaxLength ( 10 ) ; final EventsHandler handler = new EventsHandler ( ) { protected < H extends EventHandler > void onEvent ( final DomEvent < H > event ) { final Date d = new Date ( Integer . parseInt ( ts . getValue ( ) ) * 1000L ) ; box . setValue ( d , true ) ; } } ; ts . addBlurHandler ( handler ) ; ts . addKeyPressHandler ( handler ) ; hbox . add ( ts ) ; vbox . add ( hbox ) ; } vbox . setHeight ( "100 % " ) ; panel . add ( vbox ) ; panel . setCellHeight ( vbox , "100 % " ) ; } }
Kisamegr/Crawler | public Exctractor ( ) { try { Console . Log ( " - - - - - ▁ Started ▁ Extractor ▁ - - - - - " ) ; Console . Log ( " Extracting ▁ General ▁ User ▁ Info . . . " ) ; ExtractGeneralUserInfo ( ) ; Console . Log ( " Extracting ▁ Inspected ▁ User ▁ Info . . . " ) ; ExtractInspectedUserInfo ( ) ; Console . Log ( " Finding ▁ Inspected ▁ Users ▁ Duplicates . . . " ) ; FindDuplicates ( ) ; SaveInspectedUsersMongo ( ) ; } catch ( TwitterException e ) { Console . Log ( " Error ▁ @ Extractor " ) ; if ( e . isCausedByNetworkIssue ( ) ) { Console . WriteExceptionDump ( e , e . getErrorCode ( ) ) ; } } }
Kisamegr/Crawler | public void ExtractGeneralUserInfo ( ) throws TwitterException { DBCursor cursor = mongo . getStatusesCursor ( new BasicDBObject ( " trends " , 0 ) . append ( " index _ id " , 0 ) ) ; long currentTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < cursor . size ( ) ; i ++ ) { DBObject obj = cursor . next ( ) ; Status status = TwitterObjectFactory . createStatus ( obj . toString ( ) ) ; User user = status . getUser ( ) ; long age = currentTime - user . getCreatedAt ( ) . getTime ( ) ; int followers = user . getFollowersCount ( ) ; int friends = user . getFriendsCount ( ) ; mongo . addGeneralUserInfo ( user . getId ( ) , age , followers , friends ) ; } }
Kisamegr/Crawler | public void ExtractInspectedUserInfo ( ) throws TwitterException { HashMap < Long , HashMap < String , Integer > > sourcesCounter = new HashMap < > ( ) ; long currentTime = System . currentTimeMillis ( ) ; DBCursor cursor = mongo . getFollowedStatusesCursor ( ) ; for ( int i = 0 ; i < cursor . count ( ) ; i ++ ) { DBObject obj = cursor . next ( ) ; Status status = TwitterObjectFactory . createStatus ( obj . toString ( ) ) ; long id = status . getUser ( ) . getId ( ) ; InspectedUser user ; if ( ! userMap . containsKey ( id ) ) { user = new InspectedUser ( ) ; user . setId ( id ) ; userMap . put ( id , user ) ; } else user = userMap . get ( id ) ; user . setFollowers ( status . getUser ( ) . getFollowersCount ( ) ) ; user . setFriends ( status . getUser ( ) . getFriendsCount ( ) ) ; user . setAge ( currentTime - status . getUser ( ) . getCreatedAt ( ) . getTime ( ) ) ; if ( ! status . isRetweet ( ) ) user . addTweets ( ) ; else user . addRetweets ( ) ; if ( status . getInReplyToUserId ( ) != - 1 ) user . addReplies ( ) ; user . addUserMentions ( status . getUserMentionEntities ( ) . length ) ; user . addHashtags ( status . getHashtagEntities ( ) . length ) ; if ( status . getHashtagEntities ( ) . length > 0 ) user . addHashtaggedTweets ( ) ; if ( status . getURLEntities ( ) . length > 0 ) user . addUrlTweets ( ) ; String fullSource = status . getSource ( ) ; String source = fullSource . split ( " < | > " ) [ 2 ] ; if ( ! sourcesCounter . containsKey ( user . getId ( ) ) ) sourcesCounter . put ( user . getId ( ) , new HashMap < String , Integer > ( ) ) ; HashMap < String , Integer > userSourceMap = sourcesCounter . get ( user . getId ( ) ) ; if ( userSourceMap . containsKey ( source ) ) userSourceMap . put ( source , userSourceMap . get ( source ) + 1 ) ; else userSourceMap . put ( source , 1 ) ; } for ( Entry < Long , HashMap < String , Integer > > userSources : sourcesCounter . entrySet ( ) ) { String maxSource = null ; int max = - 1 ; for ( Entry < String , Integer > s : userSources . getValue ( ) . entrySet ( ) ) { if ( s . getValue ( ) > max ) { maxSource = s . getKey ( ) ; max = s . getValue ( ) ; } } userMap . get ( userSources . getKey ( ) ) . setMaxSource ( maxSource ) ; } Iterator < Entry < Long , InspectedUser > > it = userMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Entry < Long , InspectedUser > en = it . next ( ) ; if ( en . getValue ( ) . getTweets ( ) + en . getValue ( ) . getRetweets ( ) < 5 ) it . remove ( ) ; } }
Kisamegr/Crawler | public void FindDuplicates ( ) throws TwitterException { List < Number > userList = mongo . getInspectedUserIDs ( ) ; for ( Number userID : userList ) { InspectedUser user = userMap . get ( userID . longValue ( ) ) ; if ( user != null ) { DBCursor cursor = mongo . getFollowedStatusesCursor ( userID . longValue ( ) ) ; ArrayList < String > twitch = new ArrayList < > ( ) ; for ( int i = 0 ; i < cursor . size ( ) ; i ++ ) { DBObject obj = cursor . next ( ) ; Status status = TwitterObjectFactory . createStatus ( obj . toString ( ) ) ; if ( ! status . isRetweet ( ) && status . getInReplyToUserId ( ) == - 1 ) { StringBuilder tweet = new StringBuilder ( ) ; tweet . append ( status . getText ( ) ) ; for ( UserMentionEntity mention : status . getUserMentionEntities ( ) ) { int index_start = tweet . indexOf ( mention . getText ( ) ) ; if ( index_start != - 1 ) tweet . delete ( index_start , index_start + mention . getText ( ) . length ( ) ) ; } for ( URLEntity url : status . getURLEntities ( ) ) { int index_start = tweet . indexOf ( url . getText ( ) ) ; if ( index_start != - 1 ) tweet . delete ( index_start , index_start + url . getText ( ) . length ( ) ) ; } twitch . add ( tweet . toString ( ) ) ; } } int totalSimilar = 0 ; for ( int x = 0 ; x < twitch . size ( ) ; x ++ ) { for ( int y = x + 1 ; y < twitch . size ( ) ; y ++ ) { float percent = LevenshteinDistance ( twitch . get ( x ) , twitch . get ( y ) ) ; if ( percent < 0.1 ) totalSimilar ++ ; } } if ( twitch . size ( ) > 0 ) user . setDuplicateRatio ( ( double ) totalSimilar / twitch . size ( ) ) ; else user . setDuplicateRatio ( 0 ) ; } } }
Kisamegr/Crawler | public void SaveInspectedUsersMongo ( ) { for ( Entry < Long , InspectedUser > entry : userMap . entrySet ( ) ) { mongo . addInspectedUserInfo ( entry . getValue ( ) ) ; } }
Kisamegr/Crawler | public float LevenshteinDistance ( String s0 , String s1 ) { int len0 = s0 . length ( ) + 1 ; int len1 = s1 . length ( ) + 1 ; int [ ] cost = new int [ len0 ] ; int [ ] newcost = new int [ len0 ] ; for ( int i = 0 ; i < len0 ; i ++ ) cost [ i ] = i ; for ( int j = 1 ; j < len1 ; j ++ ) { newcost [ 0 ] = j ; for ( int i = 1 ; i < len0 ; i ++ ) { int match = ( s0 . charAt ( i - 1 ) == s1 . charAt ( j - 1 ) ) ? 0 : 1 ; int cost_replace = cost [ i - 1 ] + match ; int cost_insert = cost [ i ] + 1 ; int cost_delete = newcost [ i - 1 ] + 1 ; newcost [ i ] = Math . min ( Math . min ( cost_insert , cost_delete ) , cost_replace ) ; } int [ ] swap = cost ; cost = newcost ; newcost = swap ; } return ( float ) cost [ len0 - 1 ] / ( s0 . length ( ) + s1 . length ( ) ) ; }
steve1rm/busbymovies | public MovieDbHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; }
steve1rm/busbymovies | @ Override public void onCreate ( SQLiteDatabase db ) { final String CREATE_TABLE = " CREATE ▁ TABLE ▁ " + MovieContract . MovieEntry . TABLE_NAME + " ( ▁ " + MovieContract . MovieEntry . _ID + " ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , ▁ " + MovieContract . MovieEntry . MOVIE_ID + " ▁ INTEGER ▁ NOT ▁ NULL , ▁ " + MovieContract . MovieEntry . POSTER_PATH + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . OVERVIEW + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . RELEASE_DATE + " ▁ TEXT ▁ NOT ▁ NULL , ▁ " + MovieContract . MovieEntry . TITLE + " ▁ TEXT ▁ NOT ▁ NULL , ▁ " + MovieContract . MovieEntry . BACKDROP_PATH + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . VOTE_AVERAGE + " ▁ REAL , ▁ " + MovieContract . MovieEntry . VOTE_COUNT + " ▁ REAL , ▁ " + MovieContract . MovieEntry . TAGLINE + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . HOMEPATH + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . RUNTIME + " ▁ INTEGER " + " ) ; " ; db . execSQL ( CREATE_TABLE ) ; }
steve1rm/busbymovies | @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { if ( newVersion > oldVersion ) { Timber . d ( " onUpgrade ▁ old ▁ version : ▁ % d ▁ new ▁ version ▁ % d " , oldVersion , newVersion ) ; final String DROP_TABLE = " DROP ▁ TABLE ▁ IF ▁ EXISTS ▁ " + MovieContract . MovieEntry . TABLE_NAME ; db . execSQL ( DROP_TABLE ) ; onCreate ( db ) ; } }
oivarc/j2ee-samples | public Page ( ) { super ( ) ; }
oivarc/j2ee-samples | public Page ( final List < T > someContent , final int someCount ) { this ( ) ; content = someContent ; count = someCount ; }
oivarc/j2ee-samples | public List < T > getContent ( ) { return content ; }
oivarc/j2ee-samples | public void setContent ( final List < T > someContent ) { content = someContent ; }
oivarc/j2ee-samples | public int getCount ( ) { return count ; }
oivarc/j2ee-samples | public void setCount ( final int someCount ) { count = someCount ; }
yeastrc/proxl-web-app | private DB_Insert_UnifiedRepPepIsotopeLabelLookupDAO ( ) { }
yeastrc/proxl-web-app | public void save ( UnifiedRepPepIsotopeLabelLookupDTO item , Connection conn ) throws Exception { PreparedStatement pstmt = null ; ResultSet rs = null ; final String sql = SAVE_SQL ; try { pstmt = conn . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; int counter = 0 ; counter ++ ; pstmt . setInt ( counter , item . getRpMatchedPeptideId ( ) ) ; counter ++ ; pstmt . setInt ( counter , item . getIsotopeLabelId ( ) ) ; pstmt . executeUpdate ( ) ; rs = pstmt . getGeneratedKeys ( ) ; if ( rs . next ( ) ) { item . setId ( rs . getInt ( 1 ) ) ; } else throw new Exception ( " Failed ▁ to ▁ insert ▁ UnifiedRepPepIsotopeLabelLookupDTO " ) ; } catch ( Exception e ) { String msg = " ERROR : ▁ sql : ▁ " + sql ; log . error ( msg , e ) ; throw e ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Throwable t ) { ; } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( Throwable t ) { ; } pstmt = null ; } } }
fSergio101/orchextra-android-sdk | public RegionMonitoringScannerImpl ( ContextProvider contextProvider , BeaconManager beaconManager , MonitoringListener monitoringListener , BeaconsController beaconsController , BeaconRegionAndroidMapper regionMapper ) { this . beaconManager = beaconManager ; this . beaconsController = beaconsController ; this . context = contextProvider . getApplicationContext ( ) ; this . monitoringListener = monitoringListener ; this . regionMapper = regionMapper ; this . beaconManager . setMonitorNotifier ( this ) ; }
fSergio101/orchextra-android-sdk | @ Override public void onBeaconServiceConnect ( ) { obtainRegionsToScan ( ) ; }
fSergio101/orchextra-android-sdk | @ Override public Context getApplicationContext ( ) { return context ; }
fSergio101/orchextra-android-sdk | @ Override public void unbindService ( ServiceConnection serviceConnection ) { context . unbindService ( serviceConnection ) ; }
fSergio101/orchextra-android-sdk | @ Override public boolean bindService ( Intent intent , ServiceConnection serviceConnection , int i ) { return context . bindService ( intent , serviceConnection , i ) ; }
fSergio101/orchextra-android-sdk | @ Override public void didEnterRegion ( Region region ) { OrchextraRegion orchextraRegion = regionMapper . externalClassToModel ( region ) ; beaconsController . onRegionEnter ( orchextraRegion ) ; monitoringListener . onRegionEnter ( region ) ; regionsInEnter . add ( region ) ; GGGLogImpl . log ( " ENTER ▁ BEACON ▁ REGION ▁ : ▁ " + region . getUniqueId ( ) ) ; }
fSergio101/orchextra-android-sdk | @ Override public void didExitRegion ( Region region ) { OrchextraRegion orchextraRegion = regionMapper . externalClassToModel ( region ) ; beaconsController . onRegionExit ( orchextraRegion ) ; monitoringListener . onRegionExit ( region ) ; regionsInEnter . remove ( region ) ; GGGLogImpl . log ( " EXIT ▁ BEACON ▁ REGION ▁ : ▁ " + region . getUniqueId ( ) ) ; }
fSergio101/orchextra-android-sdk | @ Override public void didDetermineStateForRegion ( int i , Region region ) { }
fSergio101/orchextra-android-sdk | @ Override public void initMonitoring ( ) { beaconManager . bind ( this ) ; }
fSergio101/orchextra-android-sdk | @ Override public void stopMonitoring ( ) { stopMonitoringRegions ( regionsToBeMonitored ) ; monitoring = false ; regionsInEnter . clear ( ) ; beaconManager . unbind ( this ) ; }
fSergio101/orchextra-android-sdk | private void obtainRegionsToScan ( ) { beaconsController . getAllRegionsFromDataBase ( this ) ; }
fSergio101/orchextra-android-sdk | @ Override public boolean isMonitoring ( ) { return monitoring ; }
fSergio101/orchextra-android-sdk | @ Override public void setRunningMode ( AppRunningModeType appRunningModeType ) { beaconManager . setBackgroundMode ( appRunningModeType == AppRunningModeType . BACKGROUND ) ; }
fSergio101/orchextra-android-sdk | @ Override public void updateRegions ( List deletedRegions , List newRegions ) { if ( ! deletedRegions . isEmpty ( ) ) { List < Region > deleted = regionMapper . modelListToExternalClassList ( deletedRegions ) ; stopMonitoringRegions ( deleted ) ; } if ( ! newRegions . isEmpty ( ) ) { List < Region > added = regionMapper . modelListToExternalClassList ( newRegions ) ; startMonitoringRegions ( added ) ; } }
fSergio101/orchextra-android-sdk | @ Override public void onRegionsReady ( List < OrchextraRegion > regions ) { List < Region > altRegions = regionMapper . modelListToExternalClassList ( regions ) ; this . regionsToBeMonitored . clear ( ) ; this . regionsToBeMonitored . addAll ( altRegions ) ; startMonitoringRegions ( altRegions ) ; }
fSergio101/orchextra-android-sdk | private void startMonitoringRegions ( List < Region > altRegions ) { try { for ( Region region : altRegions ) { beaconManager . startMonitoringBeaconsInRegion ( region ) ; GGGLogImpl . log ( " Start ▁ Beacons ▁ Monitoring ▁ for ▁ region ▁ " + region . getUniqueId ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } monitoring = true ; }
fSergio101/orchextra-android-sdk | private void stopMonitoringRegions ( List < Region > altRegions ) { try { for ( Region region : altRegions ) { beaconManager . stopMonitoringBeaconsInRegion ( region ) ; GGGLogImpl . log ( " Stop ▁ Beacons ▁ Monitoring ▁ for ▁ region ▁ " + region . getUniqueId ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } }
fSergio101/orchextra-android-sdk | public List < Region > obtainRegionsInRange ( ) { return regionsInEnter ; }
adrapereira/jena | @ Test public void setup_01 ( ) { assertTrue ( RDFLanguages . isRegistered ( THRIFT ) ) ; }
adrapereira/jena | @ Test public void setup_02 ( ) { Lang lang = RDFLanguages . filenameToLang ( " data . rt " ) ; assertEquals ( lang , THRIFT ) ; }
adrapereira/jena | @ Test public void setup_03 ( ) { assertTrue ( RDFParserRegistry . isQuads ( THRIFT ) ) ; assertTrue ( RDFParserRegistry . isTriples ( THRIFT ) ) ; assertNotNull ( RDFParserRegistry . getFactory ( THRIFT ) ) ; }
adrapereira/jena | @ Test public void setup_04 ( ) { assertTrue ( RDFWriterRegistry . contains ( THRIFT ) ) ; assertNotNull ( RDFWriterRegistry . getWriterDatasetFactory ( THRIFT ) ) ; assertTrue ( RDFWriterRegistry . contains ( RDFFormat . RDF_THRIFT ) ) ; assertNotNull ( RDFWriterRegistry . getWriterDatasetFactory ( RDFFormat . RDF_THRIFT ) ) ; assertTrue ( RDFWriterRegistry . contains ( RDFFormat . RDF_THRIFT_VALUES ) ) ; assertNotNull ( RDFWriterRegistry . getWriterDatasetFactory ( RDFFormat . RDF_THRIFT_VALUES ) ) ; }
emory-libraries-ecds/namedropper-oxygen | public SelectionActionGeoNames ( StandalonePluginWorkspace ws ) { super ( ws ) ; this . putValue ( Action . NAME , this . name ) ; this . putValue ( Action . ACCELERATOR_KEY , this . shortcut ) ; }
emory-libraries-ecds/namedropper-oxygen | public String getShortName ( ) { return this . shortName ; }
emory-libraries-ecds/namedropper-oxygen | public String processSelection ( String selection ) throws Exception { String result = selection ; if ( this . tagAllowedAtSelection ( DocumentType . NameType . GEOGRAPHIC ) == false ) { throw new Exception ( " Tag ▁ is ▁ not ▁ allowed ▁ in ▁ the ▁ current ▁ context " ) ; } result = this . queryGeoNames ( selection ) ; if ( result == null ) { result = selection ; } return result ; }
emory-libraries-ecds/namedropper-oxygen | public String queryGeoNames ( String text ) throws Exception { String result = null ; if ( this . docType == null ) { return result ; } String username = SelectionActionGeoNames . getGeoNamesUsername ( ) ; if ( username . isEmpty ( ) ) { throw new Exception ( " Please ▁ set ▁ a ▁ GeoNames . org ▁ username " ) ; } WebService . setUserName ( username ) ; ToponymSearchCriteria search = new ToponymSearchCriteria ( ) ; search . setQ ( text ) ; ToponymSearchResult searchResult = WebService . search ( search ) ; if ( searchResult . getTotalResultsCount ( ) == 0 ) { throw new Exception ( " No ▁ Results " ) ; } Toponym selection = this . getUserSelection ( searchResult . getToponyms ( ) ) ; if ( selection != null ) { result = this . docType . makeTag ( text , selection ) ; } return result ; }
emory-libraries-ecds/namedropper-oxygen | public Toponym getUserSelection ( List < Toponym > suggestions ) { Object [ ] choices = suggestions . toArray ( ) ; String [ ] labels = new String [ suggestions . size ( ) ] ; for ( int i = 0 ; i < suggestions . size ( ) ; i ++ ) { Toponym t = suggestions . get ( i ) ; labels [ i ] = t . getName ( ) ; if ( ! t . getCountryName ( ) . isEmpty ( ) ) { labels [ i ] += String . format ( " ▁ ( % s ) " , t . getCountryName ( ) ) ; } } Object choice = JOptionPane . showInputDialog ( null , " Names " , " Search ▁ Results " , JOptionPane . PLAIN_MESSAGE , null , labels , labels [ 0 ] ) ; if ( choice == null ) { return null ; } else { return suggestions . get ( Arrays . asList ( labels ) . indexOf ( choice ) ) ; } }
emory-libraries-ecds/namedropper-oxygen | public boolean hasUserOptions ( ) { return true ; }
emory-libraries-ecds/namedropper-oxygen | public Action getOptionsAction ( ) { final Action showOptions = new AbstractAction ( ) { public void actionPerformed ( ActionEvent selection ) { String dialogLabel = " GeoNames . org ▁ settings " ; JTextField username = new JTextField ( SelectionActionGeoNames . getGeoNamesUsername ( ) , 15 ) ; JPanel optionPanel = new JPanel ( ) ; java . awt . GridLayout layout = new java . awt . GridLayout ( 2 , 2 ) ; optionPanel . setLayout ( layout ) ; optionPanel . add ( new JLabel ( " GeoNames ▁ API ▁ Username : ▁ " ) ) ; optionPanel . add ( username ) ; int result = JOptionPane . showConfirmDialog ( ( java . awt . Frame ) workspace . getParentFrame ( ) , optionPanel , dialogLabel , JOptionPane . OK_CANCEL_OPTION ) ; if ( result == JOptionPane . OK_OPTION ) { SelectionActionGeoNames . setGeoNamesUsername ( username . getText ( ) ) ; } } } ; return showOptions ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test ( expected = NullPointerException . class ) public void initAutoCompleterWithNullPreferenceThrowsException ( ) { new BibtexKeyAutoCompleter ( null ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeWithoutAddingAnythingReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeAfterAddingNullReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; autoCompleter . addBibtexEntry ( null ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeAfterAddingEmptyEntryReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " testKey " ) ; Assert . assertEquals ( Arrays . asList ( " testKey " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeBeginnigOfKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Arrays . asList ( " testKey " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeLowercaseKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " testkey " ) ; Assert . assertEquals ( Arrays . asList ( " testKey " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeNullReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( null ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeEmptyStringReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeReturnsMultipleResults ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entryOne = new BibEntry ( ) ; entryOne . setCiteKey ( " testKeyOne " ) ; autoCompleter . addBibtexEntry ( entryOne ) ; BibEntry entryTwo = new BibEntry ( ) ; entryTwo . setCiteKey ( " testKeyTwo " ) ; autoCompleter . addBibtexEntry ( entryTwo ) ; List < String > result = autoCompleter . complete ( " testKey " ) ; Assert . assertEquals ( Arrays . asList ( " testKeyOne " , " testKeyTwo " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeShortKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " key " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " k " ) ; Assert . assertEquals ( Arrays . asList ( " key " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeTooShortInputReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; when ( preferences . getShortestLengthToComplete ( ) ) . thenReturn ( 100 ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
apache/incubator-asterixdb | public ActiveEvent ( JobId jobId , Kind eventKind , EntityId entityId , Object eventObject ) { this . jobId = jobId ; this . entityId = entityId ; this . eventKind = eventKind ; this . eventObject = eventObject ; }
apache/incubator-asterixdb | public JobId getJobId ( ) { return jobId ; }
apache/incubator-asterixdb | public EntityId getEntityId ( ) { return entityId ; }
apache/incubator-asterixdb | public Kind getEventKind ( ) { return eventKind ; }
apache/incubator-asterixdb | public Object getEventObject ( ) { return eventObject ; }
apache/incubator-asterixdb | @ Override public String toString ( ) { return " JobId : " + jobId + " , " + " EntityId : " + entityId + " , ▁ " + " Kind " + eventKind ; }
apache/incubator-asterixdb | @ Override public boolean equals ( Object o ) { if ( ! ( o instanceof ActiveEvent ) ) { return false ; } if ( this == o ) { return true ; } ActiveEvent other = ( ActiveEvent ) o ; return Objects . equals ( entityId , other . entityId ) && Objects . equals ( eventKind , other . eventKind ) && Objects . equals ( eventObject , other . eventObject ) ; }
apache/incubator-asterixdb | @ Override public int hashCode ( ) { return Objects . hash ( jobId , entityId , eventKind , eventObject ) ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof UpdateQueueNameResult == false ) return false ; UpdateQueueNameResult other = ( UpdateQueueNameResult ) obj ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; return hashCode ; }
aws/aws-sdk-java | @ Override public UpdateQueueNameResult clone ( ) { try { return ( UpdateQueueNameResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
georgewfraser/vscode-javac | public void test ( ) { print ( this :: ) }
georgewfraser/vscode-javac | private void print ( Supplier < String > message ) { System . out . println ( message . get ( ) ) ; }
georgewfraser/vscode-javac | private String testMethods ( ) { return " foo " ; }
MohammedHammam/camel | public WebsocketEndpoint ( WebsocketComponent component , String uri , String resourceUri , Map < String , Object > parameters ) { super ( uri , component ) ; this . resourceUri = resourceUri ; this . memoryStore = new MemoryWebsocketStore ( ) ; this . sync = new DefaultNodeSynchronization ( memoryStore ) ; this . component = component ; try { this . uri = new URI ( uri ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( e ) ; } }
MohammedHammam/camel | @ Override public WebsocketComponent getComponent ( ) { ObjectHelper . notNull ( component , " component " ) ; return ( WebsocketComponent ) super . getComponent ( ) ; }
MohammedHammam/camel | @ Override public Consumer createConsumer ( Processor processor ) throws Exception { ObjectHelper . notNull ( component , " component " ) ; WebsocketConsumer consumer = new WebsocketConsumer ( this , processor ) ; configureConsumer ( consumer ) ; return consumer ; }
MohammedHammam/camel | @ Override public Producer createProducer ( ) throws Exception { return new WebsocketProducer ( this , memoryStore ) ; }
MohammedHammam/camel | public void connect ( WebsocketConsumer consumer ) throws Exception { component . connect ( consumer ) ; component . addServlet ( sync , consumer , resourceUri ) ; }
MohammedHammam/camel | public void disconnect ( WebsocketConsumer consumer ) throws Exception { component . disconnect ( consumer ) ; }
MohammedHammam/camel | public void connect ( WebsocketProducer producer ) throws Exception { component . connect ( producer ) ; component . addServlet ( sync , producer , resourceUri ) ; }
MohammedHammam/camel | public void disconnect ( WebsocketProducer producer ) throws Exception { component . disconnect ( producer ) ; }
MohammedHammam/camel | @ Override public boolean isSingleton ( ) { return true ; }
MohammedHammam/camel | public URI getUri ( ) { return uri ; }
MohammedHammam/camel | public Integer getPort ( ) { return port ; }
MohammedHammam/camel | public String getHost ( ) { return host ; }
MohammedHammam/camel | public void setHost ( String host ) { this . host = host ; }
MohammedHammam/camel | public void setPort ( int port ) { this . port = port ; }
MohammedHammam/camel | public String getStaticResources ( ) { return staticResources ; }
MohammedHammam/camel | public void setStaticResources ( String staticResources ) { this . staticResources = staticResources ; }
MohammedHammam/camel | public Boolean getSendToAll ( ) { return sendToAll ; }
MohammedHammam/camel | public void setSendToAll ( Boolean sendToAll ) { this . sendToAll = sendToAll ; }
MohammedHammam/camel | public String getProtocol ( ) { return uri . getScheme ( ) ; }
MohammedHammam/camel | public String getPath ( ) { return uri . getPath ( ) ; }
MohammedHammam/camel | public void setSessionSupport ( boolean support ) { sessionSupport = support ; }
MohammedHammam/camel | public boolean isSessionSupport ( ) { return sessionSupport ; }
MohammedHammam/camel | public Integer getBufferSize ( ) { return bufferSize ; }
MohammedHammam/camel | public void setBufferSize ( Integer bufferSize ) { this . bufferSize = bufferSize ; }
MohammedHammam/camel | public Integer getMaxIdleTime ( ) { return maxIdleTime ; }
MohammedHammam/camel | public void setMaxIdleTime ( Integer maxIdleTime ) { this . maxIdleTime = maxIdleTime ; }
MohammedHammam/camel | public Integer getMaxTextMessageSize ( ) { return maxTextMessageSize ; }
MohammedHammam/camel | public void setMaxTextMessageSize ( Integer maxTextMessageSize ) { this . maxTextMessageSize = maxTextMessageSize ; }
MohammedHammam/camel | public Integer getMaxBinaryMessageSize ( ) { return maxBinaryMessageSize ; }
MohammedHammam/camel | public void setMaxBinaryMessageSize ( Integer maxBinaryMessageSize ) { this . maxBinaryMessageSize = maxBinaryMessageSize ; }
MohammedHammam/camel | public Integer getMinVersion ( ) { return minVersion ; }
MohammedHammam/camel | public void setMinVersion ( Integer minVersion ) { this . minVersion = minVersion ; }
MohammedHammam/camel | public List < Handler > getHandlers ( ) { return handlers ; }
MohammedHammam/camel | public void setHandlers ( List < Handler > handlers ) { this . handlers = handlers ; }
MohammedHammam/camel | public SSLContextParameters getSslContextParameters ( ) { return sslContextParameters ; }
MohammedHammam/camel | public void setSslContextParameters ( SSLContextParameters sslContextParameters ) { this . sslContextParameters = sslContextParameters ; }
MohammedHammam/camel | public boolean isEnableJmx ( ) { return this . enableJmx ; }
MohammedHammam/camel | public void setEnableJmx ( boolean enableJmx ) { this . enableJmx = enableJmx ; }
MohammedHammam/camel | public String getAllowedOrigins ( ) { return allowedOrigins ; }
MohammedHammam/camel | public void setAllowedOrigins ( String allowedOrigins ) { this . allowedOrigins = allowedOrigins ; }
MohammedHammam/camel | public boolean isCrossOriginFilterOn ( ) { return crossOriginFilterOn ; }
MohammedHammam/camel | public void setCrossOriginFilterOn ( boolean crossOriginFilterOn ) { this . crossOriginFilterOn = crossOriginFilterOn ; }
MohammedHammam/camel | public String getFilterPath ( ) { return filterPath ; }
MohammedHammam/camel | public void setFilterPath ( String filterPath ) { this . filterPath = filterPath ; }
MohammedHammam/camel | public String getResourceUri ( ) { return resourceUri ; }
MohammedHammam/camel | public void setResourceUri ( String resourceUri ) { this . resourceUri = resourceUri ; }
MohammedHammam/camel | @ Override protected void doStart ( ) throws Exception { ServiceHelper . startService ( memoryStore ) ; super . doStart ( ) ; }
MohammedHammam/camel | @ Override protected void doStop ( ) throws Exception { ServiceHelper . stopService ( memoryStore ) ; super . doStop ( ) ; }
Azure/azure-sdk-for-java | @ Generated SqlScriptAsyncClient ( SqlScriptsImpl serviceClient ) { this . serviceClient = serviceClient ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . COLLECTION ) public PagedFlux < SqlScriptResource > getSqlScriptsByWorkspace ( ) { return this . serviceClient . getSqlScriptsByWorkspaceAsync ( ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < SqlScriptResource > > createOrUpdateSqlScriptWithResponse ( String sqlScriptName , SqlScriptResource sqlScript , String ifMatch ) { return this . serviceClient . createOrUpdateSqlScriptWithResponseAsync ( sqlScriptName , sqlScript , ifMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > createOrUpdateSqlScript ( String sqlScriptName , SqlScriptResource sqlScript , String ifMatch ) { return this . serviceClient . createOrUpdateSqlScriptAsync ( sqlScriptName , sqlScript , ifMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > createOrUpdateSqlScript ( String sqlScriptName , SqlScriptResource sqlScript ) { return this . serviceClient . createOrUpdateSqlScriptAsync ( sqlScriptName , sqlScript ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < SqlScriptResource > > getSqlScriptWithResponse ( String sqlScriptName , String ifNoneMatch ) { return this . serviceClient . getSqlScriptWithResponseAsync ( sqlScriptName , ifNoneMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > getSqlScript ( String sqlScriptName , String ifNoneMatch ) { return this . serviceClient . getSqlScriptAsync ( sqlScriptName , ifNoneMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > getSqlScript ( String sqlScriptName ) { return this . serviceClient . getSqlScriptAsync ( sqlScriptName ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < Void > > deleteSqlScriptWithResponse ( String sqlScriptName ) { return this . serviceClient . deleteSqlScriptWithResponseAsync ( sqlScriptName ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Void > deleteSqlScript ( String sqlScriptName ) { return this . serviceClient . deleteSqlScriptAsync ( sqlScriptName ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < Void > > renameSqlScriptWithResponse ( String sqlScriptName , ArtifactRenameRequest request ) { return this . serviceClient . renameSqlScriptWithResponseAsync ( sqlScriptName , request ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Void > renameSqlScript ( String sqlScriptName , ArtifactRenameRequest request ) { return this . serviceClient . renameSqlScriptAsync ( sqlScriptName , request ) ; }
wolfdog007/aruzhev | public int [ ] mergingArray ( int [ ] firstArray , int [ ] secondArray ) { int [ ] resultArray = new int [ firstArray . length + secondArray . length ] ; for ( int i = 0 , j = 0 ; i + j < resultArray . length ; ) { resultArray [ i + j ] = firstArray [ i ] <= secondArray [ j ] ? firstArray [ i ++ ] : secondArray [ j ++ ] ; if ( i == firstArray . length ) { for ( ; j < secondArray . length ; j ++ ) { resultArray [ i + j ] = secondArray [ j ] ; } } if ( j == secondArray . length ) { for ( ; i < firstArray . length ; i ++ ) { resultArray [ i + j ] = firstArray [ i ] ; } } } return resultArray ; }
Legioth/vaadin | @ Override public void setup ( ) throws Exception { super . setup ( ) ; openTestURL ( ) ; TableElement table = $ ( TableElement . class ) . id ( " table " ) ; rowHeight = table . getCell ( 1 , 0 ) . getLocation ( ) . getY ( ) - table . getCell ( 0 , 0 ) . getLocation ( ) . getY ( ) ; wrapper = findElement ( By . className ( " v - table - body - wrapper " ) ) ; }
Legioth/vaadin | @ Test public void testScrollingThenUpdatingContents ( ) throws Exception { testBenchElement ( wrapper ) . scroll ( 44 * rowHeight ) ; waitForScrollToFinish ( ) ; Assert . assertTrue ( " Button ▁ widget ▁ was ▁ not ▁ found ▁ after ▁ scrolling ▁ for ▁ the ▁ first ▁ time " , ! findElements ( By . id ( "46" ) ) . isEmpty ( ) ) ; WebElement refreshButton = findElement ( By . id ( " refresh " ) ) ; refreshButton . click ( ) ; testBenchElement ( wrapper ) . scroll ( 44 * rowHeight ) ; waitForScrollToFinish ( ) ; Assert . assertTrue ( " Button ▁ widget ▁ was ▁ not ▁ found ▁ after ▁ refreshing ▁ container ▁ items . " , ! findElements ( By . id ( "46" ) ) . isEmpty ( ) ) ; }
Legioth/vaadin | private void waitForScrollToFinish ( ) { waitUntil ( new ExpectedCondition < Boolean > ( ) { @ Override public Boolean apply ( WebDriver input ) { List < WebElement > elements = findElements ( By . className ( " v - table - scrollposition " ) ) ; return elements . isEmpty ( ) || ! elements . get ( 0 ) . isDisplayed ( ) ; } @ Override public String toString ( ) { return " scroll ▁ position ▁ indicator ▁ to ▁ vanish " ; } } ) ; }
avafanasiev/groovy | @ Override protected void compile ( ) { GroovyClassLoader gcl = createClassLoader ( ) ; JavaStubCompilationUnit cu = new JavaStubCompilationUnit ( config , gcl , destdir ) ; int count = 0 ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File basedir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! basedir . exists ( ) ) { throw new BuildException ( " Source ▁ directory ▁ does ▁ not ▁ exist : ▁ " + basedir , getLocation ( ) ) ; } DirectoryScanner scanner = getDirectoryScanner ( basedir ) ; String [ ] includes = scanner . getIncludedFiles ( ) ; log . debug ( " Including ▁ files ▁ from : ▁ " + basedir ) ; for ( int j = 0 ; j < includes . length ; j ++ ) { log . debug ( " ▁ ▁ ▁ ▁ " + includes [ j ] ) ; File file = new File ( basedir , includes [ j ] ) ; cu . addSource ( file ) ; if ( ! includes [ j ] . endsWith ( " . java " ) ) { count ++ ; } } } if ( count > 0 ) { log . info ( " Generating ▁ " + count + " ▁ Java ▁ stub " + ( count > 1 ? " s " : " " ) + " ▁ to ▁ " + destdir ) ; cu . compile ( ) ; log . info ( " Generated ▁ " + cu . getStubCount ( ) + " ▁ Java ▁ stub ( s ) " ) ; } else { log . info ( " No ▁ sources ▁ found ▁ for ▁ stub ▁ generation " ) ; } }
PrinceOfAmber/OpenBlocks | public ItemOBGenericUnstackable ( ) { setMaxStackSize ( 1 ) ; setCreativeTab ( OpenBlocks . tabOpenBlocks ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | public EdgeExplorer ( int allowedEdges , EvaluationCtx ctx , URI startPolicy ) { this . node = ctx . getReductionGraph ( ) . getNode ( startPolicy ) ; this . ctx = ctx ; this . allowedEdges = allowedEdges ; AbstractPolicy parentPolicySet = ctx . getParentPolicySet ( ) ; if ( parentPolicySet != null ) { this . neighbors = getActiveChilds ( parentPolicySet . getChildren ( ) , ctx ) ; } else { this . neighbors = new ArrayList < AbstractPolicy > ( ) ; } this . neighborIter = this . neighbors . iterator ( ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | public boolean hasNext ( ) { return this . neighborIter . hasNext ( ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | public URI next ( ) { if ( ! this . neighborIter . hasNext ( ) ) { return null ; } AbstractPolicy neighbor = ( AbstractPolicy ) this . neighborIter . next ( ) ; Set < ReductionGraphEdge > fromEdges = this . ctx . getReductionGraph ( ) . getFromEdges ( this . node . getNodeId ( ) ) ; Iterator < ReductionGraphEdge > edgeIt = fromEdges . iterator ( ) ; while ( edgeIt . hasNext ( ) ) { ReductionGraphEdge edge = edgeIt . next ( ) ; if ( edge . getTo ( ) . equals ( neighbor . getId ( ) ) ) { if ( ( this . allowedEdges & edge . getType ( ) ) == edge . getType ( ) ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return neighbor . getId ( ) ; } else if ( edge . getType ( ) == ReductionGraphEdge . NOT_APPLICABLE ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return next ( ) ; } else if ( ( ( this . allowedEdges & ReductionGraphEdge . PP ) == ReductionGraphEdge . PP ) && edge . getType ( ) == ReductionGraphEdge . PI ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return next ( ) ; } else if ( ( ( this . allowedEdges & ReductionGraphEdge . DP ) == ReductionGraphEdge . DP ) && edge . getType ( ) == ReductionGraphEdge . DI ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return next ( ) ; } } } this . ctx . newEvent ( neighbor ) ; MatchResult matchResult = neighbor . match ( this . ctx ) ; switch ( matchResult . getResult ( ) ) { case MatchResult . NO_MATCH : this . ctx . closeCurrentEvent ( new Result ( Result . DECISION_NOT_APPLICABLE ) ) ; this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return next ( ) ; case MatchResult . INDETERMINATE : this . ctx . closeCurrentEvent ( new Result ( Result . DECISION_INDETERMINATE , this . ctx ) ) ; if ( this . ctx . getDecision ( ) == Result . DECISION_PERMIT ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . PI , matchResult . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . PI ) == ReductionGraphEdge . PI ) { return neighbor . getId ( ) ; } } else { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . DI , matchResult . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . DI ) == ReductionGraphEdge . DI ) { return neighbor . getId ( ) ; } } return next ( ) ; case MatchResult . MATCH : if ( neighbor instanceof PolicySet ) { this . ctx . saveParentPolicySet ( neighbor ) ; } else if ( neighbor instanceof PolicyReference ) { PolicyReference ref = ( PolicyReference ) neighbor ; if ( ref . getReferenceType ( ) == PolicyReference . POLICYSET_REFERENCE ) { this . ctx . saveParentPolicySet ( neighbor ) ; } } Result eval = neighbor . getCombiningAlg ( ) . combine ( this . ctx , neighbor . getCombiningParameters ( ) , neighbor . getChildElements ( ) ) ; if ( this . ctx . getDelegationDepth ( ) > neighbor . getMaxDelegationDepth ( ) ) { this . ctx . closeCurrentEvent ( " MaxDelegationDepth ▁ violated " ) ; this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return null ; } if ( this . ctx . supportsRevocation ( neighbor , this . node . getNodeId ( ) ) ) { Result nullResult = null ; this . ctx . closeCurrentEvent ( nullResult ) ; this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return null ; } this . ctx . closeCurrentEvent ( eval ) ; if ( neighbor instanceof PolicySet ) { this . ctx . popParentPolicySet ( ) ; this . ctx . popReductionGraph ( ) ; } else if ( neighbor instanceof PolicyReference ) { PolicyReference ref = ( PolicyReference ) neighbor ; if ( ref . getReferenceType ( ) == PolicyReference . POLICYSET_REFERENCE ) { this . ctx . popParentPolicySet ( ) ; this . ctx . popReductionGraph ( ) ; } } switch ( eval . getDecision ( ) ) { case Result . DECISION_PERMIT : if ( this . ctx . getDecision ( ) == Result . DECISION_PERMIT ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . PP ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . PP ) == ReductionGraphEdge . PP ) { return neighbor . getId ( ) ; } } else if ( this . ctx . getDecision ( ) == Result . DECISION_DENY ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . DP ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . DP ) == ReductionGraphEdge . DP ) { return neighbor . getId ( ) ; } } return next ( ) ; case Result . DECISION_INDETERMINATE : if ( this . ctx . getDecision ( ) == Result . DECISION_PERMIT ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . PI , eval . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . PI ) == ReductionGraphEdge . PI ) { return neighbor . getId ( ) ; } } else if ( this . ctx . getDecision ( ) == Result . DECISION_DENY ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . DI , eval . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . DI ) == ReductionGraphEdge . DI ) { return neighbor . getId ( ) ; } } return next ( ) ; default : this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return next ( ) ; } } return next ( ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | private List < AbstractPolicy > getActiveChilds ( List < PolicyTreeElement > allChilds , EvaluationCtx context ) { List < AbstractPolicy > activeChilds = new ArrayList < AbstractPolicy > ( ) ; Iterator < PolicyTreeElement > iter = allChilds . iterator ( ) ; while ( iter . hasNext ( ) ) { AbstractPolicy policy = ( AbstractPolicy ) iter . next ( ) ; URI elementId = null ; if ( policy instanceof PolicyReference ) { PolicyReference pr = ( PolicyReference ) policy ; elementId = pr . getReference ( ) ; } else { elementId = policy . getId ( ) ; } if ( ! context . getInactivePolicyIds ( ) . contains ( elementId ) ) { activeChilds . add ( policy ) ; } } return activeChilds ; }
xushaomin/apple-pay | public String getUserName ( ) { return userName ; }
xushaomin/apple-pay | public void setUserName ( String userName ) { this . userName = userName ; }
xushaomin/apple-pay | public BigDecimal getAvailableBalance ( ) { return this . balance . subtract ( unbalance ) ; }
xushaomin/apple-pay | public BigDecimal getAvailableSettAmount ( ) { BigDecimal subSettAmount = this . settAmount . subtract ( unbalance ) ; if ( getAvailableBalance ( ) . compareTo ( subSettAmount ) == - 1 ) { return getAvailableBalance ( ) ; } return subSettAmount ; }
xushaomin/apple-pay | public boolean availableBalanceIsEnough ( BigDecimal amount ) { return this . getAvailableBalance ( ) . compareTo ( amount ) >= 0 ; }
xushaomin/apple-pay | public String getAccountNo ( ) { return accountNo ; }
xushaomin/apple-pay | public void setAccountNo ( String accountNo ) { this . accountNo = accountNo == null ? null : accountNo . trim ( ) ; }
xushaomin/apple-pay | public BigDecimal getBalance ( ) { return balance ; }
xushaomin/apple-pay | public void setBalance ( BigDecimal balance ) { this . balance = balance ; }
xushaomin/apple-pay | public BigDecimal getUnbalance ( ) { return unbalance ; }
xushaomin/apple-pay | public void setUnbalance ( BigDecimal unbalance ) { this . unbalance = unbalance ; }
xushaomin/apple-pay | public BigDecimal getSecurityMoney ( ) { return securityMoney ; }
xushaomin/apple-pay | public void setSecurityMoney ( BigDecimal securityMoney ) { this . securityMoney = securityMoney ; }
xushaomin/apple-pay | public BigDecimal getTotalIncome ( ) { return totalIncome ; }
xushaomin/apple-pay | public void setTotalIncome ( BigDecimal totalIncome ) { this . totalIncome = totalIncome ; }
xushaomin/apple-pay | public BigDecimal getTotalExpend ( ) { return totalExpend ; }
xushaomin/apple-pay | public void setTotalExpend ( BigDecimal totalExpend ) { this . totalExpend = totalExpend ; }
xushaomin/apple-pay | public BigDecimal getTodayIncome ( ) { return todayIncome ; }
xushaomin/apple-pay | public void setTodayIncome ( BigDecimal todayIncome ) { this . todayIncome = todayIncome ; }
xushaomin/apple-pay | public BigDecimal getTodayExpend ( ) { return todayExpend ; }
xushaomin/apple-pay | public void setTodayExpend ( BigDecimal todayExpend ) { this . todayExpend = todayExpend ; }
xushaomin/apple-pay | public String getAccountType ( ) { return accountType ; }
xushaomin/apple-pay | public void setAccountType ( String accountType ) { this . accountType = accountType == null ? null : accountType . trim ( ) ; }
xushaomin/apple-pay | public BigDecimal getSettAmount ( ) { return settAmount ; }
xushaomin/apple-pay | public void setSettAmount ( BigDecimal settAmount ) { this . settAmount = settAmount ; }
xushaomin/apple-pay | public String getUserNo ( ) { return userNo ; }
xushaomin/apple-pay | public void setUserNo ( String userNo ) { this . userNo = userNo == null ? null : userNo . trim ( ) ; }
theonlyguills/doc-gym | @ Override public void init ( FilterConfig filterConfig ) throws ServletException { }
theonlyguills/doc-gym | if ( DOCFITNESS_CA . equals ( servletRequest . getServerName ( ) ) ) { HttpServletResponse response = ( HttpServletResponse ) servletResponse ; response . sendRedirect ( WWW_DOCFITNESS_CA ) ; return ; }
theonlyguills/doc-gym | @ Override public void destroy ( ) { }
leafclick/intellij-community | private Mixin ( @ NotNull PsiType type , @ Nullable ConditionInstruction condition , boolean negated ) { myType = type ; myCondition = condition ; myNegated = negated ; }
leafclick/intellij-community | private Mixin negate ( ) { return new Mixin ( myType , myCondition , ! myNegated ) ; }
leafclick/intellij-community | @ Override public String toString ( ) { return ( myNegated ? " ! " : " " ) + myType ; }
leafclick/intellij-community | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Mixin mixin = ( Mixin ) o ; if ( ! myType . equals ( mixin . myType ) ) return false ; if ( ! Objects . equals ( myCondition , mixin . myCondition ) ) return false ; return true ; }
leafclick/intellij-community | @ Override public int hashCode ( ) { int result = myType . hashCode ( ) ; result = 31 * result + ( myCondition != null ? myCondition . hashCode ( ) : 0 ) ; return result ; }
leafclick/intellij-community | private DFAType ( @ Nullable PsiType primary ) { this . primary = primary ; }
leafclick/intellij-community | public void addMixin ( @ Nullable PsiType mixin , @ Nullable ConditionInstruction instruction ) { if ( mixin == null ) { return ; } mixins . add ( new Mixin ( mixin , instruction , instruction != null && instruction . isNegated ( ) ) ) ; }
leafclick/intellij-community | @ Override public boolean equals ( Object obj ) { if ( obj == this ) return true ; if ( ! ( obj instanceof DFAType ) ) return false ; final DFAType other = ( DFAType ) obj ; if ( ! eq ( primary , other . primary ) ) return false ; if ( mixins . size ( ) != other . mixins . size ( ) ) return false ; for ( Mixin mixin1 : mixins ) { boolean contains = false ; for ( Mixin mixin2 : other . mixins ) { if ( mixin1 . equals ( mixin2 ) ) { contains = mixin1 . myNegated == mixin2 . myNegated ; break ; } } if ( ! contains ) return false ; } return true ; }
leafclick/intellij-community | @ Contract ( " - > ▁ new " ) @ NotNull public DFAType copy ( ) { final DFAType type = new DFAType ( primary ) ; type . mixins . addAll ( mixins ) ; return type ; }
leafclick/intellij-community | @ Contract ( " _ ▁ - > ▁ new " ) @ NotNull public DFAType negate ( @ NotNull NegatingGotoInstruction negation ) { DFAType result = copy ( ) ; final Set < ConditionInstruction > conditionsToNegate = negation . getCondition ( ) . getDependentConditions ( ) ; for ( ListIterator < Mixin > iterator = result . mixins . listIterator ( ) ; iterator . hasNext ( ) ; ) { Mixin mixin = iterator . next ( ) ; if ( conditionsToNegate . contains ( mixin . myCondition ) ) { iterator . set ( mixin . negate ( ) ) ; } } return result ; }
leafclick/intellij-community | @ Nullable public PsiType getResultType ( ) { if ( mixins . isEmpty ( ) ) return primary ; List < PsiType > types = new ArrayList < > ( ) ; if ( primary != null ) { types . add ( primary ) ; } for ( Mixin mixin : mixins ) { if ( mixin . myNegated ) { continue ; } if ( mixin . myType . equals ( PsiType . NULL ) ) { continue ; } types . add ( mixin . myType ) ; } if ( types . isEmpty ( ) ) return null ; return PsiIntersectionType . createIntersection ( types . toArray ( PsiType . createArray ( types . size ( ) ) ) ) ; }
leafclick/intellij-community | @ Override public String toString ( ) { return " { " + primary + " ▁ : ▁ " + mixins + " } " ; }
fraunhoferfokus/Fuzzino | public BadIpAddressesGenerator ( StringSpecification stringSpec , long seed ) { super ( stringSpec , seed ) ; this . owners . add ( this ) ; initHeuristics ( ) ; }
fraunhoferfokus/Fuzzino | public BadIpAddressesGenerator ( StringSpecification stringSpec , long seed , List < FuzzingHeuristic > owners ) { super ( stringSpec , seed , owners ) ; this . owners . add ( this ) ; initHeuristics ( ) ; }
fraunhoferfokus/Fuzzino | private void initHeuristics ( ) { SpecialBadIpAddressesGenerator specialBadIpAddressesGenerator = new SpecialBadIpAddressesGenerator ( stringSpec , seed , owners ) ; BadNumbersAsStringGenerator badNumbers = new BadNumbersAsStringGenerator ( stringSpec , seed , owners ) ; ConcreteValuesGenerator dot = new ConcreteValuesGenerator ( stringSpec , seed , owners , " . " ) ; Combinator badIpAddress = new Combinator ( stringSpec , seed , owners , badNumbers , dot , badNumbers , dot , badNumbers , dot , badNumbers ) ; heuristics . add ( specialBadIpAddressesGenerator ) ; heuristics . add ( badIpAddress ) ; }
fraunhoferfokus/Fuzzino | @ Override public boolean canCreateValuesFor ( StringSpecification stringSpec ) { boolean validType = stringSpec . getType ( ) == StringType . IP_ADDRESS ; return validType ; }
fraunhoferfokus/Fuzzino | @ Override public String getName ( ) { return " BadIpAddresses " ; }
Nekorp/Tikal-Technology | public GrupoRegistroAlmacen ( Long pedidoId , Long idProveedor , LineaDeProductos linea ) { registros = new LinkedList < > ( ) ; this . pedidoId = pedidoId ; this . idProveedor = idProveedor ; this . linea = linea ; }
Nekorp/Tikal-Technology | @ Override public Long getPedidoId ( ) { return pedidoId ; }
Nekorp/Tikal-Technology | @ Override public Long getId ( ) { return null ; }
Nekorp/Tikal-Technology | @ Override public Producto getProducto ( ) { return null ; }
Nekorp/Tikal-Technology | @ Override public Long getIdProveedor ( ) { return idProveedor ; }
Nekorp/Tikal-Technology | @ Override public Long getCantidad ( ) { long cantidad = 0 ; for ( RegistroAlmacen x : registros ) { cantidad = cantidad + x . getCantidad ( ) ; } return cantidad ; }
Nekorp/Tikal-Technology | public void updateFechaCreacion ( Date fecha ) { if ( fechaDeCreacion == null || fecha . before ( fechaDeCreacion ) ) { this . fechaDeCreacion = fecha ; } }
Nekorp/Tikal-Technology | public Date getFechaDeCreacion ( ) { return fechaDeCreacion ; }
Nekorp/Tikal-Technology | public LineaDeProductos getLinea ( ) { return linea ; }
Nekorp/Tikal-Technology | public RegistroAlmacen [ ] getRegistros ( ) { RegistroAlmacen [ ] response = new RegistroAlmacen [ registros . size ( ) ] ; registros . toArray ( response ) ; return response ; }
Nekorp/Tikal-Technology | public void addRegistro ( RegistroAlmacen pedimento ) { if ( ! pedimento . getIdProveedor ( ) . equals ( this . idProveedor ) ) { throw new IllegalArgumentException ( ) ; } this . registros . add ( pedimento ) ; }
Nekorp/Tikal-Technology | @ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final GrupoRegistroAlmacen other = ( GrupoRegistroAlmacen ) obj ; return Objects . equals ( this . pedidoId , other . pedidoId ) && Objects . equals ( this . linea . getId ( ) , other . linea . getId ( ) ) && Objects . equals ( this . linea . getCatalogoId ( ) , other . linea . getCatalogoId ( ) ) && Objects . equals ( this . idProveedor , other . idProveedor ) ; }
Nekorp/Tikal-Technology | @ Override public int hashCode ( ) { return Objects . hash ( this . pedidoId , this . linea . getId ( ) , this . linea . getCatalogoId ( ) , this . idProveedor ) ; }
Nekorp/Tikal-Technology | @ Override public Date getFechaRegistro ( ) { return null ; }
Nekorp/Tikal-Technology | @ Override public Long getReferenciaEnvio ( ) { return referenciaEnvio ; }
Nekorp/Tikal-Technology | public void setReferenciaEnvio ( Long referenciaEnvio ) { this . referenciaEnvio = referenciaEnvio ; }
gravitee-io/gravitee-gateway | @ Before public void setUp ( ) { initMocks ( this ) ; }
gravitee-io/gravitee-gateway | @ Test public void doNext_multiplePolicyOrder ( ) throws Exception { List < Policy > policies = policies2 ( ) ; PolicyChain requestChain = OrderedPolicyChain . create ( policies , mock ( ExecutionContext . class ) ) ; requestChain . handler ( result -> { } ) ; PolicyChain responseChain = ReversedPolicyChain . create ( policies , mock ( ExecutionContext . class ) ) ; responseChain . handler ( result -> { } ) ; InOrder requestOrder = inOrder ( policy , policy2 ) ; InOrder responseOrder = inOrder ( policy , policy2 ) ; requestChain . doNext ( null , null ) ; responseChain . doNext ( null , null ) ; requestOrder . verify ( policy ) . execute ( any ( ) , any ( ) ) ; requestOrder . verify ( policy2 ) . execute ( any ( ) , any ( ) ) ; responseOrder . verify ( policy2 ) . execute ( any ( ) , any ( ) ) ; responseOrder . verify ( policy ) . execute ( any ( ) , any ( ) ) ; }
gravitee-io/gravitee-gateway | private List < Policy > policies2 ( ) { List < Policy > policies = new ArrayList < > ( ) ; policies . add ( policy ) ; policies . add ( policy2 ) ; return policies ; }
BlazePowered/Blaze-Server | public void subscribe ( GlowPlayer player ) { for ( GlowObjective objective : objectives . values ( ) ) { player . getSession ( ) . send ( ScoreboardObjectiveMessage . create ( objective . getName ( ) , objective . getDisplayName ( ) ) ) ; } for ( DisplaySlot slot : DisplaySlot . values ( ) ) { GlowObjective objective = displaySlots . get ( slot ) ; String name = objective != null ? objective . getName ( ) : " " ; player . getSession ( ) . send ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , name ) ) ; } for ( Map . Entry < String , Set < GlowScore > > entry : scoreMap . entrySet ( ) ) { for ( GlowScore score : entry . getValue ( ) ) { player . getSession ( ) . send ( new ScoreboardScoreMessage ( entry . getKey ( ) , score . getObjective ( ) . getName ( ) , score . getScore ( ) ) ) ; } } for ( GlowTeam team : teams . values ( ) ) { player . getSession ( ) . send ( team . getCreateMessage ( ) ) ; } players . add ( player ) ; }
BlazePowered/Blaze-Server | public void unsubscribe ( GlowPlayer player ) { players . remove ( player ) ; for ( GlowTeam team : teams . values ( ) ) { player . getSession ( ) . send ( ScoreboardTeamMessage . remove ( team . getName ( ) ) ) ; } for ( DisplaySlot slot : DisplaySlot . values ( ) ) { player . getSession ( ) . send ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , " " ) ) ; } for ( GlowObjective objective : objectives . values ( ) ) { player . getSession ( ) . send ( ScoreboardObjectiveMessage . remove ( objective . getName ( ) ) ) ; } }
BlazePowered/Blaze-Server | void broadcast ( Message message ) { for ( GlowPlayer player : players ) { player . getSession ( ) . send ( message ) ; } }
BlazePowered/Blaze-Server | void setDisplaySlot ( DisplaySlot slot , GlowObjective objective ) { GlowObjective previous = displaySlots . put ( slot , objective ) ; if ( previous != null ) { previous . displaySlot = null ; } if ( objective != null ) { broadcast ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , objective . getName ( ) ) ) ; objective . displaySlot = slot ; } else { broadcast ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , " " ) ) ; } }
BlazePowered/Blaze-Server | void removeObjective ( GlowObjective objective ) { if ( objective . displaySlot != null ) { setDisplaySlot ( objective . displaySlot , null ) ; } getForCriteria ( objective . getCriteria ( ) ) . remove ( objective ) ; objectives . remove ( objective . getName ( ) ) ; broadcast ( ScoreboardObjectiveMessage . remove ( objective . getName ( ) ) ) ; }
BlazePowered/Blaze-Server | void removeTeam ( GlowTeam team ) { for ( OfflinePlayer player : team . getPlayers ( ) ) { playerTeamMap . remove ( player ) ; } teams . remove ( team . getName ( ) ) ; broadcast ( ScoreboardTeamMessage . remove ( team . getName ( ) ) ) ; }
BlazePowered/Blaze-Server | Set < GlowObjective > getForCriteria ( String criteria ) { Set < GlowObjective > result = criteriaMap . get ( criteria ) ; if ( result == null ) { result = new HashSet < > ( ) ; criteriaMap . put ( criteria , result ) ; } return result ; }
BlazePowered/Blaze-Server | Set < GlowScore > getScoresForName ( String entry ) { Set < GlowScore > result = scoreMap . get ( entry ) ; if ( result == null ) { result = new HashSet < > ( ) ; scoreMap . put ( entry , result ) ; } return result ; }
BlazePowered/Blaze-Server | void setPlayerTeam ( OfflinePlayer player , GlowTeam team ) { GlowTeam previous = playerTeamMap . put ( player , team ) ; if ( previous != null && previous . hasPlayer ( player ) ) { previous . rawRemovePlayer ( player ) ; broadcast ( ScoreboardTeamMessage . removePlayers ( previous . getName ( ) , Arrays . asList ( player . getName ( ) ) ) ) ; } if ( team != null ) { broadcast ( ScoreboardTeamMessage . addPlayers ( team . getName ( ) , Arrays . asList ( player . getName ( ) ) ) ) ; } }
BlazePowered/Blaze-Server | public Objective registerNewObjective ( String name , String criteria ) throws IllegalArgumentException { Validate . notNull ( name , " Name ▁ cannot ▁ be ▁ null " ) ; Validate . notNull ( criteria , " Criteria ▁ cannot ▁ be ▁ null " ) ; Validate . isTrue ( ! objectives . containsKey ( name ) , " Objective ▁ \" " + name + " \" ▁ already ▁ exists " ) ; GlowObjective objective = new GlowObjective ( this , name , criteria ) ; objectives . put ( name , objective ) ; getForCriteria ( criteria ) . add ( objective ) ; broadcast ( ScoreboardObjectiveMessage . create ( name , objective . getDisplayName ( ) , RenderType . INTEGER ) ) ; return objective ; }
BlazePowered/Blaze-Server | public Objective getObjective ( String name ) throws IllegalArgumentException { return objectives . get ( name ) ; }
BlazePowered/Blaze-Server | public Set < Objective > getObjectivesByCriteria ( String criteria ) throws IllegalArgumentException { return ImmutableSet . < Objective > copyOf ( getForCriteria ( criteria ) ) ; }
BlazePowered/Blaze-Server | public Set < Objective > getObjectives ( ) { return ImmutableSet . < Objective > copyOf ( objectives . values ( ) ) ; }
BlazePowered/Blaze-Server | public Objective getObjective ( DisplaySlot slot ) throws IllegalArgumentException { Validate . notNull ( slot , " Slot ▁ cannot ▁ be ▁ null " ) ; return displaySlots . get ( slot ) ; }
BlazePowered/Blaze-Server | public void clearSlot ( DisplaySlot slot ) throws IllegalArgumentException { Validate . notNull ( slot , " Slot ▁ cannot ▁ be ▁ null " ) ; setDisplaySlot ( slot , null ) ; }
BlazePowered/Blaze-Server | public Team registerNewTeam ( String name ) throws IllegalArgumentException { Validate . notNull ( name , " Name ▁ cannot ▁ be ▁ null " ) ; Validate . isTrue ( ! teams . containsKey ( name ) , " Team ▁ \" " + name + " \" ▁ already ▁ exists " ) ; GlowTeam team = new GlowTeam ( this , name ) ; teams . put ( name , team ) ; broadcast ( team . getCreateMessage ( ) ) ; return team ; }
BlazePowered/Blaze-Server | public Team getPlayerTeam ( OfflinePlayer player ) throws IllegalArgumentException { Validate . notNull ( player , " Player ▁ cannot ▁ be ▁ null " ) ; return playerTeamMap . get ( player ) ; }
BlazePowered/Blaze-Server | @ Override public Team getEntryTeam ( String teamName ) throws IllegalArgumentException { return getTeam ( teamName ) ; }
BlazePowered/Blaze-Server | public Team getTeam ( String teamName ) throws IllegalArgumentException { Validate . notNull ( teamName , " Team ▁ name ▁ cannot ▁ be ▁ null " ) ; return teams . get ( teamName ) ; }
BlazePowered/Blaze-Server | public Set < Team > getTeams ( ) { return ImmutableSet . < Team > copyOf ( teams . values ( ) ) ; }
BlazePowered/Blaze-Server | public Set < String > getEntries ( ) { return ImmutableSet . copyOf ( scoreMap . keySet ( ) ) ; }
BlazePowered/Blaze-Server | public Set < Score > getScores ( String entry ) throws IllegalArgumentException { Validate . notNull ( entry , " Entry ▁ cannot ▁ be ▁ null " ) ; Set < GlowScore > scoreSet = scoreMap . get ( entry ) ; if ( scoreSet == null ) { return ImmutableSet . of ( ) ; } else { return ImmutableSet . < Score > copyOf ( scoreSet ) ; } }
BlazePowered/Blaze-Server | public void resetScores ( String entry ) throws IllegalArgumentException { Validate . notNull ( entry , " Entry ▁ cannot ▁ be ▁ null " ) ; for ( GlowObjective objective : objectives . values ( ) ) { broadcast ( ScoreboardScoreMessage . remove ( entry , objective . getName ( ) ) ) ; objective . deleteScore ( entry ) ; } scoreMap . remove ( entry ) ; }
BlazePowered/Blaze-Server | @ Deprecated public Set < OfflinePlayer > getPlayers ( ) { Set < OfflinePlayer > result = new HashSet < > ( ) ; for ( String name : getEntries ( ) ) { result . add ( Bukkit . getOfflinePlayer ( name ) ) ; } return Collections . unmodifiableSet ( result ) ; }
BlazePowered/Blaze-Server | @ Deprecated public Set < Score > getScores ( OfflinePlayer player ) throws IllegalArgumentException { Validate . notNull ( player , " Player ▁ cannot ▁ be ▁ null " ) ; return getScores ( player . getName ( ) ) ; }
BlazePowered/Blaze-Server | @ Deprecated public void resetScores ( OfflinePlayer player ) throws IllegalArgumentException { Validate . notNull ( player , " Player ▁ cannot ▁ be ▁ null " ) ; resetScores ( player . getName ( ) ) ; }
poornan/product-is | KeyValue ( String key , String value ) { this . key = key ; this . value = value ; }
poornan/product-is | public String getValue ( ) { return value ; }
poornan/product-is | public String getKey ( ) { return key ; }
eileenzhuang1/mozu-java | public Integer getId ( ) { return this . id ; }
eileenzhuang1/mozu-java | public void setId ( Integer id ) { this . id = id ; }
eileenzhuang1/mozu-java | public Boolean getIsDeleted ( ) { return this . isDeleted ; }
eileenzhuang1/mozu-java | public void setIsDeleted ( Boolean isDeleted ) { this . isDeleted = isDeleted ; }
eileenzhuang1/mozu-java | public String getName ( ) { return this . name ; }
eileenzhuang1/mozu-java | public void setName ( String name ) { this . name = name ; }
eileenzhuang1/mozu-java | public String getProductPublishingMode ( ) { return this . productPublishingMode ; }
eileenzhuang1/mozu-java | public void setProductPublishingMode ( String productPublishingMode ) { this . productPublishingMode = productPublishingMode ; }
bcvsolutions/CzechIdMng | @ Override public String getId ( ) { return id ; }
bcvsolutions/CzechIdMng | public void setId ( String id ) { this . id = id ; }
bcvsolutions/CzechIdMng | public Date getCreated ( ) { return created ; }
bcvsolutions/CzechIdMng | public void setCreated ( Date created ) { this . created = created ; }
bcvsolutions/CzechIdMng | public String getAssignee ( ) { return assignee ; }
bcvsolutions/CzechIdMng | public void setAssignee ( String assignee ) { this . assignee = assignee ; }
bcvsolutions/CzechIdMng | public WorkflowTaskDefinitionDto getDefinition ( ) { return definition ; }
bcvsolutions/CzechIdMng | public void setDefinition ( WorkflowTaskDefinitionDto definition ) { this . definition = definition ; }
bcvsolutions/CzechIdMng | public Map < String , Object > getVariables ( ) { if ( variables == null ) { variables = new HashMap < > ( ) ; } return variables ; }
bcvsolutions/CzechIdMng | public void setVariables ( Map < String , Object > variables ) { this . variables = variables ; }
bcvsolutions/CzechIdMng | public String getDescription ( ) { return description ; }
bcvsolutions/CzechIdMng | public void setDescription ( String description ) { this . description = description ; }
bcvsolutions/CzechIdMng | public List < DecisionFormTypeDto > getDecisions ( ) { if ( decisions == null ) { decisions = new ArrayList < > ( ) ; } return decisions ; }
bcvsolutions/CzechIdMng | public void setDecisions ( List < DecisionFormTypeDto > decisions ) { this . decisions = decisions ; }
bcvsolutions/CzechIdMng | public List < FormDataDto > getFormData ( ) { if ( formData == null ) { formData = new ArrayList < > ( ) ; } return formData ; }
bcvsolutions/CzechIdMng | public void setFormData ( List < FormDataDto > formData ) { this . formData = formData ; }
bcvsolutions/CzechIdMng | public String getName ( ) { return name ; }
bcvsolutions/CzechIdMng | public void setName ( String name ) { this . name = name ; }
bcvsolutions/CzechIdMng | public String getApplicant ( ) { return applicant ; }
bcvsolutions/CzechIdMng | public void setApplicant ( String applicant ) { this . applicant = applicant ; }
bcvsolutions/CzechIdMng | public String getApplicantFullName ( ) { return applicantFullName ; }
bcvsolutions/CzechIdMng | public void setApplicantFullName ( String applicantFullName ) { this . applicantFullName = applicantFullName ; }
bcvsolutions/CzechIdMng | public List < IdentityLinkDto > getIdentityLinks ( ) { if ( identityLinks == null ) { identityLinks = new ArrayList < > ( ) ; } return identityLinks ; }
bcvsolutions/CzechIdMng | public void setIdentityLinks ( List < IdentityLinkDto > identityLinks ) { this . identityLinks = identityLinks ; }
bcvsolutions/CzechIdMng | public String getProcessInstanceId ( ) { return processInstanceId ; }
bcvsolutions/CzechIdMng | public void setProcessInstanceId ( String processInstanceId ) { this . processInstanceId = processInstanceId ; }
bcvsolutions/CzechIdMng | public String getFormKey ( ) { return formKey ; }
bcvsolutions/CzechIdMng | public void setFormKey ( String formKey ) { this . formKey = formKey ; }
bcvsolutions/CzechIdMng | @ Override public void setId ( Serializable id ) { if ( id != null ) { Assert . isInstanceOf ( String . class , id , " WorkflowTaskInstanceDto ▁ supports ▁ only ▁ String ▁ identifier . " ) ; } this . id = ( String ) id ; }
bcvsolutions/CzechIdMng | public String getProcessDefinitionId ( ) { return processDefinitionId ; }
bcvsolutions/CzechIdMng | public void setProcessDefinitionId ( String processDefinitionId ) { this . processDefinitionId = processDefinitionId ; }
bcvsolutions/CzechIdMng | public String getProcessDefinitionKey ( ) { return processDefinitionKey ; }
bcvsolutions/CzechIdMng | public void setProcessDefinitionKey ( String processDefinitionKey ) { this . processDefinitionKey = processDefinitionKey ; }
bcvsolutions/CzechIdMng | public int getPriority ( ) { return priority ; }
bcvsolutions/CzechIdMng | public void setPriority ( int priority ) { this . priority = priority ; }
bcvsolutions/CzechIdMng | public Class < ? extends BaseDto > getType ( ) { return type ; }
bcvsolutions/CzechIdMng | public IdmDelegationDefinitionDto getDelegationDefinition ( ) { return delegationDefinition ; }
bcvsolutions/CzechIdMng | public void setDelegationDefinition ( IdmDelegationDefinitionDto delegationDefinition ) { this . delegationDefinition = delegationDefinition ; }
aws/aws-sdk-java | public void setRStudioServerProDomainSettingsForUpdate ( RStudioServerProDomainSettingsForUpdate rStudioServerProDomainSettingsForUpdate ) { this . rStudioServerProDomainSettingsForUpdate = rStudioServerProDomainSettingsForUpdate ; }
aws/aws-sdk-java | public RStudioServerProDomainSettingsForUpdate getRStudioServerProDomainSettingsForUpdate ( ) { return this . rStudioServerProDomainSettingsForUpdate ; }
aws/aws-sdk-java | public DomainSettingsForUpdate withRStudioServerProDomainSettingsForUpdate ( RStudioServerProDomainSettingsForUpdate rStudioServerProDomainSettingsForUpdate ) { setRStudioServerProDomainSettingsForUpdate ( rStudioServerProDomainSettingsForUpdate ) ; return this ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getRStudioServerProDomainSettingsForUpdate ( ) != null ) sb . append ( " RStudioServerProDomainSettingsForUpdate : ▁ " ) . append ( getRStudioServerProDomainSettingsForUpdate ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DomainSettingsForUpdate == false ) return false ; DomainSettingsForUpdate other = ( DomainSettingsForUpdate ) obj ; if ( other . getRStudioServerProDomainSettingsForUpdate ( ) == null ^ this . getRStudioServerProDomainSettingsForUpdate ( ) == null ) return false ; if ( other . getRStudioServerProDomainSettingsForUpdate ( ) != null && other . getRStudioServerProDomainSettingsForUpdate ( ) . equals ( this . getRStudioServerProDomainSettingsForUpdate ( ) ) == false ) return false ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getRStudioServerProDomainSettingsForUpdate ( ) == null ) ? 0 : getRStudioServerProDomainSettingsForUpdate ( ) . hashCode ( ) ) ; return hashCode ; }
aws/aws-sdk-java | @ Override public DomainSettingsForUpdate clone ( ) { try { return ( DomainSettingsForUpdate ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
aws/aws-sdk-java | @ com . amazonaws . annotation . SdkInternalApi @ Override public void marshall ( ProtocolMarshaller protocolMarshaller ) { com . amazonaws . services . sagemaker . model . transform . DomainSettingsForUpdateMarshaller . getInstance ( ) . marshall ( this , protocolMarshaller ) ; }
fhg-fokus-nubomedia/nubomedia-paas | public ImageStreamMessageBuilder ( String name ) { this . name = name ; }
fhg-fokus-nubomedia/nubomedia-paas | public ImageStreamConfig buildMessage ( ) { ImageStreamConfig . ImageStreamStatus status = new ImageStreamConfig . ImageStreamStatus ( " " ) ; Metadata metadata = new Metadata ( name , " " , " " ) ; return new ImageStreamConfig ( metadata , new ImageStreamConfig . ImageStreamSpecification ( ) , status ) ; }
javar/sudoku-solver | int _ ( char [ ] a , int i ) { if ( i > 80 ) System . out . println ( a ) ; else { if ( a [ i ] > 48 ) return _ ( a , i + 1 ) ; char v [ ] = a . clone ( ) , k = 65535 ; while ( ++ k < 9 ) v [ a [ i / 9 * 9 + k ] ] = v [ a [ i % 9 + k * 9 ] ] = v [ a [ i - i % 3 - i / 9 % 3 * 9 + k + k / 3 * 6 ] ] = 1 ; for ( k = 58 ; ( a [ i ] = -- k ) > 48 ; ) if ( v [ k ] > 1 && _ ( a , i + 1 ) == 1 ) return 1 ; } return i / 81 ; }
GwonGisoo/ngrinder | ) public String getAll ( @ RequestParam ( value = " region " , required = false ) final String region , ModelMap model ) { List < AgentInfo > agents = agentManagerService . getAllVisible ( ) ; model . addAttribute ( " agents " , Collections2 . filter ( agents , new Predicate < AgentInfo > ( ) { @ Override public boolean apply ( AgentInfo agentInfo ) { final String eachAgentRegion = agentInfo . getRegion ( ) ; if ( StringUtils . equals ( region , " all " ) || StringUtils . isEmpty ( region ) ) { return true ; } return eachAgentRegion . startsWith ( region + " _ owned " ) || region . equals ( eachAgentRegion ) ; } } ) ) ; model . addAttribute ( " region " , region ) ; model . addAttribute ( " regions " , regionService . getAllVisibleRegionNames ( ) ) ; File agentPackage = null ; if ( isClustered ( ) ) { if ( StringUtils . isNotBlank ( region ) ) { final RegionInfo regionInfo = regionService . getOne ( region ) ; agentPackage = agentPackageService . createAgentPackage ( region , regionInfo . getIp ( ) , regionInfo . getControllerPort ( ) , null ) ; } } else { agentPackage = agentPackageService . createAgentPackage ( " " , " " , getConfig ( ) . getControllerPort ( ) , null ) ; } if ( agentPackage != null ) { model . addAttribute ( " downloadLink " , " / agent / download / " + agentPackage . getName ( ) ) ; } return " agent / list " ; }
GwonGisoo/ngrinder | " ) public String getOne ( @ PathVariable Long id , ModelMap model ) { model . addAttribute ( " agent " , agentManagerService . getOne ( id ) ) ; return " agent / detail " ; }
GwonGisoo/ngrinder | @ PreAuthorize ( " hasAnyRole ( ' A ' ) " ) @ RequestMapping ( value = " / api " , params = " action = cleanup " , method = RequestMethod . POST ) public HttpEntity < String > cleanUpAgentsInInactiveRegion ( ) { agentManagerService . cleanup ( ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | / state " ) public HttpEntity < String > getState ( @ PathVariable Long id , @ RequestParam String ip , @ RequestParam String name ) { agentManagerService . requestShareAgentSystemDataModel ( id ) ; return toJsonHttpEntity ( agentManagerService . getSystemDataModel ( ip , name ) ) ; }
GwonGisoo/ngrinder | , method = RequestMethod . GET ) public HttpEntity < String > getStates ( ) { List < AgentInfo > agents = agentManagerService . getAllVisible ( ) ; return toJsonHttpEntity ( getAgentStatus ( agents ) ) ; }
GwonGisoo/ngrinder | , method = RequestMethod . GET ) public HttpEntity < String > getAll ( ) { return toJsonHttpEntity ( agentManagerService . getAllVisible ( ) ) ; }
GwonGisoo/ngrinder | " , method = RequestMethod . GET ) public HttpEntity < String > getOne ( @ PathVariable ( " id " ) Long id ) { return toJsonHttpEntity ( agentManagerService . getOne ( id ) ) ; }
GwonGisoo/ngrinder | " , params = " action = approve " , method = RequestMethod . PUT ) public HttpEntity < String > approve ( @ PathVariable ( " id " ) Long id ) { agentManagerService . approve ( id , true ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | " , params = " action = disapprove " , method = RequestMethod . PUT ) public HttpEntity < String > disapprove ( @ PathVariable ( " id " ) Long id ) { agentManagerService . approve ( id , false ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | " , params = " action = stop " , method = RequestMethod . PUT ) public HttpEntity < String > stop ( @ PathVariable ( " id " ) Long id ) { agentManagerService . stopAgent ( id ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | @ RestAPI @ PreAuthorize ( " hasAnyRole ( ' A ' ) " ) @ RequestMapping ( value = " / api " , params = " action = stop " , method = RequestMethod . PUT ) public HttpEntity < String > stop ( @ RequestParam ( " ids " ) String ids ) { String [ ] split = StringUtils . split ( ids , " , " ) ; for ( String each : split ) { stop ( Long . parseLong ( each ) ) ; } return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | " , params = " action = update " , method = RequestMethod . PUT ) public HttpEntity < String > update ( @ PathVariable ( " id " ) Long id ) { agentManagerService . update ( id ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | @ RestAPI @ PreAuthorize ( " hasAnyRole ( ' A ' ) " ) @ RequestMapping ( value = " / api " , params = " action = update " , method = RequestMethod . PUT ) public HttpEntity < String > update ( @ RequestParam ( " ids " ) String ids ) { String [ ] split = StringUtils . split ( ids , " , " ) ; for ( String each : split ) { update ( Long . parseLong ( each ) ) ; } return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | private List < Map < String , Object > > getAgentStatus ( List < AgentInfo > agents ) { List < Map < String , Object > > statuses = newArrayList ( agents . size ( ) ) ; for ( AgentInfo each : agents ) { Map < String , Object > result = newHashMap ( ) ; result . put ( " id " , each . getId ( ) ) ; result . put ( " port " , each . getPort ( ) ) ; result . put ( " icon " , each . getState ( ) . getCategory ( ) . getIconName ( ) ) ; result . put ( " state " , each . getState ( ) ) ; statuses . add ( result ) ; } return statuses ; }
tdelev/MULLAN | public String globalInfo ( ) { return " Changes ▁ the ▁ order ▁ of ▁ the ▁ classes ▁ so ▁ that ▁ the ▁ class ▁ values ▁ are ▁ " + " no ▁ longer ▁ of ▁ in ▁ the ▁ order ▁ specified ▁ in ▁ the ▁ header . ▁ " + " The ▁ values ▁ will ▁ be ▁ in ▁ the ▁ order ▁ specified ▁ by ▁ the ▁ user ▁ " + " - - ▁ it ▁ could ▁ be ▁ either ▁ in ▁ ascending / descending ▁ order ▁ by ▁ the ▁ class ▁ " + " frequency ▁ or ▁ in ▁ random ▁ order . ▁ Note ▁ that ▁ this ▁ filter ▁ currently ▁ does ▁ not ▁ " + " change ▁ the ▁ header , ▁ only ▁ the ▁ class ▁ values ▁ of ▁ the ▁ instances , ▁ " + " so ▁ there ▁ is ▁ not ▁ much ▁ point ▁ in ▁ using ▁ it ▁ in ▁ conjunction ▁ with ▁ the ▁ " + " FilteredClassifier . ▁ The ▁ value ▁ can ▁ also ▁ be ▁ converted ▁ back ▁ using ▁ " + " ' originalValue ( double ▁ value ) ' ▁ procedure . " ; }
tdelev/MULLAN | public Enumeration listOptions ( ) { Vector newVector = new Vector ( 1 ) ; newVector . addElement ( new Option ( " \tSpecify ▁ the ▁ seed ▁ of ▁ randomization \n " + " \tused ▁ to ▁ randomize ▁ the ▁ class \n " + " \torder ▁ ( default : ▁ 1 ) " , " R " , 1 , " - R ▁ < seed > " ) ) ; newVector . addElement ( new Option ( " \tSpecify ▁ the ▁ class ▁ order ▁ to ▁ be \n " + " \tsorted , ▁ could ▁ be ▁ 0 : ▁ ascending \n " + " \t1 : ▁ descending ▁ and ▁ 2 : ▁ random . ( default : ▁ 0 ) " , " C " , 1 , " - C ▁ < order > " ) ) ; return newVector . elements ( ) ; }
tdelev/MULLAN | public void setOptions ( String [ ] options ) throws Exception { String seedString = Utils . getOption ( ' R ' , options ) ; if ( seedString . length ( ) != 0 ) m_Seed = Long . parseLong ( seedString ) ; else m_Seed = 1 ; String orderString = Utils . getOption ( ' C ' , options ) ; if ( orderString . length ( ) != 0 ) m_ClassOrder = Integer . parseInt ( orderString ) ; else m_ClassOrder = FREQ_ASCEND ; if ( getInputFormat ( ) != null ) setInputFormat ( getInputFormat ( ) ) ; m_Random = null ; }
tdelev/MULLAN | public String [ ] getOptions ( ) { String [ ] options = new String [ 4 ] ; int current = 0 ; options [ current ++ ] = " - R " ; options [ current ++ ] = " " + m_Seed ; options [ current ++ ] = " - C " ; options [ current ++ ] = " " + m_ClassOrder ; while ( current < options . length ) { options [ current ++ ] = " " ; } return options ; }
tdelev/MULLAN | public String seedTipText ( ) { return " Specify ▁ the ▁ seed ▁ of ▁ randomization ▁ of ▁ the ▁ class ▁ order " ; }
tdelev/MULLAN | public long getSeed ( ) { return m_Seed ; }
tdelev/MULLAN | public void setSeed ( long seed ) { m_Seed = seed ; m_Random = null ; }
tdelev/MULLAN | public String classOrderTipText ( ) { return " Specify ▁ the ▁ class ▁ order ▁ after ▁ the ▁ filtering " ; }
tdelev/MULLAN | public int getClassOrder ( ) { return m_ClassOrder ; }
tdelev/MULLAN | public void setClassOrder ( int order ) { m_ClassOrder = order ; }
tdelev/MULLAN | public Capabilities getCapabilities ( ) { Capabilities result = super . getCapabilities ( ) ; result . disableAll ( ) ; result . enableAllAttributes ( ) ; result . enable ( Capability . MISSING_VALUES ) ; result . enable ( Capability . NOMINAL_CLASS ) ; return result ; }
tdelev/MULLAN | public boolean setInputFormat ( Instances instanceInfo ) throws Exception { super . setInputFormat ( new Instances ( instanceInfo , 0 ) ) ; m_ClassAttribute = instanceInfo . classAttribute ( ) ; m_Random = new Random ( m_Seed ) ; m_Converter = null ; int numClasses = instanceInfo . numClasses ( ) ; m_ClassCounts = new double [ numClasses ] ; return false ; }
tdelev/MULLAN | public boolean input ( Instance instance ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( " No ▁ input ▁ instance ▁ format ▁ defined " ) ; } if ( m_NewBatch ) { resetQueue ( ) ; m_NewBatch = false ; } if ( m_Converter != null ) { Instance datum = ( Instance ) instance . copy ( ) ; if ( ! datum . isMissing ( m_ClassAttribute ) ) { datum . setClassValue ( ( double ) m_Converter [ ( int ) datum . classValue ( ) ] ) ; } push ( datum ) ; return true ; } if ( ! instance . isMissing ( m_ClassAttribute ) ) { m_ClassCounts [ ( int ) instance . classValue ( ) ] += instance . weight ( ) ; } bufferInput ( instance ) ; return false ; }
tdelev/MULLAN | public boolean batchFinished ( ) throws Exception { Instances data = getInputFormat ( ) ; if ( data == null ) throw new IllegalStateException ( " No ▁ input ▁ instance ▁ format ▁ defined " ) ; if ( m_Converter == null ) { int [ ] randomIndices = new int [ m_ClassCounts . length ] ; for ( int i = 0 ; i < randomIndices . length ; i ++ ) { randomIndices [ i ] = i ; } for ( int j = randomIndices . length - 1 ; j > 0 ; j -- ) { int toSwap = m_Random . nextInt ( j + 1 ) ; int tmpIndex = randomIndices [ j ] ; randomIndices [ j ] = randomIndices [ toSwap ] ; randomIndices [ toSwap ] = tmpIndex ; } double [ ] randomizedCounts = new double [ m_ClassCounts . length ] ; for ( int i = 0 ; i < randomizedCounts . length ; i ++ ) { randomizedCounts [ i ] = m_ClassCounts [ randomIndices [ i ] ] ; } if ( m_ClassOrder == RANDOM ) { m_Converter = randomIndices ; m_ClassCounts = randomizedCounts ; } else { int [ ] sorted = Utils . sort ( randomizedCounts ) ; m_Converter = new int [ sorted . length ] ; if ( m_ClassOrder == FREQ_ASCEND ) { for ( int i = 0 ; i < sorted . length ; i ++ ) { m_Converter [ i ] = randomIndices [ sorted [ i ] ] ; } } else if ( m_ClassOrder == FREQ_DESCEND ) { for ( int i = 0 ; i < sorted . length ; i ++ ) { m_Converter [ i ] = randomIndices [ sorted [ sorted . length - i - 1 ] ] ; } } else { throw new IllegalArgumentException ( " Class ▁ order ▁ not ▁ defined ! " ) ; } double [ ] tmp2 = new double [ m_ClassCounts . length ] ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) { tmp2 [ i ] = m_ClassCounts [ m_Converter [ i ] ] ; } m_ClassCounts = tmp2 ; } FastVector values = new FastVector ( data . classAttribute ( ) . numValues ( ) ) ; for ( int i = 0 ; i < data . numClasses ( ) ; i ++ ) { values . addElement ( data . classAttribute ( ) . value ( m_Converter [ i ] ) ) ; } FastVector newVec = new FastVector ( data . numAttributes ( ) ) ; for ( int i = 0 ; i < data . numAttributes ( ) ; i ++ ) { if ( i == data . classIndex ( ) ) { newVec . addElement ( new Attribute ( data . classAttribute ( ) . name ( ) , values , data . classAttribute ( ) . getMetadata ( ) ) ) ; } else { newVec . addElement ( data . attribute ( i ) ) ; } } Instances newInsts = new Instances ( data . relationName ( ) , newVec , 0 ) ; newInsts . setClassIndex ( data . classIndex ( ) ) ; setOutputFormat ( newInsts ) ; int [ ] temp = new int [ m_Converter . length ] ; for ( int i = 0 ; i < temp . length ; i ++ ) { temp [ m_Converter [ i ] ] = i ; } m_Converter = temp ; for ( int xyz = 0 ; xyz < data . numInstances ( ) ; xyz ++ ) { Instance datum = data . instance ( xyz ) ; if ( ! datum . isMissing ( datum . classIndex ( ) ) ) { datum . setClassValue ( ( double ) m_Converter [ ( int ) datum . classValue ( ) ] ) ; } push ( datum ) ; } } flushInput ( ) ; m_NewBatch = true ; return ( numPendingOutput ( ) != 0 ) ; }
tdelev/MULLAN | public double [ ] getClassCounts ( ) { if ( m_ClassAttribute . isNominal ( ) ) return m_ClassCounts ; else return null ; }
tdelev/MULLAN | public double [ ] distributionsByOriginalIndex ( double [ ] before ) { double [ ] after = new double [ m_Converter . length ] ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) after [ i ] = before [ m_Converter [ i ] ] ; return after ; }
tdelev/MULLAN | public double originalValue ( double value ) throws Exception { if ( m_Converter == null ) throw new IllegalStateException ( " Coverter ▁ table ▁ not ▁ defined ▁ yet ! " ) ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) if ( ( int ) value == m_Converter [ i ] ) return ( double ) i ; return - 1 ; }
tdelev/MULLAN | public String getRevision ( ) { return RevisionUtils . extract ( " $ Revision : ▁ 8034 ▁ $ " ) ; }
Alex-Diez/Java-TDD-Katas | Chars ( String source ) { this . source = source ; }
Alex-Diez/Java-TDD-Katas | char next ( ) { return source . charAt ( index ++ ) ; }
Alex-Diez/Java-TDD-Katas | char peek ( ) { return source . charAt ( index ) ; }
Alex-Diez/Java-TDD-Katas | int index ( ) { return index ; }
Alex-Diez/Java-TDD-Katas | String subString ( int start , int end ) { return source . substring ( start , end ) ; }
Alex-Diez/Java-TDD-Katas | boolean hasNext ( ) { return index < source . length ( ) ; }
y1011/cas-server | @ Override public ModelAndView resolveException ( final HttpServletRequest request , final HttpServletResponse response , final Object handler , final Exception exception ) { if ( ! ( exception instanceof FlowExecutionRepositoryException ) || exception instanceof BadlyFormattedFlowExecutionKeyException ) { logger . debug ( " Ignoring ▁ the ▁ received ▁ exception ▁ due ▁ to ▁ a ▁ type ▁ mismatch " , exception ) ; return null ; } final String urlToRedirectTo = request . getRequestURI ( ) + ( request . getQueryString ( ) != null ? ' ? ' + request . getQueryString ( ) : " " ) ; logger . debug ( " Error ▁ getting ▁ flow ▁ information ▁ for ▁ URL ▁ [ { } ] " , urlToRedirectTo , exception ) ; final Map < String , Object > model = new HashMap < > ( ) ; model . put ( this . modelKey , StringEscapeUtils . escapeHtml4 ( exception . getMessage ( ) ) ) ; return new ModelAndView ( new RedirectView ( urlToRedirectTo ) , model ) ; }
y1011/cas-server | public void setModelKey ( final String modelKey ) { this . modelKey = modelKey ; }
XillioQA/xill-platform-3.4 | @ Override public Connection createConnection ( String database , String user , String pass , Tuple < String , String > ... options ) throws SQLException { return connect ( createConnectionURL ( database , user , pass , options ) ) ; }
XillioQA/xill-platform-3.4 | @ Override protected String createConnectionURL ( String database , String user , String pass , Tuple < String , String > ... options ) { return createJDBCURL ( " mysql " , database , user , pass , " ? " , " & " , options ) ; }
XillioQA/xill-platform-3.4 | @ Override public void loadDriver ( ) throws ClassNotFoundException { Class . forName ( Database . MYSQL . getDriverClass ( ) ) ; }
apache/bookkeeper | @ Test ( timeout = 20000 ) public void testBasicOperations ( ) throws Exception { ConcurrentBaseConfiguration conf = new ConcurrentBaseConfiguration ( ) ; conf . setProperty ( " prop1" , "1" ) ; assertEquals ( 1 , conf . getInt ( " prop1" ) ) ; conf . setProperty ( " prop1" , "2" ) ; assertEquals ( 2 , conf . getInt ( " prop1" ) ) ; conf . clearProperty ( " prop1" ) ; assertEquals ( null , conf . getInteger ( " prop1" , null ) ) ; conf . setProperty ( " prop1" , "1" ) ; conf . setProperty ( " prop2" , "2" ) ; assertEquals ( 1 , conf . getInt ( " prop1" ) ) ; assertEquals ( 2 , conf . getInt ( " prop2" ) ) ; conf . clearProperty ( " prop1" ) ; assertEquals ( null , conf . getInteger ( " prop1" , null ) ) ; assertEquals ( 2 , conf . getInt ( " prop2" ) ) ; }
jentfoo/aws-sdk-java | public void marshall ( StartSchemaExtensionRequest startSchemaExtensionRequest , ProtocolMarshaller protocolMarshaller ) { if ( startSchemaExtensionRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { protocolMarshaller . marshall ( startSchemaExtensionRequest . getDirectoryId ( ) , DIRECTORYID_BINDING ) ; protocolMarshaller . marshall ( startSchemaExtensionRequest . getCreateSnapshotBeforeSchemaExtension ( ) , CREATESNAPSHOTBEFORESCHEMAEXTENSION_BINDING ) ; protocolMarshaller . marshall ( startSchemaExtensionRequest . getLdifContent ( ) , LDIFCONTENT_BINDING ) ; protocolMarshaller . marshall ( startSchemaExtensionRequest . getDescription ( ) , DESCRIPTION_BINDING ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final RyaStatement triple , final Optional < String > visibility ) { insert ( fluo , Collections . singleton ( triple ) , visibility ) ; }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final Collection < RyaStatement > triples , final Optional < String > visibility ) { checkNotNull ( fluo ) ; checkNotNull ( triples ) ; checkNotNull ( visibility ) ; try ( Transaction tx = fluo . newTransaction ( ) ) { for ( final RyaStatement triple : triples ) { try { tx . set ( spoFormat ( triple ) , FluoQueryColumns . TRIPLES , Bytes . of ( visibility . or ( " " ) ) ) ; } catch ( final TripleRowResolverException e ) { log . error ( " Could ▁ not ▁ convert ▁ a ▁ Triple ▁ into ▁ the ▁ SPO ▁ format : ▁ " + triple ) ; } } tx . commit ( ) ; } }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final RyaStatement triple ) { checkNotNull ( fluo ) ; checkNotNull ( triple ) ; insert ( fluo , Collections . singleton ( triple ) ) ; }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final Collection < RyaStatement > triples ) { checkNotNull ( fluo ) ; checkNotNull ( triples ) ; try ( Transaction tx = fluo . newTransaction ( ) ) { for ( final RyaStatement triple : triples ) { Optional < byte [ ] > visibility = Optional . fromNullable ( triple . getColumnVisibility ( ) ) ; try { tx . set ( spoFormat ( triple ) , FluoQueryColumns . TRIPLES , Bytes . of ( visibility . or ( new byte [ 0 ] ) ) ) ; } catch ( final TripleRowResolverException e ) { log . error ( " Could ▁ not ▁ convert ▁ a ▁ Triple ▁ into ▁ the ▁ SPO ▁ format : ▁ " + triple ) ; } } tx . commit ( ) ; } }
joewalnes/idea-community | public FindMethodUsagesDialog ( PsiElement element , Project project , FindUsagesOptions findUsagesOptions , boolean toShowInNewTab , boolean mustOpenInNewTab , boolean isSingleFile , FindUsagesHandler handler ) { super ( element , project , findUsagesOptions , toShowInNewTab , mustOpenInNewTab , isSingleFile , handler ) ; }
joewalnes/idea-community | @ Nullable public JComponent getPreferredFocusedControl ( ) { return myHasFindWhatPanel ? myCbUsages : null ; }
joewalnes/idea-community | public void calcFindUsagesOptions ( JavaMethodFindUsagesOptions options ) { super . calcFindUsagesOptions ( options ) ; options . isUsages = isSelected ( myCbUsages ) || ! myHasFindWhatPanel ; if ( isToChange ( myCbOverridingMethods ) ) { options . isOverridingMethods = isSelected ( myCbOverridingMethods ) ; } if ( isToChange ( myCbImplementingMethods ) ) { options . isImplementingMethods = isSelected ( myCbImplementingMethods ) ; } options . isCheckDeepInheritance = true ; }
joewalnes/idea-community | protected JPanel createFindWhatPanel ( ) { JPanel findWhatPanel = new JPanel ( ) ; findWhatPanel . setBorder ( IdeBorderFactory . createTitledBorder ( FindBundle . message ( " find . what . group " ) ) ) ; findWhatPanel . setLayout ( new BoxLayout ( findWhatPanel , BoxLayout . Y_AXIS ) ) ; myCbUsages = addCheckboxToPanel ( FindBundle . message ( " find . what . usages . checkbox " ) , getFindUsagesOptions ( ) . isUsages , findWhatPanel , true ) ; PsiMethod method = ( PsiMethod ) getPsiElement ( ) ; PsiClass aClass = method . getContainingClass ( ) ; if ( ! method . isConstructor ( ) && ! method . hasModifierProperty ( PsiModifier . STATIC ) && ! method . hasModifierProperty ( PsiModifier . FINAL ) && ! method . hasModifierProperty ( PsiModifier . PRIVATE ) && aClass != null && ! ( aClass instanceof PsiAnonymousClass ) && ! aClass . hasModifierProperty ( PsiModifier . FINAL ) ) { if ( method . hasModifierProperty ( PsiModifier . ABSTRACT ) ) { myCbImplementingMethods = addCheckboxToPanel ( FindBundle . message ( " find . what . implementing . methods . checkbox " ) , getFindUsagesOptions ( ) . isImplementingMethods , findWhatPanel , true ) ; } else { myCbOverridingMethods = addCheckboxToPanel ( FindBundle . message ( " find . what . overriding . methods . checkbox " ) , getFindUsagesOptions ( ) . isOverridingMethods , findWhatPanel , true ) ; } } else { myHasFindWhatPanel = false ; return null ; } myHasFindWhatPanel = true ; return findWhatPanel ; }
joewalnes/idea-community | protected void update ( ) { if ( ! myHasFindWhatPanel ) { setOKActionEnabled ( true ) ; } else { boolean hasSelected = isSelected ( myCbUsages ) || isSelected ( myCbImplementingMethods ) || isSelected ( myCbOverridingMethods ) ; setOKActionEnabled ( hasSelected ) ; } }
mikessh/mageri | private ResourceIOProvider ( ) { super ( " resources " ) ; }
mikessh/mageri | @ Override public InputStream getStream ( String path ) throws IOException { InputStream is = ResourceIOProvider . class . getClassLoader ( ) . getResourceAsStream ( path ) ; return path . endsWith ( " . gz " ) ? new GZIPInputStream ( is ) : is ; }
mauriciotogneri/shoppinglist | public Dialogs ( Context context ) { this . context = context ; }
mauriciotogneri/shoppinglist | public void options ( String title , List < String > list , OnOptionSelected callback ) { String [ ] options = new String [ list . size ( ) ] ; list . toArray ( options ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( title ( title ) ) ; builder . setItems ( options , ( dialog , which ) -> callback . onOptionSelected ( which ) ) ; builder . show ( ) ; }
mauriciotogneri/shoppinglist | public void confirmation ( String title , String message , OnConfirmationAccepted callback ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( title ( title ) ) ; builder . setMessage ( message ) ; builder . setPositiveButton ( android . R . string . yes , ( dialog , whichButton ) -> callback . onConfirmationAccepted ( ) ) ; builder . setNegativeButton ( android . R . string . no , null ) ; builder . show ( ) ; }
mauriciotogneri/shoppinglist | public void input ( Context context , String title , String initialInput , OnInputConfirmed callback ) { View view = LayoutInflater . from ( context ) . inflate ( R . layout . view_dialog_input , null ) ; EditText nameField = view . findViewById ( R . id . input ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( title ( title ) ) ; builder . setView ( view ) ; builder . setPositiveButton ( R . string . button_accept , ( dialogInterface , i ) -> callback . onInputConfirmed ( nameField . getText ( ) . toString ( ) ) ) ; builder . setNegativeButton ( R . string . button_cancel , null ) ; AlertDialog dialog = builder . create ( ) ; Window window = dialog . getWindow ( ) ; if ( window != null ) { window . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_VISIBLE ) ; } dialog . show ( ) ; nameField . setText ( initialInput ) ; nameField . requestFocus ( ) ; nameField . selectAll ( ) ; dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setEnabled ( initialInput . length ( ) != 0 ) ; nameField . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable text ) { dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setEnabled ( text . length ( ) != 0 ) ; } } ) ; nameField . setOnEditorActionListener ( ( view1 , actionId , event ) -> { if ( actionId == EditorInfo . IME_ACTION_DONE ) { try { dialog . dismiss ( ) ; } catch ( Exception e ) { } callback . onInputConfirmed ( nameField . getText ( ) . toString ( ) ) ; } return false ; } ) ; }
mauriciotogneri/shoppinglist | private SpannableStringBuilder title ( String text ) { SpannableStringBuilder spannable = new SpannableStringBuilder ( text ) ; spannable . setSpan ( new ForegroundColorSpan ( ContextCompat . getColor ( context , R . color . primary ) ) , 0 , text . length ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; return spannable ; }
YoungDigitalPlanet/empiria.player | @ Test public void updateFontPropertiesAccordingToInlineFormatters ( ) { IInlineModule testModule = mock ( IInlineModule . class ) ; ModuleSocket socket = mock ( ModuleSocket . class ) ; Element element = mock ( Element . class ) ; Set < InlineFormattingContainerType > inlineStyles = new HashSet < InlineFormattingContainerType > ( ) ; inlineStyles . add ( InlineFormattingContainerType . BOLD ) ; when ( socket . getInlineFormattingTags ( testModule ) ) . thenReturn ( inlineStyles ) ; Font result = helper . initialize ( testModule , socket , element ) ; assertThat ( result . bold , is ( equalTo ( true ) ) ) ; }
YoungDigitalPlanet/empiria.player | @ Test public void updateFontPropertiesAccordingToStyles ( ) { DTOMathTextDefaultFontPropertiesProvider defaultFontPropertiesProvider = new DTOMathTextDefaultFontPropertiesProvider ( ) ; DTOMathTextFontProperties fontProperties = defaultFontPropertiesProvider . createDefaultProprerties ( ) ; HashMap < String , String > styles = new HashMap < String , String > ( ) ; styles . put ( " - empiria - math - font - size " , "26" ) ; helper . updateFontPropertiesAccordingToStyles ( styles , fontProperties ) ; assertThat ( fontProperties . getSize ( ) , is ( equalTo ( 26 ) ) ) ; }
PeterASteele/CodeForcesSolutions | public FastScanner ( Reader in ) { br = new BufferedReader ( in ) ; }
PeterASteele/CodeForcesSolutions | public FastScanner ( ) { this ( new InputStreamReader ( System . in ) ) ; }
PeterASteele/CodeForcesSolutions | String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; }
PeterASteele/CodeForcesSolutions | int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }
PeterASteele/CodeForcesSolutions | long nextLong ( ) { return Long . parseLong ( next ( ) ) ; }
PeterASteele/CodeForcesSolutions | double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; }
PeterASteele/CodeForcesSolutions | String readNextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; }
zreed/StarQuestCode | public BasicGeneratorGUI ( Player player , int id ) { super ( player , id ) ; }
zreed/StarQuestCode | @ Override public void open ( ) { Inventory gui = Bukkit . createInventory ( owner , 27 , ChatColor . BLUE + " SQTech ▁ - ▁ Basic ▁ Generator " ) ; Machine machine = ObjectUtils . getMachineFromMachineGUI ( this ) ; gui . setItem ( 8 , InventoryUtils . createSpecialItem ( Material . REDSTONE , ( short ) 0 , " Energy " , new String [ ] { EnergyUtils . formatEnergy ( machine . getEnergy ( ) ) + " / " + EnergyUtils . formatEnergy ( machine . getMachineType ( ) . getMaxEnergy ( ) ) , ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 26 , InventoryUtils . createSpecialItem ( Material . WOOD_DOOR , ( short ) 0 , " Back " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 17 , InventoryUtils . createSpecialItem ( Material . CHEST , ( short ) 0 , " Remaining ▁ fuel " , new String [ ] { " Fuel ▁ Type : ▁ None " , " Amount ▁ left : ▁ 0" , ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 0 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 2 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 9 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 11 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 18 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 19 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 20 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 1 , InventoryUtils . createSpecialItem ( Material . PAPER , ( short ) 0 , " Info " , new String [ ] { " Fuel ▁ input " , ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; owner . openInventory ( gui ) ; if ( SQTechBase . currentGui . containsKey ( owner ) ) { SQTechBase . currentGui . remove ( owner ) ; SQTechBase . currentGui . put ( owner , this ) ; } else { SQTechBase . currentGui . put ( owner , this ) ; } }
zreed/StarQuestCode | @ Override public void click ( final InventoryClickEvent event ) { if ( event . getClickedInventory ( ) != null ) { if ( event . getClickedInventory ( ) . getTitle ( ) . startsWith ( ChatColor . BLUE + " SQTech " ) ) { event . setCancelled ( true ) ; ItemStack clickedItem = event . getInventory ( ) . getItem ( event . getSlot ( ) ) ; boolean normalItem = true ; if ( clickedItem == null ) { normalItem = false ; } else { if ( clickedItem . hasItemMeta ( ) ) { if ( clickedItem . getItemMeta ( ) . hasLore ( ) ) { if ( clickedItem . getItemMeta ( ) . getLore ( ) . contains ( ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " ) ) { normalItem = false ; } } } } if ( normalItem ) { event . setCancelled ( false ) ; } if ( event . getClickedInventory ( ) . getTitle ( ) . equals ( ChatColor . BLUE + " SQTech ▁ - ▁ Basic ▁ Generator " ) ) { if ( event . getSlot ( ) == 26 ) { GUIBlock guiBlock = ObjectUtils . getMachineFromMachineGUI ( this ) . getGUIBlock ( ) ; guiBlock . getGUI ( owner ) . open ( ) ; } else if ( event . getSlot ( ) == 10 ) { event . setCancelled ( false ) ; } } } else { if ( event . getAction ( ) . equals ( InventoryAction . MOVE_TO_OTHER_INVENTORY ) ) { event . setCancelled ( true ) ; } } } }
castagna/jax-rs-example | @ Before public void setUp ( ) throws Exception { resource = client . resource ( URL ) . path ( PATH ) ; model = ModelFactory . createDefaultModel ( ) ; model . add ( model . createResource ( " foo : bar " ) , RDFS . label , model . createLiteral ( " Bar " ) ) ; }
castagna/jax-rs-example | @ After public void tearDown ( ) throws Exception { if ( resource != null ) { resource = null ; } if ( model != null ) { model . close ( ) ; model = null ; } }
castagna/jax-rs-example | @ Test public void testSetUp ( ) { assertNotNull ( client ) ; assertNotNull ( resource ) ; assertNotNull ( model ) ; }
castagna/jax-rs-example | @ Test public void testPortIsOpen ( ) { try { new URL ( URL ) . openConnection ( ) . connect ( ) ; } catch ( MalformedURLException e ) { fail ( String . format ( " % s ▁ is ▁ not ▁ a ▁ valid ▁ URL . " , URL ) ) ; } catch ( IOException e ) { fail ( ) ; } }
castagna/jax-rs-example | @ Test public void testGetXML ( ) { testPostXML ( ) ; InputStream in = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( RDFMediaType . APPLICATION_TURTLE_CURRENT ) . get ( InputStream . class ) ; Model m = ModelFactory . createDefaultModel ( ) ; m . read ( in , " " , " TURTLE " ) ; assertTrue ( model . isIsomorphicWith ( m ) ) ; }
castagna/jax-rs-example | @ Test public void testGetTurtle ( ) { testPostTurtle ( ) ; InputStream in = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( RDFMediaType . APPLICATION_TURTLE_CURRENT ) . get ( InputStream . class ) ; Model m = ModelFactory . createDefaultModel ( ) ; m . read ( in , " " , " TURTLE " ) ; assertTrue ( model . isIsomorphicWith ( m ) ) ; }
castagna/jax-rs-example | @ Test public void testPut ( ) { assertEquals ( " Put ! " , resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . TEXT_PLAIN ) . put ( String . class ) ) ; }
castagna/jax-rs-example | @ Test public void testPostXML ( ) { StringWriter content = new StringWriter ( ) ; model . write ( content , " RDF / XML " ) ; resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . TEXT_PLAIN ) . entity ( content . toString ( ) , RDFMediaType . APPLICATION_RDFXML ) . post ( InputStream . class ) ; }
castagna/jax-rs-example | @ Test public void testPostTurtle ( ) { StringWriter content = new StringWriter ( ) ; model . write ( content , " TURTLE " ) ; resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . TEXT_PLAIN ) . entity ( content . toString ( ) , RDFMediaType . APPLICATION_TURTLE_CURRENT ) . post ( InputStream . class ) ; }
castagna/jax-rs-example | @ Test public void testDelete ( ) { try { Response response = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . WILDCARD_TYPE ) . delete ( Response . class ) ; assertEquals ( Response . Status . NOT_FOUND , response . getStatus ( ) ) ; } catch ( UniformInterfaceException e ) { } testPostTurtle ( ) ; try { Response response = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . WILDCARD_TYPE ) . delete ( Response . class ) ; assertEquals ( Response . Status . NO_CONTENT , response . getStatus ( ) ) ; } catch ( UniformInterfaceException e ) { } }
castagna/jax-rs-example | @ Test public void testApplicationWadl ( ) { resource = client . resource ( URL ) ; String wadl = resource . path ( " application . wadl " ) . accept ( MediaTypes . WADL ) . get ( String . class ) ; assertTrue ( wadl . length ( ) > 0 ) ; assertTrue ( wadl . contains ( " method ▁ name = \" GET \" " ) ) ; assertTrue ( wadl . contains ( " method ▁ name = \" PUT \" " ) ) ; assertTrue ( wadl . contains ( " method ▁ name = \" POST \" " ) ) ; assertTrue ( wadl . contains ( " method ▁ name = \" DELETE \" " ) ) ; }
Esri/geoportal-server | public ApplicationException ( ) { super ( ) ; }
Esri/geoportal-server | public ApplicationException ( String msg ) { super ( msg ) ; }
Esri/geoportal-server | public ApplicationException ( String msg , Throwable cause ) { super ( msg , cause ) ; }
Esri/geoportal-server | public ApplicationException ( Throwable cause ) { super ( cause ) ; }
b-slim/druid | @ Test public void testSanity ( ) throws Exception { URL segmentDesciptor = this . getClass ( ) . getClassLoader ( ) . getResource ( " test - segment / descriptor . json " ) ; DataSegment segment = HadoopDruidIndexerConfig . JSON_MAPPER . readValue ( segmentDesciptor , DataSegment . class ) . withLoadSpec ( ImmutableMap . < String , Object > of ( " type " , " local " , " path " , this . getClass ( ) . getClassLoader ( ) . getResource ( " test - segment / index . zip " ) . getPath ( ) ) ) ; InputSplit split = new DatasourceInputSplit ( Lists . newArrayList ( WindowedDataSegment . of ( segment ) ) , null ) ; Configuration config = new Configuration ( ) ; DatasourceInputFormat . addDataSource ( config , new DatasourceIngestionSpec ( segment . getDataSource ( ) , segment . getInterval ( ) , null , null , null , segment . getDimensions ( ) , segment . getMetrics ( ) , false , null ) , Collections . emptyList ( ) , 0 ) ; TaskAttemptContext context = EasyMock . createNiceMock ( TaskAttemptContext . class ) ; EasyMock . expect ( context . getConfiguration ( ) ) . andReturn ( config ) . anyTimes ( ) ; EasyMock . replay ( context ) ; DatasourceRecordReader rr = new DatasourceRecordReader ( ) ; rr . initialize ( split , context ) ; Assert . assertEquals ( 0 , rr . getProgress ( ) , 0.0001 ) ; List < InputRow > rows = Lists . newArrayList ( ) ; while ( rr . nextKeyValue ( ) ) { rows . add ( rr . getCurrentValue ( ) ) ; } verifyRows ( rows ) ; Assert . assertEquals ( 1 , rr . getProgress ( ) , 0.0001 ) ; rr . close ( ) ; }
b-slim/druid | private void verifyRows ( List < InputRow > actualRows ) { List < ImmutableMap < String , Object > > expectedRows = ImmutableList . of ( ImmutableMap . < String , Object > of ( " time " , DateTimes . of ( "2014-10-22T00:00:00.000Z " ) , " host " , ImmutableList . of ( " a . example . com " ) , " visited _ sum " , 100L , " unique _ hosts " , 1.0d ) , ImmutableMap . < String , Object > of ( " time " , DateTimes . of ( "2014-10-22T01:00:00.000Z " ) , " host " , ImmutableList . of ( " b . example . com " ) , " visited _ sum " , 150L , " unique _ hosts " , 1.0d ) , ImmutableMap . < String , Object > of ( " time " , DateTimes . of ( "2014-10-22T02:00:00.000Z " ) , " host " , ImmutableList . of ( " c . example . com " ) , " visited _ sum " , 200L , " unique _ hosts " , 1.0d ) ) ; Assert . assertEquals ( expectedRows . size ( ) , actualRows . size ( ) ) ; for ( int i = 0 ; i < expectedRows . size ( ) ; i ++ ) { Map < String , Object > expected = expectedRows . get ( i ) ; InputRow actual = actualRows . get ( i ) ; Assert . assertEquals ( ImmutableList . of ( " host " ) , actual . getDimensions ( ) ) ; Assert . assertEquals ( expected . get ( " time " ) , actual . getTimestamp ( ) ) ; Assert . assertEquals ( expected . get ( " host " ) , actual . getDimension ( " host " ) ) ; Assert . assertEquals ( expected . get ( " visited _ sum " ) , actual . getMetric ( " visited _ sum " ) ) ; Assert . assertEquals ( ( Double ) expected . get ( " unique _ hosts " ) , ( Double ) HyperUniquesAggregatorFactory . estimateCardinality ( actual . getRaw ( " unique _ hosts " ) , false ) , 0.001 ) ; } }
ApolloDev/apollo | public DiseaseOutcomeWithProbabilitySetter ( ) { }
ApolloDev/apollo | public DiseaseOutcomeWithProbabilitySetter ( ApolloTranslationEngine apolloTranslationEngine , String prefix , String section ) { super ( prefix , section , apolloTranslationEngine ) ; }
ApolloDev/apollo | private List < SetterReturnObject > setDiseaseOutcome ( DiseaseOutcomeEnum outcome ) throws ApolloSetterException { DiseaseOutcomeSetter setter = new DiseaseOutcomeSetter ( apolloTranslationEngine , type + " . " + DISEASE_OUTCOME_FIELD , section ) ; return setter . set ( outcome ) ; }
ApolloDev/apollo | private List < SetterReturnObject > setProbability ( ProbabilisticParameter value ) throws ApolloSetterException { ProbabilisticParameterSetter setter = new ProbabilisticParameterSetter ( apolloTranslationEngine , type + " . " + PROBABILITY_FIELD , section ) ; return setter . set ( value ) ; }
ApolloDev/apollo | @ Override public List < SetterReturnObject > set ( DiseaseOutcomeWithProbability t ) throws ApolloSetterException { List < SetterReturnObject > list = new ArrayList < SetterReturnObject > ( ) ; list . addAll ( setDiseaseOutcome ( t . getDiseaseOutcome ( ) ) ) ; list . addAll ( setProbability ( t . getProbability ( ) ) ) ; return list ; }
allotria/intellij-community | public FrameworkSupportConfigurableBase ( FrameworkSupportProviderBase frameworkSupportProvider , FrameworkSupportModel model ) { this ( frameworkSupportProvider , model , Collections . emptyList ( ) , null ) ; }
allotria/intellij-community | public FrameworkSupportConfigurableBase ( FrameworkSupportProviderBase frameworkSupportProvider , FrameworkSupportModel model , @ NotNull List < FrameworkVersion > versions , @ NlsContexts . Label @ Nullable String versionLabelText ) { myFrameworkSupportProvider = frameworkSupportProvider ; myFrameworkSupportModel = model ; myVersions = versions ; myDescriptionLabel . setText ( versionLabelText ) ; myVersionComboBox . setRenderer ( SimpleListCellRenderer . create ( " " , FrameworkVersion :: getVersionName ) ) ; updateAvailableVersions ( versions ) ; myVersionComboBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { fireFrameworkVersionChanged ( ) ; } } ) ; }
allotria/intellij-community | protected void updateAvailableVersions ( List < ? extends FrameworkVersion > versions ) { if ( versions . size ( ) > 0 ) { String maxValue = " " ; ( ( DefaultComboBoxModel ) myVersionComboBox . getModel ( ) ) . removeAllElements ( ) ; FrameworkVersion defaultVersion = versions . get ( versions . size ( ) - 1 ) ; for ( FrameworkVersion version : versions ) { myVersionComboBox . addItem ( version ) ; FontMetrics fontMetrics = myVersionComboBox . getFontMetrics ( myVersionComboBox . getFont ( ) ) ; if ( fontMetrics . stringWidth ( version . getVersionName ( ) ) > fontMetrics . stringWidth ( maxValue ) ) { maxValue = version . getVersionName ( ) ; } if ( version . isDefault ( ) ) { defaultVersion = version ; } } myVersionComboBox . setSelectedItem ( defaultVersion ) ; myVersionComboBox . setPrototypeDisplayValue ( new FrameworkVersion ( maxValue + " _ " ) ) ; } final boolean hasMoreThanOneVersion = versions . size ( ) >= 2 ; myDescriptionLabel . setVisible ( hasMoreThanOneVersion ) ; myVersionComboBox . setVisible ( hasMoreThanOneVersion ) ; }
allotria/intellij-community | @ Override public JComponent getComponent ( ) { return myMainPanel ; }
allotria/intellij-community | protected void reloadVersions ( List < ? extends FrameworkVersion > frameworkVersions ) { myVersions . clear ( ) ; myVersions . addAll ( frameworkVersions ) ; }
allotria/intellij-community | @ Override @ NotNull public List < ? extends FrameworkVersion > getVersions ( ) { return myVersions ; }
allotria/intellij-community | public LibraryInfo @ NotNull [ ] getLibraries ( ) { return getSelectedVersion ( ) . getLibraries ( ) ; }
allotria/intellij-community | @ Override public void addSupport ( @ NotNull final Module module , @ NotNull final ModifiableRootModel rootModel , final @ Nullable Library library ) { myFrameworkSupportProvider . addSupport ( module , rootModel , getSelectedVersion ( ) , library ) ; }
allotria/intellij-community | @ Override public FrameworkVersion getSelectedVersion ( ) { return ( FrameworkVersion ) myVersionComboBox . getSelectedItem ( ) ; }
dickschoeller/gedbrowser | @ Override public final TrailerDocument findByFileAndString ( final String filename , final String string ) { final Query searchQuery = new Query ( Criteria . where ( " string " ) . is ( string ) . and ( " filename " ) . is ( filename ) ) ; final TrailerDocument trailerDocument = mongoTemplate . findOne ( searchQuery , TrailerDocumentMongo . class ) ; if ( trailerDocument == null ) { return null ; } final Trailer trailer = ( Trailer ) toObjConverter . createGedObject ( null , trailerDocument ) ; trailerDocument . setGedObject ( trailer ) ; return trailerDocument ; }
dickschoeller/gedbrowser | @ Override public final TrailerDocument findByRootAndString ( final RootDocument rootDocument , final String string ) { final TrailerDocument trailerDocument = findByFileAndString ( rootDocument . getFilename ( ) , string ) ; if ( trailerDocument == null ) { return null ; } final Trailer trailer = trailerDocument . getGedObject ( ) ; trailer . setParent ( rootDocument . getGedObject ( ) ) ; return trailerDocument ; }
dickschoeller/gedbrowser | @ Override public final Iterable < TrailerDocument > findAll ( final String filename ) { final Query searchQuery = new Query ( Criteria . where ( " filename " ) . is ( filename ) ) ; final List < TrailerDocumentMongo > trailerDocumentsMongo = mongoTemplate . find ( searchQuery , TrailerDocumentMongo . class ) ; if ( trailerDocumentsMongo == null ) { return null ; } final List < TrailerDocument > trailerDocuments = new ArrayList < > ( ) ; for ( final TrailerDocument trailerDocument : trailerDocumentsMongo ) { final Trailer trailer = ( Trailer ) toObjConverter . createGedObject ( null , trailerDocument ) ; trailerDocument . setGedObject ( trailer ) ; trailerDocuments . add ( trailerDocument ) ; } return trailerDocuments ; }
dickschoeller/gedbrowser | @ Override public final Iterable < TrailerDocument > findAll ( final RootDocument rootDocument ) { final Iterable < TrailerDocument > trailerDocuments = findAll ( rootDocument . getFilename ( ) ) ; if ( trailerDocuments == null ) { return null ; } for ( final TrailerDocument trailerDocument : trailerDocuments ) { final Trailer trailer = trailerDocument . getGedObject ( ) ; trailer . setParent ( rootDocument . getGedObject ( ) ) ; } return trailerDocuments ; }
dickschoeller/gedbrowser | @ Override public final long count ( final String filename ) { final Query searchQuery = new Query ( Criteria . where ( " filename " ) . is ( filename ) ) ; return mongoTemplate . count ( searchQuery , TrailerDocumentMongo . class ) ; }
dickschoeller/gedbrowser | @ Override public final long count ( final RootDocument rootDocument ) { return count ( rootDocument . getFilename ( ) ) ; }
dickschoeller/gedbrowser | @ Override public String lastId ( final RootDocument rootDocument ) { return " " ; }
dickschoeller/gedbrowser | @ Override public String newId ( final RootDocument rootDocument ) { return " " ; }
JSDemos/android-sdk-20 | protected Identity ( ) { }
JSDemos/android-sdk-20 | public Identity ( String name ) { this . name = name ; }
JSDemos/android-sdk-20 | public Identity ( String name , IdentityScope scope ) throws KeyManagementException { this ( name ) ; if ( scope != null ) { scope . addIdentity ( this ) ; this . scope = scope ; } }
JSDemos/android-sdk-20 | public void addCertificate ( Certificate certificate ) throws KeyManagementException { PublicKey certPK = certificate . getPublicKey ( ) ; if ( publicKey != null ) { if ( ! checkKeysEqual ( publicKey , certPK ) ) { throw new KeyManagementException ( " Cert ' s ▁ public ▁ key ▁ does ▁ not ▁ match ▁ Identity ' s ▁ public ▁ key " ) ; } } else { publicKey = certPK ; } if ( certificates == null ) { certificates = new Vector < Certificate > ( ) ; } certificates . add ( certificate ) ; }
JSDemos/android-sdk-20 | public void removeCertificate ( Certificate certificate ) throws KeyManagementException { if ( certificates != null ) { if ( ! certificates . contains ( certificate ) ) { throw new KeyManagementException ( " Certificate ▁ not ▁ found " ) ; } certificates . removeElement ( certificate ) ; } }
JSDemos/android-sdk-20 | public Certificate [ ] certificates ( ) { if ( certificates == null ) { return new Certificate [ 0 ] ; } Certificate [ ] ret = new Certificate [ certificates . size ( ) ] ; certificates . copyInto ( ret ) ; return ret ; }
JSDemos/android-sdk-20 | protected boolean identityEquals ( Identity identity ) { if ( ! name . equals ( identity . name ) ) { return false ; } if ( publicKey == null ) { return ( identity . publicKey == null ) ; } return checkKeysEqual ( publicKey , identity . publicKey ) ; }
JSDemos/android-sdk-20 | public String toString ( boolean detailed ) { String s = toString ( ) ; if ( detailed ) { s += " ▁ " + info ; } return s ; }
JSDemos/android-sdk-20 | public final IdentityScope getScope ( ) { return scope ; }
JSDemos/android-sdk-20 | public void setPublicKey ( PublicKey key ) throws KeyManagementException { if ( ( scope != null ) && ( key != null ) ) { Identity i = scope . getIdentity ( key ) ; if ( ( i != null ) && ( i != this ) ) { throw new KeyManagementException ( " key ▁ already ▁ used ▁ in ▁ scope " ) ; } } this . publicKey = key ; certificates = null ; }
JSDemos/android-sdk-20 | public PublicKey getPublicKey ( ) { return publicKey ; }
JSDemos/android-sdk-20 | public void setInfo ( String info ) { this . info = info ; }
JSDemos/android-sdk-20 | public String getInfo ( ) { return info ; }
JSDemos/android-sdk-20 | @ Override public final boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof Identity ) ) { return false ; } Identity i = ( Identity ) obj ; if ( Objects . equal ( name , i . name ) && ( Objects . equal ( scope , i . scope ) ) ) { return true ; } return identityEquals ( i ) ; }
JSDemos/android-sdk-20 | public final String getName ( ) { return name ; }
JSDemos/android-sdk-20 | @ Override public int hashCode ( ) { int hash = 0 ; if ( name != null ) { hash += name . hashCode ( ) ; } if ( scope != null ) { hash += scope . hashCode ( ) ; } return hash ; }
JSDemos/android-sdk-20 | @ Override public String toString ( ) { String s = ( this . name == null ? " " : this . name ) ; if ( scope != null ) { s += " ▁ [ " + scope . getName ( ) + " ] " ; } return s ; }
TomRoss/activemq-artemis | @ Override public SslContext getClientSslContext ( final SSLContextConfig config , final Map < String , Object > additionalOpts ) throws Exception { log . debugf ( " Creating ▁ Client ▁ OpenSSL ▁ Context ▁ with ▁ % s " , config ) ; return new SSLSupport ( config ) . setSslProvider ( TransportConstants . OPENSSL_PROVIDER ) . createNettyClientContext ( ) ; }
TomRoss/activemq-artemis | @ Override public SslContext getServerSslContext ( final SSLContextConfig config , final Map < String , Object > additionalOpts ) throws Exception { log . debugf ( " Creating ▁ Server ▁ OpenSSL ▁ Context ▁ with ▁ % s " , config ) ; return new SSLSupport ( config ) . setSslProvider ( TransportConstants . OPENSSL_PROVIDER ) . createNettyContext ( ) ; }
TomRoss/activemq-artemis | @ Override public int getPriority ( ) { return 5 ; }
eSDK/esdk_cloud_fm_r3_native_java | public String getName ( ) { return name ; }
eSDK/esdk_cloud_fm_r3_native_java | public void setName ( String name ) { this . name = name ; }
eSDK/esdk_cloud_fm_r3_native_java | public String getValue ( ) { return value ; }
eSDK/esdk_cloud_fm_r3_native_java | public void setValue ( String value ) { this . value = value ; }
brucevsked/vskeddemolist | " ) public String service1 ( @ PathVariable String username ) { return restTemplate . getForObject ( " http : // myprovider1 / service1 / " + username , String . class ) ; }
everttigchelaar/camel-svn | @ Test public void testMarshalDomainObject ( ) throws Exception { MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 1 ) ; PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; template . sendBody ( " direct : in " , order ) ; mock . assertIsSatisfied ( ) ; }
everttigchelaar/camel-svn | @ Test public void testMarshalDomainObjectTwice ( ) throws Exception { MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 2 ) ; PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; template . sendBody ( " direct : in " , order ) ; template . sendBody ( " direct : in " , order ) ; mock . assertIsSatisfied ( ) ; String body1 = mock . getExchanges ( ) . get ( 0 ) . getIn ( ) . getBody ( String . class ) ; String body2 = mock . getExchanges ( ) . get ( 1 ) . getIn ( ) . getBody ( String . class ) ; assertEquals ( " The ▁ body ▁ should ▁ marshalled ▁ to ▁ the ▁ same " , body1 , body2 ) ; }
everttigchelaar/camel-svn | @ Test public void testMarshalAndUnmarshal ( ) throws Exception { PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; MockEndpoint mock = getMockEndpoint ( " mock : reverse " ) ; mock . expectedMessageCount ( 1 ) ; mock . message ( 0 ) . body ( ) . isInstanceOf ( PurchaseOrder . class ) ; mock . message ( 0 ) . body ( ) . equals ( order ) ; Object result = ( Object ) template . requestBody ( " direct : marshal " , order ) ; String body = context . getTypeConverter ( ) . convertTo ( String . class , result ) ; template . sendBody ( " direct : reverse " , body ) ; mock . assertIsSatisfied ( ) ; }
everttigchelaar/camel-svn | protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : in " ) . marshal ( ) . xstream ( ) . to ( " mock : result " ) ; from ( " direct : marshal " ) . marshal ( ) . xstream ( " UTF - 8" ) ; from ( " direct : reverse " ) . unmarshal ( ) . xstream ( " UTF - 8" ) . to ( " mock : reverse " ) ; } } ; }
googleapis/google-api-java-client-services | public java . util . List < PivotGroup > getColumns ( ) { return columns ; }
googleapis/google-api-java-client-services | public PivotTable setColumns ( java . util . List < PivotGroup > columns ) { this . columns = columns ; return this ; }
googleapis/google-api-java-client-services | public java . util . Map < String , PivotFilterCriteria > getCriteria ( ) { return criteria ; }
googleapis/google-api-java-client-services | public PivotTable setCriteria ( java . util . Map < String , PivotFilterCriteria > criteria ) { this . criteria = criteria ; return this ; }
googleapis/google-api-java-client-services | public DataExecutionStatus getDataExecutionStatus ( ) { return dataExecutionStatus ; }
googleapis/google-api-java-client-services | public PivotTable setDataExecutionStatus ( DataExecutionStatus dataExecutionStatus ) { this . dataExecutionStatus = dataExecutionStatus ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getDataSourceId ( ) { return dataSourceId ; }
googleapis/google-api-java-client-services | public PivotTable setDataSourceId ( java . lang . String dataSourceId ) { this . dataSourceId = dataSourceId ; return this ; }
googleapis/google-api-java-client-services | public java . util . List < PivotFilterSpec > getFilterSpecs ( ) { return filterSpecs ; }
googleapis/google-api-java-client-services | public PivotTable setFilterSpecs ( java . util . List < PivotFilterSpec > filterSpecs ) { this . filterSpecs = filterSpecs ; return this ; }
googleapis/google-api-java-client-services | public java . util . List < PivotGroup > getRows ( ) { return rows ; }
googleapis/google-api-java-client-services | public PivotTable setRows ( java . util . List < PivotGroup > rows ) { this . rows = rows ; return this ; }
googleapis/google-api-java-client-services | public GridRange getSource ( ) { return source ; }
googleapis/google-api-java-client-services | public PivotTable setSource ( GridRange source ) { this . source = source ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getValueLayout ( ) { return valueLayout ; }
googleapis/google-api-java-client-services | public PivotTable setValueLayout ( java . lang . String valueLayout ) { this . valueLayout = valueLayout ; return this ; }
googleapis/google-api-java-client-services | public java . util . List < PivotValue > getValues ( ) { return values ; }
googleapis/google-api-java-client-services | public PivotTable setValues ( java . util . List < PivotValue > values ) { this . values = values ; return this ; }
googleapis/google-api-java-client-services | @ Override public PivotTable set ( String fieldName , Object value ) { return ( PivotTable ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public PivotTable clone ( ) { return ( PivotTable ) super . clone ( ) ; }
ucare-uchicago/hadoop | @ Before public void before ( ) { SubmarineLogs . verboseOff ( ) ; }
ucare-uchicago/hadoop | @ Test public void testPrintHelp ( ) { MockClientContext mockClientContext = new MockClientContext ( ) ; JobSubmitter mockJobSubmitter = mock ( JobSubmitter . class ) ; JobMonitor mockJobMonitor = mock ( JobMonitor . class ) ; RunJobCli runJobCli = new RunJobCli ( mockClientContext , mockJobSubmitter , mockJobMonitor ) ; runJobCli . printUsages ( ) ; }
ucare-uchicago/hadoop | @ Test public void testBasicRunJobForDistributedTraining ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; Assert . assertFalse ( SubmarineLogs . isVerbose ( ) ) ; runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - input _ path " , " hdfs : // input " , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "3" , " - - num _ ps " , "2" , " - - worker _ launch _ cmd " , " python ▁ run - job . py " , " - - worker _ resources " , " memory = 2048M , vcores = 2" , " - - ps _ resources " , " memory = 4G , vcores = 4" , " - - tensorboard " , " true " , " - - ps _ launch _ cmd " , " python ▁ run - ps . py " , " - - verbose " } ) ; RunJobParameters jobRunParameters = runJobCli . getRunJobParameters ( ) ; Assert . assertEquals ( jobRunParameters . getInputPath ( ) , " hdfs : // input " ) ; Assert . assertEquals ( jobRunParameters . getCheckpointPath ( ) , " hdfs : // output " ) ; Assert . assertEquals ( jobRunParameters . getNumPS ( ) , 2 ) ; Assert . assertEquals ( jobRunParameters . getPSLaunchCmd ( ) , " python ▁ run - ps . py " ) ; Assert . assertEquals ( Resources . createResource ( 4096 , 4 ) , jobRunParameters . getPsResource ( ) ) ; Assert . assertEquals ( jobRunParameters . getWorkerLaunchCmd ( ) , " python ▁ run - job . py " ) ; Assert . assertEquals ( Resources . createResource ( 2048 , 2 ) , jobRunParameters . getWorkerResource ( ) ) ; Assert . assertEquals ( jobRunParameters . getDockerImageName ( ) , " tf - docker : 1.1.0" ) ; Assert . assertTrue ( SubmarineLogs . isVerbose ( ) ) ; }
ucare-uchicago/hadoop | @ Test public void testBasicRunJobForSingleNodeTraining ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; Assert . assertFalse ( SubmarineLogs . isVerbose ( ) ) ; runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - input _ path " , " hdfs : // input " , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "1" , " - - worker _ launch _ cmd " , " python ▁ run - job . py " , " - - worker _ resources " , " memory = 4g , vcores = 2" , " - - tensorboard " , " true " , " - - verbose " , " - - wait _ job _ finish " } ) ; RunJobParameters jobRunParameters = runJobCli . getRunJobParameters ( ) ; Assert . assertEquals ( jobRunParameters . getInputPath ( ) , " hdfs : // input " ) ; Assert . assertEquals ( jobRunParameters . getCheckpointPath ( ) , " hdfs : // output " ) ; Assert . assertEquals ( jobRunParameters . getNumWorkers ( ) , 1 ) ; Assert . assertEquals ( jobRunParameters . getWorkerLaunchCmd ( ) , " python ▁ run - job . py " ) ; Assert . assertEquals ( Resources . createResource ( 4096 , 2 ) , jobRunParameters . getWorkerResource ( ) ) ; Assert . assertTrue ( SubmarineLogs . isVerbose ( ) ) ; Assert . assertTrue ( jobRunParameters . isWaitJobFinish ( ) ) ; }
ucare-uchicago/hadoop | @ Test public void testNoInputPathOptionSpecified ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; String expectedErrorMessage = " \" - - " + CliConstants . INPUT_PATH + " \" ▁ is ▁ absent " ; String actualMessage = " " ; try { runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "1" , " - - worker _ launch _ cmd " , " python ▁ run - job . py " , " - - worker _ resources " , " memory = 4g , vcores = 2" , " - - tensorboard " , " true " , " - - verbose " , " - - wait _ job _ finish " } ) ; } catch ( ParseException e ) { actualMessage = e . getMessage ( ) ; e . printStackTrace ( ) ; } Assert . assertEquals ( expectedErrorMessage , actualMessage ) ; }
ucare-uchicago/hadoop | @ Test public void testNoInputPathOptionButOnlyRunTensorboard ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; boolean success = true ; try { runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - num _ workers " , "0" , " - - tensorboard " , " - - verbose " , " - - tensorboard _ resources " , " memory = 2G , vcores = 2" , " - - tensorboard _ docker _ image " , " tb _ docker _ image : 001" } ) ; } catch ( ParseException e ) { success = false ; } Assert . assertTrue ( success ) ; }
ucare-uchicago/hadoop | @ Test public void testLaunchCommandPatternReplace ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; Assert . assertFalse ( SubmarineLogs . isVerbose ( ) ) ; runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - input _ path " , " hdfs : // input " , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "3" , " - - num _ ps " , "2" , " - - worker _ launch _ cmd " , " python ▁ run - job . py ▁ - - input = % input _ path % ▁ - - model _ dir = % checkpoint _ path % ▁ - - export _ dir = % saved _ model _ path % / savedmodel " , " - - worker _ resources " , " memory = 2048 , vcores = 2" , " - - ps _ resources " , " memory = 4096 , vcores = 4" , " - - tensorboard " , " true " , " - - ps _ launch _ cmd " , " python ▁ run - ps . py ▁ - - input = % input _ path % ▁ - - model _ dir = % checkpoint _ path % / model " , " - - verbose " } ) ; Assert . assertEquals ( " python ▁ run - job . py ▁ - - input = hdfs : // input ▁ - - model _ dir = hdfs : // output ▁ " + " - - export _ dir = hdfs : // output / savedmodel " , runJobCli . getRunJobParameters ( ) . getWorkerLaunchCmd ( ) ) ; Assert . assertEquals ( " python ▁ run - ps . py ▁ - - input = hdfs : // input ▁ - - model _ dir = hdfs : // output / model " , runJobCli . getRunJobParameters ( ) . getPSLaunchCmd ( ) ) ; }
ucare-uchicago/hadoop | @ Test public void testResourceUnitParsing ( ) throws Exception { Resource res = CliUtils . createResourceFromString ( " memory = 20g , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 * 1024 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20G , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 * 1024 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20M , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20m , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory - mb = 20 , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory - mb = 20m , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory - mb = 20G , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 * 1024 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20 , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 0 , 3 ) , res ) ; List < ResourceTypeInfo > resTypes = new ArrayList < > ( ResourceUtils . getResourcesTypeInfo ( ) ) ; resTypes . add ( ResourceTypeInfo . newInstance ( ResourceInformation . GPU_URI , " " ) ) ; ResourceUtils . reinitializeResources ( resTypes ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , gpu = 0" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 0 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , gpu = 3" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 3 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 0 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , yarn . io / gpu = 0" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 0 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , yarn . io / gpu = 3" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 3 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; }
mingxin6/incu | if ( user . getIsBusiness ( ) ) { request . setAttribute ( " type " , " B " ) ; }
mingxin6/incu | catch ( Exception e ) { e . printStackTrace ( ) ; }
mingxin6/incu | catch ( Exception e ) { }
kyunooh/goree-server | @ Before public void setUp ( ) { MockitoAnnotations . initMocks ( this ) ; mockMvc = MockMvcBuilders . standaloneSetup ( placeController ) . build ( ) ; }
kyunooh/goree-server | @ Test public void findPlaceById ( ) throws Exception { Place expected = new Place ( ) ; expected . setId ( 1L ) ; expected . setName ( " goodnews " ) ; expected . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; expected . setXCoordinate ( new BigDecimal ( "36.017194" ) ) ; expected . setYCoordinate ( new BigDecimal ( "128.6978236" ) ) ; when ( placeService . findPlaceById ( expected . getId ( ) ) ) . thenReturn ( expected ) ; mockMvc . perform ( get ( PlaceController . FIND_PLACE_BY_ID_URL , expected . getId ( ) ) . header ( HttpHeaderConstants . AUTH_TOKEN , settings . longLivedTokenForTest ( ) ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( jsonPath ( " $ . id " , is ( ( int ) expected . getId ( ) ) ) ) . andExpect ( jsonPath ( " $ . name " , is ( expected . getName ( ) ) ) ) . andExpect ( jsonPath ( " $ . address " , is ( expected . getAddress ( ) ) ) ) . andExpect ( jsonPath ( " $ . xCoordinate " , is ( expected . getXCoordinate ( ) . doubleValue ( ) ) ) ) . andExpect ( jsonPath ( " $ . yCoordinate " , is ( expected . getYCoordinate ( ) . doubleValue ( ) ) ) ) ; }
kyunooh/goree-server | @ Test public void createPlace ( ) throws Exception { Place newPlace = new Place ( ) ; newPlace . setName ( " goodnews " ) ; newPlace . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; newPlace . setXCoordinate ( new BigDecimal ( "36.017194" ) ) ; newPlace . setYCoordinate ( new BigDecimal ( "128.6978236" ) ) ; Place created = new Place ( ) ; PropertyUtils . copyProperties ( created , newPlace ) ; created . setId ( 1L ) ; when ( placeService . createPlace ( newPlace ) ) . thenReturn ( created ) ; mockMvc . perform ( post ( PlaceController . CREATE_PLACE_URL ) . header ( HttpHeaderConstants . AUTH_TOKEN , settings . longLivedTokenForTest ( ) ) . contentType ( MediaType . APPLICATION_JSON ) . content ( new ObjectMapper ( ) . writeValueAsString ( newPlace ) ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( jsonPath ( " $ . id " , is ( ( int ) created . getId ( ) ) ) ) . andExpect ( jsonPath ( " $ . name " , is ( created . getName ( ) ) ) ) . andExpect ( jsonPath ( " $ . address " , is ( created . getAddress ( ) ) ) ) . andExpect ( jsonPath ( " $ . xCoordinate " , is ( created . getXCoordinate ( ) . doubleValue ( ) ) ) ) . andExpect ( jsonPath ( " $ . yCoordinate " , is ( created . getYCoordinate ( ) . doubleValue ( ) ) ) ) ; }
kyunooh/goree-server | @ Test public void findPlaceByItself ( ) throws Exception { Place searchCondition = new Place ( ) ; searchCondition . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; Place expected = new Place ( ) ; expected . setName ( " goodnews " ) ; expected . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; expected . setXCoordinate ( new BigDecimal ( "36.017194" ) ) ; expected . setYCoordinate ( new BigDecimal ( "128.6978236" ) ) ; when ( placeService . findPlaceByItself ( searchCondition ) ) . thenReturn ( expected ) ; mockMvc . perform ( get ( PlaceController . FIND_PLACE_BY_ITSELF ) . header ( HttpHeaderConstants . AUTH_TOKEN , settings . longLivedTokenForTest ( ) ) . contentType ( MediaType . APPLICATION_JSON ) . content ( new ObjectMapper ( ) . writeValueAsString ( searchCondition ) ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( jsonPath ( " $ . id " , is ( ( int ) expected . getId ( ) ) ) ) . andExpect ( jsonPath ( " $ . name " , is ( expected . getName ( ) ) ) ) . andExpect ( jsonPath ( " $ . address " , is ( expected . getAddress ( ) ) ) ) . andExpect ( jsonPath ( " $ . xCoordinate " , is ( expected . getXCoordinate ( ) . doubleValue ( ) ) ) ) . andExpect ( jsonPath ( " $ . yCoordinate " , is ( expected . getYCoordinate ( ) . doubleValue ( ) ) ) ) ; }
Gusbru/pets | public PetCursorAdapter ( Context context , Cursor c ) { super ( context , c , 0 ) ; }
Gusbru/pets | @ Override public View newView ( Context context , Cursor cursor , ViewGroup parent ) { return LayoutInflater . from ( context ) . inflate ( R . layout . item_pet , parent , false ) ; }
Gusbru/pets | @ Override public void bindView ( View view , Context context , Cursor cursor ) { TextView petName = ( TextView ) view . findViewById ( R . id . pet_name ) ; TextView petBreed = ( TextView ) view . findViewById ( R . id . pet_breed ) ; String name = cursor . getString ( cursor . getColumnIndexOrThrow ( PetEntry . COLUMN_NAME ) ) ; String breed = cursor . getString ( cursor . getColumnIndexOrThrow ( PetEntry . COLUMN_BREED ) ) ; petName . setText ( name ) ; petBreed . setText ( breed ) ; }
emag/wildfly-swarm | protected Main ( ) { }
emag/wildfly-swarm | catch ( Exception e ) { throw new RuntimeException ( " Failed ▁ to ▁ load ▁ version . properties " , e ) ; }
emag/wildfly-swarm | ExitException ( final int status , final boolean printHelp , final String message ) { super ( message ) ; this . printHelp = printHelp ; this . status = status ; }
adessaigne/camel | @ Test public void givenPulsarConsumerIsNullwhenICreateFactoryverifyIllegalArgumentExceptionIsThrown ( ) { assertThrows ( IllegalArgumentException . class , ( ) -> ConsumerCreationStrategyFactory . create ( null ) ) ; }
adessaigne/camel | @ Test public void givenPulsarConsumerAndRetryPolicyNonNullwhenICreateFactoryverifyIllegalArgumentExceptionIsNotThrown ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; assertNotNull ( factory ) ; }
adessaigne/camel | @ Test public void verifyFailOverStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . FAILOVER ) ; assertEquals ( FailoverConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifySharedStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . SHARED ) ; assertEquals ( SharedConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifyExclusiveStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . EXCLUSIVE ) ; assertEquals ( ExclusiveConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifyKeySharedStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . KEY_SHARED ) ; assertEquals ( KeySharedConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifyDefaultStrategyIsExclusiveStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( null ) ; assertEquals ( ExclusiveConsumerStrategy . class , strategy . getClass ( ) ) ; }
comfreeze/android-tools | @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { android . os . Process . setThreadPriority ( android . os . Process . THREAD_PRIORITY_BACKGROUND ) ; if ( persistent ) { return START_STICKY ; } else { return super . onStartCommand ( intent , flags , startId ) ; } }
comfreeze/android-tools | @ Override public void onCreate ( ) { super . onCreate ( ) ; initializeWorkQueue ( ) ; Log . w ( TAG , " Well , ▁ hello ▁ there . . . ▁ you ▁ come ▁ here ▁ often ? " ) ; }
comfreeze/android-tools | @ Override public void onDestroy ( ) { super . onDestroy ( ) ; Log . w ( TAG , " I ' M ▁ MELtInG . . . ▁ mel . . tin . . . g . . . " ) ; }
comfreeze/android-tools | protected void initializeWorkQueue ( ) { workQueue = new ConcurrentLinkedQueue < CFZWorkerItem > ( ) ; workerThread = new CFZWorkerThread ( workQueue , getThreadTag ( ) ) ; workerThread . start ( ) ; }
comfreeze/android-tools | protected void addRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void scheduleRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { if ( ! workQueue . contains ( work ) && ! work . equals ( workerThread . getActive ( ) ) ) { workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } } }
comfreeze/android-tools | protected void schedulePriorityRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { cancelActiveWorkItem ( work ) ; workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void replaceRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { cancelPreviousWorkItem ( work ) ; workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void cancelPreviousWorkItem ( CFZWorkerItem work ) { synchronized ( workQueue ) { if ( workQueue . contains ( work ) ) workQueue . remove ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void cancelActiveWorkItem ( CFZWorkerItem work ) { cancelPreviousWorkItem ( work ) ; if ( work . equals ( workerThread . active ) ) workerThread . interrupt ( ) ; }
comfreeze/android-tools | protected void showNotification ( CharSequence message ) { Log . d ( TAG , " Showing ▁ notification " ) ; }
comfreeze/android-tools | protected void registerClient ( Message message ) { Log . d ( TAG , " Registering ▁ client " ) ; if ( null != message . replyTo ) clients . add ( message . replyTo ) ; }
comfreeze/android-tools | protected void unregisterClient ( Message message ) { Log . d ( TAG , " Unregistering ▁ client " ) ; if ( null != message . replyTo ) clients . remove ( message . replyTo ) ; }
comfreeze/android-tools | protected void sendMessage ( Messenger client , Message msg ) { Log . d ( TAG , " Sending ▁ mesage " ) ; try { client . send ( msg ) ; } catch ( RemoteException e ) { Log . e ( TAG , " Exception " , e ) ; clients . remove ( client ) ; } }
comfreeze/android-tools | protected void sendMessage ( Message msg ) { for ( int i = clients . size ( ) - 1 ; i >= 0 ; i -- ) { sendMessage ( clients . get ( i ) , msg ) ; } }
comfreeze/android-tools | protected void sendMessage ( int code ) { sendMessage ( Message . obtain ( null , code ) ) ; }
comfreeze/android-tools | public CFZWorkerThread ( ConcurrentLinkedQueue < CFZWorkerItem > workQueue , String name ) { super ( name ) ; this . workQueue = workQueue ; }
comfreeze/android-tools | private CFZWorkerItem getWork ( ) { synchronized ( workQueue ) { try { while ( workQueue . isEmpty ( ) ) workQueue . wait ( ) ; return workQueue . remove ( ) ; } catch ( InterruptedException ie ) { throw new AssertionError ( ie ) ; } } }
comfreeze/android-tools | public Runnable getActive ( ) { return this . active ; }
comfreeze/android-tools | public void run ( ) { for ( ; ; ) { active = getWork ( ) ; active . run ( ) ; } }
comfreeze/android-tools | public CFZWorkerItem ( Intent intent , int what ) { this . intent = intent ; this . what = what ; }
comfreeze/android-tools | public void run ( ) { processItem ( intent , what ) ; }
comfreeze/android-tools | public boolean equals ( CFZWorkerItem item ) { if ( null != item && null != item . intent && ( null != item . intent . getAction ( ) && null != intent && item . intent . getAction ( ) . equals ( intent . getAction ( ) ) ) && item . what == what ) return true ; return false ; }
pevdh/telegram-bots-java-api | public ChatContextTelegramBot ( String botToken , AbstractChatContextFactory chatContextFactory ) { this ( botToken , chatContextFactory , true ) ; }
pevdh/telegram-bots-java-api | public ChatContextTelegramBot ( String botToken , AbstractChatContextFactory chatContextFactory , boolean sendAsync ) { super ( botToken ) ; this . chatContextFactory = chatContextFactory ; }
pevdh/telegram-bots-java-api | public void add ( ChatContext context ) { contextMap . put ( context . getChatId ( ) , context ) ; }
pevdh/telegram-bots-java-api | public void addAll ( List < ? extends ChatContext > contextList ) { for ( ChatContext chatContext : contextList ) add ( chatContext ) ; }
pevdh/telegram-bots-java-api | @ Override protected void onStart ( ) { for ( ChatContext chatContext : contextMap . values ( ) ) chatContext . onStart ( ) ; }
pevdh/telegram-bots-java-api | @ Override protected void onStop ( ) { for ( ChatContext chatContext : contextMap . values ( ) ) chatContext . onStop ( ) ; }
pevdh/telegram-bots-java-api | @ Override protected void onMessage ( Message message ) { int chatId = message . getChat ( ) . getId ( ) ; ChatContext chatContext ; synchronized ( contextMap ) { chatContext = contextMap . get ( chatId ) ; if ( chatContext == null ) chatContext = createNewChatContext ( chatId ) ; } chatContext . passMessage ( message ) ; }
pevdh/telegram-bots-java-api | private ChatContext createNewChatContext ( int chatId ) { ChatContext chatContext = chatContextFactory . createChatContext ( chatId , this ) ; contextMap . put ( chatId , chatContext ) ; return chatContext ; }
Esjob-Cloud-DevOps/elastic-job | @ Override public void execute ( final ShardingContext shardingContext ) { completed = true ; }
chunzj/closure-templates | private CssNode ( int id , String commandText , @ Nullable ExprRootNode componentNameExpr , String selectorText , SourceLocation sourceLocation ) { super ( id , sourceLocation , " css " , commandText ) ; this . componentNameExpr = componentNameExpr ; this . selectorText = selectorText ; if ( ! SELECTOR_TEXT_PATTERN . matcher ( selectorText ) . matches ( ) ) { maybeSetSyntaxVersionBound ( new SyntaxVersionBound ( SyntaxVersion . V2_1 , " Invalid ▁ ' css ' ▁ command ▁ text . " ) ) ; } }
chunzj/closure-templates | private CssNode ( CssNode orig , CopyState copyState ) { super ( orig , copyState ) ; this . componentNameExpr = ( orig . componentNameExpr != null ) ? orig . componentNameExpr . copy ( copyState ) : null ; this . selectorText = orig . selectorText ; }
chunzj/closure-templates | public CssNode ( CssNode orig , String newSelectorText , CopyState copyState ) { super ( orig , copyState ) ; this . componentNameExpr = ( orig . componentNameExpr != null ) ? orig . componentNameExpr . copy ( copyState ) : null ; this . selectorText = newSelectorText ; }
chunzj/closure-templates | @ Override public Kind getKind ( ) { return Kind . CSS_NODE ; }
chunzj/closure-templates | @ Nullable public ExprRootNode getComponentNameExpr ( ) { return componentNameExpr ; }
chunzj/closure-templates | public String getComponentNameText ( ) { return ( componentNameExpr != null ) ? componentNameExpr . toSourceString ( ) : null ; }
chunzj/closure-templates | public String getSelectorText ( ) { return selectorText ; }
chunzj/closure-templates | public String getRenamedSelectorText ( SoyCssRenamingMap cssRenamingMap ) { Pair < SoyCssRenamingMap , String > cache = renameCache ; if ( cache != null && cache . first == cssRenamingMap ) { return cache . second ; } if ( cssRenamingMap != null ) { String mappedText = cssRenamingMap . get ( selectorText ) ; if ( mappedText != null ) { renameCache = Pair . of ( cssRenamingMap , mappedText ) ; return mappedText ; } } return selectorText ; }
chunzj/closure-templates | @ Override public List < ExprUnion > getAllExprUnions ( ) { return ( componentNameExpr != null ) ? ImmutableList . of ( new ExprUnion ( componentNameExpr ) ) : Collections . < ExprUnion > emptyList ( ) ; }
chunzj/closure-templates | @ Override public BlockNode getParent ( ) { return ( BlockNode ) super . getParent ( ) ; }
chunzj/closure-templates | @ Override public CssNode copy ( CopyState copyState ) { return new CssNode ( this , copyState ) ; }
chunzj/closure-templates | public Builder ( int id , String commandText , SourceLocation sourceLocation ) { this . id = id ; this . commandText = commandText ; this . sourceLocation = sourceLocation ; }
chunzj/closure-templates | public CssNode build ( ErrorReporter errorReporter ) { int delimPos = commandText . lastIndexOf ( ' , ' ) ; ExprRootNode componentNameExpr = null ; String selectorText = commandText ; if ( delimPos != - 1 ) { String componentNameText = commandText . substring ( 0 , delimPos ) . trim ( ) ; componentNameExpr = new ExprRootNode ( new ExpressionParser ( componentNameText , sourceLocation , errorReporter ) . parseExpression ( ) ) ; selectorText = commandText . substring ( delimPos + 1 ) . trim ( ) ; } return new CssNode ( id , commandText , componentNameExpr , selectorText , sourceLocation ) ; }
aehlig/bazel | @ Override public List < BuildOptions > split ( BuildOptions buildOptions ) { AndroidConfiguration . Options androidOptions = buildOptions . get ( AndroidConfiguration . Options . class ) ; CppOptions cppOptions = buildOptions . get ( CppOptions . class ) ; Label androidCrosstoolTop = androidOptions . androidCrosstoolTop ; if ( androidOptions . fatApkCpus . isEmpty ( ) ) { if ( androidOptions . cpu . isEmpty ( ) || androidCrosstoolTop == null || androidCrosstoolTop . equals ( cppOptions . crosstoolTop ) ) { return ImmutableList . of ( buildOptions ) ; } else { BuildOptions splitOptions = buildOptions . clone ( ) ; splitOptions . get ( CoreOptions . class ) . cpu = androidOptions . cpu ; setCommonAndroidOptions ( androidOptions , splitOptions ) ; return ImmutableList . of ( splitOptions ) ; } } else { ImmutableList . Builder < BuildOptions > result = ImmutableList . builder ( ) ; for ( String cpu : ImmutableSortedSet . copyOf ( androidOptions . fatApkCpus ) ) { BuildOptions splitOptions = buildOptions . clone ( ) ; splitOptions . get ( AndroidConfiguration . Options . class ) . fatApkCpus = ImmutableList . of ( ) ; splitOptions . get ( AndroidConfiguration . Options . class ) . cpu = cpu ; splitOptions . get ( CoreOptions . class ) . cpu = cpu ; setCommonAndroidOptions ( androidOptions , splitOptions ) ; result . add ( splitOptions ) ; } return result . build ( ) ; } }
aehlig/bazel | private void setCommonAndroidOptions ( AndroidConfiguration . Options androidOptions , BuildOptions newOptions ) { newOptions . get ( CppOptions . class ) . cppCompiler = androidOptions . cppCompiler ; newOptions . get ( CppOptions . class ) . libcTopLabel = androidOptions . androidLibcTopLabel ; newOptions . get ( CppOptions . class ) . dynamicMode = androidOptions . dynamicMode ; setCrosstoolToAndroid ( newOptions ) ; newOptions . get ( PlatformOptions . class ) . platforms = ImmutableList . of ( ) ; }
aehlig/bazel | @ Override public boolean isImmutable ( ) { return true ; }
aehlig/bazel | @ Override public void repr ( SkylarkPrinter printer ) { printer . append ( " android _ common . multi _ cpu _ configuration " ) ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , final RuleDefinitionEnvironment env ) { return builder . add ( attr ( " manifest " , LABEL ) . allowedFileTypes ( FileType . of ( " . xml " ) ) ) . add ( attr ( " resource _ files " , LABEL_LIST ) . allowedFileTypes ( FileTypeSet . ANY_FILE ) ) . add ( attr ( " assets _ dir " , STRING ) ) . add ( attr ( " assets " , LABEL_LIST ) . allowedFileTypes ( FileTypeSet . ANY_FILE ) ) . add ( attr ( " inline _ constants " , BOOLEAN ) . undocumented ( " deprecated ▁ noop ▁ on ▁ library " ) . value ( false ) ) . add ( attr ( " custom _ package " , STRING ) ) . add ( attr ( " enable _ data _ binding " , Type . BOOLEAN ) ) . add ( attr ( DataBinding . DATABINDING_ANNOTATION_PROCESSOR_ATTR , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( env . getToolsLabel ( " // tools / android : databinding _ annotation _ processor " ) ) ) . add ( attr ( DataBinding . DATABINDING_EXEC_PROCESSOR_ATTR , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : databinding _ exec " ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( AndroidResourcesInfo . PROVIDER . getKey ( ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( AndroidNativeLibsInfo . PROVIDER . getKey ( ) ) ) . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ resource _ support " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( AndroidRuleClasses . AndroidBaseRule . class ) . build ( ) ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , RuleDefinitionEnvironment env ) { return builder . add ( attr ( " : android _ sdk " , LABEL ) . allowedRuleClasses ( " android _ sdk " ) . value ( getAndroidSdkLabel ( env . getToolsLabel ( AndroidRuleClasses . DEFAULT_SDK ) ) ) ) . add ( attr ( " plugins " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . allowedRuleClasses ( " java _ plugin " ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " : java _ plugins " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . allowedRuleClasses ( " java _ plugin " ) . silentRuleClassFilter ( ) . value ( JavaSemantics . JAVA_PLUGINS ) ) . add ( attr ( " javacopts " , STRING_LIST ) ) . add ( attr ( " $ idlclass " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : IdlClass " ) ) ) . add ( attr ( " $ desugar _ java8 _ extra _ bootclasspath " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( env . getToolsLabel ( " // tools / android : desugar _ java8 _ extra _ bootclasspath " ) ) ) . add ( attr ( " $ android _ resources _ busybox " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( DEFAULT_RESOURCES_BUSYBOX ) ) ) . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ base " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( BaseRuleClasses . RuleBase . class ) . build ( ) ; }
aehlig/bazel | public AndroidBinaryBaseRule ( AndroidNeverlinkAspect androidNeverlinkAspect , DexArchiveAspect dexArchiveAspect ) { this . androidNeverlinkAspect = androidNeverlinkAspect ; this . dexArchiveAspect = dexArchiveAspect ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , final RuleDefinitionEnvironment env ) { return builder . requiresConfigurationFragments ( AndroidConfiguration . class , JavaConfiguration . class , CppConfiguration . class ) . add ( attr ( " srcs " , LABEL_LIST ) . direct_compile_time_input ( ) . allowedFileTypes ( JavaSemantics . JAVA_SOURCE , JavaSemantics . SOURCE_JAR ) ) . override ( builder . copy ( " manifest " ) . mandatory ( ) ) . override ( builder . copy ( " deps " ) . cfg ( TransitionFactories . of ( ANDROID_SPLIT_TRANSITION ) ) . allowedRuleClasses ( ALLOWED_DEPENDENCIES ) . allowedFileTypes ( ) . mandatoryProviders ( CONTAINS_CC_INFO_PARAMS ) . mandatoryProviders ( JavaRuleClasses . CONTAINS_JAVA_PROVIDER ) . mandatoryProviders ( SkylarkProviderIdentifier . forKey ( AndroidResourcesInfo . PROVIDER . getKey ( ) ) , SkylarkProviderIdentifier . forKey ( AndroidAssetsInfo . PROVIDER . getKey ( ) ) ) . aspect ( androidNeverlinkAspect ) . aspect ( dexArchiveAspect , DexArchiveAspect . PARAM_EXTRACTOR ) ) . add ( attr ( " debug _ key " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . legacyAllowAnyFileType ( ) . value ( env . getToolsLabel ( " // tools / android : debug _ keystore " ) ) ) . add ( attr ( " nocompress _ extensions " , STRING_LIST ) ) . add ( attr ( " crunch _ png " , BOOLEAN ) . value ( true ) ) . add ( attr ( ResourceFilterFactory . RESOURCE_CONFIGURATION_FILTERS_NAME , STRING_LIST ) ) . add ( attr ( " shrink _ resources " , TRISTATE ) . value ( TriState . AUTO ) ) . add ( attr ( ResourceFilterFactory . DENSITIES_NAME , STRING_LIST ) ) . add ( attr ( " $ build _ incremental _ dexmanifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( BUILD_INCREMENTAL_DEXMANIFEST_LABEL ) ) ) . add ( attr ( " $ stubify _ manifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( STUBIFY_MANIFEST_LABEL ) ) ) . add ( attr ( " $ shuffle _ jars " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : shuffle _ jars " ) ) ) . add ( attr ( " $ dexbuilder " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexbuilder " ) ) ) . add ( attr ( " $ dexbuilder _ after _ proguard " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexbuilder _ after _ proguard " ) ) ) . add ( attr ( " $ dexsharder " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexsharder " ) ) ) . add ( attr ( " $ dexmerger " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexmerger " ) ) ) . add ( attr ( " $ merge _ dexzips " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : merge _ dexzips " ) ) ) . add ( attr ( " $ incremental _ install " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( INCREMENTAL_INSTALL_LABEL ) ) ) . add ( attr ( " $ build _ split _ manifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( BUILD_SPLIT_MANIFEST_LABEL ) ) ) . add ( attr ( " $ strip _ resources " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( STRIP_RESOURCES_LABEL ) ) ) . add ( attr ( " $ incremental _ stub _ application " , LABEL ) . value ( env . getToolsLabel ( DEFAULT_INCREMENTAL_STUB_APPLICATION ) ) . aspect ( dexArchiveAspect , DexArchiveAspect . ONLY_DESUGAR_JAVA8 ) ) . add ( attr ( " $ incremental _ split _ stub _ application " , LABEL ) . value ( env . getToolsLabel ( DEFAULT_INCREMENTAL_SPLIT_STUB_APPLICATION ) ) . aspect ( dexArchiveAspect , DexArchiveAspect . ONLY_DESUGAR_JAVA8 ) ) . add ( attr ( " $ desugar " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : desugar _ java8" ) ) ) . add ( attr ( " $ java8 _ legacy _ dex " , LABEL ) . value ( env . getToolsLabel ( " // tools / android : java8 _ legacy _ dex " ) ) ) . add ( attr ( " $ build _ java8 _ legacy _ dex " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : build _ java8 _ legacy _ dex " ) ) ) . add ( attr ( " $ desugared _ java8 _ legacy _ apis " , LABEL ) . value ( env . getToolsLabel ( " // tools / android : desugared _ java8 _ legacy _ apis " ) ) ) . add ( attr ( " dexopts " , STRING_LIST ) ) . add ( attr ( " dex _ shards " , INTEGER ) . value ( 1 ) ) . add ( attr ( " incremental _ dexing " , TRISTATE ) . nonconfigurable ( " AspectParameters ▁ don ' t ▁ support ▁ configurations . " ) ) . add ( attr ( " multidex " , STRING ) . allowedValues ( new AllowedValueSet ( MultidexMode . getValidValues ( ) ) ) . value ( MultidexMode . OFF . getAttributeValue ( ) ) ) . add ( attr ( " main _ dex _ list _ opts " , STRING_LIST ) ) . add ( attr ( " main _ dex _ list " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " main _ dex _ proguard _ specs " , LABEL_LIST ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ specs " , LABEL_LIST ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ generate _ mapping " , BOOLEAN ) . value ( false ) . nonconfigurable ( " value ▁ is ▁ referenced ▁ in ▁ an ▁ ImplicitOutputsFunction " ) ) . add ( attr ( " proguard _ apply _ mapping " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ apply _ dictionary " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " : extra _ proguard _ specs " , LABEL_LIST ) . value ( JavaSemantics . EXTRA_PROGUARD_SPECS ) ) . add ( attr ( " $ dex _ list _ obfuscator " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dex _ list _ obfuscator " ) ) ) . add ( attr ( " : bytecode _ optimizers " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . value ( JavaSemantics . BYTECODE_OPTIMIZERS ) ) . add ( attr ( " $ cc _ toolchain _ split " , LABEL ) . cfg ( TransitionFactories . of ( ANDROID_SPLIT_TRANSITION ) ) . value ( env . getToolsLabel ( " // tools / cpp : current _ cc _ toolchain " ) ) ) . add ( attr ( " manifest _ values " , STRING_DICT ) ) . add ( attr ( " aapt _ version " , STRING ) . allowedValues ( new AllowedValueSet ( AndroidAaptVersion . getAttributeValues ( ) ) ) . value ( AndroidAaptVersion . getRuleAttributeDefault ( ) ) ) . add ( attr ( AndroidFeatureFlagSetProvider . FEATURE_FLAG_ATTR , LABEL_KEYED_STRING_DICT ) . undocumented ( " the ▁ feature ▁ flag ▁ feature ▁ has ▁ not ▁ yet ▁ been ▁ launched " ) . allowedRuleClasses ( " config _ feature _ flag " ) . allowedFileTypes ( ) . nonconfigurable ( " defines ▁ an ▁ aspect ▁ of ▁ configuration " ) . mandatoryProviders ( ImmutableList . of ( ConfigFeatureFlagProvider . id ( ) ) ) ) . add ( AndroidFeatureFlagSetProvider . getWhitelistAttribute ( env ) ) . add ( attr ( " $ resource _ extractor " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : resource _ extractor " ) ) ) . add ( attr ( " instruments " , LABEL ) . allowedRuleClasses ( " android _ binary " ) . allowedFileTypes ( NO_FILE ) ) . add ( attr ( " $ instrumentation _ test _ check " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( new Attribute . ComputedDefault ( ) { @ Override public Object getDefault ( AttributeMap rule ) { return rule . isAttributeValueExplicitlySpecified ( " instruments " ) ? env . getToolsLabel ( " // tools / android : instrumentation _ test _ check " ) : null ; } } ) . exec ( ) ) . add ( attr ( " $ zip _ filter " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : zip _ filter " ) ) ) . add ( attr ( " application _ resources " , LABEL ) . mandatoryProviders ( AndroidApplicationResourceInfo . PROVIDER . id ( ) ) . allowedFileTypes ( NO_FILE ) . undocumented ( " Do ▁ not ▁ use ▁ this ▁ attribute . ▁ It ' s ▁ for ▁ the ▁ migration ▁ of ▁ " + " Android ▁ resource ▁ processing ▁ to ▁ Starlark ▁ only . " ) ) . removeAttribute ( " data " ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( ApkInfo . PROVIDER . getKey ( ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( JavaInfo . PROVIDER . getKey ( ) ) ) . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ binary _ base " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( AndroidResourceSupportRule . class ) . build ( ) ; }
aehlig/bazel | public String getAttributeValue ( ) { return toString ( ) . toLowerCase ( ) ; }
aehlig/bazel | public String getOutputDexFilename ( ) { return this == OFF ? " classes . dex " : " classes . dex . zip " ; }
aehlig/bazel | public AndroidToolsDefaultsJarRule ( Class < ? extends AndroidToolsDefaultsJar > factoryClass , Label ... compatibleWithAndroidEnvironments ) { this . factoryClass = factoryClass ; this . compatibleWithAndroidEnvironments = compatibleWithAndroidEnvironments ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , RuleDefinitionEnvironment environment ) { builder . setUndocumented ( ) . add ( attr ( " : android _ sdk " , LABEL ) . allowedRuleClasses ( " android _ sdk " ) . value ( getAndroidSdkLabel ( environment . getToolsLabel ( DEFAULT_SDK ) ) ) ) ; if ( compatibleWithAndroidEnvironments . length > 0 ) { builder . compatibleWith ( compatibleWithAndroidEnvironments ) ; } return builder . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return Metadata . builder ( ) . name ( " android _ tools _ defaults _ jar " ) . ancestors ( BaseRuleClasses . BaseRule . class ) . factoryClass ( factoryClass ) . build ( ) ; }
DongpoAlex/hhvss | public WritableSheet copySheetSettingToSheet ( WritableSheet sheet , SheetSettings setting ) { SheetSettings sheetSettings = sheet . getSettings ( ) ; sheetSettings . setBottomMargin ( setting . getBottomMargin ( ) ) ; sheetSettings . setCopies ( setting . getCopies ( ) ) ; sheetSettings . setDefaultColumnWidth ( setting . getDefaultColumnWidth ( ) ) ; sheetSettings . setDefaultRowHeight ( setting . getDefaultRowHeight ( ) ) ; sheetSettings . setDisplayZeroValues ( setting . getDisplayZeroValues ( ) ) ; sheetSettings . setFitHeight ( setting . getFitHeight ( ) ) ; sheetSettings . setFitToPages ( setting . getFitToPages ( ) ) ; sheetSettings . setFitWidth ( setting . getFitWidth ( ) ) ; HeaderFooter footer = setting . getFooter ( ) ; if ( footer != null ) { sheetSettings . setFooter ( footer ) ; } sheetSettings . setFooterMargin ( setting . getFooterMargin ( ) ) ; HeaderFooter header = setting . getHeader ( ) ; if ( header != null ) { sheetSettings . setHeader ( header ) ; } sheetSettings . setHeaderMargin ( setting . getHeaderMargin ( ) ) ; sheetSettings . setHidden ( setting . isHidden ( ) ) ; sheetSettings . setHorizontalCentre ( setting . isHorizontalCentre ( ) ) ; sheetSettings . setHorizontalFreeze ( setting . getHorizontalFreeze ( ) ) ; sheetSettings . setHorizontalPrintResolution ( setting . getHorizontalPrintResolution ( ) ) ; sheetSettings . setLeftMargin ( setting . getLeftMargin ( ) ) ; PageOrientation pageOrientation = setting . getOrientation ( ) ; if ( pageOrientation != null ) { sheetSettings . setOrientation ( pageOrientation ) ; } sheetSettings . setPageStart ( setting . getPageStart ( ) ) ; PaperSize paperSize = setting . getPaperSize ( ) ; if ( paperSize != null ) { sheetSettings . setPaperSize ( setting . getPaperSize ( ) ) ; } sheetSettings . setPassword ( setting . getPassword ( ) ) ; sheetSettings . setPasswordHash ( setting . getPasswordHash ( ) ) ; sheetSettings . setPrintGridLines ( setting . getPrintGridLines ( ) ) ; sheetSettings . setPrintHeaders ( setting . getPrintHeaders ( ) ) ; sheetSettings . setProtected ( setting . isProtected ( ) ) ; sheetSettings . setRightMargin ( setting . getRightMargin ( ) ) ; sheetSettings . setScaleFactor ( setting . getScaleFactor ( ) ) ; sheetSettings . setSelected ( setting . isSelected ( ) ) ; sheetSettings . setShowGridLines ( setting . getShowGridLines ( ) ) ; sheetSettings . setTopMargin ( setting . getTopMargin ( ) ) ; sheetSettings . setVerticalCentre ( setting . isVerticalCentre ( ) ) ; sheetSettings . setVerticalFreeze ( setting . getVerticalFreeze ( ) ) ; sheetSettings . setVerticalPrintResolution ( setting . getVerticalPrintResolution ( ) ) ; sheetSettings . setZoomFactor ( setting . getZoomFactor ( ) ) ; return sheet ; }
saki4510t/ExoPlayer | public MediaChunk ( DataSource dataSource , DataSpec dataSpec , Format trackFormat , int trackSelectionReason , Object trackSelectionData , long startTimeUs , long endTimeUs , long chunkIndex ) { super ( dataSource , dataSpec , C . DATA_TYPE_MEDIA , trackFormat , trackSelectionReason , trackSelectionData , startTimeUs , endTimeUs ) ; Assertions . checkNotNull ( trackFormat ) ; this . chunkIndex = chunkIndex ; }
saki4510t/ExoPlayer | public long getNextChunkIndex ( ) { return chunkIndex != C . INDEX_UNSET ? chunkIndex + 1 : C . INDEX_UNSET ; }
dkpro/dkpro-jwktl | @ Override protected void setUp ( ) throws Exception { nounTableHandler = new DEWordFormNounTableHandler ( ) ; genusHandler = new GenusHandler ( nounTableHandler ) ; }
dkpro/dkpro-jwktl | public void testCanHandle ( ) { assertFalse ( genusHandler . canHandle ( null , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Suneg " , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus " , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ " , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ 0" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 1" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 2" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 3" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 4" , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ 4.5" , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ 5" , null , null , null ) ) ; }
dkpro/dkpro-jwktl | public void testGenus ( ) { genusHandler . handle ( " Genus " , " m " , null , null ) ; assertEquals ( DEGenderText . M , nounTableHandler . getGenusByIndex ( 1 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 2 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus1 ( ) { genusHandler . handle ( " Genus ▁ 1" , " n " , null , null ) ; assertEquals ( DEGenderText . N , nounTableHandler . getGenusByIndex ( 1 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 2 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus2 ( ) { genusHandler . handle ( " Genus ▁ 2" , " pl " , null , null ) ; assertNull ( nounTableHandler . getGenusByIndex ( 1 ) ) ; assertEquals ( DEGenderText . PL , nounTableHandler . getGenusByIndex ( 2 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 3 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus3 ( ) { genusHandler . handle ( " Genus ▁ 3" , "0" , null , null ) ; assertNull ( nounTableHandler . getGenusByIndex ( 2 ) ) ; assertEquals ( DEGenderText . _0 , nounTableHandler . getGenusByIndex ( 3 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 4 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus4 ( ) { genusHandler . handle ( " Genus ▁ 4" , " x " , null , null ) ; assertNull ( nounTableHandler . getGenusByIndex ( 3 ) ) ; assertEquals ( DEGenderText . X , nounTableHandler . getGenusByIndex ( 4 ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | public DbContactEmailSensorDao ( DaoConfig config ) { super ( config ) ; }
Telecooperation/assistance-platform-client-sdk-android | public DbContactEmailSensorDao ( DaoConfig config , DaoSession daoSession ) { super ( config , daoSession ) ; this . daoSession = daoSession ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final void bindValues ( DatabaseStatement stmt , DbContactEmailSensor entity ) { stmt . clearBindings ( ) ; Long id = entity . getId ( ) ; if ( id != null ) { stmt . bindLong ( 1 , id ) ; } Long mailId = entity . getMailId ( ) ; if ( mailId != null ) { stmt . bindLong ( 2 , mailId ) ; } String address = entity . getAddress ( ) ; if ( address != null ) { stmt . bindString ( 3 , address ) ; } String type = entity . getType ( ) ; if ( type != null ) { stmt . bindString ( 4 , type ) ; } Boolean isNew = entity . getIsNew ( ) ; if ( isNew != null ) { stmt . bindLong ( 5 , isNew ? 1L : 0L ) ; } Boolean isUpdated = entity . getIsUpdated ( ) ; if ( isUpdated != null ) { stmt . bindLong ( 6 , isUpdated ? 1L : 0L ) ; } Boolean isDeleted = entity . getIsDeleted ( ) ; if ( isDeleted != null ) { stmt . bindLong ( 7 , isDeleted ? 1L : 0L ) ; } stmt . bindString ( 8 , entity . getCreated ( ) ) ; stmt . bindLong ( 9 , entity . getContactId ( ) ) ; stmt . bindLong ( 10 , entity . getDeviceId ( ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final void bindValues ( SQLiteStatement stmt , DbContactEmailSensor entity ) { stmt . clearBindings ( ) ; Long id = entity . getId ( ) ; if ( id != null ) { stmt . bindLong ( 1 , id ) ; } Long mailId = entity . getMailId ( ) ; if ( mailId != null ) { stmt . bindLong ( 2 , mailId ) ; } String address = entity . getAddress ( ) ; if ( address != null ) { stmt . bindString ( 3 , address ) ; } String type = entity . getType ( ) ; if ( type != null ) { stmt . bindString ( 4 , type ) ; } Boolean isNew = entity . getIsNew ( ) ; if ( isNew != null ) { stmt . bindLong ( 5 , isNew ? 1L : 0L ) ; } Boolean isUpdated = entity . getIsUpdated ( ) ; if ( isUpdated != null ) { stmt . bindLong ( 6 , isUpdated ? 1L : 0L ) ; } Boolean isDeleted = entity . getIsDeleted ( ) ; if ( isDeleted != null ) { stmt . bindLong ( 7 , isDeleted ? 1L : 0L ) ; } stmt . bindString ( 8 , entity . getCreated ( ) ) ; stmt . bindLong ( 9 , entity . getContactId ( ) ) ; stmt . bindLong ( 10 , entity . getDeviceId ( ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final void attachEntity ( DbContactEmailSensor entity ) { super . attachEntity ( entity ) ; entity . __setDaoSession ( daoSession ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public Long readKey ( Cursor cursor , int offset ) { return cursor . isNull ( offset + 0 ) ? null : cursor . getLong ( offset + 0 ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public DbContactEmailSensor readEntity ( Cursor cursor , int offset ) { DbContactEmailSensor entity = new DbContactEmailSensor ( cursor . isNull ( offset + 0 ) ? null : cursor . getLong ( offset + 0 ) , cursor . isNull ( offset + 1 ) ? null : cursor . getLong ( offset + 1 ) , cursor . isNull ( offset + 2 ) ? null : cursor . getString ( offset + 2 ) , cursor . isNull ( offset + 3 ) ? null : cursor . getString ( offset + 3 ) , cursor . isNull ( offset + 4 ) ? null : cursor . getShort ( offset + 4 ) != 0 , cursor . isNull ( offset + 5 ) ? null : cursor . getShort ( offset + 5 ) != 0 , cursor . isNull ( offset + 6 ) ? null : cursor . getShort ( offset + 6 ) != 0 , cursor . getString ( offset + 7 ) , cursor . getLong ( offset + 8 ) , cursor . getLong ( offset + 9 ) ) ; return entity ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public void readEntity ( Cursor cursor , DbContactEmailSensor entity , int offset ) { entity . setId ( cursor . isNull ( offset + 0 ) ? null : cursor . getLong ( offset + 0 ) ) ; entity . setMailId ( cursor . isNull ( offset + 1 ) ? null : cursor . getLong ( offset + 1 ) ) ; entity . setAddress ( cursor . isNull ( offset + 2 ) ? null : cursor . getString ( offset + 2 ) ) ; entity . setType ( cursor . isNull ( offset + 3 ) ? null : cursor . getString ( offset + 3 ) ) ; entity . setIsNew ( cursor . isNull ( offset + 4 ) ? null : cursor . getShort ( offset + 4 ) != 0 ) ; entity . setIsUpdated ( cursor . isNull ( offset + 5 ) ? null : cursor . getShort ( offset + 5 ) != 0 ) ; entity . setIsDeleted ( cursor . isNull ( offset + 6 ) ? null : cursor . getShort ( offset + 6 ) != 0 ) ; entity . setCreated ( cursor . getString ( offset + 7 ) ) ; entity . setContactId ( cursor . getLong ( offset + 8 ) ) ; entity . setDeviceId ( cursor . getLong ( offset + 9 ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final Long updateKeyAfterInsert ( DbContactEmailSensor entity , long rowId ) { entity . setId ( rowId ) ; return rowId ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public Long getKey ( DbContactEmailSensor entity ) { if ( entity != null ) { return entity . getId ( ) ; } else { return null ; } }
Telecooperation/assistance-platform-client-sdk-android | @ Override public boolean hasKey ( DbContactEmailSensor entity ) { return entity . getId ( ) != null ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final boolean isEntityUpdateable ( ) { return true ; }
Telecooperation/assistance-platform-client-sdk-android | public List < DbContactEmailSensor > _queryDbContactSensor_DbContactEmailSensorList ( long contactId ) { synchronized ( this ) { if ( dbContactSensor_DbContactEmailSensorListQuery == null ) { QueryBuilder < DbContactEmailSensor > queryBuilder = queryBuilder ( ) ; queryBuilder . where ( Properties . ContactId . eq ( null ) ) ; dbContactSensor_DbContactEmailSensorListQuery = queryBuilder . build ( ) ; } } Query < DbContactEmailSensor > query = dbContactSensor_DbContactEmailSensorListQuery . forCurrentThread ( ) ; query . setParameter ( 0 , contactId ) ; return query . list ( ) ; }
Telecooperation/assistance-platform-client-sdk-android | protected String getSelectDeep ( ) { if ( selectDeep == null ) { StringBuilder builder = new StringBuilder ( " SELECT ▁ " ) ; SqlUtils . appendColumns ( builder , " T " , getAllColumns ( ) ) ; builder . append ( ' , ' ) ; SqlUtils . appendColumns ( builder , " T0" , daoSession . getDbContactSensorDao ( ) . getAllColumns ( ) ) ; builder . append ( ' , ' ) ; SqlUtils . appendColumns ( builder , " T1" , daoSession . getDbDeviceDao ( ) . getAllColumns ( ) ) ; builder . append ( " ▁ FROM ▁ contact _ email _ sensor ▁ T " ) ; builder . append ( " ▁ LEFT ▁ JOIN ▁ contact _ sensor ▁ T0 ▁ ON ▁ T . \" CONTACT _ ID \" = T0 . \" _ id \" " ) ; builder . append ( " ▁ LEFT ▁ JOIN ▁ device ▁ T1 ▁ ON ▁ T . \" DEVICE _ ID \" = T1 . \" _ id \" " ) ; builder . append ( ' ▁ ' ) ; selectDeep = builder . toString ( ) ; } return selectDeep ; }
Telecooperation/assistance-platform-client-sdk-android | protected DbContactEmailSensor loadCurrentDeep ( Cursor cursor , boolean lock ) { DbContactEmailSensor entity = loadCurrent ( cursor , 0 , lock ) ; int offset = getAllColumns ( ) . length ; DbContactSensor dbContactSensor = loadCurrentOther ( daoSession . getDbContactSensorDao ( ) , cursor , offset ) ; if ( dbContactSensor != null ) { entity . setDbContactSensor ( dbContactSensor ) ; } offset += daoSession . getDbContactSensorDao ( ) . getAllColumns ( ) . length ; DbDevice dbDevice = loadCurrentOther ( daoSession . getDbDeviceDao ( ) , cursor , offset ) ; if ( dbDevice != null ) { entity . setDbDevice ( dbDevice ) ; } return entity ; }
Telecooperation/assistance-platform-client-sdk-android | public DbContactEmailSensor loadDeep ( Long key ) { assertSinglePk ( ) ; if ( key == null ) { return null ; } StringBuilder builder = new StringBuilder ( getSelectDeep ( ) ) ; builder . append ( " WHERE ▁ " ) ; SqlUtils . appendColumnsEqValue ( builder , " T " , getPkColumns ( ) ) ; String sql = builder . toString ( ) ; String [ ] keyArray = new String [ ] { key . toString ( ) } ; Cursor cursor = db . rawQuery ( sql , keyArray ) ; try { boolean available = cursor . moveToFirst ( ) ; if ( ! available ) { return null ; } else if ( ! cursor . isLast ( ) ) { throw new IllegalStateException ( " Expected ▁ unique ▁ result , ▁ but ▁ count ▁ was ▁ " + cursor . getCount ( ) ) ; } return loadCurrentDeep ( cursor , true ) ; } finally { cursor . close ( ) ; } }
Telecooperation/assistance-platform-client-sdk-android | public List < DbContactEmailSensor > loadAllDeepFromCursor ( Cursor cursor ) { int count = cursor . getCount ( ) ; List < DbContactEmailSensor > list = new ArrayList < DbContactEmailSensor > ( count ) ; if ( cursor . moveToFirst ( ) ) { if ( identityScope != null ) { identityScope . lock ( ) ; identityScope . reserveRoom ( count ) ; } try { do { list . add ( loadCurrentDeep ( cursor , false ) ) ; } while ( cursor . moveToNext ( ) ) ; } finally { if ( identityScope != null ) { identityScope . unlock ( ) ; } } } return list ; }
Telecooperation/assistance-platform-client-sdk-android | protected List < DbContactEmailSensor > loadDeepAllAndCloseCursor ( Cursor cursor ) { try { return loadAllDeepFromCursor ( cursor ) ; } finally { cursor . close ( ) ; } }
Telecooperation/assistance-platform-client-sdk-android | public List < DbContactEmailSensor > queryDeep ( String where , String ... selectionArg ) { Cursor cursor = db . rawQuery ( getSelectDeep ( ) + where , selectionArg ) ; return loadDeepAllAndCloseCursor ( cursor ) ; }
Log10Solutions/querydsl | private Document createDocument ( ) { Document doc = new Document ( ) ; doc . add ( new Field ( " title " , new StringReader ( " Jurassic ▁ Park " ) ) ) ; doc . add ( new Field ( " author " , new StringReader ( " Michael ▁ Crichton " ) ) ) ; doc . add ( new Field ( " text " , new StringReader ( " It ' s ▁ a ▁ UNIX ▁ system ! ▁ I ▁ know ▁ this ! " ) ) ) ; doc . add ( new Field ( " rating " , new StringReader ( " Good " ) ) ) ; doc . add ( new Field ( " publisher " , " " , Store . YES , Index . ANALYZED ) ) ; doc . add ( new IntField ( " year " , 1990 , Store . YES ) ) ; doc . add ( new DoubleField ( " gross " , 900.0 , Store . YES ) ) ; doc . add ( new LongField ( " longField " , 1 , Store . YES ) ) ; doc . add ( new IntField ( " shortField " , 1 , Store . YES ) ) ; doc . add ( new IntField ( " byteField " , 1 , Store . YES ) ) ; doc . add ( new FloatField ( " floatField " , 1 , Store . YES ) ) ; return doc ; }
Log10Solutions/querydsl | @ Before public void setUp ( ) throws Exception { serializer = new LuceneSerializer ( true , true ) ; entityPath = new PathBuilder < Object > ( Object . class , " obj " ) ; title = entityPath . getString ( " title " ) ; author = entityPath . getString ( " author " ) ; text = entityPath . getString ( " text " ) ; publisher = entityPath . getString ( " publisher " ) ; year = entityPath . getNumber ( " year " , Integer . class ) ; rating = entityPath . getString ( " rating " ) ; gross = entityPath . getNumber ( " gross " , Double . class ) ; titles = entityPath . getCollection ( " title " , String . class , StringPath . class ) ; longField = entityPath . getNumber ( " longField " , Long . class ) ; shortField = entityPath . getNumber ( " shortField " , Short . class ) ; byteField = entityPath . getNumber ( " byteField " , Byte . class ) ; floatField = entityPath . getNumber ( " floatField " , Float . class ) ; idx = new RAMDirectory ( ) ; config = new IndexWriterConfig ( Version . LUCENE_42 , new StandardAnalyzer ( Version . LUCENE_42 ) ) . setOpenMode ( IndexWriterConfig . OpenMode . CREATE ) ; writer = new IndexWriter ( idx , config ) ; writer . addDocument ( createDocument ( ) ) ; writer . close ( ) ; IndexReader reader = IndexReader . open ( idx ) ; searcher = new IndexSearcher ( reader ) ; }
Log10Solutions/querydsl | @ After public void tearDown ( ) throws Exception { searcher . getIndexReader ( ) . close ( ) ; }
Log10Solutions/querydsl | private void testQuery ( Expression < ? > expr , int expectedHits ) throws Exception { Query query = serializer . toQuery ( expr , metadata ) ; TopDocs docs = searcher . search ( query , 100 ) ; assertEquals ( expectedHits , docs . totalHits ) ; }
Log10Solutions/querydsl | private void testQuery ( Expression < ? > expr , String expectedQuery , int expectedHits ) throws Exception { Query query = serializer . toQuery ( expr , metadata ) ; TopDocs docs = searcher . search ( query , 100 ) ; assertEquals ( expectedHits , docs . totalHits ) ; assertEquals ( expectedQuery , query . toString ( ) ) ; }
Log10Solutions/querydsl | @ Test public void QueryElement ( ) throws Exception { Query query1 = serializer . toQuery ( author . like ( " Michael " ) , metadata ) ; Query query2 = serializer . toQuery ( text . like ( " Text " ) , metadata ) ; BooleanExpression query = Expressions . anyOf ( new QueryElement ( query1 ) , new QueryElement ( query2 ) ) ; testQuery ( query , " author : michael ▁ text : text " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like ( ) throws Exception { testQuery ( author . like ( " * ichael * " ) , " author : * ichael * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Custom_Wildcard_Single_Character ( ) throws Exception { testQuery ( author . like ( " Mi ? hael " ) , " author : mi ? hael " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Custom_Wildcard_Multiple_Character ( ) throws Exception { testQuery ( text . like ( " * U * X * " ) , " text : * u * x * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Phrase ( ) throws Exception { testQuery ( title . like ( " * rassic ▁ Par * " ) , " + title : * * rassic * ▁ + title : * par * * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_or_like ( ) throws Exception { testQuery ( title . like ( " House " ) . or ( author . like ( " * ichae * " ) ) , " title : house ▁ author : * ichae * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_and_like ( ) throws Exception { testQuery ( title . like ( " * assic * " ) . and ( rating . like ( " G ? od " ) ) , " + title : * assic * ▁ + rating : g ? od " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq ( ) throws Exception { testQuery ( rating . eq ( " good " ) , " rating : good " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_with_deep_path ( ) throws Exception { StringPath deepPath = entityPath . get ( " property1" , Object . class ) . getString ( " property2" ) ; testQuery ( deepPath . eq ( " good " ) , " property1 . property2 : good " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void FuzzyLike ( ) throws Exception { testQuery ( LuceneExpressions . fuzzyLike ( rating , " Good " ) , " rating : Good ~ 2" , 1 ) ; }
Log10Solutions/querydsl | @ Test public void FuzzyLike_with_Similarity ( ) throws Exception { testQuery ( LuceneExpressions . fuzzyLike ( rating , " Good " , 2 ) , " rating : Good ~ 2" , 1 ) ; }
Log10Solutions/querydsl | @ Test public void FuzzyLike_with_Similarity_and_prefix ( ) throws Exception { testQuery ( LuceneExpressions . fuzzyLike ( rating , " Good " , 2 , 0 ) , " rating : Good ~ 2" , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_Numeric_Integer ( ) throws Exception { testQuery ( year . eq ( 1990 ) , " year : " + YEAR_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_Numeric_Double ( ) throws Exception { testQuery ( gross . eq ( 900.00 ) , " gross : " + GROSS_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_Numeric ( ) throws Exception { testQuery ( longField . eq ( 1L ) , " longField : " + LONG_PREFIX_CODED , 1 ) ; testQuery ( shortField . eq ( ( short ) 1 ) , " shortField : " + SHORT_PREFIX_CODED , 1 ) ; testQuery ( byteField . eq ( ( byte ) 1 ) , " byteField : " + BYTE_PREFIX_CODED , 1 ) ; testQuery ( floatField . eq ( ( float ) 1.0 ) , " floatField : " + FLOAT_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Equals_Ignores_Case ( ) throws Exception { testQuery ( title . eq ( " Jurassic " ) , " title : jurassic " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Title_Equals_Ignore_Case_Or_Year_Equals ( ) throws Exception { testQuery ( title . equalsIgnoreCase ( " House " ) . or ( year . eq ( 1990 ) ) , " title : house ▁ year : " + YEAR_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_and_eq ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) . and ( year . eq ( 1990 ) ) , " + title : \" jurassic ▁ park \" ▁ + year : " + YEAR_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_and_Eq_and_eq ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) . and ( year . eq ( 1990 ) ) . and ( author . eq ( " Michael ▁ Crichton " ) ) , " + ( + title : \" jurassic ▁ park \" ▁ + year : " + YEAR_PREFIX_CODED + " ) ▁ + author : \" michael ▁ crichton \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Equals_Ignore_Case_And_Or ( ) throws Exception { testQuery ( title . equalsIgnoreCase ( " Jurassic ▁ Park " ) . and ( rating . equalsIgnoreCase ( " Bad " ) ) . or ( author . equalsIgnoreCase ( " Michael ▁ Crichton " ) ) , " ( + title : \" jurassic ▁ park \" ▁ + rating : bad ) ▁ author : \" michael ▁ crichton \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_or_Eq_and_Eq_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . eq ( " jeeves " ) . or ( rating . eq ( " superb " ) ) . and ( author . eq ( " michael ▁ crichton " ) ) , " + ( title : jeeves ▁ rating : superb ) ▁ + author : \" michael ▁ crichton \" " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_Phrase ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) , " title : \" jurassic ▁ park \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore ( " Not ▁ easily ▁ done ▁ in ▁ Lucene ! " ) public void Publisher_Equals_Empty_String ( ) throws Exception { testQuery ( publisher . eq ( " " ) , " publisher : " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_Phrase_Should_Not_Find_Results_But_LuceNe_Semantics_Differs_From_Querydsls ( ) throws Exception { testQuery ( text . eq ( " UNIX ▁ System " ) , " text : \" unix ▁ system \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_Phrase_Does_Not_Find_Results_Because_Word_In_Middle ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Amusement ▁ Park " ) , " title : \" jurassic ▁ amusement ▁ park \" " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Like_not_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . like ( " * H * e * " ) . not ( ) , " - title : * h * e * ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Title_Equals_Ignore_Case_Negation_Or_Rating_Equals_Ignore_Case ( ) throws Exception { testQuery ( title . equalsIgnoreCase ( " House " ) . not ( ) . or ( rating . equalsIgnoreCase ( " Good " ) ) , " - title : house ▁ rating : good " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_not_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) . not ( ) , " - title : \" jurassic ▁ park \" ▁ + * : * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Title_Equals_Not_House ( ) throws Exception { testQuery ( title . eq ( " house " ) . not ( ) , " - title : house ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_and_Eq_not_Does_Not_Find_Results_Because_Second_Expression_Finds_Nothing ( ) throws Exception { testQuery ( rating . eq ( " superb " ) . and ( title . eq ( " house " ) . not ( ) ) , " + rating : superb ▁ + ( - title : house ▁ + * : * ) " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Not_Equals_Finds_One ( ) throws Exception { testQuery ( title . ne ( " house " ) , " - title : house ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Not_Equals_Finds_None ( ) throws Exception { testQuery ( title . ne ( " Jurassic ▁ Park " ) , " - title : \" jurassic ▁ park \" ▁ + * : * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Nothing_Found_With_Not_Equals_Or_Equals ( ) throws Exception { testQuery ( title . ne ( " jurassic ▁ park " ) . or ( rating . eq ( " lousy " ) ) , " ( - title : \" jurassic ▁ park \" ▁ + * : * ) ▁ rating : lousy " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Ne_and_eq ( ) throws Exception { testQuery ( title . ne ( " house " ) . and ( rating . eq ( " good " ) ) , " + ( - title : house ▁ + * : * ) ▁ + rating : good " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void StartsWith ( ) throws Exception { testQuery ( title . startsWith ( " Jurassi " ) , " title : jurassi * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void StartsWith_Phrase ( ) throws Exception { testQuery ( title . startsWith ( " jurassic ▁ par " ) , " + title : jurassic * ▁ + title : * par * " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Starts_With_Ignore_Case_Phrase_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . startsWithIgnoreCase ( " urassic ▁ Par " ) , " + title : urassic * ▁ + title : * par * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void EndsWith ( ) throws Exception { testQuery ( title . endsWith ( " ark " ) , " title : * ark " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Ends_With_Ignore_Case_Phrase ( ) throws Exception { testQuery ( title . endsWithIgnoreCase ( " sic ▁ Park " ) , " + title : * sic * ▁ + title : * park " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Ends_With_Ignore_Case_Phrase_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . endsWithIgnoreCase ( " sic ▁ Par " ) , " + title : * sic * ▁ + title : * par " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Contains ( ) throws Exception { testQuery ( title . contains ( " rassi " ) , " title : * rassi * " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Contains_Ignore_Case_Phrase ( ) throws Exception { testQuery ( title . containsIgnoreCase ( " rassi ▁ Pa " ) , " + title : * rassi * ▁ + title : * pa * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Contains_User_Inputted_Wildcards_Dont_Work ( ) throws Exception { testQuery ( title . contains ( " r * i " ) , " title : * r \\ * i * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Between ( ) throws Exception { testQuery ( title . between ( " Indiana " , " Kundun " ) , " title : [ indiana ▁ TO ▁ kundun ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Numeric_Integer ( ) throws Exception { testQuery ( year . between ( 1980 , 2000 ) , " year : [1980 ▁ TO ▁ 2000 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Numeric_Double ( ) throws Exception { testQuery ( gross . between ( 10.00 , 19030.00 ) , " gross : [10.0 ▁ TO ▁ 19030.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Numeric ( ) throws Exception { testQuery ( longField . between ( 0L , 2L ) , " longField : [0 ▁ TO ▁ 2 ] " , 1 ) ; testQuery ( shortField . between ( ( short ) 0 , ( short ) 2 ) , " shortField : [0 ▁ TO ▁ 2 ] " , 1 ) ; testQuery ( byteField . between ( ( byte ) 0 , ( byte ) 2 ) , " byteField : [0 ▁ TO ▁ 2 ] " , 1 ) ; testQuery ( floatField . between ( ( float ) 0.0 , ( float ) 2.0 ) , " floatField : [0.0 ▁ TO ▁ 2.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Is_Inclusive_From_Start ( ) throws Exception { testQuery ( title . between ( " Jurassic " , " Kundun " ) , " title : [ jurassic ▁ TO ▁ kundun ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Is_Inclusive_To_End ( ) throws Exception { testQuery ( title . between ( " Indiana " , " Jurassic " ) , " title : [ indiana ▁ TO ▁ jurassic ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . between ( " Indiana " , " Jurassib " ) , " title : [ indiana ▁ TO ▁ jurassib ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void In ( ) throws Exception { testQuery ( title . in ( Arrays . asList ( " jurassic " , " park " ) ) , " title : jurassic ▁ title : park " , 1 ) ; testQuery ( title . in ( " jurassic " , " park " ) , " title : jurassic ▁ title : park " , 1 ) ; testQuery ( title . eq ( " jurassic " ) . or ( title . eq ( " park " ) ) , " title : jurassic ▁ title : park " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt ( ) throws Exception { testQuery ( rating . lt ( " Superb " ) , " rating : { * ▁ TO ▁ superb } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Integer ( ) throws Exception { testQuery ( year . lt ( 1991 ) , " year : { * ▁ TO ▁ 1991 } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Double ( ) throws Exception { testQuery ( gross . lt ( 10000.0 ) , " gross : { * ▁ TO ▁ 10000.0 } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( rating . lt ( " Good " ) , " rating : { * ▁ TO ▁ good } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Integer_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( year . lt ( 1990 ) , " year : { * ▁ TO ▁ 1990 } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Double_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( gross . lt ( 900.0 ) , " gross : { * ▁ TO ▁ 900.0 } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Loe ( ) throws Exception { testQuery ( rating . loe ( " Superb " ) , " rating : [ * ▁ TO ▁ superb ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Integer ( ) throws Exception { testQuery ( year . loe ( 1991 ) , " year : [ * ▁ TO ▁ 1991 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Double ( ) throws Exception { testQuery ( gross . loe ( 903.0 ) , " gross : [ * ▁ TO ▁ 903.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Equal ( ) throws Exception { testQuery ( rating . loe ( " Good " ) , " rating : [ * ▁ TO ▁ good ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Integer_Equal ( ) throws Exception { testQuery ( year . loe ( 1990 ) , " year : [ * ▁ TO ▁ 1990 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Double_Equal ( ) throws Exception { testQuery ( gross . loe ( 900.0 ) , " gross : [ * ▁ TO ▁ 900.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Not_Found ( ) throws Exception { testQuery ( rating . loe ( " Bad " ) , " rating : [ * ▁ TO ▁ bad ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Integer_Not_Found ( ) throws Exception { testQuery ( year . loe ( 1989 ) , " year : [ * ▁ TO ▁ 1989 ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Double_Not_Found ( ) throws Exception { testQuery ( gross . loe ( 899.9 ) , " gross : [ * ▁ TO ▁ 899.9 ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Gt ( ) throws Exception { testQuery ( rating . gt ( " Bad " ) , " rating : { bad ▁ TO ▁ * } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Integer ( ) throws Exception { testQuery ( year . gt ( 1989 ) , " year : { 1989 ▁ TO ▁ * } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Double ( ) throws Exception { testQuery ( gross . gt ( 100.00 ) , " gross : { 100.0 ▁ TO ▁ * } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( rating . gt ( " Good " ) , " rating : { good ▁ TO ▁ * } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Integer_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( year . gt ( 1990 ) , " year : { 1990 ▁ TO ▁ * } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Double_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( gross . gt ( 900.00 ) , " gross : { 900.0 ▁ TO ▁ * } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Goe ( ) throws Exception { testQuery ( rating . goe ( " Bad " ) , " rating : [ bad ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Integer ( ) throws Exception { testQuery ( year . goe ( 1989 ) , " year : [1989 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Double ( ) throws Exception { testQuery ( gross . goe ( 320.50 ) , " gross : [320.5 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Equal ( ) throws Exception { testQuery ( rating . goe ( " Good " ) , " rating : [ good ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Integer_Equal ( ) throws Exception { testQuery ( year . goe ( 1990 ) , " year : [1990 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Double_Equal ( ) throws Exception { testQuery ( gross . goe ( 900.00 ) , " gross : [900.0 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Not_Found ( ) throws Exception { testQuery ( rating . goe ( " Hood " ) , " rating : [ hood ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Integer_Not_Found ( ) throws Exception { testQuery ( year . goe ( 1991 ) , " year : [1991 ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Double_Not_Found ( ) throws Exception { testQuery ( gross . goe ( 900.10 ) , " gross : [900.1 ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Equals_Empty_String ( ) throws Exception { testQuery ( title . eq ( " " ) , " title : " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Not_Equals_Empty_String ( ) throws Exception { testQuery ( title . ne ( " " ) , " - title : ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Contains_Empty_String ( ) throws Exception { testQuery ( title . contains ( " " ) , " title : * * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Empty_String ( ) throws Exception { testQuery ( title . like ( " " ) , " title : " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Starts_With_Empty_String ( ) throws Exception { testQuery ( title . startsWith ( " " ) , " title : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Ends_With_Empty_String ( ) throws Exception { testQuery ( title . endsWith ( " " ) , " title : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Empty_Strings ( ) throws Exception { testQuery ( title . between ( " " , " " ) , " title : [ ▁ TO ▁ ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void BooleanBuilder ( ) throws Exception { testQuery ( new BooleanBuilder ( gross . goe ( 900.10 ) ) , " gross : [900.1 ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Fuzzy ( ) throws Exception { fail ( " Not ▁ yet ▁ implemented ! " ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Proximity ( ) throws Exception { fail ( " Not ▁ yet ▁ implemented ! " ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Boost ( ) throws Exception { fail ( " Not ▁ yet ▁ implemented ! " ) ; }
Log10Solutions/querydsl | @ Test public void PathAny ( ) throws Exception { testQuery ( titles . any ( ) . eq ( " Jurassic " ) , " title : jurassic " , 1 ) ; }
Log10Solutions/querydsl | private boolean unsupportedOperation ( Predicate filter ) { if ( filter instanceof Operation < ? > ) { Operator op = ( ( Operation < ? > ) filter ) . getOperator ( ) ; if ( op == Ops . STARTS_WITH_IC || op == Ops . EQ_IGNORE_CASE || op == Ops . STARTS_WITH_IC || op == Ops . ENDS_WITH_IC || op == Ops . STRING_CONTAINS_IC ) { return true ; } } return false ; }
Log10Solutions/querydsl | @ Test public void various ( ) throws Exception { MatchingFiltersFactory filters = new MatchingFiltersFactory ( Module . LUCENE , Target . LUCENE ) ; for ( Predicate filter : filters . string ( title , StringConstant . create ( " jurassic ▁ park " ) ) ) { if ( unsupportedOperation ( filter ) ) { continue ; } testQuery ( filter , 1 ) ; } for ( Predicate filter : filters . string ( author , StringConstant . create ( " michael ▁ crichton " ) ) ) { if ( unsupportedOperation ( filter ) ) { continue ; } testQuery ( filter , 1 ) ; } for ( Predicate filter : filters . string ( title , StringConstant . create ( "1990" ) ) ) { if ( unsupportedOperation ( filter ) ) { continue ; } testQuery ( filter , 0 ) ; } }
BottleRocketStudios/Android-Vault | public ApplicationTest ( ) { super ( Application . class ) ; }
xabikip/CursoAndroid | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; inicializar ( ) ; }
xabikip/CursoAndroid | private void inicializar ( ) { bEmpezar = ( Button ) findViewById ( R . id . empezar ) ; bEmpezar . setOnClickListener ( this ) ; tvTurno = ( TextView ) findViewById ( R . id . turno ) ; resultA = ( TextView ) findViewById ( R . id . resultA ) ; resultB = ( TextView ) findViewById ( R . id . resultB ) ; resultados = ( TextView ) findViewById ( R . id . resultados ) ; b1 = ( Button ) findViewById ( R . id . b1 ) ; b1 . setOnClickListener ( this ) ; b2 = ( Button ) findViewById ( R . id . b2 ) ; b2 . setOnClickListener ( this ) ; b3 = ( Button ) findViewById ( R . id . b3 ) ; b3 . setOnClickListener ( this ) ; b4 = ( Button ) findViewById ( R . id . b4 ) ; b4 . setOnClickListener ( this ) ; b5 = ( Button ) findViewById ( R . id . b5 ) ; b5 . setOnClickListener ( this ) ; b6 = ( Button ) findViewById ( R . id . b6 ) ; b6 . setOnClickListener ( this ) ; b7 = ( Button ) findViewById ( R . id . b7 ) ; b7 . setOnClickListener ( this ) ; b8 = ( Button ) findViewById ( R . id . b8 ) ; b8 . setOnClickListener ( this ) ; b9 = ( Button ) findViewById ( R . id . b9 ) ; b9 . setOnClickListener ( this ) ; }
xabikip/CursoAndroid | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . main , menu ) ; return true ; }
xabikip/CursoAndroid | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . action_settings ) { return true ; } return super . onOptionsItemSelected ( item ) ; }
xabikip/CursoAndroid | @ Override public void onClick ( View v ) { if ( v . getId ( ) == R . id . empezar && bEmpezar . getText ( ) . toString ( ) . equals ( " Empezar " ) ) { this . a = 0 ; this . b = 0 ; habilitarBotones ( true ) ; bEmpezar . setText ( " Salir " ) ; this . judador = " x " ; tvTurno . setText ( " Turno ▁ del ▁ jugador : ▁ x " ) ; borrarCampos ( ) ; this . cont = 0 ; } else if ( v . getId ( ) == R . id . empezar && bEmpezar . getText ( ) . toString ( ) . equals ( " Salir " ) ) { borrarCampos ( ) ; bEmpezar . setText ( " Empezar " ) ; habilitarBotones ( false ) ; } else if ( v . getId ( ) == R . id . b1 ) { escribirJugada ( this . judador , b1 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b2 ) { escribirJugada ( this . judador , b2 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b3 ) { escribirJugada ( this . judador , b3 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b4 ) { escribirJugada ( this . judador , b4 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b5 ) { escribirJugada ( this . judador , b5 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b6 ) { escribirJugada ( this . judador , b6 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b7 ) { escribirJugada ( this . judador , b7 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b8 ) { escribirJugada ( this . judador , b8 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b9 ) { escribirJugada ( this . judador , b9 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } }
xabikip/CursoAndroid | private void comprobarGanador ( ) { if ( b1 . getText ( ) . toString ( ) . equals ( this . judador ) && b2 . getText ( ) . toString ( ) . equals ( this . judador ) && b3 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b4 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b6 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b7 . getText ( ) . toString ( ) . equals ( this . judador ) && b8 . getText ( ) . toString ( ) . equals ( this . judador ) && b9 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b1 . getText ( ) . toString ( ) . equals ( this . judador ) && b4 . getText ( ) . toString ( ) . equals ( this . judador ) && b7 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b2 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b8 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b3 . getText ( ) . toString ( ) . equals ( this . judador ) && b6 . getText ( ) . toString ( ) . equals ( this . judador ) && b9 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b1 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b9 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b3 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b7 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( this . cont == 9 ) { Toast toast = Toast . makeText ( this , " Habeis ▁ empatado " , Toast . LENGTH_SHORT ) ; toast . show ( ) ; habilitarBotones ( false ) ; bEmpezar . setText ( " Empezar " ) ; } }
xabikip/CursoAndroid | private void ganado ( ) { java . util . Date today = new java . util . Date ( ) ; this . hoy = today . toString ( ) ; DBHelper dbHelper = new DBHelper ( this , " TRESENRAYADB " , null , 1 ) ; SQLiteDatabase tresDBWrite = dbHelper . getWritableDatabase ( ) ; if ( tresDBWrite . isOpen ( ) ) { tresDBWrite . execSQL ( " INSERT ▁ INTO ▁ resultado ▁ ( FECHA , ▁ GANADOR ) ▁ VALUES ▁ ( ' " + this . hoy + " ' , ' " + this . judador + " ' ) " ) ; tresDBWrite . close ( ) ; } Toast toast = Toast . makeText ( this , " Has ▁ ganado ▁ " + this . judador , Toast . LENGTH_SHORT ) ; toast . show ( ) ; habilitarBotones ( false ) ; bEmpezar . setText ( " Empezar " ) ; String [ ] campos = new String [ ] { " FECHA " , " GANADOR " } ; SQLiteDatabase tresDBRead = dbHelper . getReadableDatabase ( ) ; if ( tresDBRead . isOpen ( ) ) { Cursor c = tresDBRead . query ( " RESULTADO " , campos , null , null , null , null , " _ ID " ) ; if ( c . moveToFirst ( ) ) { do { if ( c . getString ( c . getColumnIndex ( " GANADOR " ) ) . equals ( "0" ) ) { a ++ ; } else if ( c . getString ( c . getColumnIndex ( " GANADOR " ) ) . equals ( " x " ) ) { b ++ ; } } while ( c . moveToNext ( ) ) ; } tresDBRead . close ( ) ; } resultados . setText ( " RESULTADOS : " ) ; resultA . setText ( " Jugador ▁ 0 ▁ ganados = ▁ " + a ) ; resultB . setText ( " Jugador ▁ X ▁ ganados = ▁ " + b ) ; }
xabikip/CursoAndroid | private void cambiarJugador ( ) { if ( this . judador . toString ( ) . equals ( " x " ) ) { this . judador = "0" ; tvTurno . setText ( " Turno ▁ del ▁ jugador : ▁ 0" ) ; } else { this . judador = " x " ; tvTurno . setText ( " Turno ▁ del ▁ jugador : ▁ x " ) ; } }
xabikip/CursoAndroid | private void escribirJugada ( String jugador , Button boton ) { boton . setText ( jugador ) ; boton . setEnabled ( false ) ; this . cont ++ ; }
xabikip/CursoAndroid | private void borrarCampos ( ) { b1 . setText ( " " ) ; b2 . setText ( " " ) ; b3 . setText ( " " ) ; b4 . setText ( " " ) ; b5 . setText ( " " ) ; b6 . setText ( " " ) ; b7 . setText ( " " ) ; b8 . setText ( " " ) ; b9 . setText ( " " ) ; }
xabikip/CursoAndroid | void habilitarBotones ( boolean estado ) { b1 . setEnabled ( estado ) ; b2 . setEnabled ( estado ) ; b3 . setEnabled ( estado ) ; b4 . setEnabled ( estado ) ; b5 . setEnabled ( estado ) ; b6 . setEnabled ( estado ) ; b7 . setEnabled ( estado ) ; b8 . setEnabled ( estado ) ; b9 . setEnabled ( estado ) ; }
valegrajales/recommendation_systems_lab1 | @ Override public float predictRating ( int user , int item ) { return Float . NaN ; }
valegrajales/recommendation_systems_lab1 | public float predictRatingBPR ( int user , int item ) { int itemidx = data . itemIndices . get ( item ) ; Integer useridx = data . userIndices . get ( user ) ; if ( useridx != null ) { return ( float ) ( data . item_bias [ itemidx ] + data . rowScalarProduct ( useridx , itemidx ) ) ; } else { return Float . NaN ; } }
valegrajales/recommendation_systems_lab1 | public List < Integer > recommendByPrediction ( int user ) { List < Integer > result = new ArrayList < Integer > ( ) ; Set < Rating > ratings = getDataModel ( ) . getRatingsOfUser ( user ) ; if ( ratings == null || ratings . size ( ) == 0 ) { return Collections . emptyList ( ) ; } Map < Integer , Float > predictions = new HashMap < Integer , Float > ( ) ; float pred = Float . NaN ; for ( Integer item : dataModel . getItems ( ) ) { boolean userHasAlreadyRatedItem = false ; if ( getDataModel ( ) . originalTrainingPerUser . keySet ( ) . size ( ) > 0 ) { Set < Rating > originalRatings = getDataModel ( ) . originalTrainingPerUser . get ( user ) ; if ( originalRatings != null && Utilities101 . ratingExists ( user , item , originalRatings ) ) { userHasAlreadyRatedItem = true ; } } else { byte rating = dataModel . getRating ( user , item ) ; if ( rating != - 1 ) { userHasAlreadyRatedItem = true ; } } if ( ! userHasAlreadyRatedItem ) { pred = predictRatingBPR ( user , item ) ; if ( ! Float . isNaN ( pred ) ) { predictions . put ( item , pred ) ; } } } predictions = filterElementsByRelevanceThreshold ( predictions , user ) ; predictions = Utilities101 . sortByValueDescending ( predictions ) ; for ( Integer item : predictions . keySet ( ) ) { result . add ( item ) ; } return result ; }
valegrajales/recommendation_systems_lab1 | @ Override public List < Integer > recommendItems ( int user ) { return recommendByPrediction ( user ) ; }
valegrajales/recommendation_systems_lab1 | @ Override public void init ( ) { numItems = dataModel . getItems ( ) . size ( ) ; numUsers = dataModel . getUsers ( ) . size ( ) ; data . init ( dataModel , numUsers , numItems , numFeatures ) ; train ( ) ; System . out . println ( " BPR + + ▁ training ▁ DONE " ) ; Debug . log ( " BPRMF : init : ▁ Initial ▁ training ▁ done " ) ; }
valegrajales/recommendation_systems_lab1 | public void train ( ) { for ( int i = 0 ; i < initialSteps ; i ++ ) { if ( i % 10 == 0 ) System . out . println ( " Processed ▁ " + i + " ▁ of ▁ " + initialSteps + " ▁ BPR + + ▁ training ▁ steps . " ) ; iterate ( ) ; } }
valegrajales/recommendation_systems_lab1 | public void iterate ( ) { int num_pos_events = data . numPosentries ; int user_id , pos_item_id , neg_item_id , initial_item_id , xscale ; if ( UniformUserSampling ) { if ( SequentialLearning ) { if ( useIIMaps ) { for ( int f = 0 ; f < data . featureMatrixArray . length ; f ++ ) { SparseMatrix matrix = data . featureMatrixArray [ f ] ; for ( int entries = 0 ; entries < matrix . getNumberOfEntries ( ) ; entries ++ ) { auxiliaryStep ( matrix ) ; } } } if ( zalandoMode ) { SparseIntMatrix [ ] mcArray = initMCArray ( ) ; for ( int f = 0 ; f < mcArray . length ; f ++ ) { SparseIntMatrix matrix = mcArray [ f ] ; for ( int entries = 0 ; entries < matrix . getNumberOfEntries ( ) ; entries ++ ) { auxiliaryStep ( matrix ) ; } } } } for ( int i = 0 ; i < num_pos_events ; i ++ ) { if ( ! SequentialLearning ) { if ( useIIMaps ) { for ( int f = 0 ; f < data . featureMatrixArray . length ; f ++ ) { SparseMatrix matrix = data . featureMatrixArray [ f ] ; auxiliaryStep ( matrix ) ; } } if ( zalandoMode ) { SparseIntMatrix [ ] mcArray = initMCArray ( ) ; for ( int f = 0 ; f < mcArray . length ; f ++ ) { SparseIntMatrix matrix = mcArray [ f ] ; auxiliaryStep ( matrix ) ; } } } int [ ] triple = new int [ 4 ] ; xscale = 1 ; if ( tripleCriterion . equals ( " number " ) ) { triple [ 0 ] = sampleU ( data . numberMatrixP ) ; triple = sampleIJ ( triple , data . numberMatrixP , false ) ; } else if ( tripleCriterion . equals ( " time " ) ) { triple [ 0 ] = sampleU ( data . timeMatrixP ) ; triple = sampleIJ ( triple , data . timeMatrixP , false ) ; } else if ( tripleCriterion . equals ( " rating " ) ) { triple [ 0 ] = sampleU ( ) ; triple = sampleIJrating ( triple ) ; } else { triple [ 0 ] = sampleU ( ) ; triple = sampleIJ ( triple ) ; } user_id = triple [ 0 ] ; pos_item_id = triple [ 1 ] ; neg_item_id = triple [ 2 ] ; if ( useXscale ) xscale = triple [ 3 ] ; updateFactors ( user_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , learnRate , false ) ; } } else { if ( useIIMaps ) { for ( int f = 0 ; f < data . featureMatrixArray . length ; f ++ ) { for ( int k = 0 ; k < data . boolMatrix_numItems ; k ++ ) { for ( int l = 0 ; l < data . boolMatrix_numItems ; l ++ ) { initial_item_id = k ; pos_item_id = l ; neg_item_id = - 1 ; xscale = 1 ; if ( data . featureMatrixArray [ f ] . getBool ( initial_item_id , pos_item_id ) ) { int [ ] sampleTriple = null ; sampleTriple = sampleJ ( initial_item_id , pos_item_id , neg_item_id , data . featureMatrixArray [ f ] ) ; initial_item_id = sampleTriple [ 0 ] ; pos_item_id = sampleTriple [ 1 ] ; neg_item_id = sampleTriple [ 2 ] ; if ( useXscale ) xscale = sampleTriple [ 3 ] ; updateFactors ( initial_item_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , learnRate , true ) ; } } } } } for ( int k = 0 ; k < data . boolMatrix_numUsers ; k ++ ) { for ( int l = 0 ; l < data . boolMatrix_numItems ; l ++ ) { user_id = k ; pos_item_id = l ; neg_item_id = - 1 ; xscale = 1 ; if ( data . boolMatrix . getBool ( user_id , pos_item_id ) ) { int [ ] sampleTriple = null ; if ( tripleCriterion . equals ( " number " ) ) { sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , data . numberMatrixP , false ) ; } else if ( tripleCriterion . equals ( " time " ) ) { sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , data . timeMatrixP , false ) ; } else if ( tripleCriterion . equals ( " rating " ) ) { float useravg = data . dm . getUserAverageRating ( data . userMap . get ( user_id ) ) ; int rating = data . dm . getRating ( data . userMap . get ( user_id ) , data . itemMap . get ( pos_item_id ) ) ; if ( rating < useravg ) continue ; else sampleTriple = sampleJrating ( user_id , pos_item_id , neg_item_id ) ; } else { sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id ) ; } user_id = sampleTriple [ 0 ] ; pos_item_id = sampleTriple [ 1 ] ; neg_item_id = sampleTriple [ 2 ] ; if ( useXscale ) xscale = sampleTriple [ 3 ] ; updateFactors ( user_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , learnRate , false ) ; } if ( zalandoMode ) { SparseIntMatrix [ ] mcArray = initMCArray ( ) ; for ( int f = 0 ; f < mcArray . length ; f ++ ) { SparseIntMatrix matrix = mcArray [ f ] ; user_id = k ; pos_item_id = l ; neg_item_id = - 1 ; xscale = 1 ; if ( matrix . get ( user_id , pos_item_id ) > 0 ) { int [ ] sampleTriple = null ; if ( tripleCriterion . equals ( " unseen " ) ) sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , matrix , true ) ; else sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , matrix , false ) ; user_id = sampleTriple [ 0 ] ; pos_item_id = sampleTriple [ 1 ] ; neg_item_id = sampleTriple [ 2 ] ; if ( useXscale ) xscale = sampleTriple [ 3 ] ; updateFactors ( user_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , 0.05 , false ) ; } } } } } } }
valegrajales/recommendation_systems_lab1 | private SparseIntMatrix [ ] initMCArray ( ) { SparseIntMatrix [ ] mcArray = new SparseIntMatrix [ 6 ] ; if ( tripleCriterion . equals ( " unseen " ) ) { mcArray [ 0 ] = data . numberMatrixV ; mcArray [ 1 ] = data . numberMatrixC ; mcArray [ 2 ] = data . numberMatrixW ; mcArray [ 3 ] = data . numberMatrixVR ; mcArray [ 4 ] = data . numberMatrixDC ; mcArray [ 5 ] = data . numberMatrixDW ; } if ( tripleCriterion . equals ( " number " ) ) { mcArray [ 0 ] = data . numberMatrixV ; mcArray [ 1 ] = data . numberMatrixC ; mcArray [ 2 ] = data . numberMatrixW ; mcArray [ 3 ] = data . numberMatrixVR ; mcArray [ 4 ] = data . numberMatrixDC ; mcArray [ 5 ] = data . numberMatrixDW ; } if ( tripleCriterion . equals ( " time " ) ) { mcArray [ 0 ] = data . timeMatrixV ; mcArray [ 1 ] = data . timeMatrixC ; mcArray [ 2 ] = data . timeMatrixW ; mcArray [ 3 ] = data . timeMatrixVR ; mcArray [ 4 ] = data . timeMatrixDC ; mcArray [ 5 ] = data . timeMatrixDW ; } return mcArray ; }
valegrajales/recommendation_systems_lab1 | private void auxiliaryStep ( SparseMatrix matrix ) { int [ ] triple = new int [ 4 ] ; triple [ 0 ] = sampleK ( matrix ) ; triple = sampleIJ ( triple , matrix ) ; updateFactors ( triple [ 0 ] , triple [ 1 ] , triple [ 2 ] , true , true , updateJ , triple [ 3 ] , learnRate , true ) ; }
valegrajales/recommendation_systems_lab1 | private void auxiliaryStep ( SparseIntMatrix matrix ) { int [ ] triple = new int [ 4 ] ; triple [ 0 ] = sampleU ( matrix ) ; if ( tripleCriterion . equals ( " unseen " ) ) { triple = sampleIJ ( triple , matrix , true ) ; } else { triple = sampleIJ ( triple , matrix , false ) ; } int xscale = 1 ; if ( useXscale ) xscale = triple [ 3 ] ; updateFactors ( triple [ 0 ] , triple [ 1 ] , triple [ 2 ] , true , true , updateJ , xscale , learnRate , false ) ; }
valegrajales/recommendation_systems_lab1 | public void updateFactors ( int u , int i , int j , boolean update_u , boolean update_i , boolean update_j , int xscale , double newLearnrate , boolean item2item ) { double x_uij ; if ( ! item2item ) { x_uij = data . item_bias [ i ] - data . item_bias [ j ] + data . rowScalarProductWithRowDifference ( u , i , j ) ; } else { x_uij = data . item_bias [ i ] - data . item_bias [ j ] + data . rowScalarProductWithRowDifferenceItem ( u , i , j ) ; } x_uij *= xscale ; double one_over_one_plus_ex = 1 / ( 1 + Math . exp ( x_uij ) ) ; if ( update_i ) { double update = one_over_one_plus_ex - biasReg * data . item_bias [ i ] ; data . item_bias [ i ] += ( newLearnrate * update ) ; } if ( update_j ) { double update = - one_over_one_plus_ex - biasReg * data . item_bias [ j ] ; data . item_bias [ j ] += ( newLearnrate * update ) ; } for ( int f = 0 ; f < numFeatures ; f ++ ) { double w_uf ; if ( ! item2item ) { w_uf = data . latentUserVector [ u ] [ f ] ; } else { w_uf = data . latentItemVector [ u ] [ f ] ; } double h_if = data . latentItemVector [ i ] [ f ] ; double h_jf = data . latentItemVector [ j ] [ f ] ; if ( update_u ) { double update = ( h_if - h_jf ) * one_over_one_plus_ex - regU * w_uf ; if ( ! item2item ) { data . latentUserVector [ u ] [ f ] = ( w_uf + newLearnrate * update ) ; } else { data . latentItemVector [ u ] [ f ] = ( w_uf + newLearnrate * update ) ; } } if ( update_i ) { double update = w_uf * one_over_one_plus_ex - regI * h_if ; data . latentItemVector [ i ] [ f ] = ( float ) ( h_if + newLearnrate * update ) ; } if ( update_j ) { double update = - w_uf * one_over_one_plus_ex - regJ * h_jf ; data . latentItemVector [ j ] [ f ] = ( float ) ( h_jf + newLearnrate * update ) ; } } }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJ ( int u , int i , int j ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = u ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; boolean item_is_positive = data . boolMatrix . getBool ( u , i ) ; if ( item_is_positive == false ) System . err . println ( " This ▁ error ▁ should ▁ never ▁ happen ! " ) ; do sampleTriple [ 2 ] = random . nextInt ( numItems ) ; while ( data . boolMatrix . getBool ( u , sampleTriple [ 2 ] ) == item_is_positive ) ; sampleTriple [ 3 ] = 1 ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJrating ( int u , int i , int j ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = u ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; sampleTriple [ 3 ] = 1 ; int positive_rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( i ) ) ; List < Integer > user_items = data . userMatrix . get ( u ) ; float useravg = data . dm . getUserAverageRating ( data . userMap . get ( u ) ) ; boolean breaker ; do { sampleTriple [ 2 ] = random . nextInt ( numItems ) ; if ( user_items . contains ( sampleTriple [ 2 ] ) ) { int rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( sampleTriple [ 2 ] ) ) ; if ( rating < useravg ) { breaker = false ; sampleTriple [ 3 ] = Math . max ( 1 , positive_rating - rating ) ; } else breaker = true ; } else breaker = false ; } while ( breaker ) ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJ ( int u , int i , int j , SparseIntMatrix matrix , boolean justUnseen ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = u ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; int value_ui = matrix . get ( u , i ) ; do { sampleTriple [ 2 ] = random . nextInt ( numItems ) ; } while ( ( justUnseen ? 1 : value_ui ) <= matrix . get ( u , sampleTriple [ 2 ] ) ) ; sampleTriple [ 3 ] = justUnseen ? 1 : ( value_ui - matrix . get ( u , sampleTriple [ 2 ] ) ) ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJ ( int k , int i , int j , SparseMatrix matrix ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = k ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; boolean breaker = false ; int xscale = 1 ; do { sampleTriple [ 2 ] = random . nextInt ( numItems ) ; if ( matrix . get ( k , sampleTriple [ 2 ] ) instanceof Byte ) { byte jValue = ( byte ) matrix . get ( k , sampleTriple [ 2 ] ) ; byte iValue = ( byte ) matrix . get ( k , sampleTriple [ 1 ] ) ; if ( iValue > jValue ) breaker = true ; } else if ( matrix . get ( k , sampleTriple [ 2 ] ) instanceof Integer ) { int jValue = ( int ) matrix . get ( k , sampleTriple [ 2 ] ) ; int iValue = ( int ) matrix . get ( k , sampleTriple [ 1 ] ) ; if ( iValue > jValue ) breaker = true ; xscale = iValue - jValue ; } else { System . err . println ( " WRONG ▁ TYPE ! ▁ 1" ) ; return null ; } } while ( ! breaker ) ; sampleTriple [ 3 ] = xscale ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int sampleU ( ) { while ( true ) { int u = random . nextInt ( numUsers ) ; if ( ! data . userMatrix . containsKey ( u ) ) continue ; List < Integer > viewedItemsList = data . userMatrix . get ( u ) ; if ( viewedItemsList == null || viewedItemsList . size ( ) == 0 || viewedItemsList . size ( ) == numItems ) continue ; return u ; } }
valegrajales/recommendation_systems_lab1 | public int sampleU ( SparseIntMatrix matrix ) { while ( true ) { int i = random . nextInt ( matrix . getM ( ) ) ; if ( matrix . getRow ( i ) == null ) continue ; TIntIntMap ithRow = matrix . getRow ( i ) ; boolean oneIsNotZero = false ; boolean oneIsDifferent = false ; int temp = ithRow . get ( 0 ) ; for ( int j = 0 ; j < matrix . getN ( ) ; j ++ ) { int ij = ithRow . get ( j ) ; if ( ij != 0 ) { oneIsNotZero = true ; } if ( ij != temp ) { oneIsDifferent = true ; } temp = ij ; } if ( oneIsDifferent && oneIsNotZero ) return i ; continue ; } }
valegrajales/recommendation_systems_lab1 | public int sampleK ( SparseMatrix matrix ) { while ( true ) { int i = random . nextInt ( matrix . getM ( ) ) ; if ( matrix . getRow ( i ) == null ) continue ; Object ithRow = matrix . getRow ( i ) ; boolean breaker ; boolean oneIsNotZero = false ; boolean oneIsDifferent = false ; if ( ithRow instanceof TIntByteMap || ithRow instanceof TIntByteHashMap ) { TIntByteMap ithRowByte = ( TIntByteMap ) ithRow ; byte temp = ithRowByte . get ( 0 ) ; for ( int j = 0 ; j < matrix . getN ( ) ; j ++ ) { byte ij = ithRowByte . get ( j ) ; if ( ij != 0 ) { oneIsNotZero = true ; } if ( ij != temp ) { oneIsDifferent = true ; } temp = ij ; } } else if ( ithRow instanceof TIntIntMap || ithRow instanceof TIntIntHashMap ) { TIntIntMap ithRowInt = ( TIntIntMap ) ithRow ; int temp = ithRowInt . get ( 0 ) ; for ( int j = 0 ; j < matrix . getN ( ) ; j ++ ) { int ij = ithRowInt . get ( j ) ; if ( ij != 0 ) { oneIsNotZero = true ; } if ( ij != temp ) { oneIsDifferent = true ; } temp = ij ; } } else { System . err . println ( ithRow . getClass ( ) ) ; System . err . println ( " WRONG ▁ TYPE ! ▁ 2" ) ; return - 1 ; } if ( oneIsDifferent && oneIsNotZero ) return i ; continue ; } }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJ ( int [ ] triple ) { int u = triple [ 0 ] ; List < Integer > user_items = data . userMatrix . get ( u ) ; triple [ 1 ] = user_items . get ( ( random . nextInt ( user_items . size ( ) ) ) ) ; do triple [ 2 ] = random . nextInt ( numItems ) ; while ( user_items . contains ( triple [ 2 ] ) ) ; return triple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJrating ( int [ ] triple ) { int u = triple [ 0 ] ; int neg_rating ; float useravg = data . dm . getUserAverageRating ( data . userMap . get ( u ) ) ; int pos_rating ; triple [ 3 ] = 1 ; List < Integer > user_items = data . userMatrix . get ( u ) ; do { triple [ 1 ] = user_items . get ( ( random . nextInt ( user_items . size ( ) ) ) ) ; pos_rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( triple [ 1 ] ) ) ; if ( debug . contains ( " $ anyrated $ " ) ) { break ; } } while ( pos_rating < useravg ) ; boolean breaker ; int debugcount = 0 ; boolean debugswitch = false ; do { if ( debug . contains ( " $ force50percent $ " ) ) { debugswitch = random . nextBoolean ( ) ; } if ( debug . contains ( " $ force25percent $ " ) ) { if ( random . nextInt ( 4 ) == 0 ) debugswitch = true ; else debugswitch = false ; } if ( debug . contains ( " $ force75percent $ " ) ) { if ( random . nextInt ( 4 ) == 0 ) debugswitch = false ; else debugswitch = true ; } if ( ( debug . contains ( " $ forcerated $ " ) && debugcount < 5 ) || debugswitch ) { triple [ 2 ] = user_items . get ( ( random . nextInt ( user_items . size ( ) ) ) ) ; debugcount ++ ; } else { triple [ 2 ] = random . nextInt ( numItems ) ; } if ( user_items . contains ( triple [ 2 ] ) ) { neg_rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( triple [ 2 ] ) ) ; if ( debug . contains ( " $ anyrated $ " ) || debug . contains ( " $ smallerthani $ " ) ) { if ( neg_rating < pos_rating ) { breaker = false ; triple [ 3 ] = Math . max ( 1 , pos_rating - neg_rating ) ; } else breaker = true ; } else { if ( neg_rating < useravg ) { breaker = false ; triple [ 3 ] = Math . max ( 1 , pos_rating - neg_rating ) ; } else breaker = true ; } } else breaker = false ; } while ( breaker ) ; return triple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJ ( int [ ] triple , SparseIntMatrix matrix , boolean justUnseen ) { int i = triple [ 0 ] ; int j1 ; int j2 ; TIntIntMap ithRow = matrix . getRow ( i ) ; do { j1 = random . nextInt ( matrix . getN ( ) ) ; } while ( ithRow . get ( j1 ) == 0 ) ; do { j2 = random . nextInt ( matrix . getN ( ) ) ; } while ( ( justUnseen ? 1 : ithRow . get ( j1 ) ) <= ithRow . get ( j2 ) ) ; triple [ 1 ] = j1 ; triple [ 2 ] = j2 ; if ( useXscale ) triple [ 3 ] = justUnseen ? 1 : ( ithRow . get ( j1 ) - ithRow . get ( j2 ) ) ; return triple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJ ( int [ ] triple , SparseMatrix matrix ) { int i = triple [ 0 ] ; int j1 ; int j2 ; int xscale = 1 ; Object ithRow = matrix . getRow ( i ) ; boolean breaker ; do { j1 = random . nextInt ( matrix . getN ( ) ) ; if ( ithRow instanceof TIntByteMap ) { breaker = ( ( ( TIntByteMap ) ithRow ) . get ( j1 ) == 0 ) ; } else if ( ithRow instanceof TIntIntMap ) { breaker = ( ( ( TIntIntMap ) ithRow ) . get ( j1 ) == 0 ) ; } else { System . err . println ( " WRONG ▁ TYPE ! ▁ 3" ) ; return null ; } } while ( breaker ) ; do { j2 = random . nextInt ( matrix . getN ( ) ) ; if ( ithRow instanceof TIntByteMap ) { breaker = ( ( ( TIntByteMap ) ithRow ) . get ( j2 ) != 0 ) ; } else if ( ithRow instanceof TIntIntMap ) { breaker = ( ( ( TIntIntMap ) ithRow ) . get ( j2 ) >= ( ( TIntIntMap ) ithRow ) . get ( j1 ) ) ; xscale = ( ( TIntIntMap ) ithRow ) . get ( j1 ) - ( ( TIntIntMap ) ithRow ) . get ( j2 ) ; } else { System . err . println ( " WRONG ▁ TYPE ! ▁ 4" ) ; return null ; } } while ( breaker ) ; triple [ 1 ] = j1 ; triple [ 2 ] = j2 ; triple [ 3 ] = xscale ; return triple ; }
valegrajales/recommendation_systems_lab1 | public void setNumFeatures ( String n ) { this . numFeatures = Integer . parseInt ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setRegI ( String n ) { this . regI = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setRegJ ( String n ) { this . regJ = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setRegU ( String n ) { this . regU = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setUpdateJ ( String n ) { this . updateJ = Boolean . parseBoolean ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setBiasReg ( String n ) { this . biasReg = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setLearnRate ( String n ) { this . learnRate = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setInitialSteps ( String n ) { this . initialSteps = Integer . parseInt ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setUniformSampling ( String n ) { this . UniformUserSampling = Boolean . parseBoolean ( n ) ; }
valegrajales/recommendation_systems_lab1 | @ Override public int getDurationEstimate ( ) { return 3 ; }
valegrajales/recommendation_systems_lab1 | public void setUseRelevanceThreshold ( String u ) throws Exception { data . useRatingThreshold = Boolean . parseBoolean ( u ) ; }
valegrajales/recommendation_systems_lab1 | public void setTripleCriterion ( String u ) { this . tripleCriterion = u ; }
valegrajales/recommendation_systems_lab1 | public void setUseUIMaps ( String b ) { useUIMaps = Boolean . parseBoolean ( b ) ; data . useUIMaps = useUIMaps ; }
valegrajales/recommendation_systems_lab1 | public void setSelectIIMaps ( String b ) { if ( b != null && ! b . equals ( " " ) ) useIIMaps = true ; data . selectIIMaps = b ; data . useIIMaps = useIIMaps ; }
valegrajales/recommendation_systems_lab1 | public void setUseXscale ( String b ) { useXscale = Boolean . parseBoolean ( b ) ; }
valegrajales/recommendation_systems_lab1 | public void setSequentialLearning ( String b ) { SequentialLearning = Boolean . parseBoolean ( b ) ; }
valegrajales/recommendation_systems_lab1 | public void setZalandoMode ( String b ) { zalandoMode = Boolean . parseBoolean ( b ) ; data . zalandoMode = zalandoMode ; }
valegrajales/recommendation_systems_lab1 | public void setDebug ( String b ) { debug = b ; }
codeck/XChange | public KrakenUserTrade ( OrderType type , BigDecimal tradableAmount , CurrencyPair currencyPair , BigDecimal price , Date timestamp , String id , String orderId , BigDecimal feeAmount , String feeCurrency , BigDecimal cost ) { super ( type , tradableAmount , currencyPair , price , timestamp , id , orderId , feeAmount , feeCurrency ) ; this . cost = cost ; }
codeck/XChange | public BigDecimal getCost ( ) { return cost ; }
codeck/XChange | public Builder cost ( BigDecimal cost ) { this . cost = cost ; return this ; }
codeck/XChange | public KrakenUserTrade build ( ) { KrakenUserTrade trade = new KrakenUserTrade ( type , tradableAmount , currencyPair , price , timestamp , id , orderId , feeAmount , feeCurrency , cost ) ; return trade ; }
Hilco-Wijbenga/blueprint | @ Before public void setUp ( ) { value = " ▁ ▁ ▁ ▁ Hello ▁ ▁ ▁ \n ▁ ▁ World \n ▁ ▁ ▁ ▁ " ; comments = new Comments ( value ) ; commentsWithDifferentValue = new Comments ( " Hello \n World " ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_value_cannot_be_NULL ( ) { try { new Comments ( null ) ; fail ( " Expected ▁ a ▁ NullPointerException . " ) ; } catch ( final NullPointerException e ) { assertEquals ( " Missing ▁ ' value ' . " , e . getMessage ( ) ) ; } }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_with_an_empty_value_is_empty ( ) { final Comments emptyComments = new Comments ( " ▁ ▁ ▁ \t ▁ ▁ ▁ \n \r " ) ; assertEquals ( " " , emptyComments . value ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_lines_retain_their_indentation ( ) { final Iterator < String > lineIt = comments . iterator ( ) ; assertEquals ( " ▁ ▁ Hello " , lineIt . next ( ) ) ; assertEquals ( " World " , lineIt . next ( ) ) ; assertFalse ( lineIt . hasNext ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_hash_code_is_based_on_its_fields ( ) { assertEquals ( comments . hashCode ( ) , comments . hashCode ( ) ) ; assertEquals ( comments . hashCode ( ) , new Comments ( value ) . hashCode ( ) ) ; assertNotEquals ( comments . hashCode ( ) , new Comments ( " Hello \n world " ) . hashCode ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_MISSING_is_essentially_an_empty_instance ( ) { assertEquals ( " " , Comments . MISSING . value ( ) ) ; assertFalse ( Comments . MISSING . iterator ( ) . hasNext ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_order_is_based_on_its_value ( ) { final Comments commentsAbc = new Comments ( " abc " ) ; final Comments commentsXyz = new Comments ( " xyz " ) ; assertTrue ( commentsAbc . compareTo ( commentsXyz ) < 0 ) ; assertEquals ( 0 , commentsAbc . compareTo ( commentsAbc ) ) ; assertTrue ( commentsXyz . compareTo ( commentsAbc ) > 0 ) ; assertEquals ( 0 , commentsXyz . compareTo ( commentsXyz ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_equality_to_another_is_based_on_its_value ( ) { assertTrue ( comments . equals ( comments ) ) ; assertTrue ( comments . equals ( new Comments ( value ) ) ) ; assertTrue ( new Comments ( value ) . equals ( comments ) ) ; assertFalse ( comments . equals ( null ) ) ; assertFalse ( comments . equals ( new Object ( ) ) ) ; assertFalse ( comments . equals ( commentsWithDifferentValue ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_the_textual_representation_of_an_empty_Comments_is_correct ( ) { assertEquals ( " < comments > < / comments > " , Comments . MISSING . show ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_the_textual_representation_of_a_Comments_is_correct ( ) { assertEquals ( " < comments > \n ▁ ▁ ▁ ▁ ▁ ▁ Hello \n ▁ ▁ ▁ ▁ World \n < / comments > " , comments . show ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void executeBridgeMethod ( ) throws Exception { final Method compareTo = Comments . class . getDeclaredMethod ( " compareTo " , Object . class ) ; compareTo . invoke ( comments , comments ) ; }
desruisseaux/sis | protected MetadataAdapter ( ) { }
desruisseaux/sis | @ Override public final BoundType unmarshal ( final ValueType value ) { return value ; }
FHannes/intellij-community | private MavenArtifactDownloader ( @ NotNull Project project , MavenProjectsTree projectsTree , Collection < MavenProject > mavenProjects , Collection < MavenArtifact > artifacts , MavenEmbedderWrapper embedder , MavenProgressIndicator p ) { myProject = project ; myProjectsTree = projectsTree ; myMavenProjects = mavenProjects ; myArtifacts = artifacts == null ? null : new THashSet < > ( artifacts ) ; myEmbedder = embedder ; myProgress = p ; }
FHannes/intellij-community | private DownloadResult download ( boolean downloadSources , boolean downloadDocs ) throws MavenProcessCanceledException { List < File > downloadedFiles = new ArrayList < > ( ) ; try { List < MavenExtraArtifactType > types = new ArrayList < > ( 2 ) ; if ( downloadSources ) types . add ( MavenExtraArtifactType . SOURCES ) ; if ( downloadDocs ) types . add ( MavenExtraArtifactType . DOCS ) ; String caption = downloadSources && downloadDocs ? ProjectBundle . message ( " maven . downloading " ) : ( downloadSources ? ProjectBundle . message ( " maven . downloading . sources " ) : ProjectBundle . message ( " maven . downloading . docs " ) ) ; myProgress . setText ( caption ) ; Map < MavenId , DownloadData > artifacts = collectArtifactsToDownload ( types ) ; return download ( artifacts , downloadedFiles ) ; } finally { boolean isAsync = ! ApplicationManager . getApplication ( ) . isUnitTestMode ( ) ; Set < File > filesToRefresh = new HashSet < > ( ) ; for ( File file : downloadedFiles ) { filesToRefresh . add ( file ) ; filesToRefresh . add ( file . getParentFile ( ) ) ; } LocalFileSystem . getInstance ( ) . refreshIoFiles ( filesToRefresh , isAsync , false , null ) ; } }
FHannes/intellij-community | private Map < MavenId , DownloadData > collectArtifactsToDownload ( List < MavenExtraArtifactType > types ) { Map < MavenId , DownloadData > result = new THashMap < > ( ) ; THashSet < String > dependencyTypesFromSettings = new THashSet < > ( ) ; AccessToken accessToken = ReadAction . start ( ) ; try { if ( myProject . isDisposed ( ) ) return result ; dependencyTypesFromSettings . addAll ( MavenProjectsManager . getInstance ( myProject ) . getImportingSettings ( ) . getDependencyTypesAsSet ( ) ) ; } finally { accessToken . finish ( ) ; } for ( MavenProject eachProject : myMavenProjects ) { List < MavenRemoteRepository > repositories = eachProject . getRemoteRepositories ( ) ; for ( MavenArtifact eachDependency : eachProject . getDependencies ( ) ) { if ( myArtifacts != null && ! myArtifacts . contains ( eachDependency ) ) continue ; if ( MavenConstants . SCOPE_SYSTEM . equalsIgnoreCase ( eachDependency . getScope ( ) ) ) continue ; if ( myProjectsTree . findProject ( eachDependency . getMavenId ( ) ) != null ) continue ; String dependencyType = eachDependency . getType ( ) ; if ( ! dependencyTypesFromSettings . contains ( dependencyType ) && ! eachProject . getDependencyTypesFromImporters ( SupportedRequestType . FOR_IMPORT ) . contains ( dependencyType ) ) { continue ; } MavenId id = eachDependency . getMavenId ( ) ; DownloadData data = result . get ( id ) ; if ( data == null ) { data = new DownloadData ( ) ; result . put ( id , data ) ; } data . repositories . addAll ( repositories ) ; for ( MavenExtraArtifactType eachType : types ) { Pair < String , String > classifierAndExtension = eachProject . getClassifierAndExtension ( eachDependency , eachType ) ; String classifier = eachDependency . getFullClassifier ( classifierAndExtension . first ) ; String extension = classifierAndExtension . second ; data . classifiersWithExtensions . add ( new DownloadElement ( classifier , extension , eachType ) ) ; } } } return result ; }
FHannes/intellij-community | private DownloadResult download ( final Map < MavenId , DownloadData > toDownload , final List < File > downloadedFiles ) throws MavenProcessCanceledException { List < Future > futures = new ArrayList < > ( ) ; final AtomicInteger downloaded = new AtomicInteger ( ) ; int total = 0 ; for ( DownloadData each : toDownload . values ( ) ) { total += each . classifiersWithExtensions . size ( ) ; } final DownloadResult result = new DownloadResult ( ) ; result . unresolvedSources . addAll ( toDownload . keySet ( ) ) ; result . unresolvedDocs . addAll ( toDownload . keySet ( ) ) ; try { for ( final Map . Entry < MavenId , DownloadData > eachEntry : toDownload . entrySet ( ) ) { myProgress . checkCanceled ( ) ; final DownloadData data = eachEntry . getValue ( ) ; final MavenId id = eachEntry . getKey ( ) ; for ( final DownloadElement eachElement : data . classifiersWithExtensions ) { final int finalTotal = total ; futures . add ( EXECUTOR . submit ( ( ) -> { try { if ( myProject . isDisposed ( ) ) return ; myProgress . checkCanceled ( ) ; myProgress . setFraction ( ( ( double ) downloaded . getAndIncrement ( ) ) / finalTotal ) ; MavenArtifact a = myEmbedder . resolve ( new MavenArtifactInfo ( id , eachElement . extension , eachElement . classifier ) , new ArrayList < > ( data . repositories ) ) ; File file = a . getFile ( ) ; if ( file . exists ( ) ) { synchronized ( downloadedFiles ) { downloadedFiles . add ( file ) ; switch ( eachElement . type ) { case SOURCES : result . resolvedSources . add ( id ) ; result . unresolvedSources . remove ( id ) ; break ; case DOCS : result . resolvedDocs . add ( id ) ; result . unresolvedDocs . remove ( id ) ; break ; } } } } catch ( MavenProcessCanceledException ignore ) { } } ) ) ; } } } finally { for ( Future each : futures ) { try { each . get ( ) ; } catch ( Exception e ) { MavenLog . LOG . error ( e ) ; } } } return result ; }
FHannes/intellij-community | public DownloadElement ( String classifier , String extension , MavenExtraArtifactType type ) { this . classifier = classifier ; this . extension = extension ; this . type = type ; }
FHannes/intellij-community | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; DownloadElement that = ( DownloadElement ) o ; if ( classifier != null ? ! classifier . equals ( that . classifier ) : that . classifier != null ) return false ; if ( extension != null ? ! extension . equals ( that . extension ) : that . extension != null ) return false ; if ( type != that . type ) return false ; return true ; }
FHannes/intellij-community | @ Override public int hashCode ( ) { int result = classifier != null ? classifier . hashCode ( ) : 0 ; result = 31 * result + ( extension != null ? extension . hashCode ( ) : 0 ) ; result = 31 * result + ( type != null ? type . hashCode ( ) : 0 ) ; return result ; }
fengshao0907/incubator-geode | public LocalDataSetIndexingDUnitTest ( String name ) { super ( name ) ; }
fengshao0907/incubator-geode | @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; Host host = Host . getHost ( 0 ) ; dataStore1 = host . getVM ( 0 ) ; dataStore2 = host . getVM ( 1 ) ; }
fengshao0907/incubator-geode | public void testLocalDataSetIndexing ( ) { final CacheSerializableRunnable createPRs = new CacheSerializableRunnable ( " create ▁ prs ▁ " ) { public void run2 ( ) { AttributesFactory < Integer , RegionValue > factory = new AttributesFactory < Integer , RegionValue > ( ) ; factory . setPartitionAttributes ( new PartitionAttributesFactory < Integer , RegionValue > ( ) . setRedundantCopies ( 1 ) . setTotalNumBuckets ( 8 ) . create ( ) ) ; final PartitionedRegion pr1 = ( PartitionedRegion ) createRootRegion ( " pr1" , factory . create ( ) ) ; factory = new AttributesFactory < Integer , RegionValue > ( ) ; factory . setPartitionAttributes ( new PartitionAttributesFactory < Integer , RegionValue > ( ) . setRedundantCopies ( 1 ) . setTotalNumBuckets ( 8 ) . setColocatedWith ( pr1 . getName ( ) ) . create ( ) ) ; final PartitionedRegion pr2 = ( PartitionedRegion ) createRootRegion ( " pr2" , factory . create ( ) ) ; } } ; final CacheSerializableRunnable createIndexesOnPRs = new CacheSerializableRunnable ( " create ▁ prs ▁ " ) { public void run2 ( ) { try { QueryService qs = getCache ( ) . getQueryService ( ) ; qs . createIndex ( " valueIndex1" , IndexType . FUNCTIONAL , " e1 . value " , " / pr1 ▁ e1" ) ; qs . createIndex ( " valueIndex2" , IndexType . FUNCTIONAL , " e2 . value " , " / pr2 ▁ e2" ) ; } catch ( Exception e ) { fail ( " Test ▁ failed ▁ due ▁ to ▁ Exception ▁ in ▁ index ▁ creation ▁ " , e ) ; } } } ; final CacheSerializableRunnable execute = new CacheSerializableRunnable ( " execute ▁ function " ) { public void run2 ( ) { final PartitionedRegion pr1 = ( PartitionedRegion ) getRootRegion ( " pr1" ) ; final PartitionedRegion pr2 = ( PartitionedRegion ) getRootRegion ( " pr2" ) ; final Set < Integer > filter = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= 80 ; i ++ ) { pr1 . put ( i , new RegionValue ( i ) ) ; if ( i <= 20 ) { pr2 . put ( i , new RegionValue ( i ) ) ; if ( ( i % 5 ) == 0 ) { filter . add ( i ) ; } } } ArrayList < List > result = ( ArrayList < List > ) FunctionService . onRegion ( pr1 ) . withFilter ( filter ) . execute ( new FunctionAdapter ( ) { public void execute ( FunctionContext context ) { try { RegionFunctionContext rContext = ( RegionFunctionContext ) context ; Region pr1 = rContext . getDataSet ( ) ; LocalDataSet localCust = ( LocalDataSet ) PartitionRegionHelper . getLocalDataForContext ( rContext ) ; Map < String , Region < ? , ? > > colocatedRegions = PartitionRegionHelper . getColocatedRegions ( pr1 ) ; Map < String , Region < ? , ? > > localColocatedRegions = PartitionRegionHelper . getLocalColocatedRegions ( rContext ) ; Region pr2 = colocatedRegions . get ( " / pr2" ) ; LocalDataSet localOrd = ( LocalDataSet ) localColocatedRegions . get ( " / pr2" ) ; QueryObserverImpl observer = new QueryObserverImpl ( ) ; QueryObserverHolder . setInstance ( observer ) ; QueryService qs = pr1 . getCache ( ) . getQueryService ( ) ; DefaultQuery query = ( DefaultQuery ) qs . newQuery ( " select ▁ distinct ▁ e1 . value ▁ from ▁ / pr1 ▁ e1 , ▁ / pr2 ▁ ▁ e2 ▁ where ▁ e1 . value = e2 . value " ) ; GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " ▁ Num ▁ BUCKET ▁ SET : ▁ " + localCust . getBucketSet ( ) ) ; GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " VALUES ▁ FROM ▁ PR1 ▁ bucket : " ) ; for ( Integer bId : localCust . getBucketSet ( ) ) { BucketRegion br = ( ( PartitionedRegion ) pr1 ) . getDataStore ( ) . getLocalBucketById ( bId ) ; String val = " " ; for ( Object e : br . values ( ) ) { val += ( e + " , " ) ; } GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " : ▁ " + val ) ; } GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " VALUES ▁ FROM ▁ PR2 ▁ bucket : " ) ; for ( Integer bId : localCust . getBucketSet ( ) ) { BucketRegion br = ( ( PartitionedRegion ) pr2 ) . getDataStore ( ) . getLocalBucketById ( bId ) ; String val = " " ; for ( Object e : br . values ( ) ) { val += ( e + " , " ) ; } GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " : ▁ " + val ) ; } SelectResults r = ( SelectResults ) localCust . executeQuery ( query , null , localCust . getBucketSet ( ) ) ; GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " Result ▁ : " + r . asList ( ) ) ; Assert . assertTrue ( observer . isIndexesUsed ) ; pr1 . getCache ( ) . getLogger ( ) . fine ( " Index ▁ Used : ▁ " + observer . numIndexesUsed ( ) ) ; Assert . assertTrue ( 2 == observer . numIndexesUsed ( ) ) ; context . getResultSender ( ) . lastResult ( ( Serializable ) r . asList ( ) ) ; } catch ( Exception e ) { context . getResultSender ( ) . lastResult ( Boolean . TRUE ) ; } } @ Override public String getId ( ) { return " ok " ; } @ Override public boolean optimizeForWrite ( ) { return false ; } } ) . getResult ( ) ; int numResults = 0 ; for ( List oneNodeResult : result ) { GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " Result ▁ : " + numResults + " ▁ oneNodeResult . size ( ) : ▁ " + oneNodeResult . size ( ) + " ▁ oneNodeResult ▁ : " + oneNodeResult ) ; numResults = + oneNodeResult . size ( ) ; } Assert . assertTrue ( 10 == numResults ) ; } } ; dataStore1 . invoke ( createPRs ) ; dataStore2 . invoke ( createPRs ) ; dataStore1 . invoke ( createIndexesOnPRs ) ; dataStore1 . invoke ( execute ) ; }
fengshao0907/incubator-geode | public void beforeIndexLookup ( Index index , int oper , Object key ) { indexName = index . getName ( ) ; indexesUsed . add ( index . getName ( ) ) ; }
fengshao0907/incubator-geode | public void afterIndexLookup ( Collection results ) { if ( results != null ) { isIndexesUsed = true ; } }
fengshao0907/incubator-geode | public int numIndexesUsed ( ) { return indexesUsed . size ( ) ; }
fengshao0907/incubator-geode | public RegionValue ( int value ) { this . value = value ; this . value2 = value ; }
fengshao0907/incubator-geode | public int compareTo ( RegionValue o ) { if ( this . value > o . value ) { return 1 ; } else if ( this . value < o . value ) { return - 1 ; } else { return 0 ; } }
fengshao0907/incubator-geode | public String toString ( ) { return " " + value ; }
cmunell/micro-util | public MethodClassificationFilterDatumIndicator ( ) { this ( null ) ; }
cmunell/micro-util | public MethodClassificationFilterDatumIndicator ( DatumContext < D , L > context ) { super ( context ) ; }
cmunell/micro-util | public MethodClassification < D , L > getInnerMethod ( ) { return this . method ; }
cmunell/micro-util | @ Override public String [ ] getParameterNames ( ) { if ( this . method != null ) { String [ ] parameterNames = Arrays . copyOf ( this . parameterNames , this . parameterNames . length + this . method . getParameterNames ( ) . length ) ; for ( int i = 0 ; i < this . method . getParameterNames ( ) . length ; i ++ ) parameterNames [ this . parameterNames . length + i ] = this . method . getParameterNames ( ) [ i ] ; return parameterNames ; } else return this . parameterNames ; }
cmunell/micro-util | @ Override public Obj getParameterValue ( String parameter ) { if ( parameter . equals ( " datumIndicator " ) ) return ( this . datumIndicator == null ) ? null : Obj . stringValue ( this . datumIndicator . toString ( ) ) ; else if ( parameter . equals ( " method " ) ) return ( this . method == null ) ? null : Obj . curlyBracedValue ( this . method . getReferenceName ( ) ) ; else if ( this . method != null ) return this . method . getParameterValue ( parameter ) ; else return null ; }
cmunell/micro-util | @ Override public boolean setParameterValue ( String parameter , Obj parameterValue ) { if ( parameter . equals ( " datumIndicator " ) ) { this . datumIndicator = ( parameterValue == null ) ? null : this . context . getDatumTools ( ) . getDatumIndicator ( this . context . getMatchValue ( parameterValue ) ) ; } else if ( parameter . equals ( " method " ) ) this . method = ( parameterValue == null ) ? null : this . context . getMatchClassifyMethod ( parameterValue ) ; else if ( this . method != null ) return this . method . setParameterValue ( parameter , parameterValue ) ; else return false ; return true ; }
cmunell/micro-util | @ Override public Map < D , L > classify ( DataSet < D , L > data ) { DataSet < D , L > filteredData = data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . classify ( filteredData ) ; }
cmunell/micro-util | @ Override public Map < D , Pair < L , Double > > classifyWithScore ( DataSet < D , L > data ) { DataSet < D , L > filteredData = data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . classifyWithScore ( filteredData ) ; }
cmunell/micro-util | @ Override public boolean init ( DataSet < D , L > testData ) { DataSet < D , L > filteredData = testData . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . init ( filteredData ) ; }
cmunell/micro-util | @ Override protected boolean fromParseInternal ( AssignmentList internalAssignments ) { return true ; }
cmunell/micro-util | @ Override protected AssignmentList toParseInternal ( ) { AssignmentList assignments = new AssignmentList ( ) ; if ( this . method != null ) assignments . add ( Assignment . assignmentTyped ( null , " classify _ method " , " method " , this . method . toParse ( true ) ) ) ; return assignments ; }
cmunell/micro-util | @ Override public String getGenericName ( ) { return " FilterDatumIndicator " ; }
cmunell/micro-util | @ Override public MethodClassification < D , L > clone ( String referenceName ) { MethodClassificationFilterDatumIndicator < D , L > clone = new MethodClassificationFilterDatumIndicator < D , L > ( this . context ) ; if ( ! clone . fromParse ( this . getModifiers ( ) , this . getReferenceName ( ) , toParse ( ) ) ) return null ; clone . method = this . method . clone ( ) ; clone . referenceName = referenceName ; return clone ; }
cmunell/micro-util | @ Override public MethodClassification < D , L > makeInstance ( DatumContext < D , L > context ) { return new MethodClassificationFilterDatumIndicator < D , L > ( context ) ; }
cmunell/micro-util | @ Override public boolean hasTrainable ( ) { return this . method . hasTrainable ( ) ; }
cmunell/micro-util | @ Override public Trainable < D , L > getTrainable ( ) { if ( this . method . hasTrainable ( ) ) return this ; else return null ; }
cmunell/micro-util | @ Override public boolean train ( ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . train ( ) ; }
cmunell/micro-util | @ Override public boolean setTrainData ( DataSet < D , L > data ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . setTrainData ( data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ) ; }
cmunell/micro-util | @ Override public boolean setDevData ( DataSet < D , L > data ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . setDevData ( data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ) ; }
cmunell/micro-util | @ Override public boolean iterateTraining ( Map < D , L > constrainedData ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . iterateTraining ( constrainedData ) ; }
cmunell/micro-util | @ Override public DataSet < D , L > getTrainData ( ) { return this . method . getTrainable ( ) . getTrainData ( ) ; }
cmunell/micro-util | @ Override public L classify ( D datum ) { if ( this . datumIndicator . indicator ( datum ) ) return this . method . classify ( datum ) ; else return null ; }
cmunell/micro-util | @ Override public Pair < L , Double > classifyWithScore ( D datum ) { if ( this . datumIndicator . indicator ( datum ) ) return this . method . classifyWithScore ( datum ) ; else return null ; }
cmunell/micro-util | @ Override public Map < D , Double > score ( DataSet < D , L > data , L label ) { DataSet < D , L > filteredData = data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . score ( filteredData , label ) ; }
cmunell/micro-util | @ Override public double score ( D datum , L label ) { if ( this . datumIndicator . indicator ( datum ) ) return this . method . score ( datum , label ) ; else return 0.0 ; }
webos21/xi | public Long ( long value ) { this . value = value ; }
webos21/xi | public Long ( String string ) throws NumberFormatException { this ( parseLong ( string ) ) ; }
webos21/xi | @ Override public byte byteValue ( ) { return ( byte ) value ; }
webos21/xi | public int compareTo ( Long object ) { long thisValue = this . value ; long thatValue = object . value ; return thisValue < thatValue ? - 1 : ( thisValue == thatValue ? 0 : 1 ) ; }
webos21/xi | @ Override public double doubleValue ( ) { return value ; }
webos21/xi | @ Override public boolean equals ( Object o ) { return o instanceof Long && ( ( Long ) o ) . value == value ; }
webos21/xi | @ Override public float floatValue ( ) { return value ; }
webos21/xi | @ Override public int hashCode ( ) { return ( int ) ( value ^ ( value >>> 32 ) ) ; }
webos21/xi | @ Override public int intValue ( ) { return ( int ) value ; }
webos21/xi | @ Override public long longValue ( ) { return value ; }
webos21/xi | @ Override public short shortValue ( ) { return ( short ) value ; }
webos21/xi | @ Override public String toString ( ) { return Long . toString ( value ) ; }
webos21/xi | i ++ ) { SMALL_VALUES [ i + 128 ] = new Long ( i ) ; }
apache/wicket | @ Test void testAdd ( ) { MockPageStore mockStore = new MockPageStore ( ) ; MockPageContext context = new MockPageContext ( ) ; RequestPageStore store = new RequestPageStore ( mockStore ) ; MockPage page1 = new MockPage ( 1 ) ; MockPage page2 = new MockPage ( 2 ) ; MockPage page3 = new MockPage ( 3 ) ; store . addPage ( context , page1 ) ; store . addPage ( context , page2 ) ; store . addPage ( context , page3 ) ; assertTrue ( mockStore . getPages ( ) . isEmpty ( ) , " no ▁ pages ▁ delegated ▁ before ▁ detach " ) ; store . detach ( context ) ; assertEquals ( 3 , mockStore . getPages ( ) . size ( ) , " pages ▁ delegated ▁ on ▁ detach " ) ; mockStore . getPages ( ) . clear ( ) ; assertNull ( store . getPage ( context , 1 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; assertNull ( store . getPage ( context , 2 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; assertNull ( store . getPage ( context , 3 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; }
apache/wicket | @ Test void testUntouch ( ) { MockPageStore mockStore = new MockPageStore ( ) ; MockPageContext context = new MockPageContext ( ) ; RequestPageStore store = new RequestPageStore ( mockStore ) ; MockPage page = new MockPage ( 1 ) ; store . addPage ( context , page ) ; store . revertPage ( context , page ) ; assertTrue ( mockStore . getPages ( ) . isEmpty ( ) , " no ▁ page ▁ delegated ▁ before ▁ detach " ) ; store . detach ( context ) ; assertEquals ( 0 , mockStore . getPages ( ) . size ( ) , " untouched ▁ page ▁ not ▁ delegated ▁ on ▁ detach " ) ; assertNull ( store . getPage ( context , 1 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; }
cuba-platform/cuba | @ AfterEach public void tearDown ( ) throws Exception { if ( userId != null ) cont . deleteRecord ( " SEC _ USER " , userId ) ; }
cuba-platform/cuba | @ Test public void testTransactions ( ) throws Exception { User user ; Group group ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; userId = user . getId ( ) ; user . setName ( " testUser " ) ; user . setLogin ( " testLogin " ) ; user . setGroup ( em . find ( Group . class , UUID . fromString ( "0fa2b1a5-1d68-4d69-9fbd - dff348347f93" ) ) ) ; em . persist ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . find ( User . class , userId ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; Query query = em . createQuery ( " select ▁ u ▁ from ▁ sec $ User ▁ u ▁ where ▁ u . id ▁ = ▁ ? 1" ) . setParameter ( 1 , userId ) ; user = ( User ) query . getFirstResult ( ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( group ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; user . setName ( " changed ▁ name " ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . merge ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
cuba-platform/cuba | @ Test public void testSerialization ( ) throws Exception { User user ; Group group ; user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; user = reserialize ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = new User ( ) ; userId = user . getId ( ) ; user . setName ( " testUser " ) ; user . setLogin ( " testLogin " ) ; user . setGroup ( em . find ( Group . class , UUID . fromString ( "0fa2b1a5-1d68-4d69-9fbd - dff348347f93" ) ) ) ; em . persist ( user ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . find ( User . class , userId ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( group ) ) ; user = reserialize ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } user . setName ( " changed ▁ name " ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . merge ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; user = reserialize ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
cuba-platform/cuba | @ Test public void testTransactionRollback_new ( ) throws Exception { User user = null ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; userId = user . getId ( ) ; cont . persistence ( ) . getEntityManager ( ) . persist ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; fail ( ) ; } catch ( Exception e ) { } finally { tx . end ( ) ; } assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
cuba-platform/cuba | @ Test public void testTransactionRollback_loaded ( ) { User user ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { user = cont . persistence ( ) . getEntityManager ( ) . find ( User . class , TestSupport . ADMIN_USER_ID ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
straniggtamas/swsv_lab1b | public Yytoken ( int type , Object value ) { this . type = type ; this . value = value ; }
straniggtamas/swsv_lab1b | public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; switch ( type ) { case TYPE_VALUE : sb . append ( " VALUE ( " ) . append ( value ) . append ( " ) " ) ; break ; case TYPE_LEFT_BRACE : sb . append ( " LEFT ▁ BRACE ( { ) " ) ; break ; case TYPE_RIGHT_BRACE : sb . append ( " RIGHT ▁ BRACE ( } ) " ) ; break ; case TYPE_LEFT_SQUARE : sb . append ( " LEFT ▁ SQUARE ( [ ) " ) ; break ; case TYPE_RIGHT_SQUARE : sb . append ( " RIGHT ▁ SQUARE ( ] ) " ) ; break ; case TYPE_COMMA : sb . append ( " COMMA ( , ) " ) ; break ; case TYPE_COLON : sb . append ( " COLON ( : ) " ) ; break ; case TYPE_EOF : sb . append ( " END ▁ OF ▁ FILE " ) ; break ; default : throw new IllegalStateException ( " Not ▁ a ▁ known ▁ type " ) ; } return sb . toString ( ) ; }
tita/tita | public ButtonEdit ( String id ) { super ( id ) ; }
GDG-Korea/holo_to_material | public Category ( Parcel in ) { category = in . readString ( ) ; Object [ ] objArrays = in . readArray ( Video . class . getClassLoader ( ) ) ; videos = new Video [ objArrays . length ] ; videos = Arrays . copyOf ( objArrays , objArrays . length , Video [ ] . class ) ; }
GDG-Korea/holo_to_material | @ Override public int describeContents ( ) { return 0 ; }
GDG-Korea/holo_to_material | @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeString ( category ) ; dest . writeArray ( videos ) ; }
GDG-Korea/holo_to_material | public void initVideos ( ) { for ( Video video : videos ) { video . setCateogry ( category ) ; video . description += " \n \n " + video . description . substring ( 30 ) + video . description . substring ( 50 ) ; } }
kingland/java-design-patterns | @ Test public void taskGeneratorTest ( ) { var msgQueue = new MessageQueue ( ) ; var taskRunnable = new TaskGenerator ( msgQueue , 1 ) ; var taskGenThr = new Thread ( taskRunnable ) ; taskGenThr . start ( ) ; var srvRunnable = new ServiceExecutor ( msgQueue ) ; var srvExeThr = new Thread ( srvRunnable ) ; srvExeThr . start ( ) ; }
andreagenso/java2scala | public ClientFactoryImpl ( ) { }
andreagenso/java2scala | public SaslClient createSaslClient ( String [ ] mechs , String authorizationId , String protocol , String serverName , Map < String , ? > props , CallbackHandler cbh ) throws SaslException { for ( int i = 0 ; i < mechs . length ; i ++ ) { if ( mechs [ i ] . equals ( myMechs [ EXTERNAL ] ) && PolicyUtils . checkPolicy ( mechPolicies [ EXTERNAL ] , props ) ) { return new ExternalClient ( authorizationId ) ; } else if ( mechs [ i ] . equals ( myMechs [ CRAMMD5 ] ) && PolicyUtils . checkPolicy ( mechPolicies [ CRAMMD5 ] , props ) ) { Object [ ] uinfo = getUserInfo ( " CRAM - MD5" , authorizationId , cbh ) ; return new CramMD5Client ( ( String ) uinfo [ 0 ] , ( byte [ ] ) uinfo [ 1 ] ) ; } else if ( mechs [ i ] . equals ( myMechs [ PLAIN ] ) && PolicyUtils . checkPolicy ( mechPolicies [ PLAIN ] , props ) ) { Object [ ] uinfo = getUserInfo ( " PLAIN " , authorizationId , cbh ) ; return new PlainClient ( authorizationId , ( String ) uinfo [ 0 ] , ( byte [ ] ) uinfo [ 1 ] ) ; } } return null ; }
andreagenso/java2scala | public String [ ] getMechanismNames ( Map < String , ? > props ) { return PolicyUtils . filterMechs ( myMechs , mechPolicies , props ) ; }
andreagenso/java2scala | private Object [ ] getUserInfo ( String prefix , String authorizationId , CallbackHandler cbh ) throws SaslException { if ( cbh == null ) { throw new SaslException ( " Callback ▁ handler ▁ to ▁ get ▁ username / password ▁ required " ) ; } try { String userPrompt = prefix + " ▁ authentication ▁ id : ▁ " ; String passwdPrompt = prefix + " ▁ password : ▁ " ; NameCallback ncb = authorizationId == null ? new NameCallback ( userPrompt ) : new NameCallback ( userPrompt , authorizationId ) ; PasswordCallback pcb = new PasswordCallback ( passwdPrompt , false ) ; cbh . handle ( new Callback [ ] { ncb , pcb } ) ; char [ ] pw = pcb . getPassword ( ) ; byte [ ] bytepw ; String authId ; if ( pw != null ) { bytepw = new String ( pw ) . getBytes ( " UTF8" ) ; pcb . clearPassword ( ) ; } else { bytepw = null ; } authId = ncb . getName ( ) ; return new Object [ ] { authId , bytepw } ; } catch ( IOException e ) { throw new SaslException ( " Cannot ▁ get ▁ password " , e ) ; } catch ( UnsupportedCallbackException e ) { throw new SaslException ( " Cannot ▁ get ▁ userid / password " , e ) ; } }
SomeFire/ignite | @ Override public void start ( ) throws IgniteCheckedException { if ( port <= 0 || port >= 0xffff ) throw new IpcEndpointBindException ( " Port ▁ value ▁ is ▁ illegal : ▁ " + port ) ; try { srvSock = new ServerSocket ( ) ; assert host != null ; srvSock . bind ( new InetSocketAddress ( U . resolveLocalHost ( host ) , port ) ) ; if ( log . isInfoEnabled ( ) ) log . info ( " IPC ▁ server ▁ loopback ▁ endpoint ▁ started ▁ [ port = " + port + ' ] ' ) ; } catch ( IOException e ) { if ( srvSock != null ) U . closeQuiet ( srvSock ) ; throw new IpcEndpointBindException ( " Failed ▁ to ▁ bind ▁ loopback ▁ IPC ▁ endpoint ▁ ( is ▁ port ▁ already ▁ in ▁ " + " use ? ) : ▁ " + port , e ) ; } }
SomeFire/ignite | @ Override public IpcEndpoint accept ( ) throws IgniteCheckedException { try { Socket sock = srvSock . accept ( ) ; return new IpcClientTcpEndpoint ( sock ) ; } catch ( IOException e ) { throw new IgniteCheckedException ( e ) ; } }
SomeFire/ignite | @ Override public void close ( ) { U . closeQuiet ( srvSock ) ; }
SomeFire/ignite | @ Override public int getPort ( ) { return port ; }
SomeFire/ignite | public void setPort ( int port ) { this . port = port ; }
SomeFire/ignite | @ Override public String getHost ( ) { return host ; }
SomeFire/ignite | public void setHost ( String host ) { this . host = host ; }
SomeFire/ignite | @ Override public boolean isManagement ( ) { return mgmt ; }
SomeFire/ignite | public void setManagement ( boolean mgmt ) { this . mgmt = mgmt ; }
SomeFire/ignite | @ Override public String toString ( ) { return S . toString ( IpcServerTcpEndpoint . class , this ) ; }
SomeFire/ignite | public void setupConfiguration ( Map < String , String > endpointCfg ) throws IgniteCheckedException { for ( Map . Entry < String , String > e : endpointCfg . entrySet ( ) ) { try { switch ( e . getKey ( ) ) { case " type " : break ; case " port " : setPort ( Integer . parseInt ( e . getValue ( ) ) ) ; break ; case " host " : setHost ( e . getValue ( ) ) ; break ; case " management " : setManagement ( Boolean . valueOf ( e . getValue ( ) ) ) ; break ; default : throw new IgniteCheckedException ( " Invalid ▁ property ▁ ' " + e . getKey ( ) + " ' ▁ of ▁ " + getClass ( ) . getSimpleName ( ) ) ; } } catch ( Throwable t ) { if ( t instanceof IgniteCheckedException || t instanceof Error ) throw t ; throw new IgniteCheckedException ( " Invalid ▁ value ▁ ' " + e . getValue ( ) + " ' ▁ of ▁ the ▁ property ▁ ' " + e . getKey ( ) + " ' ▁ in ▁ " + getClass ( ) . getSimpleName ( ) , t ) ; } } }
idea4bsd/idea4bsd | public VcsLogGraphTable ( @ NotNull VcsLogUiImpl ui , @ NotNull VcsLogData logData , @ NotNull VisiblePack initialDataPack ) { super ( new GraphTableModel ( initialDataPack , logData , ui ) ) ; getEmptyText ( ) . setText ( " Changes ▁ Log " ) ; myUi = ui ; myLogData = logData ; GraphCellPainter graphCellPainter = new SimpleGraphCellPainter ( new DefaultColorGenerator ( ) ) { @ Override protected int getRowHeight ( ) { return VcsLogGraphTable . this . getRowHeight ( ) ; } } ; myGraphCommitCellRenderer = new GraphCommitCellRenderer ( logData , graphCellPainter , this ) ; myStringCellRenderer = new StringCellRenderer ( ) ; myLogData . getProgress ( ) . addProgressIndicatorListener ( new MyProgressListener ( ) , ui ) ; setDefaultRenderer ( VirtualFile . class , new RootCellRenderer ( myUi ) ) ; setDefaultRenderer ( GraphCommitCell . class , myGraphCommitCellRenderer ) ; setDefaultRenderer ( String . class , myStringCellRenderer ) ; setShowHorizontalLines ( false ) ; setIntercellSpacing ( JBUI . emptySize ( ) ) ; setTableHeader ( new InvisibleResizableHeader ( ) ) ; myController = new GraphTableController ( this , ui , logData , graphCellPainter , myGraphCommitCellRenderer ) ; getSelectionModel ( ) . addListSelectionListener ( new MyListSelectionListener ( ) ) ; PopupHandler . installPopupHandler ( this , VcsLogActionPlaces . POPUP_ACTION_GROUP , VcsLogActionPlaces . VCS_LOG_TABLE_PLACE ) ; ScrollingUtil . installActions ( this , false ) ; initColumnSize ( ) ; addComponentListener ( new ComponentAdapter ( ) { @ Override public void componentResized ( ComponentEvent e ) { updateCommitColumnWidth ( ) ; } } ) ; }
idea4bsd/idea4bsd | public void updateDataPack ( @ NotNull VisiblePack visiblePack , boolean permGraphChanged ) { VcsLogGraphTable . Selection previousSelection = getSelection ( ) ; getModel ( ) . setVisiblePack ( visiblePack ) ; previousSelection . restore ( visiblePack . getVisibleGraph ( ) , true , permGraphChanged ) ; for ( VcsLogHighlighter highlighter : myHighlighters ) { highlighter . update ( visiblePack , permGraphChanged ) ; } setPaintBusy ( false ) ; initColumnSize ( ) ; }
idea4bsd/idea4bsd | boolean initColumnSize ( ) { if ( ! myColumnsSizeInitialized && getModel ( ) . getRowCount ( ) > 0 ) { myColumnsSizeInitialized = setColumnPreferredSize ( ) ; if ( myColumnsSizeInitialized ) { setAutoCreateColumnsFromModel ( false ) ; for ( int column = 0 ; column < getColumnCount ( ) ; column ++ ) { getColumnModel ( ) . getColumn ( column ) . setResizable ( column != GraphTableModel . ROOT_COLUMN ) ; } } return myColumnsSizeInitialized ; } return false ; }
idea4bsd/idea4bsd | private boolean setColumnPreferredSize ( ) { boolean sizeCalculated = false ; Font tableFont = UIManager . getFont ( " Table . font " ) ; for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { TableColumn column = getColumnModel ( ) . getColumn ( i ) ; if ( i == GraphTableModel . ROOT_COLUMN ) { setRootColumnSize ( column ) ; } else if ( i == GraphTableModel . AUTHOR_COLUMN ) { int maxRowsToCheck = Math . min ( MAX_ROWS_TO_CALC_WIDTH , getRowCount ( ) - MAX_ROWS_TO_CALC_OFFSET ) ; if ( maxRowsToCheck < 0 ) { maxRowsToCheck = getRowCount ( ) ; } int maxWidth = 0 ; for ( int row = 0 ; row < maxRowsToCheck ; row ++ ) { String value = getModel ( ) . getValueAt ( row , i ) . toString ( ) ; Font font = tableFont ; VcsLogHighlighter . TextStyle style = getStyle ( row , i , value , false , false ) . getTextStyle ( ) ; if ( BOLD . equals ( style ) ) { font = tableFont . deriveFont ( Font . BOLD ) ; } else if ( ITALIC . equals ( style ) ) { font = tableFont . deriveFont ( Font . ITALIC ) ; } maxWidth = Math . max ( getFontMetrics ( font ) . stringWidth ( value + " * " ) , maxWidth ) ; if ( ! value . isEmpty ( ) ) sizeCalculated = true ; } int min = Math . min ( maxWidth + myStringCellRenderer . getHorizontalTextPadding ( ) , JBUI . scale ( MAX_DEFAULT_AUTHOR_COLUMN_WIDTH ) ) ; column . setPreferredWidth ( min ) ; } else if ( i == GraphTableModel . DATE_COLUMN ) { int min = getFontMetrics ( tableFont . deriveFont ( Font . BOLD ) ) . stringWidth ( DateFormatUtil . formatDateTime ( new Date ( ) ) ) + myStringCellRenderer . getHorizontalTextPadding ( ) ; column . setPreferredWidth ( min ) ; } } updateCommitColumnWidth ( ) ; return sizeCalculated ; }
idea4bsd/idea4bsd | private void updateCommitColumnWidth ( ) { int size = getWidth ( ) ; for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { if ( i == GraphTableModel . COMMIT_COLUMN ) continue ; TableColumn column = getColumnModel ( ) . getColumn ( i ) ; size -= column . getPreferredWidth ( ) ; } TableColumn commitColumn = getColumnModel ( ) . getColumn ( GraphTableModel . COMMIT_COLUMN ) ; commitColumn . setPreferredWidth ( size ) ; }
idea4bsd/idea4bsd | private void setRootColumnSize ( @ NotNull TableColumn column ) { int rootWidth ; if ( ! myUi . isMultipleRoots ( ) ) { rootWidth = 0 ; } else if ( ! myUi . isShowRootNames ( ) ) { rootWidth = JBUI . scale ( ROOT_INDICATOR_WIDTH ) ; } else { rootWidth = Math . min ( calculateMaxRootWidth ( ) , JBUI . scale ( ROOT_NAME_MAX_WIDTH ) ) ; } column . setMinWidth ( rootWidth ) ; column . setMaxWidth ( rootWidth ) ; column . setPreferredWidth ( rootWidth ) ; }
idea4bsd/idea4bsd | private int calculateMaxRootWidth ( ) { int width = 0 ; for ( VirtualFile file : myLogData . getRoots ( ) ) { Font tableFont = UIManager . getFont ( " Table . font " ) ; width = Math . max ( getFontMetrics ( tableFont ) . stringWidth ( file . getName ( ) + " ▁ ▁ " ) , width ) ; } return width ; }
idea4bsd/idea4bsd | @ Override public String getToolTipText ( @ NotNull MouseEvent event ) { int row = rowAtPoint ( event . getPoint ( ) ) ; int column = columnAtPoint ( event . getPoint ( ) ) ; if ( column < 0 || row < 0 ) { return null ; } if ( column == GraphTableModel . ROOT_COLUMN ) { Object at = getValueAt ( row , column ) ; if ( at instanceof VirtualFile ) { return " < html > < b > " + ( ( VirtualFile ) at ) . getPresentableUrl ( ) + " < / b > < br / > Click ▁ to ▁ " + ( myUi . isShowRootNames ( ) ? " collapse " : " expand " ) + " < / html > " ; } } return null ; }
idea4bsd/idea4bsd | public void jumpToRow ( int rowIndex ) { if ( rowIndex >= 0 && rowIndex <= getRowCount ( ) - 1 ) { scrollRectToVisible ( getCellRect ( rowIndex , 0 , false ) ) ; setRowSelectionInterval ( rowIndex , rowIndex ) ; scrollRectToVisible ( getCellRect ( rowIndex , 0 , false ) ) ; } }
idea4bsd/idea4bsd | @ Nullable @ Override public Object getData ( @ NonNls String dataId ) { if ( PlatformDataKeys . COPY_PROVIDER . is ( dataId ) ) { return this ; } return null ; }
idea4bsd/idea4bsd | @ Override public void performCopy ( @ NotNull DataContext dataContext ) { VcsLog log = VcsLogDataKeys . VCS_LOG . getData ( dataContext ) ; if ( log == null ) return ; List < VcsFullCommitDetails > details = VcsLogUtil . collectFirstPackOfLoadedSelectedDetails ( log ) ; if ( details . isEmpty ( ) ) return ; String text = StringUtil . join ( details , commit -> getPresentableText ( commit , true ) , " \n " ) ; CopyPasteManager . getInstance ( ) . setContents ( new StringSelection ( text ) ) ; }
idea4bsd/idea4bsd | @ Override public boolean isCopyEnabled ( @ NotNull DataContext dataContext ) { return getSelectedRowCount ( ) > 0 ; }
idea4bsd/idea4bsd | @ Override public boolean isCopyVisible ( @ NotNull DataContext dataContext ) { return true ; }
idea4bsd/idea4bsd | public void addHighlighter ( @ NotNull VcsLogHighlighter highlighter ) { myHighlighters . add ( highlighter ) ; }
idea4bsd/idea4bsd | public void removeHighlighter ( @ NotNull VcsLogHighlighter highlighter ) { myHighlighters . remove ( highlighter ) ; }
idea4bsd/idea4bsd | public void removeAllHighlighters ( ) { myHighlighters . clear ( ) ; }
idea4bsd/idea4bsd | public SimpleTextAttributes applyHighlighters ( @ NotNull Component rendererComponent , int row , int column , String text , boolean hasFocus , final boolean selected ) { VcsLogHighlighter . VcsCommitStyle style = getStyle ( row , column , text , hasFocus , selected ) ; assert style . getBackground ( ) != null && style . getForeground ( ) != null && style . getTextStyle ( ) != null ; rendererComponent . setBackground ( style . getBackground ( ) ) ; rendererComponent . setForeground ( style . getForeground ( ) ) ; switch ( style . getTextStyle ( ) ) { case BOLD : return SimpleTextAttributes . REGULAR_BOLD_ATTRIBUTES ; case ITALIC : return SimpleTextAttributes . REGULAR_ITALIC_ATTRIBUTES ; default : } return SimpleTextAttributes . REGULAR_ATTRIBUTES ; }
idea4bsd/idea4bsd | public VcsLogHighlighter . VcsCommitStyle getBaseStyle ( int row , int column , String text , boolean hasFocus , boolean selected ) { Component dummyRendererComponent = myDummyRenderer . getTableCellRendererComponent ( this , text , selected , hasFocus , row , column ) ; return VcsCommitStyleFactory . createStyle ( dummyRendererComponent . getForeground ( ) , dummyRendererComponent . getBackground ( ) , VcsLogHighlighter . TextStyle . NORMAL ) ; }
idea4bsd/idea4bsd | private VcsLogHighlighter . VcsCommitStyle getStyle ( int row , int column , String text , boolean hasFocus , boolean selected ) { VcsLogHighlighter . VcsCommitStyle baseStyle = getBaseStyle ( row , column , text , hasFocus , selected ) ; VisibleGraph < Integer > visibleGraph = getVisibleGraph ( ) ; if ( row < 0 || row >= visibleGraph . getVisibleCommitCount ( ) ) { LOG . error ( " Visible ▁ graph ▁ has ▁ " + visibleGraph . getVisibleCommitCount ( ) + " ▁ commits , ▁ yet ▁ we ▁ want ▁ row ▁ " + row ) ; return baseStyle ; } RowInfo < Integer > rowInfo = visibleGraph . getRowInfo ( row ) ; VcsLogHighlighter . VcsCommitStyle defaultStyle = VcsCommitStyleFactory . createStyle ( rowInfo . getRowType ( ) == RowType . UNMATCHED ? JBColor . GRAY : baseStyle . getForeground ( ) , baseStyle . getBackground ( ) , VcsLogHighlighter . TextStyle . NORMAL ) ; final VcsShortCommitDetails details = myLogData . getMiniDetailsGetter ( ) . getCommitDataIfAvailable ( rowInfo . getCommit ( ) ) ; if ( details == null || details instanceof LoadingDetails ) return defaultStyle ; List < VcsLogHighlighter . VcsCommitStyle > styles = ContainerUtil . map ( myHighlighters , highlighter -> highlighter . getStyle ( details , selected ) ) ; return VcsCommitStyleFactory . combine ( ContainerUtil . append ( styles , defaultStyle ) ) ; }
idea4bsd/idea4bsd | public void viewportSet ( JViewport viewport ) { viewport . addChangeListener ( e -> { AbstractTableModel model = getModel ( ) ; Couple < Integer > visibleRows = ScrollingUtil . getVisibleRows ( this ) ; model . fireTableChanged ( new TableModelEvent ( model , visibleRows . first - 1 , visibleRows . second , GraphTableModel . ROOT_COLUMN ) ) ; } ) ; }
idea4bsd/idea4bsd | public void rootColumnUpdated ( ) { setRootColumnSize ( getColumnModel ( ) . getColumn ( GraphTableModel . ROOT_COLUMN ) ) ; updateCommitColumnWidth ( ) ; }
idea4bsd/idea4bsd | @ Override public void setCursor ( Cursor cursor ) { super . setCursor ( cursor ) ; Component layeredPane = UIUtil . findParentByCondition ( this , component -> component instanceof LoadingDecorator . CursorAware ) ; if ( layeredPane != null ) { layeredPane . setCursor ( cursor ) ; } }
idea4bsd/idea4bsd | @ Override @ NotNull public GraphTableModel getModel ( ) { return ( GraphTableModel ) super . getModel ( ) ; }
idea4bsd/idea4bsd | @ NotNull public Selection getSelection ( ) { if ( mySelection == null ) mySelection = new Selection ( this ) ; return mySelection ; }
idea4bsd/idea4bsd | public void handleAnswer ( @ Nullable GraphAnswer < Integer > answer , boolean dataCouldChange ) { myController . handleGraphAnswer ( answer , dataCouldChange , null , null ) ; }
idea4bsd/idea4bsd | public Selection ( @ NotNull VcsLogGraphTable table ) { myTable = table ; List < Integer > selectedRows = ContainerUtil . sorted ( Ints . asList ( myTable . getSelectedRows ( ) ) ) ; Couple < Integer > visibleRows = ScrollingUtil . getVisibleRows ( myTable ) ; myIsOnTop = visibleRows . first - 1 == 0 ; VisibleGraph < Integer > graph = myTable . getVisibleGraph ( ) ; mySelectedCommits = new TIntHashSet ( ) ; Integer visibleSelectedCommit = null ; Integer delta = null ; for ( int row : selectedRows ) { if ( row < graph . getVisibleCommitCount ( ) ) { Integer commit = graph . getRowInfo ( row ) . getCommit ( ) ; mySelectedCommits . add ( commit ) ; if ( visibleRows . first - 1 <= row && row <= visibleRows . second && visibleSelectedCommit == null ) { visibleSelectedCommit = commit ; delta = myTable . getCellRect ( row , 0 , false ) . y - myTable . getVisibleRect ( ) . y ; } } } if ( visibleSelectedCommit == null && visibleRows . first - 1 >= 0 ) { visibleSelectedCommit = graph . getRowInfo ( visibleRows . first - 1 ) . getCommit ( ) ; delta = myTable . getCellRect ( visibleRows . first - 1 , 0 , false ) . y - myTable . getVisibleRect ( ) . y ; } myVisibleSelectedCommit = visibleSelectedCommit ; myDelta = delta ; }
idea4bsd/idea4bsd | public void restore ( @ NotNull VisibleGraph < Integer > newVisibleGraph , boolean scrollToSelection , boolean permGraphChanged ) { Pair < TIntHashSet , Integer > toSelectAndScroll = findRowsToSelectAndScroll ( myTable . getModel ( ) , newVisibleGraph ) ; if ( ! toSelectAndScroll . first . isEmpty ( ) ) { myTable . getSelectionModel ( ) . setValueIsAdjusting ( true ) ; toSelectAndScroll . first . forEach ( row -> { myTable . addRowSelectionInterval ( row , row ) ; return true ; } ) ; myTable . getSelectionModel ( ) . setValueIsAdjusting ( false ) ; } if ( scrollToSelection ) { if ( myIsOnTop && permGraphChanged ) { scrollToRow ( 0 , 0 ) ; } else if ( toSelectAndScroll . second != null ) { assert myDelta != null ; scrollToRow ( toSelectAndScroll . second , myDelta ) ; } } }
idea4bsd/idea4bsd | private void scrollToRow ( Integer row , Integer delta ) { Rectangle startRect = myTable . getCellRect ( row , 0 , true ) ; myTable . scrollRectToVisible ( new Rectangle ( startRect . x , Math . max ( startRect . y - delta , 0 ) , startRect . width , myTable . getVisibleRect ( ) . height ) ) ; }
idea4bsd/idea4bsd | @ NotNull private Pair < TIntHashSet , Integer > findRowsToSelectAndScroll ( @ NotNull GraphTableModel model , @ NotNull VisibleGraph < Integer > visibleGraph ) { TIntHashSet rowsToSelect = new TIntHashSet ( ) ; if ( model . getRowCount ( ) == 0 ) { return Pair . create ( rowsToSelect , null ) ; } Integer rowToScroll = null ; for ( int row = 0 ; row < visibleGraph . getVisibleCommitCount ( ) && ( rowsToSelect . size ( ) < mySelectedCommits . size ( ) || rowToScroll == null ) ; row ++ ) { int commit = visibleGraph . getRowInfo ( row ) . getCommit ( ) ; if ( mySelectedCommits . contains ( commit ) ) { rowsToSelect . add ( row ) ; } if ( myVisibleSelectedCommit != null && myVisibleSelectedCommit == commit ) { rowToScroll = row ; } } return Pair . create ( rowsToSelect , rowToScroll ) ; }
idea4bsd/idea4bsd | @ NotNull public VisibleGraph < Integer > getVisibleGraph ( ) { return getModel ( ) . getVisiblePack ( ) . getVisibleGraph ( ) ; }
idea4bsd/idea4bsd | @ Override public TableCellEditor getCellEditor ( ) { return myDummyEditor ; }
idea4bsd/idea4bsd | @ Override public int getRowHeight ( ) { return myGraphCommitCellRenderer . getPreferredHeight ( ) ; }
idea4bsd/idea4bsd | @ Override protected void paintFooter ( @ NotNull Graphics g , int x , int y , int width , int height ) { int lastRow = getRowCount ( ) - 1 ; if ( lastRow >= 0 ) { g . setColor ( getStyle ( lastRow , GraphTableModel . COMMIT_COLUMN , " " , hasFocus ( ) , false ) . getBackground ( ) ) ; g . fillRect ( x , y , width , height ) ; if ( myUi . isMultipleRoots ( ) ) { g . setColor ( getRootBackgroundColor ( getModel ( ) . getRoot ( lastRow ) , myUi . getColorManager ( ) ) ) ; int rootWidth = getColumnModel ( ) . getColumn ( GraphTableModel . ROOT_COLUMN ) . getWidth ( ) ; if ( ! myUi . isShowRootNames ( ) ) rootWidth -= JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) ; g . fillRect ( x , y , rootWidth , height ) ; } } else { g . setColor ( getBaseStyle ( lastRow , GraphTableModel . COMMIT_COLUMN , " " , hasFocus ( ) , false ) . getBackground ( ) ) ; g . fillRect ( x , y , width , height ) ; } }
idea4bsd/idea4bsd | boolean isResizingColumns ( ) { return getCursor ( ) == Cursor . getPredefinedCursor ( Cursor . E_RESIZE_CURSOR ) ; }
idea4bsd/idea4bsd | RootCellRenderer ( @ NotNull VcsLogUiImpl ui ) { super ( " " , CENTER ) ; myUi = ui ; }
idea4bsd/idea4bsd | @ Override protected void paintComponent ( Graphics g ) { setFont ( UIManager . getFont ( " Table . font " ) ) ; g . setColor ( myColor ) ; int width = getWidth ( ) ; if ( isNarrow ) { g . fillRect ( 0 , 0 , width - JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) , myUi . getTable ( ) . getRowHeight ( ) ) ; g . setColor ( myBorderColor ) ; g . fillRect ( width - JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) , 0 , JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) , myUi . getTable ( ) . getRowHeight ( ) ) ; } else { g . fillRect ( 0 , 0 , width , myUi . getTable ( ) . getRowHeight ( ) ) ; } super . paintComponent ( g ) ; }
idea4bsd/idea4bsd | @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { String text ; Color color ; if ( value instanceof VirtualFile ) { VirtualFile root = ( VirtualFile ) value ; int readableRow = ScrollingUtil . getReadableRow ( table , Math . round ( myUi . getTable ( ) . getRowHeight ( ) * 0.5f ) ) ; if ( row < readableRow ) { text = " " ; } else if ( row == 0 || ! value . equals ( table . getModel ( ) . getValueAt ( row - 1 , column ) ) || readableRow == row ) { text = root . getName ( ) ; } else { text = " " ; } color = getRootBackgroundColor ( root , myUi . getColorManager ( ) ) ; } else { text = null ; color = UIUtil . getTableBackground ( isSelected ) ; } myColor = color ; Color background = ( ( VcsLogGraphTable ) table ) . getStyle ( row , column , text , hasFocus , isSelected ) . getBackground ( ) ; assert background != null ; myBorderColor = background ; setForeground ( UIUtil . getTableForeground ( false ) ) ; if ( myUi . isShowRootNames ( ) ) { setText ( text ) ; isNarrow = false ; } else { setText ( " " ) ; isNarrow = true ; } return this ; }
idea4bsd/idea4bsd | @ Override public void setBackground ( Color bg ) { myBorderColor = bg ; }
idea4bsd/idea4bsd | @ Override protected void customizeCellRenderer ( JTable table , Object value , boolean selected , boolean hasFocus , int row , int column ) { if ( value == null ) { return ; } append ( value . toString ( ) , applyHighlighters ( this , row , column , value . toString ( ) , hasFocus , selected ) ) ; }
idea4bsd/idea4bsd | public int getHorizontalTextPadding ( ) { Insets borderInsets = getMyBorder ( ) . getBorderInsets ( this ) ; Insets ipad = getIpad ( ) ; return borderInsets . left + borderInsets . right + ipad . left + ipad . right ; }
idea4bsd/idea4bsd | @ Override public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { return null ; }
idea4bsd/idea4bsd | @ Override public Object getCellEditorValue ( ) { return null ; }
idea4bsd/idea4bsd | @ Override public boolean isCellEditable ( EventObject anEvent ) { return false ; }
idea4bsd/idea4bsd | @ Override public boolean shouldSelectCell ( EventObject anEvent ) { if ( ! ( anEvent instanceof MouseEvent ) ) return true ; return myController . findPrintElement ( ( MouseEvent ) anEvent ) == null ; }
idea4bsd/idea4bsd | @ Override public boolean stopCellEditing ( ) { return false ; }
idea4bsd/idea4bsd | @ Override public void cancelCellEditing ( ) { }
idea4bsd/idea4bsd | @ Override public void addCellEditorListener ( CellEditorListener l ) { }
idea4bsd/idea4bsd | @ Override public void removeCellEditorListener ( CellEditorListener l ) { }
idea4bsd/idea4bsd | public InvisibleResizableHeader ( ) { myHeaderUI = new MyBasicTableHeaderUI ( this ) ; setDefaultRenderer ( new EmptyTableCellRenderer ( ) ) ; setReorderingAllowed ( false ) ; }
idea4bsd/idea4bsd | @ Override public void setTable ( JTable table ) { JTable oldTable = getTable ( ) ; if ( oldTable != null ) { oldTable . removeMouseListener ( myHeaderUI ) ; oldTable . removeMouseMotionListener ( myHeaderUI ) ; } super . setTable ( table ) ; if ( table != null ) { table . addMouseListener ( myHeaderUI ) ; table . addMouseMotionListener ( myHeaderUI ) ; } }
idea4bsd/idea4bsd | @ Override public void setCursor ( @ Nullable Cursor cursor ) { JTable table = getTable ( ) ; if ( table != null ) { table . setCursor ( cursor ) ; myCursor = cursor ; } else { super . setCursor ( cursor ) ; } }
idea4bsd/idea4bsd | @ Override public Cursor getCursor ( ) { if ( myCursor == null ) { JTable table = getTable ( ) ; if ( table == null ) return super . getCursor ( ) ; return table . getCursor ( ) ; } return myCursor ; }
idea4bsd/idea4bsd | @ NotNull @ Override public Rectangle getHeaderRect ( int column ) { Rectangle headerRect = super . getHeaderRect ( column ) ; return new Rectangle ( headerRect . x , headerRect . y , headerRect . width , 1 ) ; }
idea4bsd/idea4bsd | @ NotNull @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setMaximumSize ( new Dimension ( 0 , 0 ) ) ; return panel ; }
idea4bsd/idea4bsd | public MyBasicTableHeaderUI ( @ NotNull JTableHeader tableHeader ) { header = tableHeader ; mouseInputListener = createMouseInputListener ( ) ; }
idea4bsd/idea4bsd | @ NotNull private MouseEvent convertMouseEvent ( @ NotNull MouseEvent e ) { return new MouseEvent ( e . getComponent ( ) , e . getID ( ) , e . getWhen ( ) , e . getModifiers ( ) , e . getX ( ) , 0 , e . getXOnScreen ( ) , header . getY ( ) , e . getClickCount ( ) , e . isPopupTrigger ( ) , e . getButton ( ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseClicked ( @ NotNull MouseEvent e ) { }
idea4bsd/idea4bsd | @ Override public void mousePressed ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mousePressed ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseReleased ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mouseReleased ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseEntered ( @ NotNull MouseEvent e ) { }
idea4bsd/idea4bsd | @ Override public void mouseExited ( @ NotNull MouseEvent e ) { }
idea4bsd/idea4bsd | @ Override public void mouseDragged ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mouseDragged ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseMoved ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mouseMoved ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | public boolean isOnBorder ( @ NotNull MouseEvent e ) { return Math . abs ( header . getTable ( ) . getWidth ( ) - e . getPoint ( ) . x ) <= JBUI . scale ( 3 ) ; }
idea4bsd/idea4bsd | @ Override public void valueChanged ( ListSelectionEvent e ) { mySelection = null ; }
idea4bsd/idea4bsd | @ Override public void progressStarted ( ) { myText = getEmptyText ( ) . getText ( ) ; getEmptyText ( ) . setText ( " Loading ▁ History . . . " ) ; }
idea4bsd/idea4bsd | @ Override public void progressStopped ( ) { getEmptyText ( ) . setText ( myText ) ; }
uber/jaeger-client-java | @ Test public void testVersionGet ( ) { assertEquals ( " Version ▁ should ▁ be ▁ the ▁ same ▁ as ▁ the ▁ properties ▁ file " , JaegerTracer . getVersionFromProperties ( ) , Version . get ( ) ) ; assertNotEquals ( " The ▁ version ▁ from ▁ the ▁ tracer ▁ should ▁ not ▁ be ▁ the ▁ same ▁ string ▁ as ▁ Version . get ( ) " , new Configuration ( " testVersionGet " ) . getTracer ( ) . getVersion ( ) , Version . get ( ) ) ; }
CCI-MIT/XCoLab | public ProposalRatingWrapper ( org . xcolab . client . contest . pojo . wrapper . ProposalRatingWrapper proposalRating ) { this . proposalRating = proposalRating ; }
CCI-MIT/XCoLab | public ProposalRatingWrapper ( org . xcolab . client . contest . pojo . wrapper . ProposalRatingWrapper proposalRating , Long roundFactor ) { this . proposalRating = proposalRating ; this . roundFactor = roundFactor ; }
CCI-MIT/XCoLab | public ProposalRatingWrapper ( ) { }
CCI-MIT/XCoLab | public String getRatingValueName ( ) { IProposalRatingValue ratingValue = this . getRatingValue ( ) ; if ( ratingValue != null ) { return ratingValue . getName ( ) ; } else { return " " ; } }
CCI-MIT/XCoLab | public String getRatingTypeLabel ( ) { IProposalRatingType ratingType = this . getRatingType ( ) ; if ( ratingType != null ) { return ratingType . getLabel ( ) ; } else { return " " ; } }
CCI-MIT/XCoLab | public boolean getIsActive ( ) { IProposalRatingType ratingType = this . getRatingType ( ) ; if ( ratingType != null ) { return ratingType . isIsActive ( ) ; } else { return true ; } }
CCI-MIT/XCoLab | public Long getRatingTypeId ( ) { IProposalRatingType ratingType = this . getRatingType ( ) ; if ( ratingType != null ) { return ratingType . getId ( ) ; } else { return null ; } }
CCI-MIT/XCoLab | public IProposalRatingType getRatingType ( ) { IProposalRatingValue ratingValue = this . getRatingValue ( ) ; if ( ratingValue != null ) { if ( ratingType == null ) ratingType = StaticProposalContext . getProposalJudgeRatingClient ( ) . getProposalRatingType ( ratingValue . getRatingTypeId ( ) ) ; return ratingType ; } return null ; }
CCI-MIT/XCoLab | public IProposalRatingValue getRatingValue ( ) { if ( ratingValue == null ) if ( roundFactor == null ) { roundFactor = 1L ; } ratingValue = StaticProposalContext . getProposalJudgeRatingClient ( ) . getProposalRatingValue ( this . proposalRating . getRatingValueId ( ) / roundFactor ) ; return ratingValue ; }
CCI-MIT/XCoLab | public double getNotRoundedRatingValue ( ) { double ratingValueNotRounded = 0. ; try { if ( roundFactor == null ) { roundFactor = 1L ; } ratingValueNotRounded = ( double ) this . proposalRating . getRatingValueId ( ) / ( double ) roundFactor ; ratingValueNotRounded = ratingValueNotRounded / getRatingTypeId ( ) ; } catch ( Exception e ) { } return ratingValueNotRounded ; }
CCI-MIT/XCoLab | public String getNotRoundedRatingValueFormatted ( ) { DecimalFormat f = new DecimalFormat ( " # 0.0" ) ; return f . format ( getNotRoundedRatingValue ( ) ) ; }
CCI-MIT/XCoLab | public double getRatingValueInPercent ( ) { double ratingValueInPercent = 0 ; Double proposalRatingValue = getNotRoundedRatingValue ( ) ; if ( proposalRatingValue != null ) { ratingValueInPercent = proposalRatingValue / 5.0 * 100.0 ; } return ratingValueInPercent ; }
CCI-MIT/XCoLab | public org . xcolab . client . contest . pojo . wrapper . ProposalRatingWrapper unwrap ( ) { return proposalRating ; }
CCI-MIT/XCoLab | public void setRatingValueId ( Long id ) { this . proposalRating . setRatingValueId ( id ) ; }
apache/jena | protected Tuple5 ( X x1 , X x2 , X x3 , X x4 , X x5 ) { this . x1 = x1 ; this . x2 = x2 ; this . x3 = x3 ; this . x4 = x4 ; this . x5 = x5 ; }
apache/jena | @ Override public final X get ( int i ) { switch ( i ) { case 0 : return x1 ; case 1 : return x2 ; case 2 : return x3 ; case 3 : return x4 ; case 4 : return x5 ; } throw new IndexOutOfBoundsException ( ) ; }
apache/jena | @ Override public final int len ( ) { return 5 ; }
apache/jena | @ Override public < Y > Tuple < Y > map ( Function < X , Y > function ) { return new Tuple5 < > ( function . apply ( x1 ) , function . apply ( x2 ) , function . apply ( x3 ) , function . apply ( x4 ) , function . apply ( x5 ) ) ; }
apache/jena | @ Override public boolean contains ( X item ) { if ( Objects . equals ( x1 , item ) ) return true ; if ( Objects . equals ( x2 , item ) ) return true ; if ( Objects . equals ( x3 , item ) ) return true ; if ( Objects . equals ( x4 , item ) ) return true ; if ( Objects . equals ( x5 , item ) ) return true ; return false ; }
daiqiquan/framework-base | public boolean protect ( int socket ) { return NetworkUtils . protectFromVpn ( socket ) ; }
daiqiquan/framework-base | public boolean protect ( Socket socket ) { return protect ( socket . getFileDescriptor$ ( ) . getInt$ ( ) ) ; }
daiqiquan/framework-base | public boolean protect ( DatagramSocket socket ) { return protect ( socket . getFileDescriptor$ ( ) . getInt$ ( ) ) ; }
daiqiquan/framework-base | public boolean addAddress ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; try { return getService ( ) . addVpnAddress ( address . getHostAddress ( ) , prefixLength ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
daiqiquan/framework-base | public boolean removeAddress ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; try { return getService ( ) . removeVpnAddress ( address . getHostAddress ( ) , prefixLength ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
daiqiquan/framework-base | public boolean setUnderlyingNetworks ( Network [ ] networks ) { try { return getService ( ) . setUnderlyingNetworksForVpn ( networks ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
daiqiquan/framework-base | @ Override public IBinder onBind ( Intent intent ) { if ( intent != null && SERVICE_INTERFACE . equals ( intent . getAction ( ) ) ) { return new Callback ( ) ; } return null ; }
daiqiquan/framework-base | public void onRevoke ( ) { stopSelf ( ) ; }
daiqiquan/framework-base | @ Override protected boolean onTransact ( int code , Parcel data , Parcel reply , int flags ) { if ( code == IBinder . LAST_CALL_TRANSACTION ) { onRevoke ( ) ; return true ; } return false ; }
daiqiquan/framework-base | public Builder ( ) { mConfig . user = VpnService . this . getClass ( ) . getName ( ) ; }
daiqiquan/framework-base | public Builder setSession ( String session ) { mConfig . session = session ; return this ; }
daiqiquan/framework-base | public Builder setConfigureIntent ( PendingIntent intent ) { mConfig . configureIntent = intent ; return this ; }
daiqiquan/framework-base | public Builder setMtu ( int mtu ) { if ( mtu <= 0 ) { throw new IllegalArgumentException ( " Bad ▁ mtu " ) ; } mConfig . mtu = mtu ; return this ; }
daiqiquan/framework-base | public Builder addAddress ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; if ( address . isAnyLocalAddress ( ) ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } mAddresses . add ( new LinkAddress ( address , prefixLength ) ) ; mConfig . updateAllowedFamilies ( address ) ; return this ; }
daiqiquan/framework-base | public Builder addAddress ( String address , int prefixLength ) { return addAddress ( InetAddress . parseNumericAddress ( address ) , prefixLength ) ; }
daiqiquan/framework-base | public Builder addRoute ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; int offset = prefixLength / 8 ; byte [ ] bytes = address . getAddress ( ) ; if ( offset < bytes . length ) { for ( bytes [ offset ] <<= prefixLength % 8 ; offset < bytes . length ; ++ offset ) { if ( bytes [ offset ] != 0 ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } } } mRoutes . add ( new RouteInfo ( new IpPrefix ( address , prefixLength ) , null ) ) ; mConfig . updateAllowedFamilies ( address ) ; return this ; }
daiqiquan/framework-base | public Builder addRoute ( String address , int prefixLength ) { return addRoute ( InetAddress . parseNumericAddress ( address ) , prefixLength ) ; }
daiqiquan/framework-base | public Builder addDnsServer ( InetAddress address ) { if ( address . isLoopbackAddress ( ) || address . isAnyLocalAddress ( ) ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } if ( mConfig . dnsServers == null ) { mConfig . dnsServers = new ArrayList < String > ( ) ; } mConfig . dnsServers . add ( address . getHostAddress ( ) ) ; return this ; }
daiqiquan/framework-base | public Builder addDnsServer ( String address ) { return addDnsServer ( InetAddress . parseNumericAddress ( address ) ) ; }
daiqiquan/framework-base | public Builder addSearchDomain ( String domain ) { if ( mConfig . searchDomains == null ) { mConfig . searchDomains = new ArrayList < String > ( ) ; } mConfig . searchDomains . add ( domain ) ; return this ; }
daiqiquan/framework-base | public Builder allowFamily ( int family ) { if ( family == AF_INET ) { mConfig . allowIPv4 = true ; } else if ( family == AF_INET6 ) { mConfig . allowIPv6 = true ; } else { throw new IllegalArgumentException ( family + " ▁ is ▁ neither ▁ " + AF_INET + " ▁ nor ▁ " + AF_INET6 ) ; } return this ; }
daiqiquan/framework-base | catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; }
daiqiquan/framework-base | if ( mConfig . disallowedApplications != null ) { throw new UnsupportedOperationException ( " addDisallowedApplication ▁ already ▁ called " ) ; }
daiqiquan/framework-base | if ( mConfig . allowedApplications == null ) { mConfig . allowedApplications = new ArrayList < String > ( ) ; }
daiqiquan/framework-base | if ( mConfig . allowedApplications != null ) { throw new UnsupportedOperationException ( " addAllowedApplication ▁ already ▁ called " ) ; }
daiqiquan/framework-base | if ( mConfig . disallowedApplications == null ) { mConfig . disallowedApplications = new ArrayList < String > ( ) ; }
daiqiquan/framework-base | public Builder allowBypass ( ) { mConfig . allowBypass = true ; return this ; }
daiqiquan/framework-base | public Builder setBlocking ( boolean blocking ) { mConfig . blocking = blocking ; return this ; }
daiqiquan/framework-base | public Builder setUnderlyingNetworks ( Network [ ] networks ) { mConfig . underlyingNetworks = networks != null ? networks . clone ( ) : null ; return this ; }
daiqiquan/framework-base | public ParcelFileDescriptor establish ( ) { mConfig . addresses = mAddresses ; mConfig . routes = mRoutes ; try { return getService ( ) . establishVpn ( mConfig ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
selenareneephillips/brixen | @ Override public boolean getClickWithJavascript ( ) { return clickWithJavascript ; }
Syncleus/AetherMUD | public InventoryCommand ( GameManager gameManager ) { super ( gameManager , validTriggers , description , correctUsage ) ; }
Syncleus/AetherMUD | @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { this . execCommand ( ctx , e , ( ) -> { List < ItemInstance > inventory = player . getInventory ( ) ; if ( inventory == null ) { write ( " You ▁ aren ' t ▁ carrying ▁ anything . " ) ; return ; } StringBuilder inventoryString = new StringBuilder ( ) ; inventoryString . append ( " You ▁ are ▁ carrying : \r \n " ) ; inventoryString . append ( RESET ) ; String join = StringUtils . join ( player . getRolledUpIntentory ( ) . toArray ( ) , " \r \n " ) ; inventoryString . append ( join ) ; write ( inventoryString . toString ( ) ) ; } ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldSucceedWithName ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " fileHierarchy " ) ; thenAssertionIsSucceeded ( ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldFailWithDifferentName ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " fileHierarchy1" ) ; thenAssertionIsFailed ( ) . hasMessage ( String . format ( " \n Expecting : \n ▁ < % s > \n to ▁ have : \n ▁ < file ▁ name : ▁ fileHierarchy1 > " , preparePath ( ) ) ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldSucceedWithRegexInAssert ( ) { givenFileHierarchyAssert ( NameMatcherType . REGEX ) ; whenHasRootDirWithName ( " f . l [ eE ] Hierar . + " ) ; thenAssertionIsSucceeded ( ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldFailWithUnmatchingRegexInAssert ( ) { givenFileHierarchyAssert ( NameMatcherType . REGEX ) ; whenHasRootDirWithName ( " f . l [ eE ] Hirar . + " ) ; thenAssertionIsFailed ( ) . hasMessage ( String . format ( " \n Expecting : \n ▁ < % s > \n to ▁ have : \n ▁ < file ▁ name : ▁ f . l [ eE ] Hirar . + > " , preparePath ( ) ) ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldSucceedWithRegexInMethod ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " f . l [ eE ] Hierar . + " , NameMatcherType . REGEX ) ; thenAssertionIsSucceeded ( ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldFailWithUnmatchingRegexInMethod ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " f . l [ eE ] Hirar . + " , NameMatcherType . REGEX ) ; thenAssertionIsFailed ( ) . hasMessage ( String . format ( " \n Expecting : \n ▁ < % s > \n to ▁ have : \n ▁ < file ▁ name : ▁ f . l [ eE ] Hirar . + > " , preparePath ( ) ) ) ; }
pkk82/file-hierarchy-assert | private void whenHasRootDirWithName ( String rootDirName ) { try { fileHierarchyAssert . hasRootDirWithName ( rootDirName ) ; } catch ( AssertionError e ) { handleAssertionError ( e ) ; } }
pkk82/file-hierarchy-assert | private void whenHasRootDirWithName ( String rootDirName , NameMatcherType nameMatcherType ) { try { fileHierarchyAssert . hasRootDirWithName ( rootDirName , nameMatcherType ) ; } catch ( AssertionError e ) { handleAssertionError ( e ) ; } }
aaronwalker/camel | public ResourceBasedEndpoint ( ) { }
aaronwalker/camel | public ResourceBasedEndpoint ( String endpointUri , Component component , String resourceUri , Processor processor ) { super ( endpointUri , component , processor ) ; this . resourceUri = resourceUri ; if ( component instanceof ResourceBasedComponent ) { this . resourceLoader = ( ( ResourceBasedComponent ) component ) . getResourceLoader ( ) ; } }
aaronwalker/camel | protected ResourceBasedEndpoint ( String endpointUri , Processor processor , String resourceUri ) { super ( endpointUri , processor ) ; this . resourceUri = resourceUri ; }
aaronwalker/camel | public Resource getResource ( ) { if ( resource == null ) { log . debug ( " Loading ▁ resource : ▁ { } ▁ using : ▁ { } " , resourceUri , getResourceLoader ( ) ) ; resource = getResourceLoader ( ) . getResource ( resourceUri ) ; if ( resource == null ) { throw new IllegalArgumentException ( " Could ▁ not ▁ find ▁ resource ▁ for ▁ URI : ▁ " + resourceUri + " ▁ using : ▁ " + getResourceLoader ( ) ) ; } } return resource ; }
aaronwalker/camel | public InputStream getResourceAsInputStream ( ) throws IOException { if ( resource == null ) { resource = getResource ( ) ; } InputStream is = null ; if ( contentCache ) { synchronized ( resource ) { if ( buffer == null ) { log . debug ( " Reading ▁ resource : ▁ { } ▁ into ▁ the ▁ content ▁ cache " , resourceUri ) ; is = getResourceAsInputStreamWithoutCache ( ) ; buffer = IOConverter . toBytes ( is ) ; } } log . debug ( " Using ▁ resource : ▁ { } ▁ from ▁ the ▁ content ▁ cache " , resourceUri ) ; return new ByteArrayInputStream ( buffer ) ; } return getResourceAsInputStreamWithoutCache ( ) ; }
aaronwalker/camel | protected InputStream getResourceAsInputStreamWithoutCache ( ) throws IOException { InputStream result ; try { result = resource . getInputStream ( ) ; } catch ( IOException exception ) { result = getCamelContext ( ) . getClassResolver ( ) . loadResourceAsStream ( resourceUri ) ; if ( result == null ) { log . warn ( " Cannot ▁ get ▁ the ▁ resource : ▁ " + resourceUri + " from ▁ the ▁ camelContext ▁ ClassResolver " ) ; throw exception ; } } return result ; }
aaronwalker/camel | public boolean isContentCache ( ) { return contentCache ; }
aaronwalker/camel | public void setContentCache ( boolean contentCache ) { this . contentCache = contentCache ; }
aaronwalker/camel | public ResourceLoader getResourceLoader ( ) { if ( resourceLoader == null ) { resourceLoader = new CamelResourceLoader ( getCamelContext ( ) ) ; } return resourceLoader ; }
aaronwalker/camel | public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; }
aaronwalker/camel | public String getResourceUri ( ) { return resourceUri ; }
aaronwalker/camel | public void setResourceUri ( String resourceUri ) { this . resourceUri = resourceUri ; }
StefanLiebenberg/throwable-interfaces | @ Test ( expected = CustomException . class ) public void testUnwrap ( ) throws CustomException { CustomException expected = new CustomException ( ) ; SuppressedException . unwrapSuppressedException ( ( ) -> { return castToDoubleFunctionWithThrowable ( ( v1 ) -> { throw expected ; } ) . applyAsDouble ( null ) ; } , CustomException . class ) ; }
apache/ant-ivy | @ Test public void testComparator ( ) { ArtifactInfo [ ] revs = toMockAI ( new String [ ] { "0.2.0 . a " , "0.2.0 . b " , "0.2.0 . final " , "1.0" , "1.0.0 . gamma " , "1.0.0 . rc1" , "1.0.0 . rc2" , "1.0.1" , "2" , "2.0.0 . b006" , "2.0.0 . b012" , "2.0.0 . xyz " } ) ; List < ArtifactInfo > shuffled = new ArrayList < > ( Arrays . asList ( revs ) ) ; Collections . shuffle ( shuffled ) ; Collections . sort ( shuffled , new OsgiLatestStrategy ( ) . new ArtifactInfoComparator ( ) ) ; assertEquals ( Arrays . asList ( revs ) , shuffled ) ; }
apache/ant-ivy | @ Test public void testSort ( ) { ArtifactInfo [ ] revs = toMockAI ( new String [ ] { "0.2.0 . a " , "0.2.0 . b " , "0.2.0 . final " , "1.0" , "1.0.0 . gamma " , "1.0.0 . rc1" , "1.0.0 . rc2" , "1.0.1" , "2" , "2.0.0 . b006" , "2.0.0 . b012" , "2.0.0 . xyz " } ) ; List < ArtifactInfo > shuffled = new ArrayList < > ( Arrays . asList ( revs ) ) ; ArtifactInfo [ ] shuffledRevs = shuffled . toArray ( new ArtifactInfo [ revs . length ] ) ; OsgiLatestStrategy latestRevisionStrategy = new OsgiLatestStrategy ( ) ; List < ArtifactInfo > sorted = latestRevisionStrategy . sort ( shuffledRevs ) ; assertEquals ( Arrays . asList ( revs ) , sorted ) ; }
apache/ant-ivy | @ Test public void testFindLatest ( ) { ArtifactInfo [ ] revs = toMockAI ( new String [ ] { "0.2.0 . a " , "0.2.0 . b " , "0.2.0 . rc1" , "0.2.0 . final " , "1.0.0 . dev1" , "1.0.0 . dev2" , "1.0.0 . alpha1" , "1.0.0 . alpha2" , "1.0.0 . beta1" , "1.0.0 . beta2" , "1.0.0 . gamma " , "1.0.0 . rc1" , "1.0.0 . rc2" , "1.0" , "1.0.1" , "2.0" } ) ; List < ArtifactInfo > shuffled = new ArrayList < > ( Arrays . asList ( revs ) ) ; Collections . shuffle ( shuffled ) ; ArtifactInfo [ ] shuffledRevs = shuffled . toArray ( new ArtifactInfo [ revs . length ] ) ; OsgiLatestStrategy latestRevisionStrategy = new OsgiLatestStrategy ( ) ; ArtifactInfo latest = latestRevisionStrategy . findLatest ( shuffledRevs , new Date ( ) ) ; assertNotNull ( latest ) ; assertEquals ( "2.0" , latest . getRevision ( ) ) ; }
apache/ant-ivy | public MockArtifactInfo ( String rev , long lastModified ) { this . rev = rev ; this . lastModified = lastModified ; }
apache/ant-ivy | public String getRevision ( ) { return rev ; }
apache/ant-ivy | public long getLastModified ( ) { return lastModified ; }
apache/ant-ivy | public String toString ( ) { return rev ; }
apache/ant-ivy | private ArtifactInfo [ ] toMockAI ( String [ ] revs ) { List < ArtifactInfo > artifactInfos = new ArrayList < > ( ) ; for ( String rev : revs ) { artifactInfos . add ( new MockArtifactInfo ( rev , 0 ) ) ; } return artifactInfos . toArray ( new ArtifactInfo [ artifactInfos . size ( ) ] ) ; }
dagnir/aws-sdk-java | public void setType ( String type ) { this . type = type ; }
dagnir/aws-sdk-java | public String getType ( ) { return this . type ; }
dagnir/aws-sdk-java | public BatchReadException withType ( String type ) { setType ( type ) ; return this ; }
dagnir/aws-sdk-java | public void setType ( BatchReadExceptionType type ) { this . type = type . toString ( ) ; }
dagnir/aws-sdk-java | public BatchReadException withType ( BatchReadExceptionType type ) { setType ( type ) ; return this ; }
dagnir/aws-sdk-java | public void setMessage ( String message ) { this . message = message ; }
dagnir/aws-sdk-java | public String getMessage ( ) { return this . message ; }
dagnir/aws-sdk-java | public BatchReadException withMessage ( String message ) { setMessage ( message ) ; return this ; }
dagnir/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getType ( ) != null ) sb . append ( " Type : ▁ " ) . append ( getType ( ) ) . append ( " , " ) ; if ( getMessage ( ) != null ) sb . append ( " Message : ▁ " ) . append ( getMessage ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dagnir/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof BatchReadException == false ) return false ; BatchReadException other = ( BatchReadException ) obj ; if ( other . getType ( ) == null ^ this . getType ( ) == null ) return false ; if ( other . getType ( ) != null && other . getType ( ) . equals ( this . getType ( ) ) == false ) return false ; if ( other . getMessage ( ) == null ^ this . getMessage ( ) == null ) return false ; if ( other . getMessage ( ) != null && other . getMessage ( ) . equals ( this . getMessage ( ) ) == false ) return false ; return true ; }
dagnir/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getType ( ) == null ) ? 0 : getType ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMessage ( ) == null ) ? 0 : getMessage ( ) . hashCode ( ) ) ; return hashCode ; }
dagnir/aws-sdk-java | @ Override public BatchReadException clone ( ) { try { return ( BatchReadException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
dagnir/aws-sdk-java | @ com . amazonaws . annotation . SdkInternalApi @ Override public void marshall ( ProtocolMarshaller protocolMarshaller ) { com . amazonaws . services . clouddirectory . model . transform . BatchReadExceptionMarshaller . getInstance ( ) . marshall ( this , protocolMarshaller ) ; }
1245816264/android-ndk | private int nextPOT ( int i ) { int pot = 1 ; while ( pot < i ) pot <<= 1 ; return pot ; }
1245816264/android-ndk | private Bitmap scaleBitmap ( Bitmap bitmapToScale , float newWidth , float newHeight ) { if ( bitmapToScale == null ) return null ; int width = bitmapToScale . getWidth ( ) ; int height = bitmapToScale . getHeight ( ) ; Matrix matrix = new Matrix ( ) ; matrix . postScale ( newWidth / width , newHeight / height ) ; return Bitmap . createBitmap ( bitmapToScale , 0 , 0 , bitmapToScale . getWidth ( ) , bitmapToScale . getHeight ( ) , matrix , true ) ; }
1245816264/android-ndk | public boolean loadTexture ( String path ) { Bitmap bitmap = null ; try { String str = path ; if ( ! path . startsWith ( " / " ) ) { str = " / " + path ; } File file = new File ( context . getExternalFilesDir ( null ) , str ) ; if ( file . canRead ( ) ) { bitmap = BitmapFactory . decodeStream ( new FileInputStream ( file ) ) ; } else { bitmap = BitmapFactory . decodeStream ( context . getResources ( ) . getAssets ( ) . open ( path ) ) ; } } catch ( Exception e ) { Log . w ( " NDKHelper " , " Coundn ' t ▁ load ▁ a ▁ file : " + path ) ; return false ; } if ( bitmap != null ) { GLUtils . texImage2D ( GL10 . GL_TEXTURE_2D , 0 , bitmap , 0 ) ; } return true ; }
1245816264/android-ndk | public Bitmap openBitmap ( String path , boolean iScalePOT ) { Bitmap bitmap = null ; try { bitmap = BitmapFactory . decodeStream ( context . getResources ( ) . getAssets ( ) . open ( path ) ) ; if ( iScalePOT ) { int originalWidth = getBitmapWidth ( bitmap ) ; int originalHeight = getBitmapHeight ( bitmap ) ; int width = nextPOT ( originalWidth ) ; int height = nextPOT ( originalHeight ) ; if ( originalWidth != width || originalHeight != height ) { bitmap = scaleBitmap ( bitmap , width , height ) ; } } } catch ( Exception e ) { Log . w ( " NDKHelper " , " Coundn ' t ▁ load ▁ a ▁ file : " + path ) ; } return bitmap ; }
1245816264/android-ndk | public int getBitmapWidth ( Bitmap bmp ) { return bmp . getWidth ( ) ; }
1245816264/android-ndk | public int getBitmapHeight ( Bitmap bmp ) { return bmp . getHeight ( ) ; }
1245816264/android-ndk | public void getBitmapPixels ( Bitmap bmp , int [ ] pixels ) { int w = bmp . getWidth ( ) ; int h = bmp . getHeight ( ) ; bmp . getPixels ( pixels , 0 , w , 0 , 0 , w , h ) ; }
1245816264/android-ndk | public void closeBitmap ( Bitmap bmp ) { bmp . recycle ( ) ; }
1245816264/android-ndk | @ TargetApi ( 17 ) public int getNativeAudioBufferSize ( ) { int SDK_INT = android . os . Build . VERSION . SDK_INT ; if ( SDK_INT >= 17 ) { AudioManager am = ( AudioManager ) context . getSystemService ( Context . AUDIO_SERVICE ) ; String framesPerBuffer = am . getProperty ( AudioManager . PROPERTY_OUTPUT_FRAMES_PER_BUFFER ) ; return Integer . parseInt ( framesPerBuffer ) ; } else { return 0 ; } }
1245816264/android-ndk | public int getNativeAudioSampleRate ( ) { return AudioTrack . getNativeOutputSampleRate ( AudioManager . STREAM_SYSTEM ) ; }
GunoH/intellij-community | @ Override @ NotNull protected String buildErrorString ( Object ... infos ) { return InspectionGadgetsBundle . message ( " instanceof . catch . parameter . problem . descriptor " ) ; }
GunoH/intellij-community | @ Override public BaseInspectionVisitor buildVisitor ( ) { return new InstanceofCatchParameterVisitor ( ) ; }
GunoH/intellij-community | @ Override public void visitInstanceOfExpression ( @ NotNull PsiInstanceOfExpression exp ) { super . visitInstanceOfExpression ( exp ) ; if ( ! ControlFlowUtils . isInCatchBlock ( exp ) ) { return ; } PsiTypeElement typeElement = exp . getCheckType ( ) ; if ( typeElement == null || ! InheritanceUtil . isInheritor ( typeElement . getType ( ) , CommonClassNames . JAVA_LANG_THROWABLE ) ) { return ; } final PsiExpression operand = PsiUtil . skipParenthesizedExprDown ( exp . getOperand ( ) ) ; if ( ! ( operand instanceof PsiReferenceExpression ) ) { return ; } final PsiReferenceExpression ref = ( PsiReferenceExpression ) operand ; final PsiElement referent = ref . resolve ( ) ; if ( ! ( referent instanceof PsiParameter ) ) { return ; } final PsiParameter parameter = ( PsiParameter ) referent ; if ( ! ( parameter . getDeclarationScope ( ) instanceof PsiCatchSection ) ) { return ; } registerError ( operand ) ; }
googleapis/google-api-java-client-services | public java . lang . String getDescription ( ) { return description ; }
googleapis/google-api-java-client-services | public GoogleCloudVideointelligenceV1p3beta1Entity setDescription ( java . lang . String description ) { this . description = description ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getEntityId ( ) { return entityId ; }
googleapis/google-api-java-client-services | public GoogleCloudVideointelligenceV1p3beta1Entity setEntityId ( java . lang . String entityId ) { this . entityId = entityId ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getLanguageCode ( ) { return languageCode ; }
googleapis/google-api-java-client-services | public GoogleCloudVideointelligenceV1p3beta1Entity setLanguageCode ( java . lang . String languageCode ) { this . languageCode = languageCode ; return this ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudVideointelligenceV1p3beta1Entity set ( String fieldName , Object value ) { return ( GoogleCloudVideointelligenceV1p3beta1Entity ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudVideointelligenceV1p3beta1Entity clone ( ) { return ( GoogleCloudVideointelligenceV1p3beta1Entity ) super . clone ( ) ; }
mgraf1/gol | public GOLPannel ( int w , int h ) { width = w ; height = h ; d = new VDataArray ( width , height ) ; }
mgraf1/gol | public void runSim ( final int steps ) { final GOLPannel gp = this ; Thread r = new Thread ( ) { public void run ( ) { d . run ( steps , gp ) ; } } ; r . start ( ) ; try { r . join ( ) ; } catch ( InterruptedException e ) { System . exit ( 1 ) ; } System . exit ( 0 ) ; }
mgraf1/gol | public void drawBoard ( Graphics g ) { boolean [ ] [ ] grid = d . getGrid ( ) ; for ( int j = 0 ; j < height ; j ++ ) { for ( int i = 0 ; i < width ; i ++ ) { if ( grid [ j ] [ i ] ) { g . setColor ( Color . black ) ; g . drawRect ( i , j , 1 , 1 ) ; } else { g . setColor ( Color . white ) ; g . drawRect ( i , j , 1 , 1 ) ; } } } }
mgraf1/gol | public Dimension getPreferredSize ( ) { return new Dimension ( width , height ) ; }
mgraf1/gol | public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; drawBoard ( g ) ; }
mgraf1/gol | public void update ( Graphics g ) { drawBoard ( g ) ; }
seriousbusinessbe/XMLModifier | public DocumentException ( final String message ) { super ( message ) ; }
apache/incubator-taverna-common-activities | public InteractionActivity ( final CredentialManager credentialManager , final InteractionRecorder interactionRecorder , final InteractionUtils interactionUtils , final InteractionJetty interactionJetty , final InteractionPreference interactionPreference , final ResponseFeedListener responseFeedListener , final InteractionVelocity interactionVelocity ) { this . credentialManager = credentialManager ; this . interactionRecorder = interactionRecorder ; this . interactionUtils = interactionUtils ; this . interactionJetty = interactionJetty ; this . interactionPreference = interactionPreference ; this . responseFeedListener = responseFeedListener ; this . interactionVelocity = interactionVelocity ; this . json = null ; }
apache/incubator-taverna-common-activities | @ Override public void configure ( final JsonNode json ) throws ActivityConfigurationException { this . json = json ; }
apache/incubator-taverna-common-activities | @ Override public void executeAsynch ( final Map < String , T2Reference > inputs , final AsynchronousActivityCallback callback ) { final InteractionRequestor requestor = new InteractionCallbackRequestor ( this , callback , inputs ) ; callback . requestRun ( new InteractionActivityRunnable ( requestor , this . presentationTemplate , this . credentialManager , this . interactionRecorder , this . interactionUtils , this . interactionJetty , this . interactionPreference , this . responseFeedListener , this . interactionVelocity ) ) ; }
apache/incubator-taverna-common-activities | @ Override public JsonNode getConfiguration ( ) { return this . json ; }
apache/incubator-taverna-common-activities | public ActivityInputPort getInputPort ( final String name ) { for ( final ActivityInputPort port : this . getInputPorts ( ) ) { if ( port . getName ( ) . equals ( name ) ) { return port ; } } return null ; }
apache/incubator-taverna-common-activities | InteractionActivityType getInteractionActivityType ( ) { JsonNode subNode = json . get ( " interactivityActivityType " ) ; if ( subNode == null ) { return InteractionActivityType . LocallyPresentedHtml ; } String textValue = subNode . textValue ( ) ; if ( textValue == null ) { return InteractionActivityType . LocallyPresentedHtml ; } if ( " VelocityTemplate " . equals ( textValue ) ) { return InteractionActivityType . VelocityTemplate ; } return InteractionActivityType . LocallyPresentedHtml ; }
apache/incubator-taverna-common-activities | String getPresentationOrigin ( ) { JsonNode subNode = json . get ( " presentationOrigin " ) ; if ( subNode == null ) { return null ; } String textValue = subNode . textValue ( ) ; if ( textValue == null ) { return null ; } return textValue ; }
apache/incubator-taverna-common-activities | public boolean isProgressNotification ( ) { JsonNode subNode = json . get ( " progressNotification " ) ; if ( subNode == null ) { return false ; } return subNode . booleanValue ( ) ; }
triathematician/blaisemath | public NodeInGraph ( E node , @ Nullable Graph < E > graph ) { this . node = requireNonNull ( node ) ; this . graph = graph ; checkArgument ( graph == null || graph . nodes ( ) . contains ( node ) ) ; }
triathematician/blaisemath | public E getNode ( ) { return node ; }
triathematician/blaisemath | public @ Nullable Graph < E > getGraph ( ) { return graph ; }
StephanEwen/incubator-flink | @ Before public void before ( ) { this . streamSettings = EnvironmentSettings . inStreamingMode ( ) ; this . batchSettings = EnvironmentSettings . inBatchMode ( ) ; }
micmiu/bigdata-tutorial | private SimpleHiveConnManager ( ) { init ( ) ; }
micmiu/bigdata-tutorial | public void freeConnection ( String name , Connection con ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { pool . freeConnection ( con ) ; } }
micmiu/bigdata-tutorial | public Connection getConnection ( String name ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { return pool . getConnection ( ) ; } return null ; }
micmiu/bigdata-tutorial | public Connection getConnection ( String name , long time ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { return pool . getConnection ( time ) ; } return null ; }
micmiu/bigdata-tutorial | public synchronized void release ( ) { if ( -- clients != 0 ) { return ; } Enumeration allPools = pools . elements ( ) ; while ( allPools . hasMoreElements ( ) ) { ConnPool pool = ( ConnPool ) allPools . nextElement ( ) ; pool . release ( ) ; } Enumeration allDrivers = drivers . elements ( ) ; while ( allDrivers . hasMoreElements ( ) ) { Driver driver = ( Driver ) allDrivers . nextElement ( ) ; try { DriverManager . deregisterDriver ( driver ) ; log ( " 撤销JDBC驱动程序 ▁ " + driver . getClass ( ) . getName ( ) + " 的注册 " ) ; } catch ( SQLException e ) { log ( e , " 无法撤销下列JDBC驱动程序的注册 : ▁ " + driver . getClass ( ) . getName ( ) ) ; } } }
micmiu/bigdata-tutorial | private void createPools ( Properties props ) { Enumeration propNames = props . propertyNames ( ) ; while ( propNames . hasMoreElements ( ) ) { String name = ( String ) propNames . nextElement ( ) ; if ( name . endsWith ( " . url " ) ) { String poolName = name . substring ( 0 , name . lastIndexOf ( " . " ) ) ; String url = props . getProperty ( poolName + " . url " ) ; if ( url == null ) { log ( " 没有为连接池 " + poolName + " 指定URL " ) ; continue ; } String user = props . getProperty ( poolName + " . user " ) ; String password = props . getProperty ( poolName + " . password " ) ; String maxconn = props . getProperty ( poolName + " . maxconn " , "0" ) ; String minconn = props . getProperty ( poolName + " . minConns " , "0" ) ; String strloginterval = props . getProperty ( poolName + " . logInterval " , "0" ) ; int max ; int min ; long logInterval = Long . parseLong ( strloginterval ) ; try { max = Integer . valueOf ( maxconn ) . intValue ( ) ; } catch ( NumberFormatException e ) { log ( " 错误的最大连接数限制 : ▁ " + maxconn + " ▁ . 连接池 : ▁ " + poolName ) ; max = 0 ; } try { min = Integer . valueOf ( minconn ) . intValue ( ) ; } catch ( NumberFormatException e ) { log ( " 错误的最小连接数限制 : ▁ " + minconn + " ▁ . 连接池 : ▁ " + poolName ) ; min = 0 ; } ConnPool pool = new ConnPool ( poolName , url , user , password , max , min , logInterval ) ; pools . put ( poolName , pool ) ; log ( " 成功创建连接池 " + poolName ) ; } } }
micmiu/bigdata-tutorial | private void init ( ) { InputStream is = getClass ( ) . getResourceAsStream ( CONF_FILE_NAME ) ; Properties dbProps = new Properties ( ) ; try { dbProps . load ( is ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( " 不能读取属性文件 . ▁ " + " 请确保db . properties在CLASSPATH指定的路径中 " ) ; return ; } String logFile = dbProps . getProperty ( " logfile " , " DBConnectionManager . log " ) ; try { log = new PrintWriter ( new FileWriter ( logFile , true ) , true ) ; } catch ( IOException e ) { System . err . println ( " 无法打开日志文件 : ▁ " + logFile ) ; log = new PrintWriter ( System . err ) ; } loadDrivers ( dbProps ) ; createPools ( dbProps ) ; }
micmiu/bigdata-tutorial | private void loadDrivers ( Properties props ) { String driverClasses = props . getProperty ( " drivers " ) ; StringTokenizer st = new StringTokenizer ( driverClasses ) ; while ( st . hasMoreElements ( ) ) { String driverClassName = st . nextToken ( ) . trim ( ) ; try { Driver driver = ( Driver ) Class . forName ( driverClassName ) . newInstance ( ) ; DriverManager . registerDriver ( driver ) ; drivers . addElement ( driver ) ; log ( " 成功注册JDBC驱动程序 " + driverClassName ) ; } catch ( Exception e ) { log ( " 无法注册JDBC驱动程序 : ▁ " + driverClassName + " , ▁ 错误 : ▁ " + e ) ; } } }
micmiu/bigdata-tutorial | private void log ( String msg ) { log . println ( new Date ( ) + " : ▁ " + msg ) ; }
micmiu/bigdata-tutorial | private void log ( Throwable e , String msg ) { log . println ( new Date ( ) + " : ▁ " + msg ) ; e . printStackTrace ( log ) ; }
micmiu/bigdata-tutorial | public ConnPool ( String name , String URL , String user , String password , int maxConn , int minConn , long logInterval ) { this . name = name ; this . URL = URL ; this . user = user ; this . password = password ; this . maxConn = maxConn ; this . minConn = minConn ; this . logInterval = logInterval ; for ( int i = 0 ; i < minConn ; i ++ ) { Connection initConn = createNewConnection ( ) ; freeConnections . addElement ( initConn ) ; } logTimer = System . currentTimeMillis ( ) ; poolMonitor = new Thread ( new Runnable ( ) { public void run ( ) { monitor ( ) ; } } ) ; poolMonitor . start ( ) ; }
micmiu/bigdata-tutorial | private void monitor ( ) { while ( true ) { if ( ( System . currentTimeMillis ( ) - logTimer ) > logInterval ) { Enumeration checkconn = freeConnections . elements ( ) ; while ( checkconn . hasMoreElements ( ) ) { Connection con = ( Connection ) checkconn . nextElement ( ) ; try { if ( con == null || con . isClosed ( ) ) { freeConnections . removeElement ( con ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } else if ( freeConnections . size ( ) > minConn ) { con . close ( ) ; freeConnections . removeElement ( con ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } } catch ( SQLException e ) { System . out . println ( " momitor ▁ 出错 ！ " ) ; } } while ( freeConnections . size ( ) < minConn ) { Connection con = createNewConnection ( ) ; freeConnections . addElement ( con ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } logTimer = System . currentTimeMillis ( ) ; } try { Thread . sleep ( SLEEP_INTERVAL ) ; } catch ( InterruptedException e ) { System . out . println ( " 监控线程被打断 ! ! " ) ; } } }
micmiu/bigdata-tutorial | public synchronized void freeConnection ( Connection con ) { freeConnections . addElement ( con ) ; checkedOut -- ; log ( " 从连接池 " + name + " 被占用的链接数 " + checkedOut ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; notifyAll ( ) ; }
micmiu/bigdata-tutorial | public synchronized Connection getConnection ( ) { Connection con = null ; if ( freeConnections . size ( ) > 0 ) { con = ( Connection ) freeConnections . firstElement ( ) ; freeConnections . removeElementAt ( 0 ) ; try { if ( con . isClosed ( ) ) { log ( " 从连接池 " + name + " 删除一个无效连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; con = getConnection ( ) ; } } catch ( SQLException e ) { log ( " 从连接池 " + name + " 删除一个无效连接 " ) ; con = getConnection ( ) ; } } else if ( maxConn == 0 || checkedOut < maxConn ) { con = createNewConnection ( ) ; } if ( con != null ) { checkedOut ++ ; log ( " 从连接池 " + name + " 被占用的链接数 " + checkedOut ) ; } return con ; }
micmiu/bigdata-tutorial | public synchronized Connection getConnection ( long timeout ) { long startTime = new Date ( ) . getTime ( ) ; Connection con ; while ( ( con = getConnection ( ) ) == null ) { try { wait ( timeout ) ; } catch ( InterruptedException e ) { } if ( ( new Date ( ) . getTime ( ) - startTime ) >= timeout ) { return null ; } } return con ; }
micmiu/bigdata-tutorial | public synchronized void release ( ) { Enumeration allConnections = freeConnections . elements ( ) ; while ( allConnections . hasMoreElements ( ) ) { Connection con = ( Connection ) allConnections . nextElement ( ) ; try { con . close ( ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; } catch ( SQLException e ) { log ( e , " 无法关闭连接池 " + name + " 中的连接 " ) ; } } freeConnections . removeAllElements ( ) ; }
micmiu/bigdata-tutorial | private Connection createNewConnection ( ) { Connection con = null ; try { if ( user == null ) { con = DriverManager . getConnection ( URL ) ; } else { con = DriverManager . getConnection ( URL , user , password ) ; } log ( " 连接池 " + name + " 创建一个新的连接 " ) ; } catch ( SQLException e ) { log ( " 无法创建下列URL的连接 : ▁ " + URL + " \n \t " + e . getNextException ( ) ) ; return null ; } return con ; }
orange-buffalo/dozer | private ParentPrime ( ) { }
orange-buffalo/dozer | public ParentPrime ( Long id , String name ) { this . id = id ; this . name = name ; }
orange-buffalo/dozer | public Long getId ( ) { return id ; }
orange-buffalo/dozer | public void setId ( Long id ) { this . id = id ; }
orange-buffalo/dozer | public String getName ( ) { return name ; }
orange-buffalo/dozer | public void setName ( String name ) { this . name = name ; }
orange-buffalo/dozer | public List getChildrenList ( ) { return childrenList ; }
orange-buffalo/dozer | public void setChildrenList ( List childrenList ) { this . childrenList = childrenList ; }
orange-buffalo/dozer | public Set getChildrenSet ( ) { return childrenSet ; }
orange-buffalo/dozer | public void setChildrenSet ( Set childrenSet ) { this . childrenSet = childrenSet ; }
orange-buffalo/dozer | public Map getChildrenMap ( ) { return childrenMap ; }
orange-buffalo/dozer | public void setChildrenMap ( Map childrenMap ) { this . childrenMap = childrenMap ; }
orange-buffalo/dozer | @ Override public boolean equals ( Object o ) { if ( o instanceof ParentPrime ) { ParentPrime castObj = ( ParentPrime ) o ; return id . equals ( castObj . getId ( ) ) ; } return false ; }
orange-buffalo/dozer | @ Override public int hashCode ( ) { return id . hashCode ( ) ; }
Wolfgang-Winter/cibet | public PersistCallable ( EventMetadata md , EntityManager em , Object obj ) { metadata = md ; entityManager = em ; entity = obj ; }
Wolfgang-Winter/cibet | @ Override public Void call ( ) throws Exception { log . debug ( " start ▁ call ▁ for ▁ entity ▁ " + entity ) ; entityManager . persist ( entity ) ; log . debug ( entity ) ; if ( Thread . interrupted ( ) ) { log . debug ( " thread ▁ is ▁ interrupted " ) ; return null ; } entityManager . flush ( ) ; ( ( JpaResource ) metadata . getResource ( ) ) . setPrimaryKeyObject ( AnnotationUtil . primaryKeyAsObject ( entity ) ) ; metadata . getResource ( ) . setUnencodedTargetObject ( entity ) ; return null ; }
apache/tapestry4 | public Timestamp getLastAccess ( ) { return _user == null ? null : _user . getLastAccess ( ) ; }
apache/tapestry4 | public Person getUser ( ) { return _user ; }
apache/tapestry4 | public Integer getUserId ( ) { return _user == null ? null : _user . getId ( ) ; }
apache/tapestry4 | public void setUser ( Person user ) { _user = user ; }
apache/tapestry4 | public boolean isUserLoggedIn ( ) { return _user != null ; }
apache/tapestry4 | public boolean isUserLoggedOut ( ) { return _user == null ; }
apache/tapestry4 | public boolean isLoggedInUser ( Integer id ) { if ( _user == null ) return false ; return _user . getId ( ) . equals ( id ) ; }
apache/tapestry4 | public void clearCache ( ) { _user = null ; }
nmldiegues/jvm-stm | public ClosedChannelException ( ) { }
apache/axis1-java | public Detail ( ) { }
apache/axis1-java | public DetailEntry addDetailEntry ( Name name ) throws SOAPException { org . apache . axis . message . DetailEntry entry = new org . apache . axis . message . DetailEntry ( name ) ; addChildElement ( entry ) ; return entry ; }
apache/axis1-java | public Iterator getDetailEntries ( ) { return this . getChildElements ( ) ; }
Fabryprog/camel | public DummyConsumer ( Endpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; }
Fabryprog/camel | @ Override public DummyEndpoint getEndpoint ( ) { return ( DummyEndpoint ) super . getEndpoint ( ) ; }
Fabryprog/camel | public boolean isFailOnRestart ( ) { return failOnRestart ; }
Fabryprog/camel | public void setFailOnRestart ( boolean failOnRestart ) { this . failOnRestart = failOnRestart ; }
Fabryprog/camel | @ Override protected void doStart ( ) throws Exception { int counter = getEndpoint ( ) . getComponent ( ) . increment ( ) ; if ( counter == 2 ) { throw new IOException ( " Forced ▁ error ▁ on ▁ restart " ) ; } super . doStart ( ) ; }
wso2/security-tools | public HTMLOutputGenerator ( JSONObject dataJSONObject , String hbsFileDirectory , String templateFileName ) { this . dataJSONObject = dataJSONObject ; this . hbsFileDirectory = hbsFileDirectory ; this . templateFileName = templateFileName ; }
wso2/security-tools | public String getHbsFileDirectory ( ) { return hbsFileDirectory ; }
wso2/security-tools | public JSONObject getDataJSONObject ( ) { return dataJSONObject ; }
wso2/security-tools | public String getTemplateFileName ( ) { return templateFileName ; }
wso2/security-tools | public void generate ( String outputFilePath ) throws FeedbackToolException { Template template ; Context context ; try { JsonNode jsonNode = new ObjectMapper ( ) . readTree ( this . getDataJSONObject ( ) . toJSONString ( ) ) ; Handlebars handlebars = new Handlebars ( ) ; handlebars . registerHelper ( " json " , Jackson2Helper . INSTANCE ) ; context = Context . newBuilder ( jsonNode ) . resolver ( JsonNodeValueResolver . INSTANCE , JavaBeanValueResolver . INSTANCE , FieldValueResolver . INSTANCE , MapValueResolver . INSTANCE , MethodValueResolver . INSTANCE ) . build ( ) ; TemplateLoader loader = new FileTemplateLoader ( this . getHbsFileDirectory ( ) , " . hbs " ) ; handlebars = new Handlebars ( loader ) ; template = handlebars . compile ( FilenameUtils . removeExtension ( this . getTemplateFileName ( ) ) ) ; String html = template . apply ( context ) ; FileHandler . writeToFile ( html , System . getProperty ( " java . io . tmpdir " ) + Constants . OUTPUT_HTML_FILE ) ; } catch ( FileNotFoundException e ) { throw new FeedbackToolException ( " FileNotFoundException ▁ was ▁ thrown ▁ while ▁ compiling ▁ the ▁ template ▁ file " , e ) ; } catch ( IOException e ) { throw new FeedbackToolException ( " IOException ▁ was ▁ thrown ▁ while ▁ compiling ▁ the ▁ template ▁ file " , e ) ; } }
abstractj/keycloak | public SAML11ResponseType ( String id , XMLGregorianCalendar issueInstant ) { super ( id , issueInstant ) ; }
abstractj/keycloak | public void add ( SAML11AssertionType assertion ) { this . assertions . add ( assertion ) ; }
abstractj/keycloak | public boolean remove ( SAML11AssertionType assertion ) { return this . assertions . remove ( assertion ) ; }
abstractj/keycloak | public List < SAML11AssertionType > get ( ) { return Collections . unmodifiableList ( assertions ) ; }
abstractj/keycloak | public SAML11StatusType getStatus ( ) { return status ; }
abstractj/keycloak | public void setStatus ( SAML11StatusType status ) { this . status = status ; }
jagarciavi/PhotoSpat | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_photo_spat ) ; webview = ( WebView ) findViewById ( R . id . webview ) ; final Activity activity = this ; webview . getSettings ( ) . setJavaScriptEnabled ( true ) ; webview . canGoBack ( ) ; webview . setWebViewClient ( new WebViewClient ( ) { public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ) ; return true ; } public void onLoadResource ( WebView view , String url ) { if ( progressDialog == null ) { progressDialog = new ProgressDialog ( activity ) ; progressDialog . setMessage ( getResources ( ) . getString ( R . string . loading ) ) ; progressDialog . show ( ) ; webview . setEnabled ( false ) ; } } public void onPageFinished ( WebView view , String url ) { Log . i ( TAG , " The ▁ app ▁ is ▁ in ▁ the ▁ onPageFinished ▁ method " ) ; String finalUrl = webview . getUrl ( ) . toString ( ) ; Log . i ( TAG , " finalurl ▁ string ▁ is ▁ " + finalUrl ) ; if ( finalUrl . equals ( " https : // instagram . com / accounts / login / " ) ) { if ( firstLoad == 1 ) { Log . i ( TAG , " The ▁ strings ▁ are ▁ equal , ▁ we ' ll ▁ set ▁ counter ▁ value ▁ to ▁ 4" ) ; counter = 4 ; } else { Log . i ( TAG , " It ' s ▁ not ▁ the ▁ load ▁ of ▁ the ▁ login ▁ page . . . " ) ; firstLoad = 1 ; } } if ( progressDialog . isShowing ( ) && counter == 4 ) { Log . i ( TAG , " On ▁ loop ▁ - > ▁ Dismiss ▁ progress ▁ dialog ▁ " ) ; progressDialog . dismiss ( ) ; webview . setEnabled ( true ) ; counter = 0 ; } Log . i ( TAG , " Counter ▁ value ▁ is ▁ " + counter ) ; counter ++ ; } public void onReceivedError ( WebView view , int errorCod , String description , String failingUrl ) { webview . setEnabled ( false ) ; setContentView ( R . layout . activity_photo_spat ) ; progressDialog . dismiss ( ) ; Log . i ( TAG , " Received ▁ error : ▁ " + errorCod + " ▁ " + description + " ▁ " + failingUrl ) ; new AlertDialog . Builder ( PhotoSpat . this ) . setTitle ( getResources ( ) . getString ( R . string . errorDialogTitle ) ) . setMessage ( getResources ( ) . getString ( R . string . errorDialogMessage ) ) . setNeutralButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { finish ( ) ; } } ) . show ( ) ; } } ) ; webview . loadUrl ( " https : // www . instagram . com / accounts / login " ) ; }
jagarciavi/PhotoSpat | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { return true ; }
jagarciavi/PhotoSpat | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . action_settings ) { return true ; } return super . onOptionsItemSelected ( item ) ; }
WANdisco/gerrit | public void setChangeAttribute ( ChangeAttribute changeAttr ) { this . changeAttr = changeAttr ; if ( changeAttr != null ) { projectName = changeAttr . project ; supported = true ; } }
WANdisco/gerrit | public void setProjectName ( String projectName ) { this . projectName = projectName ; this . supported = true ; }
WANdisco/gerrit | public void setBranchName ( Branch . NameKey branchName ) { this . branchName = branchName ; supported = true ; }
WANdisco/gerrit | public void setSupported ( boolean supported ) { this . supported = supported ; }
WANdisco/gerrit | public ChangeAttribute getChangeAttr ( ) { return changeAttr ; }
WANdisco/gerrit | public Branch . NameKey getBranchName ( ) { return branchName ; }
WANdisco/gerrit | public String getProjectName ( ) { return projectName ; }
WANdisco/gerrit | public boolean isSupported ( ) { return supported ; }
WANdisco/gerrit | @ Override public String toString ( ) { return String . format ( " ReplicatedChangeEventInfo { projectName = % s , ▁ branchName = % s , ▁ changeAttr = % s , ▁ supported = % s } " , projectName , branchName , changeAttr , supported ) ; }
avedensky/JavaRushTasks | public User ( int age , String name ) { this . age = age ; this . name = name ; }
avedensky/JavaRushTasks | @ Override protected User clone ( ) throws CloneNotSupportedException { return new User ( this . age , this . name ) ; }
avedensky/JavaRushTasks | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof User ) ) return false ; User user = ( User ) o ; if ( age != user . age ) return false ; return name . equals ( user . name ) ; }
avedensky/JavaRushTasks | @ Override public int hashCode ( ) { int result = age ; result = 31 * result + name . hashCode ( ) ; return result ; }
avedensky/JavaRushTasks | @ Override protected Solution clone ( ) throws CloneNotSupportedException { Solution solution = new Solution ( ) ; for ( Map . Entry < String , User > pair : this . users . entrySet ( ) ) { User user = pair . getValue ( ) . clone ( ) ; solution . users . put ( pair . getKey ( ) , user ) ; } return solution ; }
droolsjbpm/optaplanner | @ Override public Runnable accumulate ( InTuple input ) { KeyTuple key = toKey ( input ) ; ResultContainer1 container1 = containersMap1 . computeIfAbsent ( key , __ -> newFirstContainer ( ) ) ; ResultContainer2 container2 = containersMap2 . computeIfAbsent ( key , __ -> newSecondContainer ( ) ) ; Runnable undo1 = processFirst ( input , container1 ) ; Runnable undo2 = processSecond ( input , container2 ) ; addTuple ( key ) ; return ( ) -> { undo1 . run ( ) ; undo2 . run ( ) ; long currentCount = removeTuple ( key ) ; if ( currentCount == 0L ) { containersMap1 . remove ( key ) ; containersMap2 . remove ( key ) ; resultMap . remove ( key ) ; } } ; }
droolsjbpm/optaplanner | @ Override public Collection < OutTuple > finish ( ) { Set < KeyTuple > dirtyTupleSet = clearDirtyTupleSet ( ) ; if ( ! dirtyTupleSet . isEmpty ( ) ) { for ( KeyTuple tuple : dirtyTupleSet ) { resultMap . put ( tuple , toResult ( tuple , containersMap1 . get ( tuple ) , containersMap2 . get ( tuple ) ) ) ; } } return resultMap . values ( ) ; }
Weisses/Ebonheart-Mods | public TileEntityGemstoneWorkbench ( ) { this . inventory = new ItemStackHandler ( size ) ; }
Weisses/Ebonheart-Mods | @ Override public boolean hasCapability ( Capability < ? > capability , EnumFacing facing ) { if ( capability != CapabilityItemHandler . ITEM_HANDLER_CAPABILITY ) return false ; return super . hasCapability ( capability , facing ) ; }
Weisses/Ebonheart-Mods | @ Override public < T > T getCapability ( Capability < T > capability , EnumFacing facing ) { if ( capability == CapabilityItemHandler . ITEM_HANDLER_CAPABILITY ) return ( T ) this . inventory ; return super . getCapability ( capability , facing ) ; }
Weisses/Ebonheart-Mods | @ Override public NBTTagCompound writeToNBT ( NBTTagCompound compound ) { super . writeToNBT ( compound ) ; compound . setTag ( " Slots " , this . inventory . serializeNBT ( ) ) ; compound . setInteger ( " CutTime " , this . cutTime ) ; compound . setInteger ( " GemstoneMeta " , this . gemstoneMeta ) ; compound . setInteger ( " ProcChance " , this . procChance ) ; compound . setBoolean ( " IsOn " , this . isOn ) ; if ( this . hasCustomName ( ) ) { compound . setString ( " CustomName " , this . gemstoneWorkbenchCustomName ) ; } return compound ; }
Weisses/Ebonheart-Mods | @ Override public void readFromNBT ( NBTTagCompound compound ) { super . readFromNBT ( compound ) ; this . inventory . deserializeNBT ( compound . getCompoundTag ( " Slots " ) ) ; this . cutTime = compound . getInteger ( " CutTime " ) ; this . gemstoneMeta = compound . getInteger ( " GemstoneMeta " ) ; this . procChance = compound . getInteger ( " ProcChance " ) ; this . isOn = compound . getBoolean ( " IsOn " ) ; if ( compound . hasKey ( " CustomName " , 8 ) ) { this . gemstoneWorkbenchCustomName = compound . getString ( " CustomName " ) ; } }
Weisses/Ebonheart-Mods | @ Override @ Nullable public SPacketUpdateTileEntity getUpdatePacket ( ) { return new SPacketUpdateTileEntity ( this . pos , 3 , this . getUpdateTag ( ) ) ; }
Weisses/Ebonheart-Mods | @ Override public NBTTagCompound getUpdateTag ( ) { return this . writeToNBT ( new NBTTagCompound ( ) ) ; }
Weisses/Ebonheart-Mods | @ Override public void onDataPacket ( NetworkManager net , SPacketUpdateTileEntity pkt ) { super . onDataPacket ( net , pkt ) ; this . cutTime = pkt . getNbtCompound ( ) . getInteger ( " CutTime " ) ; this . handleUpdateTag ( pkt . getNbtCompound ( ) ) ; }
Weisses/Ebonheart-Mods | public String getName ( ) { return this . hasCustomName ( ) ? this . gemstoneWorkbenchCustomName : " gemstone _ workbench " ; }
Weisses/Ebonheart-Mods | public boolean hasCustomName ( ) { return this . gemstoneWorkbenchCustomName != null && ! this . gemstoneWorkbenchCustomName . isEmpty ( ) ; }
Weisses/Ebonheart-Mods | @ Override public void update ( ) { this . cuttingLogic ( ) ; }
Weisses/Ebonheart-Mods | private void cuttingLogic ( ) { boolean hasBeenCutting = cuttingSomething ( ) ; boolean changedCuttingState = false ; if ( ! this . world . isRemote ) { if ( this . isOn ) { if ( ! this . inventory . getStackInSlot ( 0 ) . isEmpty ( ) ) { this . totalCutTime = getMaxCutTime ( this . inventory . getStackInSlot ( 0 ) ) ; this . procChance = getGemProc ( this . inventory . getStackInSlot ( 0 ) ) ; this . procAmount = this . getMultiProcChance ( this . inventory . getStackInSlot ( 0 ) ) ; if ( ! cuttingSomething ( ) && canCut ( ) ) { if ( cuttingSomething ( ) ) { changedCuttingState = true ; } } if ( cuttingSomething ( ) && canCut ( ) ) { ++ this . cutTime ; this . syncCutTime ( ) ; if ( this . cutTime == this . totalCutTime ) { double procSuccessful = References . random . nextInt ( 100 ) ; this . cutTime = 0 ; this . totalCutTime = getMaxCutTime ( this . inventory . getStackInSlot ( 0 ) ) ; this . procAmount = this . getMultiProcChance ( this . inventory . getStackInSlot ( 0 ) ) ; if ( this . procChance >= procSuccessful ) { cutGem ( ) ; } else { this . inventory . getStackInSlot ( 0 ) . shrink ( 1 ) ; } changedCuttingState = true ; } } else { this . cutTime = 0 ; } } else { this . cutTime = 0 ; this . procChance = 0 ; } } else { this . cutTime = 0 ; if ( ! this . inventory . getStackInSlot ( 0 ) . isEmpty ( ) ) { this . procChance = getGemProc ( this . inventory . getStackInSlot ( 0 ) ) ; } else { this . procChance = 0 ; } } if ( ! canCut ( ) && this . cutTime > 0 ) { this . cutTime = 0 ; } if ( hasBeenCutting != cuttingSomething ( ) ) { changedCuttingState = true ; } } if ( changedCuttingState ) { this . markDirty ( ) ; } }
Weisses/Ebonheart-Mods | private boolean canCut ( ) { if ( ( ( ItemStack ) this . inventory . getStackInSlot ( 0 ) ) . isEmpty ( ) ) { return false ; } else { ItemStack itemstack1 = ( ItemStack ) this . inventory . getStackInSlot ( 1 ) ; if ( itemstack1 . isEmpty ( ) ) return true ; if ( ! itemstack1 . isItemEqual ( GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] ) ) return false ; int result = itemstack1 . getCount ( ) + GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] . getCount ( ) ; return result <= 64 && result <= itemstack1 . getMaxStackSize ( ) ; } }
Weisses/Ebonheart-Mods | public void cutGem ( ) { if ( this . canCut ( ) ) { ItemStack itemstackIn = ( ItemStack ) this . inventory . getStackInSlot ( 0 ) ; ItemStack itemstackOut = GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] ; ItemStack itemstack1 = ( ItemStack ) this . inventory . getStackInSlot ( 1 ) ; if ( itemstack1 . isEmpty ( ) ) { this . inventory . insertItem ( 1 , new ItemStack ( InitItemsVG . gemstone_item_basic_v1 , 1 + this . procAmount , this . gemstoneMeta ) , false ) ; } else if ( itemstack1 . isItemEqual ( GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] ) ) { if ( itemstack1 . getCount ( ) + this . procAmount > 64 ) { int reducedAmount = References . random . nextInt ( ( itemstack1 . getCount ( ) + this . procAmount ) - 64 ) ; if ( reducedAmount == 0 ) { reducedAmount = 1 ; } itemstack1 . grow ( reducedAmount ) ; } else { itemstack1 . grow ( 1 + this . procAmount ) ; } } if ( itemstack1 . getCount ( ) == 65 ) { itemstack1 . shrink ( 1 ) ; } if ( itemstack1 . getCount ( ) == 66 ) { itemstack1 . shrink ( 2 ) ; } itemstackIn . shrink ( 1 ) ; } }
Weisses/Ebonheart-Mods | public int getMaxCutTime ( ItemStack stack ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { return 200 ; } }
Weisses/Ebonheart-Mods | public int getGemProc ( ItemStack stack ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { Item item = stack . getItem ( ) ; if ( item == InitItemsVG . gemstone_item_unidentified ) return 500 ; if ( item instanceof ItemBlock && Block . getBlockFromItem ( item ) != Blocks . AIR ) { Block block = Block . getBlockFromItem ( item ) ; if ( block == Blocks . REDSTONE_ORE ) return 25 ; if ( block == Blocks . REDSTONE_BLOCK ) return 80 ; if ( block == Blocks . COAL_ORE ) return 30 ; if ( block == Blocks . COAL_BLOCK ) return 90 ; if ( block == Blocks . IRON_ORE ) return 75 ; if ( block == Blocks . IRON_BLOCK ) return 225 ; if ( block == Blocks . QUARTZ_ORE ) return 90 ; if ( block == Blocks . QUARTZ_BLOCK ) return 270 ; if ( block == Blocks . GOLD_ORE ) return 105 ; if ( block == Blocks . GOLD_BLOCK ) return 315 ; if ( block == Blocks . LAPIS_ORE ) return 115 ; if ( block == Blocks . LAPIS_BLOCK ) return 350 ; if ( block == Blocks . DIAMOND_ORE ) return 150 ; if ( block == Blocks . DIAMOND_BLOCK ) return 450 ; if ( block == Blocks . EMERALD_ORE ) return 165 ; if ( block == Blocks . EMERALD_BLOCK ) return 495 ; if ( block == Blocks . MYCELIUM ) return 10 ; if ( block == Blocks . COBBLESTONE ) return 15 ; if ( block == Blocks . LOG ) return 16 ; if ( block == Blocks . LOG2 ) return 16 ; if ( block == Blocks . NETHERRACK ) return 13 ; if ( block == Blocks . NETHER_BRICK ) return 50 ; if ( block == Blocks . RED_NETHER_BRICK ) return 60 ; if ( block == Blocks . OBSIDIAN ) return 45 ; if ( block == Blocks . GLOWSTONE ) return 95 ; if ( block == Blocks . SEA_LANTERN ) return 95 ; if ( block == Blocks . PRISMARINE ) return 100 ; if ( block == Blocks . END_STONE ) return 110 ; if ( block == Blocks . END_BRICKS ) return 110 ; if ( block == Blocks . END_ROD ) return 130 ; if ( block == Blocks . PURPUR_BLOCK ) return 150 ; if ( block == Blocks . PURPUR_PILLAR ) return 150 ; if ( block == Blocks . PURPUR_STAIRS ) return 150 ; if ( block == Blocks . PURPUR_SLAB ) return 75 ; if ( block == Blocks . ENCHANTING_TABLE ) return 280 ; if ( block == Blocks . ENDER_CHEST ) return 415 ; if ( block == Blocks . BEACON ) return 500 ; if ( block . getDefaultState ( ) . getMaterial ( ) == Material . GRASS || block . getDefaultState ( ) . getMaterial ( ) == Material . PLANTS || block . getDefaultState ( ) . getMaterial ( ) == Material . LEAVES || block . getDefaultState ( ) . getMaterial ( ) == Material . VINE || block . getDefaultState ( ) . getMaterial ( ) == Material . CACTUS || block . getDefaultState ( ) . getMaterial ( ) == Material . GOURD || block . getDefaultState ( ) . getMaterial ( ) == Material . CAKE ) { return 5 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . SNOW || block . getDefaultState ( ) . getMaterial ( ) == Material . CRAFTED_SNOW || block . getDefaultState ( ) . getMaterial ( ) == Material . ICE || block . getDefaultState ( ) . getMaterial ( ) == Material . PACKED_ICE ) { return 8 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . GROUND || block . getDefaultState ( ) . getMaterial ( ) == Material . SAND || block . getDefaultState ( ) . getMaterial ( ) == Material . WEB ) { return 10 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . WOOD ) { return 13 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . CLOTH || block . getDefaultState ( ) . getMaterial ( ) == Material . CARPET || block . getDefaultState ( ) . getMaterial ( ) == Material . SPONGE ) { return 15 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . CLAY || block . getDefaultState ( ) . getMaterial ( ) == Material . CORAL ) { return 18 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . GLASS ) { return 20 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . ROCK || block . getDefaultState ( ) . getMaterial ( ) == Material . PISTON ) { return 25 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . IRON || block . getDefaultState ( ) . getMaterial ( ) == Material . ANVIL || block . getDefaultState ( ) . getMaterial ( ) == Material . CIRCUITS || block . getDefaultState ( ) . getMaterial ( ) == Material . REDSTONE_LIGHT ) { return 40 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . TNT ) { return 50 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . DRAGON_EGG ) { return 100 ; } return 25 ; } if ( item instanceof ItemTool && " WOOD " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 15 ; if ( item instanceof ItemSword && " WOOD " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 15 ; if ( item instanceof ItemHoe && " WOOD " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 15 ; if ( item instanceof ItemTool && " STONE " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 28 ; if ( item instanceof ItemSword && " STONE " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 28 ; if ( item instanceof ItemHoe && " STONE " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 28 ; if ( item instanceof ItemTool && " IRON " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 38 ; if ( item instanceof ItemSword && " IRON " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 38 ; if ( item instanceof ItemHoe && " IRON " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 38 ; if ( item instanceof ItemTool && " GOLD " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 58 ; if ( item instanceof ItemSword && " GOLD " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 58 ; if ( item instanceof ItemHoe && " GOLD " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 58 ; if ( item instanceof ItemTool && " DIAMOND " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 85 ; if ( item instanceof ItemSword && " DIAMOND " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 85 ; if ( item instanceof ItemHoe && " DIAMOND " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 85 ; if ( item instanceof ItemArmor && " leather " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 14 ; if ( item instanceof ItemArmor && " iron " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 40 ; if ( item instanceof ItemArmor && " gold " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 60 ; if ( item instanceof ItemArmor && " chainmail " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 75 ; if ( item instanceof ItemArmor && " diamond " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 90 ; if ( item == Items . IRON_HORSE_ARMOR ) return 40 ; if ( item == Items . GOLDEN_HORSE_ARMOR ) return 60 ; if ( item == Items . DIAMOND_HORSE_ARMOR ) return 90 ; if ( item instanceof ItemRecord ) return 90 ; if ( item == Items . REDSTONE ) return 8 ; if ( item == Items . DYE ) return 10 ; if ( item == Items . COAL ) return 10 ; if ( item == Items . IRON_INGOT ) return 25 ; if ( item == Items . QUARTZ ) return 30 ; if ( item == Items . GOLD_INGOT ) return 35 ; if ( item == Items . DIAMOND ) return 50 ; if ( item == Items . EMERALD ) return 55 ; if ( item == Items . PRISMARINE_SHARD ) return 75 ; if ( item == Items . PRISMARINE_CRYSTALS ) return 90 ; if ( item instanceof ItemSeeds ) return 3 ; if ( item == Items . GOLD_NUGGET ) return 4 ; if ( item == Items . GUNPOWDER ) return 10 ; if ( item == Items . BLAZE_ROD ) return 15 ; if ( item == Items . BREWING_STAND ) return 18 ; if ( item == Items . GLOWSTONE_DUST ) return 25 ; if ( item == Items . COMPASS ) return 40 ; if ( item == Items . CLOCK ) return 55 ; if ( item == Items . ENDER_PEARL ) return 30 ; if ( item == Items . FIRE_CHARGE ) return 40 ; if ( item == Items . SHEARS ) return 40 ; if ( item == Items . FIREWORK_CHARGE ) return 45 ; if ( item == Items . CAULDRON ) return 50 ; if ( item == Items . ENDER_EYE ) return 55 ; if ( item == Items . ENCHANTED_BOOK ) return 70 ; if ( item == Items . GOLDEN_APPLE ) return 75 ; if ( item == Items . BUCKET ) return 75 ; if ( item == Items . GHAST_TEAR ) return 80 ; if ( item == Items . CHORUS_FRUIT ) return 80 ; if ( item == Items . CHORUS_FRUIT_POPPED ) return 85 ; if ( item == Items . LAVA_BUCKET ) return 85 ; if ( item == Items . EXPERIENCE_BOTTLE ) return 100 ; if ( item == Items . TOTEM ) return 300 ; if ( item == Items . NETHER_STAR ) return 350 ; if ( item == Items . SHULKER_SHELL ) return 350 ; if ( item == Items . ELYTRA ) return 400 ; return 5 ; } }
Weisses/Ebonheart-Mods | public int getMultiProcChance ( ItemStack stack ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { if ( this . getGemProc ( stack ) >= 500 ) { return References . random . nextInt ( 5 ) ; } else if ( this . getGemProc ( stack ) >= 401 ) { return References . random . nextInt ( 4 ) ; } else if ( this . getGemProc ( stack ) >= 301 ) { return References . random . nextInt ( 3 ) ; } else if ( this . getGemProc ( stack ) >= 201 ) { return References . random . nextInt ( 2 ) ; } else if ( this . getGemProc ( stack ) >= 101 ) { return References . random . nextInt ( 1 ) ; } return 0 ; } }
Weisses/Ebonheart-Mods | @ SideOnly ( Side . CLIENT ) public boolean isWorkbenchOn ( ) { boolean isCutting = false ; if ( this . cutTime > 0 ) { isCutting = true ; } return isCutting ; }
Weisses/Ebonheart-Mods | public boolean cuttingSomething ( ) { return true ; }
Weisses/Ebonheart-Mods | public void syncCutTime ( ) { if ( this . cutTime == 1 || this . cutTime == 20 || this . cutTime == 40 || this . cutTime == 60 || this . cutTime == 80 || this . cutTime == 100 || this . cutTime == 120 || this . cutTime == 140 || this . cutTime == 160 || this . cutTime == 180 || this . cutTime == 200 ) { this . markUpdate ( ) ; } }
Weisses/Ebonheart-Mods | protected void markUpdate ( ) { world . notifyBlockUpdate ( this . getPos ( ) , this . getBlockType ( ) . getDefaultState ( ) , this . getBlockType ( ) . getDefaultState ( ) , 0 ) ; }
Weisses/Ebonheart-Mods | public int getField ( int id ) { switch ( id ) { case 0 : return this . cutTime ; case 1 : return this . totalCutTime ; case 2 : return this . procChance ; default : return 0 ; } }
Weisses/Ebonheart-Mods | public void setField ( int id , int value ) { switch ( id ) { case 0 : this . cutTime = value ; break ; case 1 : this . totalCutTime = value ; break ; case 2 : this . procChance = value ; break ; } }
Weisses/Ebonheart-Mods | public int getFieldCount ( ) { return 3 ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " samlIdPMetadataCouchDbInstance " ) @ RefreshScope @ Bean public CouchDbInstance samlIdPMetadataCouchDbInstance ( ) { return samlMetadataCouchDbFactory . getIfAvailable ( ) . getCouchDbInstance ( ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " samlIdPMetadataCouchDbConnector " ) @ RefreshScope @ Bean public CouchDbConnector samlIdPMetadataCouchDbConnector ( ) { return samlMetadataCouchDbFactory . getIfAvailable ( ) . getCouchDbConnector ( ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " samlIdPMetadataCouchDbRepository " ) @ Bean @ RefreshScope public SamlIdPMetadataCouchDbRepository samlIdPMetadataCouchDbRepository ( ) { val repository = new SamlIdPMetadataCouchDbRepository ( samlMetadataCouchDbFactory . getIfAvailable ( ) . getCouchDbConnector ( ) , casProperties . getAuthn ( ) . getSamlIdp ( ) . getMetadata ( ) . getCouchDb ( ) . isCreateIfNotExists ( ) ) ; repository . initStandardDesignDocument ( ) ; return repository ; }
philliprower/cas | @ Bean @ RefreshScope @ ConditionalOnMissingBean ( name = " couchDbSamlIdPMetadataCipherExecutor " ) public CipherExecutor couchDbSamlIdPMetadataCipherExecutor ( ) { val idp = casProperties . getAuthn ( ) . getSamlIdp ( ) ; val crypto = idp . getMetadata ( ) . getCouchDb ( ) . getCrypto ( ) ; if ( crypto . isEnabled ( ) ) { return new CouchDbSamlIdPMetadataCipherExecutor ( crypto . getEncryption ( ) . getKey ( ) , crypto . getSigning ( ) . getKey ( ) , crypto . getAlg ( ) , crypto . getSigning ( ) . getKeySize ( ) , crypto . getEncryption ( ) . getKeySize ( ) ) ; } LOGGER . info ( " CouchDb ▁ SAML ▁ IdP ▁ metadata ▁ encryption / signing ▁ is ▁ turned ▁ off ▁ and ▁ " + " MAY ▁ NOT ▁ be ▁ safe ▁ in ▁ a ▁ production ▁ environment . ▁ " + " Consider ▁ using ▁ other ▁ choices ▁ to ▁ handle ▁ encryption , ▁ signing ▁ and ▁ verification ▁ of ▁ metadata ▁ artifacts " ) ; return CipherExecutor . noOp ( ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " couchDbSamlIdPMetadataGenerator " ) @ Bean ( initMethod = " generate " ) public SamlIdPMetadataGenerator samlIdPMetadataGenerator ( ) { val idp = casProperties . getAuthn ( ) . getSamlIdp ( ) ; val context = SamlIdPMetadataGeneratorConfigurationContext . builder ( ) . samlIdPMetadataLocator ( samlIdPMetadataLocator ( ) ) . samlIdPCertificateAndKeyWriter ( samlSelfSignedCertificateWriter . getIfAvailable ( ) ) . entityId ( idp . getEntityId ( ) ) . resourceLoader ( resourceLoader ) . casServerPrefix ( casProperties . getServer ( ) . getPrefix ( ) ) . scope ( idp . getScope ( ) ) . metadataCipherExecutor ( couchDbSamlIdPMetadataCipherExecutor ( ) ) . build ( ) ; return new CouchDbSamlIdPMetadataGenerator ( context , samlIdPMetadataRepository . getIfAvailable ( ) ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " couchDbSamlIdPMetadataLocator " ) @ Bean @ SneakyThrows public SamlIdPMetadataLocator samlIdPMetadataLocator ( ) { return new CouchDbSamlIdPMetadataLocator ( couchDbSamlIdPMetadataCipherExecutor ( ) , samlIdPMetadataRepository . getIfAvailable ( ) ) ; }
bsspirit/kettle-4.4.0-stable | public DatabaseExplorerNode ( ) { this . children = new ArrayList < DatabaseExplorerNode > ( ) ; }
bsspirit/kettle-4.4.0-stable | public String getName ( ) { return this . name ; }
bsspirit/kettle-4.4.0-stable | public void setName ( String name ) { this . name = name ; }
bsspirit/kettle-4.4.0-stable | public String toString ( ) { return " Database ▁ Node : ▁ " + this . name ; }
bsspirit/kettle-4.4.0-stable | public String getImage ( ) { return this . image ; }
bsspirit/kettle-4.4.0-stable | public void setImage ( String aImage ) { this . image = aImage ; }
bsspirit/kettle-4.4.0-stable | public void setIsSchema ( boolean isSchema ) { this . isSchema = isSchema ; }
bsspirit/kettle-4.4.0-stable | public boolean isSchema ( ) { return isSchema ; }
bsspirit/kettle-4.4.0-stable | public boolean isTable ( ) { return this . isTable ; }
bsspirit/kettle-4.4.0-stable | public void setIsTable ( boolean aIsTable ) { this . isTable = aIsTable ; }
bsspirit/kettle-4.4.0-stable | public void setSchema ( String schema ) { this . schema = schema ; }
bsspirit/kettle-4.4.0-stable | public String getSchema ( ) { return schema ; }
bsspirit/kettle-4.4.0-stable | public String getLabel ( ) { if ( label != null ) { return label ; } else { return name ; } }
bsspirit/kettle-4.4.0-stable | public void setLabel ( String label ) { this . label = label ; }
TDbouk/Baking-App | @ Before public void registerIdlingResource ( ) { mIdlingResource = mActivityTestRule . getActivity ( ) . getIdlingResource ( ) ; Espresso . registerIdlingResources ( mIdlingResource ) ; }
TDbouk/Baking-App | @ Test public void clickOnStepItem_CheckDetailActivity ( ) { onView ( ViewMatchers . withId ( R . id . rv_recipes ) ) . perform ( RecyclerViewActions . actionOnItemAtPosition ( 1 , click ( ) ) ) ; onView ( withId ( R . id . fab_show_ingredients ) ) . check ( matches ( isDisplayed ( ) ) ) ; onView ( ViewMatchers . withId ( R . id . rv_steps ) ) . perform ( RecyclerViewActions . actionOnItemAtPosition ( 0 , click ( ) ) ) ; onView ( withId ( R . id . img_toolbar ) ) . check ( matches ( isDisplayed ( ) ) ) ; }
TDbouk/Baking-App | @ After public void unregisterIdlingResource ( ) { if ( mIdlingResource != null ) Espresso . unregisterIdlingResources ( mIdlingResource ) ; }
VHAINNOVATIONS/Telepathology | protected void setUp ( ) throws Exception { super . setUp ( ) ; this . factory = new CommandFactoryImpl ( ( CommandContext ) null ) ; }
VHAINNOVATIONS/Telepathology | protected CommandFactory getFactory ( ) { return factory ; }
VHAINNOVATIONS/Telepathology | protected void tearDown ( ) throws Exception { this . factory = null ; super . tearDown ( ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreateLogImageAccessEventCommand ( ) { ImageAccessLogEvent event = new ImageAccessLogEvent ( " ien " , null , " icn " , " site " , System . currentTimeMillis ( ) , " reason " , " reasonDescription " , ImageAccessLogEventType . IMAGE_ACCESS , "200" ) ; Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PostImageAccessEventCommand " , null , new Class < ? > [ ] { ImageAccessLogEvent . class } , new Object [ ] { event } ) ; assertExpectedType ( command , PostImageAccessEventCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreatePrefetchPatientIdentificationImageCommand ( ) { Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PrefetchPatientIdentificationImageCommand " , null , new Class < ? > [ ] { String . class , String . class } , new Object [ ] { " icn " , " site " } ) ; assertExpectedType ( command , PrefetchPatientIdentificationImageCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreatePrefetchPatientStudyListCommand ( ) throws URNFormatException { StudyFilter filter = new StudyFilter ( new Date ( 0L ) , new Date ( ) , URNFactory . create ( " urn : vastudy : 200-300-400" , StudyURN . class ) ) ; ImageFormatQualityList formatList = new ImageFormatQualityList ( ) ; Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PrefetchPatientStudyListCommand " , null , new Class < ? > [ ] { String . class , String . class , StudyFilter . class , ImageFormatQualityList . class } , new Object [ ] { " site " , " patient " , filter , formatList } ) ; assertExpectedType ( command , PrefetchPatientStudyListCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreateCommand ( ) throws URNFormatException { String siteNumber = "660" ; String patientIcn = "6553321" ; StudyFilter filter = new StudyFilter ( new Date ( 0L ) , new Date ( ) , URNFactory . create ( " urn : vastudy : 200-300-400" , StudyURN . class ) ) ; ImageFormatQualityList formatList = new ImageFormatQualityList ( ) ; Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PrefetchPatientStudyListCommand " , null , new Class < ? > [ ] { String . class , String . class , StudyFilter . class , ImageFormatQualityList . class } , new Object [ ] { siteNumber , patientIcn , filter , formatList } ) ; assertExpectedType ( command , PrefetchPatientStudyListCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | private void assertExpectedType ( Object obj , Class < ? > expectedType ) { assertTrue ( " Command ▁ should ▁ be ▁ of ▁ type ▁ " + PostImageAccessEventCommandImpl . class . getName ( ) + " ▁ but ▁ is ▁ " + ( obj == null ? " null " : obj . getClass ( ) . getName ( ) ) , expectedType . isInstance ( obj ) ) ; }
juanchosaravia/TheReentrantBank | public UserAccountActionsThread ( String nombreUsuario , MiVariableRWL m ) { this . micuenta2 = m ; this . nombreUsuario = nombreUsuario ; }
juanchosaravia/TheReentrantBank | public void run ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { switch ( randomnumber ( ) ) { case 0 : micuenta2 . verSaldo ( nombreUsuario ) ; try { Thread . sleep ( tiempo_espera ) ; } catch ( Exception e ) { } ; break ; case 1 : micuenta2 . ingresarDinero ( nombreUsuario , 5 ) ; try { Thread . sleep ( tiempo_espera ) ; } catch ( Exception e ) { } ; break ; case 2 : micuenta2 . retirarDinero ( nombreUsuario , 2 ) ; try { Thread . sleep ( tiempo_espera ) ; } catch ( Exception e ) { } ; break ; } } System . out . println ( " Usuario : ▁ " + this . nombreUsuario + " ▁ ha ▁ finalizado ▁ la ▁ prueba . " ) ; }
juanchosaravia/TheReentrantBank | private int randomnumber ( ) { int numero = 0 ; Random r = new Random ( ) ; numero = r . nextInt ( 3 ) ; return numero ; }
dhutchis/accumulo | @ Override protected int defaultTimeoutSeconds ( ) { return 60 ; }
dhutchis/accumulo | @ Test public void test ( ) throws Exception { Connector c = getConnector ( ) ; String tableName = getUniqueNames ( 1 ) [ 0 ] ; c . tableOperations ( ) . create ( tableName ) ; IteratorSetting is = new IteratorSetting ( 30 , BadIterator . class ) ; c . tableOperations ( ) . attachIterator ( tableName , is , EnumSet . of ( IteratorScope . minc ) ) ; BatchWriter bw = c . createBatchWriter ( tableName , new BatchWriterConfig ( ) ) ; Mutation m = new Mutation ( new Text ( " r1" ) ) ; m . put ( new Text ( " acf " ) , new Text ( tableName ) , new Value ( "1" . getBytes ( UTF_8 ) ) ) ; bw . addMutation ( m ) ; bw . close ( ) ; c . tableOperations ( ) . flush ( tableName , null , null , false ) ; sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; FunctionalTestUtils . checkRFiles ( c , tableName , 1 , 1 , 0 , 0 ) ; Scanner scanner = c . createScanner ( tableName , Authorizations . EMPTY ) ; int count = Iterators . size ( scanner . iterator ( ) ) ; assertEquals ( " Did ▁ not ▁ see ▁ expected ▁ # ▁ entries ▁ " + count , 1 , count ) ; c . tableOperations ( ) . removeIterator ( tableName , BadIterator . class . getSimpleName ( ) , EnumSet . of ( IteratorScope . minc ) ) ; sleepUninterruptibly ( 5 , TimeUnit . SECONDS ) ; FunctionalTestUtils . checkRFiles ( c , tableName , 1 , 1 , 1 , 1 ) ; count = Iterators . size ( scanner . iterator ( ) ) ; if ( count != 1 ) throw new Exception ( " Did ▁ not ▁ see ▁ expected ▁ # ▁ entries ▁ " + count ) ; c . tableOperations ( ) . attachIterator ( tableName , is , EnumSet . of ( IteratorScope . minc ) ) ; bw = c . createBatchWriter ( tableName , new BatchWriterConfig ( ) ) ; m = new Mutation ( new Text ( " r2" ) ) ; m . put ( new Text ( " acf " ) , new Text ( tableName ) , new Value ( "1" . getBytes ( UTF_8 ) ) ) ; bw . addMutation ( m ) ; bw . close ( ) ; sleepUninterruptibly ( 500 , TimeUnit . MILLISECONDS ) ; c . tableOperations ( ) . flush ( tableName , null , null , false ) ; sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; c . tableOperations ( ) . delete ( tableName ) ; }
betfair/cougar | @ Test public void doTest ( ) throws Exception { CougarManager cougarManager1 = CougarManager . getInstance ( ) ; HttpCallBean getNewHttpCallBean1 = cougarManager1 . getNewHttpCallBean ( "87.248.113.14" ) ; cougarManager1 = cougarManager1 ; getNewHttpCallBean1 . setOperationName ( " TestSimpleListGet " , " simpleListGet " ) ; getNewHttpCallBean1 . setServiceName ( " baseline " , " cougarBaseline " ) ; getNewHttpCallBean1 . setVersion ( " v2" ) ; Map map2 = new HashMap ( ) ; map2 . put ( " RESTJSON " , " { \" inputList \" : ▁ \n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ [ ] \n } " ) ; getNewHttpCallBean1 . setPostQueryObjects ( map2 ) ; Timestamp getTimeAsTimeStamp7 = new Timestamp ( System . currentTimeMillis ( ) ) ; cougarManager1 . makeRestCougarHTTPCall ( getNewHttpCallBean1 , com . betfair . testing . utils . cougar . enums . CougarMessageProtocolRequestTypeEnum . RESTJSON , com . betfair . testing . utils . cougar . enums . CougarMessageContentTypeEnum . XML ) ; cougarManager1 . makeRestCougarHTTPCall ( getNewHttpCallBean1 , com . betfair . testing . utils . cougar . enums . CougarMessageProtocolRequestTypeEnum . RESTJSON , com . betfair . testing . utils . cougar . enums . CougarMessageContentTypeEnum . JSON ) ; XMLHelpers xMLHelpers4 = new XMLHelpers ( ) ; Document createAsDocument10 = xMLHelpers4 . getXMLObjectFromString ( " < TestSimpleListGetResponse > < / TestSimpleListGetResponse > " ) ; JSONHelpers jSONHelpers5 = new JSONHelpers ( ) ; JSONObject createAsJSONObject11 = jSONHelpers5 . createAsJSONObject ( new JSONObject ( " { \" response \" : ▁ [ ] } " ) ) ; HttpResponseBean response6 = getNewHttpCallBean1 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONXML ) ; AssertionUtils . multiAssertEquals ( createAsDocument10 , response6 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 200 , response6 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " OK " , response6 . getHttpStatusText ( ) ) ; HttpResponseBean response7 = getNewHttpCallBean1 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONJSON ) ; AssertionUtils . multiAssertEquals ( createAsJSONObject11 , response7 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 200 , response7 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " OK " , response7 . getHttpStatusText ( ) ) ; cougarManager1 . verifyRequestLogEntriesAfterDate ( getTimeAsTimeStamp7 , new RequestLogRequirement ( "2.8" , " testSimpleListGet " ) , new RequestLogRequirement ( "2.8" , " testSimpleListGet " ) ) ; }
yanzhijun/jclouds-aliyun | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; VolumeImpl that = VolumeImpl . class . cast ( o ) ; return equal ( this . id , that . id ) && equal ( this . getType ( ) , that . getType ( ) ) && equal ( this . size , that . size ) && equal ( this . device , that . device ) && equal ( this . bootDevice , that . bootDevice ) && equal ( this . durable , that . durable ) ; }
yanzhijun/jclouds-aliyun | @ Override public int hashCode ( ) { return Objects . hashCode ( id , size , device , bootDevice , durable ) ; }
yanzhijun/jclouds-aliyun | @ Override public String toString ( ) { return string ( ) . toString ( ) ; }
yanzhijun/jclouds-aliyun | protected ToStringHelper string ( ) { return Objects . toStringHelper ( " " ) . omitNullValues ( ) . add ( " id " , id ) . add ( " type " , getType ( ) ) . add ( " size " , size ) . add ( " device " , device ) . add ( " bootDevice " , bootDevice ) . add ( " durable " , durable ) ; }
yanzhijun/jclouds-aliyun | public VolumeImpl ( @ Nullable String id , Volume . Type type , @ Nullable Float size , @ Nullable String device , boolean bootDevice , boolean durable ) { this . id = id ; this . type = checkNotNull ( type , " type " ) ; this . size = size ; this . device = device ; this . bootDevice = bootDevice ; this . durable = durable ; }
yanzhijun/jclouds-aliyun | public VolumeImpl ( @ Nullable Float size , boolean bootDevice , boolean durable ) { this ( null , Volume . Type . LOCAL , size , null , bootDevice , durable ) ; }
yanzhijun/jclouds-aliyun | public VolumeImpl ( @ Nullable Float size , @ Nullable String device , boolean bootDevice , boolean durable ) { this ( null , Volume . Type . LOCAL , size , device , bootDevice , durable ) ; }
yanzhijun/jclouds-aliyun | @ Override public String getId ( ) { return id ; }
yanzhijun/jclouds-aliyun | @ Override public Volume . Type getType ( ) { return type ; }
yanzhijun/jclouds-aliyun | @ Override public Float getSize ( ) { return size ; }
yanzhijun/jclouds-aliyun | @ Override public String getDevice ( ) { return device ; }
yanzhijun/jclouds-aliyun | @ Override public boolean isDurable ( ) { return durable ; }
yanzhijun/jclouds-aliyun | @ Override public boolean isBootDevice ( ) { return bootDevice ; }
tzvetkoff/brkt-sdk-java | private Platform ( ) { }
dbrimley/hazelcast | @ Before public void init ( ) { factory = new TestHazelcastInstanceFactory ( 2 ) ; }
dbrimley/hazelcast | @ After public void tear ( ) { factory . shutdownAll ( ) ; }
dbrimley/hazelcast | @ Test public void testCloseableCacheLoader ( ) throws InterruptedException { CachingProvider provider = HazelcastServerCachingProvider . createCachingProvider ( factory . newHazelcastInstance ( ) ) ; CacheManager cacheManager = provider . getCacheManager ( ) ; CloseableCacheLoader loader = new CloseableCacheLoader ( ) ; Factory < CloseableCacheLoader > loaderFactory = FactoryBuilder . factoryOf ( loader ) ; CompleteConfiguration < Object , Object > configuration = new CacheConfig ( ) . setCacheLoaderFactory ( loaderFactory ) . setReadThrough ( true ) ; Cache < Object , Object > cache = cacheManager . createCache ( " test " , configuration ) ; cache . get ( " key " ) ; factory . newHazelcastInstance ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { cache . get ( i ) ; LockSupport . parkNanos ( 1000 ) ; } assertFalse ( " CacheLoader ▁ should ▁ not ▁ be ▁ closed ! " , loader . closed ) ; }
dbrimley/hazelcast | @ Override public Object load ( Object key ) throws CacheLoaderException { if ( closed ) { throw new IllegalStateException ( ) ; } return null ; }
dbrimley/hazelcast | @ Override public Map loadAll ( Iterable keys ) throws CacheLoaderException { if ( closed ) { throw new IllegalStateException ( ) ; } return null ; }
dbrimley/hazelcast | @ Override public void close ( ) throws IOException { closed = true ; }
dbrimley/hazelcast | @ Test public void testCloseableCacheWriter ( ) throws InterruptedException { CachingProvider provider = HazelcastServerCachingProvider . createCachingProvider ( factory . newHazelcastInstance ( ) ) ; CacheManager cacheManager = provider . getCacheManager ( ) ; CloseableCacheWriter writer = new CloseableCacheWriter ( ) ; Factory < CloseableCacheWriter > writerFactory = FactoryBuilder . factoryOf ( writer ) ; CompleteConfiguration < Object , Object > configuration = new CacheConfig ( ) . setCacheWriterFactory ( writerFactory ) . setWriteThrough ( true ) ; Cache < Object , Object > cache = cacheManager . createCache ( " test " , configuration ) ; cache . get ( " key " ) ; factory . newHazelcastInstance ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { cache . put ( i , i ) ; LockSupport . parkNanos ( 1000 ) ; } assertFalse ( " CacheWriter ▁ should ▁ not ▁ be ▁ closed ! " , writer . closed ) ; }
dbrimley/hazelcast | @ Override public void write ( Cache . Entry entry ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void delete ( Object key ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void deleteAll ( Collection keys ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void writeAll ( Collection collection ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void close ( ) throws IOException { closed = true ; }
dbrimley/hazelcast | @ Test public void testCloseableCacheListener ( ) { CachingProvider provider = HazelcastServerCachingProvider . createCachingProvider ( factory . newHazelcastInstance ( ) ) ; CacheManager cacheManager = provider . getCacheManager ( ) ; CloseableListener listener = new CloseableListener ( ) ; Factory < CloseableListener > listenerFactory = FactoryBuilder . factoryOf ( listener ) ; CompleteConfiguration < Object , Object > configuration = new CacheConfig ( ) . addCacheEntryListenerConfiguration ( new MutableCacheEntryListenerConfiguration ( listenerFactory , null , true , false ) ) ; Cache < Object , Object > cache = cacheManager . createCache ( " test " , configuration ) ; cache . close ( ) ; assertTrue ( " CloseableListener . close ( ) ▁ should ▁ be ▁ called ▁ when ▁ cache ▁ is ▁ closed ! " , listener . closed ) ; }
dbrimley/hazelcast | @ Override public void onCreated ( Iterable iterable ) throws CacheEntryListenerException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void close ( ) throws IOException { closed = true ; }
open-power/serverwiz | public String format ( LogRecord record ) { StringBuilder builder = new StringBuilder ( 1000 ) ; if ( record . getLevel ( ) == Level . CONFIG ) { builder . append ( df2 . format ( new Date ( record . getMillis ( ) ) ) ) . append ( " ▁ - ▁ " ) ; builder . append ( formatMessage ( record ) ) ; builder . append ( " \n " ) ; } else { builder . append ( df . format ( new Date ( record . getMillis ( ) ) ) ) . append ( " ▁ - ▁ " ) ; builder . append ( " [ " ) . append ( record . getLevel ( ) ) . append ( " ] ▁ - ▁ " ) ; builder . append ( formatMessage ( record ) ) ; builder . append ( " \n " ) ; } return builder . toString ( ) ; }
open-power/serverwiz | public String getHead ( Handler h ) { return super . getHead ( h ) ; }
open-power/serverwiz | public String getTail ( Handler h ) { return super . getTail ( h ) ; }
NuwanSameera/syncope | public DefaultModalCloseButton ( ) { super ( new ResourceModel ( " cancel " , " Cancel " ) ) ; add ( new AttributeAppender ( " class " , " ▁ pull - left " ) ) ; setOutputMarkupId ( true ) ; }
NuwanSameera/syncope | @ Override public String getAjaxIndicatorMarkupId ( ) { return StringUtils . EMPTY ; }
dbrimley/hazelcast | @ Before public void setup ( ) { HazelcastInstance [ ] cluster = createHazelcastInstanceFactory ( 2 ) . newInstances ( ) ; local = cluster [ 0 ] ; remote = cluster [ 1 ] ; operationService = ( OperationServiceImpl ) getOperationService ( local ) ; clusterService = getClusterService ( local ) ; operationRunner = new OperationRunnerImpl ( operationService , getPartitionId ( local ) , 0 , newSwCounter ( ) ) ; responseHandler = mock ( OperationResponseHandler . class ) ; }
dbrimley/hazelcast | @ Test public void runTask ( ) { final AtomicLong counter = new AtomicLong ( ) ; operationRunner . run ( new Runnable ( ) { @ Override public void run ( ) { counter . incrementAndGet ( ) ; } } ) ; assertEquals ( 1 , counter . get ( ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation ( ) { final AtomicLong counter = new AtomicLong ( ) ; final Object response = " someresponse " ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } @ Override public Object getResponse ( ) { return response ; } } ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 1 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( op , response ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenGeneric ( ) { final AtomicLong counter = new AtomicLong ( ) ; final Object response = " someresponse " ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } @ Override public Object getResponse ( ) { return response ; } } ; op . setPartitionId ( - 1 ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 1 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( op , response ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenWrongPartition_thenTaskNotExecuted ( ) { final AtomicLong counter = new AtomicLong ( ) ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } } ; op . setPartitionId ( operationRunner . getPartitionId ( ) + 1 ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 0 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( same ( op ) , any ( IllegalStateException . class ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenRunThrowsException ( ) { Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { throw new ExpectedRuntimeException ( ) ; } } ; op . setOperationResponseHandler ( responseHandler ) ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; operationRunner . run ( op ) ; verify ( responseHandler ) . sendResponse ( same ( op ) , any ( ExpectedRuntimeException . class ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenWaitingNeeded ( ) { final AtomicLong counter = new AtomicLong ( ) ; DummyWaitingOperation op = new DummyWaitingOperation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } } ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; operationRunner . run ( op ) ; assertEquals ( 0 , counter . get ( ) ) ; verify ( responseHandler , never ( ) ) . sendResponse ( same ( op ) , any ( ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenTimeout_thenOperationNotExecuted ( ) { final AtomicLong counter = new AtomicLong ( ) ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } } ; setCallId ( op , 10 ) ; setCallTimeout ( op , clusterService . getClusterClock ( ) . getClusterTime ( ) - 1 ) ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 0 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( same ( op ) , any ( CallTimeoutResponse . class ) ) ; }
dbrimley/hazelcast | @ Test public void runPacket ( ) throws Exception { Operation op = new DummyOperation ( ) ; setCallId ( op , 1000 * 1000 ) ; Packet packet = toPacket ( local , remote , op ) ; operationRunner . run ( packet ) ; }
dbrimley/hazelcast | @ Test ( expected = HazelcastSerializationException . class ) public void runPacket_whenBroken ( ) throws Exception { Operation op = new DummyOperation ( ) ; setCallId ( op , 1000 * 1000 ) ; Packet packet = toPacket ( local , remote , op ) ; byte [ ] bytes = packet . toByteArray ( ) ; for ( int k = 0 ; k < bytes . length ; k ++ ) { bytes [ k ] ++ ; } operationRunner . run ( packet ) ; }
dbrimley/hazelcast | WaitNotifyKey waitNotifyKey = new WaitNotifyKey ( ) { @ Override public String getServiceName ( ) { return " someservice " ; } @ Override public String getObjectName ( ) { return " someobject " ; } }
dbrimley/hazelcast | @ Override public WaitNotifyKey getWaitKey ( ) { return waitNotifyKey ; }
dbrimley/hazelcast | @ Override public boolean shouldWait ( ) { return true ; }
dbrimley/hazelcast | @ Override public void onWaitExpire ( ) { }
BezrukovM/veraPDF-pdfbox | AnnotFlag ( COSDictionary annotDictionary ) { this . annotDictionary = annotDictionary ; }
BezrukovM/veraPDF-pdfbox | @ Override String getFlagType ( ) { return " Annot ▁ flag " ; }
BezrukovM/veraPDF-pdfbox | @ Override String getFlagValue ( ) { return " Flag ▁ vlaue : ▁ " + annotDictionary . getInt ( COSName . F ) ; }
BezrukovM/veraPDF-pdfbox | @ Override Object [ ] [ ] getFlagBits ( ) { PDAnnotation annotation = new PDAnnotation ( annotDictionary ) { } ; return new Object [ ] [ ] { new Object [ ] { 1 , " Invisible " , annotation . isInvisible ( ) } , new Object [ ] { 2 , " Hidden " , annotation . isHidden ( ) } , new Object [ ] { 3 , " Print " , annotation . isPrinted ( ) } , new Object [ ] { 4 , " NoZoom " , annotation . isNoZoom ( ) } , new Object [ ] { 5 , " NoRotate " , annotation . isNoRotate ( ) } , new Object [ ] { 6 , " NoView " , annotation . isNoView ( ) } , new Object [ ] { 7 , " ReadOnly " , annotation . isReadOnly ( ) } , new Object [ ] { 8 , " Locked " , annotation . isLocked ( ) } , new Object [ ] { 9 , " ToggleNoView " , annotation . isToggleNoView ( ) } , new Object [ ] { 10 , " LockedContents " , annotation . isLocked ( ) } } ; }
corbel-platform/corbel | protected ApiEntity ( ) { }
corbel-platform/corbel | protected ApiEntity ( String id ) { this . id = hasText ( id ) ? id : null ; }
corbel-platform/corbel | public String getId ( ) { return id ; }
corbel-platform/corbel | public String getEtag ( ) { return etag ; }
globalbus/blueprint-gradle-plugin | @ Override public void initContext ( ContextEnricher contextEnricher ) { final Map < String , String > customParameters = contextEnricher . getBlueprintConfiguration ( ) . getCustomParameters ( ) ; for ( final String param : customParameters . keySet ( ) ) { if ( param . startsWith ( " example . " ) ) { final String key = param . split ( " \\ . " ) [ 1 ] ; contextEnricher . addBlueprintContentWriter ( " enrichContextWithExample - " + key , xmlStreamWriter -> { xmlStreamWriter . writeEmptyElement ( " example " ) ; xmlStreamWriter . writeDefaultNamespace ( " http : // exampleNamespace " ) ; xmlStreamWriter . writeAttribute ( " id " , key ) ; xmlStreamWriter . writeAttribute ( " value " , customParameters . get ( param ) ) ; } ) ; } } }
matgr1/ai-playground | protected NeatGeneticAlgorithm ( RandomGenerator random , NeatCrossoverSettings crossoverSettings , NeatMutationSettings mutationSettings , SpeciationStrategy speciationStrategy ) { super ( random ) ; if ( null == crossoverSettings ) { throw new IllegalArgumentException ( " crossoverSettings ▁ not ▁ provided " ) ; } if ( null == mutationSettings ) { throw new IllegalArgumentException ( " mutationSettings ▁ not ▁ provided " ) ; } if ( null == speciationStrategy ) { throw new IllegalArgumentException ( " speciationStrategy ▁ not ▁ provided " ) ; } this . crossoverSettings = crossoverSettings ; this . mutationSettings = mutationSettings ; this . speciationStrategy = speciationStrategy ; }
matgr1/ai-playground | public PopulationT createRandomPopulation ( EvolutionContext context , int populationSize , int inputCount , int outputCount ) { return createRandomPopulation ( getNeatEvolutionContext ( context ) , populationSize , inputCount , outputCount ) ; }
matgr1/ai-playground | private PopulationT createRandomPopulation ( NeatEvolutionContext context , int populationSize , int inputCount , int outputCount ) { List < SpeciesMemberT > genomes = new ArrayList < > ( ) ; for ( int i = 0 ; i < populationSize ; i ++ ) { NeatGenomeT genome = createRandomGenome ( random , inputCount , outputCount ) ; for ( CyclicNeuron outputNode : genome . neuralNet . neurons . values ( NeuronType . Output ) ) { addRandomConnection ( context , genome , genome . neuralNet . biasNeuron ( ) , outputNode ) ; for ( CyclicNeuron inputNode : genome . neuralNet . neurons . values ( NeuronType . Input ) ) { addRandomConnection ( context , genome , inputNode , outputNode ) ; } } SpeciesMemberT member = createSpeciesMember ( null , genome ) ; genomes . add ( member ) ; } return createNewPopulation ( context , genomes ) ; }
matgr1/ai-playground | private void addRandomConnection ( NeatEvolutionContext context , NeatGenomeT genome , CyclicNeuron source , CyclicNeuron target ) { NeatMutationFunctions . addConnection ( genome , source . id , target . id , mutationSettings . getConnectionWeightsMutationSettings ( ) . getRandomValueInRange ( random ) , context . innovationMap ) ; }
matgr1/ai-playground | @ Override public final NeatEvolutionContext createEvolutionContext ( EvolutionParameters evolutionParameters , SelectionStrategy selectionStrategy ) { return new NeatEvolutionContext ( evolutionParameters , selectionStrategy ) ; }
matgr1/ai-playground | protected NeatEvolutionContext getNeatEvolutionContext ( EvolutionContext context ) { @ SuppressWarnings ( " unchecked " ) NeatEvolutionContext neatContext = ( NeatEvolutionContext ) context ; return neatContext ; }
matgr1/ai-playground | @ Override protected List < SpeciesT > speciate ( EvolutionContext context , List < SpeciesMemberT > members , PopulationT previousPopulation ) { return speciate ( members , previousPopulation ) ; }
matgr1/ai-playground | private List < SpeciesT > speciate ( List < SpeciesMemberT > members , PopulationT previousPopulation ) { return speciationStrategy . speciate ( members , previousPopulation , this :: createSpecies ) ; }
matgr1/ai-playground | @ Override protected List < SpeciesMemberT > createOffspringAsexual ( EvolutionContext context , FitnessItem < SpeciesMemberT > parent , long currentGeneration , int count ) { return createOffspringAsexual ( getNeatEvolutionContext ( context ) , parent , currentGeneration , count ) ; }
matgr1/ai-playground | private List < SpeciesMemberT > createOffspringAsexual ( NeatEvolutionContext context , FitnessItem < SpeciesMemberT > parent , long currentGeneration , int count ) { List < SpeciesMemberT > children = new ArrayList < > ( ) ; for ( int childCount = 0 ; childCount < count ; childCount ++ ) { NeatGenomeT childGenome = Genome . cloneGenome ( parent . item . genome ( ) , true ) ; NeatMutationFunctions . mutate ( random , mutationSettings , childGenome , currentGeneration , context . innovationMap ) ; SpeciesMemberT child = createSpeciesMember ( parent . item , childGenome ) ; children . add ( child ) ; } return children ; }
matgr1/ai-playground | @ Override protected List < SpeciesMemberT > createOffspringSexual ( EvolutionContext context , FitnessItem < SpeciesMemberT > parentA , FitnessItem < SpeciesMemberT > parentB , long currentGeneration , int count ) { return createOffspringSexual ( getNeatEvolutionContext ( context ) , parentA , parentB , currentGeneration , count ) ; }
matgr1/ai-playground | private List < SpeciesMemberT > createOffspringSexual ( NeatEvolutionContext context , FitnessItem < SpeciesMemberT > parentA , FitnessItem < SpeciesMemberT > parentB , long currentGeneration , int count ) { int parentAInputCount = parentA . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Input ) ; int parentAOutputCount = parentA . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Output ) ; int parentBInputCount = parentB . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Input ) ; int parentBOutputCount = parentB . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Output ) ; if ( parentAInputCount != parentBInputCount ) { throw new IllegalArgumentException ( " Input ▁ count ▁ mismatch " ) ; } if ( parentAOutputCount != parentBOutputCount ) { throw new IllegalArgumentException ( " Output ▁ count ▁ mismatch " ) ; } FitnessItem < NeatGenomeT > parentAItem = createGenomeItem ( parentA ) ; FitnessItem < NeatGenomeT > parentBItem = createGenomeItem ( parentB ) ; GenomeParents < NeatGenomeT > parents = new GenomeParents < > ( parentAItem , parentBItem ) ; List < SpeciesMemberT > children = new ArrayList < > ( ) ; for ( int childCount = 0 ; childCount < count ; childCount ++ ) { NeatGenomeT childGenome = NeatCrossoverFunctions . crossover ( random , crossoverSettings , parents , this :: createNewGenomeFromTemplate ) ; if ( RandomFunctions . testProbability ( random , mutationSettings . getSexualMutationProbability ( ) ) ) { NeatMutationFunctions . mutate ( random , mutationSettings , childGenome , currentGeneration , context . innovationMap ) ; } GenomeParents < SpeciesMemberT > memberParents = new GenomeParents < > ( parentA , parentB ) ; SortedGenomeParents < SpeciesMemberT > sortedMemberParents = memberParents . getSorted ( random ) ; SpeciesMemberT child = createSpeciesMember ( sortedMemberParents . fittest . item , childGenome ) ; children . add ( child ) ; } return children ; }
matgr1/ai-playground | private FitnessItem < NeatGenomeT > createGenomeItem ( FitnessItem < SpeciesMemberT > member ) { return new FitnessItem < > ( member . item . genome ( ) , member . fitness ) ; }
matgr1/ai-playground | public NeatEvolutionContext ( EvolutionParameters evolutionParameters , SelectionStrategy selectionStrategy ) { super ( evolutionParameters , selectionStrategy ) ; innovationMap = new HashMap < > ( ) ; }
facebook/fresco | public TooManyBitmapsException ( ) { super ( ) ; }
facebook/fresco | public TooManyBitmapsException ( String detailMessage ) { super ( detailMessage ) ; }
tausifmuzaffar/bisApp | CodePushUpdateState ( int value ) { this . value = value ; }
tausifmuzaffar/bisApp | public int getValue ( ) { return this . value ; }
psaradhi/fabric-java-sdk | public FileKeyValStore ( String file ) { this . file = file ; }
psaradhi/fabric-java-sdk | public String getValue ( String name ) { Properties properties = loadProperties ( ) ; return ( String ) properties . getProperty ( name ) ; }
psaradhi/fabric-java-sdk | private Properties loadProperties ( ) { Properties properties = new Properties ( ) ; try ( InputStream input = new FileInputStream ( file ) ; ) { properties . load ( input ) ; input . close ( ) ; } catch ( FileNotFoundException e ) { logger . warn ( String . format ( " Could ▁ not ▁ find ▁ the ▁ file ▁ \" % s \" " , file ) ) ; } catch ( IOException e ) { logger . warn ( String . format ( " Could ▁ not ▁ load ▁ keyvalue ▁ store ▁ from ▁ file ▁ \" % s \" , ▁ reason : % s " , file , e . getMessage ( ) ) ) ; } return properties ; }
psaradhi/fabric-java-sdk | public void setValue ( String name , String value ) { Properties properties = loadProperties ( ) ; try ( OutputStream output = new FileOutputStream ( file ) ; ) { properties . setProperty ( name , value ) ; properties . store ( output , " " ) ; output . close ( ) ; } catch ( IOException e ) { logger . warn ( String . format ( " Could ▁ not ▁ save ▁ the ▁ keyvalue ▁ store , ▁ reason : % s " , e . getMessage ( ) ) ) ; } }
multi-os-engine/moe-core | @ Generated private ACAccountCredentialRenewResult ( ) { }
TACTfactory/harmony-core | protected void routerDebug ( ) { }
TACTfactory/harmony-core | public void generateManifest ( ) { }
TACTfactory/harmony-core | @ Override public final void summary ( ) { LinkedHashMap < String , String > commands = new LinkedHashMap < String , String > ( ) ; commands . put ( ROUTER_DEBUG , " List ▁ all ▁ URI " ) ; commands . put ( ROUTER_GENERATE_MANIFEST , " Generate ▁ Manifest " ) ; ConsoleUtils . displaySummary ( BUNDLE , commands ) ; }
TACTfactory/harmony-core | @ Override public final void execute ( final String action , final String [ ] args , final String option ) { }
TACTfactory/harmony-core | @ Override public final boolean isAvailableCommand ( final String command ) { return false ; }
star3136/DemoCollection | public void registerDataObseraver ( ExpandableConnectorAdapter . ConnectorDataObserver dataObserver ) { mObservable . registerObserver ( dataObserver ) ; }
star3136/DemoCollection | public void unregisterDataObserver ( ExpandableConnectorAdapter . ConnectorDataObserver dataObserver ) { mObservable . unregisterObserver ( dataObserver ) ; }
star3136/DemoCollection | public final void notifyDataSetChanged ( ) { mObservable . notifyChanged ( ) ; }
star3136/DemoCollection | @ Override public void notifyGroupInserted ( int groupPosition ) { mObservable . notifyGroupRangeInserted ( groupPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildInserted ( int groupPosition , int childPosition ) { mObservable . notifyChildRangeInserted ( groupPosition , childPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeInserted ( int groupPosition , int childPosition , int itemCount ) { mObservable . notifyChildRangeInserted ( groupPosition , childPosition , itemCount ) ; }
star3136/DemoCollection | @ Override public void notifyChildChanged ( int groupPosition , int childPosition ) { mObservable . notifyChildRangeChanged ( groupPosition , childPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildChanged ( int groupPosition , int childPosition , Object payload ) { mObservable . notifyChildRangeChanged ( groupPosition , childPosition , 1 , payload ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRangeChanged ( int positionStart , int itemCount ) { mObservable . notifyGroupRangeChanged ( positionStart , itemCount , null ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRangeChanged ( int positionStart , int itemCount , Object payload ) { mObservable . notifyGroupRangeChanged ( positionStart , itemCount , payload ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeChanged ( int groupPosition , int positionStart , int itemCount ) { mObservable . notifyChildRangeChanged ( groupPosition , positionStart , itemCount ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeChanged ( int groupPosition , int positionStart , int itemCount , Object payload ) { mObservable . notifyChildRangeChanged ( groupPosition , positionStart , itemCount , payload ) ; }
star3136/DemoCollection | @ Override public void notifyGroupMoved ( int fromPosition , int toPosition ) { mObservable . notifyGroupMoved ( fromPosition , toPosition ) ; }
star3136/DemoCollection | @ Override public void notifyChildMoved ( int groupPosition , int fromPosition , int toPosition ) { mObservable . notifyChildMoved ( groupPosition , fromPosition , toPosition ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRemoved ( int groupPosition ) { mObservable . notifyGroupRangeRemoved ( groupPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildRemoved ( int groupPosition , int position ) { mObservable . notifyChildRangeRemoved ( groupPosition , position , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRangeRemoved ( int positionStart , int itemCount ) { mObservable . notifyGroupRangeRemoved ( positionStart , itemCount ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeRemoved ( int groupPosition , int positionStart , int itemCount ) { mObservable . notifyChildRangeRemoved ( groupPosition , positionStart , itemCount ) ; }
star3136/DemoCollection | @ Override public long getChildId ( int groupPosition , int childPosition ) { return getChild ( groupPosition , childPosition ) . hashCode ( ) ; }
star3136/DemoCollection | @ Override public long getGroupId ( int groupPosition ) { return getGroup ( groupPosition ) . hashCode ( ) ; }
shin285/KOMORAN | @ Before public void init ( ) { }
shin285/KOMORAN | @ Test public void NothingYet_Test ( ) { }
Xylus/pinpoint | public Observable < String > hello ( final String name ) { return Observable . create ( new Observable . OnSubscribe < String > ( ) { @ Override public void call ( Subscriber < ? super String > subscriber ) { if ( ! subscriber . isUnsubscribed ( ) ) { String message = helloRepository . hello ( name ) ; subscriber . onNext ( message ) ; subscriber . onCompleted ( ) ; } } } ) . subscribeOn ( Schedulers . io ( ) ) ; }
Xylus/pinpoint | public Observable < String > hello ( final String name , final Exception exception ) { return Observable . create ( new Observable . OnSubscribe < String > ( ) { @ Override public void call ( Subscriber < ? super String > subscriber ) { try { if ( ! subscriber . isUnsubscribed ( ) ) { String message = helloRepository . hello ( name , exception ) ; subscriber . onNext ( message ) ; subscriber . onCompleted ( ) ; } } catch ( Exception e ) { subscriber . onError ( e ) ; } } } ) . subscribeOn ( Schedulers . io ( ) ) ; }
Xylus/pinpoint | public Observable < String > hello ( final String name , final long delayMs ) { return Observable . create ( new Observable . OnSubscribe < String > ( ) { @ Override public void call ( Subscriber < ? super String > subscriber ) { try { if ( ! subscriber . isUnsubscribed ( ) ) { String message = helloRepository . hello ( name , delayMs ) ; subscriber . onNext ( message ) ; subscriber . onCompleted ( ) ; } } catch ( Exception e ) { subscriber . onError ( e ) ; } } } ) . subscribeOn ( Schedulers . io ( ) ) ; }
freeVM/freeVM | public void test_missingFormatWidthException ( ) { try { new MissingFormatWidthException ( null ) ; fail ( " should ▁ throw ▁ NullPointerExcepiton " ) ; } catch ( NullPointerException e ) { } }
freeVM/freeVM | public void test_getFormatSpecifier ( ) { String s = " MYTESTSTRING " ; MissingFormatWidthException missingFormatWidthException = new MissingFormatWidthException ( s ) ; assertEquals ( s , missingFormatWidthException . getFormatSpecifier ( ) ) ; }
freeVM/freeVM | public void test_getMessage ( ) { String s = " MYTESTSTRING " ; MissingFormatWidthException missingFormatWidthException = new MissingFormatWidthException ( s ) ; assertTrue ( null != missingFormatWidthException . getMessage ( ) ) ; }
freeVM/freeVM | public void testSerializationSelf ( ) throws Exception { SerializationTest . verifySelf ( new MissingFormatWidthException ( " MYTESTSTRING " ) , exComparator ) ; }
freeVM/freeVM | public void testSerializationCompatibility ( ) throws Exception { SerializationTest . verifyGolden ( this , new MissingFormatWidthException ( " MYTESTSTRING " ) , exComparator ) ; }
Muni10/flyway | public AndroidScanner ( ClassLoader classLoader ) { this . classLoader = classLoader ; context = ContextHolder . getContext ( ) ; if ( context == null ) { throw new FlywayException ( " Unable ▁ to ▁ scan ▁ for ▁ Migrations ! ▁ Context ▁ not ▁ set . ▁ " + " Within ▁ an ▁ activity ▁ you ▁ can ▁ fix ▁ this ▁ with ▁ org . flywaydb . core . api . android . ContextHolder . setContext ( this ) ; " ) ; } }
Muni10/flyway | public LoadableResource [ ] scanForResources ( Location location , String prefix , String suffix ) throws Exception { List < LoadableResource > resources = new ArrayList < LoadableResource > ( ) ; String path = location . getPath ( ) ; for ( String asset : context . getAssets ( ) . list ( path ) ) { if ( asset . startsWith ( prefix ) && asset . endsWith ( suffix ) && ( asset . length ( ) > ( prefix + suffix ) . length ( ) ) ) { resources . add ( new AndroidResource ( context . getAssets ( ) , path , asset ) ) ; } else { LOG . debug ( " Filtering ▁ out ▁ asset : ▁ " + asset ) ; } } return resources . toArray ( new LoadableResource [ resources . size ( ) ] ) ; }
Muni10/flyway | public Class < ? > [ ] scanForClasses ( Location location , Class < ? > implementedInterface ) throws Exception { String pkg = location . getPath ( ) . replace ( " / " , " . " ) ; List < Class > classes = new ArrayList < Class > ( ) ; DexFile dex = new DexFile ( context . getApplicationInfo ( ) . sourceDir ) ; Enumeration < String > entries = dex . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String className = entries . nextElement ( ) ; if ( className . startsWith ( pkg ) ) { Class < ? > clazz = classLoader . loadClass ( className ) ; if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) ) { LOG . debug ( " Skipping ▁ abstract ▁ class : ▁ " + className ) ; continue ; } if ( ! implementedInterface . isAssignableFrom ( clazz ) ) { continue ; } ClassUtils . instantiate ( className , classLoader ) ; classes . add ( clazz ) ; LOG . debug ( " Found ▁ class : ▁ " + className ) ; } } return classes . toArray ( new Class < ? > [ classes . size ( ) ] ) ; }
xiangzhuyuan/spring-security-oauth | @ Before public void init ( ) { template = new OAuth2RestTemplate ( resource , new DefaultOAuth2ClientContext ( ) ) ; }
xiangzhuyuan/spring-security-oauth | @ Test public void testForRedirectWithNoToken ( ) throws Exception { try { template . getForObject ( http . getUrl ( " / " ) , String . class ) ; fail ( " Expected ▁ UserRedirectRequiredException " ) ; } catch ( UserRedirectRequiredException e ) { String message = e . getMessage ( ) ; assertTrue ( " Wrong ▁ message : ▁ " + message , message . contains ( " A ▁ redirect ▁ is ▁ required ▁ to ▁ get ▁ the ▁ users ▁ approval " ) ) ; } }
syntelos/gwtcc | public BindingProperty createBinding ( String name ) { BindingProperty prop = create ( name , BindingProperty . class ) ; bindingProps . add ( prop ) ; return prop ; }
syntelos/gwtcc | public ConfigurationProperty createConfiguration ( String name , boolean allowMultipleValues ) { ConfigurationProperty prop = create ( name , allowMultipleValues , ConfigurationProperty . class ) ; configProps . add ( prop ) ; return prop ; }
syntelos/gwtcc | public Property find ( String name ) { return map . get ( name ) ; }
syntelos/gwtcc | public SortedSet < BindingProperty > getBindingProperties ( ) { return bindingProps ; }
syntelos/gwtcc | public SortedSet < ConfigurationProperty > getConfigurationProperties ( ) { return configProps ; }
syntelos/gwtcc | public Iterator < Property > iterator ( ) { return map . values ( ) . iterator ( ) ; }
syntelos/gwtcc | private < T extends Property > T create ( String name , boolean flag , boolean useFlagArgument , Class < T > clazz ) { if ( clazz == null ) { throw new NullPointerException ( " clazz " ) ; } else if ( name == null ) { throw new NullPointerException ( " name " ) ; } Property property = find ( name ) ; if ( property != null ) { try { return clazz . cast ( property ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( " Cannot ▁ create ▁ property ▁ " + name + " ▁ because ▁ one ▁ of ▁ another ▁ type ▁ ( " + property . getClass ( ) . getSimpleName ( ) + " ) ▁ already ▁ exists . " ) ; } } Exception ex = null ; try { T newInstance ; if ( useFlagArgument ) { newInstance = clazz . getConstructor ( String . class , boolean . class ) . newInstance ( name , flag ) ; } else { newInstance = clazz . getConstructor ( String . class ) . newInstance ( name ) ; } map . put ( name , newInstance ) ; return newInstance ; } catch ( NoSuchMethodException e ) { ex = e ; } catch ( InstantiationException e ) { ex = e ; } catch ( IllegalAccessException e ) { ex = e ; } catch ( InvocationTargetException e ) { ex = e ; } throw new RuntimeException ( " Unable ▁ to ▁ create ▁ Property ▁ instance " , ex ) ; }
syntelos/gwtcc | private < T extends Property > T create ( String name , boolean flag , Class < T > clazz ) { return create ( name , flag , true , clazz ) ; }
syntelos/gwtcc | private < T extends Property > T create ( String name , Class < T > clazz ) { return create ( name , false , false , clazz ) ; }
jenkinsci/gmaven | public void testRender ( ) throws Exception { chew ( " interfaces . groovy . txt " ) ; }
kangaroo-server/kangaroo | @ Before public void bootstrap ( ) { getSession ( ) . beginTransaction ( ) ; this . client = mock ( Client . class ) ; this . webTarget = mock ( WebTarget . class ) ; this . builder = mock ( Builder . class ) ; this . getResponse = mock ( Response . class ) ; doReturn ( webTarget ) . when ( client ) . target ( anyString ( ) ) ; doReturn ( builder ) . when ( webTarget ) . request ( ) ; doReturn ( builder ) . when ( builder ) . header ( any ( ) , any ( ) ) ; doReturn ( getResponse ) . when ( builder ) . get ( ) ; doReturn ( Status . OK ) . when ( getResponse ) . getStatusInfo ( ) ; this . githubAuth = new GithubAuthenticator ( ) ; this . githubAuth . setClient ( client ) ; this . githubAuth . setSession ( getSession ( ) ) ; }
kangaroo-server/kangaroo | @ After public void cleanup ( ) { Transaction t = getSession ( ) . getTransaction ( ) ; if ( t . isActive ( ) ) { t . commit ( ) ; } }
kangaroo-server/kangaroo | @ Test public void testStaticAccessors ( ) { assertEquals ( " https : // github . com / login / oauth / authorize " , githubAuth . getAuthEndpoint ( ) ) ; assertEquals ( " https : // github . com / login / oauth / access _ token " , githubAuth . getTokenEndpoint ( ) ) ; assertEquals ( " read : user , user : email " , githubAuth . getScopes ( ) ) ; }
kangaroo-server/kangaroo | @ Test public void testLoadUser ( ) { OAuth2IdPToken result = new OAuth2IdPToken ( ) ; result . setAccessToken ( " github _ access _ token " ) ; GithubUserEntity user = new GithubUserEntity ( ) ; user . setId ( RandomUtils . nextInt ( ) ) ; user . setName ( " test ▁ name " ) ; doReturn ( user ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; OAuth2User returnedUser = githubAuth . loadUserIdentity ( result ) ; assertEquals ( returnedUser . getId ( ) , user . getId ( ) . toString ( ) ) ; assertEquals ( " test ▁ name " , returnedUser . getClaims ( ) . get ( " name " ) ) ; }
kangaroo-server/kangaroo | @ Test ( expected = ThirdPartyErrorException . class ) public void testLoadUserWithRemoteError ( ) { OAuth2IdPToken result = new OAuth2IdPToken ( ) ; result . setAccessToken ( " github _ access _ token " ) ; Map < String , String > response = new HashMap < > ( ) ; response . put ( " error " , " test " ) ; response . put ( " error _ description " , " description " ) ; doReturn ( Status . BAD_REQUEST ) . when ( getResponse ) . getStatusInfo ( ) ; doReturn ( response ) . when ( getResponse ) . readEntity ( GithubAuthenticator . MAP_TYPE ) ; githubAuth . loadUserIdentity ( result ) ; }
kangaroo-server/kangaroo | @ Test ( expected = ThirdPartyErrorException . class ) public void testLoadUserUnparseable ( ) { OAuth2IdPToken result = new OAuth2IdPToken ( ) ; result . setAccessToken ( " github _ access _ token " ) ; doThrow ( ProcessingException . class ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; githubAuth . loadUserIdentity ( result ) ; }
kangaroo-server/kangaroo | @ Test ( expected = ThirdPartyErrorException . class ) public void testLoadUserNoResponse ( ) { OAuth2IdPToken idPToken = new OAuth2IdPToken ( ) ; idPToken . setAccessToken ( " github _ access _ token " ) ; GithubUserEntity result = new GithubUserEntity ( ) ; doReturn ( result ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; githubAuth . loadUserIdentity ( idPToken ) ; }
kangaroo-server/kangaroo | @ Test ( expected = Exception . class ) public void testLoadUserErrorOnClose ( ) { OAuth2IdPToken idPToken = new OAuth2IdPToken ( ) ; idPToken . setAccessToken ( " github _ access _ token " ) ; GithubUserEntity testUser = new GithubUserEntity ( ) ; testUser . setId ( RandomUtils . nextInt ( ) ) ; testUser . setName ( " Some ▁ Random ▁ Name " ) ; testUser . setEmail ( " lol @ example . com " ) ; doReturn ( testUser ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; doThrow ( Exception . class ) . when ( getResponse ) . close ( ) ; MultivaluedStringMap params = new MultivaluedStringMap ( ) ; params . putSingle ( " code " , " valid _ code " ) ; githubAuth . loadUserIdentity ( idPToken ) ; }
denkers/jdamvc-framework | public Command ( String commandName , String [ ] paramTypes , String className , String methodName , String commandDescription ) { this . commandName = commandName ; this . paramTypes = paramTypes ; this . className = className ; this . methodName = methodName ; this . commandDescription = commandDescription ; }
denkers/jdamvc-framework | public Object call ( String [ ] params , Object instance ) { try { if ( params . length > paramTypes . length || params . length < paramTypes . length ) throw new NoSuchMethodException ( ) ; Class < ? > viewClass = Class . forName ( className ) ; Method listenMethod ; if ( instance == null ) instance = viewClass . newInstance ( ) ; if ( params . length > 0 ) { listenMethod = viewClass . getMethod ( methodName , Class . forName ( paramTypes [ 0 ] ) ) ; return listenMethod . invoke ( instance , ( Object [ ] ) params ) ; } else { listenMethod = viewClass . getDeclaredMethod ( methodName , new Class [ ] { } ) ; return listenMethod . invoke ( instance ) ; } } catch ( ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e ) { ExceptionOutput . output ( e . getMessage ( ) , ExceptionOutput . OutputType . DEBUG ) ; return null ; } }
denkers/jdamvc-framework | public String getCommandName ( ) { return commandName ; }
denkers/jdamvc-framework | public String getCommandDescription ( ) { return commandDescription ; }
denkers/jdamvc-framework | public String [ ] getParamTypes ( ) { return paramTypes ; }
denkers/jdamvc-framework | public String getClassName ( ) { return className ; }
denkers/jdamvc-framework | public String getMethodName ( ) { return methodName ; }
denkers/jdamvc-framework | public void setCommandName ( String commandName ) { this . commandName = commandName ; }
denkers/jdamvc-framework | public void setCommandDescription ( String commandDescription ) { this . commandDescription = commandDescription ; }
denkers/jdamvc-framework | public void setParamTypes ( String [ ] paramTypes ) { this . paramTypes = paramTypes ; }
denkers/jdamvc-framework | public void setClassName ( String className ) { this . className = className ; }
denkers/jdamvc-framework | public void setMethodName ( String methodName ) { this . methodName = methodName ; }
denkers/jdamvc-framework | @ Override public String toString ( ) { String output = MessageFormat . format ( " Command : ▁ { 0 } \n Command ▁ class : ▁ { 1 } \n Command ▁ method : ▁ { 2 } \n Method ▁ param ▁ count : ▁ { 3 } \n " , commandName , className , methodName , paramTypes [ 0 ] ) ; return output ; }
jpalves/ojAlgo | SuperimposedStore ( final MatrixStore < N > base , final int row , final int column , final MatrixStore < N > diff ) { super ( ( int ) base . countRows ( ) , ( int ) base . countColumns ( ) , base ) ; myRowFirst = row ; myColFirst = column ; final int tmpDiffRowDim = ( int ) diff . countRows ( ) ; final int tmpDiffColDim = ( int ) diff . countColumns ( ) ; myRowLimit = row + tmpDiffRowDim ; myColLimit = column + tmpDiffColDim ; myDiff = diff ; }
jpalves/ojAlgo | private SuperimposedStore ( final int rowsCount , final int columnsCount , final MatrixStore < N > base ) { this ( base , 0 , 0 , ( MatrixStore < N > ) null ) ; ProgrammingError . throwForIllegalInvocation ( ) ; }
jpalves/ojAlgo | SuperimposedStore ( final MatrixStore < N > base , final MatrixStore < N > diff ) { this ( base , 0 , 0 , diff ) ; }
jpalves/ojAlgo | public double doubleValue ( final long row , final long column ) { double retVal = this . getBase ( ) . doubleValue ( row , column ) ; if ( this . isCovered ( ( int ) row , ( int ) column ) ) { retVal += myDiff . doubleValue ( row - myRowFirst , column - myColFirst ) ; } return retVal ; }
jpalves/ojAlgo | public N get ( final long row , final long column ) { N retVal = this . getBase ( ) . get ( row , column ) ; if ( this . isCovered ( ( int ) row , ( int ) column ) ) { retVal = myDiff . toScalar ( ( int ) row - myRowFirst , ( int ) column - myColFirst ) . add ( retVal ) . getNumber ( ) ; } return retVal ; }
jpalves/ojAlgo | public Scalar < N > toScalar ( final long row , final long column ) { Scalar < N > retVal = this . getBase ( ) . toScalar ( row , column ) ; if ( this . isCovered ( ( int ) row , ( int ) column ) ) { retVal = retVal . add ( myDiff . get ( row - myRowFirst , column - myColFirst ) ) ; } return retVal ; }
jpalves/ojAlgo | private final boolean isCovered ( final int row , final int column ) { return ( myRowFirst <= row ) && ( myColFirst <= column ) && ( row < myRowLimit ) && ( column < myColLimit ) ; }
jisqyv/appinventor-sources | private TypeUtil ( ) { }
Reimerei/flatbuffers | public Stat __init ( int _i , ByteBuffer _bb ) { bb_pos = _i ; bb = _bb ; return this ; }
Reimerei/flatbuffers | public String id ( ) { int o = __offset ( 4 ) ; return o != 0 ? __string ( o + bb_pos ) : null ; }
Reimerei/flatbuffers | public ByteBuffer idAsByteBuffer ( ) { return __vector_as_bytebuffer ( 4 , 1 ) ; }
Reimerei/flatbuffers | public long val ( ) { int o = __offset ( 6 ) ; return o != 0 ? bb . getLong ( o + bb_pos ) : 0 ; }
Reimerei/flatbuffers | public boolean mutateVal ( long val ) { int o = __offset ( 6 ) ; if ( o != 0 ) { bb . putLong ( o + bb_pos , val ) ; return true ; } else { return false ; } }
Reimerei/flatbuffers | public int count ( ) { int o = __offset ( 8 ) ; return o != 0 ? bb . getShort ( o + bb_pos ) & 0xFFFF : 0 ; }
Reimerei/flatbuffers | public boolean mutateCount ( int count ) { int o = __offset ( 8 ) ; if ( o != 0 ) { bb . putShort ( o + bb_pos , ( short ) count ) ; return true ; } else { return false ; } }
yuananf/presto | @ BeforeMethod public void setupDatabase ( ) { TypeRegistry typeRegistry = new TypeRegistry ( ) ; dbi = new DBI ( " jdbc : h2 : mem : test " + System . nanoTime ( ) ) ; dbi . registerMapper ( new TableColumn . Mapper ( typeRegistry ) ) ; dbi . registerMapper ( new Distribution . Mapper ( typeRegistry ) ) ; dummyHandle = dbi . open ( ) ; createTablesWithRetry ( dbi ) ; RaptorConnectorId connectorId = new RaptorConnectorId ( " raptor " ) ; NodeManager nodeManager = new TestingNodeManager ( ) ; NodeSupplier nodeSupplier = nodeManager :: getWorkerNodes ; shardManager = createShardManager ( dbi , nodeSupplier , systemTicker ( ) ) ; metadata = new RaptorMetadata ( connectorId . toString ( ) , dbi , shardManager ) ; }
yuananf/presto | @ AfterMethod ( alwaysRun = true ) public void cleanupDatabase ( ) { dummyHandle . close ( ) ; }
yuananf/presto | @ Test public void testRenameColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle columnHandle = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . renameColumn ( SESSION , raptorTableHandle , columnHandle , " orderkey _ renamed " ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey _ renamed " ) ) ; }
yuananf/presto | @ Test public void testAddColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; metadata . addColumn ( SESSION , raptorTableHandle , new ColumnMetadata ( " new _ col " , BIGINT ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , raptorTableHandle ) . get ( " new _ col " ) ) ; }
yuananf/presto | @ Test public void testDropColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle lastColumn = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . dropColumn ( SESSION , raptorTableHandle , lastColumn ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; }
yuananf/presto | @ Test public void testAddColumnAfterDropColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle column = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . dropColumn ( SESSION , raptorTableHandle , column ) ; metadata . addColumn ( SESSION , raptorTableHandle , new ColumnMetadata ( " new _ col " , BIGINT ) ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , raptorTableHandle ) . get ( " new _ col " ) ) ; }
yuananf/presto | @ Test public void testDropColumnDisallowed ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; Map < String , Object > properties = ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , ORDERING_PROPERTY , ImmutableList . of ( " totalprice " ) , TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ; ConnectorTableMetadata ordersTable = buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " totalprice " , DOUBLE ) . column ( " orderdate " , DATE ) . column ( " highestid " , BIGINT ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle ordersTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( ordersTableHandle , RaptorTableHandle . class ) ; RaptorTableHandle ordersRaptorTableHandle = ( RaptorTableHandle ) ordersTableHandle ; assertEquals ( ordersRaptorTableHandle . getTableId ( ) , 1 ) ; assertInstanceOf ( ordersRaptorTableHandle , RaptorTableHandle . class ) ; ColumnHandle bucketColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " orderkey " ) ; assertThrows ( " Cannot ▁ drop ▁ bucket ▁ columns " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , bucketColumn ) ) ; ColumnHandle sortColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " totalprice " ) ; assertThrows ( " Cannot ▁ drop ▁ sort ▁ columns " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , sortColumn ) ) ; ColumnHandle temporalColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " orderdate " ) ; assertThrows ( " Cannot ▁ drop ▁ the ▁ temporal ▁ column " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , temporalColumn ) ) ; ColumnHandle highestColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " highestid " ) ; assertThrows ( " Cannot ▁ drop ▁ the ▁ column ▁ which ▁ has ▁ the ▁ largest ▁ column ▁ ID ▁ in ▁ the ▁ table " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , highestColumn ) ) ; }
yuananf/presto | @ Test public void testRenameTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; SchemaTableName renamedTable = new SchemaTableName ( raptorTableHandle . getSchemaName ( ) , " orders _ renamed " ) ; metadata . renameTable ( SESSION , raptorTableHandle , renamedTable ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableHandle renamedTableHandle = metadata . getTableHandle ( SESSION , renamedTable ) ; assertNotNull ( renamedTableHandle ) ; assertEquals ( ( ( RaptorTableHandle ) renamedTableHandle ) . getTableName ( ) , renamedTable . getTableName ( ) ) ; }
yuananf/presto | @ Test public void testCreateTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; assertEquals ( ( ( RaptorTableHandle ) tableHandle ) . getTableId ( ) , 1 ) ; ConnectorTableMetadata table = metadata . getTableMetadata ( SESSION , tableHandle ) ; assertTableEqual ( table , getOrdersTable ( ) ) ; ColumnHandle columnHandle = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; assertInstanceOf ( columnHandle , RaptorColumnHandle . class ) ; assertEquals ( ( ( RaptorColumnHandle ) columnHandle ) . getColumnId ( ) , 1 ) ; ColumnMetadata columnMetadata = metadata . getColumnMetadata ( SESSION , tableHandle , columnHandle ) ; assertNotNull ( columnMetadata ) ; assertEquals ( columnMetadata . getName ( ) , " orderkey " ) ; assertEquals ( columnMetadata . getType ( ) , BIGINT ) ; }
yuananf/presto | @ Test public void testTableProperties ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) , TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , true ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , Long . valueOf ( 4 ) ) ; assertFalse ( metadataDao . getTableInformation ( tableId ) . isOrganized ( ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testTablePropertiesWithOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) , ORGANIZED_PROPERTY , true ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertTrue ( metadataDao . getTableInformation ( tableId ) . isOrganized ( ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testCreateBucketedTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " custkey " , " orderkey " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 1 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; metadata . createTable ( SESSION , ordersTable , false ) ; tableId = ( ( RaptorTableHandle ) metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) . getTableId ( ) ; assertEquals ( tableId , 2 ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 2 ) ) ; }
yuananf/presto | @ Test public void testCreateBucketedTableAsSelect ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 32 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " , " custkey " ) ) ) ; ConnectorNewTableLayout layout = metadata . getNewTableLayout ( SESSION , ordersTable ) . get ( ) ; assertEquals ( layout . getPartitionColumns ( ) , ImmutableList . of ( " orderkey " , " custkey " ) ) ; assertInstanceOf ( layout . getPartitioning ( ) , RaptorPartitioningHandle . class ) ; RaptorPartitioningHandle partitioning = ( RaptorPartitioningHandle ) layout . getPartitioning ( ) ; assertEquals ( partitioning . getDistributionId ( ) , 1 ) ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , ordersTable , Optional . of ( layout ) ) ; metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . of ( 1 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 32 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testCreateBucketedTableExistingDistribution ( ) { MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata table = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , DISTRIBUTION_NAME_PROPERTY , " orders " ) ) ; metadata . createTable ( SESSION , table , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; long tableId = raptorTableHandle . getTableId ( ) ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_LINEITEMS ) ) ; table = getLineItemsTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , DISTRIBUTION_NAME_PROPERTY , " orders " ) ) ; metadata . createTable ( SESSION , table , false ) ; tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_LINEITEMS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; raptorTableHandle = ( RaptorTableHandle ) tableHandle ; tableId = raptorTableHandle . getTableId ( ) ; assertEquals ( tableId , 2 ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_LINEITEMS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Ordering ▁ column ▁ does ▁ not ▁ exist : ▁ orderdatefoo " ) public void testInvalidOrderingColumns ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdatefoo " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; fail ( " Expected ▁ createTable ▁ to ▁ fail " ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Temporal ▁ column ▁ does ▁ not ▁ exist : ▁ foo " ) public void testInvalidTemporalColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " foo " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; fail ( " Expected ▁ createTable ▁ to ▁ fail " ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Temporal ▁ column ▁ must ▁ be ▁ of ▁ type ▁ timestamp ▁ or ▁ date : ▁ orderkey " ) public void testInvalidTemporalColumnType ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderkey " ) ) , false ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Table ▁ with ▁ temporal ▁ columns ▁ cannot ▁ be ▁ organized " ) public void testInvalidTemporalOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderdate " , ORGANIZED_PROPERTY , true ) ) , false ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Table ▁ organization ▁ requires ▁ an ▁ ordering " ) public void testInvalidOrderingOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( ORGANIZED_PROPERTY , true ) ) , false ) ; }
yuananf/presto | @ Test public void testSortOrderProperty ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , null ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testTemporalColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertEquals ( sortColumns . size ( ) , 0 ) ; assertEquals ( sortColumns , ImmutableList . of ( ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , Long . valueOf ( 4 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testListTables ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; List < SchemaTableName > tables = metadata . listTables ( SESSION , null ) ; assertEquals ( tables , ImmutableList . of ( DEFAULT_TEST_ORDERS ) ) ; }
yuananf/presto | @ Test public void testListTableColumns ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; Map < SchemaTableName , List < ColumnMetadata > > columns = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( ) ) ; assertEquals ( columns , ImmutableMap . of ( DEFAULT_TEST_ORDERS , getOrdersTable ( ) . getColumns ( ) ) ) ; }
yuananf/presto | @ Test public void testListTableColumnsFiltering ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; Map < SchemaTableName , List < ColumnMetadata > > filterCatalog = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( ) ) ; Map < SchemaTableName , List < ColumnMetadata > > filterSchema = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( " test " ) ) ; Map < SchemaTableName , List < ColumnMetadata > > filterTable = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( " test " , " orders " ) ) ; assertEquals ( filterCatalog , filterSchema ) ; assertEquals ( filterCatalog , filterTable ) ; }
yuananf/presto | @ Test public void testTableIdentity ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle connectorTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; TableIdentity tableIdentity = metadata . getTableIdentity ( connectorTableHandle ) ; byte [ ] bytes = tableIdentity . serialize ( ) ; assertEquals ( tableIdentity , metadata . deserializeTableIdentity ( bytes ) ) ; byte version = 1 ; long tableId = 12345678L ; ByteArrayDataOutput dataOutput = newDataOutput ( ) ; dataOutput . writeByte ( version ) ; dataOutput . writeLong ( tableId ) ; byte [ ] testBytes = dataOutput . toByteArray ( ) ; TableIdentity testTableIdentity = metadata . deserializeTableIdentity ( testBytes ) ; assertEquals ( testTableIdentity , new RaptorTableIdentity ( tableId ) ) ; }
yuananf/presto | @ Test public void testColumnIdentity ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle connectorTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; Map < String , ColumnHandle > columnHandles = metadata . getColumnHandles ( SESSION , connectorTableHandle ) ; ColumnIdentity orderKeyColumnIdentity = metadata . getColumnIdentity ( columnHandles . get ( " orderkey " ) ) ; byte [ ] bytes = orderKeyColumnIdentity . serialize ( ) ; assertEquals ( orderKeyColumnIdentity , metadata . deserializeColumnIdentity ( bytes ) ) ; byte version = 1 ; long columnId = 123456789012L ; ByteArrayDataOutput dataOutput = newDataOutput ( ) ; dataOutput . writeByte ( version ) ; dataOutput . writeLong ( columnId ) ; byte [ ] testBytes = dataOutput . toByteArray ( ) ; ColumnIdentity testColumnIdentity = metadata . deserializeColumnIdentity ( testBytes ) ; assertEquals ( testColumnIdentity , new RaptorColumnIdentity ( columnId ) ) ; }
yuananf/presto | @ Test public void testViews ( ) { SchemaTableName test1 = new SchemaTableName ( " test " , " test _ view1" ) ; SchemaTableName test2 = new SchemaTableName ( " test " , " test _ view2" ) ; metadata . createView ( SESSION , test1 , " test1" , false ) ; metadata . createView ( SESSION , test2 , " test2" , false ) ; List < SchemaTableName > list = metadata . listViews ( SESSION , " test " ) ; assertEqualsIgnoreOrder ( list , ImmutableList . of ( test1 , test2 ) ) ; Map < SchemaTableName , ConnectorViewDefinition > views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertEquals ( views . keySet ( ) , ImmutableSet . of ( test1 , test2 ) ) ; assertEquals ( views . get ( test1 ) . getViewData ( ) , " test1" ) ; assertEquals ( views . get ( test2 ) . getViewData ( ) , " test2" ) ; metadata . dropView ( SESSION , test1 ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertEquals ( views . keySet ( ) , ImmutableSet . of ( test2 ) ) ; metadata . dropView ( SESSION , test2 ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertTrue ( views . isEmpty ( ) ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( ) ) ; assertTrue ( views . isEmpty ( ) ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " View ▁ already ▁ exists : ▁ test \\ . test _ view " ) public void testCreateViewWithoutReplace ( ) { SchemaTableName test = new SchemaTableName ( " test " , " test _ view " ) ; try { metadata . createView ( SESSION , test , " test " , false ) ; } catch ( Exception e ) { fail ( " should ▁ have ▁ succeeded " ) ; } metadata . createView ( SESSION , test , " test " , false ) ; }
yuananf/presto | @ Test public void testCreateViewWithReplace ( ) { SchemaTableName test = new SchemaTableName ( " test " , " test _ view " ) ; metadata . createView ( SESSION , test , " aaa " , true ) ; metadata . createView ( SESSION , test , " bbb " , true ) ; assertEquals ( metadata . getViews ( SESSION , test . toSchemaTablePrefix ( ) ) . get ( test ) . getViewData ( ) , " bbb " ) ; }
yuananf/presto | @ Test public void testTransactionSelect ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; assertFalse ( ( ( RaptorTableHandle ) tableHandle ) . getTransactionId ( ) . isPresent ( ) ) ; }
yuananf/presto | @ Test public void testTransactionTableWrite ( ) { long transactionId = 1 ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , getOrdersTable ( ) , Optional . empty ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
yuananf/presto | @ Test public void testTransactionInsert ( ) { long transactionId = 1 ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; ConnectorInsertTableHandle insertHandle = metadata . beginInsert ( SESSION , tableHandle ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishInsert ( SESSION , insertHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
yuananf/presto | @ Test public void testTransactionDelete ( ) { long transactionId = 1 ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; tableHandle = metadata . beginDelete ( SESSION , tableHandle ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; assertEquals ( raptorTableHandle . getTransactionId ( ) , OptionalLong . of ( transactionId ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . rollback ( ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertFalse ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; tableHandle = metadata . beginDelete ( SESSION , tableHandle ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishDelete ( SESSION , tableHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
yuananf/presto | @ Test public void testTransactionAbort ( ) { long transactionId = 1 ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , getOrdersTable ( ) , Optional . empty ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; shardManager . rollbackTransaction ( transactionId ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertFalse ( transactionSuccessful ( transactionId ) ) ; try { metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; fail ( " expected ▁ exception " ) ; } catch ( PrestoException e ) { assertEquals ( e . getErrorCode ( ) , TRANSACTION_CONFLICT . toErrorCode ( ) ) ; } }
yuananf/presto | private boolean transactionExists ( long transactionId ) { try ( Handle handle = dbi . open ( ) ) { return handle . createQuery ( " SELECT ▁ count ( * ) ▁ FROM ▁ transactions ▁ WHERE ▁ transaction _ id ▁ = ▁ ? " ) . bind ( 0 , transactionId ) . map ( BooleanMapper . FIRST ) . first ( ) ; } }
yuananf/presto | private Boolean transactionSuccessful ( long transactionId ) { try ( Handle handle = dbi . open ( ) ) { return ( Boolean ) handle . createQuery ( " SELECT ▁ successful ▁ FROM ▁ transactions ▁ WHERE ▁ transaction _ id ▁ = ▁ ? " ) . bind ( 0 , transactionId ) . first ( ) . get ( " successful " ) ; } }
yuananf/presto | private Long getTableDistributionId ( long tableId ) { try ( Handle handle = dbi . open ( ) ) { return handle . createQuery ( " SELECT ▁ distribution _ id ▁ FROM ▁ tables ▁ WHERE ▁ table _ id ▁ = ▁ ? " ) . bind ( 0 , tableId ) . map ( LongMapper . FIRST ) . first ( ) ; } }
scaffeinate/crack-the-code | public DetectCycleDirectedGraph ( ) { graph = new DirectedGraph < String > ( ) ; whiteSet = new HashSet < Vertex < String > > ( ) ; greySet = new HashSet < Vertex < String > > ( ) ; blackSet = new HashSet < Vertex < String > > ( ) ; }
scaffeinate/crack-the-code | public void constructGraph ( String [ ] input ) { GraphUtil . constructGraph ( graph , input ) ; vertices = graph . verticesSet ( ) ; }
scaffeinate/crack-the-code | public boolean detectCycle ( ) { whiteSet . addAll ( vertices ) ; for ( Vertex < String > vertex : vertices ) { if ( whiteSet . contains ( vertex ) ) { if ( detectCycleDFS ( vertex ) ) { return true ; } } } return false ; }
scaffeinate/crack-the-code | private boolean detectCycleDFS ( Vertex < String > vertex ) { if ( vertex == null ) { return false ; } whiteSet . remove ( vertex ) ; greySet . add ( vertex ) ; List < Vertex < String > > neighbours = graph . neighboursOf ( vertex ) ; for ( Vertex < String > neighbour : neighbours ) { if ( whiteSet . contains ( neighbour ) ) { if ( detectCycleDFS ( neighbour ) ) { return true ; } } else if ( greySet . contains ( neighbour ) ) { return true ; } } greySet . remove ( vertex ) ; blackSet . add ( vertex ) ; return false ; }
aozkesek/selenium-json-suite-runner | public FindElementCommandDriver ( ) { super ( LoggerFactory . getLogger ( FindElementCommandDriver . class ) ) ; }
aozkesek/selenium-json-suite-runner | @ Override public void execute ( CommandModel commandModel , SuiteDriver suiteDriver ) throws RuntimeException { WebElement webElement = findElement ( commandModel . getArgs ( ) . get ( 0 ) , suiteDriver ) ; commandModel . setValue ( webElement ) ; }
vjanmey/EpicMudfia | @ Override public String name ( ) { return " RandomAreaTemplates " ; }
vjanmey/EpicMudfia | @ Override public boolean isAdminMacro ( ) { return true ; }
vjanmey/EpicMudfia | @ Override public String runMacro ( HTTPRequest httpReq , String parm ) { final java . util . Map < String , String > parms = parseParms ( parm ) ; final MOB M = Authenticate . getAuthenticatedMob ( httpReq ) ; if ( M == null ) return " [ authentication ▁ error ] " ; try { final String last = httpReq . getUrlParameter ( " RTEMPLATE " ) ; if ( parms . containsKey ( " NEXT " ) ) { if ( parms . containsKey ( " RESET " ) ) { if ( last != null ) httpReq . removeUrlParameter ( " RTEMPLATE " ) ; return " " ; } if ( last == null ) return " ▁ @ break @ " ; List < String > fileList = ( List < String > ) httpReq . getRequestObjects ( ) . get ( " RANDOMAREATEMPLATESLIST " ) ; if ( fileList == null ) { fileList = new ArrayList < String > ( ) ; final List < String > templateDirs = new LinkedList < String > ( ) ; templateDirs . add ( " " ) ; while ( templateDirs . size ( ) > 0 ) { final String templateDirPath = templateDirs . remove ( 0 ) ; final CMFile templateDir = new CMFile ( Resources . buildResourcePath ( " randareas / " + templateDirPath ) , M ) ; for ( final CMFile file : templateDir . listFiles ( ) ) { if ( file . isDirectory ( ) && file . canRead ( ) ) templateDirs . add ( templateDirPath + file . getName ( ) + " / " ) ; else fileList . add ( templateDirPath + file . getName ( ) ) ; } } httpReq . getRequestObjects ( ) . put ( " RANDOMAREATEMPLATESLIST " , fileList ) ; } String lastID = " " ; for ( final String RC : fileList ) { if ( ( last . length ( ) > 0 ) && ( last . equals ( lastID ) ) && ( ! RC . equals ( lastID ) ) ) { httpReq . addFakeUrlParameter ( " RTEMPLATE " , RC ) ; return " " ; } lastID = RC ; } httpReq . addFakeUrlParameter ( " RTEMPLATE " , " " ) ; if ( parms . containsKey ( " EMPTYOK " ) ) return " < ! - - EMPTY - - > " ; return " ▁ @ break @ " ; } } catch ( final Exception e ) { return " [ an ▁ error ▁ occurred ▁ performing ▁ the ▁ last ▁ operation ] " ; } return " " ; }
PenguinSquad/Harvest-Festival | public PurchasableDestroy ( long cost , Building building ) { super ( cost , null ) ; this . building = building ; this . cost = cost ; this . resource = ( ( cost >= 0 ) ? " buy : " : " sell : " ) + building . getResource ( ) . toString ( ) . replace ( " : " , " _ " ) ; }
PenguinSquad/Harvest-Festival | @ Override public ItemStack getDisplayStack ( ) { return building . getSpawner ( ) ; }
PenguinSquad/Harvest-Festival | @ Override protected ItemStack getPurchasedStack ( ) { return building . getSpawner ( ) ; }
PenguinSquad/Harvest-Festival | @ Override public boolean canDo ( @ Nonnull World world , @ Nonnull EntityPlayer player , int amount ) { return amount == 1 && TownHelper . getClosestTownToEntity ( player , false ) . hasBuilding ( building ) ; }
PenguinSquad/Harvest-Festival | @ Override @ SuppressWarnings ( " unchecked " ) public boolean canList ( @ Nonnull World world , @ Nonnull EntityPlayer player ) { return TownHelper . getClosestTownToEntity ( player , false ) . hasBuilding ( building ) ; }
PenguinSquad/Harvest-Festival | @ Override public void onPurchased ( EntityPlayer player ) { TownData town = TownHelper . getClosestTownToEntity ( player , false ) ; TownBuilding theBuilding = town . getBuilding ( building ) ; HFTemplate template = BuildingRegistry . INSTANCE . getTemplateForBuilding ( building ) ; if ( template != null && theBuilding != null ) { template . removeBlocks ( player . world , theBuilding . pos , theBuilding . rotation , Blocks . AIR . getDefaultState ( ) , true ) ; if ( theBuilding . building == HFBuildings . FESTIVAL_GROUNDS ) { BuildingFestival . getFestivalTemplateFromFestival ( town . getFestival ( ) ) . removeBlocks ( player . world , theBuilding . pos , theBuilding . rotation , Blocks . AIR . getDefaultState ( ) , true ) ; } TownHelper . < TownDataServer > getClosestTownToEntity ( player , false ) . removeBuilding ( theBuilding ) ; } }
PenguinSquad/Harvest-Festival | @ Override public String getDisplayName ( ) { return TextHelper . formatHF ( " structures . demolish " , building . getLocalisedName ( ) ) ; }
PenguinSquad/Harvest-Festival | @ SideOnly ( Side . CLIENT ) @ Override public void addTooltip ( List < String > list ) { list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning1" ) ) ; list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning2" ) ) ; list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning3" ) ) ; }
signed/intellij-community | @ NotNull @ Override public String getProtocol ( ) { return PROTOCOL ; }
signed/intellij-community | @ Nullable @ Override protected String normalize ( @ NotNull String path ) { int p = path . indexOf ( SEPARATOR ) ; return p > 0 ? FileUtil . normalize ( path . substring ( 0 , p ) ) + path . substring ( p ) : super . normalize ( path ) ; }
signed/intellij-community | @ NotNull @ Override protected String extractLocalPath ( @ NotNull String rootPath ) { return StringUtil . trimEnd ( rootPath , SEPARATOR ) ; }
signed/intellij-community | @ NotNull @ Override protected String composeRootPath ( @ NotNull String localPath ) { return localPath + SEPARATOR ; }
signed/intellij-community | @ NotNull @ Override protected String extractRootPath ( @ NotNull String entryPath ) { int separatorIndex = entryPath . indexOf ( SEPARATOR ) ; assert separatorIndex >= 0 : " Path ▁ passed ▁ to ▁ JrtFileSystem ▁ must ▁ have ▁ a ▁ separator ▁ ' ! / ' : ▁ " + entryPath ; return entryPath . substring ( 0 , separatorIndex + SEPARATOR . length ( ) ) ; }
signed/intellij-community | @ NotNull @ Override protected ArchiveHandler getHandler ( @ NotNull VirtualFile entryFile ) { checkSubscription ( ) ; String homePath = extractLocalPath ( extractRootPath ( entryFile . getPath ( ) ) ) ; ArchiveHandler handler = myHandlers . get ( homePath ) ; if ( handler == null ) { handler = new JrtHandler ( homePath ) ; myHandlers . put ( homePath , handler ) ; ApplicationManager . getApplication ( ) . invokeLater ( ( ) -> LocalFileSystem . getInstance ( ) . refreshAndFindFileByPath ( homePath + " / release " ) , ModalityState . defaultModalityState ( ) ) ; } return handler ; }
signed/intellij-community | private void checkSubscription ( ) { if ( mySubscribed . getAndSet ( true ) ) return ; Application app = ApplicationManager . getApplication ( ) ; app . getMessageBus ( ) . connect ( app ) . subscribe ( VirtualFileManager . VFS_CHANGES , new BulkFileListener ( ) { @ Override public void after ( @ NotNull List < ? extends VFileEvent > events ) { Set < VirtualFile > toRefresh = null ; for ( VFileEvent event : events ) { if ( event . getFileSystem ( ) instanceof LocalFileSystem && event instanceof VFileContentChangeEvent ) { VirtualFile file = event . getFile ( ) ; if ( file != null && " release " . equals ( file . getName ( ) ) ) { String homePath = file . getParent ( ) . getPath ( ) ; ArchiveHandler handler = myHandlers . remove ( homePath ) ; if ( handler != null ) { handler . dispose ( ) ; VirtualFile root = findFileByPath ( composeRootPath ( homePath ) ) ; if ( root != null ) { ( ( NewVirtualFile ) root ) . markDirtyRecursively ( ) ; if ( toRefresh == null ) toRefresh = ContainerUtil . newHashSet ( ) ; toRefresh . add ( root ) ; } } } } } if ( toRefresh != null ) { boolean async = ! ApplicationManager . getApplication ( ) . isUnitTestMode ( ) ; RefreshQueue . getInstance ( ) . refresh ( async , true , null , toRefresh ) ; } } } ) ; }
signed/intellij-community | @ Override public VirtualFile findFileByPath ( @ NotNull String path ) { return VfsImplUtil . findFileByPath ( this , path ) ; }
signed/intellij-community | @ Override public VirtualFile findFileByPathIfCached ( @ NotNull String path ) { return VfsImplUtil . findFileByPathIfCached ( this , path ) ; }
signed/intellij-community | @ Override public VirtualFile refreshAndFindFileByPath ( @ NotNull String path ) { return VfsImplUtil . refreshAndFindFileByPath ( this , path ) ; }
signed/intellij-community | @ Override public void refresh ( boolean asynchronous ) { VfsImplUtil . refresh ( this , asynchronous ) ; }
signed/intellij-community | @ Override protected boolean isCorrectFileType ( @ NotNull VirtualFile local ) { return isModularJdk ( FileUtil . toSystemDependentName ( local . getPath ( ) ) ) ; }
PhilDatoon/CertIV_IntroOOP | Student ( ) { this . studentNum = 12345 ; for ( int x = 0 ; x < course . length ; x ++ ) { this . course [ x ] = new CollegeCourse ( ) ; } }
PhilDatoon/CertIV_IntroOOP | public int getStudentNum ( ) { return this . studentNum ; }
PhilDatoon/CertIV_IntroOOP | public void setStudentNum ( int num ) { this . studentNum = num ; }
PhilDatoon/CertIV_IntroOOP | public CollegeCourse getCourse ( int index ) { return this . course [ index ] ; }
PhilDatoon/CertIV_IntroOOP | public void setCourseID ( String id , int index ) { this . course [ index ] . setCourseID ( id ) ; }
PhilDatoon/CertIV_IntroOOP | public void setCreditHour ( int hour , int index ) { this . course [ index ] . setCreditHour ( hour ) ; }
PhilDatoon/CertIV_IntroOOP | public void setGrade ( String grade , int index ) { this . course [ index ] . setGrade ( grade ) ; }
yurloc/drools | public ZipKieModule ( ReleaseId releaseId , KieModuleModel kieProject , File file ) { super ( releaseId , kieProject ) ; this . file = file ; this . zipEntries = IoUtils . buildZipFileMapEntries ( file ) ; }
yurloc/drools | @ Override public File getFile ( ) { return this . file ; }
yurloc/drools | @ Override public boolean isAvailable ( String name ) { return this . zipEntries . containsKey ( name ) ; }
yurloc/drools | @ Override public byte [ ] getBytes ( String name ) { try { return readBytesFromZipEntry ( file , zipEntries . get ( name ) ) ; } catch ( IOException e ) { throw new RuntimeException ( " Unable ▁ to ▁ get ▁ ZipFile ▁ bytes ▁ for ▁ : ▁ ▁ " + name + " ▁ : ▁ " + file , e ) ; } }
yurloc/drools | @ Override public Collection < String > getFileNames ( ) { return this . zipEntries . keySet ( ) ; }
yurloc/drools | @ Override public byte [ ] getBytes ( ) { throw new UnsupportedOperationException ( ) ; }
yurloc/drools | public String toString ( ) { return " ZipKieModule [ ▁ ReleaseId = " + getReleaseId ( ) + " file = " + file + " ] " ; }
anchela/jackrabbit-oak | @ Before public void prepare ( ) { context . registerInjectActivateService ( new MountInfoProviderService ( ) , " mountedPaths " , new String [ ] { " / foo / bar " } ) ; observer = context . registerInjectActivateService ( new NonDefaultMountWriteReportingObserver ( ) , " ignoredClassNameFragments " , " MarkerToBeIgnored " ) ; reporter = new SpyChangeReporter ( ) ; observer . setReporter ( reporter ) ; }
anchela/jackrabbit-oak | @ Test public void pathAddedUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Added | / foo / bar " , " Added | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void subPathAddedUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; reporter . changes . clear ( ) ; NodeBuilder builder2 = nodeStore . getRoot ( ) . builder ( ) ; builder2 . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder2 , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Changed | / foo / bar " , " Added | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void propertyChangedUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; reporter . changes . clear ( ) ; NodeBuilder builder2 = nodeStore . getRoot ( ) . builder ( ) ; builder2 . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) . setProperty ( " prop " , " val " ) ; nodeStore . merge ( builder2 , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Changed | / foo / bar " , " Changed | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void subPathAddedUnderDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void subPathUnderNonDefaultMountButWithExpectedComponent ( ) throws Exception { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) ; MarkerToBeIgnored . call ( ( ) -> nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void commitWithMixedDefaultAndNonDefaultMounts ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) ; builder . child ( " outside " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Added | / foo / bar " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void commitWithDeletedNodeUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; reporter . changes . clear ( ) ; NodeBuilder builder2 = nodeStore . getRoot ( ) . builder ( ) ; builder2 . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) . remove ( ) ; nodeStore . merge ( builder2 , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Changed | / foo / bar " , " Deleted | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Override void reportChanges ( Map < String , String > changes , RuntimeException ignored ) { changes . forEach ( ( path , type ) -> this . changes . add ( type + " | " + path ) ) ; }
Kwangseob/graphhopper | @ Before public void setUp ( ) { instance = new SRTMProvider ( ) ; }
Kwangseob/graphhopper | @ After public void tearDown ( ) { instance . release ( ) ; }
Kwangseob/graphhopper | @ Test public void testGetFileString ( ) { assertEquals ( " Eurasia / N49E011" , instance . getFileString ( 49 , 11 ) ) ; assertEquals ( " Eurasia / N52W002" , instance . getFileString ( 52.268157 , - 1.230469 ) ) ; assertEquals ( " Africa / S06E034" , instance . getFileString ( - 5.965754 , 34.804687 ) ) ; assertEquals ( " Australia / S29E131" , instance . getFileString ( - 28.304381 , 131.484375 ) ) ; assertEquals ( " South _ America / S09W045" , instance . getFileString ( - 9 , - 45 ) ) ; assertEquals ( " South _ America / S10W046" , instance . getFileString ( - 9.1 , - 45.1 ) ) ; assertEquals ( " South _ America / S10W045" , instance . getFileString ( - 9.6 , - 45 ) ) ; assertEquals ( " South _ America / S28W071" , instance . getFileString ( - 28 , - 71 ) ) ; assertEquals ( " South _ America / S29W072" , instance . getFileString ( - 28.88316 , - 71.070557 ) ) ; }
Kwangseob/graphhopper | @ Test public void testGetHeight ( ) throws IOException { instance . setCacheDir ( new File ( " . / files / " ) ) ; assertEquals ( 466 , instance . getEle ( 49.968651 , 11.574869 ) , 1e-1 ) ; assertEquals ( 330 , instance . getEle ( 49.958233 , 11.558647 ) , 1e-1 ) ; assertEquals ( 1678 , instance . getEle ( - 28.88316 , - 71.070557 ) , 1e-1 ) ; assertEquals ( 0 , instance . getEle ( - 28.671311 , - 71.38916 ) , 1e-1 ) ; assertEquals ( 0 , instance . getEle ( 55.4711873 , 19.2501641 ) , 1e-1 ) ; assertEquals ( 161 , instance . getEle ( 55.8943144 , - 3 ) , 1e-1 ) ; }
Kwangseob/graphhopper | @ Test public void testGetHeightMMap ( ) throws IOException { instance . setCacheDir ( new File ( " . / files / " ) ) ; instance . setDAType ( DAType . MMAP ) ; assertEquals ( 161 , instance . getEle ( 55.8943144 , - 3 ) , 1e-1 ) ; }
spotify/styx | RuntimeIOException ( IOException cause ) { super ( cause ) ; this . cause = Objects . requireNonNull ( cause ) ; }
spotify/styx | @ Override public synchronized IOException getCause ( ) { return cause ; }
Groostav/CMPT880-term-project | public WMFFont ( Font font , int charset ) { this . font = font ; this . charset = charset ; }
Groostav/CMPT880-term-project | public WMFFont ( Font font , int charset , int underline , int strikeOut , int italic , int weight , int orient , int escape ) { this . font = font ; this . charset = charset ; this . underline = underline ; this . strikeOut = strikeOut ; this . italic = italic ; this . weight = weight ; this . orientation = orient ; this . escape = escape ; }
DavidWhitlock/PortlandStateJava | void assertEquals ( Person p1 , Person p2 ) { if ( p1 == null ) { assertNull ( p2 ) ; return ; } else if ( p2 == null ) { assertNull ( p1 ) ; return ; } assertNotNull ( p1 ) ; assertNotNull ( p2 ) ; Assertions . assertEquals ( p1 . getId ( ) , p2 . getId ( ) ) ; Assertions . assertEquals ( p1 . getGender ( ) , p2 . getGender ( ) ) ; Assertions . assertEquals ( p1 . getFirstName ( ) , p2 . getFirstName ( ) ) ; Assertions . assertEquals ( p1 . getMiddleName ( ) , p2 . getMiddleName ( ) ) ; Assertions . assertEquals ( p1 . getLastName ( ) , p2 . getLastName ( ) ) ; assertEquals ( p1 . getMother ( ) , p2 . getMother ( ) ) ; assertEquals ( p1 . getFather ( ) , p2 . getFather ( ) ) ; assertEquals ( p1 . getDateOfBirth ( ) , p2 . getDateOfBirth ( ) ) ; assertEquals ( p1 . getDateOfDeath ( ) , p2 . getDateOfDeath ( ) ) ; Assertions . assertEquals ( p1 . getMarriages ( ) . size ( ) , p2 . getMarriages ( ) . size ( ) ) ; Iterator < Marriage > iter1 = p1 . getMarriages ( ) . iterator ( ) ; Iterator < Marriage > iter2 = p2 . getMarriages ( ) . iterator ( ) ; while ( iter1 . hasNext ( ) && iter2 . hasNext ( ) ) { assertEquals ( iter1 . next ( ) , iter2 . next ( ) ) ; } }
DavidWhitlock/PortlandStateJava | void assertEquals ( Date d1 , Date d2 ) { if ( d1 == null ) { assertNull ( d2 ) ; return ; } else if ( d2 == null ) { assertNull ( d1 ) ; return ; } Calendar c1 = Calendar . getInstance ( ) ; c1 . setTime ( d1 ) ; Calendar c2 = Calendar . getInstance ( ) ; c2 . setTime ( d2 ) ; Assertions . assertEquals ( c1 . get ( Calendar . DAY_OF_YEAR ) , c2 . get ( Calendar . DAY_OF_YEAR ) ) ; Assertions . assertEquals ( c1 . get ( Calendar . YEAR ) , c2 . get ( Calendar . YEAR ) ) ; }
DavidWhitlock/PortlandStateJava | void assertEquals ( Marriage m1 , Marriage m2 ) { if ( m1 == null ) { assertNotNull ( m2 ) ; return ; } else if ( m2 == null ) { assertNull ( m1 ) ; return ; } Assertions . assertEquals ( m1 . getHusband ( ) . getId ( ) , m2 . getHusband ( ) . getId ( ) ) ; Assertions . assertEquals ( m1 . getWife ( ) . getId ( ) , m2 . getWife ( ) . getId ( ) ) ; assertEquals ( m1 . getDate ( ) , m2 . getDate ( ) ) ; Assertions . assertEquals ( m1 . getLocation ( ) , m2 . getLocation ( ) ) ; }
DavidWhitlock/PortlandStateJava | void assertEquals ( FamilyTree tree1 , FamilyTree tree2 ) { Assertions . assertEquals ( tree1 . getPeople ( ) . size ( ) , tree2 . getPeople ( ) . size ( ) ) ; for ( Person person : tree1 . getPeople ( ) ) { Person p2 = tree2 . getPerson ( person . getId ( ) ) ; assertNotNull ( p2 ) ; assertEquals ( person , p2 ) ; } }
DavidWhitlock/PortlandStateJava | void assertContains ( String container , String containee ) { assertTrue ( container . indexOf ( containee ) != - 1 ) ; }
DavidWhitlock/PortlandStateJava | void assertContains ( String message , String container , String containee ) { assertTrue ( container . indexOf ( containee ) != - 1 , message ) ; }
xvik/dropwizard-guicey | @ Override public void setConfiguration ( final C configuration ) { this . configuration = configuration ; }
xvik/dropwizard-guicey | @ Override public void setBootstrap ( final Bootstrap < C > bootstrap ) { this . bootstrap = bootstrap ; }
xvik/dropwizard-guicey | @ Override public void setEnvironment ( final Environment environment ) { this . environment = environment ; }
xvik/dropwizard-guicey | @ Override public void setOptions ( final Options options ) { this . options = options ; }
xvik/dropwizard-guicey | @ Override public void setConfigurationTree ( final ConfigurationTree configurationTree ) { this . configurationTree = configurationTree ; }
xvik/dropwizard-guicey | protected Bootstrap < C > bootstrap ( ) { return bootstrap ; }
xvik/dropwizard-guicey | protected C configuration ( ) { return configuration ; }
xvik/dropwizard-guicey | protected < T > T configuration ( final String yamlPath ) { return configurationTree ( ) . valueByPath ( yamlPath ) ; }
xvik/dropwizard-guicey | protected < T , K extends T > K configuration ( final Class < T > type ) { return configurationTree ( ) . valueByUniqueDeclaredType ( type ) ; }
xvik/dropwizard-guicey | protected < T > List < ? extends T > configurations ( final Class < T > type ) { return configurationTree ( ) . valuesByType ( type ) ; }
xvik/dropwizard-guicey | protected ConfigurationTree configurationTree ( ) { return configurationTree ; }
xvik/dropwizard-guicey | protected Environment environment ( ) { return environment ; }
xvik/dropwizard-guicey | protected String appPackage ( ) { return bootstrap ( ) . getApplication ( ) . getClass ( ) . getPackage ( ) . getName ( ) ; }
xvik/dropwizard-guicey | protected Options options ( ) { return options ; }
xvik/dropwizard-guicey | public void shareState ( final Class < ? > key , final Object value ) { SharedConfigurationState . getOrFail ( environment ( ) , STATE_NOT_FOUND ) . put ( key , value ) ; }
xvik/dropwizard-guicey | public < T > T sharedState ( final Class < ? > key , final Supplier < T > defaultValue ) { return SharedConfigurationState . getOrFail ( environment ( ) , STATE_NOT_FOUND ) . get ( key , defaultValue ) ; }
xvik/dropwizard-guicey | protected < T > Optional < T > sharedState ( final Class < ? > key ) { return SharedConfigurationState . lookup ( environment ( ) , key ) ; }
xvik/dropwizard-guicey | protected < T > T sharedStateOrFail ( final Class < ? > key , final String message , final Object ... args ) { return SharedConfigurationState . lookupOrFail ( environment ( ) , key , message , args ) ; }
selvasingh/azure-sdk-for-java | public void createEventData ( ) { TelemetryEvent telemetry = new TelemetryEvent ( " temperature " , "37" ) ; byte [ ] serializedTelemetryData = telemetry . toString ( ) . getBytes ( UTF_8 ) ; EventData eventData = new EventData ( serializedTelemetryData ) ; eventData . getProperties ( ) . put ( " eventType " , TelemetryEvent . class . getName ( ) ) ; }
selvasingh/azure-sdk-for-java | public void sharingConnection ( ) { EventHubClientBuilder builder = new EventHubClientBuilder ( ) . connectionString ( " event - hubs - instance - connection - string " ) . shareConnection ( ) ; EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; EventHubConsumerAsyncClient consumer = builder . consumerGroup ( " my - consumer - group " ) . buildAsyncConsumerClient ( ) ; }
selvasingh/azure-sdk-for-java | public void instantiateConsumerAsyncClient ( ) { EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; " + " SharedAccessKey = { key } ; EntityPath = { eh - name } " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; consumer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void receive ( ) { String partitionId = "0" ; EventPosition startingPosition = EventPosition . latest ( ) ; Disposable subscription = consumer . receiveFromPartition ( partitionId , startingPosition ) . subscribe ( partitionEvent -> { PartitionContext partitionContext = partitionEvent . getPartitionContext ( ) ; EventData event = partitionEvent . getData ( ) ; System . out . printf ( " Received ▁ event ▁ from ▁ partition ▁ ' % s ' % n " , partitionContext . getPartitionId ( ) ) ; System . out . printf ( " Contents ▁ of ▁ event ▁ as ▁ string : ▁ ' % s ' % n " , event . getBodyAsString ( ) ) ; } , error -> System . err . print ( error . toString ( ) ) ) ; subscription . dispose ( ) ; }
selvasingh/azure-sdk-for-java | public void receiveBackpressure ( ) { String partitionId = "0" ; EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " fake - string " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; consumer . receiveFromPartition ( partitionId , EventPosition . latest ( ) ) . subscribe ( new BaseSubscriber < PartitionEvent > ( ) { private static final int NUMBER_OF_EVENTS = 5 ; private final AtomicInteger currentNumberOfEvents = new AtomicInteger ( ) ; @ Override protected void hookOnSubscribe ( Subscription subscription ) { request ( NUMBER_OF_EVENTS ) ; } @ Override protected void hookOnNext ( PartitionEvent value ) { if ( currentNumberOfEvents . incrementAndGet ( ) % 5 == 0 ) { request ( NUMBER_OF_EVENTS ) ; } } } ) ; }
selvasingh/azure-sdk-for-java | public void receiveAll ( ) { EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " fake - string " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; consumer . receive ( true ) . subscribe ( partitionEvent -> { PartitionContext context = partitionEvent . getPartitionContext ( ) ; EventData event = partitionEvent . getData ( ) ; System . out . printf ( " Event ▁ % s ▁ is ▁ from ▁ partition ▁ % s % n . " , event . getSequenceNumber ( ) , context . getPartitionId ( ) ) ; } ) ; }
selvasingh/azure-sdk-for-java | public void receiveLastEnqueuedInformation ( ) { EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " event - hub - instance - connection - string " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; ReceiveOptions receiveOptions = new ReceiveOptions ( ) . setTrackLastEnqueuedEventProperties ( true ) ; consumer . receiveFromPartition ( "0" , EventPosition . earliest ( ) , receiveOptions ) . subscribe ( partitionEvent -> { LastEnqueuedEventProperties properties = partitionEvent . getLastEnqueuedEventProperties ( ) ; System . out . printf ( " Information ▁ received ▁ at ▁ % s . ▁ Last ▁ enqueued ▁ sequence ▁ number : ▁ % s % n " , properties . getRetrievalTime ( ) , properties . getSequenceNumber ( ) ) ; } ) ; }
selvasingh/azure-sdk-for-java | public void instantiateConsumerClient ( ) { EventHubConsumerClient consumer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { eh - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } ; Entity - Path = { hub - name } " ) . consumerGroup ( " $ DEFAULT " ) . buildConsumerClient ( ) ; consumer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void receiveFromSinglePartition ( ) { EventHubConsumerClient consumer = new EventHubClientBuilder ( ) . connectionString ( " event - hub - instance - connection - string " ) . consumerGroup ( " consumer - group - name " ) . buildConsumerClient ( ) ; Instant twelveHoursAgo = Instant . now ( ) . minus ( Duration . ofHours ( 12 ) ) ; EventPosition startingPosition = EventPosition . fromEnqueuedTime ( twelveHoursAgo ) ; String partitionId = "0" ; IterableStream < PartitionEvent > events = consumer . receiveFromPartition ( partitionId , 100 , startingPosition , Duration . ofSeconds ( 30 ) ) ; Long lastSequenceNumber = - 1L ; for ( PartitionEvent partitionEvent : events ) { System . out . print ( " Event ▁ received : ▁ " + partitionEvent . getData ( ) . getSequenceNumber ( ) ) ; lastSequenceNumber = partitionEvent . getData ( ) . getSequenceNumber ( ) ; } if ( lastSequenceNumber != - 1L ) { EventPosition nextPosition = EventPosition . fromSequenceNumber ( lastSequenceNumber , false ) ; IterableStream < PartitionEvent > nextEvents = consumer . receiveFromPartition ( partitionId , 100 , nextPosition , Duration . ofSeconds ( 30 ) ) ; } }
selvasingh/azure-sdk-for-java | public void instantiateProducerAsyncClient ( ) { EventHubProducerAsyncClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildAsyncProducerClient ( ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchAutomaticRoutingAsync ( ) { EventHubProducerAsyncClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildAsyncProducerClient ( ) ; producer . createBatch ( ) . flatMap ( batch -> { batch . tryAdd ( new EventData ( " test - event - 1" ) ) ; batch . tryAdd ( new EventData ( " test - event - 2" ) ) ; return producer . send ( batch ) ; } ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ batch : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionIdAsync ( ) { EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionId ( " foo " ) ; producer . createBatch ( options ) . flatMap ( batch -> { batch . tryAdd ( new EventData ( " test - event - 1" ) ) ; batch . tryAdd ( new EventData ( " test - event - 2" ) ) ; return producer . send ( batch ) ; } ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ batch : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionKeyAsync ( ) { EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionKey ( " bread " ) ; producer . createBatch ( options ) . flatMap ( batch -> { batch . tryAdd ( new EventData ( " sourdough " ) ) ; batch . tryAdd ( new EventData ( " rye " ) ) ; return producer . send ( batch ) ; } ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ batch : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; }
selvasingh/azure-sdk-for-java | public void batchSizeLimitedAsync ( ) { final EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; final EventData firstEvent = new EventData ( "92" . getBytes ( UTF_8 ) ) ; firstEvent . getProperties ( ) . put ( " telemetry " , " latency " ) ; final EventData secondEvent = new EventData ( "98" . getBytes ( UTF_8 ) ) ; secondEvent . getProperties ( ) . put ( " telemetry " , " cpu - temperature " ) ; final Flux < EventData > telemetryEvents = Flux . just ( firstEvent , secondEvent ) ; final CreateBatchOptions options = new CreateBatchOptions ( ) . setMaximumSizeInBytes ( 256 ) ; final AtomicReference < EventDataBatch > currentBatch = new AtomicReference < > ( producer . createBatch ( options ) . block ( ) ) ; telemetryEvents . flatMap ( event -> { final EventDataBatch batch = currentBatch . get ( ) ; if ( batch . tryAdd ( event ) ) { return Mono . empty ( ) ; } return Mono . when ( producer . send ( batch ) , producer . createBatch ( options ) . map ( newBatch -> { currentBatch . set ( newBatch ) ; if ( ! newBatch . tryAdd ( event ) ) { throw Exceptions . propagate ( new IllegalArgumentException ( " Event ▁ was ▁ too ▁ large ▁ to ▁ fit ▁ in ▁ an ▁ empty ▁ batch . ▁ Max ▁ size : ▁ " + newBatch . getMaxSizeInBytes ( ) ) ) ; } return newBatch ; } ) ) ; } ) . then ( ) . doFinally ( signal -> { final EventDataBatch batch = currentBatch . getAndSet ( null ) ; if ( batch != null && batch . getCount ( ) > 0 ) { producer . send ( batch ) . block ( ) ; } } ) ; }
selvasingh/azure-sdk-for-java | public void sendIterableSampleAsync ( ) { final EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " maple " ) , new EventData ( " aspen " ) , new EventData ( " oak " ) ) ; producer . send ( events ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ events : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; }
selvasingh/azure-sdk-for-java | public void sendIterableWithPartitionKeySampleAsync ( ) { final EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " Melbourne " ) , new EventData ( " London " ) , new EventData ( " New ▁ York " ) ) ; SendOptions sendOptions = new SendOptions ( ) . setPartitionKey ( " cities " ) ; producer . send ( events , sendOptions ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ events : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; }
selvasingh/azure-sdk-for-java | public void instantiateProducerClient ( ) { EventHubProducerClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildProducerClient ( ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchAutomaticRouting ( ) { EventHubProducerClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " test - event - 1" ) , new EventData ( " test - event - 2" ) ) ; EventDataBatch batch = producer . createBatch ( ) ; for ( EventData event : events ) { if ( batch . tryAdd ( event ) ) { continue ; } producer . send ( batch ) ; batch = producer . createBatch ( ) ; if ( ! batch . tryAdd ( event ) ) { throw new IllegalArgumentException ( " Event ▁ is ▁ too ▁ large ▁ for ▁ an ▁ empty ▁ batch . " ) ; } } producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionId ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionId ( " foo " ) ; EventDataBatch batch = producer . createBatch ( options ) ; batch . tryAdd ( new EventData ( " data - to - partition - foo " ) ) ; producer . send ( batch ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionKey ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " sourdough " ) , new EventData ( " rye " ) , new EventData ( " wheat " ) ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionKey ( " bread " ) ; EventDataBatch batch = producer . createBatch ( options ) ; events . forEach ( event -> batch . tryAdd ( event ) ) ; producer . send ( batch ) ; }
selvasingh/azure-sdk-for-java | public void batchSizeLimited ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; final EventData firstEvent = new EventData ( "92" . getBytes ( UTF_8 ) ) ; firstEvent . getProperties ( ) . put ( " telemetry " , " latency " ) ; final EventData secondEvent = new EventData ( "98" . getBytes ( UTF_8 ) ) ; secondEvent . getProperties ( ) . put ( " telemetry " , " cpu - temperature " ) ; final EventData thirdEvent = new EventData ( "120" . getBytes ( UTF_8 ) ) ; thirdEvent . getProperties ( ) . put ( " telemetry " , " fps " ) ; final List < EventData > telemetryEvents = Arrays . asList ( firstEvent , secondEvent , thirdEvent ) ; final CreateBatchOptions options = new CreateBatchOptions ( ) . setMaximumSizeInBytes ( 256 ) ; EventDataBatch currentBatch = producer . createBatch ( options ) ; for ( EventData event : telemetryEvents ) { if ( ! currentBatch . tryAdd ( event ) ) { producer . send ( currentBatch ) ; currentBatch = producer . createBatch ( options ) ; if ( ! currentBatch . tryAdd ( event ) ) { throw new IllegalArgumentException ( " Event ▁ is ▁ too ▁ large ▁ for ▁ an ▁ empty ▁ batch . " ) ; } } } }
selvasingh/azure-sdk-for-java | public void sendIterableSample ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " maple " ) , new EventData ( " aspen " ) , new EventData ( " oak " ) ) ; producer . send ( events ) ; }
selvasingh/azure-sdk-for-java | public void sendIterableWithPartitionKeySample ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " Melbourne " ) , new EventData ( " London " ) , new EventData ( " New ▁ York " ) ) ; SendOptions sendOptions = new SendOptions ( ) . setPartitionKey ( " cities " ) ; producer . send ( events , sendOptions ) ; }
selvasingh/azure-sdk-for-java | public EventProcessorClient createEventProcessor ( ) { String connectionString = " Endpoint = { endpoint } ; SharedAccessKeyName = { sharedAccessKeyName } ; " + " SharedAccessKey = { sharedAccessKey } ; EntityPath = { eventHubName } " ; EventProcessorClient eventProcessorClient = new EventProcessorClientBuilder ( ) . consumerGroup ( " consumer - group " ) . checkpointStore ( new SampleCheckpointStore ( ) ) . processEvent ( eventContext -> { System . out . println ( " Partition ▁ id ▁ = ▁ " + eventContext . getPartitionContext ( ) . getPartitionId ( ) + " and ▁ sequence ▁ number ▁ of ▁ event ▁ = ▁ " + eventContext . getEventData ( ) . getSequenceNumber ( ) ) ; } ) . processError ( errorContext -> { System . out . printf ( " Error ▁ occurred ▁ in ▁ partition ▁ processor ▁ for ▁ partition ▁ { } , ▁ { } " , errorContext . getPartitionContext ( ) . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; } ) . connectionString ( connectionString ) . buildEventProcessorClient ( ) ; return eventProcessorClient ; }
selvasingh/azure-sdk-for-java | public void receiveBatchSample ( ) { String connectionString = " Endpoint = { endpoint } ; SharedAccessKeyName = { sharedAccessKeyName } ; " + " SharedAccessKey = { sharedAccessKey } ; EntityPath = { eventHubName } " ; EventProcessorClient eventProcessorClient = new EventProcessorClientBuilder ( ) . consumerGroup ( " consumer - group " ) . checkpointStore ( new SampleCheckpointStore ( ) ) . processEventBatch ( eventBatchContext -> { eventBatchContext . getEvents ( ) . forEach ( eventData -> { System . out . println ( " Partition ▁ id ▁ = ▁ " + eventBatchContext . getPartitionContext ( ) . getPartitionId ( ) + " and ▁ sequence ▁ number ▁ of ▁ event ▁ = ▁ " + eventData . getSequenceNumber ( ) ) ; } ) ; } , 50 , Duration . ofSeconds ( 30 ) ) . processError ( errorContext -> { System . out . printf ( " Error ▁ occurred ▁ in ▁ partition ▁ processor ▁ for ▁ partition ▁ { } , ▁ { } " , errorContext . getPartitionContext ( ) . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; } ) . connectionString ( connectionString ) . buildEventProcessorClient ( ) ; }
selvasingh/azure-sdk-for-java | public void startStopSample ( ) { String connectionString = " Endpoint = { endpoint } ; SharedAccessKeyName = { sharedAccessKeyName } ; " + " SharedAccessKey = { sharedAccessKey } ; EntityPath = { eventHubName } " ; EventProcessorClient eventProcessorClient = new EventProcessorClientBuilder ( ) . connectionString ( connectionString ) . processEvent ( eventContext -> { System . out . println ( " Partition ▁ id ▁ = ▁ " + eventContext . getPartitionContext ( ) . getPartitionId ( ) + " ▁ and ▁ " + " sequence ▁ number ▁ of ▁ event ▁ = ▁ " + eventContext . getEventData ( ) . getSequenceNumber ( ) ) ; } ) . processError ( errorContext -> { System . out . printf ( " Error ▁ occurred ▁ in ▁ partition ▁ processor ▁ for ▁ partition ▁ { } , ▁ { } " , errorContext . getPartitionContext ( ) . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; } ) . consumerGroup ( " consumer - group " ) . buildEventProcessorClient ( ) ; eventProcessorClient . start ( ) ; eventProcessorClient . stop ( ) ; }
selvasingh/azure-sdk-for-java | private TelemetryEvent ( String name , String value ) { this . name = name ; this . value = value ; }
selvasingh/azure-sdk-for-java | @ Override public String toString ( ) { return String . format ( " [ name ] = % s ; [ value ] = % s " , name , value ) ; }
worldcoinproject/worldcoin-wallet-java | public WorldcoinWalletCheckpointManager ( NetworkParameters params , InputStream inputStream ) throws IOException { super ( params , inputStream ) ; }
worldcoinproject/worldcoin-wallet-java | public StoredBlock getCheckpointBeforeOrAtHeight ( int height ) { Map . Entry < Long , StoredBlock > highestCheckpointBeforeHeight = null ; for ( Map . Entry < Long , StoredBlock > loop : checkpoints . entrySet ( ) ) { if ( loop . getValue ( ) . getHeight ( ) < height ) { if ( highestCheckpointBeforeHeight == null ) { highestCheckpointBeforeHeight = loop ; } else { if ( highestCheckpointBeforeHeight . getValue ( ) . getHeight ( ) < loop . getValue ( ) . getHeight ( ) ) { highestCheckpointBeforeHeight = loop ; } } } } if ( highestCheckpointBeforeHeight == null ) { try { return new StoredBlock ( params . getGenesisBlock ( ) , params . getGenesisBlock ( ) . getWork ( ) , 0 ) ; } catch ( VerificationException e ) { e . printStackTrace ( ) ; } } return highestCheckpointBeforeHeight . getValue ( ) ; }
111t8e/h2o-2 | for ( Sys s : Sys . values ( ) ) { String str = System . getProperty ( " log . " + s ) ; if ( str == null ) continue ; if ( str . equals ( " false " ) ) unsetFlag ( s ) ; else setFlag ( s ) ; }
111t8e/h2o-2 | private void init ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages , Object message , Timer t ) { this . kind = kind ; this . ouch = ouch ; this . messages = messages ; this . message = message ; this . sys = sys ; this . when = t ; this . printMe = true ; }
111t8e/h2o-2 | public String toString ( ) { StringBuilder buf = longHeader ( new StringBuilder ( 120 ) ) ; int headroom = buf . length ( ) ; buf . append ( body ( headroom ) ) ; return buf . toString ( ) ; }
111t8e/h2o-2 | public String toShortString ( ) { StringBuilder buf = shortHeader ( new StringBuilder ( 120 ) ) ; int headroom = buf . length ( ) ; buf . append ( body ( headroom ) ) ; return buf . toString ( ) ; }
111t8e/h2o-2 | private String body ( int headroom ) { StringBuilder buf = new StringBuilder ( 120 ) ; if ( messages != null ) for ( Object m : messages ) buf . append ( m . toString ( ) ) ; else if ( message != null ) buf . append ( message . toString ( ) ) ; if ( buf . indexOf ( " \n " ) != - 1 ) { String s = buf . toString ( ) ; String [ ] lines = s . split ( " \n " ) ; if ( lines . length > 0 ) { StringBuilder buf2 = new StringBuilder ( 2 * buf . length ( ) ) ; buf2 . append ( lines [ 0 ] ) ; for ( int i = 1 ; i < lines . length ; i ++ ) { buf2 . append ( NL ) . append ( " + " ) ; for ( int j = 1 ; j < headroom ; j ++ ) buf2 . append ( " ▁ " ) ; buf2 . append ( lines [ i ] ) ; } buf = buf2 ; } } if ( ouch != null ) { buf . append ( NL ) ; Writer wr = new StringWriter ( ) ; PrintWriter pwr = new PrintWriter ( wr ) ; ouch . printStackTrace ( pwr ) ; String mess = wr . toString ( ) ; String [ ] lines = mess . split ( " \n " ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { buf . append ( " + " ) ; for ( int j = 1 ; j < headroom ; j ++ ) buf . append ( " ▁ " ) ; buf . append ( lines [ i ] ) ; if ( i != lines . length - 1 ) buf . append ( NL ) ; } } return buf . toString ( ) ; }
111t8e/h2o-2 | private StringBuilder longHeader ( StringBuilder buf ) { String headers = _longHeaders ; if ( headers == null ) { String host = H2O . SELF_ADDRESS != null ? H2O . SELF_ADDRESS . getHostAddress ( ) : " " ; headers = fixedLength ( host + " : " + H2O . API_PORT + " ▁ " , 22 ) + fixedLength ( PID + " ▁ " , 6 ) ; if ( H2O . SELF_ADDRESS != null ) _longHeaders = headers ; } buf . append ( when . startAsString ( ) ) . append ( " ▁ " ) . append ( headers ) ; if ( thread == null ) thread = fixedLength ( Thread . currentThread ( ) . getName ( ) + " ▁ " , 10 ) ; buf . append ( thread ) ; buf . append ( kind . toString ( ) ) . append ( " ▁ " ) . append ( sys . toString ( ) ) . append ( " : ▁ " ) ; return buf ; }
111t8e/h2o-2 | private StringBuilder shortHeader ( StringBuilder buf ) { buf . append ( when . startAsShortString ( ) ) . append ( " ▁ " ) ; if ( H2O . DEBUG ) { String host = H2O . SELF_ADDRESS != null ? H2O . SELF_ADDRESS . getHostAddress ( ) : " " ; buf . append ( fixedLength ( host + " : " + H2O . API_PORT + " ▁ " , 18 ) ) ; } if ( thread == null ) thread = fixedLength ( Thread . currentThread ( ) . getName ( ) + " ▁ " , 8 ) ; buf . append ( thread ) ; if ( ! H2O . DEBUG ) buf . append ( kind . toString ( ) ) . append ( " ▁ " ) . append ( sys . toString ( ) ) . append ( " : ▁ " ) ; return buf ; }
111t8e/h2o-2 | Wrapper ( PrintStream parent ) { super ( parent ) ; this . parent = parent ; }
111t8e/h2o-2 | @ Override public PrintStream printf ( String format , Object ... args ) { super . print ( log ( null , false , format , args ) ) ; return this ; }
111t8e/h2o-2 | @ Override public PrintStream printf ( Locale l , String format , Object ... args ) { super . print ( log ( l , false , format , args ) ) ; return this ; }
111t8e/h2o-2 | @ Override public void println ( String x ) { super . print ( log ( null , true , " % s " , x ) ) ; }
111t8e/h2o-2 | void printlnParent ( String s ) { super . println ( s ) ; }
111t8e/h2o-2 | LogStr ( LogStr l , String date , H2ONode h2o , long pid , String thr , Kind kind , Sys sys , String msg ) { _dates = l == null ? new String [ MAX ] : l . _dates ; _h2os = l == null ? new H2ONode [ MAX ] : l . _h2os ; _pids = l == null ? new long [ MAX ] : l . _pids ; _thrs = l == null ? new String [ MAX ] : l . _thrs ; _kinds = l == null ? new byte [ MAX ] : l . _kinds ; _syss = l == null ? new byte [ MAX ] : l . _syss ; _msgs = l == null ? new String [ MAX ] : l . _msgs ; _idx = l == null ? 0 : ( l . _idx + 1 ) & ( MAX - 1 ) ; _dates [ _idx ] = date ; _h2os [ _idx ] = h2o ; _pids [ _idx ] = pid ; _thrs [ _idx ] = thr ; _kinds [ _idx ] = ( byte ) kind . ordinal ( ) ; _syss [ _idx ] = ( byte ) sys . ordinal ( ) ; _msgs [ _idx ] = msg ; }
guard163/cassandra | private ListType ( AbstractType < T > elements , boolean isMultiCell ) { super ( ComparisonType . CUSTOM , Kind . LIST ) ; this . elements = elements ; this . serializer = ListSerializer . getInstance ( elements . getSerializer ( ) ) ; this . isMultiCell = isMultiCell ; }
guard163/cassandra | public AbstractType < T > getElementsType ( ) { return elements ; }
guard163/cassandra | public AbstractType < UUID > nameComparator ( ) { return TimeUUIDType . instance ; }
guard163/cassandra | public AbstractType < T > valueComparator ( ) { return elements ; }
guard163/cassandra | public ListSerializer < T > getSerializer ( ) { return serializer ; }
guard163/cassandra | @ Override public AbstractType < ? > freeze ( ) { if ( isMultiCell ) return getInstance ( this . elements , false ) ; else return this ; }
guard163/cassandra | @ Override public boolean isMultiCell ( ) { return isMultiCell ; }
guard163/cassandra | @ Override public boolean isCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isCompatibleWith ( ( ( ListType ) previous ) . elements ) ; }
guard163/cassandra | @ Override public boolean isValueCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isValueCompatibleWithInternal ( ( ( ListType ) previous ) . elements ) ; }
guard163/cassandra | @ Override public int compareCustom ( ByteBuffer o1 , ByteBuffer o2 ) { return compareListOrSet ( elements , o1 , o2 ) ; }
guard163/cassandra | @ Override public String toString ( boolean ignoreFreezing ) { boolean includeFrozenType = ! ignoreFreezing && ! isMultiCell ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( includeFrozenType ) sb . append ( FrozenType . class . getName ( ) ) . append ( " ( " ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( TypeParser . stringifyTypeParameters ( Collections . < AbstractType < ? > > singletonList ( elements ) , ignoreFreezing || ! isMultiCell ) ) ; if ( includeFrozenType ) sb . append ( " ) " ) ; return sb . toString ( ) ; }
guard163/cassandra | public List < ByteBuffer > serializedValues ( Iterator < Cell > cells ) { assert isMultiCell ; List < ByteBuffer > bbs = new ArrayList < ByteBuffer > ( ) ; while ( cells . hasNext ( ) ) bbs . add ( cells . next ( ) . value ( ) ) ; return bbs ; }
guard163/cassandra | @ Override public Term fromJSONObject ( Object parsed ) throws MarshalException { if ( parsed instanceof String ) parsed = Json . decodeJson ( ( String ) parsed ) ; if ( ! ( parsed instanceof List ) ) throw new MarshalException ( String . format ( " Expected ▁ a ▁ list , ▁ but ▁ got ▁ a ▁ % s : ▁ % s " , parsed . getClass ( ) . getSimpleName ( ) , parsed ) ) ; List list = ( List ) parsed ; List < Term > terms = new ArrayList < > ( list . size ( ) ) ; for ( Object element : list ) { if ( element == null ) throw new MarshalException ( " Invalid ▁ null ▁ element ▁ in ▁ list " ) ; terms . add ( elements . fromJSONObject ( element ) ) ; } return new Lists . DelayedValue ( terms ) ; }
guard163/cassandra | @ Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { return setOrListToJsonString ( buffer , elements , protocolVersion ) ; }
PlanetWaves/clockworkengine | public void initialize ( Class clazz ) { }
0x90sled/droidtowers | public ExceptionHandlerConstantVisitor ( ConstantVisitor constantVisitor ) { this . constantVisitor = constantVisitor ; }
0x90sled/droidtowers | public void visitExceptionInfo ( Clazz clazz , Method method , CodeAttribute codeAttribute , ExceptionInfo exceptionInfo ) { int catchType = exceptionInfo . u2catchType ; if ( catchType != 0 ) { clazz . constantPoolEntryAccept ( catchType , constantVisitor ) ; } }
cgfalcon/myprolang | @ Before public void setUp ( ) throws Exception { lexer = new CalcLexer ( "1 + 2" ) ; }
cgfalcon/myprolang | @ Test public void testGetTokenSimple ( ) throws Exception { lexer . setLine ( "1 + 2" ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "1" , TokenType . NUM ) , token ) ; Token tokenOp = lexer . nextToken ( ) ; assertEquals ( 1 , tokenOp . getPos ( ) ) ; assertEquals ( 1 , tokenOp . getLine ( ) ) ; assertEquals ( TokenType . OP_ADD_TOKEN , tokenOp . getKind ( ) ) ; Token tokenOperand2 = lexer . nextToken ( ) ; assertEquals ( new Token ( 2 , 1 , "2" , TokenType . NUM ) , tokenOperand2 ) ; Token tokenEndLine = lexer . nextToken ( ) ; assertEquals ( 2 , tokenEndLine . getPos ( ) ) ; assertEquals ( 1 , tokenEndLine . getLine ( ) ) ; assertEquals ( TokenType . EOF , tokenEndLine . getKind ( ) ) ; }
cgfalcon/myprolang | @ Test public void tesLexerComplex1 ( ) throws Exception { String line = "34 \n " ; lexer . setLine ( line ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "34" , TokenType . NUM ) , token ) ; String line2 = "34.9384 ▁ 0.4 \n " ; lexer . setLine ( line2 ) ; Token token2 = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "34.9384" , TokenType . NUM ) , token2 ) ; Token token3 = lexer . nextToken ( ) ; assertEquals ( new Token ( 8 , 1 , "0.4" , TokenType . NUM ) , token3 ) ; }
cgfalcon/myprolang | @ Test public void testAdd ( ) throws Exception { String line = "45.3 ▁ + ▁ 0.23 \n " ; lexer . setLine ( line ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "45.3" , TokenType . NUM ) , token ) ; Token tokenAdd = lexer . nextToken ( ) ; assertEquals ( 5 , tokenAdd . getPos ( ) ) ; assertEquals ( TokenType . OP_ADD_TOKEN , tokenAdd . getKind ( ) ) ; Token tokenOperand = lexer . nextToken ( ) ; assertEquals ( new Token ( 7 , 1 , "0.23" , TokenType . NUM ) , tokenOperand ) ; }
cgfalcon/myprolang | @ Test public void testID ( ) { String line = " dbd " ; lexer . setLine ( line ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , " dbd " , TokenType . ID ) , token ) ; }
cgfalcon/myprolang | @ Test public void testAssign ( ) { String line = " x ▁ = ▁ 10" ; lexer . setLine ( line ) ; Token tokenX = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , " x " , TokenType . ID ) , tokenX ) ; Token tokenEqual = lexer . nextToken ( ) ; assertEquals ( new Token ( 2 , 1 , " = " , TokenType . EQUAL ) , tokenEqual ) ; Token tokenNum = lexer . nextToken ( ) ; assertEquals ( new Token ( 4 , 1 , "10" , TokenType . NUM ) , tokenNum ) ; }
JEBailey/sling | while ( nodeTypeIterator . hasNext ( ) ) { NodeType nodeType = nodeTypeIterator . nextNodeType ( ) ; if ( nodeType . getName ( ) != null ) { JSONNodeType jsonNodeType = new JSONNodeType ( nodeType ) ; nodeTypes . put ( nodeType . getName ( ) , jsonNodeType . getJson ( ) ) ; } }
JEBailey/sling | catch ( RepositoryException e ) { log . error ( " Could ▁ not ▁ generate ▁ the ▁ node ▁ types . " , e ) ; response . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; }
JEBailey/sling | catch ( JSONException e ) { log . error ( " Could ▁ not ▁ generate ▁ the ▁ node ▁ types . " , e ) ; response . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; }
shs96c/buck | @ VisibleForTesting AndroidLibrary ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , JarBuildStepsFactory jarBuildStepsFactory , SourcePathRuleFinder ruleFinder , Optional < SourcePath > proguardConfig , SortedSet < BuildRule > fullJarDeclaredDeps , ImmutableSortedSet < BuildRule > fullJarExportedDeps , ImmutableSortedSet < BuildRule > fullJarProvidedDeps , ImmutableSortedSet < BuildRule > fullJarExportedProvidedDeps , @ Nullable BuildTarget abiJar , @ Nullable BuildTarget sourceOnlyAbiJar , Optional < String > mavenCoords , Optional < SourcePath > manifestFile , ImmutableSortedSet < BuildTarget > tests , boolean requiredForSourceOnlyAbi , UnusedDependenciesAction unusedDependenciesAction , Optional < UnusedDependenciesFinderFactory > unusedDependenciesFinderFactory , @ Nullable CalculateSourceAbi sourceAbi ) { super ( buildTarget , projectFilesystem , jarBuildStepsFactory , ruleFinder , proguardConfig , fullJarDeclaredDeps , fullJarExportedDeps , fullJarProvidedDeps , fullJarExportedProvidedDeps , abiJar , sourceOnlyAbiJar , mavenCoords , tests , requiredForSourceOnlyAbi , unusedDependenciesAction , unusedDependenciesFinderFactory , sourceAbi ) ; this . manifestFile = manifestFile ; }
shs96c/buck | public Optional < SourcePath > getManifestFile ( ) { return manifestFile ; }
shs96c/buck | @ Override public void addToCollector ( AndroidPackageableCollector collector ) { super . addToCollector ( collector ) ; if ( manifestFile . isPresent ( ) ) { collector . addManifestPiece ( this . getBuildTarget ( ) , manifestFile . get ( ) ) ; } }
shs96c/buck | protected Builder ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , ToolchainProvider toolchainProvider , BuildRuleParams params , ActionGraphBuilder graphBuilder , CellPathResolver cellPathResolver , JavaBuckConfig javaBuckConfig , JavacFactory javacFactory , JavacOptions javacOptions , CoreArg args , ConfiguredCompilerFactory compilerFactory ) { this . graphBuilder = graphBuilder ; DefaultJavaLibraryRules . Builder delegateBuilder = new DefaultJavaLibraryRules . Builder ( buildTarget , projectFilesystem , toolchainProvider , params , graphBuilder , cellPathResolver , compilerFactory , javaBuckConfig , args ) ; delegateBuilder . setConstructor ( new DefaultJavaLibraryRules . DefaultJavaLibraryConstructor ( ) { @ Override public DefaultJavaLibrary newInstance ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , JarBuildStepsFactory jarBuildStepsFactory , SourcePathRuleFinder ruleFinder , Optional < SourcePath > proguardConfig , SortedSet < BuildRule > firstOrderPackageableDeps , ImmutableSortedSet < BuildRule > fullJarExportedDeps , ImmutableSortedSet < BuildRule > fullJarProvidedDeps , ImmutableSortedSet < BuildRule > fullJarExportedProvidedDeps , @ Nullable BuildTarget abiJar , @ Nullable BuildTarget sourceOnlyAbiJar , Optional < String > mavenCoords , ImmutableSortedSet < BuildTarget > tests , boolean requiredForSourceOnlyAbi , UnusedDependenciesAction unusedDependenciesAction , Optional < UnusedDependenciesFinderFactory > unusedDependenciesFinderFactory , @ Nullable CalculateSourceAbi sourceAbi ) { return new AndroidLibrary ( buildTarget , projectFilesystem , jarBuildStepsFactory , ruleFinder , proguardConfig , firstOrderPackageableDeps , fullJarExportedDeps , fullJarProvidedDeps , fullJarExportedProvidedDeps , abiJar , sourceOnlyAbiJar , mavenCoords , args . getManifest ( ) , tests , requiredForSourceOnlyAbi , unusedDependenciesAction , unusedDependenciesFinderFactory , sourceAbi ) ; } } ) ; delegateBuilder . setJavacOptions ( javacOptions ) ; delegateBuilder . setTests ( args . getTests ( ) ) ; JavaLibraryDeps deps = Preconditions . checkNotNull ( delegateBuilder . getDeps ( ) ) ; BuildTarget libraryTarget = JavaAbis . isLibraryTarget ( buildTarget ) ? buildTarget : JavaAbis . getLibraryTarget ( buildTarget ) ; graphEnhancer = new AndroidLibraryGraphEnhancer ( libraryTarget , projectFilesystem , ImmutableSortedSet . copyOf ( Iterables . concat ( deps . getDeps ( ) , deps . getProvidedDeps ( ) ) ) , javacFactory . create ( new SourcePathRuleFinder ( graphBuilder ) , args ) , javacOptions , DependencyMode . FIRST_ORDER , false , args . getResourceUnionPackage ( ) , args . getFinalRName ( ) , false , args . isSkipNonUnionRDotJava ( ) ) ; getDummyRDotJava ( ) . ifPresent ( dummyRDotJava -> { delegateBuilder . setDeps ( new JavaLibraryDeps . Builder ( graphBuilder ) . from ( JavaLibraryDeps . newInstance ( args , graphBuilder , compilerFactory ) ) . addDepTargets ( dummyRDotJava . getBuildTarget ( ) ) . build ( ) ) ; } ) ; delegate = delegateBuilder . build ( ) ; }
shs96c/buck | public AndroidLibrary build ( ) { return ( AndroidLibrary ) delegate . buildLibrary ( ) ; }
shs96c/buck | public BuildRule buildAbi ( ) { return delegate . buildAbi ( ) ; }
shs96c/buck | public DummyRDotJava buildDummyRDotJava ( ) { return graphEnhancer . getBuildableForAndroidResources ( graphBuilder , true ) . get ( ) ; }
shs96c/buck | public Optional < DummyRDotJava > getDummyRDotJava ( ) { return graphEnhancer . getBuildableForAndroidResources ( graphBuilder , false ) ; }
codepitbull/wicket-buch | public HomePage ( final PageParameters parameters ) { add ( new Label ( " testText " , new AbstractReadOnlyModel < String > ( ) { @ Override public String getObject ( ) { return testService . getName ( ) ; } } ) ) ; }
google/guava | @ Override protected void setUp ( ) throws Exception { SettableFuture < ? > unused = SettableFuture . create ( ) ; final String concurrentPackage = SettableFuture . class . getPackage ( ) . getName ( ) ; classReloader = new URLClassLoader ( ClassPathUtil . getClassPathUrls ( ) ) { @ GuardedBy ( " loadedClasses " ) final Map < String , Class < ? > > loadedClasses = new HashMap < > ( ) ; @ Override public Class < ? > loadClass ( String name ) throws ClassNotFoundException { if ( name . startsWith ( concurrentPackage ) && ! ListenableFuture . class . getName ( ) . equals ( name ) ) { synchronized ( loadedClasses ) { Class < ? > toReturn = loadedClasses . get ( name ) ; if ( toReturn == null ) { toReturn = super . findClass ( name ) ; loadedClasses . put ( name , toReturn ) ; } return toReturn ; } } return super . loadClass ( name ) ; } } ; oldClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( classReloader ) ; oldSecurityManager = System . getSecurityManager ( ) ; final PropertyPermission readSystemProperty = new PropertyPermission ( " guava . concurrent . generate _ cancellation _ cause " , " read " ) ; SecurityManager disallowPropertySecurityManager = new SecurityManager ( ) { @ Override public void checkPermission ( Permission p ) { if ( readSystemProperty . equals ( p ) ) { throw new SecurityException ( " Disallowed : ▁ " + p ) ; } } } ; System . setSecurityManager ( disallowPropertySecurityManager ) ; settableFutureClass = classReloader . loadClass ( SettableFuture . class . getName ( ) ) ; }
google/guava | @ Override protected void tearDown ( ) throws Exception { System . setSecurityManager ( oldSecurityManager ) ; classReloader . close ( ) ; Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; }
google/guava | public void testAbstractFutureInitializationWithInnocuousThread_doesNotThrow ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; ForkJoinPool . commonPool ( ) . execute ( ( ) -> { try { settableFutureClass . getMethod ( " create " ) . invoke ( null ) ; latch . countDown ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }
Gigaspaces/xap-openspaces | @ Override public void calculateNewStatistics ( InternalProcessingUnitStatistics processingUnitStatistics , Collection < ProcessingUnitStatisticsId > statisticsIds ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( " calculateNewStatistics ( processingUnitStatistics = " + processingUnitStatistics + " ▁ , ▁ statisticsIds = " + statisticsIds ) ; } Map < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > instancesStatisticsPerErasedStatisticsId = eraseInstancesStatistics ( statisticsIds ) ; Set < ProcessingUnitStatisticsId > erasedStatisticsIds = instancesStatisticsPerErasedStatisticsId . keySet ( ) ; Map < ProcessingUnitStatisticsId , StatisticsObjectList > valuesPerErasedStatisticsId = getValues ( processingUnitStatistics , erasedStatisticsIds ) ; for ( Map . Entry < ProcessingUnitStatisticsId , StatisticsObjectList > pair : valuesPerErasedStatisticsId . entrySet ( ) ) { ProcessingUnitStatisticsId erasedStatisticsId = pair . getKey ( ) ; StatisticsObjectList values = pair . getValue ( ) ; for ( InstancesStatisticsConfig instancesStatistics : instancesStatisticsPerErasedStatisticsId . get ( erasedStatisticsId ) ) { if ( instancesStatistics instanceof StatisticsObjectListFunction ) { StatisticsObjectListFunction statisticsFunc = ( StatisticsObjectListFunction ) instancesStatistics ; Object value = statisticsFunc . calc ( values ) ; ProcessingUnitStatisticsId statisticsId = unerase ( erasedStatisticsId , instancesStatistics ) ; processingUnitStatistics . addStatistics ( statisticsId , value ) ; } } } }
Gigaspaces/xap-openspaces | private Map < ProcessingUnitStatisticsId , StatisticsObjectList > getValues ( InternalProcessingUnitStatistics processingUnitStatistics , Set < ProcessingUnitStatisticsId > erasedStatisticsIds ) { Map < ProcessingUnitStatisticsId , StatisticsObjectList > values = new HashMap < ProcessingUnitStatisticsId , StatisticsObjectList > ( ) ; for ( Entry < ProcessingUnitStatisticsId , Object > pair : processingUnitStatistics . getStatistics ( ) . entrySet ( ) ) { ProcessingUnitStatisticsId statisticsId = pair . getKey ( ) ; if ( statisticsId . getInstancesStatistics ( ) instanceof EachSingleInstanceStatisticsConfig ) { throw new IllegalArgumentException ( " Unsupported ▁ statisticsId . ▁ Use ▁ " + SingleInstanceStatisticsConfig . class + " ▁ instead ▁ of ▁ " + EachSingleInstanceStatisticsConfig . class ) ; } if ( statisticsId . getInstancesStatistics ( ) instanceof SingleInstanceStatisticsConfig ) { ProcessingUnitStatisticsId erasedStatisticsId = erase ( statisticsId ) ; if ( erasedStatisticsIds . contains ( erasedStatisticsId ) ) { if ( ! values . containsKey ( erasedStatisticsId ) ) { values . put ( erasedStatisticsId , new StatisticsObjectList ( ) ) ; } Object value = pair . getValue ( ) ; long timeStamp = processingUnitStatistics . getAdminTimestamp ( ) ; values . get ( erasedStatisticsId ) . add ( value , timeStamp ) ; } } } return values ; }
Gigaspaces/xap-openspaces | private Map < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > eraseInstancesStatistics ( Iterable < ProcessingUnitStatisticsId > statisticsIds ) { Map < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > groupBy = new HashMap < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > ( ) ; for ( ProcessingUnitStatisticsId statisticsId : statisticsIds ) { InstancesStatisticsConfig instancesStatistics = statisticsId . getInstancesStatistics ( ) ; ProcessingUnitStatisticsId key = erase ( statisticsId ) ; if ( ! groupBy . containsKey ( key ) ) { groupBy . put ( key , new HashSet < InstancesStatisticsConfig > ( ) ) ; } groupBy . get ( key ) . add ( instancesStatistics ) ; } return groupBy ; }
Gigaspaces/xap-openspaces | private ProcessingUnitStatisticsId erase ( ProcessingUnitStatisticsId statisticsId ) { statisticsId . validate ( ) ; ProcessingUnitStatisticsId erased = statisticsId . shallowClone ( ) ; erased . setInstancesStatistics ( null ) ; return erased ; }
Gigaspaces/xap-openspaces | private ProcessingUnitStatisticsId unerase ( ProcessingUnitStatisticsId erasedStatisticsId , InstancesStatisticsConfig instancesStatistics ) { ProcessingUnitStatisticsId unerased ; if ( erasedStatisticsId . getInstancesStatistics ( ) != null ) { unerased = erasedStatisticsId ; } else { unerased = erasedStatisticsId . shallowClone ( ) ; unerased . setInstancesStatistics ( instancesStatistics ) ; } unerased . validate ( ) ; return unerased ; }
ydengGitHub/usermodule | @ Bean public RememberMeServices rememberMeServices ( ) { TokenBasedRememberMeServices rememberMeServices = new TokenBasedRememberMeServices ( rememberMeKey , userService ) ; return rememberMeServices ; }
ydengGitHub/usermodule | @ Bean public PasswordEncoder passwordEncoder ( ) { logger . info ( " Creating ▁ password ▁ encoder ▁ bean " ) ; return new BCryptPasswordEncoder ( ) ; }
ydengGitHub/usermodule | @ Override protected void configure ( HttpSecurity http ) throws Exception { http . authorizeRequests ( ) . antMatchers ( " / " , " / home " , " / error " , " / signup " , " / forgot - password " , " / reset - password /* " , " / public /* * " , " / users /* * " ) . permitAll ( ) . anyRequest ( ) . authenticated ( ) ; http . formLogin ( ) . loginPage ( " / login " ) . permitAll ( ) . and ( ) . rememberMe ( ) . key ( rememberMeKey ) . rememberMeServices ( rememberMeServices ( ) ) . and ( ) . logout ( ) . permitAll ( ) ; }
ydengGitHub/usermodule | @ Autowired @ Override protected void configure ( AuthenticationManagerBuilder authManagerBuilder ) throws Exception { authManagerBuilder . userDetailsService ( userService ) . passwordEncoder ( passwordEncoder ( ) ) ; }
loxal/FreeEthereum | public ShhEnvelopeMessage ( final byte [ ] encoded ) { super ( encoded ) ; parse ( ) ; }
loxal/FreeEthereum | public ShhEnvelopeMessage ( final WhisperMessage ... msg ) { Collections . addAll ( messages , msg ) ; parsed = true ; }
loxal/FreeEthereum | public ShhEnvelopeMessage ( final Collection < WhisperMessage > msg ) { messages . addAll ( msg ) ; parsed = true ; }
loxal/FreeEthereum | @ Override public ShhMessageCodes getCommand ( ) { return MESSAGE ; }
loxal/FreeEthereum | public void addMessage ( final WhisperMessage msg ) { messages . add ( msg ) ; }
loxal/FreeEthereum | private void parse ( ) { if ( ! parsed ) { final RLPList paramsList = ( RLPList ) RLP . decode2 ( encoded ) . get ( 0 ) ; for ( final RLPElement aParamsList : paramsList ) { messages . add ( new WhisperMessage ( aParamsList . getRLPData ( ) ) ) ; } this . parsed = true ; } }
loxal/FreeEthereum | @ Override public byte [ ] getEncoded ( ) { if ( encoded == null ) { final byte [ ] [ ] encodedMessages = new byte [ messages . size ( ) ] [ ] ; for ( int i = 0 ; i < encodedMessages . length ; i ++ ) { encodedMessages [ i ] = messages . get ( i ) . getEncoded ( ) ; } encoded = RLP . encodeList ( encodedMessages ) ; } return encoded ; }
loxal/FreeEthereum | public List < WhisperMessage > getMessages ( ) { return messages ; }
loxal/FreeEthereum | @ Override public Class < ? > getAnswerMessage ( ) { return null ; }
loxal/FreeEthereum | @ Override public String toString ( ) { return " [ ENVELOPE ▁ " + messages . toString ( ) + " ] " ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerNonArgumentConstructor ( ) { processEngineConfiguration . setHistoryEventHandler ( new CompositeDbHistoryEventHandler ( ) ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 0 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerNonArgumentConstructorAddNullEvent ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( ) ; try { compositeDbHistoryEventHandler . add ( null ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerNonArgumentConstructorAddNotNullEvent ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( ) ; compositeDbHistoryEventHandler . add ( new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 2 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerNonArgumentConstructorAddTwoNotNullEvents ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( ) ; compositeDbHistoryEventHandler . add ( new CustomDbHistoryEventHandler ( ) ) ; compositeDbHistoryEventHandler . add ( new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 4 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNullVarargs ( ) { HistoryEventHandler historyEventHandler = null ; try { new CompositeDbHistoryEventHandler ( historyEventHandler ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNullTwoVarargs ( ) { try { new CompositeDbHistoryEventHandler ( null , null ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotNullVarargsOneEvent ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 2 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotNullVarargsTwoEvents ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( new CustomDbHistoryEventHandler ( ) , new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 4 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithEmptyList ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( new ArrayList < HistoryEventHandler > ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 0 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotEmptyListNullTwoEvents ( ) { List < HistoryEventHandler > historyEventHandlers = new ArrayList < HistoryEventHandler > ( ) ; historyEventHandlers . add ( null ) ; historyEventHandlers . add ( null ) ; try { new CompositeDbHistoryEventHandler ( historyEventHandlers ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotEmptyListNotNullTwoEvents ( ) { List < HistoryEventHandler > historyEventHandlers = new ArrayList < HistoryEventHandler > ( ) ; historyEventHandlers . add ( new CustomDbHistoryEventHandler ( ) ) ; historyEventHandlers . add ( new CustomDbHistoryEventHandler ( ) ) ; CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( historyEventHandlers ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 4 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
blacroix/droidcon_android_tests | public Messenger ( Context context ) { this . context = context ; }
blacroix/droidcon_android_tests | void showMessage ( String message ) { Toast . makeText ( context , message , Toast . LENGTH_SHORT ) . show ( ) ; }
blacroix/droidcon_android_tests | public void showMessage ( int messageId ) { Toast . makeText ( context , messageId , Toast . LENGTH_SHORT ) . show ( ) ; }
sovaj/sovaj.basics | @ Override public Calendar unmarshal ( String value ) { if ( value == null || value . length ( ) < 1 ) { return null ; } return DatatypeConverter . parseDateTime ( value ) ; }
sovaj/sovaj.basics | @ Override public String marshal ( Calendar value ) { if ( value == null ) { return null ; } return DatatypeConverter . printDateTime ( value ) ; }
nemoNoboru/SecretHitler | public PersonajeLiberal ( ) { }
nemoNoboru/SecretHitler | public String getPersonaje ( ) { return " Liberal " ; }
ChallenHB/drools | public Float getDistance2 ( ) { return this . distance2 ; }
ChallenHB/drools | public void setDistance2 ( final Float distance2 ) { this . distance2 = distance2 ; }
ChallenHB/drools | public Float getTime2 ( ) { return this . time2 ; }
ChallenHB/drools | public void setTime2 ( final Float time2 ) { this . time2 = time2 ; }
ChallenHB/drools | public Float getBearing ( ) { return this . bearing ; }
ChallenHB/drools | public void setBearing ( final Float bearing ) { this . bearing = bearing ; }
ChallenHB/drools | public Float getDistance ( ) { return this . distance ; }
ChallenHB/drools | public void setDistance ( final Float distance ) { this . distance = distance ; }
ChallenHB/drools | public String getLabel ( ) { return this . label ; }
ChallenHB/drools | public void setLabel ( final String label ) { this . label = label ; }
ChallenHB/drools | public String getLabel2 ( ) { return this . label2 ; }
ChallenHB/drools | public void setLabel2 ( final String label2 ) { this . label2 = label2 ; }
ChallenHB/drools | public Float getTime ( ) { return this . time ; }
ChallenHB/drools | public void setTime ( final Float time ) { this . time = time ; }
ChallenHB/drools | public Float getBearing2 ( ) { return this . bearing2 ; }
ChallenHB/drools | public void setBearing2 ( final Float bearing2 ) { this . bearing2 = bearing2 ; }
ChallenHB/drools | public String toString ( ) { return " Approach < ▁ label : ▁ " + this . label + " ▁ label2 : ▁ " + this . label2 + " ▁ time : ▁ " + this . time + " ▁ time2 : ▁ " + this . time2 + " ▁ distance : ▁ " + this . distance + " ▁ distance2 : ▁ " + this . distance2 + " ▁ bearing : ▁ " + this . bearing + " ▁ bearing2 : ▁ " + this . bearing2 + " ▁ > " ; }
westbury/dwg-lib | public Expander ( byte [ ] compressedData , int uncompressedSize ) { this . compressedData = compressedData ; result = expand ( uncompressedSize ) ; }
westbury/dwg-lib | private byte [ ] expand ( int uncompressedSize ) { byte [ ] outputBytes = new byte [ uncompressedSize ] ; int initialLitCount = getLitLength ( ) ; for ( int i = 0 ; i < initialLitCount ; i ++ ) { outputBytes [ outputPosition ++ ] = compressedData [ inputPosition ++ ] ; } int opcode1 ; while ( ( opcode1 = getUnsignedByte ( ) ) != 0x11 ) { if ( opcode1 < 0x10 ) { throw new RuntimeException ( " bad ▁ data ? ? ? " ) ; } int compressedBytes ; int compOffset ; int litCount ; if ( opcode1 == 0x10 ) { compressedBytes = getLongCompressionOffset ( ) + 9 ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset + 0x3FFF ; litCount = twoByteOffset . litCount ; } else if ( opcode1 <= 0x1F ) { assert opcode1 >= 0x12 && opcode1 <= 0x1F ; compressedBytes = ( opcode1 & 0x0F ) + 2 ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset + 0x3FFF ; litCount = twoByteOffset . litCount ; } else if ( opcode1 == 0x20 ) { compressedBytes = getLongCompressionOffset ( ) + 0x21 ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset ; litCount = twoByteOffset . litCount ; } else if ( opcode1 <= 0x3F ) { assert opcode1 >= 0x21 && opcode1 <= 0x3F ; compressedBytes = opcode1 - 0x1E ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset ; litCount = twoByteOffset . litCount ; } else { assert opcode1 >= 0x40 ; compressedBytes = ( ( opcode1 & 0xF0 ) >> 4 ) - 1 ; int opcode2 = getUnsignedByte ( ) ; compOffset = ( opcode2 << 2 ) | ( ( opcode1 & 0x0C ) >> 2 ) ; litCount = opcode1 & 0x03 ; if ( litCount == 0 ) { litCount = getLitLength ( ) ; } } int duplicateFromPosition = outputPosition - compOffset - 1 ; for ( int i = 0 ; i < compressedBytes ; i ++ ) { outputBytes [ outputPosition ++ ] = outputBytes [ duplicateFromPosition ++ ] ; } for ( int i = 0 ; i < litCount ; i ++ ) { outputBytes [ outputPosition ++ ] = compressedData [ inputPosition ++ ] ; } } return outputBytes ; }
westbury/dwg-lib | private int getLitLength ( ) { int opcode = peekUnsignedByte ( ) ; if ( opcode > 0x0F ) { return 0 ; } getUnsignedByte ( ) ; int runningTotal = 0 ; if ( opcode == 0x00 ) { runningTotal += 0x0F ; while ( ( opcode = getUnsignedByte ( ) ) == 0x00 ) { runningTotal += 0xFF ; } } return runningTotal + opcode + 3 ; }
westbury/dwg-lib | private int getLongCompressionOffset ( ) { int runningTotal = 0 ; int opcode ; while ( ( opcode = getUnsignedByte ( ) ) == 0x00 ) { runningTotal += 0xFF ; } return runningTotal + opcode ; }
westbury/dwg-lib | private TwoByteOffset getTwoByteOffset ( ) { int firstByte = getUnsignedByte ( ) ; int secondByte = getUnsignedByte ( ) ; int reducedCompOffset = ( firstByte >> 2 ) | ( secondByte << 6 ) ; int litCount = ( firstByte & 0x03 ) ; if ( litCount == 0 ) { litCount = getLitLength ( ) ; } return new TwoByteOffset ( reducedCompOffset , litCount ) ; }
westbury/dwg-lib | private int getUnsignedByte ( ) { return ( compressedData [ inputPosition ++ ] ) & 0xff ; }
westbury/dwg-lib | private int peekUnsignedByte ( ) { return ( compressedData [ inputPosition ] ) & 0xff ; }
westbury/dwg-lib | public TwoByteOffset ( int reducedCompOffset , int litCount ) { this . reducedCompOffset = reducedCompOffset ; this . litCount = litCount ; }
elect86/NvGlSamples | private NvGLSLProgram ( int program , boolean strict ) { this . programName = program ; this . strict = strict ; }
elect86/NvGlSamples | public int getAttribLocation ( GL4 gl4 , String attribute ) { return getAttribLocation ( gl4 , attribute , false ) ; }
elect86/NvGlSamples | public int getAttribLocation ( GL4 gl4 , String attribute , boolean isOptional ) { int result = gl4 . glGetAttribLocation ( programName , attribute ) ; if ( result == - 1 ) { if ( ( logAllMissing || strict ) && ! isOptional ) { System . err . println ( " could ▁ not ▁ find ▁ attribute ▁ " + attribute + " ▁ in ▁ program ▁ " + programName ) ; } } return result ; }
elect86/NvGlSamples | public void enable ( GL4 gl4 ) { gl4 . glUseProgram ( programName ) ; }
elect86/NvGlSamples | public void disable ( GL4 gl4 ) { gl4 . glUseProgram ( 0 ) ; }
elect86/NvGlSamples | public int getUniformLocation ( GL4 gl4 , String uniform ) { return getUniformLocation ( gl4 , uniform , false ) ; }
elect86/NvGlSamples | public int getUniformLocation ( GL4 gl4 , String uniform , boolean isOptional ) { int result = gl4 . glGetUniformLocation ( programName , uniform ) ; if ( result == - 1 ) { if ( ( logAllMissing || strict ) && ! isOptional ) { System . err . println ( " could ▁ not ▁ find ▁ uniform ▁ " + uniform + " ▁ in ▁ program ▁ " + programName ) ; } } return result ; }
eBay/myriad | public DeleteClusterResponse ( ) { }
cybera/OpenConext-dashboard | public Policy ( ) { }
cybera/OpenConext-dashboard | private Policy ( PolicyBuilder builder ) { this . id = builder . id ; this . created = builder . created ; this . userDisplayName = builder . userDisplayName ; this . actionsAllowed = builder . actionsAllowed ; this . revisionNbr = builder . revisionNbr ; this . numberOfRevisions = builder . numberOfRevisions ; this . serviceProviderName = builder . serviceProviderName ; this . name = builder . policy . name ; this . description = builder . policy . description ; this . serviceProviderId = builder . policy . serviceProviderId ; this . identityProviderIds = builder . policy . identityProviderIds ; this . identityProviderNames = builder . policy . identityProviderNames ; this . attributes = builder . policy . attributes ; this . denyAdvice = builder . policy . denyAdvice ; this . denyAdviceNl = builder . policy . denyAdviceNl ; this . denyRule = builder . policy . denyRule ; this . allAttributesMustMatch = builder . policy . allAttributesMustMatch ; this . authenticatingAuthorityName = builder . policy . authenticatingAuthorityName ; this . isActivatedSr = builder . policy . isActivatedSr ; this . active = builder . policy . active ; this . type = builder . policy . type ; }
cybera/OpenConext-dashboard | public Policy ( String name , String description ) { this . name = name ; this . description = description ; }
cybera/OpenConext-dashboard | public Long getId ( ) { return id ; }
cybera/OpenConext-dashboard | public String getName ( ) { return name ; }
cybera/OpenConext-dashboard | public String getDescription ( ) { return description ; }
cybera/OpenConext-dashboard | public String getServiceProviderName ( ) { return serviceProviderName ; }
cybera/OpenConext-dashboard | public String getServiceProviderNameNl ( ) { return serviceProviderNameNl ; }
cybera/OpenConext-dashboard | public int getNumberOfRevisions ( ) { return numberOfRevisions ; }
cybera/OpenConext-dashboard | public List < String > getIdentityProviderIds ( ) { return identityProviderIds ; }
cybera/OpenConext-dashboard | public List < String > getIdentityProviderNames ( ) { return identityProviderNames ; }
cybera/OpenConext-dashboard | public List < String > getIdentityProviderNamesNl ( ) { return identityProviderNamesNl ; }
cybera/OpenConext-dashboard | public boolean isActionsAllowed ( ) { return actionsAllowed ; }
cybera/OpenConext-dashboard | public List < Attribute > getAttributes ( ) { return attributes ; }
cybera/OpenConext-dashboard | public String getCreated ( ) { return created ; }
cybera/OpenConext-dashboard | public String getDenyAdvice ( ) { return denyAdvice ; }
cybera/OpenConext-dashboard | public String getDenyAdviceNl ( ) { return denyAdviceNl ; }
cybera/OpenConext-dashboard | public boolean isDenyRule ( ) { return denyRule ; }
cybera/OpenConext-dashboard | public boolean isAllAttributesMustMatch ( ) { return allAttributesMustMatch ; }
cybera/OpenConext-dashboard | public String getServiceProviderId ( ) { return serviceProviderId ; }
cybera/OpenConext-dashboard | public String getUserDisplayName ( ) { return userDisplayName ; }
cybera/OpenConext-dashboard | public int getRevisionNbr ( ) { return revisionNbr ; }
cybera/OpenConext-dashboard | public boolean isActivatedSr ( ) { return isActivatedSr ; }
cybera/OpenConext-dashboard | public boolean isActive ( ) { return active ; }
cybera/OpenConext-dashboard | public String getAuthenticatingAuthorityName ( ) { return authenticatingAuthorityName ; }
cybera/OpenConext-dashboard | public String getType ( ) { return type ; }
cybera/OpenConext-dashboard | public String toString ( ) { return MoreObjects . toStringHelper ( Policy . class ) . add ( " name " , name ) . add ( " serviceProviderId " , serviceProviderId ) . add ( " identityProviderIds " , identityProviderIds ) . add ( " denyRule " , denyRule ) . add ( " denyAdvice " , denyAdvice ) . add ( " denyAdviceNl " , denyAdviceNl ) . add ( " attributes " , attributes ) . add ( " created " , created ) . add ( " description " , description ) . add ( " type " , type ) . add ( " serviceProviderName " , serviceProviderName ) . toString ( ) ; }
cybera/OpenConext-dashboard | public Attribute ( ) { }
cybera/OpenConext-dashboard | public Attribute ( String name , String value ) { this . name = name ; this . value = value ; }
cybera/OpenConext-dashboard | public String getName ( ) { return name ; }
cybera/OpenConext-dashboard | public String getValue ( ) { return value ; }
cybera/OpenConext-dashboard | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( Attribute . class ) . add ( " name " , name ) . add ( " value " , value ) . toString ( ) ; }
cybera/OpenConext-dashboard | private PolicyBuilder ( Policy policy ) { this . policy = policy ; }
cybera/OpenConext-dashboard | public PolicyBuilder withId ( Long id ) { this . id = id ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withCreated ( String created ) { this . created = created ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withUserDisplayName ( String userDisplayName ) { this . userDisplayName = userDisplayName ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withActionsAllowed ( boolean actionsAllowed ) { this . actionsAllowed = actionsAllowed ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withRevisionNbr ( int revisionNbr ) { this . revisionNbr = revisionNbr ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withNumberOfRevisions ( int numberOfRevisions ) { this . numberOfRevisions = numberOfRevisions ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withServiceProviderName ( String serviceProviderName ) { this . serviceProviderName = serviceProviderName ; return this ; }
cybera/OpenConext-dashboard | public Policy build ( ) { return new Policy ( this ) ; }
Lanceolata/code-problems | public int numJewelsInStones ( String J , String S ) { Map < Character , Integer > map = new HashMap < Character , Integer > ( ) ; char [ ] arr = S . toCharArray ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { map . put ( arr [ i ] , map . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } arr = J . toCharArray ( ) ; int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { res += map . getOrDefault ( arr [ i ] , 0 ) ; } return res ; }
GunoH/intellij-community | BindToNewBeanStep ( @ NotNull final WizardData data ) { myData = data ; myTableModel = new MyTableModel ( ) ; myTable . setModel ( myTableModel ) ; myTable . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; myScrollPane . getViewport ( ) . setBackground ( myTable . getBackground ( ) ) ; myTable . setSurrendersFocusOnKeystroke ( true ) ; { final TableColumn column = myTable . getColumnModel ( ) . getColumn ( 0 ) ; column . setCellRenderer ( new FormPropertyTableCellRenderer ( myData . myProject ) ) ; } { final TableColumn column = myTable . getColumnModel ( ) . getColumn ( 1 ) ; column . setCellRenderer ( new BeanPropertyTableCellRenderer ( ) ) ; column . setCellEditor ( new BeanPropertyTableCellEditor ( ) ) ; final DefaultCellEditor editor = ( DefaultCellEditor ) myTable . getDefaultEditor ( Object . class ) ; editor . setClickCountToStart ( 1 ) ; } myChkGetData . setSelected ( true ) ; myChkGetData . setEnabled ( false ) ; myChkSetData . setSelected ( true ) ; myChkSetData . setEnabled ( false ) ; myChkIsModified . setSelected ( myData . myGenerateIsModified ) ; }
GunoH/intellij-community | @ Override public JComponent getComponent ( ) { return myPanel ; }
GunoH/intellij-community | @ Override public void _init ( ) { LOG . assertTrue ( myData . myBindToNewBean ) ; myTableModel . fireTableDataChanged ( ) ; }
GunoH/intellij-community | @ Override public void _commit ( boolean finishChosen ) throws CommitStepException { final TableCellEditor cellEditor = myTable . getCellEditor ( ) ; if ( cellEditor != null ) { cellEditor . stopCellEditing ( ) ; } final PsiNameHelper nameHelper = PsiNameHelper . getInstance ( myData . myProject ) ; for ( int i = 0 ; i < myData . myBindings . length ; i ++ ) { final FormProperty2BeanProperty binding = myData . myBindings [ i ] ; if ( binding . myBeanProperty == null ) { continue ; } if ( ! nameHelper . isIdentifier ( binding . myBeanProperty . myName ) ) { throw new CommitStepException ( UIDesignerBundle . message ( " error . X . is . not . a . valid . property . name " , binding . myBeanProperty . myName ) ) ; } } myData . myGenerateIsModified = myChkIsModified . isSelected ( ) ; }
GunoH/intellij-community | MyTableModel ( ) { myColumnNames = new String [ ] { UIDesignerBundle . message ( " column . form . field " ) , UIDesignerBundle . message ( " column . bean . property " ) } ; myColumnClasses = new Class [ ] { Object . class , Object . class } ; }
GunoH/intellij-community | @ Override public int getColumnCount ( ) { return myColumnNames . length ; }
GunoH/intellij-community | @ Override public String getColumnName ( final int column ) { return myColumnNames [ column ] ; }
GunoH/intellij-community | @ Override public Class getColumnClass ( final int column ) { return myColumnClasses [ column ] ; }
GunoH/intellij-community | @ Override public int getRowCount ( ) { return myData . myBindings . length ; }
GunoH/intellij-community | @ Override public boolean isCellEditable ( final int row , final int column ) { return column == 1 ; }
GunoH/intellij-community | @ Override public Object getValueAt ( final int row , final int column ) { final FormProperty2BeanProperty binding = myData . myBindings [ row ] ; if ( column == 0 ) { return binding . myFormProperty ; } else if ( column == 1 ) { return binding . myBeanProperty ; } else { throw new IllegalArgumentException ( " unknown ▁ column : ▁ " + column ) ; } }
GunoH/intellij-community | @ Override public void setValueAt ( final Object value , final int row , final int column ) { final FormProperty2BeanProperty binding = myData . myBindings [ row ] ; if ( column == 1 ) { binding . myBeanProperty = ( BeanProperty ) value ; } else { throw new IllegalArgumentException ( " unknown ▁ column : ▁ " + column ) ; } }
nmaguirre/riocuartobandasderock | @ Test public void nameTest ( ) { Song song = new Song ( ) ; song . setName ( " thebeatles " ) ; assertEquals ( " thebeatles " , song . getName ( ) ) ; }
nmaguirre/riocuartobandasderock | @ Test public void durationTest ( ) { Song song = new Song ( ) ; song . setDuration ( 3 ) ; assertEquals ( 3 , song . getDuration ( ) ) ; }
nmaguirre/riocuartobandasderock | @ Test public void constructorTest ( ) { Song song = new Song ( " pinguinos ▁ en ▁ la ▁ cama " , 300 ) ; boolean res = ( song . getName ( ) == " pinguinos ▁ en ▁ la ▁ cama " ) && ( song . getDuration ( ) == 300 ) ; assertTrue ( res ) ; }
nmaguirre/riocuartobandasderock | @ Test public void getDurationInStringTest ( ) { Song song = new Song ( ) ; int a = 129 ; song . setDuration ( a ) ; assertEquals ( "2:9" , song . getDurationAsString ( ) ) ; }
BriData/DBus | public List < Integer > getScope ( ) { return scope ; }
BriData/DBus | public void setScope ( List < Integer > scope ) { this . scope = scope ; }
BriData/DBus | public Boolean getEq ( ) { return isEq ; }
BriData/DBus | public void setEq ( Boolean eq ) { isEq = eq ; }
BriData/DBus | public void setStart ( String start ) { this . start = start ; }
BriData/DBus | public void setEnd ( String end ) { this . end = end ; }
BriData/DBus | public String getStart ( ) { return start ; }
BriData/DBus | public String getEnd ( ) { return end ; }
BriData/DBus | public String getStartType ( ) { return startType ; }
BriData/DBus | public void setStartType ( String startType ) { this . startType = startType ; }
BriData/DBus | public String getEndType ( ) { return endType ; }
BriData/DBus | public void setEndType ( String endType ) { this . endType = endType ; }
BriData/DBus | public String getParamter ( ) { return paramter ; }
BriData/DBus | public void setParamter ( String paramter ) { this . paramter = paramter ; }
BriData/DBus | public String getOperate ( ) { return operate ; }
BriData/DBus | public void setOperate ( String operate ) { this . operate = operate ; }
BriData/DBus | public String getRuleType ( ) { return ruleType ; }
BriData/DBus | public void setRuleType ( String ruleType ) { this . ruleType = ruleType ; }
BriData/DBus | public String getFilterKey ( ) { return filterKey ; }
BriData/DBus | public void setFilterKey ( String filterKey ) { this . filterKey = filterKey ; }
WhatAKitty/spark-project | ConfigurationWrapper ( String configurationName ) { Class < ? > clazz = null ; try { clazz = ClassUtils . forName ( configurationName , getClass ( ) . getClassLoader ( ) ) ; } catch ( ClassNotFoundException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( String . format ( " Target ▁ configuration ▁ named ▁ % s ▁ is ▁ not ▁ found . " , configurationName ) , e ) ; } } if ( ! clazz . isAnnotationPresent ( Configuration . class ) ) { throw new RuntimeException ( String . format ( " Target ▁ class ▁ % s ▁ is ▁ not ▁ configurable . " , configurationName ) ) ; } this . configurationAnnotation = clazz . getAnnotation ( Configuration . class ) ; Constructor < ? > [ ] constructors = clazz . getDeclaredConstructors ( ) ; if ( constructors . length > 1 ) { throw new RuntimeException ( " Target ▁ configuration ▁ can ' t ▁ be ▁ instantiated : ▁ There ▁ are ▁ too ▁ many ▁ constructor , ▁ please ▁ reduce ▁ constructor ' s ▁ count . ▁ Only ▁ one ▁ constructor ▁ can ▁ be ▁ instantiated . " ) ; } for ( Constructor < ? > constructor : constructors ) { if ( constructor . isAnnotationPresent ( ConfigurationProperties . class ) ) { ConfigurationProperties configurationProperties = constructor . getAnnotation ( ConfigurationProperties . class ) ; int propertyLength = 0 ; String [ ] propertiesLocations = configurationProperties . propertiesLocation ( ) ; Parameter [ ] parameters = constructor . getParameters ( ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { Parameter parameter = parameters [ i ] ; if ( parameter . getType ( ) . equals ( Properties . class ) ) { propertyLength ++ ; } } if ( propertiesLocations . length != propertyLength ) { throw new RuntimeException ( String . format ( " Target ▁ configuration ▁ % s ▁ can ▁ not ▁ be ▁ instantiated : ▁ Properties ' ▁ size ▁ is ▁ not ▁ equal ▁ to ▁ configuration ▁ locations ' ▁ size . " , configurationName ) ) ; } Object [ ] parameterValues = new Object [ parameters . length ] ; for ( int i = 0 ; i < parameters . length ; i ++ ) { String propertiesLocation = propertiesLocations [ i ] ; Parameter parameter = parameters [ i ] ; Object parameterValue ; if ( parameter . getType ( ) . equals ( Properties . class ) ) { parameterValue = loadProperties ( clazz , propertiesLocation ) ; } else { parameterValue = null ; } parameterValues [ i ] = parameterValue ; } try { this . configuration = constructor . newInstance ( parameterValues ) ; } catch ( InstantiationException | IllegalAccessException | InvocationTargetException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( String . format ( " Target ▁ configuration ▁ % s ▁ can ▁ not ▁ be ▁ instantiated . " , configurationName ) , e ) ; } } } else { this . configuration = Reflect . on ( clazz ) . create ( ) ; } } }
WhatAKitty/spark-project | private Properties loadProperties ( Class < ? > clazz , String propertiesLocation ) { URL propertiesUrl = null ; try { propertiesUrl = ResourceUtils . getURL ( propertiesLocation ) ; } catch ( FileNotFoundException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( String . format ( " The ▁ % s ▁ configuration ▁ file ▁ properties ▁ % s ▁ is ▁ not ▁ exists . ▁ " , clazz . getName ( ) , propertiesLocation ) , e ) ; } throw new RuntimeException ( e ) ; } return PropertiesLoaderUtils . loadProperties ( propertiesUrl ) ; }
WhatAKitty/spark-project | final String getName ( ) { return this . configuration . getClass ( ) . getName ( ) ; }
WhatAKitty/spark-project | final < T > T getConfiguration ( ) { return ( T ) this . configuration ; }
WhatAKitty/spark-project | final Configuration getConfigurationAnnotation ( ) { return this . configurationAnnotation ; }
WhatAKitty/spark-project | final Properties getProperties ( String propertiesName ) { return configurationProperties . get ( propertiesName ) ; }
WhatAKitty/spark-project | final boolean withMissing ( ) { return configurationAnnotation . withMissing ( ) ; }
google/differential-privacy | @ Before public void setUp ( ) { when ( noise . addNoise ( anyDouble ( ) , anyInt ( ) , anyDouble ( ) , anyDouble ( ) , anyDouble ( ) ) ) . thenAnswer ( invocation -> invocation . getArguments ( ) [ 0 ] ) ; when ( noise . getMechanismType ( ) ) . thenReturn ( GAUSSIAN ) ; sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . maxContributionsPerPartition ( 1 ) . lower ( - Double . MAX_VALUE ) . upper ( Double . MAX_VALUE ) . build ( ) ; }
google/differential-privacy | @ Test public void addEntry ( ) { sum . addEntry ( 1.0 ) ; sum . addEntry ( 2.0 ) ; sum . addEntry ( 3.0 ) ; sum . addEntry ( 4.0 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 10.0 ) ; }
google/differential-privacy | @ Test public void addEntries ( ) { sum . addEntries ( Arrays . asList ( 1.0 , 2.0 , 3.0 , 4.0 ) ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 10.0 ) ; }
google/differential-privacy | @ Test public void addEntry_Nan_ignored ( ) { sum . addEntry ( NaN ) ; sum . addEntry ( 2 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 2.0 ) ; }
google/differential-privacy | @ Test public void addEntry_calledAfterComputeResult_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntry ( 0.0 ) ) ; }
google/differential-privacy | @ Test public void addEntry_calledAfterSerialize_throwsException ( ) { sum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntry ( 0.0 ) ) ; }
google/differential-privacy | @ Test public void addEntries_calledAfterComputeResult_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntries ( Arrays . asList ( 0.0 ) ) ) ; }
google/differential-privacy | @ Test public void addEntries_calledAfterSerialize_throwsException ( ) { sum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntries ( Arrays . asList ( 0.0 ) ) ) ; }
google/differential-privacy | @ Test public void computeResult_multipleCalls_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . computeResult ( ) ) ; }
google/differential-privacy | @ Test public void computeResult_calledAfterSerialize_throwsException ( ) { sum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . computeResult ( ) ) ; }
google/differential-privacy | @ Test public void addEntry_clampsInput ( ) { sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . lower ( 0 ) . upper ( 1 ) . build ( ) ; sum . addEntry ( - 1.0 ) ; sum . addEntry ( 1.0 ) ; sum . addEntry ( 10.0 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 2 ) ; }
google/differential-privacy | @ Test public void computeResult_callsNoiseCorrectly ( ) { double value = 0.5 ; int l0Sensitivity = 1 ; sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( l0Sensitivity ) . maxContributionsPerPartition ( 5 ) . lower ( 0 ) . upper ( 100 ) . build ( ) ; sum . addEntry ( value ) ; sum . computeResult ( ) ; verify ( noise ) . addNoise ( eq ( value ) , eq ( l0Sensitivity ) , eq ( 500.0 ) , eq ( EPSILON ) , eq ( DELTA ) ) ; }
google/differential-privacy | @ Test public void computeResult_addsNoise ( ) { when ( noise . addNoise ( anyDouble ( ) , anyInt ( ) , anyDouble ( ) , anyDouble ( ) , anyDouble ( ) ) ) . thenAnswer ( invocation -> ( double ) invocation . getArguments ( ) [ 0 ] + 100.0 ) ; sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . lower ( 0 ) . upper ( 1000 ) . build ( ) ; sum . addEntry ( 10 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 110 ) ; }
google/differential-privacy | @ Test public void lowerBoundMinInteger_doesntOverflow ( ) { sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . maxContributionsPerPartition ( 1 ) . lower ( Integer . MIN_VALUE ) . upper ( 0 ) . build ( ) ; sum . computeResult ( ) ; verify ( noise ) . addNoise ( anyDouble ( ) , anyInt ( ) , eq ( - ( double ) Integer . MIN_VALUE ) , anyDouble ( ) , anyDouble ( ) ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesPartialSumCorrectly ( ) { sum . addEntry ( 10.0 ) ; sum . addEntry ( 10.0 ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( 20.0 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesZeroSumCorrectly ( ) { BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( 0.0 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMaxDoubleSumCorrectly ( ) { sum . addEntry ( Double . MAX_VALUE ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( Double . MAX_VALUE ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMinDoubleSumCorrectly ( ) { sum . addEntry ( Double . MIN_VALUE ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( Double . MIN_VALUE ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesNegativeSumCorrectly ( ) { sum . addEntry ( - 5.0 ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( - 5 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesPositiveSumCorrectly ( ) { sum . addEntry ( 5 ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( 5.0 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_calledAfterComputeResult_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . getSerializableSummary ( ) ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_multipleCalls_returnsSameSummary ( ) { sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . noise ( new LaplaceNoise ( ) ) . maxPartitionsContributed ( 1 ) . lower ( 0.0 ) . upper ( 1.0 ) . build ( ) ; sum . addEntry ( 0.5 ) ; byte [ ] summary1 = sum . getSerializableSummary ( ) ; byte [ ] summary2 = sum . getSerializableSummary ( ) ; assertThat ( summary1 ) . isEqualTo ( summary2 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesEpsilonCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . epsilon ( EPSILON ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getEpsilon ( ) ) . isEqualTo ( EPSILON ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesDeltaCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . delta ( DELTA ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getDelta ( ) ) . isEqualTo ( DELTA ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesGaussianNoiseCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . noise ( new GaussianNoise ( ) ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMechanismType ( ) ) . isEqualTo ( GAUSSIAN ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesLaplaceNoiseCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMechanismType ( ) ) . isEqualTo ( LAPLACE ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMaxPartitionsContributedCorrectly ( ) { int maxPartitionsContributed = 150 ; sum = getBoundedSumBuilderWithFields ( ) . maxPartitionsContributed ( maxPartitionsContributed ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMaxPartitionsContributed ( ) ) . isEqualTo ( maxPartitionsContributed ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMaxContributionsPerPartitionCorrectly ( ) { int maxContributionsPerPartition = 150 ; sum = getBoundedSumBuilderWithFields ( ) . maxContributionsPerPartition ( maxContributionsPerPartition ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMaxContributionsPerPartition ( ) ) . isEqualTo ( maxContributionsPerPartition ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesLowerCorrectly ( ) { double lower = - 0.1 ; sum = getBoundedSumBuilderWithFields ( ) . lower ( lower ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getLower ( ) ) . isEqualTo ( lower ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesUpperCorrectly ( ) { double upper = 0.1 ; sum = getBoundedSumBuilderWithFields ( ) . upper ( upper ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getUpper ( ) ) . isEqualTo ( upper ) ; }
google/differential-privacy | @ Test public void mergeWith_basicExample_sumsValues ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . addEntry ( 1 ) ; sourceSum . addEntry ( 1 ) ; targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ; assertThat ( targetSum . computeResult ( ) ) . isEqualTo ( 2 ) ; }
google/differential-privacy | @ Test public void mergeWith_calledTwice_sumsValues ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum1 = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum2 = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . addEntry ( 1 ) ; sourceSum1 . addEntry ( 2 ) ; sourceSum2 . addEntry ( 3 ) ; targetSum . mergeWith ( sourceSum1 . getSerializableSummary ( ) ) ; targetSum . mergeWith ( sourceSum2 . getSerializableSummary ( ) ) ; assertThat ( targetSum . computeResult ( ) ) . isEqualTo ( 6 ) ; }
google/differential-privacy | @ Test public void mergeWith_epsilonMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . epsilon ( EPSILON ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . epsilon ( 2 * EPSILON ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_nullDelta_mergesWithoutException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ; }
google/differential-privacy | @ Test public void mergeWith_deltaMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . delta ( DELTA ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . delta ( 2 * DELTA ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_noiseMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . noise ( new GaussianNoise ( ) ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_maxPartitionsContributedMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . maxPartitionsContributed ( 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . maxPartitionsContributed ( 2 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_maxContributionsPerPartitionMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . maxContributionsPerPartition ( 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . maxContributionsPerPartition ( 2 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_lowerBoundsMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . lower ( - 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . lower ( - 100 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_upperBoundsMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . upper ( 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . upper ( 100 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_calledAfterComputeResult_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . computeResult ( ) ; byte [ ] summary = sourceSum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> targetSum . mergeWith ( summary ) ) ; }
google/differential-privacy | @ Test public void mergeWith_calledAfterSerialization_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . getSerializableSummary ( ) ; byte [ ] summary = sourceSum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> targetSum . mergeWith ( summary ) ) ; }
google/differential-privacy | private BoundedSum . Params . Builder getBoundedSumBuilderWithFields ( ) { return BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . maxContributionsPerPartition ( 10 ) . lower ( - 10 ) . upper ( 10 ) ; }
dbs-leipzig/gradoop | @ Override public CCSSubgraph map ( CCSSubgraphEmbeddings subgraphEmbeddings ) throws Exception { reuseTuple . setCategory ( subgraphEmbeddings . getCategory ( ) ) ; reuseTuple . setCanonicalLabel ( subgraphEmbeddings . getCanonicalLabel ( ) ) ; reuseTuple . setEmbedding ( subgraphEmbeddings . getEmbeddings ( ) . iterator ( ) . next ( ) ) ; return reuseTuple ; }
JasmeenKaur19/jenkins-client | @ Test public void shouldAddStringParamToAnExistingJob ( ) throws IOException { JenkinsServer js = new JenkinsServer ( URI . create ( " http : // ci . soebes . de : 8080 / " ) ) ; MavenJobWithDetails mavenJob = js . getMavenJob ( " SupoSE " ) ; BuildWithDetails details = mavenJob . getLastSuccessfulBuild ( ) . details ( ) ; System . out . println ( " Build ▁ Number : ▁ " + details . getNumber ( ) ) ; TestReport testReport = mavenJob . getLastSuccessfulBuild ( ) . getTestReport ( ) ; System . out . println ( " - - - - - - ▁ Tests " ) ; System . out . println ( " ▁ ▁ ▁ ▁ urlName : ▁ " + testReport . getUrlName ( ) ) ; System . out . println ( " ▁ ▁ failCount : ▁ " + testReport . getFailCount ( ) ) ; System . out . println ( " ▁ ▁ skipCount : ▁ " + testReport . getSkipCount ( ) ) ; System . out . println ( " ▁ totalCount : ▁ " + testReport . getTotalCount ( ) ) ; List < TestChildReport > childReports = testReport . getChildReports ( ) ; for ( TestChildReport testChildReport : childReports ) { TestChild child = testChildReport . getChild ( ) ; System . out . println ( " ▁ Child ▁ number : ▁ " + child . getNumber ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ ▁ ▁ url : ▁ " + child . getUrl ( ) ) ; TestResult testResult = testChildReport . getResult ( ) ; System . out . println ( " ▁ Child ▁ ▁ ▁ duration : ▁ " + testResult . getDuration ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ failCount : ▁ " + testResult . getFailCount ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ passCount : ▁ " + testResult . getPassCount ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ skipCount : ▁ " + testResult . getSkipCount ( ) ) ; List < TestSuites > suites = testResult . getSuites ( ) ; for ( TestSuites testSuite : suites ) { System . out . println ( " ▁ ▁ ▁ TestSuite ▁ ▁ duration : " + testSuite . getDuration ( ) ) ; System . out . println ( " ▁ ▁ ▁ TestSuite ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ id : " + testSuite . getId ( ) ) ; System . out . println ( " ▁ ▁ ▁ TestSuite ▁ ▁ ▁ ▁ ▁ ▁ name : " + testSuite . getName ( ) ) ; System . out . println ( " ▁ ▁ ▁ TestSuite ▁ timestamp : " + testSuite . getTimestamp ( ) ) ; List < TestCase > testCases = testSuite . getCases ( ) ; double sumTestCases = 0.0 ; for ( TestCase testCase : testCases ) { System . out . println ( " ▁ ▁ ▁ ▁ ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ age : ▁ " + testCase . getAge ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ classname : ▁ " + testCase . getClassName ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ duration : ▁ " + testCase . getDuration ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ failedSince : ▁ " + testCase . getFailedSince ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ " + testCase . getName ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ ▁ ▁ status : ▁ " + testCase . getStatus ( ) ) ; sumTestCases += testCase . getDuration ( ) ; } System . out . println ( " - - - - > ▁ SUM : ▁ " + sumTestCases ) ; } } }
ControlSystemStudio/diirt | public final PVDirector < ? > getDirector ( ) { return director ; }
ControlSystemStudio/diirt | public final < T > DesiredRateExpression < T > channel ( String channelName , Class clazz ) { return new LastOfChannelExpression < > ( channelName , clazz ) ; }
ControlSystemStudio/diirt | void setDirector ( PVDirector < ? > director ) { this . director = director ; }
CandleCandle/camel | @ Override public boolean isUseRouteBuilder ( ) { return false ; }
CandleCandle/camel | @ Test public void testHttpsHandshakeError ( ) throws Exception { if ( isJavaVendor ( " ibm " ) ) { return ; } getMockEndpoint ( " mock : target " ) . expectedMessageCount ( 0 ) ; context . addRoutes ( new RouteBuilder ( ) { public void configure ( ) { from ( " netty - http : https : // localhost : { { port } } ? ssl = true & needClientAuth = true & keyStoreFormat = JKS " + " & passphrase = storepassword & keyStoreResource = jsse / server - keystore . jks & trustStoreResource = jsse / server - truststore . jks " ) . to ( " mock : target " ) ; } } ) ; context . start ( ) ; DefaultExchange exchange = new DefaultExchange ( context ) ; Exchange response = template . send ( " netty - http : https : // localhost : { { port } } ? requestTimeout = 10000 & throwExceptionOnFailure = false " + " & ssl = true & keyStoreFormat = JKS & passphrase = storepassword & keyStoreResource = jsse / client - keystore . jks & trustStoreResource = jsse / server - truststore . jks " , exchange ) ; Exception ex = response . getException ( ) ; assertTrue ( " should ▁ have ▁ failed " , response . isFailed ( ) ) ; assertEquals ( " exception ▁ expected " , javax . net . ssl . SSLHandshakeException . class , ex . getClass ( ) ) ; assertMockEndpointsSatisfied ( ) ; }
damorim/compilers-cin | i ++ ) { tokenNames [ i ] = VOCABULARY . getLiteralName ( i ) ; if ( tokenNames [ i ] == null ) { tokenNames [ i ] = VOCABULARY . getSymbolicName ( i ) ; } if ( tokenNames [ i ] == null ) { tokenNames [ i ] = " < INVALID > " ; } }
damorim/compilers-cin | @ Override @ Deprecated public String [ ] getTokenNames ( ) { return tokenNames ; }
damorim/compilers-cin | @ Override public Vocabulary getVocabulary ( ) { return VOCABULARY ; }
damorim/compilers-cin | public TestLexer ( CharStream input ) { super ( input ) ; _interp = new LexerATNSimulator ( this , _ATN , _decisionToDFA , _sharedContextCache ) ; }
damorim/compilers-cin | @ Override public String getGrammarFileName ( ) { return " Test . g4" ; }
damorim/compilers-cin | @ Override public String [ ] getRuleNames ( ) { return ruleNames ; }
damorim/compilers-cin | @ Override public String getSerializedATN ( ) { return _serializedATN ; }
damorim/compilers-cin | @ Override public String [ ] getModeNames ( ) { return modeNames ; }
damorim/compilers-cin | @ Override public ATN getATN ( ) { return _ATN ; }
damorim/compilers-cin | i ++ ) { _decisionToDFA [ i ] = new DFA ( _ATN . getDecisionState ( i ) , i ) ; }
prabodhprakash/problemsolving | private void printLCS ( ) { int i = 0 , j = 0 ; StringBuffer sb = new StringBuffer ( ) ; while ( i < sizeA && j < sizeB ) { if ( string1 [ i ] . equalsIgnoreCase ( string2 [ j ] ) ) { sb . append ( string1 [ i ] + " ▁ " ) ; i ++ ; j ++ ; } else if ( max [ i + 1 ] [ j ] >= max [ i ] [ j + 1 ] ) { i ++ ; } else { j ++ ; } } System . out . println ( sb . toString ( ) ) ; }
prabodhprakash/problemsolving | private void readInput ( ) { Scanner in = new Scanner ( System . in ) ; String [ ] sizes = in . nextLine ( ) . split ( " ▁ " ) ; sizeA = Integer . parseInt ( sizes [ 0 ] ) ; sizeB = Integer . parseInt ( sizes [ 1 ] ) ; max = new int [ sizeA + 1 ] [ sizeB + 1 ] ; string1 = in . nextLine ( ) . split ( " ▁ " ) ; string2 = in . nextLine ( ) . split ( " ▁ " ) ; in . close ( ) ; }
prabodhprakash/problemsolving | private int calculateLCS ( int i , int j ) { if ( i >= sizeA || j >= sizeB ) { return 0 ; } if ( max [ i ] [ j ] > 0 ) { return max [ i ] [ j ] ; } String a = string1 [ i ] ; String b = string2 [ j ] ; if ( i < sizeA && j < sizeB && a . equalsIgnoreCase ( b ) ) { max [ i ] [ j ] = 1 + calculateLCS ( i + 1 , j + 1 ) ; } else { max [ i ] [ j ] = Math . max ( calculateLCS ( i + 1 , j ) , calculateLCS ( i , j + 1 ) ) ; } return max [ i ] [ j ] ; }
plum-umd/pasket | public void paintIcon ( Component c , Graphics g , int x , int y ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setColor ( Color . WHITE ) ; g2d . fillRect ( x + 1 , y + 1 , width - 2 , height - 2 ) ; g2d . setColor ( Color . BLACK ) ; g2d . drawRect ( x + 1 , y + 1 , width - 2 , height - 2 ) ; g2d . setColor ( Color . RED ) ; g2d . setStroke ( stroke ) ; g2d . drawLine ( x + 10 , y + 10 , x + width - 10 , y + height - 10 ) ; g2d . drawLine ( x + 10 , y + height - 10 , x + width - 10 , y + 10 ) ; g2d . dispose ( ) ; }
plum-umd/pasket | public int getIconWidth ( ) { return width ; }
plum-umd/pasket | public int getIconHeight ( ) { return height ; }
AdrianCozma/gateway | @ Override public String getSchemeName ( ) { return SCHEME_NAME ; }
AdrianCozma/gateway | @ Override protected int getSchemePort ( ) { return SCHEME_PORT ; }
AdrianCozma/gateway | @ Override protected String getTransportName ( ) { return TRANSPORT_NAME ; }
AdrianCozma/gateway | @ Override protected ResourceFactory getTransportFactory ( ) { return TRANSPORT_FACTORY ; }
AdrianCozma/gateway | @ Override protected String getProtocolName ( ) { return PROTOCOL_NAME ; }
AdrianCozma/gateway | @ Override protected void parseNamedOptions0 ( String location , ResourceOptions options , Map < String , Object > optionsByName ) { Boolean keepAlive = ( Boolean ) optionsByName . remove ( KEEP_ALIVE . name ( ) ) ; if ( keepAlive != null ) { options . setOption ( KEEP_ALIVE , keepAlive ) ; } Object maxRedirects = optionsByName . remove ( MAXIMUM_REDIRECTS . name ( ) ) ; if ( maxRedirects != null ) { options . setOption ( MAXIMUM_REDIRECTS , maxRedirects instanceof String ? Integer . parseInt ( ( String ) maxRedirects ) : ( Integer ) maxRedirects ) ; } Integer keepAliveTimeout = ( Integer ) optionsByName . remove ( KEEP_ALIVE_TIMEOUT . name ( ) ) ; if ( keepAliveTimeout != null ) { options . setOption ( KEEP_ALIVE_TIMEOUT , keepAliveTimeout ) ; } Integer keepAliveConnections = ( Integer ) optionsByName . remove ( KEEP_ALIVE_CONNECTIONS . name ( ) ) ; if ( keepAliveConnections != null ) { options . setOption ( KEEP_ALIVE_CONNECTIONS , keepAliveConnections ) ; } String [ ] requiredRoles = ( String [ ] ) optionsByName . remove ( REQUIRED_ROLES . name ( ) ) ; if ( requiredRoles != null ) { options . setOption ( REQUIRED_ROLES , requiredRoles ) ; } String authenticationConnect = ( String ) optionsByName . remove ( AUTHENTICATION_CONNECT . name ( ) ) ; if ( authenticationConnect != null ) { options . setOption ( AUTHENTICATION_CONNECT , authenticationConnect ) ; } String authenticationIdentifier = ( String ) optionsByName . remove ( AUTHENTICATION_IDENTIFIER . name ( ) ) ; if ( authenticationIdentifier != null ) { options . setOption ( AUTHENTICATION_IDENTIFIER , authenticationIdentifier ) ; } String encryptionKeyAlias = ( String ) optionsByName . remove ( ENCRYPTION_KEY_ALIAS . name ( ) ) ; if ( encryptionKeyAlias != null ) { options . setOption ( ENCRYPTION_KEY_ALIAS , encryptionKeyAlias ) ; } String serviceDomain = ( String ) optionsByName . remove ( SERVICE_DOMAIN . name ( ) ) ; if ( serviceDomain != null ) { options . setOption ( SERVICE_DOMAIN , serviceDomain ) ; } Set < HttpInjectableHeader > injectableHeaders = ( Set < HttpInjectableHeader > ) optionsByName . remove ( INJECTABLE_HEADERS . name ( ) ) ; if ( injectableHeaders != null ) { options . setOption ( INJECTABLE_HEADERS , injectableHeaders ) ; } Map < String , ? extends CrossSiteConstraintContext > acceptConstraints = ( Map < String , ? extends CrossSiteConstraintContext > ) optionsByName . remove ( ORIGIN_SECURITY . name ( ) ) ; if ( acceptConstraints != null ) { options . setOption ( ORIGIN_SECURITY , new HttpOriginSecurity ( acceptConstraints ) ) ; } File tempDirectory = ( File ) optionsByName . remove ( TEMP_DIRECTORY . name ( ) ) ; if ( tempDirectory != null ) { options . setOption ( TEMP_DIRECTORY , tempDirectory ) ; } List < Map < String , Map < String , CrossSiteConstraintContext > > > authorityToSetOfAcceptConstraintsByURI = ( List < Map < String , Map < String , CrossSiteConstraintContext > > > ) optionsByName . remove ( GATEWAY_ORIGIN_SECURITY . name ( ) ) ; if ( authorityToSetOfAcceptConstraintsByURI != null ) { options . setOption ( GATEWAY_ORIGIN_SECURITY , new GatewayHttpOriginSecurity ( authorityToSetOfAcceptConstraintsByURI ) ) ; } Collection < String > balanceOrigin = ( Collection < String > ) optionsByName . remove ( BALANCE_ORIGINS . name ( ) ) ; if ( balanceOrigin != null ) { options . setOption ( BALANCE_ORIGINS , balanceOrigin ) ; } Boolean serverHeaderEnabled = ( Boolean ) optionsByName . remove ( SERVER_HEADER_ENABLED . name ( ) ) ; if ( serverHeaderEnabled != null ) { options . setOption ( SERVER_HEADER_ENABLED , serverHeaderEnabled ) ; } Boolean dateHeaderEnabled = ( Boolean ) optionsByName . remove ( DATE_HEADER_ENABLED . name ( ) ) ; if ( serverHeaderEnabled != null ) { options . setOption ( DATE_HEADER_ENABLED , dateHeaderEnabled ) ; } Boolean userAgentHeaderEnabled = ( Boolean ) optionsByName . remove ( USER_AGENT_HEADER_ENABLED . name ( ) ) ; if ( userAgentHeaderEnabled != null ) { options . setOption ( USER_AGENT_HEADER_ENABLED , userAgentHeaderEnabled ) ; } Boolean hostHeaderEnabled = ( Boolean ) optionsByName . remove ( HOST_HEADER_ENABLED . name ( ) ) ; if ( hostHeaderEnabled != null ) { options . setOption ( HOST_HEADER_ENABLED , hostHeaderEnabled ) ; } Object maxAuthenticationAttempts = optionsByName . remove ( MAX_AUTHENTICATION_ATTEMPTS . name ( ) ) ; if ( maxAuthenticationAttempts != null ) { if ( maxAuthenticationAttempts instanceof String ) { maxAuthenticationAttempts = Integer . parseInt ( ( String ) maxAuthenticationAttempts ) ; } options . setOption ( MAX_AUTHENTICATION_ATTEMPTS , ( Integer ) maxAuthenticationAttempts ) ; } HttpRealmInfo [ ] realms = ( HttpRealmInfo [ ] ) optionsByName . remove ( REALMS . name ( ) ) ; if ( realms != null ) { options . setOption ( REALMS , realms ) ; } IdentityResolver httpIdentityResolver = ( IdentityResolver ) optionsByName . remove ( IDENTITY_RESOLVER . name ( ) ) ; if ( httpIdentityResolver != null ) { options . setOption ( IDENTITY_RESOLVER , httpIdentityResolver ) ; } else { Collection < Class < ? extends Principal > > userPrincipalClasses = getUserPrincipalClasses ( ( HttpRealmInfo [ ] ) optionsByName . remove ( REALMS . name ( ) ) ) ; if ( userPrincipalClasses != null && ! userPrincipalClasses . isEmpty ( ) ) { httpIdentityResolver = new HttpIdentityResolver ( userPrincipalClasses ) ; options . setOption ( IDENTITY_RESOLVER , httpIdentityResolver ) ; } } }
AdrianCozma/gateway | private Collection < Class < ? extends Principal > > getUserPrincipalClasses ( HttpRealmInfo [ ] realms ) { if ( realms != null && realms . length > 0 ) { if ( realms . length == 1 ) { return realms [ 0 ] . getUserPrincipleClasses ( ) ; } else { return Arrays . stream ( realms ) . map ( r -> r . getUserPrincipleClasses ( ) ) . filter ( upc -> upc != null ) . flatMap ( upc -> upc . stream ( ) ) . collect ( Collectors . toList ( ) ) ; } } else { return Collections . emptySet ( ) ; } }
AdrianCozma/gateway | @ Override protected void setAlternateOption ( final String location , ResourceOptions options , Map < String , Object > optionsByName ) { String key = options . getOption ( HttpResourceAddress . NEXT_PROTOCOL ) ; String scheme = URIUtils . getScheme ( location ) ; final boolean secureScheme = " https " . equals ( scheme ) || scheme . contains ( " + ssl " ) ; if ( key != null && secureScheme ) { key = key + " ▁ secure " ; } List < ResourceFactory > resourceFactories = RESOURCE_FACTORIES_BY_KEY . get ( key ) ; if ( resourceFactories != null && ! resourceFactories . isEmpty ( ) && getResourceAddressFactory ( ) != null ) { HttpResourceAddress alternateAddress = null ; for ( ResourceFactory resourceFactory : resourceFactories ) { alternateAddress = newResourceAddressWithAlternate ( resourceFactory . createURI ( location ) , getNewOptionsByName ( options , optionsByName ) , alternateAddress ) ; } options . setOption ( ResourceAddress . ALTERNATE , alternateAddress ) ; } }
AdrianCozma/gateway | @ Override protected HttpResourceAddress newResourceAddress0 ( String original , String location ) { String host = URIUtils . getHost ( location ) ; int port = URIUtils . getPort ( location ) ; String path = URIUtils . getPath ( location ) ; if ( host == null ) { throw new IllegalArgumentException ( format ( " Missing ▁ host ▁ in ▁ URI : ▁ % s " , location ) ) ; } if ( port == - 1 ) { throw new IllegalArgumentException ( format ( " Missing ▁ port ▁ in ▁ URI : ▁ % s " , location ) ) ; } if ( path == null || path . length ( ) == 0 ) { throw new IllegalArgumentException ( format ( " Missing ▁ path ▁ in ▁ URI : ▁ % s " , location ) ) ; } URI uriLocation = URI . create ( location ) ; return new HttpResourceAddress ( this , original , uriLocation ) ; }
AdrianCozma/gateway | @ Override protected void setOptions ( HttpResourceAddress address , ResourceOptions options , Object qualifier ) { super . setOptions ( address , options , qualifier ) ; address . setOption0 ( KEEP_ALIVE , options . getOption ( KEEP_ALIVE ) ) ; address . setOption0 ( MAXIMUM_REDIRECTS , options . getOption ( MAXIMUM_REDIRECTS ) ) ; address . setOption0 ( KEEP_ALIVE_TIMEOUT , options . getOption ( KEEP_ALIVE_TIMEOUT ) ) ; address . setOption0 ( KEEP_ALIVE_CONNECTIONS , options . getOption ( KEEP_ALIVE_CONNECTIONS ) ) ; address . setOption0 ( REQUIRED_ROLES , options . getOption ( REQUIRED_ROLES ) ) ; address . setOption0 ( INJECTABLE_HEADERS , options . getOption ( INJECTABLE_HEADERS ) ) ; address . setOption0 ( ORIGIN_SECURITY , options . getOption ( ORIGIN_SECURITY ) ) ; address . setOption0 ( TEMP_DIRECTORY , options . getOption ( TEMP_DIRECTORY ) ) ; address . setOption0 ( GATEWAY_ORIGIN_SECURITY , options . getOption ( GATEWAY_ORIGIN_SECURITY ) ) ; address . setOption0 ( BALANCE_ORIGINS , options . getOption ( BALANCE_ORIGINS ) ) ; address . setOption0 ( AUTHENTICATION_CONNECT , options . getOption ( AUTHENTICATION_CONNECT ) ) ; address . setOption0 ( AUTHENTICATION_IDENTIFIER , options . getOption ( AUTHENTICATION_IDENTIFIER ) ) ; address . setOption0 ( ENCRYPTION_KEY_ALIAS , options . getOption ( ENCRYPTION_KEY_ALIAS ) ) ; address . setOption0 ( SERVICE_DOMAIN , options . getOption ( SERVICE_DOMAIN ) ) ; address . setOption0 ( SERVER_HEADER_ENABLED , options . getOption ( SERVER_HEADER_ENABLED ) ) ; address . setOption0 ( USER_AGENT_HEADER_ENABLED , options . getOption ( USER_AGENT_HEADER_ENABLED ) ) ; address . setOption0 ( HOST_HEADER_ENABLED , options . getOption ( HOST_HEADER_ENABLED ) ) ; address . setOption0 ( DATE_HEADER_ENABLED , options . getOption ( DATE_HEADER_ENABLED ) ) ; address . setOption0 ( MAX_AUTHENTICATION_ATTEMPTS , options . getOption ( MAX_AUTHENTICATION_ATTEMPTS ) ) ; address . setOption0 ( REALMS , options . getOption ( REALMS ) ) ; if ( address . getOption ( IDENTITY_RESOLVER ) == null ) { Collection < Class < ? extends Principal > > realmUserPrincipalClasses = getUserPrincipalClasses ( address . getOption ( REALMS ) ) ; if ( realmUserPrincipalClasses != null && ! realmUserPrincipalClasses . isEmpty ( ) ) { IdentityResolver httpIdentityResolver = new HttpIdentityResolver ( realmUserPrincipalClasses ) ; address . setIdentityResolver ( IDENTITY_RESOLVER , httpIdentityResolver ) ; } } }
aws/aws-sdk-java | public ListTagsForResourceResult unmarshall ( JsonUnmarshallerContext context ) throws Exception { ListTagsForResourceResult listTagsForResourceResult = new ListTagsForResourceResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; String currentParentElement = context . getCurrentParentElement ( ) ; int targetDepth = originalDepth + 1 ; JsonToken token = context . getCurrentToken ( ) ; if ( token == null ) token = context . nextToken ( ) ; if ( token == VALUE_NULL ) { return listTagsForResourceResult ; } while ( true ) { if ( token == null ) break ; if ( token == FIELD_NAME || token == START_OBJECT ) { if ( context . testExpression ( " Tags " , targetDepth ) ) { context . nextToken ( ) ; listTagsForResourceResult . setTags ( new ListUnmarshaller < Tag > ( TagJsonUnmarshaller . getInstance ( ) ) . unmarshall ( context ) ) ; } } else if ( token == END_ARRAY || token == END_OBJECT ) { if ( context . getLastParsedParentElement ( ) == null || context . getLastParsedParentElement ( ) . equals ( currentParentElement ) ) { if ( context . getCurrentDepth ( ) <= originalDepth ) break ; } } token = context . nextToken ( ) ; } return listTagsForResourceResult ; }
donovanmuller/spring-cloud-dataflow | TaskNode ( String name , String taskDSL , List < LabelledTaskNode > sequences , boolean inAppMode ) { super ( ( sequences . size ( ) == 0 ) ? 0 : sequences . get ( 0 ) . getStartPos ( ) , ( sequences . size ( ) == 0 ) ? 0 : sequences . get ( sequences . size ( ) - 1 ) . getEndPos ( ) ) ; this . name = name ; this . taskDSL = taskDSL ; this . sequences = sequences ; }
donovanmuller/spring-cloud-dataflow | @ Override public String stringify ( boolean includePositionInfo ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < sequences . size ( ) ; i ++ ) { if ( i > 0 ) { s . append ( " \n " ) ; } s . append ( sequences . get ( i ) . stringify ( includePositionInfo ) ) ; } return s . toString ( ) ; }
donovanmuller/spring-cloud-dataflow | public List < TaskApp > getTaskApps ( ) { if ( taskApps == null ) { TaskAppsCollector collector = new TaskAppsCollector ( ) ; accept ( collector ) ; taskApps = collector . getTaskApps ( ) ; } return taskApps ; }
donovanmuller/spring-cloud-dataflow | public void accept ( TaskVisitor visitor ) { Assert . notNull ( visitor , " visitor ▁ expected ▁ to ▁ be ▁ non - null " ) ; visitor . startVisit ( this . name , this . taskDSL ) ; int sequenceNumber = 0 ; for ( LabelledTaskNode ctn : sequences ) { if ( visitor . preVisitSequence ( ctn , sequenceNumber ) ) { ctn . accept ( visitor ) ; visitor . postVisitSequence ( ctn , sequenceNumber ) ; } sequenceNumber ++ ; } visitor . endVisit ( ) ; }
donovanmuller/spring-cloud-dataflow | public Graph toGraph ( ) { GraphGeneratorVisitor ggv = new GraphGeneratorVisitor ( ) ; this . accept ( ggv ) ; return ggv . getGraph ( ) ; }
donovanmuller/spring-cloud-dataflow | public List < TaskValidationProblem > validate ( ) { TaskValidatorVisitor validator = new TaskValidatorVisitor ( ) ; this . accept ( validator ) ; return validator . getProblems ( ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void startVisit ( String taskName , String taskDSL ) { this . taskName = taskName ; }
donovanmuller/spring-cloud-dataflow | @ Override public void visit ( TaskAppNode taskApp ) { taskApps . add ( new TaskApp ( taskName , taskApp ) ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void visit ( TransitionNode transition ) { if ( transition . isTargetApp ( ) ) { taskApps . add ( new TaskApp ( taskName , transition . getTargetApp ( ) ) ) ; } }
donovanmuller/spring-cloud-dataflow | public List < TaskApp > getTaskApps ( ) { return taskApps ; }
donovanmuller/spring-cloud-dataflow | public String getName ( ) { return this . name ; }
donovanmuller/spring-cloud-dataflow | public String getTaskText ( ) { return this . taskDSL ; }
donovanmuller/spring-cloud-dataflow | public LabelledTaskNode getStart ( ) { if ( sequences . size ( ) == 0 ) { return null ; } else { return sequences . get ( 0 ) ; } }
donovanmuller/spring-cloud-dataflow | public List < LabelledTaskNode > getSequences ( ) { return Collections . unmodifiableList ( sequences ) ; }
donovanmuller/spring-cloud-dataflow | public LabelledTaskNode getSequenceWithLabel ( String label ) { Assert . hasText ( label , " label ▁ is ▁ required " ) ; for ( LabelledTaskNode ctn : sequences ) { if ( ctn . hasLabel ( ) && ctn . getLabelString ( ) . equals ( label ) ) { return ctn ; } } return null ; }
donovanmuller/spring-cloud-dataflow | public String toDSL ( ) { return stringify ( false ) ; }
donovanmuller/spring-cloud-dataflow | public String toExecutableDSL ( ) { ExecutableDSLVisitor v = new ExecutableDSLVisitor ( ) ; accept ( v ) ; return v . getDSL ( ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void startVisit ( String taskName , String taskDSL ) { this . taskName = taskName ; }
donovanmuller/spring-cloud-dataflow | @ Override public boolean preVisit ( FlowNode flow ) { if ( ! state . isEmpty ( ) && state . peek ( ) == IN_SPLIT ) { dsl . append ( " ▁ | | ▁ " ) ; } state . push ( START_OF_FLOW ) ; return true ; }
donovanmuller/spring-cloud-dataflow | @ Override public void postVisit ( FlowNode flow ) { state . pop ( ) ; if ( ! state . isEmpty ( ) && state . peek ( ) == START_OF_SPLIT ) { state . pop ( ) ; state . push ( IN_SPLIT ) ; } }
donovanmuller/spring-cloud-dataflow | @ Override public boolean preVisit ( SplitNode split ) { if ( state . peek ( ) == START_OF_FLOW ) { state . pop ( ) ; state . push ( IN_FLOW ) ; } else if ( state . peek ( ) == IN_FLOW ) { dsl . append ( " ▁ & & ▁ " ) ; } state . push ( START_OF_SPLIT ) ; dsl . append ( " < " ) ; return true ; }
donovanmuller/spring-cloud-dataflow | @ Override public void postVisit ( SplitNode split ) { dsl . append ( " > " ) ; state . pop ( ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void visit ( TaskAppNode taskApp ) { int currentState = state . peek ( ) ; if ( currentState == START_OF_FLOW ) { state . pop ( ) ; state . push ( IN_FLOW ) ; } else if ( currentState == IN_FLOW ) { dsl . append ( " ▁ & & ▁ " ) ; } else { throw new IllegalStateException ( " " + state . peek ( ) ) ; } dsl . append ( toExecutableDSLTaskName ( taskApp ) ) ; List < TransitionNode > transitions = taskApp . getTransitions ( ) ; for ( TransitionNode transition : transitions ) { dsl . append ( " ▁ " ) ; dsl . append ( transition . getStatusToCheckInDSLForm ( ) ) ; dsl . append ( " - > " ) ; if ( transition . isTargetApp ( ) ) { dsl . append ( toExecutableDSLTaskName ( transition . getTargetApp ( ) ) ) ; } else { dsl . append ( " : " ) . append ( transition . getTargetLabel ( ) ) ; } } }
donovanmuller/spring-cloud-dataflow | private String toExecutableDSLTaskName ( TaskAppNode taskApp ) { StringBuilder taskDefName = new StringBuilder ( ) ; taskDefName . append ( getTaskPrefix ( taskName ) ) ; if ( taskApp . hasLabel ( ) ) { taskDefName . append ( taskApp . getLabelString ( ) ) ; } else { taskDefName . append ( taskApp . getName ( ) ) ; } return taskDefName . toString ( ) ; }
donovanmuller/spring-cloud-dataflow | public String getDSL ( ) { return dsl . toString ( ) ; }
donovanmuller/spring-cloud-dataflow | public boolean isComposed ( ) { boolean isOneTask = ( sequences . size ( ) == 1 && sequences . get ( 0 ) . isFlow ( ) && ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesLength ( ) == 1 && ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesElement ( 0 ) . isTaskApp ( ) ) ; if ( ! isOneTask ) { return true ; } TaskAppNode singleNode = ( TaskAppNode ) ( ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesElement ( 0 ) ) ; return singleNode . hasTransitions ( ) ; }
donovanmuller/spring-cloud-dataflow | public TaskAppNode getTaskApp ( ) { return ( isComposed ( ) ? null : ( TaskAppNode ) ( ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesElement ( 0 ) ) ) ; }
donovanmuller/spring-cloud-dataflow | public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; s . append ( " TaskNode ▁ for ▁ " ) . append ( taskDSL . replaceAll ( " \n " , " ; " ) ) ; s . append ( " \n " ) . append ( sequences ) ; return s . toString ( ) ; }
tilioteo/hypothesis | public Interval ( T min , T max ) { this . min = min ; this . max = max ; }
tilioteo/hypothesis | public boolean contains ( T value ) { if ( value != null ) { return value . compareTo ( min ) >= 0 && value . compareTo ( max ) <= 0 ; } return false ; }
tilioteo/hypothesis | public boolean containsExclusive ( T value ) { if ( value != null ) { return value . compareTo ( min ) > 0 && value . compareTo ( max ) < 0 ; } return false ; }
tilioteo/hypothesis | public boolean containsExclusiveRight ( T value ) { if ( value != null ) { return value . compareTo ( min ) >= 0 && value . compareTo ( max ) < 0 ; } return false ; }
tilioteo/hypothesis | public boolean containsExclusiveLeft ( T value ) { if ( value != null ) { return value . compareTo ( min ) > 0 && value . compareTo ( max ) <= 0 ; } return false ; }
ufoscout/jpattern | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; }
ufoscout/jpattern | @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; }
ufoscout/jpattern | public void testString ( ) { assertTrue ( mc . estimate ( new String ( " Hello ▁ World ! " ) ) >= 64 ) ; }
ufoscout/jpattern | public void testIntegerToString ( ) { for ( int i = 0 ; i < 1 ; i ++ ) { assertEquals ( 42 , mc . estimate ( " " + i ) ) ; } }
ufoscout/jpattern | Entry ( int h , Object k , Object v , Entry n ) { value = v ; next = n ; key = k ; hash = h ; }
ufoscout/jpattern | @ Override public Object getKey ( ) { return key ; }
ufoscout/jpattern | @ Override public Object getValue ( ) { return value ; }
ufoscout/jpattern | @ Override public Object setValue ( Object value ) { return value ; }
ufoscout/jpattern | public void testHashMap ( ) { assertTrue ( mc . estimate ( new HashMap < Object , Object > ( ) ) >= 120 ) ; Byte [ ] all = new Byte [ 256 ] ; for ( int i = - 128 ; i < 128 ; i ++ ) { all [ i + 128 ] = new Byte ( ( byte ) i ) ; } assertTrue ( mc . estimate ( all ) >= 5136 ) ; HashMap < Object , Object > hm = new HashMap < Object , Object > ( ) ; for ( int i = - 128 ; i < 128 ; i ++ ) { hm . put ( " " + i , new Byte ( ( byte ) i ) ) ; } assertEquals ( 23940 , mc . estimate ( hm ) ) ; }
ufoscout/jpattern | public void testVector ( ) { assertEquals ( 80 , mc . estimate ( new Vector < Object > ( 10 ) ) ) ; }
ufoscout/jpattern | public void testObject ( ) { assertEquals ( 8 , mc . estimate ( new Object ( ) ) ) ; }
ufoscout/jpattern | public void testInteger ( ) { assertEquals ( 16 , mc . estimate ( new Integer ( 1 ) ) ) ; }
ufoscout/jpattern | public void testCharArray ( ) { assertEquals ( 40 , mc . estimate ( " Hello ▁ World ! " . toCharArray ( ) ) ) ; }
ufoscout/jpattern | public void testByte ( ) { assertEquals ( 16 , mc . estimate ( new Byte ( ( byte ) 10 ) ) ) ; }
ufoscout/jpattern | public void testThreeBytes ( ) { assertEquals ( 16 , mc . estimate ( new ThreeBytes ( ) ) ) ; }
ufoscout/jpattern | public void testSixtyFourBooleans ( ) { assertEquals ( 72 , mc . estimate ( new SixtyFourBooleans ( ) ) ) ; }
ufoscout/jpattern | public void testThousandBooleansObjects ( ) { Boolean [ ] booleans = new Boolean [ 1000 ] ; for ( int i = 0 ; i < booleans . length ; i ++ ) booleans [ i ] = new Boolean ( true ) ; assertEquals ( 20016 , mc . estimate ( booleans ) ) ; }
ufoscout/jpattern | public void testThousandBytes ( ) { assertEquals ( 1016 , mc . estimate ( new byte [ 1000 ] ) ) ; }
ufoscout/jpattern | public void testEmptyArrayList ( ) { assertEquals ( 80 , mc . estimate ( new ArrayList < Object > ( ) ) ) ; }
ufoscout/jpattern | public void testFullArrayList ( ) { ArrayList < Object > arrayList = new ArrayList < Object > ( 10000 ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { arrayList . add ( new Object ( ) ) ; } assertEquals ( 120040 , mc . estimate ( arrayList ) ) ; }
ufoscout/jpattern | public void testFullLinkedList ( ) { LinkedList < Object > linkedList = new LinkedList < Object > ( ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { linkedList . add ( new Object ( ) ) ; } assertEquals ( 320048 , mc . estimate ( linkedList ) ) ; }
ufoscout/jpattern | public void testComplexClass ( ) { assertEquals ( 48 , mc . estimate ( new ComplexClass ( ) ) ) ; }
ufoscout/jpattern | public void testBooleanArray ( ) { assertEquals ( 27 , mc . estimate ( new boolean [ 11 ] ) ) ; }
ufoscout/jpattern | public void testShortArray ( ) { assertEquals ( 38 , mc . estimate ( new short [ 11 ] ) ) ; }
ufoscout/jpattern | public void testIntArray ( ) { assertEquals ( 60 , mc . estimate ( new int [ 11 ] ) ) ; }
ufoscout/jpattern | public void testFloatArray ( ) { assertEquals ( 60 , mc . estimate ( new float [ 11 ] ) ) ; }
ufoscout/jpattern | public void testLongArray ( ) { assertEquals ( 104 , mc . estimate ( new long [ 11 ] ) ) ; }
ufoscout/jpattern | public void testDoubleArray ( ) { assertEquals ( 104 , mc . estimate ( new double [ 11 ] ) ) ; }
eljefe6a/incubator-beam | ShardFn ( int numShards , RecordIdMethod recordIdMethod ) { this . numShards = numShards ; this . recordIdMethod = recordIdMethod ; }
eljefe6a/incubator-beam | @ ProcessElement public void processElement ( ProcessContext c ) throws Exception { elementCounter . inc ( ) ; PubsubMessage message = c . element ( ) ; byte [ ] elementBytes = message . getPayload ( ) ; Map < String , String > attributes = message . getAttributeMap ( ) ; long timestampMsSinceEpoch = c . timestamp ( ) . getMillis ( ) ; @ Nullable String recordId = null ; switch ( recordIdMethod ) { case NONE : break ; case DETERMINISTIC : recordId = Hashing . murmur3_128 ( ) . hashBytes ( elementBytes ) . toString ( ) ; break ; case RANDOM : recordId = UUID . randomUUID ( ) . toString ( ) ; break ; } c . output ( KV . of ( ThreadLocalRandom . current ( ) . nextInt ( numShards ) , new OutgoingMessage ( elementBytes , attributes , timestampMsSinceEpoch , recordId ) ) ) ; }
eljefe6a/incubator-beam | @ Override public void populateDisplayData ( Builder builder ) { super . populateDisplayData ( builder ) ; builder . add ( DisplayData . item ( " numShards " , numShards ) ) ; }
eljefe6a/incubator-beam | WriterFn ( PubsubClientFactory pubsubFactory , ValueProvider < TopicPath > topic , String timestampAttribute , String idAttribute , int publishBatchSize , int publishBatchBytes ) { this . pubsubFactory = pubsubFactory ; this . topic = topic ; this . timestampAttribute = timestampAttribute ; this . idAttribute = idAttribute ; this . publishBatchSize = publishBatchSize ; this . publishBatchBytes = publishBatchBytes ; }
eljefe6a/incubator-beam | private void publishBatch ( List < OutgoingMessage > messages , int bytes ) throws IOException { int n = pubsubClient . publish ( topic . get ( ) , messages ) ; checkState ( n == messages . size ( ) , " Attempted ▁ to ▁ publish ▁ % s ▁ messages ▁ but ▁ % s ▁ were ▁ successful " , messages . size ( ) , n ) ; batchCounter . inc ( ) ; elementCounter . inc ( messages . size ( ) ) ; byteCounter . inc ( bytes ) ; }
eljefe6a/incubator-beam | @ StartBundle public void startBundle ( StartBundleContext c ) throws Exception { checkState ( pubsubClient == null , " startBundle ▁ invoked ▁ without ▁ prior ▁ finishBundle " ) ; pubsubClient = pubsubFactory . newClient ( timestampAttribute , idAttribute , c . getPipelineOptions ( ) . as ( PubsubOptions . class ) ) ; }
eljefe6a/incubator-beam | @ ProcessElement public void processElement ( ProcessContext c ) throws Exception { List < OutgoingMessage > pubsubMessages = new ArrayList < > ( publishBatchSize ) ; int bytes = 0 ; for ( OutgoingMessage message : c . element ( ) . getValue ( ) ) { if ( ! pubsubMessages . isEmpty ( ) && bytes + message . elementBytes . length > publishBatchBytes ) { publishBatch ( pubsubMessages , bytes ) ; pubsubMessages . clear ( ) ; bytes = 0 ; } pubsubMessages . add ( message ) ; bytes += message . elementBytes . length ; } if ( ! pubsubMessages . isEmpty ( ) ) { publishBatch ( pubsubMessages , bytes ) ; } }
eljefe6a/incubator-beam | @ FinishBundle public void finishBundle ( ) throws Exception { pubsubClient . close ( ) ; pubsubClient = null ; }
eljefe6a/incubator-beam | @ Override public void populateDisplayData ( Builder builder ) { super . populateDisplayData ( builder ) ; builder . add ( DisplayData . item ( " topic " , topic ) ) ; builder . add ( DisplayData . item ( " transport " , pubsubFactory . getKind ( ) ) ) ; builder . addIfNotNull ( DisplayData . item ( " timestampAttribute " , timestampAttribute ) ) ; builder . addIfNotNull ( DisplayData . item ( " idAttribute " , idAttribute ) ) ; }
eljefe6a/incubator-beam | @ VisibleForTesting PubsubUnboundedSink ( PubsubClientFactory pubsubFactory , ValueProvider < TopicPath > topic , String timestampAttribute , String idAttribute , int numShards , int publishBatchSize , int publishBatchBytes , Duration maxLatency , RecordIdMethod recordIdMethod ) { this . pubsubFactory = pubsubFactory ; this . topic = topic ; this . timestampAttribute = timestampAttribute ; this . idAttribute = idAttribute ; this . numShards = numShards ; this . publishBatchSize = publishBatchSize ; this . publishBatchBytes = publishBatchBytes ; this . maxLatency = maxLatency ; this . recordIdMethod = idAttribute == null ? RecordIdMethod . NONE : recordIdMethod ; }
eljefe6a/incubator-beam | public PubsubUnboundedSink ( PubsubClientFactory pubsubFactory , ValueProvider < TopicPath > topic , String timestampAttribute , String idAttribute , int numShards ) { this ( pubsubFactory , topic , timestampAttribute , idAttribute , numShards , DEFAULT_PUBLISH_BATCH_SIZE , DEFAULT_PUBLISH_BATCH_BYTES , DEFAULT_MAX_LATENCY , RecordIdMethod . RANDOM ) ; }
eljefe6a/incubator-beam | public TopicPath getTopic ( ) { return topic . get ( ) ; }
eljefe6a/incubator-beam | public ValueProvider < TopicPath > getTopicProvider ( ) { return topic ; }
eljefe6a/incubator-beam | @ Nullable public String getTimestampAttribute ( ) { return timestampAttribute ; }
eljefe6a/incubator-beam | @ Nullable public String getIdAttribute ( ) { return idAttribute ; }
eljefe6a/incubator-beam | @ Override public PDone expand ( PCollection < PubsubMessage > input ) { input . apply ( " PubsubUnboundedSink . Window " , Window . < PubsubMessage > into ( new GlobalWindows ( ) ) . triggering ( Repeatedly . forever ( AfterFirst . of ( AfterPane . elementCountAtLeast ( publishBatchSize ) , AfterProcessingTime . pastFirstElementInPane ( ) . plusDelayOf ( maxLatency ) ) ) ) . discardingFiredPanes ( ) ) . apply ( " PubsubUnboundedSink . Shard " , ParDo . of ( new ShardFn ( numShards , recordIdMethod ) ) ) . setCoder ( KvCoder . of ( VarIntCoder . of ( ) , CODER ) ) . apply ( GroupByKey . < Integer , OutgoingMessage > create ( ) ) . apply ( " PubsubUnboundedSink . Writer " , ParDo . of ( new WriterFn ( pubsubFactory , topic , timestampAttribute , idAttribute , publishBatchSize , publishBatchBytes ) ) ) ; return PDone . in ( input . getPipeline ( ) ) ; }
Aliaksandr-Kastenka/pentaho-kettle | public IfNullDialog ( Shell parent , Object in , TransMeta tr , String sname ) { super ( parent , ( BaseStepMeta ) in , tr , sname ) ; input = ( IfNullMeta ) in ; }
Aliaksandr-Kastenka/pentaho-kettle | public String open ( ) { Shell parent = getParent ( ) ; Display display = parent . getDisplay ( ) ; shell = new Shell ( parent , SWT . DIALOG_TRIM | SWT . RESIZE | SWT . MIN | SWT . MAX ) ; props . setLook ( shell ) ; setShellImage ( shell , input ) ; lsMod = new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { input . setChanged ( ) ; } } ; changed = input . hasChanged ( ) ; oldlsMod = lsMod ; FormLayout formLayout = new FormLayout ( ) ; formLayout . marginWidth = Const . FORM_MARGIN ; formLayout . marginHeight = Const . FORM_MARGIN ; middle = props . getMiddlePct ( ) ; margin = Const . MARGIN ; FieldsRows = input . getFieldName ( ) . length ; shell . setLayout ( formLayout ) ; shell . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Shell . Title " ) ) ; wlStepname = new Label ( shell , SWT . RIGHT ) ; wlStepname . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Stepname . Label " ) ) ; props . setLook ( wlStepname ) ; fdlStepname = new FormData ( ) ; fdlStepname . left = new FormAttachment ( 0 , 0 ) ; fdlStepname . right = new FormAttachment ( middle , - margin ) ; fdlStepname . top = new FormAttachment ( 0 , margin ) ; wlStepname . setLayoutData ( fdlStepname ) ; wStepname = new Text ( shell , SWT . SINGLE | SWT . LEFT | SWT . BORDER ) ; wStepname . setText ( stepname ) ; props . setLook ( wStepname ) ; wStepname . addModifyListener ( lsMod ) ; fdStepname = new FormData ( ) ; fdStepname . left = new FormAttachment ( middle , 0 ) ; fdStepname . top = new FormAttachment ( 0 , margin ) ; fdStepname . right = new FormAttachment ( 100 , 0 ) ; wStepname . setLayoutData ( fdStepname ) ; wAllFields = new Group ( shell , SWT . SHADOW_NONE ) ; props . setLook ( wAllFields ) ; wAllFields . setText ( BaseMessages . getString ( PKG , " IfNullDialog . AllFields . Label " ) ) ; FormLayout AllFieldsgroupLayout = new FormLayout ( ) ; AllFieldsgroupLayout . marginWidth = 10 ; AllFieldsgroupLayout . marginHeight = 10 ; wAllFields . setLayout ( AllFieldsgroupLayout ) ; wlReplaceByValue = new Label ( wAllFields , SWT . RIGHT ) ; wlReplaceByValue . setText ( BaseMessages . getString ( PKG , " IfNullDialog . ReplaceByValue . Label " ) ) ; props . setLook ( wlReplaceByValue ) ; fdlReplaceByValue = new FormData ( ) ; fdlReplaceByValue . left = new FormAttachment ( 0 , 0 ) ; fdlReplaceByValue . right = new FormAttachment ( middle , - margin ) ; fdlReplaceByValue . top = new FormAttachment ( wStepname , margin * 2 ) ; wlReplaceByValue . setLayoutData ( fdlReplaceByValue ) ; wReplaceByValue = new TextVar ( transMeta , wAllFields , SWT . SINGLE | SWT . LEFT | SWT . BORDER ) ; wReplaceByValue . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . ReplaceByValue . Tooltip " ) ) ; props . setLook ( wReplaceByValue ) ; fdReplaceByValue = new FormData ( ) ; fdReplaceByValue . left = new FormAttachment ( middle , 0 ) ; fdReplaceByValue . top = new FormAttachment ( wStepname , 2 * margin ) ; fdReplaceByValue . right = new FormAttachment ( 100 , 0 ) ; wReplaceByValue . setLayoutData ( fdReplaceByValue ) ; wlSetEmptyStringAll = new Label ( wAllFields , SWT . RIGHT ) ; wlSetEmptyStringAll . setText ( BaseMessages . getString ( PKG , " IfNullDialog . SetEmptyStringAll . Label " ) ) ; props . setLook ( wlSetEmptyStringAll ) ; fdlSetEmptyStringAll = new FormData ( ) ; fdlSetEmptyStringAll . left = new FormAttachment ( 0 , 0 ) ; fdlSetEmptyStringAll . top = new FormAttachment ( wReplaceByValue , margin ) ; fdlSetEmptyStringAll . right = new FormAttachment ( middle , - margin ) ; wlSetEmptyStringAll . setLayoutData ( fdlSetEmptyStringAll ) ; wSetEmptyStringAll = new Button ( wAllFields , SWT . CHECK ) ; wSetEmptyStringAll . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . SetEmptyStringAll . Tooltip " ) ) ; props . setLook ( wSetEmptyStringAll ) ; fdSetEmptyStringAll = new FormData ( ) ; fdSetEmptyStringAll . left = new FormAttachment ( middle , 0 ) ; fdSetEmptyStringAll . top = new FormAttachment ( wReplaceByValue , margin ) ; fdSetEmptyStringAll . right = new FormAttachment ( 100 , 0 ) ; wSetEmptyStringAll . setLayoutData ( fdSetEmptyStringAll ) ; wSetEmptyStringAll . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { input . setChanged ( ) ; enableSetEmptyStringAll ( ) ; } } ) ; wlMask = new Label ( wAllFields , SWT . RIGHT ) ; wlMask . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Mask . Label " ) ) ; props . setLook ( wlMask ) ; fdlMask = new FormData ( ) ; fdlMask . left = new FormAttachment ( 0 , 0 ) ; fdlMask . top = new FormAttachment ( wSetEmptyStringAll , margin ) ; fdlMask . right = new FormAttachment ( middle , - margin ) ; wlMask . setLayoutData ( fdlMask ) ; wMask = new CCombo ( wAllFields , SWT . BORDER | SWT . READ_ONLY ) ; wMask . setEditable ( true ) ; wMask . setItems ( Const . getDateFormats ( ) ) ; props . setLook ( wMask ) ; wMask . addModifyListener ( lsMod ) ; fdMask = new FormData ( ) ; fdMask . left = new FormAttachment ( middle , 0 ) ; fdMask . top = new FormAttachment ( wSetEmptyStringAll , margin ) ; fdMask . right = new FormAttachment ( 100 , 0 ) ; wMask . setLayoutData ( fdMask ) ; fdAllFields = new FormData ( ) ; fdAllFields . left = new FormAttachment ( 0 , margin ) ; fdAllFields . top = new FormAttachment ( wStepname , margin ) ; fdAllFields . right = new FormAttachment ( 100 , - margin ) ; wAllFields . setLayoutData ( fdAllFields ) ; wlSelectFields = new Label ( shell , SWT . RIGHT ) ; wlSelectFields . setText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectFields . Label " ) ) ; props . setLook ( wlSelectFields ) ; fdlSelectFields = new FormData ( ) ; fdlSelectFields . left = new FormAttachment ( 0 , 0 ) ; fdlSelectFields . top = new FormAttachment ( wAllFields , margin ) ; fdlSelectFields . right = new FormAttachment ( middle , - margin ) ; wlSelectFields . setLayoutData ( fdlSelectFields ) ; wSelectFields = new Button ( shell , SWT . CHECK ) ; wSelectFields . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectFields . Tooltip " ) ) ; props . setLook ( wSelectFields ) ; fdSelectFields = new FormData ( ) ; fdSelectFields . left = new FormAttachment ( middle , 0 ) ; fdSelectFields . top = new FormAttachment ( wAllFields , margin ) ; fdSelectFields . right = new FormAttachment ( 100 , 0 ) ; wSelectFields . setLayoutData ( fdSelectFields ) ; wlSelectValuesType = new Label ( shell , SWT . RIGHT ) ; wlSelectValuesType . setText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectValuesType . Label " ) ) ; props . setLook ( wlSelectValuesType ) ; fdlSelectValuesType = new FormData ( ) ; fdlSelectValuesType . left = new FormAttachment ( 0 , 0 ) ; fdlSelectValuesType . top = new FormAttachment ( wSelectFields , margin ) ; fdlSelectValuesType . right = new FormAttachment ( middle , - margin ) ; wlSelectValuesType . setLayoutData ( fdlSelectValuesType ) ; wSelectValuesType = new Button ( shell , SWT . CHECK ) ; wSelectValuesType . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectValuesType . Tooltip " ) ) ; props . setLook ( wSelectValuesType ) ; fdSelectValuesType = new FormData ( ) ; fdSelectValuesType . left = new FormAttachment ( middle , 0 ) ; fdSelectValuesType . top = new FormAttachment ( wSelectFields , margin ) ; fdSelectValuesType . right = new FormAttachment ( 100 , 0 ) ; wSelectValuesType . setLayoutData ( fdSelectValuesType ) ; wlValueTypes = new Label ( shell , SWT . NONE ) ; wlValueTypes . setText ( BaseMessages . getString ( PKG , " IfNullDialog . ValueTypes . Label " ) ) ; props . setLook ( wlValueTypes ) ; fdlValueTypes = new FormData ( ) ; fdlValueTypes . left = new FormAttachment ( 0 , 0 ) ; fdlValueTypes . top = new FormAttachment ( wSelectValuesType , margin ) ; wlValueTypes . setLayoutData ( fdlValueTypes ) ; int ValueTypesRows = input . getFieldName ( ) . length ; int FieldsCols = 4 ; ColumnInfo [ ] colval = new ColumnInfo [ FieldsCols ] ; colval [ 0 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . ValueType . Column " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , ValueMetaInterface . typeCodes ) ; colval [ 1 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . Column " ) , ColumnInfo . COLUMN_TYPE_TEXT , false ) ; colval [ 2 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . ConversionMask " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , Const . getDateFormats ( ) ) ; colval [ 3 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . SetEmptyString " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , new String [ ] { BaseMessages . getString ( PKG , " System . Combo . Yes " ) , BaseMessages . getString ( PKG , " System . Combo . No " ) } ) ; colval [ 1 ] . setUsingVariables ( true ) ; wValueTypes = new TableView ( transMeta , shell , SWT . BORDER | SWT . FULL_SELECTION | SWT . MULTI , colval , ValueTypesRows , oldlsMod , props ) ; fdValueTypes = new FormData ( ) ; fdValueTypes . left = new FormAttachment ( 0 , 0 ) ; fdValueTypes . top = new FormAttachment ( wlValueTypes , margin ) ; fdValueTypes . right = new FormAttachment ( 100 , 0 ) ; fdValueTypes . bottom = new FormAttachment ( wlValueTypes , 190 ) ; wValueTypes . setLayoutData ( fdValueTypes ) ; getFirstData ( ) ; wOK = new Button ( shell , SWT . PUSH ) ; wOK . setText ( BaseMessages . getString ( PKG , " System . Button . OK " ) ) ; wGet = new Button ( shell , SWT . PUSH ) ; wGet . setText ( BaseMessages . getString ( PKG , " System . Button . GetFields " ) ) ; wCancel = new Button ( shell , SWT . PUSH ) ; wCancel . setText ( BaseMessages . getString ( PKG , " System . Button . Cancel " ) ) ; setButtonPositions ( new Button [ ] { wOK , wGet , wCancel } , margin , null ) ; addFields ( ) ; wSelectValuesType . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { activeSelectValuesType ( ) ; input . setChanged ( ) ; } } ) ; wSelectFields . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { activeSelectFields ( ) ; input . setChanged ( ) ; } } ) ; lsCancel = new Listener ( ) { public void handleEvent ( Event e ) { cancel ( ) ; } } ; lsGet = new Listener ( ) { public void handleEvent ( Event e ) { get ( ) ; } } ; lsOK = new Listener ( ) { public void handleEvent ( Event e ) { ok ( ) ; } } ; wCancel . addListener ( SWT . Selection , lsCancel ) ; wOK . addListener ( SWT . Selection , lsOK ) ; wGet . addListener ( SWT . Selection , lsGet ) ; lsDef = new SelectionAdapter ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { ok ( ) ; } } ; wStepname . addSelectionListener ( lsDef ) ; shell . addShellListener ( new ShellAdapter ( ) { public void shellClosed ( ShellEvent e ) { cancel ( ) ; } } ) ; setSize ( ) ; getData ( ) ; enableSetEmptyStringAll ( ) ; activeSelectFields ( ) ; activeSelectValuesType ( ) ; input . setChanged ( changed ) ; shell . open ( ) ; while ( ! shell . isDisposed ( ) ) { if ( ! display . readAndDispatch ( ) ) { display . sleep ( ) ; } } return stepname ; }
Aliaksandr-Kastenka/pentaho-kettle | private void addFields ( ) { int FieldsCols = 4 ; ColumnInfo [ ] colinf = new ColumnInfo [ FieldsCols ] ; wlFields = new Label ( shell , SWT . NONE ) ; wlFields . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Fields . Label " ) ) ; props . setLook ( wlFields ) ; fdlFields = new FormData ( ) ; fdlFields . left = new FormAttachment ( 0 , 0 ) ; fdlFields . top = new FormAttachment ( wValueTypes , margin ) ; wlFields . setLayoutData ( fdlFields ) ; colinf [ 0 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Fieldname . Column " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , new String [ ] { } , false ) ; colinf [ 1 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . Column " ) , ColumnInfo . COLUMN_TYPE_TEXT , false ) ; colinf [ 2 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . ConversionMask " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , Const . getDateFormats ( ) ) ; colinf [ 1 ] . setUsingVariables ( true ) ; colinf [ 3 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . SetEmptyString " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , new String [ ] { BaseMessages . getString ( PKG , " System . Combo . Yes " ) , BaseMessages . getString ( PKG , " System . Combo . No " ) } ) ; wFields = new TableView ( transMeta , shell , SWT . BORDER | SWT . FULL_SELECTION | SWT . MULTI , colinf , FieldsRows , oldlsMod , props ) ; fdFields = new FormData ( ) ; fdFields . left = new FormAttachment ( 0 , 0 ) ; fdFields . top = new FormAttachment ( wlFields , margin ) ; fdFields . right = new FormAttachment ( 100 , 0 ) ; fdFields . bottom = new FormAttachment ( wOK , - 2 * margin ) ; wFields . setLayoutData ( fdFields ) ; setComboValues ( ) ; fieldColumns . add ( colinf [ 0 ] ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void activeSelectFields ( ) { if ( wSelectFields . getSelection ( ) ) { wSelectValuesType . setSelection ( false ) ; wlValueTypes . setEnabled ( false ) ; wValueTypes . setEnabled ( false ) ; } activeFields ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void activeSelectValuesType ( ) { if ( wSelectValuesType . getSelection ( ) ) { wSelectFields . setSelection ( false ) ; wFields . setEnabled ( false ) ; wlFields . setEnabled ( false ) ; } activeFields ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void activeFields ( ) { wlFields . setEnabled ( wSelectFields . getSelection ( ) ) ; wFields . setEnabled ( wSelectFields . getSelection ( ) ) ; wGet . setEnabled ( wSelectFields . getSelection ( ) ) ; wlValueTypes . setEnabled ( wSelectValuesType . getSelection ( ) ) ; wValueTypes . setEnabled ( wSelectValuesType . getSelection ( ) ) ; wlReplaceByValue . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wReplaceByValue . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wlMask . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wMask . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wlSetEmptyStringAll . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wSetEmptyStringAll . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void get ( ) { try { RowMetaInterface r = transMeta . getPrevStepFields ( stepname ) ; if ( r != null ) { TableItemInsertListener insertListener = new TableItemInsertListener ( ) { public boolean tableItemInserted ( TableItem tableItem , ValueMetaInterface v ) { return true ; } } ; BaseStepDialog . getFieldsFromPrevious ( r , wFields , 1 , new int [ ] { 1 } , new int [ ] { } , - 1 , - 1 , insertListener ) ; } } catch ( KettleException ke ) { new ErrorDialog ( shell , BaseMessages . getString ( PKG , " System . Dialog . GetFieldsFailed . Title " ) , BaseMessages . getString ( PKG , " System . Dialog . GetFieldsFailed . Message " ) , ke ) ; } }
Aliaksandr-Kastenka/pentaho-kettle | private void setComboValues ( ) { Runnable fieldLoader = new Runnable ( ) { public void run ( ) { try { prevFields = transMeta . getPrevStepFields ( stepname ) ; } catch ( KettleException e ) { String msg = BaseMessages . getString ( PKG , " IfNullDialog . DoMapping . UnableToFindInput " ) ; logError ( msg ) ; } String [ ] prevStepFieldNames = prevFields . getFieldNames ( ) ; if ( prevStepFieldNames != null ) { Arrays . sort ( prevStepFieldNames ) ; for ( int i = 0 ; i < fieldColumns . size ( ) ; i ++ ) { ColumnInfo colInfo = fieldColumns . get ( i ) ; if ( colInfo != null ) { colInfo . setComboValues ( prevStepFieldNames ) ; } } } } } ; new Thread ( fieldLoader ) . start ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | public void getFirstData ( ) { wSelectFields . setSelection ( input . isSelectFields ( ) ) ; wSelectValuesType . setSelection ( input . isSelectValuesType ( ) ) ; }
Aliaksandr-Kastenka/pentaho-kettle | public void getData ( ) { if ( input . getReplaceAllByValue ( ) != null ) { wReplaceByValue . setText ( input . getReplaceAllByValue ( ) ) ; } if ( input . getReplaceAllMask ( ) != null ) { wMask . setText ( input . getReplaceAllMask ( ) ) ; } wSetEmptyStringAll . setSelection ( input . isSetEmptyStringAll ( ) ) ; wSelectFields . setSelection ( input . isSelectFields ( ) ) ; wSelectValuesType . setSelection ( input . isSelectValuesType ( ) ) ; Table table = wValueTypes . table ; if ( input . getTypeName ( ) . length > 0 ) { table . removeAll ( ) ; } for ( int i = 0 ; i < input . getTypeName ( ) . length ; i ++ ) { TableItem ti = new TableItem ( table , SWT . NONE ) ; ti . setText ( 0 , " " + ( i + 1 ) ) ; if ( input . getTypeName ( ) [ i ] != null ) { ti . setText ( 1 , input . getTypeName ( ) [ i ] ) ; } if ( input . getTypeReplaceValue ( ) [ i ] != null ) { ti . setText ( 2 , input . getTypeReplaceValue ( ) [ i ] ) ; } if ( input . getTypeReplaceMask ( ) [ i ] != null ) { ti . setText ( 3 , input . getTypeReplaceMask ( ) [ i ] ) ; } ti . setText ( 4 , input . isSetTypeEmptyString ( ) [ i ] ? BaseMessages . getString ( PKG , " System . Combo . Yes " ) : BaseMessages . getString ( PKG , " System . Combo . No " ) ) ; } wValueTypes . setRowNums ( ) ; wValueTypes . removeEmptyRows ( ) ; wValueTypes . optWidth ( true ) ; table = wFields . table ; if ( input . getFieldName ( ) . length > 0 ) { table . removeAll ( ) ; } for ( int i = 0 ; i < input . getFieldName ( ) . length ; i ++ ) { TableItem ti = new TableItem ( table , SWT . NONE ) ; ti . setText ( 0 , " " + ( i + 1 ) ) ; if ( input . getFieldName ( ) [ i ] != null ) { ti . setText ( 1 , input . getFieldName ( ) [ i ] ) ; } if ( input . getReplaceValue ( ) [ i ] != null ) { ti . setText ( 2 , input . getReplaceValue ( ) [ i ] ) ; } if ( input . getReplaceMask ( ) [ i ] != null ) { ti . setText ( 3 , input . getReplaceMask ( ) [ i ] ) ; } ti . setText ( 4 , input . isSetEmptyString ( ) [ i ] ? BaseMessages . getString ( PKG , " System . Combo . Yes " ) : BaseMessages . getString ( PKG , " System . Combo . No " ) ) ; } wFields . setRowNums ( ) ; wValueTypes . removeEmptyRows ( ) ; wFields . optWidth ( true ) ; wStepname . selectAll ( ) ; wStepname . setFocus ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void cancel ( ) { stepname = null ; input . setChanged ( changed ) ; dispose ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void enableSetEmptyStringAll ( ) { wMask . setText ( " " ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void ok ( ) { if ( Const . isEmpty ( wStepname . getText ( ) ) ) { return ; } stepname = wStepname . getText ( ) ; input . setEmptyStringAll ( wSetEmptyStringAll . getSelection ( ) ) ; if ( wSetEmptyStringAll . getSelection ( ) ) { input . setReplaceAllByValue ( " " ) ; input . setReplaceAllMask ( " " ) ; } else { input . setReplaceAllByValue ( wReplaceByValue . getText ( ) ) ; input . setReplaceAllMask ( wMask . getText ( ) ) ; } input . setSelectFields ( wSelectFields . getSelection ( ) ) ; input . setSelectValuesType ( wSelectValuesType . getSelection ( ) ) ; int nrtypes = wValueTypes . nrNonEmpty ( ) ; int nrfields = wFields . nrNonEmpty ( ) ; input . allocate ( nrtypes , nrfields ) ; for ( int i = 0 ; i < nrtypes ; i ++ ) { TableItem ti = wValueTypes . getNonEmpty ( i ) ; input . getTypeName ( ) [ i ] = ti . getText ( 1 ) ; input . isSetTypeEmptyString ( ) [ i ] = BaseMessages . getString ( PKG , " System . Combo . Yes " ) . equalsIgnoreCase ( ti . getText ( 4 ) ) ; if ( input . isSetTypeEmptyString ( ) [ i ] ) { input . getTypeReplaceValue ( ) [ i ] = " " ; input . getTypeReplaceMask ( ) [ i ] = " " ; } else { input . getTypeReplaceValue ( ) [ i ] = ti . getText ( 2 ) ; input . getTypeReplaceMask ( ) [ i ] = ti . getText ( 3 ) ; } } for ( int i = 0 ; i < nrfields ; i ++ ) { TableItem ti = wFields . getNonEmpty ( i ) ; input . getFieldName ( ) [ i ] = ti . getText ( 1 ) ; input . isSetEmptyString ( ) [ i ] = BaseMessages . getString ( PKG , " System . Combo . Yes " ) . equalsIgnoreCase ( ti . getText ( 4 ) ) ; if ( input . isSetEmptyString ( ) [ i ] ) { input . getReplaceValue ( ) [ i ] = " " ; input . getReplaceMask ( ) [ i ] = " " ; } else { input . getReplaceValue ( ) [ i ] = ti . getText ( 2 ) ; input . getReplaceMask ( ) [ i ] = ti . getText ( 3 ) ; } } dispose ( ) ; }
loafer/spring4-tutorials | public ResponseResult ( boolean success ) { this . success = success ; }
loafer/spring4-tutorials | public ResponseResult ( boolean success , String url , Object message ) { this . success = success ; this . url = url ; this . message = message ; }
loafer/spring4-tutorials | public boolean isSuccess ( ) { return success ; }
loafer/spring4-tutorials | public String getUrl ( ) { return url ; }
loafer/spring4-tutorials | public Object getMessage ( ) { return message ; }
llenterak/eulers | private int sumDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += factorials [ n % 10 ] ; n = n / 10 ; } return sum ; }
llenterak/eulers | private long getDigitFactorials ( int limit ) { long res = 0l ; for ( int i = 3 ; i < limit ; i ++ ) { if ( sumDigits ( i ) == i ) res += i ; } return res ; }
llenterak/eulers | @ Override public String getResult ( ) { return String . format ( " % d " , getDigitFactorials ( 1000000 ) ) ; }
user404d/CS6601-Project | public OrOperation ( ) { super ( NAME ) ; }
user404d/CS6601-Project | public Circuit create_circuit ( State [ ] operands ) throws Exception { if ( operands . length == 1 ) { return new OR_L_1 ( operands [ 0 ] . getWidth ( ) ) ; } else { return new OR_2L_L ( operands [ 0 ] . getWidth ( ) ) ; } }
user404d/CS6601-Project | public int circuit_id ( State [ ] operands ) { int id = operands [ 0 ] . getWidth ( ) ; if ( operands . length == 1 ) return - id ; else return id ; }
user404d/CS6601-Project | public State execute ( State [ ] inputs , Circuit or ) throws Exception { if ( inputs . length == 1 ) { return or . startExecuting ( inputs [ 0 ] ) ; } else { return binaryOperation ( or , inputs ) ; } }
user404d/CS6601-Project | public int validate ( Variable [ ] operands ) throws CircuitDescriptionException { if ( operands . length == 1 ) { int o = operands [ 0 ] . validate ( ) ; if ( o < 2 ) { throw createException ( " Unary ▁ or ▁ operation ▁ requires ▁ at ▁ least ▁ two ▁ bits " ) ; } return 1 ; } else { binaryOperation ( operands ) ; return operands [ 0 ] . validate ( ) ; } }
n4cer/estockkarte | public Result index ( ) { List < Colony > colonies = Colony . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . order ( ) . asc ( " id " ) . findList ( ) ; return ok ( index . render ( colonies ) ) ; }
n4cer/estockkarte | public Result add ( ) { List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; return ok ( add . render ( formFactory . form ( Colony . class ) , hives , QueenColor . getColors ( ) , races , stands ) ) ; }
n4cer/estockkarte | public Result create ( ) { Form < Colony > form = formFactory . form ( Colony . class ) . bindFromRequest ( ) ; List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; if ( form . hasErrors ( ) ) { return badRequest ( add . render ( form , hives , QueenColor . getColors ( ) , races , stands ) ) ; } Colony colony = form . get ( ) ; colony . user = Util . getUser ( ) ; colony . shortUrl = Util . rndUrl ( 10 ) ; colony . save ( ) ; return redirect ( routes . Colonies . index ( ) ) ; }
n4cer/estockkarte | public Result edit ( Long id ) { Colony colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; return ok ( edit . render ( colony , formFactory . form ( Colony . class ) . fill ( colony ) , hives , QueenColor . getColors ( ) , races , stands ) ) ; }
n4cer/estockkarte | public Result update ( Long id ) { Colony old_colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( old_colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } Form < Colony > form = formFactory . form ( Colony . class ) . bindFromRequest ( ) ; List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; if ( form . hasErrors ( ) ) { return badRequest ( edit . render ( old_colony , form , hives , QueenColor . getColors ( ) , races , stands ) ) ; } Colony colony = form . get ( ) ; colony . id = old_colony . id ; colony . user = Util . getUser ( ) ; colony . update ( ) ; return redirect ( routes . Colonies . index ( ) ) ; }
n4cer/estockkarte | public Result delete ( Long id ) { Colony colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } colony . delete ( ) ; return redirect ( routes . Colonies . index ( ) ) ; }
n4cer/estockkarte | public Result showQRCode ( String shortUrl ) { File qrcode = QRCode . from ( " https : // www . estockkarte . de / d / " + shortUrl ) . file ( ) ; return ok ( qrcode ) . as ( " image / png " ) ; }
n4cer/estockkarte | public Result inscription ( Long id ) { Colony colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } return ok ( inscription . render ( colony ) ) ; }
MikePfaff/acs-aem-commons | @ Before public void setupSession ( ) { when ( workflowSession . getSession ( ) ) . thenReturn ( session ) ; when ( jcrFactory . getResourceResolver ( session ) ) . thenReturn ( resourceResolver ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_null_rendition_arg_is_noop ( ) throws Exception { WorkItem workItem = mock ( WorkItem . class ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; process . execute ( workItem , workflowSession , metaData ) ; verifyZeroInteractions ( harness ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_blank_rendition_arg_is_noop ( ) throws Exception { WorkItem workItem = mock ( WorkItem . class ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; metaData . put ( " PROCESS _ ARGS " , " " ) ; process . execute ( workItem , workflowSession , metaData ) ; verifyZeroInteractions ( harness ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_rendition_arg_getting_no_rendition_is_noop ( ) throws Exception { String path = " / content / dam / some / path . ext " ; WorkItem workItem = mock ( WorkItem . class ) ; WorkflowData data = mock ( WorkflowData . class ) ; when ( workItem . getWorkflowData ( ) ) . thenReturn ( data ) ; when ( data . getPayloadType ( ) ) . thenReturn ( AbstractAssetWorkflowProcess . TYPE_JCR_PATH ) ; when ( data . getPayload ( ) ) . thenReturn ( path ) ; Resource resource = mock ( Resource . class ) ; Asset asset = mock ( Asset . class ) ; when ( resource . adaptTo ( Asset . class ) ) . thenReturn ( asset ) ; when ( resource . getResourceType ( ) ) . thenReturn ( DamConstants . NT_DAM_ASSET ) ; when ( resourceResolver . getResource ( path ) ) . thenReturn ( resource ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; metaData . put ( " PROCESS _ ARGS " , " renditionName : test " ) ; process . execute ( workItem , workflowSession , metaData ) ; verifyZeroInteractions ( harness ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_rendition_arg_getting_real_rendition ( ) throws Exception { String path = " / content / dam / some / path . ext " ; WorkItem workItem = mock ( WorkItem . class ) ; WorkflowData data = mock ( WorkflowData . class ) ; when ( workItem . getWorkflowData ( ) ) . thenReturn ( data ) ; when ( data . getPayloadType ( ) ) . thenReturn ( AbstractAssetWorkflowProcess . TYPE_JCR_PATH ) ; when ( data . getPayload ( ) ) . thenReturn ( path ) ; Resource resource = mock ( Resource . class ) ; Asset asset = mock ( Asset . class ) ; Rendition rendition = mock ( Rendition . class ) ; when ( resource . adaptTo ( Asset . class ) ) . thenReturn ( asset ) ; when ( resource . getResourceType ( ) ) . thenReturn ( DamConstants . NT_DAM_ASSET ) ; when ( resourceResolver . getResource ( path ) ) . thenReturn ( resource ) ; when ( asset . getRendition ( isA ( RenditionPicker . class ) ) ) . thenReturn ( rendition ) ; when ( rendition . getStream ( ) ) . then ( new Answer < InputStream > ( ) { @ Override public InputStream answer ( InvocationOnMock invocation ) throws Throwable { return getClass ( ) . getResourceAsStream ( " / img / test . png " ) ; } } ) ; when ( harness . processLayer ( any ( Layer . class ) , eq ( rendition ) , eq ( workflowSession ) , any ( String [ ] . class ) ) ) . thenAnswer ( new Answer < Layer > ( ) { @ Override public Layer answer ( InvocationOnMock invocation ) throws Throwable { return ( Layer ) invocation . getArguments ( ) [ 0 ] ; } } ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; metaData . put ( " PROCESS _ ARGS " , " renditionName : test " ) ; process . execute ( workItem , workflowSession , metaData ) ; verify ( harness , times ( 1 ) ) . processLayer ( any ( Layer . class ) , eq ( rendition ) , eq ( workflowSession ) , any ( String [ ] . class ) ) ; verify ( harness , times ( 1 ) ) . saveImage ( eq ( asset ) , eq ( rendition ) , any ( Layer . class ) , eq ( " image / png " ) , eq ( 0.6 ) ) ; }
branches-cc/camel-cookbook-examples | @ Override public RouteBuilder createRouteBuilder ( ) { return new AggregateCompletionTimeoutRouteBuilder ( ) ; }
branches-cc/camel-cookbook-examples | @ Test public void testAggregation ( ) throws InterruptedException { MockEndpoint mockOut = getMockEndpoint ( " mock : out " ) ; mockOut . setExpectedMessageCount ( 2 ) ; template . sendBodyAndHeader ( " direct : in " , " One " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Two " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Three " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Four " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Five " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Six " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Seven " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Eight " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Nine " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Ten " , " group " , " even " ) ; assertMockEndpointsSatisfied ( ) ; List < Exchange > receivedExchanges = mockOut . getReceivedExchanges ( ) ; Set < String > odd = receivedExchanges . get ( 0 ) . getIn ( ) . getBody ( Set . class ) ; assertTrue ( odd . containsAll ( Arrays . asList ( " One " , " Three " , " Five " , " Seven " , " Nine " ) ) ) ; Set < String > even = receivedExchanges . get ( 1 ) . getIn ( ) . getBody ( Set . class ) ; assertTrue ( even . containsAll ( Arrays . asList ( " Two " , " Four " , " Six " , " Eight " , " Ten " ) ) ) ; }
OpenNTF/Nagios4DominoIntegration | if ( isAccessAllowed ( req . getRemoteAddr ( ) , NotesIniFactory . getNagiosCaller ( ) ) ) { strResult = ActionRegistry . getInstance ( ) . getServletAction ( strAction ) . buildResponse ( req . getParameterMap ( ) , sesServer ) ; }
OpenNTF/Nagios4DominoIntegration | catch ( Exception e ) { ErrorPageBuilder . getInstance ( ) . processError ( resp , e . getMessage ( ) , e ) ; }
OpenNTF/Nagios4DominoIntegration | if ( sesServer != null ) { sesServer . recycle ( ) ; }
OpenNTF/Nagios4DominoIntegration | catch ( Exception e ) { e . printStackTrace ( ) ; }
OpenNTF/Nagios4DominoIntegration | private boolean isAccessAllowed ( String strCallerIP , String strNotesINIIP ) { try { InetAddress inCurrent = InetAddress . getByName ( strCallerIP ) ; if ( inCurrent . isAnyLocalAddress ( ) || inCurrent . isLoopbackAddress ( ) ) { return true ; } if ( NetworkInterface . getByInetAddress ( inCurrent ) != null ) { return true ; } if ( strNotesINIIP != null && ! " " . equals ( strNotesINIIP ) ) { List < String > lstAddr = Arrays . asList ( strNotesINIIP . split ( " ; " ) ) ; for ( String strAdrCheck : lstAddr ) { if ( strAdrCheck . equals ( strCallerIP ) ) { return true ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; }
FHannes/intellij-community | public KeyAwareInspectionViewAction ( String name ) { super ( name ) ; }
FHannes/intellij-community | @ Override protected boolean isEnabled ( @ NotNull InspectionResultsView view , AnActionEvent e ) { final InspectionToolWrapper wrapper = view . getTree ( ) . getSelectedToolWrapper ( true ) ; return wrapper != null && HighlightDisplayKey . find ( wrapper . getShortName ( ) ) != null ; }
FHannes/intellij-community | @ Override public void actionPerformed ( AnActionEvent e ) { final InspectionResultsView view = getView ( e ) ; final HighlightDisplayKey key = HighlightDisplayKey . find ( view . getTree ( ) . getSelectedToolWrapper ( true ) . getShortName ( ) ) ; actionPerformed ( view , key ) ; }
FHannes/intellij-community | public DisableInspection ( ) { super ( DisableInspectionToolAction . NAME ) ; }
FHannes/intellij-community | @ Override protected boolean isEnabled ( @ NotNull InspectionResultsView view , AnActionEvent e ) { final boolean enabled = super . isEnabled ( view , e ) ; if ( ! enabled ) return false ; final HighlightDisplayKey key = HighlightDisplayKey . find ( view . getTree ( ) . getSelectedToolWrapper ( true ) . getShortName ( ) ) ; final InspectionProfile profile = InspectionProjectProfileManager . getInstance ( view . getProject ( ) ) . getCurrentProfile ( ) ; return profile . isToolEnabled ( key ) ; }
FHannes/intellij-community | @ Override protected void actionPerformed ( @ NotNull InspectionResultsView view , @ NotNull HighlightDisplayKey key ) { if ( view . isSingleInspectionRun ( ) ) { view . getCurrentProfile ( ) . modifyProfile ( it -> it . setToolEnabled ( key . toString ( ) , false ) ) ; view . updateCurrentProfile ( ) ; } else { final RefEntity [ ] selectedElements = view . getTree ( ) . getSelectedElements ( ) ; final Set < PsiElement > files = new HashSet < > ( ) ; for ( RefEntity selectedElement : selectedElements ) { if ( selectedElement instanceof RefElement ) { files . add ( ( ( RefElement ) selectedElement ) . getElement ( ) ) ; } } InspectionProfileModifiableModelKt . modifyAndCommitProjectProfile ( view . getProject ( ) , it -> { for ( PsiElement element : files ) { it . disableTool ( key . toString ( ) , element ) ; } } ) ; } }
FHannes/intellij-community | public RunInspectionOn ( ) { super ( InspectionsBundle . message ( " run . inspection . on . file . intention . text " ) ) ; }
FHannes/intellij-community | @ Override protected boolean isEnabled ( @ NotNull InspectionResultsView view , AnActionEvent e ) { return super . isEnabled ( view , e ) && getPsiElement ( view ) != null ; }
FHannes/intellij-community | @ Override protected void actionPerformed ( @ NotNull InspectionResultsView view , @ NotNull HighlightDisplayKey key ) { Set < PsiFile > files = new THashSet < > ( ) ; for ( RefEntity entity : view . getTree ( ) . getSelectedElements ( ) ) { if ( entity instanceof RefElement && entity . isValid ( ) ) { final PsiElement element = ( ( RefElement ) entity ) . getElement ( ) ; final PsiFile file = element . getContainingFile ( ) ; files . add ( file ) ; } } boolean useModule = true ; Module module = null ; for ( PsiFile file : files ) { final Module currentFileModule = ModuleUtilCore . findModuleForPsiElement ( file ) ; if ( currentFileModule != null ) { if ( module == null ) { module = currentFileModule ; } else if ( currentFileModule != module ) { useModule = false ; break ; } } else { useModule = false ; break ; } } final PsiElement context ; final AnalysisScope scope ; switch ( files . size ( ) ) { case 0 : context = null ; scope = view . getScope ( ) ; break ; case 1 : final PsiFile theFile = ContainerUtil . getFirstItem ( files ) ; LOG . assertTrue ( theFile != null ) ; context = theFile ; scope = new AnalysisScope ( theFile ) ; break ; default : context = null ; scope = new AnalysisScope ( view . getProject ( ) , files . stream ( ) . map ( PsiFile :: getVirtualFile ) . collect ( Collectors . toList ( ) ) ) ; } RunInspectionIntention . selectScopeAndRunInspection ( key . toString ( ) , scope , useModule ? module : null , context , view . getProject ( ) ) ; }
fvasquezjatar/fermat-unused | public AssetIssuerIdentityDatabaseFactory ( PluginDatabaseSystem pluginDatabaseSystem ) { this . pluginDatabaseSystem = pluginDatabaseSystem ; }
fvasquezjatar/fermat-unused | public Database createDatabase ( UUID pluginId ) throws CantCreateDatabaseException { Database database ; try { database = this . pluginDatabaseSystem . createDatabase ( pluginId , AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_DB_NAME ) ; DatabaseTableFactory table ; DatabaseFactory databaseFactory = database . getDatabaseFactory ( ) ; table = databaseFactory . newTableFactory ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_TABLE_NAME ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_PUBLIC_KEY_COLUMN_NAME , DatabaseDataType . STRING , 130 , true ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_PRIVATE_KEY_COLUMN_NAME , DatabaseDataType . STRING , 130 , false ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_ALIAS_COLUMN_NAME , DatabaseDataType . STRING , 36 , false ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_STATUS_COLUMN_NAME , DatabaseDataType . STRING , 130 , false ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_DEVICE_USER_PUBLIC_KEY_COLUMN_NAME , DatabaseDataType . STRING , 130 , false ) ; table . addIndex ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_FIRST_KEY_COLUMN ) ; databaseFactory . createTable ( table ) ; } catch ( CantCreateDatabaseException cantCreateDatabaseException ) { String message = CantCreateDatabaseException . DEFAULT_MESSAGE ; FermatException cause = cantCreateDatabaseException . getCause ( ) ; String context = " Asset ▁ Issuer ▁ Identity ▁ DataBase _ Factory : ▁ " + cantCreateDatabaseException . getContext ( ) ; String possibleReason = " The ▁ exception ▁ is ▁ thrown ▁ the ▁ Create ▁ Database ▁ Asset ▁ Issuer ▁ Identity ▁ ' this . platformDatabaseSystem . createDatabase ( \" AssetIssuerIdentity \" ) ' " + cantCreateDatabaseException . getPossibleReason ( ) ; throw new CantCreateDatabaseException ( message , cause , context , possibleReason ) ; } catch ( CantCreateTableException cantCreateTableException ) { String message = CantCreateTableException . DEFAULT_MESSAGE ; FermatException cause = cantCreateTableException . getCause ( ) ; String context = " Create ▁ Table ▁ Asset ▁ Issuer ▁ Identity " + cantCreateTableException . getContext ( ) ; String possibleReason = " The ▁ exception ▁ is ▁ generated ▁ when ▁ creating ▁ the ▁ table ▁ Asset ▁ Issuer ▁ Identity ▁ - ▁ DatabaseFactory . createTable ( table ) ▁ " + cantCreateTableException . getPossibleReason ( ) ; throw new CantCreateDatabaseException ( message , cause , context , possibleReason ) ; } catch ( Exception exception ) { throw new CantCreateDatabaseException ( CantCreateDatabaseException . DEFAULT_MESSAGE , FermatException . wrapException ( exception ) , null , null ) ; } return database ; }
fvasquezjatar/fermat-unused | @ Override public void setPluginDatabaseSystem ( PluginDatabaseSystem pluginDatabaseSystem ) { this . pluginDatabaseSystem = pluginDatabaseSystem ; }
fvasquezjatar/fermat-unused | @ Override public void setErrorManager ( ErrorManager errorManager ) { this . errorManager = errorManager ; }
0359xiaodong/blink | public Group ( ) { }
0359xiaodong/blink | public Group ( Long id ) { this . id = id ; }
0359xiaodong/blink | public Group ( String name , Integer state , Long id , String attributableType ) { this . name = name ; this . state = state ; this . id = id ; this . attributableType = attributableType ; }
0359xiaodong/blink | public void __setDaoSession ( DaoSession daoSession ) { this . daoSession = daoSession ; myDao = daoSession != null ? daoSession . getGroupDao ( ) : null ; }
0359xiaodong/blink | public String getName ( ) { return name ; }
0359xiaodong/blink | public void setName ( String name ) { this . name = name ; }
0359xiaodong/blink | public Integer getState ( ) { return state ; }
0359xiaodong/blink | public void setState ( Integer state ) { this . state = state ; }
0359xiaodong/blink | public Long getId ( ) { return id ; }
0359xiaodong/blink | public void setId ( Long id ) { this . id = id ; }
0359xiaodong/blink | public String getAttributableType ( ) { return attributableType ; }
0359xiaodong/blink | public void setAttributableType ( String attributableType ) { this . attributableType = attributableType ; }
0359xiaodong/blink | public List < GroupDevice > getGroupDeviceList ( ) { if ( groupDeviceList == null ) { if ( daoSession == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } GroupDeviceDao targetDao = daoSession . getGroupDeviceDao ( ) ; List < GroupDevice > groupDeviceListNew = targetDao . _queryGroup_GroupDeviceList ( id ) ; synchronized ( this ) { if ( groupDeviceList == null ) { groupDeviceList = groupDeviceListNew ; } } } return groupDeviceList ; }
0359xiaodong/blink | public synchronized void resetGroupDeviceList ( ) { groupDeviceList = null ; }
0359xiaodong/blink | public List < Attribute > getAttributes ( ) { if ( attributes == null ) { if ( daoSession == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } AttributeDao targetDao = daoSession . getAttributeDao ( ) ; List < Attribute > attributesNew = targetDao . _queryGroup_Attributes ( id , attributableType ) ; synchronized ( this ) { if ( attributes == null ) { attributes = attributesNew ; } } } return attributes ; }
0359xiaodong/blink | public synchronized void resetAttributes ( ) { attributes = null ; }
0359xiaodong/blink | public void delete ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } myDao . delete ( this ) ; }
0359xiaodong/blink | public void update ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } myDao . update ( this ) ; }
0359xiaodong/blink | public void refresh ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } myDao . refresh ( this ) ; }
0359xiaodong/blink | public void flushAttributes ( ) { AttributeDao attributeDao = BlinkApp . getDaoSession ( ) . getAttributeDao ( ) ; for ( Attribute attribute : getAttributes ( ) ) { attribute . setAttributableId ( id ) ; attribute . setAttributableType ( ATTRIBUTABLE_TYPE ) ; attributeDao . insertOrIgnore ( attribute ) ; } }
0359xiaodong/blink | public void flushGroupDevices ( ) { GroupDeviceDao groupDeviceDao = BlinkApp . getDaoSession ( ) . getGroupDeviceDao ( ) ; List < GroupDevice > groupDevices = groupDeviceDao . queryBuilder ( ) . where ( GroupDeviceDao . Properties . GroupId . eq ( getId ( ) ) ) . list ( ) ; Set < Long > deviceSet = new HashSet < > ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { deviceSet . add ( groupDevice . getDeviceId ( ) ) ; } Log . d ( TAG , " flushGroupDevices : ▁ " + groupDevices . size ( ) ) ; Log . d ( TAG , " flushGroupDevices : ▁ " + getGroupDeviceList ( ) . size ( ) ) ; for ( GroupDevice groupDevice : groupDevices ) { if ( ! deviceSet . remove ( groupDevice . getDeviceId ( ) ) ) { Log . d ( TAG , " delete : ▁ " + groupDevice . getDeviceId ( ) ) ; groupDevice . delete ( ) ; } } for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { if ( deviceSet . contains ( groupDevice . getDeviceId ( ) ) ) { Log . d ( TAG , " adding : ▁ " + groupDevice . getDeviceId ( ) ) ; groupDeviceDao . insertOrReplace ( groupDevice ) ; } } }
0359xiaodong/blink | public void deleteWithReferences ( ) { BlinkApp . getDaoSession ( ) . runInTx ( new Runnable ( ) { @ Override public void run ( ) { for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { groupDevice . delete ( ) ; } for ( Attribute attribute : getAttributes ( ) ) { attribute . delete ( ) ; } delete ( ) ; } } ) ; Event . broadcast ( Group . KEY ) ; }
0359xiaodong/blink | public List < Device > getDevices ( ) { List < Device > devices = new ArrayList < > ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { devices . add ( groupDevice . getDevice ( ) ) ; } return devices ; }
0359xiaodong/blink | public void setLevel ( final int level ) { BlinkApp . getDaoSession ( ) . runInTx ( new Runnable ( ) { @ Override public void run ( ) { Attribute attribute = getAttributes ( ) . get ( 1 ) ; String newValue = String . valueOf ( level ) ; attribute . setValueLocal ( newValue ) ; attribute . update ( ) ; state = BlinkApp . STATE_UPDATED ; update ( ) ; Long attributeTypeId = attribute . getAttributeTypeId ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { groupDevice . getDevice ( ) . setAttribute ( attributeTypeId , newValue ) ; } } } ) ; }
0359xiaodong/blink | public void setOn ( final boolean on ) { BlinkApp . getDaoSession ( ) . runInTx ( new Runnable ( ) { @ Override public void run ( ) { Attribute attribute = getAttributes ( ) . get ( 0 ) ; String newValue = on ? Attribute . ON : Attribute . OFF ; attribute . setValueLocal ( newValue ) ; attribute . update ( ) ; state = BlinkApp . STATE_UPDATED ; update ( ) ; Long attributeTypeId = attribute . getAttributeTypeId ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { groupDevice . getDevice ( ) . setAttribute ( attributeTypeId , newValue ) ; } } } ) ; }
0359xiaodong/blink | public boolean isOn ( ) { if ( getAttributes ( ) . size ( ) < 1 ) { return false ; } return getAttributes ( ) . get ( 0 ) . getBool ( ) ; }
0359xiaodong/blink | public int getLevel ( ) { if ( getAttributes ( ) . size ( ) < 2 ) { return 0 ; } return getAttributes ( ) . get ( 1 ) . getInt ( ) ; }
0359xiaodong/blink | public String toNfc ( ) { List < NfcCommand > commands = new ArrayList < > ( ) ; List < NfcCommand . Update > updates = new ArrayList < > ( ) ; NfcCommand command = new NfcCommand ( ) ; command . g = getId ( ) ; command . u = updates ; commands . add ( command ) ; for ( Attribute attribute : getAttributes ( ) ) { NfcCommand . Update update = new NfcCommand . Update ( ) ; update . i = attribute . getAttributeTypeId ( ) ; update . v = attribute . getValue ( ) ; updates . add ( update ) ; } return BlinkApi . getGson ( ) . toJson ( commands ) ; }
0359xiaodong/blink | public void setNominal ( ) { switch ( state ) { case BlinkApp . STATE_UPDATED : for ( Attribute attribute : getAttributes ( ) ) { attribute . onSync ( ) ; } state = BlinkApp . STATE_NOMINAL ; update ( ) ; break ; case BlinkApp . STATE_REMOVED : deleteWithReferences ( ) ; break ; case BlinkApp . STATE_ADDED : state = BlinkApp . STATE_NOMINAL ; update ( ) ; break ; case BlinkApp . STATE_NAME_SET : state = BlinkApp . STATE_NOMINAL ; update ( ) ; break ; } }
0359xiaodong/blink | public void onEdit ( final String newName , final long [ ] ids ) { Log . d ( TAG , " onEdit : ▁ " + newName + " ▁ " + ids . length ) ; daoSession . runInTx ( new Runnable ( ) { @ Override public void run ( ) { if ( ! getName ( ) . equals ( newName ) ) { setName ( newName ) ; setState ( BlinkApp . STATE_NAME_SET ) ; update ( ) ; } setDeviceIds ( ids ) ; Syncro . getInstance ( ) . syncDevices ( ) ; } } ) ; }
0359xiaodong/blink | private void setDeviceIds ( long [ ] deviceIds ) { Set < Long > deviceSet = new HashSet < > ( ) ; for ( long deviceId : deviceIds ) { deviceSet . add ( deviceId ) ; } for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { if ( ! deviceSet . remove ( groupDevice . getDeviceId ( ) ) ) { groupDevice . setState ( BlinkApp . STATE_REMOVED ) ; groupDevice . update ( ) ; } } for ( Long deviceId : deviceSet ) { addDevice ( deviceId ) ; } resetGroupDeviceList ( ) ; Event . broadcast ( Group . KEY ) ; }
0359xiaodong/blink | private void addDevice ( long deviceId ) { GroupDevice groupDevice = new GroupDevice ( ) ; groupDevice . setDeviceId ( deviceId ) ; groupDevice . setGroupId ( getId ( ) ) ; groupDevice . setState ( BlinkApp . STATE_ADDED ) ; daoSession . getGroupDeviceDao ( ) . insertOrReplace ( groupDevice ) ; }
VaybhavSharma/commons | @ Test public void testEmptyMergedHistogram ( ) { ApproximateHistogram empty [ ] = new ApproximateHistogram [ 0 ] ; Histogram mergedHistogram = ApproximateHistogram . merge ( empty ) ; assertEquals ( 0L , mergedHistogram . getQuantile ( 0.5 ) ) ; }
VaybhavSharma/commons | @ Test public void testMergedSimilarHistogram ( ) { int n = 10 ; ApproximateHistogram histograms [ ] = new ApproximateHistogram [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ApproximateHistogram h = new ApproximateHistogram ( ) ; h . add ( i ) ; histograms [ i ] = h ; } Histogram mergedHistogram = ApproximateHistogram . merge ( histograms ) ; assertEquals ( 0L , mergedHistogram . getQuantile ( 0.0 ) ) ; assertEquals ( 1L , mergedHistogram . getQuantile ( 0.1 ) ) ; assertEquals ( 5L , mergedHistogram . getQuantile ( 0.5 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.9 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.99 ) ) ; }
VaybhavSharma/commons | @ Test public void testMergedDifferentHistogram ( ) { int n = 10 ; ApproximateHistogram histograms [ ] = new ApproximateHistogram [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ApproximateHistogram h = new ApproximateHistogram ( Amount . of ( 2L + 4 * i , Data . KB ) ) ; h . add ( i ) ; histograms [ i ] = h ; } Histogram mergedHistogram = ApproximateHistogram . merge ( histograms ) ; assertEquals ( 0L , mergedHistogram . getQuantile ( 0.0 ) ) ; assertEquals ( 1L , mergedHistogram . getQuantile ( 0.1 ) ) ; assertEquals ( 5L , mergedHistogram . getQuantile ( 0.5 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.9 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.99 ) ) ; }
VaybhavSharma/commons | @ Test public void testMergedBigHistogram ( ) { int n = 10 ; int m = 5000 ; ApproximateHistogram histograms [ ] = new ApproximateHistogram [ n ] ; int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ApproximateHistogram h = new ApproximateHistogram ( ) ; while ( x < m * ( i + 1 ) ) { h . add ( x ) ; x += 1 ; } histograms [ i ] = h ; } long sum = m * n ; double maxError = ApproximateHistogram . DEFAULT_PRECISION . getEpsilon ( ) * ApproximateHistogram . DEFAULT_PRECISION . getN ( ) ; Histogram mergedHistogram = ApproximateHistogram . merge ( histograms ) ; for ( int i = 1 ; i < 10 ; i ++ ) { double q = i / 10.0 ; double expected = q * sum ; assertEquals ( expected , mergedHistogram . getQuantile ( q ) , maxError ) ; } }
vvakame/JsonPullParser | OnJsonObjectAddListener listener = new OnJsonObjectAddListener ( ) { @ Override public void onAdd ( Object obj ) { if ( obj instanceof Tweet ) { s += " t " ; } else if ( obj instanceof User ) { s += " u " ; } else if ( obj instanceof Place ) { s += " p " ; } else if ( obj instanceof NestParentData ) { s += " Np " ; } else if ( obj instanceof NestDepth1Data ) { s += " N1" ; } else if ( obj instanceof NestDepth2Data ) { s += " N2" ; } else { s += " o " ; } } }
vvakame/JsonPullParser | i ++ ) { expected += " uot " ; }
vvakame/JsonPullParser | InputStream getStream ( String str ) { return new ByteArrayInputStream ( str . getBytes ( ) ) ; }
vvakame/JsonPullParser | @ Before public void setup ( ) { s = " " ; }
bunjlabs/jed2d | protected Vector4b ( Vector4b v ) { this . x1 = v . x1 ; this . x2 = v . x2 ; this . x3 = v . x3 ; this . x4 = v . x4 ; }
bunjlabs/jed2d | protected Vector4b ( boolean v ) { this . x1 = v ; this . x2 = v ; this . x3 = v ; this . x4 = v ; }
bunjlabs/jed2d | protected Vector4b ( boolean x1 , boolean x2 , boolean x3 , boolean x4 ) { this . x1 = x1 ; this . x2 = x2 ; this . x3 = x3 ; this . x4 = x4 ; }
bunjlabs/jed2d | protected Vector4b ( ) { this . x1 = this . x2 = this . x3 = this . x4 = false ; }
bunjlabs/jed2d | public Vector4i toInteger ( ) { return new Vector4i ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | public Vector4l toLong ( ) { return new Vector4l ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | public Vector4f toFloat ( ) { return new Vector4f ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | public Vector4d toDouble ( ) { return new Vector4d ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | @ Override public String toString ( ) { return " Vector4b { " + " x1 = " + x1 + " , ▁ x2 = " + x2 + " , ▁ x3 = " + x3 + " , ▁ x4 = " + x4 + ' } ' ; }
bunjlabs/jed2d | @ Override public int hashCode ( ) { int hash = 5 ; hash = 47 * hash + ( this . x1 ? 1 : 0 ) ; hash = 47 * hash + ( this . x2 ? 1 : 0 ) ; hash = 47 * hash + ( this . x3 ? 1 : 0 ) ; hash = 47 * hash + ( this . x4 ? 1 : 0 ) ; return hash ; }
bunjlabs/jed2d | @ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Vector4b other = ( Vector4b ) obj ; if ( this . x1 != other . x1 ) { return false ; } if ( this . x2 != other . x2 ) { return false ; } if ( this . x3 != other . x3 ) { return false ; } if ( this . x4 != other . x4 ) { return false ; } return true ; }
LCA311/leoapp-sources | public ResultDialog ( @ NonNull Context context , int id , String to ) { super ( context ) ; this . id = id ; this . to = to ; }
LCA311/leoapp-sources | @ Override public void onCreate ( Bundle b ) { super . onCreate ( b ) ; setContentView ( R . layout . dialog_survey_result ) ; b1 = findViewById ( R . id . buttonOK ) ; t1 = findViewById ( R . id . question ) ; t2 = findViewById ( R . id . votes ) ; load = findViewById ( R . id . progressBarLoading ) ; ProgressBar p1 = findViewById ( R . id . progressBar1 ) ; ProgressBar p2 = findViewById ( R . id . progressBar2 ) ; ProgressBar p3 = findViewById ( R . id . progressBar3 ) ; ProgressBar p4 = findViewById ( R . id . progressBar4 ) ; ProgressBar p5 = findViewById ( R . id . progressBar5 ) ; progressBars = new ProgressBar [ ] { p1 , p2 , p3 , p4 , p5 } ; TextView op1 = findViewById ( R . id . answer1 ) ; TextView op2 = findViewById ( R . id . answer2 ) ; TextView op3 = findViewById ( R . id . answer3 ) ; TextView op4 = findViewById ( R . id . answer4 ) ; TextView op5 = findViewById ( R . id . answer5 ) ; answers = new TextView [ ] { op1 , op2 , op3 , op4 , op5 } ; TextView pe1 = findViewById ( R . id . percent1 ) ; TextView pe2 = findViewById ( R . id . percent2 ) ; TextView pe3 = findViewById ( R . id . percent3 ) ; TextView pe4 = findViewById ( R . id . percent4 ) ; TextView pe5 = findViewById ( R . id . percent5 ) ; percentages = new TextView [ ] { pe1 , pe2 , pe3 , pe4 , pe5 } ; for ( TextView cur : answers ) cur . setVisibility ( View . GONE ) ; for ( ProgressBar cur : progressBars ) cur . setVisibility ( View . GONE ) ; t1 . setVisibility ( View . INVISIBLE ) ; t2 . setVisibility ( View . INVISIBLE ) ; b1 . setOnClickListener ( v -> { dismiss ( ) ; stopLoading ( ) ; } ) ; asyncTask = new SyncResultTask ( ) ; asyncTask . addListener ( this ) . execute ( id , to ) ; }
LCA311/leoapp-sources | private void animateChanges ( int amount , HashMap < String , Integer > answerMap , int target , int votes ) { Map . Entry < String , Integer > [ ] entries = answerMap . entrySet ( ) . toArray ( new Map . Entry [ 0 ] ) ; for ( int i = 0 ; i < amount ; i ++ ) { answers [ i ] . setText ( entries [ i ] . getKey ( ) ) ; answers [ i ] . setVisibility ( View . VISIBLE ) ; progressBars [ i ] . setVisibility ( View . VISIBLE ) ; if ( votes == 0 ) continue ; ObjectAnimator animation = ObjectAnimator . ofInt ( progressBars [ i ] , " progress " , entries [ i ] . getValue ( ) * 100 / votes ) ; animation . setDuration ( 1250 ) ; animation . setInterpolator ( new DecelerateInterpolator ( ) ) ; animation . start ( ) ; percentages [ i ] . setText ( String . valueOf ( entries [ i ] . getValue ( ) ) ) ; } RelativeLayout . LayoutParams params = ( RelativeLayout . LayoutParams ) b1 . getLayoutParams ( ) ; params . addRule ( RelativeLayout . BELOW , answers [ amount - 1 ] . getId ( ) ) ; b1 . setLayoutParams ( params ) ; for ( int i = amount ; i < answers . length ; i ++ ) { answers [ i ] . setVisibility ( GONE ) ; } double percentage = ( double ) votes * 100d / ( double ) target ; DecimalFormat df = new DecimalFormat ( " # # # #0.00" ) ; t2 . setText ( Utils . getContext ( ) . getString ( R . string . statistics_result , votes , target , df . format ( percentage ) ) ) ; }
LCA311/leoapp-sources | private void stopLoading ( ) { asyncTask . cancel ( true ) ; }
LCA311/leoapp-sources | @ Override @ SuppressWarnings ( " unchecked " ) public void taskFinished ( Object ... params ) { ResponseCode responseCode = ( ResponseCode ) params [ 0 ] ; int amountAnswers = ( int ) params [ 1 ] ; LinkedHashMap < String , Integer > answerResults = ( LinkedHashMap < String , Integer > ) params [ 2 ] ; int target = ( int ) params [ 3 ] ; int sumVotes = ( int ) params [ 4 ] ; String title = ( String ) params [ 5 ] ; load . setVisibility ( View . GONE ) ; switch ( responseCode ) { case NO_CONNECTION : findViewById ( R . id . imageViewError ) . setVisibility ( View . VISIBLE ) ; final Snackbar snack = Snackbar . make ( findViewById ( R . id . snackbar ) , Utils . getString ( R . string . snackbar_no_connection_info ) , Snackbar . LENGTH_LONG ) ; snack . setActionTextColor ( ContextCompat . getColor ( getContext ( ) , R . color . colorPrimary ) ) ; snack . setAction ( getContext ( ) . getString ( R . string . confirm ) , v -> snack . dismiss ( ) ) ; snack . show ( ) ; break ; case NOT_SENT : case SERVER_FAILED : findViewById ( R . id . imageViewError ) . setVisibility ( View . VISIBLE ) ; final Snackbar snackbar = Snackbar . make ( findViewById ( R . id . snackbar ) , Utils . getString ( R . string . error_later ) , Snackbar . LENGTH_SHORT ) ; snackbar . setActionTextColor ( ContextCompat . getColor ( getContext ( ) , R . color . colorPrimary ) ) ; snackbar . setAction ( getContext ( ) . getString ( R . string . confirm ) , v -> snackbar . dismiss ( ) ) ; snackbar . show ( ) ; break ; case SUCCESS : t1 . setText ( title ) ; t1 . setVisibility ( View . VISIBLE ) ; t2 . setVisibility ( View . VISIBLE ) ; animateChanges ( amountAnswers , answerResults , target , sumVotes ) ; break ; } }
cezarykluczynski/stapi | public AstronomicalObject ( AstronomicalObjectPortType astronomicalObjectPortType , ApiKeySupplier apiKeySupplier ) { this . astronomicalObjectPortType = astronomicalObjectPortType ; this . apiKeySupplier = apiKeySupplier ; }
cezarykluczynski/stapi | public AstronomicalObjectFullResponse get ( AstronomicalObjectFullRequest request ) { apiKeySupplier . supply ( request ) ; return astronomicalObjectPortType . getAstronomicalObjectFull ( request ) ; }
cezarykluczynski/stapi | public AstronomicalObjectBaseResponse search ( AstronomicalObjectBaseRequest request ) { apiKeySupplier . supply ( request ) ; return astronomicalObjectPortType . getAstronomicalObjectBase ( request ) ; }
rodhilton/rallydroid | public Activity ( JSONObject object ) { super ( object ) ; }
rodhilton/rallydroid | public String getText ( ) { return getString ( " Text " ) ; }
rodhilton/rallydroid | public String getUserName ( ) { return getString ( " UserName " ) ; }
rodhilton/rallydroid | public String getArtifact ( ) { return getString ( " Artifact " ) ; }
rodhilton/rallydroid | public String toString ( ) { StringBuffer ret = new StringBuffer ( getCreationDate ( ) ) ; ret . append ( " ▁ : ▁ " + getUserName ( ) ) ; ret . append ( " ▁ : ▁ " + getArtifact ( ) ) ; ret . append ( " ▁ ( " + getText ( ) + " ) " ) ; return ret . toString ( ) ; }
rodhilton/rallydroid | public String getCreationDate ( ) { return getString ( " CreationDate " ) ; }
mzubairahmed/externalapi | public ProductColorJsonModel ( ) { }
mzubairahmed/externalapi | public ProductColorJsonModel ( String code , String description , String displayName , List < CodeValueGroupJsonModel > codeValueGroups ) { this . code = code ; this . description = description ; this . displayName = displayName ; this . codeValueGroups = codeValueGroups ; }
mzubairahmed/externalapi | public String getCode ( ) { return code ; }
mzubairahmed/externalapi | public void setCode ( String code ) { this . code = code ; }
mzubairahmed/externalapi | public String getDescription ( ) { return description ; }
mzubairahmed/externalapi | public void setDescription ( String description ) { this . description = description ; }
mzubairahmed/externalapi | public String getDisplayName ( ) { return displayName ; }
mzubairahmed/externalapi | public void setDisplayName ( String displayName ) { this . displayName = displayName ; }
mzubairahmed/externalapi | public List < CodeValueGroupJsonModel > getCodeValueGroups ( ) { return codeValueGroups ; }
mzubairahmed/externalapi | public void setCodeValueGroups ( List < CodeValueGroupJsonModel > codeValueGroups ) { this . codeValueGroups = codeValueGroups ; }
mzubairahmed/externalapi | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( code == null ) ? 0 : code . hashCode ( ) ) ; result = prime * result + ( ( codeValueGroups == null ) ? 0 : codeValueGroups . hashCode ( ) ) ; result = prime * result + ( ( description == null ) ? 0 : description . hashCode ( ) ) ; result = prime * result + ( ( displayName == null ) ? 0 : displayName . hashCode ( ) ) ; return result ; }
mzubairahmed/externalapi | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ProductColorJsonModel other = ( ProductColorJsonModel ) obj ; if ( code == null ) { if ( other . code != null ) return false ; } else if ( ! code . equals ( other . code ) ) return false ; if ( codeValueGroups == null ) { if ( other . codeValueGroups != null ) return false ; } else if ( ! codeValueGroups . equals ( other . codeValueGroups ) ) return false ; if ( description == null ) { if ( other . description != null ) return false ; } else if ( ! description . equals ( other . description ) ) return false ; if ( displayName == null ) { if ( other . displayName != null ) return false ; } else if ( ! displayName . equals ( other . displayName ) ) return false ; return true ; }
mzubairahmed/externalapi | @ Override public String toString ( ) { return " ProductColorJsonModel ▁ [ code = " + code + " , ▁ description = " + description + " , ▁ displayName = " + displayName + " , ▁ codeValueGroups = " + codeValueGroups + " ] " ; }
jk1/intellij-community | public RemoveBuildFileAction ( AntExplorer antExplorer ) { super ( AntBundle . message ( " remove . build . file . action . name " ) ) ; myAntExplorer = antExplorer ; }
jk1/intellij-community | public void actionPerformed ( AnActionEvent e ) { myAntExplorer . removeSelectedBuildFiles ( ) ; }
JMedinilla/Netbour | @ OnItemClick ( R . id . fragListMeeting_list ) public void itemClick ( View view , int position ) { TextView txv = ( TextView ) view . findViewById ( R . id . adapterMeeting_txtDescription ) ; PoMeeting meeting = adpMeeting . getItem ( position ) ; if ( txv != null && meeting != null ) { String txt = txv . getText ( ) . toString ( ) ; if ( txv . getMaxLines ( ) == 2 ) { openText ( txv , txt ) ; } else { closeText ( txv ) ; } } }
JMedinilla/Netbour | @ Override public void onAttach ( Context context ) { super . onAttach ( context ) ; callbackBack = ( FrgBack ) context ; callSnack = ( FrgLists ) context ; callback = ( ListMeeting ) context ; }
JMedinilla/Netbour | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setRetainInstance ( true ) ; setHasOptionsMenu ( true ) ; loadingDialogCreate ( ) ; Bundle bundle = getArguments ( ) ; if ( bundle != null ) { userEmail = bundle . getString ( " userEmail " ) ; String code = bundle . getString ( " comcode " ) ; userCategory = bundle . getInt ( " userCategory " ) ; ArrayList < String > arrayList = bundle . getStringArrayList ( " adminEmails " ) ; List < PoMeeting > list = new ArrayList < > ( ) ; adpMeeting = new AdpMeeting ( getActivity ( ) , list , this , this ) ; presenterMeeting = new PresenterMeetingImpl ( null , this ) ; presenterMeeting . instanceFirebase ( code ) ; if ( arrayList != null ) { to = arrayList . toArray ( new String [ arrayList . size ( ) ] ) ; } } }
JMedinilla/Netbour | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_list_meeting , container , false ) ; ButterKnife . bind ( this , view ) ; return view ; }
JMedinilla/Netbour | @ Override public void onViewCreated ( View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; meetingList . setAdapter ( adpMeeting ) ; meetingList . setDivider ( null ) ; }
JMedinilla/Netbour | @ Override public void onStart ( ) { super . onStart ( ) ; loadingDialogShow ( ) ; if ( callbackBack != null ) { callbackBack . backFromForm ( ) ; } if ( presenterMeeting != null ) { presenterMeeting . attachFirebase ( ) ; } }
JMedinilla/Netbour | @ Override public void onStop ( ) { super . onStop ( ) ; if ( presenterMeeting != null ) { presenterMeeting . dettachFirebase ( ) ; } loadingDialogHide ( ) ; }
JMedinilla/Netbour | @ Override public void onDetach ( ) { super . onDetach ( ) ; callback = null ; callSnack = null ; callbackBack = null ; }
JMedinilla/Netbour | @ Override public void deleteElement ( PoMeeting meeting , int position ) { if ( meeting != null ) { if ( userEmail . equals ( meeting . getAuthorEmail ( ) ) || userCategory == PoUser . GROUP_ADMIN ) { showDeleteDialog ( meeting , position ) ; } else { if ( callSnack != null ) { callSnack . sendSnack ( getString ( R . string . no_permission ) ) ; } } } }
JMedinilla/Netbour | @ Override public void deletedMeeting ( PoMeeting item ) { callback . deletedMeeting ( item ) ; }
JMedinilla/Netbour | @ Override public void editElement ( PoMeeting meeting ) { if ( meeting != null ) { if ( userEmail . equals ( meeting . getAuthorEmail ( ) ) || userCategory == PoUser . GROUP_ADMIN ) { if ( callback != null ) { callback . sendMeeting ( meeting ) ; } } else { if ( callSnack != null ) { callSnack . sendSnack ( getString ( R . string . no_permission ) ) ; } } } }
JMedinilla/Netbour | @ Override public void reportElement ( ) { sendEmail ( ) ; }
JMedinilla/Netbour | @ Override public void returnList ( List < PoMeeting > list ) { meetingList . setVisibility ( View . VISIBLE ) ; meetingEmpty . setVisibility ( View . GONE ) ; loadingDialogHide ( ) ; updateList ( list ) ; }
JMedinilla/Netbour | @ Override public void returnListEmpty ( ) { meetingList . setVisibility ( View . GONE ) ; meetingEmpty . setVisibility ( View . VISIBLE ) ; List < PoMeeting > list = new ArrayList < > ( ) ; loadingDialogHide ( ) ; updateList ( list ) ; }
JMedinilla/Netbour | private void closeText ( TextView txv ) { txv . setMaxLines ( 2 ) ; txv . setEllipsize ( TextUtils . TruncateAt . END ) ; }
JMedinilla/Netbour | private void deleteResponse ( int position ) { if ( presenterMeeting != null ) { presenterMeeting . deleteMeeting ( adpMeeting . getItem ( position ) ) ; } }
JMedinilla/Netbour | private void loadingDialogCreate ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; LayoutInflater inflater = getActivity ( ) . getLayoutInflater ( ) ; View view = inflater . inflate ( R . layout . loading_dialog , null ) ; builder . setView ( view ) ; builder . setCancelable ( false ) ; loading = builder . create ( ) ; loading . setCancelable ( false ) ; loading . setCanceledOnTouchOutside ( false ) ; if ( loading . getWindow ( ) != null ) { loading . getWindow ( ) . setBackgroundDrawable ( new ColorDrawable ( Color . TRANSPARENT ) ) ; } }
JMedinilla/Netbour | public void loadingDialogHide ( ) { if ( loading != null ) { loading . dismiss ( ) ; } }
JMedinilla/Netbour | public void loadingDialogShow ( ) { if ( loading != null ) { loading . show ( ) ; } }
JMedinilla/Netbour | private void openText ( TextView txv , String txt ) { txv . setMaxLines ( Integer . MAX_VALUE ) ; txv . setEllipsize ( null ) ; txv . setText ( txt ) ; }
JMedinilla/Netbour | private void sendEmail ( ) { if ( to != null ) { if ( to . length > 0 ) { EmailIntentBuilder . from ( getActivity ( ) ) . to ( Arrays . asList ( to ) ) . subject ( getActivity ( ) . getString ( R . string . report_meeting ) ) . start ( ) ; } else { Toast . makeText ( getActivity ( ) , R . string . no_email_admin , Toast . LENGTH_SHORT ) . show ( ) ; } } else { Toast . makeText ( getActivity ( ) , R . string . no_email_admin , Toast . LENGTH_SHORT ) . show ( ) ; } }
JMedinilla/Netbour | private void showDeleteDialog ( PoMeeting meeting , final int position ) { AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( R . string . dialog_title_delete ) ; builder . setMessage ( getString ( R . string . dialog_message_delete ) + " ▁ " + meeting . getDate ( ) + getString ( R . string . dialog_message_delete_two ) ) ; builder . setPositiveButton ( android . R . string . yes , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { deleteResponse ( position ) ; } } ) ; builder . setNegativeButton ( android . R . string . no , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; }
JMedinilla/Netbour | private void updateList ( List < PoMeeting > list ) { adpMeeting . clear ( ) ; adpMeeting . addAll ( list ) ; }
TonyTangAndroid/storio | PreparedGetMandatoryResult ( @ NonNull StorIOSQLite storIOSQLite , @ NonNull Query query ) { super ( storIOSQLite , query ) ; }
TonyTangAndroid/storio | PreparedGetMandatoryResult ( @ NonNull StorIOSQLite storIOSQLite , @ NonNull RawQuery rawQuery ) { super ( storIOSQLite , rawQuery ) ; }
TonyTangAndroid/storio | @ WorkerThread @ NonNull public final Result executeAsBlocking ( ) { return super . executeAsBlocking ( ) ; }
data-integrations/pivot | public AggregateResult ( Schema inputSchema , Map < String , AggregateFunction > functions ) { this . inputSchema = inputSchema ; this . functions = functions ; missingColumnsModel = new HashMap < > ( ) ; }
data-integrations/pivot | public Schema getInputSchema ( ) { return inputSchema ; }
data-integrations/pivot | public Map < String , AggregateFunction > getFunctions ( ) { return functions ; }
data-integrations/pivot | public HashMap < String , Set < Object > > getMissingColumnsModel ( ) { return missingColumnsModel ; }
data-integrations/pivot | public void mergeMissingColumnDataModels ( AggregateResult otherResult ) { missingColumnsModel . putAll ( otherResult . getMissingColumnsModel ( ) ) ; }
Thanu/stratos | public StratosManagerTopologyEventReceiver ( ) { }
GunoH/intellij-community | @ Override protected boolean isEnabled ( @ NotNull XDebugSession session , DataContext dataContext ) { Promise < String > textPromise = getTextToEvaluate ( dataContext , session ) ; if ( textPromise . getState ( ) == Promise . State . PENDING ) { return true ; } else if ( textPromise . getState ( ) == Promise . State . REJECTED ) { return false ; } try { return textPromise . blockingGet ( 0 ) != null ; } catch ( TimeoutException | ExecutionException e ) { return false ; } }
GunoH/intellij-community | @ Override protected void perform ( @ NotNull XDebugSession session , DataContext dataContext ) { getTextToEvaluate ( dataContext , session ) . onSuccess ( text -> { if ( text == null ) return ; UIUtil . invokeLaterIfNeeded ( ( ) -> { XDebugSessionTab tab = ( ( XDebugSessionImpl ) session ) . getSessionTab ( ) ; if ( tab != null ) { ( ( XWatchesViewImpl ) tab . getWatchesView ( ) ) . addWatchExpression ( XExpressionImpl . fromText ( text ) , - 1 , true , true ) ; } } ) ; } ) ; }
DavideD/hibernate-validator | public PropertyDescriptorImpl ( Type returnType , String propertyName , Set < ConstraintDescriptorImpl < ? > > constraints , boolean cascaded , boolean defaultGroupSequenceRedefined , List < Class < ? > > defaultGroupSequence , Set < GroupConversionDescriptor > groupConversions ) { super ( returnType , constraints , defaultGroupSequenceRedefined , defaultGroupSequence ) ; this . property = propertyName ; this . cascaded = cascaded ; this . groupConversions = Collections . unmodifiableSet ( groupConversions ) ; }
DavideD/hibernate-validator | @ Override public boolean isCascaded ( ) { return cascaded ; }
DavideD/hibernate-validator | @ Override public Set < GroupConversionDescriptor > getGroupConversions ( ) { return groupConversions ; }
DavideD/hibernate-validator | @ Override public String getPropertyName ( ) { return property ; }
DavideD/hibernate-validator | @ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " PropertyDescriptorImpl " ) ; sb . append ( " { property = " ) . append ( property ) ; sb . append ( " , ▁ cascaded = ' " ) . append ( cascaded ) . append ( ' \' ' ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; }
sawano/java-commons | public ValidationException ( ) { }
sawano/java-commons | public ValidationException ( final String message ) { super ( message ) ; }
sawano/java-commons | public ValidationException ( final String message , final Throwable cause ) { super ( message , cause ) ; }
sawano/java-commons | public ValidationException ( final Throwable cause ) { super ( cause ) ; }
numixproject/com.numix.calculator | public TinyDB ( Context appContext ) { preferences = PreferenceManager . getDefaultSharedPreferences ( appContext ) ; }
numixproject/com.numix.calculator | public Bitmap getImage ( String path ) { Bitmap bitmapFromPath = null ; try { bitmapFromPath = BitmapFactory . decodeFile ( path ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return bitmapFromPath ; }
numixproject/com.numix.calculator | public String getSavedImagePath ( ) { return lastImagePath ; }
numixproject/com.numix.calculator | public boolean putImage ( String theFolder , String theImageName , Bitmap theBitmap ) { if ( theFolder == null || theImageName == null || theBitmap == null ) return false ; this . DEFAULT_APP_IMAGEDATA_DIRECTORY = theFolder ; String mFullPath = setupFullPath ( theImageName ) ; if ( ! mFullPath . equals ( " " ) ) { lastImagePath = mFullPath ; return saveBitmap ( mFullPath , theBitmap ) ; } return false ; }
numixproject/com.numix.calculator | public boolean putImageWithFullPath ( String fullPath , Bitmap theBitmap ) { return ! ( fullPath == null || theBitmap == null ) && saveBitmap ( fullPath , theBitmap ) ; }
numixproject/com.numix.calculator | private String setupFullPath ( String imageName ) { File mFolder = new File ( Environment . getExternalStorageDirectory ( ) , DEFAULT_APP_IMAGEDATA_DIRECTORY ) ; if ( isExternalStorageReadable ( ) && isExternalStorageWritable ( ) && ! mFolder . exists ( ) ) { if ( ! mFolder . mkdirs ( ) ) { Log . e ( " ERROR " , " Failed ▁ to ▁ setup ▁ folder " ) ; return " " ; } } return mFolder . getPath ( ) + ' / ' + imageName ; }
numixproject/com.numix.calculator | private boolean saveBitmap ( String fullPath , Bitmap bitmap ) { if ( fullPath == null || bitmap == null ) return false ; boolean fileCreated = false ; boolean bitmapCompressed = false ; boolean streamClosed = false ; File imageFile = new File ( fullPath ) ; if ( imageFile . exists ( ) ) if ( ! imageFile . delete ( ) ) return false ; try { fileCreated = imageFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } FileOutputStream out = null ; try { out = new FileOutputStream ( imageFile ) ; bitmapCompressed = bitmap . compress ( CompressFormat . PNG , 100 , out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; bitmapCompressed = false ; } finally { if ( out != null ) { try { out . flush ( ) ; out . close ( ) ; streamClosed = true ; } catch ( IOException e ) { e . printStackTrace ( ) ; streamClosed = false ; } } } return ( fileCreated && bitmapCompressed && streamClosed ) ; }
numixproject/com.numix.calculator | public int getInt ( String key , int defaultValue ) { return preferences . getInt ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public ArrayList < Integer > getListInt ( String key ) { String [ ] myList = TextUtils . split ( preferences . getString ( key , " " ) , " ‚ ‗ ‚ " ) ; ArrayList < String > arrayToList = new ArrayList < String > ( Arrays . asList ( myList ) ) ; ArrayList < Integer > newList = new ArrayList < Integer > ( ) ; for ( String item : arrayToList ) newList . add ( Integer . parseInt ( item ) ) ; return newList ; }
numixproject/com.numix.calculator | public long getLong ( String key , long defaultValue ) { return preferences . getLong ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public float getFloat ( String key , float defaultValue ) { return preferences . getFloat ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public double getDouble ( String key , double defaultValue ) { String number = getString ( key ) ; try { return Double . parseDouble ( number ) ; } catch ( NumberFormatException e ) { return defaultValue ; } }
numixproject/com.numix.calculator | public ArrayList < Double > getListDouble ( String key ) { String [ ] myList = TextUtils . split ( preferences . getString ( key , " " ) , " â € šâ € — â € š " ) ; ArrayList < String > arrayToList = new ArrayList < String > ( Arrays . asList ( myList ) ) ; ArrayList < Double > newList = new ArrayList < Double > ( ) ; for ( String item : arrayToList ) newList . add ( Double . parseDouble ( item ) ) ; return newList ; }
numixproject/com.numix.calculator | public String getString ( String key ) { return preferences . getString ( key , " " ) ; }
numixproject/com.numix.calculator | public ArrayList < String > getListString ( String key ) { return new ArrayList < String > ( Arrays . asList ( TextUtils . split ( preferences . getString ( key , " " ) , " ‚ ‗ ‚ " ) ) ) ; }
numixproject/com.numix.calculator | public boolean getBoolean ( String key , boolean defaultValue ) { return preferences . getBoolean ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public ArrayList < Boolean > getListBoolean ( String key ) { ArrayList < String > myList = getListString ( key ) ; ArrayList < Boolean > newList = new ArrayList < Boolean > ( ) ; for ( String item : myList ) { if ( item . equals ( " true " ) ) { newList . add ( true ) ; } else { newList . add ( false ) ; } } return newList ; }
numixproject/com.numix.calculator | public void putInt ( String key , int value ) { preferences . edit ( ) . putInt ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putListInt ( String key , ArrayList < Integer > intList ) { Integer [ ] myIntList = intList . toArray ( new Integer [ intList . size ( ) ] ) ; preferences . edit ( ) . putString ( key , TextUtils . join ( " ‚ ‗ ‚ " , myIntList ) ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putLong ( String key , long value ) { preferences . edit ( ) . putLong ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putFloat ( String key , float value ) { preferences . edit ( ) . putFloat ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putDouble ( String key , double value ) { putString ( key , String . valueOf ( value ) ) ; }
numixproject/com.numix.calculator | public void putListDouble ( String key , ArrayList < Double > doubleList ) { Double [ ] myDoubleList = doubleList . toArray ( new Double [ doubleList . size ( ) ] ) ; preferences . edit ( ) . putString ( key , TextUtils . join ( " â € šâ € — â € š " , myDoubleList ) ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putString ( String key , String value ) { preferences . edit ( ) . putString ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putListString ( String key , ArrayList < String > stringList ) { String [ ] myStringList = stringList . toArray ( new String [ stringList . size ( ) ] ) ; preferences . edit ( ) . putString ( key , TextUtils . join ( " ‚ ‗ ‚ " , myStringList ) ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putBoolean ( String key , boolean value ) { preferences . edit ( ) . putBoolean ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putListBoolean ( String key , ArrayList < Boolean > boolList ) { ArrayList < String > newList = new ArrayList < String > ( ) ; for ( Boolean item : boolList ) { if ( item ) { newList . add ( " true " ) ; } else { newList . add ( " false " ) ; } } putListString ( key , newList ) ; }
numixproject/com.numix.calculator | public void remove ( String key ) { preferences . edit ( ) . remove ( key ) . apply ( ) ; }
numixproject/com.numix.calculator | public boolean deleteImage ( String path ) { return new File ( path ) . delete ( ) ; }
numixproject/com.numix.calculator | public void clear ( ) { preferences . edit ( ) . clear ( ) . apply ( ) ; }
numixproject/com.numix.calculator | public Map < String , ? > getAll ( ) { return preferences . getAll ( ) ; }
numixproject/com.numix.calculator | public void registerOnSharedPreferenceChangeListener ( SharedPreferences . OnSharedPreferenceChangeListener listener ) { preferences . registerOnSharedPreferenceChangeListener ( listener ) ; }
numixproject/com.numix.calculator | public void unregisterOnSharedPreferenceChangeListener ( SharedPreferences . OnSharedPreferenceChangeListener listener ) { preferences . unregisterOnSharedPreferenceChangeListener ( listener ) ; }
Khushmeet/LeaveApp-VIT | public Default_Detail_View_Fragment ( ) { }
Khushmeet/LeaveApp-VIT | @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View rootView = inflater . inflate ( R . layout . default_detail_view , container , false ) ; return rootView ; }
nkolban/jpigpio | MyListener ( int userGpio , int edge ) { super ( userGpio , edge ) ; }
nkolban/jpigpio | @ Override public void alert ( int gpio , int level , long tick ) { this . count ++ ; System . out . println ( " MyListener ▁ # " + count + " ▁ GPIO = " + gpio ) ; }
nkolban/jpigpio | public void run ( ) { String host = " pigpiod - host " ; int gpio1 = 23 ; int gpio2 = 24 ; int gpio3 = 25 ; long startTime = System . currentTimeMillis ( ) ; try { JPigpio pigpio = new PigpioSocket ( host , 8888 ) ; pigpio . gpioInitialize ( ) ; pigpio . addCallback ( new MyListener ( gpio1 , JPigpio . PI_RISING_EDGE ) ) ; System . out . println ( " Listening ▁ for ▁ changes ▁ on ▁ GPIO ▁ " + gpio1 ) ; pigpio . addCallback ( new MyListener ( gpio2 , JPigpio . PI_FALLING_EDGE ) ) ; System . out . println ( " Listening ▁ for ▁ changes ▁ on ▁ GPIO ▁ " + gpio2 ) ; pigpio . gpioSetAlertFunc ( gpio3 , ( int gpio , int level , long tick ) -> { System . out . println ( " ALERT ▁ Received : ▁ ▁ gpio = " + gpio + " ▁ ▁ level = " + Integer . toBinaryString ( level ) + " ▁ ▁ tick = " + tick ) ; } ) ; System . out . println ( " Waiting ▁ 20s ▁ for ▁ incoming ▁ notifications " ) ; while ( System . currentTimeMillis ( ) - startTime < 20000 ) { Thread . sleep ( 100 ) ; } System . out . println ( " Finished . " ) ; pigpio . gpioTerminate ( ) ; } catch ( PigpioException | InterruptedException e ) { e . printStackTrace ( ) ; } }
ChallenHB/droolsjbpm-tools | public BPMNWorkItemNodeFigure ( ) { setSize ( 80 , 48 ) ; }
ChallenHB/droolsjbpm-tools | protected void customizeFigure ( ) { rectangle = new RoundedRectangle ( ) ; rectangle . setCornerDimensions ( new Dimension ( 25 , 25 ) ) ; add ( rectangle , 0 ) ; rectangle . setBounds ( getBounds ( ) ) ; setSelected ( false ) ; }
ChallenHB/droolsjbpm-tools | public void setBounds ( Rectangle rectangle ) { super . setBounds ( rectangle ) ; this . rectangle . setBounds ( rectangle ) ; }
ChallenHB/droolsjbpm-tools | public void setSelected ( boolean b ) { super . setSelected ( b ) ; rectangle . setLineWidth ( b ? 3 : 1 ) ; repaint ( ) ; }
o3project/openflowj-otn | private OFInstructionIdGotoTableVer14 ( ) { }
o3project/openflowj-otn | @ Override public OFInstructionType getType ( ) { return OFInstructionType . GOTO_TABLE ; }
o3project/openflowj-otn | @ Override public OFVersion getVersion ( ) { return OFVersion . OF_14 ; }
o3project/openflowj-otn | public OFInstructionIdGotoTable . Builder createBuilder ( ) { throw new UnsupportedOperationException ( " OFInstructionIdGotoTableVer14 ▁ has ▁ no ▁ mutable ▁ properties ▁ - - ▁ builder ▁ unneeded " ) ; }
o3project/openflowj-otn | @ Override public OFInstructionIdGotoTable readFrom ( ChannelBuffer bb ) throws OFParseError { int start = bb . readerIndex ( ) ; short type = bb . readShort ( ) ; if ( type != ( short ) 0x1 ) throw new OFParseError ( " Wrong ▁ type : ▁ Expected = OFInstructionType . GOTO _ TABLE ( 1 ) , ▁ got = " + type ) ; int length = U16 . f ( bb . readShort ( ) ) ; if ( length != 4 ) throw new OFParseError ( " Wrong ▁ length : ▁ Expected = 4(4 ) , ▁ got = " + length ) ; if ( bb . readableBytes ( ) + ( bb . readerIndex ( ) - start ) < length ) { bb . readerIndex ( start ) ; return null ; } if ( logger . isTraceEnabled ( ) ) logger . trace ( " readFrom ▁ - ▁ length = { } " , length ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( " readFrom ▁ - ▁ returning ▁ shared ▁ instance = { } " , INSTANCE ) ; return INSTANCE ; }
o3project/openflowj-otn | public void putTo ( PrimitiveSink sink ) { FUNNEL . funnel ( this , sink ) ; }
o3project/openflowj-otn | @ Override public void funnel ( OFInstructionIdGotoTableVer14 message , PrimitiveSink sink ) { sink . putShort ( ( short ) 0x1 ) ; sink . putShort ( ( short ) 0x4 ) ; }
o3project/openflowj-otn | public void writeTo ( ChannelBuffer bb ) { WRITER . write ( bb , this ) ; }
o3project/openflowj-otn | @ Override public void write ( ChannelBuffer bb , OFInstructionIdGotoTableVer14 message ) { bb . writeShort ( ( short ) 0x1 ) ; bb . writeShort ( ( short ) 0x4 ) ; }
o3project/openflowj-otn | @ Override public String toString ( ) { StringBuilder b = new StringBuilder ( " OFInstructionIdGotoTableVer14 ( " ) ; b . append ( " ) " ) ; return b . toString ( ) ; }
o3project/openflowj-otn | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; return true ; }
o3project/openflowj-otn | @ Override public int hashCode ( ) { int result = 1 ; return result ; }
detnavillus/modular-informatic-designs | public void setGeoFormat ( String geoFormat ) { this . geoFormat = geoFormat ; }
detnavillus/modular-informatic-designs | public void setLatitudeProperty ( String latitudeProperty ) { this . latitudeProperty = latitudeProperty ; }
detnavillus/modular-informatic-designs | public void setLongitudeProperty ( String longitudeProperty ) { this . longitudeProperty = longitudeProperty ; }
detnavillus/modular-informatic-designs | public void setGeoLocationProperty ( String geoLocationProperty ) { this . geoLocationProperty = geoLocationProperty ; }
detnavillus/modular-informatic-designs | @ Override public IProperty transform ( IProperty input ) throws PropertyTransformException { LOG . info ( " transform ▁ ▁ val : ▁ " + input . getValue ( ) + " ▁ class : ▁ " + input . getClass ( ) . getName ( ) ) ; try { if ( input instanceof DataObject ) { if ( latitudeProperty == null || longitudeProperty == null || geoLocationProperty == null ) { throw new PropertyTransformException ( " Cannot ▁ transform ▁ DataObject ▁ - ▁ need ▁ lat , lon ▁ and ▁ geoloc ▁ properties ▁ defined ! " ) ; } DataObject dobj = ( DataObject ) input ; IProperty latProp = dobj . getProperty ( latitudeProperty ) ; IProperty lonProp = dobj . getProperty ( longitudeProperty ) ; if ( latProp instanceof IQuantity && lonProp instanceof IQuantity ) { GeographicLocation geoLoc = new GeographicLocation ( ( IQuantity ) latProp , ( IQuantity ) lonProp ) ; geoLoc . setName ( geoLocationProperty ) ; dobj . setProperty ( geoLoc ) ; } else { throw new PropertyTransformException ( " latitude ▁ and ▁ longitude ▁ must ▁ be ▁ quantities ! " ) ; } } else { GeographicLocation geoProp = new GeographicLocation ( ) ; geoProp . setValue ( input . getValue ( ) , geoFormat ) ; geoProp . setName ( input . getName ( ) ) ; return geoProp ; } } catch ( PropertyValidationException pve ) { throw new PropertyTransformException ( pve . getMessage ( ) ) ; } return input ; }
detnavillus/modular-informatic-designs | @ Override public IPropertyHolder transformPropertyHolder ( IPropertyHolder input ) throws PropertyTransformException { if ( latitudeProperty != null && longitudeProperty != null ) { IProperty latProp = input . getProperty ( latitudeProperty ) ; IProperty lonProp = input . getProperty ( longitudeProperty ) ; if ( latProp instanceof IQuantity && lonProp instanceof IQuantity ) { GeographicLocation geoLoc = new GeographicLocation ( ( IQuantity ) latProp , ( IQuantity ) lonProp ) ; geoLoc . setName ( geoLocationProperty ) ; input . setProperty ( geoLoc ) ; } else { throw new PropertyTransformException ( " latitude ▁ and ▁ longitude ▁ must ▁ be ▁ quantities ! " ) ; } } return input ; }
detnavillus/modular-informatic-designs | @ Override public void startTransform ( IProperty input , IPropertyTransformListener transformListener ) throws PropertyTransformException { }
hsaputra/cdap | public DefaultDataWriter ( WorkerContext context , DatasetContext dsContext ) { this . context = context ; this . dsContext = dsContext ; }
hsaputra/cdap | @ Override public < T extends Dataset > T getDataset ( final String name ) throws DatasetInstantiationException { try { return LogContext . runWithoutLogging ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { return dsContext . getDataset ( name ) ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , DatasetInstantiationException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public < T extends Dataset > T getDataset ( final String name , final Map < String , String > arguments ) throws DatasetInstantiationException { try { return LogContext . runWithoutLogging ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { return dsContext . getDataset ( name , arguments ) ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , DatasetInstantiationException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final String data ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final String data , final Map < String , String > headers ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data , headers ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final ByteBuffer data ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final StreamEventData data ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void writeFile ( final String stream , final File file , final String contentType ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . writeFile ( stream , file , contentType ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public StreamBatchWriter createBatchWriter ( final String stream , final String contentType ) throws IOException { try { return LogContext . runWithoutLogging ( new Callable < StreamBatchWriter > ( ) { @ Override public StreamBatchWriter call ( ) throws Exception { return context . createBatchWriter ( stream , contentType ) ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
rajeevanv89/developer-studio | public EnrichMediatorOutputConnectorItemSemanticEditPolicy ( ) { super ( EsbElementTypes . EnrichMediatorOutputConnector_3037 ) ; }
rajeevanv89/developer-studio | protected Command getDestroyElementCommand ( DestroyElementRequest req ) { View view = ( View ) getHost ( ) . getModel ( ) ; CompositeTransactionalCommand cmd = new CompositeTransactionalCommand ( getEditingDomain ( ) , null ) ; cmd . setTransactionNestingEnabled ( false ) ; for ( Iterator < ? > it = view . getSourceEdges ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Edge outgoingLink = ( Edge ) it . next ( ) ; if ( EsbVisualIDRegistry . getVisualID ( outgoingLink ) == EsbLinkEditPart . VISUAL_ID ) { DestroyElementRequest r = new DestroyElementRequest ( outgoingLink . getElement ( ) , false ) ; cmd . add ( new DestroyElementCommand ( r ) ) ; cmd . add ( new DeleteCommand ( getEditingDomain ( ) , outgoingLink ) ) ; continue ; } } EAnnotation annotation = view . getEAnnotation ( " Shortcut " ) ; if ( annotation == null ) { addDestroyShortcutsCommand ( cmd , view ) ; cmd . add ( new DestroyElementCommand ( req ) ) ; } else { cmd . add ( new DeleteCommand ( getEditingDomain ( ) , view ) ) ; } return getGEFWrapper ( cmd . reduce ( ) ) ; }
rajeevanv89/developer-studio | protected Command getCreateRelationshipCommand ( CreateRelationshipRequest req ) { Command command = req . getTarget ( ) == null ? getStartCreateRelationshipCommand ( req ) : getCompleteCreateRelationshipCommand ( req ) ; return command != null ? command : super . getCreateRelationshipCommand ( req ) ; }
rajeevanv89/developer-studio | protected Command getStartCreateRelationshipCommand ( CreateRelationshipRequest req ) { if ( EsbElementTypes . EsbLink_4001 == req . getElementType ( ) ) { return getGEFWrapper ( new EsbLinkCreateCommand ( req , req . getSource ( ) , req . getTarget ( ) ) ) ; } return null ; }
rajeevanv89/developer-studio | protected Command getCompleteCreateRelationshipCommand ( CreateRelationshipRequest req ) { if ( EsbElementTypes . EsbLink_4001 == req . getElementType ( ) ) { return null ; } return null ; }
rajeevanv89/developer-studio | protected Command getReorientRelationshipCommand ( ReorientRelationshipRequest req ) { switch ( getVisualID ( req ) ) { case EsbLinkEditPart . VISUAL_ID : return getGEFWrapper ( new EsbLinkReorientCommand ( req ) ) ; } return super . getReorientRelationshipCommand ( req ) ; }
gems-uff/oceano | public void setup ( ) { mapAttributeIndices = new HashMap < String , Integer > ( ) ; int indice = 1 ; attributeNames = new String [ QMOOD . QMOOD_QUALITY_ATTRIBUTES . length + 1 ] ; for ( String qaName : QMOOD . QMOOD_QUALITY_ATTRIBUTES ) { attributeNames [ indice ] = qaName ; mapAttributeIndices . put ( qaName , indice ++ ) ; } }
gems-uff/oceano | private void updateAttributeIndiceMap ( DataMiningResult currentDataMiningResult ) { mapAttributeIndices = new HashMap < String , Integer > ( ) ; int indice = 1 ; List < String > attributes = getAttributes ( currentDataMiningResult ) ; Collections . sort ( attributes ) ; for ( String attributeName : attributes ) { mapAttributeIndices . put ( attributeName , indice ++ ) ; } attributeNames = new String [ mapAttributeIndices . keySet ( ) . size ( ) + 1 ] ; for ( String attributeName : mapAttributeIndices . keySet ( ) ) { MetricManager mm = ( MetricManager ) MetricManagerFactory . getInstance ( ) . getMetricByName ( attributeName ) ; System . out . println ( " mapAttributeIndices . get ( attributeName ) ▁ = ▁ " + mapAttributeIndices . get ( attributeName ) ) ; System . out . println ( " mm . getMetric ( ) . getAcronym ( ) ▁ = ▁ " + mm . getMetric ( ) . getAcronym ( ) ) ; attributeNames [ mapAttributeIndices . get ( attributeName ) ] = mm . getMetric ( ) . getAcronym ( ) ; } TABLE_SIZE = attributeNames . length ; }
gems-uff/oceano | public synchronized Behavior [ ] [ ] buildTable ( DataMiningResult currentDataMiningResult ) { updateAttributeIndiceMap ( currentDataMiningResult ) ; Behavior [ ] [ ] behaviorTable = createDefaultTable ( currentDataMiningResult ) ; final String ruleMetricName = currentDataMiningResult . getRuleMetricName ( ) ; for ( DataMiningPattern dataMiningPattern : currentDataMiningResult . getDataMiningPatterns ( ) ) { if ( dataMiningPattern . getSize ( ) != 2 ) { continue ; } final String pattern = dataMiningPattern . getPattern ( ) ; if ( pattern . contains ( " project - revision " ) || pattern . contains ( " rdate " ) || pattern . contains ( " rcommiter " ) || pattern . contains ( " # files " ) || pattern . contains ( " rday " ) || pattern . contains ( " rhour " ) || pattern . contains ( " rcompile " ) ) { continue ; } final String precedentAttribute = DataMiningPattern . getAttribute ( dataMiningPattern . getPrecedent ( ) ) ; final String consequentAttribute = DataMiningPattern . getAttribute ( dataMiningPattern . getConsequent ( ) ) ; final Integer precedentIndice = mapAttributeIndices . get ( precedentAttribute ) ; final Integer consequentIndice = mapAttributeIndices . get ( consequentAttribute ) ; if ( precedentIndice == null || consequentIndice == null ) { continue ; } final Behavior behavior = behaviorTable [ precedentIndice ] [ consequentIndice ] ; behavior . getRules ( ) . add ( dataMiningPattern ) ; behavior . setValue ( verifyBehaviors ( behavior . getRules ( ) ) ) ; final Double highestValue = behavior . getHighestConfidence ( ) ; final Double actualValue = getRuleMetric ( ruleMetricName , dataMiningPattern ) ; if ( highestValue == null || actualValue > highestValue ) { behavior . setHighestConfidence ( actualValue ) ; } } return behaviorTable ; }
gems-uff/oceano | private Behavior [ ] [ ] createDefaultTable ( DataMiningResult dataMiningResult ) { Behavior [ ] [ ] behaviorTable = new Behavior [ TABLE_SIZE ] [ TABLE_SIZE ] ; for ( int i = 0 ; i < behaviorTable . length ; i ++ ) { for ( int j = 0 ; j < behaviorTable [ i ] . length ; j ++ ) { if ( j == 0 && i == 0 ) { behaviorTable [ i ] [ j ] = new Behavior ( dataMiningResult ) ; } else if ( j == 0 ) { behaviorTable [ i ] [ j ] = new Behavior ( attributeNames [ i ] , dataMiningResult ) ; } else if ( i == 0 ) { behaviorTable [ i ] [ j ] = new Behavior ( attributeNames [ j ] , dataMiningResult ) ; } else { behaviorTable [ i ] [ j ] = new Behavior ( dataMiningResult ) ; } } } return behaviorTable ; }
gems-uff/oceano | private String verifyBehavior ( String oneValue , String otherValue ) { if ( oneValue . equals ( otherValue ) ) { return SYMBOL_PROPORTIONAL_BEHAVIOR ; } else { return SYMBOL_OPOSITE_BEHAVIOR ; } }
gems-uff/oceano | private String verifyBehaviors ( List < DataMiningPattern > rules ) { boolean proportionalBehavior = false ; boolean opositeBehavior = false ; for ( DataMiningPattern rule : rules ) { String behavior = verifyBehavior ( DataMiningPattern . getValue ( rule . getPrecedent ( ) ) , DataMiningPattern . getValue ( rule . getConsequent ( ) ) ) ; if ( behavior . equals ( SYMBOL_PROPORTIONAL_BEHAVIOR ) ) { proportionalBehavior = true ; } else if ( behavior . equals ( SYMBOL_OPOSITE_BEHAVIOR ) ) { opositeBehavior = true ; } } if ( opositeBehavior && proportionalBehavior ) { return SYMBOL_CONFLICTANT_BEHAVIOR ; } else if ( opositeBehavior ) { return SYMBOL_OPOSITE_BEHAVIOR ; } else { return SYMBOL_PROPORTIONAL_BEHAVIOR ; } }
gems-uff/oceano | private Double getRuleMetric ( String ruleMetricName , DataMiningPattern dataMiningPattern ) { if ( ruleMetricName . equals ( " Confidence " ) ) { return dataMiningPattern . getConfidence ( ) ; } if ( ruleMetricName . equals ( " Lift " ) ) { return dataMiningPattern . getLift ( ) ; } if ( ruleMetricName . equals ( " Leverage " ) ) { return dataMiningPattern . getLeverage ( ) ; } if ( ruleMetricName . equals ( " Conviction " ) ) { return dataMiningPattern . getConviction ( ) ; } return null ; }
gems-uff/oceano | private List < String > getAttributes ( DataMiningResult dataMiningResult ) { List < String > returningAttributes = new LinkedList < String > ( ) ; final String arff = dataMiningResult . getArff ( ) ; for ( String line : arff . substring ( 0 , arff . indexOf ( " @ DATA " ) ) . split ( " \n " ) ) { if ( line . startsWith ( " @ ATTRIBUTE " ) ) { if ( line . contains ( " project - revision " ) || line . contains ( " rdate " ) || line . contains ( " rcommiter " ) || line . contains ( " # files " ) || line . contains ( " rday " ) || line . contains ( " rhour " ) || line . contains ( " rRound " ) || line . contains ( " rcompile " ) ) { continue ; } String attributeName ; if ( line . contains ( " \" " ) ) { attributeName = line . substring ( line . indexOf ( " \" " ) + 1 ) ; attributeName = attributeName . substring ( 0 , attributeName . indexOf ( " \" " ) ) ; } else { attributeName = line . split ( " ▁ " ) [ 1 ] ; } attributeName = attributeName . substring ( " dAvg - " . length ( ) ) ; returningAttributes . add ( attributeName ) ; } } return returningAttributes ; }
FelixGV/azkaban2 | protected AbstractJob ( String id , Logger log ) { _id = id ; _log = log ; _progress = 0.0 ; }
FelixGV/azkaban2 | public String getId ( ) { return _id ; }
FelixGV/azkaban2 | public double getProgress ( ) throws Exception { return _progress ; }
FelixGV/azkaban2 | public void setProgress ( double progress ) { this . _progress = progress ; }
FelixGV/azkaban2 | public void cancel ( ) throws Exception { throw new RuntimeException ( " Job ▁ " + _id + " ▁ does ▁ not ▁ support ▁ cancellation ! " ) ; }
FelixGV/azkaban2 | public Logger getLog ( ) { return this . _log ; }
FelixGV/azkaban2 | public void debug ( String message ) { this . _log . debug ( message ) ; }
FelixGV/azkaban2 | public void debug ( String message , Throwable t ) { this . _log . debug ( message , t ) ; }
FelixGV/azkaban2 | public void info ( String message ) { this . _log . info ( message ) ; }
FelixGV/azkaban2 | public void info ( String message , Throwable t ) { this . _log . info ( message , t ) ; }
FelixGV/azkaban2 | public void warn ( String message ) { this . _log . warn ( message ) ; }
FelixGV/azkaban2 | public void warn ( String message , Throwable t ) { this . _log . warn ( message , t ) ; }
FelixGV/azkaban2 | public void error ( String message ) { this . _log . error ( message ) ; }
FelixGV/azkaban2 | public void error ( String message , Throwable t ) { this . _log . error ( message , t ) ; }
FelixGV/azkaban2 | public Props getJobGeneratedProperties ( ) { return new Props ( ) ; }
FelixGV/azkaban2 | public boolean isCanceled ( ) { return false ; }
goodwinnk/intellij-community | public LiveTemplateBuilder ( ) { this ( false , Registry . intValue ( " emmet . segments . limit " ) ) ; }
goodwinnk/intellij-community | public LiveTemplateBuilder ( boolean addEndVariableAtTheEndOfTemplate , int segmentLimit ) { mySegmentLimit = segmentLimit ; myAddEndVariableAtTheEndOfTemplate = addEndVariableAtTheEndOfTemplate ; }
goodwinnk/intellij-community | public void setIsToReformat ( boolean isToReformat ) { myIsToReformat = isToReformat ; }
goodwinnk/intellij-community | public CharSequence getText ( ) { return myText ; }
goodwinnk/intellij-community | private VarOccurence ( String name , int offset ) { myName = name ; myOffset = offset ; }
goodwinnk/intellij-community | public boolean findVarOccurence ( String name ) { for ( VarOccurence occurence : myVariableOccurrences ) { if ( occurence . myName . equals ( name ) ) { return true ; } } return false ; }
goodwinnk/intellij-community | @ NotNull public TemplateImpl buildTemplate ( ) { List < Variable > variables = getListWithLimit ( myVariables ) ; if ( ! findVarOccurence ( TemplateImpl . END ) ) { if ( myLastEndVarName == null ) { for ( Variable variable : variables ) { if ( isEndVariable ( variable . getName ( ) ) ) { myLastEndVarName = variable . getName ( ) ; break ; } } } if ( myLastEndVarName != null ) { int endOffset = - 1 ; if ( myAddEndVariableAtTheEndOfTemplate ) { endOffset = myText . length ( ) ; } else { Iterator < VarOccurence > it = myVariableOccurrences . iterator ( ) ; while ( it . hasNext ( ) ) { VarOccurence occurence = it . next ( ) ; if ( occurence . myName . equals ( myLastEndVarName ) ) { endOffset = occurence . myOffset ; break ; } } if ( endOffset >= 0 ) { for ( Iterator < Variable > it1 = variables . iterator ( ) ; it1 . hasNext ( ) ; ) { Variable variable = it1 . next ( ) ; if ( myLastEndVarName . equals ( variable . getName ( ) ) && variable . isAlwaysStopAt ( ) ) { it . remove ( ) ; it1 . remove ( ) ; } } } } if ( endOffset >= 0 ) { myVariableOccurrences . add ( new VarOccurence ( TemplateImpl . END , endOffset ) ) ; } } } TemplateImpl template = new TemplateImpl ( " " , " " ) ; for ( Variable variable : variables ) { template . addVariable ( variable . getName ( ) , variable . getExpressionString ( ) , variable . getDefaultValueString ( ) , variable . isAlwaysStopAt ( ) ) ; } List < VarOccurence > variableOccurrences = getListWithLimit ( myVariableOccurrences ) ; Collections . sort ( variableOccurrences , Comparator . comparingInt ( o -> o . myOffset ) ) ; int last = 0 ; for ( VarOccurence occurence : variableOccurrences ) { template . addTextSegment ( myText . substring ( last , occurence . myOffset ) ) ; template . addVariableSegment ( occurence . myName ) ; last = occurence . myOffset ; } template . addTextSegment ( myText . substring ( last ) ) ; template . setToReformat ( myIsToReformat ) ; return template ; }
goodwinnk/intellij-community | private < T > List < T > getListWithLimit ( List < T > list ) { if ( ApplicationManager . getApplication ( ) . isUnitTestMode ( ) ) { return list ; } if ( mySegmentLimit == 0 ) { return Collections . emptyList ( ) ; } if ( mySegmentLimit > 0 && list . size ( ) > mySegmentLimit ) { warnTooManySegments ( list . size ( ) ) ; return list . subList ( 0 , Math . min ( list . size ( ) , mySegmentLimit ) ) ; } return list ; }
goodwinnk/intellij-community | public void insertText ( int offset , String text , boolean disableEndVariable ) { if ( disableEndVariable ) { String varName = null ; for ( VarOccurence occurence : myVariableOccurrences ) { if ( ! isEndVariable ( occurence . myName ) ) { continue ; } if ( occurence . myOffset == offset ) { varName = occurence . myName ; break ; } } if ( varName != null ) { for ( Variable variable : myVariables ) { if ( varName . equals ( variable . getName ( ) ) ) { variable . setAlwaysStopAt ( false ) ; variable . setDefaultValueString ( " \" \" " ) ; break ; } } } } int delta = text . length ( ) ; for ( VarOccurence occurence : myVariableOccurrences ) { if ( occurence . myOffset > offset || ! disableEndVariable && occurence . myOffset == offset ) { occurence . myOffset += delta ; } } myText . insert ( offset , text ) ; updateMarkers ( offset , text ) ; }
goodwinnk/intellij-community | public int length ( ) { return myText . length ( ) ; }
goodwinnk/intellij-community | private void updateMarkers ( int offset , String text ) { for ( Marker marker : myMarkers ) { if ( offset < marker . getStartOffset ( ) ) { marker . myStartOffset += text . length ( ) ; } else if ( offset <= marker . getEndOffset ( ) ) { marker . myEndOffset += text . length ( ) ; } } }
goodwinnk/intellij-community | private String generateUniqueVarName ( Set < String > existingNames , boolean end ) { String prefix = end ? END_PREFIX : " VAR " ; int i = 0 ; while ( myVarNames . contains ( prefix + i ) || existingNames . contains ( prefix + i ) ) { i ++ ; } return prefix + i ; }
goodwinnk/intellij-community | public int insertTemplate ( int offset , TemplateImpl template , Map < String , String > predefinedVarValues ) { myIsToReformat = myText . length ( ) > 0 || template . isToReformat ( ) ; removeEndVarAtOffset ( offset ) ; String text = template . getTemplateText ( ) ; insertText ( offset , text , false ) ; Set < String > oldVarNames = new HashSet < > ( ) ; for ( int i = 0 ; i < template . getVariableCount ( ) ; i ++ ) { String varName = template . getVariableNameAt ( i ) ; oldVarNames . add ( varName ) ; } Map < String , String > newVarNames = new HashMap < > ( ) ; for ( int i = 0 ; i < template . getVariableCount ( ) ; i ++ ) { String varName = template . getVariableNameAt ( i ) ; if ( ! TemplateImpl . INTERNAL_VARS_SET . contains ( varName ) ) { if ( predefinedVarValues != null && predefinedVarValues . containsKey ( varName ) ) { continue ; } String newVarName ; if ( myVarNames . contains ( varName ) ) { oldVarNames . remove ( varName ) ; newVarName = generateUniqueVarName ( oldVarNames , isEndVariable ( varName ) ) ; newVarNames . put ( varName , newVarName ) ; if ( varName . equals ( myLastEndVarName ) ) { myLastEndVarName = newVarName ; } } else { newVarName = varName ; } Variable var = new Variable ( newVarName , template . getExpressionStringAt ( i ) , template . getDefaultValueStringAt ( i ) , template . isAlwaysStopAt ( i ) ) ; if ( mySegmentLimit >= 0 && myVariables . size ( ) >= mySegmentLimit ) { if ( mySegmentLimit > 0 ) { warnTooManySegments ( myVariables . size ( ) ) ; } break ; } myVariables . add ( var ) ; myVarNames . add ( newVarName ) ; } } int end = - 1 ; for ( int i = 0 ; i < template . getSegmentsCount ( ) ; i ++ ) { String segmentName = template . getSegmentName ( i ) ; int localOffset = template . getSegmentOffset ( i ) ; if ( TemplateImpl . END . equals ( segmentName ) ) { end = offset + localOffset ; } else { if ( predefinedVarValues != null && predefinedVarValues . containsKey ( segmentName ) ) { String value = predefinedVarValues . get ( segmentName ) ; insertText ( offset + localOffset , value , false ) ; offset += value . length ( ) ; continue ; } if ( newVarNames . containsKey ( segmentName ) ) { segmentName = newVarNames . get ( segmentName ) ; } myVariableOccurrences . add ( new VarOccurence ( segmentName , offset + localOffset ) ) ; } } int endOffset = end >= 0 ? end : offset + text . length ( ) ; if ( endOffset > 0 && endOffset != offset + text . length ( ) && endOffset < myText . length ( ) && ! hasVarAtOffset ( endOffset ) ) { myLastEndVarName = generateUniqueVarName ( myVarNames , true ) ; myVariables . add ( new Variable ( myLastEndVarName , " " , " " , true ) ) ; myVarNames . add ( myLastEndVarName ) ; myVariableOccurrences . add ( new VarOccurence ( myLastEndVarName , endOffset ) ) ; } return endOffset ; }
goodwinnk/intellij-community | private void warnTooManySegments ( int size ) { LOGGER . warn ( " Too ▁ many ▁ ( " + size + " ▁ with ▁ the ▁ limit ▁ of ▁ " + mySegmentLimit + " ) ▁ segments ▁ were ▁ requested " + " ▁ for ▁ the ▁ template ▁ with ▁ the ▁ text : ▁ " + myText ) ; }
goodwinnk/intellij-community | private void removeEndVarAtOffset ( int offset ) { for ( Iterator < VarOccurence > it = myVariableOccurrences . iterator ( ) ; it . hasNext ( ) ; ) { VarOccurence occurence = it . next ( ) ; if ( ! isEndVariable ( occurence . myName ) ) { continue ; } if ( occurence . myOffset == offset ) { it . remove ( ) ; myVariables . removeIf ( variable -> occurence . myName . equals ( variable . getName ( ) ) ) ; } } }
goodwinnk/intellij-community | private boolean hasVarAtOffset ( int offset ) { boolean flag = false ; for ( VarOccurence occurence : myVariableOccurrences ) { if ( occurence . myOffset == offset ) { flag = true ; } } return flag ; }
goodwinnk/intellij-community | public Marker createMarker ( int offset ) { Marker marker = new Marker ( offset , offset ) ; myMarkers . add ( marker ) ; return marker ; }
goodwinnk/intellij-community | private Marker ( int startOffset , int endOffset ) { myStartOffset = startOffset ; myEndOffset = endOffset ; }
goodwinnk/intellij-community | public int getStartOffset ( ) { return myStartOffset ; }
goodwinnk/intellij-community | public int getEndOffset ( ) { return myEndOffset ; }
Niranjan-K/carbon-kernel | @ Override public void loadSecrets ( SecretRepositoryConfiguration secretRepositoryConfiguration ) throws SecureVaultException { logger . debug ( " Loading ▁ secrets ▁ to ▁ SecretRepository " ) ; Path secretPropertiesFilePath = Paths . get ( SecureVaultUtils . getSecretPropertiesFileLocation ( secretRepositoryConfiguration ) ) ; String resolvedFileContent = SecureVaultUtils . resolveFileToString ( secretPropertiesFilePath . toFile ( ) ) ; Properties secretsProperties = new Properties ( ) ; try { secretsProperties . load ( new StringReader ( resolvedFileContent ) ) ; } catch ( IOException e ) { throw new SecureVaultException ( " Failed ▁ to ▁ load ▁ secrets . properties ▁ file " ) ; } for ( Map . Entry < Object , Object > entry : secretsProperties . entrySet ( ) ) { String key = entry . getKey ( ) . toString ( ) . trim ( ) ; String value = entry . getValue ( ) . toString ( ) . trim ( ) ; char [ ] decryptedPassword ; String [ ] tokens = value . split ( SecureVaultConstants . SPACE ) ; if ( tokens . length != 2 ) { logger . error ( " Secret ▁ properties ▁ file ▁ contains ▁ an ▁ invalid ▁ entry ▁ at ▁ key ▁ : ▁ { } " , key ) ; continue ; } String updatedTokenValue = SecureVaultUtils . substituteVariables ( tokens [ 1 ] ) ; if ( SecureVaultConstants . CIPHER_TEXT . equals ( tokens [ 0 ] ) ) { byte [ ] base64Decoded = SecureVaultUtils . base64Decode ( SecureVaultUtils . toBytes ( updatedTokenValue ) ) ; decryptedPassword = SecureVaultUtils . toChars ( decrypt ( base64Decoded ) ) ; } else if ( SecureVaultConstants . PLAIN_TEXT . equals ( tokens [ 0 ] ) ) { decryptedPassword = updatedTokenValue . toCharArray ( ) ; } else { logger . error ( " Unknown ▁ prefix ▁ in ▁ secrets ▁ file " ) ; continue ; } secrets . put ( key , decryptedPassword ) ; } logger . debug ( " Secret ▁ repository ▁ loaded ▁ with ▁ ' { } ' ▁ secrets " , secrets . size ( ) ) ; }
Niranjan-K/carbon-kernel | @ Override public void persistSecrets ( SecretRepositoryConfiguration secretRepositoryConfiguration ) throws SecureVaultException { logger . debug ( " Persisting ▁ secrets ▁ to ▁ SecretRepository " ) ; Path secretPropertiesFilePath = Paths . get ( SecureVaultUtils . getSecretPropertiesFileLocation ( secretRepositoryConfiguration ) ) ; Properties secretsProperties = SecureVaultUtils . loadSecretFile ( secretPropertiesFilePath ) ; int count = 0 ; for ( Map . Entry < Object , Object > entry : secretsProperties . entrySet ( ) ) { String key = entry . getKey ( ) . toString ( ) . trim ( ) ; String value = entry . getValue ( ) . toString ( ) . trim ( ) ; byte [ ] encryptedPassword ; String [ ] tokens = value . split ( SecureVaultConstants . SPACE ) ; if ( tokens . length != 2 ) { logger . error ( " Secret ▁ properties ▁ file ▁ contains ▁ an ▁ invalid ▁ entry ▁ at ▁ key ▁ : ▁ { } " , key ) ; continue ; } if ( SecureVaultConstants . PLAIN_TEXT . equals ( tokens [ 0 ] ) ) { encryptedPassword = SecureVaultUtils . base64Encode ( encrypt ( SecureVaultUtils . toBytes ( tokens [ 1 ] . trim ( ) ) ) ) ; secretsProperties . setProperty ( key , SecureVaultConstants . CIPHER_TEXT + " ▁ " + new String ( SecureVaultUtils . toChars ( encryptedPassword ) ) ) ; count ++ ; } } SecureVaultUtils . updateSecretFile ( secretPropertiesFilePath , secretsProperties ) ; logger . debug ( " Secrets ▁ file ▁ updated ▁ with ▁ ' { } ' ▁ new ▁ encrypted ▁ secrets " , count ) ; }
Niranjan-K/carbon-kernel | @ Override public char [ ] resolve ( String alias ) { char [ ] secret = secrets . get ( alias ) ; if ( secret != null && secret . length != 0 ) { return secret ; } return new char [ 0 ] ; }
jSquirrel/nutforms | @ Before public void setUp ( ) throws Exception { KieServices kieServices = KieServices . Factory . get ( ) ; KieContainer kieContainer = kieServices . getKieClasspathContainer ( ) ; kieSession = kieContainer . newStatelessKieSession ( " accountsession " ) ; kieSession . setGlobal ( " status " , " verified " ) ; }
jSquirrel/nutforms | @ Test public void inspectUserEntityRules ( ) { Collection < KiePackage > kiePackages = kieSession . getKieBase ( ) . getKiePackages ( ) ; for ( KiePackage kiePackage : kiePackages ) { if ( kiePackage . getRules ( ) . size ( ) > 0 ) { System . out . println ( kiePackage . getRules ( ) . size ( ) + " ▁ rule ( s ) ▁ found ▁ in ▁ package ▁ " + kiePackage . getName ( ) + " : " ) ; for ( Rule rule : kiePackage . getRules ( ) ) { inspectRule ( ( RuleImpl ) rule ) ; System . out . println ( ) ; } } } }
jSquirrel/nutforms | @ Test public void testInspectRule ( ) { Inspector inspector = new Inspector ( ) ; Map < String , Set < cz . cvut . fel . nutforms . rules . metamodel . Rule > > rules = inspector . inspectBase ( kieSession . getKieBase ( ) ) ; }
jSquirrel/nutforms | private void inspectRule ( RuleImpl rule ) { System . out . println ( " \tName : ▁ " ) ; System . out . println ( " \t\t " + rule . getName ( ) ) ; System . out . println ( " \tDeclarations : ▁ " ) ; for ( String s : rule . getDeclarations ( ) . keySet ( ) ) { System . out . println ( " \t\t " + s + " ▁ [ " + rule . getDeclaration ( s ) . getBoxedTypeName ( ) + " ] " ) ; } System . out . println ( " \tConstraints : ▁ " ) ; for ( RuleConditionElement ruleConditionElement : rule . getLhs ( ) . getChildren ( ) ) { for ( Constraint constraint : ( ( Pattern ) ruleConditionElement ) . getConstraints ( ) ) { System . out . println ( " \t\t " + " Object ▁ type : ▁ " + ( ( Pattern ) ruleConditionElement ) . getObjectType ( ) ) ; System . out . println ( " \t\t " + ( ( MvelConstraint ) constraint ) . getExpression ( ) ) ; } } if ( rule . getConsequence ( ) != null ) { System . out . println ( " \tConsequence : ▁ " ) ; try { Field unit = rule . getConsequence ( ) . getClass ( ) . getDeclaredField ( " unit " ) ; unit . setAccessible ( true ) ; System . out . println ( " \t\t " + ( ( MVELCompilationUnit ) unit . get ( rule . getConsequence ( ) ) ) . getExpression ( ) ) ; } catch ( NoSuchFieldException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } }
SpongePowered/SpongeAPI | default BlockEntity rotate ( final Supplier < ? extends Rotation > rotation ) { return this . rotate ( rotation . get ( ) ) ; }
SpongePowered/SpongeAPI | default BlockEntity mirror ( final Supplier < ? extends Mirror > mirror ) { return this . mirror ( mirror . get ( ) ) ; }
CMPUT301F17T13/cat-is-a-dog | public HabitEventRepository ( String userId ) { mHabitEventsRef = FirebaseDatabase . getInstance ( ) . getReference ( " events / " + userId ) ; this . userId = userId ; mGeoFireRef = FirebaseDatabase . getInstance ( ) . getReference ( " events _ geofire / " ) ; geoFire = new GeoFire ( mGeoFireRef ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void add ( HabitEvent habitEvent ) { HabitEventDataModel eventModel = new HabitEventDataModel ( habitEvent ) ; DatabaseReference newEvent = mHabitEventsRef . push ( ) ; eventModel . setKey ( newEvent . getKey ( ) ) ; newEvent . setValue ( eventModel , - 1 * habitEvent . getEventDate ( ) . getMillis ( ) , null ) ; geoFire . setLocation ( userId + ' @ ' + newEvent . getKey ( ) , new GeoLocation ( habitEvent . getLatitude ( ) , habitEvent . getLongitude ( ) ) ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void update ( String key , HabitEvent habitEvent ) { HabitEventDataModel eventModel = new HabitEventDataModel ( habitEvent ) ; mHabitEventsRef . child ( key ) . getRef ( ) . setValue ( eventModel , null ) ; geoFire . setLocation ( userId + ' @ ' + habitEvent . getKey ( ) , new GeoLocation ( habitEvent . getLatitude ( ) , habitEvent . getLongitude ( ) ) ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void delete ( String key ) { mHabitEventsRef . child ( key ) . getRef ( ) . removeValue ( null ) ; geoFire . removeLocation ( userId + ' @ ' + key ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void get ( String key , final OnResultListener < HabitEvent > resultListener ) { mHabitEventsRef . child ( key ) . addListenerForSingleValueEvent ( new ValueEventListener ( ) { @ Override public void onDataChange ( DataSnapshot dataSnapshot ) { HabitEventDataModel model = dataSnapshot . getValue ( HabitEventDataModel . class ) ; if ( model != null ) { resultListener . onResult ( model . getHabitEvent ( ) ) ; } else { resultListener . onResult ( null ) ; } } @ Override public void onCancelled ( DatabaseError databaseError ) { } } ) ; }
changshan/graphdb-benchmarks | public LouvainMethod ( GraphDatabase < ? , ? , ? , ? > graphDatabase , int cacheSize , boolean isRandomized ) throws ExecutionException { this . graphDatabase = graphDatabase ; this . isRandomized = isRandomized ; initialize ( ) ; cache = new Cache ( graphDatabase , cacheSize ) ; }
changshan/graphdb-benchmarks | private void initialize ( ) { this . N = this . graphDatabase . getNodeCount ( ) ; this . graphWeightSum = this . graphDatabase . getGraphWeightSum ( ) / 2 ; this . communityWeights = new ArrayList < Double > ( this . N ) ; for ( int i = 0 ; i < this . N ; i ++ ) { this . communityWeights . add ( 0.0 ) ; } this . graphDatabase . initCommunityProperty ( ) ; }
changshan/graphdb-benchmarks | public void computeModularity ( ) throws ExecutionException { Random rand = new Random ( ) ; boolean someChange = true ; while ( someChange ) { someChange = false ; boolean localChange = true ; while ( localChange ) { localChange = false ; int start = 0 ; if ( this . isRandomized ) { start = Math . abs ( rand . nextInt ( ) ) % this . N ; } int step = 0 ; for ( int i = start ; step < this . N ; i = ( i + 1 ) % this . N ) { step ++ ; int bestCommunity = updateBestCommunity ( i ) ; if ( ( this . cache . getCommunity ( i ) != bestCommunity ) && ( this . communityUpdate ) ) { this . cache . moveNodeCommunity ( i , bestCommunity ) ; this . graphDatabase . moveNode ( i , bestCommunity ) ; double bestCommunityWeight = this . communityWeights . get ( bestCommunity ) ; bestCommunityWeight += cache . getNodeCommunityWeight ( i ) ; this . communityWeights . set ( bestCommunity , bestCommunityWeight ) ; localChange = true ; } this . communityUpdate = false ; } someChange = localChange || someChange ; } if ( someChange ) { zoomOut ( ) ; } } }
changshan/graphdb-benchmarks | private int updateBestCommunity ( int node ) throws ExecutionException { int bestCommunity = 0 ; double best = 0 ; Set < Integer > communities = this . cache . getCommunitiesConnectedToNodeCommunities ( node ) ; for ( int community : communities ) { double qValue = q ( node , community ) ; if ( qValue > best ) { best = qValue ; bestCommunity = community ; this . communityUpdate = true ; } } return bestCommunity ; }
changshan/graphdb-benchmarks | private double q ( int nodeCommunity , int community ) throws ExecutionException { double edgesInCommunity = this . cache . getEdgesInsideCommunity ( nodeCommunity , community ) ; double communityWeight = this . communityWeights . get ( community ) ; double nodeWeight = this . cache . getNodeCommunityWeight ( nodeCommunity ) ; double qValue = this . resolution * edgesInCommunity - ( nodeWeight * communityWeight ) / ( 2.0 * this . graphWeightSum ) ; int actualNodeCom = this . cache . getCommunity ( nodeCommunity ) ; int communitySize = this . cache . getCommunitySize ( community ) ; if ( ( actualNodeCom == community ) && ( communitySize > 1 ) ) { qValue = this . resolution * edgesInCommunity - ( nodeWeight * ( communityWeight - nodeWeight ) ) / ( 2.0 * this . graphWeightSum ) ; } if ( ( actualNodeCom == community ) && ( communitySize == 1 ) ) { qValue = 0. ; } return qValue ; }
changshan/graphdb-benchmarks | public void zoomOut ( ) { this . N = this . graphDatabase . reInitializeCommunities ( ) ; this . cache . reInitializeCommunities ( ) ; this . communityWeights = new ArrayList < Double > ( this . N ) ; for ( int i = 0 ; i < this . N ; i ++ ) { this . communityWeights . add ( graphDatabase . getCommunityWeight ( i ) ) ; } }
changshan/graphdb-benchmarks | public int getN ( ) { return this . N ; }
nabilzhang/enunciate | public RootElementDeclaration ( TypeElement delegate , TypeDefinition typeDefinition , EnunciateJaxbContext context ) { super ( delegate , context . getContext ( ) . getProcessingEnvironment ( ) ) ; this . rootElement = getAnnotation ( XmlRootElement . class ) ; this . typeDefinition = typeDefinition ; this . schema = new Schema ( this . env . getElementUtils ( ) . getPackageOf ( delegate ) , env ) ; this . facets . addAll ( Facet . gatherFacets ( delegate , context . getContext ( ) ) ) ; this . facets . addAll ( this . schema . getFacets ( ) ) ; }
nabilzhang/enunciate | public TypeDefinition getTypeDefinition ( ) { return this . typeDefinition ; }
nabilzhang/enunciate | public String getName ( ) { String name = Introspector . decapitalize ( getSimpleName ( ) . toString ( ) ) ; if ( ( rootElement != null ) && ( ! " # # default " . equals ( rootElement . name ( ) ) ) ) { name = rootElement . name ( ) ; } return name ; }
nabilzhang/enunciate | public String getNamespace ( ) { String namespace = getPackage ( ) . getNamespace ( ) ; if ( ( rootElement != null ) && ( ! " # # default " . equals ( rootElement . namespace ( ) ) ) ) { namespace = rootElement . namespace ( ) ; } return namespace ; }
nabilzhang/enunciate | public QName getQname ( ) { return new QName ( getNamespace ( ) , getName ( ) ) ; }
nabilzhang/enunciate | public String getClientSimpleName ( ) { String clientSimpleName = getSimpleName ( ) . toString ( ) ; ClientName clientName = getAnnotation ( ClientName . class ) ; if ( clientName != null ) { clientSimpleName = clientName . value ( ) ; } return clientSimpleName ; }
nabilzhang/enunciate | public Schema getSchema ( ) { return schema ; }
nabilzhang/enunciate | @ Override public Schema getPackage ( ) { return getSchema ( ) ; }
nabilzhang/enunciate | public Set < Facet > getFacets ( ) { return facets ; }
kaen/Terasology | @ Before public void setUp ( ) { bindsSubsystem = new BindsSubsystem ( ) ; bindsConfiguration = new BindsConfigAdapter ( new BindsConfig ( ) ) ; context = new ContextImpl ( ) ; context . put ( BindsConfiguration . class , bindsConfiguration ) ; bindsSubsystem . preInitialise ( context ) ; setUpMockModuleEnvironment ( ) ; }
kaen/Terasology | private void setUpMockModuleEnvironment ( ) { ModuleManager moduleManager = mock ( ModuleManager . class ) ; ModuleRegistry moduleRegistry = new TableModuleRegistry ( ) ; Module module = mock ( Module . class ) ; when ( module . isCodeModule ( ) ) . thenReturn ( true ) ; when ( module . getId ( ) ) . thenReturn ( new Name ( TEST_MODULE ) ) ; when ( module . getVersion ( ) ) . thenReturn ( new Version ( 0 , 0 , 1 , true ) ) ; when ( module . getMetadata ( ) ) . thenReturn ( new ModuleMetadata ( ) ) ; moduleRegistry . add ( module ) ; when ( moduleManager . getRegistry ( ) ) . thenReturn ( moduleRegistry ) ; ModuleEnvironment environment = mock ( ModuleEnvironment . class ) ; when ( moduleManager . loadEnvironment ( any ( ) , anyBoolean ( ) ) ) . thenReturn ( environment ) ; when ( moduleManager . getEnvironment ( ) ) . thenReturn ( environment ) ; registerBindButtonClasses = new ArrayList < > ( ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindButton . class ) ) ) . thenReturn ( registerBindButtonClasses ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindButton . class ) , any ( ) ) ) . thenReturn ( registerBindButtonClasses ) ; registerRealBindAxisClasses = new ArrayList < > ( ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindAxis . class ) ) ) . thenReturn ( registerRealBindAxisClasses ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindAxis . class ) , any ( ) ) ) . thenReturn ( registerRealBindAxisClasses ) ; when ( environment . getModuleProviding ( any ( ) ) ) . thenReturn ( new Name ( TEST_MODULE ) ) ; context . put ( ModuleManager . class , moduleManager ) ; }
kaen/Terasology | @ Test public void testSelfRegisterOnContext ( ) { assertThat ( context . get ( BindsManager . class ) , is ( bindsSubsystem ) ) ; }
kaen/Terasology | @ Test public void testUpdateBinds ( ) { registerBindButtonClasses . add ( TestEventButton . class ) ; bindsSubsystem . updateConfigWithDefaultBinds ( ) ; List < Input > defaultBinds = bindsSubsystem . getDefaultBindsConfig ( ) . getBinds ( new SimpleUri ( TEST_MODULE , " testEvent " ) ) ; assertThat ( defaultBinds . size ( ) , is ( 1 ) ) ; assertThat ( defaultBinds . get ( 0 ) . getType ( ) , is ( InputType . KEY ) ) ; assertThat ( defaultBinds . get ( 0 ) . getId ( ) , is ( KeyId . T ) ) ; assertThat ( defaultBinds . get ( 0 ) . getName ( ) , is ( Key . T . getName ( ) ) ) ; assertThat ( defaultBinds . get ( 0 ) . getDisplayName ( ) , is ( Key . T . getDisplayName ( ) ) ) ; List < Input > binds = bindsSubsystem . getBindsConfig ( ) . getBinds ( new SimpleUri ( TEST_MODULE , " testEvent " ) ) ; assertThat ( binds . size ( ) , is ( 1 ) ) ; assertThat ( binds . get ( 0 ) . getType ( ) , is ( InputType . KEY ) ) ; assertThat ( binds . get ( 0 ) . getId ( ) , is ( KeyId . T ) ) ; assertThat ( binds . get ( 0 ) . getName ( ) , is ( Key . T . getName ( ) ) ) ; assertThat ( binds . get ( 0 ) . getDisplayName ( ) , is ( Key . T . getDisplayName ( ) ) ) ; }
kaen/Terasology | @ Test public void test ( ) { ModuleEnvironment environment = mock ( ModuleEnvironment . class ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindButton . class ) , any ( ) ) ) . thenReturn ( registerBindButtonClasses ) ; registerBindButtonClasses . add ( TestEventButton . class ) ; }
kaen/Terasology | @ Test public void testRegisterBinds ( ) { registerBindButtonClasses . add ( TestEventButton . class ) ; bindsSubsystem . updateConfigWithDefaultBinds ( ) ; bindsSubsystem . registerBinds ( ) ; BindableButton button = bindsSubsystem . getKeyBinds ( ) . get ( KeyId . T ) ; assertThat ( button , is ( not ( nullValue ( ) ) ) ) ; assertThat ( button . getId ( ) , is ( new SimpleUri ( TEST_MODULE , " testEvent " ) ) ) ; assertThat ( button . getDisplayName ( ) , is ( " $ { engine - tests : menu # theTestEvent } " ) ) ; }
wso2/security-tools | public Class ( String className ) { this . className = className ; this . methods = new ArrayList < Method > ( ) ; }
wso2/security-tools | public String getClassName ( ) { return className ; }
wso2/security-tools | public void setClassName ( String className ) { this . className = className ; }
wso2/security-tools | public ArrayList < Method > getMethods ( ) { return methods ; }
wso2/security-tools | public void setMethods ( ArrayList < Method > methods ) { this . methods = methods ; }
lnquy/TodoTask | if ( username != null && SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { UserDetails userDetails = this . userDetailsService . loadUserByUsername ( username ) ; if ( jwtTokenUtil . validateToken ( authToken , userDetails ) ) { UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken ( userDetails , null , userDetails . getAuthorities ( ) ) ; authentication . setDetails ( new WebAuthenticationDetailsSource ( ) . buildDetails ( httpRequest ) ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; } }
jexp/idea2 | public ThreadState ( final String name , final String state ) { myName = name ; myState = state . trim ( ) ; }
jexp/idea2 | public String getName ( ) { return myName ; }
jexp/idea2 | public String getState ( ) { return myState ; }
jexp/idea2 | public String getStackTrace ( ) { return myStackTrace ; }
jexp/idea2 | public void setStackTrace ( final String stackTrace , boolean isEmpty ) { myStackTrace = stackTrace ; myEmptyStackTrace = isEmpty ; }
jexp/idea2 | public Collection < ThreadState > getAwaitingThreads ( ) { return Collections . unmodifiableSet ( myThreadsWaitingForMyLock ) ; }
jexp/idea2 | public String toString ( ) { return myName ; }
jexp/idea2 | public void setJavaThreadState ( final String javaThreadState ) { myJavaThreadState = javaThreadState ; }
jexp/idea2 | public void setThreadStateDetail ( @ NonNls final String threadStateDetail ) { myThreadStateDetail = threadStateDetail ; }
jexp/idea2 | public String getJavaThreadState ( ) { return myJavaThreadState ; }
jexp/idea2 | public String getThreadStateDetail ( ) { if ( myOperation != null ) { return myOperation . toString ( ) ; } return myThreadStateDetail ; }
jexp/idea2 | public boolean isEmptyStackTrace ( ) { return myEmptyStackTrace ; }
jexp/idea2 | public String getExtraState ( ) { return myExtraState ; }
jexp/idea2 | public void setExtraState ( final String extraState ) { myExtraState = extraState ; }
jexp/idea2 | public boolean isSleeping ( ) { return " sleeping " . equals ( getThreadStateDetail ( ) ) || ( ( " parking " . equals ( getThreadStateDetail ( ) ) || " waiting ▁ on ▁ condition " . equals ( myState ) ) && isThreadPoolExecutor ( ) ) ; }
jexp/idea2 | private boolean isThreadPoolExecutor ( ) { return myStackTrace . contains ( " java . util . concurrent . ScheduledThreadPoolExecutor $ DelayedWorkQueue . take " ) || myStackTrace . contains ( " java . util . concurrent . ThreadPoolExecutor . getTask " ) ; }
jexp/idea2 | public boolean isAwaitedBy ( ThreadState thread ) { return myThreadsWaitingForMyLock . contains ( thread ) ; }
jexp/idea2 | public void addWaitingThread ( ThreadState thread ) { myThreadsWaitingForMyLock . add ( thread ) ; }
jexp/idea2 | public boolean isDeadlocked ( ) { return ! myDeadlockedThreads . isEmpty ( ) ; }
jexp/idea2 | public void addDeadlockedThread ( ThreadState thread ) { myDeadlockedThreads . add ( thread ) ; }
jexp/idea2 | @ Nullable public ThreadOperation getOperation ( ) { return myOperation ; }
jexp/idea2 | public void setOperation ( @ Nullable final ThreadOperation operation ) { myOperation = operation ; }
jexp/idea2 | public boolean isWaiting ( ) { return " on ▁ object ▁ monitor " . equals ( myThreadStateDetail ) || myState . startsWith ( " waiting " ) || ( " parking " . equals ( myThreadStateDetail ) && ! isSleeping ( ) ) ; }
jexp/idea2 | public boolean isEDT ( ) { final String name = getName ( ) ; return isEDT ( name ) ; }
emboss/krypt-core-java | public PemInputStream ( InputStream in ) { super ( in ) ; b64Buffer = new Base64Buffer ( in ) ; }
emboss/krypt-core-java | public void continueStream ( ) { b64Buffer . continueStream ( ) ; }
emboss/krypt-core-java | public String getCurrentName ( ) { return b64Buffer . getName ( ) ; }
emboss/krypt-core-java | @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( len <= 0 ) throw new IllegalArgumentException ( " Negative ▁ or ▁ zero ▁ length " ) ; return b64Buffer . read ( b , off , len ) ; }
emboss/krypt-core-java | @ Override public int read ( ) throws IOException { int r = read ( singleByte ) ; while ( r == 0 ) { r = read ( singleByte ) ; } if ( r == - 1 ) return r ; return ( singleByte [ 0 ] & 0xff ) ; }
emboss/krypt-core-java | @ Override public boolean markSupported ( ) { return false ; }
emboss/krypt-core-java | @ Override public long skip ( long n ) throws IOException { throw new UnsupportedOperationException ( " Not ▁ implemented ▁ yet " ) ; }
emboss/krypt-core-java | public PemLineMatcher ( String line , final String beginOrEnd ) { this . pattern = Pattern . compile ( " ^ - - - - - " + beginOrEnd + " ▁ ( \\ w ( \\ w | \\ s ) * ) - - - - - $ " ) ; this . line = line ; }
emboss/krypt-core-java | public boolean match ( ) throws IOException { Matcher m = pattern . matcher ( line ) ; if ( m . matches ( ) ) { name = m . group ( 1 ) ; if ( name == null ) return false ; return true ; } return false ; }
emboss/krypt-core-java | public String getName ( ) { return name ; }
emboss/krypt-core-java | public PemHeaderMatcher ( String line ) { super ( line , " BEGIN " ) ; }
emboss/krypt-core-java | public PemFooterMatcher ( String line , String name ) { super ( line , " END " ) ; this . name = name ; }
emboss/krypt-core-java | @ Override public boolean match ( ) throws IOException { boolean match = super . match ( ) ; if ( match && name . equals ( getName ( ) ) ) return true ; else return false ; }
emboss/krypt-core-java | public Base64Buffer ( InputStream in ) { try { this . in = new BufferedReader ( new InputStreamReader ( in , " US - ASCII " ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } }
emboss/krypt-core-java | public void continueStream ( ) { this . buffer = null ; this . name = null ; this . bufpos = 0 ; this . state = State . HEADER ; this . eof = false ; }
emboss/krypt-core-java | private int decodeLine ( String line , OutputStream out ) throws IOException { try { byte [ ] bytes = line . getBytes ( " US - ASCII " ) ; Base64 . decodeTo ( bytes , 0 , bytes . length , out ) ; return bytes . length ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } }
emboss/krypt-core-java | private void fill ( ) throws IOException { int total = 0 ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( THRESHOLD ) ; String line = in . readLine ( ) ; while ( ! state . equals ( State . DONE ) && total < THRESHOLD && line != null ) { if ( line . equals ( " " ) ) { line = in . readLine ( ) ; continue ; } switch ( state ) { case HEADER : if ( line . charAt ( 0 ) == ' - ' ) { PemHeaderMatcher matcher = new PemHeaderMatcher ( line ) ; if ( matcher . match ( ) ) { state = State . CONTENT ; name = matcher . getName ( ) ; } } line = in . readLine ( ) ; break ; case CONTENT : if ( line . charAt ( 0 ) == ' - ' ) { state = State . FOOTER ; } else { total += decodeLine ( line , baos ) ; if ( total < THRESHOLD ) line = in . readLine ( ) ; } break ; case FOOTER : if ( line . charAt ( 0 ) == ' - ' ) { PemFooterMatcher matcher = new PemFooterMatcher ( line , name ) ; if ( matcher . match ( ) ) { state = State . DONE ; } else { line = in . readLine ( ) ; } } else { line = in . readLine ( ) ; } break ; default : break ; } } if ( state . equals ( State . DONE ) || line == null ) eof = true ; if ( line == null && ! state . equals ( State . DONE ) ) { switch ( state ) { case HEADER : break ; case CONTENT : throw new MalformedPemException ( " PEM ▁ data ▁ ended ▁ prematurely " ) ; default : throw new MalformedPemException ( " Could ▁ not ▁ find ▁ matching ▁ footer " ) ; } } buffer = baos . toByteArray ( ) ; bufpos = 0 ; }
emboss/krypt-core-java | private int consumeBytes ( byte [ ] b , int off , int len ) { if ( bufpos == buffer . length ) return 0 ; int available = buffer . length - bufpos ; int toRead = len < available ? len : available ; System . arraycopy ( buffer , bufpos , b , off , toRead ) ; bufpos += toRead ; return toRead ; }
emboss/krypt-core-java | public int read ( byte [ ] b , int off , int len ) throws IOException { int total = 0 ; if ( buffer == null ) { fill ( ) ; } while ( total != len && ! ( bufpos == buffer . length && eof ) ) { if ( bufpos == buffer . length ) fill ( ) ; total += consumeBytes ( b , off + total , len - total ) ; } if ( total == 0 && eof ) return - 1 ; return total ; }
emboss/krypt-core-java | public String getName ( ) { return name ; }
emboss/krypt-core-java | public MalformedPemException ( Throwable cause ) { super ( cause ) ; }
emboss/krypt-core-java | public MalformedPemException ( String message , Throwable cause ) { super ( message , cause ) ; }
emboss/krypt-core-java | public MalformedPemException ( String message ) { super ( message ) ; }
lsimons/phloc-schematron-standalone | public ComparatorThreadID ( ) { super ( ) ; }
lsimons/phloc-schematron-standalone | public ComparatorThreadID ( @ Nonnull final ESortOrder eSortOrder ) { super ( eSortOrder ) ; }
lsimons/phloc-schematron-standalone | @ Override protected long asLong ( @ Nullable final Thread aThread ) { return aThread == null ? CGlobal . ILLEGAL_ULONG : aThread . getId ( ) ; }
open-o/nfvo | @ Test public void testOperateFail ( ) throws ServiceException { execTestCase ( new File ( POST_PATH ) ) ; execTestCase ( new File ( PUT_PATH ) ) ; execTestCase ( new File ( DEL_PATH ) ) ; }
google/or-tools | public VarArraySolutionPrinter ( IntVar [ ] variables ) { variableArray = variables ; }
google/or-tools | @ Override public void onSolutionCallback ( ) { System . out . printf ( " Solution ▁ # % d : ▁ time ▁ = ▁ % .02f ▁ s % n " , solutionCount , wallTime ( ) ) ; for ( IntVar v : variableArray ) { System . out . printf ( " ▁ ▁ % s ▁ = ▁ % d % n " , v . getName ( ) , value ( v ) ) ; } solutionCount ++ ; }
google/or-tools | public int getSolutionCount ( ) { return solutionCount ; }
bollsal/pikicast-java-study | Knight ( Color color ) { super ( color ) ; }
bollsal/pikicast-java-study | @ Override public String getName ( ) { if ( isWhite ( ) ) { return WHITE_NAME ; } else { return BLACK_NAME ; } }
Estructuras-ITESM/Anpharos | public void settings ( ) { size ( multiplier * 600 , multiplier * 600 ) ; }
Estructuras-ITESM/Anpharos | public void setup ( ) { city = " " ; destCity = " " ; cp5 = new ControlP5 ( this ) ; dfs = cp5 . addButton ( " DFS " ) . setPosition ( 2 * width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; bfs = cp5 . addButton ( " BFS " ) . setPosition ( 3 * width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; input = cp5 . addTextfield ( " input " ) . setPosition ( 0 , 00 ) . setSize ( 100 * multiplier , 20 * multiplier ) ; destination = cp5 . addTextfield ( " destination " ) . setPosition ( 0 , 40 ) . setSize ( 100 * multiplier , 20 * multiplier ) ; spainGraph = new SpainGraph ( this , multiplier ) ; sphero = new Sphero ( this , multiplier , spainGraph . getGuiNodes ( ) ) ; dijkstra = cp5 . addButton ( " Dijkstra " ) . setPosition ( width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; }
Estructuras-ITESM/Anpharos | public void controlEvent ( ControlEvent theEvent ) { System . out . println ( theEvent . getController ( ) . getName ( ) ) ; if ( city != " " ) { switch ( theEvent . getName ( ) ) { case " Dijkstra " : if ( destCity != " " ) { Dijkstra tmp = new Dijkstra ( spainGraph . getGraph ( ) ) ; tmp . setSource ( city ) ; trace = tmp . trace ( destCity ) ; sphero . putTo ( trace ) ; } break ; case " DFS " : trace = DFS . trace ( spainGraph . getGraph ( ) , city ) ; sphero . putTo ( trace ) ; break ; case " BFS " : trace = BFS . trace ( spainGraph . getGraph ( ) , city ) ; sphero . putTo ( trace ) ; break ; } } }
Estructuras-ITESM/Anpharos | public void Dijkstra ( ) { System . out . println ( " Dijkstra ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } if ( spainGraph . contains ( destination . getText ( ) ) ) { destCity = destination . getText ( ) ; } }
Estructuras-ITESM/Anpharos | public void DFS ( ) { System . out . println ( " DFS ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } }
Estructuras-ITESM/Anpharos | public void BFS ( ) { System . out . println ( " BFS ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } }
Estructuras-ITESM/Anpharos | public void draw ( ) { background ( 255 ) ; spainGraph . draw ( ) ; sphero . draw ( ) ; }
neckhyg/dataChart | @ RequestMapping ( " / list " ) @ RequiresPermissions ( " czitattendance : list " ) public R list ( @ RequestParam Map < String , Object > params ) { Query query = new Query ( params ) ; List < CzitAttendanceEntity > czitAttendanceList = czitAttendanceService . queryList ( query ) ; int total = czitAttendanceService . queryTotal ( query ) ; PageUtils pageUtil = new PageUtils ( czitAttendanceList , total , query . getLimit ( ) , query . getPage ( ) ) ; return R . ok ( ) . put ( " page " , pageUtil ) ; }
neckhyg/dataChart | @ RequestMapping ( " / list2" ) public R list2 ( @ RequestParam Map < String , Object > params ) { List < CzitAttendanceEntity > czitAttendanceList = czitAttendanceService . queryList ( params ) ; return R . ok ( ) . put ( " data " , czitAttendanceList ) ; }
neckhyg/dataChart | " ) @ RequiresPermissions ( " czitattendance : info " ) public R info ( @ PathVariable ( " id " ) Integer id ) { CzitAttendanceEntity czitAttendance = czitAttendanceService . queryObject ( id ) ; return R . ok ( ) . put ( " czitAttendance " , czitAttendance ) ; }
neckhyg/dataChart | @ RequestMapping ( " / save " ) @ RequiresPermissions ( " czitattendance : save " ) public R save ( @ RequestBody CzitAttendanceEntity czitAttendance ) { czitAttendanceService . save ( czitAttendance ) ; return R . ok ( ) ; }
neckhyg/dataChart | @ RequestMapping ( " / update " ) @ RequiresPermissions ( " czitattendance : update " ) public R update ( @ RequestBody CzitAttendanceEntity czitAttendance ) { czitAttendanceService . update ( czitAttendance ) ; return R . ok ( ) ; }
neckhyg/dataChart | @ RequestMapping ( " / delete " ) @ RequiresPermissions ( " czitattendance : delete " ) public R delete ( @ RequestBody Integer [ ] ids ) { czitAttendanceService . deleteBatch ( ids ) ; return R . ok ( ) ; }
saandrews/pulsar | private final TypeReference < Map < String , Map < BookieSocketAddress , BookieInfo > > > typeRef = new TypeReference < Map < String , Map < BookieSocketAddress , BookieInfo > > > ( ) { }
saandrews/pulsar | public ZkIsolatedBookieEnsemblePlacementPolicy ( ) { super ( ) ; }
saandrews/pulsar | @ Override public RackawareEnsemblePlacementPolicyImpl initialize ( ClientConfiguration conf , Optional < DNSToSwitchMapping > optionalDnsResolver , HashedWheelTimer timer , FeatureProvider featureProvider , StatsLogger statsLogger ) { if ( conf . getProperty ( ISOLATION_BOOKIE_GROUPS ) != null ) { String isolationGroupsString = ( String ) conf . getProperty ( ISOLATION_BOOKIE_GROUPS ) ; if ( ! isolationGroupsString . isEmpty ( ) ) { for ( String isolationGroup : isolationGroupsString . split ( " , " ) ) { isolationGroups . add ( isolationGroup ) ; } bookieMappingCache = getAndSetZkCache ( conf ) ; } } return super . initialize ( conf , optionalDnsResolver , timer , featureProvider , statsLogger ) ; }
saandrews/pulsar | private ZooKeeperCache getAndSetZkCache ( Configuration conf ) { ZooKeeperCache zkCache = null ; if ( conf . getProperty ( ZooKeeperCache . ZK_CACHE_INSTANCE ) != null ) { zkCache = ( ZooKeeperCache ) conf . getProperty ( ZooKeeperCache . ZK_CACHE_INSTANCE ) ; } else { int zkTimeout ; String zkServers ; if ( conf instanceof ClientConfiguration ) { zkTimeout = ( ( ClientConfiguration ) conf ) . getZkTimeout ( ) ; zkServers = ( ( ClientConfiguration ) conf ) . getZkServers ( ) ; try { ZooKeeper zkClient = ZooKeeperClient . newBuilder ( ) . connectString ( zkServers ) . sessionTimeoutMs ( zkTimeout ) . build ( ) ; zkCache = new ZooKeeperCache ( zkClient ) { } ; conf . addProperty ( ZooKeeperCache . ZK_CACHE_INSTANCE , zkCache ) ; } catch ( Exception e ) { LOG . error ( " Error ▁ creating ▁ zookeeper ▁ client " , e ) ; } } else { LOG . error ( " No ▁ zk ▁ configurations ▁ available " ) ; } } return zkCache ; }
saandrews/pulsar | @ Override public ArrayList < BookieSocketAddress > newEnsemble ( int ensembleSize , int writeQuorumSize , int ackQuorumSize , Map < String , byte [ ] > customMetadata , Set < BookieSocketAddress > excludeBookies ) throws BKNotEnoughBookiesException { Set < BookieSocketAddress > blacklistedBookies = getBlacklistedBookies ( ) ; if ( excludeBookies == null ) { excludeBookies = new HashSet < BookieSocketAddress > ( ) ; } excludeBookies . addAll ( blacklistedBookies ) ; return super . newEnsemble ( ensembleSize , writeQuorumSize , ackQuorumSize , customMetadata , excludeBookies ) ; }
saandrews/pulsar | @ Override public BookieSocketAddress replaceBookie ( int ensembleSize , int writeQuorumSize , int ackQuorumSize , Map < String , byte [ ] > customMetadata , Set < BookieSocketAddress > currentEnsemble , BookieSocketAddress bookieToReplace , Set < BookieSocketAddress > excludeBookies ) throws BKNotEnoughBookiesException { Set < BookieSocketAddress > blacklistedBookies = getBlacklistedBookies ( ) ; if ( excludeBookies == null ) { excludeBookies = new HashSet < BookieSocketAddress > ( ) ; } excludeBookies . addAll ( blacklistedBookies ) ; return super . replaceBookie ( ensembleSize , writeQuorumSize , ackQuorumSize , customMetadata , currentEnsemble , bookieToReplace , excludeBookies ) ; }
saandrews/pulsar | private Set < BookieSocketAddress > getBlacklistedBookies ( ) { Set < BookieSocketAddress > blacklistedBookies = new HashSet < BookieSocketAddress > ( ) ; try { if ( bookieMappingCache != null ) { Map < String , Map < BookieSocketAddress , BookieInfo > > allGroupsBookieMapping = bookieMappingCache . getData ( ZkBookieRackAffinityMapping . BOOKIE_INFO_ROOT_PATH , this ) . orElseThrow ( ( ) -> new KeeperException . NoNodeException ( ZkBookieRackAffinityMapping . BOOKIE_INFO_ROOT_PATH ) ) ; for ( String group : allGroupsBookieMapping . keySet ( ) ) { if ( ! isolationGroups . contains ( group ) ) { for ( BookieSocketAddress bookieAddress : allGroupsBookieMapping . get ( group ) . keySet ( ) ) { blacklistedBookies . add ( bookieAddress ) ; } } } } } catch ( Exception e ) { LOG . warn ( " Error ▁ getting ▁ bookie ▁ isolation ▁ info ▁ from ▁ zk : ▁ { } " , e . getMessage ( ) ) ; } return blacklistedBookies ; }
saandrews/pulsar | @ Override public Map < String , Map < BookieSocketAddress , BookieInfo > > deserialize ( String key , byte [ ] content ) throws Exception { LOG . info ( " Reloading ▁ the ▁ bookie ▁ isolation ▁ groups ▁ mapping ▁ cache . " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading ▁ the ▁ bookie ▁ mappings ▁ with ▁ bookie ▁ info ▁ data : ▁ { } " , new String ( content ) ) ; } return jsonMapper . readValue ( content , typeRef ) ; }
thedevgeek/ANDROID-APPs | public DatabaseOpenHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; }
thedevgeek/ANDROID-APPs | @ Override public void onCreate ( SQLiteDatabase db ) { Twitter . Status . class . getMethods ( ) ; String sql = String . format ( " CREATE ▁ table ▁ % s ▁ ( " + " % s ▁ integer ▁ NOT ▁ NULL ▁ primary ▁ key , " + " % s ▁ timestamp , ▁ % s ▁ TEXT , ▁ % s ▁ TEXT ) " , TABLE , C_ID , C_CREATED_AT , C_TEXT , C_USER ) ; Log . d ( TAG , " Created ▁ SQLite ▁ database : ▁ " + sql ) ; db . execSQL ( sql ) ; }
thedevgeek/ANDROID-APPs | @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( " DROP ▁ TABLE ▁ IF ▁ EXISTS ▁ " + TABLE + " ; " ) ; this . onCreate ( db ) ; }
NguyenAnhDuc/fpt-qa | public String getId ( ) { return id ; }
NguyenAnhDuc/fpt-qa | public void setId ( String id ) { this . id = id ; }
NguyenAnhDuc/fpt-qa | public String getName ( ) { return name ; }
NguyenAnhDuc/fpt-qa | public void setName ( String name ) { this . name = name ; }
omindra/schema_org_java_api | public Number getNumberOfRooms ( ) { return numberOfRooms ; }
omindra/schema_org_java_api | public void setNumberOfRooms ( Number numberOfRooms ) { this . numberOfRooms = numberOfRooms ; }
omindra/schema_org_java_api | public QuantitativeValue getOccupancy ( ) { return occupancy ; }
omindra/schema_org_java_api | public void setOccupancy ( QuantitativeValue occupancy ) { this . occupancy = occupancy ; }
LanternPowered/LanternServer | LanternBlockType ( ResourceKey key , Iterable < BlockTrait < ? > > blockTraits , TranslationProvider translationProvider , MutableBehaviorPipeline < Behavior > behaviorPipeline , @ Nullable BlockEntityProvider tileEntityProvider ) { super ( key ) ; this . translationProvider = translationProvider ; this . behaviorPipeline = behaviorPipeline ; this . tileEntityProvider = tileEntityProvider ; this . tickRandomly = ! behaviorPipeline . pipeline ( RandomTickBehavior . class ) . getBehaviors ( ) . isEmpty ( ) ; this . blockStateBase = new LanternBlockStateMap ( this , blockTraits ) ; this . defaultBlockState = this . blockStateBase . getBaseState ( ) ; this . isAir = key . getValue ( ) . contains ( " air " ) ; }
LanternPowered/LanternServer | void setItemType ( ItemType itemType ) { this . itemType = itemType ; }
LanternPowered/LanternServer | void setDefaultBlockState ( BlockState blockState ) { this . defaultBlockState = blockState ; }
LanternPowered/LanternServer | public Optional < BlockEntityProvider > getBlockEntityProvider ( ) { return Optional . ofNullable ( this . tileEntityProvider ) ; }
LanternPowered/LanternServer | public MutableBehaviorPipeline < Behavior > getPipeline ( ) { return this . behaviorPipeline ; }
LanternPowered/LanternServer | public LanternBlockStateMap getBlockStateBase ( ) { return this . blockStateBase ; }
LanternPowered/LanternServer | @ Override public Translation getTranslation ( ) { return this . translationProvider . get ( getDefaultState ( ) , null , null ) ; }
LanternPowered/LanternServer | public Translation getTranslation ( BlockState blockState ) { return this . translationProvider . get ( blockState , null , null ) ; }
LanternPowered/LanternServer | public BlockState getStateFromItemStack ( ItemStack itemStack ) { return this . getDefaultState ( ) ; }
LanternPowered/LanternServer | public PropertyProviderCollection getPropertyProviderCollection ( ) { return this . propertyProviderCollection ; }
LanternPowered/LanternServer | @ Override public Optional < ItemType > getItem ( ) { return Optional . ofNullable ( this . itemType ) ; }
LanternPowered/LanternServer | @ Override public String getName ( ) { return super . getName ( ) ; }
LanternPowered/LanternServer | @ Override public BlockState getDefaultState ( ) { return this . defaultBlockState ; }
LanternPowered/LanternServer | @ Override public Collection < BlockState > getAllBlockStates ( ) { return this . blockStateBase . getBlockStates ( ) ; }
LanternPowered/LanternServer | @ Override public boolean getTickRandomly ( ) { return this . tickRandomly ; }
LanternPowered/LanternServer | @ Override public void setTickRandomly ( boolean tickRandomly ) { this . tickRandomly = tickRandomly ; }
LanternPowered/LanternServer | @ Override public Collection < BlockTrait < ? > > getTraits ( ) { return getDefaultState ( ) . getTraits ( ) ; }
LanternPowered/LanternServer | @ Override public Optional < BlockTrait < ? > > getTrait ( String blockTrait ) { return getDefaultState ( ) . getTrait ( blockTrait ) ; }
LanternPowered/LanternServer | @ Override public BlockSoundGroup getSoundGroup ( ) { return this . blockSoundGroup ; }
LanternPowered/LanternServer | void setSoundGroup ( BlockSoundGroup blockSoundGroup ) { this . blockSoundGroup = blockSoundGroup ; }
LanternPowered/LanternServer | void setPropertyProviderCollection ( PropertyProviderCollection propertyProviderCollection ) { this . propertyProviderCollection = propertyProviderCollection ; }
LanternPowered/LanternServer | @ Nullable public BlockObjectProvider < AABB > getSelectionBoxProvider ( ) { return this . selectionBoxProvider ; }
LanternPowered/LanternServer | void setSelectionBoxProvider ( @ Nullable BlockObjectProvider < AABB > selectionBoxProvider ) { this . selectionBoxProvider = selectionBoxProvider ; }
LanternPowered/LanternServer | @ Nullable public BlockObjectProvider < Collection < AABB > > getCollisionBoxesProvider ( ) { return this . collisionBoxesProvider ; }
LanternPowered/LanternServer | void setCollisionBoxesProvider ( @ Nullable BlockObjectProvider < Collection < AABB > > boundingBoxProvider ) { this . collisionBoxesProvider = boundingBoxProvider ; }
LanternPowered/LanternServer | public boolean isAir ( ) { return this . isAir ; }
cjm0000000/mmt | @ Test public void testUser ( ) { User user = addUser ( ) ; assertNotEquals ( 0 , user . getUser_id ( ) ) ; Role role = addRole ( ) ; assertNotEquals ( 0 , role . getRole_id ( ) ) ; Customer cust = addCustomer ( ) ; assertNotEquals ( 0 , cust . getCust_id ( ) ) ; userMapper . addUserRole ( user . getUser_id ( ) , role . getRole_id ( ) , cust . getCust_id ( ) ) ; User u3 = userMapper . checkLogin ( user . getUsername ( ) , user . getPassword ( ) ) ; assertNotNull ( u3 ) ; assertEquals ( role . getRole_name ( ) , u3 . getRole_name ( ) ) ; assertEquals ( cust . getCust_name ( ) , u3 . getCust_name ( ) ) ; Role r2 = addRole ( ) ; Customer c2 = addCustomer ( ) ; userMapper . updateUserRole ( user . getUser_id ( ) , r2 . getRole_id ( ) , c2 . getCust_id ( ) ) ; User u4 = userMapper . getUserById ( user . getUser_id ( ) ) ; assertEquals ( r2 . getRole_name ( ) , u4 . getRole_name ( ) ) ; assertEquals ( c2 . getCust_name ( ) , u4 . getCust_name ( ) ) ; }
cjm0000000/mmt | @ Test public void getUserIdByName ( ) { User u1 = addUser ( ) ; assertNotNull ( u1 ) ; int user_id = userMapper . getUserIdByName ( u1 . getUsername ( ) ) ; assertEquals ( user_id , u1 . getUser_id ( ) ) ; }
cjm0000000/mmt | @ Test public void getUserById ( ) { User u1 = addUser ( ) ; assertNotNull ( u1 ) ; User u2 = userMapper . getUserById ( u1 . getUser_id ( ) ) ; assertNotNull ( u2 ) ; }
cjm0000000/mmt | @ Test public void deleteUser ( ) { User u1 = addUser ( ) ; User u2 = addUser ( ) ; User u3 = addUser ( ) ; String [ ] users = { String . valueOf ( u1 . getUser_id ( ) ) , String . valueOf ( u2 . getUser_id ( ) ) , String . valueOf ( u3 . getUser_id ( ) ) } ; userMapper . deleteUser ( users ) ; }
cjm0000000/mmt | @ Test public void getUserList ( ) { List < User > list = userMapper . getUserList ( 0 , 0 , null ) ; int cnt = userMapper . getUserCnt ( null ) ; assertEquals ( cnt , list . size ( ) ) ; }
cjm0000000/mmt | private User addUser ( ) { User user = new User ( ) ; user . setBz ( " 备注 " ) ; user . setIslock ( Status . UNAVAILABLE ) ; user . setPassword ( " password " ) ; user . setRole_id ( 10 ) ; user . setIdcard ( "330111190012123333" ) ; user . setMphone ( "18805718888" ) ; user . setStatus ( Status . AVAILABLE ) ; user . setUsername ( new Object ( ) . toString ( ) ) ; user . setXm ( " xm " ) ; userMapper . addUser ( user ) ; return user ; }
cjm0000000/mmt | private Role addRole ( ) { Role role = new Role ( ) ; role . setReloadable ( Status . AVAILABLE ) ; role . setRole_desc ( " role _ desc " ) ; role . setRole_name ( " ROLE _ NAME " ) ; role . setSort ( 1 ) ; role . setStatus ( Status . AVAILABLE ) ; roleMapper . addRole ( role ) ; return role ; }
cjm0000000/mmt | private Customer addCustomer ( ) { Customer cust = new Customer ( ) ; cust . setCust_name ( " LEMON ▁ TEST ▁ CUSTOMER " ) ; cust . setMemo ( " MEMO . . . " ) ; cust . setStatus ( Status . AVAILABLE ) ; customerMapper . addCustomer ( cust ) ; return cust ; }
CodeArcsInc/candlestack | private SQSCloudWatchMetric ( CloudWatchStatistic statistic , String serviceName , String commandName , String scriptFileName , String notes ) { this . statistic = statistic ; this . serviceName = serviceName ; this . commandName = commandName ; this . scriptFileName = scriptFileName ; this . notes = notes ; try { logsHost = GlobalAWSProperties . getLogsHost ( ) ; logsAuthToken = GlobalAWSProperties . getLogsAuthToken ( ) ; } catch ( CandlestackPropertiesException ignore ) { } }
CodeArcsInc/candlestack | @ Override public CloudWatchStatistic getStatistic ( ) { return statistic ; }
CodeArcsInc/candlestack | @ Override public String getServiceName ( ) { return serviceName ; }
CodeArcsInc/candlestack | @ Override public String getCommandName ( ) { return commandName ; }
CodeArcsInc/candlestack | @ Override public String getScriptFileName ( ) { return scriptFileName ; }
CodeArcsInc/candlestack | @ Override public Service getService ( String queueName , Set < String > contactGroups ) throws CandlestackPropertiesException { long warning = GlobalAWSProperties . getSQSCloudWatchMetricWarningLevel ( queueName , this ) ; long critical = GlobalAWSProperties . getSQSCloudWatchMetricCriticalLevel ( queueName , this ) ; String command = commandName + " ! " + MetricsReaderWriter . sanitizeString ( queueName ) + " ! " + warning + " ! " + critical ; String notificationPeriod = GlobalAWSProperties . getSQSServiceNotificationPeriod ( queueName ) ; return new Service ( serviceName , queueName , command , notes , notificationPeriod , contactGroups ) ; }
CodeArcsInc/candlestack | @ Override public Command getMonitorCommand ( String relativePathToMonitorResource ) { return new Command ( commandName , relativePathToMonitorResource + scriptFileName + " ▁ " + logsHost + " ▁ " + logsAuthToken + " ▁ $ ARG1 $ ▁ $ ARG2 $ ▁ $ ARG3 $ " ) ; }
CodeArcsInc/candlestack | @ Override public String getNamespace ( ) { return NAMESPACE ; }
CodeArcsInc/candlestack | @ Override public String getName ( ) { return name ( ) ; }
code2358/jcdk-wrapper | @ Before public void init ( ) throws IOException { configurationFile = Files . createTempFile ( " " , " " ) ; jcdk2Installation = new Jcdk2Installation ( JCDK2_PATH ) ; jcdk3Installation = new Jcdk3Installation ( JCDK3_PATH ) ; jcdkInstallation = jcdk3Installation ; jcdkWrongPath = Files . createTempDirectory ( " " ) ; jcdkInstallationWrongPath = new Jcdk3Installation ( jcdkWrongPath ) ; jcdkWrapper = new JcdkWrapperImpl ( jcdkInstallation , configurationFile ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdk2Success ( ) throws Exception { String command = JcdkWrapperImpl . generateCommand ( jcdk2Installation , configurationFile ) ; assertThat ( command , equalTo ( String . format ( " java ▁ - cp ▁ % s ▁ " + " - Djc . home = % s ▁ % s ▁ - config ▁ % s " , jcdk2Installation . getConverterClasspath ( ) , jcdk2Installation . getBasePath ( ) , jcdk2Installation . getConverterClass ( ) , configurationFile ) ) ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdk3Success ( ) throws Exception { String command = JcdkWrapperImpl . generateCommand ( jcdk3Installation , configurationFile ) ; assertThat ( command , equalTo ( String . format ( " java ▁ - cp ▁ % s ▁ " + " - Djc . home = % s ▁ % s ▁ - config ▁ % s " , jcdk3Installation . getConverterClasspath ( ) , jcdk3Installation . getBasePath ( ) , jcdk3Installation . getConverterClass ( ) , configurationFile ) ) ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdkWithoutConfigurationFailure ( ) throws Exception { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Provided ▁ configuration ▁ path ▁ is ▁ not ▁ valid : ▁ " + configurationFile ) ; Files . delete ( configurationFile ) ; JcdkWrapperImpl . generateCommand ( jcdkInstallation , configurationFile ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdkWithWrongJcdkPathFailure ( ) throws Exception { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Provided ▁ JCDK ▁ path ▁ is ▁ not ▁ valid : ▁ " + jcdkWrongPath ) ; JcdkWrapperImpl . generateCommand ( jcdkInstallationWrongPath , configurationFile ) ; }
code2358/jcdk-wrapper | @ Test public void convertCannotFindClassFailure ( ) throws Exception { exception . expect ( ConvertionException . class ) ; exception . expectMessage ( " Error ▁ during ▁ execution ▁ of ▁ JCDK ▁ converter ▁ ( see ▁ output ▁ for ▁ details ) . " ) ; jcdkWrapper . convert ( ) ; }
code2358/jcdk-wrapper | @ Test public void checkoutAfterConvertFailureSuccess ( ) throws Exception { try { jcdkWrapper . convert ( ) ; } catch ( ConvertionException e ) { } assertThat ( jcdkWrapper . getJcdkOutput ( ) , startsWith ( " Error : ▁ Could ▁ not ▁ find ▁ or ▁ load ▁ main ▁ class ▁ " ) ) ; }
code2358/jcdk-wrapper | @ Test public void emptyOutputSuccess ( ) throws Exception { assertThat ( jcdkWrapper . getJcdkOutput ( ) , nullValue ( ) ) ; }
WilliamRen/gretty | public Greeting ( String content ) { this . content = content ; }
WilliamRen/gretty | public String getContent ( ) { return content ; }
alexTrifonov/atrifonov | public AutoModel ( ) { }
alexTrifonov/atrifonov | public AutoModel ( String model , MakeCar makeCar ) { this . model = model ; this . makeCar = makeCar ; }
alexTrifonov/atrifonov | public int getId ( ) { return id ; }
alexTrifonov/atrifonov | public String getModel ( ) { return model ; }
alexTrifonov/atrifonov | public void setId ( int id ) { this . id = id ; }
alexTrifonov/atrifonov | public void setModel ( String model ) { this . model = model ; }
alexTrifonov/atrifonov | public MakeCar getMakeCar ( ) { return makeCar ; }
alexTrifonov/atrifonov | public void setMakeCar ( MakeCar makeCar ) { this . makeCar = makeCar ; }
alexTrifonov/atrifonov | @ Override public String toString ( ) { return model ; }
alexTrifonov/atrifonov | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; AutoModel autoModel = ( AutoModel ) o ; if ( id != autoModel . id ) return false ; if ( model != null ? ! model . equals ( autoModel . model ) : autoModel . model != null ) return false ; return makeCar != null ? makeCar . equals ( autoModel . makeCar ) : autoModel . makeCar == null ; }
alexTrifonov/atrifonov | @ Override public int hashCode ( ) { int result = id ; result = 31 * result + ( model != null ? model . hashCode ( ) : 0 ) ; result = 31 * result + ( makeCar != null ? makeCar . hashCode ( ) : 0 ) ; return result ; }
PrakashGoulla/selendroid | public FingerView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; paint = new Paint ( ) ; paint . setColor ( Color . WHITE ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeWidth ( 12 ) ; pointerPathMap = new HashMap < Integer , Path > ( ) ; }
PrakashGoulla/selendroid | @ Override public boolean onTouchEvent ( MotionEvent event ) { int idx = event . getActionIndex ( ) ; int id = event . getPointerId ( idx ) ; switch ( event . getActionMasked ( ) ) { case MotionEvent . ACTION_DOWN : case MotionEvent . ACTION_POINTER_DOWN : Path pth = new Path ( ) ; pth . moveTo ( event . getX ( idx ) , event . getY ( idx ) ) ; pointerPathMap . put ( id , pth ) ; break ; case MotionEvent . ACTION_MOVE : for ( Map . Entry < Integer , Path > entry : pointerPathMap . entrySet ( ) ) { idx = event . findPointerIndex ( entry . getKey ( ) ) ; entry . getValue ( ) . lineTo ( event . getX ( idx ) , event . getY ( idx ) ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_POINTER_UP : pointerPathMap . remove ( id ) ; break ; } invalidate ( ) ; return true ; }
PrakashGoulla/selendroid | @ Override protected void onDraw ( Canvas canvas ) { for ( Path p : pointerPathMap . values ( ) ) { canvas . drawPath ( p , paint ) ; } }
Stargator/testdrivenexamples | public List < Segment > parseSegments ( String template ) { List < Segment > segments = new ArrayList < > ( ) ; collectSegments ( segments , template ) ; return segments ; }
Stargator/testdrivenexamples | private void collectSegments ( List < Segment > segments , String template ) { Pattern pattern = Pattern . compile ( " \\ $ \\ { [ ^ } ] * \\ }
Stargator/testdrivenexamples | while ( matcher . find ( ) ) { String strToEval = template . substring ( matcher . start ( ) , matcher . end ( ) ) ; if ( isVariable ( strToEval ) ) { segments . add ( new Variable ( strToEval ) ) ; } else { segments . add ( new PlainText ( strToEval ) ) ; } }
Stargator/testdrivenexamples | private void addEmptyStringIfTemplateWasEmpty ( List < Segment > segments ) { if ( segments . isEmpty ( ) ) { segments . add ( new PlainText ( " " ) ) ; } }
Stargator/testdrivenexamples | private boolean isVariable ( String segment ) { return segment . startsWith ( varStarting ) && segment . endsWith ( varEnding ) ; }
hizel/lorsource | @ RequestMapping ( value = " / commit . jsp " , method = RequestMethod . GET ) public ModelAndView showCommitForm ( HttpServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ ModelAttribute ( " form " ) EditTopicRequest form ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; if ( message . isCommited ( ) ) { throw new UserErrorException ( " Сообщение ▁ уже ▁ подтверждено " ) ; } PreparedTopic preparedMessage = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; if ( ! preparedMessage . getSection ( ) . isPremoderated ( ) ) { throw new UserErrorException ( " Раздел ▁ не ▁ премодерируемый " ) ; } ModelAndView mv = prepareModel ( preparedMessage , form , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) ) ; mv . getModel ( ) . put ( " commit " , true ) ; return mv ; }
hizel/lorsource | @ RequestMapping ( value = " / edit . jsp " , method = RequestMethod . GET ) public ModelAndView showEditForm ( ServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ ModelAttribute ( " form " ) EditTopicRequest form ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; User user = tmpl . getCurrentUser ( ) ; PreparedTopic preparedMessage = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; if ( ! permissionService . isEditable ( preparedMessage , user ) && ! permissionService . isTagsEditable ( preparedMessage , user ) ) { throw new AccessViolationException ( " это ▁ сообщение ▁ нельзя ▁ править " ) ; } return prepareModel ( preparedMessage , form , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) ) ; }
hizel/lorsource | private ModelAndView prepareModel ( PreparedTopic preparedTopic , EditTopicRequest form , User currentUser , Profile profile ) throws PollNotFoundException { Map < String , Object > params = new HashMap < > ( ) ; final Topic message = preparedTopic . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedTopic ) ; Group group = preparedTopic . getGroup ( ) ; params . put ( " group " , group ) ; params . put ( " groups " , groupDao . getGroups ( preparedTopic . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; TopicMenu topicMenu = prepareService . getTopicMenu ( preparedTopic , currentUser , profile , true ) ; params . put ( " topicMenu " , topicMenu ) ; List < EditHistoryRecord > editInfoList = editHistoryService . getEditInfo ( message . getId ( ) , EditHistoryObjectTypeEnum . TOPIC ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; ImmutableSet < User > editors = editHistoryService . getEditorUsers ( message , editInfoList ) ; form . setEditorBonus ( editors . stream ( ) . collect ( Collectors . toMap ( User :: getId , u -> 0 ) ) ) ; params . put ( " editors " , editors ) ; } params . put ( " commit " , false ) ; if ( group . isLinksAllowed ( ) ) { form . setLinktext ( message . getLinktext ( ) ) ; form . setUrl ( message . getUrl ( ) ) ; } form . setTitle ( StringEscapeUtils . unescapeHtml4 ( message . getTitle ( ) ) ) ; form . setMsg ( msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ) ; if ( message . getSectionId ( ) == Section . SECTION_NEWS ) { form . setMinor ( message . isMinor ( ) ) ; } if ( ! preparedTopic . getTags ( ) . isEmpty ( ) ) { form . setTags ( TagRef . names ( preparedTopic . getTags ( ) ) ) ; } if ( preparedTopic . getSection ( ) . isPollPostAllowed ( ) ) { Poll poll = pollDao . getPollByTopicId ( message . getId ( ) ) ; form . setPoll ( PollVariant . toMap ( poll . getVariants ( ) ) ) ; form . setMultiselect ( poll . isMultiSelect ( ) ) ; } params . put ( " imagepost " , permissionService . isImagePostingAllowed ( preparedTopic . getSection ( ) , currentUser ) ) ; return new ModelAndView ( " edit " , params ) ; }
hizel/lorsource | @ ModelAttribute ( " ipBlockInfo " ) private IPBlockInfo loadIPBlock ( HttpServletRequest request ) { return ipBlockDao . getBlockInfo ( request . getRemoteAddr ( ) ) ; }
hizel/lorsource | @ RequestMapping ( value = " / edit . jsp " , method = RequestMethod . POST ) public ModelAndView edit ( HttpServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @ RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId , @ Valid @ ModelAttribute ( " form " ) EditTopicRequest form , Errors errors , @ ModelAttribute ( " ipBlockInfo " ) IPBlockInfo ipBlockInfo ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; final Topic message = messageDao . getById ( msgid ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; Group group = preparedTopic . getGroup ( ) ; User user = tmpl . getCurrentUser ( ) ; IPBlockDao . checkBlockIP ( ipBlockInfo , errors , user ) ; boolean tagsEditable = permissionService . isTagsEditable ( preparedTopic , user ) ; boolean editable = permissionService . isEditable ( preparedTopic , user ) ; if ( ! editable && ! tagsEditable ) { throw new AccessViolationException ( " это ▁ сообщение ▁ нельзя ▁ править " ) ; } params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedTopic ) ; params . put ( " group " , group ) ; params . put ( " topicMenu " , prepareService . getTopicMenu ( preparedTopic , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , true ) ) ; params . put ( " groups " , groupDao . getGroups ( preparedTopic . getSection ( ) ) ) ; if ( editable ) { String title = request . getParameter ( " title " ) ; if ( title == null || title . trim ( ) . isEmpty ( ) ) { throw new BadInputException ( " заголовок ▁ сообщения ▁ не ▁ может ▁ быть ▁ пустым " ) ; } } boolean preview = request . getParameter ( " preview " ) != null ; if ( preview ) { params . put ( " info " , " Предпросмотр " ) ; } boolean publish = request . getParameter ( " publish " ) != null ; List < EditHistoryRecord > editInfoList = editHistoryService . getEditInfo ( message . getId ( ) , EditHistoryObjectTypeEnum . TOPIC ) ; if ( ! editInfoList . isEmpty ( ) ) { EditHistoryRecord editHistoryRecord = editInfoList . get ( 0 ) ; params . put ( " editInfo " , editHistoryRecord ) ; if ( lastEdit == null || editHistoryRecord . getEditdate ( ) . getTime ( ) != lastEdit ) { errors . reject ( null , " Сообщение ▁ было ▁ отредактировано ▁ независимо " ) ; } } boolean commit = request . getParameter ( " commit " ) != null ; if ( commit ) { user . checkCommit ( ) ; if ( message . isCommited ( ) ) { throw new BadInputException ( " сообщение ▁ уже ▁ подтверждено " ) ; } } params . put ( " commit " , ! message . isCommited ( ) && preparedTopic . getSection ( ) . isPremoderated ( ) && user . isModerator ( ) ) ; Topic newMsg = new Topic ( group , message , form , publish ) ; boolean modified = false ; if ( ! message . getTitle ( ) . equals ( newMsg . getTitle ( ) ) ) { modified = true ; } if ( form . getMsg ( ) != null ) { String oldText = msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ; if ( ! oldText . equals ( form . getMsg ( ) ) ) { modified = true ; } } if ( message . getLinktext ( ) == null ) { if ( newMsg . getLinktext ( ) != null ) { modified = true ; } } else if ( ! message . getLinktext ( ) . equals ( newMsg . getLinktext ( ) ) ) { modified = true ; } if ( group . isLinksAllowed ( ) ) { if ( message . getUrl ( ) == null ) { if ( newMsg . getUrl ( ) != null ) { modified = true ; } } else if ( ! message . getUrl ( ) . equals ( newMsg . getUrl ( ) ) ) { modified = true ; } } UploadedImagePreview imagePreview = null ; if ( permissionService . isImagePostingAllowed ( preparedTopic . getSection ( ) , user ) ) { if ( permissionService . isTopicPostingAllowed ( group , user ) ) { File image = imageService . processUploadImage ( request ) ; imagePreview = imageService . processUpload ( user , request . getSession ( ) , image , errors ) ; if ( imagePreview != null ) { modified = true ; } } } if ( ! editable && modified ) { throw new AccessViolationException ( " нельзя ▁ править ▁ это ▁ сообщение , ▁ только ▁ теги " ) ; } if ( form . getMinor ( ) != null && ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " вы ▁ не ▁ можете ▁ менять ▁ статус ▁ новости " ) ; } List < String > newTags = null ; if ( form . getTags ( ) != null ) { newTags = TagName . parseAndSanitizeTags ( form . getTags ( ) ) ; } if ( changeGroupId != null ) { if ( message . getGroupId ( ) != changeGroupId ) { Group changeGroup = groupDao . getGroup ( changeGroupId ) ; int section = message . getSectionId ( ) ; if ( changeGroup . getSectionId ( ) != section ) { throw new AccessViolationException ( " Can ' t ▁ move ▁ topics ▁ between ▁ sections " ) ; } } } Poll newPoll = null ; if ( preparedTopic . getSection ( ) . isPollPostAllowed ( ) && form . getPoll ( ) != null && tmpl . isModeratorSession ( ) ) { newPoll = buildNewPoll ( message , form ) ; } String newText ; if ( form . getMsg ( ) != null ) { newText = form . getMsg ( ) ; } else { newText = msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ; } if ( form . getEditorBonus ( ) != null ) { ImmutableSet < Integer > editors = editHistoryService . getEditors ( message , editInfoList ) ; form . getEditorBonus ( ) . keySet ( ) . stream ( ) . filter ( userid -> ! editors . contains ( userid ) ) . forEach ( userid -> errors . reject ( " editorBonus " , " некорректный ▁ корректор ? ! " ) ) ; } if ( ! preview && ! errors . hasErrors ( ) && ipBlockInfo . isCaptchaRequired ( ) ) { captcha . checkCaptcha ( request , errors ) ; } if ( ! preview && ! errors . hasErrors ( ) ) { boolean changed = topicService . updateAndCommit ( newMsg , message , user , newTags , newText , commit , changeGroupId , form . getBonus ( ) , newPoll != null ? newPoll . getVariants ( ) : null , form . isMultiselect ( ) , form . getEditorBonus ( ) , imagePreview ) ; if ( changed || commit || publish ) { if ( ! newMsg . isDraft ( ) ) { searchQueueSender . updateMessage ( newMsg . getId ( ) , true ) ; } if ( ! publish || ! preparedTopic . getSection ( ) . isPremoderated ( ) ) { return new ModelAndView ( new RedirectView ( TopicLinkBuilder . baseLink ( message ) . forceLastmod ( ) . build ( ) ) ) ; } else { params . put ( " moderated " , true ) ; params . put ( " url " , TopicLinkBuilder . baseLink ( message ) . forceLastmod ( ) . build ( ) ) ; return new ModelAndView ( " add - done - moderated " , params ) ; } } else { errors . reject ( null , " Нет ▁ изменений " ) ; } } params . put ( " newMsg " , newMsg ) ; Image imageObject = null ; if ( imagePreview != null ) { imageObject = new Image ( 0 , 0 , " gallery / preview / " + imagePreview . mainFile ( ) . getName ( ) ) ; } params . put ( " newPreparedMessage " , prepareService . prepareTopicPreview ( newMsg , newTags != null ? TagService . namesToRefs ( newTags ) : null , newPoll , request . isSecure ( ) , newText , imageObject ) ) ; return new ModelAndView ( " edit " , params ) ; }
hizel/lorsource | private Poll buildNewPoll ( Topic message , EditTopicRequest form ) throws PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( message . getId ( ) ) ; List < PollVariant > newVariants = new ArrayList < > ( ) ; for ( PollVariant v : poll . getVariants ( ) ) { String label = form . getPoll ( ) . get ( v . getId ( ) ) ; if ( ! Strings . isNullOrEmpty ( label ) ) { newVariants . add ( new PollVariant ( v . getId ( ) , label ) ) ; } } for ( String label : form . getNewPoll ( ) ) { if ( ! Strings . isNullOrEmpty ( label ) ) { newVariants . add ( new PollVariant ( 0 , label ) ) ; } } return poll . createNew ( newVariants ) ; }
hizel/lorsource | @ InitBinder ( " form " ) public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( editTopicRequestValidator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; }
elimu-ai/webapp | @ RequestMapping ( method = RequestMethod . GET ) public String handleGetRequest ( HttpServletRequest request ) { logger . info ( " handleGetRequest " ) ; JSONArray videosJsonArray = new JSONArray ( ) ; for ( Video video : videoDao . readAllOrdered ( ) ) { VideoGson videoGson = JpaToGsonConverter . getVideoGson ( video ) ; String json = new Gson ( ) . toJson ( videoGson ) ; videosJsonArray . put ( new JSONObject ( json ) ) ; } String jsonResponse = videosJsonArray . toString ( ) ; logger . info ( " jsonResponse : ▁ " + jsonResponse ) ; return jsonResponse ; }
guonl/DesignPattern | public String getServiceId ( ) { return serviceId ; }
guonl/DesignPattern | public void setServiceId ( String serviceId ) { this . serviceId = serviceId ; }
guonl/DesignPattern | public String getRequestType ( ) { return requestType ; }
guonl/DesignPattern | public void setRequestType ( String requestType ) { this . requestType = requestType ; }
guonl/DesignPattern | public Map < String , Object > getAttributes ( ) { return attributes ; }
guonl/DesignPattern | public void setAttributes ( Map < String , Object > attributes ) { this . attributes = attributes ; }
anishek/hive | KEY ( String s ) { this . keyName = s ; }
anishek/hive | @ Override public String toString ( ) { return keyName ; }
anishek/hive | public ReplicationSpec ( ASTNode node ) { if ( node != null ) { if ( isApplicable ( node ) ) { init ( node ) ; return ; } else { for ( int i = 1 ; i < node . getChildCount ( ) ; ++ i ) { ASTNode child = ( ASTNode ) node . getChild ( i ) ; if ( isApplicable ( child ) ) { init ( child ) ; return ; } } } } }
anishek/hive | public ReplicationSpec ( ) { this ( ( ASTNode ) null ) ; }
anishek/hive | public ReplicationSpec ( String fromId , String toId ) { this ( true , false , fromId , toId , false , false ) ; }
anishek/hive | public ReplicationSpec ( boolean isInReplicationScope , boolean isMetadataOnly , String eventReplicationState , String currentReplicationState , boolean isNoop , boolean isReplace ) { this . isInReplicationScope = isInReplicationScope ; this . isMetadataOnly = isMetadataOnly ; this . eventId = eventReplicationState ; this . currStateId = currentReplicationState ; this . isNoop = isNoop ; this . isReplace = isReplace ; this . specType = Type . DEFAULT ; }
anishek/hive | public ReplicationSpec ( Function < String , String > keyFetcher ) { String scope = keyFetcher . apply ( ReplicationSpec . KEY . REPL_SCOPE . toString ( ) ) ; this . isInReplicationScope = false ; this . isMetadataOnly = false ; this . specType = Type . DEFAULT ; if ( scope != null ) { if ( scope . equalsIgnoreCase ( " metadata " ) ) { this . isMetadataOnly = true ; this . isInReplicationScope = true ; } else if ( scope . equalsIgnoreCase ( " all " ) ) { this . isInReplicationScope = true ; } } this . eventId = keyFetcher . apply ( ReplicationSpec . KEY . EVENT_ID . toString ( ) ) ; this . currStateId = keyFetcher . apply ( ReplicationSpec . KEY . CURR_STATE_ID . toString ( ) ) ; this . isNoop = Boolean . parseBoolean ( keyFetcher . apply ( ReplicationSpec . KEY . NOOP . toString ( ) ) ) ; this . isReplace = Boolean . parseBoolean ( keyFetcher . apply ( ReplicationSpec . KEY . IS_REPLACE . toString ( ) ) ) ; this . validWriteIdList = keyFetcher . apply ( ReplicationSpec . KEY . VALID_WRITEID_LIST . toString ( ) ) ; this . validTxnList = keyFetcher . apply ( KEY . VALID_TXN_LIST . toString ( ) ) ; }
anishek/hive | public boolean allowReplacement ( String currReplState , String replacementReplState ) { if ( ( currReplState == null ) || ( currReplState . isEmpty ( ) ) ) { return true ; } if ( ( replacementReplState == null ) || ( replacementReplState . isEmpty ( ) ) ) { return false ; } long currReplStateLong = Long . parseLong ( currReplState . replaceAll ( " \\ D " , " " ) ) ; long replacementReplStateLong = Long . parseLong ( replacementReplState . replaceAll ( " \\ D " , " " ) ) ; if ( specType == Type . IMPORT ) { return ( currReplStateLong <= replacementReplStateLong ) ; } else { return ( currReplStateLong < replacementReplStateLong ) ; } }
anishek/hive | public boolean allowReplacementInto ( Map < String , String > params ) { return allowReplacement ( getLastReplicatedStateFromParameters ( params ) , getCurrentReplicationState ( ) ) ; }
anishek/hive | public boolean allowEventReplacementInto ( Map < String , String > params ) { return allowReplacement ( getLastReplicatedStateFromParameters ( params ) , getReplicationState ( ) ) ; }
anishek/hive | public Predicate < Partition > allowEventReplacementInto ( ) { return new Predicate < Partition > ( ) { @ Override public boolean apply ( @ Nullable Partition partition ) { if ( partition == null ) { return false ; } return ( allowEventReplacementInto ( partition . getParameters ( ) ) ) ; } } ; }
anishek/hive | private void init ( ASTNode node ) { isInReplicationScope = true ; eventId = PlanUtils . stripQuotes ( node . getChild ( 0 ) . getText ( ) ) ; if ( ( node . getChildCount ( ) > 1 ) && node . getChild ( 1 ) . getText ( ) . toLowerCase ( ) . equals ( " metadata " ) ) { isMetadataOnly = true ; try { if ( Long . parseLong ( eventId ) >= 0 ) { currStateId = eventId ; } } catch ( Exception ex ) { } } }
anishek/hive | public Type getReplSpecType ( ) { return this . specType ; }
anishek/hive | public void setReplSpecType ( Type specType ) { this . specType = specType ; }
anishek/hive | public boolean isInReplicationScope ( ) { return isInReplicationScope ; }
anishek/hive | public boolean isMetadataOnly ( ) { return isMetadataOnly ; }
anishek/hive | public void setIsMetadataOnly ( boolean isMetadataOnly ) { this . isMetadataOnly = isMetadataOnly ; }
anishek/hive | public boolean isMetadataOnlyForExternalTables ( ) { return isMetadataOnlyForExternalTables ; }
anishek/hive | public void setMetadataOnlyForExternalTables ( boolean metadataOnlyForExternalTables ) { isMetadataOnlyForExternalTables = metadataOnlyForExternalTables ; }
anishek/hive | public boolean isReplace ( ) { return isReplace ; }
anishek/hive | public void setIsReplace ( boolean isReplace ) { this . isReplace = isReplace ; }
anishek/hive | public String getReplicationState ( ) { return eventId ; }
anishek/hive | public String getCurrentReplicationState ( ) { return currStateId ; }
anishek/hive | public void setCurrentReplicationState ( String currStateId ) { this . currStateId = currStateId ; }
anishek/hive | public boolean isNoop ( ) { return isNoop ; }
anishek/hive | public void setNoop ( boolean isNoop ) { this . isNoop = isNoop ; }
anishek/hive | public String getValidWriteIdList ( ) { return validWriteIdList ; }
anishek/hive | public void setValidWriteIdList ( String validWriteIdList ) { this . validWriteIdList = validWriteIdList ; }
anishek/hive | public String getValidTxnList ( ) { return validTxnList ; }
anishek/hive | public void setValidTxnList ( String validTxnList ) { this . validTxnList = validTxnList ; }
anishek/hive | public boolean isTransactionalTableDump ( ) { return ( validWriteIdList != null ) ; }
anishek/hive | public String get ( KEY key ) { switch ( key ) { case REPL_SCOPE : switch ( getScope ( ) ) { case MD_ONLY : return " metadata " ; case REPL : return " all " ; case NO_REPL : return " none " ; } case EVENT_ID : return getReplicationState ( ) ; case CURR_STATE_ID : return getCurrentReplicationState ( ) ; case NOOP : return String . valueOf ( isNoop ( ) ) ; case IS_REPLACE : return String . valueOf ( isReplace ( ) ) ; case VALID_WRITEID_LIST : return getValidWriteIdList ( ) ; case VALID_TXN_LIST : return getValidTxnList ( ) ; } return null ; }
anishek/hive | public SCOPE getScope ( ) { if ( isInReplicationScope ( ) ) { if ( isMetadataOnly ( ) ) { return SCOPE . MD_ONLY ; } else { return SCOPE . REPL ; } } else { return SCOPE . NO_REPL ; } }
anishek/hive | public boolean isMigratingToTxnTable ( ) { return isMigratingToTxnTable ; }
anishek/hive | public void setMigratingToTxnTable ( ) { isMigratingToTxnTable = true ; }
anishek/hive | public boolean isMigratingToExternalTable ( ) { return isMigratingToExternalTable ; }
anishek/hive | public void setMigratingToExternalTable ( ) { isMigratingToExternalTable = true ; }
anishek/hive | public boolean needDupCopyCheck ( ) { return needDupCopyCheck ; }
anishek/hive | public void setNeedDupCopyCheck ( boolean isFirstIncPending ) { this . needDupCopyCheck = isFirstIncPending ; }
anishek/hive | public boolean isRepl ( ) { return isRepl ; }
anishek/hive | public void setRepl ( boolean repl ) { isRepl = repl ; }
aaneja/Twitter | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; binding = DataBindingUtil . setContentView ( this , R . layout . activity_compose_tweet ) ; }
aaneja/Twitter | public void onCancelClick ( View view ) { setResult ( RESULT_CANCELED ) ; finish ( ) ; }
aaneja/Twitter | public void onPublishTweetClick ( View view ) { final String tweetText = binding . etTweetText . getText ( ) . toString ( ) ; twitterClient . postTweet ( tweetText , new JsonHttpResponseHandler ( ) { @ Override public void onSuccess ( int statusCode , Header [ ] headers , JSONObject response ) { final Tweet postedTweet = new Tweet ( response ) ; Log . d ( " POSTTWEET " , " New ▁ tweet ▁ id : " + postedTweet . getId ( ) ) ; Intent data = new Intent ( ) ; data . putExtra ( NEW_TWEET , Parcels . wrap ( postedTweet ) ) ; setResult ( RESULT_OK , data ) ; finish ( ) ; } @ Override public void onFailure ( int statusCode , Header [ ] headers , Throwable throwable , JSONObject errorResponse ) { Toast . makeText ( ComposeTweetActivity . this , String . format ( " Error ▁ posting ▁ tweet ▁ : ▁ StatusCode ▁ : ▁ % d , ▁ ExceptionText : ▁ % s " , statusCode , throwable . getMessage ( ) ) , Toast . LENGTH_LONG ) ; super . onFailure ( statusCode , headers , throwable , errorResponse ) ; } } ) ; }
dcoraboeuf/ontrack | @ When ( " I ▁ create ▁ a ▁ $ name ▁ project ▁ with ▁ description ▁ \" $ description \" " ) public void create_project ( String name , String description ) { generalSteps . open_home_page ( ) ; projectSteps . create_project ( name , description ) ; }
dcoraboeuf/ontrack | @ When ( " I ▁ close ▁ the ▁ project ▁ page " ) public void project_page_close ( ) { projectSteps . project_page_close ( ) ; }
dcoraboeuf/ontrack | @ Then ( " I ▁ am ▁ on ▁ the ▁ $ name ▁ project ▁ page " ) public void project_page_check ( String name ) { projectSteps . project_page_check ( name ) ; }
jaltekruse/parquet-mr | public MessageType ( String name , Type ... fields ) { super ( Repetition . REPEATED , name , fields ) ; }
jaltekruse/parquet-mr | public MessageType ( String name , List < Type > fields ) { super ( Repetition . REPEATED , name , fields ) ; }
jaltekruse/parquet-mr | @ Override public void accept ( TypeVisitor visitor ) { visitor . visit ( this ) ; }
jaltekruse/parquet-mr | @ Override public void writeToStringBuilder ( StringBuilder sb , String indent ) { sb . append ( " message ▁ " ) . append ( getName ( ) ) . append ( getOriginalType ( ) == null ? " " : " ▁ ( " + getOriginalType ( ) + " ) " ) . append ( " ▁ { \n " ) ; membersDisplayString ( sb , " ▁ ▁ " ) ; sb . append ( " } \n " ) ; }
jaltekruse/parquet-mr | public int getMaxRepetitionLevel ( String ... path ) { return getMaxRepetitionLevel ( path , 0 ) - 1 ; }
jaltekruse/parquet-mr | public int getMaxDefinitionLevel ( String ... path ) { return getMaxDefinitionLevel ( path , 0 ) - 1 ; }
jaltekruse/parquet-mr | public Type getType ( String ... path ) { return getType ( path , 0 ) ; }
jaltekruse/parquet-mr | public ColumnDescriptor getColumnDescription ( String [ ] path ) { int maxRep = getMaxRepetitionLevel ( path ) ; int maxDef = getMaxDefinitionLevel ( path ) ; PrimitiveTypeName type = getType ( path ) . asPrimitiveType ( ) . getPrimitiveTypeName ( ) ; return new ColumnDescriptor ( path , type , maxRep , maxDef ) ; }
jaltekruse/parquet-mr | public List < String [ ] > getPaths ( ) { return this . getPaths ( 0 ) ; }
jaltekruse/parquet-mr | public List < ColumnDescriptor > getColumns ( ) { List < String [ ] > paths = this . getPaths ( 0 ) ; List < ColumnDescriptor > columns = new ArrayList < ColumnDescriptor > ( paths . size ( ) ) ; for ( String [ ] path : paths ) { columns . add ( new ColumnDescriptor ( path , getType ( path ) . asPrimitiveType ( ) . getPrimitiveTypeName ( ) , getMaxRepetitionLevel ( path ) , getMaxDefinitionLevel ( path ) ) ) ; } return columns ; }
jaltekruse/parquet-mr | @ Override public void checkContains ( Type subType ) { if ( ! ( subType instanceof MessageType ) ) { throw new InvalidRecordException ( subType + " ▁ found : ▁ expected ▁ " + this ) ; } super . checkContains ( subType ) ; }
jaltekruse/parquet-mr | public < T > T convertWith ( TypeConverter < T > converter ) { final ArrayList < GroupType > path = new ArrayList < GroupType > ( ) ; path . add ( this ) ; return converter . convertMessageType ( this , convertChildren ( path , converter ) ) ; }
jaltekruse/parquet-mr | public boolean containsPath ( String [ ] path ) { return containsPath ( path , 0 ) ; }
moghaddam/cas | public ISOStandardDateFormat ( ) { super ( DATE_FORMAT , TimeZone . getDefault ( ) , Locale . getDefault ( ) ) ; }
moghaddam/cas | public String getCurrentDateAndTime ( ) { return format ( new Date ( ) ) ; }
moghaddam/cas | public String format ( final DateTime dt ) { return format ( dt . toDate ( ) ) ; }
liufeiit/itmarry | public ApkCacheHelper ( Context paramContext ) { context = paramContext ; init ( paramContext ) ; }
liufeiit/itmarry | private void init ( Context paramContext ) { if ( init ) { return ; } init = true ; dbHelper = new DbHelper ( this . context ) ; apkCacheRepo = new HashMap < String , ApkCache > ( ) ; Cursor localCursor = dbHelper . getApkCacheCursor ( ) ; if ( localCursor != null ) { localCursor . moveToFirst ( ) ; } while ( true ) { if ( localCursor . isAfterLast ( ) ) { localCursor . close ( ) ; return ; } ApkCache localApkCache = new ApkCache ( ) ; localApkCache . appName = localCursor . getString ( localCursor . getColumnIndex ( " appName " ) ) ; localApkCache . pkgName = localCursor . getString ( localCursor . getColumnIndex ( " pkg " ) ) ; byte [ ] arrayOfByte = localCursor . getBlob ( localCursor . getColumnIndex ( " icon " ) ) ; if ( arrayOfByte != null ) { localApkCache . icon = new BitmapDrawable ( paramContext . getResources ( ) , BitmapFactory . decodeByteArray ( arrayOfByte , 0 , arrayOfByte . length ) ) ; } apkCacheRepo . put ( localApkCache . pkgName , localApkCache ) ; localCursor . moveToNext ( ) ; } }
liufeiit/itmarry | public ApkCache load ( String paramString ) { init ( context ) ; ApkCache localApkCache = apkCacheRepo . get ( paramString ) ; return localApkCache ; }
liufeiit/itmarry | public boolean save ( String packageName , Drawable paramDrawable , String apkInfoName ) { init ( context ) ; ApkCache localApkCache = new ApkCache ( ) ; localApkCache . appName = apkInfoName ; localApkCache . pkgName = packageName ; localApkCache . icon = paramDrawable ; if ( dbHelper . saveApkCache ( localApkCache ) != - 1L ) { apkCacheRepo . put ( packageName , localApkCache ) ; return true ; } return false ; }
pepstock-org/Charba | ArrayImageList ( ArrayImage array ) { if ( array == null ) { this . array = new ArrayImage ( ) ; } else { this . array = array ; } }
pepstock-org/Charba | public ArrayImageList ( ) { this ( null ) ; }
pepstock-org/Charba | @ Override ArrayImage getArray ( ) { return array ; }
pepstock-org/Charba | public void addAll ( Img ... values ) { if ( values != null && values . length > 0 ) { for ( Img val : values ) { add ( val ) ; } } }
pepstock-org/Charba | @ Override public boolean add ( Img element ) { if ( element != null ) { array . push ( element ) ; return true ; } return false ; }
pepstock-org/Charba | @ Override public boolean addAll ( Collection < ? extends Img > collection ) { boolean modified = collection != null && ! collection . isEmpty ( ) ; if ( modified ) { Iterator < ? extends Img > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { modified = modified && add ( iter . next ( ) ) ; } } return modified ; }
pepstock-org/Charba | @ Override public boolean retainAll ( Collection < ? > collection ) { boolean modified = collection != null && ! collection . isEmpty ( ) ; if ( modified ) { List < Img > contained = new ArrayList < > ( ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { Img value = get ( i ) ; if ( ! collection . contains ( value ) ) { contained . add ( value ) ; } } if ( ! contained . isEmpty ( ) ) { for ( Img toRemove : contained ) { modified = modified && remove ( toRemove ) ; } } } return modified ; }
pepstock-org/Charba | @ Override public void clear ( ) { array . clear ( ) ; }
pepstock-org/Charba | @ Override public Img get ( int index ) { if ( checkRange ( index ) ) { return array . get ( index ) ; } return null ; }
pepstock-org/Charba | @ Override public Img set ( int index , Img element ) { if ( element != null && checkRange ( index ) ) { Img old = array . get ( index ) ; array . set ( index , element ) ; return old ; } return null ; }
pepstock-org/Charba | @ Override public void add ( int index , Img element ) { if ( element != null ) { array . insertAt ( index , element ) ; } }
pepstock-org/Charba | @ Override public Img remove ( int index ) { if ( checkRange ( index ) ) { return array . remove ( index ) ; } return Undefined . IMAGE_ELEMENT ; }
pepstock-org/Charba | @ Override public int indexOf ( Object object ) { if ( object instanceof Img ) { Img value = ( Img ) object ; return array . indexOf ( value ) ; } return AbstractArrayList . NOT_FOUND ; }
pepstock-org/Charba | @ Override public int lastIndexOf ( Object object ) { if ( object instanceof Img ) { Img value = ( Img ) object ; return array . lastIndexOf ( value ) ; } return AbstractArrayList . NOT_FOUND ; }
pepstock-org/Charba | @ Override public Object [ ] toArray ( ) { Object [ ] toArray = new Object [ array . length ( ) ] ; for ( int i = 0 ; i < array . length ( ) ; i ++ ) { toArray [ i ] = array . get ( i ) ; } return toArray ; }
rkistner/binarization | public int findThreshold ( int [ ] h ) { int n = h . length ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total += h [ i ] ; } double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = ( double ) h [ i ] / total ; } double max = Double . MIN_VALUE ; int best = 0 ; for ( int T = 1 ; T < n ; T ++ ) { double sum1a = 0 ; double sum1b = 0 ; for ( int i = 0 ; i < T ; i ++ ) { if ( p [ i ] > 0 ) { sum1a += p [ i ] ; sum1b += p [ i ] * Math . log ( p [ i ] ) ; } } double sum2a = 0 ; double sum2b = 0 ; for ( int i = T ; i < n ; i ++ ) { if ( p [ i ] > 0 ) { sum2a += p [ i ] ; sum2b += p [ i ] * Math . log ( p [ i ] ) ; } } double theTotal = Math . log ( sum1a ) + Math . log ( sum2a ) - sum1b / sum1a - sum2b / sum2a ; if ( theTotal > max ) { max = theTotal ; best = T ; } } return best ; }
rkistner/binarization | public String toString ( ) { return " Kapur " ; }
nikgoodley-ibboost/jsparklines | public XYDataPoint ( double x , double y ) { this . x = x ; this . y = y ; }
nikgoodley-ibboost/jsparklines | public XYDataPoint ( double x , double y , boolean compareBasedOnFirstDataPoint ) { this . x = x ; this . y = y ; this . compareBasedOnFirstDataPoint = compareBasedOnFirstDataPoint ; }
nikgoodley-ibboost/jsparklines | public double getX ( ) { return x ; }
nikgoodley-ibboost/jsparklines | public void setX ( double x ) { this . x = x ; }
nikgoodley-ibboost/jsparklines | public double getY ( ) { return y ; }
nikgoodley-ibboost/jsparklines | public void setY ( double y ) { this . y = y ; }
nikgoodley-ibboost/jsparklines | public String toString ( ) { return " " + Util . roundDouble ( x , 2 ) ; }
nikgoodley-ibboost/jsparklines | public int compareTo ( XYDataPoint o ) { if ( compareBasedOnFirstDataPoint ) { return Double . compare ( this . x , o . x ) ; } else { return Double . compare ( this . x + this . y , o . x + o . y ) ; } }
gemmellr/qpid-proton-j | @ Test public void testCompareToWithSameObject ( ) { TaskImpl task = new TaskImpl ( 1000 , 1 ) ; Assert . assertEquals ( 0 , task . compareTo ( task ) ) ; }
gemmellr/qpid-proton-j | @ Test public void testCompareToWithDifferentDeadlines ( ) { TaskImpl task1 = new TaskImpl ( 1000 , 1 ) ; TaskImpl task2 = new TaskImpl ( 2000 , 2 ) ; Assert . assertTrue ( task1 . compareTo ( task2 ) < 0 ) ; Assert . assertTrue ( task2 . compareTo ( task1 ) > 0 ) ; }
gemmellr/qpid-proton-j | @ Test public void testCompareToWithSameDeadlines ( ) { int deadline = 1000 ; TaskImpl task1 = new TaskImpl ( deadline , 1 ) ; TaskImpl task2 = new TaskImpl ( deadline , 2 ) ; Assert . assertTrue ( " Expected ▁ task1 ▁ to ▁ order ▁ ' less ' ▁ due ▁ to ▁ being ▁ created ▁ first " , task1 . compareTo ( task2 ) < 0 ) ; Assert . assertTrue ( " Expected ▁ task2 ▁ to ▁ order ▁ ' greater ' ▁ due ▁ to ▁ being ▁ created ▁ second " , task1 . compareTo ( task2 ) < 0 ) ; Assert . assertTrue ( task2 . compareTo ( task1 ) > 0 ) ; }
weiwenqiang/GitHub | public CupcakeDetector ( Context context ) { final ViewConfiguration configuration = ViewConfiguration . get ( context ) ; mMinimumVelocity = configuration . getScaledMinimumFlingVelocity ( ) ; mTouchSlop = configuration . getScaledTouchSlop ( ) ; }
weiwenqiang/GitHub | float getActiveX ( MotionEvent ev ) { return ev . getX ( ) ; }
weiwenqiang/GitHub | float getActiveY ( MotionEvent ev ) { return ev . getY ( ) ; }
weiwenqiang/GitHub | public boolean isScaling ( ) { return false ; }
weiwenqiang/GitHub | @ Override public boolean onTouchEvent ( MotionEvent ev ) { switch ( ev . getAction ( ) ) { case MotionEvent . ACTION_DOWN : { mVelocityTracker = VelocityTracker . obtain ( ) ; mVelocityTracker . addMovement ( ev ) ; mLastTouchX = getActiveX ( ev ) ; mLastTouchY = getActiveY ( ev ) ; mIsDragging = false ; break ; } case MotionEvent . ACTION_MOVE : { final float x = getActiveX ( ev ) ; final float y = getActiveY ( ev ) ; final float dx = x - mLastTouchX , dy = y - mLastTouchY ; if ( ! mIsDragging ) { mIsDragging = ( float ) Math . sqrt ( ( dx * dx ) + ( dy * dy ) ) >= mTouchSlop ; } if ( mIsDragging ) { mListener . onDrag ( dx , dy ) ; mLastTouchX = x ; mLastTouchY = y ; if ( null != mVelocityTracker ) { mVelocityTracker . addMovement ( ev ) ; } } break ; } case MotionEvent . ACTION_CANCEL : { if ( null != mVelocityTracker ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } break ; } case MotionEvent . ACTION_UP : { if ( mIsDragging ) { if ( null != mVelocityTracker ) { mLastTouchX = getActiveX ( ev ) ; mLastTouchY = getActiveY ( ev ) ; mVelocityTracker . addMovement ( ev ) ; mVelocityTracker . computeCurrentVelocity ( 1000 ) ; final float vX = mVelocityTracker . getXVelocity ( ) , vY = mVelocityTracker . getYVelocity ( ) ; if ( Math . max ( Math . abs ( vX ) , Math . abs ( vY ) ) >= mMinimumVelocity ) { mListener . onFling ( mLastTouchX , mLastTouchY , - vX , - vY ) ; } } } if ( null != mVelocityTracker ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } break ; } } return true ; }
weiwenqiang/GitHub | public EclairDetector ( Context context ) { super ( context ) ; }
weiwenqiang/GitHub | @ Override float getActiveX ( MotionEvent ev ) { try { return ev . getX ( mActivePointerIndex ) ; } catch ( Exception e ) { return ev . getX ( ) ; } }
weiwenqiang/GitHub | @ Override float getActiveY ( MotionEvent ev ) { try { return ev . getY ( mActivePointerIndex ) ; } catch ( Exception e ) { return ev . getY ( ) ; } }
weiwenqiang/GitHub | @ Override public boolean onTouchEvent ( MotionEvent ev ) { final int action = ev . getAction ( ) ; switch ( action & MotionEvent . ACTION_MASK ) { case MotionEvent . ACTION_DOWN : mActivePointerId = ev . getPointerId ( 0 ) ; break ; case MotionEvent . ACTION_CANCEL : case MotionEvent . ACTION_UP : mActivePointerId = INVALID_POINTER_ID ; break ; case MotionEvent . ACTION_POINTER_UP : final int pointerIndex = ( ev . getAction ( ) & MotionEvent . ACTION_POINTER_INDEX_MASK ) >> MotionEvent . ACTION_POINTER_INDEX_SHIFT ; final int pointerId = ev . getPointerId ( pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == 0 ? 1 : 0 ; mActivePointerId = ev . getPointerId ( newPointerIndex ) ; mLastTouchX = ev . getX ( newPointerIndex ) ; mLastTouchY = ev . getY ( newPointerIndex ) ; } break ; } mActivePointerIndex = ev . findPointerIndex ( mActivePointerId != INVALID_POINTER_ID ? mActivePointerId : 0 ) ; return super . onTouchEvent ( ev ) ; }
weiwenqiang/GitHub | private final OnScaleGestureListener mScaleListener = new OnScaleGestureListener ( ) { @ Override public boolean onScale ( ScaleGestureDetector detector ) { mListener . onScale ( detector . getScaleFactor ( ) , detector . getFocusX ( ) , detector . getFocusY ( ) ) ; return true ; } @ Override public boolean onScaleBegin ( ScaleGestureDetector detector ) { return true ; } @ Override public void onScaleEnd ( ScaleGestureDetector detector ) { } }
weiwenqiang/GitHub | public FroyoDetector ( Context context ) { super ( context ) ; mDetector = new ScaleGestureDetector ( context , mScaleListener ) ; }
weiwenqiang/GitHub | @ Override public boolean isScaling ( ) { return mDetector . isInProgress ( ) ; }
weiwenqiang/GitHub | @ Override public boolean onTouchEvent ( MotionEvent ev ) { mDetector . onTouchEvent ( ev ) ; return super . onTouchEvent ( ev ) ; }
derekhiggins/ovirt-engine | public AuditLogableBase ( ) { }
derekhiggins/ovirt-engine | public AuditLogableBase ( final NGuid vdsId ) { mVdsId = vdsId ; }
derekhiggins/ovirt-engine | public AuditLogableBase ( final NGuid vdsId , final Guid vmId ) { this ( vdsId ) ; mVmId = vmId ; }
derekhiggins/ovirt-engine | public NGuid getUserId ( ) { if ( mUserId . equals ( Guid . Empty ) && getCurrentUser ( ) != null ) { mUserId = getCurrentUser ( ) . getUserId ( ) ; } return mUserId ; }
derekhiggins/ovirt-engine | public void setUserId ( final NGuid value ) { mUserId = value . getValue ( ) ; }
derekhiggins/ovirt-engine | public String getUserName ( ) { if ( StringUtils . isEmpty ( mUserName ) && getCurrentUser ( ) != null ) { mUserName = getCurrentUser ( ) . getUserName ( ) ; } return mUserName ; }
derekhiggins/ovirt-engine | public void setUserName ( final String value ) { mUserName = value ; }
derekhiggins/ovirt-engine | public IVdcUser getCurrentUser ( ) { return mVdcUser ; }
derekhiggins/ovirt-engine | public void setCurrentUser ( final IVdcUser value ) { mVdcUser = value ; }
derekhiggins/ovirt-engine | public Guid getVmTemplateId ( ) { return getVmTemplateIdRef ( ) != null ? getVmTemplateIdRef ( ) . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public void setVmTemplateId ( final Guid value ) { mVmTemplateId = value ; }
derekhiggins/ovirt-engine | public NGuid getVmTemplateIdRef ( ) { if ( mVmTemplateId == null && getVmTemplate ( ) != null ) { mVmTemplateId = getVmTemplate ( ) . getId ( ) ; } return mVmTemplateId ; }
derekhiggins/ovirt-engine | public String getVmTemplateName ( ) { if ( mVmTemplateName == null && getVmTemplate ( ) != null ) { mVmTemplateName = getVmTemplate ( ) . getname ( ) ; } return mVmTemplateName ; }
derekhiggins/ovirt-engine | protected void setVmTemplateName ( final String value ) { mVmTemplateName = value ; }
derekhiggins/ovirt-engine | public Guid getVmId ( ) { return getVmIdRef ( ) != null ? getVmIdRef ( ) . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public void setVmId ( final Guid value ) { mVmId = value ; }
derekhiggins/ovirt-engine | public String getSnapshotName ( ) { return privateSnapshotName ; }
derekhiggins/ovirt-engine | public void setSnapshotName ( final String value ) { privateSnapshotName = value ; }
derekhiggins/ovirt-engine | public NGuid getVmIdRef ( ) { if ( mVmId == null && getVm ( ) != null ) { mVmId = getVm ( ) . getId ( ) ; } return mVmId ; }
derekhiggins/ovirt-engine | public String getVmName ( ) { if ( mVmName == null && getVm ( ) != null ) { mVmName = getVm ( ) . getvm_name ( ) ; } return mVmName ; }
derekhiggins/ovirt-engine | protected void setVmName ( final String value ) { mVmName = value ; }
derekhiggins/ovirt-engine | public NGuid getVdsIdRef ( ) { if ( mVdsId == null && getVds ( ) != null ) { mVdsId = getVds ( ) . getId ( ) ; } return mVdsId ; }
derekhiggins/ovirt-engine | protected void setVdsIdRef ( final NGuid value ) { mVdsId = value ; }
derekhiggins/ovirt-engine | public Guid getVdsId ( ) { return mVdsId != null ? mVdsId . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public void setVdsId ( final Guid value ) { mVdsId = value ; }
derekhiggins/ovirt-engine | public String getVdsName ( ) { if ( mVdsName == null && getVds ( ) != null ) { mVdsName = getVds ( ) . getvds_name ( ) ; } return mVdsName ; }
derekhiggins/ovirt-engine | protected void setVdsName ( final String value ) { mVdsName = value ; }
derekhiggins/ovirt-engine | public Guid getQuotaId ( ) { return getQuotaIdRef ( ) != null ? getQuotaIdRef ( ) . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public Guid getQuotaIdRef ( ) { if ( quotaId == null && getQuota ( ) != null ) { quotaId = getQuota ( ) . getId ( ) ; } return quotaId ; }
derekhiggins/ovirt-engine | public void setQuotaId ( final Guid value ) { quotaId = value ; }
derekhiggins/ovirt-engine | public String getQuotaName ( ) { if ( quotaName == null && getQuota ( ) != null ) { quotaName = getQuota ( ) . getQuotaName ( ) ; } return quotaName ; }
derekhiggins/ovirt-engine | protected void setQuotaName ( final String value ) { quotaName = value ; }
derekhiggins/ovirt-engine | public storage_domains getStorageDomain ( ) { if ( _storageDomain == null && getStorageDomainId ( ) != null ) { if ( _storagePoolId != null && getStoragePool ( ) != null ) { _storageDomain = getStorageDomainDAO ( ) . getForStoragePool ( getStorageDomainId ( ) . getValue ( ) , getStoragePool ( ) . getId ( ) ) ; } if ( _storageDomain == null ) { final List < storage_domains > storageDomainList = getStorageDomainDAO ( ) . getAllForStorageDomain ( getStorageDomainId ( ) . getValue ( ) ) ; if ( storageDomainList . size ( ) != 0 ) { _storageDomain = storageDomainList . get ( 0 ) ; for ( final storage_domains storageDomainFromList : storageDomainList ) { if ( storageDomainFromList . getstatus ( ) != null && storageDomainFromList . getstatus ( ) == StorageDomainStatus . Active ) { _storageDomain = storageDomainFromList ; break ; } } } } } return _storageDomain ; }
derekhiggins/ovirt-engine | public void setStorageDomain ( final storage_domains value ) { _storageDomain = value ; }
derekhiggins/ovirt-engine | public NGuid getStorageDomainId ( ) { if ( _storageDomain != null ) { return _storageDomain . getId ( ) ; } return _storageDomainId ; }
derekhiggins/ovirt-engine | public void setStorageDomainId ( final NGuid value ) { _storageDomainId = value ; }
derekhiggins/ovirt-engine | public String getStorageDomainName ( ) { if ( getStorageDomain ( ) != null ) { return getStorageDomain ( ) . getstorage_name ( ) ; } return " " ; }
derekhiggins/ovirt-engine | public storage_pool getStoragePool ( ) { if ( _storagePool == null && getStoragePoolId ( ) != null && ! Guid . Empty . equals ( getStoragePoolId ( ) ) ) { _storagePool = getStoragePoolDAO ( ) . get ( getStoragePoolId ( ) . getValue ( ) ) ; } return _storagePool ; }
derekhiggins/ovirt-engine | public void setStoragePool ( final storage_pool value ) { _storagePool = value ; }
derekhiggins/ovirt-engine | public NGuid getStoragePoolId ( ) { if ( _storagePoolId == null ) { if ( _storagePool != null ) { _storagePoolId = _storagePool . getId ( ) ; } else if ( getStorageDomain ( ) != null ) { _storagePoolId = getStorageDomain ( ) . getstorage_pool_id ( ) ; } } return _storagePoolId ; }
derekhiggins/ovirt-engine | public void setStoragePoolId ( final NGuid value ) { _storagePoolId = value ; }
derekhiggins/ovirt-engine | public String getStoragePoolName ( ) { if ( getStoragePool ( ) != null ) { return getStoragePool ( ) . getname ( ) ; } return " " ; }
derekhiggins/ovirt-engine | public AuditLogType getAuditLogTypeValue ( ) { return AuditLogType . UNASSIGNED ; }
derekhiggins/ovirt-engine | protected Quota getQuota ( ) { if ( quota == null && quotaId != null ) { try { quota = getQuotaDAO ( ) . getById ( getQuotaId ( ) ) ; } catch ( final RuntimeException e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ quota ▁ { 0 } \n { 1 } " , quotaId , e . getMessage ( ) ) ; } } return quota ; }
derekhiggins/ovirt-engine | protected void setQuota ( final Quota value ) { quota = value ; quotaName = null ; }
derekhiggins/ovirt-engine | protected VDS getVds ( ) { if ( mVds == null && ( mVdsId != null || ( getVm ( ) != null && getVm ( ) . getrun_on_vds ( ) != null ) ) ) { if ( mVdsId == null ) { mVdsId = new Guid ( getVm ( ) . getrun_on_vds ( ) . toString ( ) ) ; } try { mVds = getVdsDAO ( ) . get ( getVdsId ( ) ) ; } catch ( final RuntimeException e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ vds ▁ { 0 } \n { 1 } " , mVdsId , e . getMessage ( ) ) ; } } return mVds ; }
derekhiggins/ovirt-engine | protected void setVds ( final VDS value ) { mVds = value ; mVdsName = null ; }
derekhiggins/ovirt-engine | public VM getVm ( ) { if ( mVm == null && mVmId != null && ! mVmId . equals ( Guid . Empty ) ) { try { mVm = getVmDAO ( ) . get ( mVmId . getValue ( ) ) ; if ( mVm != null ) { mVm . setInterfaces ( getVmNetworkInterfaceDAO ( ) . getAllForVm ( mVmId . getValue ( ) ) ) ; } } catch ( final Exception e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ vm ▁ { 0 } " , mVmId ) ; log . debug ( e ) ; } } return mVm ; }
derekhiggins/ovirt-engine | protected void setVm ( final VM value ) { mVm = value ; }
derekhiggins/ovirt-engine | public VmTemplate getVmTemplate ( ) { if ( mVmTemplate == null && ( mVmTemplateId != null || getVm ( ) != null ) ) { mVmTemplate = getVmTemplateDAO ( ) . get ( mVmTemplateId != null ? getVmTemplateId ( ) : getVm ( ) . getvmt_guid ( ) ) ; } return mVmTemplate ; }
derekhiggins/ovirt-engine | protected void setVmTemplate ( final VmTemplate value ) { mVmTemplate = value ; }
derekhiggins/ovirt-engine | public Guid getVdsGroupId ( ) { if ( mVdsGroupId != null ) { return mVdsGroupId ; } else if ( getVdsGroup ( ) != null ) { mVdsGroupId = getVdsGroup ( ) . getId ( ) ; return mVdsGroupId ; } else { return Guid . Empty ; } }
derekhiggins/ovirt-engine | public void setVdsGroupId ( final Guid value ) { mVdsGroupId = value ; }
derekhiggins/ovirt-engine | protected VDSGroup getVdsGroup ( ) { if ( mVdsGroup == null ) { if ( mVdsGroupId != null ) { mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } else if ( getVds ( ) != null ) { mVdsGroupId = getVds ( ) . getvds_group_id ( ) ; mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } else if ( getVm ( ) != null ) { mVdsGroupId = getVm ( ) . getvds_group_id ( ) ; mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } } return mVdsGroup ; }
derekhiggins/ovirt-engine | protected void setVdsGroup ( final VDSGroup value ) { mVdsGroup = value ; }
derekhiggins/ovirt-engine | public String getVdsGroupName ( ) { if ( getVdsGroup ( ) != null ) { return getVdsGroup ( ) . getname ( ) ; } return " " ; }
derekhiggins/ovirt-engine | protected void log ( ) { final Transaction transaction = TransactionSupport . suspend ( ) ; try { try { AuditLogDirector . log ( this ) ; } catch ( final RuntimeException ex ) { log . errorFormat ( " Error ▁ during ▁ log ▁ command : ▁ { 0 } . ▁ Exception ▁ { 1 } " , getClass ( ) . getName ( ) , ex ) ; } } finally { TransactionSupport . resume ( transaction ) ; } }
derekhiggins/ovirt-engine | public void DefaultLog ( ) { }
derekhiggins/ovirt-engine | public void AddCustomValue ( final String name , final String value ) { customValues . put ( name . toLowerCase ( ) , value ) ; }
derekhiggins/ovirt-engine | public void AddCustomValue ( CustomAuditLogKeys key , final String value ) { AddCustomValue ( key . name ( ) , value ) ; }
derekhiggins/ovirt-engine | public void AppendCustomValue ( final String name , final String value , final String separator ) { final String key = name . toLowerCase ( ) ; String newValue = value ; if ( customValues . containsKey ( key ) ) { newValue = String . format ( " % 1 $ s % 2 $ s % 3 $ s " , customValues . get ( key ) , separator , value ) ; } customValues . put ( name . toLowerCase ( ) , newValue ) ; }
derekhiggins/ovirt-engine | public Map < String , String > getCustomValues ( ) { return customValues ; }
derekhiggins/ovirt-engine | @ Override protected String getKey ( ) { return getAuditLogTypeValue ( ) . toString ( ) ; }
derekhiggins/ovirt-engine | public String GetCustomValue ( final String name ) { if ( customValues . containsKey ( name ) ) { return customValues . get ( name ) ; } return " " ; }
derekhiggins/ovirt-engine | public void setCorrelationId ( String correlationId ) { this . correlationId = correlationId ; }
derekhiggins/ovirt-engine | public String getCorrelationId ( ) { return correlationId ; }
derekhiggins/ovirt-engine | public void setJobId ( NGuid jobId ) { this . jobId = jobId ; }
derekhiggins/ovirt-engine | public NGuid getJobId ( ) { return jobId ; }
derekhiggins/ovirt-engine | public boolean isInternalExecution ( ) { return isInternalExecution ; }
derekhiggins/ovirt-engine | public void setInternalExecution ( boolean isInternalExecution ) { this . isInternalExecution = isInternalExecution ; }
derekhiggins/ovirt-engine | public NGuid getGlusterVolumeId ( ) { return glusterVolumeId ; }
derekhiggins/ovirt-engine | public void setGlusterVolumeId ( NGuid value ) { glusterVolumeId = value ; }
derekhiggins/ovirt-engine | public String getGlusterVolumeName ( ) { if ( glusterVolumeName == null && getGlusterVolume ( ) != null ) { glusterVolumeName = getGlusterVolume ( ) . getName ( ) ; } return glusterVolumeName ; }
derekhiggins/ovirt-engine | public void setGlusterVolumeName ( String value ) { glusterVolumeName = value ; }
derekhiggins/ovirt-engine | protected GlusterVolumeEntity getGlusterVolume ( ) { if ( glusterVolume == null && glusterVolumeId != null ) { glusterVolume = getGlusterVolumeDao ( ) . getById ( glusterVolumeId . getValue ( ) ) ; } return glusterVolume ; }
derekhiggins/ovirt-engine | public GlusterVolumeDao getGlusterVolumeDao ( ) { return getDbFacade ( ) . getGlusterVolumeDao ( ) ; }
derekhiggins/ovirt-engine | public StorageDomainDAO getStorageDomainDAO ( ) { return getDbFacade ( ) . getStorageDomainDAO ( ) ; }
derekhiggins/ovirt-engine | public StoragePoolDAO getStoragePoolDAO ( ) { return getDbFacade ( ) . getStoragePoolDAO ( ) ; }
derekhiggins/ovirt-engine | public VdsDAO getVdsDAO ( ) { return getDbFacade ( ) . getVdsDAO ( ) ; }
derekhiggins/ovirt-engine | public QuotaDAO getQuotaDAO ( ) { return getDbFacade ( ) . getQuotaDAO ( ) ; }
derekhiggins/ovirt-engine | public VmTemplateDAO getVmTemplateDAO ( ) { return getDbFacade ( ) . getVmTemplateDAO ( ) ; }
derekhiggins/ovirt-engine | protected VmDAO getVmDAO ( ) { return getDbFacade ( ) . getVmDAO ( ) ; }
derekhiggins/ovirt-engine | public VmStaticDAO getVmStaticDAO ( ) { return getDbFacade ( ) . getVmStaticDAO ( ) ; }
derekhiggins/ovirt-engine | protected VmStatisticsDAO getVmStatisticsDAO ( ) { return getDbFacade ( ) . getVmStatisticsDAO ( ) ; }
derekhiggins/ovirt-engine | public VdsGroupDAO getVdsGroupDAO ( ) { return getDbFacade ( ) . getVdsGroupDAO ( ) ; }
derekhiggins/ovirt-engine | public RoleDAO getRoleDao ( ) { return getDbFacade ( ) . getRoleDAO ( ) ; }
derekhiggins/ovirt-engine | public RoleGroupMapDAO getRoleGroupMapDAO ( ) { return getDbFacade ( ) . getRoleGroupMapDAO ( ) ; }
derekhiggins/ovirt-engine | public PermissionDAO getPermissionDAO ( ) { return getDbFacade ( ) . getPermissionDAO ( ) ; }
derekhiggins/ovirt-engine | public DbUserDAO getDbUserDAO ( ) { return getDbFacade ( ) . getDbUserDAO ( ) ; }
derekhiggins/ovirt-engine | public AdGroupDAO getAdGroupDAO ( ) { return getDbFacade ( ) . getAdGroupDAO ( ) ; }
derekhiggins/ovirt-engine | protected VmNetworkInterfaceDAO getVmNetworkInterfaceDAO ( ) { return getDbFacade ( ) . getVmNetworkInterfaceDAO ( ) ; }
derekhiggins/ovirt-engine | protected NetworkClusterDAO getNetworkClusterDAO ( ) { return getDbFacade ( ) . getNetworkClusterDAO ( ) ; }
derekhiggins/ovirt-engine | protected NetworkDAO getNetworkDAO ( ) { return getDbFacade ( ) . getNetworkDAO ( ) ; }
derekhiggins/ovirt-engine | protected DbFacade getDbFacade ( ) { return DbFacade . getInstance ( ) ; }
melthaw/spring-backend-boilerplate | @ Override public void onApplicationEvent ( ApplicationFailedEvent event ) { if ( StringUtils . isEmpty ( webhookConfigurationProperties . getUrl ( ) ) ) { return ; } webhookClient . sendMessage ( webhookConfigurationProperties . getUrl ( ) , String . format ( " % s ▁ startup ▁ failed . ▁ The ▁ cause ▁ is ▁ % s " , getAppName ( ) , event . getException ( ) . getMessage ( ) ) , event . getException ( ) . getMessage ( ) ) ; }
markharwood/elasticsearch | public Version getVersion ( ) { return this . version ; }
markharwood/elasticsearch | public StreamOutput setVersion ( Version version ) { this . version = version ; return this ; }
markharwood/elasticsearch | public long position ( ) throws IOException { throw new UnsupportedOperationException ( ) ; }
markharwood/elasticsearch | public void seek ( long position ) throws IOException { throw new UnsupportedOperationException ( ) ; }
markharwood/elasticsearch | public void writeBytes ( byte [ ] b ) throws IOException { writeBytes ( b , 0 , b . length ) ; }
markharwood/elasticsearch | public void writeBytes ( byte [ ] b , int length ) throws IOException { writeBytes ( b , 0 , length ) ; }
markharwood/elasticsearch | public void writeByteArray ( byte [ ] b ) throws IOException { writeVInt ( b . length ) ; writeBytes ( b , 0 , b . length ) ; }
markharwood/elasticsearch | public void writeBytesReference ( @ Nullable BytesReference bytes ) throws IOException { if ( bytes == null ) { writeVInt ( 0 ) ; return ; } writeVInt ( bytes . length ( ) ) ; bytes . writeTo ( this ) ; }
markharwood/elasticsearch | public void writeBytesRef ( BytesRef bytes ) throws IOException { if ( bytes == null ) { writeVInt ( 0 ) ; return ; } writeVInt ( bytes . length ) ; write ( bytes . bytes , bytes . offset , bytes . length ) ; }
markharwood/elasticsearch | public final void writeShort ( short v ) throws IOException { writeByte ( ( byte ) ( v >> 8 ) ) ; writeByte ( ( byte ) v ) ; }
markharwood/elasticsearch | public void writeInt ( int i ) throws IOException { writeByte ( ( byte ) ( i >> 24 ) ) ; writeByte ( ( byte ) ( i >> 16 ) ) ; writeByte ( ( byte ) ( i >> 8 ) ) ; writeByte ( ( byte ) i ) ; }
markharwood/elasticsearch | public void writeVInt ( int i ) throws IOException { while ( ( i & ~ 0x7F ) != 0 ) { writeByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i >>>= 7 ; } writeByte ( ( byte ) i ) ; }
markharwood/elasticsearch | public void writeLong ( long i ) throws IOException { writeInt ( ( int ) ( i >> 32 ) ) ; writeInt ( ( int ) i ) ; }
markharwood/elasticsearch | public void writeVLong ( long i ) throws IOException { assert i >= 0 ; while ( ( i & ~ 0x7F ) != 0 ) { writeByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i >>>= 7 ; } writeByte ( ( byte ) i ) ; }
markharwood/elasticsearch | public void writeZLong ( long i ) throws IOException { long value = BitUtil . zigZagEncode ( i ) ; while ( ( value & 0xFFFFFFFFFFFFFF80L ) != 0L ) { writeByte ( ( byte ) ( ( value & 0x7F ) | 0x80 ) ) ; value >>>= 7 ; } writeByte ( ( byte ) ( value & 0x7F ) ) ; }
markharwood/elasticsearch | public void writeOptionalString ( @ Nullable String str ) throws IOException { if ( str == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeString ( str ) ; } }
markharwood/elasticsearch | public void writeOptionalVInt ( @ Nullable Integer integer ) throws IOException { if ( integer == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeVInt ( integer ) ; } }
markharwood/elasticsearch | public void writeOptionalText ( @ Nullable Text text ) throws IOException { if ( text == null ) { writeInt ( - 1 ) ; } else { writeText ( text ) ; } }
markharwood/elasticsearch | public void writeText ( Text text ) throws IOException { if ( ! text . hasBytes ( ) ) { final String string = text . string ( ) ; spare . copyChars ( string ) ; writeInt ( spare . length ( ) ) ; write ( spare . bytes ( ) , 0 , spare . length ( ) ) ; } else { BytesReference bytes = text . bytes ( ) ; writeInt ( bytes . length ( ) ) ; bytes . writeTo ( this ) ; } }
markharwood/elasticsearch | public void writeString ( String str ) throws IOException { int charCount = str . length ( ) ; writeVInt ( charCount ) ; int c ; for ( int i = 0 ; i < charCount ; i ++ ) { c = str . charAt ( i ) ; if ( c <= 0x007F ) { writeByte ( ( byte ) c ) ; } else if ( c > 0x07FF ) { writeByte ( ( byte ) ( 0xE0 | c >> 12 & 0x0F ) ) ; writeByte ( ( byte ) ( 0x80 | c >> 6 & 0x3F ) ) ; writeByte ( ( byte ) ( 0x80 | c >> 0 & 0x3F ) ) ; } else { writeByte ( ( byte ) ( 0xC0 | c >> 6 & 0x1F ) ) ; writeByte ( ( byte ) ( 0x80 | c >> 0 & 0x3F ) ) ; } } }
markharwood/elasticsearch | public void writeFloat ( float v ) throws IOException { writeInt ( Float . floatToIntBits ( v ) ) ; }
markharwood/elasticsearch | public void writeDouble ( double v ) throws IOException { writeLong ( Double . doubleToLongBits ( v ) ) ; }
markharwood/elasticsearch | public void writeBoolean ( boolean b ) throws IOException { writeByte ( b ? ONE : ZERO ) ; }
markharwood/elasticsearch | public void writeOptionalBoolean ( @ Nullable Boolean b ) throws IOException { if ( b == null ) { writeByte ( TWO ) ; } else { writeByte ( b ? ONE : ZERO ) ; } }
markharwood/elasticsearch | @ Override public void write ( int b ) throws IOException { writeByte ( ( byte ) b ) ; }
markharwood/elasticsearch | @ Override public void write ( byte [ ] b , int off , int len ) throws IOException { writeBytes ( b , off , len ) ; }
markharwood/elasticsearch | public void writeStringArray ( String [ ] array ) throws IOException { writeVInt ( array . length ) ; for ( String s : array ) { writeString ( s ) ; } }
markharwood/elasticsearch | public void writeStringArrayNullable ( @ Nullable String [ ] array ) throws IOException { if ( array == null ) { writeVInt ( 0 ) ; } else { writeVInt ( array . length ) ; for ( String s : array ) { writeString ( s ) ; } } }
markharwood/elasticsearch | public void writeOptionalStringArray ( @ Nullable String [ ] array ) throws IOException { if ( array == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeStringArray ( array ) ; } }
markharwood/elasticsearch | public void writeMap ( @ Nullable Map < String , Object > map ) throws IOException { writeGenericValue ( map ) ; }
markharwood/elasticsearch | public void writeGenericValue ( @ Nullable Object value ) throws IOException { if ( value == null ) { writeByte ( ( byte ) - 1 ) ; return ; } Class type = value . getClass ( ) ; if ( type == String . class ) { writeByte ( ( byte ) 0 ) ; writeString ( ( String ) value ) ; } else if ( type == Integer . class ) { writeByte ( ( byte ) 1 ) ; writeInt ( ( Integer ) value ) ; } else if ( type == Long . class ) { writeByte ( ( byte ) 2 ) ; writeLong ( ( Long ) value ) ; } else if ( type == Float . class ) { writeByte ( ( byte ) 3 ) ; writeFloat ( ( Float ) value ) ; } else if ( type == Double . class ) { writeByte ( ( byte ) 4 ) ; writeDouble ( ( Double ) value ) ; } else if ( type == Boolean . class ) { writeByte ( ( byte ) 5 ) ; writeBoolean ( ( Boolean ) value ) ; } else if ( type == byte [ ] . class ) { writeByte ( ( byte ) 6 ) ; writeVInt ( ( ( byte [ ] ) value ) . length ) ; writeBytes ( ( ( byte [ ] ) value ) ) ; } else if ( value instanceof List ) { writeByte ( ( byte ) 7 ) ; List list = ( List ) value ; writeVInt ( list . size ( ) ) ; for ( Object o : list ) { writeGenericValue ( o ) ; } } else if ( value instanceof Object [ ] ) { writeByte ( ( byte ) 8 ) ; Object [ ] list = ( Object [ ] ) value ; writeVInt ( list . length ) ; for ( Object o : list ) { writeGenericValue ( o ) ; } } else if ( value instanceof Map ) { if ( value instanceof LinkedHashMap ) { writeByte ( ( byte ) 9 ) ; } else { writeByte ( ( byte ) 10 ) ; } @ SuppressWarnings ( " unchecked " ) Map < String , Object > map = ( Map < String , Object > ) value ; writeVInt ( map . size ( ) ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { writeString ( entry . getKey ( ) ) ; writeGenericValue ( entry . getValue ( ) ) ; } } else if ( type == Byte . class ) { writeByte ( ( byte ) 11 ) ; writeByte ( ( Byte ) value ) ; } else if ( type == Date . class ) { writeByte ( ( byte ) 12 ) ; writeLong ( ( ( Date ) value ) . getTime ( ) ) ; } else if ( value instanceof ReadableInstant ) { writeByte ( ( byte ) 13 ) ; writeString ( ( ( ReadableInstant ) value ) . getZone ( ) . getID ( ) ) ; writeLong ( ( ( ReadableInstant ) value ) . getMillis ( ) ) ; } else if ( value instanceof BytesReference ) { writeByte ( ( byte ) 14 ) ; writeBytesReference ( ( BytesReference ) value ) ; } else if ( value instanceof Text ) { writeByte ( ( byte ) 15 ) ; writeText ( ( Text ) value ) ; } else if ( type == Short . class ) { writeByte ( ( byte ) 16 ) ; writeShort ( ( Short ) value ) ; } else if ( type == int [ ] . class ) { writeByte ( ( byte ) 17 ) ; writeIntArray ( ( int [ ] ) value ) ; } else if ( type == long [ ] . class ) { writeByte ( ( byte ) 18 ) ; writeLongArray ( ( long [ ] ) value ) ; } else if ( type == float [ ] . class ) { writeByte ( ( byte ) 19 ) ; writeFloatArray ( ( float [ ] ) value ) ; } else if ( type == double [ ] . class ) { writeByte ( ( byte ) 20 ) ; writeDoubleArray ( ( double [ ] ) value ) ; } else if ( value instanceof BytesRef ) { writeByte ( ( byte ) 21 ) ; writeBytesRef ( ( BytesRef ) value ) ; } else if ( type == GeoPoint . class ) { writeByte ( ( byte ) 22 ) ; writeGeoPoint ( ( GeoPoint ) value ) ; } else { throw new IOException ( " Can ' t ▁ write ▁ type ▁ [ " + type + " ] " ) ; } }
markharwood/elasticsearch | public void writeIntArray ( int [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( int value : values ) { writeInt ( value ) ; } }
markharwood/elasticsearch | public void writeVIntArray ( int [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( int value : values ) { writeVInt ( value ) ; } }
markharwood/elasticsearch | public void writeLongArray ( long [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( long value : values ) { writeLong ( value ) ; } }
markharwood/elasticsearch | public void writeVLongArray ( long [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( long value : values ) { writeVLong ( value ) ; } }
markharwood/elasticsearch | public void writeFloatArray ( float [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( float value : values ) { writeFloat ( value ) ; } }
markharwood/elasticsearch | public void writeDoubleArray ( double [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( double value : values ) { writeDouble ( value ) ; } }
markharwood/elasticsearch | public void writeOptionalStreamable ( @ Nullable Streamable streamable ) throws IOException { if ( streamable != null ) { writeBoolean ( true ) ; streamable . writeTo ( this ) ; } else { writeBoolean ( false ) ; } }
markharwood/elasticsearch | public void writeThrowable ( Throwable throwable ) throws IOException { if ( throwable == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; boolean writeCause = true ; boolean writeMessage = true ; if ( throwable instanceof CorruptIndexException ) { writeVInt ( 1 ) ; writeOptionalString ( ( ( CorruptIndexException ) throwable ) . getOriginalMessage ( ) ) ; writeOptionalString ( ( ( CorruptIndexException ) throwable ) . getResourceDescription ( ) ) ; writeMessage = false ; } else if ( throwable instanceof IndexFormatTooNewException ) { writeVInt ( 2 ) ; writeOptionalString ( ( ( IndexFormatTooNewException ) throwable ) . getResourceDescription ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getVersion ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getMinVersion ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getMaxVersion ( ) ) ; writeMessage = false ; writeCause = false ; } else if ( throwable instanceof IndexFormatTooOldException ) { writeVInt ( 3 ) ; IndexFormatTooOldException t = ( IndexFormatTooOldException ) throwable ; writeOptionalString ( t . getResourceDescription ( ) ) ; if ( t . getVersion ( ) == null ) { writeBoolean ( false ) ; writeOptionalString ( t . getReason ( ) ) ; } else { writeBoolean ( true ) ; writeInt ( t . getVersion ( ) ) ; writeInt ( t . getMinVersion ( ) ) ; writeInt ( t . getMaxVersion ( ) ) ; } writeMessage = false ; writeCause = false ; } else if ( throwable instanceof NullPointerException ) { writeVInt ( 4 ) ; writeCause = false ; } else if ( throwable instanceof NumberFormatException ) { writeVInt ( 5 ) ; writeCause = false ; } else if ( throwable instanceof IllegalArgumentException ) { writeVInt ( 6 ) ; } else if ( throwable instanceof AlreadyClosedException ) { writeVInt ( 7 ) ; } else if ( throwable instanceof EOFException ) { writeVInt ( 8 ) ; writeCause = false ; } else if ( throwable instanceof SecurityException ) { writeVInt ( 9 ) ; } else if ( throwable instanceof StringIndexOutOfBoundsException ) { writeVInt ( 10 ) ; writeCause = false ; } else if ( throwable instanceof ArrayIndexOutOfBoundsException ) { writeVInt ( 11 ) ; writeCause = false ; } else if ( throwable instanceof AssertionError ) { writeVInt ( 12 ) ; } else if ( throwable instanceof FileNotFoundException ) { writeVInt ( 13 ) ; writeCause = false ; } else if ( throwable instanceof FileSystemException ) { writeVInt ( 14 ) ; if ( throwable instanceof NoSuchFileException ) { writeVInt ( 0 ) ; } else if ( throwable instanceof NotDirectoryException ) { writeVInt ( 1 ) ; } else if ( throwable instanceof DirectoryNotEmptyException ) { writeVInt ( 2 ) ; } else if ( throwable instanceof AtomicMoveNotSupportedException ) { writeVInt ( 3 ) ; } else if ( throwable instanceof FileAlreadyExistsException ) { writeVInt ( 4 ) ; } else if ( throwable instanceof AccessDeniedException ) { writeVInt ( 5 ) ; } else if ( throwable instanceof FileSystemLoopException ) { writeVInt ( 6 ) ; } else { writeVInt ( 7 ) ; } writeOptionalString ( ( ( FileSystemException ) throwable ) . getFile ( ) ) ; writeOptionalString ( ( ( FileSystemException ) throwable ) . getOtherFile ( ) ) ; writeOptionalString ( ( ( FileSystemException ) throwable ) . getReason ( ) ) ; writeCause = false ; } else if ( throwable instanceof OutOfMemoryError ) { writeVInt ( 15 ) ; writeCause = false ; } else if ( throwable instanceof IllegalStateException ) { writeVInt ( 16 ) ; } else if ( throwable instanceof LockObtainFailedException ) { writeVInt ( 17 ) ; } else if ( throwable instanceof InterruptedException ) { writeVInt ( 18 ) ; writeCause = false ; } else if ( throwable instanceof IOException ) { writeVInt ( 19 ) ; } else { ElasticsearchException ex ; if ( throwable instanceof ElasticsearchException && ElasticsearchException . isRegistered ( throwable . getClass ( ) ) ) { ex = ( ElasticsearchException ) throwable ; } else { ex = new NotSerializableExceptionWrapper ( throwable ) ; } writeVInt ( 0 ) ; writeVInt ( ElasticsearchException . getId ( ex . getClass ( ) ) ) ; ex . writeTo ( this ) ; return ; } if ( writeMessage ) { writeOptionalString ( throwable . getMessage ( ) ) ; } if ( writeCause ) { writeThrowable ( throwable . getCause ( ) ) ; } ElasticsearchException . writeStackTraces ( throwable , this ) ; } }
markharwood/elasticsearch | void writeNamedWriteable ( NamedWriteable namedWriteable ) throws IOException { writeString ( namedWriteable . getWriteableName ( ) ) ; namedWriteable . writeTo ( this ) ; }
markharwood/elasticsearch | public void writeQuery ( QueryBuilder queryBuilder ) throws IOException { writeNamedWriteable ( queryBuilder ) ; }
markharwood/elasticsearch | public void writeShape ( ShapeBuilder shapeBuilder ) throws IOException { writeNamedWriteable ( shapeBuilder ) ; }
markharwood/elasticsearch | public void writeScoreFunction ( ScoreFunctionBuilder < ? > scoreFunctionBuilder ) throws IOException { writeNamedWriteable ( scoreFunctionBuilder ) ; }
markharwood/elasticsearch | public void writeTaskStatus ( Task . Status status ) throws IOException { writeNamedWriteable ( status ) ; }
markharwood/elasticsearch | public void writeGeoPoint ( GeoPoint geoPoint ) throws IOException { writeDouble ( geoPoint . lat ( ) ) ; writeDouble ( geoPoint . lon ( ) ) ; }
markharwood/elasticsearch | public < T extends Writeable < T > > void writeList ( List < T > list ) throws IOException { writeVInt ( list . size ( ) ) ; for ( T obj : list ) { obj . writeTo ( this ) ; } }
markharwood/elasticsearch | public void writeRescorer ( RescoreBuilder < ? > rescorer ) throws IOException { writeNamedWriteable ( rescorer ) ; }
selvasingh/azure-sdk-for-java | public String body ( ) { return this . body ; }
selvasingh/azure-sdk-for-java | public ApplicationGatewayProbeHealthResponseMatch withBody ( String body ) { this . body = body ; return this ; }
selvasingh/azure-sdk-for-java | public List < String > statusCodes ( ) { return this . statusCodes ; }
selvasingh/azure-sdk-for-java | public ApplicationGatewayProbeHealthResponseMatch withStatusCodes ( List < String > statusCodes ) { this . statusCodes = statusCodes ; return this ; }
OnePaaS/aws-sdk-java | public void setLogStreamName ( String logStreamName ) { this . logStreamName = logStreamName ; }
OnePaaS/aws-sdk-java | public String getLogStreamName ( ) { return this . logStreamName ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withLogStreamName ( String logStreamName ) { setLogStreamName ( logStreamName ) ; return this ; }
OnePaaS/aws-sdk-java | public void setTimestamp ( Long timestamp ) { this . timestamp = timestamp ; }
OnePaaS/aws-sdk-java | public Long getTimestamp ( ) { return this . timestamp ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withTimestamp ( Long timestamp ) { setTimestamp ( timestamp ) ; return this ; }
OnePaaS/aws-sdk-java | public void setMessage ( String message ) { this . message = message ; }
OnePaaS/aws-sdk-java | public String getMessage ( ) { return this . message ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withMessage ( String message ) { setMessage ( message ) ; return this ; }
OnePaaS/aws-sdk-java | public void setIngestionTime ( Long ingestionTime ) { this . ingestionTime = ingestionTime ; }
OnePaaS/aws-sdk-java | public Long getIngestionTime ( ) { return this . ingestionTime ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withIngestionTime ( Long ingestionTime ) { setIngestionTime ( ingestionTime ) ; return this ; }
OnePaaS/aws-sdk-java | public void setEventId ( String eventId ) { this . eventId = eventId ; }
OnePaaS/aws-sdk-java | public String getEventId ( ) { return this . eventId ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withEventId ( String eventId ) { setEventId ( eventId ) ; return this ; }
OnePaaS/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getLogStreamName ( ) != null ) sb . append ( " LogStreamName : ▁ " + getLogStreamName ( ) + " , " ) ; if ( getTimestamp ( ) != null ) sb . append ( " Timestamp : ▁ " + getTimestamp ( ) + " , " ) ; if ( getMessage ( ) != null ) sb . append ( " Message : ▁ " + getMessage ( ) + " , " ) ; if ( getIngestionTime ( ) != null ) sb . append ( " IngestionTime : ▁ " + getIngestionTime ( ) + " , " ) ; if ( getEventId ( ) != null ) sb . append ( " EventId : ▁ " + getEventId ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
OnePaaS/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof FilteredLogEvent == false ) return false ; FilteredLogEvent other = ( FilteredLogEvent ) obj ; if ( other . getLogStreamName ( ) == null ^ this . getLogStreamName ( ) == null ) return false ; if ( other . getLogStreamName ( ) != null && other . getLogStreamName ( ) . equals ( this . getLogStreamName ( ) ) == false ) return false ; if ( other . getTimestamp ( ) == null ^ this . getTimestamp ( ) == null ) return false ; if ( other . getTimestamp ( ) != null && other . getTimestamp ( ) . equals ( this . getTimestamp ( ) ) == false ) return false ; if ( other . getMessage ( ) == null ^ this . getMessage ( ) == null ) return false ; if ( other . getMessage ( ) != null && other . getMessage ( ) . equals ( this . getMessage ( ) ) == false ) return false ; if ( other . getIngestionTime ( ) == null ^ this . getIngestionTime ( ) == null ) return false ; if ( other . getIngestionTime ( ) != null && other . getIngestionTime ( ) . equals ( this . getIngestionTime ( ) ) == false ) return false ; if ( other . getEventId ( ) == null ^ this . getEventId ( ) == null ) return false ; if ( other . getEventId ( ) != null && other . getEventId ( ) . equals ( this . getEventId ( ) ) == false ) return false ; return true ; }
OnePaaS/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getLogStreamName ( ) == null ) ? 0 : getLogStreamName ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getTimestamp ( ) == null ) ? 0 : getTimestamp ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMessage ( ) == null ) ? 0 : getMessage ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getIngestionTime ( ) == null ) ? 0 : getIngestionTime ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getEventId ( ) == null ) ? 0 : getEventId ( ) . hashCode ( ) ) ; return hashCode ; }
OnePaaS/aws-sdk-java | @ Override public FilteredLogEvent clone ( ) { try { return ( FilteredLogEvent ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
Runpop/MVPDemo | @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( 4 , 2 + 2 ) ; }
PG85/OpenTerrainGenerator | public BiomeLayerData ( BiomeLayerData data ) { this . biomeColorMap = new HashMap < > ( ) ; for ( Entry < Integer , Integer > entry : data . biomeColorMap . entrySet ( ) ) { this . biomeColorMap . put ( entry . getKey ( ) . intValue ( ) , entry . getValue ( ) . intValue ( ) ) ; } this . imageXOffset = data . imageXOffset ; this . imageZOffset = data . imageZOffset ; this . imageMode = data . imageMode ; this . configImageFillBiome = data . configImageFillBiome ; this . imageFillBiome = data . imageFillBiome ; this . presetDir = data . presetDir ; this . imageFile = data . imageFile ; this . imageOrientation = data . imageOrientation ; this . biomeMode = data . biomeMode ; this . generationDepth = data . generationDepth ; this . landSize = data . landSize ; this . landFuzzy = data . landFuzzy ; this . landRarity = data . landRarity ; this . oceanBiomeSize = data . oceanBiomeSize ; this . frozenOceanTemperature = data . frozenOceanTemperature ; this . biomeRarityScale = data . biomeRarityScale ; this . randomRivers = data . randomRivers ; this . riverDepth = data . riverDepth ; this . riverSize = data . riverSize ; this . riversEnabled = data . riversEnabled ; this . oceanBiomeData = data . oceanBiomeData . clone ( ) ; this . biomeDepths . addAll ( data . biomeDepths ) ; this . cumulativeGroupRarities = data . cumulativeGroupRarities . clone ( ) ; this . groupMaxRarityPerDepth = data . groupMaxRarityPerDepth . clone ( ) ; this . oldMaxRarities = data . oldMaxRarities ; this . oldGroupRarity = data . oldGroupRarity ; this . oldLandRarity = data . oldLandRarity ; this . forceLandAtSpawn = data . forceLandAtSpawn ; for ( Entry < Integer , List < NewBiomeGroup > > entry : data . groups . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { List < NewBiomeGroup > clonedList = new ArrayList < > ( ) ; for ( NewBiomeGroup group : entry . getValue ( ) ) { NewBiomeGroup clonedGroup = group . clone ( ) ; this . groupRegistry . put ( clonedGroup . id , clonedGroup ) ; clonedList . add ( clonedGroup ) ; } this . groups . put ( entry . getKey ( ) . intValue ( ) , clonedList ) ; } else { this . groups . put ( entry . getKey ( ) . intValue ( ) , null ) ; } } for ( Entry < Integer , List < BiomeData > > entry : data . isleBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { List < BiomeData > clonedList = new ArrayList < > ( ) ; for ( BiomeData biome : entry . getValue ( ) ) { clonedList . add ( biome . clone ( ) ) ; } this . isleBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , clonedList ) ; } else { this . isleBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , null ) ; } } for ( Entry < Integer , List < BiomeData > > entry : data . borderBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { List < BiomeData > clonedList = new ArrayList < > ( ) ; for ( BiomeData biome : entry . getValue ( ) ) { clonedList . add ( biome . clone ( ) ) ; } this . borderBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , clonedList ) ; } else { this . borderBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , null ) ; } } this . riverBiomes = data . riverBiomes . clone ( ) ; this . oceanTemperatures = new int [ 4 ] ; System . arraycopy ( data . oceanTemperatures , 0 , this . oceanTemperatures , 0 , 4 ) ; }
PG85/OpenTerrainGenerator | public BiomeLayerData ( Path presetDir , IWorldConfig worldConfig , IBiomeConfig oceanBiomeConfig , int [ ] oceanTemperatures ) { this . imageXOffset = worldConfig . getImageXOffset ( ) ; this . imageZOffset = worldConfig . getImageZOffset ( ) ; this . imageMode = worldConfig . getImageMode ( ) ; this . configImageFillBiome = worldConfig . getImageFillBiome ( ) ; this . presetDir = presetDir ; this . imageFile = worldConfig . getImageFile ( ) ; this . imageOrientation = worldConfig . getImageOrientation ( ) ; this . biomeMode = worldConfig . getBiomeMode ( ) ; this . generationDepth = worldConfig . getGenerationDepth ( ) ; this . landSize = worldConfig . getLandSize ( ) ; this . landFuzzy = worldConfig . getLandFuzzy ( ) ; this . landRarity = worldConfig . getLandRarity ( ) ; this . oceanBiomeSize = worldConfig . getOceanBiomeSize ( ) ; this . oceanTemperatures = oceanTemperatures ; this . cumulativeGroupRarities = new int [ this . generationDepth + 1 ] ; this . groupMaxRarityPerDepth = new int [ this . generationDepth + 1 ] ; this . oldMaxRarities = new int [ this . generationDepth + 1 ] ; this . oldGroupRarity = worldConfig . getOldGroupRarity ( ) ; this . oldLandRarity = worldConfig . getOldLandRarity ( ) ; this . forceLandAtSpawn = worldConfig . getForceLandAtSpawn ( ) ; if ( oceanBiomeConfig == null ) { this . oceanBiomeData = new BiomeData ( 0 , 0 , 0 , 0 , ImmutableList . of ( ) , ImmutableList . of ( ) , ImmutableList . of ( ) , ImmutableList . of ( ) ) ; } else { this . oceanBiomeData = new BiomeData ( 0 , oceanBiomeConfig . getBiomeRarity ( ) , oceanBiomeConfig . getBiomeSize ( ) , oceanBiomeConfig . getBiomeTemperature ( ) , oceanBiomeConfig . getIsleInBiomes ( ) , oceanBiomeConfig . getBorderInBiomes ( ) , oceanBiomeConfig . getOnlyBorderNearBiomes ( ) , oceanBiomeConfig . getNotBorderNearBiomes ( ) ) ; } this . frozenOceanTemperature = worldConfig . getFrozenOceanTemperature ( ) ; this . biomeRarityScale = worldConfig . getBiomeRarityScale ( ) ; this . randomRivers = worldConfig . getIsRandomRivers ( ) ; this . riverDepth = worldConfig . getRiverRarity ( ) ; this . riverSize = worldConfig . getRiverSize ( ) ; this . riversEnabled = worldConfig . getRiversEnabled ( ) ; }
PG85/OpenTerrainGenerator | public void init ( Set < Integer > biomeDepths , Map < Integer , List < NewBiomeGroup > > groupDepth , Map < Integer , List < BiomeData > > isleBiomesAtDepth , Map < Integer , List < BiomeData > > borderBiomesAtDepth , Map < String , List < Integer > > biomeIdsByName , HashMap < Integer , Integer > biomeColorMap , IBiome [ ] biomes ) { this . biomeDepths . addAll ( biomeDepths ) ; this . groups . putAll ( groupDepth ) ; this . isleBiomesAtDepth . putAll ( isleBiomesAtDepth ) ; this . borderBiomesAtDepth . putAll ( borderBiomesAtDepth ) ; for ( Entry < Integer , List < NewBiomeGroup > > entry : this . groups . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { int cumulativeRarity = 0 ; for ( NewBiomeGroup group : entry . getValue ( ) ) { group . init ( biomeIdsByName ) ; cumulativeRarity += group . rarity ; oldMaxRarities [ entry . getKey ( ) ] ++ ; } this . cumulativeGroupRarities [ entry . getKey ( ) ] = cumulativeRarity ; } } for ( int depth = 0 ; depth < this . cumulativeGroupRarities . length ; depth ++ ) { for ( int j = depth ; j < this . cumulativeGroupRarities . length ; j ++ ) { this . groupMaxRarityPerDepth [ depth ] += this . cumulativeGroupRarities [ j ] ; } } for ( int i = 0 ; i < oldMaxRarities . length ; i ++ ) { oldMaxRarities [ i ] *= 100 ; } for ( Entry < Integer , List < BiomeData > > entry : this . isleBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { for ( BiomeData biome : entry . getValue ( ) ) { biome . init ( biomeIdsByName ) ; } } } for ( Entry < Integer , List < BiomeData > > entry : this . borderBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { for ( BiomeData biome : entry . getValue ( ) ) { biome . init ( biomeIdsByName ) ; } } } this . biomeColorMap = biomeColorMap ; this . riverBiomes = new int [ biomes . length ] ; for ( int i = 0 ; i < biomes . length ; i ++ ) { List < Integer > ids = biomeIdsByName . getOrDefault ( biomes [ i ] . getBiomeConfig ( ) . getRiverBiome ( ) , null ) ; this . riverBiomes [ i ] = ids == null ? - 1 : ids . get ( 0 ) ; } }
spring-projects/spring-framework | @ Override protected ClientHttpRequestFactory createRequestFactory ( ) { return new BufferingClientHttpRequestFactory ( new HttpComponentsClientHttpRequestFactory ( ) ) ; }
spring-projects/spring-framework | @ Test void repeatableRead ( ) throws Exception { ClientHttpRequest request = factory . createRequest ( new URI ( baseUrl + " / echo " ) , HttpMethod . PUT ) ; assertThat ( request . getMethod ( ) ) . as ( " Invalid ▁ HTTP ▁ method " ) . isEqualTo ( HttpMethod . PUT ) ; String headerName = " MyHeader " ; String headerValue1 = " value1" ; request . getHeaders ( ) . add ( headerName , headerValue1 ) ; String headerValue2 = " value2" ; request . getHeaders ( ) . add ( headerName , headerValue2 ) ; byte [ ] body = " Hello ▁ World " . getBytes ( " UTF - 8" ) ; request . getHeaders ( ) . setContentLength ( body . length ) ; FileCopyUtils . copy ( body , request . getBody ( ) ) ; try ( ClientHttpResponse response = request . execute ( ) ) { assertThat ( response . getStatusCode ( ) ) . as ( " Invalid ▁ status ▁ code " ) . isEqualTo ( HttpStatus . OK ) ; assertThat ( response . getStatusCode ( ) ) . as ( " Invalid ▁ status ▁ code " ) . isEqualTo ( HttpStatus . OK ) ; assertThat ( response . getHeaders ( ) . containsKey ( headerName ) ) . as ( " Header ▁ not ▁ found " ) . isTrue ( ) ; assertThat ( response . getHeaders ( ) . containsKey ( headerName ) ) . as ( " Header ▁ not ▁ found " ) . isTrue ( ) ; assertThat ( response . getHeaders ( ) . get ( headerName ) ) . as ( " Header ▁ value ▁ not ▁ found " ) . isEqualTo ( Arrays . asList ( headerValue1 , headerValue2 ) ) ; assertThat ( response . getHeaders ( ) . get ( headerName ) ) . as ( " Header ▁ value ▁ not ▁ found " ) . isEqualTo ( Arrays . asList ( headerValue1 , headerValue2 ) ) ; byte [ ] result = FileCopyUtils . copyToByteArray ( response . getBody ( ) ) ; assertThat ( Arrays . equals ( body , result ) ) . as ( " Invalid ▁ body " ) . isTrue ( ) ; FileCopyUtils . copyToByteArray ( response . getBody ( ) ) ; assertThat ( Arrays . equals ( body , result ) ) . as ( " Invalid ▁ body " ) . isTrue ( ) ; } }
DebalinaDey/AuraDevelopDeb | @ AuraEnabled public String getThirdThing ( ) { return thirdThing ; }
DebalinaDey/AuraDevelopDeb | public void setThirdThing ( String thirdThing ) { this . thirdThing = thirdThing ; }
DebalinaDey/AuraDevelopDeb | @ AuraEnabled public String getReadOnlyThing ( ) { return " readonlyFromTestController2" ; }
johanwermensjoe/project-bacon | public MaterialModel ( ) { super ( new String [ ] { " Name " , " Amount " , " Manufacture " , " Manufacture ▁ Cost / unit ▁ ( ISK ) " , " Price / unit ▁ ( ISK ) " , " Total ▁ Cost ▁ ( ISK ) " } , new int [ ] { LEFT , RIGHT , CENTER , RIGHT , RIGHT , RIGHT } , new int [ ] { 2 } ) ; }
johanwermensjoe/project-bacon | @ Override public Class < ? > getColumnClass ( int columnIndex ) { switch ( columnIndex ) { case 0 : return String . class ; case 2 : return Boolean . class ; case 1 : case 3 : case 4 : case 5 : return Double . class ; default : return Object . class ; } }
johanwermensjoe/project-bacon | @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return getColumnClass ( columnIndex ) == Boolean . class && dataList . get ( rowIndex ) . canBeManufactured ( ) ; }
johanwermensjoe/project-bacon | @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { if ( getColumnClass ( columnIndex ) == Boolean . class ) { dataList . get ( rowIndex ) . setProduced ( ( Boolean ) aValue ) ; fireTableCellUpdated ( rowIndex , columnIndex ) ; } }
johanwermensjoe/project-bacon | @ Override public Object getValueAt ( int row , int col ) { Material m = dataList . get ( row ) ; switch ( col ) { case 0 : return m . getItem ( ) . getName ( ) ; case 1 : return m . getAmount ( ) ; case 2 : return m . canBeManufactured ( ) ? m . isProduced ( ) : null ; case 3 : return m . getManufactureQuote ( ) == null ? null : m . getManufactureQuote ( ) . getManuCost ( ) ; case 4 : return m . getPrice ( ) ; case 5 : return m . isProduced ( ) ? m . getManufactureQuote ( ) . getManuCost ( ) * m . getAmount ( ) : m . getPrice ( ) * m . getAmount ( ) ; default : return null ; } }
Ladicek/creaper | public RemoveModule ( String moduleName ) { this ( moduleName , AddModule . DEFAULT_SLOT ) ; }
Ladicek/creaper | public RemoveModule ( String moduleName , String slot ) { if ( moduleName == null ) { throw new IllegalArgumentException ( " moduleName ▁ cannot ▁ be ▁ null " ) ; } if ( slot == null ) { throw new IllegalArgumentException ( " slot ▁ cannot ▁ be ▁ null " ) ; } this . moduleName = moduleName ; this . slot = slot ; }
Ladicek/creaper | @ Override public void apply ( OnlineCommandContext ctx ) throws Exception { if ( ctx . options . isDomain ) { throw new CommandFailedException ( " RemoveModule ▁ command ▁ isn ' t ▁ supported ▁ in ▁ domain ▁ mode " ) ; } ctx . client . executeCli ( " module ▁ remove ▁ - - name = " + moduleName + " ▁ - - slot = " + slot ) ; }
Ladicek/creaper | @ Override public String toString ( ) { return " RemoveModule ▁ " + moduleName ; }
syg5201314/demoCollection | @ Override protected void onCreate ( Bundle arg0 ) { super . onCreate ( arg0 ) ; setContentView ( R . layout . eleme_content_layout ) ; mRecyclerView = ( RecyclerView ) findViewById ( R . id . recyclerView ) ; mViewPager = ( ViewPager ) findViewById ( R . id . viewpager ) ; mHeaderView = ( ElemeHeaderView ) findViewById ( R . id . zoomHeader ) ; mViewPager . setAdapter ( new Adapter ( ) ) ; mViewPager . setOffscreenPageLimit ( 4 ) ; CtrlLinearLayoutManager layoutManager = new CtrlLinearLayoutManager ( this ) ; layoutManager . setScrollEnabled ( false ) ; mRecyclerView . setLayoutManager ( layoutManager ) ; mRecyclerView . setAdapter ( new ListAdapter ( ) ) ; mRecyclerView . setAlpha ( 0 ) ; mBottomView = ( RelativeLayout ) findViewById ( R . id . rv_bottom ) ; }
syg5201314/demoCollection | @ Override public void onWindowFocusChanged ( boolean hasFocus ) { super . onWindowFocusChanged ( hasFocus ) ; int size = mViewPager . getChildCount ( ) ; if ( isFirst ) { for ( int i = 0 ; i < size ; i ++ ) { View v = mViewPager . getChildAt ( i ) . findViewById ( R . id . ll_bottom ) ; v . setY ( mViewPager . getChildAt ( i ) . findViewById ( R . id . imageView ) . getHeight ( ) ) ; v . setX ( MarginConfig . MARGIN_LEFT_RIGHT ) ; mHeaderView . setY ( mHeaderView . getY ( ) - 1 ) ; isFirst = false ; } } bottomY = ( int ) mBottomView . getY ( ) ; mBottomView . setTranslationY ( mBottomView . getY ( ) + mBottomView . getHeight ( ) ) ; mHeaderView . setBottomView ( mBottomView , bottomY ) ; }
syg5201314/demoCollection | @ Override public Object instantiateItem ( ViewGroup container , int position ) { views . get ( position ) . findViewById ( R . id . imageView ) . setBackgroundResource ( imgs [ position ] ) ; container . addView ( views . get ( position ) ) ; return views . get ( position ) ; }
syg5201314/demoCollection | public Adapter ( ) { views = new ArrayList < > ( ) ; views . add ( View . inflate ( ElemeDetailContentActivity . this , R . layout . item_img , null ) ) ; views . get ( 0 ) . findViewById ( R . id . btn_buy ) . setOnClickListener ( v -> Toast . makeText ( ElemeDetailContentActivity . this , " buy " , Toast . LENGTH_SHORT ) . show ( ) ) ; views . add ( View . inflate ( ElemeDetailContentActivity . this , R . layout . item_img , null ) ) ; views . add ( View . inflate ( ElemeDetailContentActivity . this , R . layout . item_img , null ) ) ; }
syg5201314/demoCollection | @ Override public int getCount ( ) { return views . size ( ) ; }
syg5201314/demoCollection | @ Override public boolean isViewFromObject ( View view , Object object ) { return view == object ; }
syg5201314/demoCollection | @ Override public void onBackPressed ( ) { if ( mHeaderView . isExpand ( ) ) { mHeaderView . restore ( mHeaderView . getY ( ) ) ; } else { finish ( ) ; } }
pupnewfster/Necessities | public boolean commandUse ( CommandSender sender , String [ ] args ) { Variables var = Necessities . getVar ( ) ; if ( sender instanceof Player ) { sender . sendMessage ( var . getEr ( ) + " Error : ▁ " + var . getErMsg ( ) + " You ▁ cannot ▁ use ▁ this ▁ command , ▁ it ▁ is ▁ console ▁ specific . " ) ; } else { Console console = Necessities . getConsole ( ) ; sender . sendMessage ( var . getMessages ( ) + ( console . chatToggled ( ) ? " Toggled ▁ back ▁ to ▁ command ▁ mode . " : " Toggled ▁ to ▁ chat ▁ mode . " ) ) ; console . chatToggle ( ) ; } return true ; }
pupnewfster/Necessities | public boolean isPaintballEnabled ( ) { return true ; }
mmnaseri/cs-review | @ Test public void testFindingItemsAtTheBeginning ( ) throws Exception { assertThat ( getFinder ( ) . find ( 1 , 1 , 2 , 3 , 4 , 5 ) , is ( 0 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemsAtTheEnd ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , 1 , 2 , 3 , 4 , 5 ) , is ( 4 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemInArrayOfSmallSize ( ) throws Exception { assertThat ( getFinder ( ) . find ( 2 , 1 , 2 ) , is ( 1 ) ) ; assertThat ( getFinder ( ) . find ( 3 , 3 , 4 ) , is ( 0 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingFromAnEmptyList ( ) throws Exception { assertThat ( getFinder ( ) . find ( 0 ) , is ( - 1 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemInTheMiddle ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , 1 , 3 , 5 , 7 , 9 ) , is ( 2 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemThatIsNotThere ( ) throws Exception { assertThat ( getFinder ( ) . find ( - 1 , 1 , 2 , 3 , 4 ) , is ( - 1 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemWhenListContainsInfinity ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , Integer . MIN_VALUE , 1 , 2 , 3 , 5 , Integer . MAX_VALUE ) , is ( 4 ) ) ; }
bclozel/spring-boot | @ Before public void setup ( ) { this . mockMvc = MockMvcBuilders . webAppContextSetup ( this . wac ) . build ( ) ; }
bclozel/spring-boot | @ Test public void testDirectAccessForMachineClient ( ) throws Exception { MvcResult response = this . mockMvc . perform ( get ( " / error " ) ) . andExpect ( status ( ) . is5xxServerError ( ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( "999" ) ; }
bclozel/spring-boot | @ Test public void testErrorWithResponseStatus ( ) throws Exception { MvcResult result = this . mockMvc . perform ( get ( " / bang " ) ) . andExpect ( status ( ) . isNotFound ( ) ) . andReturn ( ) ; MvcResult response = this . mockMvc . perform ( new ErrorDispatcher ( result , " / error " ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( " Expected ! " ) ; }
bclozel/spring-boot | @ Test public void testBindingExceptionForMachineClient ( ) throws Exception { MvcResult result = this . mockMvc . perform ( get ( " / bind " ) ) . andExpect ( status ( ) . is4xxClientError ( ) ) . andReturn ( ) ; MvcResult response = this . mockMvc . perform ( new ErrorDispatcher ( result , " / error " ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( " Error ▁ count : ▁ 1" ) ; }
bclozel/spring-boot | @ Test public void testDirectAccessForBrowserClient ( ) throws Exception { MvcResult response = this . mockMvc . perform ( get ( " / error " ) . accept ( MediaType . TEXT_HTML ) ) . andExpect ( status ( ) . is5xxServerError ( ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( " ERROR _ BEAN " ) ; }
bclozel/spring-boot | @ Bean public View error ( ) { return new AbstractView ( ) { @ Override protected void renderMergedOutputModel ( Map < String , Object > model , HttpServletRequest request , HttpServletResponse response ) throws Exception { response . getWriter ( ) . write ( " ERROR _ BEAN " ) ; } } ; }
bclozel/spring-boot | public String getFoo ( ) { return " foo " ; }
bclozel/spring-boot | @ RequestMapping ( " / " ) public String home ( ) { throw new IllegalStateException ( " Expected ! " ) ; }
bclozel/spring-boot | @ RequestMapping ( " / bang " ) public String bang ( ) { throw new NotFoundException ( " Expected ! " ) ; }
bclozel/spring-boot | @ RequestMapping ( " / bind " ) public String bind ( ) throws Exception { BindException error = new BindException ( this , " test " ) ; error . rejectValue ( " foo " , " bar . error " ) ; throw error ; }
bclozel/spring-boot | NotFoundException ( String string ) { super ( string ) ; }
bclozel/spring-boot | ErrorDispatcher ( MvcResult result , String path ) { this . result = result ; this . path = path ; }
bclozel/spring-boot | @ Override public MockHttpServletRequest buildRequest ( ServletContext servletContext ) { MockHttpServletRequest request = this . result . getRequest ( ) ; request . setDispatcherType ( DispatcherType . ERROR ) ; request . setRequestURI ( this . path ) ; return request ; }
udayinfy/ECommerce-Java | public FulfillmentClient ( ) { super ( ) ; }
udayinfy/ECommerce-Java | private void recieveMessages ( ) { CreateQueueResult queue = super . getQueue ( ) ; ReceiveMessageResult result = client . receiveMessage ( new ReceiveMessageRequest ( queue . getQueueUrl ( ) ) ) ; List < Message > messages = result . getMessages ( ) ; while ( true ) { for ( Message message : messages ) { processMessage ( message ) ; } try { Thread . sleep ( 1 * 1000 ) ; } catch ( InterruptedException ie ) { } } }
udayinfy/ECommerce-Java | private void processMessage ( Message message ) { client . deleteMessage ( new DeleteMessageRequest ( getQueue ( ) . getQueueUrl ( ) , message . getReceiptHandle ( ) ) ) ; logger . info ( " Message ▁ Deleted : " + message . getReceiptHandle ( ) ) ; }
medlinker/android-photo-picker | private final PhotoGridAdapter . ICallback < BasePhotoFileEntity > mCallback = new PhotoGridAdapter . ICallback < BasePhotoFileEntity > ( ) { @ Override public void onClickCamera ( View itemView ) { showToast ( " onClickCamera " ) ; try { startActivityForResult ( mPickerHelper . makeTakePhotoIntent ( ) , PhotoPickerHelper . REQUEST_TAKE_PHOTO ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void onClickItemView ( View itemView , int position , BasePhotoFileEntity item ) { showToast ( " onClickItemView : ▁ position ▁ = ▁ " + position ) ; List < BasePhotoFileEntity > selectItems = mGridAdapter . getSelectHelper ( ) . getSelectedItems ( ) ; ArrayList < BasePhotoFileEntity > photoes = new ArrayList < > ( mGridAdapter . getAdapterManager ( ) . getItems ( ) ) ; if ( mGridAdapter . isShowCamera ( ) ) { photoes . remove ( 0 ) ; position -= 1 ; } Bundle b = new Bundle ( ) ; b . putInt ( PhotoPickerHelper . KEY_SELECT_INDEX , position ) ; b . putParcelableArrayList ( PhotoPickerHelper . KEY_PHOTOES , photoes ) ; if ( selectItems != null ) { b . putParcelableArrayList ( PhotoPickerHelper . KEY_PHOTOES_SELECTED , new ArrayList < > ( mGridAdapter . getSelectHelper ( ) . getSelectedItems ( ) ) ) ; } getIntentExecutor ( ) . launchActivityForResult ( PhotoPagerActivity . class , PhotoPickerHelper . REQUEST_CODE_SEE_BIG_PIC , b ) ; } @ Override public void onClickSelectIcon ( View itemView , int position , BasePhotoFileEntity item , List < BasePhotoFileEntity > selectItems ) { int size = selectItems != null ? selectItems . size ( ) : 0 ; tv_done_notice . setText ( getString ( R . string . template_done , size ) ) ; showToast ( " onClickSelectIcon : ▁ position ▁ = ▁ " + position + " ▁ , size ▁ = ▁ " + size ) ; } @ Override public boolean shouldIgnoreClickEventOfSelectIcon ( int position , BasePhotoFileEntity item , List < BasePhotoFileEntity > selectItems ) { if ( selectItems != null && selectItems . size ( ) == 9 ) { showToast ( R . string . only_permit_9_image ) ; return true ; } return false ; } }
medlinker/android-photo-picker | @ Override protected int getlayoutId ( ) { return R . layout . ac_photo_picker ; }
medlinker/android-photo-picker | @ Override protected void onSaveInstanceState ( Bundle outState ) { outState . putString ( " image " , mPickerHelper . getCurrentPhotoPath ( ) ) ; super . onSaveInstanceState ( outState ) ; showToast ( " onSaveInstanceState " + mPickerHelper . getCurrentPhotoPath ( ) ) ; }
medlinker/android-photo-picker | @ Override protected void onRestoreInstanceState ( Bundle savedInstanceState ) { super . onRestoreInstanceState ( savedInstanceState ) ; mPickerHelper . setPhotoPath ( savedInstanceState . getString ( " image " , null ) ) ; Logger . i ( " - - ▁ onRestoreInstanceState ▁ - - " , " ▁ path ▁ = ▁ " + mPickerHelper . getCurrentPhotoPath ( ) ) ; }
medlinker/android-photo-picker | @ Override protected void initView ( ) { setCommonBackListener ( iv_Back ) ; GridLayoutManager layoutManager = new GridLayoutManager ( this , 3 , GridLayoutManager . VERTICAL , false ) ; rv_photos . setLayoutManager ( layoutManager ) ; rv_photos . addItemDecoration ( new SpacesItemDecoration ( ( int ) getResources ( ) . getDimension ( R . dimen . photo_width ) ) ) ; PhotoPickerFactory . setImageLoader ( new DraweeImageLoader ( 0 ) ) ; PhotoPickerFactory . setPhotoFileEntityFactory ( new PhotoPickerFactory . IPhotoFileEntityFactory < BasePhotoFileEntity > ( ) { @ Override public BasePhotoFileEntity create ( int id , String path ) { return new BasePhotoFileEntity ( id , path ) ; } } ) ; mPickerHelper = PhotoPickerFactory . createPhotoPickerHelper ( this ) ; }
medlinker/android-photo-picker | @ Override protected void initData ( Bundle savedInstanceState ) { if ( savedInstanceState != null ) { mPickerHelper . setPhotoPath ( savedInstanceState . getString ( " image " , null ) ) ; } if ( ContextCompat . checkSelfPermission ( this , android . Manifest . permission . WRITE_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , 100 ) ; } else { mPickerHelper . scanPhotoes ( this ) ; } }
medlinker/android-photo-picker | @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode != RESULT_OK ) return ; switch ( requestCode ) { case PhotoPickerHelper . REQUEST_CODE_SEE_BIG_PIC : finishSelect ( ) ; break ; case PhotoPickerHelper . REQUEST_TAKE_PHOTO : mPickerHelper . scanFileToDatabase ( ) ; if ( mPhotoDirs == null ) { mPickerHelper . scanPhotoes ( this ) ; return ; } String path = mPickerHelper . getCurrentPhotoPath ( ) ; BasePhotoFileEntity entity = ( BasePhotoFileEntity ) PhotoPickerFactory . getPhotoFileEntityFactory ( ) . create ( path . hashCode ( ) , path ) ; final PhotoDirectory < BasePhotoFileEntity > dirs = mPhotoDirs . get ( PhotoPickerHelper . INDEX_ALL_PHOTOS ) ; dirs . getPhotos ( ) . add ( 0 , entity ) ; dirs . setPath ( path ) ; mGridAdapter . clearAllSelected ( ) ; mGridAdapter . getAdapterManager ( ) . getItems ( ) . add ( 0 , entity ) ; break ; } }
medlinker/android-photo-picker | private void finishSelect ( ) { Intent sIntent = new Intent ( ) ; List < BasePhotoFileEntity > selectedPhotos = mGridAdapter . getSelectHelper ( ) . getSelectedItems ( ) ; sIntent . putParcelableArrayListExtra ( PhotoPickerHelper . KEY_PHOTOES_SELECTED , ( ArrayList < ? extends Parcelable > ) selectedPhotos ) ; setResult ( RESULT_OK , sIntent ) ; finish ( ) ; }
medlinker/android-photo-picker | @ Override public void onResultCallback ( List < PhotoDirectory < BasePhotoFileEntity > > directories ) { this . mPhotoDirs = directories ; final List < BasePhotoFileEntity > photos = directories . get ( 0 ) . getPhotos ( ) ; if ( mGridAdapter == null ) { if ( photos . size ( ) == 0 ) { showToast ( " no ▁ photoes " ) ; } mGridAdapter = new PhotoGridAdapter < BasePhotoFileEntity > ( R . layout . item_photo , photos , ISelectable . SELECT_MODE_MULTI ) { @ Override protected void applySelectState ( ImageView selectIcon , boolean selected ) { selectIcon . setImageResource ( selected ? R . mipmap . pic_check_select : R . mipmap . pic_check_normal ) ; } @ Override protected boolean bindCameraItemSuccess ( Context context , int position , ViewHelper helper ) { return false ; } @ Override protected int getCameraItemLayoutId ( ) { return R . layout . item_photo_camera ; } } ; mGridAdapter . setCallback ( mCallback ) ; rv_photos . setAdapter ( mGridAdapter ) ; } else { mGridAdapter . getAdapterManager ( ) . replaceAllItems ( photos ) ; } }
medlinker/android-photo-picker | @ Override public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { mPickerHelper . scanPhotoes ( this ) ; } else { showToast ( " permission ▁ denied ▁ ！ " ) ; } }
medlinker/android-photo-picker | public SpacesItemDecoration ( int space ) { this . space = space ; }
medlinker/android-photo-picker | public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( ( parent . getChildLayoutPosition ( view ) + 1 ) % 3 == 0 ) { outRect . right = space ; } else { outRect . right = space ; } outRect . bottom = space ; }
nafae/developer | public Integer getTotalResultSetSize ( ) { return totalResultSetSize ; }
nafae/developer | public void setTotalResultSetSize ( Integer value ) { this . totalResultSetSize = value ; }
nafae/developer | public Integer getStartIndex ( ) { return startIndex ; }
nafae/developer | public void setStartIndex ( Integer value ) { this . startIndex = value ; }
nafae/developer | public List < ActivityGroup > getResults ( ) { if ( results == null ) { results = new ArrayList < ActivityGroup > ( ) ; } return this . results ; }
FilteredPush/geo_ref_qc | @ Test public void test ( ) { List < GeolocationResult > results = service . queryGeoLocateMulti ( " USA " , " Arizona " , " " , "1 ▁ mi . ▁ S ▁ of ▁ Portal " , "31.899097" , " - 109.14083" ) ; assertTrue ( results . size ( ) > 0 ) ; }
FingolfinTEK/camel | public Update ( ) { }
FingolfinTEK/camel | public Long getUpdateId ( ) { return updateId ; }
FingolfinTEK/camel | public void setUpdateId ( Long updateId ) { this . updateId = updateId ; }
FingolfinTEK/camel | public IncomingMessage getMessage ( ) { return message ; }
FingolfinTEK/camel | public void setMessage ( IncomingMessage message ) { this . message = message ; }
FingolfinTEK/camel | @ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( " Update { " ) ; sb . append ( " updateId = " ) . append ( updateId ) ; sb . append ( " , ▁ message = " ) . append ( message ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; }
masaki-yamakawa/geode | public void setLocalAddr ( InternalDistributedMember localAddr ) { this . localAddr = localAddr ; conduit . setMemberId ( localAddr ) ; if ( disconnected ) { disconnected = false ; disconnectCompleted = false ; } }
masaki-yamakawa/geode | public CancelCriterion getCancelCriterion ( ) { return conduit . getCancelCriterion ( ) ; }
masaki-yamakawa/geode | public DirectChannel ( Membership < InternalDistributedMember > mgr , MessageListener < InternalDistributedMember > listener , ClusterDistributionManager dm ) throws ConnectionException { this . receiver = listener ; this . dm = dm ; this . stats = dm . getStats ( ) ; this . bufferPool = new BufferPool ( stats ) ; DistributionConfig dc = dm . getConfig ( ) ; this . address = initAddress ( dc ) ; boolean isBindAddress = dc . getBindAddress ( ) != null ; try { int port = Integer . getInteger ( " tcpServerPort " , 0 ) . intValue ( ) ; if ( port == 0 ) { port = dc . getTcpPort ( ) ; } Properties props = System . getProperties ( ) ; if ( props . getProperty ( " p2p . shareSockets " ) == null ) { props . setProperty ( " p2p . shareSockets " , String . valueOf ( dc . getConserveSockets ( ) ) ) ; } if ( dc . getSocketBufferSize ( ) != DistributionConfig . DEFAULT_SOCKET_BUFFER_SIZE ) { props . setProperty ( " p2p . tcpBufferSize " , String . valueOf ( dc . getSocketBufferSize ( ) ) ) ; } if ( props . getProperty ( " p2p . idleConnectionTimeout " ) == null ) { props . setProperty ( " p2p . idleConnectionTimeout " , String . valueOf ( dc . getSocketLeaseTime ( ) ) ) ; } int [ ] range = dc . getMembershipPortRange ( ) ; props . setProperty ( " membership _ port _ range _ start " , " " + range [ 0 ] ) ; props . setProperty ( " membership _ port _ range _ end " , " " + range [ 1 ] ) ; this . conduit = new TCPConduit ( mgr , port , address , isBindAddress , this , bufferPool , props ) ; disconnected = false ; disconnectCompleted = false ; logger . info ( " GemFire ▁ P2P ▁ Listener ▁ started ▁ on ▁ { } " , conduit . getSocketId ( ) ) ; } catch ( ConnectionException ce ) { logger . fatal ( String . format ( " Unable ▁ to ▁ initialize ▁ direct ▁ channel ▁ because : ▁ % s " , new Object [ ] { ce . getMessage ( ) } ) , ce ) ; throw ce ; } }
masaki-yamakawa/geode | boolean threadOwnsResources ( ) { if ( dm != null ) { return dm . getSystem ( ) . threadOwnsResources ( ) && ! AlertingAction . isThreadAlerting ( ) ; } return false ; }
masaki-yamakawa/geode | public BufferPool getBufferPool ( ) { return bufferPool ; }
masaki-yamakawa/geode | if ( msg instanceof DirectReplyMessage ) { directMsg = ( DirectReplyMessage ) msg ; }
masaki-yamakawa/geode | if ( directMsg != null || msg . getProcessorId ( ) > 0 ) { ackTimeout = ( int ) ( ackWaitThreshold * 1000 ) ; if ( msg . isSevereAlertCompatible ( ) || ReplyProcessor21 . isSevereAlertProcessingForced ( ) ) { ackSDTimeout = ( int ) ( ackSAThreshold * 1000 ) ; if ( ReplyProcessor21 . getShortSevereAlertProcessing ( ) ) { ackSDTimeout = ( int ) ( ReplyProcessor21 . PR_SEVERE_ALERT_RATIO * ackSDTimeout ) ; } } }
masaki-yamakawa/geode | if ( directMsg != null && directMsg . supportsDirectAck ( ) && threadOwnsResources ( ) ) { directReply = true ; }
masaki-yamakawa/geode | if ( ! directReply && directMsg != null ) { directMsg . registerProcessor ( ) ; }
masaki-yamakawa/geode | if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Sending ▁ ( { } ) ▁ to ▁ { } ▁ peers ▁ ( { } ) ▁ via ▁ tcp / ip " , msg , p_destinations . length , Arrays . toString ( p_destinations ) ) ; }
masaki-yamakawa/geode | if ( retryInfo != null ) { List retryMembers = retryInfo . getMembers ( ) ; InternalDistributedMember [ ] retryDest = new InternalDistributedMember [ retryMembers . size ( ) ] ; retryDest = ( InternalDistributedMember [ ] ) retryMembers . toArray ( retryDest ) ; destinations = retryDest ; retryInfo = null ; retry = true ; }
masaki-yamakawa/geode | if ( directReply && msg . getProcessorId ( ) > 0 ) { directReply = false ; }
masaki-yamakawa/geode | if ( ce != null ) { if ( failedCe != null ) { failedCe . getMembers ( ) . addAll ( ce . getMembers ( ) ) ; failedCe . getCauses ( ) . addAll ( ce . getCauses ( ) ) ; } else { failedCe = ce ; } ce = null ; }
masaki-yamakawa/geode | if ( cons . isEmpty ( ) ) { if ( failedCe != null ) { throw failedCe ; } return bytesWritten ; }
masaki-yamakawa/geode | if ( logger . isDebugEnabled ( ) ) { logger . debug ( " { } ▁ on ▁ these ▁ { } ▁ connections : ▁ { } " , ( retry ? " Retrying ▁ send " : " Sending " ) , cons . size ( ) , cons ) ; }
masaki-yamakawa/geode | if ( ackTimeout > 0 ) { startTime = System . currentTimeMillis ( ) ; }
masaki-yamakawa/geode | if ( bytesWritten == 0 ) { bytesWritten = result ; }
masaki-yamakawa/geode | catch ( NotSerializableException e ) { throw e ; }
masaki-yamakawa/geode | catch ( IOException ex ) { throw new InternalGemFireException ( " Unknown ▁ error ▁ serializing ▁ message " , ex ) ; }
masaki-yamakawa/geode | catch ( IOException e ) { throw new InternalGemFireException ( " Unknown ▁ error ▁ serializing ▁ message " , e ) ; }
masaki-yamakawa/geode | if ( ce != null ) { retryInfo = ce ; ce = null ; }
masaki-yamakawa/geode | if ( directReply && ! sentCons . isEmpty ( ) ) { long readAckStart = 0 ; if ( stats != null ) { readAckStart = stats . startReplyWait ( ) ; } try { ce = readAcks ( sentCons , startTime , ackTimeout , ackSDTimeout , ce , directMsg . getDirectReplyProcessor ( ) ) ; } finally { if ( stats != null ) { stats . endReplyWait ( readAckStart , startTime ) ; } } }
masaki-yamakawa/geode | if ( ce != null ) { if ( retryInfo != null ) { retryInfo . getMembers ( ) . addAll ( ce . getMembers ( ) ) ; retryInfo . getCauses ( ) . addAll ( ce . getCauses ( ) ) ; } else { retryInfo = ce ; } ce = null ; }
masaki-yamakawa/geode | if ( retryInfo != null ) { this . conduit . getCancelCriterion ( ) . checkCancelInProgress ( null ) ; }
masaki-yamakawa/geode | if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; }
masaki-yamakawa/geode | ) { Connection con = ( Connection ) it . next ( ) ; con . setInUse ( false , 0 , 0 , 0 , null ) ; }
masaki-yamakawa/geode | if ( failedCe != null ) { throw failedCe ; }
masaki-yamakawa/geode | private ConnectExceptions readAcks ( List sentCons , long startTime , long ackTimeout , long ackSDTimeout , ConnectExceptions cumulativeExceptions , DirectReplyProcessor processor ) { ConnectExceptions ce = cumulativeExceptions ; for ( Iterator it = sentCons . iterator ( ) ; it . hasNext ( ) ; ) { Connection con = ( Connection ) it . next ( ) ; if ( con . isSharedResource ( ) ) { continue ; } try { try { con . readAck ( processor ) ; } catch ( SocketTimeoutException ex ) { handleAckTimeout ( ackTimeout , ackSDTimeout , con , processor ) ; } } catch ( ConnectionException conEx ) { if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( con . getRemoteAddress ( ) , conEx ) ; } } return ce ; }
masaki-yamakawa/geode | private ConnectExceptions getConnections ( Membership mgr , DistributionMessage msg , InternalDistributedMember [ ] destinations , boolean preserveOrder , boolean retry , long ackTimeout , long ackSDTimeout , List cons ) { ConnectExceptions ce = null ; for ( int i = 0 ; i < destinations . length ; i ++ ) { InternalDistributedMember destination = destinations [ i ] ; if ( destination == null ) { continue ; } if ( localAddr . equals ( destination ) ) { continue ; } if ( ! mgr . memberExists ( destination ) || mgr . shutdownInProgress ( ) || mgr . isShunned ( destination ) ) { if ( logger . isTraceEnabled ( LogMarker . DM_VERBOSE ) ) { logger . trace ( LogMarker . DM_VERBOSE , " Not ▁ a ▁ member : ▁ { } " , destination ) ; } if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( destination , new ShunnedMemberException ( String . format ( " Member ▁ is ▁ being ▁ shunned : ▁ % s " , destination ) ) ) ; } else { try { long startTime = 0 ; if ( ackTimeout > 0 ) { startTime = System . currentTimeMillis ( ) ; } Connection con = conduit . getConnection ( destination , preserveOrder , retry , startTime , ackTimeout , ackSDTimeout ) ; con . setInUse ( true , startTime , 0 , 0 , null ) ; cons . add ( con ) ; if ( con . isSharedResource ( ) && msg instanceof DirectReplyMessage ) { DirectReplyMessage directMessage = ( DirectReplyMessage ) msg ; directMessage . registerProcessor ( ) ; } } catch ( IOException ex ) { if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( destination , ex ) ; } } } return ce ; }
masaki-yamakawa/geode | if ( disconnected ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ channel ▁ is ▁ disconnected : ▁ { } " , msg ) ; } return 0 ; }
masaki-yamakawa/geode | if ( destinations == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ null ▁ set ▁ passed ▁ in : ▁ { } " , msg ) ; } return 0 ; }
masaki-yamakawa/geode | if ( destinations . length == 0 ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ empty ▁ destinations ▁ passed ▁ in ▁ { } " , msg ) ; } return 0 ; }
masaki-yamakawa/geode | if ( destinations . length == 1 ) { return sendToOne ( mgr , destinations , msg , ackWaitThreshold , ackSAThreshold ) ; }
masaki-yamakawa/geode | public DMStats getDMStats ( ) { return stats ; }
masaki-yamakawa/geode | public DistributionConfig getDMConfig ( ) { if ( dm != null ) { return dm . getConfig ( ) ; } else { return null ; } }
masaki-yamakawa/geode | public DistributionManager getDM ( ) { return dm ; }
masaki-yamakawa/geode | private void handleAckTimeout ( long ackTimeout , long ackSATimeout , Connection c , DirectReplyProcessor processor ) throws ConnectionException { Set activeMembers = dm . getDistributionManagerIds ( ) ; dm . getStats ( ) . incReplyTimeouts ( ) ; { String msg = " % s ▁ seconds ▁ have ▁ elapsed ▁ while ▁ waiting ▁ for ▁ reply ▁ from ▁ % s ▁ on ▁ % s ▁ whose ▁ current ▁ membership ▁ list ▁ is : ▁ [ % s ] " ; final Object [ ] msgArgs = new Object [ ] { Long . valueOf ( ackTimeout / 1000 ) , c . getRemoteAddress ( ) , dm . getId ( ) , activeMembers } ; logger . warn ( String . format ( msg , msgArgs ) ) ; msgArgs [ 3 ] = " ( omitted ) " ; Breadcrumbs . setProblem ( msg , msgArgs ) ; if ( ReplyProcessor21 . THROW_EXCEPTION_ON_TIMEOUT ) { TimeoutException cause = new TimeoutException ( " Timed ▁ out ▁ waiting ▁ for ▁ ACKS . " ) ; throw new InternalGemFireException ( String . format ( msg , msgArgs ) , cause ) ; } } if ( activeMembers . contains ( c . getRemoteAddress ( ) ) ) { if ( ackSATimeout > 0 ) { try { c . readAck ( processor ) ; return ; } catch ( SocketTimeoutException e ) { Object [ ] args = new Object [ ] { Long . valueOf ( ( ackSATimeout + ackTimeout ) / 1000 ) , c . getRemoteAddress ( ) , dm . getId ( ) , activeMembers } ; logger . fatal ( " { } ▁ seconds ▁ have ▁ elapsed ▁ while ▁ waiting ▁ for ▁ reply ▁ from ▁ { } ▁ on ▁ { } ▁ whose ▁ currentFull ▁ membership ▁ list ▁ is : ▁ [ { } ] " , args ) ; } } try { c . readAck ( processor ) ; } catch ( SocketTimeoutException ex ) { logger . error ( String . format ( " Unexpected ▁ timeout ▁ while ▁ waiting ▁ for ▁ ack ▁ from ▁ % s " , c . getRemoteAddress ( ) ) , ex ) ; } } else { logger . warn ( " View ▁ no ▁ longer ▁ has ▁ { } ▁ as ▁ an ▁ active ▁ member , ▁ so ▁ we ▁ will ▁ no ▁ longer ▁ wait ▁ for ▁ it . " , c . getRemoteAddress ( ) ) ; processor . memberDeparted ( getDM ( ) , c . getRemoteAddress ( ) , true ) ; } }
masaki-yamakawa/geode | public void receive ( DistributionMessage msg , int bytesRead ) throws MemberShunnedException { if ( disconnected ) { return ; } try { receiver . messageReceived ( msg ) ; } catch ( MemberShunnedException e ) { throw e ; } catch ( CancelException e ) { } catch ( Exception ex ) { if ( ! conduit . getCancelCriterion ( ) . isCancelInProgress ( ) ) { logger . fatal ( " While ▁ pulling ▁ a ▁ message " , ex ) ; } } }
masaki-yamakawa/geode | public void emergencyClose ( ) { this . conduit . emergencyClose ( ) ; }
masaki-yamakawa/geode | public synchronized void disconnect ( Exception cause ) { this . disconnected = true ; this . disconnectCompleted = false ; this . conduit . stop ( cause ) ; this . disconnectCompleted = true ; }
masaki-yamakawa/geode | public boolean isOpen ( ) { return ! disconnectCompleted ; }
masaki-yamakawa/geode | protected MessageListener getReceiver ( ) { return receiver ; }
masaki-yamakawa/geode | public int getPort ( ) { return this . conduit . getPort ( ) ; }
masaki-yamakawa/geode | public TCPConduit getConduit ( ) { return this . conduit ; }
masaki-yamakawa/geode | private InetAddress initAddress ( DistributionConfig dc ) { String bindAddress = dc . getBindAddress ( ) ; try { if ( bindAddress != null && bindAddress . length ( ) > 0 ) { return InetAddress . getByName ( bindAddress ) ; } else { return LocalHostUtil . getLocalHost ( ) ; } } catch ( java . net . UnknownHostException unhe ) { throw new RuntimeException ( unhe ) ; } }
masaki-yamakawa/geode | public void closeEndpoint ( InternalDistributedMember member , String reason , boolean notifyDisconnect ) { TCPConduit tc = this . conduit ; if ( tc != null ) { tc . removeEndpoint ( member , reason , notifyDisconnect ) ; } }
masaki-yamakawa/geode | public void getChannelStates ( DistributedMember member , Map result ) { TCPConduit tc = this . conduit ; if ( tc != null ) { tc . getThreadOwnedOrderedConnectionState ( member , result ) ; } }
masaki-yamakawa/geode | public void waitForChannelState ( DistributedMember member , Map channelState ) throws InterruptedException { if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } TCPConduit tc = this . conduit ; if ( tc != null ) { tc . waitForThreadOwnedOrderedConnectionState ( member , channelState ) ; } }
masaki-yamakawa/geode | public boolean hasReceiversFor ( DistributedMember mbr ) { return this . conduit . hasReceiversFor ( mbr ) ; }
glaucio-melo-movile/activemq-artemis | @ Before public void startBroker ( ) throws Exception { broker = createBroker ( ) ; TransportConnector connector = broker . addConnector ( " tcp : // 0.0.0.0:0" ) ; broker . deleteAllMessages ( ) ; broker . start ( ) ; broker . waitUntilStarted ( ) ; PolicyEntry policy = new PolicyEntry ( ) ; policy . setMaxBrowsePageSize ( browserLimit ) ; broker . setDestinationPolicy ( new PolicyMap ( ) ) ; broker . getDestinationPolicy ( ) . setDefaultEntry ( policy ) ; connectUri = connector . getConnectUri ( ) ; factory = new ActiveMQConnectionFactory ( connectUri ) ; }
glaucio-melo-movile/activemq-artemis | public BrokerService createBroker ( ) throws IOException { return new BrokerService ( ) ; }
glaucio-melo-movile/activemq-artemis | @ After public void stopBroker ( ) throws Exception { broker . stop ( ) ; broker . waitUntilStopped ( ) ; }
glaucio-melo-movile/activemq-artemis | @ Test public void testBrowsingLimited ( ) throws Exception { int messageToSend = 470 ; ActiveMQQueue queue = new ActiveMQQueue ( " TEST " ) ; Connection connection = factory . createConnection ( ) ; connection . start ( ) ; Session session = connection . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; MessageProducer producer = session . createProducer ( queue ) ; String data = " " ; for ( int i = 0 ; i < 1024 * 2 ; i ++ ) { data += " x " ; } for ( int i = 0 ; i < messageToSend ; i ++ ) { producer . send ( session . createTextMessage ( data ) ) ; } QueueBrowser browser = session . createBrowser ( queue ) ; Enumeration < ? > enumeration = browser . getEnumeration ( ) ; int received = 0 ; while ( enumeration . hasMoreElements ( ) ) { Message m = ( Message ) enumeration . nextElement ( ) ; received ++ ; LOG . info ( " Browsed ▁ message ▁ " + received + " : ▁ " + m . getJMSMessageID ( ) ) ; } browser . close ( ) ; assertEquals ( browserLimit , received ) ; }
longkerdandy/chii2mqtt | public PubRelMessage ( ) { }
longkerdandy/chii2mqtt | public PubRelMessage ( boolean dupFlag , int messageID ) { this . messageType = MessageType . PUBREL ; this . qosLevel = QoSLevel . LEAST_ONCE ; this . dupFlag = dupFlag ; this . messageID = messageID ; this . remainingLength = calculateRemainingLength ( ) ; }
longkerdandy/chii2mqtt | @ Override protected int calculateRemainingLength ( ) { return 2 ; }
longkerdandy/chii2mqtt | @ Override public void validate ( ) { if ( messageID < 0 ) { throw new IllegalStateException ( " Negative ▁ Message ▁ ID . " ) ; } }
longkerdandy/chii2mqtt | public int getMessageID ( ) { return messageID ; }
longkerdandy/chii2mqtt | public void setMessageID ( int messageID ) { this . messageID = messageID ; }
kaiyuntao/tao | public long getId ( ) { return id ; }
kaiyuntao/tao | public void setId ( long id ) { this . id = id ; }
kaiyuntao/tao | public long getUserId ( ) { return userId ; }
kaiyuntao/tao | public void setUserId ( long userId ) { this . userId = userId ; }
kaiyuntao/tao | public int getType ( ) { return type ; }
kaiyuntao/tao | public void setType ( int type ) { this . type = type ; }
kaiyuntao/tao | public String getAccount ( ) { return account ; }
kaiyuntao/tao | public void setAccount ( String account ) { this . account = account ; }
kaiyuntao/tao | public String getBank ( ) { return bank ; }
kaiyuntao/tao | public void setBank ( String bank ) { this . bank = bank ; }
kaiyuntao/tao | public String getName ( ) { return name ; }
kaiyuntao/tao | public void setName ( String name ) { this . name = name ; }
zhangleidaniejian/bluemmSite | public MallVirtualProduct get ( String id ) { return super . get ( id ) ; }
zhangleidaniejian/bluemmSite | public List < MallVirtualProduct > findList ( MallVirtualProduct mallVirtualProduct ) { return super . findList ( mallVirtualProduct ) ; }
zhangleidaniejian/bluemmSite | public Page < MallVirtualProduct > findPage ( Page < MallVirtualProduct > page , MallVirtualProduct mallVirtualProduct ) { return super . findPage ( page , mallVirtualProduct ) ; }
zhangleidaniejian/bluemmSite | @ Transactional ( readOnly = false ) public void save ( MallVirtualProduct mallVirtualProduct ) { super . save ( mallVirtualProduct ) ; }
zhangleidaniejian/bluemmSite | @ Transactional ( readOnly = false ) public void delete ( MallVirtualProduct mallVirtualProduct ) { super . delete ( mallVirtualProduct ) ; }
tudelft-atlarge/granula | public ExtractionRule ( int level ) { super ( level ) ; }
jstourac/undertow | public NonStandardResponseWrapper ( ServletResponse response ) { this . response = checkNotNullParam ( " response " , response ) ; }
jstourac/undertow | public ServletResponse getResponse ( ) { return this . response ; }
jstourac/undertow | public void setResponse ( ServletResponse response ) { this . response = checkNotNullParam ( " response " , response ) ; }
jstourac/undertow | public void setCharacterEncoding ( String charset ) { this . response . setCharacterEncoding ( charset ) ; }
jstourac/undertow | public String getCharacterEncoding ( ) { return this . response . getCharacterEncoding ( ) ; }
jstourac/undertow | public ServletOutputStream getOutputStream ( ) throws IOException { return this . response . getOutputStream ( ) ; }
jstourac/undertow | public PrintWriter getWriter ( ) throws IOException { return this . response . getWriter ( ) ; }
jstourac/undertow | public void setContentLength ( int len ) { this . response . setContentLength ( len ) ; }
jstourac/undertow | public void setContentLengthLong ( long len ) { this . response . setContentLengthLong ( len ) ; }
jstourac/undertow | public void setContentType ( String type ) { this . response . setContentType ( type ) ; }
jstourac/undertow | public String getContentType ( ) { return this . response . getContentType ( ) ; }
jstourac/undertow | public void setBufferSize ( int size ) { this . response . setBufferSize ( size ) ; }
jstourac/undertow | public int getBufferSize ( ) { return this . response . getBufferSize ( ) ; }
jstourac/undertow | public void flushBuffer ( ) throws IOException { this . response . flushBuffer ( ) ; }
jstourac/undertow | public boolean isCommitted ( ) { return this . response . isCommitted ( ) ; }
jstourac/undertow | public void reset ( ) { this . response . reset ( ) ; }
jstourac/undertow | public void resetBuffer ( ) { this . response . resetBuffer ( ) ; }
jstourac/undertow | public void setLocale ( Locale loc ) { this . response . setLocale ( loc ) ; }
jstourac/undertow | public Locale getLocale ( ) { return this . response . getLocale ( ) ; }
jstourac/undertow | public boolean isWrapperFor ( ServletResponse wrapped ) { if ( response == wrapped ) { return true ; } else if ( response instanceof ServletResponseWrapper ) { return ( ( ServletResponseWrapper ) response ) . isWrapperFor ( wrapped ) ; } else { return false ; } }
jstourac/undertow | public boolean isWrapperFor ( Class < ? > wrappedType ) { if ( ! ServletResponse . class . isAssignableFrom ( wrappedType ) ) { throw new IllegalArgumentException ( " Given ▁ class ▁ " + wrappedType . getName ( ) + " ▁ not ▁ a ▁ subinterface ▁ of ▁ " + ServletResponse . class . getName ( ) ) ; } if ( wrappedType . isAssignableFrom ( response . getClass ( ) ) ) { return true ; } else if ( response instanceof ServletResponseWrapper ) { return ( ( ServletResponseWrapper ) response ) . isWrapperFor ( wrappedType ) ; } else { return false ; } }
jstourac/undertow | private HttpServletResponse _getHttpServletResponse ( ) { return ( HttpServletResponse ) response ; }
jstourac/undertow | @ Override public void addCookie ( Cookie cookie ) { this . _getHttpServletResponse ( ) . addCookie ( cookie ) ; }
jstourac/undertow | @ Override public boolean containsHeader ( String name ) { return this . _getHttpServletResponse ( ) . containsHeader ( name ) ; }
jstourac/undertow | @ Override public String encodeURL ( String url ) { return this . _getHttpServletResponse ( ) . encodeURL ( url ) ; }
jstourac/undertow | @ Override public String encodeRedirectURL ( String url ) { return this . _getHttpServletResponse ( ) . encodeRedirectURL ( url ) ; }
jstourac/undertow | @ Override public String encodeUrl ( String url ) { return this . _getHttpServletResponse ( ) . encodeUrl ( url ) ; }
jstourac/undertow | @ Override public String encodeRedirectUrl ( String url ) { return this . _getHttpServletResponse ( ) . encodeRedirectUrl ( url ) ; }
jstourac/undertow | @ Override public void sendError ( int sc , String msg ) throws IOException { this . _getHttpServletResponse ( ) . sendError ( sc , msg ) ; }
jstourac/undertow | @ Override public void sendError ( int sc ) throws IOException { this . _getHttpServletResponse ( ) . sendError ( sc ) ; }
jstourac/undertow | @ Override public void sendRedirect ( String location ) throws IOException { this . _getHttpServletResponse ( ) . sendRedirect ( location ) ; }
jstourac/undertow | @ Override public void setDateHeader ( String name , long date ) { this . _getHttpServletResponse ( ) . setDateHeader ( name , date ) ; }
jstourac/undertow | @ Override public void addDateHeader ( String name , long date ) { this . _getHttpServletResponse ( ) . addDateHeader ( name , date ) ; }
jstourac/undertow | @ Override public void setHeader ( String name , String value ) { this . _getHttpServletResponse ( ) . setHeader ( name , value ) ; }
jstourac/undertow | @ Override public void addHeader ( String name , String value ) { this . _getHttpServletResponse ( ) . addHeader ( name , value ) ; }
jstourac/undertow | @ Override public void setIntHeader ( String name , int value ) { this . _getHttpServletResponse ( ) . setIntHeader ( name , value ) ; }
jstourac/undertow | @ Override public void addIntHeader ( String name , int value ) { this . _getHttpServletResponse ( ) . addIntHeader ( name , value ) ; }
jstourac/undertow | @ Override public void setStatus ( int sc ) { this . _getHttpServletResponse ( ) . setStatus ( sc ) ; }
jstourac/undertow | @ Override public void setStatus ( int sc , String sm ) { this . _getHttpServletResponse ( ) . setStatus ( sc , sm ) ; }
jstourac/undertow | @ Override public int getStatus ( ) { return _getHttpServletResponse ( ) . getStatus ( ) ; }
jstourac/undertow | @ Override public String getHeader ( String name ) { return _getHttpServletResponse ( ) . getHeader ( name ) ; }
jstourac/undertow | @ Override public Collection < String > getHeaders ( String name ) { return _getHttpServletResponse ( ) . getHeaders ( name ) ; }
jstourac/undertow | @ Override public Collection < String > getHeaderNames ( ) { return _getHttpServletResponse ( ) . getHeaderNames ( ) ; }
eldemcan/markettsp | @ RequestMapping ( value = " / test " , method = RequestMethod . GET ) @ ResponseBody public String testMethod ( ) { return " Test ▁ OK " ; }
eldemcan/markettsp | @ RequestMapping ( value = " / poolrecent " , method = RequestMethod . GET ) @ ResponseBody public TradeMessageData poolRecentMessage ( ) { return consumerFacade . getRecentMessageData ( ) ; }
eldemcan/markettsp | @ RequestMapping ( value = " / poolall " , method = RequestMethod . GET ) @ ResponseBody public DeferredResult < List < TradeMessageData > > poolAllMessages ( ) { DeferredResult < List < TradeMessageData > > results = new DeferredResult < List < TradeMessageData > > ( ) ; results . setResult ( consumerFacade . findAllMessages ( ) ) ; return results ; }
eldemcan/markettsp | " ) @ ResponseBody public DeferredResult < List < TradeMessageData > > poolMessagesCountry ( @ PathVariable String country ) { DeferredResult < List < TradeMessageData > > results = new DeferredResult < List < TradeMessageData > > ( ) ; results . setResult ( consumerFacade . findTradeMessagesByCountryCode ( country ) ) ; return results ; }
jelsas/JavaItertools | public CountingIterator ( ) { this ( 0 ) ; }
jelsas/JavaItertools | public CountingIterator ( int start ) { count = start ; }
jelsas/JavaItertools | public boolean hasNext ( ) { return true ; }
jelsas/JavaItertools | public Integer next ( ) { return new Integer ( count ++ ) ; }
jelsas/JavaItertools | public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
jelsas/JavaItertools | public int nextInt ( ) { return count ++ ; }
milindaperera/product-ei | if ( createConsumer ) { if ( ExchangeType . QUEUE == this . consumerConfig . getExchangeType ( ) ) { this . createQueueConnection ( ) ; } else if ( ExchangeType . TOPIC == this . consumerConfig . getExchangeType ( ) ) { this . createTopicConnection ( ) ; } }
milindaperera/product-ei | if ( TopicSession . SESSION_TRANSACTED == this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) { topicSession = topicConnection . createTopicSession ( true , this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) ; }
milindaperera/product-ei | if ( this . consumerConfig . isDurable ( ) ) { if ( null != this . consumerConfig . getSelectors ( ) ) { receiver = topicSession . createDurableSubscriber ( topic , this . consumerConfig . getSubscriptionID ( ) , this . consumerConfig . getSelectors ( ) , false ) ; } else { receiver = topicSession . createDurableSubscriber ( topic , this . consumerConfig . getSubscriptionID ( ) ) ; } }
milindaperera/product-ei | if ( null != this . consumerConfig . getSelectors ( ) ) { receiver = topicSession . createSubscriber ( topic , this . consumerConfig . getSelectors ( ) , false ) ; }
milindaperera/product-ei | if ( QueueSession . SESSION_TRANSACTED == this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) { queueSession = queueConnection . createQueueSession ( true , this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) ; }
milindaperera/product-ei | if ( null != this . consumerConfig . getSelectors ( ) ) { receiver = queueSession . createReceiver ( queue , this . consumerConfig . getSelectors ( ) ) ; }
milindaperera/product-ei | if ( null != connection && null != session && null != receiver ) { log . info ( " Starting ▁ Consumer " ) ; if ( this . consumerConfig . isAsync ( ) ) { receiver . setMessageListener ( this ) ; } else { Thread consumerThread = new Thread ( this ) ; consumerThread . start ( ) ; } }
milindaperera/product-ei | @ Override public void stopClient ( ) { Thread stopThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( null != connection && null != session && null != receiver ) { try { log . info ( " Closing ▁ Consumer " ) ; if ( ExchangeType . TOPIC == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { TopicSubscriber topicSubscriber = ( TopicSubscriber ) receiver ; topicSubscriber . close ( ) ; } if ( null != session ) { TopicSession topicSession = ( TopicSession ) session ; topicSession . close ( ) ; } if ( null != connection ) { TopicConnection topicConnection = ( TopicConnection ) connection ; topicConnection . close ( ) ; } } else if ( ExchangeType . QUEUE == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { QueueReceiver queueReceiver = ( QueueReceiver ) receiver ; queueReceiver . close ( ) ; } if ( null != session ) { QueueSession queueSession = ( QueueSession ) session ; queueSession . close ( ) ; } if ( null != connection ) { QueueConnection queueConnection = ( QueueConnection ) connection ; queueConnection . stop ( ) ; queueConnection . close ( ) ; } } receiver = null ; session = null ; connection = null ; log . info ( " Consumer ▁ Closed " ) ; } catch ( JMSException e ) { log . error ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; throw new RuntimeException ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; } } } } ) ; stopThread . start ( ) ; try { stopThread . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Error ▁ waiting ▁ for ▁ subscriber ▁ to ▁ stop " , e ) ; } }
milindaperera/product-ei | public void stopClientSync ( ) { if ( null != connection && null != session && null != receiver ) { try { log . info ( " Closing ▁ Consumer " ) ; if ( ExchangeType . TOPIC == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { TopicSubscriber topicSubscriber = ( TopicSubscriber ) receiver ; topicSubscriber . close ( ) ; } if ( null != session ) { TopicSession topicSession = ( TopicSession ) session ; topicSession . close ( ) ; } if ( null != connection ) { TopicConnection topicConnection = ( TopicConnection ) connection ; topicConnection . close ( ) ; } } else if ( ExchangeType . QUEUE == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { QueueReceiver queueReceiver = ( QueueReceiver ) receiver ; queueReceiver . close ( ) ; } if ( null != session ) { QueueSession queueSession = ( QueueSession ) session ; queueSession . close ( ) ; } if ( null != connection ) { QueueConnection queueConnection = ( QueueConnection ) connection ; queueConnection . stop ( ) ; queueConnection . close ( ) ; } } receiver = null ; session = null ; connection = null ; log . info ( " Consumer ▁ Closed " ) ; } catch ( JMSException e ) { log . error ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; throw new RuntimeException ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; } } }
milindaperera/product-ei | public void unSubscribe ( final boolean stopClient ) throws JMSException { Thread unsubscribeThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( null != connection && null != session && null != receiver ) { try { log . info ( " Un - subscribing ▁ Subscriber " ) ; session . unsubscribe ( consumerConfig . getSubscriptionID ( ) ) ; log . info ( " Subscriber ▁ Un - Subscribed " ) ; if ( stopClient ) { stopClient ( ) ; } } catch ( JMSException e ) { log . error ( " Error ▁ in ▁ removing ▁ subscription ( un - subscribing ) . " , e ) ; throw new RuntimeException ( " JMSException ▁ : ▁ Error ▁ in ▁ removing ▁ subscription ( un - subscribing ) . " , e ) ; } } else { AndesClientException andesClientException = new AndesClientException ( " The ▁ connection , ▁ session ▁ and ▁ message ▁ receiver ▁ is ▁ not ▁ assigned . " ) ; log . error ( " The ▁ connection , ▁ session ▁ and ▁ message ▁ receiver ▁ is ▁ not ▁ assigned . " , andesClientException ) ; throw new RuntimeException ( " The ▁ connection , ▁ session ▁ and ▁ message ▁ receiver ▁ is ▁ not ▁ assigned . " , andesClientException ) ; } } } ) ; unsubscribeThread . start ( ) ; try { unsubscribeThread . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Error ▁ waiting ▁ for ▁ consumer ▁ to ▁ unsubscribe " , e ) ; } }
milindaperera/product-ei | @ Override public void run ( ) { try { boolean interrupted = false ; while ( true ) { Message message = this . receiver . receive ( ) ; if ( null == message ) { interrupted = true ; break ; } else if ( processReceivedMessage ( message ) ) { break ; } } if ( ! interrupted ) { stopClientSync ( ) ; } } catch ( JMSException e ) { log . error ( " Error ▁ while ▁ receiving ▁ messages ▁ " , e ) ; throw new RuntimeException ( " JMSException ▁ : ▁ Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; } catch ( IOException e ) { log . error ( " Error ▁ while ▁ writing ▁ message ▁ to ▁ file " , e ) ; throw new RuntimeException ( " IOException ▁ : ▁ Error ▁ while ▁ writing ▁ message ▁ to ▁ file \" " , e ) ; } }
milindaperera/product-ei | @ Override public void onMessage ( Message message ) { try { boolean success = this . processReceivedMessage ( message ) ; if ( success ) { stopClient ( ) ; } } catch ( JMSException e ) { log . error ( " Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; throw new RuntimeException ( " Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; } catch ( IOException e ) { log . error ( " Error ▁ while ▁ writing ▁ message ▁ to ▁ file " , e ) ; throw new RuntimeException ( " Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; } }
milindaperera/product-ei | if ( null != message ) { long threadID = Thread . currentThread ( ) . getId ( ) ; long currentTimeStamp = System . currentTimeMillis ( ) ; this . totalLatency = this . totalLatency + ( currentTimeStamp - message . getJMSTimestamp ( ) ) ; if ( 0 == this . firstMessageConsumedTimestamp ) { this . firstMessageConsumedTimestamp = currentTimeStamp ; } this . lastMessageConsumedTimestamp = currentTimeStamp ; this . receivedMessageCount . incrementAndGet ( ) ; JMSDeliveryStatus deliveryStatus ; if ( message . getJMSRedelivered ( ) ) { deliveryStatus = JMSDeliveryStatus . REDELIVERED ; } else { deliveryStatus = JMSDeliveryStatus . ORIGINAL ; } if ( 0 == this . receivedMessageCount . get ( ) % this . consumerConfig . getPrintsPerMessageCount ( ) ) { log . info ( " [ RECEIVE ] ▁ ThreadID : " + threadID + " ▁ Destination ( " + this . consumerConfig . getExchangeType ( ) . getType ( ) + " ) : " + this . consumerConfig . getDestinationName ( ) + " ▁ ReceivedMessageCount : " + this . receivedMessageCount + " ▁ MessageToReceive : " + this . consumerConfig . getMaximumMessagesToReceived ( ) + " ▁ Original / Redelivered : " + deliveryStatus . getStatus ( ) ) ; } if ( null != this . consumerConfig . getFilePathToWriteStatistics ( ) ) { String statisticsString = Long . toString ( currentTimeStamp ) + " , " + Double . toString ( this . getConsumerTPS ( ) ) + " , " + Double . toString ( this . getAverageLatency ( ) ) ; AndesClientUtils . writeStatisticsToFile ( statisticsString , this . consumerConfig . getFilePathToWriteStatistics ( ) ) ; } if ( message instanceof TextMessage ) { TextMessage textMessage = ( TextMessage ) message ; if ( null != this . consumerConfig . getFilePathToWriteReceivedMessages ( ) ) { AndesClientUtils . writeReceivedMessagesToFile ( textMessage . getText ( ) , this . consumerConfig . getFilePathToWriteReceivedMessages ( ) ) ; } else { this . consumerConfig . addReceivedMessage ( textMessage . getText ( ) ) ; } } if ( 0 == this . receivedMessageCount . get ( ) % this . consumerConfig . getAcknowledgeAfterEachMessageCount ( ) ) { if ( Session . CLIENT_ACKNOWLEDGE == session . getAcknowledgeMode ( ) ) { message . acknowledge ( ) ; log . info ( " Acknowledging ▁ message ▁ : ▁ " + message . getJMSMessageID ( ) ) ; } } if ( 0 == this . receivedMessageCount . get ( ) % consumerConfig . getCommitAfterEachMessageCount ( ) ) { session . commit ( ) ; log . info ( " Committed ▁ session " ) ; } else if ( 0 == this . receivedMessageCount . get ( ) % consumerConfig . getRollbackAfterEachMessageCount ( ) ) { session . rollback ( ) ; log . info ( " Roll - backed ▁ session " ) ; } else if ( 0 == this . receivedMessageCount . get ( ) % consumerConfig . getRecoverAfterEachMessageCount ( ) ) { log . info ( " Recovering ▁ session " ) ; session . recover ( ) ; } if ( this . receivedMessageCount . get ( ) >= consumerConfig . getUnSubscribeAfterEachMessageCount ( ) ) { unSubscribe ( true ) ; AndesClientUtils . sleepForInterval ( 1000L ) ; return true ; } else if ( this . receivedMessageCount . get ( ) >= consumerConfig . getMaximumMessagesToReceived ( ) ) { return true ; } if ( 0 < consumerConfig . getRunningDelay ( ) ) { try { Thread . sleep ( consumerConfig . getRunningDelay ( ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } }
milindaperera/product-ei | public AtomicLong getReceivedMessageCount ( ) { return this . receivedMessageCount ; }
milindaperera/product-ei | public double getConsumerTPS ( ) { if ( 0 == this . lastMessageConsumedTimestamp - this . firstMessageConsumedTimestamp ) { return this . receivedMessageCount . doubleValue ( ) / ( 1D / 1000 ) ; } else { return this . receivedMessageCount . doubleValue ( ) / ( ( ( double ) ( this . lastMessageConsumedTimestamp - this . firstMessageConsumedTimestamp ) ) / 1000D ) ; } }
milindaperera/product-ei | public double getAverageLatency ( ) { if ( 0 == this . receivedMessageCount . doubleValue ( ) ) { log . warn ( " No ▁ messages ▁ were ▁ received ▁ to ▁ calculate ▁ average ▁ latency . " ) ; return 0D ; } else { return ( ( ( double ) this . totalLatency ) / 1000D ) / this . receivedMessageCount . doubleValue ( ) ; } }
milindaperera/product-ei | @ Override public AndesJMSConsumerClientConfiguration getConfig ( ) { return this . consumerConfig ; }
milindaperera/product-ei | public Connection getConnection ( ) { return this . connection ; }
milindaperera/product-ei | public void setConnection ( Connection connection ) { this . connection = connection ; }
milindaperera/product-ei | public Session getSession ( ) { return this . session ; }
milindaperera/product-ei | public void setSession ( Session session ) { this . session = session ; }
milindaperera/product-ei | public MessageConsumer getReceiver ( ) { return this . receiver ; }
milindaperera/product-ei | public void setReceiver ( MessageConsumer receiver ) { this . receiver = receiver ; }
VHAINNOVATIONS/Telepathology | private ImageExchangeApplicationContext ( ) { super ( effectiveApplicationContext ) ; }
RedHotChiliBots/FRC4453 | public OI ( ) { System . out . println ( " OI ▁ starting . . . " ) ; drive1Controller = new Joystick ( RobotMap . FIRST_CONTROLLER ) ; }
RedHotChiliBots/FRC4453 | public Joystick getDrive1Controller ( ) { return drive1Controller ; }
RedHotChiliBots/FRC4453 | public double getLeftYDriveStick ( ) { double leftY = drive1Controller . getRawAxis ( RobotMap . Y_AXIS ) ; return ( Math . abs ( leftY ) < 0.15 ? 0.0 : - leftY ) ; }
RedHotChiliBots/FRC4453 | public double getLeftXDriveStick ( ) { double leftX = drive1Controller . getRawAxis ( RobotMap . X_AXIS ) ; return ( Math . abs ( leftX ) < 0.15 ? 0.0 : - leftX ) ; }
RedHotChiliBots/FRC4453 | public double getThrottleDrive ( ) { double leftZ = drive1Controller . getRawAxis ( RobotMap . THROTTLE_AXIS ) ; return 0.35 * - leftZ + 0.65 ; }
james345221/coolweather | public int getId ( ) { return id ; }
james345221/coolweather | public void setId ( int id ) { this . id = id ; }
james345221/coolweather | public String getCityName ( ) { return cityName ; }
james345221/coolweather | public void setCityName ( String cityName ) { this . cityName = cityName ; }
james345221/coolweather | public int getCityCode ( ) { return cityCode ; }
james345221/coolweather | public void setCityCode ( int cityCode ) { this . cityCode = cityCode ; }
james345221/coolweather | public int getProvinceId ( ) { return provinceId ; }
james345221/coolweather | public void setProvinceId ( int provinceId ) { this . provinceId = provinceId ; }
Svish/hyperic-sonicmq-plugin | public DomainOptions ( Properties properties ) { validate ( properties , Options . Domain . Name , Options . Domain . Location , Options . Domain . Username , Options . Domain . Password ) ; domain = properties . getProperty ( Options . Domain . Name ) ; location = properties . getProperty ( Options . Domain . Location ) ; username = properties . getProperty ( Options . Domain . Username ) ; password = properties . getProperty ( Options . Domain . Password ) ; id = properties . getProperty ( Options . Component . Id , domain + " . DIRECTORY ▁ SERVICE : ID = DIRECTORY ▁ SERVICE " ) ; }
ivelin1936/Studing-SoftUni- | @ Autowired public OfferServiceImpl ( OfferRepository offerRepository , ModelMapper modelMapper , Validator validator ) { this . offerRepository = offerRepository ; this . modelMapper = modelMapper ; this . validator = validator ; }
ivelin1936/Studing-SoftUni- | @ Override public void register ( OfferServiceModel serviceModel ) { if ( validator . validate ( serviceModel ) . size ( ) != DEFAULT_CONSTRAINT_VIOLATION_SIZE ) { throw new IllegalArgumentException ( DEFAULT_INVALID_MODEL_MESSAGE ) ; } Offer offerEntity = this . modelMapper . map ( serviceModel , Offer . class ) ; this . offerRepository . saveAndFlush ( offerEntity ) ; }
ivelin1936/Studing-SoftUni- | @ Override public List < OfferServiceModel > findAll ( ) { return this . offerRepository . findAll ( ) . stream ( ) . map ( entity -> this . modelMapper . map ( entity , OfferServiceModel . class ) ) . collect ( Collectors . toList ( ) ) ; }
ivelin1936/Studing-SoftUni- | @ Override public void findOffer ( OfferFindServiceModel model ) { if ( this . validator . validate ( model ) . size ( ) != DEFAULT_CONSTRAINT_VIOLATION_SIZE ) { throw new IllegalArgumentException ( DEFAULT_INVALID_MODEL_MESSAGE ) ; } Offer offer = this . offerRepository . findAll ( ) . stream ( ) . filter ( o -> o . getApartmentType ( ) . toLowerCase ( ) . equals ( model . getApartmentType ( ) . toLowerCase ( ) ) && this . isFamilyBudgetEnough ( model . getFamilyBudget ( ) , o ) ) . findFirst ( ) . orElse ( null ) ; if ( offer == null ) { throw new IllegalArgumentException ( DEFAULT_NOT_FOUND_OFFER_MESSAGE ) ; } this . offerRepository . delete ( offer ) ; }
ivelin1936/Studing-SoftUni- | private boolean isFamilyBudgetEnough ( BigDecimal familyBudget , Offer offer ) { BigDecimal finalPrice = offer . getApartmentRent ( ) . add ( offer . getAgencyCommission ( ) . divide ( new BigDecimal ( 100 ) ) . multiply ( offer . getApartmentRent ( ) ) ) ; return familyBudget . compareTo ( finalPrice ) >= 0 ; }
mocircle/cidrawing | @ Override public void applyMatrixForData ( Matrix matrix ) { super . applyMatrixForData ( matrix ) ; boundingPath . transform ( matrix ) ; }
mocircle/cidrawing | @ Override public void updateBoundingBox ( ) { if ( boundingPath != null ) { RectF box = new RectF ( ) ; boundingPath . computeBounds ( box , true ) ; setBoundingBox ( box ) ; } }
mocircle/cidrawing | @ Override public RectF getOuterBoundingBox ( ) { if ( boundingPath != null ) { Path path = new Path ( boundingPath ) ; path . transform ( getDisplayMatrix ( ) ) ; RectF box = new RectF ( ) ; path . computeBounds ( box , true ) ; return box ; } return new RectF ( ) ; }
mocircle/cidrawing | @ Override public Path getTouchableArea ( ) { if ( boundingPath != null ) { return boundingPath ; } else { return new Path ( ) ; } }
mocircle/cidrawing | @ Override protected void cloneTo ( BaseElement element ) { super . cloneTo ( element ) ; if ( element instanceof BoundsElement ) { BoundsElement obj = ( BoundsElement ) element ; if ( originalBoundingBox != null ) { obj . originalBoundingBox = new RectF ( originalBoundingBox ) ; } if ( boundingPath != null ) { obj . boundingPath = new Path ( boundingPath ) ; } } }
mocircle/cidrawing | protected void updateBoundingBoxWithDataMatrix ( ) { boundingPath . transform ( getDataMatrix ( ) ) ; updateBoundingBox ( ) ; }
shigengyu/Hyperion | public ListHashMap < K , V > addAll ( Iterable < V > values , Function < V , K > keySelector ) { for ( V value : values ) { K key = keySelector . apply ( value ) ; addItem ( key , value ) ; } return this ; }
shigengyu/Hyperion | public ListHashMap < K , V > addItem ( K key , V value ) { if ( ! map . containsKey ( key ) ) { map . put ( key , new ArrayList < V > ( ) ) ; } map . get ( key ) . add ( value ) ; return this ; }
shigengyu/Hyperion | public boolean containsItems ( String key , V item ) { return map . containsKey ( key ) && map . get ( key ) . contains ( item ) ; }
shigengyu/Hyperion | public boolean containsKey ( String key ) { return map . containsKey ( key ) ; }
shigengyu/Hyperion | public List < V > get ( K key ) { List < V > mutable = getMutable ( key ) ; if ( mutable == null ) { return null ; } return ImmutableList . copyOf ( mutable ) ; }
shigengyu/Hyperion | public List < V > getMutable ( K key ) { return map . get ( key ) ; }
shigengyu/Hyperion | @ Override public Iterator < Entry < K , List < V > > > iterator ( ) { return map . entrySet ( ) . iterator ( ) ; }
shigengyu/Hyperion | public List < V > remove ( String key ) { return map . remove ( key ) ; }
shigengyu/Hyperion | public boolean removeItem ( String key , V value ) { if ( ! map . containsKey ( key ) ) { return false ; } return map . get ( key ) . remove ( value ) ; }
shigengyu/Hyperion | public int size ( ) { return map . size ( ) ; }
shigengyu/Hyperion | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int count = 0 ; for ( Entry < K , List < V > > entry : map . entrySet ( ) ) { sb . append ( entry . getKey ( ) + " ▁ ( " + entry . getKey ( ) . hashCode ( ) + " ) ▁ = ▁ " + entry . getValue ( ) + SystemUtils . LINE_SEPARATOR ) ; ++ count ; if ( count == 10 ) { sb . append ( " . . . " ) ; return sb . toString ( ) ; } } return sb . toString ( ) ; }
SweeneyLiu/TravelWeather | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; ButterKnife . bind ( this ) ; setSupportActionBar ( toolbar ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; getSupportActionBar ( ) . setTitle ( R . string . about ) ; } version . setText ( " V ▁ " + getVersionName ( ) ) ; }
SweeneyLiu/TravelWeather | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : finish ( ) ; break ; default : } return super . onOptionsItemSelected ( item ) ; }
SweeneyLiu/TravelWeather | ) public void onClick ( View view ) { switch ( view . getId ( ) ) { case R . id . suggestion : Intent intent = new Intent ( AboutActivity . this , ContactActivity . class ) ; startActivity ( intent ) ; break ; case R . id . new_version : break ; case R . id . favourable_comment : openApplicationMarket ( ) ; break ; } }
SweeneyLiu/TravelWeather | @ Override protected void onResume ( ) { super . onResume ( ) ; }
SweeneyLiu/TravelWeather | @ Override protected void onStop ( ) { super . onStop ( ) ; }
SweeneyLiu/TravelWeather | private void openApplicationMarket ( ) { try { String str = " market : // details ? id = " + getPackageName ( ) ; Intent localIntent = new Intent ( Intent . ACTION_VIEW ) ; localIntent . setData ( Uri . parse ( str ) ) ; startActivity ( localIntent ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; Toast . makeText ( getApplicationContext ( ) , " 打开应用商店失败 " , Toast . LENGTH_SHORT ) . show ( ) ; String url = " http : // app . mi . com / detail / 163525 ? ref = search " ; openLinkBySystem ( url ) ; } }
SweeneyLiu/TravelWeather | private void openLinkBySystem ( String url ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; startActivity ( intent ) ; }
SweeneyLiu/TravelWeather | private String getVersionName ( ) { PackageManager packageManager = getPackageManager ( ) ; PackageInfo packInfo = null ; String version = " " ; try { packInfo = packageManager . getPackageInfo ( getPackageName ( ) , 0 ) ; version = packInfo . versionName ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } return version ; }
AndiDog/zap-extensions | public WebSocketProxyListenerBreak ( ExtensionWebSocket extension , BreakpointMessageHandler messageHandler ) { this . extension = extension ; this . wsBrkMessageHandler = messageHandler ; }
AndiDog/zap-extensions | @ Override public int getObservingOrder ( ) { return WEBSOCKET_OBSERVING_ORDER ; }
AndiDog/zap-extensions | @ Override public boolean onMessageFrame ( int channelId , WebSocketMessage wsMessage ) { boolean continueNotifying = false ; WebSocketMessageDTO message = wsMessage . getDTO ( ) ; if ( ! extension . isSafe ( message ) ) { return true ; } if ( ! wsMessage . isFinished ( ) ) { boolean isRequest = ( wsMessage . getDirection ( ) . equals ( Direction . OUTGOING ) ) ; if ( wsBrkMessageHandler . isBreakpoint ( message , isRequest , false ) ) { continueNotifying = false ; } else { continueNotifying = true ; } return continueNotifying ; } if ( message . isOutgoing ) { if ( wsBrkMessageHandler . handleMessageReceivedFromClient ( message , false ) ) { setPayload ( wsMessage , message . payload ) ; continueNotifying = true ; } } else { if ( wsBrkMessageHandler . handleMessageReceivedFromServer ( message , false ) ) { setPayload ( wsMessage , message . payload ) ; continueNotifying = true ; } } return continueNotifying ; }
AndiDog/zap-extensions | @ Override public void onStateChange ( State state , WebSocketProxy proxy ) { }
AndiDog/zap-extensions | private void setPayload ( WebSocketMessage message , Object payload ) { try { if ( payload instanceof String ) { message . setReadablePayload ( ( String ) payload ) ; } else if ( payload instanceof byte [ ] ) { message . setPayload ( ( byte [ ] ) payload ) ; } } catch ( WebSocketException e ) { logger . error ( e ) ; } }
ChengCorp/robolectric | @ Test public void shouldUseApplicationLabelFromManifestAsTitleForActivity ( ) throws Exception { activity = Robolectric . setupActivity ( LabelTestActivity1 . class ) ; assertThat ( activity . getTitle ( ) ) . isNotNull ( ) ; assertThat ( activity . getTitle ( ) . toString ( ) ) . isEqualTo ( activity . getString ( R . string . app_name ) ) ; }
ChengCorp/robolectric | @ Test public void shouldUseActivityLabelFromManifestAsTitleForActivity ( ) throws Exception { activity = Robolectric . setupActivity ( LabelTestActivity2 . class ) ; assertThat ( activity . getTitle ( ) ) . isNotNull ( ) ; assertThat ( activity . getTitle ( ) . toString ( ) ) . isEqualTo ( activity . getString ( R . string . activity_name ) ) ; }
ChengCorp/robolectric | @ Test public void shouldUseActivityLabelFromManifestAsTitleForActivityWithShortName ( ) throws Exception { activity = Robolectric . setupActivity ( LabelTestActivity3 . class ) ; assertThat ( activity . getTitle ( ) ) . isNotNull ( ) ; assertThat ( activity . getTitle ( ) . toString ( ) ) . isEqualTo ( activity . getString ( R . string . activity_name ) ) ; }
ChengCorp/robolectric | @ Test public void shouldNotComplainIfActivityIsDestroyedWhileAnotherActivityHasRegisteredBroadcastReceivers ( ) throws Exception { ActivityController < DialogCreatingActivity > controller = Robolectric . buildActivity ( DialogCreatingActivity . class ) ; activity = controller . get ( ) ; DialogLifeCycleActivity activity2 = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; activity2 . registerReceiver ( new AppWidgetProvider ( ) , new IntentFilter ( ) ) ; controller . destroy ( ) ; }
ChengCorp/robolectric | @ Test public void shouldNotRegisterNullBroadcastReceiver ( ) { ActivityController < DialogCreatingActivity > controller = Robolectric . buildActivity ( DialogCreatingActivity . class ) ; activity = controller . get ( ) ; activity . registerReceiver ( null , new IntentFilter ( ) ) ; controller . destroy ( ) ; }
ChengCorp/robolectric | @ Test @ Config ( minSdk = JELLY_BEAN_MR1 ) public void shouldReportDestroyedStatus ( ) { ActivityController < DialogCreatingActivity > controller = Robolectric . buildActivity ( DialogCreatingActivity . class ) ; activity = controller . get ( ) ; controller . destroy ( ) ; assertThat ( activity . isDestroyed ( ) ) . isTrue ( ) ; }
ChengCorp/robolectric | @ Test public void startActivity_shouldDelegateToStartActivityForResult ( ) { final List < String > transcript = new ArrayList < > ( ) ; Activity activity = new Activity ( ) { @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { transcript . add ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ " + requestCode + " , ▁ resultCode ▁ " + resultCode + " , ▁ intent ▁ data ▁ " + data . getData ( ) ) ; } } ; activity . startActivity ( new Intent ( ) . setType ( " image /* " ) ) ; shadowOf ( activity ) . receiveResult ( new Intent ( ) . setType ( " image /* " ) , Activity . RESULT_OK , new Intent ( ) . setData ( Uri . parse ( " content : foo " ) ) ) ; assertThat ( transcript ) . containsExactly ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ - 1 , ▁ resultCode ▁ - 1 , ▁ intent ▁ data ▁ content : foo " ) ; }
ChengCorp/robolectric | @ Test public void startActivities_shouldStartAllActivities ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final Intent view = new Intent ( Intent . ACTION_VIEW ) ; final Intent pick = new Intent ( Intent . ACTION_PICK ) ; activity . startActivities ( new Intent [ ] { view , pick } ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( pick ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( view ) ; }
ChengCorp/robolectric | @ Test public void startActivities_withBundle_shouldStartAllActivities ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final Intent view = new Intent ( Intent . ACTION_VIEW ) ; final Intent pick = new Intent ( Intent . ACTION_PICK ) ; activity . startActivities ( new Intent [ ] { view , pick } , new Bundle ( ) ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( pick ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( view ) ; }
ChengCorp/robolectric | @ Test public void startActivityForResultAndReceiveResult_shouldSendResponsesBackToActivity ( ) throws Exception { final List < String > transcript = new ArrayList < > ( ) ; Activity activity = new Activity ( ) { @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { transcript . add ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ " + requestCode + " , ▁ resultCode ▁ " + resultCode + " , ▁ intent ▁ data ▁ " + data . getData ( ) ) ; } } ; activity . startActivityForResult ( new Intent ( ) . setType ( " audio /* " ) , 123 ) ; activity . startActivityForResult ( new Intent ( ) . setType ( " image /* " ) , 456 ) ; shadowOf ( activity ) . receiveResult ( new Intent ( ) . setType ( " image /* " ) , Activity . RESULT_OK , new Intent ( ) . setData ( Uri . parse ( " content : foo " ) ) ) ; assertThat ( transcript ) . containsExactly ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ 456 , ▁ resultCode ▁ - 1 , ▁ intent ▁ data ▁ content : foo " ) ; }
ChengCorp/robolectric | @ Test public void startActivityForResultAndReceiveResult_whenNoIntentMatches_shouldThrowException ( ) throws Exception { Activity activity = new Activity ( ) { @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { throw new IllegalStateException ( " should ▁ not ▁ be ▁ called " ) ; } } ; activity . startActivityForResult ( new Intent ( ) . setType ( " audio /* " ) , 123 ) ; activity . startActivityForResult ( new Intent ( ) . setType ( " image /* " ) , 456 ) ; Intent requestIntent = new Intent ( ) . setType ( " video /* " ) ; try { shadowOf ( activity ) . receiveResult ( requestIntent , Activity . RESULT_OK , new Intent ( ) . setData ( Uri . parse ( " content : foo " ) ) ) ; fail ( ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) ) . startsWith ( " No ▁ intent ▁ matches ▁ " + requestIntent ) ; } }
ChengCorp/robolectric | @ Test public void shouldSupportStartActivityForResult ( ) throws Exception { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; Intent intent = new Intent ( ) . setClass ( activity , DialogLifeCycleActivity . class ) ; assertThat ( shadowActivity . getNextStartedActivity ( ) ) . isNull ( ) ; activity . startActivityForResult ( intent , 142 ) ; Intent startedIntent = shadowActivity . getNextStartedActivity ( ) ; assertThat ( startedIntent ) . isNotNull ( ) ; assertThat ( startedIntent ) . isSameAs ( intent ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportGetStartedActivitiesForResult ( ) throws Exception { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; Intent intent = new Intent ( ) . setClass ( activity , DialogLifeCycleActivity . class ) ; activity . startActivityForResult ( intent , 142 ) ; ShadowActivity . IntentForResult intentForResult = shadowActivity . getNextStartedActivityForResult ( ) ; assertThat ( intentForResult ) . isNotNull ( ) ; assertThat ( shadowActivity . getNextStartedActivityForResult ( ) ) . isNull ( ) ; assertThat ( intentForResult . intent ) . isNotNull ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 142 ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportPeekStartedActivitiesForResult ( ) throws Exception { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; Intent intent = new Intent ( ) . setClass ( activity , DialogLifeCycleActivity . class ) ; activity . startActivityForResult ( intent , 142 ) ; ShadowActivity . IntentForResult intentForResult = shadowActivity . peekNextStartedActivityForResult ( ) ; assertThat ( intentForResult ) . isNotNull ( ) ; assertThat ( shadowActivity . peekNextStartedActivityForResult ( ) ) . isSameAs ( intentForResult ) ; assertThat ( intentForResult . intent ) . isNotNull ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 142 ) ; }
ChengCorp/robolectric | @ Test public void onContentChangedShouldBeCalledAfterContentViewIsSet ( ) throws RuntimeException { final List < String > transcript = new ArrayList < > ( ) ; ActivityWithContentChangedTranscript customActivity = Robolectric . setupActivity ( ActivityWithContentChangedTranscript . class ) ; customActivity . setTranscript ( transcript ) ; customActivity . setContentView ( R . layout . main ) ; assertThat ( transcript ) . containsExactly ( " onContentChanged ▁ was ▁ called ; ▁ title ▁ is ▁ \" Main ▁ Layout \" " ) ; }
ChengCorp/robolectric | @ Test public void shouldRetrievePackageNameFromTheManifest ( ) throws Exception { assertThat ( Robolectric . setupActivity ( Activity . class ) . getPackageName ( ) ) . isEqualTo ( RuntimeEnvironment . application . getPackageName ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldRunUiTasksImmediatelyByDefault ( ) throws Exception { TestRunnable runnable = new TestRunnable ( ) ; activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; activity . runOnUiThread ( runnable ) ; assertTrue ( runnable . wasRun ) ; }
ChengCorp/robolectric | @ Test public void shouldQueueUiTasksWhenUiThreadIsPaused ( ) throws Exception { ShadowLooper . pauseMainLooper ( ) ; activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; TestRunnable runnable = new TestRunnable ( ) ; activity . runOnUiThread ( runnable ) ; assertFalse ( runnable . wasRun ) ; ShadowLooper . unPauseMainLooper ( ) ; assertTrue ( runnable . wasRun ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldCreatePrepareAndShowDialog ( ) { final DialogLifeCycleActivity activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final AtomicBoolean dialogWasShown = new AtomicBoolean ( false ) ; new Dialog ( activity ) { { activity . dialog = this ; } @ Override public void show ( ) { dialogWasShown . set ( true ) ; } } ; activity . showDialog ( 1 ) ; assertTrue ( activity . createdDialog ) ; assertTrue ( activity . preparedDialog ) ; assertTrue ( dialogWasShown . get ( ) ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldCreatePrepareAndShowDialogWithBundle ( ) { final DialogLifeCycleActivity activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final AtomicBoolean dialogWasShown = new AtomicBoolean ( false ) ; new Dialog ( activity ) { { activity . dialog = this ; } @ Override public void show ( ) { dialogWasShown . set ( true ) ; } } ; activity . showDialog ( 1 , new Bundle ( ) ) ; assertTrue ( activity . createdDialog ) ; assertTrue ( activity . preparedDialogWithBundle ) ; assertTrue ( dialogWasShown . get ( ) ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldReturnFalseIfDialogDoesNotExist ( ) { final DialogLifeCycleActivity activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; boolean dialogCreated = activity . showDialog ( 97 , new Bundle ( ) ) ; assertThat ( dialogCreated ) . isFalse ( ) ; assertThat ( activity . createdDialog ) . isTrue ( ) ; assertThat ( activity . preparedDialogWithBundle ) . isFalse ( ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldReuseDialogs ( ) { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; Dialog firstDialog = ShadowDialog . getLatestDialog ( ) ; activity . showDialog ( 1 ) ; Dialog secondDialog = ShadowDialog . getLatestDialog ( ) ; assertSame ( " dialogs ▁ should ▁ be ▁ the ▁ same ▁ instance " , firstDialog , secondDialog ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldShowDialog ( ) throws Exception { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; Dialog dialog = ShadowDialog . getLatestDialog ( ) ; assertTrue ( dialog . isShowing ( ) ) ; }
ChengCorp/robolectric | @ Test public void dismissDialog_shouldDismissPreviouslyShownDialog ( ) throws Exception { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; activity . dismissDialog ( 1 ) ; Dialog dialog = ShadowDialog . getLatestDialog ( ) ; assertFalse ( dialog . isShowing ( ) ) ; }
ChengCorp/robolectric | @ Test ( expected = IllegalArgumentException . class ) public void dismissDialog_shouldThrowExceptionIfDialogWasNotPreviouslyShown ( ) throws Exception { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . dismissDialog ( 1 ) ; }
ChengCorp/robolectric | @ Test public void removeDialog_shouldCreateDialogAgain ( ) { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; Dialog firstDialog = ShadowDialog . getLatestDialog ( ) ; activity . removeDialog ( 1 ) ; assertNull ( shadowOf ( activity ) . getDialogById ( 1 ) ) ; activity . showDialog ( 1 ) ; Dialog secondDialog = ShadowDialog . getLatestDialog ( ) ; assertNotSame ( " dialogs ▁ should ▁ not ▁ be ▁ the ▁ same ▁ instance " , firstDialog , secondDialog ) ; }
ChengCorp/robolectric | @ Test public void shouldCallOnCreateDialogFromShowDialog ( ) { ActivityWithOnCreateDialog activity = Robolectric . setupActivity ( ActivityWithOnCreateDialog . class ) ; activity . showDialog ( 123 ) ; assertTrue ( activity . onCreateDialogWasCalled ) ; assertThat ( ShadowDialog . getLatestDialog ( ) ) . isNotNull ( ) ; }
ChengCorp/robolectric | @ Test public void shouldCallFinishInOnBackPressed ( ) { Activity activity = new Activity ( ) ; activity . onBackPressed ( ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; assertTrue ( shadowActivity . isFinishing ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportCurrentFocus ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadow = shadowOf ( activity ) ; assertNull ( shadow . getCurrentFocus ( ) ) ; View view = new View ( activity ) ; shadow . setCurrentFocus ( view ) ; assertEquals ( view , shadow . getCurrentFocus ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldSetOrientation ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; assertThat ( activity . getRequestedOrientation ( ) ) . isEqualTo ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; }
ChengCorp/robolectric | @ Test public void setDefaultKeyMode_shouldSetKeyMode ( ) { int [ ] modes = { Activity . DEFAULT_KEYS_DISABLE , Activity . DEFAULT_KEYS_SHORTCUT , Activity . DEFAULT_KEYS_DIALER , Activity . DEFAULT_KEYS_SEARCH_LOCAL , Activity . DEFAULT_KEYS_SEARCH_GLOBAL } ; Activity activity = new Activity ( ) ; ShadowActivity shadow = shadowOf ( activity ) ; for ( int mode : modes ) { activity . setDefaultKeyMode ( mode ) ; assertThat ( shadow . getDefaultKeymode ( ) ) . as ( " Unexpected ▁ key ▁ mode " ) . isEqualTo ( mode ) ; } }
ChengCorp/robolectric | @ Test public void shouldPopulateWindowDecorViewWithMergeLayoutContents ( ) throws Exception { Activity activity = Robolectric . buildActivity ( Activity . class ) . create ( ) . get ( ) ; activity . setContentView ( R . layout . toplevel_merge ) ; View contentView = activity . findViewById ( android . R . id . content ) ; assertThat ( ( ( ViewGroup ) contentView ) . getChildCount ( ) ) . isEqualTo ( 2 ) ; }
ChengCorp/robolectric | @ Test public void setContentView_shouldReplaceOldContentView ( ) throws Exception { View view1 = new View ( application ) ; view1 . setId ( R . id . burritos ) ; View view2 = new View ( application ) ; view2 . setId ( R . id . button ) ; Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; activity . setContentView ( view1 ) ; assertSame ( view1 , activity . findViewById ( R . id . burritos ) ) ; activity . setContentView ( view2 ) ; assertNull ( activity . findViewById ( R . id . burritos ) ) ; assertSame ( view2 , activity . findViewById ( R . id . button ) ) ; }
ChengCorp/robolectric | @ Test public void onKeyUp_callsOnBackPressedWhichFinishesTheActivity ( ) throws Exception { OnBackPressedActivity activity = buildActivity ( OnBackPressedActivity . class ) . setup ( ) . get ( ) ; boolean downConsumed = activity . dispatchKeyEvent ( new KeyEvent ( KeyEvent . ACTION_DOWN , KeyEvent . KEYCODE_BACK ) ) ; boolean upConsumed = activity . dispatchKeyEvent ( new KeyEvent ( KeyEvent . ACTION_UP , KeyEvent . KEYCODE_BACK ) ) ; assertTrue ( downConsumed ) ; assertTrue ( upConsumed ) ; assertTrue ( activity . onBackPressedCalled ) ; assertTrue ( activity . isFinishing ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldGiveSharedPreferences ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; SharedPreferences preferences = activity . getPreferences ( Context . MODE_PRIVATE ) ; assertNotNull ( preferences ) ; preferences . edit ( ) . putString ( " foo " , " bar " ) . commit ( ) ; assertThat ( activity . getPreferences ( Context . MODE_PRIVATE ) . getString ( " foo " , null ) ) . isEqualTo ( " bar " ) ; }
ChengCorp/robolectric | @ Test public void shouldFindContentViewContainerWithChild ( ) throws Exception { Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; View contentView = new View ( activity ) ; activity . setContentView ( contentView ) ; FrameLayout contentViewContainer = ( FrameLayout ) activity . findViewById ( android . R . id . content ) ; assertThat ( contentViewContainer . getChildAt ( 0 ) ) . isSameAs ( contentView ) ; }
ChengCorp/robolectric | @ Test public void shouldFindContentViewContainerWithoutChild ( ) throws Exception { Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; FrameLayout contentViewContainer = ( FrameLayout ) activity . findViewById ( android . R . id . content ) ; assertThat ( contentViewContainer . getId ( ) ) . isEqualTo ( android . R . id . content ) ; }
ChengCorp/robolectric | @ Test public void recreateGoesThroughFullLifeCycle ( ) throws Exception { TestActivity activity = buildActivity ( TestActivity . class ) . get ( ) ; activity . recreate ( ) ; assertThat ( activity . transcript ) . containsExactly ( " onSaveInstanceState " , " onPause " , " onStop " , " onRetainNonConfigurationInstance " , " onDestroy " , " onCreate " , " onStart " , " onRestoreInstanceState " , " onResume " ) ; Integer storedValue = ( Integer ) activity . getLastNonConfigurationInstance ( ) ; assertEquals ( 5 , storedValue . intValue ( ) ) ; }
ChengCorp/robolectric | @ Test public void startAndStopManagingCursorTracksCursors ( ) throws Exception { TestActivity activity = new TestActivity ( ) ; ShadowActivity shadow = shadowOf ( activity ) ; assertThat ( shadow . getManagedCursors ( ) ) . isNotNull ( ) ; assertThat ( shadow . getManagedCursors ( ) . size ( ) ) . isEqualTo ( 0 ) ; Cursor c = Shadow . newInstanceOf ( SQLiteCursor . class ) ; activity . startManagingCursor ( c ) ; assertThat ( shadow . getManagedCursors ( ) ) . isNotNull ( ) ; assertThat ( shadow . getManagedCursors ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertThat ( shadow . getManagedCursors ( ) . get ( 0 ) ) . isSameAs ( c ) ; activity . stopManagingCursor ( c ) ; assertThat ( shadow . getManagedCursors ( ) ) . isNotNull ( ) ; assertThat ( shadow . getManagedCursors ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
ChengCorp/robolectric | @ Test public void setVolumeControlStream_setsTheSpecifiedStreamType ( ) { TestActivity activity = new TestActivity ( ) ; activity . setVolumeControlStream ( AudioManager . STREAM_ALARM ) ; assertThat ( activity . getVolumeControlStream ( ) ) . isEqualTo ( AudioManager . STREAM_ALARM ) ; }
ChengCorp/robolectric | @ Test public void decorViewSizeEqualToDisplaySize ( ) { Activity activity = buildActivity ( Activity . class ) . create ( ) . visible ( ) . get ( ) ; View decorView = activity . getWindow ( ) . getDecorView ( ) ; assertThat ( decorView ) . isNotEqualTo ( null ) ; ViewRootImpl root = decorView . getViewRootImpl ( ) ; assertThat ( root ) . isNotEqualTo ( null ) ; assertThat ( decorView . getWidth ( ) ) . isNotEqualTo ( 0 ) ; assertThat ( decorView . getHeight ( ) ) . isNotEqualTo ( 0 ) ; Display display = Shadow . newInstanceOf ( Display . class ) ; ShadowDisplay shadowDisplay = Shadows . shadowOf ( display ) ; assertThat ( decorView . getWidth ( ) ) . isEqualTo ( shadowDisplay . getWidth ( ) ) ; assertThat ( decorView . getHeight ( ) ) . isEqualTo ( shadowDisplay . getHeight ( ) ) ; }
ChengCorp/robolectric | @ Test @ Config ( minSdk = M ) public void requestsPermissions ( ) { TestActivity activity = new TestActivity ( ) ; activity . requestPermissions ( new String [ 0 ] , - 1 ) ; }
ChengCorp/robolectric | @ Override public void onSaveInstanceState ( Bundle outState ) { isRecreating = true ; transcript . add ( " onSaveInstanceState " ) ; outState . putString ( " TestActivityKey " , " TestActivityValue " ) ; super . onSaveInstanceState ( outState ) ; }
ChengCorp/robolectric | @ Override public void onRestoreInstanceState ( Bundle savedInstanceState ) { transcript . add ( " onRestoreInstanceState " ) ; assertTrue ( savedInstanceState . containsKey ( " TestActivityKey " ) ) ; assertEquals ( " TestActivityValue " , savedInstanceState . getString ( " TestActivityKey " ) ) ; super . onRestoreInstanceState ( savedInstanceState ) ; }
ChengCorp/robolectric | @ Override public Object onRetainNonConfigurationInstance ( ) { transcript . add ( " onRetainNonConfigurationInstance " ) ; return new Integer ( 5 ) ; }
ChengCorp/robolectric | @ Override public void onPause ( ) { transcript . add ( " onPause " ) ; super . onPause ( ) ; }
ChengCorp/robolectric | @ Override public void onDestroy ( ) { transcript . add ( " onDestroy " ) ; super . onDestroy ( ) ; }
ChengCorp/robolectric | @ Override public void onCreate ( Bundle savedInstanceState ) { transcript . add ( " onCreate " ) ; if ( isRecreating ) { assertTrue ( savedInstanceState . containsKey ( " TestActivityKey " ) ) ; assertEquals ( " TestActivityValue " , savedInstanceState . getString ( " TestActivityKey " ) ) ; } super . onCreate ( savedInstanceState ) ; }
ChengCorp/robolectric | @ Override public void onStart ( ) { transcript . add ( " onStart " ) ; super . onStart ( ) ; }
ChengCorp/robolectric | @ Override public void onPostCreate ( Bundle savedInstanceState ) { transcript . add ( " onPostCreate " ) ; super . onPostCreate ( savedInstanceState ) ; }
ChengCorp/robolectric | @ Override public void onStop ( ) { transcript . add ( " onStop " ) ; super . onStop ( ) ; }
ChengCorp/robolectric | @ Override public void onRestart ( ) { transcript . add ( " onRestart " ) ; super . onRestart ( ) ; }
ChengCorp/robolectric | @ Override public void onResume ( ) { transcript . add ( " onResume " ) ; super . onResume ( ) ; }
ChengCorp/robolectric | @ Test public void getAndSetParentActivity_shouldWorkForTestingPurposes ( ) throws Exception { Activity parentActivity = new Activity ( ) { } ; Activity activity = new Activity ( ) { } ; shadowOf ( activity ) . setParent ( parentActivity ) ; assertSame ( parentActivity , activity . getParent ( ) ) ; }
ChengCorp/robolectric | @ Test public void getAndSetRequestedOrientation_shouldRemember ( ) throws Exception { Activity activity = new Activity ( ) { } ; activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; assertEquals ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT , activity . getRequestedOrientation ( ) ) ; }
ChengCorp/robolectric | @ Test public void getAndSetRequestedOrientation_shouldDelegateToParentIfPresent ( ) throws Exception { Activity parentActivity = new Activity ( ) { } ; Activity activity = new Activity ( ) { } ; shadowOf ( activity ) . setParent ( parentActivity ) ; parentActivity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; assertEquals ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT , activity . getRequestedOrientation ( ) ) ; activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_LANDSCAPE ) ; assertEquals ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_LANDSCAPE , parentActivity . getRequestedOrientation ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportIsTaskRoot ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; assertTrue ( activity . isTaskRoot ( ) ) ; shadowOf ( activity ) . setIsTaskRoot ( false ) ; assertFalse ( activity . isTaskRoot ( ) ) ; }
ChengCorp/robolectric | @ Test public void getPendingTransitionEnterAnimationResourceId_should ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; activity . overridePendingTransition ( 15 , 2 ) ; assertThat ( shadowOf ( activity ) . getPendingTransitionEnterAnimationResourceId ( ) ) . isEqualTo ( 15 ) ; }
ChengCorp/robolectric | @ Test public void getPendingTransitionExitAnimationResourceId_should ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; activity . overridePendingTransition ( 15 , 2 ) ; assertThat ( shadowOf ( activity ) . getPendingTransitionExitAnimationResourceId ( ) ) . isEqualTo ( 2 ) ; }
ChengCorp/robolectric | @ Test public void shouldGetAttributeFromThemeSetOnActivity ( ) throws Exception { ShadowThemeTest . TestActivity activity = setupActivity ( ShadowThemeTest . TestActivityWithAnotherTheme . class ) ; TypedArray a = activity . obtainStyledAttributes ( R . styleable . AnotherTheme ) ; assertThat ( a . hasValue ( R . styleable . AnotherTheme_animalStyle ) ) . isTrue ( ) ; }
ChengCorp/robolectric | @ Test public void getActionBar_shouldWorkIfActivityHasAnAppropriateTheme ( ) throws Exception { ActionBarThemedActivity myActivity = Robolectric . buildActivity ( ActionBarThemedActivity . class ) . create ( ) . get ( ) ; ActionBar actionBar = myActivity . getActionBar ( ) ; assertThat ( actionBar ) . isNotNull ( ) ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setTheme ( android . R . style . Theme_Holo_Light ) ; setContentView ( new LinearLayout ( this ) ) ; }
ChengCorp/robolectric | @ Test public void canGetOptionsMenu ( ) throws Exception { Activity activity = buildActivity ( OptionsMenuActivity . class ) . create ( ) . visible ( ) . get ( ) ; Menu optionsMenu = shadowOf ( activity ) . getOptionsMenu ( ) ; assertThat ( optionsMenu ) . isNotNull ( ) ; assertThat ( optionsMenu . getItem ( 0 ) . getTitle ( ) ) . isEqualTo ( " Algebraic ! " ) ; }
ChengCorp/robolectric | @ Test public void canGetOptionsMenuWithActionMenu ( ) throws Exception { ActionMenuActivity activity = buildActivity ( ActionMenuActivity . class ) . create ( ) . visible ( ) . get ( ) ; SearchView searchView = activity . mSearchView ; searchView . setIconifiedByDefault ( false ) ; }
ChengCorp/robolectric | @ Test public void canStartActivityFromFragment ( ) { final Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; activity . startActivityFromFragment ( new Fragment ( ) , intent , 4 ) ; ShadowActivity . IntentForResult intentForResult = shadowOf ( activity ) . getNextStartedActivityForResult ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 4 ) ; }
ChengCorp/robolectric | @ Test public void canStartActivityFromFragment_withBundle ( ) { final Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; Bundle options = new Bundle ( ) ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; activity . startActivityFromFragment ( new Fragment ( ) , intent , 5 , options ) ; ShadowActivity . IntentForResult intentForResult = shadowOf ( activity ) . getNextStartedActivityForResult ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . options ) . isSameAs ( options ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 5 ) ; }
ChengCorp/robolectric | @ Test public void shouldUseAnimationOverride ( ) { Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; Intent intent = new Intent ( activity , OptionsMenuActivity . class ) ; Bundle animationBundle = ActivityOptions . makeCustomAnimation ( activity , R . anim . test_anim_1 , R . anim . test_anim_1 ) . toBundle ( ) ; activity . startActivity ( intent , animationBundle ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivityForResult ( ) . options ) . isSameAs ( animationBundle ) ; }
ChengCorp/robolectric | @ Test public void shouldCallActivityLifecycleCallbacks ( ) { final List < String > transcript = new ArrayList < > ( ) ; final ActivityController < Activity > controller = buildActivity ( Activity . class ) ; RuntimeEnvironment . application . registerActivityLifecycleCallbacks ( new ActivityLifecycleCallbacks ( transcript ) ) ; controller . create ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityCreated " ) ; transcript . clear ( ) ; controller . start ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityStarted " ) ; transcript . clear ( ) ; controller . resume ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityResumed " ) ; transcript . clear ( ) ; controller . saveInstanceState ( new Bundle ( ) ) ; assertThat ( transcript ) . containsExactly ( " onActivitySaveInstanceState " ) ; transcript . clear ( ) ; controller . pause ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityPaused " ) ; transcript . clear ( ) ; controller . stop ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityStopped " ) ; transcript . clear ( ) ; controller . destroy ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityDestroyed " ) ; }
ChengCorp/robolectric | @ Test public void getParentActivityIntent ( ) { Activity activity = setupActivity ( ChildActivity . class ) ; assertThat ( activity . getParentActivityIntent ( ) . getComponent ( ) . getClassName ( ) ) . isEqualTo ( ParentActivity . class . getName ( ) ) ; }
ChengCorp/robolectric | @ Test public void getCallingActivity_defaultsToNull ( ) { Activity activity = Robolectric . setupActivity ( Activity . class ) ; assertNull ( activity . getCallingActivity ( ) ) ; }
ChengCorp/robolectric | @ Test public void getCallingActivity_returnsSetValue ( ) { Activity activity = Robolectric . setupActivity ( Activity . class ) ; ComponentName componentName = new ComponentName ( " com . example . package " , " SomeActivity " ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; shadowActivity . setCallingActivity ( componentName ) ; assertEquals ( componentName , activity . getCallingActivity ( ) ) ; }
ChengCorp/robolectric | public AndroidManifest newConfigWith ( String contents ) throws IOException { return newConfigWith ( " org . robolectric " , contents ) ; }
ChengCorp/robolectric | private AndroidManifest newConfigWith ( String packageName , String contents ) throws IOException { String fileContents = " < ? xml ▁ version = \" 1.0 \" ▁ encoding = \" utf - 8 \" ? > \n " + " < manifest ▁ xmlns : android = \" http : // schemas . android . com / apk / res / android \" \n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ package = \" " + packageName + " \" > \n " + " ▁ ▁ ▁ ▁ " + contents + " \n " + " < / manifest > \n " ; File f = temporaryFolder . newFile ( " whatever . xml " ) ; Files . write ( fileContents , f , Charsets . UTF_8 ) ; return new AndroidManifest ( Fs . newFile ( f ) , null , null ) ; }
ChengCorp/robolectric | @ Override protected Dialog onCreateDialog ( int id ) { return new Dialog ( this ) ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow ( ) . requestFeature ( Window . FEATURE_ACTION_BAR ) ; setContentView ( new FrameLayout ( this ) ) ; }
ChengCorp/robolectric | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( " Algebraic ! " ) ; return true ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow ( ) . requestFeature ( Window . FEATURE_ACTION_BAR ) ; setContentView ( new FrameLayout ( this ) ) ; }
ChengCorp/robolectric | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . action_menu , menu ) ; MenuItem searchMenuItem = menu . findItem ( R . id . action_search ) ; mSearchView = ( SearchView ) searchMenuItem . getActionView ( ) ; return true ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( new FrameLayout ( this ) ) ; }
ChengCorp/robolectric | @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; }
ChengCorp/robolectric | @ Override protected Dialog onCreateDialog ( int id ) { createdDialog = true ; return dialog ; }
ChengCorp/robolectric | @ Override protected void onPrepareDialog ( int id , Dialog dialog ) { preparedDialog = true ; }
ChengCorp/robolectric | @ Override protected void onPrepareDialog ( int id , Dialog dialog , Bundle bundle ) { preparedDialogWithBundle = true ; }
ChengCorp/robolectric | @ Override protected Dialog onCreateDialog ( int id ) { onCreateDialogWasCalled = true ; return new Dialog ( this ) ; }
ChengCorp/robolectric | @ Override public void onContentChanged ( ) { transcript . add ( " onContentChanged ▁ was ▁ called ; ▁ title ▁ is ▁ \" " + shadowOf ( ( View ) findViewById ( R . id . title ) ) . innerText ( ) + " \" " ) ; }
ChengCorp/robolectric | private void setTranscript ( List < String > transcript ) { this . transcript = transcript ; }
ChengCorp/robolectric | @ Override public void onBackPressed ( ) { onBackPressedCalled = true ; super . onBackPressed ( ) ; }
ChengCorp/robolectric | public ActivityLifecycleCallbacks ( List < String > transcript ) { this . transcript = transcript ; }
ChengCorp/robolectric | @ Override public void onActivityCreated ( Activity activity , Bundle bundle ) { transcript . add ( " onActivityCreated " ) ; }
ChengCorp/robolectric | @ Override public void onActivityStarted ( Activity activity ) { transcript . add ( " onActivityStarted " ) ; }
ChengCorp/robolectric | @ Override public void onActivityResumed ( Activity activity ) { transcript . add ( " onActivityResumed " ) ; }
ChengCorp/robolectric | @ Override public void onActivityPaused ( Activity activity ) { transcript . add ( " onActivityPaused " ) ; }
ChengCorp/robolectric | @ Override public void onActivityStopped ( Activity activity ) { transcript . add ( " onActivityStopped " ) ; }
ChengCorp/robolectric | @ Override public void onActivitySaveInstanceState ( Activity activity , Bundle bundle ) { transcript . add ( " onActivitySaveInstanceState " ) ; }
ChengCorp/robolectric | @ Override public void onActivityDestroyed ( Activity activity ) { transcript . add ( " onActivityDestroyed " ) ; }
MX-Futhark/hook-any-text | public void addAttempt ( DebuggableDecodingAttempt attempt ) { attempts . add ( attempt ) ; }
MX-Futhark/hook-any-text | @ Override public DebuggableLineList getDecorableList ( ) { for ( DebuggableDecodingAttempt attempt : attempts ) { if ( attempt . isValidEncoding ( ) ) { return attempt . getAttempt ( ) ; } } return null ; }
MX-Futhark/hook-any-text | @ Override public String toString ( long debuggingFlags , int converterStrictness ) { StringBuilder sb = new StringBuilder ( ) ; if ( ( debuggingFlags & DebuggingFlags . LINE_LIST_ENCODING_REJECTED ) > 0 ) { sb . append ( " Lines ▁ with ▁ detected ▁ encoding : ▁ \n " ) ; } for ( DebuggableDecodingAttempt attempt : attempts ) { if ( attempt . isValidEncoding ( ) ) { sb . append ( attempt . toString ( debuggingFlags , converterStrictness ) ) ; break ; } } if ( ( debuggingFlags & DebuggingFlags . LINE_LIST_ENCODING_REJECTED ) > 0 ) { sb . append ( " \n Failed ▁ attempts ▁ at ▁ decoding : ▁ \n " ) ; for ( DebuggableDecodingAttempt attempt : attempts ) { if ( ! attempt . isValidEncoding ( ) ) { sb . append ( attempt . toString ( debuggingFlags , converterStrictness ) ) ; sb . append ( " \n " ) ; } } } return sb . toString ( ) . trim ( ) ; }
darciopacifico/omr | public MDBVO ( ) { }
darciopacifico/omr | public String getDesc ( ) { return Desc ; }
darciopacifico/omr | public long getDtExec ( ) { return dtExec ; }
darciopacifico/omr | public long getDtSolic ( ) { return dtSolic ; }
darciopacifico/omr | public String getId ( ) { return Id ; }
darciopacifico/omr | public String getMensagem ( ) { return mensagem ; }
darciopacifico/omr | public String getStatus ( ) { return status ; }
darciopacifico/omr | public String getTipo ( ) { return tipo ; }
darciopacifico/omr | public String getUsuarioId ( ) { return usuarioId ; }
darciopacifico/omr | public void setDesc ( String desc ) { Desc = desc ; }
darciopacifico/omr | public void setDtExec ( long dtExec ) { this . dtExec = dtExec ; }
darciopacifico/omr | public void setDtSolic ( long dtSolic ) { this . dtSolic = dtSolic ; }
darciopacifico/omr | public void setId ( String id ) { Id = id ; }
darciopacifico/omr | public void setMensagem ( String mensagem ) { this . mensagem = mensagem ; }
darciopacifico/omr | public void setStatus ( String status ) { this . status = status ; }
darciopacifico/omr | public void setTipo ( String tipo ) { this . tipo = tipo ; }
darciopacifico/omr | public void setUsuarioId ( String usuarioId ) { this . usuarioId = usuarioId ; }
bubbledoodle/Algorithms_Training | public int reverse ( int x ) { int res = 0 ; while ( x != 0 ) { int tail = x % 10 ; int temp = res * 10 + tail ; if ( ( temp - tail ) / 10 != res ) return 0 ; res = temp ; x = x / 10 ; } return res ; }
prabushi/devstudio-tooling-esb | public IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl ( IPropertiesEditionComponent editionComponent ) { super ( editionComponent ) ; }
prabushi/devstudio-tooling-esb | public Composite createFigure ( final Composite parent ) { view = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 3 ; view . setLayout ( layout ) ; createControls ( view ) ; return view ; }
prabushi/devstudio-tooling-esb | public void createControls ( Composite view ) { CompositionSequence iterateMediatorTargetOutputConnectorStep = new BindingCompositionSequence ( propertiesEditionComponent ) ; iterateMediatorTargetOutputConnectorStep . addStep ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . class ) . addStep ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) ; composer = new PartComposer ( iterateMediatorTargetOutputConnectorStep ) { @ Override public Composite addToPart ( Composite parent , Object key ) { if ( key == EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . class ) { return createPropertiesGroup ( parent ) ; } if ( key == EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) { return createCommentMediatorsAdvancedTableComposition ( parent ) ; } return parent ; } } ; composer . compose ( view ) ; }
prabushi/devstudio-tooling-esb | protected Composite createPropertiesGroup ( Composite parent ) { Group propertiesGroup = new Group ( parent , SWT . NONE ) ; propertiesGroup . setText ( EsbMessages . IterateMediatorTargetOutputConnectorPropertiesEditionPart_PropertiesGroupLabel ) ; GridData propertiesGroupData = new GridData ( GridData . FILL_HORIZONTAL ) ; propertiesGroupData . horizontalSpan = 3 ; propertiesGroup . setLayoutData ( propertiesGroupData ) ; GridLayout propertiesGroupLayout = new GridLayout ( ) ; propertiesGroupLayout . numColumns = 3 ; propertiesGroup . setLayout ( propertiesGroupLayout ) ; return propertiesGroup ; }
prabushi/devstudio-tooling-esb | protected Composite createCommentMediatorsAdvancedTableComposition ( Composite parent ) { this . commentMediators = new ReferencesTable ( getDescription ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , EsbMessages . IterateMediatorTargetOutputConnectorPropertiesEditionPart_CommentMediatorsLabel ) , new ReferencesTableListener ( ) { public void handleAdd ( ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . ADD , null , null ) ) ; commentMediators . refresh ( ) ; } public void handleEdit ( EObject element ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . EDIT , null , element ) ) ; commentMediators . refresh ( ) ; } public void handleMove ( EObject element , int oldIndex , int newIndex ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . MOVE , element , newIndex ) ) ; commentMediators . refresh ( ) ; } public void handleRemove ( EObject element ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . REMOVE , null , element ) ) ; commentMediators . refresh ( ) ; } public void navigateTo ( EObject element ) { } } ) ; for ( ViewerFilter filter : this . commentMediatorsFilters ) { this . commentMediators . addFilter ( filter ) ; } this . commentMediators . setHelpText ( propertiesEditionComponent . getHelpContent ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , EsbViewsRepository . SWT_KIND ) ) ; this . commentMediators . createControls ( parent ) ; this . commentMediators . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( e . item != null && e . item . getData ( ) instanceof EObject ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . CHANGE , PropertiesEditionEvent . SELECTION_CHANGED , null , e . item . getData ( ) ) ) ; } } } ) ; GridData commentMediatorsData = new GridData ( GridData . FILL_HORIZONTAL ) ; commentMediatorsData . horizontalSpan = 3 ; this . commentMediators . setLayoutData ( commentMediatorsData ) ; this . commentMediators . setLowerBound ( 0 ) ; this . commentMediators . setUpperBound ( - 1 ) ; commentMediators . setID ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) ; commentMediators . setEEFType ( " eef : : AdvancedTableComposition " ) ; return parent ; }
prabushi/devstudio-tooling-esb | public void firePropertiesChanged ( IPropertiesEditionEvent event ) { }
prabushi/devstudio-tooling-esb | public void initCommentMediators ( ReferencesTableSettings settings ) { if ( current . eResource ( ) != null && current . eResource ( ) . getResourceSet ( ) != null ) this . resourceSet = current . eResource ( ) . getResourceSet ( ) ; ReferencesTableContentProvider contentProvider = new ReferencesTableContentProvider ( ) ; commentMediators . setContentProvider ( contentProvider ) ; commentMediators . setInput ( settings ) ; boolean eefElementEditorReadOnlyState = isReadOnly ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) ; if ( eefElementEditorReadOnlyState && commentMediators . isEnabled ( ) ) { commentMediators . setEnabled ( false ) ; commentMediators . setToolTipText ( EsbMessages . IterateMediatorTargetOutputConnector_ReadOnly ) ; } else if ( ! eefElementEditorReadOnlyState && ! commentMediators . isEnabled ( ) ) { commentMediators . setEnabled ( true ) ; } }
prabushi/devstudio-tooling-esb | public void updateCommentMediators ( ) { commentMediators . refresh ( ) ; }
prabushi/devstudio-tooling-esb | public void addFilterToCommentMediators ( ViewerFilter filter ) { commentMediatorsFilters . add ( filter ) ; if ( this . commentMediators != null ) { this . commentMediators . addFilter ( filter ) ; } }
prabushi/devstudio-tooling-esb | public void addBusinessFilterToCommentMediators ( ViewerFilter filter ) { commentMediatorsBusinessFilters . add ( filter ) ; }
prabushi/devstudio-tooling-esb | public boolean isContainedInCommentMediatorsTable ( EObject element ) { return ( ( ReferencesTableSettings ) commentMediators . getInput ( ) ) . contains ( element ) ; }
prabushi/devstudio-tooling-esb | public String getTitle ( ) { return EsbMessages . IterateMediatorTargetOutputConnector_Part_Title ; }
ThiagoGarciaAlves/elasticsearch | DummyQuery ( int id ) { this . id = id ; }
ThiagoGarciaAlves/elasticsearch | @ Override public boolean equals ( Object obj ) { return sameClassAs ( obj ) && id == ( ( DummyQuery ) obj ) . id ; }
ThiagoGarciaAlves/elasticsearch | @ Override public int hashCode ( ) { return 31 * classHash ( ) + id ; }
ThiagoGarciaAlves/elasticsearch | @ Override public String toString ( String field ) { return " dummy " ; }
ThiagoGarciaAlves/elasticsearch | @ Override public Weight createWeight ( IndexSearcher searcher , boolean needsScores , float boost ) throws IOException { return new ConstantScoreWeight ( this , boost ) { @ Override public Scorer scorer ( LeafReaderContext context ) throws IOException { return new ConstantScoreScorer ( this , score ( ) , DocIdSetIterator . all ( context . reader ( ) . maxDoc ( ) ) ) ; } @ Override public boolean isCacheable ( LeafReaderContext ctx ) { return true ; } } ; }
ThiagoGarciaAlves/elasticsearch | public void testBasics ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriter w = new IndexWriter ( dir , newIndexWriterConfig ( ) ) ; w . addDocument ( new Document ( ) ) ; DirectoryReader r = DirectoryReader . open ( w ) ; w . close ( ) ; ShardId shard = new ShardId ( " index " , " _ na _ " , 0 ) ; r = ElasticsearchDirectoryReader . wrap ( r , shard ) ; IndexSearcher s = new IndexSearcher ( r ) ; s . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s . setQueryCache ( cache ) ; QueryCacheStats stats = cache . getStats ( shard ) ; assertEquals ( 0L , stats . getCacheSize ( ) ) ; assertEquals ( 0L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 0L , stats . getMissCount ( ) ) ; assertEquals ( 1 , s . count ( new DummyQuery ( 0 ) ) ) ; stats = cache . getStats ( shard ) ; assertEquals ( 1L , stats . getCacheSize ( ) ) ; assertEquals ( 1L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 1L , stats . getMissCount ( ) ) ; for ( int i = 1 ; i < 20 ; ++ i ) { assertEquals ( 1 , s . count ( new DummyQuery ( i ) ) ) ; } stats = cache . getStats ( shard ) ; assertEquals ( 10L , stats . getCacheSize ( ) ) ; assertEquals ( 20L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 20L , stats . getMissCount ( ) ) ; s . count ( new DummyQuery ( 10 ) ) ; stats = cache . getStats ( shard ) ; assertEquals ( 10L , stats . getCacheSize ( ) ) ; assertEquals ( 20L , stats . getCacheCount ( ) ) ; assertEquals ( 1L , stats . getHitCount ( ) ) ; assertEquals ( 20L , stats . getMissCount ( ) ) ; IOUtils . close ( r , dir ) ; stats = cache . getStats ( shard ) ; assertEquals ( 0L , stats . getCacheSize ( ) ) ; assertEquals ( 20L , stats . getCacheCount ( ) ) ; assertEquals ( 1L , stats . getHitCount ( ) ) ; assertEquals ( 20L , stats . getMissCount ( ) ) ; cache . onClose ( shard ) ; stats = cache . getStats ( shard ) ; assertEquals ( 0L , stats . getCacheSize ( ) ) ; assertEquals ( 0L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 0L , stats . getMissCount ( ) ) ; cache . close ( ) ; }
ThiagoGarciaAlves/elasticsearch | public void testTwoShards ( ) throws IOException { Directory dir1 = newDirectory ( ) ; IndexWriter w1 = new IndexWriter ( dir1 , newIndexWriterConfig ( ) ) ; w1 . addDocument ( new Document ( ) ) ; DirectoryReader r1 = DirectoryReader . open ( w1 ) ; w1 . close ( ) ; ShardId shard1 = new ShardId ( " index " , " _ na _ " , 0 ) ; r1 = ElasticsearchDirectoryReader . wrap ( r1 , shard1 ) ; IndexSearcher s1 = new IndexSearcher ( r1 ) ; s1 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Directory dir2 = newDirectory ( ) ; IndexWriter w2 = new IndexWriter ( dir2 , newIndexWriterConfig ( ) ) ; w2 . addDocument ( new Document ( ) ) ; DirectoryReader r2 = DirectoryReader . open ( w2 ) ; w2 . close ( ) ; ShardId shard2 = new ShardId ( " index " , " _ na _ " , 1 ) ; r2 = ElasticsearchDirectoryReader . wrap ( r2 , shard2 ) ; IndexSearcher s2 = new IndexSearcher ( r2 ) ; s2 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s1 . setQueryCache ( cache ) ; s2 . setQueryCache ( cache ) ; assertEquals ( 1 , s1 . count ( new DummyQuery ( 0 ) ) ) ; QueryCacheStats stats1 = cache . getStats ( shard1 ) ; assertEquals ( 1L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; QueryCacheStats stats2 = cache . getStats ( shard2 ) ; assertEquals ( 0L , stats2 . getCacheSize ( ) ) ; assertEquals ( 0L , stats2 . getCacheCount ( ) ) ; assertEquals ( 0L , stats2 . getHitCount ( ) ) ; assertEquals ( 0L , stats2 . getMissCount ( ) ) ; assertEquals ( 1 , s2 . count ( new DummyQuery ( 0 ) ) ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 1L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 1L , stats2 . getCacheSize ( ) ) ; assertEquals ( 1L , stats2 . getCacheCount ( ) ) ; assertEquals ( 0L , stats2 . getHitCount ( ) ) ; assertEquals ( 1L , stats2 . getMissCount ( ) ) ; for ( int i = 0 ; i < 20 ; ++ i ) { assertEquals ( 1 , s2 . count ( new DummyQuery ( i ) ) ) ; } stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 10L , stats2 . getCacheSize ( ) ) ; assertEquals ( 20L , stats2 . getCacheCount ( ) ) ; assertEquals ( 1L , stats2 . getHitCount ( ) ) ; assertEquals ( 20L , stats2 . getMissCount ( ) ) ; IOUtils . close ( r1 , dir1 ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 10L , stats2 . getCacheSize ( ) ) ; assertEquals ( 20L , stats2 . getCacheCount ( ) ) ; assertEquals ( 1L , stats2 . getHitCount ( ) ) ; assertEquals ( 20L , stats2 . getMissCount ( ) ) ; cache . onClose ( shard1 ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 0L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 0L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 10L , stats2 . getCacheSize ( ) ) ; assertEquals ( 20L , stats2 . getCacheCount ( ) ) ; assertEquals ( 1L , stats2 . getHitCount ( ) ) ; assertEquals ( 20L , stats2 . getMissCount ( ) ) ; IOUtils . close ( r2 , dir2 ) ; cache . onClose ( shard2 ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 0L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 0L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 0L , stats2 . getCacheSize ( ) ) ; assertEquals ( 0L , stats2 . getCacheCount ( ) ) ; assertEquals ( 0L , stats2 . getHitCount ( ) ) ; assertEquals ( 0L , stats2 . getMissCount ( ) ) ; cache . close ( ) ; }
ThiagoGarciaAlves/elasticsearch | public void testStatsOnEviction ( ) throws IOException { Directory dir1 = newDirectory ( ) ; IndexWriter w1 = new IndexWriter ( dir1 , newIndexWriterConfig ( ) ) ; w1 . addDocument ( new Document ( ) ) ; DirectoryReader r1 = DirectoryReader . open ( w1 ) ; w1 . close ( ) ; ShardId shard1 = new ShardId ( " index " , " _ na _ " , 0 ) ; r1 = ElasticsearchDirectoryReader . wrap ( r1 , shard1 ) ; IndexSearcher s1 = new IndexSearcher ( r1 ) ; s1 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Directory dir2 = newDirectory ( ) ; IndexWriter w2 = new IndexWriter ( dir2 , newIndexWriterConfig ( ) ) ; w2 . addDocument ( new Document ( ) ) ; DirectoryReader r2 = DirectoryReader . open ( w2 ) ; w2 . close ( ) ; ShardId shard2 = new ShardId ( " index " , " _ na _ " , 1 ) ; r2 = ElasticsearchDirectoryReader . wrap ( r2 , shard2 ) ; IndexSearcher s2 = new IndexSearcher ( r2 ) ; s2 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s1 . setQueryCache ( cache ) ; s2 . setQueryCache ( cache ) ; assertEquals ( 1 , s1 . count ( new DummyQuery ( 0 ) ) ) ; for ( int i = 1 ; i <= 20 ; ++ i ) { assertEquals ( 1 , s2 . count ( new DummyQuery ( i ) ) ) ; } QueryCacheStats stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; IOUtils . close ( r1 , dir1 ) ; cache . onClose ( shard1 ) ; IOUtils . close ( r2 , dir2 ) ; cache . onClose ( shard2 ) ; cache . close ( ) ; }
ThiagoGarciaAlves/elasticsearch | DummyWeight ( Weight weight ) { super ( weight . getQuery ( ) ) ; this . weight = weight ; }
ThiagoGarciaAlves/elasticsearch | @ Override public void extractTerms ( Set < Term > terms ) { weight . extractTerms ( terms ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public Explanation explain ( LeafReaderContext context , int doc ) throws IOException { return weight . explain ( context , doc ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public Scorer scorer ( LeafReaderContext context ) throws IOException { scorerCalled = true ; return weight . scorer ( context ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public ScorerSupplier scorerSupplier ( LeafReaderContext context ) throws IOException { scorerSupplierCalled = true ; return weight . scorerSupplier ( context ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public boolean isCacheable ( LeafReaderContext ctx ) { return true ; }
ThiagoGarciaAlves/elasticsearch | public void testDelegatesScorerSupplier ( ) throws Exception { Directory dir = newDirectory ( ) ; IndexWriter w = new IndexWriter ( dir , newIndexWriterConfig ( ) ) ; w . addDocument ( new Document ( ) ) ; DirectoryReader r = DirectoryReader . open ( w ) ; w . close ( ) ; ShardId shard = new ShardId ( " index " , " _ na _ " , 0 ) ; r = ElasticsearchDirectoryReader . wrap ( r , shard ) ; IndexSearcher s = new IndexSearcher ( r ) ; s . setQueryCachingPolicy ( new QueryCachingPolicy ( ) { @ Override public boolean shouldCache ( Query query ) throws IOException { return false ; } @ Override public void onUse ( Query query ) { } } ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s . setQueryCache ( cache ) ; Query query = new MatchAllDocsQuery ( ) ; final DummyWeight weight = new DummyWeight ( s . createNormalizedWeight ( query , false ) ) ; final Weight cached = cache . doCache ( weight , s . getQueryCachingPolicy ( ) ) ; assertNotSame ( weight , cached ) ; assertFalse ( weight . scorerCalled ) ; assertFalse ( weight . scorerSupplierCalled ) ; cached . scorerSupplier ( s . getIndexReader ( ) . leaves ( ) . get ( 0 ) ) ; assertFalse ( weight . scorerCalled ) ; assertTrue ( weight . scorerSupplierCalled ) ; IOUtils . close ( r , dir ) ; cache . onClose ( shard ) ; cache . close ( ) ; }
Ossit/SenseBack | private SensorDbHelper ( Context context ) { super ( context , SensorDbContract . DATABASE_NAME , null , DATABASE_VERSION ) ; }
Ossit/SenseBack | @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_DATA_TABLE ) ; db . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_NAME_TABLE ) ; initializeSensorTable ( db ) ; }
Ossit/SenseBack | public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_DATA_TABLE ) ; db . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_NAME_TABLE ) ; onCreate ( db ) ; }
Ossit/SenseBack | public void insertSensorData ( long timeStampMillis , int sensorId , int value ) { ContentValues values = new ContentValues ( ) ; values . put ( SensorDbContract . SensorDataTable . COLUMN_NAME_TIME , timeStampMillis ) ; values . put ( SensorDbContract . SensorDataTable . COLUMN_NAME_SENSOR_ID , sensorId ) ; values . put ( SensorDbContract . SensorDataTable . COLUMN_NAME_VALUE , value ) ; this . getWritableDatabase ( ) . insert ( SensorDbContract . SensorDataTable . TABLE_NAME , null , values ) ; }
Ossit/SenseBack | public void insertSensor ( int sensorId , String sensorName ) { ContentValues values = new ContentValues ( ) ; values . put ( SensorDbContract . SensorNameTable . COLUMN_NAME_SENSOR_ID , sensorId ) ; values . put ( SensorDbContract . SensorNameTable . COLUMN_NAME_SENSOR_NAME , sensorName ) ; this . getWritableDatabase ( ) . insert ( SensorDbContract . SensorNameTable . TABLE_NAME , null , values ) ; }
Ossit/SenseBack | public void dropSensorDataTable ( ) { this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_DATA_TABLE ) ; this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_DATA_TABLE ) ; }
Ossit/SenseBack | public void dropSensorNameTable ( ) { this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_NAME_TABLE ) ; this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_NAME_TABLE ) ; }
Ossit/SenseBack | private void initializeSensorTable ( SQLiteDatabase db ) { insertSensor ( 34 , " Sensor34" ) ; insertSensor ( 56 , " Sensor56" ) ; }
TexasDigitalLibrary/duracloud | @ Before public void setUp ( ) throws Exception { targetProvider = new MockStorageProvider ( ) ; directProvider = new MockStorageProvider ( ) ; dispatchProvider = new StatelessStorageProviderImpl ( ) ; broker = new BrokeredStorageProvider ( dispatchProvider , targetProvider , StorageProviderType . UNKNOWN , "0" ) ; content = new ByteArrayInputStream ( " " . getBytes ( ) ) ; }
TexasDigitalLibrary/duracloud | @ After public void tearDown ( ) throws Exception { broker = null ; dispatchProvider = null ; targetProvider = null ; directProvider = null ; content . close ( ) ; content = null ; }
TexasDigitalLibrary/duracloud | @ Test public void testAddContent ( ) throws StorageException { directProvider . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; broker . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; verifySpaceId ( ) ; verifyContentId ( ) ; verifyContentMimeType ( ) ; verifyContentSize ( ) ; verifyContent ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void testCreateSpace ( ) throws StorageException { directProvider . createSpace ( spaceId ) ; broker . createSpace ( spaceId ) ; verifySpaceId ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void testDeleteContent ( ) throws StorageException { directProvider . deleteContent ( spaceId , contentId ) ; broker . deleteContent ( spaceId , contentId ) ; verifySpaceId ( ) ; verifyContentId ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void deleteSpace ( ) throws StorageException { directProvider . deleteSpace ( spaceId ) ; broker . deleteSpace ( spaceId ) ; verifySpaceId ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getContent ( ) throws StorageException { directProvider . setContent ( content ) ; targetProvider . setContent ( content ) ; InputStream content0 = directProvider . getContent ( spaceId , contentId ) . getContentStream ( ) ; InputStream content1 = broker . getContent ( spaceId , contentId ) . getContentStream ( ) ; verify ( content0 , content1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getContentProperties ( ) throws StorageException { directProvider . setContentProperties ( spaceId , contentId , contentProperties ) ; broker . setContentProperties ( spaceId , contentId , contentProperties ) ; Map < String , String > meta0 = directProvider . getContentProperties ( spaceId , contentId ) ; Map < String , String > meta1 = broker . getContentProperties ( spaceId , contentId ) ; verify ( meta0 , meta1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaceContents ( ) throws StorageException { directProvider . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; broker . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; Iterator < String > spaceContents0 = directProvider . getSpaceContents ( spaceId , null ) ; Iterator < String > spaceContents1 = broker . getSpaceContents ( spaceId , null ) ; verifyIteratorContents ( spaceContents0 , spaceContents1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaceContentsChunked ( ) throws StorageException { directProvider . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; broker . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; List < String > spaceContents0 = directProvider . getSpaceContentsChunked ( spaceId , null , 0 , null ) ; List < String > spaceContents1 = broker . getSpaceContentsChunked ( spaceId , null , 0 , null ) ; verifyIteratorContents ( spaceContents0 . iterator ( ) , spaceContents1 . iterator ( ) ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaceProperties ( ) throws StorageException { Map < String , String > meta0 = directProvider . getSpaceProperties ( spaceId ) ; Map < String , String > meta1 = broker . getSpaceProperties ( spaceId ) ; verify ( meta0 , meta1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaces ( ) throws StorageException { directProvider . createSpace ( spaceId ) ; broker . createSpace ( spaceId ) ; Iterator < String > spaces0 = directProvider . getSpaces ( ) ; Iterator < String > spaces1 = broker . getSpaces ( ) ; verifyIteratorContents ( spaces0 , spaces1 ) ; }
TexasDigitalLibrary/duracloud | private void verifySpaceId ( ) { Assert . assertNotNull ( directProvider . getSpaceId ( ) ) ; Assert . assertEquals ( directProvider . getSpaceId ( ) , targetProvider . getSpaceId ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContentId ( ) { Assert . assertNotNull ( directProvider . getContentId ( ) ) ; Assert . assertEquals ( directProvider . getContentId ( ) , targetProvider . getContentId ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContentMimeType ( ) { Assert . assertNotNull ( directProvider . getContentMimeType ( ) ) ; Assert . assertEquals ( directProvider . getContentMimeType ( ) , targetProvider . getContentMimeType ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContentSize ( ) { Assert . assertNotNull ( directProvider . getContentSize ( ) ) ; Assert . assertEquals ( directProvider . getContentSize ( ) , targetProvider . getContentSize ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContent ( ) { Assert . assertNotNull ( directProvider . getContent ( ) ) ; Assert . assertEquals ( directProvider . getContent ( ) , targetProvider . getContent ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifySpaceProperties ( ) { Assert . assertNotNull ( directProvider . getSpaceProperties ( ) ) ; Assert . assertEquals ( directProvider . getSpaceProperties ( ) , targetProvider . getSpaceProperties ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyIteratorContents ( Iterator < String > iter0 , Iterator < String > iter1 ) { Assert . assertNotNull ( iter0 ) ; Assert . assertNotNull ( iter1 ) ; while ( iter0 . hasNext ( ) ) { Assert . assertEquals ( iter0 . next ( ) , iter1 . next ( ) ) ; } Assert . assertFalse ( iter1 . hasNext ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verify ( Object obj0 , Object obj1 ) { Assert . assertNotNull ( obj0 ) ; Assert . assertEquals ( obj0 , obj1 ) ; }
Alluxio/alluxio | protected KodoUnderFileSystem ( AlluxioURI uri , KodoClient kodoclient , UnderFileSystemConfiguration conf ) { super ( uri , conf ) ; mKodoClinet = kodoclient ; }
Alluxio/alluxio | @ Override public String getUnderFSType ( ) { return " kodo " ; }
Alluxio/alluxio | @ Override public void setOwner ( String path , String user , String group ) { }
Alluxio/alluxio | @ Override public void setMode ( String path , short mode ) throws IOException { }
Alluxio/alluxio | @ Override protected boolean copyObject ( String src , String dst ) { try { mKodoClinet . copyObject ( src , dst ) ; return true ; } catch ( QiniuException e ) { LOG . error ( " copy ▁ Object ▁ failed ▁ { } ▁ to ▁ { } ▁ , ▁ Msg : { } " , src , dst , e ) ; } return false ; }
Alluxio/alluxio | @ Override public boolean createEmptyObject ( String key ) { try { mKodoClinet . createEmptyObject ( key ) ; return true ; } catch ( QiniuException e ) { LOG . error ( " create ▁ empty ▁ object ▁ failed ▁ key : { } ▁ , ▁ Msg : { } " , key , e ) ; } return false ; }
Alluxio/alluxio | @ Override protected OutputStream createObject ( String key ) throws IOException { return new KodoOutputStream ( key , mKodoClinet , mUfsConf . getList ( PropertyKey . TMP_DIRS ) ) ; }
Alluxio/alluxio | @ Override protected boolean deleteObject ( String key ) { try { mKodoClinet . deleteObject ( key ) ; return true ; } catch ( QiniuException e ) { LOG . error ( " delete ▁ object ▁ failed ▁ key : { } , ▁ Msg : { } " , key , e ) ; } return false ; }
Alluxio/alluxio | @ Override protected String getFolderSuffix ( ) { return FOLDER_SUFFIX ; }
Alluxio/alluxio | @ Nullable @ Override protected ObjectListingChunk getObjectListingChunk ( String key , boolean recursive ) throws IOException { String delimiter = recursive ? " " : PATH_SEPARATOR ; key = PathUtils . normalizePath ( key , PATH_SEPARATOR ) ; key = key . equals ( PATH_SEPARATOR ) ? " " : key ; FileListing result = getObjectListingChunk ( key , getListingChunkLength ( mUfsConf ) , delimiter ) ; if ( result != null ) { return new KodoObjectListingChunk ( result , getListingChunkLength ( mUfsConf ) , delimiter , key ) ; } return null ; }
Alluxio/alluxio | private FileListing getObjectListingChunk ( String prefix , int limit , String delimiter ) { try { return mKodoClinet . listFiles ( prefix , null , limit , delimiter ) ; } catch ( QiniuException e ) { LOG . error ( " list ▁ objects ▁ failed : " , e ) ; return null ; } }
Alluxio/alluxio | @ Nullable @ Override protected ObjectStatus getObjectStatus ( String key ) { try { FileInfo fileInfo = mKodoClinet . getFileInfo ( key ) ; if ( fileInfo == null ) { return null ; } return new ObjectStatus ( key , fileInfo . hash , fileInfo . fsize , fileInfo . putTime / 10000 ) ; } catch ( QiniuException e ) { return null ; } }
Alluxio/alluxio | @ Override protected ObjectPermissions getPermissions ( ) { return new ObjectPermissions ( " " , " " , Constants . DEFAULT_FILE_SYSTEM_MODE ) ; }
Alluxio/alluxio | @ Override protected InputStream openObject ( String key , OpenOptions options , RetryPolicy retryPolicy ) { try { return new KodoInputStream ( key , mKodoClinet , options . getOffset ( ) , retryPolicy , mUfsConf . getBytes ( PropertyKey . UNDERFS_OBJECT_STORE_MULTI_RANGE_CHUNK_SIZE ) ) ; } catch ( QiniuException e ) { LOG . error ( " Failed ▁ to ▁ open ▁ Object ▁ { } , ▁ Msg : ▁ { } " , key , e ) ; } return null ; }
Alluxio/alluxio | @ Override protected String getRootKey ( ) { return Constants . HEADER_KODO + mKodoClinet . getBucketName ( ) ; }
Alluxio/alluxio | KodoObjectListingChunk ( FileListing result , int limit , String delimiter , String prefix ) throws IOException { mLimit = limit ; mDelimiter = delimiter ; mResult = result ; mPrefix = prefix ; }
Alluxio/alluxio | @ Override public ObjectStatus [ ] getObjectStatuses ( ) { FileInfo [ ] fileInfos = mResult . items ; ObjectStatus [ ] ret = new ObjectStatus [ fileInfos . length ] ; int i = 0 ; for ( FileInfo fileInfo : fileInfos ) { if ( fileInfo . key != null ) { ret [ i ++ ] = new ObjectStatus ( fileInfo . key , fileInfo . hash , fileInfo . fsize , fileInfo . putTime / 10000 ) ; } } return ret ; }
Alluxio/alluxio | @ Override public String [ ] getCommonPrefixes ( ) { if ( mResult . commonPrefixes == null ) { return new String [ ] { } ; } return mResult . commonPrefixes ; }
Alluxio/alluxio | @ Nullable @ Override public ObjectListingChunk getNextChunk ( ) throws IOException { if ( ! mResult . isEOF ( ) ) { FileListing nextResult = mKodoClinet . listFiles ( mPrefix , mResult . marker , mLimit , mDelimiter ) ; return new KodoObjectListingChunk ( nextResult , mLimit , mDelimiter , mPrefix ) ; } return null ; }
DarwinSPL/DarwinSPL | public HymappingKeyword ( String value , eu . hyvar . feature . mapping . resource . hymapping . grammar . HymappingCardinality cardinality ) { super ( cardinality , null ) ; this . value = value ; }
DarwinSPL/DarwinSPL | public String getValue ( ) { return value ; }
DarwinSPL/DarwinSPL | public String toString ( ) { return " \" " + value + " \" " ; }
459below/jitsi | public StatusSelectorMenu ( ) { super ( ) ; }
459below/jitsi | public StatusSelectorMenu ( String text , Icon defaultIcon , ProtocolProviderService protocolProvider ) { super ( text , defaultIcon ) ; this . protocolProvider = protocolProvider ; this . presence = protocolProvider . getOperationSet ( OperationSetPresence . class ) ; this . onlineStatus = AccountStatusUtils . getOnlineStatus ( protocolProvider ) ; this . offlineStatus = AccountStatusUtils . getOfflineStatus ( protocolProvider ) ; loadSkin ( ) ; }
459below/jitsi | public int getAccountIndex ( ) { return - 1 ; }
459below/jitsi | public void setAccountIndex ( int index ) { }
459below/jitsi | @ Override public void paintComponent ( Graphics g ) { AntialiasingManager . activateAntialiasing ( g ) ; super . paintComponent ( g ) ; if ( isConnecting ) g . drawImage ( getConnectingIcon ( ) , 0 , 3 , this ) ; }
459below/jitsi | private Image getConnectingIcon ( ) { if ( connectingIcon == null ) { connectingIcon = GuiActivator . getResources ( ) . getImage ( " service . gui . icons . CONNECTING " ) . getImage ( ) ; } return connectingIcon ; }
459below/jitsi | private void clearConnectingIcon ( ) { if ( connectingIcon != null ) { connectingIcon . flush ( ) ; connectingIcon = null ; } }
459below/jitsi | public void startConnecting ( ) { setConnecting ( true ) ; }
459below/jitsi | public void stopConnecting ( ) { clearConnectingIcon ( ) ; setConnecting ( false ) ; }
459below/jitsi | private void setConnecting ( boolean isConnecting ) { this . isConnecting = isConnecting ; this . repaint ( ) ; }
459below/jitsi | @ Override public boolean imageUpdate ( Image img , int infoflags , int x , int y , int w , int h ) { repaint ( ) ; return true ; }
459below/jitsi | public ProtocolProviderService getProtocolProvider ( ) { return protocolProvider ; }
459below/jitsi | public PresenceStatus getOfflineStatus ( ) { return offlineStatus ; }
459below/jitsi | public PresenceStatus getOnlineStatus ( ) { return onlineStatus ; }
459below/jitsi | public void loadSkin ( ) { clearConnectingIcon ( ) ; }
459below/jitsi | public void dispose ( ) { protocolProvider = null ; clearConnectingIcon ( ) ; offlineStatus = null ; onlineStatus = null ; }
459below/jitsi | public JMenuItem getEntryComponent ( ) { return this ; }
gurbuzali/hazelcast-jet | CsvFileFormat ( ) { }
gurbuzali/hazelcast-jet | @ Nonnull public CsvFileFormat < T > withClass ( @ Nullable Class < T > clazz ) { this . clazz = clazz ; return this ; }
gurbuzali/hazelcast-jet | @ Nullable public Class < T > clazz ( ) { return clazz ; }
gurbuzali/hazelcast-jet | @ Nonnull @ Override public String format ( ) { return FORMAT_CSV ; }
onders86/camel | protected AbstractBraintreeTestSupport ( ) { this . gateway = null ; }
onders86/camel | @ Override protected CamelContext createCamelContext ( ) throws Exception { final CamelContext context = super . createCamelContext ( ) ; final BraintreeComponent component = new BraintreeComponent ( context ) ; component . setConfiguration ( buildBraintreeConfiguration ( ) ) ; context . addComponent ( " braintree " , component ) ; return context ; }
onders86/camel | protected void addOptionIfMissing ( Map < String , Object > options , String name , String envName ) { if ( ! options . containsKey ( name ) ) { String value = System . getenv ( envName ) ; if ( ObjectHelper . isNotEmpty ( value ) ) { options . put ( name , value ) ; } } }
onders86/camel | protected BraintreeConfiguration buildBraintreeConfiguration ( ) throws Exception { final Properties properties = new Properties ( ) ; try { properties . load ( getClass ( ) . getResourceAsStream ( TEST_OPTIONS_PROPERTIES ) ) ; } catch ( Exception e ) { throw new IOException ( String . format ( " % s ▁ could ▁ not ▁ be ▁ loaded : ▁ % s " , TEST_OPTIONS_PROPERTIES , e . getMessage ( ) ) , e ) ; } Map < String , Object > options = new HashMap < > ( ) ; for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { options . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } AuthenticationType configurationType = getAuthenticationType ( ) ; LOG . info ( String . format ( " Test ▁ using ▁ % s ▁ configuration ▁ profile " , configurationType ) ) ; switch ( configurationType ) { case PUBLIC_PRIVATE_KEYS : addOptionIfMissing ( options , " environment " , " CAMEL _ BRAINTREE _ ENVIRONMENT " ) ; addOptionIfMissing ( options , " merchantId " , " CAMEL _ BRAINTREE _ MERCHANT _ ID " ) ; addOptionIfMissing ( options , " publicKey " , " CAMEL _ BRAINTREE _ PUBLIC _ KEY " ) ; addOptionIfMissing ( options , " privateKey " , " CAMEL _ BRAINTREE _ PRIVATE _ KEY " ) ; options . remove ( " accessToken " ) ; options . remove ( " clientId " ) ; break ; case ACCESS_TOKEN : addOptionIfMissing ( options , " accessToken " , " CAMEL _ BRAINTREE _ ACCESS _ TOKEN " ) ; options . remove ( " environment " ) ; options . remove ( " merchantId " ) ; options . remove ( " publicKey " ) ; options . remove ( " privateKey " ) ; break ; default : throw new IllegalArgumentException ( " Unsupported ▁ configuration ▁ type " ) ; } final BraintreeConfiguration configuration = new BraintreeConfiguration ( ) ; configuration . setHttpLogLevel ( BraintreeLogHandler . DEFAULT_LOGGER_VERSION ) ; configuration . setHttpLogName ( BraintreeLogHandler . DEFAULT_LOGGER_NAME ) ; IntrospectionSupport . setProperties ( configuration , options ) ; return configuration ; }
onders86/camel | protected AuthenticationType getAuthenticationType ( ) { if ( authenticationType == null ) { authenticationType = parseAuthenticationType ( ) ; } return authenticationType ; }
onders86/camel | protected boolean checkAuthenticationType ( AuthenticationType authenticationType ) { return getAuthenticationType ( ) . equals ( authenticationType ) ; }
onders86/camel | private AuthenticationType parseAuthenticationType ( ) { String authenticationTypeString = System . getProperty ( " braintreeAuthenticationType " ) ; if ( authenticationTypeString != null ) { AuthenticationType authenticationType = AuthenticationType . valueOf ( authenticationTypeString ) ; if ( authenticationType != null ) { return authenticationType ; } } return AuthenticationType . PUBLIC_PRIVATE_KEYS ; }
onders86/camel | @ Override public boolean isCreateCamelContextPerClass ( ) { return false ; }
onders86/camel | protected < T > T requestBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) throws CamelExecutionException { return ( T ) template ( ) . requestBodyAndHeaders ( endpointUri , body , headers ) ; }
onders86/camel | protected < T > T requestBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers , Class < T > type ) throws CamelExecutionException { return template ( ) . requestBodyAndHeaders ( endpointUri , body , headers , type ) ; }
onders86/camel | protected < T > T requestBody ( String endpoint , Object body ) throws CamelExecutionException { return ( T ) template ( ) . requestBody ( endpoint , body ) ; }
onders86/camel | protected < T > T requestBody ( String endpoint , Object body , Class < T > type ) throws CamelExecutionException { return template ( ) . requestBody ( endpoint , body , type ) ; }
onders86/camel | protected final BraintreeComponent getBraintreeComponent ( ) { return ( BraintreeComponent ) context ( ) . getComponent ( " braintree " ) ; }
onders86/camel | protected final synchronized BraintreeGateway getGateway ( ) { if ( gateway == null ) { gateway = getBraintreeComponent ( ) . getConfiguration ( ) . newBraintreeGateway ( ) ; } return gateway ; }
onders86/camel | public BraintreeHeaderBuilder ( ) { headers = new HashMap < > ( ) ; }
onders86/camel | public BraintreeHeaderBuilder add ( String key , Object value ) { if ( key . startsWith ( BraintreeConstants . PROPERTY_PREFIX ) ) { headers . put ( key , value ) ; } else { headers . put ( BraintreeConstants . PROPERTY_PREFIX + key , value ) ; } return this ; }
onders86/camel | public Map < String , Object > build ( ) { return Collections . unmodifiableMap ( headers ) ; }
Ironc2/barbapapa | @ Override protected void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . command_layout ) ; beer = Database . getBeerForCommand ( ) ; TextView beerText = ( TextView ) findViewById ( R . id . beerText ) ; beerText . setText ( beer . name ) ; ImageView beerImage = ( ImageView ) findViewById ( R . id . beerPhoto ) ; beerImage . setImageResource ( beer . imageID ) ; TextView type = ( TextView ) findViewById ( R . id . typeText ) ; type . setText ( beer . type ) ; TextView color = ( TextView ) findViewById ( R . id . colorText ) ; color . setText ( " Couleur ▁ : ▁ " + beer . color ) ; TextView abv = ( TextView ) findViewById ( R . id . ABVText ) ; abv . setText ( beer . getABV ( ) ) ; TextView bottle = ( TextView ) findViewById ( R . id . bottleText ) ; bottle . setText ( beer . getBottleDesc ( ) ) ; TextView description = ( TextView ) findViewById ( R . id . description ) ; description . setText ( beer . description ) ; ImageButton cancel = ( ImageButton ) findViewById ( R . id . cancelButton ) ; cancel . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { returnToMainActivity ( ) ; } } ) ; number = ( TextView ) findViewById ( R . id . number ) ; number . setText ( String . valueOf ( beerNumber ) ) ; ImageButton minus = ( ImageButton ) findViewById ( R . id . minus ) ; minus . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( beerNumber > 1 ) { beerNumber -- ; number . setText ( String . valueOf ( beerNumber ) ) ; } } } ) ; ImageButton plus = ( ImageButton ) findViewById ( R . id . plus ) ; plus . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( beerNumber < 10 ) { beerNumber ++ ; number . setText ( String . valueOf ( beerNumber ) ) ; } } } ) ; final Button commanderButton = ( Button ) findViewById ( R . id . commanderButton ) ; final Button retourButton = ( Button ) findViewById ( R . id . retourButton ) ; if ( beer . checked ) { commanderButton . setText ( " Checked " ) ; retourButton . setText ( " Annuler " ) ; } else { commanderButton . setText ( " Check - in " ) ; retourButton . setText ( " Retour " ) ; } commanderButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( ! beer . checked ) { beer . checked = true ; Utils . goToActivity ( CommandActivity . this , MainActivity . class ) ; } } } ) ; retourButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( beer . checked ) { beer . checked = false ; } Utils . goToActivity ( CommandActivity . this , MainActivity . class ) ; } } ) ; }
Ironc2/barbapapa | public void returnToMainActivity ( ) { Intent intent = new Intent ( this , MainActivity . class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivity ( intent ) ; }
SP96/SpringProject | public Address ( ) { }
SP96/SpringProject | public String getStreet ( ) { return street ; }
SP96/SpringProject | public void setStreet ( String street ) { this . street = street ; }
SP96/SpringProject | public String getPostcode ( ) { return postcode ; }
SP96/SpringProject | public void setPostcode ( String postcode ) { this . postcode = postcode ; }
SP96/SpringProject | public Address ( String street , String postcode ) { this . street = street ; this . postcode = postcode ; }
SP96/SpringProject | public void init ( ) { System . out . println ( " init ▁ called , ▁ Bean ▁ created : ▁ " + this ) ; }
SP96/SpringProject | public void destroy ( ) { }
SP96/SpringProject | @ Override public String toString ( ) { return " Address ▁ [ street = ▁ " + street + " , ▁ postcode = ▁ " + postcode + " ] " ; }
afinka77/ignite | public VisorCachePartitions ( ) { primary = new ArrayList < > ( ) ; backup = new ArrayList < > ( ) ; }
afinka77/ignite | public void addPrimary ( int part , int heap , long offheap , long swap ) { primary . add ( new VisorCachePartition ( part , heap , offheap , swap ) ) ; }
afinka77/ignite | public void addBackup ( int part , int heap , long offheap , long swap ) { backup . add ( new VisorCachePartition ( part , heap , offheap , swap ) ) ; }
afinka77/ignite | public List < VisorCachePartition > primary ( ) { return primary ; }
afinka77/ignite | public List < VisorCachePartition > backup ( ) { return backup ; }
afinka77/ignite | @ Override public String toString ( ) { return S . toString ( VisorCachePartitions . class , this ) ; }
jmarkos/protostream | @ Override public String getTypeName ( ) { return " sample _ bank _ account . Account . Limits " ; }
jmarkos/protostream | @ Override public Class < ? extends Account . Limits > getJavaClass ( ) { return Account . Limits . class ; }
jmarkos/protostream | @ Override public Account . Limits readFrom ( ProtoStreamReader reader ) throws IOException { double maxDailyLimit = reader . readDouble ( " maxDailyLimit " ) ; double maxTransactionLimit = reader . readDouble ( " maxTransactionLimit " ) ; Account . Limits account = new Account . Limits ( ) ; account . setMaxDailyLimit ( maxDailyLimit ) ; account . setMaxTransactionLimit ( maxTransactionLimit ) ; return account ; }
jmarkos/protostream | @ Override public void writeTo ( ProtoStreamWriter writer , Account . Limits limits ) throws IOException { writer . writeDouble ( " maxDailyLimit " , limits . getMaxDailyLimit ( ) ) ; writer . writeDouble ( " maxTransactionLimit " , limits . getMaxTransactionLimit ( ) ) ; }
osinstom/onos | private CriterionTranslatorHelper ( ) { }
Mozu/mozu-java | public ChannelResource ( ApiContext apiContext ) { _apiContext = apiContext ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . ChannelCollection getChannels ( ) throws Exception { return getChannels ( null , null , null , null , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . ChannelCollection getChannels ( Integer startIndex , Integer pageSize , String sortBy , String filter , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . ChannelCollection > client = com . mozu . api . clients . commerce . ChannelClient . getChannelsClient ( startIndex , pageSize , sortBy , filter , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel getChannel ( String code ) throws Exception { return getChannel ( code , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel getChannel ( String code , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . Channel > client = com . mozu . api . clients . commerce . ChannelClient . getChannelClient ( code , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel createChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel ) throws Exception { return createChannel ( channel , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel createChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . Channel > client = com . mozu . api . clients . commerce . ChannelClient . createChannelClient ( channel , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel updateChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel , String code ) throws Exception { return updateChannel ( channel , code , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel updateChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel , String code , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . Channel > client = com . mozu . api . clients . commerce . ChannelClient . updateChannelClient ( channel , code , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public void deleteChannel ( String code ) throws Exception { MozuClient client = com . mozu . api . clients . commerce . ChannelClient . deleteChannelClient ( code ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; client . cleanupHttpConnection ( ) ; }
simplaapliko/Trips | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ButterKnife . bind ( this ) ; ActionBar actionBar = getSupportActionBar ( ) ; if ( actionBar != null ) { actionBar . setDisplayHomeAsUpEnabled ( true ) ; actionBar . setHomeButtonEnabled ( true ) ; } mPagerAdapter = new PlacePagerAdapter ( getSupportFragmentManager ( ) , this ) ; activityComponent ( ) . inject ( this ) ; initializeWidgets ( ) ; initializeActivity ( savedInstanceState ) ; initializeInjector ( ) ; }
simplaapliko/Trips | @ Override protected void onSaveInstanceState ( Bundle savedInstanceState ) { if ( savedInstanceState != null ) { savedInstanceState . putLong ( TRIP_ID_KEY , mTripId ) ; } super . onSaveInstanceState ( savedInstanceState ) ; }
simplaapliko/Trips | @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode != RESULT_OK ) { return ; } switch ( requestCode ) { case CREATE_PLACE : onCreatePlaceResultReceived ( ) ; break ; case EDIT_PLACE : onEditPlaceResultReceived ( ) ; break ; } }
simplaapliko/Trips | @ Override public PlaceListComponent getComponent ( ) { return mPlaceListComponent ; }
simplaapliko/Trips | @ OnClick ( R . id . add_fab ) public void onAddFabClick ( ) { mNavigator . navigateToAddPlace ( this , mTripId ) ; }
simplaapliko/Trips | @ Override protected int getContentView ( ) { return R . layout . activity_trip ; }
simplaapliko/Trips | private void initializeActivity ( Bundle savedInstanceState ) { if ( savedInstanceState == null ) { mTripId = getIntent ( ) . getLongExtra ( TRIP_ID_KEY , - 1L ) ; } else { mTripId = savedInstanceState . getInt ( TRIP_ID_KEY ) ; } }
simplaapliko/Trips | private void initializeInjector ( ) { mPlaceListComponent = super . getAppComponent ( ) . plusPlaceListComponent ( new PlaceListModule ( mTripId ) ) ; }
simplaapliko/Trips | private void initializeWidgets ( ) { mViewPager . setAdapter ( mPagerAdapter ) ; mViewPager . addOnPageChangeListener ( new ViewPager . SimpleOnPageChangeListener ( ) { @ Override public void onPageSelected ( int position ) { mPagerAdapter . onPageSelected ( position ) ; } } ) ; mTabLayout . setupWithViewPager ( mViewPager ) ; }
simplaapliko/Trips | private void onCreatePlaceResultReceived ( ) { mPagerAdapter . notifyDataSetChanged ( ) ; }
simplaapliko/Trips | private void onEditPlaceResultReceived ( ) { mPagerAdapter . notifyDataSetChanged ( ) ; }
Ckathode/archimedes-ships | public MobileChunkServer ( World world , EntityShip entityship ) { super ( world , entityship ) ; sendQueue = new HashSet < ChunkPosition > ( ) ; }
Ckathode/archimedes-ships | public Collection < ChunkPosition > getSendQueue ( ) { return sendQueue ; }
Ckathode/archimedes-ships | @ Override public boolean setBlockIDWithMetadata ( int x , int y , int z , Block block , int meta ) { if ( super . setBlockIDWithMetadata ( x , y , z , block , meta ) ) { sendQueue . add ( new ChunkPosition ( x , y , z ) ) ; return true ; } return false ; }
Ckathode/archimedes-ships | @ Override public boolean setBlockMetadata ( int x , int y , int z , int meta ) { if ( super . setBlockMetadata ( x , y , z , meta ) ) { sendQueue . add ( new ChunkPosition ( x , y , z ) ) ; return true ; } return false ; }
Ckathode/archimedes-ships | @ Override protected void onSetBlockAsFilledAir ( int x , int y , int z ) { }
cbeams-archive/spring-framework-2.5.x | public void setFooService ( FooService fooService ) { this . fooService = fooService ; }
cbeams-archive/spring-framework-2.5.x | public void setServiceInvocationCounter ( ServiceInvocationCounter serviceInvocationCounter ) { this . serviceInvocationCounter = serviceInvocationCounter ; }
cbeams-archive/spring-framework-2.5.x | public void testFooService ( ) throws Exception { String value = fooService . foo ( 1 ) ; assertEquals ( " bar " , value ) ; assertEquals ( 1 , serviceInvocationCounter . getCount ( ) ) ; fooService . foo ( 1 ) ; assertEquals ( 2 , serviceInvocationCounter . getCount ( ) ) ; }
cbeams-archive/spring-framework-2.5.x | @ Override protected String [ ] getConfigLocations ( ) { return new String [ ] { " org / springframework / context / annotation / simpleConfigTests . xml " } ; }
michel-kraemer/vertx-lang-typescript | public DiskCache ( File cacheDir ) { this . cacheDir = cacheDir ; }
michel-kraemer/vertx-lang-typescript | private File getFileOnDisk ( Source source ) { return new File ( cacheDir , source . getDigest ( ) ) ; }
michel-kraemer/vertx-lang-typescript | @ Override public String get ( Source src ) { String result = memoryCache . get ( src ) ; if ( result == null ) { File f = getFileOnDisk ( src ) ; if ( f . exists ( ) ) { Source rs ; try { rs = Source . fromFile ( f , StandardCharsets . UTF_8 ) ; result = rs . toString ( ) ; memoryCache . put ( src , result ) ; } catch ( IOException e ) { } } } return result ; }
michel-kraemer/vertx-lang-typescript | @ Override public void put ( Source src , String value ) { memoryCache . put ( src , value ) ; if ( ! cacheDir . exists ( ) ) { cacheDir . mkdirs ( ) ; } File f = getFileOnDisk ( src ) ; try ( Writer w = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( f ) ) ) ) { w . write ( value ) ; w . flush ( ) ; } catch ( IOException e ) { } }
aperepel/netty | public RtspResponseDecoder ( ) { super ( ) ; }
aperepel/netty | public RtspResponseDecoder ( int maxInitialLineLength , int maxHeaderSize , int maxContentLength ) { super ( maxInitialLineLength , maxHeaderSize , maxContentLength ) ; }
aperepel/netty | @ Override protected HttpMessage createMessage ( String [ ] initialLine ) throws Exception { return new DefaultHttpResponse ( RtspVersions . valueOf ( initialLine [ 0 ] ) , new HttpResponseStatus ( Integer . valueOf ( initialLine [ 1 ] ) , initialLine [ 2 ] ) ) ; }
aperepel/netty | @ Override protected boolean isDecodingRequest ( ) { return false ; }
SirDap/itranslator99-to-unicode-epub-converter | if ( deleteOutputFile ) { actualOutputFile . deleteOnExit ( ) ; }
bsenduran/wso2-commons-vfs | public FileContentInfo create ( FileContent fileContent ) throws FileSystemException { WebdavFileObject file = ( WebdavFileObject ) ( FileObjectUtils . getAbstractFileObject ( fileContent . getFile ( ) ) ) ; String contentType = null ; String contentEncoding = null ; DavPropertyNameSet nameSet = new DavPropertyNameSet ( ) ; nameSet . add ( DavPropertyName . GETCONTENTTYPE ) ; DavPropertySet propertySet = file . getProperties ( ( URLFileName ) file . getName ( ) , nameSet , true ) ; DavProperty property = propertySet . get ( DavPropertyName . GETCONTENTTYPE ) ; if ( property != null ) { contentType = ( String ) property . getValue ( ) ; } property = propertySet . get ( WebdavFileObject . RESPONSE_CHARSET ) ; if ( property != null ) { contentEncoding = ( String ) property . getValue ( ) ; } return new DefaultFileContentInfo ( contentType , contentEncoding ) ; }
BladeRunnerJS/closure-compiler | private Base64 ( ) { }
BladeRunnerJS/closure-compiler | i ++ ) { BASE64_DECODE_MAP [ BASE64_MAP . charAt ( i ) ] = i ; }
alect/Puzzledice | public DatabaseModel ( ) { _items = new HashMap < String , DatabaseItem > ( ) ; _properties = new HashMap < String , DatabaseProperty > ( ) ; }
alect/Puzzledice | public boolean addItemToDatabase ( DatabaseItem item ) { if ( _items . containsKey ( item . getName ( ) ) ) { return false ; } for ( String propertyName : _properties . keySet ( ) ) { if ( ! item . hasProperty ( propertyName ) ) item . addProperty ( propertyName , null ) ; } _items . put ( item . getName ( ) , item ) ; WindowMain . addItemToListView ( item ) ; WindowMain . addItemToTableView ( item ) ; return true ; }
alect/Puzzledice | public void removeItemFromDatabase ( DatabaseItem item ) { if ( ! _items . containsKey ( item . getName ( ) ) ) return ; _items . remove ( item . getName ( ) ) ; WindowMain . removeItemFromListView ( item ) ; WindowMain . removeItemFromTableView ( item ) ; }
alect/Puzzledice | public boolean addPropertyToDatabase ( DatabaseProperty property ) { if ( _properties . containsKey ( property . getName ( ) ) ) return false ; _properties . put ( property . getName ( ) , property ) ; for ( DatabaseItem item : _items . values ( ) ) { item . addProperty ( property . getName ( ) , null ) ; } WindowMain . addPropertyToTableView ( property ) ; WindowMain . updateGUI ( ) ; return true ; }
alect/Puzzledice | public void removePropertyFromDatabase ( DatabaseProperty property ) { if ( ! _properties . containsKey ( property . getName ( ) ) ) return ; _properties . remove ( property . getName ( ) ) ; for ( DatabaseItem item : _items . values ( ) ) { item . removeProperty ( property . getName ( ) ) ; } WindowMain . removePropertyFromTableView ( property ) ; WindowMain . updateGUI ( ) ; }
alect/Puzzledice | public DatabaseProperty createInstance ( String propertyName ) { if ( ! _properties . containsKey ( propertyName ) ) return null ; return _properties . get ( propertyName ) . initializeInstance ( ) ; }
alect/Puzzledice | public boolean isPropertyNameInDatabase ( String propertyName ) { return _properties . containsKey ( propertyName ) ; }
alect/Puzzledice | public DatabaseItem [ ] getItemList ( ) { DatabaseItem [ ] items = new DatabaseItem [ _items . values ( ) . size ( ) ] ; return _items . values ( ) . toArray ( items ) ; }
alect/Puzzledice | public DatabaseProperty [ ] getPropertyList ( ) { DatabaseProperty [ ] properties = new DatabaseProperty [ _properties . values ( ) . size ( ) ] ; return _properties . values ( ) . toArray ( properties ) ; }
alect/Puzzledice | public DatabaseProperty getPropertyValue ( String propertyName ) { return _properties . get ( propertyName ) ; }
alect/Puzzledice | public String xmlDigest ( ) { String xml = " < Database > \n < Properties > \n " ; for ( DatabaseProperty property : _properties . values ( ) ) { xml += property . toXML ( ) + " \n " ; } xml += " < / Properties > \n < Items > \n " ; for ( DatabaseItem item : _items . values ( ) ) { xml += item . toXML ( ) + " \n " ; } xml += " < / Items > \n < / Database > " ; return xml ; }
YoungDigitalPlanet/empiria.player | @ Before public void init ( ) { when ( flowData . getCurrentPageIndex ( ) ) . thenReturn ( 0 ) ; when ( itemDataSourceCollectionManager . getItemIdentifier ( 0 ) ) . thenReturn ( identifier ) ; }
YoungDigitalPlanet/empiria.player | @ Test public void shouldReturnStyleWrappedWithOptional ( ) { String style = " style " ; Optional < String > optionalStyle = Optional . of ( style ) ; when ( itemStylesContainer . getStyle ( identifier ) ) . thenReturn ( optionalStyle ) ; Optional < String > result = testObj . getCurrentItemStyle ( ) ; assertThat ( result . isPresent ( ) ) . isTrue ( ) ; assertThat ( result . get ( ) ) . isEqualTo ( style ) ; }
YoungDigitalPlanet/empiria.player | @ Test public void shouldReturnEmptyOptional_whenStyleForPageDoesNotExist ( ) { Optional < String > optionalStyle = Optional . absent ( ) ; when ( itemStylesContainer . getStyle ( identifier ) ) . thenReturn ( optionalStyle ) ; Optional < String > result = testObj . getCurrentItemStyle ( ) ; assertThat ( result . isPresent ( ) ) . isFalse ( ) ; }
snowdream/android-sharesdk | public DemoPage ( final SlidingMenu menu ) { super ( menu ) ; View pageView = getPage ( ) ; llTitle = ( TitleLayout ) pageView . findViewById ( R . id . llTitle ) ; llTitle . getBtnBack ( ) . setOnClickListener ( this ) ; llTitle . getTvTitle ( ) . setText ( R . string . sm_item_demo ) ; pageView . findViewById ( R . id . btnShareAllGui ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnShareAll ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnFlSw ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnFlTc ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnGetToken ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnVisitWc ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnGetInfor ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnGetUserInfor ) . setOnClickListener ( this ) ; new Thread ( ) { public void run ( ) { Platform [ ] list = ShareSDK . getPlatformList ( menu . getContext ( ) ) ; if ( list != null ) { Message msg = new Message ( ) ; msg . obj = list ; UIHandler . sendMessage ( msg , new Callback ( ) { public boolean handleMessage ( Message msg ) { afterPlatformsGot ( ( Platform [ ] ) msg . obj ) ; return false ; } } ) ; } } } . start ( ) ; }
snowdream/android-sharesdk | private void afterPlatformsGot ( Platform [ ] platforms ) { View pageView = getPage ( ) ; LinearLayout llList = ( LinearLayout ) pageView . findViewById ( R . id . llList ) ; LinearLayout line = ( LinearLayout ) View . inflate ( menu . getContext ( ) , R . layout . demo_page_item , null ) ; llList . addView ( line ) ; int lineCount = 0 ; for ( Platform platform : platforms ) { String name = platform . getName ( ) ; if ( ShareCore . isUseClientToShare ( platform . getContext ( ) , name ) ) { continue ; } if ( lineCount >= 2 ) { line = ( LinearLayout ) View . inflate ( menu . getContext ( ) , R . layout . demo_page_item , null ) ; llList . addView ( line ) ; lineCount = 0 ; } int res = lineCount == 0 ? R . id . btnLeft : R . id . btnRight ; Button btn = ( Button ) line . findViewById ( res ) ; btn . setSingleLine ( ) ; int platNameRes = cn . sharesdk . framework . utils . R . getStringRes ( menu . getContext ( ) , name ) ; String platName = menu . getContext ( ) . getString ( platNameRes ) ; String text = menu . getContext ( ) . getString ( R . string . share_to_format , platName ) ; btn . setText ( text ) ; btn . setTag ( platform ) ; btn . setVisibility ( View . VISIBLE ) ; btn . setOnClickListener ( this ) ; lineCount ++ ; } }
snowdream/android-sharesdk | protected View initPage ( ) { return LayoutInflater . from ( menu . getContext ( ) ) . inflate ( R . layout . page_demo , null ) ; }
snowdream/android-sharesdk | private void showShare ( boolean silent , String platform ) { final OnekeyShare oks = new OnekeyShare ( ) ; oks . setNotification ( R . drawable . ic_launcher , menu . getContext ( ) . getString ( R . string . app_name ) ) ; oks . setAddress ( "12345678901" ) ; oks . setTitle ( menu . getContext ( ) . getString ( R . string . evenote_title ) ) ; oks . setTitleUrl ( " http : // sharesdk . cn " ) ; oks . setText ( menu . getContext ( ) . getString ( R . string . share_content ) ) ; oks . setImagePath ( MainActivity . TEST_IMAGE ) ; oks . setImageUrl ( " http : // img . appgo . cn / imgs / sharesdk / content / 2013/07/25/1374723172663 . jpg " ) ; oks . setUrl ( " http : // www . sharesdk . cn " ) ; oks . setFilePath ( MainActivity . TEST_IMAGE ) ; oks . setComment ( menu . getContext ( ) . getString ( R . string . share ) ) ; oks . setSite ( menu . getContext ( ) . getString ( R . string . app_name ) ) ; oks . setSiteUrl ( " http : // sharesdk . cn " ) ; oks . setVenueName ( " ShareSDK " ) ; oks . setVenueDescription ( " This ▁ is ▁ a ▁ beautiful ▁ place ! " ) ; oks . setLatitude ( 23.056081f ) ; oks . setLongitude ( 113.385708f ) ; oks . setSilent ( silent ) ; if ( platform != null ) { oks . setPlatform ( platform ) ; } oks . setShareContentCustomizeCallback ( new ShareContentCustomizeDemo ( ) ) ; oks . show ( menu . getContext ( ) ) ; }
snowdream/android-sharesdk | public void onClick ( View v ) { if ( v . equals ( llTitle . getBtnBack ( ) ) ) { if ( menu . isMenuShown ( ) ) { menu . hideMenu ( ) ; } else { menu . showMenu ( ) ; } return ; } final int id = v . getId ( ) ; if ( id == R . id . btnShareAllGui ) { showShare ( false , null ) ; } else if ( id == R . id . btnShareAll ) { showShare ( true , null ) ; } else if ( id == R . id . btnFlSw ) { Platform plat = ShareSDK . getPlatform ( menu . getContext ( ) , " SinaWeibo " ) ; plat . setPlatformActionListener ( this ) ; plat . followFriend ( MainAdapter . SDK_SINAWEIBO_UID ) ; } else if ( id == R . id . btnFlTc ) { Platform plat = ShareSDK . getPlatform ( menu . getContext ( ) , " TencentWeibo " ) ; plat . setPlatformActionListener ( this ) ; plat . followFriend ( MainAdapter . SDK_TENCENTWEIBO_UID ) ; } else if ( id == R . id . btnGetToken ) { GetTokenPage page = new GetTokenPage ( ) ; page . show ( menu . getContext ( ) , null ) ; } else if ( id == R . id . btnVisitWc ) { String packageName = " com . tencent . mm " ; PackageInfo pi = null ; try { pi = menu . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , 0 ) ; } catch ( Throwable t ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_is_not_installed_correctly , Toast . LENGTH_SHORT ) . show ( ) ; t . printStackTrace ( ) ; } if ( pi == null ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_is_not_installed_correctly , Toast . LENGTH_SHORT ) . show ( ) ; } Intent i = new Intent ( Intent . ACTION_VIEW ) ; i . setData ( Uri . parse ( MainAdapter . WECHAT_ADDR ) ) ; i . setPackage ( " com . tencent . mm " ) ; ResolveInfo ri = menu . getContext ( ) . getPackageManager ( ) . resolveActivity ( i , 0 ) ; if ( ri == null ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_is_not_installed_correctly , Toast . LENGTH_SHORT ) . show ( ) ; } try { menu . getContext ( ) . startActivity ( i ) ; } catch ( Throwable t ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_not_support_following_operation , Toast . LENGTH_SHORT ) . show ( ) ; t . printStackTrace ( ) ; } } else if ( id == R . id . btnGetInfor ) { GetInforPage page = new GetInforPage ( ) ; page . setType ( 0 ) ; page . show ( menu . getContext ( ) , null ) ; } else if ( id == R . id . btnGetUserInfor ) { Intent i = new Intent ( menu . getContext ( ) , GetInforPage . class ) ; i . putExtra ( " type " , 1 ) ; menu . getContext ( ) . startActivity ( i ) ; } else { Object tag = v . getTag ( ) ; if ( tag != null ) { showShare ( false , ( ( Platform ) tag ) . getName ( ) ) ; } } }
snowdream/android-sharesdk | public void onComplete ( Platform plat , int action , HashMap < String , Object > res ) { Message msg = new Message ( ) ; msg . arg1 = 1 ; msg . arg2 = action ; msg . obj = plat ; UIHandler . sendMessage ( msg , this ) ; }
snowdream/android-sharesdk | public void onCancel ( Platform palt , int action ) { Message msg = new Message ( ) ; msg . arg1 = 3 ; msg . arg2 = action ; msg . obj = palt ; UIHandler . sendMessage ( msg , this ) ; }
snowdream/android-sharesdk | public void onError ( Platform palt , int action , Throwable t ) { t . printStackTrace ( ) ; Message msg = new Message ( ) ; msg . arg1 = 2 ; msg . arg2 = action ; msg . obj = palt ; UIHandler . sendMessage ( msg , this ) ; }
snowdream/android-sharesdk | public boolean handleMessage ( Message msg ) { Platform plat = ( Platform ) msg . obj ; String text = MainActivity . actionToString ( msg . arg2 ) ; switch ( msg . arg1 ) { case 1 : { text = plat . getName ( ) + " ▁ completed ▁ at ▁ " + text ; } break ; case 2 : { text = plat . getName ( ) + " ▁ caught ▁ error ▁ at ▁ " + text ; } break ; case 3 : { text = plat . getName ( ) + " ▁ canceled ▁ at ▁ " + text ; } break ; } Toast . makeText ( menu . getContext ( ) , text , Toast . LENGTH_SHORT ) . show ( ) ; return false ; }
LearnLib/automatalib | @ Test public void testNormalDomain ( ) { final Set < List < Integer > > combinations = Streams . stream ( CollectionsUtil . cartesianProduct ( DOMAIN1 , DOMAIN2 , DOMAIN3 ) ) . map ( ArrayList :: new ) . collect ( Collectors . toSet ( ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 1 , 3 , 4 ) ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 1 , 3 , 5 ) ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 2 , 3 , 4 ) ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 2 , 3 , 5 ) ) ) ; Assert . assertTrue ( combinations . isEmpty ( ) ) ; }
LearnLib/automatalib | @ Test public void testEmptyDomain ( ) { final Iterable < List < Integer > > iter = CollectionsUtil . cartesianProduct ( DOMAIN1 , Collections . emptyList ( ) , DOMAIN3 ) ; Assert . assertTrue ( Iterables . isEmpty ( iter ) ) ; Assert . assertThrows ( NoSuchElementException . class , ( ) -> iter . iterator ( ) . next ( ) ) ; }
LearnLib/automatalib | @ Test public void testEmptyDimension ( ) { final Iterable < List < Integer > > iter = CollectionsUtil . cartesianProduct ( ) ; Assert . assertEquals ( Iterables . size ( iter ) , 1 ) ; Assert . assertTrue ( Iterables . all ( iter , List :: isEmpty ) ) ; }
GunoH/intellij-community | public MavenImportDependency ( @ NotNull T artifact , @ NotNull DependencyScope scope ) { this . artifact = artifact ; this . scope = scope ; }
GunoH/intellij-community | public @ NotNull T getArtifact ( ) { return artifact ; }
GunoH/intellij-community | public @ NotNull DependencyScope getScope ( ) { return scope ; }
GunoH/intellij-community | @ Override public String toString ( ) { return artifact . toString ( ) ; }
dagnir/aws-sdk-java | public void marshall ( StartLambdaFunctionFailedEventAttributes startLambdaFunctionFailedEventAttributes , ProtocolMarshaller protocolMarshaller ) { if ( startLambdaFunctionFailedEventAttributes == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { protocolMarshaller . marshall ( startLambdaFunctionFailedEventAttributes . getScheduledEventId ( ) , SCHEDULEDEVENTID_BINDING ) ; protocolMarshaller . marshall ( startLambdaFunctionFailedEventAttributes . getCause ( ) , CAUSE_BINDING ) ; protocolMarshaller . marshall ( startLambdaFunctionFailedEventAttributes . getMessage ( ) , MESSAGE_BINDING ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
AlanJinTS/zstack | public NetworkServiceType ( String typeName ) { this . typeName = typeName ; types . put ( typeName , this ) ; }
AlanJinTS/zstack | @ Override public String toString ( ) { return typeName ; }
AlanJinTS/zstack | @ Override public boolean equals ( Object t ) { if ( t == null || ! ( t instanceof NetworkServiceType ) ) { return false ; } NetworkServiceType type = ( NetworkServiceType ) t ; return type . toString ( ) . equals ( typeName ) ; }
AlanJinTS/zstack | @ Override public int hashCode ( ) { return typeName . hashCode ( ) ; }
ZhernakovMikhail/fax4j | private ProcessExecutorHelper ( ) { super ( ) ; }
ZhernakovMikhail/fax4j | public ProcessOutput ( String outputText , String errorText , int exitCode ) { super ( ) ; this . OUTPUT_TEXT = outputText ; this . ERROR_TEXT = errorText ; this . EXIT_CODE = exitCode ; }
ZhernakovMikhail/fax4j | public String getOutputText ( ) { return this . OUTPUT_TEXT ; }
ZhernakovMikhail/fax4j | public String getErrorText ( ) { return this . ERROR_TEXT ; }
ZhernakovMikhail/fax4j | public int getExitCode ( ) { return this . EXIT_CODE ; }
AdamPD/drill | public DrillServiceInstance ( ) { }
AdamPD/drill | public String getId ( ) { return id ; }
AdamPD/drill | public DrillServiceInstance setId ( String id ) { this . id = id ; return this ; }
AdamPD/drill | public long getRegistrationTimeUTC ( ) { return registrationTimeUTC ; }
AdamPD/drill | public DrillServiceInstance setRegistrationTimeUTC ( long registrationTimeUTC ) { this . registrationTimeUTC = registrationTimeUTC ; return this ; }
AdamPD/drill | public DrillbitEndpoint getEndpoint ( ) { return endpoint ; }
AdamPD/drill | public DrillServiceInstance setEndpoint ( DrillbitEndpoint endpoint ) { this . endpoint = endpoint ; return this ; }
AdamPD/drill | public void readExternal ( ObjectInput in ) throws IOException { GraphIOUtil . mergeDelimitedFrom ( in , this , this ) ; }
AdamPD/drill | public void writeExternal ( ObjectOutput out ) throws IOException { GraphIOUtil . writeDelimitedTo ( out , this , this ) ; }
AdamPD/drill | public Schema < DrillServiceInstance > cachedSchema ( ) { return DEFAULT_INSTANCE ; }
AdamPD/drill | public DrillServiceInstance newMessage ( ) { return new DrillServiceInstance ( ) ; }
AdamPD/drill | public Class < DrillServiceInstance > typeClass ( ) { return DrillServiceInstance . class ; }
AdamPD/drill | public String messageName ( ) { return DrillServiceInstance . class . getSimpleName ( ) ; }
AdamPD/drill | public String messageFullName ( ) { return DrillServiceInstance . class . getName ( ) ; }
AdamPD/drill | public boolean isInitialized ( DrillServiceInstance message ) { return true ; }
AdamPD/drill | public void mergeFrom ( Input input , DrillServiceInstance message ) throws IOException { for ( int number = input . readFieldNumber ( this ) ; ; number = input . readFieldNumber ( this ) ) { switch ( number ) { case 0 : return ; case 1 : message . id = input . readString ( ) ; break ; case 2 : message . registrationTimeUTC = input . readInt64 ( ) ; break ; case 3 : message . endpoint = input . mergeObject ( message . endpoint , DrillbitEndpoint . getSchema ( ) ) ; break ; default : input . handleUnknownField ( number , this ) ; } } }
AdamPD/drill | public void writeTo ( Output output , DrillServiceInstance message ) throws IOException { if ( message . id != null ) output . writeString ( 1 , message . id , false ) ; if ( message . registrationTimeUTC != 0 ) output . writeInt64 ( 2 , message . registrationTimeUTC , false ) ; if ( message . endpoint != null ) output . writeObject ( 3 , message . endpoint , DrillbitEndpoint . getSchema ( ) , false ) ; }
AdamPD/drill | public String getFieldName ( int number ) { switch ( number ) { case 1 : return " id " ; case 2 : return " registrationTimeUTC " ; case 3 : return " endpoint " ; default : return null ; } }
AdamPD/drill | public int getFieldNumber ( String name ) { final Integer number = __fieldMap . get ( name ) ; return number == null ? 0 : number . intValue ( ) ; }
googlesamples/android-testdpc | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mDevicePolicyManager = ( DevicePolicyManager ) getActivity ( ) . getSystemService ( Context . DEVICE_POLICY_SERVICE ) ; }
googlesamples/android-testdpc | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { final ViewGroup rootView = ( ViewGroup ) inflater . inflate ( R . layout . transfer_ownership_dialog , null ) ; final ListView listView = rootView . findViewById ( R . id . list ) ; final EditText componentName = rootView . findViewById ( R . id . component_name ) ; final EditText result = rootView . findViewById ( R . id . result ) ; final Button transferButton = rootView . findViewById ( R . id . transfer_btn ) ; final Intent intent = new Intent ( DeviceAdminReceiver . ACTION_DEVICE_ADMIN_ENABLED ) ; final List < String > items = new ArrayList < > ( ) ; final PackageManager packageManager = getActivity ( ) . getPackageManager ( ) ; final List < ResolveInfo > resolveInfos = packageManager . queryBroadcastReceivers ( intent , 0 ) ; for ( ResolveInfo resolveInfo : resolveInfos ) { ActivityInfo activityInfo = resolveInfo . activityInfo ; if ( activityInfo == null ) { continue ; } items . add ( activityInfo . packageName + " / " + activityInfo . name ) ; } final ListAdapter adapter = new ArrayAdapter < > ( getActivity ( ) , android . R . layout . simple_list_item_1 , items ) ; listView . setAdapter ( adapter ) ; listView . setOnItemClickListener ( ( adapterView , view1 , i , __ ) -> componentName . setText ( adapterView . getItemAtPosition ( i ) . toString ( ) ) ) ; transferButton . setOnClickListener ( view -> { ComponentName target = ComponentName . unflattenFromString ( componentName . getText ( ) . toString ( ) ) ; if ( target != null ) { result . setText ( performTransfer ( target ) ) ; } else { result . setText ( R . string . transfer_ownership_invalid_target_format ) ; } } ) ; return rootView ; }
googlesamples/android-testdpc | private String performTransfer ( ComponentName target ) { ComponentName source = com . afwsamples . testdpc . DeviceAdminReceiver . getComponentName ( getActivity ( ) ) ; Log . i ( getClass ( ) . getName ( ) , " Transferring ▁ ownership ▁ from ▁ " + source + " ▁ to ▁ target ▁ " + target ) ; try { PersistableBundle persistableBundle = new PersistableBundle ( ) ; persistableBundle . putString ( " random _ key " , " random _ value " ) ; mDevicePolicyManager . transferOwnership ( source , target , persistableBundle ) ; return " Success ! " ; } catch ( Exception e ) { Throwable cause = e . getCause ( ) ; if ( cause instanceof InvocationTargetException ) { return getStackTrace ( ( ( InvocationTargetException ) cause ) . getTargetException ( ) ) ; } return getStackTrace ( cause ) ; } }
googlesamples/android-testdpc | private String getStackTrace ( Throwable throwable ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( stringWriter ) ; throwable . printStackTrace ( printWriter ) ; return stringWriter . toString ( ) ; }
dylanscott/proxie | DispatcherAdapter ( Supplier < ? > supplier ) { this . supplier = supplier ; }
dylanscott/proxie | @ Override public Object loadObject ( ) throws Exception { return supplier . get ( ) ; }
ladygagapowerbot/bachelor-thesis-implementation | public RippleGimpyRenderer ( double d1 , double d2 , ColorRangeContainer colorRange1 , ColorRangeContainer colorRange2 ) { super ( d1 , d2 , colorRange1 , colorRange2 ) ; }
ladygagapowerbot/bachelor-thesis-implementation | @ Override public void gimp ( BufferedImage image ) { RippleFilter filter = new RippleFilter ( ) ; filter . setWaveType ( RippleFilter . SINGLEFRAME ) ; filter . setXAmplitude ( d1 ) ; filter . setYAmplitude ( d2 ) ; filter . setXWavelength ( ( 5.77 ) * d1 ) ; filter . setYWavelength ( ( 2.94 ) * d2 ) ; filter . setEdgeAction ( TransformFilter . RANDOMPIXELORDER ) ; ImageUtil . applyFilter ( image , filter ) ; }
jrbeaumont/workcraft | @ Test public void testMirrorSignalTransformationCommand ( ) throws DeserialisationException { final Framework framework = Framework . getInstance ( ) ; final ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; for ( String testStgWork : TEST_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; Stg stg = WorkspaceUtils . getAs ( we , Stg . class ) ; Set < String > srcInputs = stg . getSignalNames ( Type . INPUT , null ) ; Set < String > srcOutputs = stg . getSignalNames ( Type . OUTPUT , null ) ; Set < String > srcInternals = stg . getSignalNames ( Type . INTERNAL , null ) ; MirrorSignalTransformationCommand command = new MirrorSignalTransformationCommand ( ) ; command . execute ( we ) ; Set < String > dstInputs = stg . getSignalNames ( Type . INPUT , null ) ; Set < String > dstOutputs = stg . getSignalNames ( Type . OUTPUT , null ) ; Set < String > dstInternals = stg . getSignalNames ( Type . INTERNAL , null ) ; Assert . assertEquals ( srcInputs , dstOutputs ) ; Assert . assertEquals ( srcOutputs , dstInputs ) ; Assert . assertEquals ( srcInternals , dstInternals ) ; framework . closeWork ( we ) ; } }
jrbeaumont/workcraft | @ Test public void testMirrorTransitionTransformationCommand ( ) throws DeserialisationException { final Framework framework = Framework . getInstance ( ) ; final ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; for ( String testStgWork : TEST_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; Stg stg = WorkspaceUtils . getAs ( we , Stg . class ) ; int srcMinusCount = 0 ; int srcPlusCount = 0 ; int srcToggleCount = 0 ; for ( SignalTransition srcTransition : stg . getSignalTransitions ( ) ) { switch ( srcTransition . getDirection ( ) ) { case MINUS : srcMinusCount ++ ; break ; case PLUS : srcPlusCount ++ ; break ; case TOGGLE : srcToggleCount ++ ; break ; } } MirrorTransitionTransformationCommand command = new MirrorTransitionTransformationCommand ( ) ; command . execute ( we ) ; int dstMinusCount = 0 ; int dstPlusCount = 0 ; int dstToggleCount = 0 ; for ( SignalTransition dstTransition : stg . getSignalTransitions ( ) ) { switch ( dstTransition . getDirection ( ) ) { case MINUS : dstMinusCount ++ ; break ; case PLUS : dstPlusCount ++ ; break ; case TOGGLE : dstToggleCount ++ ; break ; } } Assert . assertEquals ( srcMinusCount , dstPlusCount ) ; Assert . assertEquals ( srcPlusCount , dstMinusCount ) ; Assert . assertEquals ( srcToggleCount , dstToggleCount ) ; framework . closeWork ( we ) ; } }
jrbeaumont/workcraft | @ Test public void testPlaceTransformationCommands ( ) throws DeserialisationException { final Framework framework = Framework . getInstance ( ) ; final ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; for ( String testStgWork : TEST_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; VisualStg stg = WorkspaceUtils . getAs ( we , VisualStg . class ) ; int srcPlaces = stg . getVisualPlaces ( ) . size ( ) ; int srcImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int srcSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int srcDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; ExplicitPlaceTransformationCommand command1 = new ExplicitPlaceTransformationCommand ( ) ; command1 . execute ( we ) ; int expPlaces = stg . getVisualPlaces ( ) . size ( ) ; int expImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int expSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int expDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; Assert . assertEquals ( srcPlaces + srcImplicitPlaceArcs , expPlaces + expImplicitPlaceArcs ) ; Assert . assertEquals ( srcSignalTransitions , expSignalTransitions ) ; Assert . assertEquals ( srcDummyTransitions , expDummyTransitions ) ; ImplicitPlaceTransformationCommand command2 = new ImplicitPlaceTransformationCommand ( ) ; command2 . execute ( we ) ; int impPlaces = stg . getVisualPlaces ( ) . size ( ) ; int impImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int impSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int impDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; Assert . assertEquals ( srcPlaces + srcImplicitPlaceArcs , impPlaces + impImplicitPlaceArcs ) ; Assert . assertEquals ( srcSignalTransitions , impSignalTransitions ) ; Assert . assertEquals ( srcDummyTransitions , impDummyTransitions ) ; framework . closeWork ( we ) ; } }
jrbeaumont/workcraft | for ( String testStgWork : COMPRESSED_HANDSHAKE_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; VisualStg stg = WorkspaceUtils . getAs ( we , VisualStg . class ) ; int srcPlaces = stg . getVisualPlaces ( ) . size ( ) ; int srcImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int srcSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int srcDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; int srcConnections = stg . getVisualConnections ( ) . size ( ) ; stg . selectAll ( ) ; ExpandHandshakeReqAckTransformationCommand command = new ExpandHandshakeReqAckTransformationCommand ( ) ; command . execute ( we ) ; int dstPlaces = stg . getVisualPlaces ( ) . size ( ) ; int dstImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int dstSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int dstDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; int dstConnections = stg . getVisualConnections ( ) . size ( ) ; Assert . assertEquals ( srcPlaces , dstPlaces ) ; Assert . assertEquals ( srcSignalTransitions * 2 , dstSignalTransitions ) ; Assert . assertEquals ( srcDummyTransitions , dstDummyTransitions ) ; Assert . assertEquals ( srcImplicitPlaceArcs + srcSignalTransitions , dstImplicitPlaceArcs ) ; Assert . assertEquals ( srcConnections + srcSignalTransitions , dstConnections ) ; framework . closeWork ( we ) ; }
acmi/L2unreal | @ Override protected int getOpcode ( ) { return OPCODE ; }
acmi/L2unreal | @ Override public String toString ( ) { return " Let ( " + left + " , ▁ " + right + ' ) ' ; }
acmi/L2unreal | @ Override public String toString ( UnrealRuntimeContext context ) { return left . toString ( context ) + " ▁ = ▁ " + right . toString ( context ) ; }
mogoweb/webkit_for_android5.1 | public WebResourceResponse ( String mimeType , String encoding , InputStream data ) { mMimeType = mimeType ; mEncoding = encoding ; mInputStream = data ; }
mogoweb/webkit_for_android5.1 | public WebResourceResponse ( String mimeType , String encoding , int statusCode , String reasonPhrase , Map < String , String > responseHeaders , InputStream data ) { this ( mimeType , encoding , data ) ; setStatusCodeAndReasonPhrase ( statusCode , reasonPhrase ) ; setResponseHeaders ( responseHeaders ) ; }
mogoweb/webkit_for_android5.1 | public void setMimeType ( String mimeType ) { mMimeType = mimeType ; }
mogoweb/webkit_for_android5.1 | public String getMimeType ( ) { return mMimeType ; }
mogoweb/webkit_for_android5.1 | public void setEncoding ( String encoding ) { mEncoding = encoding ; }
mogoweb/webkit_for_android5.1 | public String getEncoding ( ) { return mEncoding ; }
mogoweb/webkit_for_android5.1 | public void setStatusCodeAndReasonPhrase ( int statusCode , String reasonPhrase ) { if ( statusCode < 100 ) throw new IllegalArgumentException ( " statusCode ▁ can ' t ▁ be ▁ less ▁ than ▁ 100 . " ) ; if ( statusCode > 599 ) throw new IllegalArgumentException ( " statusCode ▁ can ' t ▁ be ▁ greater ▁ than ▁ 599 . " ) ; if ( statusCode > 299 && statusCode < 400 ) throw new IllegalArgumentException ( " statusCode ▁ can ' t ▁ be ▁ in ▁ the ▁ [ 300 , ▁ 399 ] ▁ range . " ) ; if ( reasonPhrase == null ) throw new IllegalArgumentException ( " reasonPhrase ▁ can ' t ▁ be ▁ null . " ) ; if ( reasonPhrase . trim ( ) . isEmpty ( ) ) throw new IllegalArgumentException ( " reasonPhrase ▁ can ' t ▁ be ▁ empty . " ) ; for ( int i = 0 ; i < reasonPhrase . length ( ) ; i ++ ) { int c = reasonPhrase . charAt ( i ) ; if ( c > 0x7F ) { throw new IllegalArgumentException ( " reasonPhrase ▁ can ' t ▁ contain ▁ non - ASCII ▁ characters . " ) ; } } mStatusCode = statusCode ; mReasonPhrase = reasonPhrase ; }
mogoweb/webkit_for_android5.1 | public int getStatusCode ( ) { return mStatusCode ; }
mogoweb/webkit_for_android5.1 | public String getReasonPhrase ( ) { return mReasonPhrase ; }
mogoweb/webkit_for_android5.1 | public void setResponseHeaders ( Map < String , String > headers ) { mResponseHeaders = headers ; }
mogoweb/webkit_for_android5.1 | public Map < String , String > getResponseHeaders ( ) { return mResponseHeaders ; }
mogoweb/webkit_for_android5.1 | public void setData ( InputStream data ) { mInputStream = data ; }
mogoweb/webkit_for_android5.1 | public InputStream getData ( ) { return mInputStream ; }
apache/skywalking | @ Override public void reportInstanceProperties ( final InstanceProperties request , final StreamObserver < Commands > responseObserver ) { delegate . reportInstanceProperties ( request , responseObserver ) ; }
apache/skywalking | @ Override public void keepAlive ( final InstancePingPkg request , final StreamObserver < Commands > responseObserver ) { delegate . keepAlive ( request , responseObserver ) ; }
droolsjbpm/droolsjbpm-integration | @ Before public void prepareSession ( ) { kieSession = kieContainer . newKieSession ( ) ; results = new ArrayList < > ( ) ; kieSession . setGlobal ( " results " , results ) ; }
droolsjbpm/droolsjbpm-integration | @ After public void disposeSession ( ) { if ( kieSession != null ) { kieSession . dispose ( ) ; } results = null ; }
droolsjbpm/droolsjbpm-integration | @ Test public void testLoadingKJarAndFiringRules ( ) { final String dogName = " Azor " ; final Person person = new Person ( " Bruno " , 17 ) ; person . addPet ( new Dog ( dogName , 2 ) ) ; kieSession . insert ( person ) ; kieSession . fireAllRules ( ) ; assertThat ( results ) . containsExactlyInAnyOrder ( dogName ) ; }
droolsjbpm/droolsjbpm-integration | @ Test public void testOOPathReactivityWithInstrumentedModel ( ) { final Person person = new Person ( " Bruno " , 17 ) ; FactHandle fh = kieSession . insert ( person ) ; kieSession . fireAllRules ( ) ; assertThat ( results ) . isEmpty ( ) ; person . setAge ( 18 ) ; kieSession . update ( fh , person ) ; kieSession . fireAllRules ( ) ; assertThat ( results ) . containsExactlyInAnyOrder ( " Lassie " , " The ▁ Cat " ) ; }
yafengguo/Apache-beam | BoundedReadEvaluatorFactory ( EvaluationContext evaluationContext ) { this ( evaluationContext , REQUIRED_DYNAMIC_SPLIT_ORIGINAL_SIZE ) ; }
yafengguo/Apache-beam | @ VisibleForTesting BoundedReadEvaluatorFactory ( EvaluationContext evaluationContext , long minimumDynamicSplitSize ) { this . evaluationContext = evaluationContext ; this . minimumDynamicSplitSize = minimumDynamicSplitSize ; }
yafengguo/Apache-beam | ) @ Override @ Nullable public < InputT > TransformEvaluator < InputT > forApplication ( AppliedPTransform < ? , ? , ? > application , CommittedBundle < ? > inputBundle ) throws IOException { return createEvaluator ( ( AppliedPTransform ) application ) ; }
yafengguo/Apache-beam | private < OutputT > TransformEvaluator < ? > createEvaluator ( final AppliedPTransform < ? , PCollection < OutputT > , ? > transform ) { return new BoundedReadEvaluator < > ( transform , evaluationContext , minimumDynamicSplitSize , executor ) ; }
yafengguo/Apache-beam | @ Override public void cleanup ( ) { }
yafengguo/Apache-beam | public BoundedReadEvaluator ( AppliedPTransform < ? , PCollection < OutputT > , ? > transform , EvaluationContext evaluationContext , long minimumDynamicSplitSize , ExecutorService executor ) { this . transform = transform ; this . evaluationContext = evaluationContext ; resultBuilder = StepTransformResult . withoutHold ( transform ) ; this . minimumDynamicSplitSize = minimumDynamicSplitSize ; this . produceSplitExecutor = executor ; }
yafengguo/Apache-beam | @ Override public void processElement ( WindowedValue < BoundedSourceShard < OutputT > > element ) throws Exception { BoundedSource < OutputT > source = element . getValue ( ) . getSource ( ) ; try ( final BoundedReader < OutputT > reader = source . createReader ( evaluationContext . getPipelineOptions ( ) ) ) { boolean contentsRemaining = reader . start ( ) ; Future < BoundedSource < OutputT > > residualFuture = startDynamicSplitThread ( source , reader ) ; UncommittedBundle < OutputT > output = evaluationContext . createBundle ( transform . getOutput ( ) ) ; while ( contentsRemaining ) { output . add ( WindowedValue . timestampedValueInGlobalWindow ( reader . getCurrent ( ) , reader . getCurrentTimestamp ( ) ) ) ; contentsRemaining = reader . advance ( ) ; } resultBuilder . addOutput ( output ) ; try { BoundedSource < OutputT > residual = residualFuture . get ( ) ; if ( residual != null ) { resultBuilder . addUnprocessedElements ( element . withValue ( BoundedSourceShard . of ( residual ) ) ) ; } } catch ( ExecutionException exex ) { throw UserCodeException . wrap ( exex . getCause ( ) ) ; } } }
yafengguo/Apache-beam | private Future < BoundedSource < OutputT > > startDynamicSplitThread ( BoundedSource < OutputT > source , BoundedReader < OutputT > reader ) throws Exception { if ( source . getEstimatedSizeBytes ( evaluationContext . getPipelineOptions ( ) ) > minimumDynamicSplitSize ) { return produceSplitExecutor . submit ( new GenerateSplitAtHalfwayPoint < > ( reader ) ) ; } else { SettableFuture < BoundedSource < OutputT > > emptyFuture = SettableFuture . create ( ) ; emptyFuture . set ( null ) ; return emptyFuture ; } }
yafengguo/Apache-beam | @ Override public TransformResult finishBundle ( ) { return resultBuilder . build ( ) ; }
yafengguo/Apache-beam | InputProvider ( EvaluationContext evaluationContext ) { this . evaluationContext = evaluationContext ; }
yafengguo/Apache-beam | @ Override public Collection < CommittedBundle < BoundedSourceShard < T > > > getInitialInputs ( AppliedPTransform < PBegin , PCollection < T > , Read . Bounded < T > > transform , int targetParallelism ) throws Exception { BoundedSource < T > source = transform . getTransform ( ) . getSource ( ) ; PipelineOptions options = evaluationContext . getPipelineOptions ( ) ; long estimatedBytes = source . getEstimatedSizeBytes ( options ) ; long bytesPerBundle = estimatedBytes / targetParallelism ; List < ? extends BoundedSource < T > > bundles = source . splitIntoBundles ( bytesPerBundle , options ) ; ImmutableList . Builder < CommittedBundle < BoundedSourceShard < T > > > shards = ImmutableList . builder ( ) ; for ( BoundedSource < T > bundle : bundles ) { CommittedBundle < BoundedSourceShard < T > > inputShard = evaluationContext . < BoundedSourceShard < T > > createRootBundle ( ) . add ( WindowedValue . valueInGlobalWindow ( BoundedSourceShard . of ( bundle ) ) ) . commit ( BoundedWindow . TIMESTAMP_MAX_VALUE ) ; shards . add ( inputShard ) ; } return shards . build ( ) ; }
yafengguo/Apache-beam | private GenerateSplitAtHalfwayPoint ( BoundedReader < T > reader ) { this . reader = reader ; }
yafengguo/Apache-beam | @ Override public BoundedSource < T > call ( ) throws Exception { Double currentlyConsumed = reader . getFractionConsumed ( ) ; if ( currentlyConsumed == null || currentlyConsumed == 1.0 ) { return null ; } double halfwayBetweenCurrentAndCompletion = 0.5 + ( currentlyConsumed / 2 ) ; return reader . splitAtFraction ( halfwayBetweenCurrentAndCompletion ) ; }
FedericoPecora/meta-csp-framework | public MultiConstraint ( ) { this . constraints = null ; }
FedericoPecora/meta-csp-framework | public Constraint [ ] getInternalConstraints ( ) { if ( constraints == null ) constraints = this . createInternalConstraints ( this . scope ) ; return constraints ; }
FedericoPecora/meta-csp-framework | public void setPropagateLater ( ) { propagateImmediately = false ; }
FedericoPecora/meta-csp-framework | public void setPropagateImmediately ( ) { propagateImmediately = true ; }
FedericoPecora/meta-csp-framework | public boolean propagateImmediately ( ) { return propagateImmediately ; }
FedericoPecora/meta-csp-framework | @ Override public String getDescription ( ) { String ret = this . getClass ( ) . getSimpleName ( ) + " : ▁ [ " ; if ( this . getInternalConstraints ( ) != null ) { for ( int i = 0 ; i < this . getInternalConstraints ( ) . length ; i ++ ) { ret += this . getInternalConstraints ( ) [ i ] . getClass ( ) . getSimpleName ( ) ; if ( i != this . getInternalConstraints ( ) . length - 1 ) ret += " , " ; } } return ret + " ] " ; }
pac4j/pac4j | protected LdaptiveAuthenticatorBuilder ( ) { }
elminsterjimmy/java | public SequentialPuzzleSolver ( Puzzle < P , M > puzzle ) { super ( ) ; this . puzzle = puzzle ; }
elminsterjimmy/java | public List < M > solve ( ) { P pos = puzzle . initialPosition ( ) ; return search ( new Node < P , M > ( pos , null , null ) ) ; }
elminsterjimmy/java | private List < M > search ( Node < P , M > node ) { if ( ! seen . contains ( node . pos ) ) { seen . add ( node . pos ) ; if ( puzzle . isGoal ( node . pos ) ) { return node . asMoveList ( ) ; } for ( M move : puzzle . legalMoves ( node . pos ) ) { P pos = puzzle . move ( node . pos , move ) ; Node < P , M > child = new Node < P , M > ( pos , move , node ) ; List < M > result = search ( child ) ; if ( null != result ) { return result ; } } } return null ; }
elminsterjimmy/java | public Node ( P pos , M move , Node < P , M > prev ) { super ( ) ; this . pos = pos ; this . move = move ; this . prev = prev ; }
elminsterjimmy/java | List < M > asMoveList ( ) { List < M > solution = new LinkedList < M > ( ) ; for ( Node < P , M > n = this ; n . move != null ; n = n . prev ) { solution . add ( 0 , n . move ) ; } return solution ; }
gajen0981/FHIR-Server | @ Test public void testExtensionType ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . setPetName ( new StringDt ( " Fido " ) ) ; patient . getImportantDates ( ) . add ( new DateTimeDt ( "2010-01-02" ) ) ; patient . getImportantDates ( ) . add ( new DateTimeDt ( "2014-01-26T11:11:11" ) ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newXmlParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , containsString ( " < modifierExtension ▁ url = \" http : // example . com / dontuse # importantDates \" > < valueDateTime ▁ value = \" 2010-01-02 \" / > < / modifierExtension > " ) ) ; }
gajen0981/FHIR-Server | @ Test public void testEmptyExtensionType ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newXmlParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , not ( containsString ( " xtension " ) ) ) ; }
gajen0981/FHIR-Server | @ Test public void testEmptyExtensionTypeJson ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newJsonParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , not ( containsString ( " xtension " ) ) ) ; }
Nimco/sling | private Session getSession ( ) throws RepositoryException { return repository . loginAdministrative ( null ) ; }
Nimco/sling | private void ungetSession ( final Session session ) { if ( session != null ) { try { session . logout ( ) ; } catch ( Throwable t ) { log . error ( " Unable ▁ to ▁ log ▁ out ▁ of ▁ session : ▁ " + t . getMessage ( ) , t ) ; } } }
Nimco/sling | @ Override protected void activate ( ComponentContext componentContext ) { super . activate ( componentContext ) ; Dictionary < ? , ? > props = componentContext . getProperties ( ) ; Object propValue = props . get ( PROP_SELF_REGISTRATION_ENABLED ) ; if ( propValue instanceof Boolean ) { selfRegistrationEnabled = ( Boolean ) propValue ; } else if ( propValue instanceof String ) { selfRegistrationEnabled = Boolean . parseBoolean ( ( String ) propValue ) ; } else { selfRegistrationEnabled = DEFAULT_SELF_REGISTRATION_ENABLED ; } this . userAdminGroupName = OsgiUtil . toString ( props . get ( PAR_USER_ADMIN_GROUP_NAME ) , DEFAULT_USER_ADMIN_GROUP_NAME ) ; log . info ( " User ▁ Admin ▁ Group ▁ Name ▁ { } " , this . userAdminGroupName ) ; }
Nimco/sling | @ Override protected void deactivate ( ComponentContext context ) { super . deactivate ( context ) ; }
Nimco/sling | @ Override protected void handleOperation ( SlingHttpServletRequest request , AbstractPostResponse response , List < Modification > changes ) throws RepositoryException { Session session = request . getResourceResolver ( ) . adaptTo ( Session . class ) ; String principalName = request . getParameter ( SlingPostConstants . RP_NODE_NAME ) ; User user = createUser ( session , principalName , request . getParameter ( " pwd " ) , request . getParameter ( " pwdConfirm " ) , request . getRequestParameterMap ( ) , changes ) ; String userPath = null ; if ( user == null ) { if ( changes . size ( ) > 0 ) { Modification modification = changes . get ( 0 ) ; if ( modification . getType ( ) == ModificationType . CREATE ) { userPath = modification . getSource ( ) ; } } } else { userPath = AuthorizableResourceProvider . SYSTEM_USER_MANAGER_USER_PREFIX + user . getID ( ) ; } if ( userPath != null ) { response . setPath ( userPath ) ; response . setLocation ( externalizePath ( request , userPath ) ) ; } response . setParentLocation ( externalizePath ( request , AuthorizableResourceProvider . SYSTEM_USER_MANAGER_USER_PATH ) ) ; }
Nimco/sling | public User createUser ( Session jcrSession , String name , String password , String passwordConfirm , Map < String , ? > properties , List < Modification > changes ) throws RepositoryException { if ( jcrSession == null ) { throw new RepositoryException ( " JCR ▁ Session ▁ not ▁ found " ) ; } boolean administrator = false ; try { UserManager um = AccessControlUtil . getUserManager ( jcrSession ) ; User currentUser = ( User ) um . getAuthorizable ( jcrSession . getUserID ( ) ) ; administrator = currentUser . isAdmin ( ) ; if ( ! administrator ) { Authorizable userAdmin = um . getAuthorizable ( this . userAdminGroupName ) ; if ( userAdmin instanceof Group ) { boolean isMember = ( ( Group ) userAdmin ) . isMember ( currentUser ) ; if ( isMember ) { administrator = true ; } } } } catch ( Exception ex ) { log . warn ( " Failed ▁ to ▁ determine ▁ if ▁ the ▁ user ▁ is ▁ an ▁ admin , ▁ assuming ▁ not . ▁ Cause : ▁ " + ex . getMessage ( ) ) ; administrator = false ; } if ( ! administrator && ! selfRegistrationEnabled ) { throw new RepositoryException ( " Sorry , ▁ registration ▁ of ▁ new ▁ users ▁ is ▁ not ▁ currently ▁ enabled . ▁ ▁ Please ▁ try ▁ again ▁ later . " ) ; } if ( name == null || name . length ( ) == 0 ) { throw new RepositoryException ( " User ▁ name ▁ was ▁ not ▁ submitted " ) ; } if ( password == null ) { throw new RepositoryException ( " Password ▁ was ▁ not ▁ submitted " ) ; } if ( ! password . equals ( passwordConfirm ) ) { throw new RepositoryException ( " Password ▁ value ▁ does ▁ not ▁ match ▁ the ▁ confirmation ▁ password " ) ; } User user = null ; Session selfRegSession = jcrSession ; boolean useAdminSession = ! administrator && selfRegistrationEnabled ; try { if ( useAdminSession ) { selfRegSession = getSession ( ) ; } UserManager userManager = AccessControlUtil . getUserManager ( selfRegSession ) ; Authorizable authorizable = userManager . getAuthorizable ( name ) ; if ( authorizable != null ) { throw new RepositoryException ( " A ▁ principal ▁ already ▁ exists ▁ with ▁ the ▁ requested ▁ name : ▁ " + name ) ; } else { user = userManager . createUser ( name , password ) ; String userPath = AuthorizableResourceProvider . SYSTEM_USER_MANAGER_USER_PREFIX + user . getID ( ) ; Map < String , RequestProperty > reqProperties = collectContent ( properties , userPath ) ; changes . add ( Modification . onCreated ( userPath ) ) ; writeContent ( selfRegSession , user , reqProperties , changes ) ; if ( selfRegSession . hasPendingChanges ( ) ) { selfRegSession . save ( ) ; } if ( useAdminSession ) { UserManager userManager2 = AccessControlUtil . getUserManager ( jcrSession ) ; Authorizable authorizable2 = userManager2 . getAuthorizable ( user . getID ( ) ) ; if ( authorizable2 instanceof User ) { user = ( User ) authorizable2 ; } else { user = null ; } } } } finally { if ( useAdminSession ) { ungetSession ( selfRegSession ) ; } } return user ; }
kouddy/SoftwareTestingTool | public String run ( String executableLine , OutputType t ) throws Exception { Process proc ; Runtime rt = Runtime . getRuntime ( ) ; String result ; proc = rt . exec ( executableLine . toString ( ) ) ; ThreadedOutputStream out = new ThreadedOutputStream ( proc . getInputStream ( ) ) ; out . start ( ) ; ThreadedOutputStream err = new ThreadedOutputStream ( proc . getErrorStream ( ) ) ; err . start ( ) ; int exitValue = proc . waitFor ( ) ; out . join ( ) ; err . join ( ) ; proc . destroy ( ) ; result = ( OutputType . STDOUT == t ) ? out . getString ( ) : err . getString ( ) ; err = null ; out = null ; return result ; }
ineiros/jbake | public JadeTemplateEngine ( final CompositeConfiguration config , final ContentStore db , final File destination , final File templatesPath ) { super ( config , db , destination , templatesPath ) ; TemplateLoader loader = new FileTemplateLoader ( templatesPath . getAbsolutePath ( ) + File . separatorChar , config . getString ( Keys . TEMPLATE_ENCODING ) ) ; jadeConfiguration . setTemplateLoader ( loader ) ; jadeConfiguration . setMode ( Jade4J . Mode . XHTML ) ; jadeConfiguration . setPrettyPrint ( true ) ; jadeConfiguration . setFilter ( FILTER_CDATA , new CDATAFilter ( ) ) ; jadeConfiguration . setFilter ( FILTER_SCRIPT , new JsFilter ( ) ) ; jadeConfiguration . setFilter ( FILTER_STYLE , new CssFilter ( ) ) ; jadeConfiguration . getSharedVariables ( ) . put ( " formatter " , new FormatHelper ( ) ) ; }
ineiros/jbake | @ Override public void renderDocument ( Map < String , Object > model , String templateName , Writer writer ) throws RenderingException { try { JadeTemplate template = jadeConfiguration . getTemplate ( templateName ) ; renderTemplate ( template , model , writer ) ; } catch ( IOException e ) { throw new RenderingException ( e ) ; } }
ineiros/jbake | public void renderTemplate ( JadeTemplate template , Map < String , Object > model , Writer writer ) throws JadeCompilerException { JadeModel jadeModel = wrap ( jadeConfiguration . getSharedVariables ( ) ) ; jadeModel . putAll ( model ) ; template . process ( jadeModel , writer ) ; }
ineiros/jbake | private JadeModel wrap ( final Map < String , Object > model ) { return new JadeModel ( model ) { @ Override public Object get ( final Object property ) { String key = property . toString ( ) ; try { return extractors . extractAndTransform ( db , key , model , new TemplateEngineAdapter . NoopAdapter ( ) ) ; } catch ( NoModelExtractorException e ) { } return super . get ( property ) ; } } ; }
ineiros/jbake | public String format ( Date date , String pattern ) { if ( date != null && pattern != null ) { SimpleDateFormat df = formatters . get ( pattern ) ; if ( df == null ) { df = new SimpleDateFormat ( pattern ) ; formatters . put ( pattern , df ) ; } return df . format ( date ) ; } else { return " " ; } }
ineiros/jbake | public String escape ( String s ) { return StringEscapeUtils . escapeHtml ( s ) ; }
kaaaaang/ews-java-api | protected SubscribeToPushNotificationsRequest ( ExchangeService service ) throws Exception { super ( service ) ; }
kaaaaang/ews-java-api | @ Override protected void validate ( ) throws Exception { super . validate ( ) ; EwsUtilities . validateParam ( this . getUrl ( ) , " Url " ) ; if ( ( this . getFrequency ( ) < 1 ) || ( this . getFrequency ( ) > 1440 ) ) { throw new ArgumentException ( String . format ( Strings . InvalidFrequencyValue , this . getFrequency ( ) ) ) ; } }
kaaaaang/ews-java-api | @ Override protected String getSubscriptionXmlElementName ( ) { return XmlElementNames . PushSubscriptionRequest ; }
kaaaaang/ews-java-api | @ Override protected SubscribeResponse < PushSubscription > createServiceResponse ( ExchangeService service , int responseIndex ) throws Exception { return new SubscribeResponse < PushSubscription > ( new PushSubscription ( service ) ) ; }
kaaaaang/ews-java-api | @ Override protected ExchangeVersion getMinimumRequiredServerVersion ( ) { return ExchangeVersion . Exchange2007_SP1 ; }
kaaaaang/ews-java-api | public int getFrequency ( ) { return this . frequency ; }
kaaaaang/ews-java-api | public void setFrequency ( int frequency ) { this . frequency = frequency ; }
kaaaaang/ews-java-api | public URI getUrl ( ) { return this . url ; }
kaaaaang/ews-java-api | public void setUrl ( URI url ) { this . url = url ; }
GunoH/intellij-community | @ NotNull @ Override protected String getActionName ( ) { return SvnBundle . message ( " action . Subversion . Unlock . description " ) ; }
GunoH/intellij-community | @ Override protected boolean isEnabled ( @ NotNull SvnVcs vcs , @ NotNull VirtualFile file ) { return ! file . isDirectory ( ) && SvnStatusUtil . isExplicitlyLocked ( vcs , file ) ; }
GunoH/intellij-community | @ Override protected void perform ( @ NotNull SvnVcs vcs , @ NotNull VirtualFile file , @ NotNull DataContext context ) throws VcsException { batchPerform ( vcs , ar ( file ) , context ) ; }
GunoH/intellij-community | @ Override protected void batchPerform ( @ NotNull SvnVcs vcs , VirtualFile @ NotNull [ ] files , @ NotNull DataContext context ) throws VcsException { SvnUtil . doUnlockFiles ( vcs . getProject ( ) , vcs , toIoFiles ( files ) ) ; }
GunoH/intellij-community | @ Override protected boolean isBatchAction ( ) { return true ; }
googleapis/google-api-java-client-services | public CloudSqlConnectionProfile getCloudsql ( ) { return cloudsql ; }
googleapis/google-api-java-client-services | public ConnectionProfile setCloudsql ( CloudSqlConnectionProfile cloudsql ) { this . cloudsql = cloudsql ; return this ; }
googleapis/google-api-java-client-services | public String getCreateTime ( ) { return createTime ; }
googleapis/google-api-java-client-services | public ConnectionProfile setCreateTime ( String createTime ) { this . createTime = createTime ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getDisplayName ( ) { return displayName ; }
googleapis/google-api-java-client-services | public ConnectionProfile setDisplayName ( java . lang . String displayName ) { this . displayName = displayName ; return this ; }
googleapis/google-api-java-client-services | public Status getError ( ) { return error ; }
googleapis/google-api-java-client-services | public ConnectionProfile setError ( Status error ) { this . error = error ; return this ; }
googleapis/google-api-java-client-services | public java . util . Map < String , java . lang . String > getLabels ( ) { return labels ; }
googleapis/google-api-java-client-services | public ConnectionProfile setLabels ( java . util . Map < String , java . lang . String > labels ) { this . labels = labels ; return this ; }
googleapis/google-api-java-client-services | public MySqlConnectionProfile getMysql ( ) { return mysql ; }
googleapis/google-api-java-client-services | public ConnectionProfile setMysql ( MySqlConnectionProfile mysql ) { this . mysql = mysql ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getName ( ) { return name ; }
googleapis/google-api-java-client-services | public ConnectionProfile setName ( java . lang . String name ) { this . name = name ; return this ; }
googleapis/google-api-java-client-services | public PostgreSqlConnectionProfile getPostgresql ( ) { return postgresql ; }
googleapis/google-api-java-client-services | public ConnectionProfile setPostgresql ( PostgreSqlConnectionProfile postgresql ) { this . postgresql = postgresql ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getProvider ( ) { return provider ; }
googleapis/google-api-java-client-services | public ConnectionProfile setProvider ( java . lang . String provider ) { this . provider = provider ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getState ( ) { return state ; }
googleapis/google-api-java-client-services | public ConnectionProfile setState ( java . lang . String state ) { this . state = state ; return this ; }
googleapis/google-api-java-client-services | public String getUpdateTime ( ) { return updateTime ; }
googleapis/google-api-java-client-services | public ConnectionProfile setUpdateTime ( String updateTime ) { this . updateTime = updateTime ; return this ; }
googleapis/google-api-java-client-services | @ Override public ConnectionProfile set ( String fieldName , Object value ) { return ( ConnectionProfile ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public ConnectionProfile clone ( ) { return ( ConnectionProfile ) super . clone ( ) ; }
ys305751572/shouye | @ Override public void queryBefore ( AopContext ac ) { setParma ( " userId " , ac ) ; String keyWord = this . getRecord ( ) . getStr ( " keyWord " ) ; StringBuffer whereBuffer = new StringBuffer ( ) ; whereBuffer . append ( " ▁ and ▁ ( " ) . append ( " ▁ province _ city ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ school ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ career ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ domain ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ professional ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ product _ service _ name ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ organization ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zy ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zl ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ sc ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zy2 ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ industry _ ranking ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ qualification ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ key _ word ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' " ) ; ac . setCondition ( whereBuffer . toString ( ) ) ; super . queryBefore ( ac ) ; }
3dcitydb/importer-exporter | public ExportCounter ( SchemaMapping schemaMapping ) { this . schemaMapping = schemaMapping ; objectCounter = new HashMap < > ( ) ; geometryCounter = new HashMap < > ( ) ; counterWalker = new CounterWalker ( ) ; }
3dcitydb/importer-exporter | public void updateExportCounter ( AbstractGML object ) { object . accept ( counterWalker ) ; }
3dcitydb/importer-exporter | private void updateObjectCounter ( int objectClassId ) { Long counter = objectCounter . get ( objectClassId ) ; if ( counter == null ) objectCounter . put ( objectClassId , 1L ) ; else objectCounter . put ( objectClassId , counter + 1 ) ; }
3dcitydb/importer-exporter | private void updateGeometryCounter ( GMLClass type ) { Long counter = geometryCounter . get ( type ) ; if ( counter == null ) geometryCounter . put ( type , 1L ) ; else geometryCounter . put ( type , counter + 1 ) ; }
3dcitydb/importer-exporter | public Map < Integer , Long > getAndResetObjectCounter ( ) { Map < Integer , Long > tmp = new HashMap < > ( objectCounter ) ; objectCounter . clear ( ) ; return tmp ; }
3dcitydb/importer-exporter | public Map < GMLClass , Long > getAndResetGeometryCounter ( ) { Map < GMLClass , Long > tmp = new HashMap < > ( geometryCounter ) ; geometryCounter . clear ( ) ; return tmp ; }
3dcitydb/importer-exporter | public void visit ( AbstractGML object ) { AbstractObjectType < ? > type = schemaMapping . getAbstractObjectType ( Util . getObjectClassId ( object . getClass ( ) ) ) ; if ( type != null ) updateObjectCounter ( type . getObjectClassId ( ) ) ; else if ( object instanceof ImplicitGeometry ) updateObjectCounter ( MappingConstants . IMPLICIT_GEOMETRY_OBJECTclass_ID ) ; }
3dcitydb/importer-exporter | public void visit ( AbstractSurfaceData surfaceData ) { }
3dcitydb/importer-exporter | public void visit ( Address address ) { }
3dcitydb/importer-exporter | public void visit ( AbstractGeometry geometry ) { updateGeometryCounter ( geometry . getGMLClass ( ) ) ; }
google/intellij-protocol-buffer-editor | public PbTextFileImpl ( @ NotNull FileViewProvider viewProvider , @ NotNull Language language ) { super ( viewProvider , language ) ; }
google/intellij-protocol-buffer-editor | @ NotNull @ Override public FileType getFileType ( ) { return PbTextFileType . INSTANCE ; }
google/intellij-protocol-buffer-editor | @ Override public PbTextRootMessage getRootMessage ( ) { return this ; }
google/intellij-protocol-buffer-editor | @ Override @ Nullable public SchemaInfo getSchemaInfo ( ) { return CachedValuesManager . getCachedValue ( this , ( ) -> CachedValueProvider . Result . create ( SchemaProvider . forFile ( this ) , PsiModificationTracker . MODIFICATION_COUNT ) ) ; }
google/intellij-protocol-buffer-editor | @ Override public String toString ( ) { return " Protocol ▁ Buffer ▁ Text ▁ File " ; }
liyanippon/working | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; init ( ) ; }
liyanippon/working | private void init ( ) { gesture = ( Button ) findViewById ( R . id . gesture ) ; gesture . setOnClickListener ( this ) ; }
liyanippon/working | @ Override public void onClick ( View view ) { switch ( view . getId ( ) ) { case R . id . gesture : Log . d ( " MainActivity " , " gesture " ) ; in = new Intent ( MainActivity . this , GestureLockActivity . class ) ; startActivity ( in ) ; break ; } }
hakanmhmd/algorithms-and-data-structures | public Client ( ) { shapes = new ArrayList < Shape > ( ) ; }
hakanmhmd/algorithms-and-data-structures | public void readShapes ( String [ ] shapes ) { for ( String shape : shapes ) { this . shapes . add ( Shape . create ( shape ) ) ; } }
hakanmhmd/algorithms-and-data-structures | public void drawShapes ( ) { for ( Shape shape : shapes ) { shape . draw ( ) ; } }
Xylus/pinpoint | public ByteArrayHeaderReader ( byte [ ] bytes ) { this ( checkBytes ( bytes ) , 0 , bytes . length ) ; }
Xylus/pinpoint | public ByteArrayHeaderReader ( byte [ ] bytes , final int startOffset , final int length ) { checkBytes ( bytes ) ; this . buffer = new OffsetFixedBuffer ( bytes , startOffset , length ) ; }
Xylus/pinpoint | public Header readHeader ( ) { final byte signature = buffer . readByte ( ) ; if ( signature != Header . SIGNATURE ) { throw new InvalidHeaderException ( " invalid ▁ signature ▁ : " + signature ) ; } final byte version = buffer . readByte ( ) ; final short type = buffer . readShort ( ) ; if ( version == HeaderV1 . VERSION ) { return new HeaderV1 ( signature , version , type ) ; } if ( version == HeaderV2 . VERSION ) { return new HeaderV2 ( signature , version , type ) ; } throw new InvalidHeaderException ( String . format ( " invalid ▁ Header ▁ : ▁ signature ( 0x % 02X ) , ▁ version ( 0x % 02X ) " , signature , version ) ) ; }
Xylus/pinpoint | public HeaderEntity readHeaderEntity ( Header header ) { final byte version = header . getVersion ( ) ; if ( version == HeaderV1 . VERSION ) { return HeaderEntity . EMPTY_HEADER_ENTITY ; } if ( version == HeaderV2 . VERSION ) { return readHeaderEntity ( ) ; } throw new InvalidHeaderException ( " invalid ▁ Header ▁ : ▁ " + header ) ; }
Xylus/pinpoint | private HeaderEntity readHeaderEntity ( ) { final short headerEntitySize = buffer . readShort ( ) ; if ( headerEntitySize < 0 || headerEntitySize > HeaderV2 . HEADER_ENTITY_COUNT_MAX_SIZE ) { throw new InvalidHeaderException ( " header ▁ entity ▁ count ▁ size ▁ is ▁ invalid . ▁ size ▁ : ▁ " + headerEntitySize ) ; } if ( headerEntitySize == 0 ) { return HeaderEntity . EMPTY_HEADER_ENTITY ; } final Map < String , String > headerEntity = new HashMap < String , String > ( headerEntitySize ) ; for ( int i = 0 ; i < headerEntitySize ; i ++ ) { final String key = readString ( ) ; final String value = readString ( ) ; headerEntity . put ( key , value ) ; } return new HeaderEntity ( headerEntity ) ; }
Xylus/pinpoint | private String readString ( ) { final short stringLength = buffer . readShort ( ) ; if ( ! validCheck ( stringLength ) ) { throw new InvalidHeaderException ( " string ▁ length ▁ is ▁ invalid ▁ in ▁ header ▁ data . ▁ length ▁ : ▁ " + stringLength ) ; } buffer . setOffset ( buffer . getOffset ( ) - 2 ) ; return buffer . read2PrefixedString ( ) ; }
Xylus/pinpoint | private boolean validCheck ( short length ) { if ( length > HeaderV2 . HEADER_ENTITY_STRING_MAX_LANGTH || length == 0 ) { return false ; } return true ; }
Xylus/pinpoint | @ Override public int getOffset ( ) { return this . buffer . getOffset ( ) ; }
Xylus/pinpoint | @ Override public int getRemaining ( ) { return this . buffer . remaining ( ) ; }
0x1mason/selendroid | public ShellCommandException ( String message ) { super ( message ) ; }
0x1mason/selendroid | public ShellCommandException ( Throwable t ) { super ( t ) ; }
0x1mason/selendroid | public ShellCommandException ( String message , Throwable t ) { super ( message , t ) ; }
mzhu22/SimpleLogo | public TurtleStatsWindow ( double x , double y , double width , double height , TurtleCollection turtles ) { super ( x , y , width , height , " \t " + GUI_NAMES . getString ( " Stats " ) + " \n " ) ; myTurtleCollection = turtles ; }
mzhu22/SimpleLogo | @ Override public void updatePane ( ) { finalOutput = initialString ; myTurtleCollection . setActiveTurtles ( ) ; for ( Turtle myTurtle : myTurtleCollection ) { Map < String , String > turtleInfo = new TreeMap < String , String > ( ) ; turtleInfo . put ( GUI_NAMES . getString ( " X " ) + " : " , ( ( Long ) Math . round ( ( myTurtle . getX ( ) - CANVAS_WIDTH / 2 ) ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " Y " ) + " : " , ( ( Long ) Math . round ( - 1 * ( myTurtle . getY ( ) - CANVAS_HEIGHT / 2 ) ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " Heading " ) + " : " , ( ( Long ) Math . round ( myTurtle . getDirection ( ) ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " Showing " ) + " : " , ( ( Boolean ) myTurtle . isShowing ( ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " PenDown " ) + " : " , ( ( Boolean ) myTurtle . getPen ( ) . isPenDown ( ) ) . toString ( ) ) ; for ( String s : turtleInfo . keySet ( ) ) { finalOutput += s + " \t " + turtleInfo . get ( s ) + " \n " ; } finalOutput += " \n " ; } super . updatePane ( ) ; }
brightchen/pcap4j | while ( true ) { try { Packet packet = handle . getNextPacketEx ( ) ; Short id = packet . get ( IpV4Packet . class ) . getHeader ( ) . getIdentification ( ) ; if ( ipV4Packets . containsKey ( id ) ) { ipV4Packets . get ( id ) . add ( packet . get ( IpV4Packet . class ) ) ; } else { List < IpV4Packet > list = new ArrayList < IpV4Packet > ( ) ; list . add ( packet . get ( IpV4Packet . class ) ) ; ipV4Packets . put ( id , list ) ; originalPackets . put ( id , packet ) ; } } catch ( TimeoutException e ) { continue ; } catch ( EOFException e ) { break ; } }
brightchen/pcap4j | for ( Short id : ipV4Packets . keySet ( ) ) { List < IpV4Packet > list = ipV4Packets . get ( id ) ; final IpV4Packet defragmentedIpV4Packet = IpV4Helper . defragment ( list ) ; Packet . Builder builder = originalPackets . get ( id ) . getBuilder ( ) ; builder . getOuterOf ( IpV4Packet . Builder . class ) . payloadBuilder ( new SimpleBuilder ( defragmentedIpV4Packet ) ) ; System . out . println ( builder . build ( ) ) ; }
camelgroup/back2home_cliente | public TipoMascota ( ) { }
camelgroup/back2home_cliente | public Integer getPktipoMascota ( ) { return pktipoMascota ; }
camelgroup/back2home_cliente | public void setPktipoMascota ( Integer pktipoMascota ) { this . pktipoMascota = pktipoMascota ; }
camelgroup/back2home_cliente | public String getNombre ( ) { return nombre ; }
camelgroup/back2home_cliente | public void setNombre ( String nombre ) { this . nombre = nombre ; }
GitLqr/MaterialDesignDemo | @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_recycler_view ) ; mRv = ( RecyclerView ) findViewById ( R . id . rv ) ; initData ( ) ; initView ( ) ; setRecyclerView ( ) ; }
GitLqr/MaterialDesignDemo | private void initView ( ) { MyDecorationThree decorationThree = new MyDecorationThree ( this , mData ) ; mRv . addItemDecoration ( decorationThree ) ; }
GitLqr/MaterialDesignDemo | private void initData ( ) { mData = Arrays . asList ( Cheeses . NAMES ) ; Collections . sort ( mData , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return PinyinUtils . getPinyin ( o1 ) . compareTo ( PinyinUtils . getPinyin ( o2 ) ) ; } } ) ; }
GitLqr/MaterialDesignDemo | private void setRecyclerView ( ) { mMyAdapter = new MyAdapter ( mData ) ; mRv . setLayoutManager ( new LinearLayoutManager ( this ) ) ; mRv . setAdapter ( mMyAdapter ) ; }
JoelMarcey/buck | public Groovyc ( Supplier < ? extends SourcePath > path , boolean external ) { this . path = path ; this . external = external ; }
JoelMarcey/buck | public Groovyc ( SourcePath path , boolean external ) { this ( ( ) -> Objects . requireNonNull ( path ) , external ) ; }
JoelMarcey/buck | @ Override public ImmutableList < String > getCommandPrefix ( SourcePathResolverAdapter resolver ) { AbsPath toolPath = resolver . getAbsolutePath ( path . get ( ) ) ; if ( ! external ) { toolPath = toolPath . resolve ( BIN_GROOVYC ) ; } return ImmutableList . of ( toolPath . toString ( ) ) ; }
JoelMarcey/buck | @ Override public ImmutableMap < String , String > getEnvironment ( SourcePathResolverAdapter resolver ) { return ImmutableMap . of ( ) ; }
freeVM/freeVM | public boolean isCellEditable ( final EventObject e ) { return true ; }
freeVM/freeVM | public boolean shouldSelectCell ( final EventObject event ) { return true ; }
freeVM/freeVM | public boolean stopCellEditing ( ) { fireEditingStopped ( ) ; return true ; }
freeVM/freeVM | public void cancelCellEditing ( ) { fireEditingCanceled ( ) ; }
freeVM/freeVM | public void addCellEditorListener ( final CellEditorListener l ) { listenerList . add ( CellEditorListener . class , l ) ; }
freeVM/freeVM | public void removeCellEditorListener ( final CellEditorListener l ) { listenerList . remove ( CellEditorListener . class , l ) ; }
freeVM/freeVM | public CellEditorListener [ ] getCellEditorListeners ( ) { return listenerList . getListeners ( CellEditorListener . class ) ; }
freeVM/freeVM | protected void fireEditingStopped ( ) { CellEditorListener [ ] listeners = getCellEditorListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { listeners [ i ] . editingStopped ( getChangeEvent ( ) ) ; } }
freeVM/freeVM | protected void fireEditingCanceled ( ) { CellEditorListener [ ] listeners = getCellEditorListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { listeners [ i ] . editingCanceled ( getChangeEvent ( ) ) ; } }
freeVM/freeVM | private ChangeEvent getChangeEvent ( ) { if ( changeEvent == null ) { changeEvent = new ChangeEvent ( this ) ; } return changeEvent ; }
Scottmitch/netty | private Http2TestUtil ( ) { }
Scottmitch/netty | FrameAdapter ( Http2FrameListener listener , CountDownLatch latch ) { this ( null , listener , latch ) ; }
Scottmitch/netty | FrameAdapter ( Http2Connection connection , Http2FrameListener listener , CountDownLatch latch ) { this ( connection , new DefaultHttp2FrameReader ( false ) , listener , latch ) ; }
Scottmitch/netty | FrameAdapter ( Http2Connection connection , DefaultHttp2FrameReader reader , Http2FrameListener listener , CountDownLatch latch ) { this . connection = connection ; this . listener = listener ; this . reader = reader ; this . latch = latch ; }
Scottmitch/netty | private Http2Stream getOrCreateStream ( int streamId , boolean halfClosed ) throws Http2Exception { return getOrCreateStream ( connection , streamId , halfClosed ) ; }
Scottmitch/netty | private void closeStream ( Http2Stream stream ) { closeStream ( stream , false ) ; }
Scottmitch/netty | protected void closeStream ( Http2Stream stream , boolean dataRead ) { if ( stream != null ) { stream . close ( ) ; } }
Scottmitch/netty | @ Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { reader . readFrame ( ctx , in , new Http2FrameListener ( ) { @ Override public int onDataRead ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , endOfStream ) ; int processed = listener . onDataRead ( ctx , streamId , data , padding , endOfStream ) ; if ( endOfStream ) { closeStream ( stream , true ) ; } latch . countDown ( ) ; return processed ; } @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , endStream ) ; listener . onHeadersRead ( ctx , streamId , headers , padding , endStream ) ; if ( endStream ) { closeStream ( stream ) ; } latch . countDown ( ) ; } @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endStream ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , endStream ) ; if ( stream != null ) { stream . setPriority ( streamDependency , weight , exclusive ) ; } listener . onHeadersRead ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endStream ) ; if ( endStream ) { closeStream ( stream ) ; } latch . countDown ( ) ; } @ Override public void onPriorityRead ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , false ) ; if ( stream != null ) { stream . setPriority ( streamDependency , weight , exclusive ) ; } listener . onPriorityRead ( ctx , streamId , streamDependency , weight , exclusive ) ; latch . countDown ( ) ; } @ Override public void onRstStreamRead ( ChannelHandlerContext ctx , int streamId , long errorCode ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , false ) ; listener . onRstStreamRead ( ctx , streamId , errorCode ) ; closeStream ( stream ) ; latch . countDown ( ) ; } @ Override public void onSettingsAckRead ( ChannelHandlerContext ctx ) throws Http2Exception { listener . onSettingsAckRead ( ctx ) ; latch . countDown ( ) ; } @ Override public void onSettingsRead ( ChannelHandlerContext ctx , Http2Settings settings ) throws Http2Exception { listener . onSettingsRead ( ctx , settings ) ; latch . countDown ( ) ; } @ Override public void onPingRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingRead ( ctx , data ) ; latch . countDown ( ) ; } @ Override public void onPingAckRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingAckRead ( ctx , data ) ; latch . countDown ( ) ; } @ Override public void onPushPromiseRead ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding ) throws Http2Exception { getOrCreateStream ( promisedStreamId , false ) ; listener . onPushPromiseRead ( ctx , streamId , promisedStreamId , headers , padding ) ; latch . countDown ( ) ; } @ Override public void onGoAwayRead ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData ) throws Http2Exception { listener . onGoAwayRead ( ctx , lastStreamId , errorCode , debugData ) ; latch . countDown ( ) ; } @ Override public void onWindowUpdateRead ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement ) throws Http2Exception { getOrCreateStream ( streamId , false ) ; listener . onWindowUpdateRead ( ctx , streamId , windowSizeIncrement ) ; latch . countDown ( ) ; } @ Override public void onUnknownFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload ) throws Http2Exception { listener . onUnknownFrame ( ctx , frameType , streamId , flags , payload ) ; latch . countDown ( ) ; } } ) ; }
Scottmitch/netty | FrameCountDown ( Http2FrameListener listener , CountDownLatch settingsAckLatch , CountDownLatch messageLatch ) { this ( listener , settingsAckLatch , messageLatch , null , null ) ; }
Scottmitch/netty | FrameCountDown ( Http2FrameListener listener , CountDownLatch settingsAckLatch , CountDownLatch messageLatch , CountDownLatch dataLatch , CountDownLatch trailersLatch ) { this ( listener , settingsAckLatch , messageLatch , dataLatch , trailersLatch , messageLatch ) ; }
Scottmitch/netty | FrameCountDown ( Http2FrameListener listener , CountDownLatch settingsAckLatch , CountDownLatch messageLatch , CountDownLatch dataLatch , CountDownLatch trailersLatch , CountDownLatch goAwayLatch ) { this . listener = listener ; this . messageLatch = messageLatch ; this . settingsAckLatch = settingsAckLatch ; this . dataLatch = dataLatch ; this . trailersLatch = trailersLatch ; this . goAwayLatch = goAwayLatch ; }
Scottmitch/netty | @ Override public int onDataRead ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { int numBytes = data . readableBytes ( ) ; int processed = listener . onDataRead ( ctx , streamId , data , padding , endOfStream ) ; messageLatch . countDown ( ) ; if ( dataLatch != null ) { for ( int i = 0 ; i < numBytes ; ++ i ) { dataLatch . countDown ( ) ; } } return processed ; }
Scottmitch/netty | @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream ) throws Http2Exception { listener . onHeadersRead ( ctx , streamId , headers , padding , endStream ) ; messageLatch . countDown ( ) ; if ( trailersLatch != null && endStream ) { trailersLatch . countDown ( ) ; } }
Scottmitch/netty | @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endStream ) throws Http2Exception { listener . onHeadersRead ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endStream ) ; messageLatch . countDown ( ) ; if ( trailersLatch != null && endStream ) { trailersLatch . countDown ( ) ; } }
Scottmitch/netty | @ Override public void onPriorityRead ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive ) throws Http2Exception { listener . onPriorityRead ( ctx , streamId , streamDependency , weight , exclusive ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onRstStreamRead ( ChannelHandlerContext ctx , int streamId , long errorCode ) throws Http2Exception { listener . onRstStreamRead ( ctx , streamId , errorCode ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onSettingsAckRead ( ChannelHandlerContext ctx ) throws Http2Exception { listener . onSettingsAckRead ( ctx ) ; settingsAckLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onSettingsRead ( ChannelHandlerContext ctx , Http2Settings settings ) throws Http2Exception { listener . onSettingsRead ( ctx , settings ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onPingRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingRead ( ctx , data ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onPingAckRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingAckRead ( ctx , data ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onPushPromiseRead ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding ) throws Http2Exception { listener . onPushPromiseRead ( ctx , streamId , promisedStreamId , headers , padding ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onGoAwayRead ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData ) throws Http2Exception { listener . onGoAwayRead ( ctx , lastStreamId , errorCode , debugData ) ; goAwayLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onWindowUpdateRead ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement ) throws Http2Exception { listener . onWindowUpdateRead ( ctx , streamId , windowSizeIncrement ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onUnknownFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload ) throws Http2Exception { listener . onUnknownFrame ( ctx , frameType , streamId , flags , payload ) ; messageLatch . countDown ( ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsTextGridFile ( ) { FormattedFile ff = new FormattedFile ( " blah . TextGrid " ) ; assertEquals ( FormattedFile . Format . TEXTGRID , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsBURNCFile ( ) { FormattedFile ff = new FormattedFile ( " blah . ala " ) ; assertEquals ( FormattedFile . Format . BURNC , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsBuckeyeFile ( ) { FormattedFile ff = new FormattedFile ( " s1234b . words " ) ; assertEquals ( FormattedFile . Format . BUCKEYE , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsSimpleWordFile ( ) { FormattedFile ff = new FormattedFile ( " file . words " ) ; assertEquals ( FormattedFile . Format . SIMPLE_WORD , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsSwitchboardFile ( ) { FormattedFile ff = new FormattedFile ( " file . terminals . xml " ) ; assertEquals ( FormattedFile . Format . SWB_NXT , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructorAndGetter ( ) { FormattedFile ff = new FormattedFile ( " test / file . name " , FormattedFile . Format . SWB_NXT ) ; assertEquals ( " test / file . name " , ff . getFilename ( ) ) ; assertEquals ( FormattedFile . Format . SWB_NXT , ff . getFormat ( ) ) ; }
hidekatsu-izuno/xmlic | DefaultNumberExpr ( Double number ) { this . number = number ; }
hidekatsu-izuno/xmlic | public Number getNumber ( ) { return this . number ; }
hidekatsu-izuno/xmlic | public String toString ( ) { return " [ ( DefaultNumberExpr ) : ▁ " + getNumber ( ) + " ] " ; }
hidekatsu-izuno/xmlic | public String getText ( ) { return getNumber ( ) . toString ( ) ; }
hidekatsu-izuno/xmlic | public Object evaluate ( Context context ) { return getNumber ( ) ; }
datalayer/zeppelin | public Mathjax ( Properties property ) { super ( property ) ; }
datalayer/zeppelin | @ Override public void open ( ) { }
datalayer/zeppelin | @ Override public void close ( ) { }
datalayer/zeppelin | @ Override public InterpreterResult interpret ( String text , InterpreterContext interpreterContext ) { return new InterpreterResult ( Code . SUCCESS , " % mathjax ▁ " + text ) ; }
datalayer/zeppelin | @ Override public void cancel ( InterpreterContext context ) { }
datalayer/zeppelin | @ Override public FormType getFormType ( ) { return FormType . SIMPLE ; }
datalayer/zeppelin | @ Override public int getProgress ( InterpreterContext context ) { return 0 ; }
datalayer/zeppelin | @ Override public Scheduler getScheduler ( ) { return SchedulerFactory . singleton ( ) . createOrGetParallelScheduler ( Mathjax . class . getName ( ) + this . hashCode ( ) , 5 ) ; }
datalayer/zeppelin | @ Override public List < InterpreterCompletion > completion ( String buf , int cursor , InterpreterContext interpreterContext ) { return null ; }
NatashaWso2/carbon-business-process | public void execute ( ) { HumanTaskServerConfiguration serverConfiguration = HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getServerConfig ( ) ; final SimpleQueryCriteria queryCriteria = createQueryCriteria ( serverConfiguration ) ; log . info ( " Running ▁ the ▁ task ▁ cleanup ▁ service . . . . . " ) ; try { HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getTaskEngine ( ) . getScheduler ( ) . execTransaction ( new Callable < Object > ( ) { public Object call ( ) throws Exception { HumanTaskDAOConnection daoConnection = HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getDaoConnectionFactory ( ) . getConnection ( ) ; daoConnection . removeTasks ( queryCriteria ) ; return null ; } } ) ; } catch ( Exception ex ) { String errMsg = " Task ▁ Cleanup ▁ operation ▁ failed ! ▁ : " ; log . error ( errMsg , ex ) ; throw new HumanTaskRuntimeException ( errMsg , ex ) ; } }
NatashaWso2/carbon-business-process | private SimpleQueryCriteria createQueryCriteria ( HumanTaskServerConfiguration serverConfiguration ) { SimpleQueryCriteria queryCriteria = new SimpleQueryCriteria ( ) ; queryCriteria . setSimpleQueryType ( SimpleQueryCriteria . QueryType . REMOVE_TASKS ) ; queryCriteria . setStatuses ( serverConfiguration . getRemovableTaskStatuses ( ) ) ; return queryCriteria ; }
CodeSmell/camel | public AmazonIdentityManagement getIamClient ( ) { return iamClient ; }
CodeSmell/camel | public void setIamClient ( AmazonIdentityManagement iamClient ) { this . iamClient = iamClient ; }
CodeSmell/camel | public String getAccessKey ( ) { return accessKey ; }
CodeSmell/camel | public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; }
CodeSmell/camel | public String getSecretKey ( ) { return secretKey ; }
CodeSmell/camel | public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; }
CodeSmell/camel | public IAMOperations getOperation ( ) { return operation ; }
CodeSmell/camel | public void setOperation ( IAMOperations operation ) { this . operation = operation ; }
CodeSmell/camel | public Protocol getProxyProtocol ( ) { return proxyProtocol ; }
CodeSmell/camel | public void setProxyProtocol ( Protocol proxyProtocol ) { this . proxyProtocol = proxyProtocol ; }
CodeSmell/camel | public String getProxyHost ( ) { return proxyHost ; }
CodeSmell/camel | public void setProxyHost ( String proxyHost ) { this . proxyHost = proxyHost ; }
CodeSmell/camel | public Integer getProxyPort ( ) { return proxyPort ; }
CodeSmell/camel | public void setProxyPort ( Integer proxyPort ) { this . proxyPort = proxyPort ; }
CodeSmell/camel | public String getRegion ( ) { return region ; }
CodeSmell/camel | public void setRegion ( String region ) { this . region = region ; }
CodeSmell/camel | public IAMConfiguration copy ( ) { try { return ( IAMConfiguration ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } }
ypresto/miniguava | ImmutableMapKeySet ( ImmutableMap < K , V > map ) { this . map = map ; }
ypresto/miniguava | @ Override public int size ( ) { return map . size ( ) ; }
ypresto/miniguava | @ Override public UnmodifiableIterator < K > iterator ( ) { return map . keyIterator ( ) ; }
ypresto/miniguava | @ Override public boolean contains ( @ Nullable Object object ) { return map . containsKey ( object ) ; }
ypresto/miniguava | @ Override K get ( int index ) { return map . entrySet ( ) . asList ( ) . get ( index ) . getKey ( ) ; }
ypresto/miniguava | @ Override boolean isPartialView ( ) { return true ; }
ypresto/miniguava | @ Override Object writeReplace ( ) { return new KeySetSerializedForm < K > ( map ) ; }
ypresto/miniguava | KeySetSerializedForm ( ImmutableMap < K , ? > map ) { this . map = map ; }
ypresto/miniguava | Object readResolve ( ) { return map . keySet ( ) ; }
beijunyi/ParallelGit | @ Before public void setupTargetSystem ( ) throws IOException { targetRepo = new TestRepository ( ) ; targetGfs = Gfs . newFileSystem ( targetRepo ) ; }
beijunyi/ParallelGit | @ After public void closeTargetSystem ( ) throws IOException { targetGfs . close ( ) ; targetRepo . close ( ) ; }
beijunyi/ParallelGit | @ Test public void moveFileToAnotherSystem_theTargetFileShouldExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source . txt " ) ; GitPath target = targetGfs . getPath ( " / target . txt " ) ; Files . move ( source , target ) ; assertTrue ( Files . exists ( target ) ) ; }
beijunyi/ParallelGit | @ Test public void moveFile_theSourceFileShouldNotExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source . txt " ) ; GitPath target = targetGfs . getPath ( " / target . txt " ) ; Files . move ( source , target ) ; assertFalse ( Files . exists ( source ) ) ; }
beijunyi/ParallelGit | @ Test public void moveFileToAnotherSystem_theTargetFileShouldHaveTheSameData ( ) throws IOException { initRepository ( ) ; byte [ ] expected = someBytes ( ) ; writeToCache ( " / source . txt " , expected ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source . txt " ) ; GitPath target = targetGfs . getPath ( " / target . txt " ) ; Files . move ( source , target ) ; assertArrayEquals ( expected , Files . readAllBytes ( target ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theTargetDirectoryShouldExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source / file . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertTrue ( Files . exists ( target ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theSourceDirectoryShouldNotExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source / file . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertFalse ( Files . exists ( source ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theTargetDirectoryShouldHaveTheSameChildren ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source / file1 . txt " ) ; writeToCache ( " / source / file2 . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertTrue ( Files . exists ( target . resolve ( " file1 . txt " ) ) ) ; assertTrue ( Files . exists ( target . resolve ( " file2 . txt " ) ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theChildrenInTheTargetDirectoryShouldHaveTheSameData ( ) throws IOException { initRepository ( ) ; byte [ ] expectedData1 = someBytes ( ) ; writeToCache ( " / source / file1 . txt " , expectedData1 ) ; byte [ ] expectedData2 = someBytes ( ) ; writeToCache ( " / source / file2 . txt " , expectedData2 ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertArrayEquals ( expectedData1 , Files . readAllBytes ( target . resolve ( " file1 . txt " ) ) ) ; assertArrayEquals ( expectedData2 , Files . readAllBytes ( target . resolve ( " file2 . txt " ) ) ) ; }
apache/directory-kerby | public DesCbcMd5Enc ( ) { super ( new Md5Provider ( ) ) ; }
apache/directory-kerby | public EncryptionType eType ( ) { return EncryptionType . DES_CBC_MD5 ; }
apache/directory-kerby | public CheckSumType checksumType ( ) { return CheckSumType . RSA_MD5_DES ; }
servioticy/servioticy-datamodel | public String getCurrentValue ( ) { return currentValue ; }
servioticy/servioticy-datamodel | public void setCurrentValue ( String currentValue ) { this . currentValue = currentValue ; }
servioticy/servioticy-datamodel | public String getUnit ( ) { return unit ; }
servioticy/servioticy-datamodel | public void setUnit ( String unit ) { this . unit = unit ; }
servioticy/servioticy-datamodel | public String getType ( ) { return type ; }
servioticy/servioticy-datamodel | public void setType ( String type ) { this . type = type ; }
hovsepm/azure-sdk-for-java | @ Ignore ( " Depends ▁ on ▁ the ▁ existing ▁ SQL ▁ server " ) @ Test public void canListRecommendedElasticPools ( ) throws Exception { SqlServer sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( " ans " , " ans - secondary " ) ; sqlServer . databases ( ) . list ( ) . get ( 0 ) . listServiceTierAdvisors ( ) . values ( ) . iterator ( ) . next ( ) . serviceLevelObjectiveUsageMetrics ( ) ; Map < String , RecommendedElasticPool > recommendedElasticPools = sqlServer . listRecommendedElasticPools ( ) ; Assert . assertNotNull ( recommendedElasticPools ) ; Assert . assertNotNull ( sqlServer . databases ( ) . list ( ) . get ( 0 ) . getUpgradeHint ( ) ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlServer ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; validateSqlServer ( sqlServer ) ; List < ServiceObjective > serviceObjectives = sqlServer . listServiceObjectives ( ) ; Assert . assertNotEquals ( serviceObjectives . size ( ) , 0 ) ; Assert . assertNotNull ( serviceObjectives . get ( 0 ) . refresh ( ) ) ; Assert . assertNotNull ( sqlServer . getServiceObjective ( " d1737d22 - a8ea - 4de7-9bd0-33395d2a7419" ) ) ; sqlServer . update ( ) . withAdministratorPassword ( " P @ ssword ~ 2" ) . apply ( ) ; List < SqlServer > sqlServers = sqlServerManager . sqlServers ( ) . listByResourceGroup ( RG_NAME ) ; boolean found = false ; for ( SqlServer server : sqlServers ) { if ( server . name ( ) . equals ( SQL_SERVER_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; Assert . assertNotNull ( sqlServer ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canUseCoolShortcutsForResourceCreation ( ) throws Exception { String database2Name = " database2" ; String database1InEPName = " database1InEP " ; String database2InEPName = " database2InEP " ; String elasticPool2Name = " elasticPool2" ; String elasticPool3Name = " elasticPool3" ; String elasticPool1Name = SQL_ELASTIC_POOL_NAME ; SqlServer sqlServer = sqlServerManager . sqlServers ( ) . define ( SQL_SERVER_NAME ) . withRegion ( Region . US_CENTRAL ) . withNewResourceGroup ( RG_NAME ) . withAdministratorLogin ( " userName " ) . withAdministratorPassword ( " Password ~ 1" ) . withNewDatabase ( SQL_DATABASE_NAME ) . withNewDatabase ( database2Name ) . withNewElasticPool ( elasticPool1Name , ElasticPoolEditions . STANDARD ) . withNewElasticPool ( elasticPool2Name , ElasticPoolEditions . PREMIUM , database1InEPName , database2InEPName ) . withNewElasticPool ( elasticPool3Name , ElasticPoolEditions . STANDARD ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS , SQL_FIREWALLRULE_NAME ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS ) . withNewFirewallRule ( START_IPADDRESS ) . create ( ) ; validateMultiCreation ( database2Name , database1InEPName , database2InEPName , elasticPool1Name , elasticPool2Name , elasticPool3Name , sqlServer , false ) ; elasticPool1Name = SQL_ELASTIC_POOL_NAME + " ▁ U " ; database2Name = " database2U " ; database1InEPName = " database1InEPU " ; database2InEPName = " database2InEPU " ; elasticPool2Name = " elasticPool2U " ; elasticPool3Name = " elasticPool3U " ; sqlServer = sqlServer . update ( ) . withNewDatabase ( SQL_DATABASE_NAME ) . withNewDatabase ( database2Name ) . withNewElasticPool ( elasticPool1Name , ElasticPoolEditions . STANDARD ) . withNewElasticPool ( elasticPool2Name , ElasticPoolEditions . PREMIUM , database1InEPName , database2InEPName ) . withNewElasticPool ( elasticPool3Name , ElasticPoolEditions . STANDARD ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS , SQL_FIREWALLRULE_NAME ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS ) . withNewFirewallRule ( START_IPADDRESS ) . apply ( ) ; validateMultiCreation ( database2Name , database1InEPName , database2InEPName , elasticPool1Name , elasticPool2Name , elasticPool3Name , sqlServer , true ) ; sqlServer . refresh ( ) ; Assert . assertEquals ( sqlServer . elasticPools ( ) . list ( ) . size ( ) , 0 ) ; List < SqlServer > sqlServers = sqlServerManager . sqlServers ( ) . listByResourceGroup ( RG_NAME ) ; boolean found = false ; for ( SqlServer server : sqlServers ) { if ( server . name ( ) . equals ( SQL_SERVER_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; Assert . assertNotNull ( sqlServer ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlDatabase ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; Observable < Indexable > resourceStream = sqlServer . databases ( ) . define ( SQL_DATABASE_NAME ) . createAsync ( ) ; SqlDatabase sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlDatabase ( sqlDatabase , SQL_DATABASE_NAME ) ; Assert . assertTrue ( sqlServer . databases ( ) . list ( ) . size ( ) > 0 ) ; TransparentDataEncryption transparentDataEncryption = sqlDatabase . getTransparentDataEncryption ( ) ; Assert . assertNotNull ( transparentDataEncryption . status ( ) ) ; List < TransparentDataEncryptionActivity > transparentDataEncryptionActivities = transparentDataEncryption . listActivities ( ) ; Assert . assertNotNull ( transparentDataEncryptionActivities ) ; transparentDataEncryption = transparentDataEncryption . updateStatus ( TransparentDataEncryptionStates . ENABLED ) ; Assert . assertNotNull ( transparentDataEncryption ) ; Assert . assertEquals ( transparentDataEncryption . status ( ) , TransparentDataEncryptionStates . ENABLED ) ; transparentDataEncryptionActivities = transparentDataEncryption . listActivities ( ) ; Assert . assertNotNull ( transparentDataEncryptionActivities ) ; TestUtilities . sleep ( 10000 , isRecordMode ( ) ) ; transparentDataEncryption = sqlDatabase . getTransparentDataEncryption ( ) . updateStatus ( TransparentDataEncryptionStates . DISABLED ) ; Assert . assertNotNull ( transparentDataEncryption ) ; Assert . assertEquals ( transparentDataEncryption . status ( ) , TransparentDataEncryptionStates . DISABLED ) ; Assert . assertEquals ( transparentDataEncryption . sqlServerName ( ) , SQL_SERVER_NAME ) ; Assert . assertEquals ( transparentDataEncryption . databaseName ( ) , SQL_DATABASE_NAME ) ; Assert . assertNotNull ( transparentDataEncryption . name ( ) ) ; Assert . assertNotNull ( transparentDataEncryption . id ( ) ) ; Assert . assertNotNull ( sqlDatabase . getUpgradeHint ( ) ) ; Map < String , ServiceTierAdvisor > serviceTierAdvisors = sqlDatabase . listServiceTierAdvisors ( ) ; Assert . assertNotNull ( serviceTierAdvisors ) ; Assert . assertNotNull ( serviceTierAdvisors . values ( ) . iterator ( ) . next ( ) . serviceLevelObjectiveUsageMetrics ( ) ) ; Assert . assertNotEquals ( serviceTierAdvisors . size ( ) , 0 ) ; Assert . assertNotNull ( serviceTierAdvisors . values ( ) . iterator ( ) . next ( ) . refresh ( ) ) ; Assert . assertNotNull ( serviceTierAdvisors . values ( ) . iterator ( ) . next ( ) . serviceLevelObjectiveUsageMetrics ( ) ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; Creatable < SqlElasticPool > sqlElasticPoolCreatable = sqlServer . elasticPools ( ) . define ( SQL_ELASTIC_POOL_NAME ) . withEdition ( ElasticPoolEditions . STANDARD ) ; String anotherDatabaseName = " anotherDatabase " ; SqlDatabase anotherDatabase = sqlServer . databases ( ) . define ( anotherDatabaseName ) . withNewElasticPool ( sqlElasticPoolCreatable ) . withSourceDatabase ( sqlDatabase . id ( ) ) . withMode ( CreateMode . COPY ) . create ( ) ; validateSqlDatabaseWithElasticPool ( anotherDatabase , anotherDatabaseName ) ; sqlServer . databases ( ) . delete ( anotherDatabase . name ( ) ) ; validateSqlDatabase ( sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) , SQL_DATABASE_NAME ) ; validateListSqlDatabase ( sqlServer . databases ( ) . list ( ) ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; validateSqlDatabaseNotFound ( SQL_DATABASE_NAME ) ; resourceStream = sqlServer . databases ( ) . define ( " newDatabase " ) . withEdition ( DatabaseEditions . STANDARD ) . withCollation ( COLLATION ) . createAsync ( ) ; sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; sqlServer . databases ( ) . delete ( sqlDatabase . name ( ) ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canManageReplicationLinks ( ) throws Exception { String anotherSqlServerName = SQL_SERVER_NAME + " another " ; SqlServer sqlServer1 = createSqlServer ( ) ; SqlServer sqlServer2 = createSqlServer ( anotherSqlServerName ) ; Observable < Indexable > resourceStream = sqlServer1 . databases ( ) . define ( SQL_DATABASE_NAME ) . withEdition ( DatabaseEditions . STANDARD ) . withCollation ( COLLATION ) . createAsync ( ) ; SqlDatabase databaseInServer1 = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlDatabase ( databaseInServer1 , SQL_DATABASE_NAME ) ; SqlDatabase databaseInServer2 = sqlServer2 . databases ( ) . define ( SQL_DATABASE_NAME ) . withSourceDatabase ( databaseInServer1 . id ( ) ) . withMode ( CreateMode . ONLINE_SECONDARY ) . create ( ) ; TestUtilities . sleep ( 2000 , isRecordMode ( ) ) ; List < ReplicationLink > replicationLinksInDb1 = new ArrayList < > ( databaseInServer1 . listReplicationLinks ( ) . values ( ) ) ; Assert . assertEquals ( replicationLinksInDb1 . size ( ) , 1 ) ; Assert . assertEquals ( replicationLinksInDb1 . get ( 0 ) . partnerDatabase ( ) , databaseInServer2 . name ( ) ) ; Assert . assertEquals ( replicationLinksInDb1 . get ( 0 ) . partnerServer ( ) , databaseInServer2 . sqlServerName ( ) ) ; List < ReplicationLink > replicationLinksInDb2 = new ArrayList < > ( databaseInServer2 . listReplicationLinks ( ) . values ( ) ) ; Assert . assertEquals ( replicationLinksInDb2 . size ( ) , 1 ) ; Assert . assertEquals ( replicationLinksInDb2 . get ( 0 ) . partnerDatabase ( ) , databaseInServer1 . name ( ) ) ; Assert . assertEquals ( replicationLinksInDb2 . get ( 0 ) . partnerServer ( ) , databaseInServer1 . sqlServerName ( ) ) ; Assert . assertNotNull ( replicationLinksInDb1 . get ( 0 ) . refresh ( ) ) ; replicationLinksInDb2 . get ( 0 ) . failover ( ) ; replicationLinksInDb2 . get ( 0 ) . refresh ( ) ; TestUtilities . sleep ( 30000 , isRecordMode ( ) ) ; replicationLinksInDb1 . get ( 0 ) . forceFailoverAllowDataLoss ( ) ; replicationLinksInDb1 . get ( 0 ) . refresh ( ) ; TestUtilities . sleep ( 30000 , isRecordMode ( ) ) ; replicationLinksInDb2 . get ( 0 ) . delete ( ) ; Assert . assertEquals ( databaseInServer2 . listReplicationLinks ( ) . size ( ) , 0 ) ; sqlServer1 . databases ( ) . delete ( databaseInServer1 . name ( ) ) ; sqlServer2 . databases ( ) . delete ( databaseInServer2 . name ( ) ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer2 . resourceGroupName ( ) , sqlServer2 . name ( ) ) ; validateSqlServerNotFound ( sqlServer2 ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer1 . resourceGroupName ( ) , sqlServer1 . name ( ) ) ; validateSqlServerNotFound ( sqlServer1 ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canDoOperationsOnDataWarehouse ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; validateSqlServer ( sqlServer ) ; Assert . assertNotNull ( sqlServer . listUsages ( ) ) ; Observable < Indexable > resourceStream = sqlServer . databases ( ) . define ( SQL_DATABASE_NAME ) . withEdition ( DatabaseEditions . DATA_WAREHOUSE ) . withCollation ( COLLATION ) . createAsync ( ) ; SqlDatabase sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; Assert . assertNotNull ( sqlDatabase ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertNotNull ( sqlDatabase ) ; Assert . assertTrue ( sqlDatabase . isDataWarehouse ( ) ) ; SqlWarehouse dataWarehouse = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) . asWarehouse ( ) ; Assert . assertNotNull ( dataWarehouse ) ; Assert . assertEquals ( dataWarehouse . name ( ) , SQL_DATABASE_NAME ) ; Assert . assertEquals ( dataWarehouse . edition ( ) , DatabaseEditions . DATA_WAREHOUSE ) ; Assert . assertNotNull ( dataWarehouse . listRestorePoints ( ) ) ; Assert . assertNotNull ( dataWarehouse . listUsages ( ) ) ; dataWarehouse . pauseDataWarehouse ( ) ; dataWarehouse . resumeDataWarehouse ( ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlDatabaseWithElasticPool ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; Creatable < SqlElasticPool > sqlElasticPoolCreatable = sqlServer . elasticPools ( ) . define ( SQL_ELASTIC_POOL_NAME ) . withEdition ( ElasticPoolEditions . STANDARD ) ; Observable < Indexable > resourceStream = sqlServer . databases ( ) . define ( SQL_DATABASE_NAME ) . withNewElasticPool ( sqlElasticPoolCreatable ) . withCollation ( COLLATION ) . createAsync ( ) ; SqlDatabase sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlDatabase ( sqlDatabase , SQL_DATABASE_NAME ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; SqlElasticPool elasticPool = sqlServer . elasticPools ( ) . get ( SQL_ELASTIC_POOL_NAME ) ; validateSqlElasticPool ( elasticPool ) ; validateSqlDatabaseWithElasticPool ( sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) , SQL_DATABASE_NAME ) ; validateListSqlDatabase ( sqlServer . databases ( ) . list ( ) ) ; sqlDatabase . update ( ) . withoutElasticPool ( ) . withEdition ( DatabaseEditions . STANDARD ) . withServiceObjective ( ServiceObjectiveName . S3 ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertNull ( sqlDatabase . elasticPoolName ( ) ) ; sqlDatabase . update ( ) . withEdition ( DatabaseEditions . PREMIUM ) . withServiceObjective ( ServiceObjectiveName . P1 ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . edition ( ) , DatabaseEditions . PREMIUM ) ; Assert . assertEquals ( sqlDatabase . serviceLevelObjective ( ) , ServiceObjectiveName . P1 ) ; sqlDatabase . update ( ) . withServiceObjective ( ServiceObjectiveName . P2 ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . serviceLevelObjective ( ) , ServiceObjectiveName . P2 ) ; Assert . assertEquals ( sqlDatabase . requestedServiceObjectiveName ( ) , ServiceObjectiveName . P2 ) ; sqlDatabase . update ( ) . withMaxSizeBytes ( 268435456000L ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . maxSizeBytes ( ) , 268435456000L ) ; sqlDatabase . update ( ) . withExistingElasticPool ( SQL_ELASTIC_POOL_NAME ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . elasticPoolName ( ) , SQL_ELASTIC_POOL_NAME ) ; Assert . assertNotNull ( elasticPool . listActivities ( ) ) ; Assert . assertNotNull ( elasticPool . listDatabaseActivities ( ) ) ; List < SqlDatabase > databasesInElasticPool = elasticPool . listDatabases ( ) ; Assert . assertNotNull ( databasesInElasticPool ) ; Assert . assertEquals ( databasesInElasticPool . size ( ) , 1 ) ; SqlDatabase databaseInElasticPool = elasticPool . getDatabase ( SQL_DATABASE_NAME ) ; validateSqlDatabase ( databaseInElasticPool , SQL_DATABASE_NAME ) ; databaseInElasticPool . refresh ( ) ; try { elasticPool . getDatabase ( " does _ not _ exist " ) ; Assert . assertNotNull ( null ) ; } catch ( Exception ex ) { } sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; validateSqlDatabaseNotFound ( SQL_DATABASE_NAME ) ; SqlElasticPool sqlElasticPool = sqlServer . elasticPools ( ) . get ( SQL_ELASTIC_POOL_NAME ) ; resourceStream = sqlServer . databases ( ) . define ( " newDatabase " ) . withExistingElasticPool ( sqlElasticPool ) . withCollation ( COLLATION ) . createAsync ( ) ; sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; sqlServer . databases ( ) . delete ( sqlDatabase . name ( ) ) ; validateSqlDatabaseNotFound ( " newDatabase " ) ; sqlServer . elasticPools ( ) . delete ( SQL_ELASTIC_POOL_NAME ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlElasticPool ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; Observable < Indexable > resourceStream = sqlServer . elasticPools ( ) . define ( SQL_ELASTIC_POOL_NAME ) . withEdition ( ElasticPoolEditions . STANDARD ) . createAsync ( ) ; SqlElasticPool sqlElasticPool = Utils . < SqlElasticPool > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlElasticPool ( sqlElasticPool ) ; Assert . assertEquals ( sqlElasticPool . listDatabases ( ) . size ( ) , 0 ) ; sqlElasticPool = sqlElasticPool . update ( ) . withDtu ( 100 ) . withDatabaseDtuMax ( 20 ) . withDatabaseDtuMin ( 10 ) . withStorageCapacity ( 102400 ) . withNewDatabase ( SQL_DATABASE_NAME ) . apply ( ) ; validateSqlElasticPool ( sqlElasticPool ) ; Assert . assertEquals ( sqlElasticPool . listDatabases ( ) . size ( ) , 1 ) ; validateSqlElasticPool ( sqlServer . elasticPools ( ) . get ( SQL_ELASTIC_POOL_NAME ) ) ; validateListSqlElasticPool ( sqlServer . elasticPools ( ) . list ( ) ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; sqlServer . elasticPools ( ) . delete ( SQL_ELASTIC_POOL_NAME ) ; validateSqlElasticPoolNotFound ( sqlServer , SQL_ELASTIC_POOL_NAME ) ; resourceStream = sqlServer . elasticPools ( ) . define ( " newElasticPool " ) . withEdition ( ElasticPoolEditions . STANDARD ) . createAsync ( ) ; sqlElasticPool = Utils . < SqlElasticPool > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; sqlServer . elasticPools ( ) . delete ( sqlElasticPool . name ( ) ) ; validateSqlElasticPoolNotFound ( sqlServer , " newElasticPool " ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlFirewallRule ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; Observable < Indexable > resourceStream = sqlServer . firewallRules ( ) . define ( SQL_FIREWALLRULE_NAME ) . withIPAddressRange ( START_IPADDRESS , END_IPADDRESS ) . createAsync ( ) ; SqlFirewallRule sqlFirewallRule = Utils . < SqlFirewallRule > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlFirewallRule ( sqlFirewallRule , SQL_FIREWALLRULE_NAME ) ; validateSqlFirewallRule ( sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) , SQL_FIREWALLRULE_NAME ) ; String secondFirewallRuleName = " secondFireWallRule " ; SqlFirewallRule secondFirewallRule = sqlServer . firewallRules ( ) . define ( secondFirewallRuleName ) . withIPAddress ( START_IPADDRESS ) . create ( ) ; Assert . assertNotNull ( secondFirewallRule ) ; secondFirewallRule = sqlServer . firewallRules ( ) . get ( secondFirewallRuleName ) ; Assert . assertNotNull ( secondFirewallRule ) ; Assert . assertEquals ( START_IPADDRESS , secondFirewallRule . endIPAddress ( ) ) ; secondFirewallRule = secondFirewallRule . update ( ) . withEndIPAddress ( END_IPADDRESS ) . apply ( ) ; validateSqlFirewallRule ( secondFirewallRule , secondFirewallRuleName ) ; sqlServer . firewallRules ( ) . delete ( secondFirewallRuleName ) ; Assert . assertNull ( sqlServer . firewallRules ( ) . get ( secondFirewallRuleName ) ) ; sqlFirewallRule = sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) ; validateSqlFirewallRule ( sqlFirewallRule , SQL_FIREWALLRULE_NAME ) ; sqlFirewallRule . update ( ) . withEndIPAddress ( START_IPADDRESS ) . apply ( ) ; sqlFirewallRule = sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) ; Assert . assertEquals ( sqlFirewallRule . endIPAddress ( ) , START_IPADDRESS ) ; validateListSqlFirewallRule ( sqlServer . firewallRules ( ) . list ( ) ) ; sqlServer . firewallRules ( ) . delete ( sqlFirewallRule . name ( ) ) ; validateSqlFirewallRuleNotFound ( ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
OyabunAB/criters | public FooPropertyFilter ( final Integer value ) { this . value = value ; }
OyabunAB/criters | @ Parameter ( restriction = Restriction . EQUALS , name = " value " ) public Integer getValue ( ) { return value ; }
OyabunAB/criters | public void setValue ( Integer value ) { this . value = value ; }
hazendaz/assertj-core | protected AbstractBooleanArrayAssert ( boolean [ ] actual , Class < ? > selfType ) { super ( actual , selfType ) ; }
hazendaz/assertj-core | @ Override public void isNullOrEmpty ( ) { arrays . assertNullOrEmpty ( info , actual ) ; }
hazendaz/assertj-core | @ Override public void isEmpty ( ) { arrays . assertEmpty ( info , actual ) ; }
hazendaz/assertj-core | @ Override public SELF isNotEmpty ( ) { arrays . assertNotEmpty ( info , actual ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSize ( int expected ) { arrays . assertHasSize ( info , actual , expected ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeGreaterThan ( int boundary ) { arrays . assertHasSizeGreaterThan ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeGreaterThanOrEqualTo ( int boundary ) { arrays . assertHasSizeGreaterThanOrEqualTo ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeLessThan ( int boundary ) { arrays . assertHasSizeLessThan ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeLessThanOrEqualTo ( int boundary ) { arrays . assertHasSizeLessThanOrEqualTo ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeBetween ( int lowerBoundary , int higherBoundary ) { arrays . assertHasSizeBetween ( info , actual , lowerBoundary , higherBoundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSameSizeAs ( Iterable < ? > other ) { arrays . assertHasSameSizeAs ( info , actual , other ) ; return myself ; }
hazendaz/assertj-core | public SELF contains ( boolean ... values ) { arrays . assertContains ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF contains ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContains ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnly ( boolean ... values ) { arrays . assertContainsOnly ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnly ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsOnly ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnlyOnce ( boolean ... values ) { arrays . assertContainsOnlyOnce ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnlyOnce ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsOnlyOnce ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSequence ( boolean ... sequence ) { arrays . assertContainsSequence ( info , actual , sequence ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSequence ( Boolean [ ] sequence ) { requireNonNullParameter ( sequence , " sequence " ) ; arrays . assertContainsSequence ( info , actual , toPrimitiveBooleanArray ( sequence ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSubsequence ( boolean ... subsequence ) { arrays . assertContainsSubsequence ( info , actual , subsequence ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSubsequence ( Boolean [ ] subsequence ) { requireNonNullParameter ( subsequence , " subsequence " ) ; arrays . assertContainsSubsequence ( info , actual , toPrimitiveBooleanArray ( subsequence ) ) ; return myself ; }
hazendaz/assertj-core | public SELF contains ( boolean value , Index index ) { arrays . assertContains ( info , actual , value , index ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotContain ( boolean ... values ) { arrays . assertDoesNotContain ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotContain ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertDoesNotContain ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotContain ( boolean value , Index index ) { arrays . assertDoesNotContain ( info , actual , value , index ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotHaveDuplicates ( ) { arrays . assertDoesNotHaveDuplicates ( info , actual ) ; return myself ; }
hazendaz/assertj-core | public SELF startsWith ( boolean ... sequence ) { arrays . assertStartsWith ( info , actual , sequence ) ; return myself ; }
hazendaz/assertj-core | public SELF startsWith ( Boolean [ ] sequence ) { requireNonNullParameter ( sequence , " sequence " ) ; arrays . assertStartsWith ( info , actual , toPrimitiveBooleanArray ( sequence ) ) ; return myself ; }
hazendaz/assertj-core | public SELF endsWith ( boolean ... sequence ) { arrays . assertEndsWith ( info , actual , sequence ) ; return myself ; }
hazendaz/assertj-core | public SELF endsWith ( Boolean [ ] sequence ) { requireNonNullParameter ( sequence , " sequence " ) ; arrays . assertEndsWith ( info , actual , toPrimitiveBooleanArray ( sequence ) ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF isSorted ( ) { arrays . assertIsSorted ( info , actual ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF isSortedAccordingTo ( Comparator < ? super Boolean > comparator ) { arrays . assertIsSortedAccordingToComparator ( info , actual , comparator ) ; return myself ; }
hazendaz/assertj-core | @ Override @ Deprecated public final SELF usingElementComparator ( Comparator < ? super Boolean > customComparator ) { throw new UnsupportedOperationException ( " custom ▁ element ▁ Comparator ▁ is ▁ not ▁ supported ▁ for ▁ Boolean ▁ array ▁ comparison " ) ; }
hazendaz/assertj-core | @ Override @ Deprecated public final SELF usingDefaultElementComparator ( ) { throw new UnsupportedOperationException ( " custom ▁ element ▁ Comparator ▁ is ▁ not ▁ supported ▁ for ▁ Boolean ▁ array ▁ comparison " ) ; }
hazendaz/assertj-core | public SELF containsExactly ( boolean ... values ) { arrays . assertContainsExactly ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsExactly ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsExactly ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsExactlyInAnyOrder ( boolean ... values ) { arrays . assertContainsExactlyInAnyOrder ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsExactlyInAnyOrder ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsExactlyInAnyOrder ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsAnyOf ( boolean ... values ) { arrays . assertContainsAnyOf ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsAnyOf ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsAnyOf ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
caldofran/PFM-LoadSensing | public BalloonOverlayView ( Context context , int balloonBottomOffset ) { super ( context ) ; setPadding ( 10 , 0 , 10 , balloonBottomOffset ) ; layout = new LinearLayout ( context ) ; layout . setVisibility ( VISIBLE ) ; LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; View v = inflater . inflate ( R . layout . balloon_overlay , layout ) ; title = ( TextView ) v . findViewById ( R . id . balloon_item_title ) ; snippet = ( TextView ) v . findViewById ( R . id . balloon_item_snippet ) ; ImageView close = ( ImageView ) v . findViewById ( R . id . close_img_button ) ; close . setOnClickListener ( new OnClickListener ( ) { public void onClick ( View v ) { layout . setVisibility ( GONE ) ; } } ) ; FrameLayout . LayoutParams params = new FrameLayout . LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ; params . gravity = Gravity . NO_GRAVITY ; addView ( layout , params ) ; }
caldofran/PFM-LoadSensing | public void setData ( Item item ) { layout . setVisibility ( VISIBLE ) ; if ( item . getTitle ( ) != null ) { title . setVisibility ( VISIBLE ) ; title . setText ( item . getTitle ( ) ) ; } else { title . setVisibility ( GONE ) ; } if ( item . getSnippet ( ) != null ) { snippet . setVisibility ( VISIBLE ) ; snippet . setText ( item . getSnippet ( ) ) ; } else { snippet . setVisibility ( GONE ) ; } }
danathughes/javaEvolutionaryAlgorithm | public Fitness ( double value ) { fitness = value ; }
danathughes/javaEvolutionaryAlgorithm | public double value ( ) { return fitness ; }
danathughes/javaEvolutionaryAlgorithm | public int compareTo ( Fitness other ) { int results = 0 ; if ( this . value ( ) > other . value ( ) ) { results = 1 ; } if ( other . value ( ) > this . value ( ) ) { results = - 1 ; } return results ; }
TatsianaKasiankova/pentaho-kettle | @ Test public void testNegatedTrueFuncEvaluatesAsFalse ( ) throws Exception { String left = " test _ filed " ; String right = " test _ value " ; int func = Condition . func_TRUE ; boolean negate = true ; Condition condition = new Condition ( negate , left , func , right , null ) ; assertFalse ( condition . evaluate ( new RowMeta ( ) , new Object [ ] { " test " } ) ) ; }
TatsianaKasiankova/pentaho-kettle | @ Test public void testPdi13227 ( ) throws Exception { RowMetaInterface rowMeta1 = new RowMeta ( ) ; rowMeta1 . addValueMeta ( new ValueMetaNumber ( " name1" ) ) ; rowMeta1 . addValueMeta ( new ValueMetaNumber ( " name2" ) ) ; rowMeta1 . addValueMeta ( new ValueMetaNumber ( " name3" ) ) ; RowMetaInterface rowMeta2 = new RowMeta ( ) ; rowMeta2 . addValueMeta ( new ValueMetaNumber ( " name2" ) ) ; rowMeta2 . addValueMeta ( new ValueMetaNumber ( " name1" ) ) ; rowMeta2 . addValueMeta ( new ValueMetaNumber ( " name3" ) ) ; String left = " name1" ; String right = " name3" ; Condition condition = new Condition ( left , Condition . func_EQUAL , right , null ) ; assertTrue ( condition . evaluate ( rowMeta1 , new Object [ ] { 1.0 , 2.0 , 1.0 } ) ) ; assertTrue ( condition . evaluate ( rowMeta2 , new Object [ ] { 2.0 , 1.0 , 1.0 } ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromMessageCopiesBody ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; byte [ ] testBody = httpsMsg . getBody ( ) ; byte [ ] expectedBody = body ; assertThat ( testBody , is ( expectedBody ) ) ; expectedBody [ 0 ] = 0x34 ; assertThat ( testBody , is ( not ( expectedBody ) ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromMessageSavesBase64Encoded ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; boolean testBase64Encoded = httpsMsg . isBase64Encoded ( ) ; boolean expectedBase64Encoded = base64Encoded ; assertThat ( testBase64Encoded , is ( expectedBase64Encoded ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromMessageSavesPropertiesWithPrefix ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; final String expectedPrefix = " iothub - app - " ; final String expectedPropertyName = expectedPrefix + propertyName ; final String expectedPropertyValue = propertyValue ; new Verifications ( ) { { new IotHubMessageProperty ( expectedPropertyName , expectedPropertyValue ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseCopiesBody ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; byte [ ] testBody = httpsMsg . getBody ( ) ; byte [ ] expectedBody = body ; assertThat ( testBody , is ( expectedBody ) ) ; expectedBody [ 0 ] = 0x34 ; assertThat ( testBody , is ( not ( expectedBody ) ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseDoesNotBase64EncodeBody ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; boolean testBase64Encoded = httpsMsg . isBase64Encoded ( ) ; boolean expectedBase64Encoded = false ; assertThat ( testBase64Encoded , is ( expectedBase64Encoded ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseDoesNotIncludeNonAppProperties ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; IotHubMessageProperty [ ] testProperties = httpsMsg . getProperties ( ) ; IotHubMessageProperty [ ] expectedProperties = { } ; assertThat ( testProperties , is ( expectedProperties ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseIncludesAppProperties ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; IotHubMessageProperty . isValidAppProperty ( propertyName , propertyValue ) ; result = true ; } } ; HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; new Verifications ( ) { { new IotHubMessageProperty ( propertyName , propertyValue ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void toMessageCopiesBody ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty , @ Mocked final IotHubMessage mockMsg ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; IotHubMessageProperty . isValidAppProperty ( propertyName , propertyValue ) ; result = true ; new IotHubMessageProperty ( propertyName , propertyValue ) ; result = mockProperty ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; new IotHubMessage ( body ) ; result = mockMsg ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; httpsMsg . toMessage ( ) ; final byte [ ] expectedBody = body ; new Verifications ( ) { { new IotHubMessage ( expectedBody ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void toMessageRemovesPrefixFromProperties ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty , @ Mocked final IotHubMessage mockMsg ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; IotHubMessageProperty . isValidAppProperty ( propertyName , propertyValue ) ; result = true ; new IotHubMessageProperty ( propertyName , propertyValue ) ; result = mockProperty ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; new IotHubMessage ( body ) ; result = mockMsg ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; httpsMsg . toMessage ( ) ; final String expectedPropertyName = " test - property - name " ; final String expectedPropertyValue = propertyValue ; new Verifications ( ) { { mockMsg . setProperty ( expectedPropertyName , expectedPropertyValue ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void getBodyReturnsCopyOfBody ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; byte [ ] testBody = httpsMsg . getBody ( ) ; byte [ ] expectedBody = body ; assertThat ( testBody , is ( expectedBody ) ) ; testBody [ 0 ] = 0x34 ; testBody = httpsMsg . getBody ( ) ; assertThat ( testBody , is ( expectedBody ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void getBodyAsStringsReturnsUtf8Body ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; String testBody = httpsMsg . getBodyAsString ( ) ; String expectedBody = " abc " ; assertThat ( testBody , is ( expectedBody ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void getContentTypeReturnsCorrectContentType ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; String testContentType = httpsMsg . getContentType ( ) ; String expectedContentType = " binary / octet - stream " ; assertThat ( testContentType , is ( expectedContentType ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void getPropertiesReturnsCopyOfProperties ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String httpsPropertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; result = httpsPropertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; IotHubMessageProperty [ ] testProperties = httpsMsg . getProperties ( ) ; final IotHubMessageProperty [ ] expectedProperties = properties ; assertThat ( testProperties . length , is ( expectedProperties . length ) ) ; final String expectedPropertyName = httpsPropertyName ; final String expectedPropertyValue = propertyValue ; new Verifications ( ) { { new IotHubMessageProperty ( expectedPropertyName , expectedPropertyValue ) ; times = 2 ; } } ; }
cs383-final/skynet | @ Before public void setUp ( ) throws Exception { baseTime = new DateTime ( 2011 , 2 , 1 , 0 , 0 , 0 , 0 , DateTimeZone . UTC ) . toInstant ( ) ; broker = new PowerTacBroker ( ) ; ApplicationContext ctx = mock ( ApplicationContext . class ) ; SpringApplicationContext sac = new SpringApplicationContext ( ) ; sac . setApplicationContext ( ctx ) ; MessageDispatcher messageDispatcher = new MessageDispatcher ( ) ; ReflectionTestUtils . setField ( broker , " router " , messageDispatcher ) ; customerRepo = new CustomerRepo ( ) ; ReflectionTestUtils . setField ( broker , " customerRepo " , customerRepo ) ; brokerRepo = new BrokerRepo ( ) ; ReflectionTestUtils . setField ( broker , " brokerRepo " , brokerRepo ) ; ReflectionTestUtils . setField ( broker , " username " , " Sample " ) ; broker . init ( ) ; }
cs383-final/skynet | @ Test public void testSampleBroker ( ) { assertFalse ( broker . getBroker ( ) . isEnabled ( ) ) ; }
cs383-final/skynet | @ Test public void testIsEnabled ( ) { assertFalse ( broker . getBroker ( ) . isEnabled ( ) ) ; broker . getBroker ( ) . receiveMessage ( new BrokerAccept ( 3 ) ) ; assertTrue ( broker . getBroker ( ) . isEnabled ( ) ) ; assertEquals ( " correct ▁ prefix " , 3 , IdGenerator . getPrefix ( ) ) ; }
cs383-final/skynet | @ Test public void testReceiveCompetition ( ) { assertEquals ( " initially , ▁ no ▁ competing ▁ brokers " , 1 , broker . getBrokerList ( ) . size ( ) ) ; Competition comp = Competition . newInstance ( " Test " ) . withSimulationBaseTime ( baseTime ) . addBroker ( " Sam " ) . addBroker ( " Sally " ) . addCustomer ( new CustomerInfo ( " Podunk " , 3 ) ) . addCustomer ( new CustomerInfo ( " Midvale " , 1000 ) ) . addCustomer ( new CustomerInfo ( " Metro " , 100000 ) ) ; broker . getBroker ( ) . receiveMessage ( comp ) ; assertEquals ( " still ▁ no ▁ competing ▁ brokers " , 1 , broker . getBrokerList ( ) . size ( ) ) ; broker . getBroker ( ) . receiveMessage ( new BrokerAccept ( 3 ) ) ; broker . getBroker ( ) . receiveMessage ( comp ) ; assertEquals ( "2 ▁ competing ▁ brokers " , 3 , broker . getBrokerList ( ) . size ( ) ) ; assertEquals ( "3 ▁ customers " , 3 , customerRepo . size ( ) ) ; }
8106yogi/music-synthesizer-for-android | public void testBasic ( ) { SynthesizerInput frequency = new SynthesizerInput ( 0.0 , 0.0 , 1.0 ) ; SynthesisTime time = new SynthesisTime ( ) ; time . setSampleRate ( 8 ) ; Sawtooth sawtooth = new Sawtooth ( frequency ) ; assertEquals ( - 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 2.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 3.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 4.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 3.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 2.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 0.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; }
8106yogi/music-synthesizer-for-android | public void testFrequencyChange ( ) { SynthesizerInput frequency = new SynthesizerInput ( 0.0 , 0.0 , 1.0 ) ; SynthesisTime time = new SynthesisTime ( ) ; time . setSampleRate ( 8 ) ; Sawtooth sawtooth = new Sawtooth ( frequency ) ; assertEquals ( - 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 2.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; frequency . setValue ( - 1.0 ) ; assertEquals ( - 3.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 8.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 7.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 6.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 5.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 4.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 3.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 2.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 1.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 0.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 1.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; }
alecharp/plugin-dependency-analyzer | @ GetMapping public String ping ( ) { return " pong " ; }
AngusZhu/spring-boot | @ Before public void setup ( ) throws Exception { this . sampleJarFile = createSampleJarFile ( ) ; URL url = this . sampleJarFile . toURI ( ) . toURL ( ) ; ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; URL [ ] urls = new URL [ ] { url } ; this . parentClassLoader = new URLClassLoader ( urls , classLoader ) ; this . updatedFiles = new ClassLoaderFiles ( ) ; this . reloadClassLoader = new RestartClassLoader ( this . parentClassLoader , urls , this . updatedFiles ) ; }
AngusZhu/spring-boot | private File createSampleJarFile ( ) throws IOException { File file = this . temp . newFile ( " sample . jar " ) ; JarOutputStream jarOutputStream = new JarOutputStream ( new FileOutputStream ( file ) ) ; jarOutputStream . putNextEntry ( new ZipEntry ( PACKAGE_PATH + " / Sample . class " ) ) ; StreamUtils . copy ( getClass ( ) . getResourceAsStream ( " Sample . class " ) , jarOutputStream ) ; jarOutputStream . closeEntry ( ) ; jarOutputStream . putNextEntry ( new ZipEntry ( PACKAGE_PATH + " / Sample . txt " ) ) ; StreamUtils . copy ( " fromchild " , UTF_8 , jarOutputStream ) ; jarOutputStream . closeEntry ( ) ; jarOutputStream . close ( ) ; return file ; }
AngusZhu/spring-boot | @ Test public void parentMustNotBeNull ( ) throws Exception { this . thrown . expect ( IllegalArgumentException . class ) ; this . thrown . expectMessage ( " Parent ▁ must ▁ not ▁ be ▁ null " ) ; new RestartClassLoader ( null , new URL [ ] { } ) ; }
AngusZhu/spring-boot | @ Test public void updatedFilesMustNotBeNull ( ) throws Exception { this . thrown . expect ( IllegalArgumentException . class ) ; this . thrown . expectMessage ( " UpdatedFiles ▁ must ▁ not ▁ be ▁ null " ) ; new RestartClassLoader ( this . parentClassLoader , new URL [ ] { } , null ) ; }
AngusZhu/spring-boot | @ Test public void getResourceFromReloadableUrl ( ) throws Exception { String content = readString ( this . reloadClassLoader . getResourceAsStream ( PACKAGE_PATH + " / Sample . txt " ) ) ; assertThat ( content , startsWith ( " fromchild " ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourceFromParent ( ) throws Exception { String content = readString ( this . reloadClassLoader . getResourceAsStream ( PACKAGE_PATH + " / Parent . txt " ) ) ; assertThat ( content , startsWith ( " fromparent " ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourcesFiltersDuplicates ( ) throws Exception { List < URL > resources = toList ( this . reloadClassLoader . getResources ( PACKAGE_PATH + " / Sample . txt " ) ) ; assertThat ( resources . size ( ) , equalTo ( 1 ) ) ; }
AngusZhu/spring-boot | @ Test public void loadClassFromReloadableUrl ( ) throws Exception { Class < ? > loaded = this . reloadClassLoader . loadClass ( PACKAGE + " . Sample " ) ; assertThat ( loaded . getClassLoader ( ) , equalTo ( ( ClassLoader ) this . reloadClassLoader ) ) ; }
AngusZhu/spring-boot | @ Test public void loadClassFromParent ( ) throws Exception { Class < ? > loaded = this . reloadClassLoader . loadClass ( PACKAGE + " . SampleParent " ) ; assertThat ( loaded . getClassLoader ( ) , equalTo ( getClass ( ) . getClassLoader ( ) ) ) ; }
AngusZhu/spring-boot | @ Test public void getDeletedResource ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; assertThat ( this . reloadClassLoader . getResource ( name ) , equalTo ( null ) ) ; }
AngusZhu/spring-boot | @ Test public void getDeletedResourceAsStream ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; assertThat ( this . reloadClassLoader . getResourceAsStream ( name ) , equalTo ( null ) ) ; }
AngusZhu/spring-boot | @ Test public void getUpdatedResource ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; byte [ ] bytes = " abc " . getBytes ( ) ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . MODIFIED , bytes ) ) ; URL resource = this . reloadClassLoader . getResource ( name ) ; assertThat ( FileCopyUtils . copyToByteArray ( resource . openStream ( ) ) , equalTo ( bytes ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourcesWithDeleted ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; List < URL > resources = toList ( this . reloadClassLoader . getResources ( name ) ) ; assertThat ( resources . size ( ) , equalTo ( 0 ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourcesWithUpdated ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; byte [ ] bytes = " abc " . getBytes ( ) ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . MODIFIED , bytes ) ) ; List < URL > resources = toList ( this . reloadClassLoader . getResources ( name ) ) ; assertThat ( FileCopyUtils . copyToByteArray ( resources . get ( 0 ) . openStream ( ) ) , equalTo ( bytes ) ) ; }
AngusZhu/spring-boot | @ Test public void getDeletedClass ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . class " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; this . thrown . expect ( ClassNotFoundException . class ) ; this . reloadClassLoader . loadClass ( PACKAGE + " . Sample " ) ; }
AngusZhu/spring-boot | @ Test public void getUpdatedClass ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . class " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . MODIFIED , new byte [ 10 ] ) ) ; this . thrown . expect ( ClassFormatError . class ) ; this . reloadClassLoader . loadClass ( PACKAGE + " . Sample " ) ; }
AngusZhu/spring-boot | @ Test public void getAddedClass ( ) throws Exception { String name = PACKAGE_PATH + " / SampleParent . class " ; byte [ ] bytes = FileCopyUtils . copyToByteArray ( getClass ( ) . getResourceAsStream ( " SampleParent . class " ) ) ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . ADDED , bytes ) ) ; Class < ? > loaded = this . reloadClassLoader . loadClass ( PACKAGE + " . SampleParent " ) ; assertThat ( loaded . getClassLoader ( ) , equalTo ( ( ClassLoader ) this . reloadClassLoader ) ) ; }
AngusZhu/spring-boot | private String readString ( InputStream in ) throws IOException { return new String ( FileCopyUtils . copyToByteArray ( in ) ) ; }
AngusZhu/spring-boot | private < T > List < T > toList ( Enumeration < T > enumeration ) { List < T > list = new ArrayList < T > ( ) ; if ( enumeration != null ) { while ( enumeration . hasMoreElements ( ) ) { list . add ( enumeration . nextElement ( ) ) ; } } return list ; }
leafclick/intellij-community | @ Override protected final void customizeCellRenderer ( @ NotNull JList < ? extends T > list , T value , int index , boolean selected , boolean hasFocus ) { doCustomize ( list , value , index , selected , hasFocus ) ; }
leafclick/intellij-community | public void append ( @ NotNull SimpleColoredText text ) { text . appendToComponent ( this ) ; }
saddi909/LementProAndroidApp | public Checkpoints ( ) { dateClosed = " " ; description = " " ; duration = 0 ; id = " " ; isClosed = false ; isExpired = false ; name = " " ; startDateTime = " " ; authorAvatarFileld = " " ; authorId = " " ; authorisInVacation = false ; authorText = " " ; authorFromAvatarFileld = " " ; authorFromId = " " ; authorFromisInVacation = false ; authorFromText = " " ; }
incodehq/ecpcrm | @ Programmatic public List < Center > listAll ( ) { return repositoryService . allInstances ( Center . class ) ; }
incodehq/ecpcrm | @ Programmatic public Center findByExactName ( final String name ) { return repositoryService . uniqueMatch ( new QueryDefault < > ( Center . class , " findByExactName " , " name " , name ) ) ; }
incodehq/ecpcrm | @ Programmatic public List < Center > findByNameContains ( final String name ) { return repositoryService . allMatches ( new QueryDefault < > ( Center . class , " findByNameContains " , " name " , name ) ) ; }
incodehq/ecpcrm | @ Programmatic public List < Center > findByMailchimpListId ( final String mailchimpListId ) { QCenter center = QCenter . candidate ( ) ; return isisJdoSupport . executeQuery ( Center . class , center . mailchimpListId . eq ( mailchimpListId ) ) ; }
incodehq/ecpcrm | @ Programmatic public Center findByCode ( final String code ) { return repositoryService . uniqueMatch ( new QueryDefault < > ( Center . class , " findByCode " , " code " , code ) ) ; }
incodehq/ecpcrm | @ Programmatic private Center newCenter ( final String code , final String name , final String id , final String mailchimpListId , final String contactEmail ) { Center center = repositoryService . instantiate ( Center . class ) ; center . setCode ( code ) ; center . setId ( id ) ; center . setName ( name ) ; center . setNumerator ( numeratorRepository . findOrCreate ( name , " % d " , Long . parseLong ( "2" + code + "000000000" ) ) ) ; center . setAtPath ( " / FRA / " + code ) ; center . setMailchimpListId ( mailchimpListId ) ; center . setContactEmail ( contactEmail ) ; repositoryService . persist ( center ) ; return center ; }
incodehq/ecpcrm | @ Programmatic public Center findOrCreate ( final String code , final String name , final String id , final String mailchimpListId , final String contactEmail ) { Center center = findByCode ( code ) ; center = center != null ? center : findByExactName ( name ) ; center = center != null ? center : newCenter ( code , name , id , mailchimpListId , contactEmail ) ; return center ; }
anilgursel/squbs | catch ( Exception e ) { binding = null ; }
anilgursel/squbs | if ( " helloHttps " . equals ( svcName ) ) { return Optional . of ( HttpEndpoint . create ( " https : // localhost : " + port , sslContext ( " exampletrust . jks " , " changeit " ) , Optional . empty ( ) ) ) ; }
anilgursel/squbs | public ClientFlowHttpsEndpointTest ( ) { clientFlow = ClientFlow . create ( " helloHttps " , system , mat ) ; }
anilgursel/squbs | CompletionStage < Try < HttpResponse > > doRequest ( HttpRequest request ) { return Source . single ( Pair . create ( request , 42 ) ) . via ( clientFlow ) . runWith ( Sink . head ( ) , mat ) . thenApply ( Pair :: first ) ; }
anilgursel/squbs | @ Test public void testClientCallHelloService ( ) throws Exception { CompletionStage < Try < HttpResponse > > cs = doRequest ( HttpRequest . create ( " / hello " ) ) ; HttpResponse response = cs . toCompletableFuture ( ) . get ( ) . get ( ) ; assertEquals ( StatusCodes . OK , response . status ( ) ) ; String content = response . entity ( ) . toStrict ( Timeouts . awaitMax ( ) . toMillis ( ) , mat ) . toCompletableFuture ( ) . get ( ) . getData ( ) . utf8String ( ) ; assertEquals ( " Hello ▁ World ! " , content ) ; }
anilgursel/squbs | @ Test ( expected = HttpClientEndpointNotExistException . class ) public void endPointNotExist ( ) throws Exception { ClientFlow . < Integer > create ( " cannotResolve " , system , mat ) ; }
minwoo-jung/pinpoint | @ Before public void before ( ) { when ( mockApplicationIndexDao . selectAgentIds ( APPLICATION_NAME ) ) . thenReturn ( Arrays . asList ( AGENT_ID_1 , AGENT_ID_2 , AGENT_ID_3 ) ) ; }
minwoo-jung/pinpoint | private long createEventTimestamp ( ) { return RandomUtils . nextLong ( START_TIME_MILLIS , CURRENT_TIME_MILLIS ) ; }
minwoo-jung/pinpoint | @ Test public void checkTest1 ( ) { Rule rule = new Rule ( APPLICATION_NAME , SERVICE_TYPE , CheckerCategory . ERROR_COUNT . getName ( ) , 50 , " testGroup " , false , false , " " ) ; Application application = new Application ( APPLICATION_NAME , ServiceType . STAND_ALONE ) ; Range range = Range . newUncheckedRange ( START_TIME_MILLIS , CURRENT_TIME_MILLIS ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_1 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_1 , createEventTimestamp ( ) , AgentEventType . AGENT_CLOSED_BY_SERVER ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_2 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_2 , createEventTimestamp ( ) , AgentEventType . AGENT_DEADLOCK_DETECTED ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_3 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_3 , createEventTimestamp ( ) , AgentEventType . AGENT_PING ) ) ) ; AgentEventDataCollector dataCollector = new AgentEventDataCollector ( DataCollectorFactory . DataCollectorCategory . AGENT_EVENT , application , mockAgentEventDao , mockApplicationIndexDao , CURRENT_TIME_MILLIS , INTERVAL_MILLIS ) ; DeadlockChecker checker = new DeadlockChecker ( dataCollector , rule ) ; checker . check ( ) ; Assert . assertTrue ( checker . isDetected ( ) ) ; String emailMessage = checker . getEmailMessage ( ) ; Assert . assertTrue ( StringUtils . hasLength ( emailMessage ) ) ; List < String > smsMessage = checker . getSmsMessage ( ) ; Assert . assertTrue ( smsMessage . size ( ) == 1 ) ; }
minwoo-jung/pinpoint | @ Test public void checkTest2 ( ) { Rule rule = new Rule ( APPLICATION_NAME , SERVICE_TYPE , CheckerCategory . ERROR_COUNT . getName ( ) , 50 , " testGroup " , false , false , " " ) ; Application application = new Application ( APPLICATION_NAME , ServiceType . STAND_ALONE ) ; Range range = Range . newUncheckedRange ( START_TIME_MILLIS , CURRENT_TIME_MILLIS ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_1 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_1 , createEventTimestamp ( ) , AgentEventType . AGENT_CLOSED_BY_SERVER ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_2 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_2 , createEventTimestamp ( ) , AgentEventType . AGENT_SHUTDOWN ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_3 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_3 , createEventTimestamp ( ) , AgentEventType . AGENT_PING ) ) ) ; AgentEventDataCollector dataCollector = new AgentEventDataCollector ( DataCollectorFactory . DataCollectorCategory . AGENT_EVENT , application , mockAgentEventDao , mockApplicationIndexDao , CURRENT_TIME_MILLIS , INTERVAL_MILLIS ) ; DeadlockChecker checker = new DeadlockChecker ( dataCollector , rule ) ; checker . check ( ) ; Assert . assertFalse ( checker . isDetected ( ) ) ; String emailMessage = checker . getEmailMessage ( ) ; Assert . assertTrue ( StringUtils . isEmpty ( emailMessage ) ) ; List < String > smsMessage = checker . getSmsMessage ( ) ; Assert . assertTrue ( smsMessage . isEmpty ( ) ) ; }
minwoo-jung/pinpoint | private AgentEventBo createAgentEvent ( String agentId , long eventTimestamp , AgentEventType agentEventType ) { return new AgentEventBo ( agentId , START_TIME_MILLIS , eventTimestamp , agentEventType ) ; }
mnipper/AndroidSurvey | public SendResponsesTask ( Context context ) { mContext = context ; }
mnipper/AndroidSurvey | @ Override protected Void doInBackground ( Void ... params ) { if ( NetworkNotificationUtils . checkForNetworkErrors ( mContext ) ) { ActiveRecordCloudSync . syncSendTables ( mContext ) ; } return null ; }
intrack/BoofCV-master | public ShowLensDistortion ( Class < T > imageType ) { this . imageType = imageType ; input = new MultiSpectral < T > ( imageType , 1 , 1 , 3 ) ; output = new MultiSpectral < T > ( imageType , 1 , 1 , 3 ) ; addToToolbar ( createRadialSelect ( ) ) ; setMainGUI ( gui ) ; }
intrack/BoofCV-master | private JPanel createRadialSelect ( ) { JPanel ret = new JPanel ( ) ; ret . setLayout ( new BoxLayout ( ret , BoxLayout . X_AXIS ) ) ; radialOrder1 = new JSpinner ( new SpinnerNumberModel ( radial1 , - 1.0 , 2.0 , 0.05 ) ) ; radialOrder1 . addChangeListener ( this ) ; int h = radialOrder1 . getPreferredSize ( ) . height ; radialOrder1 . setPreferredSize ( new Dimension ( 50 , h ) ) ; radialOrder1 . setMaximumSize ( radialOrder1 . getPreferredSize ( ) ) ; radialOrder2 = new JSpinner ( new SpinnerNumberModel ( radial2 , - 1.0 , 2.0 , 0.05 ) ) ; radialOrder2 . addChangeListener ( this ) ; radialOrder2 . setPreferredSize ( new Dimension ( 50 , h ) ) ; radialOrder2 . setMaximumSize ( radialOrder1 . getPreferredSize ( ) ) ; ret . add ( Box . createRigidArea ( new Dimension ( 10 , 1 ) ) ) ; ret . add ( new JLabel ( " Radial ▁ 1 : " ) ) ; ret . add ( radialOrder1 ) ; ret . add ( Box . createRigidArea ( new Dimension ( 10 , 1 ) ) ) ; ret . add ( new JLabel ( " Radial ▁ 2 : " ) ) ; ret . add ( radialOrder2 ) ; ret . addPropertyChangeListener ( new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . equals ( " enabled " ) ) { JPanel src = ( JPanel ) evt . getSource ( ) ; boolean value = ( Boolean ) evt . getNewValue ( ) ; for ( int i = 0 ; i < src . getComponentCount ( ) ; i ++ ) { src . getComponent ( i ) . setEnabled ( value ) ; } } } } ) ; return ret ; }
intrack/BoofCV-master | public void process ( final BufferedImage image ) { input . reshape ( image . getWidth ( ) , image . getHeight ( ) ) ; output . reshape ( image . getWidth ( ) , image . getHeight ( ) ) ; ConvertBufferedImage . convertFromMulti ( image , input , imageType ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { setInputImage ( image ) ; outputImage = new BufferedImage ( input . width , input . height , BufferedImage . TYPE_INT_BGR ) ; renderedImage = new BufferedImage ( input . width , input . height , BufferedImage . TYPE_INT_BGR ) ; gui . setBufferedImage ( outputImage ) ; gui . setPreferredSize ( new Dimension ( input . width , input . height ) ) ; gui . repaint ( ) ; processedImage = true ; doRefreshAll ( ) ; } } ) ; }
intrack/BoofCV-master | @ Override public void loadConfigurationFile ( String fileName ) { }
intrack/BoofCV-master | @ Override public boolean getHasProcessedImage ( ) { return processedImage ; }
intrack/BoofCV-master | @ Override public void refreshAll ( Object [ ] cookies ) { performUpdate ( ) ; }
intrack/BoofCV-master | private synchronized void performUpdate ( ) { if ( input == null || output == null ) return ; progress = 0 ; ProgressMonitorThread thread = new MyMonitorThread ( this ) ; thread . start ( ) ; PointTransform_F32 ptran = new AddRadialPtoP_F32 ( input . width * 0.8 , input . width * 0.8 , 0 , input . width / 2 , input . height / 2 , radial1 , radial2 ) ; PixelTransform_F32 tran = new PointToPixelTransform_F32 ( ptran ) ; for ( int i = 0 ; i < input . getNumBands ( ) ; i ++ , progress ++ ) { T bandIn = input . getBand ( i ) ; T bandOut = output . getBand ( i ) ; DistortImageOps . distortSingle ( bandIn , bandOut , tran , false , TypeInterpolate . BILINEAR ) ; } thread . stopThread ( ) ; ConvertBufferedImage . convertTo ( output , renderedImage ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { outputImage . createGraphics ( ) . drawImage ( renderedImage , 0 , 0 , null ) ; gui . repaint ( ) ; } } ) ; }
intrack/BoofCV-master | @ Override public void changeInput ( String name , int index ) { BufferedImage image = media . openImage ( inputRefs . get ( index ) . getPath ( ) ) ; if ( image != null ) { process ( image ) ; } }
intrack/BoofCV-master | @ Override public synchronized void stateChanged ( ChangeEvent e ) { if ( e . getSource ( ) == radialOrder1 ) radial1 = ( ( Number ) radialOrder1 . getValue ( ) ) . doubleValue ( ) ; if ( e . getSource ( ) == radialOrder2 ) radial2 = ( ( Number ) radialOrder2 . getValue ( ) ) . doubleValue ( ) ; performUpdate ( ) ; }
intrack/BoofCV-master | protected MyMonitorThread ( Component comp ) { super ( new ProgressMonitor ( comp , " Applying ▁ Distortion " , " " , 0 , input . getNumBands ( ) ) ) ; }
intrack/BoofCV-master | @ Override public void doRun ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { monitor . setProgress ( progress ) ; } } ) ; }
pvillard31/nifi | @ Override public Set < Relationship > getRelationships ( ) { return RELATIONSHIPS ; }
pvillard31/nifi | @ Override public void onTrigger ( final ProcessContext context , final ProcessSession session ) throws ProcessException { FlowFile flowFile = session . get ( ) ; if ( flowFile == null ) { return ; } FlowFile extracted = session . create ( flowFile ) ; boolean error = false ; try ( InputStream is = session . read ( flowFile ) ; Reader tikaReader = new Tika ( ) . parse ( is ) ; OutputStream os = session . write ( extracted ) ; OutputStreamWriter writer = new OutputStreamWriter ( os ) ) { IOUtils . copy ( tikaReader , writer ) ; } catch ( final Throwable t ) { error = true ; getLogger ( ) . error ( " Extraction ▁ Failed ▁ { } " , flowFile , t ) ; session . remove ( extracted ) ; session . transfer ( flowFile , REL_FAILURE ) ; } finally { if ( ! error ) { final Map < String , String > attributes = new HashMap < > ( ) ; attributes . put ( CoreAttributes . MIME_TYPE . key ( ) , TEXT_PLAIN ) ; extracted = session . putAllAttributes ( extracted , attributes ) ; session . transfer ( extracted , REL_EXTRACTED ) ; session . transfer ( flowFile , REL_ORIGINAL ) ; } } }
blacklocus/jres | public < T extends Facet > T get ( String facetName , Class < T > klass ) { return ObjectMappers . fromJson ( get ( facetName ) , klass ) ; }
cf0566/FireEyes | @ Override protected void getIntentData ( Bundle savedInstanceState ) { Intent intent = getIntent ( ) ; taskId = intent . getStringExtra ( " taskId " ) ; areaData = intent . getParcelableExtra ( " checkAreaData " ) ; }
cf0566/FireEyes | @ Override protected void loadXml ( ) { setContentView ( R . layout . activity_add_area_check ) ; }
cf0566/FireEyes | @ Override protected void initView ( ) { ivBack = ( ImageView ) findViewById ( R . id . activity_add_area_check_back ) ; tvSave = ( TextView ) findViewById ( R . id . activity_add_area_check_save ) ; etName = ( EditText ) findViewById ( R . id . area_name_et_activity_add_area_check ) ; elv = ( ExpandableListView ) findViewById ( R . id . activity_add_area_check_lv ) ; progressDialog = ProgressDialogHandle . getProgressDialog ( this , null ) ; }
cf0566/FireEyes | @ Override protected void registerListener ( ) { ivBack . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { onBackPressed ( ) ; } } ) ; tvSave . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { saveCheckArea ( ) ; } } ) ; elv . setOnChildClickListener ( new OnChildClickListener ( ) { @ Override public boolean onChildClick ( ExpandableListView parent , View v , int groupPosition , int childPosition , long id ) { CheckBox cBox = ( CheckBox ) v . findViewById ( R . id . item_add_book_check_listview_item_cbox ) ; if ( ! cBox . isChecked ( ) ) { cBox . setChecked ( true ) ; selInfoIds . add ( solutions . get ( groupPosition ) . children . get ( childPosition ) . sub_id ) ; } else { cBox . setChecked ( false ) ; selInfoIds . remove ( solutions . get ( groupPosition ) . children . get ( childPosition ) . sub_id ) ; } return false ; } } ) ; }
cf0566/FireEyes | @ Override protected void initData ( ) { SharedPreferences sharedPref = PreferenceManager . getDefaultSharedPreferences ( this ) ; token = sharedPref . getString ( " token " , null ) ; solutions = areaData . list ; initAdapter ( ) ; }
cf0566/FireEyes | private void initAdapter ( ) { groupTitles = new ArrayList < String > ( ) ; childItems = new ArrayList < ArrayList < ChildItem > > ( ) ; for ( Solution solu : solutions ) { groupTitles . add ( solu . solution ) ; ArrayList < ChildItem > subItems = new ArrayList < ChildItem > ( ) ; for ( SolutionChildItem item : solu . children ) { subItems . add ( new ChildItem ( item . sub_id , item . sub_name ) ) ; } childItems . add ( subItems ) ; } infoAdapter = new AddBookCheckListViewAdapter ( this ) ; infoAdapter . setDatas ( groupTitles , childItems , selInfoIds ) ; elv . setAdapter ( infoAdapter ) ; for ( int i = 0 ; i < groupTitles . size ( ) ; i ++ ) elv . expandGroup ( i ) ; }
cf0566/FireEyes | private void saveCheckArea ( ) { areaName = etName . getText ( ) . toString ( ) ; if ( areaName . isEmpty ( ) ) { showShortToast ( " 名称不能为空 " ) ; etName . requestFocus ( ) ; return ; } if ( taskId == null ) return ; RequestParams params = new RequestParams ( ) ; params . addBodyParameter ( " token " , token ) ; params . addBodyParameter ( " task _ id " , taskId ) ; params . addBodyParameter ( " name " , areaName ) ; params . addBodyParameter ( " type " , Constants . checkTypeArea ) ; String sels = " " ; if ( selInfoIds . size ( ) > 0 ) { for ( int i = 0 ; i < selInfoIds . size ( ) - 1 ; i ++ ) { sels += selInfoIds . get ( i ) + " , " ; } sels += selInfoIds . get ( selInfoIds . size ( ) - 1 ) ; } params . addBodyParameter ( " ids " , sels ) ; HttpUtils http = new HttpUtils ( ) ; String url = Constants . postUrl + Constants . path_saveCheckUnit ; http . send ( HttpMethod . POST , url , params , new RequestCallBack < String > ( ) { @ Override public void onStart ( ) { if ( progressDialog != null ) progressDialog . show ( ) ; } @ Override public void onFailure ( HttpException arg0 , String arg1 ) { if ( progressDialog != null ) progressDialog . dismiss ( ) ; showShortToast ( " 提交失败 ， 请检查网络连接 " ) ; } @ Override public void onSuccess ( ResponseInfo < String > arg0 ) { if ( progressDialog != null ) progressDialog . dismiss ( ) ; showShortToast ( " 操作成功 " ) ; intent = new Intent ( ) ; intent . putExtra ( " areaName " , areaName ) ; setResult ( RESULT_OK , intent ) ; onBackPressed ( ) ; } } ) ; }
apereo/cas | @ Override public SamlAttributeQueryTicket create ( final String id , final SAMLObject samlObject , final String relyingParty , final TicketGrantingTicket ticketGrantingTicket ) { return FunctionUtils . doUnchecked ( ( ) -> { try ( val w = SamlUtils . transformSamlObject ( this . configBean , samlObject ) ) { val codeId = createTicketIdFor ( id , relyingParty ) ; val service = webApplicationServiceFactory . createService ( relyingParty ) ; service . getAttributes ( ) . put ( TicketGrantingTicket . class . getSimpleName ( ) , CollectionUtils . wrapList ( ticketGrantingTicket . getId ( ) ) ) ; service . getAttributes ( ) . put ( RegisteredService . class . getSimpleName ( ) , CollectionUtils . wrapList ( relyingParty ) ) ; service . getAttributes ( ) . put ( " owner " , CollectionUtils . wrapList ( getTicketType ( ) . getName ( ) ) ) ; return new SamlAttributeQueryTicketImpl ( codeId , service , expirationPolicy . buildTicketExpirationPolicy ( ) , relyingParty , w . toString ( ) , Objects . requireNonNull ( ticketGrantingTicket ) . getAuthentication ( ) ) ; } } ) ; }
apereo/cas | @ Override public Class < ? extends Ticket > getTicketType ( ) { return SamlAttributeQueryTicket . class ; }
ivakegg/accumulo | public SummingCombinerTest ( IteratorTestInput input , IteratorTestOutput expectedOutput , IteratorTestCase testCase ) { super ( input , expectedOutput , testCase ) ; }
Tonius/E-Mobile | public InventoryCellphone ( ItemStack cellphone ) { if ( cellphone == null || ! ( cellphone . getItem ( ) instanceof ItemCellphone ) ) { throw new IllegalArgumentException ( " Invalid ▁ ItemStack ▁ when ▁ creating ▁ a ▁ " + this . getClass ( ) . getSimpleName ( ) + " ▁ instance " ) ; } this . cellphone = cellphone ; this . readFromNBT ( StackUtils . getNBT ( cellphone ) ) ; }
Tonius/E-Mobile | public ItemStack getCellphone ( ) { this . markDirty ( ) ; return this . cellphone ; }
Tonius/E-Mobile | public int getStoredPearls ( ) { ItemStack pearls = this . getStackInSlot ( 0 ) ; return pearls != null ? pearls . stackSize : 0 ; }
Tonius/E-Mobile | public boolean useFuel ( ) { if ( this . getStoredPearls ( ) <= 0 ) { return false ; } this . getStackInSlot ( 0 ) ; this . decrStackSize ( 0 , 1 ) ; this . markDirty ( ) ; return true ; }
Tonius/E-Mobile | public void readFromNBT ( NBTTagCompound tagCompound ) { NBTTagList tagList = tagCompound . getTagList ( " Inventory " , 10 ) ; for ( int i = 0 ; i < tagList . tagCount ( ) ; i ++ ) { NBTTagCompound tag = tagList . getCompoundTagAt ( i ) ; byte slot = tag . getByte ( " Slot " ) ; if ( slot >= 0 && slot < this . inv . length ) { this . inv [ slot ] = ItemStack . loadItemStackFromNBT ( tag ) ; } } }
Tonius/E-Mobile | public void writeToNBT ( NBTTagCompound tagCompound ) { NBTTagList itemList = new NBTTagList ( ) ; for ( int i = 0 ; i < this . inv . length ; i ++ ) { ItemStack stack = this . inv [ i ] ; if ( stack != null ) { NBTTagCompound tag = new NBTTagCompound ( ) ; tag . setByte ( " Slot " , ( byte ) i ) ; stack . writeToNBT ( tag ) ; itemList . appendTag ( tag ) ; } } tagCompound . setTag ( " Inventory " , itemList ) ; }
Tonius/E-Mobile | @ Override public int getSizeInventory ( ) { return this . inv . length ; }
Tonius/E-Mobile | @ Override public ItemStack getStackInSlot ( int slot ) { return this . inv [ slot ] ; }
Tonius/E-Mobile | @ Override public ItemStack decrStackSize ( int slot , int amount ) { ItemStack itemStack = this . getStackInSlot ( slot ) ; if ( itemStack != null ) { if ( itemStack . stackSize <= amount ) { this . setInventorySlotContents ( slot , null ) ; } else { itemStack = itemStack . splitStack ( amount ) ; if ( itemStack . stackSize == 0 ) { this . setInventorySlotContents ( slot , null ) ; } } } return itemStack ; }
Tonius/E-Mobile | @ Override public ItemStack getStackInSlotOnClosing ( int slot ) { ItemStack itemStack = this . getStackInSlot ( slot ) ; if ( itemStack != null ) { this . setInventorySlotContents ( slot , null ) ; } return itemStack ; }
Tonius/E-Mobile | @ Override public void setInventorySlotContents ( int slot , ItemStack itemStack ) { this . inv [ slot ] = itemStack ; if ( itemStack != null && itemStack . stackSize > this . getInventoryStackLimit ( ) ) { itemStack . stackSize = this . getInventoryStackLimit ( ) ; } }
Tonius/E-Mobile | @ Override public String getInventoryName ( ) { return this . cellphone . getDisplayName ( ) ; }
Tonius/E-Mobile | @ Override public boolean hasCustomInventoryName ( ) { return true ; }
Tonius/E-Mobile | @ Override public int getInventoryStackLimit ( ) { return 64 ; }
Tonius/E-Mobile | @ Override public void markDirty ( ) { NBTTagCompound tagCompound = StackUtils . getNBT ( this . cellphone ) ; this . writeToNBT ( tagCompound ) ; this . cellphone . setTagCompound ( tagCompound ) ; }
Tonius/E-Mobile | @ Override public boolean isUseableByPlayer ( EntityPlayer player ) { return true ; }
Tonius/E-Mobile | @ Override public void openInventory ( ) { }
Tonius/E-Mobile | @ Override public void closeInventory ( ) { }
Tonius/E-Mobile | @ Override public boolean isItemValidForSlot ( int slot , ItemStack item ) { return item != null && item . getItem ( ) instanceof ItemEnderPearl ; }
shaunmahony/seqcode | public GeneDomainData ( Gene g , int win ) { super ( g ) ; gene = g ; window = new Region ( gene . getGenome ( ) , gene . getChrom ( ) , gene . getStart ( ) - win , gene . getEnd ( ) + win ) ; windowData = new RegionDomainData ( window ) ; exons = new Vector < Region > ( ) ; exonData = new Vector < RegionDomainData > ( ) ; if ( g instanceof ExonicGene ) { ExonicGene eg = ( ExonicGene ) g ; Iterator < Region > exitr = eg . getExons ( ) ; while ( exitr . hasNext ( ) ) { Region ex = exitr . next ( ) ; exons . add ( ex ) ; exonData . add ( new RegionDomainData ( ex ) ) ; } } }
shaunmahony/seqcode | public void addDomain ( Region dom ) { super . addDomain ( dom ) ; windowData . addDomain ( dom ) ; for ( RegionDomainData rdd : exonData ) { rdd . addDomain ( dom ) ; } }
shaunmahony/seqcode | public RegionDomainData getWindowData ( ) { return windowData ; }
shaunmahony/seqcode | public RegionDomainData getExonData ( int i ) { return exonData . get ( i ) ; }
shaunmahony/seqcode | public int getNumExons ( ) { return exons . size ( ) ; }
shaunmahony/seqcode | public Region getExon ( int i ) { return exons . get ( i ) ; }
shaunmahony/seqcode | public Region getWindow ( ) { return window ; }
shaunmahony/seqcode | public Gene getGene ( ) { return gene ; }
shaunmahony/seqcode | public boolean isTSSCovered ( ) { Point tss = new Point ( gene . getGenome ( ) , gene . getChrom ( ) , gene . getTSS ( ) ) ; for ( Region unc : uncoveredRegions ) { if ( unc . contains ( tss ) ) { return false ; } } return true ; }
shaunmahony/seqcode | public void printData ( ) { double cover = ( double ) getCoveredBP ( ) / ( double ) getBP ( ) ; double wincover = ( double ) windowData . getCoveredBP ( ) / ( double ) windowData . getBP ( ) ; System . out . println ( " Gene : ▁ " + gene . getID ( ) ) ; System . out . println ( " \tLocation : ▁ " + gene . getLocationString ( ) ) ; System . out . println ( " \t # ▁ Domains : ▁ " + getNumDomains ( ) ) ; for ( Region dom : domains ) { System . out . println ( " \t\t " + dom . getLocationString ( ) ) ; } System . out . println ( " \t % ▁ Coverage : ▁ " + nf . format ( cover ) ) ; System . out . println ( " \t % ▁ Window ▁ Coverage : ▁ " + nf . format ( wincover ) ) ; if ( exons . size ( ) >= 1 ) { System . out . println ( " \t # ▁ Exons : ▁ " + getNumExons ( ) ) ; double ex_cover = ( double ) ( exonData . get ( 0 ) . getCoveredBP ( ) ) / ( double ) ( exonData . get ( 0 ) . getBP ( ) ) ; System . out . println ( " \t % ▁ 1st ▁ Exon ▁ Coverage : ▁ " + nf . format ( ex_cover ) ) ; } System . out . println ( ) ; }
mingjian2049/zstack | public RequestInfo ( HttpServletRequest req ) { session = req . getSession ( ) ; remoteHost = req . getRemoteHost ( ) ; for ( Enumeration e = req . getHeaderNames ( ) ; e . hasMoreElements ( ) ; ) { String name = e . nextElement ( ) . toString ( ) ; headers . add ( name , req . getHeader ( name ) ) ; } try { requestUrl = URLDecoder . decode ( req . getRequestURI ( ) , " UTF - 8" ) ; } catch ( UnsupportedEncodingException e ) { throw new CloudRuntimeException ( e ) ; } }
mingjian2049/zstack | @ Override public boolean handleEvent ( Event e ) { if ( e instanceof APIEvent ) { RequestData d = asyncStore . complete ( ( APIEvent ) e ) ; if ( d != null && d . webHook != null ) { try { callWebHook ( d ) ; } catch ( Throwable t ) { throw new CloudRuntimeException ( t ) ; } } } return false ; }
mingjian2049/zstack | public WebHookRetryException ( ) { }
mingjian2049/zstack | public WebHookRetryException ( String message ) { super ( message ) ; }
mingjian2049/zstack | public WebHookRetryException ( String message , Throwable cause ) { super ( message , cause ) ; }
mingjian2049/zstack | public WebHookRetryException ( Throwable cause ) { super ( cause ) ; }
mingjian2049/zstack | public WebHookRetryException ( String message , Throwable cause , boolean enableSuppression , boolean writableStackTrace ) { super ( message , cause , enableSuppression , writableStackTrace ) ; }
mingjian2049/zstack | if ( evt . isSuccess ( ) ) { RestResponseWrapper w = responseAnnotationByClass . get ( evt . getClass ( ) ) ; if ( w == null ) { throw new CloudRuntimeException ( String . format ( " cannot ▁ find ▁ RestResponseWrapper ▁ for ▁ the ▁ class [ % s ] " , evt . getClass ( ) ) ) ; } writeResponse ( response , w , ret . getResult ( ) ) ; }
mingjian2049/zstack | new Retry < Void > ( ) { String __name__ = String . format ( " call - webhook - % s " , d . webHook ) ; @ Override @ RetryCondition ( onExceptions = { WebHookRetryException . class } , times = 15 , interval = 2 ) protected Void call ( ) { try { if ( requestLogger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( String . format ( " Call ▁ Web - Hook [ % s ] ▁ ( to ▁ % s % s ) " , d . webHook , d . requestInfo . remoteHost , d . requestInfo . requestUrl ) ) ; sb . append ( String . format ( " ▁ Body : ▁ % s " , body ) ) ; requestLogger . trace ( sb . toString ( ) ) ; } Response r = http . newCall ( request ) . execute ( ) ; if ( r . code ( ) < 200 || r . code ( ) >= 300 ) { throw new WebHookRetryException ( String . format ( " failed ▁ to ▁ post ▁ to ▁ the ▁ webhook [ % s ] , ▁ % s " , d . webHook , r . toString ( ) ) ) ; } } catch ( IOException e ) { throw new WebHookRetryException ( e ) ; } return null ; } }
mingjian2049/zstack | @ Override public String toString ( ) { return String . format ( " % s - % s " , requestAnnotation . method ( ) , " null " . equals ( requestAnnotation . path ( ) ) ? apiClass . getName ( ) : path ) ; }
mingjian2049/zstack | Api ( Class clz , RestRequest at ) { apiClass = clz ; requestAnnotation = at ; apiResponseClass = at . responseClass ( ) ; path = String . format ( " % s % s " , RestConstants . API_VERSION , at . path ( ) ) ; if ( at . mappingFields ( ) . length > 0 ) { requestMappingFields = new HashMap < > ( ) ; for ( String mf : at . mappingFields ( ) ) { String [ ] kv = mf . split ( " = " ) ; if ( kv . length != 2 ) { throw new CloudRuntimeException ( String . format ( " bad ▁ requestMappingField [ % s ] ▁ of ▁ % s " , mf , apiClass ) ) ; } requestMappingFields . put ( kv [ 0 ] . trim ( ) , kv [ 1 ] . trim ( ) ) ; } } responseAnnotation = ( RestResponse ) apiResponseClass . getAnnotation ( RestResponse . class ) ; DebugUtils . Assert ( responseAnnotation != null , String . format ( " % s ▁ must ▁ be ▁ annotated ▁ with ▁ @ RestResponse " , apiResponseClass ) ) ; Collections . addAll ( optionalPaths , at . optionalPaths ( ) ) ; optionalPaths = optionalPaths . stream ( ) . map ( p -> String . format ( " % s % s " , RestConstants . API_VERSION , p ) ) . collect ( Collectors . toList ( ) ) ; if ( at . isAction ( ) ) { actionName = StringUtils . removeStart ( apiClass . getSimpleName ( ) , " API " ) ; actionName = StringUtils . removeEnd ( actionName , " Msg " ) ; actionName = StringUtils . uncapitalize ( actionName ) ; } if ( ! at . isAction ( ) && requestAnnotation . parameterName ( ) . isEmpty ( ) && requestAnnotation . method ( ) == HttpMethod . PUT ) { throw new CloudRuntimeException ( String . format ( " Invalid ▁ @ RestRequest ▁ of ▁ % s , ▁ either ▁ isAction ▁ must ▁ be ▁ set ▁ to ▁ true ▁ or " + " ▁ parameterName ▁ is ▁ set ▁ to ▁ a ▁ non - empty ▁ string " , apiClass . getName ( ) ) ) ; } List < Field > fs = FieldUtils . getAllFields ( apiClass ) ; fs = fs . stream ( ) . filter ( f -> ! f . isAnnotationPresent ( APINoSee . class ) && ! Modifier . isStatic ( f . getModifiers ( ) ) ) . collect ( Collectors . toList ( ) ) ; for ( Field f : fs ) { allApiClassFields . put ( f . getName ( ) , f ) ; if ( requestAnnotation . method ( ) == HttpMethod . GET ) { if ( APIQueryMessage . class . isAssignableFrom ( apiClass ) ) { continue ; } if ( Collection . class . isAssignableFrom ( f . getType ( ) ) ) { Class gtype = FieldUtils . getGenericType ( f ) ; if ( gtype == null ) { throw new CloudRuntimeException ( String . format ( " % s . % s ▁ is ▁ of ▁ collection ▁ type ▁ but ▁ doesn ' t ▁ not ▁ have " + " ▁ a ▁ generic ▁ type " , apiClass , f . getName ( ) ) ) ; } if ( ! gtype . getName ( ) . startsWith ( " java . " ) ) { throw new CloudRuntimeException ( String . format ( " % s . % s ▁ is ▁ of ▁ collection ▁ type ▁ with ▁ a ▁ generic ▁ type " + " [ % s ] ▁ not ▁ belonging ▁ to ▁ JDK " , apiClass , f . getName ( ) , gtype ) ) ; } } else if ( Map . class . isAssignableFrom ( f . getType ( ) ) ) { throw new CloudRuntimeException ( String . format ( " % s . % s ▁ is ▁ of ▁ map ▁ type , ▁ however , ▁ the ▁ GET ▁ method ▁ doesn ' t " + " ▁ support ▁ query ▁ parameters ▁ of ▁ map ▁ type " , apiClass , f . getName ( ) ) ) ; } } } }
mingjian2049/zstack | String getMappingField ( String key ) { if ( requestMappingFields == null ) { return null ; } return requestMappingFields . get ( key ) ; }
mingjian2049/zstack | private void mapQueryParameterToApiFieldValue ( String name , String [ ] vals , Map < String , Object > params ) throws RestException { String [ ] pairs = name . split ( " \\ . " ) ; String fname = pairs [ 0 ] ; String key = pairs [ 1 ] ; Field f = allApiClassFields . get ( fname ) ; if ( f == null ) { logger . warn ( String . format ( " unknown ▁ map ▁ query ▁ parameter [ % s ] , ▁ ignore " , name ) ) ; return ; } MapField at = f . getAnnotation ( MapField . class ) ; DebugUtils . Assert ( at != null , String . format ( " % s : : % s ▁ must ▁ be ▁ annotated ▁ by ▁ @ MapField " , apiClass , fname ) ) ; Map m = ( Map ) params . get ( fname ) ; if ( m == null ) { m = new HashMap ( ) ; params . put ( fname , m ) ; } if ( m . containsKey ( key ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " duplicate ▁ map ▁ query ▁ parameter [ % s ] , ▁ there ▁ has ▁ been ▁ a ▁ parameter ▁ with ▁ the ▁ same ▁ map ▁ key " , name ) ) ; } if ( Collection . class . isAssignableFrom ( at . valueType ( ) ) ) { m . put ( key , asList ( vals ) ) ; } else { if ( vals . length > 1 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter [ % s ] , ▁ only ▁ one ▁ value ▁ is ▁ allowed ▁ for ▁ the ▁ parameter ▁ but " + " ▁ multiple ▁ values ▁ found " , name ) ) ; } m . put ( key , vals [ 0 ] ) ; } }
mingjian2049/zstack | Object queryParameterToApiFieldValue ( String name , String [ ] vals ) throws RestException { Field f = allApiClassFields . get ( name ) ; if ( f == null ) { return null ; } if ( Collection . class . isAssignableFrom ( f . getType ( ) ) ) { Class gtype = FieldUtils . getGenericType ( f ) ; List lst = new ArrayList ( ) ; for ( String v : vals ) { lst . add ( TypeUtils . stringToValue ( v , gtype ) ) ; } return lst ; } else { if ( vals . length > 1 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter [ % s ] , ▁ only ▁ one ▁ value ▁ is ▁ allowed ▁ for ▁ the ▁ parameter ▁ but " + " ▁ multiple ▁ values ▁ found " , name ) ) ; } return TypeUtils . stringToValue ( vals [ 0 ] , f . getType ( ) ) ; } }
mingjian2049/zstack | public RestException ( int statusCode , String error ) { this . statusCode = statusCode ; this . error = error ; }
mingjian2049/zstack | public RestResponseWrapper ( RestResponse annotation , Class apiResponseClass ) { this . annotation = annotation ; this . apiResponseClass = apiResponseClass ; if ( annotation . fieldsTo ( ) . length > 0 ) { responseMappingFields = new HashMap < > ( ) ; if ( annotation . fieldsTo ( ) . length == 1 && " all " . equals ( annotation . fieldsTo ( ) [ 0 ] ) ) { List < Field > apiFields = FieldUtils . getAllFields ( apiResponseClass ) ; apiFields = apiFields . stream ( ) . filter ( f -> ! f . isAnnotationPresent ( APINoSee . class ) && ! Modifier . isStatic ( f . getModifiers ( ) ) ) . collect ( Collectors . toList ( ) ) ; for ( Field f : apiFields ) { responseMappingFields . put ( f . getName ( ) , f . getName ( ) ) ; } } else { for ( String mf : annotation . fieldsTo ( ) ) { String [ ] kv = mf . split ( " = " ) ; if ( kv . length == 2 ) { responseMappingFields . put ( kv [ 0 ] . trim ( ) , kv [ 1 ] . trim ( ) ) ; } else if ( kv . length == 1 ) { responseMappingFields . put ( kv [ 0 ] . trim ( ) , kv [ 0 ] . trim ( ) ) ; } else { throw new CloudRuntimeException ( String . format ( " bad ▁ mappingFields [ % s ] ▁ of ▁ % s " , mf , apiResponseClass ) ) ; } } } } }
mingjian2049/zstack | private HttpEntity < String > toHttpEntity ( HttpServletRequest req ) { try { String body = IOUtils . toString ( req . getReader ( ) ) ; req . getReader ( ) . close ( ) ; HttpHeaders header = new HttpHeaders ( ) ; for ( Enumeration e = req . getHeaderNames ( ) ; e . hasMoreElements ( ) ; ) { String name = e . nextElement ( ) . toString ( ) ; header . add ( name , req . getHeader ( name ) ) ; } return new HttpEntity < > ( body , header ) ; } catch ( Exception e ) { logger . warn ( e . getMessage ( ) , e ) ; throw new CloudRuntimeException ( e ) ; } }
mingjian2049/zstack | private void sendResponse ( int statusCode , String body , HttpServletResponse rsp ) throws IOException { if ( requestLogger . isTraceEnabled ( ) ) { RequestInfo info = requestInfo . get ( ) ; StringBuilder sb = new StringBuilder ( String . format ( " [ ID : ▁ % s ] ▁ Response ▁ to ▁ % s ▁ ( % s ) , " , info . session . getId ( ) , info . remoteHost , info . requestUrl ) ) ; sb . append ( String . format ( " ▁ Status ▁ Code : ▁ % s , " , statusCode ) ) ; sb . append ( String . format ( " ▁ Body : ▁ % s " , body == null || body . isEmpty ( ) ? null : body ) ) ; requestLogger . trace ( sb . toString ( ) ) ; } rsp . setStatus ( statusCode ) ; rsp . getWriter ( ) . write ( body == null ? " " : body ) ; }
mingjian2049/zstack | private String getDecodedUrl ( HttpServletRequest req ) { try { if ( req . getContextPath ( ) == null ) { return URLDecoder . decode ( req . getRequestURI ( ) , " UTF - 8" ) ; } else { return URLDecoder . decode ( StringUtils . removeStart ( req . getRequestURI ( ) , req . getContextPath ( ) ) , " UTF - 8" ) ; } } catch ( UnsupportedEncodingException e ) { throw new CloudRuntimeException ( e ) ; } }
mingjian2049/zstack | if ( requestLogger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( String . format ( " [ ID : ▁ % s , ▁ Method : ▁ % s ] ▁ Request ▁ from ▁ % s ▁ ( to ▁ % s ) , ▁ " , req . getSession ( ) . getId ( ) , req . getMethod ( ) , req . getRemoteHost ( ) , URLDecoder . decode ( req . getRequestURI ( ) , " UTF - 8" ) ) ) ; sb . append ( String . format ( " ▁ Headers : ▁ % s , " , JSONObjectUtil . toJsonString ( entity . getHeaders ( ) ) ) ) ; if ( req . getQueryString ( ) != null && ! req . getQueryString ( ) . isEmpty ( ) ) { sb . append ( String . format ( " ▁ Query : ▁ % s , " , URLDecoder . decode ( req . getQueryString ( ) , " UTF - 8" ) ) ) ; } sb . append ( String . format ( " ▁ Body : ▁ % s " , entity . getBody ( ) . isEmpty ( ) ? null : entity . getBody ( ) ) ) ; requestLogger . trace ( sb . toString ( ) ) ; }
mingjian2049/zstack | if ( matcher . match ( ASYNC_JOB_PATH_PATTERN , path ) ) { handleJobQuery ( req , rsp ) ; return ; }
mingjian2049/zstack | if ( api == null ) { for ( String p : apis . keySet ( ) ) { if ( matcher . match ( p , path ) ) { api = apis . get ( p ) ; break ; } } }
mingjian2049/zstack | if ( api == null ) { sendResponse ( HttpStatus . NOT_FOUND . value ( ) , String . format ( " no ▁ api ▁ mapping ▁ to ▁ % s " , path ) , rsp ) ; return ; }
mingjian2049/zstack | if ( api instanceof Api ) { handleUniqueApi ( ( Api ) api , entity , req , rsp ) ; }
mingjian2049/zstack | catch ( RestException e ) { sendResponse ( e . statusCode , e . error , rsp ) ; }
mingjian2049/zstack | catch ( Throwable e ) { logger . warn ( String . format ( " failed ▁ to ▁ handle ▁ API ▁ to ▁ % s " , path ) , e ) ; sendResponse ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , e . getMessage ( ) , rsp ) ; }
mingjian2049/zstack | if ( ! req . getMethod ( ) . equals ( HttpMethod . GET . name ( ) ) ) { sendResponse ( HttpStatus . METHOD_NOT_ALLOWED . value ( ) , " only ▁ GET ▁ method ▁ is ▁ allowed ▁ for ▁ querying ▁ job ▁ status " , rsp ) ; return ; }
mingjian2049/zstack | if ( ret . getState ( ) == AsyncRestState . expired ) { sendResponse ( HttpStatus . NOT_FOUND . value ( ) , " the ▁ job ▁ has ▁ been ▁ expired " , rsp ) ; return ; }
mingjian2049/zstack | if ( ret . getState ( ) == AsyncRestState . processing ) { sendResponse ( HttpStatus . ACCEPTED . value ( ) , response , rsp ) ; return ; }
mingjian2049/zstack | if ( evt . isSuccess ( ) ) { RestResponseWrapper w = responseAnnotationByClass . get ( evt . getClass ( ) ) ; if ( w == null ) { throw new CloudRuntimeException ( String . format ( " cannot ▁ find ▁ RestResponseWrapper ▁ for ▁ the ▁ class [ % s ] " , evt . getClass ( ) ) ) ; } writeResponse ( response , w , ret . getResult ( ) ) ; sendResponse ( HttpStatus . OK . value ( ) , response , rsp ) ; }
mingjian2049/zstack | private void sendResponse ( int statusCode , ApiResponse response , HttpServletResponse rsp ) throws IOException { sendResponse ( statusCode , response . isEmpty ( ) ? " " : JSONObjectUtil . toJsonString ( response ) , rsp ) ; }
mingjian2049/zstack | if ( " POST " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> a . requestAnnotation . method ( ) . name ( ) . equals ( " POST " ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , String . format ( " No ▁ creational ▁ API ▁ found " + " ▁ for ▁ the ▁ path [ % s ] " , req . getRequestURI ( ) ) ) ; } api = o . get ( ) ; }
mingjian2049/zstack | else if ( " PUT " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> m . containsKey ( a . actionName ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " the ▁ body ▁ doesn ' t ▁ contain ▁ action ▁ mapping " + " ▁ to ▁ the ▁ URL [ % s ] " , getDecodedUrl ( req ) ) ) ; } api = o . get ( ) ; parameterName = api . actionName ; }
mingjian2049/zstack | else if ( " GET " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> a . requestAnnotation . method ( ) . name ( ) . equals ( " GET " ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , String . format ( " No ▁ query ▁ API ▁ found " + " ▁ for ▁ the ▁ path [ % s ] " , req . getRequestURI ( ) ) ) ; } api = o . get ( ) ; }
mingjian2049/zstack | else if ( " DELETE " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> a . requestAnnotation . method ( ) . name ( ) . equals ( " DELETE " ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , String . format ( " No ▁ delete ▁ API ▁ found " + " ▁ for ▁ the ▁ path [ % s ] " , req . getRequestURI ( ) ) ) ; } api = o . get ( ) ; }
mingjian2049/zstack | if ( body == null ) { body = new HashMap ( ) ; }
mingjian2049/zstack | if ( ! api . apiClass . isAnnotationPresent ( SuppressCredentialCheck . class ) ) { String auth = entity . getHeaders ( ) . getFirst ( " Authorization " ) ; if ( auth == null ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , " missing ▁ header ▁ ' Authorization ' " ) ; } auth = auth . trim ( ) ; if ( ! auth . startsWith ( RestConstants . HEADER_OAUTH ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Authorization ▁ type ▁ must ▁ be ▁ ' % s ' " , RestConstants . HEADER_OAUTH ) ) ; } sessionId = auth . replaceFirst ( " OAuth " , " " ) . trim ( ) ; }
mingjian2049/zstack | if ( APIQueryMessage . class . isAssignableFrom ( api . apiClass ) ) { handleQueryApi ( api , sessionId , req , rsp ) ; return ; }
mingjian2049/zstack | if ( req . getMethod ( ) . equals ( HttpMethod . GET . toString ( ) ) || req . getMethod ( ) . equals ( HttpMethod . DELETE . toString ( ) ) ) { Map < String , Object > m = new HashMap < > ( ) ; Map < String , String [ ] > queryParameters = req . getParameterMap ( ) ; for ( Map . Entry < String , String [ ] > e : queryParameters . entrySet ( ) ) { String k = e . getKey ( ) ; String [ ] vals = e . getValue ( ) ; if ( k . contains ( " . " ) ) { api . mapQueryParameterToApiFieldValue ( k , vals , m ) ; } else { Object val = api . queryParameterToApiFieldValue ( k , vals ) ; if ( val == null ) { logger . warn ( String . format ( " unknown ▁ query ▁ parameter [ % s ] , ▁ ignored " , k ) ) ; continue ; } m . put ( k , val ) ; } } parameter = m ; }
mingjian2049/zstack | if ( parameter == null ) { msg = ( APIMessage ) api . apiClass . newInstance ( ) ; }
mingjian2049/zstack | if ( requestInfo . get ( ) . headers . containsKey ( RestConstants . HEADER_JOB_UUID ) ) { String jobUuid = requestInfo . get ( ) . headers . get ( RestConstants . HEADER_JOB_UUID ) . get ( 0 ) ; if ( jobUuid . length ( ) != 32 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ header [ % s ] , ▁ it " + " ▁ must ▁ be ▁ a ▁ UUID ▁ with ▁ ' - ' ▁ stripped " , RestConstants . HEADER_JOB_UUID ) ) ; } msg . setId ( jobUuid ) ; }
mingjian2049/zstack | if ( sessionId != null ) { SessionInventory session = new SessionInventory ( ) ; session . setUuid ( sessionId ) ; msg . setSession ( session ) ; }
mingjian2049/zstack | if ( ! req . getMethod ( ) . equals ( HttpMethod . GET . toString ( ) ) && ! req . getMethod ( ) . equals ( HttpMethod . DELETE . toString ( ) ) ) { Object systemTags = body . get ( " systemTags " ) ; if ( systemTags != null ) { msg . setSystemTags ( ( List < String > ) systemTags ) ; } Object userTags = body . get ( " userTags " ) ; if ( userTags != null ) { msg . setUserTags ( ( List < String > ) userTags ) ; } }
mingjian2049/zstack | for ( Map . Entry < String , String > e : vars . entrySet ( ) ) { String key = e . getKey ( ) ; String mappingKey = api . getMappingField ( key ) ; PropertyUtils . setProperty ( msg , mappingKey == null ? key : mappingKey , e . getValue ( ) ) ; }
mingjian2049/zstack | if ( uuid != null ) { QueryCondition qc = new QueryCondition ( ) ; qc . setName ( " uuid " ) ; qc . setOp ( " = " ) ; qc . setValue ( uuid ) ; msg . getConditions ( ) . add ( qc ) ; sendMessage ( msg , api , rsp ) ; return ; }
mingjian2049/zstack | for ( Map . Entry < String , String [ ] > e : vars . entrySet ( ) ) { String varname = e . getKey ( ) . trim ( ) ; String varvalue = e . getValue ( ) [ 0 ] . trim ( ) ; if ( " limit " . equals ( varname ) ) { try { msg . setLimit ( Integer . valueOf ( varvalue ) ) ; } catch ( NumberFormatException ex ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , " Invalid ▁ query ▁ parameter . ▁ ' limit ' ▁ must ▁ be ▁ an ▁ integer " ) ; } } else if ( " start " . equals ( varname ) ) { try { msg . setStart ( Integer . valueOf ( varvalue ) ) ; } catch ( NumberFormatException ex ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , " Invalid ▁ query ▁ parameter . ▁ ' start ' ▁ must ▁ be ▁ an ▁ integer " ) ; } } else if ( " count " . equals ( varname ) ) { msg . setCount ( Boolean . valueOf ( varvalue ) ) ; } else if ( " groupBy " . equals ( varname ) ) { msg . setGroupBy ( varvalue ) ; } else if ( " replyWithCount " . equals ( varname ) ) { msg . setReplyWithCount ( Boolean . valueOf ( varvalue ) ) ; } else if ( " sort " . equals ( varname ) ) { if ( varvalue . startsWith ( " + " ) ) { msg . setSortDirection ( " asc " ) ; varvalue = StringUtils . stripStart ( varvalue , " + " ) ; } else if ( varvalue . startsWith ( " - " ) ) { msg . setSortDirection ( " desc " ) ; varvalue = StringUtils . stripStart ( varvalue , " - " ) ; } else { msg . setSortDirection ( " asc " ) ; } msg . setSortBy ( varvalue ) ; } else if ( " q " . startsWith ( varname ) ) { String [ ] conds = e . getValue ( ) ; for ( String cond : conds ) { String OP = null ; String delimiter = null ; for ( String op : QUERY_OP_MAPPING . keySet ( ) ) { if ( cond . contains ( op ) ) { OP = QUERY_OP_MAPPING . get ( op ) ; delimiter = op ; break ; } } if ( OP == null ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter . " + " ▁ The ▁ ' % s ' ▁ in ▁ the ▁ parameter [ q ] ▁ doesn ' t ▁ contain ▁ any ▁ query ▁ operator . ▁ Valid ▁ query ▁ operators ▁ are " + " ▁ % s " , cond , asList ( QUERY_OP_MAPPING . keySet ( ) ) ) ) ; } QueryCondition qc = new QueryCondition ( ) ; String [ ] ks = StringUtils . splitByWholeSeparator ( cond , delimiter , 2 ) ; if ( OP . equals ( QueryOp . IS_NULL . toString ( ) ) || OP . equals ( QueryOp . NOT_NULL . toString ( ) ) ) { String cname = ks [ 0 ] . trim ( ) ; qc . setName ( cname ) ; qc . setOp ( OP ) ; } else { if ( ks . length != 2 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter . " + " ▁ The ▁ ' % s ' ▁ in ▁ parameter [ q ] ▁ is ▁ not ▁ a ▁ key - value ▁ pair ▁ split ▁ by ▁ % s " , cond , OP ) ) ; } String cname = ks [ 0 ] . trim ( ) ; String cvalue = ks [ 1 ] ; qc . setName ( cname ) ; qc . setOp ( OP ) ; qc . setValue ( cvalue ) ; } msg . getConditions ( ) . add ( qc ) ; } } else if ( " fields " . equals ( varname ) ) { List < String > fs = new ArrayList < > ( ) ; for ( String f : varvalue . split ( " , " ) ) { fs . add ( f . trim ( ) ) ; } if ( fs . isEmpty ( ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter . ▁ ' fields ' " + " ▁ contains ▁ zero ▁ field " ) ) ; } msg . setFields ( fs ) ; } }
mingjian2049/zstack | if ( msg . getConditions ( ) == null ) { msg . setConditions ( new ArrayList < > ( ) ) ; }
mingjian2049/zstack | if ( ! w . annotation . allTo ( ) . equals ( " " ) ) { response . put ( w . annotation . allTo ( ) , PropertyUtils . getProperty ( replyOrEvent , w . annotation . allTo ( ) ) ) ; }
mingjian2049/zstack | for ( Map . Entry < String , String > e : w . responseMappingFields . entrySet ( ) ) { response . put ( e . getKey ( ) , PropertyUtils . getProperty ( replyOrEvent , e . getValue ( ) ) ) ; }
mingjian2049/zstack | if ( APIQueryReply . class . isAssignableFrom ( w . apiResponseClass ) ) { Object total = PropertyUtils . getProperty ( replyOrEvent , " total " ) ; if ( total != null ) { response . put ( " total " , total ) ; } }
mingjian2049/zstack | if ( requestInfo . get ( ) . headers . containsKey ( RestConstants . HEADER_JSON_SCHEMA ) || APIQueryReply . class . isAssignableFrom ( w . apiResponseClass ) ) { response . setSchema ( new JsonSchemaBuilder ( response ) . build ( ) ) ; }
mingjian2049/zstack | if ( ! reply . isSuccess ( ) ) { response . setError ( reply . getError ( ) ) ; sendResponse ( HttpStatus . SERVICE_UNAVAILABLE . value ( ) , JSONObjectUtil . toJsonString ( response ) , rsp ) ; return ; }
mingjian2049/zstack | if ( msg instanceof APISyncCallMessage ) { MessageReply reply = bus . call ( msg ) ; sendReplyResponse ( reply , api , rsp ) ; }
mingjian2049/zstack | if ( webHook != null && ! webHook . isEmpty ( ) ) { d . webHook = webHook . get ( 0 ) ; }
mingjian2049/zstack | @ Override public boolean start ( ) { build ( ) ; return true ; }
mingjian2049/zstack | private String substituteUrl ( String url , Map < String , String > tokens ) { Pattern pattern = Pattern . compile ( " \\ { ( . + ? ) \\ } " ) ; Matcher matcher = pattern . matcher ( url ) ; StringBuffer buffer = new StringBuffer ( ) ; while ( matcher . find ( ) ) { String varName = matcher . group ( 1 ) ; Object replacement = tokens . get ( varName ) ; if ( replacement == null ) { throw new CloudRuntimeException ( String . format ( " cannot ▁ find ▁ value ▁ for ▁ URL ▁ variable [ % s ] " , varName ) ) ; } matcher . appendReplacement ( buffer , " " ) ; buffer . append ( replacement . toString ( ) ) ; } matcher . appendTail ( buffer ) ; return buffer . toString ( ) ; }
mingjian2049/zstack | private List < String > getVarNamesFromUrl ( String url ) { Pattern pattern = Pattern . compile ( " \\ { ( . + ? ) \\ } " ) ; Matcher matcher = pattern . matcher ( url ) ; List < String > urlVars = new ArrayList < > ( ) ; while ( matcher . find ( ) ) { urlVars . add ( matcher . group ( 1 ) ) ; } return urlVars ; }
mingjian2049/zstack | private String normalizePath ( String p ) { List < String > varNames = getVarNamesFromUrl ( p ) ; if ( varNames . isEmpty ( ) ) { return p ; } Map < String , String > m = new HashMap < > ( ) ; for ( int i = 0 ; i < varNames . size ( ) ; i ++ ) { m . put ( varNames . get ( i ) , String . format ( " { % s } " , i ) ) ; } return substituteUrl ( p , m ) ; }
mingjian2049/zstack | private void build ( ) { Reflections reflections = Platform . getReflections ( ) ; Set < Class < ? > > classes = reflections . getTypesAnnotatedWith ( RestRequest . class ) . stream ( ) . filter ( it -> it . isAnnotationPresent ( RestRequest . class ) ) . collect ( Collectors . toSet ( ) ) ; for ( Class clz : classes ) { RestRequest at = ( RestRequest ) clz . getAnnotation ( RestRequest . class ) ; Api api = new Api ( clz , at ) ; List < String > paths = new ArrayList < > ( ) ; if ( ! " null " . equals ( api . path ) ) { paths . add ( api . path ) ; } paths . addAll ( api . optionalPaths ) ; for ( String path : paths ) { String normalizedPath = normalizePath ( path ) ; api = new Api ( clz , at ) ; api . path = path ; if ( ! apis . containsKey ( normalizedPath ) ) { apis . put ( normalizedPath , api ) ; } else { Object c = apis . get ( normalizedPath ) ; List lst ; if ( c instanceof Api ) { lst = new ArrayList ( ) ; lst . add ( c ) ; apis . put ( normalizedPath , lst ) ; } else { lst = ( List ) c ; } lst . add ( api ) ; } } responseAnnotationByClass . put ( api . apiResponseClass , new RestResponseWrapper ( api . responseAnnotation , api . apiResponseClass ) ) ; } for ( Object o : apis . values ( ) ) { if ( ! ( o instanceof List ) ) { continue ; } List < Api > as = ( List < Api > ) o ; List < Api > nonActions = as . stream ( ) . filter ( a -> ! a . requestAnnotation . isAction ( ) ) . collect ( Collectors . toList ( ) ) ; Map < String , Api > set = new HashMap < > ( ) ; for ( Api a : nonActions ) { Api old = set . get ( a . toString ( ) ) ; if ( old != null ) { throw new CloudRuntimeException ( String . format ( " duplicate ▁ rest ▁ API [ % s , ▁ % s ] , ▁ they ▁ both ▁ have ▁ the ▁ same " + " ▁ HTTP ▁ methods ▁ and ▁ paths , ▁ and ▁ both ▁ are ▁ not ▁ actions . ▁ % s " , a . apiClass , old . apiClass , a . toString ( ) ) ) ; } set . put ( a . toString ( ) , a ) ; } List < Api > actions = as . stream ( ) . filter ( a -> a . requestAnnotation . isAction ( ) ) . collect ( Collectors . toList ( ) ) ; set = new HashMap < > ( ) ; for ( Api a : actions ) { Api old = set . get ( a . actionName ) ; if ( old != null ) { throw new CloudRuntimeException ( String . format ( " duplicate ▁ rest ▁ API [ % s , ▁ % s ] , ▁ they ▁ are ▁ both ▁ actions ▁ with ▁ the " + " ▁ same ▁ action ▁ name [ % s ] " , a . apiClass , old . apiClass , a . actionName ) ) ; } set . put ( a . actionName , a ) ; } } }
mingjian2049/zstack | @ Override public boolean stop ( ) { return true ; }
camunda/camunda-bpm-camel | @ Test public void getSignalProcessProducerFromUri ( ) throws Exception { CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; assertThat ( producer ) . isInstanceOf ( MessageProducer . class ) ; }
camunda/camunda-bpm-camel | @ Test public void messageIsDeliveredCalled ( ) throws Exception { ProcessInstance processInstance = mock ( ProcessInstance . class ) ; when ( processInstance . getProcessInstanceId ( ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( processInstance . getProcessDefinitionId ( ) ) . thenReturn ( " theProcessDefinitionId " ) ; when ( runtimeService . startProcessInstanceByKey ( eq ( " aProcessDefinitionKey " ) , anyMap ( ) ) ) . thenReturn ( processInstance ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; assertThat ( producer ) . isInstanceOf ( MessageProducer . class ) ; }
camunda/camunda-bpm-camel | @ Test public void signalCalled ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; ExecutionQuery query = mock ( ExecutionQuery . class ) ; Execution execution = mock ( Execution . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_PROCESS_INSTANCE_ID ) , eq ( String . class ) ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( runtimeService . createExecutionQuery ( ) ) . thenReturn ( query ) ; when ( query . processInstanceId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . activityId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . singleResult ( ) ) . thenReturn ( execution ) ; when ( execution . getId ( ) ) . thenReturn ( "1234" ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; verify ( runtimeService ) . signal ( anyString ( ) , anyMap ( ) ) ; }
camunda/camunda-bpm-camel | @ Test public void signalTransformBusinesskey ( ) throws Exception { Exchange exchange = mock ( ExtendedExchange . class ) ; Message message = mock ( Message . class ) ; ExecutionQuery query = mock ( ExecutionQuery . class ) ; Execution execution = mock ( Execution . class ) ; ProcessInstanceQuery piQuery = mock ( ProcessInstanceQuery . class ) ; ProcessInstance processInstance = mock ( ProcessInstance . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; when ( runtimeService . createProcessInstanceQuery ( ) ) . thenReturn ( piQuery ) ; when ( runtimeService . createExecutionQuery ( ) ) . thenReturn ( query ) ; when ( piQuery . processInstanceBusinessKey ( anyString ( ) ) ) . thenReturn ( piQuery ) ; when ( piQuery . singleResult ( ) ) . thenReturn ( processInstance ) ; when ( processInstance . getId ( ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( query . processInstanceId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . activityId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . singleResult ( ) ) . thenReturn ( execution ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; verify ( piQuery ) . processInstanceBusinessKey ( " theBusinessKey " ) ; verify ( query ) . processInstanceId ( " theProcessInstanceId " ) ; }
camunda/camunda-bpm-camel | @ Test public void messageProcessInstanceId ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; ExecutionQuery query = mock ( ExecutionQuery . class ) ; Execution execution = mock ( Execution . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_PROCESS_INSTANCE_ID ) , eq ( String . class ) ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( runtimeService . createExecutionQuery ( ) ) . thenReturn ( query ) ; when ( query . processInstanceId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . messageEventSubscriptionName ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . singleResult ( ) ) . thenReturn ( execution ) ; when ( execution . getId ( ) ) . thenReturn ( " theExecutionId " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; verify ( query ) . processInstanceId ( " theProcessInstanceId " ) ; verify ( query ) . messageEventSubscriptionName ( " aMessageName " ) ; verify ( runtimeService ) . messageEventReceived ( eq ( " aMessageName " ) , eq ( " theExecutionId " ) , anyMap ( ) ) ; }
camunda/camunda-bpm-camel | @ Test public void messageBusinessKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , eq ( " theBusinessKey " ) , correlationCaptor . capture ( ) , anyMap ( ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
camunda/camunda-bpm-camel | @ Test public void messageBusinessKeyCorrelationKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; final String BODY = " body " ; when ( message . getBody ( ) ) . thenReturn ( BODY ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theCorrelationKey " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " + " & " + CORRELATION_KEY_NAME_PARAMETER + " = " + " aCorrelationKeyName " + " & " + COPY_MESSAGE_BODY_AS_PROCESS_VARIABLE_PARAMETER + " = test " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; ArgumentCaptor < Map < String , Object > > variablesCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , eq ( " theBusinessKey " ) , correlationCaptor . capture ( ) , variablesCaptor . capture ( ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( correlationCaptor . getValue ( ) . keySet ( ) . contains ( " aCorrelationKeyName " ) ) ; assertTrue ( correlationCaptor . getValue ( ) . values ( ) . contains ( " theCorrelationKey " ) ) ; assertThat ( variablesCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( variablesCaptor . getValue ( ) . containsKey ( " test " ) ) ; assertTrue ( variablesCaptor . getValue ( ) . containsValue ( BODY ) ) ; }
camunda/camunda-bpm-camel | @ Test public void messageBusinessKeyCorrelationKeyType ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY ) , eq ( java . lang . Integer . class ) ) ) . thenReturn ( 15 ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY_TYPE ) , eq ( String . class ) ) ) . thenReturn ( " java . lang . Integer " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " + " & " + CORRELATION_KEY_NAME_PARAMETER + " = " + " aCorrelationKeyName " + " & " + EXCHANGE_HEADER_CORRELATION_KEY_TYPE + " = java . lang . Integer " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , eq ( " theBusinessKey " ) , correlationCaptor . capture ( ) , anyMap ( ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( correlationCaptor . getValue ( ) . keySet ( ) . contains ( " aCorrelationKeyName " ) ) ; assertTrue ( correlationCaptor . getValue ( ) . values ( ) . contains ( 15 ) ) ; }
camunda/camunda-bpm-camel | @ Test public void messageNoKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , correlationCaptor . capture ( ) , anyMapOf ( String . class , Object . class ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
camunda/camunda-bpm-camel | @ Test public void messageCorrelationKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theCorrelationKey " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " + " & " + CORRELATION_KEY_NAME_PARAMETER + " = " + " aCorrelationKeyName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , correlationCaptor . capture ( ) , anyMapOf ( String . class , Object . class ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( correlationCaptor . getValue ( ) . keySet ( ) . contains ( " aCorrelationKeyName " ) ) ; assertTrue ( correlationCaptor . getValue ( ) . values ( ) . contains ( " theCorrelationKey " ) ) ; }
camunda/camunda-bpm-camel | @ Test ( expected = IllegalArgumentException . class ) public void shouldFailWithoutMessageActivityId ( ) throws Exception { CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message " ) ) ; endpoint . createProducer ( ) ; }
PG85/OpenTerrainGenerator | public PlottedChunksRegion ( ) { }
PG85/OpenTerrainGenerator | PlottedChunksRegion ( boolean [ ] [ ] plottedChunks ) { this . plottedChunks = plottedChunks ; }
PG85/OpenTerrainGenerator | boolean requiresSave ( ) { return this . requiresSave ; }
PG85/OpenTerrainGenerator | void markSaved ( ) { this . requiresSave = false ; }
PG85/OpenTerrainGenerator | public boolean getChunk ( int internalX , int internalZ ) { return this . plottedChunks [ internalX ] [ internalZ ] ; }
PG85/OpenTerrainGenerator | public void setChunk ( int internalX , int internalZ ) { this . plottedChunks [ internalX ] [ internalZ ] = true ; this . requiresSave = true ; }
PG85/OpenTerrainGenerator | public boolean [ ] [ ] getArray ( ) { return this . plottedChunks ; }
imikemo/robot-plugin | public RobotSuiteResult ( String name ) { this . name = name ; this . parent = null ; }
imikemo/robot-plugin | public RobotSuiteResult ( RobotTestObject parent , Element suite , File baseDirectory ) throws DocumentException { this . name = suite . attributeValue ( " name " ) ; this . parent = parent ; this . baseDirectory = baseDirectory ; if ( suite . attributeValue ( " src " ) != null ) { parseExternalFile ( suite ) ; } else { parseChildren ( suite ) ; } }
imikemo/robot-plugin | private void parseExternalFile ( Element suite ) throws DocumentException { File externalFile = new File ( baseDirectory , suite . attributeValue ( " src " ) ) ; SAXReader reader = new SAXReader ( ) ; Document splittedOutput = reader . read ( externalFile ) ; Element rootElement = splittedOutput . getRootElement ( ) . element ( " suite " ) ; parseChildren ( rootElement ) ; }
imikemo/robot-plugin | private void parseChildren ( Element suite ) throws DocumentException { for ( Element nestedSuite : ( List < Element > ) suite . elements ( " suite " ) ) { RobotSuiteResult suiteResult = new RobotSuiteResult ( this , nestedSuite , baseDirectory ) ; addChild ( suiteResult ) ; } for ( Element testCase : ( List < Element > ) suite . elements ( " test " ) ) { RobotCaseResult caseResult = new RobotCaseResult ( this , testCase ) ; addCaseResult ( caseResult ) ; } }
imikemo/robot-plugin | public void addChild ( RobotSuiteResult child ) { if ( children == null ) children = new HashMap < String , RobotSuiteResult > ( ) ; children . put ( child . getSafeName ( ) , child ) ; }
imikemo/robot-plugin | public Collection < RobotSuiteResult > getChildSuites ( ) { return children == null ? new ArrayList < RobotSuiteResult > ( ) : children . values ( ) ; }
imikemo/robot-plugin | public RobotTestObject getParent ( ) { return parent ; }
imikemo/robot-plugin | public String getName ( ) { return name ; }
imikemo/robot-plugin | public Collection < RobotCaseResult > getCaseResults ( ) { return caseResults == null ? new ArrayList < RobotCaseResult > ( ) : caseResults . values ( ) ; }
imikemo/robot-plugin | public int getFailed ( ) { return failed ; }
imikemo/robot-plugin | public int getPassed ( ) { return passed ; }
imikemo/robot-plugin | public int getTotal ( ) { return passed + failed ; }
imikemo/robot-plugin | public long getDuration ( ) { return duration ; }
imikemo/robot-plugin | public int getCriticalPassed ( ) { return criticalPassed ; }
imikemo/robot-plugin | public int getCriticalFailed ( ) { return criticalFailed ; }
imikemo/robot-plugin | public int getCriticalTotal ( ) { return criticalPassed + criticalFailed ; }
imikemo/robot-plugin | public void addCaseResult ( RobotCaseResult caseResult ) { if ( caseResults == null ) caseResults = new HashMap < String , RobotCaseResult > ( ) ; caseResults . put ( caseResult . getSafeName ( ) , caseResult ) ; }
imikemo/robot-plugin | public String getDisplayName ( ) { return getName ( ) ; }
imikemo/robot-plugin | public String getSearchUrl ( ) { return getDisplayName ( ) ; }
imikemo/robot-plugin | public RobotSuiteResult getSuite ( String name ) { if ( children == null ) return null ; return children . get ( name ) ; }
imikemo/robot-plugin | public RobotCaseResult getCase ( String name ) { if ( caseResults == null ) return null ; return caseResults . get ( name ) ; }
imikemo/robot-plugin | public RobotSuiteResult getPreviousResult ( ) { if ( parent == null ) return null ; RobotTestObject prevParent = parent . getPreviousResult ( ) ; if ( prevParent instanceof RobotSuiteResult ) return ( ( RobotSuiteResult ) prevParent ) . getSuite ( getSafeName ( ) ) ; else if ( prevParent instanceof RobotResult ) { return ( ( RobotResult ) prevParent ) . getSuite ( getSafeName ( ) ) ; } return null ; }
imikemo/robot-plugin | public Object getDynamic ( String token , StaplerRequest req , StaplerRequest rsp ) { if ( ( token ) == null ) return this ; if ( getCase ( token ) != null ) return getCase ( token ) ; return getSuite ( token ) ; }
imikemo/robot-plugin | public List < RobotSuiteResult > getAllChildSuites ( ) { List < RobotSuiteResult > allChildSuites = new ArrayList < RobotSuiteResult > ( ) ; if ( children != null ) { for ( RobotSuiteResult suite : children . values ( ) ) { allChildSuites . add ( suite ) ; List < RobotSuiteResult > childSuites = suite . getAllChildSuites ( ) ; allChildSuites . addAll ( childSuites ) ; } } return allChildSuites ; }
imikemo/robot-plugin | public List < RobotCaseResult > getAllFailedCases ( ) { List < RobotCaseResult > failedCases = new ArrayList < RobotCaseResult > ( ) ; if ( caseResults != null ) { for ( RobotCaseResult caseResult : caseResults . values ( ) ) { if ( ! caseResult . isPassed ( ) ) failedCases . add ( caseResult ) ; } } if ( children != null ) { for ( RobotSuiteResult suite : children . values ( ) ) { failedCases . addAll ( suite . getAllFailedCases ( ) ) ; } } return failedCases ; }
imikemo/robot-plugin | public void tally ( RobotBuildAction parentAction ) { setParentAction ( parentAction ) ; failed = 0 ; passed = 0 ; criticalPassed = 0 ; criticalFailed = 0 ; duration = 0 ; if ( caseResults != null ) { for ( RobotCaseResult caseResult : getCaseResults ( ) ) { if ( caseResult . isPassed ( ) ) { if ( caseResult . isCritical ( ) ) criticalPassed ++ ; passed ++ ; } else { if ( caseResult . isCritical ( ) ) criticalFailed ++ ; failed ++ ; } duration += caseResult . getDuration ( ) ; caseResult . setParentAction ( parentAction ) ; } } if ( children != null ) { for ( RobotSuiteResult suite : getChildSuites ( ) ) { suite . tally ( parentAction ) ; failed += suite . getFailed ( ) ; passed += suite . getPassed ( ) ; criticalFailed += suite . getCriticalFailed ( ) ; criticalPassed += suite . getCriticalPassed ( ) ; duration += suite . getDuration ( ) ; } } }
imikemo/robot-plugin | public RobotTestObject findObjectById ( String id ) { if ( id . indexOf ( " / " ) >= 0 ) { String suiteName = id . substring ( 0 , id . indexOf ( " / " ) ) ; String childId = id . substring ( id . indexOf ( " / " ) + 1 , id . length ( ) ) ; RobotSuiteResult suite = children . get ( suiteName ) ; return suite . findObjectById ( childId ) ; } else if ( getSuite ( id ) != null ) { return getSuite ( id ) ; } else return getCase ( id ) ; }
imikemo/robot-plugin | public void doGraph ( StaplerRequest req , StaplerResponse rsp ) throws IOException { if ( ! isNeedToGenerate ( req , rsp ) ) return ; Graph g = new RobotGraph ( getOwner ( ) , RobotGraphHelper . createDataSetForSuite ( this ) , Messages . robot_trendgraph_testcases ( ) , Messages . robot_trendgraph_builds ( ) , 500 , 200 , false , Color . green , Color . red ) ; g . doPng ( req , rsp ) ; }
imikemo/robot-plugin | public void doDurationGraph ( StaplerRequest req , StaplerResponse rsp ) throws IOException { if ( ! isNeedToGenerate ( req , rsp ) ) return ; Graph g = new RobotGraph ( getOwner ( ) , RobotGraphHelper . createDurationDataSetForSuite ( this ) , " Duration ▁ ( ms ) " , Messages . robot_trendgraph_builds ( ) , 500 , 200 , false , Color . cyan ) ; g . doPng ( req , rsp ) ; }
imikemo/robot-plugin | public void addChildren ( Collection < RobotSuiteResult > childSuites ) { for ( RobotSuiteResult child : childSuites ) { if ( children . get ( child . getSafeName ( ) ) == null ) children . put ( child . getSafeName ( ) , child ) ; } }
imikemo/robot-plugin | public void addCaseResults ( Collection < RobotCaseResult > newCaseResults ) { for ( RobotCaseResult caseResult : newCaseResults ) { if ( caseResults . get ( caseResult . getSafeName ( ) ) == null ) { caseResults . put ( caseResult . getSafeName ( ) , caseResult ) ; } } }
djechelon/spring-security | @ BeforeEach public void setup ( ) throws Exception { String keyData = " - - - - - BEGIN ▁ PRIVATE ▁ KEY - - - - - \n " + " MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANG7v8QjQGU3MwQE \n " + " VUBxvH6Uuiy / MhZT7TV0ZNjyAF2ExA1gpn3aUxx6jYK5UnrpxRRE / KbeLucYbOhK \n " + " cDECt77Rggz5TStrOta0BQTvfluRyoQtmQ5Nkt6Vqg7O2ZapFt7k64Sal7AftzH6 \n " + " Q2BxWN1y04bLdDrH4jipqRj / 2qEFAgMBAAECgYEAj4ExY1jjdN3iEDuOwXuRB + Nn \n " + " x7pC4TgntE2huzdKvLJdGvIouTArce8A6JM5NlTBvm69mMepvAHgcsiMH1zGr5J5 \n " + " wJz23mGOyhM1veON41 / DJTVG + cxq4soUZhdYy3bpOuXGMAaJ8QLMbQQoivllNihd \n " + " vwH0rNSK8LTYWWPZYIECQQDxct + TFX1VsQ1eo41K0T4fu2rWUaxlvjUGhK6HxTmY \n " + "8OMJptunGRJL1CUjIb45Uz7SP8TPz5FwhXWsLfS182kRAkEA3l + Qd9C9gdpUh1uX \n " + " oPSNIxn5hFUrSTW1EwP9QH9vhwb5Vr8Jrd5ei678WYDLjUcx648RjkjhU9jSMzIx \n " + " EGvYtQJBAMm / i9NR7IVyyNIgZUpz5q4LI21rl1r4gUQuD8vA36zM81i4ROeuCly0 \n " + " KkfdxR4PUfnKcQCX11YnHjk9uTFj75ECQEFY / gBnxDjzqyF35hAzrYIiMPQVfznt \n " + " YX / sDTE2AdVBVGaMj1Cb51bPHnNC6Q5kXKQnj / YrLqRQND09Q7ParX0CQQC5NxZr \n " + "9jKqhHj8yQD6PlXTsY4Occ7DH6 / IoDenfdEVD5qlet0zmd50HatN2Jiqm5ubN7CM \n " + " INrtuLp4YHbgk1mi \n " + " - - - - - END ▁ PRIVATE ▁ KEY - - - - - " ; this . key = RsaKeyConverters . pkcs8 ( ) . convert ( new ByteArrayInputStream ( keyData . getBytes ( StandardCharsets . UTF_8 ) ) ) ; final CertificateFactory factory = CertificateFactory . getInstance ( " X . 509" ) ; String certificateData = " - - - - - BEGIN ▁ CERTIFICATE - - - - - \n " + " MIICgTCCAeoCCQCuVzyqFgMSyDANBgkqhkiG9w0BAQsFADCBhDELMAkGA1UEBhMC \n " + " VVMxEzARBgNVBAgMCldhc2hpbmd0b24xEjAQBgNVBAcMCVZhbmNvdXZlcjEdMBsG \n " + " A1UECgwUU3ByaW5nIFNlY3VyaXR5IFNBTUwxCzAJBgNVBAsMAnNwMSAwHgYDVQQD \n " + " DBdzcC5zcHJpbmcuc2VjdXJpdHkuc2FtbDAeFw0xODA1MTQxNDMwNDRaFw0yODA1 \n " + " MTExNDMwNDRaMIGEMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3RvbjES \n " + " MBAGA1UEBwwJVmFuY291dmVyMR0wGwYDVQQKDBRTcHJpbmcgU2VjdXJpdHkgU0FN \n " + " TDELMAkGA1UECwwCc3AxIDAeBgNVBAMMF3NwLnNwcmluZy5zZWN1cml0eS5zYW1s \n " + " MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRu7 / EI0BlNzMEBFVAcbx + lLos \n " + " vzIWU + 01dGTY8gBdhMQNYKZ92lMceo2CuVJ66cUURPym3i7nGGzoSnAxAre + 0YIM \n " + " + U0razrWtAUE735bkcqELZkOTZLelaoOztmWqRbe5OuEmpewH7cx + kNgcVjdctOG \n " + " y3Q6x + I4qakY / 9qhBQIDAQABMA0GCSqGSIb3DQEBCwUAA4GBAAeViTvHOyQopWEi \n " + " XOfI2Z9eukwrSknDwq / zscR0YxwwqDBMt / QdAODfSwAfnciiYLkmEjlozWRtOeN + \n " + " qK7UFgP1bRl5qksrYX5S0z2iGJh0GvonLUt3e20Ssfl5tTEDDnAEUMLfBkyaxEHD \n " + " RZ / nbTJ7VTeZOSyRoVn5XHhpuJ0B \n " + " - - - - - END ▁ CERTIFICATE - - - - - " ; this . certificate = ( X509Certificate ) factory . generateCertificate ( new ByteArrayInputStream ( certificateData . getBytes ( StandardCharsets . UTF_8 ) ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithCredentialsThenItSucceeds ( ) { new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . SIGNING ) ; new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . SIGNING , Saml2X509CredentialType . DECRYPTION ) ; new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . DECRYPTION ) ; Saml2X509Credential . signing ( this . key , this . certificate ) ; Saml2X509Credential . decryption ( this . key , this . certificate ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithCredentialsThenItSucceeds ( ) { new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . VERIFICATION ) ; new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . VERIFICATION , Saml2X509CredentialType . ENCRYPTION ) ; new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . ENCRYPTION ) ; Saml2X509Credential . verification ( this . certificate ) ; Saml2X509Credential . encryption ( this . certificate ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithoutCredentialsThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( null , ( X509Certificate ) null , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithoutPrivateKeyThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( null , this . certificate , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . key , null , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( null , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithEncryptionUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . ENCRYPTION ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithVerificationUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . VERIFICATION ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithSigningUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithDecryptionUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . DECRYPTION ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForSigningWithoutCredentialsThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . signing ( null , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForSigningWithoutPrivateKeyThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . signing ( null , this . certificate ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForSigningWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . signing ( this . key , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForDecryptionWithoutCredentialsThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . decryption ( null , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForDecryptionWithoutPrivateKeyThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . decryption ( null , this . certificate ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForDecryptionWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . decryption ( this . key , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenAssertingPartyForVerificationWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . verification ( null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenAssertingPartyForEncryptionWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . encryption ( null ) ) ; }
Gitpiece/ssm | @ Override public boolean checkResource ( Locale locale ) { File file = new File ( this . getServletContext ( ) . getRealPath ( " / " ) + getUrl ( ) ) ; return file . exists ( ) ; }
aws/aws-sdk-java | public DescribeBudgetActionsForAccountRequestProtocolMarshaller ( com . amazonaws . protocol . json . SdkJsonProtocolFactory protocolFactory ) { this . protocolFactory = protocolFactory ; }
aws/aws-sdk-java | public Request < DescribeBudgetActionsForAccountRequest > marshall ( DescribeBudgetActionsForAccountRequest describeBudgetActionsForAccountRequest ) { if ( describeBudgetActionsForAccountRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { final ProtocolRequestMarshaller < DescribeBudgetActionsForAccountRequest > protocolMarshaller = protocolFactory . createProtocolMarshaller ( SDK_OPERATION_BINDING , describeBudgetActionsForAccountRequest ) ; protocolMarshaller . startMarshalling ( ) ; DescribeBudgetActionsForAccountRequestMarshaller . getInstance ( ) . marshall ( describeBudgetActionsForAccountRequest , protocolMarshaller ) ; return protocolMarshaller . finishMarshalling ( ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
XClouded/t4f-core | public LittleEndianShortIn ( TypedByteIn linputStream ) { super ( linputStream ) ; }
XClouded/t4f-core | protected void fill ( ) throws IOException { int number = lin . readShort ( ) ; String s = Integer . toString ( number ) + System . getProperty ( " line . separator " , " \r \n " ) ; byte [ ] b = s . getBytes ( "8859_1" ) ; buf = new int [ b . length ] ; for ( int i = 0 ; i < b . length ; i ++ ) { buf [ i ] = b [ i ] ; } }
gosu-lang/old-gosu-repo | public UsingStatement ( ) { _varStmts = Collections . emptyList ( ) ; }
gosu-lang/old-gosu-repo | public Expression getExpression ( ) { return _expression ; }
gosu-lang/old-gosu-repo | public void setExpression ( IExpression expression ) { _expression = ( Expression ) expression ; }
gosu-lang/old-gosu-repo | public Statement getStatement ( ) { return _statement ; }
gosu-lang/old-gosu-repo | public void setStatement ( IStatement statement ) { _statement = ( Statement ) statement ; }
gosu-lang/old-gosu-repo | public List < IVarStatement > getVarStatements ( ) { return _varStmts ; }
gosu-lang/old-gosu-repo | public boolean hasVarStatements ( ) { return _varStmts != null && ! _varStmts . isEmpty ( ) ; }
gosu-lang/old-gosu-repo | public void setVarStatements ( List < IVarStatement > varStmts ) { _varStmts = varStmts ; }
gosu-lang/old-gosu-repo | public Statement getFinallyStatement ( ) { return _finallyStatement ; }
gosu-lang/old-gosu-repo | public void setFinallyStatement ( Statement finallyStatement ) { _finallyStatement = finallyStatement ; }
gosu-lang/old-gosu-repo | public Object execute ( ) { if ( ! isCompileTimeConstant ( ) ) { return super . execute ( ) ; } throw new IllegalStateException ( " Can ' t ▁ execute ▁ this ▁ parsed ▁ element ▁ directly " ) ; }
gosu-lang/old-gosu-repo | protected ITerminalStatement getLeastSignificantTerminalStatement_internal ( boolean [ ] bAbsolute ) { bAbsolute [ 0 ] = false ; return getStatement ( ) == null ? null : getStatement ( ) . getLeastSignificantTerminalStatement ( bAbsolute ) ; }
gosu-lang/old-gosu-repo | public String toString ( ) { return " using ( ▁ " + ( getExpression ( ) == null ? varStatementsToString ( ) : getExpression ( ) . toString ( ) ) + " ▁ ) \n " + getStatement ( ) == null ? " " : getStatement ( ) . toString ( ) + ( getFinallyStatement ( ) == null ? " " : ( " \n finally \n " + getFinallyStatement ( ) . toString ( ) ) ) ; }
gosu-lang/old-gosu-repo | private String varStatementsToString ( ) { String s = " " ; for ( IVarStatement varStmt : getVarStatements ( ) ) { if ( s . length ( ) == 0 ) { s += varStmt . toString ( ) ; } else { s += " , ▁ " ; } } return s ; }
Stratio/stratio-connector-commons | @ Override protected ClusterName getClusterName ( ) { return new ClusterName ( " discoverClusterName " ) ; }
Stratio/stratio-connector-commons | @ Override public void setUp ( ) throws ConnectorException { super . setUp ( ) ; prepareEnvironment ( tableMetadata ) ; prepareEnvironment ( tableMetadataSecondary ) ; Iterator < CatalogMetadata > iteratorMetadata = getConnector ( ) . getMetadataEngine ( ) . provideMetadata ( getClusterName ( ) ) . iterator ( ) ; boolean catalogFound = false ; while ( iteratorMetadata . hasNext ( ) && ! catalogFound ) { catalogMetadataProvided = iteratorMetadata . next ( ) ; catalogFound = catalogMetadataProvided . getName ( ) . getName ( ) . equals ( CATALOG ) ; } ; assertTrue ( " The ▁ catalog ▁ " + CATALOG + " ▁ must ▁ be ▁ recovered " , catalogFound ) ; }
Stratio/stratio-connector-commons | private void verifyIndexMetadata ( TableMetadata tableMetadataProvided ) { assertTrue ( " The ▁ index ▁ has ▁ not ▁ been ▁ created " , iConnectorHelper . containsIndex ( CATALOG , TABLE , INDEX_NAME ) ) ; Map < IndexName , IndexMetadata > indexes = tableMetadataProvided . getIndexes ( ) ; assertTrue ( " The ▁ index ▁ has ▁ not ▁ been ▁ recovered " , containsIndex ( indexes ) ) ; IndexType typeProvided = resolveIndexType ( indexes ) ; IndexType typeExpected = resolveIndexType ( tableMetadata . getIndexes ( ) ) ; assertEquals ( " The ▁ type ▁ is ▁ not ▁ the ▁ expected " , typeExpected , typeProvided ) ; Set < IndexName > keySet = tableMetadataProvided . getIndexes ( ) . keySet ( ) ; IndexMetadata indexMetadata = indexes . get ( keySet . iterator ( ) . next ( ) ) ; assertEquals ( " The ▁ index ▁ should ▁ have ▁ 2 ▁ columns " , 2 , indexMetadata . getColumns ( ) . keySet ( ) . size ( ) ) ; Iterator < ColumnName > iterator = indexMetadata . getColumns ( ) . keySet ( ) . iterator ( ) ; assertEquals ( " First ▁ column ▁ in ▁ composite ▁ index ▁ is ▁ not ▁ the ▁ expected " , COLUMN_1 , iterator . next ( ) . getName ( ) ) ; assertEquals ( " Second ▁ column ▁ in ▁ composite ▁ index ▁ is ▁ not ▁ the ▁ expected " , COLUMN_2 , iterator . next ( ) . getName ( ) ) ; }
Stratio/stratio-connector-commons | protected boolean containsIndex ( Map < IndexName , IndexMetadata > indexes ) { for ( IndexName indexName : indexes . keySet ( ) ) { if ( indexName . getName ( ) . equals ( INDEX_NAME ) ) { return true ; } } return false ; }
Stratio/stratio-connector-commons | protected IndexType resolveIndexType ( Map < IndexName , IndexMetadata > indexList ) { IndexType typeProvided = null ; for ( Entry < IndexName , IndexMetadata > indexName : indexList . entrySet ( ) ) { if ( indexName . getKey ( ) . getName ( ) . equals ( INDEX_NAME ) ) { typeProvided = indexName . getValue ( ) . getType ( ) ; } } return typeProvided ; }
Stratio/stratio-connector-commons | private TableMetadata createTableMetadataWithIndex ( ) { TableMetadataBuilder tableMetadataBuilder = new TableMetadataBuilder ( CATALOG , TABLE , getClusterName ( ) . getName ( ) ) ; tableMetadataBuilder . addColumn ( COLUMN_1 , new ColumnType ( DataType . INT ) ) . addColumn ( COLUMN_2 , new ColumnType ( DataType . TEXT ) ) ; tableMetadataBuilder . withPartitionKey ( COLUMN_1 ) ; IndexMetadataBuilder indexMetadataBuilder = new IndexMetadataBuilder ( CATALOG , TABLE , INDEX_NAME , IndexType . DEFAULT ) ; indexMetadataBuilder . addColumn ( COLUMN_1 , new ColumnType ( DataType . VARCHAR ) ) ; indexMetadataBuilder . addColumn ( COLUMN_2 , new ColumnType ( DataType . TEXT ) ) ; IndexMetadata indexMetadata = indexMetadataBuilder . build ( ) ; tableMetadataBuilder . addIndex ( indexMetadata ) ; tableMetadata = tableMetadataBuilder . build ( ) ; return tableMetadata ; }
Stratio/stratio-connector-commons | private TableMetadata createSimpleTableMetadata ( ) { TableMetadataBuilder tableMetadataBuilder = new TableMetadataBuilder ( CATALOG , SECOND_TABLE , getClusterName ( ) . getName ( ) ) ; tableMetadataBuilder . addColumn ( SECOND_TABLE_COLUMN , new ColumnType ( DataType . INT ) ) ; tableMetadataBuilder . withPartitionKey ( SECOND_TABLE_COLUMN ) ; return tableMetadataBuilder . build ( ) ; }
hyperfresh/mc-universe | @ Test public void testGsonSerializer ( ) { GsonSerializer serializer = new GsonSerializer ( ) ; long time = System . currentTimeMillis ( ) ; testPingPacketSerialization ( serializer ) ; testServerPacketSerialization ( serializer ) ; testSwitchPacketSerialization ( serializer ) ; System . out . println ( serializer . getName ( ) + " ▁ Serializer ▁ finished ▁ in ▁ " + ( System . currentTimeMillis ( ) - time ) + " ▁ ms " ) ; }
hyperfresh/mc-universe | @ Test public void testJavaSerializer ( ) { JavaSerializer serializer = new JavaSerializer ( ) ; long time = System . currentTimeMillis ( ) ; testPingPacketSerialization ( serializer ) ; testServerPacketSerialization ( serializer ) ; testSwitchPacketSerialization ( serializer ) ; System . out . println ( serializer . getName ( ) + " ▁ Serializer ▁ finished ▁ in ▁ " + ( System . currentTimeMillis ( ) - time ) + " ▁ ms " ) ; }
hyperfresh/mc-universe | public void testPingPacketSerialization ( SwitchCorePacketSerializer serializer ) { Packet packet ; String encoded ; encoded = serializer . serialize ( new PacketOutServerPing ( ) ) ; System . out . println ( " Encoded ▁ PacketOutServerPing : ▁ " + encoded ) ; packet = serializer . deserialize ( encoded ) ; System . out . println ( " Decoded ▁ SwitchPacket : ▁ " + packet . getClass ( ) . getName ( ) ) ; }
hyperfresh/mc-universe | public void testServerPacketSerialization ( SwitchCorePacketSerializer serializer ) { Packet packet ; String encoded ; encoded = serializer . serialize ( new PacketOutServerDiscover ( new FakeServer ( ) ) ) ; System . out . println ( " Encoded ▁ PacketOutServerDiscover : ▁ " + encoded ) ; packet = serializer . deserialize ( encoded ) ; System . out . println ( " Decoded ▁ SwitchPacket : ▁ " + ( ( PacketOutServerDiscover ) packet ) . getServer ( ) ) ; }
hyperfresh/mc-universe | public void testSwitchPacketSerialization ( SwitchCorePacketSerializer serializer ) { Packet packet ; String encoded ; encoded = serializer . serialize ( new PacketInPlayerSwitch ( ) ) ; System . out . println ( " Encoded ▁ PacketInPlayerSwitch : ▁ " + encoded ) ; packet = serializer . deserialize ( encoded ) ; System . out . println ( " Decoded ▁ PacketInPlayerSwitch : ▁ " + ( ( PacketInPlayerSwitch ) packet ) . getResult ( ) . name ( ) ) ; }
hyperfresh/mc-universe | @ Override public void setValue ( ServerValue type , Object object ) { }
hyperfresh/mc-universe | @ Override public Object getValue ( ServerValue type ) { return null ; }
hyperfresh/mc-universe | @ Override public int totalValues ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public Map < ServerValue , Object > toValueMap ( ) { return new HashMap < > ( ) ; }
hyperfresh/mc-universe | @ Override public boolean isExternal ( ) { return true ; }
hyperfresh/mc-universe | @ Override public boolean isOnline ( ) { return false ; }
hyperfresh/mc-universe | @ Override public String getServerIdentifier ( ) { return " test " ; }
hyperfresh/mc-universe | @ Override public String getServerName ( ) { return " test " ; }
hyperfresh/mc-universe | @ Override public String getServerVersion ( ) { return null ; }
hyperfresh/mc-universe | @ Override public int getMaxPlayers ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public boolean getWhitelistEnabled ( ) { return false ; }
hyperfresh/mc-universe | @ Override public String [ ] getWhitelistedPlayers ( ) { return new String [ 0 ] ; }
hyperfresh/mc-universe | @ Override public int getHubPriority ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public String [ ] getOnlinePlayers ( ) { return new String [ 0 ] ; }
hyperfresh/mc-universe | @ Override public String [ ] getQueuedPlayers ( ) { return new String [ 0 ] ; }
hyperfresh/mc-universe | @ Override public long getLastOnline ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public String toString ( ) { return " [ server : ▁ " + getServerIdentifier ( ) + " , ▁ values : ▁ " + totalValues ( ) + " , ▁ external : ▁ " + isExternal ( ) + " ] " ; }
crockpotveggies/deeplearning4j | @ Test public void testHasNext ( ) throws Exception { ClassPathResource reuters5250 = new ClassPathResource ( " / reuters / 5250" ) ; File f = reuters5250 . getFile ( ) ; StreamLineIterator iterator = new StreamLineIterator . Builder ( new FileInputStream ( f ) ) . setFetchSize ( 100 ) . build ( ) ; int cnt = 0 ; while ( iterator . hasNext ( ) ) { String line = iterator . nextSentence ( ) ; assertNotEquals ( null , line ) ; logger . info ( " Line : ▁ " + line ) ; cnt ++ ; } assertEquals ( 24 , cnt ) ; }
hawkular/wildfly-monitor | public MonitorWriteAttributeHandler ( AttributeDefinition ... definitions ) { super ( MonitorDefinition . MONITOR , definitions ) ; }
hawkular/wildfly-monitor | @ Override protected void recreateParentService ( OperationContext context , PathAddress parentAddress , ModelNode parentModel , ServiceVerificationHandler verificationHandler ) throws OperationFailedException { }
hawkular/wildfly-monitor | @ Override protected ServiceName getParentServiceName ( PathAddress parentAddress ) { return RhqMetricsService . SERVICE_NAME . append ( parentAddress . getLastElement ( ) . getValue ( ) ) ; }
ggeorg/WebXView | public SimpleImageHandler ( ImageHandler imageHandler ) { if ( imageHandler == null ) { throw new IllegalArgumentException ( ) ; } this . imageHandler = imageHandler ; }
ggeorg/WebXView | public void setDOMTreeManager ( DOMTreeManager domTreeManager ) { }
ggeorg/WebXView | public Element createElement ( SVGGeneratorContext generatorContext ) { Element imageElement = generatorContext . getDOMFactory ( ) . createElementNS ( SVG_NAMESPACE_URI , SVG_IMAGE_TAG ) ; return imageElement ; }
ggeorg/WebXView | public AffineTransform handleImage ( Image image , Element imageElement , int x , int y , int width , int height , SVGGeneratorContext generatorContext ) { int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; if ( imageWidth == 0 || imageHeight == 0 || width == 0 || height == 0 ) { handleEmptyImage ( imageElement ) ; } else { imageHandler . handleImage ( image , imageElement , generatorContext ) ; setImageAttributes ( imageElement , x , y , width , height , generatorContext ) ; } return null ; }
ggeorg/WebXView | public AffineTransform handleImage ( RenderedImage image , Element imageElement , int x , int y , int width , int height , SVGGeneratorContext generatorContext ) { int imageWidth = image . getWidth ( ) ; int imageHeight = image . getHeight ( ) ; if ( imageWidth == 0 || imageHeight == 0 || width == 0 || height == 0 ) { handleEmptyImage ( imageElement ) ; } else { imageHandler . handleImage ( image , imageElement , generatorContext ) ; setImageAttributes ( imageElement , x , y , width , height , generatorContext ) ; } return null ; }
ggeorg/WebXView | public AffineTransform handleImage ( RenderableImage image , Element imageElement , double x , double y , double width , double height , SVGGeneratorContext generatorContext ) { double imageWidth = image . getWidth ( ) ; double imageHeight = image . getHeight ( ) ; if ( imageWidth == 0 || imageHeight == 0 || width == 0 || height == 0 ) { handleEmptyImage ( imageElement ) ; } else { imageHandler . handleImage ( image , imageElement , generatorContext ) ; setImageAttributes ( imageElement , x , y , width , height , generatorContext ) ; } return null ; }
ggeorg/WebXView | protected void setImageAttributes ( Element imageElement , double x , double y , double width , double height , SVGGeneratorContext generatorContext ) { imageElement . setAttributeNS ( null , SVG_X_ATTRIBUTE , generatorContext . doubleString ( x ) ) ; imageElement . setAttributeNS ( null , SVG_Y_ATTRIBUTE , generatorContext . doubleString ( y ) ) ; imageElement . setAttributeNS ( null , SVG_WIDTH_ATTRIBUTE , generatorContext . doubleString ( width ) ) ; imageElement . setAttributeNS ( null , SVG_HEIGHT_ATTRIBUTE , generatorContext . doubleString ( height ) ) ; imageElement . setAttributeNS ( null , SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE , SVG_NONE_VALUE ) ; }
ggeorg/WebXView | protected void handleEmptyImage ( Element imageElement ) { imageElement . setAttributeNS ( XLINK_NAMESPACE_URI , XLINK_HREF_QNAME , " " ) ; imageElement . setAttributeNS ( null , SVG_WIDTH_ATTRIBUTE , "0" ) ; imageElement . setAttributeNS ( null , SVG_HEIGHT_ATTRIBUTE , "0" ) ; }
paradoxical-io/common | @ Override @ Nullable public ValueClass unmarshal ( @ Nullable UnderlyingType value ) throws Exception { return createNewInstance ( value ) ; }
paradoxical-io/common | @ Override @ Nullable public UnderlyingType marshal ( @ Nullable ValueClass valueClass ) throws Exception { if ( valueClass == null ) { return null ; } return valueClass . get ( ) ; }
vam-google/google-cloud-java | @ Test public void run ( ) { main ( null ) ; }
likelet/DAtools | public Aterm ( String DB , String DB_Object_ID , String DB_Object_Symbol , String GO_ID , String Aspect , String name , String namespace ) { this . DB = DB ; this . DB_Object_ID = DB_Object_ID ; this . DB_Object_Symbol = DB_Object_Symbol ; this . GO_ID = GO_ID ; this . Aspect = Aspect ; this . name = name ; this . namespace = namespace ; }
likelet/DAtools | public Aterm ( String DB_Object_Symbol , String GO_ID ) { this . DB_Object_Symbol = DB_Object_Symbol ; this . GO_ID = GO_ID ; }
likelet/DAtools | public String getAspect ( ) { return Aspect ; }
likelet/DAtools | public void setAspect ( String Aspect ) { this . Aspect = Aspect ; }
likelet/DAtools | public String getDB ( ) { return DB ; }
likelet/DAtools | public void setDB ( String DB ) { this . DB = DB ; }
likelet/DAtools | public String getDB_Object_ID ( ) { return DB_Object_ID ; }
likelet/DAtools | public void setDB_Object_ID ( String DB_Object_ID ) { this . DB_Object_ID = DB_Object_ID ; }
likelet/DAtools | public String getDB_Object_Symbol ( ) { return DB_Object_Symbol ; }
likelet/DAtools | public void setDB_Object_Symbol ( String DB_Object_Symbol ) { this . DB_Object_Symbol = DB_Object_Symbol ; }
likelet/DAtools | public String getGO_ID ( ) { return GO_ID ; }
likelet/DAtools | public void setGO_ID ( String GO_ID ) { this . GO_ID = GO_ID ; }
likelet/DAtools | public String getName ( ) { return name ; }
likelet/DAtools | public void setName ( String name ) { this . name = name ; }
likelet/DAtools | public String getNamespace ( ) { return namespace ; }
likelet/DAtools | public void setNamespace ( String namespace ) { this . namespace = namespace ; }
likelet/DAtools | @ Override public String toString ( ) { return DB + " \t " + DB_Object_ID + " \t " + DB_Object_Symbol + " \t " + GO_ID + " \t " + Aspect + " \t " + name + " \t " + namespace ; }
likelet/DAtools | public String toString2 ( ) { return DB_Object_Symbol + " \t " + GO_ID ; }
adataylor/ios-driver | public SetConfigurationNHandler ( IOSServerManager driver , WebDriverLikeRequest request ) { super ( driver , request ) ; }
adataylor/ios-driver | @ Override public Response handle ( ) throws Exception { WebDriverLikeCommand command = WebDriverLikeCommand . valueOf ( getRequest ( ) . getVariableValue ( " : command " ) ) ; JSONObject payload = getRequest ( ) . getPayload ( ) ; Iterator < String > iter = payload . keys ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; Object value = payload . opt ( key ) ; getSession ( ) . configure ( command ) . set ( key , value ) ; } Response resp = new Response ( ) ; resp . setSessionId ( getSession ( ) . getSessionId ( ) ) ; resp . setStatus ( 0 ) ; resp . setValue ( new JSONObject ( ) ) ; return resp ; }
adataylor/ios-driver | @ Override public JSONObject configurationDescription ( ) throws JSONException { return noConfigDefined ( ) ; }
Andimeo/OneNightUltimate | @ MessageMapping ( " / hello " ) @ SendTo ( " / topic / greetings " ) public Object greeting ( HelloMessage message ) throws InterruptedException { Thread . sleep ( 1000 ) ; return new Greeting ( " Hello . ▁ " + message . getName ( ) + " ! " ) ; }
erickubenka/code-examples | @ Test public void testT01_GoogleSearch ( ) throws MalformedURLException { final HttpCommandExecutor executor = new HttpCommandExecutor ( new HashMap < > ( ) , new URL ( " http : // localhost : 4444 / wd / hub " ) , new CustomHttpFactory ( ) ) ; final WebDriver driver = new RemoteWebDriver ( executor , new ChromeOptions ( ) ) ; driver . get ( " https : // google . de " ) ; }
suntion/suns_build | @ Override public final Serializable doCreate ( Session session ) { Serializable sessionId = this . generateSessionId ( session ) ; this . assignSessionId ( session , sessionId ) ; byte [ ] keyByte = getByteKey ( session . getId ( ) ) ; RedisUtil . set ( keyByte , serializer . serialize ( session ) , sessionCacheExprie / 1000 ) ; logger . trace ( " ↓ ↓ CREATE ↓ ↓ , ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ expire ▁ { } . ▁ url ▁ { } " , getStringKey ( keyByte ) , getHourMinuteSecend ( sessionCacheExprie ) , ShiroUtil . getRequestUrl ( ) ) ; return sessionId ; }
suntion/suns_build | @ Override public final void delete ( Session session ) { if ( session != null && session . getId ( ) != null ) { byte [ ] keyByte = getByteKey ( session . getId ( ) ) ; if ( RedisUtil . exists ( keyByte ) ) { RedisUtil . del ( keyByte ) ; logger . trace ( " DELETE ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ url ▁ { } " , getStringKey ( keyByte ) , ShiroUtil . getRequestUrl ( ) ) ; } } }
suntion/suns_build | @ Override public final void update ( Session session ) throws UnknownSessionException { byte [ ] keyByte = getByteKey ( session . getId ( ) ) ; RedisUtil . set ( keyByte , serializer . serialize ( session ) , sessionCacheExprie / 1000 ) ; logger . trace ( " ↓ ↓ UPDATE ↓ ↓ , ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ expire ▁ { } . ▁ url ▁ { } " , getStringKey ( keyByte ) , getHourMinuteSecend ( sessionCacheExprie ) , ShiroUtil . getRequestUrl ( ) ) ; }
suntion/suns_build | @ Override public Session doReadSession ( Serializable sessionId ) { byte [ ] keyByte = getByteKey ( sessionId ) ; Session session = ( Session ) serializer . deserialize ( RedisUtil . get ( keyByte ) ) ; logger . trace ( " ↑ ↑ ▁ READ ▁ ↑ ↑ , ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ expire ▁ less ▁ { } ▁ . ▁ url ▁ { } " , getStringKey ( keyByte ) , getHourMinuteSecend ( RedisUtil . ttl ( keyByte ) * 1000 ) , ShiroUtil . getRequestUrl ( ) ) ; return session ; }
suntion/suns_build | @ Override public final Collection < Session > getActiveSessions ( ) { Set < Session > sessions = new HashSet < Session > ( ) ; Set < byte [ ] > byteKeys = RedisUtil . keys ( ConstantsShiro . SHIRO_CACHE_SESSION + " : * " ) ; if ( byteKeys != null && byteKeys . size ( ) > 0 ) { for ( byte [ ] bs : byteKeys ) { Session s = ( Session ) serializer . deserialize ( RedisUtil . get ( bs ) ) ; sessions . add ( s ) ; } } logger . trace ( " VALUES ▁ [ session ] ▁ redis ▁ by ▁ Keys ▁ { } . " , ConstantsShiro . SHIRO_CACHE_SESSION + " : * " ) ; return sessions ; }
suntion/suns_build | public int getSessionCacheExprie ( ) { return sessionCacheExprie ; }
suntion/suns_build | public void setSessionCacheExprie ( int sessionCacheExprie ) { this . sessionCacheExprie = sessionCacheExprie ; }
kingland/java-design-patterns | @ Test public void test ( ) { App . main ( new String [ ] { } ) ; }
forgemo/bittrex-java-client | public Long getId ( ) { return id ; }
forgemo/bittrex-java-client | public void setId ( Long id ) { this . id = id ; }
forgemo/bittrex-java-client | public LocalDateTime getTimeStamp ( ) { return timeStamp ; }
forgemo/bittrex-java-client | public void setTimeStamp ( LocalDateTime timeStamp ) { this . timeStamp = timeStamp ; }
forgemo/bittrex-java-client | public BigDecimal getQuantity ( ) { return quantity ; }
forgemo/bittrex-java-client | public void setQuantity ( BigDecimal quantity ) { this . quantity = quantity ; }
forgemo/bittrex-java-client | public BigDecimal getPrice ( ) { return price ; }
forgemo/bittrex-java-client | public void setPrice ( BigDecimal price ) { this . price = price ; }
forgemo/bittrex-java-client | public BigDecimal getTotal ( ) { return total ; }
forgemo/bittrex-java-client | public void setTotal ( BigDecimal total ) { this . total = total ; }
forgemo/bittrex-java-client | public String getFillType ( ) { return fillType ; }
forgemo/bittrex-java-client | public void setFillType ( String fillType ) { this . fillType = fillType ; }
forgemo/bittrex-java-client | public String getOrderType ( ) { return orderType ; }
forgemo/bittrex-java-client | public void setOrderType ( String orderType ) { this . orderType = orderType ; }
danailKondov/dkondov | public Item ( ) { }
danailKondov/dkondov | public Item ( String name , String desc , long created ) { this . name = name ; this . desc = desc ; this . created = created ; }
danailKondov/dkondov | public String getID ( ) { return id ; }
danailKondov/dkondov | public void setID ( String id ) { this . id = id ; }
danailKondov/dkondov | public String getName ( ) { return name ; }
danailKondov/dkondov | public void setName ( String name ) { this . name = name ; }
danailKondov/dkondov | public String getDescription ( ) { return desc ; }
danailKondov/dkondov | public void setDescription ( String desc ) { this . desc = desc ; }
danailKondov/dkondov | public long getCreated ( ) { return created ; }
danailKondov/dkondov | public void setCreated ( long created ) { this . created = created ; }
danailKondov/dkondov | public ArrayList < String > getComments ( ) { return comments ; }
danailKondov/dkondov | public void setComments ( ArrayList < String > comments ) { this . comments = comments ; }
danailKondov/dkondov | @ Override public String toString ( ) { String comment = null ; if ( comments != null ) { comment = comments . toString ( ) ; } return " id : ▁ " + id + " , ▁ ▁ name : ▁ " + name + " , ▁ description : ▁ " + desc + " , ▁ created : ▁ " + created + " ▁ \n " + " comments : ▁ " + comment ; }
danailKondov/dkondov | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Item item = ( Item ) o ; if ( getCreated ( ) != item . getCreated ( ) ) return false ; if ( id != null ? ! id . equals ( item . id ) : item . id != null ) return false ; if ( getName ( ) != null ? ! getName ( ) . equals ( item . getName ( ) ) : item . getName ( ) != null ) return false ; return desc != null ? desc . equals ( item . desc ) : item . desc == null ; }
danailKondov/dkondov | @ Override public int hashCode ( ) { int result = id != null ? id . hashCode ( ) : 0 ; result = 31 * result + ( getName ( ) != null ? getName ( ) . hashCode ( ) : 0 ) ; result = 31 * result + ( desc != null ? desc . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( getCreated ( ) ^ ( getCreated ( ) >>> 32 ) ) ; return result ; }
sajavadi/pinot | new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( int i = 0 ; i < jobs ; i ++ ) { bes . execute ( new Runnable ( ) { @ Override public void run ( ) { try { running . incrementAndGet ( ) ; syncer . startupBarrier . await ( ) ; syncer . validationBarrier . await ( ) ; running . decrementAndGet ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ) ; } } }
OblivionNW/Nucleus | @ Override public Instant deserialize ( TypeToken < ? > type , ConfigurationNode value ) { return Instant . ofEpochMilli ( value . getLong ( ) ) ; }
OblivionNW/Nucleus | @ Override public void serialize ( TypeToken < ? > type , Instant obj , ConfigurationNode value ) { value . setValue ( obj . toEpochMilli ( ) ) ; }
agentmilindu/stratos | @ Inject DefaultVDC ( @ Memoized Supplier < Set < ? extends Location > > locationsSupplier , IsDefaultVDC isDefaultVDC ) { this . locationsSupplier = checkNotNull ( locationsSupplier , " locationsSupplierSupplier " ) ; this . isDefaultVDC = checkNotNull ( isDefaultVDC , " isDefaultVDC " ) ; }
agentmilindu/stratos | @ Override public Location get ( ) { return find ( locationsSupplier . get ( ) , isDefaultVDC ) ; }
agentmilindu/stratos | @ Inject IsDefaultVDC ( @ VDC Supplier < ReferenceType > defaultVDCSupplier ) { this . defaultVDCSupplier = checkNotNull ( defaultVDCSupplier , " defaultVDCSupplier " ) ; }
agentmilindu/stratos | @ Override public boolean apply ( Location input ) { ReferenceType defaultVDC = defaultVDCSupplier . get ( ) ; return input . getScope ( ) == LocationScope . ZONE && input . getId ( ) . equals ( defaultVDC . getHref ( ) . toASCIIString ( ) ) ; }
agentmilindu/stratos | @ Override public String toString ( ) { return " isDefaultVDC ( ) " ; }
lukearndt/CommunityRosterSystem | public Member ( int aID , String aName , String aAddress , String aSuburb , String aState , String aPostCode , int aSpouseID , String aHomePhone , String aMobilePhone ) { ID = aID ; name = aName ; address = aAddress ; suburb = aSuburb ; state = aState ; postCode = aPostCode ; spouseID = aSpouseID ; homePhone = aHomePhone ; mobilePhone = aMobilePhone ; }
lukearndt/CommunityRosterSystem | public int getID ( ) { return ID ; }
lukearndt/CommunityRosterSystem | public void setID ( int iD ) { ID = iD ; }
lukearndt/CommunityRosterSystem | public String getName ( ) { return name ; }
lukearndt/CommunityRosterSystem | public void setName ( String name ) { this . name = name ; }
lukearndt/CommunityRosterSystem | public String getAddress ( ) { return address ; }
lukearndt/CommunityRosterSystem | public void setAddress ( String address ) { this . address = address ; }
lukearndt/CommunityRosterSystem | public String getSuburb ( ) { return suburb ; }
lukearndt/CommunityRosterSystem | public void setSuburb ( String suburb ) { this . suburb = suburb ; }
lukearndt/CommunityRosterSystem | public String getState ( ) { return state ; }
lukearndt/CommunityRosterSystem | public void setState ( String state ) { this . state = state ; }
lukearndt/CommunityRosterSystem | public String getPostCode ( ) { return postCode ; }
lukearndt/CommunityRosterSystem | public void setPostCode ( String postCode ) { this . postCode = postCode ; }
lukearndt/CommunityRosterSystem | public int getSpouseID ( ) { return spouseID ; }
lukearndt/CommunityRosterSystem | public void setSpouseID ( int spouseID ) { this . spouseID = spouseID ; }
lukearndt/CommunityRosterSystem | public String getHomePhone ( ) { return homePhone ; }
lukearndt/CommunityRosterSystem | public void setHomePhone ( String homePhone ) { this . homePhone = homePhone ; }
lukearndt/CommunityRosterSystem | public String getMobilePhone ( ) { return mobilePhone ; }
lukearndt/CommunityRosterSystem | public void setMobilePhone ( String mobilePhone ) { this . mobilePhone = mobilePhone ; }
Alex-Diez/Java-TDD-Katas | MinTriangleSum ( List < List < Integer > > triangle ) { this . triangle = triangle ; }
Alex-Diez/Java-TDD-Katas | int compute ( ) { return IntStream . range ( 0 , triangle . size ( ) ) . map ( i -> triangle . size ( ) - i - 1 ) . mapToObj ( triangle :: get ) . reduce ( this :: combine ) . map ( l -> l . get ( 0 ) ) . orElse ( 0 ) ; }
Alex-Diez/Java-TDD-Katas | private List < Integer > combine ( List < Integer > acc , List < Integer > list ) { return IntStream . range ( 0 , list . size ( ) ) . mapToObj ( j -> Math . min ( acc . get ( j ) , acc . get ( j + 1 ) ) + list . get ( j ) ) . collect ( Collectors . toCollection ( ( ) -> new ArrayList < > ( acc . size ( ) ) ) ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int pFromColor , final int pToColor , final LinearGradientDirection pLinearGradientDirection ) { this ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , pFromColor , pToColor , pLinearGradientDirection , null ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int pFromColor , final int pToColor , final LinearGradientDirection pLinearGradientDirection , final TextureAtlasSourceDecoratorOptions pTextureAtlasSourceDecoratorOptions ) { this ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , new int [ ] { pFromColor , pToColor } , null , pLinearGradientDirection , pTextureAtlasSourceDecoratorOptions ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int [ ] pColors , final float [ ] pPositions , final LinearGradientDirection pLinearGradientDirection ) { this ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , pColors , pPositions , pLinearGradientDirection , null ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int [ ] pColors , final float [ ] pPositions , final LinearGradientDirection pLinearGradientDirection , final TextureAtlasSourceDecoratorOptions pTextureAtlasSourceDecoratorOptions ) { super ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , pTextureAtlasSourceDecoratorOptions ) ; this . mColors = pColors ; this . mPositions = pPositions ; this . mLinearGradientDirection = pLinearGradientDirection ; this . mPaint . setStyle ( Style . FILL ) ; final int right = pBitmapTextureAtlasSource . getTextureWidth ( ) - 1 ; final int bottom = pBitmapTextureAtlasSource . getTextureHeight ( ) - 1 ; final float fromX = pLinearGradientDirection . getFromX ( right ) ; final float fromY = pLinearGradientDirection . getFromY ( bottom ) ; final float toX = pLinearGradientDirection . getToX ( right ) ; final float toY = pLinearGradientDirection . getToY ( bottom ) ; this . mPaint . setShader ( new LinearGradient ( fromX , fromY , toX , toY , pColors , pPositions , TileMode . CLAMP ) ) ; }
iraupph/tictactoe-android | @ Override public LinearGradientFillBitmapTextureAtlasSourceDecorator deepCopy ( ) { return new LinearGradientFillBitmapTextureAtlasSourceDecorator ( this . mBitmapTextureAtlasSource , this . mBitmapTextureAtlasSourceDecoratorShape , this . mColors , this . mPositions , this . mLinearGradientDirection , this . mTextureAtlasSourceDecoratorOptions ) ; }
iraupph/tictactoe-android | private LinearGradientDirection ( final int pFromX , final int pFromY , final int pToX , final int pToY ) { this . mFromX = pFromX ; this . mFromY = pFromY ; this . mToX = pToX ; this . mToY = pToY ; }
iraupph/tictactoe-android | final int getFromX ( int pRight ) { return this . mFromX * pRight ; }
iraupph/tictactoe-android | final int getFromY ( int pBottom ) { return this . mFromY * pBottom ; }
iraupph/tictactoe-android | final int getToX ( int pRight ) { return this . mToX * pRight ; }
iraupph/tictactoe-android | final int getToY ( int pBottom ) { return this . mToY * pBottom ; }
autoschool/splinter | public WebDriverRule ( WebDriver driver ) { this . driver = driver ; }
autoschool/splinter | public String getBaseUrl ( ) { return " http : // localhost : 8080" ; }
autoschool/splinter | public void before ( ) { }
autoschool/splinter | public void after ( ) { driver . close ( ) ; driver . quit ( ) ; }
thunderace/newtifry | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; }
BadWaka/SmallDianPing | catch ( NumberFormatException nfe ) { sdkInt = 10000 ; }
BadWaka/SmallDianPing | private CameraManager ( Context context ) { this . context = context ; this . configManager = new CameraConfigurationManager ( context ) ; useOneShotPreviewCallback = Integer . parseInt ( Build . VERSION . SDK ) > 3 ; previewCallback = new PreviewCallback ( configManager , useOneShotPreviewCallback ) ; autoFocusCallback = new AutoFocusCallback ( ) ; }
BadWaka/SmallDianPing | public void openDriver ( SurfaceHolder holder ) throws IOException { if ( camera == null ) { camera = Camera . open ( ) ; if ( camera == null ) { throw new IOException ( ) ; } camera . setPreviewDisplay ( holder ) ; camera . setDisplayOrientation ( 90 ) ; Camera . Parameters parameters = camera . getParameters ( ) ; parameters . setRotation ( 90 ) ; camera . setParameters ( parameters ) ; if ( ! initialized ) { initialized = true ; configManager . initFromCameraParameters ( camera ) ; } configManager . setDesiredCameraParameters ( camera ) ; FlashlightManager . enableFlashlight ( ) ; } }
BadWaka/SmallDianPing | public void closeDriver ( ) { if ( camera != null ) { FlashlightManager . disableFlashlight ( ) ; camera . release ( ) ; camera = null ; } }
BadWaka/SmallDianPing | public void startPreview ( ) { if ( camera != null && ! previewing ) { camera . startPreview ( ) ; previewing = true ; } }
BadWaka/SmallDianPing | public void stopPreview ( ) { if ( camera != null && previewing ) { if ( ! useOneShotPreviewCallback ) { camera . setPreviewCallback ( null ) ; } camera . stopPreview ( ) ; previewCallback . setHandler ( null , 0 ) ; autoFocusCallback . setHandler ( null , 0 ) ; previewing = false ; } }
BadWaka/SmallDianPing | public void requestPreviewFrame ( Handler handler , int message ) { if ( camera != null && previewing ) { previewCallback . setHandler ( handler , message ) ; if ( useOneShotPreviewCallback ) { camera . setOneShotPreviewCallback ( previewCallback ) ; } else { camera . setPreviewCallback ( previewCallback ) ; } } }
BadWaka/SmallDianPing | public void requestAutoFocus ( Handler handler , int message ) { if ( camera != null && previewing ) { autoFocusCallback . setHandler ( handler , message ) ; camera . autoFocus ( autoFocusCallback ) ; } }
BadWaka/SmallDianPing | public Rect getFramingRect ( ) { Point screenResolution = configManager . getScreenResolution ( ) ; if ( framingRect == null ) { if ( camera == null ) { return null ; } DisplayMetrics metrics = context . getResources ( ) . getDisplayMetrics ( ) ; int width = ( int ) ( metrics . widthPixels * 0.6 ) ; int height = ( int ) ( width * 0.9 ) ; int leftOffset = ( screenResolution . x - width ) / 2 ; int topOffset = ( screenResolution . y - height ) / 2 ; framingRect = new Rect ( leftOffset , topOffset , leftOffset + width , topOffset + height ) ; Log . d ( TAG , " Calculated ▁ framing ▁ rect : ▁ " + framingRect ) ; } return framingRect ; }
BadWaka/SmallDianPing | public Rect getFramingRectInPreview ( ) { if ( framingRectInPreview == null ) { Rect rect = new Rect ( getFramingRect ( ) ) ; Point cameraResolution = configManager . getCameraResolution ( ) ; Point screenResolution = configManager . getScreenResolution ( ) ; rect . left = rect . left * cameraResolution . x / screenResolution . x ; rect . right = rect . right * cameraResolution . x / screenResolution . x ; rect . top = rect . top * cameraResolution . y / screenResolution . y ; rect . bottom = rect . bottom * cameraResolution . y / screenResolution . y ; framingRectInPreview = rect ; } return framingRectInPreview ; }
BadWaka/SmallDianPing | public PlanarYUVLuminanceSource buildLuminanceSource ( byte [ ] data , int width , int height ) { Rect rect = getFramingRectInPreview ( ) ; int previewFormat = configManager . getPreviewFormat ( ) ; String previewFormatString = configManager . getPreviewFormatString ( ) ; switch ( previewFormat ) { case PixelFormat . YCbCr_420_SP : case PixelFormat . YCbCr_422_SP : return new PlanarYUVLuminanceSource ( data , width , height , rect . left , rect . top , rect . width ( ) , rect . height ( ) ) ; default : if ( " yuv420p " . equals ( previewFormatString ) ) { return new PlanarYUVLuminanceSource ( data , width , height , rect . left , rect . top , rect . width ( ) , rect . height ( ) ) ; } } throw new IllegalArgumentException ( " Unsupported ▁ picture ▁ format : ▁ " + previewFormat + ' / ' + previewFormatString ) ; }
yyitsz/myjavastudio | public MyEntity ( ) { }
yyitsz/myjavastudio | public MyEntity ( Long id , String name ) { super ( ) ; this . id = id ; this . name = name ; }
yyitsz/myjavastudio | public Long getId ( ) { return id ; }
yyitsz/myjavastudio | public void setId ( Long id ) { this . id = id ; }
yyitsz/myjavastudio | public String getName ( ) { return name ; }
yyitsz/myjavastudio | public void setName ( String name ) { this . name = name ; }
yyitsz/myjavastudio | @ Override public String toString ( ) { return " MyEntity ▁ [ id = " + id + " , ▁ name = " + name + " ] " ; }
sayan801/LiveSDK-for-Android | public MockHttpClient ( ) { }
sayan801/LiveSDK-for-Android | public MockHttpClient ( ClientProtocolException clientProtocolException ) { this . clientProtocolException = clientProtocolException ; }
sayan801/LiveSDK-for-Android | public MockHttpClient ( HttpResponse httpResponse ) { this . responseQueue = new LinkedList < HttpResponse > ( ) ; this . responseQueue . add ( httpResponse ) ; }
sayan801/LiveSDK-for-Android | public MockHttpClient ( IOException ioException ) { this . ioException = ioException ; }
sayan801/LiveSDK-for-Android | public void addHttpResponse ( HttpResponse httpResponse ) { this . responseQueue . add ( httpResponse ) ; }
sayan801/LiveSDK-for-Android | public void clearHttpResponseQueue ( ) { this . responseQueue . clear ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpHost target , HttpRequest request ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpHost target , HttpRequest request , HttpContext context ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpHost arg0 , HttpRequest arg1 , ResponseHandler < ? extends T > arg2 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpHost arg0 , HttpRequest arg1 , ResponseHandler < ? extends T > arg2 , HttpContext arg3 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpUriRequest request ) throws IOException { if ( this . ioException != null ) { throw this . ioException ; } else if ( this . clientProtocolException != null ) { throw this . clientProtocolException ; } else if ( this . responseQueue != null && ! this . responseQueue . isEmpty ( ) ) { return this . responseQueue . remove ( ) ; } else { throw new UnsupportedOperationException ( ) ; } }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpUriRequest request , HttpContext context ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpUriRequest arg0 , ResponseHandler < ? extends T > arg1 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpUriRequest arg0 , ResponseHandler < ? extends T > arg1 , HttpContext arg2 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public ClientConnectionManager getConnectionManager ( ) { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | public HttpResponse getHttpResponse ( ) { return this . responseQueue . peek ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpParams getParams ( ) { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | public void setClientProtocolException ( ClientProtocolException clientProtocolException ) { this . clientProtocolException = clientProtocolException ; }
sayan801/LiveSDK-for-Android | public void setHttpResponse ( HttpResponse httpResponse ) { this . responseQueue . clear ( ) ; this . responseQueue . add ( httpResponse ) ; }
sayan801/LiveSDK-for-Android | public void setIoException ( IOException ioException ) { this . ioException = ioException ; }
lwd1815/Transition | public FourFragment ( ) { }
lwd1815/Transition | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; }
lwd1815/Transition | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = View . inflate ( container . getContext ( ) , R . layout . fragment_child_four , null ) ; FrameLayout frameLayout = view . findViewById ( R . id . four_child ) ; FourView fourView = new FourView ( container . getContext ( ) ) ; frameLayout . addView ( fourView ) ; return view ; }
lwd1815/Transition | @ Override public void onLazyInitView ( @ Nullable Bundle savedInstanceState ) { super . onLazyInitView ( savedInstanceState ) ; }
jyoshiriro/Boogle | private Destination getDestination ( ) { try { Destination dest = new Destination ( this , BASE_URL ) ; int queryNumber = TestsMocks . getRandomInteger ( ) ; String query = TestsMocks . getQuery ( queryNumber ) ; dest . getRequestContext ( ) . addPathSegment ( " query " , query ) ; List < ResultDetail > expectedResults = TestsMocks . getExpectedResults ( queryNumber ) ; Map < String , List < ResultDetail > > expectedMap = new TreeMap < String , List < ResultDetail > > ( ) ; expectedMap . put ( BookUtil . RESULT_MATCHES_NAME , expectedResults ) ; ObjectMapper mapper = new ObjectMapper ( ) ; expectedResult = mapper . writeValueAsString ( expectedMap ) ; return dest ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
jyoshiriro/Boogle | " , type = MediaType . TEXT_HTML ) public void testSearch ( ) { assertOk ( response ) ; assertEquals ( response . getBody ( ) . trim ( ) , expectedResult . trim ( ) ) ; }
gocd-contrib/docker-elastic-agents | @ Override public GoPluginApiResponse execute ( ) { return new DefaultGoPluginApiResponse ( 200 , GSON . toJson ( FIELDS ) ) ; }
au-research/ANDS-RIFCS-API | protected CitationDate ( final Node n ) throws RIFCSException { super ( n , Constants . ELEMENT_DATE ) ; }
au-research/ANDS-RIFCS-API | public final void setType ( final String type ) { super . setAttributeValue ( Constants . ATTRIBUTE_TYPE , type ) ; }
au-research/ANDS-RIFCS-API | public final String getType ( ) { return super . getAttributeValue ( Constants . ATTRIBUTE_TYPE ) ; }
au-research/ANDS-RIFCS-API | public final void setValue ( final String value ) { super . setTextContent ( value ) ; }
au-research/ANDS-RIFCS-API | public final String getValue ( ) { return super . getTextContent ( ) ; }
mmazurkevich/sping-examples | @ Override public void afterConnected ( StompSession session , StompHeaders connectedHeaders ) { session . subscribe ( " / topic / connection " , new ConnectionHandler ( ) ) ; session . subscribe ( " / topic / messages " , new MessageHandler ( ) ) ; session . send ( " / app / login " , SocketClient . username ) ; }
JSDemos/android-sdk-20 | public GeofenceHardware ( IGeofenceHardware service ) { mService = service ; }
JSDemos/android-sdk-20 | public int [ ] getMonitoringTypes ( ) { try { return mService . getMonitoringTypes ( ) ; } catch ( RemoteException e ) { } return new int [ 0 ] ; }
JSDemos/android-sdk-20 | public int getStatusOfMonitoringType ( int monitoringType ) { try { return mService . getStatusOfMonitoringType ( monitoringType ) ; } catch ( RemoteException e ) { return MONITOR_UNSUPPORTED ; } }
JSDemos/android-sdk-20 | public boolean addGeofence ( int geofenceId , int monitoringType , GeofenceHardwareRequest geofenceRequest , GeofenceHardwareCallback callback ) { try { if ( geofenceRequest . getType ( ) == GeofenceHardwareRequest . GEOFENCE_TYPE_CIRCLE ) { return mService . addCircularFence ( geofenceId , monitoringType , geofenceRequest . getLatitude ( ) , geofenceRequest . getLongitude ( ) , geofenceRequest . getRadius ( ) , geofenceRequest . getLastTransition ( ) , geofenceRequest . getMonitorTransitions ( ) , geofenceRequest . getNotificationResponsiveness ( ) , geofenceRequest . getUnknownTimer ( ) , getCallbackWrapper ( callback ) ) ; } else { throw new IllegalArgumentException ( " Geofence ▁ Request ▁ type ▁ not ▁ supported " ) ; } } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean removeGeofence ( int geofenceId , int monitoringType ) { try { return mService . removeGeofence ( geofenceId , monitoringType ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean pauseGeofence ( int geofenceId , int monitoringType ) { try { return mService . pauseGeofence ( geofenceId , monitoringType ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean resumeGeofence ( int geofenceId , int monitoringType , int monitorTransition ) { try { return mService . resumeGeofence ( geofenceId , monitoringType , monitorTransition ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean registerForMonitorStateChangeCallback ( int monitoringType , GeofenceHardwareMonitorCallback callback ) { try { return mService . registerForMonitorStateChangeCallback ( monitoringType , getMonitorCallbackWrapper ( callback ) ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean unregisterForMonitorStateChangeCallback ( int monitoringType , GeofenceHardwareMonitorCallback callback ) { boolean result = false ; try { result = mService . unregisterForMonitorStateChangeCallback ( monitoringType , getMonitorCallbackWrapper ( callback ) ) ; if ( result ) removeMonitorCallback ( callback ) ; } catch ( RemoteException e ) { } return result ; }
JSDemos/android-sdk-20 | private void removeCallback ( GeofenceHardwareCallback callback ) { synchronized ( mCallbacks ) { mCallbacks . remove ( callback ) ; } }
JSDemos/android-sdk-20 | private GeofenceHardwareCallbackWrapper getCallbackWrapper ( GeofenceHardwareCallback callback ) { synchronized ( mCallbacks ) { GeofenceHardwareCallbackWrapper wrapper = mCallbacks . get ( callback ) ; if ( wrapper == null ) { wrapper = new GeofenceHardwareCallbackWrapper ( callback ) ; mCallbacks . put ( callback , wrapper ) ; } return wrapper ; } }
JSDemos/android-sdk-20 | private void removeMonitorCallback ( GeofenceHardwareMonitorCallback callback ) { synchronized ( mMonitorCallbacks ) { mMonitorCallbacks . remove ( callback ) ; } }
JSDemos/android-sdk-20 | private GeofenceHardwareMonitorCallbackWrapper getMonitorCallbackWrapper ( GeofenceHardwareMonitorCallback callback ) { synchronized ( mMonitorCallbacks ) { GeofenceHardwareMonitorCallbackWrapper wrapper = mMonitorCallbacks . get ( callback ) ; if ( wrapper == null ) { wrapper = new GeofenceHardwareMonitorCallbackWrapper ( callback ) ; mMonitorCallbacks . put ( callback , wrapper ) ; } return wrapper ; } }
JSDemos/android-sdk-20 | GeofenceHardwareMonitorCallbackWrapper ( GeofenceHardwareMonitorCallback c ) { mCallback = new WeakReference < GeofenceHardwareMonitorCallback > ( c ) ; }
JSDemos/android-sdk-20 | public void onMonitoringSystemChange ( int monitoringType , boolean available , Location location ) { GeofenceHardwareMonitorCallback c = mCallback . get ( ) ; if ( c != null ) c . onMonitoringSystemChange ( monitoringType , available , location ) ; }
JSDemos/android-sdk-20 | GeofenceHardwareCallbackWrapper ( GeofenceHardwareCallback c ) { mCallback = new WeakReference < GeofenceHardwareCallback > ( c ) ; }
JSDemos/android-sdk-20 | public void onGeofenceTransition ( int geofenceId , int transition , Location location , long timestamp , int monitoringType ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) { c . onGeofenceTransition ( geofenceId , transition , location , timestamp , monitoringType ) ; } }
JSDemos/android-sdk-20 | public void onGeofenceAdd ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) c . onGeofenceAdd ( geofenceId , status ) ; }
JSDemos/android-sdk-20 | public void onGeofenceRemove ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) { c . onGeofenceRemove ( geofenceId , status ) ; removeCallback ( c ) ; } }
JSDemos/android-sdk-20 | public void onGeofencePause ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) { c . onGeofencePause ( geofenceId , status ) ; } }
JSDemos/android-sdk-20 | public void onGeofenceResume ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) c . onGeofenceResume ( geofenceId , status ) ; }
artem-aliev/tinkerpop | @ Test public void shouldEvalBytecode ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " x " , g ) ; final Traversal evald = scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; assertTraversals ( t , evald ) ; assertThat ( manager . getBindings ( ) . containsKey ( GremlinScriptEngine . HIDDEN_G ) , is ( false ) ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithAliasInBindings ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " x " , g ) ; bindings . put ( GremlinScriptEngine . HIDDEN_G , g ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithAliasAsTraversalSource ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " x " , g ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , GremlinScriptEngine . HIDDEN_G ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithMissingBinding ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " z " , g ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithInvalidBinding ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " z " , g ) ; bindings . put ( " x " , " invalid - binding - for - x - given - x - should - be - traversal - source " ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; }
artem-aliev/tinkerpop | @ Test public void shouldGetEngineByName ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; assertEquals ( ENGINE_TO_TEST , scriptEngine . getFactory ( ) . getEngineName ( ) ) ; }
artem-aliev/tinkerpop | @ Test public void shouldHaveCoreImportsInPlace ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final List < Class > classesToCheck = Arrays . asList ( Vertex . class , Edge . class , Graph . class , VertexProperty . class ) ; for ( Class clazz : classesToCheck ) { assertEquals ( clazz , scriptEngine . eval ( clazz . getSimpleName ( ) ) ) ; } }
artem-aliev/tinkerpop | @ Test public void shouldReturnNoCustomizers ( ) { final GremlinScriptEngineManager mgr = new DefaultGremlinScriptEngineManager ( ) ; mgr . addPlugin ( ImportGremlinPlugin . build ( ) . classImports ( java . awt . Color . class ) . appliesTo ( Collections . singletonList ( " fake - script - engine " ) ) . create ( ) ) ; assertEquals ( 0 , mgr . getCustomizers ( ENGINE_TO_TEST ) . size ( ) ) ; }
stephencullinan/WeighBridge | public WeighBridgeFrame ( ) { try { UIManager . setLookAndFeel ( new SubstanceOfficeBlue2007LookAndFeel ( ) ) ; } catch ( Exception error ) { JOptionPane . showMessageDialog ( null , error ) ; } aWeighBridge = new WeighBridge ( ) ; frame = createFrame ( " WeighBridge ▁ Portal " ) ; selectWeightType ( ) ; frame . setVisible ( true ) ; }
stephencullinan/WeighBridge | public void selectWeightType ( ) { JPanel aPanel = new JPanel ( new GridLayout ( 2 , 2 ) ) ; JButton firstWeightTile = createTile ( " First ▁ Weight " , " " , 4 ) ; firstWeightTile . addActionListener ( x -> selectWeightDocketType ( ) ) ; aPanel . add ( firstWeightTile ) ; JButton secondWeightTile = createTile ( " Second ▁ Weight " , " " , 4 ) ; secondWeightTile . addActionListener ( x -> selectSecondWeight ( ) ) ; aPanel . add ( secondWeightTile ) ; JButton logOnTile = createTile ( " Log ▁ On " , " " , 4 ) ; logOnTile . addActionListener ( x -> { SwingUtilities . invokeLater ( ( ) -> { new LogOnFrame ( ) ; frame . dispose ( ) ; } ) ; } ) ; aPanel . add ( logOnTile ) ; JButton registrationTile = createTile ( " Registration " , " " , 4 ) ; registrationTile . addActionListener ( x -> { SwingUtilities . invokeLater ( ( ) -> { new RegistrationFrame ( ) ; frame . dispose ( ) ; } ) ; } ) ; aPanel . add ( registrationTile ) ; addComponent ( aPanel ) ; }
stephencullinan/WeighBridge | public void selectWeightDocketType ( ) { ArrayList < DocketType > docketTypesObjects = aWeighBridge . getDocketTypes ( ) ; JPanel docketTypesPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; docketTypesObjects . forEach ( z -> { JButton aDocketType = createTile ( z . toString ( ) , " " , docketTypesObjects . size ( ) ) ; aDocketType . addActionListener ( ( y ) -> { aWeighBridge . setSelectedDocketType ( z ) ; selectConsignee ( ) ; } ) ; docketTypesPanel . add ( aDocketType ) ; } ) ; addComponent ( docketTypesPanel ) ; }
stephencullinan/WeighBridge | public void selectConsignee ( ) { JPanel consigneesPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; ArrayList < Consignee > consigneesObjects = new ArrayList < > ( ) ; final int numberOfConsignees = consigneesObjects . size ( ) ; if ( aWeighBridge . getSelectedDocketType ( ) . getCode ( ) == 1 ) { consigneesObjects = aWeighBridge . getConsignees ( " suppliers " ) ; JButton addNewSupplierTile = createTile ( " Add ▁ New ▁ Supplier " , " " , numberOfConsignees + 1 ) ; addNewSupplierTile . addActionListener ( ( x ) -> addNewSupplier ( ) ) ; consigneesPanel . add ( addNewSupplierTile ) ; } else if ( aWeighBridge . getSelectedDocketType ( ) . getCode ( ) == 2 ) { consigneesObjects = aWeighBridge . getConsignees ( " customers " ) ; JButton addNewCustomerTile = createTile ( " Add ▁ New ▁ Customer " , " " , numberOfConsignees + 1 ) ; addNewCustomerTile . addActionListener ( ( x ) -> addNewCustomer ( ) ) ; consigneesPanel . add ( addNewCustomerTile ) ; } consigneesObjects . forEach ( x -> { JButton aConsignee = createTile ( x . toString ( ) , " " , numberOfConsignees + 1 ) ; aConsignee . addActionListener ( y -> { aWeighBridge . setSelectedConsignee ( x ) ; selectDriver ( ) ; } ) ; consigneesPanel . add ( aConsignee ) ; } ) ; addComponent ( consigneesPanel ) ; }
stephencullinan/WeighBridge | public void selectDriver ( ) { ArrayList < Driver > driverObjects = aWeighBridge . getDrivers ( ) ; JPanel driversPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; JButton createNewDriver = createTile ( " Add ▁ New ▁ Driver " , " " , driverObjects . size ( ) + 1 ) ; createNewDriver . addActionListener ( ( x ) -> addNewDriver ( ) ) ; driversPanel . add ( createNewDriver ) ; driverObjects . forEach ( x -> { JButton aDriver = createTile ( x . toString ( ) , " users / " + x . getCode ( ) + " . png " , driverObjects . size ( ) + 1 ) ; aDriver . addActionListener ( ( y ) -> { aWeighBridge . setSelectedDriver ( x ) ; selectCommodity ( ) ; } ) ; driversPanel . add ( aDriver ) ; } ) ; addComponent ( driversPanel ) ; }
stephencullinan/WeighBridge | public void addNewDriver ( ) { JPanel addNewDriversPanel = new JPanel ( new GridLayout ( 5 , 1 ) ) ; JTextField firstName = createTextField ( " " ) ; JTextField lastName = createTextField ( " " ) ; JButton addDriverButton = createButton ( " Add ▁ New ▁ Driver " ) ; addDriverButton . addActionListener ( ( x ) -> { if ( firstName . getText ( ) . length ( ) > 1 && lastName . getText ( ) . length ( ) > 1 ) { Driver aDriver = aWeighBridge . insertNewDriver ( firstName . getText ( ) , lastName . getText ( ) ) ; JPanel obtainPhotoPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; JProgressBar obtainPhotoProgressBar = createProgressBar ( 0 , 100 ) ; JLabel obtainPhotoLabel = createLabel ( " Initialising ▁ The ▁ WebCam " ) ; obtainPhotoPanel . add ( obtainPhotoLabel ) ; obtainPhotoPanel . add ( obtainPhotoProgressBar ) ; addComponent ( obtainPhotoPanel ) ; ObtainPhoto obtainPhoto = new ObtainPhoto ( obtainPhotoLabel , obtainPhotoProgressBar , " images / users / " + aDriver . getCode ( ) + " . png " ) ; obtainPhoto . execute ( ) ; obtainPhoto . addPropertyChangeListener ( y -> { if ( y . getNewValue ( ) . toString ( ) . contains ( " DONE " ) && y . getPropertyName ( ) . toString ( ) . contains ( " state " ) ) selectCommodity ( ) ; } ) ; } else addNewDriver ( ) ; } ) ; addNewDriversPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ first ▁ name ▁ of ▁ the ▁ driver " ) ) ; addNewDriversPanel . add ( firstName ) ; addNewDriversPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ last ▁ name ▁ of ▁ the ▁ driver " ) ) ; addNewDriversPanel . add ( lastName ) ; addNewDriversPanel . add ( addDriverButton ) ; addComponent ( addNewDriversPanel ) ; }
stephencullinan/WeighBridge | public void addNewCommodity ( ) { JPanel addNewCommodityPanel = new JPanel ( new GridLayout ( 3 , 1 ) ) ; JTextField commodity = createTextField ( " " ) ; JButton addCommodityButton = createButton ( " Add ▁ New ▁ Entities . Commodity " ) ; addCommodityButton . addActionListener ( ( x ) -> { if ( commodity . getText ( ) . length ( ) > 1 ) { aWeighBridge . insertNewCommodity ( commodity . getText ( ) ) ; selectFirstWeight ( ) ; } else addNewCommodity ( ) ; } ) ; addNewCommodityPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ name ▁ of ▁ the ▁ commodity " ) ) ; addNewCommodityPanel . add ( commodity ) ; addNewCommodityPanel . add ( addCommodityButton ) ; addComponent ( addNewCommodityPanel ) ; }
stephencullinan/WeighBridge | public void addNewCustomer ( ) { JPanel addNewCustomerPanel = new JPanel ( new GridLayout ( 5 , 1 ) ) ; JTextField customerFirstName = createTextField ( " " ) ; JTextField customerLastName = createTextField ( " " ) ; JButton addCustomerButton = createButton ( " Add ▁ New ▁ Customer " ) ; addCustomerButton . addActionListener ( ( x ) -> { if ( customerFirstName . getText ( ) . length ( ) > 1 && customerLastName . getText ( ) . length ( ) > 1 ) { aWeighBridge . insertNewConsignee ( customerFirstName . getText ( ) , customerLastName . getText ( ) , " customers " ) ; selectDriver ( ) ; } else addNewCustomer ( ) ; } ) ; addNewCustomerPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ first ▁ name ▁ of ▁ the ▁ customer " ) ) ; addNewCustomerPanel . add ( customerFirstName ) ; addNewCustomerPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ last ▁ name ▁ of ▁ the ▁ customer " ) ) ; addNewCustomerPanel . add ( customerLastName ) ; addNewCustomerPanel . add ( addCustomerButton ) ; addComponent ( addNewCustomerPanel ) ; }
stephencullinan/WeighBridge | public void addNewSupplier ( ) { JPanel addNewSupplierPanel = new JPanel ( new GridLayout ( 5 , 1 ) ) ; JTextField supplierFirstName = createTextField ( " " ) ; JTextField supplierLastName = createTextField ( " " ) ; JButton addSupplierButton = createButton ( " Add ▁ New ▁ Supplier " ) ; addSupplierButton . addActionListener ( ( x ) -> { if ( supplierFirstName . getText ( ) . length ( ) > 1 && supplierLastName . getText ( ) . length ( ) > 1 ) { aWeighBridge . insertNewConsignee ( supplierFirstName . getText ( ) , supplierLastName . getText ( ) , " suppliers " ) ; selectDriver ( ) ; } else addNewSupplier ( ) ; } ) ; addNewSupplierPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ first ▁ name ▁ of ▁ the ▁ supplier " ) ) ; addNewSupplierPanel . add ( supplierFirstName ) ; addNewSupplierPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ last ▁ name ▁ of ▁ the ▁ supplier " ) ) ; addNewSupplierPanel . add ( supplierLastName ) ; addNewSupplierPanel . add ( addSupplierButton ) ; addComponent ( addNewSupplierPanel ) ; }
stephencullinan/WeighBridge | public void selectCommodity ( ) { ArrayList < Commodity > commoditiesObjects = aWeighBridge . getCommodities ( ) ; JPanel commoditiesPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; JButton addNewCommodityButton = createTile ( " Add ▁ New ▁ Commodity " , " " , commoditiesObjects . size ( ) + 1 ) ; addNewCommodityButton . addActionListener ( x -> addNewCommodity ( ) ) ; commoditiesPanel . add ( addNewCommodityButton ) ; commoditiesObjects . forEach ( x -> { JButton aCommodity = createTile ( x . getTitle ( ) , " commodities / " + x . getCode ( ) , commoditiesObjects . size ( ) + 1 ) ; aCommodity . addActionListener ( y -> { aWeighBridge . setSelectedCommodity ( x ) ; selectFirstWeight ( ) ; } ) ; commoditiesPanel . add ( aCommodity ) ; } ) ; addComponent ( commoditiesPanel ) ; }
stephencullinan/WeighBridge | public void selectFirstWeight ( ) { aWeighBridge . insertNewFirstWeight ( ) ; selectWeightType ( ) ; }
stephencullinan/WeighBridge | public void selectSecondWeight ( ) { ArrayList < ArrayList < String > > firstWeightsAwaitingSecondWeight = aWeighBridge . getDocketsAwaitingSecondWeightment ( ) ; JPanel secondWeightsPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; firstWeightsAwaitingSecondWeight . forEach ( x -> { aWeighBridge . retrieveParametersForSelectedSecondWeight ( x . get ( 1 ) , x . get ( 2 ) , x . get ( 5 ) , x . get ( 6 ) ) ; JButton currentButton = createTile ( aWeighBridge . getCaptionTitle ( ) , " " , firstWeightsAwaitingSecondWeight . size ( ) ) ; currentButton . addActionListener ( ( y ) -> { aWeighBridge . insertNewSecondWeight ( x . get ( 0 ) , x . get ( 3 ) , x . get ( 4 ) ) ; aWeighBridge . generateReport ( ) ; selectDocket ( ) ; } ) ; secondWeightsPanel . add ( currentButton ) ; } ) ; if ( firstWeightsAwaitingSecondWeight . size ( ) == 0 ) { JButton returnToMainMenuTile = createTile ( " Return ▁ To ▁ Main ▁ Menu " , " " , 1 ) ; returnToMainMenuTile . addActionListener ( ( ( y ) -> selectWeightType ( ) ) ) ; secondWeightsPanel . add ( returnToMainMenuTile ) ; } addComponent ( secondWeightsPanel ) ; }
stephencullinan/WeighBridge | public void selectDocket ( ) { JPanel processDocketPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; JButton printDocketTile = createTile ( " Print ▁ Docket " , " " , 3 ) ; printDocketTile . addActionListener ( ( x ) -> { aWeighBridge . printReport ( ) ; selectWeightType ( ) ; } ) ; JButton emailDocketTile = createTile ( " Email ▁ Docket " , " " , 3 ) ; emailDocketTile . addActionListener ( ( x ) -> { JPanel emailDocketPanel = new JPanel ( new GridLayout ( 3 , 1 ) ) ; JTextField emailAddressTextField = createTextField ( " " ) ; emailDocketPanel . add ( createLabel ( " Please ▁ enter ▁ your ▁ email ▁ address " ) ) ; emailDocketPanel . add ( emailAddressTextField ) ; JButton emailDocketButton = createButton ( " Submit ▁ Your ▁ Email ▁ Address " ) ; emailDocketButton . addActionListener ( ( y ) -> { if ( emailAddressTextField . getText ( ) . length ( ) > 2 ) { aWeighBridge . emailReport ( emailAddressTextField . getText ( ) ) ; selectWeightType ( ) ; } } ) ; emailDocketPanel . add ( emailDocketButton ) ; addComponent ( emailDocketPanel ) ; } ) ; JButton returnToMainMenuTile = createTile ( " Return ▁ To ▁ Main ▁ Menu " , " " , 3 ) ; returnToMainMenuTile . addActionListener ( ( x ) -> { selectWeightType ( ) ; } ) ; processDocketPanel . add ( printDocketTile ) ; processDocketPanel . add ( emailDocketTile ) ; processDocketPanel . add ( returnToMainMenuTile ) ; addComponent ( processDocketPanel ) ; }
stephencullinan/WeighBridge | private void addComponent ( JComponent newComponent ) { if ( component != null ) frame . remove ( component ) ; component = newComponent ; frame . add ( component ) ; frame . invalidate ( ) ; frame . revalidate ( ) ; }
stephencullinan/WeighBridge | private void refreshComponent ( ) { frame . invalidate ( ) ; frame . revalidate ( ) ; }
facebook/presto | @ Inject public TestingAccessControlManager ( TransactionManager transactionManager ) { super ( transactionManager ) ; setSystemAccessControl ( AllowAllSystemAccessControl . NAME , ImmutableMap . of ( ) ) ; }
facebook/presto | public void deny ( TestingPrivilege ... deniedPrivileges ) { Collections . addAll ( this . denyPrivileges , deniedPrivileges ) ; }
facebook/presto | public void reset ( ) { denyPrivileges . clear ( ) ; }
facebook/presto | @ Override public void checkCanSetUser ( Identity identity , AccessControlContext context , Optional < Principal > principal , String userName ) { if ( shouldDenyPrivilege ( userName , userName , SET_USER ) ) { denySetUser ( principal , userName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetUser ( identity , context , principal , userName ) ; } }
facebook/presto | @ Override public void checkCanCreateSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , CREATE_SCHEMA ) ) { denyCreateSchema ( schemaName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateSchema ( transactionId , identity , context , schemaName ) ; } }
facebook/presto | @ Override public void checkCanDropSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , DROP_SCHEMA ) ) { denyDropSchema ( schemaName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropSchema ( transactionId , identity , context , schemaName ) ; } }
facebook/presto | @ Override public void checkCanRenameSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName , String newSchemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , RENAME_SCHEMA ) ) { denyRenameSchema ( schemaName . toString ( ) , newSchemaName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanRenameSchema ( transactionId , identity , context , schemaName , newSchemaName ) ; } }
facebook/presto | @ Override public void checkCanCreateTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , CREATE_TABLE ) ) { denyCreateTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanDropTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DROP_TABLE ) ) { denyDropTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanRenameTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , QualifiedObjectName newTableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , RENAME_TABLE ) ) { denyRenameTable ( tableName . toString ( ) , newTableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanRenameTable ( transactionId , identity , context , tableName , newTableName ) ; } }
facebook/presto | @ Override public void checkCanAddColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , ADD_COLUMN ) ) { denyAddColumn ( tableName . toString ( ) ) ; } super . checkCanAddColumns ( transactionId , identity , context , tableName ) ; }
facebook/presto | @ Override public void checkCanDropColumn ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DROP_COLUMN ) ) { denyDropColumn ( tableName . toString ( ) ) ; } super . checkCanDropColumn ( transactionId , identity , context , tableName ) ; }
facebook/presto | @ Override public void checkCanRenameColumn ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , RENAME_COLUMN ) ) { denyRenameColumn ( tableName . toString ( ) ) ; } super . checkCanRenameColumn ( transactionId , identity , context , tableName ) ; }
facebook/presto | @ Override public void checkCanInsertIntoTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , INSERT_TABLE ) ) { denyInsertTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanInsertIntoTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanDeleteFromTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DELETE_TABLE ) ) { denyDeleteTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDeleteFromTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanCreateView ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName viewName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , viewName . getObjectName ( ) , CREATE_VIEW ) ) { denyCreateView ( viewName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateView ( transactionId , identity , context , viewName ) ; } }
facebook/presto | @ Override public void checkCanDropView ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName viewName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , viewName . getObjectName ( ) , DROP_VIEW ) ) { denyDropView ( viewName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropView ( transactionId , identity , context , viewName ) ; } }
facebook/presto | @ Override public void checkCanSetSystemSessionProperty ( Identity identity , AccessControlContext context , String propertyName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , propertyName , SET_SESSION ) ) { denySetSystemSessionProperty ( propertyName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetSystemSessionProperty ( identity , context , propertyName ) ; } }
facebook/presto | @ Override public void checkCanCreateViewWithSelectFromColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , Set < String > columnNames ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , CREATE_VIEW_WITH_SELECT_COLUMNS ) ) { denyCreateViewWithSelect ( tableName . toString ( ) , identity ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateViewWithSelectFromColumns ( transactionId , identity , context , tableName , columnNames ) ; } }
facebook/presto | @ Override public void checkCanSetCatalogSessionProperty ( TransactionId transactionId , Identity identity , AccessControlContext context , String catalogName , String propertyName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , catalogName + " . " + propertyName , SET_SESSION ) ) { denySetCatalogSessionProperty ( catalogName , propertyName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetCatalogSessionProperty ( transactionId , identity , context , catalogName , propertyName ) ; } }
facebook/presto | @ Override public void checkCanSelectFromColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , Set < String > columns ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , SELECT_COLUMN ) ) { denySelectColumns ( tableName . toString ( ) , columns ) ; } for ( String column : columns ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , column , SELECT_COLUMN ) ) { denySelectColumns ( tableName . toString ( ) , columns ) ; } } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSelectFromColumns ( transactionId , identity , context , tableName , columns ) ; } }
facebook/presto | private boolean shouldDenyPrivilege ( String userName , String entityName , TestingPrivilegeType type ) { TestingPrivilege testPrivilege = privilege ( userName , entityName , type ) ; for ( TestingPrivilege denyPrivilege : denyPrivileges ) { if ( denyPrivilege . matches ( testPrivilege ) ) { return true ; } } return false ; }
facebook/presto | private TestingPrivilege ( Optional < String > userName , String entityName , TestingPrivilegeType type ) { this . userName = requireNonNull ( userName , " userName ▁ is ▁ null " ) ; this . entityName = requireNonNull ( entityName , " entityName ▁ is ▁ null " ) ; this . type = requireNonNull ( type , " type ▁ is ▁ null " ) ; }
facebook/presto | public boolean matches ( TestingPrivilege testPrivilege ) { return userName . map ( name -> testPrivilege . userName . get ( ) . equals ( name ) ) . orElse ( true ) && entityName . equals ( testPrivilege . entityName ) && type == testPrivilege . type ; }
facebook/presto | @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TestingPrivilege that = ( TestingPrivilege ) o ; return Objects . equals ( entityName , that . entityName ) && Objects . equals ( type , that . type ) ; }
facebook/presto | @ Override public int hashCode ( ) { return Objects . hash ( entityName , type ) ; }
facebook/presto | @ Override public String toString ( ) { return toStringHelper ( this ) . add ( " userName " , userName ) . add ( " entityName " , entityName ) . add ( " type " , type ) . toString ( ) ; }
KiviMao/kivi | if ( unpackNested ) { nestedEntry . setComment ( " UNPACK : 0000000000000000000000000000000000000000" ) ; }
markzhai/InterestingTitleBar | catch ( Throwable e ) { e . printStackTrace ( ) ; }
11xor6/presto | private DynamicFiltersTestUtil ( ) { }
Dhandapani/gluster-ovirt | @ Override public UICommand getUpdateCommand ( ) { return privateUpdateCommand ; }
Dhandapani/gluster-ovirt | private void setUpdateCommand ( UICommand value ) { privateUpdateCommand = value ; }
Dhandapani/gluster-ovirt | public UICommand getLoginAllCommand ( ) { return privateLoginAllCommand ; }
Dhandapani/gluster-ovirt | private void setLoginAllCommand ( UICommand value ) { privateLoginAllCommand = value ; }
Dhandapani/gluster-ovirt | public UICommand getDiscoverTargetsCommand ( ) { return privateDiscoverTargetsCommand ; }
Dhandapani/gluster-ovirt | private void setDiscoverTargetsCommand ( UICommand value ) { privateDiscoverTargetsCommand = value ; }
Dhandapani/gluster-ovirt | @ Override public StorageModel getContainer ( ) { return privateContainer ; }
Dhandapani/gluster-ovirt | @ Override public void setContainer ( StorageModel value ) { privateContainer = value ; }
Dhandapani/gluster-ovirt | @ Override public StorageDomainType getRole ( ) { return privateRole ; }
Dhandapani/gluster-ovirt | @ Override public void setRole ( StorageDomainType value ) { privateRole = value ; }
Dhandapani/gluster-ovirt | public EntityModel getAddress ( ) { return privateAddress ; }
Dhandapani/gluster-ovirt | private void setAddress ( EntityModel value ) { privateAddress = value ; }
Dhandapani/gluster-ovirt | public EntityModel getPort ( ) { return privatePort ; }
Dhandapani/gluster-ovirt | private void setPort ( EntityModel value ) { privatePort = value ; }
Dhandapani/gluster-ovirt | public EntityModel getUserName ( ) { return privateUserName ; }
Dhandapani/gluster-ovirt | private void setUserName ( EntityModel value ) { privateUserName = value ; }
Dhandapani/gluster-ovirt | public EntityModel getPassword ( ) { return privatePassword ; }
Dhandapani/gluster-ovirt | private void setPassword ( EntityModel value ) { privatePassword = value ; }
Dhandapani/gluster-ovirt | public EntityModel getUseUserAuth ( ) { return privateUseUserAuth ; }
Dhandapani/gluster-ovirt | private void setUseUserAuth ( EntityModel value ) { privateUseUserAuth = value ; }
Dhandapani/gluster-ovirt | public boolean getProposeDiscoverTargets ( ) { return proposeDiscoverTargets ; }
Dhandapani/gluster-ovirt | public void setProposeDiscoverTargets ( boolean value ) { if ( proposeDiscoverTargets != value ) { proposeDiscoverTargets = value ; OnPropertyChanged ( new PropertyChangedEventArgs ( " ProposeDiscoverTargets " ) ) ; } }
Dhandapani/gluster-ovirt | public boolean getIsAllLunsSelected ( ) { return isAllLunsSelected ; }
Dhandapani/gluster-ovirt | public void setIsAllLunsSelected ( boolean value ) { if ( isAllLunsSelected != value ) { isAllLunsSelected = value ; IsAllLunsSelectedChanged ( ) ; OnPropertyChanged ( new PropertyChangedEventArgs ( " IsAllLunsSelected " ) ) ; } }
Dhandapani/gluster-ovirt | protected SanStorageModelBase ( ) { setUpdateCommand ( new UICommand ( " Update " , this ) ) ; UICommand tempVar = new UICommand ( " LoginAll " , this ) ; tempVar . setIsExecutionAllowed ( false ) ; setLoginAllCommand ( tempVar ) ; setDiscoverTargetsCommand ( new UICommand ( " DiscoverTargets " , this ) ) ; setAddress ( new EntityModel ( ) ) ; EntityModel tempVar2 = new EntityModel ( ) ; tempVar2 . setEntity ( "3260" ) ; setPort ( tempVar2 ) ; setUserName ( new EntityModel ( ) ) ; setPassword ( new EntityModel ( ) ) ; EntityModel tempVar3 = new EntityModel ( ) ; tempVar3 . setEntity ( false ) ; setUseUserAuth ( tempVar3 ) ; getUseUserAuth ( ) . getEntityChangedEvent ( ) . addListener ( this ) ; UpdateUserAuthFields ( ) ; }
Dhandapani/gluster-ovirt | @ Override public void eventRaised ( Event ev , Object sender , EventArgs args ) { super . eventRaised ( ev , sender , args ) ; if ( ev . equals ( SanTargetModel . LoggedInEventDefinition ) ) { SanTargetModel_LoggedIn ( sender , args ) ; } else if ( ev . equals ( EntityChangedEventDefinition ) ) { UseUserAuth_EntityChanged ( sender , args ) ; } }
Dhandapani/gluster-ovirt | private void postLogin ( FrontendActionAsyncResult result ) { VdcReturnValueBase returnValue = result . getReturnValue ( ) ; SanStorageModelBase sanStorageModel = ( SanStorageModelBase ) result . getState ( ) ; SanTargetModel sanTargetModel = sanStorageModel . targetsToConnect . remove ( 0 ) ; boolean success = returnValue != null && returnValue . getSucceeded ( ) ; if ( success ) { sanTargetModel . setIsLoggedIn ( true ) ; sanTargetModel . getLoginCommand ( ) . setIsExecutionAllowed ( false ) ; } if ( sanStorageModel . targetsToConnect . isEmpty ( ) ) { sanStorageModel . getContainer ( ) . StopProgress ( ) ; sanStorageModel . UpdateInternal ( ) ; } }
Dhandapani/gluster-ovirt | private void connectTargets ( ) { VDS host = ( VDS ) getContainer ( ) . getHost ( ) . getSelectedItem ( ) ; if ( host == null ) { return ; } java . util . ArrayList < VdcActionType > actionTypes = new java . util . ArrayList < VdcActionType > ( ) ; ArrayList < VdcActionParametersBase > paramerters = new ArrayList < VdcActionParametersBase > ( ) ; ArrayList < IFrontendActionAsyncCallback > callbacks = new ArrayList < IFrontendActionAsyncCallback > ( ) ; IFrontendActionAsyncCallback loginCallback = new IFrontendActionAsyncCallback ( ) { @ Override public void Executed ( FrontendActionAsyncResult result ) { SanStorageModelBase sanStorageModel = ( SanStorageModelBase ) result . getState ( ) ; sanStorageModel . postLogin ( result ) ; } } ; for ( int i = 0 ; i < targetsToConnect . size ( ) ; i ++ ) { SanTargetModel model = targetsToConnect . get ( i ) ; storage_server_connections connection = new storage_server_connections ( ) ; connection . setportal ( "0" ) ; connection . setstorage_type ( StorageType . ISCSI ) ; connection . setuser_name ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getUserName ( ) . getEntity ( ) : " " ) ; connection . setpassword ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getPassword ( ) . getEntity ( ) : " " ) ; connection . setiqn ( model . getName ( ) ) ; connection . setconnection ( model . getAddress ( ) ) ; connection . setport ( String . valueOf ( model . getPort ( ) ) ) ; actionTypes . add ( VdcActionType . ConnectStorageToVds ) ; paramerters . add ( new StorageServerConnectionParametersBase ( connection , host . getId ( ) ) ) ; callbacks . add ( loginCallback ) ; } getContainer ( ) . StartProgress ( null ) ; Frontend . RunMultipleActions ( actionTypes , paramerters , callbacks , null , this ) ; }
Dhandapani/gluster-ovirt | private void SanTargetModel_LoggedIn ( Object sender , EventArgs args ) { SanTargetModel model = ( SanTargetModel ) sender ; targetsToConnect = new ArrayList < SanTargetModel > ( ) ; targetsToConnect . add ( model ) ; connectTargets ( ) ; }
Dhandapani/gluster-ovirt | private void LoginAll ( ) { java . util . List < SanTargetModel > items = ( java . util . List < SanTargetModel > ) getItems ( ) ; targetsToConnect = new ArrayList < SanTargetModel > ( ) ; for ( SanTargetModel item : items ) { if ( ! item . getIsLoggedIn ( ) ) { targetsToConnect . add ( item ) ; } } connectTargets ( ) ; }
Dhandapani/gluster-ovirt | private void DiscoverTargets ( ) { if ( getContainer ( ) . getProgress ( ) != null ) { return ; } if ( ! ValidateDiscoverTargetFields ( ) ) { return ; } VDS host = ( VDS ) getContainer ( ) . getHost ( ) . getSelectedItem ( ) ; storage_server_connections tempVar = new storage_server_connections ( ) ; tempVar . setconnection ( ( ( String ) getAddress ( ) . getEntity ( ) ) . trim ( ) ) ; tempVar . setport ( ( ( String ) getPort ( ) . getEntity ( ) ) . trim ( ) ) ; tempVar . setportal ( "0" ) ; tempVar . setstorage_type ( StorageType . ISCSI ) ; tempVar . setuser_name ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getUserName ( ) . getEntity ( ) : " " ) ; tempVar . setpassword ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getPassword ( ) . getEntity ( ) : " " ) ; DiscoverSendTargetsQueryParameters parameters = new DiscoverSendTargetsQueryParameters ( host . getId ( ) , tempVar ) ; setMessage ( null ) ; getContainer ( ) . StartProgress ( null ) ; Frontend . RunQuery ( VdcQueryType . DiscoverSendTargets , parameters , new AsyncQuery ( this , new INewAsyncCallback ( ) { @ Override public void OnSuccess ( Object target , Object returnValue ) { SanStorageModelBase model = ( SanStorageModelBase ) target ; Object result = ( ( VdcQueryReturnValue ) returnValue ) . getReturnValue ( ) ; model . PostDiscoverTargetsInternal ( result != null ? ( java . util . ArrayList < storage_server_connections > ) result : new java . util . ArrayList < storage_server_connections > ( ) ) ; } } , true ) ) ; }
Dhandapani/gluster-ovirt | private void PostDiscoverTargetsInternal ( java . util . ArrayList < storage_server_connections > items ) { java . util . ArrayList < SanTargetModel > newItems = new java . util . ArrayList < SanTargetModel > ( ) ; for ( storage_server_connections a : items ) { SanTargetModel tempVar = new SanTargetModel ( ) ; tempVar . setAddress ( a . getconnection ( ) ) ; tempVar . setPort ( a . getport ( ) ) ; tempVar . setName ( a . getiqn ( ) ) ; tempVar . setLuns ( new ObservableCollection < LunModel > ( ) ) ; SanTargetModel model = tempVar ; model . getLoggedInEvent ( ) . addListener ( this ) ; newItems . add ( model ) ; } if ( items . isEmpty ( ) ) { setMessage ( " No ▁ new ▁ devices ▁ were ▁ found . ▁ This ▁ may ▁ be ▁ due ▁ to ▁ either : ▁ incorrect ▁ multipath ▁ configuration ▁ on ▁ the ▁ Host ▁ or ▁ wrong ▁ address ▁ of ▁ the ▁ iscsi ▁ target ▁ or ▁ a ▁ failure ▁ to ▁ authenticate ▁ on ▁ the ▁ target ▁ device . ▁ Please ▁ consult ▁ your ▁ Storage ▁ Administrator . " ) ; } PostDiscoverTargets ( newItems ) ; }
Dhandapani/gluster-ovirt | protected void PostDiscoverTargets ( java . util . ArrayList < SanTargetModel > newItems ) { }
Dhandapani/gluster-ovirt | private boolean ValidateDiscoverTargetFields ( ) { getContainer ( ) . getHost ( ) . ValidateSelectedItem ( new NotEmptyValidation [ ] { new NotEmptyValidation ( ) } ) ; getAddress ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) } ) ; IntegerValidation tempVar = new IntegerValidation ( ) ; tempVar . setMinimum ( 0 ) ; tempVar . setMaximum ( 65535 ) ; getPort ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) , tempVar } ) ; if ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ) { getUserName ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) } ) ; getPassword ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) } ) ; } return getContainer ( ) . getHost ( ) . getIsValid ( ) && getAddress ( ) . getIsValid ( ) && getPort ( ) . getIsValid ( ) && getUserName ( ) . getIsValid ( ) && getPassword ( ) . getIsValid ( ) ; }
Dhandapani/gluster-ovirt | @ Override public boolean Validate ( ) { return true ; }
Dhandapani/gluster-ovirt | private void UseUserAuth_EntityChanged ( Object sender , EventArgs args ) { UpdateUserAuthFields ( ) ; }
Dhandapani/gluster-ovirt | private void UpdateUserAuthFields ( ) { getUserName ( ) . setIsValid ( true ) ; getUserName ( ) . setIsChangable ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ) ; getPassword ( ) . setIsValid ( true ) ; getPassword ( ) . setIsChangable ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ) ; }
Dhandapani/gluster-ovirt | @ Override public void ExecuteCommand ( UICommand command ) { super . ExecuteCommand ( command ) ; if ( command == getUpdateCommand ( ) ) { Update ( ) ; } else if ( command == getLoginAllCommand ( ) ) { LoginAll ( ) ; } else if ( command == getDiscoverTargetsCommand ( ) ) { DiscoverTargets ( ) ; } }
Dhandapani/gluster-ovirt | protected void Update ( ) { UpdateInternal ( ) ; setIsValid ( true ) ; }
Dhandapani/gluster-ovirt | protected void UpdateInternal ( ) { }
Dhandapani/gluster-ovirt | protected void UpdateLoginAllAvailability ( ) { java . util . List < SanTargetModel > items = ( java . util . List < SanTargetModel > ) getItems ( ) ; boolean allow = false ; for ( SanTargetModel item : items ) { if ( ! item . getIsLoggedIn ( ) ) { allow = true ; break ; } } getLoginAllCommand ( ) . setIsExecutionAllowed ( allow ) ; }
Dhandapani/gluster-ovirt | protected void IsAllLunsSelectedChanged ( ) { }
keycloak/keycloak-quickstarts | public PropertyFileUserStorageProvider ( KeycloakSession session , ComponentModel model , Properties properties ) { this . session = session ; this . model = model ; this . properties = properties ; }
keycloak/keycloak-quickstarts | @ Override public UserModel getUserByUsername ( String username , RealmModel realm ) { UserModel adapter = loadedUsers . get ( username ) ; if ( adapter == null ) { String password = properties . getProperty ( username ) ; if ( password != null ) { adapter = createAdapter ( realm , username ) ; loadedUsers . put ( username , adapter ) ; } } return adapter ; }
keycloak/keycloak-quickstarts | protected UserModel createAdapter ( RealmModel realm , String username ) { return new AbstractUserAdapter ( session , realm , model ) { @ Override public String getUsername ( ) { return username ; } } ; }
keycloak/keycloak-quickstarts | @ Override public UserModel getUserById ( String id , RealmModel realm ) { StorageId storageId = new StorageId ( id ) ; String username = storageId . getExternalId ( ) ; return getUserByUsername ( username , realm ) ; }
keycloak/keycloak-quickstarts | @ Override public UserModel getUserByEmail ( String email , RealmModel realm ) { return null ; }
keycloak/keycloak-quickstarts | @ Override public boolean isConfiguredFor ( RealmModel realm , UserModel user , String credentialType ) { String password = properties . getProperty ( user . getUsername ( ) ) ; return credentialType . equals ( CredentialModel . PASSWORD ) && password != null ; }
keycloak/keycloak-quickstarts | @ Override public boolean supportsCredentialType ( String credentialType ) { return credentialType . equals ( CredentialModel . PASSWORD ) ; }
keycloak/keycloak-quickstarts | @ Override public boolean isValid ( RealmModel realm , UserModel user , CredentialInput input ) { if ( ! supportsCredentialType ( input . getType ( ) ) || ! ( input instanceof UserCredentialModel ) ) return false ; UserCredentialModel cred = ( UserCredentialModel ) input ; String password = properties . getProperty ( user . getUsername ( ) ) ; if ( password == null ) return false ; return password . equals ( cred . getValue ( ) ) ; }
keycloak/keycloak-quickstarts | @ Override public boolean updateCredential ( RealmModel realm , UserModel user , CredentialInput input ) { if ( input . getType ( ) . equals ( CredentialModel . PASSWORD ) ) throw new ReadOnlyException ( " user ▁ is ▁ read ▁ only ▁ for ▁ this ▁ update " ) ; return false ; }
keycloak/keycloak-quickstarts | @ Override public void disableCredentialType ( RealmModel realm , UserModel user , String credentialType ) { }
keycloak/keycloak-quickstarts | @ Override public Set < String > getDisableableCredentialTypes ( RealmModel realm , UserModel user ) { return Collections . EMPTY_SET ; }
keycloak/keycloak-quickstarts | @ Override public void close ( ) { }
FAU-Inf2/spongycastle | public OCSPResponse ( OCSPResponseStatus responseStatus , ResponseBytes responseBytes ) { this . responseStatus = responseStatus ; this . responseBytes = responseBytes ; }
FAU-Inf2/spongycastle | private OCSPResponse ( ASN1Sequence seq ) { responseStatus = OCSPResponseStatus . getInstance ( seq . getObjectAt ( 0 ) ) ; if ( seq . size ( ) == 2 ) { responseBytes = ResponseBytes . getInstance ( ( ASN1TaggedObject ) seq . getObjectAt ( 1 ) , true ) ; } }
FAU-Inf2/spongycastle | public OCSPResponseStatus getResponseStatus ( ) { return responseStatus ; }
FAU-Inf2/spongycastle | public ResponseBytes getResponseBytes ( ) { return responseBytes ; }
FAU-Inf2/spongycastle | public ASN1Primitive toASN1Primitive ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( responseStatus ) ; if ( responseBytes != null ) { v . add ( new DERTaggedObject ( true , 0 , responseBytes ) ) ; } return new DERSequence ( v ) ; }
JIGAsoftSTP/NICON | public AdministracaoBean ( ) { listaCategorias = rhd . listaCategorias ( ) ; }
JIGAsoftSTP/NICON | @ PostConstruct public void init ( ) { listArticles = this . rhd . listaArtigos ( ) ; funcionarios = this . rhd . employeers ( ) ; categories = this . rhd . categoryNames ( ) ; }
JIGAsoftSTP/NICON | public Artigo getArtigo ( ) { return ( artigo == null ) ? artigo = new Artigo ( ) : artigo ; }
JIGAsoftSTP/NICON | public void setArtigo ( Artigo artigo ) { this . artigo = artigo ; }
JIGAsoftSTP/NICON | public List < ComoBox > getFuncionarios ( ) { return funcionarios ; }
JIGAsoftSTP/NICON | public Artigo getArtigoSelecionado ( ) { return ( artigoSelecionado == null ) ? artigoSelecionado = new Artigo ( ) : artigoSelecionado ; }
JIGAsoftSTP/NICON | public void setArtigoSelecionado ( Artigo artigoSelecionado ) { this . artigoSelecionado = artigoSelecionado ; }
JIGAsoftSTP/NICON | public List < ComoBox > getCategories ( ) { return categories ; }
JIGAsoftSTP/NICON | public List < Artigo > getListArticles ( ) { return listArticles ; }
JIGAsoftSTP/NICON | public void newArticle ( ) { if ( SessionUtil . obterValor ( Funcionario . SESSION_NAME ) != null ) { artigo . setId ( null ) ; if ( Integer . valueOf ( artigo . getQuantidade ( ) ) > 0 ) { String result = this . rhd . registarArtigo ( artigo ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { if ( Integer . valueOf ( artigo . getQuantidade ( ) ) > 0 ) { result = this . rhd . registrarItemArtigo ( artigo , Integer . valueOf ( result . split ( " ; " ) [ 1 ] ) , 1 ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { Message . addInfoMsg ( " Artigo ▁ " + artigo . getNomeArtigo ( ) + " ▁ registrado ▁ com ▁ sucesso ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } else { RequestContext . getCurrentInstance ( ) . execute ( " nomeArtigoExiste ( ) " ) ; Message . addErrorMsg ( result . split ( " ; " ) [ 1 ] , " articleForm " , " articleGrowl " ) ; } } else { Message . addInfoMsg ( " Artigo ▁ " + artigo . getNomeArtigo ( ) + " ▁ registrado ▁ com ▁ sucesso ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } } else { RequestContext . getCurrentInstance ( ) . execute ( " nomeArtigoExiste ( ) " ) ; Message . addErrorMsg ( result . split ( " ; " ) [ 1 ] , " articleForm " , " articleGrowl " ) ; } } else { Message . addWarningMsg ( " Quantidade ▁ de ▁ artigo ▁ deve ▁ ser ▁ superior ▁ a ▁ zero ( 0 ) ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " ▁ $ ( ' . artigoQuantidade ' ) . focus ( ) " ) ; } } }
JIGAsoftSTP/NICON | public void changeQuantity ( String param , Artigo a ) { stock = param ; artigoSelecionado = a ; artigo = artigoSelecionado ; if ( param . equals ( " Retirar ▁ Artigo ▁ do ▁ Stock " ) && Integer . valueOf ( artigoSelecionado . getQuantidade ( ) ) == 0 ) Message . addWarningMsg ( " Nenhuma ▁ quantidade ▁ existente ▁ no ▁ stock ! " , " articleForm " , " articleGrowl " ) ; else if ( param . equals ( " Editar ▁ Artigo ▁ do ▁ Stock " ) ) { artigo . setNomeArtigo ( artigoSelecionado . getConsumivel ( ) ) ; artigo . setCategoria ( artigoSelecionado . getCategoria ( ) ) ; Validacao . atualizar ( " articleForm " , " articleName " , " articleCategory " ) ; RequestContext . getCurrentInstance ( ) . execute ( " articleChangeQuantity ( ' " + param + " ' , ' " + null + " ' ) " ) ; } else { artigo . setNomeArtigo ( artigoSelecionado . getConsumivel ( ) ) ; artigo . setCategoria ( artigoSelecionado . getCategoria ( ) ) ; Validacao . atualizar ( " articleForm " , " articleName " , " articleCategory " ) ; RequestContext . getCurrentInstance ( ) . execute ( " articleChangeQuantity ( ' " + param + " ' , ' " + artigo . getQuantidade ( ) + " ' ) " ) ; } }
JIGAsoftSTP/NICON | public String getId ( String nome ) { for ( ComoBox cb : this . categories ) { if ( cb . getValue ( ) . equals ( nome ) ) { return cb . getId ( ) ; } } return null ; }
JIGAsoftSTP/NICON | public String getIdArtigo ( String nomeArtigo ) { String id = null ; for ( Artigo cb : this . listArticles ) { if ( cb . getConsumivel ( ) . equals ( nomeArtigo ) ) { id = cb . getCodigo ( ) ; break ; } } return id ; }
JIGAsoftSTP/NICON | public void operation ( ) { String type , articleName ; FacesContext facesContext = FacesContext . getCurrentInstance ( ) ; artigo . setNomeArtigo ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " nome " ) ) ; artigo . setCategoria ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " categoria " ) ) ; artigo . setQuantidade ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " quantidade " ) ) ; artigo . setFuncionarioResponsavel ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " funcionario " ) ) ; artigo . setFornecedor ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " fornecedor " ) ) ; artigo . setDescricao ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " obs " ) ) ; artigo . setAdicionarRemover ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " adicionarRemover " ) ) ; artigo . setQuantidadeStock ( Integer . valueOf ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " stockQuantidade " ) ) ) ; articleName = facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " nomeArtigoAtualizar " ) ; type = facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " typeOperation " ) ; switch ( type ) { case " novo " : this . newArticle ( ) ; break ; case " alterar ▁ quantidade " : alterarQuantidade ( ) ; break ; default : alterarNomeCategoriaArtigo ( articleName ) ; break ; } }
JIGAsoftSTP/NICON | public void atualizarTabelaArtigo ( ) { listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; }
JIGAsoftSTP/NICON | private void alterarNomeCategoriaArtigo ( String articleName ) { artigo . setId ( Integer . valueOf ( getIdArtigo ( articleName ) ) ) ; String result = rhd . registarArtigo ( artigo ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { listArticles . clear ( ) ; Message . addInfoMsg ( " Artigo ▁ atualizado ▁ com ▁ sucesso " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } else Message . addErrorMsg ( result . split ( " ; " ) [ 1 ] , " articleForm " , " articleGrowl " ) ; }
JIGAsoftSTP/NICON | public void alterarQuantidade ( ) { if ( SessionUtil . obterValor ( Funcionario . SESSION_NAME ) != null ) { if ( Integer . valueOf ( artigo . getQuantidade ( ) ) > 0 ) { if ( ! artigo . getAdicionarRemover ( ) . equals ( " Adicionar ▁ Artigo ▁ ao ▁ Stock " ) && ( Integer . valueOf ( artigo . getQuantidade ( ) ) > artigo . getQuantidadeStock ( ) ) ) Message . addErrorMsg ( " Quantidade ▁ de ▁ consumível ▁ superior ▁ ao ▁ existente ▁ do ▁ stock ! " , " articleForm " , " articleGrowl " ) ; else { String result = this . rhd . registrarItemArtigo ( artigo , Integer . valueOf ( getIdArtigo ( artigo . getNomeArtigo ( ) ) ) , ( ( artigo . getAdicionarRemover ( ) . equals ( " Adicionar ▁ Artigo ▁ ao ▁ Stock " ) ? 1 : 2 ) ) ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { Message . addInfoMsg ( " Quantidade ▁ do ▁ artigo ▁ " + artigo . getNomeArtigo ( ) + " ▁ alterado ▁ no ▁ stock ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } } } else { RequestContext . getCurrentInstance ( ) . execute ( " artigoQuantidadeBorda ( ) " ) ; Message . addWarningMsg ( " Quantidade ▁ deve ▁ ser ▁ superior ▁ a ▁ zero ( 0 ) ! " , " articleForm " , " articleGrowl " ) ; } } }
JIGAsoftSTP/NICON | public List < String > getListaCategorias ( ) { return listaCategorias ; }
JIGAsoftSTP/NICON | public List < String > completarListaCategoria ( String info ) { System . out . println ( " info ▁ categoria ▁ " + info ) ; listaCategorias . set ( 0 , info ) ; return likeStart ( this . listaCategorias , info ) ; }
eriqadams/computer-graphics | private EXTUnpackSubimage ( ) { }
angcyo/RLibrary | public DefaultDatabaseOpenHelper ( final Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; }
angcyo/RLibrary | @ Override public void onOpen ( SQLiteDatabase db ) { super . onOpen ( db ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) { setWriteAheadLoggingEnabled ( true ) ; } else if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { db . enableWriteAheadLogging ( ) ; } }
angcyo/RLibrary | @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ( ▁ " + FileDownloadModel . ID + " ▁ INTEGER ▁ PRIMARY ▁ KEY , ▁ " + FileDownloadModel . URL + " ▁ VARCHAR , ▁ " + FileDownloadModel . PATH + " ▁ VARCHAR , ▁ " + FileDownloadModel . STATUS + " ▁ TINYINT ( 7 ) , ▁ " + FileDownloadModel . SOFAR + " ▁ INTEGER , ▁ " + FileDownloadModel . TOTAL + " ▁ INTEGER , ▁ " + FileDownloadModel . ERR_MSG + " ▁ VARCHAR , ▁ " + FileDownloadModel . ETAG + " ▁ VARCHAR , ▁ " + FileDownloadModel . PATH_AS_DIRECTORY + " ▁ TINYINT ( 1 ) ▁ DEFAULT ▁ 0 , ▁ " + FileDownloadModel . FILENAME + " ▁ VARCHAR , ▁ " + FileDownloadModel . CONNECTION_COUNT + " ▁ INTEGER ▁ DEFAULT ▁ 1" + " ) " ) ; db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . CONNECTION_TABLE_NAME + " ( ▁ " + ConnectionModel . ID + " ▁ INTEGER , ▁ " + ConnectionModel . INDEX + " ▁ INTEGER , ▁ " + ConnectionModel . START_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . CURRENT_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . END_OFFSET + " ▁ INTEGER , ▁ " + " PRIMARY ▁ KEY ▁ ( ▁ " + ConnectionModel . ID + " , ▁ " + ConnectionModel . INDEX + " ▁ ) " + " ) " ) ; }
angcyo/RLibrary | @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { if ( oldVersion < 2 ) { String addAsDirectoryColumn = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . PATH_AS_DIRECTORY + " ▁ TINYINT ( 1 ) ▁ DEFAULT ▁ 0" ; db . execSQL ( addAsDirectoryColumn ) ; String addFilenameColumn = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . FILENAME + " ▁ VARCHAR " ; db . execSQL ( addFilenameColumn ) ; } if ( oldVersion < 3 ) { final String addConnectionCount = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . CONNECTION_COUNT + " ▁ INTEGER ▁ DEFAULT ▁ 1" ; db . execSQL ( addConnectionCount ) ; db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . CONNECTION_TABLE_NAME + " ( ▁ " + ConnectionModel . ID + " ▁ INTEGER , ▁ " + ConnectionModel . INDEX + " ▁ INTEGER , ▁ " + ConnectionModel . START_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . CURRENT_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . END_OFFSET + " ▁ INTEGER , ▁ " + " PRIMARY ▁ KEY ▁ ( ▁ " + ConnectionModel . ID + " , ▁ " + ConnectionModel . INDEX + " ▁ ) " + " ) " ) ; } }
AlexMinsk/camunda-bpm-platform | ) public void testStart ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; ProcessInstance processInstance ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; }
AlexMinsk/camunda-bpm-platform | protected void verifyVariables ( String caseInstanceId , List < VariableInstance > result ) { for ( VariableInstance variable : result ) { assertEquals ( caseInstanceId , variable . getCaseExecutionId ( ) ) ; assertEquals ( caseInstanceId , variable . getCaseInstanceId ( ) ) ; if ( variable . getName ( ) . equals ( " aVariableName " ) ) { assertEquals ( " aVariableName " , variable . getName ( ) ) ; assertEquals ( " abc " , variable . getValue ( ) ) ; } else if ( variable . getName ( ) . equals ( " anotherVariableName " ) ) { assertEquals ( " anotherVariableName " , variable . getName ( ) ) ; assertEquals ( 999 , variable . getValue ( ) ) ; } else { fail ( " Unexpected ▁ variable : ▁ " + variable . getName ( ) ) ; } } }
AlexMinsk/camunda-bpm-platform | ) public void testManualStart ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . manualStart ( ) ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartWithVariables ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; Map < String , Object > variables = new HashMap < String , Object > ( ) ; variables . put ( " aVariableName " , " abc " ) ; variables . put ( " anotherVariableName " , 999 ) ; caseService . withCaseExecution ( processTaskId ) . setVariables ( variables ) . manualStart ( ) ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; List < VariableInstance > result = runtimeService . createVariableInstanceQuery ( ) . list ( ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 2 , result . size ( ) ) ; verifyVariables ( caseInstanceId , result ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartWithLocalVariable ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . setVariableLocal ( " aVariableName " , " abc " ) . setVariableLocal ( " anotherVariableName " , 999 ) . manualStart ( ) ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; List < VariableInstance > result = runtimeService . createVariableInstanceQuery ( ) . list ( ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 2 , result . size ( ) ) ; for ( VariableInstance variable : result ) { assertEquals ( processTaskId , variable . getCaseExecutionId ( ) ) ; assertEquals ( caseInstanceId , variable . getCaseInstanceId ( ) ) ; if ( variable . getName ( ) . equals ( " aVariableName " ) ) { assertEquals ( " aVariableName " , variable . getName ( ) ) ; assertEquals ( " abc " , variable . getValue ( ) ) ; } else if ( variable . getName ( ) . equals ( " anotherVariableName " ) ) { assertEquals ( " anotherVariableName " , variable . getName ( ) ) ; assertEquals ( 999 , variable . getValue ( ) ) ; } else { fail ( " Unexpected ▁ variable : ▁ " + variable . getName ( ) ) ; } } }
AlexMinsk/camunda-bpm-platform | ) public void testReenableAnEnabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; try { caseService . withCaseExecution ( processTaskId ) . reenable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ re - enable ▁ an ▁ enabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testReenableADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; caseService . withCaseExecution ( processTaskId ) . reenable ( ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isEnabled ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testReenableAnActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . reenable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ re - enable ▁ an ▁ active ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testDisableAnEnabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isDisabled ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testDisableADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; try { caseService . withCaseExecution ( processTaskId ) . disable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ disable ▁ a ▁ already ▁ disabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testDisableAnActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . disable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ disable ▁ an ▁ active ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartOfADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; try { caseService . withCaseExecution ( processTaskId ) . manualStart ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ start ▁ a ▁ disabled ▁ process ▁ task ▁ manually . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartOfAnActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . manualStart ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ start ▁ an ▁ already ▁ active ▁ process ▁ task ▁ manually . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testComplete ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . complete ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ complete ▁ a ▁ process ▁ task , ▁ while ▁ the ▁ process ▁ instance ▁ is ▁ still ▁ running . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testCompleteProcessInstanceShouldCompleteProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; String taskId = queryTask ( ) . getId ( ) ; taskService . complete ( taskId ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; CaseInstance caseInstance = caseService . createCaseInstanceQuery ( ) . singleResult ( ) ; assertNotNull ( caseInstance ) ; assertTrue ( caseInstance . isCompleted ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testDisableShouldCompleteCaseInstance ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; CaseInstance caseInstance = caseService . createCaseInstanceQuery ( ) . completed ( ) . singleResult ( ) ; assertNotNull ( caseInstance ) ; assertTrue ( caseInstance . isCompleted ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testCompleteAnEnabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . complete ( ) ; fail ( " Should ▁ not ▁ be ▁ able ▁ to ▁ complete ▁ an ▁ enabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testCompleteADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; try { caseService . withCaseExecution ( processTaskId ) . complete ( ) ; fail ( " Should ▁ not ▁ be ▁ able ▁ to ▁ complete ▁ a ▁ disabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testClose ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . close ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ close ▁ a ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testTerminate ( ) { createCaseInstance ( DEFINITION_KEY ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; caseService . withCaseExecution ( processTask . getId ( ) ) . terminate ( ) ; processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testTerminateNonFluent ( ) { createCaseInstance ( DEFINITION_KEY ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; caseService . terminateCaseExecution ( processTask . getId ( ) ) ; processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testTerminateNonActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isEnabled ( ) ) ; try { caseService . terminateCaseExecution ( processTask . getId ( ) ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ terminate ▁ a ▁ task . " ) ; } catch ( NotAllowedException e ) { boolean result = e . getMessage ( ) . contains ( " The ▁ case ▁ execution ▁ must ▁ be ▁ in ▁ state ▁ ' active ' ▁ to ▁ terminate " ) ; assertTrue ( result ) ; } }
AlexMinsk/camunda-bpm-platform | protected CaseInstance createCaseInstance ( String caseDefinitionKey ) { return caseService . withCaseDefinitionByKey ( caseDefinitionKey ) . create ( ) ; }
AlexMinsk/camunda-bpm-platform | protected CaseExecution queryCaseExecutionByActivityId ( String activityId ) { return caseService . createCaseExecutionQuery ( ) . activityId ( activityId ) . singleResult ( ) ; }
AlexMinsk/camunda-bpm-platform | protected ProcessInstance queryProcessInstance ( ) { return runtimeService . createProcessInstanceQuery ( ) . singleResult ( ) ; }
AlexMinsk/camunda-bpm-platform | protected Task queryTask ( ) { return taskService . createTaskQuery ( ) . singleResult ( ) ; }
Nexmo/nexmo-java-sdk | public String getDialingPrefix ( ) { return dialingPrefix ; }
Nexmo/nexmo-java-sdk | public BigDecimal getDefaultPrice ( ) { return defaultPrice ; }
Nexmo/nexmo-java-sdk | public String getCurrency ( ) { return currency ; }
Nexmo/nexmo-java-sdk | public Country getCountry ( ) { return country ; }
Nexmo/nexmo-java-sdk | public List < Network > getNetworks ( ) { return networks ; }
griffon/griffon-hibernate4-plugin | @ Override public void handle ( AnnotationValues < Hibernate4Aware > annotation , Annotation source , EclipseNode annotationNode ) { EclipseType type = EclipseType . typeOf ( annotationNode , source ) ; if ( type . isAnnotation ( ) || type . isInterface ( ) ) { annotationNode . addError ( canBeUsedOnClassAndEnumOnly ( Hibernate4Aware . class ) ) ; return ; } EclipseUtil . addInterface ( type . get ( ) , Hibernate4AwareConstants . MYBATIS_CONTRIBUTION_HANDLER_TYPE , source ) ; handler . addHibernate4ProviderField ( type ) ; handler . addHibernate4ProviderAccessors ( type ) ; handler . addHibernate4ContributionMethods ( type ) ; type . editor ( ) . rebuild ( ) ; }
ThinkKeep/EvilsLive | public CameraOld ( Context context ) { this . context = context ; }
ThinkKeep/EvilsLive | Size ( int width , int height ) { this . width = width ; this . height = height ; }
ThinkKeep/EvilsLive | private Camera . PreviewCallback callback = new Camera . PreviewCallback ( ) { @ Override public void onPreviewFrame ( byte [ ] data , Camera camera ) { int width = camera . getParameters ( ) . getPreviewSize ( ) . width ; int height = camera . getParameters ( ) . getPreviewSize ( ) . height ; int index = JniManager . getInstance ( ) . getIndex ( ) ; if ( index >= 0 ) { EvilsLiveJni . sendStream ( index , data , width , height ) ; } if ( listener != null ) { listener . onPreviewFrameListener ( data , width , height ) ; } } }
ThinkKeep/EvilsLive | @ Override public CameraSupport open ( ) { cameraId = getCameraId ( ) ; this . camera = Camera . open ( cameraId ) ; startPreview ( ) ; return this ; }
ThinkKeep/EvilsLive | private int getCameraId ( ) { int cameraId = Defines . EcameraFacing . CAMERA_FACING_FRONT . index ; if ( config != null ) { Defines . EcameraFacing cameraFacing = config . getCameraFacing ( ) ; if ( cameraFacing != null ) { cameraId = cameraFacing . index ; } } return cameraId ; }
ThinkKeep/EvilsLive | @ Override public int startPushStream ( ) { if ( config != null && this . camera != null ) { String streamUrl = config . getStreamUrl ( ) ; if ( streamUrlValid ( streamUrl ) ) { JniManager . getInstance ( ) . startPushStream ( size , streamUrl . getBytes ( ) , 15 , 512 ) ; camera . setPreviewCallback ( callback ) ; isStartStream = true ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( isStartStream ) { int index = JniManager . getInstance ( ) . getIndex ( ) ; try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } JniManager . getInstance ( ) . setStreamConfig ( index , size . width , size . height , 15 , 512 , true ) ; } } } ) . start ( ) ; } } return 0 ; }
ThinkKeep/EvilsLive | private boolean streamUrlValid ( String streamUrl ) { return streamUrl != null && ! ( " " . equals ( streamUrl ) ) ; }
ThinkKeep/EvilsLive | @ Override public int getOrientation ( final int cameraId ) { Camera . CameraInfo info = new Camera . CameraInfo ( ) ; Camera . getCameraInfo ( cameraId , info ) ; return info . orientation ; }
ThinkKeep/EvilsLive | @ Override public void setDisplayPreview ( SurfaceView surfaceView ) { this . surfaceView = surfaceView ; }
ThinkKeep/EvilsLive | private void startPreview ( ) { try { Camera . Parameters parameters = setParameters ( ) ; camera . setParameters ( parameters ) ; if ( surfaceView != null ) { final Camera . Size previewSize = parameters . getPreviewSize ( ) ; runMainHanlder ( previewSize ) ; SurfaceHolder surfaceHolder = surfaceView . getHolder ( ) ; camera . setPreviewDisplay ( surfaceHolder ) ; } camera . startPreview ( ) ; } catch ( Exception e ) { Log . e ( TAG , " startPreview : ▁ error " + Log . getStackTraceString ( e ) ) ; } }
ThinkKeep/EvilsLive | private void runMainHanlder ( final Camera . Size previewSize ) { Handler mainHanlder = new Handler ( Looper . getMainLooper ( ) ) ; mainHanlder . post ( new Runnable ( ) { @ Override public void run ( ) { adjustViewSize ( previewSize ) ; } } ) ; }
ThinkKeep/EvilsLive | private void adjustViewSize ( Camera . Size cameraSize ) { Point previewSize = convertSizeToLandscapeOrientation ( new Point ( surfaceView . getWidth ( ) , surfaceView . getHeight ( ) ) ) ; float cameraRatio = ( ( float ) cameraSize . width ) / cameraSize . height ; float screenRatio = ( ( float ) previewSize . x ) / previewSize . y ; if ( screenRatio > cameraRatio ) { setViewSize ( ( int ) ( previewSize . y * cameraRatio ) , previewSize . y ) ; } else { setViewSize ( previewSize . x , ( int ) ( previewSize . x / cameraRatio ) ) ; } }
ThinkKeep/EvilsLive | private Point convertSizeToLandscapeOrientation ( Point size ) { if ( getDisplayOrientation ( ) % 180 == 0 ) { return size ; } else { return new Point ( size . y , size . x ) ; } }
ThinkKeep/EvilsLive | private void setViewSize ( int width , int height ) { ViewGroup . LayoutParams layoutParams = surfaceView . getLayoutParams ( ) ; int tmpWidth ; int tmpHeight ; if ( getDisplayOrientation ( ) % 180 == 0 ) { tmpWidth = width ; tmpHeight = height ; } else { tmpWidth = height ; tmpHeight = width ; } if ( mShouldScaleToFill ) { int parentWidth = ( ( View ) surfaceView . getParent ( ) ) . getWidth ( ) ; int parentHeight = ( ( View ) surfaceView . getParent ( ) ) . getHeight ( ) ; float ratioWidth = ( float ) parentWidth / ( float ) tmpWidth ; float ratioHeight = ( float ) parentHeight / ( float ) tmpHeight ; float compensation ; if ( ratioWidth > ratioHeight ) { compensation = ratioWidth ; } else { compensation = ratioHeight ; } tmpWidth = Math . round ( tmpWidth * compensation ) ; tmpHeight = Math . round ( tmpHeight * compensation ) ; } layoutParams . width = tmpWidth ; layoutParams . height = tmpHeight ; surfaceView . setLayoutParams ( layoutParams ) ; }
ThinkKeep/EvilsLive | public int getDisplayOrientation ( ) { if ( camera == null ) { return 0 ; } Camera . CameraInfo info = new Camera . CameraInfo ( ) ; if ( cameraId == - 1 ) { Camera . getCameraInfo ( Camera . CameraInfo . CAMERA_FACING_BACK , info ) ; } else { Camera . getCameraInfo ( cameraId , info ) ; } WindowManager wm = ( WindowManager ) context . getSystemService ( Context . WINDOW_SERVICE ) ; Display display = wm . getDefaultDisplay ( ) ; int rotation = display . getRotation ( ) ; int degrees = 0 ; switch ( rotation ) { case Surface . ROTATION_0 : degrees = 0 ; break ; case Surface . ROTATION_90 : degrees = 90 ; break ; case Surface . ROTATION_180 : degrees = 180 ; break ; case Surface . ROTATION_270 : degrees = 270 ; break ; } int result ; if ( info . facing == Camera . CameraInfo . CAMERA_FACING_FRONT ) { result = ( info . orientation + degrees ) % 360 ; result = ( 360 - result ) % 360 ; } else { result = ( info . orientation - degrees + 360 ) % 360 ; } return result ; }
ThinkKeep/EvilsLive | @ NonNull private Camera . Parameters setParameters ( ) { Camera . Parameters parameters = camera . getParameters ( ) ; size = choosePreviewSize ( parameters ) ; setPreviewFrameRate ( parameters ) ; camera . setDisplayOrientation ( 90 ) ; parameters . setRotation ( 90 ) ; parameters . setPreviewSize ( size . width , size . height ) ; int imageFormat = chooseImageFormat ( parameters ) ; parameters . setPreviewFormat ( imageFormat ) ; return parameters ; }
ThinkKeep/EvilsLive | private void setPreviewFrameRate ( Camera . Parameters parameters ) { int frameRate = Defines . DEFAULT_FRAME_RATE ; if ( config != null ) { int previewFrameRate = config . getPreviewFrameRate ( ) ; if ( previewFrameRate >= 0 ) { frameRate = previewFrameRate ; } } parameters . setPreviewFpsRange ( 25 * 1000 , 25 * 1000 ) ; }
ThinkKeep/EvilsLive | private int chooseImageFormat ( Camera . Parameters parameters ) { if ( config == null ) { return DEFAULT_IMAGE_FORMAT ; } List < Integer > list = parameters . getSupportedPreviewFormats ( ) ; for ( Integer val : list ) { LogUtils . e ( TAG , " hujd ▁ startPreview : ▁ val : ▁ " + val ) ; if ( val == config . getImageFormat ( ) ) { return val ; } } return DEFAULT_IMAGE_FORMAT ; }
ThinkKeep/EvilsLive | private Size choosePreviewSize ( Camera . Parameters parameters ) { Size size = null ; if ( config == null ) { return new Size ( Defines . EvideoResolution . E640P . getWidth ( ) , Defines . EvideoResolution . E640P . getHeight ( ) ) ; } Defines . EvideoResolution videoResolution = config . getVideoResolution ( ) ; if ( videoResolution != null ) { int width = videoResolution . getWidth ( ) ; int height = videoResolution . getHeight ( ) ; List < Camera . Size > sizeList = parameters . getSupportedPreviewSizes ( ) ; Camera . Size optimalSize = getOptimalSize ( sizeList , Math . max ( width , height ) , Math . min ( width , height ) ) ; size = new Size ( optimalSize . width , optimalSize . height ) ; } if ( size == null ) { size = new Size ( Defines . EvideoResolution . E640P . getWidth ( ) , Defines . EvideoResolution . E640P . getHeight ( ) ) ; } return size ; }
ThinkKeep/EvilsLive | private Camera . Size getOptimalSize ( @ NonNull List < Camera . Size > sizes , int width , int height ) { final double ASPECT_TOLERANCE = 0.1 ; assert ( width == 0 ) ; double targetRatio = ( double ) height / width ; Camera . Size optimalSize = null ; double minDiff = Double . MIN_VALUE ; int targetHeight = height ; for ( Camera . Size size : sizes ) { double ratio = ( double ) size . height / size . width ; if ( Math . abs ( ratio - targetRatio ) > ASPECT_TOLERANCE ) { continue ; } if ( Math . abs ( size . height - targetHeight ) < minDiff ) { optimalSize = size ; minDiff = Math . abs ( size . height - targetHeight ) ; } } if ( optimalSize == null ) { minDiff = Double . MIN_VALUE ; for ( Camera . Size size : sizes ) { if ( Math . abs ( size . height - targetHeight ) < minDiff ) { optimalSize = size ; minDiff = Math . abs ( size . height - targetHeight ) ; } } } return optimalSize ; }
ThinkKeep/EvilsLive | @ Override public void setOnPreviewFrameListener ( OnPreviewFrameListener listener ) { this . listener = listener ; }
ThinkKeep/EvilsLive | @ Override public void setStreamConfig ( EvilsLiveStreamerConfig config ) { this . config = config ; }
ThinkKeep/EvilsLive | @ Override public void stopPushStream ( ) { isStartStream = false ; if ( camera == null ) { return ; } int index = JniManager . getInstance ( ) . getIndex ( ) ; if ( index >= 0 ) { JniManager . getInstance ( ) . stopPushStream ( index ) ; } camera . setPreviewCallback ( null ) ; }
ThinkKeep/EvilsLive | @ Override public void close ( ) { if ( camera == null ) { return ; } camera . stopPreview ( ) ; camera . release ( ) ; camera = null ; }
wwz-zackjo/testgit | " , method = RequestMethod . GET ) public String detailBoard ( ModelMap modelMap , @ PathVariable ( " contentId " ) int contentId , @ RequestParam ( required = true , value = " pageNum " , defaultValue = "1" ) int pageNum ) { Board board = boardService . findContentWithComment ( contentId ) ; boolean isExist = true ; if ( board == null ) { isExist = false ; } else { boardService . modifyContentHit ( contentId ) ; board . setHit ( board . getHit ( ) + 1 ) ; } return " / boardDetail " ; }
mpmunasinghe/product-ei | @ BeforeClass ( alwaysRun = true ) public void setEnvironment ( ) throws Exception { init ( TestUserMode . SUPER_TENANT_ADMIN ) ; serverManager = new ServerConfigurationManager ( context ) ; serverManager . copyToComponentDropins ( new File ( getClass ( ) . getResource ( JRUBY_JAR_LOCATION + JRUBY_JAR ) . toURI ( ) ) ) ; Thread . sleep ( 3000 ) ; serverManager . restartGracefully ( ) ; init ( TestUserMode . SUPER_TENANT_ADMIN ) ; }
mpmunasinghe/product-ei | , description = " Script ▁ Mediator ▁ - Run ▁ a ▁ Ruby ▁ script ▁ with ▁ the ▁ mediator " ) public void testJRubyScriptMediation ( ) throws Exception { loadSampleESBConfiguration ( 353 ) ; OMElement response = axis2Client . sendCustomQuoteRequest ( getMainSequenceURL ( ) , null , " WSO2" ) ; assertNotNull ( response , " Fault ▁ response ▁ message ▁ null " ) ; assertNotNull ( response . getQName ( ) . getLocalPart ( ) , " Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getQName ( ) . getLocalPart ( ) , " CheckPriceResponse " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " ▁ Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " Code " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstChildWithName ( new QName ( " http : // services . samples / xsd " , " Price " ) ) , " Fault ▁ response ▁ null ▁ localpart " ) ; }
mpmunasinghe/product-ei | , description = " Script ▁ Mediator ▁ - Run ▁ a ▁ Ruby ▁ script ▁ with ▁ the ▁ mediator " + " ▁ - Script ▁ from ▁ gov ▁ registry " ) public void testJRubyScriptMediationScriptFromGovRegistry ( ) throws Exception { Thread . sleep ( 5000 ) ; updateESBRegistry ( File . separator + " artifacts " + File . separator + " ESB " + File . separator + " synapseconfig " + File . separator + " WSO2Registry . xml " ) ; enableDebugLogging ( ) ; uploadResourcesToConfigRegistry ( ) ; Thread . sleep ( 3000 ) ; loadESBConfigurationFromClasspath ( " / artifacts / ESB / synapseconfig / script _ mediator / retrieve _ script _ from _ gov _ reg _ mediation . xml " ) ; OMElement response = axis2Client . sendCustomQuoteRequest ( getMainSequenceURL ( ) , null , " WSO2" ) ; assertNotNull ( response , " Fault ▁ response ▁ message ▁ null " ) ; assertNotNull ( response . getQName ( ) . getLocalPart ( ) , " Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getQName ( ) . getLocalPart ( ) , " CheckPriceResponse " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " ▁ Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " Code " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstChildWithName ( new QName ( " http : // services . samples / xsd " , " Price " ) ) , " Fault ▁ response ▁ null ▁ localpart " ) ; clearUploadedResource ( ) ; }
mpmunasinghe/product-ei | @ AfterClass ( alwaysRun = true ) public void destroy ( ) throws Exception { try { deleteSequence ( " main " ) ; cleanup ( ) ; Thread . sleep ( 5000 ) ; } finally { serverManager . restartGracefully ( ) ; Thread . sleep ( 3000 ) ; serverManager . removeFromComponentDropins ( JRUBY_JAR ) ; serverManager = null ; } }
mpmunasinghe/product-ei | private void uploadResourcesToConfigRegistry ( ) throws Exception { ResourceAdminServiceClient resourceAdminServiceStub = new ResourceAdminServiceClient ( contextUrls . getBackEndUrl ( ) , context . getContextTenant ( ) . getContextUser ( ) . getUserName ( ) , context . getContextTenant ( ) . getContextUser ( ) . getPassword ( ) ) ; resourceAdminServiceStub . deleteResource ( " / _ system / governance / script " ) ; resourceAdminServiceStub . addCollection ( " / _ system / governance / " , " script " , " " , " Contains ▁ test ▁ script ▁ files " ) ; resourceAdminServiceStub . addResource ( " / _ system / governance / script / stockquoteTransform . rb " , " application / xml " , " script ▁ files " , new DataHandler ( new URL ( " file : // / " + getClass ( ) . getResource ( " / artifacts / ESB / mediatorconfig / script / stockquoteTransform . rb " ) . getPath ( ) ) ) ) ; }
mpmunasinghe/product-ei | private void enableDebugLogging ( ) throws Exception { LoggingAdminClient logAdminClient = new LoggingAdminClient ( contextUrls . getBackEndUrl ( ) , getSessionCookie ( ) ) ; logAdminClient . updateLoggerData ( " org . apache . synapse " , " DEBUG " , true , false ) ; }
luoqii/ApkLauncher_legacy | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . chronometer ) ; Button button ; mChronometer = ( Chronometer ) findViewById ( R . id . chronometer ) ; button = ( Button ) findViewById ( R . id . start ) ; button . setOnClickListener ( mStartListener ) ; button = ( Button ) findViewById ( R . id . stop ) ; button . setOnClickListener ( mStopListener ) ; button = ( Button ) findViewById ( R . id . reset ) ; button . setOnClickListener ( mResetListener ) ; button = ( Button ) findViewById ( R . id . set_format ) ; button . setOnClickListener ( mSetFormatListener ) ; button = ( Button ) findViewById ( R . id . clear_format ) ; button . setOnClickListener ( mClearFormatListener ) ; }
luoqii/ApkLauncher_legacy | View . OnClickListener mStartListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . start ( ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mStopListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . stop ( ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mResetListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . setBase ( SystemClock . elapsedRealtime ( ) ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mSetFormatListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . setFormat ( " Formatted ▁ time ▁ ( % s ) " ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mClearFormatListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . setFormat ( null ) ; } }
cdeange/WKRPTapp | public VolleyLibrary ( final Context context ) { mContext = context ; mController = new OperationController ( context ) ; mQueue = Volley . newRequestQueue ( mContext ) ; mQueue . start ( ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . Get get ( final String url , final OperationParams . Get params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; mQueue . add ( new StringRequest ( Request . Method . GET , url , future , future ) ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . Get ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . Post post ( final String url , final OperationParams . Post params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; mQueue . add ( new PostFileRequest ( url , future , future , mContext . getResources ( ) . openRawResource ( params . rawResourceId ) ) ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . Post ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . MultipartPost postMultipart ( final String url , final OperationParams . Multipart params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; final MultipartRequest request = new MultipartRequest ( url , future , future ) ; request . addStringPart ( params . formField . first , params . formField . second ) ; request . addFilePart ( params . fileName , mContext . getResources ( ) . openRawResource ( params . rawResourceId ) ) ; mQueue . add ( request ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . MultipartPost ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . ImageGet loadImage ( final String url , final OperationParams . Image params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < Bitmap > future = RequestFuture . newFuture ( ) ; mQueue . add ( new ImageRequest ( url , future , 0 , 0 , Bitmap . Config . ARGB_8888 , future ) ) ; final Bitmap response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . ImageGet ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats batchGet ( final String ... urls ) throws IOException { mController . reset ( ) ; mController . start ( ) ; mCountdown = new Countdown ( ) ; for ( final String url : urls ) { final CountdownListener < String > listener = new CountdownListener < String > ( mCountdown ) ; mQueue . add ( new StringRequest ( Request . Method . GET , url , listener , listener ) ) ; mCountdown . await ( ) ; } mCountdown . blockUntilDone ( ) ; mController . stop ( ) ; return new ResponseStats ( mController ) ; }
7a6/medium | @ Bean public DataSource dataSource ( ) throws PropertyVetoException { ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource ( ) ; comboPooledDataSource . setDriverClass ( " com . mysql . jdbc . Driver " ) ; comboPooledDataSource . setJdbcUrl ( " jdbc : mysql : // localhost / test " ) ; comboPooledDataSource . setUser ( " dbuser " ) ; comboPooledDataSource . setPassword ( " password " ) ; return null ; }
eschwert/ontop | public void generateTriples ( ) throws Exception { OBDADataFactory fac = OBDADataFactoryImpl . getInstance ( ) ; OBDAModel obdaModel = fac . getOBDAModel ( ) ; ModelIOManager ioManager = new ModelIOManager ( obdaModel ) ; ioManager . load ( inputFile ) ; try ( OWLAPIMaterializer materializer = new OWLAPIMaterializer ( obdaModel , false ) ) { long numberOfTriples = materializer . getTriplesCount ( ) ; System . out . println ( " Generated ▁ triples : ▁ " + numberOfTriples ) ; QuestOWLIndividualAxiomIterator triplesIter = materializer . getIterator ( ) ; File fout = new File ( outputFile ) ; if ( fout . exists ( ) ) { fout . delete ( ) ; } try ( PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( fout , true ) ) ) ) { while ( triplesIter . hasNext ( ) ) { OWLIndividualAxiom individual = triplesIter . next ( ) ; out . println ( individual . toString ( ) ) ; } out . flush ( ) ; } } }
jjculber/defcoinj | public TestNet3Params ( ) { super ( ) ; id = ID_TESTNET ; packetMagic = 0xfcc1b7dc ; interval = INTERVAL ; targetTimespan = TARGET_TIMESPAN ; proofOfWorkLimit = Utils . decodeCompactBits ( 0x1e0ffff0L ) ; port = 44556 ; addressHeader = 113 ; p2shHeader = 196 ; acceptableAddressCodes = new int [ ] { addressHeader , p2shHeader } ; dumpedPrivateKeyHeader = 241 ; genesisBlock . setTime ( 1391503289L ) ; genesisBlock . setDifficultyTarget ( 0x1e0ffff0L ) ; genesisBlock . setNonce ( 997879 ) ; spendableCoinbaseDepth = 30 ; subsidyDecreaseBlockCount = 100000 ; String genesisHash = genesisBlock . getHashAsString ( ) ; checkState ( genesisHash . equals ( " bb0a78264637406b6360aad926284d544d7049f45189db5664f3c4d07350559e " ) ) ; alertSigningKey = Hex . decode ( "042756726da3c7ef515d89212ee1705023d14be389e25fe15611585661b9a20021908b2b80a3c7200a0139dd2b26946606aab0eef9aa7689a6dc2c7eee237fa834" ) ; diffChangeTarget = 50 ; dnsSeeds = new String [ ] { } ; }
jjculber/defcoinj | public String getPaymentProtocolId ( ) { return PAYMENT_PROTOCOL_ID_TESTNET ; }
kiall/ExoPlayer | @ Test public void testParcelable ( ) { DrmInitData . SchemeData drmData1 = new DrmInitData . SchemeData ( WIDEVINE_UUID , VIDEO_MP4 , TestUtil . buildTestData ( 128 , 1 ) ) ; DrmInitData . SchemeData drmData2 = new DrmInitData . SchemeData ( C . UUID_NIL , VIDEO_WEBM , TestUtil . buildTestData ( 128 , 1 ) ) ; DrmInitData drmInitData = new DrmInitData ( drmData1 , drmData2 ) ; byte [ ] projectionData = new byte [ ] { 1 , 2 , 3 } ; Metadata metadata = new Metadata ( new TextInformationFrame ( " id1" , " description1" , " value1" ) , new TextInformationFrame ( " id2" , " description2" , " value2" ) ) ; ColorInfo colorInfo = new ColorInfo ( C . COLOR_SPACE_BT709 , C . COLOR_RANGE_LIMITED , C . COLOR_TRANSFER_SDR , new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ) ; Format formatToParcel = new Format ( " id " , MimeTypes . VIDEO_MP4 , MimeTypes . VIDEO_H264 , null , 1024 , 2048 , 1920 , 1080 , 24 , 90 , 2 , projectionData , C . STEREO_MODE_TOP_BOTTOM , colorInfo , 6 , 44100 , C . ENCODING_PCM_24BIT , 1001 , 1002 , 0 , " und " , Format . NO_VALUE , Format . OFFSET_SAMPLE_RELATIVE , INIT_DATA , drmInitData , metadata ) ; Parcel parcel = Parcel . obtain ( ) ; formatToParcel . writeToParcel ( parcel , 0 ) ; parcel . setDataPosition ( 0 ) ; Format formatFromParcel = Format . CREATOR . createFromParcel ( parcel ) ; assertThat ( formatFromParcel ) . isEqualTo ( formatToParcel ) ; parcel . recycle ( ) ; }
kiall/ExoPlayer | @ Test public void testConversionToFrameworkMediaFormat ( ) { if ( Util . SDK_INT < 16 ) { return ; } testConversionToFrameworkMediaFormatV16 ( Format . createVideoSampleFormat ( null , " video / xyz " , null , 5000 , 102400 , 1280 , 720 , 30 , INIT_DATA , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createVideoSampleFormat ( null , " video / xyz " , null , 5000 , Format . NO_VALUE , 1280 , 720 , 30 , null , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createAudioSampleFormat ( null , " audio / xyz " , null , 500 , 128 , 5 , 44100 , INIT_DATA , null , 0 , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createAudioSampleFormat ( null , " audio / xyz " , null , 500 , Format . NO_VALUE , 5 , 44100 , null , null , 0 , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createTextSampleFormat ( null , " text / xyz " , 0 , " eng " ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createTextSampleFormat ( null , " text / xyz " , 0 , null ) ) ; }
windbender/wildlife-camera-machine | public LatLonPair ( Double lat , Double lon ) { super ( ) ; this . lat = lat ; this . lon = lon ; }
windbender/wildlife-camera-machine | public Double getLat ( ) { return lat ; }
windbender/wildlife-camera-machine | public Double getLon ( ) { return lon ; }
windbender/wildlife-camera-machine | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( lat == null ) ? 0 : lat . hashCode ( ) ) ; result = prime * result + ( ( lon == null ) ? 0 : lon . hashCode ( ) ) ; return result ; }
windbender/wildlife-camera-machine | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; LatLonPair other = ( LatLonPair ) obj ; if ( lat == null ) { if ( other . lat != null ) return false ; } else if ( ! lat . equals ( other . lat ) ) return false ; if ( lon == null ) { if ( other . lon != null ) return false ; } else if ( ! lon . equals ( other . lon ) ) return false ; return true ; }
windbender/wildlife-camera-machine | @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " LatLonPair ▁ [ lat = " ) ; builder . append ( lat ) ; builder . append ( " , ▁ lon = " ) ; builder . append ( lon ) ; builder . append ( " ] " ) ; return builder . toString ( ) ; }
jk1/intellij-community | @ Override public void actionPerformed ( final AnActionEvent e ) { final Project project = e . getProject ( ) ; final Editor editor = e . getData ( CommonDataKeys . EDITOR ) ; if ( Boolean . TRUE . equals ( e . getData ( PlatformDataKeys . IS_MODAL_CONTEXT ) ) ) { return ; } if ( project != null && editor != null ) { if ( DumbService . getInstance ( project ) . isDumb ( ) ) { DumbService . getInstance ( project ) . showDumbModeNotification ( IdeBundle . message ( " goto . custom . region . message . dumb . mode " ) ) ; return ; } CommandProcessor processor = CommandProcessor . getInstance ( ) ; processor . executeCommand ( project , ( ) -> { Collection < FoldingDescriptor > foldingDescriptors = getCustomFoldingDescriptors ( editor , project ) ; if ( foldingDescriptors . size ( ) > 0 ) { CustomFoldingRegionsPopup . show ( foldingDescriptors , editor , project ) ; } else { notifyCustomRegionsUnavailable ( editor , project ) ; } } , IdeBundle . message ( " goto . custom . region . command " ) , null ) ; } }
jk1/intellij-community | @ Override public void update ( AnActionEvent e ) { Presentation presentation = e . getPresentation ( ) ; presentation . setText ( IdeBundle . message ( " goto . custom . region . menu . item " ) ) ; final Editor editor = e . getData ( CommonDataKeys . EDITOR ) ; final Project project = e . getProject ( ) ; boolean isAvailable = editor != null && project != null ; presentation . setEnabled ( isAvailable ) ; presentation . setVisible ( isAvailable ) ; }
dremio/dremio-oss | public ExcelFormatPlugin ( String name , SabotContext context , ExcelFormatPluginConfig formatConfig , FileSystemPlugin fsPlugin ) { super ( name , context , formatConfig , true , false , false , false , formatConfig . getExtensions ( ) , NAME , fsPlugin ) ; maxExcelFileSize = context . getOptionManager ( ) . getOption ( ExecConstants . EXCEL_MAX_FILE_SIZE_VALIDATOR ) ; }
dremio/dremio-oss | @ Override public boolean supportsPushDown ( ) { return false ; }
dremio/dremio-oss | @ Override public RecordReader getRecordReader ( OperatorContext context , FileSystem dfs , EasyDatasetSplitXAttr splitAttributes , List < SchemaPath > columns ) throws ExecutionSetupException { final Path path = dfs . makeQualified ( Path . of ( splitAttributes . getPath ( ) ) ) ; checkExcelFileSize ( path , dfs ) ; final ExcelFormatPluginConfig excelFormatConfig = ( ExcelFormatPluginConfig ) formatConfig ; return new ExcelRecordReader ( context , dfs , path , excelFormatConfig , columns ) ; }
dremio/dremio-oss | @ Override public RecordReader getRecordReader ( OperatorContext context , FileSystem dfs , EasyDatasetSplitXAttr splitAttributes , List < SchemaPath > columns , EasySubScan config ) throws ExecutionSetupException { RecordReader inner = getRecordReader ( context , dfs , splitAttributes , columns ) ; return new EasyCoercionReader ( context , columns , inner , config . getFullSchema ( ) , Iterables . getFirst ( config . getReferencedTables ( ) , null ) ) ; }
dremio/dremio-oss | private void checkExcelFileSize ( final Path path , final FileSystem dfs ) { try { long excelFileSize = dfs . getFileAttributes ( path ) . size ( ) ; if ( excelFileSize > maxExcelFileSize ) { final String errorMessage = String . format ( " File ▁ % s ▁ exceeds ▁ maximum ▁ size ▁ limit ▁ for ▁ Excel ▁ files ▁ of ▁ % d ▁ bytes " , path , maxExcelFileSize ) ; throw UserException . unsupportedError ( ) . message ( errorMessage ) . build ( logger ) ; } } catch ( IOException e ) { logger . error ( " Error ▁ occurred ▁ while ▁ fetching ▁ file ▁ attributes ▁ for ▁ " + path ) ; } }
dremio/dremio-oss | @ Override public int getReaderOperatorType ( ) { return CoreOperatorType . EXCEL_SUB_SCAN_VALUE ; }
dremio/dremio-oss | @ Override public RecordWriter getRecordWriter ( OperatorContext context , EasyWriter writer ) throws IOException { throw UserException . unsupportedError ( ) . message ( " Writing ▁ output ▁ in ▁ Excel ▁ format ▁ is ▁ not ▁ supported " ) . build ( logger ) ; }
dremio/dremio-oss | @ Override public int getWriterOperatorType ( ) { throw UserException . unsupportedError ( ) . message ( " Writing ▁ output ▁ in ▁ Excel ▁ format ▁ is ▁ not ▁ supported " ) . build ( logger ) ; }
frodoking/GradleAndroid-App | public MySimpleAdapter ( Context context , int layoutRes ) { super ( context , layoutRes , android . R . id . text1 ) ; }
frodoking/GradleAndroid-App | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . sample_act ) ; mAdapterView = ( MultiColumnListView ) findViewById ( R . id . list ) ; { for ( int i = 0 ; i < 3 ; ++ i ) { TextView tv = new TextView ( this ) ; tv . setLayoutParams ( new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ) ; tv . setText ( " Hello ▁ Header ! ! ▁ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . " ) ; mAdapterView . addHeaderView ( tv ) ; } } { for ( int i = 0 ; i < 3 ; ++ i ) { TextView tv = new TextView ( this ) ; tv . setLayoutParams ( new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ) ; tv . setText ( " Hello ▁ Footer ! ! ▁ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . " ) ; mAdapterView . addFooterView ( tv ) ; } } }
frodoking/GradleAndroid-App | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { menu . add ( Menu . NONE , 1001 , 0 , " Load ▁ More ▁ Contents " ) ; menu . add ( Menu . NONE , 1002 , 0 , " Launch ▁ Pull - To - Refresh ▁ Activity " ) ; return super . onCreateOptionsMenu ( menu ) ; }
frodoking/GradleAndroid-App | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case 1001 : { int startCount = mAdapter . getCount ( ) ; for ( int i = 0 ; i < 100 ; ++ i ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Hello ! ! [ " ) ; builder . append ( startCount + i ) ; builder . append ( " ] ▁ " ) ; char [ ] chars = new char [ mRand . nextInt ( 100 ) ] ; Arrays . fill ( chars , '1' ) ; builder . append ( chars ) ; mAdapter . add ( builder . toString ( ) ) ; } } break ; case 1002 : { Intent intent = new Intent ( this , PullToRefreshSampleActivity . class ) ; startActivity ( intent ) ; } break ; } return true ; }
frodoking/GradleAndroid-App | @ Override protected void onResume ( ) { super . onResume ( ) ; initAdapter ( ) ; mAdapterView . setAdapter ( mAdapter ) ; }
frodoking/GradleAndroid-App | private void initAdapter ( ) { mAdapter = new MySimpleAdapter ( this , R . layout . sample_item ) ; for ( int i = 0 ; i < 30 ; ++ i ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Hello ! ! [ " ) ; builder . append ( i ) ; builder . append ( " ] ▁ " ) ; char [ ] chars = new char [ mRand . nextInt ( 500 ) ] ; Arrays . fill ( chars , '1' ) ; builder . append ( chars ) ; mAdapter . add ( builder . toString ( ) ) ; } }
awhitford/DependencyCheck | @ Test public void testSanitizer ( ) { JsonObjectBuilder builder = Json . createObjectBuilder ( ) . add ( " name " , " my ▁ app " ) . add ( " version " , "1.0.0" ) . add ( " random " , " random " ) . add ( " lockfileVersion " , 1 ) . add ( " requires " , true ) . add ( " dependencies " , Json . createObjectBuilder ( ) . add ( " abbrev " , Json . createObjectBuilder ( ) . add ( " version " , "1.1.1" ) . add ( " resolved " , " https : // registry . npmjs . org / abbrev / - / abbrev - 1.1.1 . tgz " ) . add ( " integrity " , " sha512 - nne9 / IiQ / hzIhY6pdDnbBtz7DjPTKrY00P / zvPSm5pOFkl6xuGrGnXn / VtTNNfNtAfZ9/1RtehkszU9qcTii0Q = = " ) . add ( " dev " , true ) ) ) ; JsonObject packageJson = builder . build ( ) ; JsonObject sanitized = SanitizePackage . sanitize ( packageJson ) ; Assert . assertTrue ( sanitized . containsKey ( " name " ) ) ; Assert . assertTrue ( sanitized . containsKey ( " version " ) ) ; Assert . assertTrue ( sanitized . containsKey ( " dependencies " ) ) ; Assert . assertTrue ( sanitized . containsKey ( " requires " ) ) ; JsonObject requires = sanitized . getJsonObject ( " requires " ) ; Assert . assertTrue ( requires . containsKey ( " abbrev " ) ) ; Assert . assertEquals ( "1.1.1" , requires . getString ( " abbrev " ) ) ; Assert . assertFalse ( sanitized . containsKey ( " lockfileVersion " ) ) ; Assert . assertFalse ( sanitized . containsKey ( " random " ) ) ; }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void outputOfLSVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; File outputFile = new File ( ROOT , " / basicCheckOutput " ) ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; oiv . go ( ) ; HashMap < String , LsElements > fileOutput = readLsfile ( outputFile ) ; compareNamespaces ( writtenFiles , fileOutput ) ; } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } LOG . debug ( " Correctly ▁ generated ▁ ls - style ▁ output . " ) ; }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void unsupportedFSLayoutVersion ( ) throws IOException { File testFile = new File ( ROOT , " / invalidLayoutVersion " ) ; File outputFile = new File ( ROOT , " invalidLayoutVersionOutput " ) ; try { int badVersionNum = - 432 ; changeLayoutVersion ( originalFsimage , testFile , badVersionNum ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; try { oiv . go ( ) ; fail ( " Shouldn ' t ▁ be ▁ able ▁ to ▁ read ▁ invalid ▁ laytout ▁ version " ) ; } catch ( IOException e ) { if ( ! e . getMessage ( ) . contains ( Integer . toString ( badVersionNum ) ) ) throw e ; LOG . debug ( " Correctly ▁ failed ▁ at ▁ reading ▁ bad ▁ image ▁ version . " ) ; } } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void truncatedFSImage ( ) throws IOException { File testFile = new File ( ROOT , " / truncatedFSImage " ) ; File outputFile = new File ( ROOT , " / trucnatedFSImageOutput " ) ; try { copyPartOfFile ( originalFsimage , testFile ) ; assertTrue ( " Created ▁ truncated ▁ fsimage " , testFile . exists ( ) ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; try { oiv . go ( ) ; fail ( " Managed ▁ to ▁ process ▁ a ▁ truncated ▁ fsimage ▁ file " ) ; } catch ( EOFException e ) { LOG . debug ( " Correctly ▁ handled ▁ EOF " ) ; } } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | private void compareNamespaces ( HashMap < String , FileStatus > written , HashMap < String , LsElements > fileOutput ) { assertEquals ( " Should ▁ be ▁ the ▁ same ▁ number ▁ of ▁ files ▁ in ▁ both , ▁ plus ▁ one ▁ for ▁ root " + " ▁ in ▁ fileoutput " , fileOutput . keySet ( ) . size ( ) , written . keySet ( ) . size ( ) + 1 ) ; Set < String > inFile = fileOutput . keySet ( ) ; for ( String path : inFile ) { if ( path . equals ( " / " ) ) continue ; assertTrue ( " Path ▁ in ▁ file ▁ ( " + path + " ) ▁ was ▁ written ▁ to ▁ fs " , written . containsKey ( path ) ) ; compareFiles ( written . get ( path ) , fileOutput . get ( path ) ) ; written . remove ( path ) ; } assertEquals ( " No ▁ more ▁ files ▁ were ▁ written ▁ to ▁ fs " , 0 , written . size ( ) ) ; }
JuntaoZhang/myhadoop-2.2.0 | private void compareFiles ( FileStatus fs , LsElements elements ) { assertEquals ( " directory ▁ listed ▁ as ▁ such " , fs . isDirectory ( ) ? ' d ' : ' - ' , elements . dir ) ; assertEquals ( " perms ▁ string ▁ equal " , fs . getPermission ( ) . toString ( ) , elements . perms ) ; assertEquals ( " replication ▁ equal " , fs . getReplication ( ) , elements . replication ) ; assertEquals ( " owner ▁ equal " , fs . getOwner ( ) , elements . username ) ; assertEquals ( " group ▁ equal " , fs . getGroup ( ) , elements . groupname ) ; assertEquals ( " lengths ▁ equal " , fs . getLen ( ) , elements . filesize ) ; }
JuntaoZhang/myhadoop-2.2.0 | private HashMap < String , LsElements > readLsfile ( File lsFile ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( lsFile ) ) ; String line = null ; HashMap < String , LsElements > fileContents = new HashMap < String , LsElements > ( ) ; while ( ( line = br . readLine ( ) ) != null ) readLsLine ( line , fileContents ) ; br . close ( ) ; return fileContents ; }
JuntaoZhang/myhadoop-2.2.0 | private void readLsLine ( String line , HashMap < String , LsElements > fileContents ) { String elements [ ] = line . split ( " \\ s + " ) ; assertEquals ( " Not ▁ enough ▁ elements ▁ in ▁ ls ▁ output " , 8 , elements . length ) ; LsElements lsLine = new LsElements ( ) ; lsLine . dir = elements [ 0 ] . charAt ( 0 ) ; lsLine . perms = elements [ 0 ] . substring ( 1 ) ; lsLine . replication = elements [ 1 ] . equals ( " - " ) ? 0 : Integer . valueOf ( elements [ 1 ] ) ; lsLine . username = elements [ 2 ] ; lsLine . groupname = elements [ 3 ] ; lsLine . filesize = Long . valueOf ( elements [ 4 ] ) ; String path = elements [ 7 ] ; assertFalse ( " LS ▁ file ▁ had ▁ duplicate ▁ file ▁ entries " , fileContents . containsKey ( path ) ) ; fileContents . put ( path , lsLine ) ; }
JuntaoZhang/myhadoop-2.2.0 | private void changeLayoutVersion ( File src , File dest , int newVersion ) throws IOException { DataInputStream in = null ; DataOutputStream out = null ; try { in = new DataInputStream ( new FileInputStream ( src ) ) ; out = new DataOutputStream ( new FileOutputStream ( dest ) ) ; in . readInt ( ) ; out . writeInt ( newVersion ) ; byte [ ] b = new byte [ 1024 ] ; while ( in . read ( b ) > 0 ) { out . write ( b ) ; } } finally { if ( in != null ) in . close ( ) ; if ( out != null ) out . close ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | private void copyPartOfFile ( File src , File dest ) throws IOException { InputStream in = null ; OutputStream out = null ; byte [ ] b = new byte [ 256 ] ; int bytesWritten = 0 ; int count ; int maxBytes = 700 ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( dest ) ; while ( ( count = in . read ( b ) ) > 0 && bytesWritten < maxBytes ) { out . write ( b ) ; bytesWritten += count ; } } finally { if ( in != null ) in . close ( ) ; if ( out != null ) out . close ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void outputOfFileDistributionVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; File outputFile = new File ( ROOT , " / fileDistributionCheckOutput " ) ; int totalFiles = 0 ; BufferedReader reader = null ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; ImageVisitor v = new FileDistributionVisitor ( outputFile . getPath ( ) , 0 , 0 ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; oiv . go ( ) ; reader = new BufferedReader ( new FileReader ( outputFile ) ) ; String line = reader . readLine ( ) ; assertEquals ( line , " Size\tNumFiles " ) ; while ( ( line = reader . readLine ( ) ) != null ) { String [ ] row = line . split ( " \t " ) ; assertEquals ( row . length , 2 ) ; totalFiles += Integer . parseInt ( row [ 1 ] ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } assertEquals ( totalFiles , NUM_DIRS * FILES_PER_DIR ) ; }
JuntaoZhang/myhadoop-2.2.0 | TestImageVisitor ( ) { }
JuntaoZhang/myhadoop-2.2.0 | List < String > getDelegationTokenRenewers ( ) { return delegationTokenRenewers ; }
JuntaoZhang/myhadoop-2.2.0 | @ Override void start ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void finish ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void finishAbnormally ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void visit ( ImageElement element , String value ) throws IOException { if ( element == ImageElement . DELEGATION_TOKEN_IDENTIFIER_RENEWER ) { delegationTokenRenewers . add ( value ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ Override void visitEnclosingElement ( ImageElement element ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void visitEnclosingElement ( ImageElement element , ImageElement key , String value ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void leaveEnclosingElement ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void outputOfTestVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; TestImageVisitor v = new TestImageVisitor ( ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , true ) ; oiv . go ( ) ; List < String > dtrs = v . getDelegationTokenRenewers ( ) ; assertEquals ( 1 , dtrs . size ( ) ) ; assertEquals ( TEST_RENEWER , dtrs . get ( 0 ) ) ; } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; } LOG . debug ( " Passed ▁ TestVisitor ▁ validation . " ) ; }
silvanheller/cineast | public BooleanProviderImpl ( boolean value ) { this . value = value ; }
silvanheller/cineast | @ Override public boolean getBoolean ( ) { return this . value ; }
silvanheller/cineast | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( value ? 1231 : 1237 ) ; return result ; }
silvanheller/cineast | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } BooleanProviderImpl other = ( BooleanProviderImpl ) obj ; if ( value != other . value ) { return false ; } return true ; }
silvanheller/cineast | @ Override public String toString ( ) { return " BooleanProviderImpl ▁ [ value = " + value + " ] " ; }
bindstone/graphbank | @ RequestMapping ( value = " / " , method = RequestMethod . GET ) public ResponseEntity < List < Client > > getAll ( ) { List < Client > entities = clientService . findAll ( ) ; return ackEntities ( entities ) ; }
bindstone/graphbank | " , method = RequestMethod . GET ) public ResponseEntity < Client > findById ( @ PathVariable ( " id " ) String id ) { Client entity = clientService . findById ( id ) ; return ackEntity ( entity ) ; }
bindstone/graphbank | @ RequestMapping ( value = " / " , method = RequestMethod . POST ) @ CrossOrigin public ResponseEntity < Client > create ( @ RequestBody Client input ) throws ContextedException { Client entity = clientService . save ( input ) ; return ackEntity ( entity ) ; }
bindstone/graphbank | @ RequestMapping ( value = " / " , method = RequestMethod . PUT ) @ CrossOrigin public ResponseEntity < Client > update ( @ RequestBody Client input ) throws ContextedException { Client entity = clientService . save ( input ) ; return ackEntity ( entity ) ; }
bindstone/graphbank | " , method = RequestMethod . DELETE ) @ CrossOrigin public ResponseEntity < Void > delete ( @ PathVariable ( " id " ) String id ) { clientService . delete ( id ) ; return ack ( ) ; }
xiwc/thymeleaf.test | private StringUtil ( ) { super ( ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue AllBatchesLoadedEvent event ) { jmsClient . send ( event ) . inTransaction ( ) . withProperty ( " variantID " , event . getVariantID ( ) ) . to ( allBatchesLoadedQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue BatchLoadedEvent event ) { jmsClient . send ( event ) . inTransaction ( ) . withProperty ( " variantID " , event . getVariantID ( ) ) . to ( batchLoadedQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue TriggerMetricCollectionEvent event ) { jmsClient . send ( event ) . withDuplicateDetectionId ( event . getPushMessageInformationId ( ) ) . withDelayedDelivery ( 500L ) . to ( triggerMetricCollectionQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue TriggerVariantMetricCollectionEvent event ) { jmsClient . send ( event ) . to ( triggerVariantMetricCollectionQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void broadcastMessage ( @ Observes @ DispatchToQueue MetricsProcessingStartedEvent event ) { jmsClient . send ( event ) . to ( metricsProcessingStartedTopic ) ; }
jentfoo/aws-sdk-java | private AmazonWebServiceRequest originalRequest = new AmazonWebServiceRequest ( ) { }
jentfoo/aws-sdk-java | public EmptyHttpRequest ( String endpoint , HttpMethodName httpMethod ) { this ( endpoint , httpMethod , null ) ; }
jentfoo/aws-sdk-java | public EmptyHttpRequest ( String endpoint , HttpMethodName httpMethod , InputStream payload ) { this . endpoint = URI . create ( endpoint ) ; this . httpMethod = httpMethod ; this . content = payload ; }
jentfoo/aws-sdk-java | @ Override public void addHeader ( String name , String value ) { }
jentfoo/aws-sdk-java | @ Override public Map < String , String > getHeaders ( ) { return Collections . emptyMap ( ) ; }
jentfoo/aws-sdk-java | @ Override public void setHeaders ( Map < String , String > headers ) { }
jentfoo/aws-sdk-java | @ Override public void setResourcePath ( String path ) { }
jentfoo/aws-sdk-java | @ Override public String getResourcePath ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public void addParameter ( String name , String value ) { }
jentfoo/aws-sdk-java | @ Override public Request < Object > withParameter ( String name , String value ) { return this ; }
jentfoo/aws-sdk-java | @ Override public void addParameters ( String name , List < String > values ) { }
jentfoo/aws-sdk-java | @ Override public Map < String , List < String > > getParameters ( ) { return Collections . emptyMap ( ) ; }
jentfoo/aws-sdk-java | @ Override public void setParameters ( Map < String , List < String > > parameters ) { }
jentfoo/aws-sdk-java | @ Override public URI getEndpoint ( ) { return endpoint ; }
jentfoo/aws-sdk-java | @ Override public void setEndpoint ( URI endpoint ) { throw new UnsupportedOperationException ( ) ; }
jentfoo/aws-sdk-java | @ Override public HttpMethodName getHttpMethod ( ) { return httpMethod ; }
jentfoo/aws-sdk-java | @ Override public void setHttpMethod ( HttpMethodName httpMethod ) { throw new UnsupportedOperationException ( ) ; }
jentfoo/aws-sdk-java | @ Override public InputStream getContent ( ) { return content ; }
jentfoo/aws-sdk-java | @ Override public void setContent ( InputStream content ) { }
jentfoo/aws-sdk-java | @ Override public String getServiceName ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public AmazonWebServiceRequest getOriginalRequest ( ) { return originalRequest ; }
jentfoo/aws-sdk-java | public void setOriginalRequest ( AmazonWebServiceRequest originalRequest ) { this . originalRequest = originalRequest ; }
jentfoo/aws-sdk-java | @ Override public int getTimeOffset ( ) { return 0 ; }
jentfoo/aws-sdk-java | @ Override public void setTimeOffset ( int timeOffset ) { }
jentfoo/aws-sdk-java | @ Override public Request < Object > withTimeOffset ( int timeOffset ) { return this ; }
jentfoo/aws-sdk-java | @ Override public AWSRequestMetrics getAWSRequestMetrics ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public void setAWSRequestMetrics ( AWSRequestMetrics metrics ) { }
jentfoo/aws-sdk-java | @ Override public ReadLimitInfo getReadLimitInfo ( ) { return new AmazonWebServiceRequest ( ) { } ; }
jentfoo/aws-sdk-java | @ Override public InputStream getContentUnwrapped ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public Object getOriginalRequestObject ( ) { return new AmazonWebServiceRequest ( ) { } ; }
jentfoo/aws-sdk-java | @ Override public < X > void addHandlerContext ( HandlerContextKey < X > key , X value ) { }
jentfoo/aws-sdk-java | @ Override public < X > X getHandlerContext ( HandlerContextKey < X > key ) { return null ; }
artemrudenko/java_training16 | @ BeforeMethod public void ensurePreconditions ( ) { if ( app . db ( ) . groups ( ) . size ( ) == 0 ) { app . goTo ( ) . groupPage ( ) ; app . group ( ) . create ( new GroupData ( ) . withName ( " MyGroup " ) ) ; } app . goTo ( ) . groupPage ( ) ; }
artemrudenko/java_training16 | @ Test public void testGroupModification ( ) { Groups before = app . db ( ) . groups ( ) ; GroupData modifiedGroup = before . iterator ( ) . next ( ) ; GroupData group = new GroupData ( ) . withId ( modifiedGroup . getId ( ) ) . withName ( " NAMEE " ) . withHeader ( " HEADER " ) . withFooter ( " FOOTER " ) ; app . group ( ) . modify ( group ) ; assertThat ( app . group ( ) . count ( ) , equalTo ( before . size ( ) ) ) ; Groups after = app . db ( ) . groups ( ) ; assertThat ( after , equalTo ( before . withModified ( group ) ) ) ; verifyGroupListInUI ( ) ; }
jaehong-kim/pinpoint | public MqttV5ClientPublishInterceptor ( TraceContext traceContext , MethodDescriptor descriptor , PahoMqttPluginConfig config ) { super ( traceContext , descriptor , config ) ; }
jaehong-kim/pinpoint | @ Override protected void setCallerDataWhenSampled ( Trace trace , SpanEventRecorder recorder , Object [ ] args , boolean canSampled ) { MqttProperties mqttProperties = getMqttProperties ( args [ 1 ] ) ; if ( mqttProperties == null ) { return ; } List < UserProperty > mqttUserProperties = mqttProperties . getUserProperties ( ) ; List < UserProperty > userPropertiesWithHeader = new ArrayList < UserProperty > ( mqttUserProperties ) ; cleanPinpointHeader ( userPropertiesWithHeader ) ; if ( canSampled ) { final TraceId nextId = trace . getTraceId ( ) . getNextTraceId ( ) ; recorder . recordNextSpanId ( nextId . getSpanId ( ) ) ; userPropertiesWithHeader . addAll ( Arrays . asList ( new UserProperty ( Header . HTTP_TRACE_ID . toString ( ) , nextId . getTransactionId ( ) ) , new UserProperty ( Header . HTTP_SPAN_ID . toString ( ) , String . valueOf ( nextId . getSpanId ( ) ) ) , new UserProperty ( Header . HTTP_PARENT_SPAN_ID . toString ( ) , String . valueOf ( nextId . getParentSpanId ( ) ) ) , new UserProperty ( Header . HTTP_FLAGS . toString ( ) , String . valueOf ( nextId . getFlags ( ) ) ) , new UserProperty ( Header . HTTP_PARENT_APPLICATION_NAME . toString ( ) , String . valueOf ( traceContext . getApplicationName ( ) ) ) , new UserProperty ( Header . HTTP_PARENT_APPLICATION_TYPE . toString ( ) , Short . toString ( traceContext . getServerTypeCode ( ) ) ) ) ) ; } else { userPropertiesWithHeader . add ( new UserProperty ( Header . HTTP_SAMPLED . toString ( ) , SamplingFlagUtils . SAMPLING_RATE_FALSE ) ) ; } mqttProperties . setUserProperties ( userPropertiesWithHeader ) ; }
jaehong-kim/pinpoint | private MqttProperties getMqttProperties ( Object arg ) { if ( arg instanceof org . eclipse . paho . mqttv5 . common . MqttMessage ) { org . eclipse . paho . mqttv5 . common . MqttMessage mqttMessage = ( org . eclipse . paho . mqttv5 . common . MqttMessage ) arg ; return mqttMessage . getProperties ( ) ; } return null ; }
jaehong-kim/pinpoint | private void cleanPinpointHeader ( List < UserProperty > userPropertiesWithHeader ) { for ( UserProperty userProperty : userPropertiesWithHeader ) { String key = userProperty . getKey ( ) ; if ( Header . startWithPinpointHeader ( key ) ) { userPropertiesWithHeader . remove ( userProperty ) ; } } }
jhulick/zuul-netty | @ Test public void registeresHandlersOnceServerStarted ( ) throws Exception { httpServer = new HttpServer ( 9090 ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_enabled_after_disabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_disabled_after_enabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_disabled_after_default_enabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " properties " ) . startObject ( " some _ text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_enabled_after_enabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder expectedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testNoConflictWhileMergingAndMappingChanged ( mapping , mappingUpdate , expectedMapping ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_disabled_after_disabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder expectedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testNoConflictWhileMergingAndMappingChanged ( mapping , mappingUpdate , expectedMapping ) ; }
Clairebi/ElasticsearchClone | private void testNoConflictWhileMergingAndMappingChanged ( XContentBuilder mapping , XContentBuilder mappingUpdate , XContentBuilder expectedMapping ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) , " type " , mapping ) ; DocumentMapper . MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( " type " ) . merge ( indexService . mapperService ( ) . parse ( " type " , new CompressedString ( mappingUpdate . bytes ( ) ) , true ) . mapping ( ) , DocumentMapper . MergeFlags . mergeFlags ( ) . simulate ( false ) ) ; assertThat ( mergeResult . conflicts ( ) . length , equalTo ( 0 ) ) ; CompressedString mappingAfterUpdate = indexService . mapperService ( ) . documentMapper ( " type " ) . mappingSource ( ) ; assertThat ( mappingAfterUpdate . toString ( ) , equalTo ( expectedMapping . string ( ) ) ) ; }
Clairebi/ElasticsearchClone | public void testConflictFieldsMapping ( String fieldName ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( fieldName ) . field ( " enabled " , true ) . field ( " store " , " no " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( fieldName ) . field ( " enabled " , true ) . field ( " store " , " yes " ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | protected void testConflictWhileMergingAndMappingUnchanged ( XContentBuilder mapping , XContentBuilder mappingUpdate ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) , " type " , mapping ) ; CompressedString mappingBeforeUpdate = indexService . mapperService ( ) . documentMapper ( " type " ) . mappingSource ( ) ; DocumentMapper . MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( " type " ) . merge ( indexService . mapperService ( ) . parse ( " type " , new CompressedString ( mappingUpdate . bytes ( ) ) , true ) . mapping ( ) , DocumentMapper . MergeFlags . mergeFlags ( ) . simulate ( true ) ) ; assertThat ( mergeResult . conflicts ( ) . length , equalTo ( 1 ) ) ; CompressedString mappingAfterUpdate = indexService . mapperService ( ) . documentMapper ( " type " ) . mappingSource ( ) ; assertThat ( mappingAfterUpdate , equalTo ( mappingBeforeUpdate ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testIndexFieldParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( " type " ) . startObject ( " _ index " ) . field ( " enabled " , enabled ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . indexMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . indexMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testTimestampParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( " type " ) . startObject ( " _ timestamp " ) . field ( " enabled " , enabled ) . field ( " store " , true ) . startObject ( " fielddata " ) . field ( " format " , " doc _ values " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . hasDocValues ( ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . hasDocValues ( ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testSizeParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( " type " ) . startObject ( " _ size " ) . field ( " enabled " , enabled ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . sizeFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . sizeFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . sizeFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testSizeTimestampIndexParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; String mapping = copyToStringFromClasspath ( " / org / elasticsearch / index / mapper / update / default _ mapping _ with _ disabled _ root _ types . json " ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( mapping ) , true ) ; assertThat ( documentMapper . mappingSource ( ) . string ( ) , equalTo ( mapping ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . mappingSource ( ) . string ( ) , equalTo ( mapping ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testDefaultApplied ( ) throws IOException { createIndex ( " test1" , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; createIndex ( " test2" , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder defaultMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( MapperService . DEFAULT_MAPPING ) . startObject ( " _ size " ) . field ( " enabled " , true ) . endObject ( ) . endObject ( ) . endObject ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( ) . setType ( MapperService . DEFAULT_MAPPING ) . setSource ( defaultMapping ) . get ( ) ; XContentBuilder typeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . endObject ( ) . endObject ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( " test1" ) . setType ( " type " ) . setSource ( typeMapping ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( " test1" , " test2" ) . setType ( " type " ) . setSource ( typeMapping ) . get ( ) ; GetMappingsResponse response = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( " test2" ) . get ( ) ; assertNotNull ( response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ all " ) ) ; assertFalse ( ( Boolean ) ( ( LinkedHashMap ) response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ all " ) ) . get ( " enabled " ) ) ; assertNotNull ( response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ size " ) ) ; assertTrue ( ( Boolean ) ( ( LinkedHashMap ) response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ size " ) ) . get ( " enabled " ) ) ; }
dmdlcoding/matrix | public void execute ( JobExecutionContext ctx ) throws JobExecutionException { while ( ConfigureCache . isExecuting ( " TaskReminderLock " ) ) { Thread . yield ( ) ; try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } ConfigureCache . setExecuting ( " TaskReminderLock " , true ) ; try { Iterator < Integer > itAlpha = ConfigureCache . taskCentralMap . keySet ( ) . iterator ( ) ; while ( itAlpha . hasNext ( ) ) { Integer userId = itAlpha . next ( ) ; Map < Integer , List < TaskCentral > > mapAlpha = ConfigureCache . taskCentralMap . get ( userId ) ; if ( mapAlpha . size ( ) > 0 ) { Iterator < Integer > itBeta = mapAlpha . keySet ( ) . iterator ( ) ; while ( itBeta . hasNext ( ) ) { Integer taskId = itBeta . next ( ) ; List < TaskCentral > taskList = mapAlpha . get ( taskId ) ; if ( taskList . size ( ) > 0 ) { Iterator < TaskCentral > itGamma = taskList . iterator ( ) ; while ( itGamma . hasNext ( ) ) { TaskCentral taskCentral = itGamma . next ( ) ; if ( System . currentTimeMillis ( ) - taskCentral . getArrivalTime ( ) . getTime ( ) > 1000 * 60 ) { itGamma . remove ( ) ; } } } else { itBeta . remove ( ) ; } } } else { itAlpha . remove ( ) ; } } } catch ( Exception e ) { logger . error ( e ) ; } ConfigureCache . setExecuting ( " TaskReminderLock " , false ) ; }
dmdlcoding/matrix | public void viewRealtimeData ( ) { try { JSONArray resultArr = new JSONArray ( ) ; Iterator < Integer > itAlpha = ConfigureCache . taskCentralMap . keySet ( ) . iterator ( ) ; while ( itAlpha . hasNext ( ) ) { Integer userId = itAlpha . next ( ) ; JSONObject alphaJson = new JSONObject ( ) ; alphaJson . accumulate ( " userId " , userId ) ; alphaJson . accumulate ( " children " , new JSONArray ( ) ) ; Map < Integer , List < TaskCentral > > taskMap = ConfigureCache . taskCentralMap . get ( userId ) ; Iterator < Integer > itBeta = taskMap . keySet ( ) . iterator ( ) ; while ( itBeta . hasNext ( ) ) { Integer taskId = itBeta . next ( ) ; JSONObject betaJson = new JSONObject ( ) ; betaJson . accumulate ( " taskId " , taskId ) ; betaJson . accumulate ( " children " , new JSONArray ( ) ) ; List < TaskCentral > taskList = taskMap . get ( taskId ) ; Iterator < TaskCentral > itGamma = taskList . iterator ( ) ; while ( itGamma . hasNext ( ) ) { TaskCentral taskCentral = itGamma . next ( ) ; TaskInfo taskInfo = ConfigureCache . taskInfoMap . get ( taskCentral . getUserInfoId ( ) ) . get ( taskCentral . getTaskInfoId ( ) ) ; JSONObject gammaJson = new JSONObject ( ) ; gammaJson . accumulate ( " userInfoId " , taskCentral . getUserInfoId ( ) ) ; gammaJson . accumulate ( " taskInfoId " , taskCentral . getTaskInfoId ( ) ) ; gammaJson . accumulate ( " arrivalTime " , DateTimeHelper . dateToStr ( taskCentral . getArrivalTime ( ) , DateTimeHelper . PATTERN_DATE_TIME ) ) ; gammaJson . accumulate ( " cronExpression " , taskInfo . getCronExpression ( ) ) ; betaJson . getJSONArray ( " children " ) . add ( gammaJson ) ; } alphaJson . getJSONArray ( " children " ) . add ( betaJson ) ; } resultArr . add ( alphaJson ) ; } System . out . println ( " \n " + resultArr + " \n " ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
AlexMinsk/camunda-bpm-platform | public ActivityInstanceStateImpl ( int suspensionCode , String string ) { this . stateCode = suspensionCode ; this . name = string ; }
AlexMinsk/camunda-bpm-platform | public int getStateCode ( ) { return stateCode ; }
AlexMinsk/camunda-bpm-platform | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + stateCode ; return result ; }
AlexMinsk/camunda-bpm-platform | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ActivityInstanceStateImpl other = ( ActivityInstanceStateImpl ) obj ; if ( stateCode != other . stateCode ) return false ; return true ; }
AlexMinsk/camunda-bpm-platform | @ Override public String toString ( ) { return name ; }
badvision/lawless-legends | TYPE ( boolean r ) { this . read = r ; }
badvision/lawless-legends | public boolean isRead ( ) { return read ; }
badvision/lawless-legends | public RAMEvent ( TYPE t , SCOPE s , VALUE v , int address , int oldValue , int newValue ) { setType ( t ) ; setScope ( s ) ; setValue ( v ) ; this . setAddress ( address ) ; this . setOldValue ( oldValue ) ; this . setNewValue ( newValue ) ; }
badvision/lawless-legends | public TYPE getType ( ) { return type ; }
badvision/lawless-legends | public final void setType ( TYPE type ) { this . type = type ; }
badvision/lawless-legends | public SCOPE getScope ( ) { return scope ; }
badvision/lawless-legends | public final void setScope ( SCOPE scope ) { this . scope = scope ; }
badvision/lawless-legends | public VALUE getValue ( ) { return value ; }
badvision/lawless-legends | public final void setValue ( VALUE value ) { this . value = value ; }
badvision/lawless-legends | public int getAddress ( ) { return address ; }
badvision/lawless-legends | public final void setAddress ( int address ) { this . address = address ; }
badvision/lawless-legends | public int getOldValue ( ) { return oldValue ; }
badvision/lawless-legends | public final void setOldValue ( int oldValue ) { this . oldValue = oldValue ; }
badvision/lawless-legends | public int getNewValue ( ) { return newValue ; }
badvision/lawless-legends | public final void setNewValue ( int newValue ) { this . newValue = newValue ; }
Cangol/Cangol-appcore | protected DownloadHttpClient ( final String group , boolean safe ) { this . group = group ; this . httpClient = HttpClientFactory . createDefaultHttpClient ( ) ; threadPool = PoolManager . buildPool ( group , DEFAULT_MAX ) ; this . requestMap = new WeakHashMap < > ( ) ; this . downloadRetryHandler = new DownloadRetryHandler ( DEFAULT_RETRYTIMES ) ; }
Cangol/Cangol-appcore | protected DownloadRetryHandler getDownloadRetryHandler ( ) { return downloadRetryHandler ; }
Cangol/Cangol-appcore | public Future send ( Object tag , String url , DownloadResponseHandler responseHandler , long from , String saveFile ) { final Request request = new Request . Builder ( ) . tag ( tag ) . addHeader ( " Range " , " bytes = " + from + " - " ) . url ( url ) . build ( ) ; return sendRequest ( request , responseHandler , saveFile ) ; }
Cangol/Cangol-appcore | protected Future sendRequest ( Request urlRequest , DownloadResponseHandler responseHandler , String saveFile ) { final Future < ? > request = threadPool . submit ( new DownloadThread ( this , httpClient , urlRequest , responseHandler , saveFile ) ) ; if ( urlRequest . tag ( ) != null ) { List < WeakReference < Future < ? > > > requestList = requestMap . get ( urlRequest . tag ( ) ) ; if ( requestList == null ) { requestList = new LinkedList < > ( ) ; requestMap . put ( urlRequest . tag ( ) , requestList ) ; } requestList . add ( new WeakReference < Future < ? > > ( request ) ) ; } return request ; }
Cangol/Cangol-appcore | public void cancelRequests ( Object tag , boolean mayInterruptIfRunning ) { final List < WeakReference < Future < ? > > > requestList = requestMap . get ( tag ) ; if ( requestList != null ) { for ( final WeakReference < Future < ? > > requestRef : requestList ) { final Future < ? > request = requestRef . get ( ) ; if ( request != null ) { request . cancel ( mayInterruptIfRunning ) ; } } } requestMap . remove ( tag ) ; for ( final Call call : httpClient . dispatcher ( ) . queuedCalls ( ) ) { if ( call . request ( ) . tag ( ) . equals ( group ) ) { call . cancel ( ) ; } } for ( final Call call : httpClient . dispatcher ( ) . runningCalls ( ) ) { if ( call . request ( ) . tag ( ) . equals ( group ) ) { call . cancel ( ) ; } } }
Cangol/Cangol-appcore | public void cancelAll ( ) { httpClient . dispatcher ( ) . cancelAll ( ) ; }
Cangol/Cangol-appcore | public void close ( ) { threadPool . close ( false ) ; }
darranl/keycloak | public MapAuthenticatedClientSessionAdapter ( KeycloakSession session , RealmModel realm , ClientModel client , UserSessionModel userSession , MapAuthenticatedClientSessionEntity < K > entity ) { super ( session , realm , client , userSession , entity ) ; }
darranl/keycloak | @ Override public int getTimestamp ( ) { return entity . getTimestamp ( ) ; }
darranl/keycloak | @ Override public void setTimestamp ( int timestamp ) { entity . setTimestamp ( timestamp ) ; }
darranl/keycloak | @ Override public UserSessionModel getUserSession ( ) { return userSession ; }
darranl/keycloak | @ Override public String getCurrentRefreshToken ( ) { return entity . getCurrentRefreshToken ( ) ; }
darranl/keycloak | @ Override public void setCurrentRefreshToken ( String currentRefreshToken ) { entity . setCurrentRefreshToken ( currentRefreshToken ) ; }
darranl/keycloak | @ Override public int getCurrentRefreshTokenUseCount ( ) { return entity . getCurrentRefreshTokenUseCount ( ) ; }
darranl/keycloak | @ Override public void setCurrentRefreshTokenUseCount ( int currentRefreshTokenUseCount ) { entity . setCurrentRefreshTokenUseCount ( currentRefreshTokenUseCount ) ; }
darranl/keycloak | @ Override public String getNote ( String name ) { return ( name != null ) ? entity . getNotes ( ) . get ( name ) : null ; }
darranl/keycloak | @ Override public void setNote ( String name , String value ) { if ( name != null ) { if ( value == null ) { entity . removeNote ( name ) ; } else { entity . addNote ( name , value ) ; } } }
darranl/keycloak | @ Override public void removeNote ( String name ) { if ( name != null ) { entity . removeNote ( name ) ; } }
darranl/keycloak | @ Override public Map < String , String > getNotes ( ) { return entity . getNotes ( ) ; }
darranl/keycloak | @ Override public String getRedirectUri ( ) { return entity . getRedirectUri ( ) ; }
darranl/keycloak | @ Override public void setRedirectUri ( String uri ) { entity . setRedirectUri ( uri ) ; }
darranl/keycloak | @ Override public RealmModel getRealm ( ) { return realm ; }
darranl/keycloak | @ Override public ClientModel getClient ( ) { return client ; }
darranl/keycloak | @ Override public String getAction ( ) { return entity . getAction ( ) ; }
darranl/keycloak | @ Override public void setAction ( String action ) { entity . setAction ( action ) ; }
darranl/keycloak | @ Override public String getProtocol ( ) { return entity . getAuthMethod ( ) ; }
darranl/keycloak | @ Override public void setProtocol ( String method ) { entity . setAuthMethod ( method ) ; }
darranl/keycloak | @ Override public String toString ( ) { return String . format ( " % s @ %08x " , getId ( ) , hashCode ( ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithMaxKeepaliveIsAliveRightNow ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , FOREVER ) ; assertTrue ( bean . isAlive ( now ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithMaxKeepaliveIsAliveAfterThreeDays ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , FOREVER ) ; assertTrue ( bean . isAlive ( threeDaysFromNow ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithOneSecondOfKeepaliveIsAliveRightNow ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , ONE_SECOND ) ; assertTrue ( bean . isAlive ( now ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithTwoHoursOfKeepaliveIsAliveAfterASecond ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , TWO_HOURS ) ; assertTrue ( bean . isAlive ( oneSecondFromNow ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithOneSecondOfKeepaliveIsNotAliveAfterTwoSeconds ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , ONE_SECOND ) ; assertFalse ( bean . isAlive ( twoHoursFromNow ( ) ) ) ; }
gfyoung/elasticsearch | public AliasValidator ( Settings settings ) { super ( settings ) ; }
gfyoung/elasticsearch | public void validateAlias ( Alias alias , String index , MetaData metaData ) { validateAlias ( alias . name ( ) , index , alias . indexRouting ( ) , metaData :: index ) ; }
gfyoung/elasticsearch | public void validateAliasMetaData ( AliasMetaData aliasMetaData , String index , MetaData metaData ) { validateAlias ( aliasMetaData . alias ( ) , index , aliasMetaData . indexRouting ( ) , metaData :: index ) ; }
gfyoung/elasticsearch | public void validateAliasStandalone ( Alias alias ) { validateAliasStandalone ( alias . name ( ) , alias . indexRouting ( ) ) ; if ( Strings . hasLength ( alias . filter ( ) ) ) { try { XContentHelper . convertToMap ( XContentFactory . xContent ( alias . filter ( ) ) , alias . filter ( ) , false ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " failed ▁ to ▁ parse ▁ filter ▁ for ▁ alias ▁ [ " + alias . name ( ) + " ] " , e ) ; } } }
gfyoung/elasticsearch | public void validateAlias ( String alias , String index , @ Nullable String indexRouting , Function < String , IndexMetaData > indexLookup ) { validateAliasStandalone ( alias , indexRouting ) ; if ( ! Strings . hasText ( index ) ) { throw new IllegalArgumentException ( " index ▁ name ▁ is ▁ required " ) ; } IndexMetaData indexNamedSameAsAlias = indexLookup . apply ( alias ) ; if ( indexNamedSameAsAlias != null ) { throw new InvalidAliasNameException ( indexNamedSameAsAlias . getIndex ( ) , alias , " an ▁ index ▁ exists ▁ with ▁ the ▁ same ▁ name ▁ as ▁ the ▁ alias " ) ; } }
gfyoung/elasticsearch | void validateAliasStandalone ( String alias , String indexRouting ) { if ( ! Strings . hasText ( alias ) ) { throw new IllegalArgumentException ( " alias ▁ name ▁ is ▁ required " ) ; } MetaDataCreateIndexService . validateIndexOrAliasName ( alias , InvalidAliasNameException :: new ) ; if ( indexRouting != null && indexRouting . indexOf ( ' , ' ) != - 1 ) { throw new IllegalArgumentException ( " alias ▁ [ " + alias + " ] ▁ has ▁ several ▁ index ▁ routing ▁ values ▁ associated ▁ with ▁ it " ) ; } }
gfyoung/elasticsearch | public void validateAliasFilter ( String alias , String filter , QueryShardContext queryShardContext , NamedXContentRegistry xContentRegistry ) { assert queryShardContext != null ; try ( XContentParser parser = XContentFactory . xContent ( filter ) . createParser ( xContentRegistry , LoggingDeprecationHandler . INSTANCE , filter ) ) { validateAliasFilter ( parser , queryShardContext ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " failed ▁ to ▁ parse ▁ filter ▁ for ▁ alias ▁ [ " + alias + " ] " , e ) ; } }
gfyoung/elasticsearch | public void validateAliasFilter ( String alias , byte [ ] filter , QueryShardContext queryShardContext , NamedXContentRegistry xContentRegistry ) { assert queryShardContext != null ; try ( XContentParser parser = XContentFactory . xContent ( filter ) . createParser ( xContentRegistry , LoggingDeprecationHandler . INSTANCE , filter ) ) { validateAliasFilter ( parser , queryShardContext ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " failed ▁ to ▁ parse ▁ filter ▁ for ▁ alias ▁ [ " + alias + " ] " , e ) ; } }
smanvi-pivotal/geode | , optionContext = ConverterHint . MEMBERIDNAME , help = CliStrings . CREATE_GATEWAYRECEIVER__MEMBER__HELP ) String [ ] onMember , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__MANUALSTART , help = CliStrings . CREATE_GATEWAYRECEIVER__MANUALSTART__HELP ) Boolean manualStart , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__STARTPORT , help = CliStrings . CREATE_GATEWAYRECEIVER__STARTPORT__HELP ) Integer startPort , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__ENDPORT , help = CliStrings . CREATE_GATEWAYRECEIVER__ENDPORT__HELP ) Integer endPort , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__BINDADDRESS , help = CliStrings . CREATE_GATEWAYRECEIVER__BINDADDRESS__HELP ) String bindAddress , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__MAXTIMEBETWEENPINGS , help = CliStrings . CREATE_GATEWAYRECEIVER__MAXTIMEBETWEENPINGS__HELP ) Integer maximumTimeBetweenPings , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__SOCKETBUFFERSIZE , help = CliStrings . CREATE_GATEWAYRECEIVER__SOCKETBUFFERSIZE__HELP ) Integer socketBufferSize , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER , help = CliStrings . CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER__HELP ) String [ ] gatewayTransportFilters , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__HOSTNAMEFORSENDERS , help = CliStrings . CREATE_GATEWAYRECEIVER__HOSTNAMEFORSENDERS__HELP ) String hostnameForSenders ) { GatewayReceiverFunctionArgs gatewayReceiverFunctionArgs = new GatewayReceiverFunctionArgs ( manualStart , startPort , endPort , bindAddress , socketBufferSize , maximumTimeBetweenPings , gatewayTransportFilters , hostnameForSenders ) ; Set < DistributedMember > membersToCreateGatewayReceiverOn = getMembers ( onGroups , onMember ) ; List < CliFunctionResult > gatewayReceiverCreateResults = executeAndGetFunctionResult ( GatewayReceiverCreateFunction . INSTANCE , gatewayReceiverFunctionArgs , membersToCreateGatewayReceiverOn ) ; CommandResult result = ResultBuilder . buildResult ( gatewayReceiverCreateResults ) ; XmlEntity xmlEntity = findXmlEntity ( gatewayReceiverCreateResults ) ; if ( xmlEntity == null ) { return result ; } if ( onMember != null || getSharedConfiguration ( ) == null ) { result . setCommandPersisted ( false ) ; return result ; } getSharedConfiguration ( ) . addXmlEntity ( xmlEntity , onGroups ) ; return result ; }
smanvi-pivotal/geode | @ Override public Result preExecution ( GfshParseResult parseResult ) { Integer startPort = ( Integer ) parseResult . getParamValue ( " start - port " ) ; Integer endPort = ( Integer ) parseResult . getParamValue ( " end - port " ) ; if ( startPort == null ) { startPort = GatewayReceiver . DEFAULT_START_PORT ; } if ( endPort == null ) { endPort = GatewayReceiver . DEFAULT_END_PORT ; } if ( startPort > endPort ) { return ResultBuilder . createUserErrorResult ( " start - port ▁ must ▁ be ▁ smaller ▁ than ▁ end - port . " ) ; } return ResultBuilder . createInfoResult ( " " ) ; }
whiskeysierra/riptide | String getLogin ( ) { return login ; }
whiskeysierra/riptide | @ AfterEach void tearDown ( ) { executor . shutdown ( ) ; }
whiskeysierra/riptide | @ Test void shouldBuffer ( ) throws IOException { requestFactory . setBufferRequestBody ( true ) ; shouldReadContributors ( ) ; }
whiskeysierra/riptide | @ Test void shouldStream ( ) throws IOException { requestFactory . setBufferRequestBody ( false ) ; shouldReadContributors ( ) ; }
whiskeysierra/riptide | private void shouldReadContributors ( ) throws IOException { driver . addExpectation ( onRequestTo ( " / repos / zalando / riptide / contributors " ) , giveResponseAsBytes ( getResource ( " contributors . json " ) . openStream ( ) , " application / json " ) ) ; final AtomicReference < List < User > > reference = new AtomicReference < > ( ) ; http . get ( " / repos / { org } / { repo } / contributors " , " zalando " , " riptide " ) . dispatch ( series ( ) , on ( SUCCESSFUL ) . call ( listOf ( User . class ) , reference :: set ) ) . join ( ) ; final List < String > users = reference . get ( ) . stream ( ) . map ( User :: getLogin ) . collect ( toList ( ) ) ; assertThat ( users , hasItems ( " jhorstmann " , " lukasniemeier - zalando " , " whiskeysierra " ) ) ; }
stupidlittleboy/myprojectforsmu | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View contactsLayout = inflater . inflate ( R . layout . complany_mana_layout , container , false ) ; return contactsLayout ; }
stupidlittleboy/myprojectforsmu | @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; init ( ) ; }
stupidlittleboy/myprojectforsmu | private void init ( ) { complanyMeeting = ( LinearLayout ) getActivity ( ) . findViewById ( R . id . layout_complany_meeting ) ; complanyContacts = ( LinearLayout ) getActivity ( ) . findViewById ( R . id . layout_complany_contacts ) ; complanyNotices = ( LinearLayout ) getActivity ( ) . findViewById ( R . id . layout_complany_noticts ) ; complanyMeeting . setOnClickListener ( this ) ; complanyContacts . setOnClickListener ( this ) ; complanyNotices . setOnClickListener ( this ) ; }
stupidlittleboy/myprojectforsmu | @ Override public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . layout_complany_meeting : ComplanyMeeting . startComplanyMeeting ( getActivity ( ) ) ; Toast . makeText ( getActivity ( ) , " 会议信息 " , Toast . LENGTH_SHORT ) . show ( ) ; break ; case R . id . layout_complany_contacts : ComplanyContacts . startComplanyContacts ( getActivity ( ) ) ; Toast . makeText ( getActivity ( ) , " 企业通讯录 " , Toast . LENGTH_SHORT ) . show ( ) ; break ; case R . id . layout_complany_noticts : ComplanyNotices . startComplanyNotices ( getActivity ( ) ) ; Toast . makeText ( getActivity ( ) , " 企业公告 " , Toast . LENGTH_SHORT ) . show ( ) ; break ; default : break ; } }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " seq " ) @ NotNull public Integer getSeq ( ) { return seq ; }
samuelfac/portalunico.siscomex.gov.br | public void setSeq ( Integer seq ) { this . seq = seq ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO seq ( Integer seq ) { this . seq = seq ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " codigoProduto " ) public Long getCodigoProduto ( ) { return codigoProduto ; }
samuelfac/portalunico.siscomex.gov.br | public void setCodigoProduto ( Long codigoProduto ) { this . codigoProduto = codigoProduto ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO codigoProduto ( Long codigoProduto ) { this . codigoProduto = codigoProduto ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " cpfCnpjRaiz " ) @ NotNull public String getCpfCnpjRaiz ( ) { return cpfCnpjRaiz ; }
samuelfac/portalunico.siscomex.gov.br | public void setCpfCnpjRaiz ( String cpfCnpjRaiz ) { this . cpfCnpjRaiz = cpfCnpjRaiz ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO cpfCnpjRaiz ( String cpfCnpjRaiz ) { this . cpfCnpjRaiz = cpfCnpjRaiz ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " numeroAto " ) @ NotNull public String getNumeroAto ( ) { return numeroAto ; }
samuelfac/portalunico.siscomex.gov.br | public void setNumeroAto ( String numeroAto ) { this . numeroAto = numeroAto ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO numeroAto ( String numeroAto ) { this . numeroAto = numeroAto ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " numeroItem " ) @ NotNull public String getNumeroItem ( ) { return numeroItem ; }
samuelfac/portalunico.siscomex.gov.br | public void setNumeroItem ( String numeroItem ) { this . numeroItem = numeroItem ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO numeroItem ( String numeroItem ) { this . numeroItem = numeroItem ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " class ▁ RegimeEspecialIntegracaoDTO ▁ { \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ seq : ▁ " ) . append ( toIndentedString ( seq ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ codigoProduto : ▁ " ) . append ( toIndentedString ( codigoProduto ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ cpfCnpjRaiz : ▁ " ) . append ( toIndentedString ( cpfCnpjRaiz ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ numeroAto : ▁ " ) . append ( toIndentedString ( numeroAto ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ numeroItem : ▁ " ) . append ( toIndentedString ( numeroItem ) ) . append ( " \n " ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
allpaykz/webshop-service-examples | public ObjectFactory ( ) { }
allpaykz/webshop-service-examples | public WebShopResponseType createWebShopResponseType ( ) { return new WebShopResponseType ( ) ; }
allpaykz/webshop-service-examples | public TransationType createTransationType ( ) { return new TransationType ( ) ; }
allpaykz/webshop-service-examples | @ XmlElementDecl ( namespace = Constants . RESPONSE_XSD , name = " WebShopResponse " ) public JAXBElement < WebShopResponseType > createWebShopResponse ( WebShopResponseType value ) { return new JAXBElement < WebShopResponseType > ( _WebShopResponse_QNAME , WebShopResponseType . class , null , value ) ; }
apache/incubator-asterixdb | @ Test public void testNormalSequence ( ) throws HyracksDataException { int numMemoryComponents = 2 ; ILSMIndex mockIndex = Mockito . mock ( ILSMIndex . class ) ; String indexId = " mockIndexId " ; Mockito . when ( mockIndex . getNumberOfAllMemoryComponents ( ) ) . thenReturn ( numMemoryComponents ) ; Mockito . when ( mockIndex . getCurrentMemoryComponent ( ) ) . thenReturn ( Mockito . mock ( AbstractLSMMemoryComponent . class ) ) ; DatasetInfo dsInfo = new DatasetInfo ( 101 , null ) ; LSMComponentIdGenerator idGenerator = new LSMComponentIdGenerator ( numMemoryComponents , MIN_VALID_COMPONENT_ID ) ; LSMIOOperationCallback callback = new LSMIOOperationCallback ( dsInfo , mockIndex , idGenerator . getId ( ) , mockIndexCheckpointManagerProvider ( ) ) ; idGenerator . refresh ( ) ; long flushLsn = 1L ; ILSMComponentId nextComponentId = idGenerator . getId ( ) ; Map < String , Object > flushMap = new HashMap < > ( ) ; flushMap . put ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN , flushLsn ) ; flushMap . put ( LSMIOOperationCallback . KEY_NEXT_COMPONENT_ID , nextComponentId ) ; ILSMIndexAccessor firstAccessor = new TestLSMIndexAccessor ( new TestLSMIndexOperationContext ( mockIndex ) ) ; firstAccessor . getOpContext ( ) . setParameters ( flushMap ) ; FileReference firstTarget = new FileReference ( Mockito . mock ( IODeviceHandle . class ) , getComponentFileName ( ) ) ; LSMComponentFileReferences firstFiles = new LSMComponentFileReferences ( firstTarget , firstTarget , firstTarget ) ; FlushOperation firstFlush = new TestFlushOperation ( firstAccessor , firstTarget , callback , indexId , firstFiles , new LSMComponentId ( 0 , 0 ) ) ; callback . scheduled ( firstFlush ) ; callback . beforeOperation ( firstFlush ) ; idGenerator . refresh ( ) ; flushLsn = 2L ; nextComponentId = idGenerator . getId ( ) ; flushMap = new HashMap < > ( ) ; flushMap . put ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN , flushLsn ) ; flushMap . put ( LSMIOOperationCallback . KEY_NEXT_COMPONENT_ID , nextComponentId ) ; ILSMIndexAccessor secondAccessor = new TestLSMIndexAccessor ( new TestLSMIndexOperationContext ( mockIndex ) ) ; secondAccessor . getOpContext ( ) . setParameters ( flushMap ) ; FileReference secondTarget = new FileReference ( Mockito . mock ( IODeviceHandle . class ) , getComponentFileName ( ) ) ; LSMComponentFileReferences secondFiles = new LSMComponentFileReferences ( secondTarget , secondTarget , secondTarget ) ; FlushOperation secondFlush = new TestFlushOperation ( secondAccessor , secondTarget , callback , indexId , secondFiles , new LSMComponentId ( 1 , 1 ) ) ; callback . scheduled ( secondFlush ) ; callback . beforeOperation ( secondFlush ) ; Map < String , Object > firstFlushMap = firstFlush . getAccessor ( ) . getOpContext ( ) . getParameters ( ) ; long firstFlushLogLsn = ( Long ) firstFlushMap . get ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN ) ; Assert . assertEquals ( 1 , firstFlushLogLsn ) ; final ILSMDiskComponent diskComponent1 = mockDiskComponent ( ) ; firstFlush . setNewComponent ( diskComponent1 ) ; callback . afterOperation ( firstFlush ) ; callback . afterFinalize ( firstFlush ) ; callback . completed ( firstFlush ) ; Map < String , Object > secondFlushMap = secondFlush . getAccessor ( ) . getOpContext ( ) . getParameters ( ) ; long secondFlushLogLsn = ( Long ) secondFlushMap . get ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN ) ; Assert . assertEquals ( 2 , secondFlushLogLsn ) ; final ILSMDiskComponent diskComponent2 = mockDiskComponent ( ) ; secondFlush . setNewComponent ( diskComponent2 ) ; callback . afterOperation ( secondFlush ) ; callback . afterFinalize ( secondFlush ) ; callback . completed ( secondFlush ) ; }
apache/incubator-asterixdb | @ Test public void testAllocateComponentId ( ) throws HyracksDataException { int numMemoryComponents = 2 ; DatasetInfo dsInfo = new DatasetInfo ( 101 , null ) ; ILSMComponentIdGenerator idGenerator = new LSMComponentIdGenerator ( numMemoryComponents , MIN_VALID_COMPONENT_ID ) ; ILSMIndex mockIndex = Mockito . mock ( ILSMIndex . class ) ; Mockito . when ( mockIndex . getNumberOfAllMemoryComponents ( ) ) . thenReturn ( numMemoryComponents ) ; ILSMMemoryComponent mockComponent = Mockito . mock ( AbstractLSMMemoryComponent . class ) ; Mockito . when ( mockIndex . getCurrentMemoryComponent ( ) ) . thenReturn ( mockComponent ) ; LSMIOOperationCallback callback = new LSMIOOperationCallback ( dsInfo , mockIndex , idGenerator . getId ( ) , mockIndexCheckpointManagerProvider ( ) ) ; ILSMComponentId initialId = idGenerator . getId ( ) ; idGenerator . refresh ( ) ; long flushLsn = 1L ; ILSMComponentId nextComponentId = idGenerator . getId ( ) ; callback . allocated ( mockComponent ) ; callback . recycled ( mockComponent ) ; checkMemoryComponent ( initialId , mockComponent ) ; }
apache/incubator-asterixdb | @ Test public void testRecycleComponentId ( ) throws HyracksDataException { int numMemoryComponents = 2 ; DatasetInfo dsInfo = new DatasetInfo ( 101 , null ) ; ILSMComponentIdGenerator idGenerator = new LSMComponentIdGenerator ( numMemoryComponents , MIN_VALID_COMPONENT_ID ) ; ILSMIndex mockIndex = Mockito . mock ( ILSMIndex . class ) ; Mockito . when ( mockIndex . getNumberOfAllMemoryComponents ( ) ) . thenReturn ( numMemoryComponents ) ; ILSMMemoryComponent mockComponent = Mockito . mock ( AbstractLSMMemoryComponent . class ) ; Mockito . when ( mockIndex . getCurrentMemoryComponent ( ) ) . thenReturn ( mockComponent ) ; LSMIOOperationCallback callback = new LSMIOOperationCallback ( dsInfo , mockIndex , idGenerator . getId ( ) , mockIndexCheckpointManagerProvider ( ) ) ; String indexId = " mockIndexId " ; ILSMComponentId id = idGenerator . getId ( ) ; callback . recycled ( mockComponent ) ; checkMemoryComponent ( id , mockComponent ) ; Mockito . when ( mockIndex . isMemoryComponentsAllocated ( ) ) . thenReturn ( true ) ; for ( int i = 0 ; i < 100 ; i ++ ) { idGenerator . refresh ( ) ; ILSMComponentId expectedId = idGenerator . getId ( ) ; long flushLsn = 0L ; Map < String , Object > flushMap = new HashMap < > ( ) ; flushMap . put ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN , flushLsn ) ; flushMap . put ( LSMIOOperationCallback . KEY_NEXT_COMPONENT_ID , expectedId ) ; ILSMIndexAccessor accessor = new TestLSMIndexAccessor ( new TestLSMIndexOperationContext ( mockIndex ) ) ; accessor . getOpContext ( ) . setParameters ( flushMap ) ; FileReference target = new FileReference ( Mockito . mock ( IODeviceHandle . class ) , getComponentFileName ( ) ) ; LSMComponentFileReferences files = new LSMComponentFileReferences ( target , target , target ) ; FlushOperation flush = new TestFlushOperation ( accessor , target , callback , indexId , files , new LSMComponentId ( 0 , 0 ) ) ; callback . scheduled ( flush ) ; callback . beforeOperation ( flush ) ; callback . recycled ( mockComponent ) ; flush . setNewComponent ( mockDiskComponent ( ) ) ; callback . afterOperation ( flush ) ; callback . afterFinalize ( flush ) ; callback . completed ( flush ) ; checkMemoryComponent ( expectedId , mockComponent ) ; } }
apache/incubator-asterixdb | private void checkMemoryComponent ( ILSMComponentId expected , ILSMMemoryComponent memoryComponent ) throws HyracksDataException { ArgumentCaptor < ILSMComponentId > idArgument = ArgumentCaptor . forClass ( ILSMComponentId . class ) ; ArgumentCaptor < Boolean > forceArgument = ArgumentCaptor . forClass ( Boolean . class ) ; Mockito . verify ( memoryComponent ) . resetId ( idArgument . capture ( ) , forceArgument . capture ( ) ) ; assertEquals ( expected , idArgument . getValue ( ) ) ; assertEquals ( false , forceArgument . getValue ( ) . booleanValue ( ) ) ; Mockito . reset ( memoryComponent ) ; }
apache/incubator-asterixdb | private ILSMDiskComponent mockDiskComponent ( ) { ILSMDiskComponent component = Mockito . mock ( ILSMDiskComponent . class ) ; Mockito . when ( component . getMetadata ( ) ) . thenReturn ( Mockito . mock ( DiskComponentMetadata . class ) ) ; return component ; }
apache/incubator-asterixdb | protected IIndexCheckpointManagerProvider mockIndexCheckpointManagerProvider ( ) throws HyracksDataException { IIndexCheckpointManagerProvider indexCheckpointManagerProvider = Mockito . mock ( IIndexCheckpointManagerProvider . class ) ; IIndexCheckpointManager indexCheckpointManager = Mockito . mock ( IIndexCheckpointManager . class ) ; Mockito . doNothing ( ) . when ( indexCheckpointManager ) . flushed ( Mockito . anyLong ( ) , Mockito . anyLong ( ) , Mockito . anyLong ( ) ) ; Mockito . doReturn ( indexCheckpointManager ) . when ( indexCheckpointManagerProvider ) . get ( Mockito . any ( ) ) ; return indexCheckpointManagerProvider ; }
GeoSmartCity-CIP/gsc-datacatalogue | public UpdateShapeService ( ) { logger = Logger . getLogger ( this . getClass ( ) ) ; gsc007Dao = PersistenceServiceProvider . getService ( Gsc007DatasetPersistence . class ) ; gsc006Dao = PersistenceServiceProvider . getService ( Gsc006DatasourcePersistence . class ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | public List < Gsc007DatasetEntity > getUpdatableDatasets ( ) { String updatableDatasetsQuery = createGetUpdatableDatasetsQuery ( ) ; return gsc007Dao . getDatasets ( updatableDatasetsQuery ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | private String createGetUpdatableDatasetsQuery ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " SELECT ▁ * ▁ FROM ▁ " ) . append ( Constants . DATASETS_TABLE_NAME ) . append ( " ▁ dstT ▁ " ) ; sb . append ( " WHERE ▁ dstT . json - > > ' tobeingested ' ▁ = ▁ ' true ' ▁ AND ▁ ( " ) ; sb . append ( " to _ timestamp ( dstT . json - > > ' lastupdated ' , ' dd / MM / yyyy ▁ hh24 : mi : ss ' ) ▁ + ▁ " ) ; sb . append ( " ( CAST ( ( dstT . json - > > ' refreshinterval ' ) ▁ AS ▁ INTEGER ) ▁ * ▁ INTERVAL ▁ ' 1 ▁ hour ' ) ) " ) ; sb . append ( " < ▁ clock _ timestamp ( ) " ) ; return sb . toString ( ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | public Gsc007DatasetEntity updateFile ( Gsc007DatasetEntity dataset ) throws DCException { try { Long datasetId = dataset . getId ( ) ; String lastUpdateTimestamp = getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . LAST_UPDATE_TS ) ; String sourceURL = getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . URL ) ; Gsc006DatasourceEntity datasource = gsc006Dao . load ( Long . parseLong ( getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . DATASOURCE_ID_FIELD ) ) ) ; String destinationDirectory = getFieldValueFromJsonText ( datasource . getJson ( ) , Constants . PATH ) ; String fileName = getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . DSET_REALNAME_FIELD ) ; String fileNameNoExtension = fileName . substring ( 0 , fileName . lastIndexOf ( " . " ) ) ; boolean updated = updateFile ( datasetId , sourceURL , fileNameNoExtension , destinationDirectory , lastUpdateTimestamp ) ; if ( updated ) { ObjectNode datasetNode = ( ( ObjectNode ) om . readTree ( dataset . getJson ( ) ) ) ; DateFormat formatter = new SimpleDateFormat ( " dd / MM / yyyy ▁ HH : mm : ss " ) ; String dateFormatted = formatter . format ( System . currentTimeMillis ( ) ) ; datasetNode . put ( Constants . LAST_UPDATE_TS , dateFormatted ) ; dataset . setJson ( om . writeValueAsString ( datasetNode ) ) ; return gsc007Dao . save ( dataset ) ; } return null ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private boolean updateFile ( Long datasetId , String sourceURL , String fileNameNoExtension , String destinationDirectory , String lastUpdateTimestamp ) throws DCException { try { File file = new File ( destinationDirectory + fileNameNoExtension + " . zip " ) ; if ( isFileModified ( sourceURL , file ) ) { String tempDestinationDirectory = destinationDirectory + " temp " ; File tempDir = new File ( tempDestinationDirectory ) ; if ( ! tempDir . exists ( ) ) { tempDir . mkdir ( ) ; } if ( datasetId != null ) { logger . info ( " Found ▁ new ▁ file ▁ for ▁ datasetId = " + datasetId + " . . . ▁ update ▁ in ▁ progress . " ) ; } FileUtils . copyURLToFile ( new URL ( sourceURL ) , file ) ; ZipInputStream zipIn = new ZipInputStream ( new FileInputStream ( destinationDirectory + fileNameNoExtension + " . zip " ) ) ; getZipFiles ( zipIn , tempDestinationDirectory ) ; File shpFile = new File ( destinationDirectory + fileNameNoExtension + " . shp " ) ; if ( shpFile . exists ( ) ) { String tempFilePath = tempDestinationDirectory + File . separator + fileNameNoExtension + " . shp " ; String oldFilePath = destinationDirectory + fileNameNoExtension + " . shp " ; logger . info ( " Check ▁ if ▁ metadata ▁ from ▁ " + tempFilePath + " ▁ file ▁ are ▁ equals ▁ to ▁ " + oldFilePath + " ▁ file " ) ; if ( ! metadataMatch ( tempFilePath , oldFilePath ) ) { logger . error ( " The ▁ retrieved ▁ file ▁ cannot ▁ be ▁ updated ▁ because ▁ its ▁ metadata ▁ do ▁ not ▁ match ▁ with ▁ the ▁ ones ▁ of ▁ the ▁ file ▁ that ▁ needs ▁ to ▁ be ▁ ovverridden " ) ; throw new DCException ( Constants . ER22 ) ; } else { FileUtils . copyDirectory ( tempDir , new File ( destinationDirectory ) ) ; } } else { FileUtils . copyDirectory ( tempDir , new File ( destinationDirectory ) ) ; } FileUtils . deleteDirectory ( tempDir ) ; return true ; } return false ; } catch ( DCException e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( e . getErrorCode ( ) ) ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private void getZipFiles ( ZipInputStream zipIn , String destDirectory ) throws DCException { try { ZipEntry entry = zipIn . getNextEntry ( ) ; while ( entry != null ) { String filePath = destDirectory + File . separator + entry . getName ( ) ; if ( ! entry . isDirectory ( ) ) { extractFile ( zipIn , filePath ) ; } else { File dir = new File ( filePath ) ; dir . mkdir ( ) ; } zipIn . closeEntry ( ) ; entry = zipIn . getNextEntry ( ) ; } zipIn . close ( ) ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private void extractFile ( ZipInputStream zipIn , String filePath ) throws IOException { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( filePath ) ) ; byte [ ] bytesIn = new byte [ 4096 ] ; int read = 0 ; while ( ( read = zipIn . read ( bytesIn ) ) != - 1 ) { bos . write ( bytesIn , 0 , read ) ; } bos . close ( ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | private boolean metadataMatch ( String tempFilePath , String localFilePath ) throws DCException { try { String tempFileMetadata = ServiceUtil . createJSONColumnsFromShapeFile ( tempFilePath ) ; String localFileMetadata = ServiceUtil . createJSONColumnsFromShapeFile ( localFilePath ) ; if ( localFileMetadata . equalsIgnoreCase ( tempFileMetadata ) ) { return true ; } return false ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private boolean isFileModified ( String sourceURL , File file ) throws DCException { return getRemoteLastModified ( sourceURL ) > getLocalLastModified ( file ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | private long getRemoteLastModified ( String sourceURL ) throws DCException { try { URL url = new URL ( sourceURL ) ; HttpURLConnection httpCon = ( HttpURLConnection ) url . openConnection ( ) ; return httpCon . getLastModified ( ) ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private long getLocalLastModified ( File file ) throws DCException { return file . lastModified ( ) ; }
Kangmo/bitcoinj | channelClient = new PaymentChannelClient ( wallet , myKey , maxValue , Sha256Hash . create ( serverId . getBytes ( ) ) , new PaymentChannelClient . ClientConnection ( ) { @ Override public void sendToServer ( Protos . TwoWayChannelMessage msg ) { wireParser . write ( msg ) ; } @ Override public void destroyConnection ( PaymentChannelCloseException . CloseReason reason ) { channelOpenFuture . setException ( new PaymentChannelCloseException ( " Payment ▁ channel ▁ client ▁ requested ▁ that ▁ the ▁ connection ▁ be ▁ closed : ▁ " + reason , reason ) ) ; wireParser . closeConnection ( ) ; } @ Override public void channelOpen ( boolean wasInitiated ) { wireParser . setSocketTimeout ( 0 ) ; channelOpenFuture . set ( PaymentChannelClientConnection . this ) ; } }
Kangmo/bitcoinj | wireParser = new ProtobufParser < Protos . TwoWayChannelMessage > ( new ProtobufParser . Listener < Protos . TwoWayChannelMessage > ( ) { @ Override public void messageReceived ( ProtobufParser < Protos . TwoWayChannelMessage > handler , Protos . TwoWayChannelMessage msg ) { try { channelClient . receiveMessage ( msg ) ; } catch ( InsufficientMoneyException e ) { channelOpenFuture . setException ( e ) ; } } @ Override public void connectionOpen ( ProtobufParser < Protos . TwoWayChannelMessage > handler ) { channelClient . connectionOpen ( ) ; } @ Override public void connectionClosed ( ProtobufParser < Protos . TwoWayChannelMessage > handler ) { channelClient . connectionClosed ( ) ; channelOpenFuture . setException ( new PaymentChannelCloseException ( " The ▁ TCP ▁ socket ▁ died " , PaymentChannelCloseException . CloseReason . CONNECTION_CLOSED ) ) ; } }
Kangmo/bitcoinj | public ListenableFuture < PaymentChannelClientConnection > getChannelOpenFuture ( ) { return channelOpenFuture ; }
Kangmo/bitcoinj | public PaymentChannelClientState state ( ) { return channelClient . state ( ) ; }
Kangmo/bitcoinj | public void settle ( ) { try { channelClient . settle ( ) ; } catch ( IllegalStateException e ) { } }
Kangmo/bitcoinj | public void disconnectWithoutSettlement ( ) { wireParser . closeConnection ( ) ; }
jasonstack/cassandra | public EncodingStats ( long minTimestamp , int minLocalDeletionTime , int minTTL ) { this . minTimestamp = minTimestamp == LivenessInfo . NO_TIMESTAMP ? TIMESTAMP_EPOCH : minTimestamp ; this . minLocalDeletionTime = minLocalDeletionTime == LivenessInfo . NO_EXPIRATION_TIME ? DELETION_TIME_EPOCH : minLocalDeletionTime ; this . minTTL = minTTL ; }
jasonstack/cassandra | public EncodingStats mergeWith ( EncodingStats that ) { long minTimestamp = this . minTimestamp == TIMESTAMP_EPOCH ? that . minTimestamp : ( that . minTimestamp == TIMESTAMP_EPOCH ? this . minTimestamp : Math . min ( this . minTimestamp , that . minTimestamp ) ) ; int minDelTime = this . minLocalDeletionTime == DELETION_TIME_EPOCH ? that . minLocalDeletionTime : ( that . minLocalDeletionTime == DELETION_TIME_EPOCH ? this . minLocalDeletionTime : Math . min ( this . minLocalDeletionTime , that . minLocalDeletionTime ) ) ; int minTTL = this . minTTL == TTL_EPOCH ? that . minTTL : ( that . minTTL == TTL_EPOCH ? this . minTTL : Math . min ( this . minTTL , that . minTTL ) ) ; return new EncodingStats ( minTimestamp , minDelTime , minTTL ) ; }
jasonstack/cassandra | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; EncodingStats that = ( EncodingStats ) o ; return this . minLocalDeletionTime == that . minLocalDeletionTime && this . minTTL == that . minTTL && this . minTimestamp == that . minTimestamp ; }
jasonstack/cassandra | @ Override public int hashCode ( ) { return Objects . hash ( minTimestamp , minLocalDeletionTime , minTTL ) ; }
jasonstack/cassandra | @ Override public String toString ( ) { return String . format ( " EncodingStats ( ts = % d , ▁ ldt = % d , ▁ ttl = % d ) " , minTimestamp , minLocalDeletionTime , minTTL ) ; }
jasonstack/cassandra | public void update ( LivenessInfo info ) { if ( info . isEmpty ( ) ) return ; updateTimestamp ( info . timestamp ( ) ) ; if ( info . isExpiring ( ) ) { updateTTL ( info . ttl ( ) ) ; updateLocalDeletionTime ( info . localExpirationTime ( ) ) ; } }
jasonstack/cassandra | public void update ( Cell cell ) { updateTimestamp ( cell . timestamp ( ) ) ; if ( cell . isExpiring ( ) ) { updateTTL ( cell . ttl ( ) ) ; updateLocalDeletionTime ( cell . localDeletionTime ( ) ) ; } else if ( cell . isTombstone ( ) ) { updateLocalDeletionTime ( cell . localDeletionTime ( ) ) ; } }
jasonstack/cassandra | public void update ( DeletionTime deletionTime ) { if ( deletionTime . isLive ( ) ) return ; updateTimestamp ( deletionTime . markedForDeleteAt ( ) ) ; updateLocalDeletionTime ( deletionTime . localDeletionTime ( ) ) ; }
jasonstack/cassandra | public void updateTimestamp ( long timestamp ) { isTimestampSet = true ; minTimestamp = Math . min ( minTimestamp , timestamp ) ; }
jasonstack/cassandra | public void updateLocalDeletionTime ( int deletionTime ) { isDelTimeSet = true ; minDeletionTime = Math . min ( minDeletionTime , deletionTime ) ; }
jasonstack/cassandra | public void updateTTL ( int ttl ) { isTTLSet = true ; minTTL = Math . min ( minTTL , ttl ) ; }
jasonstack/cassandra | public void updateColumnSetPerRow ( long columnSetInRow ) { }
jasonstack/cassandra | public void updateHasLegacyCounterShards ( boolean hasLegacyCounterShards ) { }
jasonstack/cassandra | public EncodingStats get ( ) { return new EncodingStats ( isTimestampSet ? minTimestamp : TIMESTAMP_EPOCH , isDelTimeSet ? minDeletionTime : DELETION_TIME_EPOCH , isTTLSet ? minTTL : TTL_EPOCH ) ; }
jasonstack/cassandra | public void serialize ( EncodingStats stats , DataOutputPlus out ) throws IOException { out . writeUnsignedVInt ( stats . minTimestamp - TIMESTAMP_EPOCH ) ; out . writeUnsignedVInt ( stats . minLocalDeletionTime - DELETION_TIME_EPOCH ) ; out . writeUnsignedVInt ( stats . minTTL - TTL_EPOCH ) ; }
jasonstack/cassandra | public int serializedSize ( EncodingStats stats ) { return TypeSizes . sizeofUnsignedVInt ( stats . minTimestamp - TIMESTAMP_EPOCH ) + TypeSizes . sizeofUnsignedVInt ( stats . minLocalDeletionTime - DELETION_TIME_EPOCH ) + TypeSizes . sizeofUnsignedVInt ( stats . minTTL - TTL_EPOCH ) ; }
jasonstack/cassandra | public EncodingStats deserialize ( DataInputPlus in ) throws IOException { long minTimestamp = in . readUnsignedVInt ( ) + TIMESTAMP_EPOCH ; int minLocalDeletionTime = ( int ) in . readUnsignedVInt ( ) + DELETION_TIME_EPOCH ; int minTTL = ( int ) in . readUnsignedVInt ( ) + TTL_EPOCH ; return new EncodingStats ( minTimestamp , minLocalDeletionTime , minTTL ) ; }
FlorianHuebner/Adventurer-Conqueror-King-Mobile | @ Override public String getName ( ) { return DUNGEON_BASHING ; }
FlorianHuebner/Adventurer-Conqueror-King-Mobile | @ Override public String getDescription ( ) { return " The ▁ character ▁ is ▁ hardened ▁ to ▁ the ▁ heavy ▁ lifting ▁ and ▁ physical ▁ labor ▁ involved ▁ in ▁ " + " dungeon ▁ exploration . ▁ The ▁ character ▁ receives ▁ a ▁ + 4 ▁ bonus ▁ on ▁ throws ▁ to ▁ open ▁ doors ▁ " + " and ▁ similar ▁ acts ▁ of ▁ brute ▁ strength . " ; }
fernandoj92/mvca-parkinson | public FullEm ( MixedDataSet data , boolean reuseParameters , int restarts , int maxSteps , double threshold ) { super ( data ) ; use ( new EmParameters ( reuseParameters , restarts , 0 , maxSteps , threshold ) ) ; }
fernandoj92/mvca-parkinson | public FullEm ( MixedDataSet data ) { this ( data , true , 64 , 500 , 1e-2 ) ; }
fernandoj92/mvca-parkinson | @ Override protected Estimation [ ] createEstimations ( int size , Gltm model , Focus focus ) { Estimation [ ] estimations = new Estimation [ size ] ; for ( int i = 0 ; i < estimations . length ; i ++ ) estimations [ i ] = estimationFactory ( ) . createSimple ( model , data , parameters . smoothing ) ; return estimations ; }
jmockit/jmockit2 | public MockedTypeInfo ( @ Nonnull Type mockedType ) { Class < ? > mockedClass = Utilities . getClassType ( mockedType ) ; genericTypeMap = new GenericTypeReflection ( mockedClass , mockedType ) ; String signature = getGenericClassSignature ( mockedType ) ; String classDesc = mockedClass . getName ( ) . replace ( ' . ' , ' / ' ) ; implementationSignature = ' L ' + classDesc + signature ; }
giraudsa/serialisation | protected ActionJsonSimpleComportement ( final Class < T > type , final JsonUnmarshaller < ? > jsonUnmarshaller ) { super ( type , jsonUnmarshaller ) ; }
giraudsa/serialisation | @ Override protected void construitObjet ( ) { }
giraudsa/serialisation | @ Override public < U extends T > ActionAbstrait < U > getNewInstance ( final Class < U > type , final Unmarshaller unmarshaller ) { return new ActionJsonSimpleComportement < > ( type , ( JsonUnmarshaller < ? > ) unmarshaller ) ; }
giraudsa/serialisation | @ Override protected Class < ? > getTypeAttribute ( final String nomAttribut ) { if ( Constants . VALEUR . equals ( nomAttribut ) ) return type ; return null ; }
giraudsa/serialisation | @ Override protected < W > void integreObjet ( final String nomAttribut , final W objet ) { }
giraudsa/serialisation | @ Override protected void rempliData ( final String donnees ) throws InstanciationException { try { obj = type . getConstructor ( String . class ) . newInstance ( donnees ) ; } catch ( InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e ) { throw new InstanciationException ( " impossible ▁ de ▁ trouver ▁ un ▁ constructeur ▁ avec ▁ un ▁ string ▁ pour ▁ le ▁ type ▁ " + type . getName ( ) , e ) ; } }
aws/aws-sdk-java | if ( defaultMetricsEnabled ) { String [ ] values = defaultMetrics . split ( " , " ) ; boolean excludeMachineMetrics = false ; boolean includePerHostMetrics = false ; boolean useSingleMetricNamespace = false ; boolean enableHttpSocketReadMetric = false ; for ( String s : values ) { String part = s . trim ( ) ; if ( ! excludeMachineMetrics && EXCLUDE_MACHINE_METRICS . equals ( part ) ) { excludeMachineMetrics = true ; } else if ( ! includePerHostMetrics && INCLUDE_PER_HOST_METRICS . equals ( part ) ) { includePerHostMetrics = true ; } else if ( ! useSingleMetricNamespace && USE_SINGLE_METRIC_NAMESPACE . equals ( part ) ) { useSingleMetricNamespace = true ; } else if ( ! enableHttpSocketReadMetric && ENABLE_HTTP_SOCKET_READ_METRIC . equals ( part ) ) { enableHttpSocketReadMetric = true ; } else { String [ ] pair = part . split ( " = " ) ; if ( pair . length == 2 ) { String key = pair [ 0 ] . trim ( ) ; String value = pair [ 1 ] . trim ( ) ; try { if ( AWS_CREDENTIAL_PROPERTIES_FILE . equals ( key ) ) { setCredentialFile0 ( value ) ; } else if ( CLOUDWATCH_REGION . equals ( key ) ) { region = RegionUtils . getRegion ( value ) ; } else if ( METRIC_QUEUE_SIZE . equals ( key ) ) { Integer i = Integer . valueOf ( value ) ; if ( i . intValue ( ) < 1 ) throw new IllegalArgumentException ( METRIC_QUEUE_SIZE + " ▁ must ▁ be ▁ at ▁ least ▁ 1" ) ; metricQueueSize = i ; } else if ( QUEUE_POLL_TIMEOUT_MILLI . equals ( key ) ) { Long i = Long . valueOf ( value ) ; if ( i . intValue ( ) < 1000 ) throw new IllegalArgumentException ( QUEUE_POLL_TIMEOUT_MILLI + " ▁ must ▁ be ▁ at ▁ least ▁ 1000" ) ; queuePollTimeoutMilli = i ; } else if ( METRIC_NAME_SPACE . equals ( key ) ) { metricNameSpace = value ; } else if ( JVM_METRIC_NAME . equals ( key ) ) { jvmMetricName = value ; } else if ( HOST_METRIC_NAME . equals ( key ) ) { hostMetricName = value ; } else { LogFactory . getLog ( AwsSdkMetrics . class ) . debug ( " Ignoring ▁ unrecognized ▁ parameter : ▁ " + part ) ; } } catch ( Exception e ) { LogFactory . getLog ( AwsSdkMetrics . class ) . debug ( " Ignoring ▁ failure " , e ) ; } } } } machineMetricsExcluded = excludeMachineMetrics ; perHostMetricsIncluded = includePerHostMetrics ; singleMetricNamespace = useSingleMetricNamespace ; httpSocketReadMetricEnabled = enableHttpSocketReadMetric ; }
aws/aws-sdk-java | catch ( Exception ex ) { LogFactory . getLog ( AwsSdkMetrics . class ) . warn ( " " , ex ) ; }
aws/aws-sdk-java | synchronized ( AwsSdkMetrics . class ) { credentialProvider = new AWSCredentialsProvider ( ) { @ Override public void refresh ( ) { } @ Override public AWSCredentials getCredentials ( ) { return cred ; } } ; AwsSdkMetrics . credentialFile = filepath ; }
aws/aws-sdk-java | MetricRegistry ( ) { metricTypes . add ( Field . ClientExecuteTime ) ; metricTypes . add ( Field . Exception ) ; metricTypes . add ( Field . ThrottleException ) ; metricTypes . add ( Field . HttpClientRetryCount ) ; metricTypes . add ( Field . HttpRequestTime ) ; metricTypes . add ( Field . RequestCount ) ; metricTypes . add ( Field . RetryCount ) ; metricTypes . add ( Field . RetryCapacityConsumed ) ; metricTypes . add ( Field . ThrottledRetryCount ) ; metricTypes . add ( Field . HttpClientSendRequestTime ) ; metricTypes . add ( Field . HttpClientReceiveResponseTime ) ; metricTypes . add ( Field . HttpSocketReadTime ) ; metricTypes . add ( Field . HttpClientPoolAvailableCount ) ; metricTypes . add ( Field . HttpClientPoolLeasedCount ) ; metricTypes . add ( Field . HttpClientPoolPendingCount ) ; metricTypes . add ( AWSServiceMetrics . HttpClientGetConnectionTime ) ; syncReadOnly ( ) ; }
aws/aws-sdk-java | private void syncReadOnly ( ) { readOnly = Collections . unmodifiableSet ( new HashSet < MetricType > ( metricTypes ) ) ; }
aws/aws-sdk-java | public boolean addMetricType ( MetricType type ) { synchronized ( metricTypes ) { boolean added = metricTypes . add ( type ) ; if ( added ) syncReadOnly ( ) ; return added ; } }
aws/aws-sdk-java | public < T extends MetricType > boolean addMetricTypes ( Collection < T > types ) { synchronized ( metricTypes ) { boolean added = metricTypes . addAll ( types ) ; if ( added ) syncReadOnly ( ) ; return added ; } }
aws/aws-sdk-java | public < T extends MetricType > void setMetricTypes ( Collection < T > types ) { synchronized ( metricTypes ) { if ( types == null || types . size ( ) == 0 ) { if ( metricTypes . size ( ) == 0 ) return ; if ( types == null ) types = Collections . emptyList ( ) ; } metricTypes . clear ( ) ; if ( ! addMetricTypes ( types ) ) { syncReadOnly ( ) ; } } }
aws/aws-sdk-java | public boolean removeMetricType ( MetricType type ) { synchronized ( metricTypes ) { boolean removed = metricTypes . remove ( type ) ; if ( removed ) syncReadOnly ( ) ; return removed ; } }
aws/aws-sdk-java | public Set < MetricType > predefinedMetrics ( ) { return readOnly ; }
saga810203/jfw | public AbstractJobInfo ( String pId , String pName , String pDescrption , boolean pMoreRunning , JobSchedulerMode pJsm ) { this . name = pName ; this . jobId = pId ; this . descrption = pDescrption ; this . jsm = pJsm ; this . moreRunning = pMoreRunning ; }
saga810203/jfw | @ Override synchronized public JobInfo cloneJobInfo ( ) { ReadOnlyJobInfo roji = new ReadOnlyJobInfo ( this . jobId , this . name , this . descrption , this . moreRunning , this . jsm ) ; roji . actived = this . actived ; roji . errorReason = this . errorReason ; roji . firstBeginTime = this . firstBeginTime ; roji . firstEndTime = this . firstEndTime ; roji . lastBeginTime = this . lastBeginTime ; roji . lastEndTime = this . lastEndTime ; roji . lastErrorTime = this . lastErrorTime ; roji . lastHandleDataTime = this . lastHandleDataTime ; roji . lastThrowable = this . lastThrowable ; roji . nextRunningTime = this . nextRunningTime ; roji . noHandleDataReason = this . noHandleDataReason ; roji . noHandleDataTime = this . noHandleDataTime ; roji . numForFailrue = this . numForFailrue ; roji . numForHandleData = this . numForHandleData ; roji . numForRunning = this . numForRunning ; return roji ; }
saga810203/jfw | @ Override public String getLastErrorReason ( ) { return this . errorReason ; }
saga810203/jfw | @ Override public String getLastNoHandleDataReason ( ) { return this . noHandleDataReason ; }
saga810203/jfw | @ Override public long getNextRunningTime ( ) { return this . nextRunningTime ; }
saga810203/jfw | @ Override public long getNumForRunning ( ) { return this . numForRunning ; }
saga810203/jfw | @ Override public long getNumForHandleData ( ) { return this . numForHandleData ; }
saga810203/jfw | @ Override public long getNumForFailrue ( ) { return this . numForFailrue ; }
saga810203/jfw | @ Override public long getLastEndTime ( ) { return 0 ; }
saga810203/jfw | @ Override public long getLastHandleDataTime ( ) { return this . lastHandleDataTime ; }
saga810203/jfw | @ Override synchronized public void updateJobInfoBeforeExecuted ( ReadableExecutedInfo rei ) { if ( this . firstBeginTime == - 1 ) this . firstBeginTime = rei . getBeginTime ( ) ; this . lastBeginTime = rei . getBeginTime ( ) ; this . updateNextRunningTime ( true ) ; }
saga810203/jfw | @ Override public long getLastErrorTime ( ) { return this . lastErrorTime ; }
saga810203/jfw | @ Override public Throwable getLastThrowable ( ) { return this . lastThrowable ; }
saga810203/jfw | @ Override public String getId ( ) { return this . jobId ; }
saga810203/jfw | @ Override public String getName ( ) { return this . name ; }
saga810203/jfw | @ Override public boolean isActived ( ) { return this . actived ; }
saga810203/jfw | @ Override public void active ( boolean isActived ) { this . actived = isActived ; }
saga810203/jfw | @ Override public String getDescrption ( ) { return this . descrption ; }
saga810203/jfw | @ Override synchronized public void updateJobInfoAfterExecuted ( ReadableExecutedInfo rei ) { if ( this . firstEndTime == - 1 ) this . firstEndTime = rei . getEndTime ( ) ; this . lastEndTime = rei . getEndTime ( ) ; if ( this . lastEndTime == - 1 ) this . lastEndTime = System . currentTimeMillis ( ) ; ++ numForRunning ; if ( ! rei . isSuccessTermination ( ) ) { ++ numForFailrue ; this . lastErrorTime = this . lastEndTime ; this . lastThrowable = rei . getFailureException ( ) ; this . errorReason = rei . getFailureReason ( ) ; } if ( rei . isHanlded ( ) ) { ++ numForHandleData ; this . lastHandleDataTime = this . lastEndTime ; } else { this . noHandleDataReason = rei . getNotHandledReason ( ) ; this . noHandleDataTime = this . lastEndTime ; } updateNextRunningTime ( false ) ; }
saga810203/jfw | @ Override public boolean isMoreRunningJob ( ) { return this . moreRunning ; }
saga810203/jfw | @ Override public JobSchedulerMode getJobSchedulerMode ( ) { return this . jsm ; }
saga810203/jfw | @ Override public long getLastNoHandleDataTime ( ) { return this . noHandleDataTime ; }
saga810203/jfw | @ Override public long getLastBeginTime ( ) { return this . lastBeginTime ; }
OpenConext/OpenConext-api | if ( ! openSAMLContext . isSAMLResponse ( req ) ) { LOG . debug ( " Request ▁ is ▁ not ▁ a ▁ SAML ▁ response . ▁ Will ▁ continue ▁ filter ▁ chain . " ) ; chain . doFilter ( request , response ) ; return ; }
OpenConext/OpenConext-api | catch ( IOException e ) { LOG . info ( " Cannot ▁ redirect ▁ to ▁ original ▁ url " , e ) ; }
OpenConext/OpenConext-api | protected Object getPreAuthenticatedPrincipal ( HttpServletRequest request ) { if ( ! openSAMLContext . isSAMLResponse ( request ) ) { return null ; } Response samlResponse = openSAMLContext . extractSamlResponse ( request ) ; final UserDetails ud = openSAMLContext . authenticate ( samlResponse ) ; Assert . notNull ( ud , " Authentication ▁ using ▁ a ▁ saml ▁ response ▁ should ▁ always ▁ yield ▁ a ▁ UserDetails . " ) ; return new ClientMetaDataPrincipal ( ud . getUsername ( ) ) ; }
linkedin/PalDB | private StoreImpl ( ) { }
lime-company/lime-security-powerauth-webauth | public AuthenticationContext ( ) { }
lime-company/lime-security-powerauth-webauth | public AuthenticationContext ( PasswordProtectionType passwordProtection , String cipherTransformation ) { this . passwordProtection = passwordProtection ; this . cipherTransformation = cipherTransformation ; }
lime-company/lime-security-powerauth-webauth | public AuthenticationContext ( PasswordProtectionType passwordProtection , String cipherTransformation , SmsAuthorizationResult smsAuthorizationResult ) { this . passwordProtection = passwordProtection ; this . cipherTransformation = cipherTransformation ; this . smsAuthorizationResult = smsAuthorizationResult ; }
lime-company/lime-security-powerauth-webauth | public PasswordProtectionType getPasswordProtection ( ) { return passwordProtection ; }
lime-company/lime-security-powerauth-webauth | public void setPasswordProtection ( PasswordProtectionType passwordProtection ) { this . passwordProtection = passwordProtection ; }
lime-company/lime-security-powerauth-webauth | public String getCipherTransformation ( ) { return cipherTransformation ; }
lime-company/lime-security-powerauth-webauth | public void setCipherTransformation ( String cipherTransformation ) { this . cipherTransformation = cipherTransformation ; }
lime-company/lime-security-powerauth-webauth | public SmsAuthorizationResult getSmsAuthorizationResult ( ) { return smsAuthorizationResult ; }
lime-company/lime-security-powerauth-webauth | public void setSmsAuthorizationResult ( SmsAuthorizationResult smsAuthorizationResult ) { this . smsAuthorizationResult = smsAuthorizationResult ; }
ZiglioNZ/construct | i ++ ) { byte [ ] bin = int_to_bin ( i , 8 ) ; _char_to_bin [ i ] = bin ; }
Springws/Springweather | public int getErrNum ( ) { return errNum ; }
Springws/Springweather | public void setErrNum ( int errNum ) { this . errNum = errNum ; }
Springws/Springweather | public RetDataInfo getRetData ( ) { return retData ; }
Springws/Springweather | public void setRetData ( RetDataInfo retData ) { this . retData = retData ; }
Springws/Springweather | public String getErrMsg ( ) { return errMsg ; }
Springws/Springweather | public void setErrMsg ( String errMsg ) { this . errMsg = errMsg ; }
javidcf/masmusic | public MusicInputTracker ( ) { onsets = new ArrayList < > ( ) ; }
javidcf/masmusic | @ Override public String getStatementQuery ( ) { return " select " + " ▁ noteOnset ( * ) ▁ as ▁ onset " + " ▁ from ▁ TimeSpanNote . win : time ( " + ANALYSIS_WINDOW + " ▁ msec ) ▁ " + " ▁ output ▁ snapshot ▁ every ▁ " + ANALYSIS_FREQUENCY + " ▁ msec " + " ▁ order ▁ by ▁ timestamp ▁ asc " ; }
javidcf/masmusic | public void updateStart ( int countNew , int countOld ) { onsets . clear ( ) ; }
javidcf/masmusic | public void update ( Map < String , Onset > eventMap ) { onsets . add ( eventMap . get ( " onset " ) ) ; }
javidcf/masmusic | public void updateEnd ( ) { if ( ! onsets . isEmpty ( ) ) { publisher . publishEvent ( new MusicInputBufferUpdatedEvent ( this , onsets ) ) ; } }
noties/Storm2.0 | @ Test public void testNullCursor ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( null , null ) ; assertTrue ( iterator . isClosed ( ) ) ; assertTrue ( iterator . getCount ( ) == 0 ) ; assertTrue ( ! iterator . hasNext ( ) ) ; try { iterator . get ( 0 ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } try { iterator . next ( ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | @ Test public void testRemove ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( null , null ) ; try { iterator . remove ( ) ; assertTrue ( false ) ; } catch ( UnsupportedOperationException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | public void testBaseCursor ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { private boolean mIsClosed ; @ Override public int getCount ( ) { return 5 ; } @ Override public boolean moveToPosition ( int position ) { return position < 5 ; } @ Override public void close ( ) { mIsClosed = true ; } @ Override public boolean isClosed ( ) { return mIsClosed ; } } , null ) ; assertTrue ( iterator . hasNext ( ) ) ; assertTrue ( ! iterator . isClosed ( ) ) ; assertTrue ( iterator . getCount ( ) == 5 ) ; try { iterator . get ( 5 ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } iterator . close ( ) ; assertTrue ( ! iterator . hasNext ( ) ) ; assertTrue ( iterator . isClosed ( ) ) ; assertTrue ( iterator . getCount ( ) == 0 ) ; try { iterator . next ( ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | @ Test public void testWithParser ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { @ Override public int getCount ( ) { return 3 ; } @ Override public boolean moveToPosition ( int position ) { return position < 3 ; } } , new CursorIteratorParser < Object > ( ) { @ Override public Object parse ( Cursor cursor ) { return new Object ( ) ; } } ) ; Object o ; for ( int i = 0 , count = iterator . getCount ( ) ; i < count ; i ++ ) { o = iterator . get ( i ) ; assertTrue ( o != null ) ; } try { iterator . get ( 3 ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | @ Test public void testForEach ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { @ Override public int getCount ( ) { return 2 ; } @ Override public boolean moveToPosition ( int position ) { return position < 2 ; } } , new CursorIteratorParser < Object > ( ) { @ Override public Object parse ( Cursor cursor ) { return new Object ( ) ; } } ) ; int iterated = 0 ; for ( Object o : iterator ) { iterated ++ ; } assertTrue ( iterated == 2 ) ; }
noties/Storm2.0 | @ Test public void testNullParser ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { @ Override public int getCount ( ) { return 4 ; } @ Override public boolean moveToPosition ( int position ) { return position < 4 ; } } , null ) ; try { for ( Object o : iterator ) { ; } assertTrue ( false ) ; } catch ( NullPointerException e ) { assertTrue ( true ) ; } }
Anadyr/OSRSe | public XTEA ( int [ ] xtea_keys , byte [ ] bytes , int startOffset ) { this . keys = xtea_keys ; this . data = bytes ; this . startOffset = startOffset ; }
Anadyr/OSRSe | public byte [ ] decipher ( ) { int offset = startOffset ; int length = data . length - startOffset ; int qword_count = ( length - offset ) / 8 ; ByteBuffer inbb = ByteBuffer . wrap ( data ) ; ByteBuffer outbb = ByteBuffer . allocate ( data . length ) ; for ( int i = 0 ; i < startOffset ; i ++ ) { outbb . put ( inbb . get ( ) ) ; } for ( int qword_pos = 0 ; qword_pos < qword_count ; qword_pos ++ ) { int dword_1 = inbb . getInt ( ) ; int dword_2 = inbb . getInt ( ) ; int const_1 = - 957401312 ; int const_2 = - 1640531527 ; int run_count = 32 ; while ( ( run_count -- ^ 0xffffffff ) < - 1 ) { dword_2 -= ( ( dword_1 >>> - 1563092443 ^ dword_1 << 611091524 ) + dword_1 ^ const_1 + keys [ const_1 >>> - 1002502837 & 0x56c00003 ] ) ; const_1 -= const_2 ; dword_1 -= ( ( dword_2 >>> 1337206757 ^ dword_2 << 363118692 ) - - dword_2 ^ const_1 + keys [ const_1 & 0x3 ] ) ; } outbb . putInt ( dword_1 ) ; outbb . putInt ( dword_2 ) ; } byte [ ] remaining = new byte [ inbb . remaining ( ) ] ; inbb . get ( remaining ) ; outbb . put ( remaining ) ; outbb . flip ( ) ; return outbb . array ( ) ; }
Anadyr/OSRSe | private void decipher ( int [ ] block ) { long sum = ( long ) SUM ; for ( int i = 0 ; i < NUM_ROUNDS ; i ++ ) { block [ 1 ] -= ( keys [ ( int ) ( ( sum & 0x1933 ) >>> 11 ) ] + sum ^ block [ 0 ] + ( block [ 0 ] << 4 ^ block [ 0 ] >>> 5 ) ) ; sum -= DELTA ; block [ 0 ] -= ( ( block [ 1 ] << 4 ^ block [ 1 ] >>> 5 ) + block [ 1 ] ^ keys [ ( int ) ( sum & 0x3 ) ] + sum ) ; } }
Anadyr/OSRSe | public byte [ ] decrypt ( int length ) { int numBlocks = length / 8 ; int [ ] block = new int [ 2 ] ; for ( int i = 0 ; i < numBlocks ; i ++ ) { block [ 0 ] = StreamUtilities . readInt ( ( i * 8 ) + startOffset , data ) ; block [ 1 ] = StreamUtilities . readInt ( ( i * 8 ) + startOffset + 4 , data ) ; decipher ( block ) ; StreamUtilities . writeInt ( block [ 0 ] , ( i * 8 ) + startOffset , data ) ; StreamUtilities . writeInt ( block [ 1 ] , ( i * 8 ) + startOffset + 4 , data ) ; } return data ; }
Team4761/TShirt-Cannon | public AlignGatling ( ) { requires ( Robot . cannonSubsystem ) ; }
Team4761/TShirt-Cannon | protected void initialize ( ) { Robot . cannonSubsystem . PID = false ; }
Team4761/TShirt-Cannon | protected void execute ( ) { Robot . cannonSubsystem . spinGatling ( 0.5 ) ; }
Team4761/TShirt-Cannon | protected boolean isFinished ( ) { return Robot . cannonSubsystem . getAligned ( ) ; }
Team4761/TShirt-Cannon | protected void end ( ) { Robot . cannonSubsystem . spinGatling ( 0 ) ; }
Team4761/TShirt-Cannon | protected void interrupted ( ) { Robot . cannonSubsystem . spinGatling ( 0 ) ; }
username115/FRCScouting | @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { setPreferencesFromResource ( R . xml . mainprefs , rootKey ) ; passP = findPreference ( " passPref " ) ; urlP = findPreference ( " databaseURLPref " ) ; syncPreference = findPreference ( " enableSyncPref " ) ; passP . setOnPreferenceChangeListener ( new onPassChangeListener ( true ) ) ; urlP . setOnPreferenceChangeListener ( new onPassChangeListener ( false ) ) ; syncPreference . setOnPreferenceChangeListener ( new OnSyncChangeListener ( ) ) ; findPreference ( " syncFreqPref " ) . setEnabled ( getAutoSync ( getPreferenceManager ( ) . getContext ( ) , false ) ) ; eventP = findPreference ( " eventPref " ) ; db = new DB ( getPreferenceManager ( ) . getContext ( ) , binder ) ; List < String > events = db . getEventList ( ) ; if ( events != null ) updateEventPreference ( events ) ; Intent intent = new Intent ( getPreferenceManager ( ) . getContext ( ) , DBSyncService . class ) ; getPreferenceManager ( ) . getContext ( ) . bindService ( intent , watcher , Context . BIND_AUTO_CREATE ) ; }
username115/FRCScouting | @ Override public void onDestroyView ( ) { super . onDestroyView ( ) ; unbindDB ( ) ; }
username115/FRCScouting | public void unbindDB ( ) { getPreferenceManager ( ) . getContext ( ) . unbindService ( watcher ) ; }
username115/FRCScouting | public void onServiceConnected ( ComponentName name , IBinder service ) { if ( service instanceof LocalBinder ) { binder = ( LocalBinder ) service ; db . setBinder ( binder ) ; } }
username115/FRCScouting | public void onServiceDisconnected ( ComponentName name ) { }
username115/FRCScouting | private void updateEventPreference ( List < String > events ) { if ( ! events . isEmpty ( ) ) { Collections . sort ( events ) ; String [ ] entries = events . toArray ( new String [ 0 ] ) ; eventP . setEntries ( entries ) ; eventP . setEntryValues ( entries ) ; } }
username115/FRCScouting | public onPassChangeListener ( boolean pass ) { isPass = pass ; }
username115/FRCScouting | public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( isPass ) { DB db = new DB ( getPreferenceManager ( ) . getContext ( ) , null ) ; db . checkPass ( newValue . toString ( ) , new PasswordCallback ( true ) ) ; } else { String ret = newValue . toString ( ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } binder . refreshNotification ( ret ) ; } return true ; }
username115/FRCScouting | @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( ! ( newValue instanceof Boolean ) ) return false ; Boolean checked = ( Boolean ) newValue ; findPreference ( " syncFreqPref " ) . setEnabled ( checked ) ; return true ; }
username115/FRCScouting | public PasswordCallback ( boolean pass ) { isPass = pass ; }
username115/FRCScouting | @ Override public void onResponse ( @ NonNull String resp ) { Toast toast ; try { if ( resp . contains ( " success " ) ) { toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Password ▁ confirmed " , Toast . LENGTH_SHORT ) ; if ( binder != null ) { binder . setPassword ( getSavedPassword ( getPreferenceManager ( ) . getContext ( ) ) ) ; binder . initSync ( ) ; } } else toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Invalid ▁ password " , Toast . LENGTH_SHORT ) ; } catch ( Exception e ) { toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Invalid ▁ password " , Toast . LENGTH_SHORT ) ; } if ( isPass ) toast . show ( ) ; }
username115/FRCScouting | @ Override public void onError ( @ NonNull VolleyError e ) { Toast toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Cannot ▁ connect ▁ to ▁ Server " , Toast . LENGTH_SHORT ) ; toast . show ( ) ; }
hs71122/qualify-me | @ Test public void contextLoads ( ) { }
ngerakines/elasticservices | @ Bean public MessageFactory gossipMessageFactory ( ) { return new DefaultMessageFactory ( ImmutableList . < Message > of ( GossipServiceProto . ComponentOnline . getDefaultInstance ( ) , GossipServiceProto . ComponentStatus . getDefaultInstance ( ) ) ) ; }
ngerakines/elasticservices | @ Bean public ServiceProto . ServiceRef gossipServiceRef ( ) { return ServiceProto . ServiceRef . newBuilder ( ) . setComponentRef ( localComponentRef ) . setServiceId ( " gossip " ) . build ( ) ; }
ngerakines/elasticservices | @ Bean public TestPresenceListener testPresenceListener ( ) { return new TestPresenceListener ( ) ; }
ngerakines/elasticservices | @ Bean public Service gossipService ( ) { final List < ServicePresenceListener > servicePresenceListeners = Lists . newArrayList ( ) ; if ( serviceRegistry instanceof DefaultServiceRegistry ) { servicePresenceListeners . add ( ( ServicePresenceListener ) serviceRegistry ) ; } servicePresenceListeners . add ( testPresenceListener ( ) ) ; return new GossipService ( gossipMessageFactory ( ) , gossipServiceRef ( ) , servicePresenceListeners ) ; }
ngerakines/elasticservices | @ Bean public Work broadcastWork ( ) { return new BroadcastWork ( gossipServiceRef ( ) , serviceRegistry ) ; }
ngerakines/elasticservices | @ Bean public Ref mockGossipTransportRef ( ) { return RefUtils . localTransportRef ( " gossip " ) ; }
ngerakines/elasticservices | @ Bean public Transport mockGossipTransport ( ) { final Transport transport = mock ( Transport . class ) ; when ( transport . getRef ( ) ) . thenReturn ( mockGossipTransportRef ( ) ) ; return transport ; }
ngerakines/elasticservices | @ PostConstruct public void registerService ( ) { serviceRegistry . registerService ( gossipService ( ) , mockGossipTransport ( ) ) ; if ( localTransportClientFactory instanceof LocalTransportClientFactory ) { final LocalTransportClientFactory localTransportClientFactoryImpl = ( LocalTransportClientFactory ) localTransportClientFactory ; localTransportClientFactoryImpl . addService ( " gossip " , gossipService ( ) ) ; } serviceRegistry . initTransportClient ( gossipServiceRef ( ) , mockGossipTransportRef ( ) ) ; }
ngerakines/elasticservices | @ Test public void load ( ) { Assert . assertNotNull ( gossipService ) ; Assert . assertTrue ( waitUntil ( new Callable < Integer > ( ) { @ Override public Integer call ( ) throws Exception { return testPresenceListener . getCount ( ) ; } } , 3 , 60 ) ) ; Assert . assertTrue ( testPresenceListener . getCount ( ) > 0 ) ; }
ngerakines/elasticservices | private < T > boolean waitUntil ( final Callable < T > callable , final T value , final int seconds ) { final DateTime start = DateTime . now ( ) ; while ( DateTime . now ( ) . isBefore ( start . plusSeconds ( seconds ) ) ) { try { if ( callable . call ( ) . equals ( value ) ) { return true ; } Thread . sleep ( TimeUnit . SECONDS . toMillis ( 1 ) ) ; } catch ( final Exception e ) { return false ; } } return false ; }
ngerakines/elasticservices | @ Override public void updateComponentServices ( final ServiceProto . ComponentRef componentRef , final Multimap < ServiceProto . ServiceRef , String > services , final Multimap < ServiceProto . ServiceRef , Integer > serviceFlags ) { LOGGER . info ( " counter ▁ now ▁ at ▁ { } . " , counter . incrementAndGet ( ) ) ; }
ngerakines/elasticservices | public int getCount ( ) { return counter . get ( ) ; }
google/binnavi | public CInstructionUpdater ( final ZyGraph graph ) { m_graph = graph ; }
google/binnavi | private void rebuildNode ( ) { m_realizer . regenerate ( ) ; m_graph . updateViews ( ) ; }
google/binnavi | @ Override public void appendedComment ( final IInstruction instruction , final IComment comment ) { rebuildNode ( ) ; }
google/binnavi | @ Override public void deletedComment ( final IInstruction instruction , final IComment comment ) { rebuildNode ( ) ; }
google/binnavi | @ Override public void editedComment ( final IInstruction instruction , final IComment comment ) { rebuildNode ( ) ; }
google/binnavi | @ Override public void initializedComment ( final IInstruction instruction , final List < IComment > comment ) { rebuildNode ( ) ; }
google/binnavi | public void setRealizer ( final IZyNodeRealizer realizer ) { m_realizer = realizer ; }
fr0609/SeriesGuide | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_extensions_configure ) ; setupActionBar ( ) ; if ( getIntent ( ) . hasExtra ( SeriesGuideExtension . EXTRA_FROM_SERIESGUIDE_SETTINGS ) ) { if ( savedInstanceState == null ) { AmazonConfigurationFragment f = new AmazonConfigurationFragment ( ) ; android . app . FragmentTransaction ft = getFragmentManager ( ) . beginTransaction ( ) ; ft . add ( R . id . content_frame , f ) ; ft . commit ( ) ; } } else { if ( savedInstanceState == null ) { ExtensionsConfigurationFragment f = new ExtensionsConfigurationFragment ( ) ; FragmentTransaction ft = getSupportFragmentManager ( ) . beginTransaction ( ) ; ft . add ( R . id . content_frame , f ) ; ft . commit ( ) ; } } }
fr0609/SeriesGuide | private void setupActionBar ( ) { ActionBar actionBar = getActionBar ( ) ; actionBar . setTitle ( R . string . action_extensions_configure ) ; actionBar . setDisplayHomeAsUpEnabled ( true ) ; }
fr0609/SeriesGuide | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int itemId = item . getItemId ( ) ; if ( itemId == android . R . id . home ) { onBackPressed ( ) ; return true ; } return super . onOptionsItemSelected ( item ) ; }
Dragon-Boat/openAndroid | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_home ) ; $ ( R . id . swapAdapter ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { getFragmentManager ( ) . beginTransaction ( ) . add ( android . R . id . content , SwapAdapterDemoFragment . instance ( ) , " " ) . addToBackStack ( " " ) . commit ( ) ; } } ) ; }
Dragon-Boat/openAndroid | @ Override public void onClick ( View v ) { }
jk1/intellij-community | private PyTypeChecker ( ) { }
jk1/intellij-community | public MatchContext ( @ NotNull TypeEvalContext context , @ NotNull Map < PyGenericType , PyType > substitutions ) { this ( context , substitutions , true , new HashSet < > ( ) ) ; }
jk1/intellij-community | private MatchContext ( @ NotNull TypeEvalContext context , @ NotNull Map < PyGenericType , PyType > substitutions , boolean recursive , @ NotNull Set < Pair < PyType , PyType > > matching ) { this . context = context ; this . substitutions = substitutions ; this . recursive = recursive ; this . matching = matching ; }
jk1/intellij-community | @ NotNull public MatchContext notRecursive ( ) { return new MatchContext ( context , substitutions , false , matching ) ; }
kasperdokter/Reo | public volatile QueueableHandler masterHandler = new QueueableHandler ( new Semaphore ( 1 ) , new QueueableHandlersQueue ( 1 ) ) { @ Override public boolean call ( ) { return false ; } }
kasperdokter/Reo | public void kickMaster ( ) { masterHandler . flag ( ) ; masterHandler . callAsync ( ) ; }
ButterflyNetwork/bazel | private ActionCacheTestHelper ( ) { }
mkl-software/websuites | public CheckAttributeValueContainingCommand ( String attribute ) { super ( attribute ) ; }
mkl-software/websuites | @ Override protected String getPredicateString ( ) { return " arguments [ 0 ] . attributes [ i ] . value ▁ ! = ▁ null ▁ & & ▁ " + " arguments [ 0 ] . attributes [ i ] . value . indexOf ( arguments [ 1 ] ) ▁ ! = ▁ - 1" ; }
mkl-software/websuites | @ Override protected void runSingleStringAssertion ( StringAssert assertion , String string ) { assertion . overridingErrorMessage ( " The ▁ attribute ▁ with ▁ value ▁ containing ▁ ' % s ' ▁ is ▁ expected ▁ to ▁ appear ▁ somewhere ▁ on ▁ the ▁ page ▁ " + " ( in ▁ any ▁ element ) " , attribute ) . isEqualTo ( " OK " ) ; }
topsale/leesite | public TwoDimensionCodeImage ( BufferedImage bufImg ) { this . bufImg = bufImg ; }
topsale/leesite | @ Override public int getHeight ( ) { return bufImg . getHeight ( ) ; }
topsale/leesite | @ Override public int getPixel ( int x , int y ) { return bufImg . getRGB ( x , y ) ; }
topsale/leesite | @ Override public int getWidth ( ) { return bufImg . getWidth ( ) ; }
tzou24/BPS | protected ListInfo getDataList ( String sortKey , boolean desc , long offset , int maxItem ) { ListInfo listInfo = new ListInfo ( ) ; ParsedPoolman poolman = PoolmanHelper . getParsedPoolman ( ) ; ParsedDataSource dataSource = ( ParsedDataSource ) poolman . getDataSourceList ( ) . get ( ( int ) offset ) ; List list = new ArrayList ( ) ; list . add ( dataSource ) ; listInfo . setDatas ( list ) ; listInfo . setTotalSize ( poolman . getDataSourceList ( ) . size ( ) ) ; return listInfo ; }
tzou24/BPS | protected ListInfo getDataList ( String sortKey , boolean desc ) { return null ; }
Dhandapani/gluster-ovirt | public DiskImageDynamic ( ) { }
Dhandapani/gluster-ovirt | @ XmlElement public Integer getread_rate ( ) { return readRate ; }
Dhandapani/gluster-ovirt | public void setread_rate ( Integer rate ) { readRate = rate ; }
Dhandapani/gluster-ovirt | @ XmlElement public Integer getwrite_rate ( ) { return writeRate ; }
Dhandapani/gluster-ovirt | public void setwrite_rate ( Integer rate ) { writeRate = rate ; }
Dhandapani/gluster-ovirt | @ XmlElement ( name = " ReadLatency " ) public Double getReadLatency ( ) { return readLatency ; }
Dhandapani/gluster-ovirt | public void setReadLatency ( Double readLatency ) { this . readLatency = readLatency ; }
Dhandapani/gluster-ovirt | @ XmlElement ( name = " WriteLatency " ) public Double getWriteLatency ( ) { return writeLatency ; }
Dhandapani/gluster-ovirt | public void setWriteLatency ( Double writeLatency ) { this . writeLatency = writeLatency ; }
Dhandapani/gluster-ovirt | @ XmlElement ( name = " FlushLatency " ) public Double getFlushLatency ( ) { return flushLatency ; }
Dhandapani/gluster-ovirt | public void setFlushLatency ( Double flushLatency ) { this . flushLatency = flushLatency ; }
Dhandapani/gluster-ovirt | @ XmlElement public long getactual_size ( ) { return this . actualSize ; }
Dhandapani/gluster-ovirt | public void setactual_size ( long size ) { this . actualSize = size ; OnPropertyChanged ( new PropertyChangedEventArgs ( " actual _ size " ) ) ; }
Dhandapani/gluster-ovirt | protected void OnPropertyChanged ( PropertyChangedEventArgs e ) { }
Dhandapani/gluster-ovirt | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( int ) ( actualSize ^ ( actualSize >>> 32 ) ) ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; result = prime * result + ( ( readRate == null ) ? 0 : readRate . hashCode ( ) ) ; result = prime * result + ( ( writeRate == null ) ? 0 : writeRate . hashCode ( ) ) ; result = prime * result + ( ( writeLatency == null ) ? 0 : writeLatency . hashCode ( ) ) ; result = prime * result + ( ( readLatency == null ) ? 0 : readLatency . hashCode ( ) ) ; result = prime * result + ( ( flushLatency == null ) ? 0 : flushLatency . hashCode ( ) ) ; return result ; }
Dhandapani/gluster-ovirt | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; DiskImageDynamic other = ( DiskImageDynamic ) obj ; if ( actualSize != other . actualSize ) return false ; if ( id == null ) { if ( other . id != null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; if ( readRate == null ) { if ( other . readRate != null ) return false ; } else if ( ! readRate . equals ( other . readRate ) ) return false ; if ( writeRate == null ) { if ( other . writeRate != null ) return false ; } else if ( ! writeRate . equals ( other . writeRate ) ) return false ; if ( readLatency == null ) { if ( other . readLatency != null ) return false ; } else if ( ! readLatency . equals ( other . readLatency ) ) return false ; if ( writeLatency == null ) { if ( other . writeLatency != null ) return false ; } else if ( ! writeLatency . equals ( other . writeLatency ) ) return false ; if ( flushLatency == null ) { if ( other . flushLatency != null ) return false ; } else if ( ! flushLatency . equals ( other . flushLatency ) ) return false ; return true ; }
Dhandapani/gluster-ovirt | @ Override @ XmlElement ( name = " Id " ) @ Id @ GeneratedValue ( generator = " system - uuid " ) @ GenericGenerator ( name = " system - uuid " , strategy = " org . ovirt . engine . core . dao . GuidGenerator " ) @ Column ( name = " image _ id " ) @ Type ( type = " guid " ) public Guid getId ( ) { return id ; }
Dhandapani/gluster-ovirt | @ Override public void setId ( Guid id ) { this . id = id ; }
QualiMaster/Infrastructure | public RecordingTopologyBuilder ( ) { }
QualiMaster/Infrastructure | public RecordingTopologyBuilder ( PipelineOptions options ) { this . options = options ; }
QualiMaster/Infrastructure | public void startRecording ( String id ) { currentId = id ; }
QualiMaster/Infrastructure | private void record ( String id , Object processor ) { if ( null != currentId && null != processor ) { List < String > tmp = recording . get ( currentId ) ; if ( null == tmp ) { tmp = new ArrayList < String > ( ) ; recording . put ( currentId , tmp ) ; } tmp . add ( id + SubTopologyMonitoringEvent . SEPARATOR + processor . getClass ( ) . getName ( ) ) ; } }
QualiMaster/Infrastructure | private Number getExecutorParallelism ( String id , Number dflt ) { Number result = dflt ; if ( null != options ) { result = options . getExecutorParallelism ( id , dflt ) ; if ( DEBUG ) { LOGGER . info ( " Executors ▁ for ▁ " + id + " : ▁ " + result ) ; } } return result ; }
QualiMaster/Infrastructure | < D extends ComponentConfigurationDeclarer < ? > > D setNumTasks ( String id , D declarer , Number dflt ) { Number tasks = dflt ; if ( null != options ) { tasks = options . getTaskParallelism ( id , null ) ; } if ( null != tasks ) { if ( DEBUG ) { LOGGER . info ( " Tasks ▁ for ▁ " + id + " : ▁ " + tasks ) ; } declarer . setNumTasks ( tasks ) ; } return declarer ; }
QualiMaster/Infrastructure | private BoltDeclarer setNumTasks ( String id , BoltDeclarer declarer ) { setNumTasks ( id , declarer , null ) ; return new MyBoltGetter ( id ) ; }
QualiMaster/Infrastructure | private SpoutDeclarer setNumTasks ( String id , SpoutDeclarer declarer ) { setNumTasks ( id , declarer , null ) ; return new MySpoutGetter ( id ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IRichBolt bolt ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , null ) ) ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IRichBolt bolt , Number parallelism_hint ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , parallelism_hint ) ) ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IBasicBolt bolt ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , null ) ) ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IBasicBolt bolt , Number parallelism_hint ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , parallelism_hint ) ) ) ; }
QualiMaster/Infrastructure | @ Override public SpoutDeclarer setSpout ( String id , IRichSpout spout ) { record ( id , spout ) ; return setNumTasks ( id , super . setSpout ( id , spout , getExecutorParallelism ( id , null ) ) ) ; }
QualiMaster/Infrastructure | @ Override public SpoutDeclarer setSpout ( String id , IRichSpout spout , Number parallelism_hint ) { record ( id , spout ) ; return setNumTasks ( id , super . setSpout ( id , spout , getExecutorParallelism ( id , parallelism_hint ) ) ) ; }
QualiMaster/Infrastructure | public void endRecording ( ) { endRecording ( null ) ; }
QualiMaster/Infrastructure | public void endRecording ( ITopologyCreate topology ) { if ( null != currentId && topology instanceof IScalableTopology ) { IScalingDescriptor desc = ( ( IScalableTopology ) topology ) . getScalingDescriptor ( ) ; if ( null != desc ) { scalingDescriptors . put ( currentId , desc ) ; } } currentId = null ; }
QualiMaster/Infrastructure | public void close ( String pipelineName , @ SuppressWarnings ( " rawtypes " ) Map config ) { SubTopologyMonitoringEvent event = createClosingEvent ( pipelineName , config ) ; if ( null != event ) { EventManager . send ( event ) ; } }
QualiMaster/Infrastructure | public SubTopologyMonitoringEvent createClosingEvent ( String pipelineName , @ SuppressWarnings ( " rawtypes " ) Map config ) { SubTopologyMonitoringEvent result = null ; if ( ! recording . isEmpty ( ) ) { StormSignalConnection . configureEventBus ( config ) ; result = new SubTopologyMonitoringEvent ( pipelineName , recording , scalingDescriptors ) ; } return result ; }
QualiMaster/Infrastructure | public MyBoltGetter ( String boltId ) { super ( boltId ) ; this . boltId = boltId ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setNumTasks ( Number val ) { Number tasks = val ; if ( null != options ) { tasks = options . getTaskParallelism ( boltId , val ) ; } return super . setNumTasks ( tasks ) ; }
QualiMaster/Infrastructure | public MySpoutGetter ( String spoutId ) { super ( spoutId ) ; this . spoutId = spoutId ; }
QualiMaster/Infrastructure | @ Override public SpoutDeclarer setNumTasks ( Number val ) { Number tasks = val ; if ( null != options ) { tasks = options . getTaskParallelism ( spoutId , val ) ; } return super . setNumTasks ( tasks ) ; }
rvillablanca/java-notes | public void alimentar ( ) { System . out . println ( " Alimentando ▁ a ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; }
rvillablanca/java-notes | public void add ( T t ) { lista . add ( t ) ; }
rvillablanca/java-notes | public List < T > getLista ( ) { return lista ; }
mcaliman/dochi | public List < Object > getArgsAndGroups ( ) { if ( argsAndGroups == null ) { argsAndGroups = new ArrayList < Object > ( ) ; } return this . argsAndGroups ; }
mcaliman/dochi | public String getRole ( ) { return role ; }
mcaliman/dochi | public void setRole ( String value ) { this . role = value ; }
mcaliman/dochi | public String getId ( ) { return id ; }
mcaliman/dochi | public void setId ( String value ) { this . id = value ; }
mcaliman/dochi | public String getCommonVersion ( ) { return commonVersion ; }
mcaliman/dochi | public void setCommonVersion ( String value ) { this . commonVersion = value ; }
mcaliman/dochi | public String getXmlLang ( ) { return xmlLang ; }
mcaliman/dochi | public void setXmlLang ( String value ) { this . xmlLang = value ; }
mcaliman/dochi | public String getBase ( ) { return base ; }
mcaliman/dochi | public void setBase ( String value ) { this . base = value ; }
mcaliman/dochi | public String getRemap ( ) { return remap ; }
mcaliman/dochi | public void setRemap ( String value ) { this . remap = value ; }
mcaliman/dochi | public String getXreflabel ( ) { return xreflabel ; }
mcaliman/dochi | public void setXreflabel ( String value ) { this . xreflabel = value ; }
mcaliman/dochi | public String getRevisionflag ( ) { return revisionflag ; }
mcaliman/dochi | public void setRevisionflag ( String value ) { this . revisionflag = value ; }
mcaliman/dochi | public String getDir ( ) { return dir ; }
mcaliman/dochi | public void setDir ( String value ) { this . dir = value ; }
mcaliman/dochi | public String getArch ( ) { return arch ; }
mcaliman/dochi | public void setArch ( String value ) { this . arch = value ; }
mcaliman/dochi | public String getAudience ( ) { return audience ; }
mcaliman/dochi | public void setAudience ( String value ) { this . audience = value ; }
mcaliman/dochi | public String getCondition ( ) { return condition ; }
mcaliman/dochi | public void setCondition ( String value ) { this . condition = value ; }
mcaliman/dochi | public String getConformance ( ) { return conformance ; }
mcaliman/dochi | public void setConformance ( String value ) { this . conformance = value ; }
mcaliman/dochi | public String getOs ( ) { return os ; }
mcaliman/dochi | public void setOs ( String value ) { this . os = value ; }
mcaliman/dochi | public String getCommonRevision ( ) { return commonRevision ; }
mcaliman/dochi | public void setCommonRevision ( String value ) { this . commonRevision = value ; }
mcaliman/dochi | public String getSecurity ( ) { return security ; }
mcaliman/dochi | public void setSecurity ( String value ) { this . security = value ; }
mcaliman/dochi | public String getUserlevel ( ) { return userlevel ; }
mcaliman/dochi | public void setUserlevel ( String value ) { this . userlevel = value ; }
mcaliman/dochi | public String getVendor ( ) { return vendor ; }
mcaliman/dochi | public void setVendor ( String value ) { this . vendor = value ; }
mcaliman/dochi | public String getWordsize ( ) { return wordsize ; }
mcaliman/dochi | public void setWordsize ( String value ) { this . wordsize = value ; }
mcaliman/dochi | public String getAnnotations ( ) { return annotations ; }
mcaliman/dochi | public void setAnnotations ( String value ) { this . annotations = value ; }
mcaliman/dochi | public Object getLinkend ( ) { return linkend ; }
mcaliman/dochi | public void setLinkend ( Object value ) { this . linkend = value ; }
mcaliman/dochi | public String getHref ( ) { return href ; }
mcaliman/dochi | public void setHref ( String value ) { this . href = value ; }
mcaliman/dochi | public String getXlinkType ( ) { return xlinkType ; }
mcaliman/dochi | public void setXlinkType ( String value ) { this . xlinkType = value ; }
mcaliman/dochi | public String getXlinkRole ( ) { return xlinkRole ; }
mcaliman/dochi | public void setXlinkRole ( String value ) { this . xlinkRole = value ; }
mcaliman/dochi | public String getArcrole ( ) { return arcrole ; }
mcaliman/dochi | public void setArcrole ( String value ) { this . arcrole = value ; }
mcaliman/dochi | public String getXlinkTitle ( ) { return xlinkTitle ; }
mcaliman/dochi | public void setXlinkTitle ( String value ) { this . xlinkTitle = value ; }
mcaliman/dochi | public String getShow ( ) { return show ; }
mcaliman/dochi | public void setShow ( String value ) { this . show = value ; }
mcaliman/dochi | public String getActuate ( ) { return actuate ; }
mcaliman/dochi | public void setActuate ( String value ) { this . actuate = value ; }
codeprimate-software/cp-elements | default boolean isRunning ( ) { throw new IllegalStateException ( " The ▁ runnable ▁ state ▁ of ▁ this ▁ object ▁ cannot ▁ be ▁ determined " ) ; }
codeprimate-software/cp-elements | @ Override default T call ( ) { return execute ( ) ; }
codeprimate-software/cp-elements | @ Override default void run ( ) { execute ( ) ; }
redisson/redisson | @ Override RMultimapCache < String , String > getMultimapCache ( String name ) { return redisson . getSetMultimapCache ( name ) ; }
redisson/redisson | @ Test public void testValues ( ) throws InterruptedException { RMultimapCache < String , String > multimap = getMultimapCache ( " test " ) ; multimap . put ( "1" , "1" ) ; multimap . put ( "1" , "2" ) ; multimap . put ( "1" , "3" ) ; multimap . put ( "1" , "3" ) ; assertThat ( multimap . get ( "1" ) . size ( ) ) . isEqualTo ( 3 ) ; assertThat ( multimap . get ( "1" ) ) . containsExactlyInAnyOrder ( "1" , "2" , "3" ) ; assertThat ( multimap . get ( "1" ) . remove ( "3" ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . contains ( "3" ) ) . isFalse ( ) ; assertThat ( multimap . get ( "1" ) . contains ( "2" ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . containsAll ( Arrays . asList ( "1" ) ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . containsAll ( Arrays . asList ( "1" , "2" ) ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . retainAll ( Arrays . asList ( "1" ) ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . removeAll ( Arrays . asList ( "1" ) ) ) . isTrue ( ) ; }
summer0581/sumflow | public CompleteGeneralTaskCmd ( GeneralTaskCommand abstractCustomExpandTaskCommand ) { super ( abstractCustomExpandTaskCommand ) ; }
summer0581/sumflow | public Void execute ( CommandContext commandContext ) { loadProcessParameter ( commandContext ) ; addVariable ( ) ; runCommandExpression ( ) ; TaskInstanceEntity taskInstance = getTaskInstanceEntity ( ) ; TaskCommandInst taskCommand = getTaskCommandInst ( ) ; if ( taskInstance != null ) { taskInstance . end ( taskCommand , this . taskComment ) ; } else { throw new FixFlowException ( " 没有找到id为 : ▁ " + taskId + " ▁ 的任务 " ) ; } saveProcessInstance ( commandContext ) ; return null ; }
killme2008/xmemcached | public MockHandler ( int version , String response ) { super ( ) ; this . response = response ; this . version = version ; }
killme2008/xmemcached | @ Override public void onMessageReceived ( Session session , Object message ) { if ( message . equals ( " quit " ) ) { session . close ( ) ; return ; } session . write ( " CONFIG ▁ cluster ▁ 0 ▁ " + this . response . length ( ) ) ; session . write ( String . valueOf ( version ) + " \n " + this . response ) ; session . write ( " END " ) ; this . version ++ ; }
killme2008/xmemcached | @ Override public void setUp ( ) throws Exception { Properties properties = ResourcesUtils . getResourceAsProperties ( " test . properties " ) ; List < InetSocketAddress > addresses = AddrUtil . getAddresses ( properties . getProperty ( " test . memcached . servers " ) ) ; StringBuffer sb = new StringBuffer ( ) ; boolean wasFirst = true ; for ( InetSocketAddress addr : addresses ) { if ( wasFirst ) { wasFirst = false ; } else { sb . append ( " ▁ " ) ; } sb . append ( addr . getHostName ( ) + " | " + addr . getHostName ( ) + " | " + addr . getPort ( ) ) ; } this . addresses = addresses ; serverList = sb . toString ( ) ; }
killme2008/xmemcached | @ Test public void testInvalidConfig ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , " invalid " ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2271 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertTrue ( e . getMessage ( ) . contains ( " failed " ) ) ; } finally { configServer . stop ( ) ; } }
killme2008/xmemcached | @ Test public void testPollConfigAndUsage ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , serverList ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2271 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( addresses . size ( ) , config . getNodeList ( ) . size ( ) ) ; client . set ( " aws - cache " , 0 , " foobar " ) ; assertEquals ( " foobar " , client . get ( " aws - cache " ) ) ; } finally { configServer . stop ( ) ; } }
killme2008/xmemcached | @ Test public void testPollConfigAndUsageWithBuilder ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , serverList ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2279 ) ) ; try { AWSElasticCacheClientBuilder builder = new AWSElasticCacheClientBuilder ( new InetSocketAddress ( 2279 ) ) ; builder . setConnectionPoolSize ( 2 ) ; builder . setEnableHealSession ( false ) ; AWSElasticCacheClient client = builder . build ( ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( addresses . size ( ) , config . getNodeList ( ) . size ( ) ) ; client . set ( " aws - cache " , 0 , " foobar " ) ; assertEquals ( " foobar " , client . get ( " aws - cache " ) ) ; } finally { configServer . stop ( ) ; } }
killme2008/xmemcached | @ Test public void testPollConfigInterval ( ) throws Exception { TCPController cs1 = new TCPController ( ) ; int version = 10 ; cs1 . setHandler ( new MockHandler ( version , " localhost | localhost | 2272" ) ) ; cs1 . setCodecFactory ( new TextLineCodecFactory ( ) ) ; cs1 . bind ( new InetSocketAddress ( 2271 ) ) ; TCPController cs2 = new TCPController ( ) ; cs2 . setHandler ( new MockHandler ( version + 1 , " localhost | localhost | 2271 ▁ localhost | localhost | 2272" ) ) ; cs2 . setCodecFactory ( new TextLineCodecFactory ( ) ) ; cs2 . bind ( new InetSocketAddress ( 2272 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) , 3000 ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( 1 , config . getNodeList ( ) . size ( ) ) ; assertEquals ( 2272 , config . getNodeList ( ) . get ( 0 ) . getPort ( ) ) ; Thread . sleep ( 3500 ) ; config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version + 1 ) ; assertEquals ( 2 , config . getNodeList ( ) . size ( ) ) ; assertEquals ( 2271 , config . getNodeList ( ) . get ( 0 ) . getPort ( ) ) ; assertEquals ( 2272 , config . getNodeList ( ) . get ( 1 ) . getPort ( ) ) ; } finally { cs1 . stop ( ) ; cs2 . stop ( ) ; } }
hgschmie/presto | public PagesSerde ( BlockEncodingSerde blockEncodingSerde , Optional < Compressor > compressor , Optional < Decompressor > decompressor , Optional < SpillCipher > spillCipher ) { this . blockEncodingSerde = requireNonNull ( blockEncodingSerde , " blockEncodingSerde ▁ is ▁ null " ) ; checkArgument ( compressor . isPresent ( ) == decompressor . isPresent ( ) , " compressor ▁ and ▁ decompressor ▁ must ▁ both ▁ be ▁ present ▁ or ▁ both ▁ be ▁ absent " ) ; this . compressor = requireNonNull ( compressor , " compressor ▁ is ▁ null " ) ; this . decompressor = requireNonNull ( decompressor , " decompressor ▁ is ▁ null " ) ; this . spillCipher = requireNonNull ( spillCipher , " spillCipher ▁ is ▁ null " ) ; }
hgschmie/presto | public SerializedPage serialize ( Page page ) { SliceOutput serializationBuffer = new DynamicSliceOutput ( toIntExact ( page . getSizeInBytes ( ) + Integer . BYTES ) ) ; writeRawPage ( page , serializationBuffer , blockEncodingSerde ) ; Slice slice = serializationBuffer . slice ( ) ; int uncompressedSize = serializationBuffer . size ( ) ; MarkerSet markers = MarkerSet . empty ( ) ; if ( compressor . isPresent ( ) ) { byte [ ] compressed = new byte [ compressor . get ( ) . maxCompressedLength ( uncompressedSize ) ] ; int compressedSize = compressor . get ( ) . compress ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , uncompressedSize , compressed , 0 , compressed . length ) ; if ( ( ( ( double ) compressedSize ) / uncompressedSize ) <= MINIMUM_COMPRESSION_RATIO ) { slice = Slices . wrappedBuffer ( compressed , 0 , compressedSize ) ; markers . add ( COMPRESSED ) ; } } if ( spillCipher . isPresent ( ) ) { byte [ ] encrypted = new byte [ spillCipher . get ( ) . encryptedMaxLength ( slice . length ( ) ) ] ; int encryptedSize = spillCipher . get ( ) . encrypt ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , encrypted , 0 ) ; slice = Slices . wrappedBuffer ( encrypted , 0 , encryptedSize ) ; markers . add ( ENCRYPTED ) ; } if ( ! slice . isCompact ( ) ) { slice = Slices . copyOf ( slice ) ; } return new SerializedPage ( slice , markers , page . getPositionCount ( ) , uncompressedSize ) ; }
hgschmie/presto | public Page deserialize ( SerializedPage serializedPage ) { checkArgument ( serializedPage != null , " serializedPage ▁ is ▁ null " ) ; Slice slice = serializedPage . getSlice ( ) ; if ( serializedPage . isEncrypted ( ) ) { checkState ( spillCipher . isPresent ( ) , " Page ▁ is ▁ encrypted , ▁ but ▁ spill ▁ cipher ▁ is ▁ missing " ) ; byte [ ] decrypted = new byte [ spillCipher . get ( ) . decryptedMaxLength ( slice . length ( ) ) ] ; int decryptedSize = spillCipher . get ( ) . decrypt ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , decrypted , 0 ) ; slice = Slices . wrappedBuffer ( decrypted , 0 , decryptedSize ) ; } if ( serializedPage . isCompressed ( ) ) { checkState ( decompressor . isPresent ( ) , " Page ▁ is ▁ compressed , ▁ but ▁ decompressor ▁ is ▁ missing " ) ; int uncompressedSize = serializedPage . getUncompressedSizeInBytes ( ) ; byte [ ] decompressed = new byte [ uncompressedSize ] ; checkState ( decompressor . get ( ) . decompress ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , decompressed , 0 , uncompressedSize ) == uncompressedSize ) ; slice = Slices . wrappedBuffer ( decompressed ) ; } return readRawPage ( serializedPage . getPositionCount ( ) , slice . getInput ( ) , blockEncodingSerde ) ; }
jennyqujy/GitHubApp | @ Override public void onCreate ( Bundle savedInstanceState ) { supportRequestWindowFeature ( Window . FEATURE_PROGRESS ) ; super . onCreate ( savedInstanceState ) ; getWindow ( ) . setFeatureInt ( Window . FEATURE_PROGRESS , Window . PROGRESS_VISIBILITY_ON ) ; mWebView = new WebView ( this ) ; mWebView . loadUrl ( repo . getUrl ( ) ) ; mWebView . setWebViewClient ( new WebViewClient ( ) { @ Override public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ) ; return true ; } } ) ; this . setContentView ( mWebView ) ; }
jennyqujy/GitHubApp | @ Override public boolean onKeyDown ( final int keyCode , final KeyEvent event ) { if ( ( keyCode == KeyEvent . KEYCODE_BACK ) && mWebView . canGoBack ( ) ) { mWebView . goBack ( ) ; return true ; } return super . onKeyDown ( keyCode , event ) ; }
userKarl/sctd | @ Transient public ScStock getScStock ( ) { return scStock ; }
userKarl/sctd | public void setScStock ( ScStock scStock ) { this . scStock = scStock ; }
userKarl/sctd | @ Transient public ScFutures getScFutures ( ) { return scFutures ; }
userKarl/sctd | public void setScFutures ( ScFutures scFutures ) { this . scFutures = scFutures ; }
userKarl/sctd | @ Transient public Double getPrice ( ) { return price ; }
userKarl/sctd | public void setPrice ( Double price ) { this . price = price ; }
kawakicchi/jersey | @ Override public void filter ( final ContainerRequestContext requestContext ) throws IOException { String method = requestContext . getMethod ( ) ; if ( " POST " . equals ( method ) ) { ContainerRequest r = ( ContainerRequest ) requestContext . getRequest ( ) ; if ( MediaTypes . typeEqual ( MediaType . APPLICATION_JSON_TYPE , requestContext . getMediaType ( ) ) ) { if ( ! r . bufferEntity ( ) ) { System . out . println ( " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; } r . getEntityStream ( ) . reset ( ) ; } else if ( MediaTypes . typeEqual ( MediaType . MULTIPART_FORM_DATA_TYPE , requestContext . getMediaType ( ) ) ) { InputStream in = r . getEntityStream ( ) ; if ( in . getClass ( ) != ByteArrayInputStream . class ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ReaderWriter . writeTo ( in , baos ) ; in = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; requestContext . setEntityStream ( in ) ; } MultivaluedMap < String , String > map = new MultivaluedHashMap < String , String > ( ) ; FormDataMultiPart form = r . readEntity ( FormDataMultiPart . class ) ; Map < String , List < FormDataBodyPart > > m = form . getFields ( ) ; for ( String key : m . keySet ( ) ) { List < FormDataBodyPart > parts = form . getFields ( key ) ; for ( FormDataBodyPart part : parts ) { if ( MediaTypes . typeEqual ( MediaType . TEXT_PLAIN_TYPE , part . getMediaType ( ) ) ) { map . add ( key , part . getValue ( ) ) ; } } } ByteArrayInputStream bais = ( ByteArrayInputStream ) in ; bais . reset ( ) ; } else { if ( ! r . bufferEntity ( ) ) { } Form f = r . readEntity ( Form . class ) ; MultivaluedMap < String , String > map = f . asMap ( ) ; r . getEntityStream ( ) . reset ( ) ; } } }
vespa-engine/vespa | public CloudTrialExpirer ( Controller controller , Duration interval ) { super ( controller , interval , null , SystemName . allOf ( SystemName :: isPublic ) ) ; this . extendedTrialTenants = PermanentFlags . EXTENDED_TRIAL_TENANTS . bindTo ( controller ( ) . flagSource ( ) ) ; }
vespa-engine/vespa | @ Override protected double maintain ( ) { var expiredTenants = controller ( ) . tenants ( ) . asList ( ) . stream ( ) . filter ( this :: tenantIsCloudTenant ) . filter ( this :: tenantHasTrialPlan ) . filter ( this :: tenantIsNotExemptFromExpiry ) . filter ( this :: tenantReadersNotLoggedIn ) . filter ( this :: tenantHasNoDeployments ) . collect ( Collectors . toList ( ) ) ; if ( ! expiredTenants . isEmpty ( ) ) { var expiredTenantNames = expiredTenants . stream ( ) . map ( Tenant :: name ) . map ( TenantName :: value ) . collect ( Collectors . joining ( " , ▁ " ) ) ; log . info ( " Moving ▁ expired ▁ tenants ▁ to ▁ ' none ' ▁ plan : ▁ " + expiredTenantNames ) ; } expireTenants ( expiredTenants ) ; return 1 ; }
vespa-engine/vespa | private boolean tenantIsCloudTenant ( Tenant tenant ) { return tenant . type ( ) == Tenant . Type . cloud ; }
vespa-engine/vespa | private boolean tenantReadersNotLoggedIn ( Tenant tenant ) { return tenant . lastLoginInfo ( ) . get ( LastLoginInfo . UserLevel . user ) . map ( instant -> { var sinceLastLogin = Duration . between ( instant , controller ( ) . clock ( ) . instant ( ) ) ; return sinceLastLogin . compareTo ( loginExpiry ) > 0 ; } ) . orElse ( false ) ; }
vespa-engine/vespa | private boolean tenantHasTrialPlan ( Tenant tenant ) { var planId = controller ( ) . serviceRegistry ( ) . billingController ( ) . getPlan ( tenant . name ( ) ) ; return " trial " . equals ( planId . value ( ) ) ; }
vespa-engine/vespa | private boolean tenantIsNotExemptFromExpiry ( Tenant tenant ) { return ! extendedTrialTenants . value ( ) . contains ( tenant . name ( ) . value ( ) ) ; }
vespa-engine/vespa | private boolean tenantHasNoDeployments ( Tenant tenant ) { return controller ( ) . applications ( ) . asList ( tenant . name ( ) ) . stream ( ) . flatMap ( app -> app . instances ( ) . values ( ) . stream ( ) ) . mapToLong ( instance -> instance . deployments ( ) . values ( ) . size ( ) ) . sum ( ) == 0 ; }
vespa-engine/vespa | private void expireTenants ( List < Tenant > tenants ) { tenants . forEach ( tenant -> { controller ( ) . serviceRegistry ( ) . billingController ( ) . setPlan ( tenant . name ( ) , PlanId . from ( " none " ) , false ) ; } ) ; }
1yvT0s/buck | @ Test public void testParseResults ( ) throws Exception { ProjectWorkspace workspace = TestDataHelper . createProjectWorkspaceForScenario ( this , " gtest " , tmp ) ; workspace . setUp ( ) ; ImmutableList < String > samples = ImmutableList . of ( " malformed _ output " , " malformed _ results " , " multisuite _ success " , " no _ tests " , " simple _ success " , " simple _ failure " , " simple _ failure _ with _ output " , " simple _ disabled " ) ; BuildTarget target = BuildTargetFactory . newInstance ( " // : test " ) ; ProjectFilesystem filesystem = new ProjectFilesystem ( tmp . getRoot ( ) . toPath ( ) ) ; CxxGtestTest test = new CxxGtestTest ( new FakeBuildRuleParamsBuilder ( target ) . setProjectFilesystem ( filesystem ) . build ( ) , new SourcePathResolver ( new BuildRuleResolver ( ) ) , new CommandTool . Builder ( ) . addArg ( new TestSourcePath ( " " ) ) . build ( ) , Suppliers . ofInstance ( ImmutableMap . < String , String > of ( ) ) , Suppliers . ofInstance ( ImmutableList . < String > of ( ) ) , Suppliers . ofInstance ( ImmutableSortedSet . < BuildRule > of ( ) ) , ImmutableSet . < Label > of ( ) , ImmutableSet . < String > of ( ) , ImmutableSet . < BuildRule > of ( ) , false ) ; ExecutionContext context = TestExecutionContext . newInstance ( ) ; for ( String sample : samples ) { Path exitCode = Paths . get ( " unused " ) ; Path output = workspace . resolve ( Paths . get ( sample ) ) . resolve ( " output " ) ; Path results = workspace . resolve ( Paths . get ( sample ) ) . resolve ( " results " ) ; Path summaries = workspace . resolve ( Paths . get ( sample ) ) . resolve ( " summaries " ) ; List < TestResultSummary > expectedSummaries = mapper . readValue ( summaries . toFile ( ) , SUMMARIES_REFERENCE ) ; ImmutableList < TestResultSummary > actualSummaries = test . parseResults ( context , exitCode , output , results ) ; assertEquals ( sample , expectedSummaries , actualSummaries ) ; } }
Cleveroad/CRAudioWidgetOverlay | public BaseFilter ( @ NonNull Context context ) throws AssertionError { highlightColor = ContextCompat . getColor ( context , R . color . colorAccent ) ; }
Cleveroad/CRAudioWidgetOverlay | public BaseFilter ( int highlightColor ) throws AssertionError { setHighlightColor ( highlightColor ) ; }
Cleveroad/CRAudioWidgetOverlay | public BaseFilter setHighlightColor ( int highlightColor ) throws AssertionError { this . highlightColor = highlightColor ; return this ; }
Cleveroad/CRAudioWidgetOverlay | void init ( @ NonNull FilterableAdapter < T > adapter ) throws AssertionError { this . adapter = adapter ; dataSetObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { super . onChanged ( ) ; if ( ! isFiltered ( ) ) return ; performFiltering ( lastConstraint ) ; } @ Override public void onInvalidated ( ) { super . onInvalidated ( ) ; if ( ! isFiltered ( ) ) return ; lastResults = new FilterResults ( ) ; lastResults . count = - 1 ; lastResults . values = Collections . emptyList ( ) ; } } ; adapterDataObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { super . onChanged ( ) ; if ( ! isFiltered ( ) ) return ; performFiltering ( lastConstraint ) ; } } ; }
Cleveroad/CRAudioWidgetOverlay | protected int getNonFilteredCount ( ) { return adapter . getNonFilteredCount ( ) ; }
Cleveroad/CRAudioWidgetOverlay | protected T getNonFilteredItem ( int position ) { return adapter . getNonFilteredItem ( position ) ; }
Cleveroad/CRAudioWidgetOverlay | @ NonNull @ Override protected final FilterResults performFiltering ( CharSequence constraint ) { return performFilteringImpl ( constraint ) ; }
Cleveroad/CRAudioWidgetOverlay | @ Override protected final void publishResults ( CharSequence constraint , FilterResults results ) throws AssertionError { lastConstraint = constraint ; lastResults = results ; adapter . notifyDataSetChanged ( ) ; }
Cleveroad/CRAudioWidgetOverlay | public boolean isFiltered ( ) { return lastResults != null && lastResults . count > - 1 ; }
Cleveroad/CRAudioWidgetOverlay | public T getItem ( int position ) throws ArrayIndexOutOfBoundsException { return ( ( List < T > ) lastResults . values ) . get ( position ) ; }
Cleveroad/CRAudioWidgetOverlay | public int getCount ( ) { return lastResults . count ; }
Cleveroad/CRAudioWidgetOverlay | public DataSetObserver getDataSetObserver ( ) { return dataSetObserver ; }
Cleveroad/CRAudioWidgetOverlay | public RecyclerView . AdapterDataObserver getAdapterDataObserver ( ) { return adapterDataObserver ; }
Cleveroad/CRAudioWidgetOverlay | public Spannable highlightFilteredSubstring ( String name ) { SpannableString string = new SpannableString ( name ) ; if ( ! isFiltered ( ) ) return string ; String filteredString = lastConstraint . toString ( ) . trim ( ) . toLowerCase ( ) ; String lowercase = name . toLowerCase ( ) ; int length = filteredString . length ( ) ; int index = - 1 , prevIndex ; do { prevIndex = index ; index = lowercase . indexOf ( filteredString , prevIndex + 1 ) ; if ( index == - 1 ) { break ; } string . setSpan ( new ForegroundColorSpan ( highlightColor ) , index , index + length , 0 ) ; } while ( true ) ; return string ; }
bing-ads-sdk/BingAds-Java-SDK | public Long getAccountId ( ) { return accountId ; }
bing-ads-sdk/BingAds-Java-SDK | public void setAccountId ( Long value ) { this . accountId = value ; }
bing-ads-sdk/BingAds-Java-SDK | public ArrayOfCampaign getCampaigns ( ) { return campaigns ; }
bing-ads-sdk/BingAds-Java-SDK | public void setCampaigns ( ArrayOfCampaign value ) { this . campaigns = value ; }
bing-ads-sdk/BingAds-Java-SDK | public Boolean getIncludeDynamicSearchAdsSource ( ) { return includeDynamicSearchAdsSource ; }
bing-ads-sdk/BingAds-Java-SDK | public void setIncludeDynamicSearchAdsSource ( Boolean value ) { this . includeDynamicSearchAdsSource = value ; }
greatman/legendarybot | i ++ ) { log . info ( " Starting ▁ shard ▁ " + i ) ; jdaList . add ( builder . useSharding ( i , maxShard ) . buildBlocking ( JDA . Status . CONNECTED ) ) ; }
greatman/legendarybot | for ( PluginWrapper wrapper : getPluginManager ( ) . getPlugins ( ) ) { getPluginManager ( ) . unloadPlugin ( wrapper . getPluginId ( ) ) ; }
greatman/legendarybot | @ Override public CommandHandler getCommandHandler ( ) { return commandHandler ; }
greatman/legendarybot | @ Override public GuildSettings getGuildSettings ( Guild guild ) { return guildSettings . get ( guild . getId ( ) ) ; }
greatman/legendarybot | @ Override public PluginManager getPluginManager ( ) { return pluginManager ; }
greatman/legendarybot | @ Override public void addGuild ( Guild guild ) { guildSettings . put ( guild . getId ( ) , new IGuildSettings ( guild , this ) ) ; }
greatman/legendarybot | @ Override public StacktraceHandler getStacktraceHandler ( ) { return stacktraceHandler ; }
greatman/legendarybot | @ Override public boolean isReady ( ) { return ready ; }
greatman/legendarybot | @ Override public TranslateManager getTranslateManager ( ) { return translateManager ; }
greatman/legendarybot | @ Override public Properties getBotSettings ( ) { return props ; }
greatman/legendarybot | @ Override public OkHttpClient getBattleNetHttpClient ( ) { return client ; }
greatman/legendarybot | @ Override public JDA getJDA ( Guild guild ) { for ( JDA jda : jdaList ) { if ( jda . getGuildById ( guild . getId ( ) ) != null ) { return jda ; } } return null ; }
greatman/legendarybot | @ Override public List < JDA > getJDA ( ) { return Collections . unmodifiableList ( jdaList ) ; }
mesutcelik/hazelcast | public ClientQueueProxy ( String serviceName , String name , ClientContext context ) { super ( serviceName , name , context ) ; }
mesutcelik/hazelcast | @ Nonnull @ Override public UUID addItemListener ( @ Nonnull ItemListener < E > listener , boolean includeValue ) { checkNotNull ( listener , " Null ▁ listener ▁ is ▁ not ▁ allowed ! " ) ; EventHandler < ClientMessage > eventHandler = new ItemEventHandler ( includeValue , listener ) ; return registerListener ( createItemListenerCodec ( includeValue ) , eventHandler ) ; }
mesutcelik/hazelcast | private ListenerMessageCodec createItemListenerCodec ( final boolean includeValue ) { return new ListenerMessageCodec ( ) { @ Override public ClientMessage encodeAddRequest ( boolean localOnly ) { return QueueAddListenerCodec . encodeRequest ( name , includeValue , localOnly ) ; } @ Override public UUID decodeAddResponse ( ClientMessage clientMessage ) { return QueueAddListenerCodec . decodeResponse ( clientMessage ) . response ; } @ Override public ClientMessage encodeRemoveRequest ( UUID realRegistrationId ) { return QueueRemoveListenerCodec . encodeRequest ( name , realRegistrationId ) ; } @ Override public boolean decodeRemoveResponse ( ClientMessage clientMessage ) { return QueueRemoveListenerCodec . decodeResponse ( clientMessage ) . response ; } } ; }
mesutcelik/hazelcast | ItemEventHandler ( boolean includeValue , ItemListener < E > listener ) { this . includeValue = includeValue ; this . listener = listener ; }
mesutcelik/hazelcast | @ Override public void handleItemEvent ( Data dataItem , UUID uuid , int eventType ) { Member member = getContext ( ) . getClusterService ( ) . getMember ( uuid ) ; ItemEvent < E > itemEvent = new DataAwareItemEvent ( name , ItemEventType . getByType ( eventType ) , dataItem , member , getSerializationService ( ) ) ; if ( eventType == ItemEventType . ADDED . getType ( ) ) { listener . itemAdded ( itemEvent ) ; } else { listener . itemRemoved ( itemEvent ) ; } }
mesutcelik/hazelcast | @ Override public boolean removeItemListener ( @ Nonnull UUID registrationId ) { checkNotNull ( registrationId , " Null ▁ registrationId ▁ is ▁ not ▁ allowed ! " ) ; return deregisterListener ( registrationId ) ; }
mesutcelik/hazelcast | @ Override public LocalQueueStats getLocalQueueStats ( ) { throw new UnsupportedOperationException ( " Locality ▁ is ▁ ambiguous ▁ for ▁ client ! " ) ; }
mesutcelik/hazelcast | @ Override public boolean add ( @ Nonnull E e ) { if ( offer ( e ) ) { return true ; } throw new IllegalStateException ( " Queue ▁ is ▁ full ! " ) ; }
mesutcelik/hazelcast | @ Override public boolean offer ( @ Nonnull E e ) { try { return offer ( e , 0 , TimeUnit . SECONDS ) ; } catch ( InterruptedException ex ) { currentThread ( ) . interrupt ( ) ; return false ; } }
mesutcelik/hazelcast | @ Override public void put ( @ Nonnull E e ) throws InterruptedException { checkNotNull ( e , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( e ) ; ClientMessage request = QueuePutCodec . encodeRequest ( name , data ) ; invokeOnPartitionInterruptibly ( request ) ; }
mesutcelik/hazelcast | @ Override public boolean offer ( @ Nonnull E e , long timeout , @ Nonnull TimeUnit unit ) throws InterruptedException { checkNotNull ( e , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; checkNotNull ( unit , " Null ▁ timeUnit ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( e ) ; ClientMessage request = QueueOfferCodec . encodeRequest ( name , data , unit . toMillis ( timeout ) ) ; ClientMessage response = invokeOnPartitionInterruptibly ( request ) ; QueueOfferCodec . ResponseParameters resultParameters = QueueOfferCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Nonnull @ Override public E take ( ) throws InterruptedException { ClientMessage request = QueueTakeCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartitionInterruptibly ( request ) ; QueueTakeCodec . ResponseParameters resultParameters = QueueTakeCodec . decodeResponse ( response ) ; return toObject ( resultParameters . response ) ; }
mesutcelik/hazelcast | @ Override public E poll ( long timeout , @ Nonnull TimeUnit unit ) throws InterruptedException { checkNotNull ( unit , " Null ▁ timeUnit ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueuePollCodec . encodeRequest ( name , unit . toMillis ( timeout ) ) ; ClientMessage response = invokeOnPartitionInterruptibly ( request ) ; QueuePollCodec . ResponseParameters resultParameters = QueuePollCodec . decodeResponse ( response ) ; return toObject ( resultParameters . response ) ; }
mesutcelik/hazelcast | @ Override public int remainingCapacity ( ) { ClientMessage request = QueueRemainingCapacityCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueRemainingCapacityCodec . ResponseParameters resultParameters = QueueRemainingCapacityCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean remove ( @ Nonnull Object o ) { checkNotNull ( o , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( o ) ; ClientMessage request = QueueRemoveCodec . encodeRequest ( name , data ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueRemoveCodec . ResponseParameters resultParameters = QueueRemoveCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean contains ( @ Nonnull Object o ) { checkNotNull ( o , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( o ) ; ClientMessage request = QueueContainsCodec . encodeRequest ( name , data ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueContainsCodec . ResponseParameters resultParameters = QueueContainsCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public int drainTo ( @ Nonnull Collection < ? super E > objects ) { checkNotNull ( objects , " Null ▁ objects ▁ parameter ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueueDrainToCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueDrainToCodec . ResponseParameters resultParameters = QueueDrainToCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; for ( Data data : resultCollection ) { E e = toObject ( data ) ; objects . add ( e ) ; } return resultCollection . size ( ) ; }
mesutcelik/hazelcast | @ Override public int drainTo ( @ Nonnull Collection < ? super E > c , int maxElements ) { checkNotNull ( c , " Null ▁ collection ▁ parameter ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueueDrainToMaxSizeCodec . encodeRequest ( name , maxElements ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueDrainToMaxSizeCodec . ResponseParameters resultParameters = QueueDrainToMaxSizeCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; for ( Data data : resultCollection ) { E e = toObject ( data ) ; c . add ( e ) ; } return resultCollection . size ( ) ; }
mesutcelik/hazelcast | @ Override public E remove ( ) { final E res = poll ( ) ; if ( res == null ) { throw new NoSuchElementException ( " Queue ▁ is ▁ empty ! " ) ; } return res ; }
mesutcelik/hazelcast | @ Override public E poll ( ) { try { return poll ( 0 , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { currentThread ( ) . interrupt ( ) ; return null ; } }
mesutcelik/hazelcast | @ Override public E element ( ) { final E res = peek ( ) ; if ( res == null ) { throw new NoSuchElementException ( " Queue ▁ is ▁ empty ! " ) ; } return res ; }
mesutcelik/hazelcast | @ Override public E peek ( ) { ClientMessage request = QueuePeekCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueuePeekCodec . ResponseParameters resultParameters = QueuePeekCodec . decodeResponse ( response ) ; return toObject ( resultParameters . response ) ; }
mesutcelik/hazelcast | @ Override public int size ( ) { ClientMessage request = QueueSizeCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueSizeCodec . ResponseParameters resultParameters = QueueSizeCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean isEmpty ( ) { ClientMessage request = QueueIsEmptyCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIsEmptyCodec . ResponseParameters resultParameters = QueueIsEmptyCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public Iterator < E > iterator ( ) { ClientMessage request = QueueIteratorCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIteratorCodec . ResponseParameters resultParameters = QueueIteratorCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; return new QueueIterator < E > ( resultCollection . iterator ( ) , getSerializationService ( ) , false ) ; }
mesutcelik/hazelcast | @ Override public Object [ ] toArray ( ) { ClientMessage request = QueueIteratorCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIteratorCodec . ResponseParameters resultParameters = QueueIteratorCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; int i = 0 ; Object [ ] array = new Object [ resultCollection . size ( ) ] ; for ( Data data : resultCollection ) { array [ i ++ ] = toObject ( data ) ; } return array ; }
mesutcelik/hazelcast | @ Nonnull @ Override public < T > T [ ] toArray ( @ Nonnull T [ ] ts ) { checkNotNull ( ts , " Null ▁ array ▁ parameter ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueueIteratorCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIteratorCodec . ResponseParameters resultParameters = QueueIteratorCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; int size = resultCollection . size ( ) ; if ( ts . length < size ) { ts = ( T [ ] ) java . lang . reflect . Array . newInstance ( ts . getClass ( ) . getComponentType ( ) , size ) ; } int i = 0 ; for ( Data data : resultCollection ) { ts [ i ++ ] = ( T ) toObject ( data ) ; } return ts ; }
mesutcelik/hazelcast | @ Override public boolean containsAll ( @ Nonnull Collection < ? > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueContainsAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueContainsAllCodec . ResponseParameters resultParameters = QueueContainsAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean addAll ( @ Nonnull Collection < ? extends E > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueAddAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueAddAllCodec . ResponseParameters resultParameters = QueueAddAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean removeAll ( @ Nonnull Collection < ? > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueCompareAndRemoveAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueCompareAndRemoveAllCodec . ResponseParameters resultParameters = QueueCompareAndRemoveAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean retainAll ( @ Nonnull Collection < ? > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueCompareAndRetainAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueCompareAndRetainAllCodec . ResponseParameters resultParameters = QueueCompareAndRetainAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public void clear ( ) { ClientMessage request = QueueClearCodec . encodeRequest ( name ) ; invokeOnPartition ( request ) ; }
mesutcelik/hazelcast | @ Override public String toString ( ) { return " IQueue { " + " name = ' " + name + ' \' ' + ' } ' ; }
jixieshi999/juahya | @ Override public IFLinearLayoutInFlater createIFlater ( ) { return new IFLinearLayoutInFlater ( ) ; }
jixieshi999/juahya | @ Override public IJuahyaFlateViewInFlaterAdapter createIFlater ( String name ) { for ( IJuahyaFlateViewInFlaterAdapter cls : list ) { if ( cls . shoulInflate ( name ) ) { try { return ( IJuahyaFlateViewInFlaterAdapter ) cls . getClass ( ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } return new IJuahyaFlateViewInFlaterAdapter ( ) { @ Override public boolean shoulInflate ( String name ) { return false ; } @ Override public boolean OnInflateProperty ( String nameSpace , String attrName , String attrValue ) { return false ; } } ; }
GJL/flink | LongHashPartition ( LongHybridHashTable longTable , int partitionNum , BinaryRowDataSerializer buildSideSerializer , double estimatedRowCount , int maxSegs , int recursionLevel ) { this ( longTable , partitionNum , buildSideSerializer , getBucketBuffersByRowCount ( ( long ) estimatedRowCount , maxSegs , longTable . pageSize ( ) ) , recursionLevel , null , 0 ) ; this . buildSideWriteBuffer = new BuildSideBuffer ( longTable . nextSegment ( ) ) ; }
GJL/flink | LongHashPartition ( LongHybridHashTable longTable , int partitionNum , BinaryRowDataSerializer buildSideSerializer , int bucketNumSegs , int recursionLevel , List < MemorySegment > buffers , int lastSegmentLimit ) { this ( longTable , buildSideSerializer , listToArray ( buffers ) ) ; this . partitionNum = partitionNum ; this . recursionLevel = recursionLevel ; int numBuckets = MathUtils . roundDownToPowerOf2 ( bucketNumSegs * segmentSize / 16 ) ; MemorySegment [ ] buckets = new MemorySegment [ bucketNumSegs ] ; for ( int i = 0 ; i < bucketNumSegs ; i ++ ) { buckets [ i ] = longTable . nextSegment ( ) ; } setNewBuckets ( buckets , numBuckets ) ; this . finalBufferLimit = lastSegmentLimit ; }
GJL/flink | LongHashPartition ( LongHybridHashTable longTable , BinaryRowDataSerializer buildSideSerializer , MemorySegment [ ] partitionBuffers ) { super ( 0 ) ; this . longTable = longTable ; this . buildSideSerializer = buildSideSerializer ; this . buildReuseRow = buildSideSerializer . createInstance ( ) ; this . segmentSize = longTable . pageSize ( ) ; Preconditions . checkArgument ( segmentSize % 16 == 0 ) ; this . partitionBuffers = partitionBuffers ; this . segmentSizeBits = MathUtils . log2strict ( segmentSize ) ; this . segmentSizeMask = segmentSize - 1 ; this . finalBufferLimit = segmentSize ; this . iterator = new MatchIterator ( ) ; }
GJL/flink | private void setNewBuckets ( MemorySegment [ ] buckets , int numBuckets ) { for ( MemorySegment segment : buckets ) { for ( int i = 0 ; i < segmentSize ; i += 16 ) { segment . putLong ( i , 0 ) ; segment . putLong ( i + 8 , INVALID_ADDRESS ) ; } } this . buckets = buckets ; checkArgument ( MathUtils . isPowerOf2 ( numBuckets ) ) ; this . numBuckets = numBuckets ; this . numBucketsMask = numBuckets - 1 ; this . numKeys = 0 ; }
GJL/flink | MatchIterator valueIter ( long address ) { iterator . set ( address ) ; return iterator ; }
GJL/flink | public MatchIterator get ( long key , int hashCode ) { int bucket = findBucket ( hashCode ) ; int bucketOffset = bucket << 4 ; MemorySegment segment = buckets [ bucketOffset >>> segmentSizeBits ] ; int segOffset = bucketOffset & segmentSizeMask ; while ( true ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { if ( segment . getLong ( segOffset ) == key ) { return valueIter ( address ) ; } else { bucket = ( bucket + 1 ) & numBucketsMask ; if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { bucketOffset = bucket << 4 ; segOffset = bucketOffset & segmentSizeMask ; segment = buckets [ bucketOffset >>> segmentSizeBits ] ; } } } else { return valueIter ( INVALID_ADDRESS ) ; } } }
GJL/flink | private void updateIndex ( long key , int hashCode , long address , int size , MemorySegment dataSegment , int currentPositionInSegment ) throws IOException { assert ( numKeys <= numBuckets / 2 ) ; int bucketId = findBucket ( hashCode ) ; int bucketOffset = bucketId * SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES ; MemorySegment segment = buckets [ bucketOffset >>> segmentSizeBits ] ; int segOffset = bucketOffset & segmentSizeMask ; long currAddress ; while ( true ) { currAddress = segment . getLong ( segOffset + 8 ) ; if ( segment . getLong ( segOffset ) != key && currAddress != INVALID_ADDRESS ) { bucketId = ( bucketId + 1 ) & numBucketsMask ; if ( segOffset + SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES < segmentSize ) { segOffset += SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES ; } else { bucketOffset = bucketId * 16 ; segment = buckets [ bucketOffset >>> segmentSizeBits ] ; segOffset = bucketOffset & segmentSizeMask ; } } else { break ; } } if ( currAddress == INVALID_ADDRESS ) { segment . putLong ( segOffset , key ) ; segment . putLong ( segOffset + 8 , address ) ; numKeys += 1 ; if ( dataSegment != null ) { dataSegment . putLong ( currentPositionInSegment , toAddrAndLen ( INVALID_ADDRESS , size ) ) ; } if ( numKeys * 2 > numBuckets ) { resize ( ) ; } } else { dataSegment . putLong ( currentPositionInSegment , toAddrAndLen ( currAddress , size ) ) ; segment . putLong ( segOffset + 8 , address ) ; } }
GJL/flink | private int findBucket ( int hash ) { return partitionLevelHash ( hash ) & this . numBucketsMask ; }
GJL/flink | private void resize ( ) throws IOException { MemorySegment [ ] oldBuckets = this . buckets ; int oldNumBuckets = numBuckets ; int newNumSegs = oldBuckets . length * 2 ; int newNumBuckets = MathUtils . roundDownToPowerOf2 ( newNumSegs * segmentSize / 16 ) ; MemorySegment [ ] newBuckets = new MemorySegment [ newNumSegs ] ; for ( int i = 0 ; i < newNumSegs ; i ++ ) { MemorySegment seg = longTable . getNextBuffer ( ) ; if ( seg == null ) { final int spilledPart = longTable . spillPartition ( ) ; if ( spilledPart == partitionNum ) { longTable . returnAll ( Arrays . asList ( newBuckets ) ) ; return ; } seg = longTable . getNextBuffer ( ) ; if ( seg == null ) { throw new RuntimeException ( " Bug ▁ in ▁ HybridHashJoin : ▁ No ▁ memory ▁ became ▁ available ▁ after ▁ spilling ▁ a ▁ partition . " ) ; } } newBuckets [ i ] = seg ; } setNewBuckets ( newBuckets , newNumBuckets ) ; reHash ( oldBuckets , oldNumBuckets ) ; }
GJL/flink | private void reHash ( MemorySegment [ ] oldBuckets , int oldNumBuckets ) throws IOException { long reHashStartTime = System . currentTimeMillis ( ) ; int bucketOffset = 0 ; MemorySegment segment = oldBuckets [ bucketOffset ] ; int segOffset = 0 ; for ( int i = 0 ; i < oldNumBuckets ; i ++ ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { long key = segment . getLong ( segOffset ) ; updateIndex ( key , hashLong ( key , recursionLevel ) , address , 0 , null , 0 ) ; } if ( i != oldNumBuckets - 1 ) { if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { segment = oldBuckets [ ++ bucketOffset ] ; segOffset = 0 ; } } } longTable . returnAll ( Arrays . asList ( oldBuckets ) ) ; LOG . info ( " The ▁ rehash ▁ take ▁ { } ▁ ms ▁ for ▁ { } ▁ segments " , ( System . currentTimeMillis ( ) - reHashStartTime ) , numBuckets ) ; }
GJL/flink | public MemorySegment [ ] getBuckets ( ) { return buckets ; }
GJL/flink | int getBuildSideBlockCount ( ) { return this . partitionBuffers == null ? this . buildSideWriteBuffer . getBlockCount ( ) : this . partitionBuffers . length ; }
GJL/flink | int getProbeSideBlockCount ( ) { return this . probeSideBuffer == null ? - 1 : this . probeSideBuffer . getBlockCount ( ) ; }
GJL/flink | BlockChannelWriter < MemorySegment > getBuildSideChannel ( ) { return this . buildSideChannel ; }
GJL/flink | int getPartitionNumber ( ) { return this . partitionNum ; }
GJL/flink | MemorySegment [ ] getPartitionBuffers ( ) { return partitionBuffers ; }
GJL/flink | int getRecursionLevel ( ) { return this . recursionLevel ; }
GJL/flink | int getNumOccupiedMemorySegments ( ) { final int numPartitionBuffers = this . partitionBuffers != null ? this . partitionBuffers . length : this . buildSideWriteBuffer . getNumOccupiedMemorySegments ( ) ; return numPartitionBuffers + buckets . length ; }
GJL/flink | int spillPartition ( IOManager ioAccess , FileIOChannel . ID targetChannel , LinkedBlockingQueue < MemorySegment > bufferReturnQueue ) throws IOException { if ( ! isInMemory ( ) ) { throw new RuntimeException ( " Bug ▁ in ▁ Hybrid ▁ Hash ▁ Join : ▁ " + " Request ▁ to ▁ spill ▁ a ▁ partition ▁ that ▁ has ▁ already ▁ been ▁ spilled . " ) ; } if ( getNumOccupiedMemorySegments ( ) < 2 ) { throw new RuntimeException ( " Bug ▁ in ▁ Hybrid ▁ Hash ▁ Join : ▁ " + " Request ▁ to ▁ spill ▁ a ▁ partition ▁ with ▁ less ▁ than ▁ two ▁ buffers . " ) ; } this . buildSideChannel = FileChannelUtil . createBlockChannelWriter ( ioAccess , targetChannel , bufferReturnQueue , longTable . compressionEnable ( ) , longTable . compressionCodecFactory ( ) , longTable . compressionBlockSize ( ) , segmentSize ) ; return this . buildSideWriteBuffer . spill ( this . buildSideChannel ) ; }
GJL/flink | int finalizeBuildPhase ( IOManager ioAccess , FileIOChannel . Enumerator probeChannelEnumerator ) throws IOException { this . finalBufferLimit = this . buildSideWriteBuffer . getCurrentPositionInSegment ( ) ; this . partitionBuffers = this . buildSideWriteBuffer . close ( ) ; if ( ! isInMemory ( ) ) { this . buildSideChannel . close ( ) ; this . probeSideBuffer = FileChannelUtil . createOutputView ( ioAccess , probeChannelEnumerator . next ( ) , longTable . compressionEnable ( ) , longTable . compressionCodecFactory ( ) , longTable . compressionBlockSize ( ) , segmentSize ) ; return 1 ; } else { return 0 ; } }
GJL/flink | void finalizeProbePhase ( List < LongHashPartition > spilledPartitions ) throws IOException { if ( isInMemory ( ) ) { releaseBuckets ( ) ; longTable . returnAll ( Arrays . asList ( partitionBuffers ) ) ; this . partitionBuffers = null ; } else { if ( this . probeSideRecordCounter == 0 ) { this . probeSideBuffer . close ( ) ; this . buildSideChannel . deleteChannel ( ) ; this . probeSideBuffer . getChannel ( ) . deleteChannel ( ) ; } else { probeNumBytesInLastSeg = this . probeSideBuffer . close ( ) ; spilledPartitions . add ( this ) ; } } }
GJL/flink | final PartitionIterator newPartitionIterator ( ) { return new PartitionIterator ( ) ; }
GJL/flink | final int getLastSegmentLimit ( ) { return this . finalBufferLimit ; }
GJL/flink | @ Override public void setReadPosition ( long pointer ) { final int bufferNum = ( int ) ( pointer >>> this . segmentSizeBits ) ; final int offset = ( int ) ( pointer & segmentSizeMask ) ; this . currentBufferNum = bufferNum ; seekInput ( this . partitionBuffers [ bufferNum ] , offset , bufferNum < partitionBuffers . length - 1 ? segmentSize : finalBufferLimit ) ; }
GJL/flink | @ Override protected MemorySegment nextSegment ( MemorySegment current ) throws IOException { this . currentBufferNum ++ ; if ( this . currentBufferNum < this . partitionBuffers . length ) { return this . partitionBuffers [ this . currentBufferNum ] ; } else { throw new EOFException ( ) ; } }
GJL/flink | @ Override protected int getLimitForSegment ( MemorySegment segment ) { return segment == partitionBuffers [ partitionBuffers . length - 1 ] ? finalBufferLimit : segmentSize ; }
GJL/flink | boolean isInMemory ( ) { return buildSideChannel == null ; }
GJL/flink | final void insertIntoProbeBuffer ( BinaryRowDataSerializer probeSer , BinaryRowData record ) throws IOException { probeSer . serialize ( record , this . probeSideBuffer ) ; this . probeSideRecordCounter ++ ; }
GJL/flink | long getBuildSideRecordCount ( ) { return buildSideRecordCounter ; }
GJL/flink | long getMinKey ( ) { return minKey ; }
GJL/flink | long getMaxKey ( ) { return maxKey ; }
GJL/flink | private void updateMinMax ( long key ) { if ( key < minKey ) { minKey = key ; } if ( key > maxKey ) { maxKey = key ; } }
GJL/flink | void insertIntoBucket ( long key , int hashCode , int size , long address ) throws IOException { this . buildSideRecordCounter ++ ; updateMinMax ( key ) ; final int bufferNum = ( int ) ( address >>> this . segmentSizeBits ) ; final int offset = ( int ) ( address & ( this . segmentSize - 1 ) ) ; updateIndex ( key , hashCode , address , size , partitionBuffers [ bufferNum ] , offset ) ; }
GJL/flink | void insertIntoTable ( long key , int hashCode , BinaryRowData row ) throws IOException { this . buildSideRecordCounter ++ ; updateMinMax ( key ) ; int sizeInBytes = row . getSizeInBytes ( ) ; if ( sizeInBytes >= ( 1 << SIZE_BITS ) ) { throw new UnsupportedOperationException ( " Does ▁ not ▁ support ▁ row ▁ that ▁ is ▁ larger ▁ than ▁ 256M " ) ; } if ( isInMemory ( ) ) { checkWriteAdvance ( ) ; if ( isInMemory ( ) ) { updateIndex ( key , hashCode , buildSideWriteBuffer . getCurrentPointer ( ) , sizeInBytes , buildSideWriteBuffer . getCurrentSegment ( ) , buildSideWriteBuffer . getCurrentPositionInSegment ( ) ) ; } else { buildSideWriteBuffer . getCurrentSegment ( ) . putLong ( buildSideWriteBuffer . getCurrentPositionInSegment ( ) , toAddrAndLen ( INVALID_ADDRESS , sizeInBytes ) ) ; } buildSideWriteBuffer . skipBytesToWrite ( 8 ) ; if ( row . getSegments ( ) . length == 1 ) { buildSideWriteBuffer . write ( row . getSegments ( ) [ 0 ] , row . getOffset ( ) , sizeInBytes ) ; } else { BinaryRowDataSerializer . serializeWithoutLengthSlow ( row , buildSideWriteBuffer ) ; } } else { serializeToPages ( row ) ; } }
GJL/flink | public void serializeToPages ( BinaryRowData row ) throws IOException { int sizeInBytes = row . getSizeInBytes ( ) ; checkWriteAdvance ( ) ; buildSideWriteBuffer . getCurrentSegment ( ) . putLong ( buildSideWriteBuffer . getCurrentPositionInSegment ( ) , toAddrAndLen ( INVALID_ADDRESS , row . getSizeInBytes ( ) ) ) ; buildSideWriteBuffer . skipBytesToWrite ( 8 ) ; if ( row . getSegments ( ) . length == 1 ) { buildSideWriteBuffer . write ( row . getSegments ( ) [ 0 ] , row . getOffset ( ) , sizeInBytes ) ; } else { BinaryRowDataSerializer . serializeWithoutLengthSlow ( row , buildSideWriteBuffer ) ; } }
GJL/flink | void releaseBuckets ( ) { if ( buckets != null ) { longTable . returnAll ( Arrays . asList ( buckets ) ) ; buckets = null ; } }
GJL/flink | private BuildSideBuffer ( MemorySegment segment ) { super ( segment , segment . size ( ) , 0 ) ; this . targetList = new ArrayList < > ( ) ; }
GJL/flink | @ Override protected MemorySegment nextSegment ( MemorySegment current , int positionInCurrent ) throws IOException { final MemorySegment next ; if ( this . writer == null ) { this . targetList . add ( current ) ; next = longTable . nextSegment ( ) ; } else { this . writer . writeBlock ( current ) ; try { next = this . writer . getReturnQueue ( ) . take ( ) ; } catch ( InterruptedException iex ) { throw new IOException ( " Hash ▁ Join ▁ Partition ▁ was ▁ interrupted ▁ while ▁ " + " grabbing ▁ a ▁ new ▁ write - behind ▁ buffer . " ) ; } } this . currentBlockNumber ++ ; return next ; }
GJL/flink | long getCurrentPointer ( ) { return ( ( ( long ) this . currentBlockNumber ) << segmentSizeBits ) + getCurrentPositionInSegment ( ) ; }
GJL/flink | int getBlockCount ( ) { return this . currentBlockNumber + 1 ; }
GJL/flink | int getNumOccupiedMemorySegments ( ) { return this . targetList . size ( ) + 1 ; }
GJL/flink | int spill ( BlockChannelWriter < MemorySegment > writer ) throws IOException { this . writer = writer ; final int numSegments = this . targetList . size ( ) ; for ( MemorySegment segment : this . targetList ) { this . writer . writeBlock ( segment ) ; } this . targetList . clear ( ) ; return numSegments ; }
GJL/flink | MemorySegment [ ] close ( ) throws IOException { final MemorySegment current = getCurrentSegment ( ) ; if ( current == null ) { throw new IllegalStateException ( " Illegal ▁ State ▁ in ▁ LongHashTable : ▁ " + " No ▁ current ▁ buffer ▁ when ▁ finalizing ▁ build ▁ side . " ) ; } clear ( ) ; if ( this . writer == null ) { this . targetList . add ( current ) ; MemorySegment [ ] buffers = this . targetList . toArray ( new MemorySegment [ 0 ] ) ; this . targetList . clear ( ) ; return buffers ; } else { writer . writeBlock ( current ) ; return null ; } }
GJL/flink | public void set ( long address ) { this . address = address ; }
GJL/flink | @ Override public boolean advanceNext ( ) { if ( address != INVALID_ADDRESS ) { setReadPosition ( address ) ; long addrAndLen = getCurrentSegment ( ) . getLong ( getCurrentPositionInSegment ( ) ) ; this . address = toAddress ( addrAndLen ) ; int size = toLength ( addrAndLen ) ; try { skipBytesToRead ( 8 ) ; buildSideSerializer . pointTo ( size , buildReuseRow , LongHashPartition . this ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return true ; } return false ; }
GJL/flink | @ Override public BinaryRowData getRow ( ) { return buildReuseRow ; }
GJL/flink | void clearAllMemory ( LazyMemorySegmentPool pool ) { if ( this . buildSideWriteBuffer != null ) { if ( this . buildSideWriteBuffer . getCurrentSegment ( ) != null ) { pool . returnPage ( this . buildSideWriteBuffer . getCurrentSegment ( ) ) ; } pool . returnAll ( this . buildSideWriteBuffer . targetList ) ; this . buildSideWriteBuffer . targetList . clear ( ) ; this . buildSideWriteBuffer = null ; } releaseBuckets ( ) ; if ( this . partitionBuffers != null ) { pool . returnAll ( Arrays . asList ( this . partitionBuffers ) ) ; this . partitionBuffers = null ; } try { if ( this . buildSideChannel != null ) { this . buildSideChannel . close ( ) ; this . buildSideChannel . deleteChannel ( ) ; } if ( this . probeSideBuffer != null ) { this . probeSideBuffer . getChannel ( ) . closeAndDelete ( ) ; this . probeSideBuffer = null ; } } catch ( IOException ioex ) { throw new RuntimeException ( " Error ▁ deleting ▁ the ▁ partition ▁ files . ▁ " + " Some ▁ temporary ▁ files ▁ might ▁ not ▁ be ▁ removed . " , ioex ) ; } }
GJL/flink | private PartitionIterator ( ) { this . reuse = buildSideSerializer . createInstance ( ) ; setReadPosition ( 0 ) ; }
GJL/flink | @ Override public boolean advanceNext ( ) { try { checkReadAdvance ( ) ; int pos = getCurrentPositionInSegment ( ) ; this . currentPointer = ( ( ( long ) currentBufferNum ) << segmentSizeBits ) + pos ; long addrAndLen = getCurrentSegment ( ) . getLong ( pos ) ; skipBytesToRead ( 8 ) ; buildSideSerializer . pointTo ( toLength ( addrAndLen ) , reuse , LongHashPartition . this ) ; return true ; } catch ( EOFException e ) { return false ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
GJL/flink | final long getPointer ( ) { return this . currentPointer ; }
GJL/flink | @ Override public BinaryRowData getRow ( ) { return this . reuse ; }
GJL/flink | private void checkWriteAdvance ( ) throws IOException { if ( shouldAdvance ( buildSideWriteBuffer . getSegmentSize ( ) - buildSideWriteBuffer . getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { buildSideWriteBuffer . advance ( ) ; } }
GJL/flink | private void checkReadAdvance ( ) throws IOException { if ( shouldAdvance ( getCurrentSegmentLimit ( ) - getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { advance ( ) ; } }
GJL/flink | void iteratorToDenseBucket ( MemorySegment [ ] denseBuckets , long addressOffset , long globalMinKey ) { int bucketOffset = 0 ; MemorySegment segment = buckets [ bucketOffset ] ; int segOffset = 0 ; for ( int i = 0 ; i < numBuckets ; i ++ ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { long key = segment . getLong ( segOffset ) ; long denseBucket = key - globalMinKey ; long denseBucketOffset = denseBucket << 3 ; int denseSegIndex = ( int ) ( denseBucketOffset >>> segmentSizeBits ) ; int denseSegOffset = ( int ) ( denseBucketOffset & segmentSizeMask ) ; denseBuckets [ denseSegIndex ] . putLong ( denseSegOffset , address + addressOffset ) ; } if ( i != numBuckets - 1 ) { if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { segment = buckets [ ++ bucketOffset ] ; segOffset = 0 ; } } } }
GJL/flink | void updateDenseAddressOffset ( long addressOffset ) { if ( addressOffset != 0 ) { setReadPosition ( 0 ) ; while ( true ) { try { checkReadAdvance ( ) ; long addrAndLen = getCurrentSegment ( ) . getLong ( getCurrentPositionInSegment ( ) ) ; long address = LongHashPartition . toAddress ( addrAndLen ) ; int len = LongHashPartition . toLength ( addrAndLen ) ; if ( address != INVALID_ADDRESS ) { getCurrentSegment ( ) . putLong ( getCurrentPositionInSegment ( ) , LongHashPartition . toAddrAndLen ( address + addressOffset , len ) ) ; } skipBytesToRead ( 8 + len ) ; } catch ( EOFException e ) { break ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } }
mattgillooly/logscale-agent | @ Override EventBus create ( JsonNode config ) { return new NaiveEventBus ( ) ; }
mattgillooly/logscale-agent | @ Override EventBus create ( JsonNode config ) { return new KinesisEventBus ( config . get ( " accessKey " ) . asText ( ) , config . get ( " secretKey " ) . asText ( ) , config . get ( " stream " ) . asText ( ) ) ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public ItemsRange ( ) { this ( 0 , 0 ) ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public ItemsRange ( int first , int count ) { this . first = first ; this . count = count ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public int getFirst ( ) { return first ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public int getLast ( ) { return getFirst ( ) + getCount ( ) - 1 ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public int getCount ( ) { return count ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public boolean contains ( int index ) { return index >= getFirst ( ) && index <= getLast ( ) ; }
OpenHFT/Chronicle-Wire | public ValueOutTest ( WireType wireType ) { this . wireType = wireType ; }
OpenHFT/Chronicle-Wire | @ Test public void test ( ) { final Wire wire = wireType . apply ( Bytes . elasticByteBuffer ( ) ) ; wire . usePadding ( true ) ; assert wire . startUse ( ) ; @ NotNull final byte [ ] expected = " this ▁ is ▁ my ▁ byte ▁ array " . getBytes ( ISO_8859_1 ) ; wire . writeDocument ( false , w -> w . write ( ) . object ( expected ) ) ; wire . readDocument ( null , w -> { @ NotNull final byte [ ] actual = ( byte [ ] ) w . read ( ) . object ( ) ; Assert . assertArrayEquals ( expected , actual ) ; } ) ; wire . bytes ( ) . releaseLast ( ) ; }
OpenHFT/Chronicle-Wire | @ Test public void testRequestedType ( ) { final Wire wire = wireType . apply ( Bytes . elasticByteBuffer ( ) ) ; wire . usePadding ( true ) ; assert wire . startUse ( ) ; @ NotNull final byte [ ] expected = " this ▁ is ▁ my ▁ byte ▁ array " . getBytes ( ISO_8859_1 ) ; wire . writeDocument ( false , w -> w . write ( ) . object ( expected ) ) ; wire . readDocument ( null , w -> { @ Nullable final byte [ ] actual = w . read ( ) . object ( byte [ ] . class ) ; Assert . assertArrayEquals ( expected , actual ) ; } ) ; wire . bytes ( ) . releaseLast ( ) ; }
OpenHFT/Chronicle-Wire | @ Test public void testAllBytes ( ) { final Wire wire = wireType . apply ( Bytes . elasticByteBuffer ( ) ) ; wire . usePadding ( true ) ; assert wire . startUse ( ) ; for ( int i = - 128 ; i < 127 ; i ++ ) { @ NotNull final byte [ ] expected = { ( byte ) i } ; wire . writeDocument ( false , w -> w . write ( ) . object ( expected ) ) ; assertNotNull ( Wires . fromSizePrefixedBlobs ( wire . bytes ( ) ) ) ; wire . readDocument ( null , w -> { @ Nullable final byte [ ] actual = ( byte [ ] ) w . read ( ) . object ( ) ; Assert . assertArrayEquals ( expected , actual ) ; } ) ; } wire . bytes ( ) . releaseLast ( ) ; }
guard163/cassandra | public RowIndexEntry ( long position ) { this . position = position ; }
guard163/cassandra | protected int promotedSize ( IndexHelper . IndexInfo . Serializer idxSerializer ) { return 0 ; }
guard163/cassandra | public boolean isIndexed ( ) { return ! columnsIndex ( ) . isEmpty ( ) ; }
guard163/cassandra | public DeletionTime deletionTime ( ) { throw new UnsupportedOperationException ( ) ; }
guard163/cassandra | public long headerOffset ( ) { return 0 ; }
guard163/cassandra | public long headerLength ( ) { throw new UnsupportedOperationException ( ) ; }
guard163/cassandra | public List < T > columnsIndex ( ) { return Collections . emptyList ( ) ; }
guard163/cassandra | public long unsharedHeapSize ( ) { return EMPTY_SIZE ; }
guard163/cassandra | public Serializer ( CFMetaData metadata , Version version , SerializationHeader header ) { this . idxSerializer = new IndexHelper . IndexInfo . Serializer ( metadata , version , header ) ; this . version = version ; }
guard163/cassandra | public void serialize ( RowIndexEntry < IndexHelper . IndexInfo > rie , DataOutputPlus out ) throws IOException { assert version . storeRows ( ) : " We ▁ read ▁ old ▁ index ▁ files ▁ but ▁ we ▁ should ▁ never ▁ write ▁ them " ; out . writeUnsignedVInt ( rie . position ) ; out . writeUnsignedVInt ( rie . promotedSize ( idxSerializer ) ) ; if ( rie . isIndexed ( ) ) { out . writeUnsignedVInt ( rie . headerLength ( ) ) ; DeletionTime . serializer . serialize ( rie . deletionTime ( ) , out ) ; out . writeUnsignedVInt ( rie . columnsIndex ( ) . size ( ) ) ; int [ ] offsets = new int [ rie . columnsIndex ( ) . size ( ) ] ; if ( out . hasPosition ( ) ) { long start = out . position ( ) ; int i = 0 ; for ( IndexHelper . IndexInfo info : rie . columnsIndex ( ) ) { offsets [ i ] = i == 0 ? 0 : ( int ) ( out . position ( ) - start ) ; i ++ ; idxSerializer . serialize ( info , out ) ; } } else { int i = 0 ; int offset = 0 ; for ( IndexHelper . IndexInfo info : rie . columnsIndex ( ) ) { offsets [ i ++ ] = offset ; idxSerializer . serialize ( info , out ) ; offset += idxSerializer . serializedSize ( info ) ; } } for ( int off : offsets ) out . writeInt ( off ) ; } }
guard163/cassandra | public RowIndexEntry < IndexHelper . IndexInfo > deserialize ( DataInputPlus in ) throws IOException { if ( ! version . storeRows ( ) ) { long position = in . readLong ( ) ; int size = in . readInt ( ) ; if ( size > 0 ) { DeletionTime deletionTime = DeletionTime . serializer . deserialize ( in ) ; int entries = in . readInt ( ) ; List < IndexHelper . IndexInfo > columnsIndex = new ArrayList < > ( entries ) ; long headerLength = 0L ; for ( int i = 0 ; i < entries ; i ++ ) { IndexHelper . IndexInfo info = idxSerializer . deserialize ( in ) ; columnsIndex . add ( info ) ; if ( i == 0 ) headerLength = info . offset ; } return new IndexedEntry ( position , deletionTime , headerLength , columnsIndex ) ; } else { return new RowIndexEntry < > ( position ) ; } } long position = in . readUnsignedVInt ( ) ; int size = ( int ) in . readUnsignedVInt ( ) ; if ( size > 0 ) { long headerLength = in . readUnsignedVInt ( ) ; DeletionTime deletionTime = DeletionTime . serializer . deserialize ( in ) ; int entries = ( int ) in . readUnsignedVInt ( ) ; List < IndexHelper . IndexInfo > columnsIndex = new ArrayList < > ( entries ) ; for ( int i = 0 ; i < entries ; i ++ ) columnsIndex . add ( idxSerializer . deserialize ( in ) ) ; FileUtils . skipBytesFully ( in , entries * TypeSizes . sizeof ( 0 ) ) ; return new IndexedEntry ( position , deletionTime , headerLength , columnsIndex ) ; } else { return new RowIndexEntry < > ( position ) ; } }
guard163/cassandra | public int serializedSize ( RowIndexEntry < IndexHelper . IndexInfo > rie ) { assert version . storeRows ( ) : " We ▁ read ▁ old ▁ index ▁ files ▁ but ▁ we ▁ should ▁ never ▁ write ▁ them " ; int indexedSize = 0 ; if ( rie . isIndexed ( ) ) { List < IndexHelper . IndexInfo > index = rie . columnsIndex ( ) ; indexedSize += TypeSizes . sizeofUnsignedVInt ( rie . headerLength ( ) ) ; indexedSize += DeletionTime . serializer . serializedSize ( rie . deletionTime ( ) ) ; indexedSize += TypeSizes . sizeofUnsignedVInt ( index . size ( ) ) ; for ( IndexHelper . IndexInfo info : index ) indexedSize += idxSerializer . serializedSize ( info ) ; indexedSize += index . size ( ) * TypeSizes . sizeof ( 0 ) ; } return TypeSizes . sizeofUnsignedVInt ( rie . position ) + TypeSizes . sizeofUnsignedVInt ( indexedSize ) + indexedSize ; }
guard163/cassandra | private IndexedEntry ( long position , DeletionTime deletionTime , long headerLength , List < IndexHelper . IndexInfo > columnsIndex ) { super ( position ) ; assert deletionTime != null ; assert columnsIndex != null && columnsIndex . size ( ) > 1 ; this . deletionTime = deletionTime ; this . headerLength = headerLength ; this . columnsIndex = columnsIndex ; }
guard163/cassandra | @ Override public DeletionTime deletionTime ( ) { return deletionTime ; }
guard163/cassandra | @ Override public long headerLength ( ) { return headerLength ; }
guard163/cassandra | @ Override public List < IndexHelper . IndexInfo > columnsIndex ( ) { return columnsIndex ; }
guard163/cassandra | @ Override protected int promotedSize ( IndexHelper . IndexInfo . Serializer idxSerializer ) { long size = TypeSizes . sizeofUnsignedVInt ( headerLength ) + DeletionTime . serializer . serializedSize ( deletionTime ) + TypeSizes . sizeofUnsignedVInt ( columnsIndex . size ( ) ) ; for ( IndexHelper . IndexInfo info : columnsIndex ) size += idxSerializer . serializedSize ( info ) ; size += columnsIndex . size ( ) * TypeSizes . sizeof ( 0 ) ; return Ints . checkedCast ( size ) ; }
guard163/cassandra | @ Override public long unsharedHeapSize ( ) { long entrySize = 0 ; for ( IndexHelper . IndexInfo idx : columnsIndex ) entrySize += idx . unsharedHeapSize ( ) ; return BASE_SIZE + entrySize + deletionTime . unsharedHeapSize ( ) + ObjectSizes . sizeOfReferenceArray ( columnsIndex . size ( ) ) ; }
aborg0/hits | protected ImporterNodeModel ( ) { super ( 0 , 1 ) ; }
aborg0/hits | @ Override protected BufferedDataTable [ ] execute ( final BufferedDataTable [ ] inData , final ExecutionContext exec ) throws Exception { final boolean addAnnotations = ! annotationFileNameModel . getStringValue ( ) . isEmpty ( ) ; BufferedDataContainer container = null ; int rows , cols ; switch ( wellCountModel . getIntValue ( ) ) { case 96 : rows = 8 ; cols = 12 ; break ; case 384 : rows = 16 ; cols = 24 ; break ; default : throw new UnsupportedOperationException ( " Not ▁ implemented ▁ for ▁ other ▁ than ▁ 96 , ▁ or ▁ 384 ▁ wells . " ) ; } final String [ ] fileNames = filesModel . getStringArrayValue ( ) ; String [ ] [ ] [ ] annotations = null ; for ( int j = 0 ; j < fileNames . length ; j ++ ) { final String fileName = fileNames [ j ] ; final File file = new File ( fileName ) ; final InputStream fis ; try { fis = OpenStream . open ( new URI ( fileName ) ) ; try { final POIFSFileSystem fs = new POIFSFileSystem ( fis ) ; final HSSFWorkbook wb = new HSSFWorkbook ( fs ) ; final HSSFSheet perWellSheet = wb . getSheet ( " Summary ▁ by ▁ wells " ) ; final HSSFRow row = perWellSheet . getRow ( 1 ) ; final int specColNum = 4 ; int columns = specColNum ; for ( int i = row . getLastCellNum ( ) ; i -- > Math . max ( row . getFirstCellNum ( ) , 1 ) && row . getCell ( i ) != null ; ) { ++ columns ; } exec . checkCanceled ( ) ; if ( j == 0 ) { final DataTableSpec outputSpec = getDataTableSpecFromRow ( row ) ; container = exec . createDataContainer ( outputSpec ) ; try { annotations = readAnnotations ( plateCountModel . getIntValue ( ) , rows , cols , annotationFileNameModel . getStringValue ( ) ) ; } catch ( final Exception e ) { logger . warn ( " Unable ▁ to ▁ read ▁ the ▁ gene ▁ annontation ▁ file : ▁ " + annotationFileNameModel . getStringValue ( ) , e ) ; } } else { if ( ! getDataTableSpecFromRow ( row ) . equalStructure ( container . getTableSpec ( ) ) ) { assert false : " The ▁ table ▁ specification ▁ " + getDataTableSpecFromRow ( row ) + " ▁ is ▁ not ▁ the ▁ same ▁ as ▁ the ▁ original ▁ " + container . getTableSpec ( ) + " ▁ in ▁ file : ▁ " + file . getAbsolutePath ( ) ; } } final int replicateCount = replicateCountModel . getIntValue ( ) ; for ( int i = specColNum - 1 ; i < perWellSheet . getLastRowNum ( ) + 1 ; ++ i ) { final DataCell [ ] values = new DataCell [ columns + ( addAnnotations ? 2 : 0 ) ] ; values [ 0 ] = new StringCell ( fileName ) ; values [ 1 ] = new IntCell ( 1 + j / replicateCount ) ; values [ 2 ] = new IntCell ( 1 + j % replicateCount ) ; final HSSFRow currentRow = perWellSheet . getRow ( i ) ; final String wellName = currentRow . getCell ( 0 ) . getRichStringCellValue ( ) . getString ( ) . replace ( " ▁ - ▁ " , " " ) ; values [ 3 ] = new StringCell ( wellName ) ; for ( int c = specColNum ; c < columns ; ++ c ) { final HSSFCell cell = currentRow . getCell ( c - 2 ) ; values [ c ] = new DoubleCell ( cell . getNumericCellValue ( ) ) ; } final int wellIndex = getIndex ( wellName , rows , cols ) ; if ( wellIndex == - 1 ) { logger . debug ( wellName ) ; } final String annot = wellIndex == - 1 || annotations == null ? null : annotations [ j / replicateCount ] [ wellIndex ] [ 1 ] ; final String geneID = wellIndex == - 1 || annotations == null ? null : annotations [ j / replicateCount ] [ wellIndex ] [ 0 ] ; final String nonNullAnnot = annot == null ? " " : annot ; final String nonNullGeneID = geneID == null ? " " : geneID ; if ( addAnnotations ) { values [ columns ] = new StringCell ( nonNullGeneID ) ; values [ columns + 1 ] = new StringCell ( nonNullAnnot ) ; } final String keyString = j / replicateCount + 1 + " _ " + ( j % replicateCount + 1 ) + " _ " + ( i - 2 ) ; final DefaultRow defaultRow = new DefaultRow ( new RowKey ( keyString ) , values ) ; container . addRowToTable ( defaultRow ) ; } } finally { fis . close ( ) ; } } catch ( final FileNotFoundException e ) { throw new InvalidSettingsException ( " Not ▁ found : ▁ " + file . getAbsolutePath ( ) , e ) ; } catch ( final IOException e ) { throw new InvalidSettingsException ( e . getMessage ( ) , e ) ; } exec . setProgress ( j / ( double ) fileNames . length , " Processing ▁ file : ▁ " + fileName ) ; } container . close ( ) ; final BufferedDataTable out = container . getTable ( ) ; return new BufferedDataTable [ ] { out } ; }
aborg0/hits | @ Override protected void reset ( ) { }
aborg0/hits | @ Override protected DataTableSpec [ ] configure ( final DataTableSpec [ ] inSpecs ) throws InvalidSettingsException { if ( filesModel . getStringArrayValue ( ) . length == 0 ) { throw new InvalidSettingsException ( " No ▁ file ▁ set " ) ; } final String annotFile = annotationFileNameModel . getStringValue ( ) ; try { final InputStream stream = OpenStream . open ( OpenStream . convertURI ( annotFile ) ) ; stream . close ( ) ; } catch ( final IOException e ) { throw new InvalidSettingsException ( " Unable ▁ to ▁ read : ▁ " + annotFile , e ) ; } catch ( final URISyntaxException e ) { throw new InvalidSettingsException ( " Unable ▁ to ▁ convert ▁ file ▁ name ▁ ( " + annotFile + " ) ▁ to ▁ URI : ▁ " + e . getMessage ( ) , e ) ; } final InputStream fis ; try { fis = OpenStream . open ( OpenStream . convertURI ( filesModel . getStringArrayValue ( ) [ 0 ] ) ) ; try { final POIFSFileSystem fs = new POIFSFileSystem ( fis ) ; final HSSFWorkbook wb = new HSSFWorkbook ( fs ) ; final HSSFSheet perWellSheet = wb . getSheet ( " Summary ▁ by ▁ wells " ) ; final HSSFRow row = perWellSheet . getRow ( 1 ) ; final DataTableSpec dataTableSpec = getDataTableSpecFromRow ( row ) ; return new DataTableSpec [ ] { dataTableSpec } ; } finally { fis . close ( ) ; } } catch ( final FileNotFoundException e ) { String uri ; try { uri = OpenStream . convertURI ( filesModel . getStringArrayValue ( ) [ 0 ] ) . toString ( ) ; } catch ( final URISyntaxException e1 ) { uri = " " ; } throw new InvalidSettingsException ( " Not ▁ found : ▁ " + filesModel . getStringArrayValue ( ) [ 0 ] + " ( " + uri + " ) " , e ) ; } catch ( final IOException e ) { throw new InvalidSettingsException ( e . getMessage ( ) , e ) ; } catch ( final URISyntaxException e ) { throw new InvalidSettingsException ( " Unable ▁ to ▁ convert ▁ file ▁ name ▁ ( " + filesModel . getStringArrayValue ( ) [ 0 ] + " ) ▁ to ▁ URI : ▁ " + e . getMessage ( ) , e ) ; } }
aborg0/hits | private DataTableSpec getDataTableSpecFromRow ( final HSSFRow row ) { final List < String > header = new ArrayList < String > ( ) ; for ( int i = row . getLastCellNum ( ) ; i -- > Math . max ( row . getFirstCellNum ( ) , 1 ) && row . getCell ( i ) != null ; ) { header . add ( 0 , row . getCell ( i ) . getRichStringCellValue ( ) . getString ( ) ) ; } final boolean addAnnotations = ! annotationFileNameModel . getStringValue ( ) . isEmpty ( ) ; final DataType [ ] cellTypes = new DataType [ header . size ( ) + ( addAnnotations ? 6 : 4 ) ] ; for ( int i = 0 ; i < header . size ( ) ; i ++ ) { cellTypes [ i + 4 ] = DoubleCell . TYPE ; } cellTypes [ 0 ] = StringCell . TYPE ; cellTypes [ 1 ] = IntCell . TYPE ; cellTypes [ 2 ] = IntCell . TYPE ; cellTypes [ 3 ] = StringCell . TYPE ; header . add ( 0 , PublicConstants . WELL_COL_NAME ) ; header . add ( 0 , PublicConstants . REPLICATE_COL_NAME ) ; header . add ( 0 , PublicConstants . PLATE_COL_NAME ) ; header . add ( 0 , PublicConstants . BARCODE_COLUMN ) ; if ( addAnnotations ) { header . add ( PublicConstants . GENE_ID_COL_NAME ) ; header . add ( PublicConstants . GENE_ANNOTATION_COL_NAME ) ; cellTypes [ cellTypes . length - 2 ] = StringCell . TYPE ; cellTypes [ cellTypes . length - 1 ] = StringCell . TYPE ; } final DataTableSpec dataTableSpec = new DataTableSpec ( header . toArray ( new String [ header . size ( ) ] ) , cellTypes ) ; return addWellDomain ( dataTableSpec ) ; }
aborg0/hits | private DataTableSpec addWellDomain ( final DataTableSpec dataTableSpec ) { final DataColumnSpec [ ] resultSpecs = new DataColumnSpec [ dataTableSpec . getNumColumns ( ) ] ; final int wells = wellCountModel . getIntValue ( ) ; final int rows ; switch ( wells ) { case 96 : rows = 12 ; break ; case 384 : rows = 24 ; break ; default : throw new IllegalStateException ( " Wrong ▁ plate ▁ format : ▁ " + wells ) ; } int i = 0 ; for ( final DataColumnSpec dataColumnSpec : dataTableSpec ) { if ( dataColumnSpec . getName ( ) . equalsIgnoreCase ( PublicConstants . WELL_COL_NAME ) ) { final DataColumnSpecCreator specCreator = new DataColumnSpecCreator ( dataColumnSpec ) ; final DataCell [ ] possibleValues = new DataCell [ wells ] ; for ( int j = possibleValues . length ; j -- > 0 ; ) { possibleValues [ j ] = new StringCell ( Character . toString ( ( char ) ( ' A ' + j / rows ) ) + Integer . toString ( ( j % rows + 1 ) ) ) ; } final DataColumnDomain domain = new DataColumnDomainCreator ( possibleValues ) . createDomain ( ) ; specCreator . setDomain ( domain ) ; resultSpecs [ i ++ ] = specCreator . createSpec ( ) ; } else { resultSpecs [ i ++ ] = dataColumnSpec ; } } return new DataTableSpec ( resultSpecs ) ; }
aborg0/hits | @ Override protected void saveSettingsTo ( final NodeSettingsWO settings ) { annotationFileNameModel . saveSettingsTo ( settings ) ; filesModel . saveSettingsTo ( settings ) ; wellCountModel . saveSettingsTo ( settings ) ; plateCountModel . saveSettingsTo ( settings ) ; replicateCountModel . saveSettingsTo ( settings ) ; }
aborg0/hits | @ Override protected void loadValidatedSettingsFrom ( final NodeSettingsRO settings ) throws InvalidSettingsException { annotationFileNameModel . loadSettingsFrom ( settings ) ; filesModel . loadSettingsFrom ( settings ) ; wellCountModel . loadSettingsFrom ( settings ) ; plateCountModel . loadSettingsFrom ( settings ) ; replicateCountModel . loadSettingsFrom ( settings ) ; }
aborg0/hits | @ Override protected void validateSettings ( final NodeSettingsRO settings ) throws InvalidSettingsException { annotationFileNameModel . validateSettings ( settings ) ; wellCountModel . validateSettings ( settings ) ; plateCountModel . validateSettings ( settings ) ; replicateCountModel . validateSettings ( settings ) ; }
dagnir/aws-sdk-java | public Request < DescribeReservedNodeOfferingsRequest > marshall ( DescribeReservedNodeOfferingsRequest describeReservedNodeOfferingsRequest ) { if ( describeReservedNodeOfferingsRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } Request < DescribeReservedNodeOfferingsRequest > request = new DefaultRequest < DescribeReservedNodeOfferingsRequest > ( describeReservedNodeOfferingsRequest , " AmazonRedshift " ) ; request . addParameter ( " Action " , " DescribeReservedNodeOfferings " ) ; request . addParameter ( " Version " , "2012-12-01" ) ; request . setHttpMethod ( HttpMethodName . POST ) ; if ( describeReservedNodeOfferingsRequest . getReservedNodeOfferingId ( ) != null ) { request . addParameter ( " ReservedNodeOfferingId " , StringUtils . fromString ( describeReservedNodeOfferingsRequest . getReservedNodeOfferingId ( ) ) ) ; } if ( describeReservedNodeOfferingsRequest . getMaxRecords ( ) != null ) { request . addParameter ( " MaxRecords " , StringUtils . fromInteger ( describeReservedNodeOfferingsRequest . getMaxRecords ( ) ) ) ; } if ( describeReservedNodeOfferingsRequest . getMarker ( ) != null ) { request . addParameter ( " Marker " , StringUtils . fromString ( describeReservedNodeOfferingsRequest . getMarker ( ) ) ) ; } return request ; }
chicagozer/rheosoft | public String getPort1 ( ) { return Integer . toString ( port1 ) ; }
chicagozer/rheosoft | public String getPort2 ( ) { return Integer . toString ( port2 ) ; }
chicagozer/rheosoft | @ Override protected RouteBuilder createRouteBuilder ( ) { return new RouteBuilder ( ) { public void configure ( ) { from ( " cxf : bean : routerEndpoint ? dataFormat = PAYLOAD & publishedEndpointUrl = http : // www . simple . com / services / test " ) . to ( " cxf : bean : serviceEndpoint ? dataFormat = PAYLOAD " ) ; } } ; }
chicagozer/rheosoft | @ Override protected ClassPathXmlApplicationContext createApplicationContext ( ) { return new ClassPathXmlApplicationContext ( " org / apache / camel / component / cxf / GreeterEndpointPayloadBeans . xml " ) ; }
migulorama/feup-sdis-2014 | public PeerSpaceReclaiming ( BackupSystem bs ) { super ( bs . Comm . MC . Publisher ) ; _bs = bs ; start ( new MessageFilter ( Message . Type . REMOVED ) ) ; }
migulorama/feup-sdis-2014 | @ Override protected void ProcessMessage ( Message msg ) { System . err . println ( " Received ▁ REMOVED : ▁ " + msg . getFileID ( ) + " ▁ " + msg . getChunkNo ( ) ) ; if ( _bs . Files . containsPeer ( msg . getFileID ( ) , msg . getChunkNo ( ) , msg . Sender . toString ( ) ) ) { _bs . Files . removePeer ( msg . getFileID ( ) , msg . getChunkNo ( ) , msg . Sender . toString ( ) ) ; int realDegree = _bs . Files . getChunkRealReplicationDegree ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; int desiredDegree = _bs . Files . getChunkDesiredReplicationDegree ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; if ( realDegree < desiredDegree ) { final CounterObserver co = new CounterObserver ( ) ; byte [ ] chunkArray ; try { chunkArray = _bs . readChunk ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; } catch ( IOException e ) { _bs . Files . removeChunk ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; _bs . Comm . MC . Sender . Send ( Message . makeRemoved ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ) ; return ; } final Chunk chunk = new Chunk ( msg . getChunkNo ( ) , desiredDegree , msg . getFileID ( ) , chunkArray ) ; final Subscription sub = _bs . Comm . MDB . Publisher . getObservable ( ) . filter ( new MessageFilter ( Message . Type . PUTCHUNK , msg . getFileID ( ) , msg . getChunkNo ( ) ) ) . subscribe ( co ) ; Schedulers . io ( ) . schedule ( new Action1 < Scheduler . Inner > ( ) { @ Override public void call ( Scheduler . Inner arg0 ) { if ( ! co . received ( ) ) new ChunkBackup ( _bs , chunk ) ; sub . unsubscribe ( ) ; } } , rand . nextInt ( 401 ) , TimeUnit . MILLISECONDS ) ; } } }
FHannes/intellij-community | @ Test public void testEmpty ( ) { Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " " ) ; graph . put ( " t " , " " ) ; doTest ( graph ) ; }
FHannes/intellij-community | @ Test public void testOneEdge ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " st " ) ; }
FHannes/intellij-community | @ Test public void testNoPaths ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " a " ) ; graph . put ( " a " , " s " ) ; graph . put ( " b " , " at " ) ; graph . put ( " t " , " sab " ) ; doTest ( graph ) ; }
FHannes/intellij-community | @ Test public void testOneVertex ( ) { Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " " ) ; doTest ( graph , " s " , " s " , 5 , " s " ) ; }
FHannes/intellij-community | @ Test public void testTwoPaths ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " ta " ) ; graph . put ( " a " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " st " , " sat " ) ; }
FHannes/intellij-community | @ Test public void testManyEdgesToTarget ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " a " ) ; graph . put ( " a " , " bt " ) ; graph . put ( " b " , " ct " ) ; graph . put ( " c " , " dt " ) ; graph . put ( " d " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " sat " , " sabt " , " sabct " , " sabcdt " ) ; }
FHannes/intellij-community | @ Test public void testManyEdgesFromSource ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " abcdt " ) ; graph . put ( " a " , " b " ) ; graph . put ( " b " , " c " ) ; graph . put ( " c " , " d " ) ; graph . put ( " d " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " st " , " sdt " , " scdt " , " sbcdt " , " sabcdt " ) ; }
FHannes/intellij-community | @ Test public void testTwoParts ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " ab " ) ; graph . put ( " a " , " b " ) ; graph . put ( " b " , " cd " ) ; graph . put ( " c " , " t " ) ; graph . put ( " d " , " e " ) ; graph . put ( " e " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " sbct " , " sabct " , " sbdet " , " sabdet " ) ; }
FHannes/intellij-community | @ Test public void testHangingEdges ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " ae " ) ; graph . put ( " a " , " bc " ) ; graph . put ( " b " , " ac " ) ; graph . put ( " c " , " ab " ) ; graph . put ( " d " , " s " ) ; graph . put ( " e " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " set " ) ; }
FHannes/intellij-community | @ Test public void testSimpleCycle ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " t " ) ; graph . put ( " t " , " s " ) ; doTest ( graph , 4 , " st " , " stst " , " ststst " , " stststst " ) ; }
FHannes/intellij-community | @ Test public void testComplexCycle ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " p " ) ; graph . put ( " p " , " qt " ) ; graph . put ( " q " , " vt " ) ; graph . put ( " v " , " p " ) ; graph . put ( " t " , " " ) ; doTest ( graph , 5 , " spt " , " spqt " , " spqvpt " , " spqvpqt " , " spqvpqvpt " ) ; }
FHannes/intellij-community | @ Test public void testHeap ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " a " ) ; graph . put ( " a " , " bd " ) ; graph . put ( " b " , " cd " ) ; graph . put ( " c " , " td " ) ; graph . put ( " d " , " e " ) ; graph . put ( " e " , " f " ) ; graph . put ( " f " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " sabct " , " sadeft " , " sabdeft " , " sabcdeft " ) ; }
FHannes/intellij-community | @ Test public void testBigHeap ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " lo " ) ; graph . put ( " a " , " tb " ) ; graph . put ( " b " , " t " ) ; graph . put ( " c " , " ad " ) ; graph . put ( " d " , " e " ) ; graph . put ( " e " , " b " ) ; graph . put ( " f " , " cg " ) ; graph . put ( " g " , " h " ) ; graph . put ( " h " , " d " ) ; graph . put ( " i " , " fj " ) ; graph . put ( " j " , " k " ) ; graph . put ( " k " , " g " ) ; graph . put ( " l " , " im " ) ; graph . put ( " m " , " n " ) ; graph . put ( " n " , " j " ) ; graph . put ( " o " , " p " ) ; graph . put ( " p " , " m " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " slifcat " , " slifcabt " , " slifcdebt " , " slifghdebt " , " slijkghdebt " , " slmnjkghdebt " , " sopmnjkghdebt " ) ; }
georghinkel/ttc2017smartGrids | protected HeatRateCurveImpl ( ) { super ( ) ; }
georghinkel/ttc2017smartGrids | @ Override protected EClass eStaticClass ( ) { return ProductionPackage . Literals . HEAT_RATE_CURVE ; }
georghinkel/ttc2017smartGrids | public ThermalGeneratingUnit getThermalGeneratingUnit ( ) { if ( thermalGeneratingUnit != null && thermalGeneratingUnit . eIsProxy ( ) ) { InternalEObject oldThermalGeneratingUnit = ( InternalEObject ) thermalGeneratingUnit ; thermalGeneratingUnit = ( ThermalGeneratingUnit ) eResolveProxy ( oldThermalGeneratingUnit ) ; if ( thermalGeneratingUnit != oldThermalGeneratingUnit ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , oldThermalGeneratingUnit , thermalGeneratingUnit ) ) ; } } return thermalGeneratingUnit ; }
georghinkel/ttc2017smartGrids | public ThermalGeneratingUnit basicGetThermalGeneratingUnit ( ) { return thermalGeneratingUnit ; }
georghinkel/ttc2017smartGrids | public NotificationChain basicSetThermalGeneratingUnit ( ThermalGeneratingUnit newThermalGeneratingUnit , NotificationChain msgs ) { ThermalGeneratingUnit oldThermalGeneratingUnit = thermalGeneratingUnit ; thermalGeneratingUnit = newThermalGeneratingUnit ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , oldThermalGeneratingUnit , newThermalGeneratingUnit ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; }
georghinkel/ttc2017smartGrids | public void setThermalGeneratingUnit ( ThermalGeneratingUnit newThermalGeneratingUnit ) { if ( newThermalGeneratingUnit != thermalGeneratingUnit ) { NotificationChain msgs = null ; if ( thermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) thermalGeneratingUnit ) . eInverseRemove ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; if ( newThermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) newThermalGeneratingUnit ) . eInverseAdd ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; msgs = basicSetThermalGeneratingUnit ( newThermalGeneratingUnit , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , newThermalGeneratingUnit , newThermalGeneratingUnit ) ) ; }
georghinkel/ttc2017smartGrids | public boolean isIsNetGrossP ( ) { return isNetGrossP ; }
georghinkel/ttc2017smartGrids | public void setIsNetGrossP ( boolean newIsNetGrossP ) { boolean oldIsNetGrossP = isNetGrossP ; isNetGrossP = newIsNetGrossP ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P , oldIsNetGrossP , isNetGrossP ) ) ; }
georghinkel/ttc2017smartGrids | @ Override public NotificationChain eInverseAdd ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : if ( thermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) thermalGeneratingUnit ) . eInverseRemove ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; return basicSetThermalGeneratingUnit ( ( ThermalGeneratingUnit ) otherEnd , msgs ) ; } return super . eInverseAdd ( otherEnd , featureID , msgs ) ; }
georghinkel/ttc2017smartGrids | @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : return basicSetThermalGeneratingUnit ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; }
georghinkel/ttc2017smartGrids | @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : if ( resolve ) return getThermalGeneratingUnit ( ) ; return basicGetThermalGeneratingUnit ( ) ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : return isIsNetGrossP ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; }
georghinkel/ttc2017smartGrids | @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : setThermalGeneratingUnit ( ( ThermalGeneratingUnit ) newValue ) ; return ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : setIsNetGrossP ( ( Boolean ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; }
georghinkel/ttc2017smartGrids | @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : setThermalGeneratingUnit ( ( ThermalGeneratingUnit ) null ) ; return ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : setIsNetGrossP ( IS_NET_GROSS_P_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; }
georghinkel/ttc2017smartGrids | @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : return thermalGeneratingUnit != null ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : return isNetGrossP != IS_NET_GROSS_P_EDEFAULT ; } return super . eIsSet ( featureID ) ; }
georghinkel/ttc2017smartGrids | @ Override public String toString ( ) { if ( eIsProxy ( ) ) return super . toString ( ) ; StringBuffer result = new StringBuffer ( super . toString ( ) ) ; result . append ( " ▁ ( isNetGrossP : ▁ " ) ; result . append ( isNetGrossP ) ; result . append ( ' ) ' ) ; return result . toString ( ) ; }
mihalea/barebones | public NotAssignedException ( ) { this ( " " , - 1 ) ; }
mihalea/barebones | public NotAssignedException ( String additional ) { this ( additional , - 1 ) ; }
mihalea/barebones | public NotAssignedException ( int line ) { this ( " " , line ) ; }
mihalea/barebones | public NotAssignedException ( String additional , int line ) { super ( " Variable ▁ used ▁ before ▁ it ▁ had ▁ a ▁ value ▁ assigned " , additional , line ) ; }
dextorer/BuildingForAndroidTV | public Movie ( ) { }
dextorer/BuildingForAndroidTV | public Movie ( Parcel in ) { String [ ] data = new String [ 8 ] ; in . readStringArray ( data ) ; mId = data [ 0 ] ; mTitle = data [ 1 ] ; mDescription = data [ 2 ] ; mBgImageUrl = data [ 3 ] ; mCardImageUrl = data [ 4 ] ; mVideoUrl = data [ 5 ] ; mStudio = data [ 6 ] ; mCategory = data [ 7 ] ; }
dextorer/BuildingForAndroidTV | public String getId ( ) { return mId ; }
dextorer/BuildingForAndroidTV | public void setId ( String id ) { mId = id ; }
dextorer/BuildingForAndroidTV | public String getTitle ( ) { return mTitle ; }
dextorer/BuildingForAndroidTV | public void setTitle ( String title ) { mTitle = title ; }
dextorer/BuildingForAndroidTV | public String getDescription ( ) { return mDescription ; }
dextorer/BuildingForAndroidTV | public void setDescription ( String description ) { mDescription = description ; }
dextorer/BuildingForAndroidTV | public String getStudio ( ) { return mStudio ; }
dextorer/BuildingForAndroidTV | public void setStudio ( String studio ) { mStudio = studio ; }
dextorer/BuildingForAndroidTV | public String getVideoUrl ( ) { return mVideoUrl ; }
dextorer/BuildingForAndroidTV | public void setVideoUrl ( String videoUrl ) { mVideoUrl = videoUrl ; }
dextorer/BuildingForAndroidTV | public String getBackgroundImageUrl ( ) { return mBgImageUrl ; }
dextorer/BuildingForAndroidTV | public void setBackgroundImageUrl ( String bgImageUrl ) { mBgImageUrl = bgImageUrl ; }
dextorer/BuildingForAndroidTV | public String getCardImageUrl ( ) { return mCardImageUrl ; }
dextorer/BuildingForAndroidTV | public void setCardImageUrl ( String cardImageUrl ) { mCardImageUrl = cardImageUrl ; }
dextorer/BuildingForAndroidTV | public String getCategory ( ) { return mCategory ; }
dextorer/BuildingForAndroidTV | public void setCategory ( String category ) { mCategory = category ; }
dextorer/BuildingForAndroidTV | public URI getBackgroundImageURI ( ) { try { return new URI ( getBackgroundImageUrl ( ) ) ; } catch ( URISyntaxException e ) { return null ; } }
dextorer/BuildingForAndroidTV | public int describeContents ( ) { return 0 ; }
dextorer/BuildingForAndroidTV | @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeStringArray ( new String [ ] { mId , mTitle , mDescription , mBgImageUrl , mCardImageUrl , mVideoUrl , mStudio , mCategory } ) ; }
dextorer/BuildingForAndroidTV | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( 200 ) ; sb . append ( " Movie { " ) ; sb . append ( " mId = " + mId ) ; sb . append ( " , ▁ mTitle = ' " + mTitle + ' \' ' ) ; sb . append ( " , ▁ mVideoUrl = ' " + mVideoUrl + ' \' ' ) ; sb . append ( " , ▁ backgroundImageUrl = ' " + mBgImageUrl + ' \' ' ) ; sb . append ( " , ▁ backgroundImageURI = ' " + getBackgroundImageURI ( ) . toString ( ) + ' \' ' ) ; sb . append ( " , ▁ mCardImageUrl = ' " + mCardImageUrl + ' \' ' ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; }
gjordi/gwt-jquery-sparklines-lib | @ Override public void onModuleLoad ( ) { JQuerySparklinesClientBundle bundle = JQuerySparklinesClientBundle . INSTANCE ; logger . log ( Level . INFO , " Injecting ▁ sparklines ▁ javascript ▁ script ▁ element . " ) ; ScriptInjector . fromString ( bundle . sparklines ( ) . getText ( ) ) . setWindow ( ScriptInjector . TOP_WINDOW ) . inject ( ) ; }
JoelMarcey/buck | public PrebuiltGoLibraryDescription ( GoBuckConfig goBuckConfig , ToolchainProvider toolchainProvider ) { this . goBuckConfig = goBuckConfig ; this . toolchainProvider = toolchainProvider ; }
JoelMarcey/buck | @ Override public Class < PrebuiltGoLibraryDescriptionArg > getConstructorArgType ( ) { return PrebuiltGoLibraryDescriptionArg . class ; }
JoelMarcey/buck | @ Override public < U > Optional < U > createMetadata ( BuildTarget buildTarget , ActionGraphBuilder graphBuilder , CellPathResolver cellRoots , PrebuiltGoLibraryDescriptionArg args , Optional < ImmutableMap < BuildTarget , Version > > selectedVersions , Class < U > metadataClass ) { Optional < GoPlatform > platform = getGoToolchain ( buildTarget . getTargetConfiguration ( ) ) . getPlatformFlavorDomain ( ) . getValue ( buildTarget ) . map ( goPlatform -> goPlatform . resolve ( graphBuilder , buildTarget . getTargetConfiguration ( ) ) ) ; if ( metadataClass . isAssignableFrom ( GoLinkable . class ) ) { Preconditions . checkState ( platform . isPresent ( ) ) ; SourcePath output = graphBuilder . requireRule ( buildTarget ) . getSourcePathToOutput ( ) ; return Optional . of ( metadataClass . cast ( GoLinkable . of ( ImmutableMap . of ( args . getPackageName ( ) . map ( Paths :: get ) . orElse ( goBuckConfig . getDefaultPackageName ( buildTarget ) ) , output ) , args . getExportedDeps ( ) ) ) ) ; } else if ( buildTarget . getFlavors ( ) . contains ( GoDescriptors . TRANSITIVE_LINKABLES_FLAVOR ) ) { Preconditions . checkState ( platform . isPresent ( ) ) ; return Optional . of ( metadataClass . cast ( GoDescriptors . requireTransitiveGoLinkables ( buildTarget , graphBuilder , platform . get ( ) , Iterables . concat ( args . getDeps ( ) , args . getExportedDeps ( ) ) , true ) ) ) ; } else { return Optional . empty ( ) ; } }
JoelMarcey/buck | private GoToolchain getGoToolchain ( TargetConfiguration toolchainTargetConfiguration ) { return toolchainProvider . getByName ( GoToolchain . DEFAULT_NAME , toolchainTargetConfiguration , GoToolchain . class ) ; }
JoelMarcey/buck | @ Override public PrebuiltGoLibrary createBuildRule ( BuildRuleCreationContextWithTargetGraph context , BuildTarget buildTarget , BuildRuleParams params , PrebuiltGoLibraryDescriptionArg args ) { return new PrebuiltGoLibrary ( buildTarget , context . getProjectFilesystem ( ) , params , args . getPackageName ( ) . map ( Paths :: get ) . orElse ( goBuckConfig . getDefaultPackageName ( buildTarget ) ) , args . getLibrary ( ) , args . getExportedDeps ( ) ) ; }
coolcrowd/ObjectService | private ExperimentOuterClass ( ) { }
coolcrowd/ObjectService | com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner assigner = new com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner ( ) { public com . google . protobuf . ExtensionRegistry assignDescriptors ( com . google . protobuf . Descriptors . FileDescriptor root ) { descriptor = root ; return null ; } }
ericbottard/spring-cloud-dataflow | @ Before public void setupMockMVC ( ) { taskDefinitionRepository . save ( new TaskDefinition ( TASK_NAME_ORIG , " demo " ) ) ; appRegistry = mock ( AppRegistry . class ) ; resourceLoader = mock ( ResourceLoader . class ) ; metadataResolver = mock ( ApplicationConfigurationMetadataResolver . class ) ; taskLauncher = mock ( TaskLauncher . class ) ; when ( this . appRegistry . find ( anyString ( ) , any ( ApplicationType . class ) ) ) . thenReturn ( new AppRegistration ( " some - name " , task , URI . create ( " http : // helloworld " ) , resourceLoader ) ) ; when ( this . resourceLoader . getResource ( anyString ( ) ) ) . thenReturn ( mock ( Resource . class ) ) ; taskService = new DefaultTaskService ( dataSourceProperties , taskDefinitionRepository , taskExplorer , taskExecutionRepository , appRegistry , resourceLoader , taskLauncher , metadataResolver , new TaskConfigurationProperties ( ) , new InMemoryDeploymentIdRepository ( ) , null ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeSingleTaskTest ( ) { when ( taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; assertEquals ( 1L , this . taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeMultipleTasksTest ( ) { when ( taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; assertEquals ( 1L , this . taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ) ; assertEquals ( 2L , this . taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeTaskWithNullIDReturnedTest ( ) { boolean errorCaught = false ; when ( this . taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( null ) ; try { taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ; } catch ( IllegalStateException ise ) { errorCaught = true ; assertEquals ( " Deployment ▁ ID ▁ is ▁ null ▁ for ▁ the ▁ task : myTask _ ORIG " , ise . getMessage ( ) ) ; } if ( ! errorCaught ) { fail ( ) ; } }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeTaskWithNullDefinitionTest ( ) { boolean errorCaught = false ; when ( this . taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; TaskService taskService = new DefaultTaskService ( this . dataSourceProperties , mock ( TaskDefinitionRepository . class ) , this . taskExplorer , this . taskExecutionRepository , this . appRegistry , this . resourceLoader , this . taskLauncher , this . metadataResolver , new TaskConfigurationProperties ( ) , new InMemoryDeploymentIdRepository ( ) , null ) ; try { taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ; } catch ( NoSuchTaskDefinitionException ise ) { errorCaught = true ; assertEquals ( " Could ▁ not ▁ find ▁ task ▁ definition ▁ named ▁ myTask _ ORIG " , ise . getMessage ( ) ) ; } if ( ! errorCaught ) { fail ( ) ; } }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createSequenceComposedTask ( ) { String dsl = " AAA ▁ & & ▁ BBB " ; taskService . saveTaskDefinition ( " seqTask " , dsl ) ; verifyTaskExistsInRepo ( " seqTask " , dsl ) ; verifyTaskExistsInRepo ( " seqTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " seqTask - BBB " , " BBB " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createSplitComposedTask ( ) { String dsl = " < AAA ▁ | | ▁ BBB > " ; taskService . saveTaskDefinition ( " splitTask " , dsl ) ; verifyTaskExistsInRepo ( " splitTask " , dsl ) ; verifyTaskExistsInRepo ( " splitTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " splitTask - BBB " , " BBB " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void verifyComposedTaskFlag ( ) { String composedTaskDsl = " < AAA ▁ | | ▁ BBB > " ; assertTrue ( " Expected ▁ true ▁ for ▁ composed ▁ task " , taskService . isComposedDefinition ( composedTaskDsl ) ) ; composedTaskDsl = " AAA ▁ ' FAILED ' ▁ - > ▁ BBB ▁ ' * ' ▁ - > ▁ CCC " ; assertTrue ( " Expected ▁ true ▁ for ▁ composed ▁ task " , taskService . isComposedDefinition ( composedTaskDsl ) ) ; composedTaskDsl = " AAA ▁ & & ▁ BBB ▁ & & ▁ CCC " ; assertTrue ( " Expected ▁ true ▁ for ▁ composed ▁ task " , taskService . isComposedDefinition ( composedTaskDsl ) ) ; String nonComposedTaskDsl = " AAA " ; assertFalse ( " Expected ▁ false ▁ for ▁ non - composed ▁ task " , taskService . isComposedDefinition ( nonComposedTaskDsl ) ) ; nonComposedTaskDsl = " AAA ▁ - - foo = bar " ; assertFalse ( " Expected ▁ false ▁ for ▁ non - composed ▁ task " , taskService . isComposedDefinition ( nonComposedTaskDsl ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createTransitionComposedTask ( ) { String dsl = " AAA ▁ ' FAILED ' ▁ - > ▁ BBB ▁ ' * ' ▁ - > ▁ CCC " ; taskService . saveTaskDefinition ( " transitionTask " , dsl ) ; verifyTaskExistsInRepo ( " transitionTask " , dsl ) ; verifyTaskExistsInRepo ( " transitionTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " transitionTask - BBB " , " BBB " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createSimpleTask ( ) { taskService . saveTaskDefinition ( " simpleTask " , " AAA ▁ - - foo = bar " ) ; verifyTaskExistsInRepo ( " simpleTask " , " AAA ▁ - - foo = bar " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void deleteComposedTask ( ) { String dsl = " AAA ▁ & & ▁ BBB ▁ & & ▁ CCC " ; taskService . saveTaskDefinition ( " deleteTask " , dsl ) ; verifyTaskExistsInRepo ( " deleteTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " deleteTask - BBB " , " BBB " ) ; verifyTaskExistsInRepo ( " deleteTask - CCC " , " CCC " ) ; verifyTaskExistsInRepo ( " deleteTask " , dsl ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskService . deleteTaskDefinition ( " deleteTask " ) ; assertThat ( preDeleteSize - 4 , is ( equalTo ( taskDefinitionRepository . count ( ) ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void deleteComposedTaskDeleteOnlyChildren ( ) { taskService . saveTaskDefinition ( " deleteTask - AAA " , " AAA " ) ; String dsl = " BBB ▁ & & ▁ CCC " ; taskService . saveTaskDefinition ( " deleteTask " , dsl ) ; verifyTaskExistsInRepo ( " deleteTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " deleteTask - BBB " , " BBB " ) ; verifyTaskExistsInRepo ( " deleteTask - CCC " , " CCC " ) ; verifyTaskExistsInRepo ( " deleteTask " , dsl ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskService . deleteTaskDefinition ( " deleteTask " ) ; assertThat ( preDeleteSize - 3 , is ( equalTo ( taskDefinitionRepository . count ( ) ) ) ) ; verifyTaskExistsInRepo ( " deleteTask - AAA " , " AAA " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void deleteComposedTaskWithLabel ( ) { String dsl = " LLL : ▁ AAA ▁ & & ▁ BBB " ; taskService . saveTaskDefinition ( " deleteTask " , dsl ) ; verifyTaskExistsInRepo ( " deleteTask - LLL " , " AAA " ) ; verifyTaskExistsInRepo ( " deleteTask - BBB " , " BBB " ) ; verifyTaskExistsInRepo ( " deleteTask " , dsl ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskService . deleteTaskDefinition ( " deleteTask " ) ; assertThat ( preDeleteSize - 3 , is ( equalTo ( taskDefinitionRepository . count ( ) ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void verifyDataFlowUriProperty ( ) throws Exception { when ( this . taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; TaskService taskService = new DefaultTaskService ( this . dataSourceProperties , mock ( TaskDefinitionRepository . class ) , this . taskExplorer , this . taskExecutionRepository , this . appRegistry , this . resourceLoader , this . taskLauncher , this . metadataResolver , new TaskConfigurationProperties ( ) , new InMemoryDeploymentIdRepository ( ) , " http : // myserver : 9191" ) ; List < String > cmdLineArgs = new ArrayList < > ( ) ; Method method = ReflectionUtils . findMethod ( DefaultTaskService . class , " updateDataFlowUriIfNeeded " , Map . class , List . class ) ; ReflectionUtils . makeAccessible ( method ) ; Map < String , String > appDeploymentProperties = new HashMap < > ( ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ expected ▁ to ▁ be ▁ in ▁ the ▁ app ▁ deployment ▁ properties " , appDeploymentProperties . get ( " dataflowServerUri " ) . equals ( " http : // myserver : 9191" ) ) ; appDeploymentProperties . clear ( ) ; appDeploymentProperties . put ( " dataflow - server - uri " , " http : // localhost : 8080" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ incorrect " , appDeploymentProperties . get ( " dataflow - server - uri " ) . equals ( " http : // localhost : 8080" ) ) ; appDeploymentProperties . clear ( ) ; appDeploymentProperties . put ( " dataflowServerUri " , " http : // localhost : 8191" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ incorrect " , appDeploymentProperties . get ( " dataflowServerUri " ) . equals ( " http : // localhost : 8191" ) ) ; appDeploymentProperties . clear ( ) ; appDeploymentProperties . put ( " DATAFLOW _ SERVER _ URI " , " http : // localhost : 9000" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ incorrect " , appDeploymentProperties . get ( " DATAFLOW _ SERVER _ URI " ) . equals ( " http : // localhost : 9000" ) ) ; appDeploymentProperties . clear ( ) ; cmdLineArgs . add ( " - - dataflowServerUri = http : // localhost : 8383" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; cmdLineArgs . clear ( ) ; cmdLineArgs . add ( " DATAFLOW _ SERVER _ URI = http : // localhost : 8383" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " DATAFLOW - SERVER - URI " ) ) ; }
ericbottard/spring-cloud-dataflow | private void verifyTaskExistsInRepo ( String taskName , String dsl ) { TaskDefinition taskDefinition = taskDefinitionRepository . findOne ( taskName ) ; assertThat ( taskDefinition . getName ( ) , is ( equalTo ( taskName ) ) ) ; assertThat ( taskDefinition . getDslText ( ) , is ( equalTo ( dsl ) ) ) ; }
asgarth/snow | public StatusBarFooter ( final ApplicationWindow parent ) { this ( parent , SWT . BORDER | SWT . SHADOW_OUT ) ; }
asgarth/snow | public StatusBarFooter ( final ApplicationWindow parent , final int style ) { super ( parent , style ) ; final FillLayout layout = new FillLayout ( ) ; layout . marginWidth = 5 ; setLayout ( layout ) ; status = new CLabel ( this , SWT . NONE ) ; }
asgarth/snow | public void log ( final String message ) { status . setText ( message ) ; }
asgarth/snow | public void error ( final String message ) { status . setText ( message ) ; }
asgarth/snow | @ Override public int getHeight ( ) { return HEIGHT ; }
andyj24/googleads-java-lib | public ThirdPartyAudienceSegmentAudienceSegmentApprovalStatus getApprovalStatus ( ) { return approvalStatus ; }
andyj24/googleads-java-lib | public void setApprovalStatus ( ThirdPartyAudienceSegmentAudienceSegmentApprovalStatus value ) { this . approvalStatus = value ; }
andyj24/googleads-java-lib | public Money getCost ( ) { return cost ; }
andyj24/googleads-java-lib | public void setCost ( Money value ) { this . cost = value ; }
andyj24/googleads-java-lib | public DateTime getStartDateTime ( ) { return startDateTime ; }
andyj24/googleads-java-lib | public void setStartDateTime ( DateTime value ) { this . startDateTime = value ; }
andyj24/googleads-java-lib | public DateTime getEndDateTime ( ) { return endDateTime ; }
andyj24/googleads-java-lib | public void setEndDateTime ( DateTime value ) { this . endDateTime = value ; }
nikolai-m/nmatveev | public Point ( int x , int y ) { this . x = x ; this . y = y ; }
nikolai-m/nmatveev | public int getX ( ) { return this . x ; }
nikolai-m/nmatveev | public int getY ( ) { return this . y ; }
nikolai-m/nmatveev | public boolean is ( int a , int b ) { return y == ( ( a * x ) + b ) ; }
coding0011/elasticsearch | @ Before public void setup ( ) throws IOException { String yaml = " / org / elasticsearch / index / analysis / phonetic - 1 . yml " ; Settings settings = Settings . builder ( ) . loadFromStream ( yaml , getClass ( ) . getResourceAsStream ( yaml ) , false ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) . build ( ) ; this . analysis = createTestAnalysis ( new Index ( " test " , " _ na _ " ) , settings , new AnalysisPhoneticPlugin ( ) ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterFactory ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " phonetic " ) ; MatcherAssert . assertThat ( filterFactory , instanceOf ( PhoneticTokenFilterFactory . class ) ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterBeiderMorseNoLanguage ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " beidermorsefilter " ) ; Tokenizer tokenizer = new WhitespaceTokenizer ( ) ; tokenizer . setReader ( new StringReader ( " ABADIAS " ) ) ; String [ ] expected = new String [ ] { " abYdias " , " abYdios " , " abadia " , " abadiaS " , " abadias " , " abadio " , " abadioS " , " abadios " , " abodia " , " abodiaS " , " abodias " , " abodio " , " abodioS " , " abodios " , " avadias " , " avadios " , " avodias " , " avodios " , " obadia " , " obadiaS " , " obadias " , " obadio " , " obadioS " , " obadios " , " obodia " , " obodiaS " , " obodias " , " obodioS " } ; BaseTokenStreamTestCase . assertTokenStreamContents ( filterFactory . create ( tokenizer ) , expected ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterBeiderMorseWithLanguage ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " beidermorsefilterfrench " ) ; Tokenizer tokenizer = new WhitespaceTokenizer ( ) ; tokenizer . setReader ( new StringReader ( " Rimbault " ) ) ; String [ ] expected = new String [ ] { " rimbD " , " rimbDlt " , " rimba " , " rimbalt " , " rimbo " , " rimbolt " , " rimbu " , " rimbult " , " rmbD " , " rmbDlt " , " rmba " , " rmbalt " , " rmbo " , " rmbolt " , " rmbu " , " rmbult " } ; BaseTokenStreamTestCase . assertTokenStreamContents ( filterFactory . create ( tokenizer ) , expected ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterDaitchMotokoff ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " daitch _ mokotoff " ) ; Tokenizer tokenizer = new WhitespaceTokenizer ( ) ; tokenizer . setReader ( new StringReader ( " chauptman " ) ) ; String [ ] expected = new String [ ] { "473660" , "573660" } ; assertThat ( filterFactory . create ( tokenizer ) , instanceOf ( DaitchMokotoffSoundexFilter . class ) ) ; BaseTokenStreamTestCase . assertTokenStreamContents ( filterFactory . create ( tokenizer ) , expected ) ; }
ernestp/consulo | CacheEntry ( int visualLine , @ NotNull Editor editor ) { this . visualLine = visualLine ; myEditor = editor ; }
ernestp/consulo | public void setLineStartPosition ( @ NotNull EditorPosition context ) { assert context . visualColumn == 0 ; startLogicalLine = context . logicalLine ; startLogicalColumn = context . logicalColumn ; visualLine = context . visualLine ; startOffset = context . offset ; startSoftWrapLinesBefore = context . softWrapLinesBefore ; startSoftWrapLinesCurrent = context . softWrapLinesCurrent ; startSoftWrapColumnDiff = context . softWrapColumnDiff ; startFoldedLines = context . foldedLines ; startFoldingColumnDiff = context . foldingColumnDiff ; }
ernestp/consulo | public void setLineEndPosition ( @ NotNull EditorPosition position ) { endOffset = position . offset ; endLogicalLine = position . logicalLine ; endLogicalColumn = position . logicalColumn ; endVisualColumn = position . visualColumn ; endSoftWrapLinesBefore = position . softWrapLinesBefore ; endSoftWrapLinesCurrent = position . softWrapLinesCurrent ; endSoftWrapColumnDiff = position . softWrapColumnDiff ; endFoldedLines = position . foldedLines ; endFoldingColumnDiff = position . foldingColumnDiff ; }
ernestp/consulo | public EditorPosition buildStartLinePosition ( ) { EditorPosition result = new EditorPosition ( myEditor ) ; result . logicalLine = startLogicalLine ; result . logicalColumn = startLogicalColumn ; result . offset = startOffset ; result . visualLine = visualLine ; result . visualColumn = 0 ; result . softWrapLinesBefore = startSoftWrapLinesBefore ; result . softWrapLinesCurrent = startSoftWrapLinesCurrent ; result . softWrapColumnDiff = startSoftWrapColumnDiff ; result . foldedLines = startFoldedLines ; result . foldingColumnDiff = startFoldingColumnDiff ; return result ; }
ernestp/consulo | public EditorPosition buildEndLinePosition ( ) { EditorPosition result = new EditorPosition ( myEditor ) ; result . logicalLine = endLogicalLine ; result . logicalColumn = endLogicalColumn ; result . offset = endOffset ; result . visualLine = visualLine ; result . visualColumn = endVisualColumn ; result . softWrapLinesBefore = endSoftWrapLinesBefore ; result . softWrapLinesCurrent = endSoftWrapLinesCurrent ; result . softWrapColumnDiff = endSoftWrapColumnDiff ; result . foldedLines = endFoldedLines ; result . foldingColumnDiff = endFoldingColumnDiff ; return result ; }
ernestp/consulo | public void removeAllDataAtOrAfter ( final int offset ) { if ( myFoldingData != DUMMY && ! myFoldingData . isEmpty ( ) ) { myFoldingData . retainEntries ( new TIntObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( int a , FoldingData b ) { return a < offset ; } } ) ; } int i ; for ( i = 0 ; i < myTabPositions . size ( ) ; i ++ ) { if ( myTabPositions . get ( i ) . offset >= offset ) { break ; } } myTabPositions . subList ( i , myTabPositions . size ( ) ) . clear ( ) ; }
ernestp/consulo | @ Nullable public FoldingData getFoldingData ( @ NotNull final FoldRegion region ) { FoldingData candidate = myFoldingData . get ( region . getStartOffset ( ) ) ; if ( candidate != null ) { return candidate ; } final Ref < FoldingData > result = new Ref < FoldingData > ( ) ; myFoldingData . forEachValue ( new TObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( FoldingData data ) { if ( data . getFoldRegion ( ) . equals ( region ) ) { result . set ( data ) ; return false ; } return true ; } } ) ; return result . get ( ) ; }
ernestp/consulo | public void store ( FoldingData foldData , int offset ) { if ( myFoldingData == DUMMY ) { myFoldingData = new TIntObjectHashMap < FoldingData > ( ) ; } myFoldingData . put ( offset , foldData ) ; }
ernestp/consulo | public List < TabData > getTabData ( ) { return myTabPositions ; }
ernestp/consulo | public void storeTabData ( TabData tabData ) { if ( myTabPositions == Collections . EMPTY_LIST ) { myTabPositions = new ArrayList < TabData > ( ) ; } myTabPositions . add ( tabData ) ; }
ernestp/consulo | public void advance ( final int offsetDiff ) { startOffset += offsetDiff ; endOffset += offsetDiff ; for ( int i = 0 ; i < myTabPositions . size ( ) ; i ++ ) { myTabPositions . get ( i ) . offset += offsetDiff ; } if ( myFoldingData . isEmpty ( ) ) { return ; } final TIntObjectHashMap < FoldingData > newFoldingData = new TIntObjectHashMap < FoldingData > ( myFoldingData . size ( ) ) ; myFoldingData . forEachEntry ( new TIntObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( int offset , FoldingData foldingData ) { newFoldingData . put ( offset + offsetDiff , foldingData ) ; return true ; } } ) ; myFoldingData = newFoldingData ; }
ernestp/consulo | @ TestOnly public TIntObjectHashMap < FoldingData > getFoldingData ( ) { return myFoldingData ; }
ernestp/consulo | @ Override public int compareTo ( CacheEntry e ) { return visualLine - e . visualLine ; }
ernestp/consulo | @ Override public String toString ( ) { return String . format ( " % d ▁ - ▁ visual ▁ line : ▁ % d , ▁ offsets : ▁ % d - % d , ▁ logical ▁ lines : ▁ % d - % d , ▁ logical ▁ columns : ▁ % d - % d , ▁ end ▁ visual ▁ column : ▁ % d , ▁ " + " fold ▁ regions : ▁ % s , ▁ tab ▁ data : ▁ % s " , System . identityHashCode ( this ) , visualLine , startOffset , endOffset , startLogicalLine , endLogicalLine , startLogicalColumn , endLogicalColumn , endVisualColumn , Arrays . toString ( myFoldingData . getValues ( ) ) , myTabPositions ) ; }
ernestp/consulo | @ Override protected CacheEntry clone ( ) { final CacheEntry result = new CacheEntry ( visualLine , myEditor ) ; result . startLogicalLine = startLogicalLine ; result . startLogicalColumn = startLogicalColumn ; result . startOffset = startOffset ; result . startSoftWrapLinesBefore = startSoftWrapLinesBefore ; result . startSoftWrapLinesCurrent = startSoftWrapLinesCurrent ; result . startSoftWrapColumnDiff = startSoftWrapColumnDiff ; result . startFoldedLines = startFoldedLines ; result . startFoldingColumnDiff = startFoldingColumnDiff ; result . endOffset = endOffset ; result . endLogicalLine = endLogicalLine ; result . endLogicalColumn = endLogicalColumn ; result . endVisualColumn = endVisualColumn ; result . endSoftWrapLinesBefore = endSoftWrapLinesBefore ; result . endSoftWrapLinesCurrent = endSoftWrapLinesCurrent ; result . endSoftWrapColumnDiff = endSoftWrapColumnDiff ; result . endFoldedLines = endFoldedLines ; result . endFoldingColumnDiff = endFoldingColumnDiff ; myFoldingData . forEachEntry ( new TIntObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( int offset , FoldingData foldData ) { result . store ( foldData , offset ) ; return true ; } } ) ; for ( TabData tabPosition : myTabPositions ) { result . storeTabData ( tabPosition ) ; } return result ; }
midiao/isst | private ArchiveCategory ( String subUrl , String nameInDB ) { this . subUrl = subUrl ; this . nameInDB = nameInDB ; }
midiao/isst | public String getSubUrl ( ) { return subUrl ; }
midiao/isst | public String getNameInDB ( ) { return nameInDB ; }
