AliaksandrShuhayeu/pentaho-kettle | public JobEntrySSH2PUT ( String n ) { super ( n , " " ) ; serverName = null ; publicpublickey = false ; keyFilename = null ; keyFilePass = null ; usehttpproxy = false ; httpproxyhost = null ; httpproxyport = null ; httpproxyusername = null ; httpProxyPassword = null ; serverPort = "22" ; useBasicAuthentication = false ; createRemoteFolder = false ; afterFtpPut = " do _ nothing " ; destinationfolder = null ; createDestinationFolder = false ; cachehostkey = false ; timeout = 0 ; }
AliaksandrShuhayeu/pentaho-kettle | public JobEntrySSH2PUT ( ) { this ( " " ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public Object clone ( ) { JobEntrySSH2PUT je = ( JobEntrySSH2PUT ) super . clone ( ) ; return je ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public String getXML ( ) { StringBuffer retval = new StringBuffer ( 128 ) ; retval . append ( super . getXML ( ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " servername " , serverName ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " username " , userName ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " password " , Encr . encryptPasswordIfNotUsingVariables ( getPassword ( ) ) ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " serverport " , serverPort ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " ftpdirectory " , ftpDirectory ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " localdirectory " , localDirectory ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " wildcard " , wildcard ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " only _ new " , onlyGettingNewFiles ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " usehttpproxy " , usehttpproxy ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxyhost " , httpproxyhost ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxyport " , httpproxyport ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxyusername " , httpproxyusername ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " httpproxypassword " , httpProxyPassword ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " publicpublickey " , publicpublickey ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " keyfilename " , keyFilename ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " keyfilepass " , keyFilePass ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " usebasicauthentication " , useBasicAuthentication ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " createremotefolder " , createRemoteFolder ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " afterftpput " , afterFtpPut ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " destinationfolder " , destinationfolder ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " createdestinationfolder " , createDestinationFolder ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " cachehostkey " , cachehostkey ) ) ; retval . append ( " ▁ ▁ ▁ ▁ ▁ ▁ " ) . append ( XMLHandler . addTagValue ( " timeout " , timeout ) ) ; return retval . toString ( ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void loadXML ( Node entrynode , List < DatabaseMeta > databases , List < SlaveServer > slaveServers , Repository rep , IMetaStore metaStore ) throws KettleXMLException { try { super . loadXML ( entrynode , databases , slaveServers ) ; serverName = XMLHandler . getTagValue ( entrynode , " servername " ) ; userName = XMLHandler . getTagValue ( entrynode , " username " ) ; password = Encr . decryptPasswordOptionallyEncrypted ( XMLHandler . getTagValue ( entrynode , " password " ) ) ; serverPort = XMLHandler . getTagValue ( entrynode , " serverport " ) ; ftpDirectory = XMLHandler . getTagValue ( entrynode , " ftpdirectory " ) ; localDirectory = XMLHandler . getTagValue ( entrynode , " localdirectory " ) ; wildcard = XMLHandler . getTagValue ( entrynode , " wildcard " ) ; onlyGettingNewFiles = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " only _ new " ) ) ; usehttpproxy = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " usehttpproxy " ) ) ; httpproxyhost = XMLHandler . getTagValue ( entrynode , " httpproxyhost " ) ; httpproxyport = XMLHandler . getTagValue ( entrynode , " httpproxyport " ) ; httpproxyusername = XMLHandler . getTagValue ( entrynode , " httpproxyusername " ) ; httpProxyPassword = XMLHandler . getTagValue ( entrynode , " httpproxypassword " ) ; publicpublickey = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " publicpublickey " ) ) ; keyFilename = XMLHandler . getTagValue ( entrynode , " keyfilename " ) ; keyFilePass = XMLHandler . getTagValue ( entrynode , " keyfilepass " ) ; useBasicAuthentication = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " usebasicauthentication " ) ) ; createRemoteFolder = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " createremotefolder " ) ) ; afterFtpPut = XMLHandler . getTagValue ( entrynode , " afterftpput " ) ; destinationfolder = XMLHandler . getTagValue ( entrynode , " destinationfolder " ) ; createDestinationFolder = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " createdestinationfolder " ) ) ; cachehostkey = " Y " . equalsIgnoreCase ( XMLHandler . getTagValue ( entrynode , " cachehostkey " ) ) ; timeout = Const . toInt ( XMLHandler . getTagValue ( entrynode , " timeout " ) , 0 ) ; } catch ( KettleXMLException xe ) { throw new KettleXMLException ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . UnableLoadXML " , xe . getMessage ( ) ) ) ; } }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void loadRep ( Repository rep , IMetaStore metaStore , ObjectId id_jobentry , List < DatabaseMeta > databases , List < SlaveServer > slaveServers ) throws KettleException { try { serverName = rep . getJobEntryAttributeString ( id_jobentry , " servername " ) ; userName = rep . getJobEntryAttributeString ( id_jobentry , " username " ) ; password = Encr . decryptPasswordOptionallyEncrypted ( rep . getJobEntryAttributeString ( id_jobentry , " password " ) ) ; serverPort = rep . getJobEntryAttributeString ( id_jobentry , " serverport " ) ; ftpDirectory = rep . getJobEntryAttributeString ( id_jobentry , " ftpdirectory " ) ; localDirectory = rep . getJobEntryAttributeString ( id_jobentry , " localdirectory " ) ; wildcard = rep . getJobEntryAttributeString ( id_jobentry , " wildcard " ) ; onlyGettingNewFiles = rep . getJobEntryAttributeBoolean ( id_jobentry , " only _ new " ) ; usehttpproxy = rep . getJobEntryAttributeBoolean ( id_jobentry , " usehttpproxy " ) ; httpproxyhost = rep . getJobEntryAttributeString ( id_jobentry , " httpproxyhost " ) ; httpproxyusername = rep . getJobEntryAttributeString ( id_jobentry , " httpproxyusername " ) ; httpProxyPassword = rep . getJobEntryAttributeString ( id_jobentry , " httpproxypassword " ) ; publicpublickey = rep . getJobEntryAttributeBoolean ( id_jobentry , " publicpublickey " ) ; keyFilename = rep . getJobEntryAttributeString ( id_jobentry , " keyfilename " ) ; keyFilePass = rep . getJobEntryAttributeString ( id_jobentry , " keyfilepass " ) ; useBasicAuthentication = rep . getJobEntryAttributeBoolean ( id_jobentry , " usebasicauthentication " ) ; createRemoteFolder = rep . getJobEntryAttributeBoolean ( id_jobentry , " createremotefolder " ) ; afterFtpPut = rep . getJobEntryAttributeString ( id_jobentry , " afterftpput " ) ; destinationfolder = rep . getJobEntryAttributeString ( id_jobentry , " destinationfolder " ) ; createDestinationFolder = rep . getJobEntryAttributeBoolean ( id_jobentry , " createdestinationfolder " ) ; cachehostkey = rep . getJobEntryAttributeBoolean ( id_jobentry , " cachehostkey " ) ; timeout = ( int ) rep . getJobEntryAttributeInteger ( id_jobentry , " timeout " ) ; } catch ( KettleException dbe ) { throw new KettleException ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . UnableLoadRep " , " " + id_jobentry , dbe . getMessage ( ) ) ) ; } }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void saveRep ( Repository rep , IMetaStore metaStore , ObjectId id_job ) throws KettleException { try { rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " servername " , serverName ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " username " , userName ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " password " , Encr . encryptPasswordIfNotUsingVariables ( password ) ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " serverport " , serverPort ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " ftpdirectory " , ftpDirectory ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " localdirectory " , localDirectory ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " wildcard " , wildcard ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " only _ new " , onlyGettingNewFiles ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " usehttpproxy " , usehttpproxy ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxyhost " , httpproxyhost ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxyport " , httpproxyport ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxyusername " , httpproxyusername ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " httpproxypassword " , httpProxyPassword ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " publicpublickey " , publicpublickey ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " keyfilename " , keyFilename ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " keyfilepass " , keyFilePass ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " usebasicauthentication " , useBasicAuthentication ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " createremotefolder " , createRemoteFolder ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " afterftpput " , afterFtpPut ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " destinationfolder " , destinationfolder ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " createdestinationfolder " , createDestinationFolder ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " cachehostkey " , cachehostkey ) ; rep . saveJobEntryAttribute ( id_job , getObjectId ( ) , " timeout " , timeout ) ; } catch ( KettleDatabaseException dbe ) { throw new KettleException ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . UnableSaveRep " , " " + id_job , dbe . getMessage ( ) ) ) ; } }
AliaksandrShuhayeu/pentaho-kettle | public String getFtpDirectory ( ) { return ftpDirectory ; }
AliaksandrShuhayeu/pentaho-kettle | public void setFtpDirectory ( String directory ) { this . ftpDirectory = directory ; }
AliaksandrShuhayeu/pentaho-kettle | public String getPassword ( ) { return password ; }
AliaksandrShuhayeu/pentaho-kettle | public void setPassword ( String password ) { this . password = password ; }
AliaksandrShuhayeu/pentaho-kettle | public String getAfterFTPPut ( ) { return afterFtpPut ; }
AliaksandrShuhayeu/pentaho-kettle | public void setAfterFTPPut ( String afterFtpPut ) { this . afterFtpPut = afterFtpPut ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyPassword ( String httpProxyPassword ) { this . httpProxyPassword = httpProxyPassword ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyPassword ( ) { return httpProxyPassword ; }
AliaksandrShuhayeu/pentaho-kettle | public void setKeyFilepass ( String keyFilePass ) { this . keyFilePass = keyFilePass ; }
AliaksandrShuhayeu/pentaho-kettle | public String getKeyFilepass ( ) { return keyFilePass ; }
AliaksandrShuhayeu/pentaho-kettle | public String getServerName ( ) { return serverName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setServerName ( String serverName ) { this . serverName = serverName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyHost ( String proxyhost ) { this . httpproxyhost = proxyhost ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyHost ( ) { return httpproxyhost ; }
AliaksandrShuhayeu/pentaho-kettle | public void setKeyFilename ( String keyFilename ) { this . keyFilename = keyFilename ; }
AliaksandrShuhayeu/pentaho-kettle | public String getKeyFilename ( ) { return keyFilename ; }
AliaksandrShuhayeu/pentaho-kettle | public String getUserName ( ) { return userName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUserName ( String userName ) { this . userName = userName ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyUsername ( String proxyusername ) { this . httpproxyusername = proxyusername ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyUsername ( ) { return httpproxyusername ; }
AliaksandrShuhayeu/pentaho-kettle | public String getWildcard ( ) { return wildcard ; }
AliaksandrShuhayeu/pentaho-kettle | public void setWildcard ( String wildcard ) { this . wildcard = wildcard ; }
AliaksandrShuhayeu/pentaho-kettle | public String getlocalDirectory ( ) { return localDirectory ; }
AliaksandrShuhayeu/pentaho-kettle | public void setlocalDirectory ( String localDirectory ) { this . localDirectory = localDirectory ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isOnlyGettingNewFiles ( ) { return onlyGettingNewFiles ; }
AliaksandrShuhayeu/pentaho-kettle | public void setOnlyGettingNewFiles ( boolean onlyGettingNewFiles ) { this . onlyGettingNewFiles = onlyGettingNewFiles ; }
AliaksandrShuhayeu/pentaho-kettle | public void setCacheHostKey ( boolean cachehostkeyin ) { this . cachehostkey = cachehostkeyin ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isCacheHostKey ( ) { return cachehostkey ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUseHTTPProxy ( boolean httpproxy ) { this . usehttpproxy = httpproxy ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isUseHTTPProxy ( ) { return usehttpproxy ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isUseBasicAuthentication ( ) { return useBasicAuthentication ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUseBasicAuthentication ( boolean useBasicAuthenticationin ) { this . useBasicAuthentication = useBasicAuthenticationin ; }
AliaksandrShuhayeu/pentaho-kettle | public void setCreateRemoteFolder ( boolean createRemoteFolder ) { this . createRemoteFolder = createRemoteFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isCreateRemoteFolder ( ) { return createRemoteFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public void setCreateDestinationFolder ( boolean createDestinationFolder ) { this . createDestinationFolder = createDestinationFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isCreateDestinationFolder ( ) { return createDestinationFolder ; }
AliaksandrShuhayeu/pentaho-kettle | public void setUsePublicKey ( boolean publickey ) { this . publicpublickey = publickey ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean isUsePublicKey ( ) { return publicpublickey ; }
AliaksandrShuhayeu/pentaho-kettle | public String getServerPort ( ) { return serverPort ; }
AliaksandrShuhayeu/pentaho-kettle | public void setServerPort ( String serverPort ) { this . serverPort = serverPort ; }
AliaksandrShuhayeu/pentaho-kettle | public void setHTTPProxyPort ( String proxyport ) { this . httpproxyport = proxyport ; }
AliaksandrShuhayeu/pentaho-kettle | public String getHTTPProxyPort ( ) { return httpproxyport ; }
AliaksandrShuhayeu/pentaho-kettle | public void setDestinationFolder ( String destinationfolderin ) { this . destinationfolder = destinationfolderin ; }
AliaksandrShuhayeu/pentaho-kettle | public String getDestinationFolder ( ) { return destinationfolder ; }
AliaksandrShuhayeu/pentaho-kettle | public void setTimeout ( int timeout ) { this . timeout = timeout ; }
AliaksandrShuhayeu/pentaho-kettle | public int getTimeout ( ) { return timeout ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public Result execute ( Result previousResult , int nr ) { Result result = previousResult ; result . setResult ( false ) ; try { String realServerName = environmentSubstitute ( serverName ) ; int realServerPort = Const . toInt ( environmentSubstitute ( serverPort ) , 22 ) ; String realUserName = environmentSubstitute ( userName ) ; String realServerPassword = Encr . decryptPasswordOptionallyEncrypted ( environmentSubstitute ( password ) ) ; String realProxyHost = environmentSubstitute ( httpproxyhost ) ; int realProxyPort = Const . toInt ( environmentSubstitute ( httpproxyport ) , 22 ) ; String realproxyUserName = environmentSubstitute ( httpproxyusername ) ; String realProxyPassword = Encr . decryptPasswordOptionallyEncrypted ( environmentSubstitute ( httpProxyPassword ) ) ; String realKeyFilename = environmentSubstitute ( keyFilename ) ; String relKeyFilepass = environmentSubstitute ( keyFilePass ) ; String realLocalDirectory = environmentSubstitute ( localDirectory ) ; String realwildcard = environmentSubstitute ( wildcard ) ; String realftpDirectory = environmentSubstitute ( ftpDirectory ) ; String realDestinationFolder = environmentSubstitute ( destinationfolder ) ; try { realftpDirectory = FTPUtils . normalizePath ( realftpDirectory ) ; realDestinationFolder = FTPUtils . normalizePath ( realDestinationFolder ) ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . CanNotNormalizePath " , e . getMessage ( ) ) ) ; result . setNrErrors ( 1 ) ; return result ; } boolean mandatoryok = true ; if ( Utils . isEmpty ( realServerName ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . ServernameMissing " ) ) ; } if ( usehttpproxy ) { if ( Utils . isEmpty ( realProxyHost ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . HttpProxyhostMissing " ) ) ; } } if ( publicpublickey ) { if ( Utils . isEmpty ( realKeyFilename ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . KeyFileMissing " ) ) ; } else { if ( ! KettleVFS . fileExists ( realKeyFilename , this ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . KeyFileNotExist " ) ) ; } } } if ( Utils . isEmpty ( realLocalDirectory ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . LocalFolderMissing " ) ) ; } if ( afterFtpPut . equals ( " move _ file " ) ) { if ( Utils . isEmpty ( realDestinationFolder ) ) { mandatoryok = false ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . DestinatFolderMissing " ) ) ; } else { FileObject folder = null ; try { folder = KettleVFS . getFileObject ( realDestinationFolder , this ) ; if ( ! folder . exists ( ) ) { if ( createDestinationFolder ) { folder . createFolder ( ) ; } else { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . DestinatFolderNotExist " , realDestinationFolder ) ) ; } } } catch ( Exception e ) { throw new KettleException ( e ) ; } finally { if ( folder != null ) { try { folder . close ( ) ; folder = null ; } catch ( Exception e ) { } } } } } if ( mandatoryok ) { Connection conn = null ; SFTPv3Client client = null ; boolean good = true ; int nbfilestoput = 0 ; int nbput = 0 ; int nbrerror = 0 ; try { conn = getConnection ( realServerName , realServerPort , realProxyHost , realProxyPort , realproxyUserName , realProxyPassword ) ; if ( timeout > 0 ) { if ( cachehostkey ) { conn . connect ( new SimpleVerifier ( database ) , 0 , timeout * 1000 ) ; } else { conn . connect ( null , 0 , timeout * 1000 ) ; } } else { if ( cachehostkey ) { conn . connect ( new SimpleVerifier ( database ) ) ; } else { conn . connect ( ) ; } } boolean isAuthenticated = false ; if ( publicpublickey ) { String keyContent = KettleVFS . getTextFileContent ( realKeyFilename , this , Const . XML_ENCODING ) ; isAuthenticated = conn . authenticateWithPublicKey ( realUserName , keyContent . toCharArray ( ) , relKeyFilepass ) ; } else { isAuthenticated = conn . authenticateWithPassword ( realUserName , realServerPassword ) ; } if ( isAuthenticated == false ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . AuthenticationFailed " ) ) ; } else { if ( log . isBasic ( ) ) { logBasic ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Connected " , serverName , userName ) ) ; } client = new SFTPv3Client ( conn ) ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . ProtocolVersion " , " " + client . getProtocolVersion ( ) ) ) ; } if ( ! Utils . isEmpty ( realftpDirectory ) ) { if ( ! sshDirectoryExists ( client , realftpDirectory ) ) { good = false ; if ( createRemoteFolder ) { good = CreateRemoteFolder ( client , realftpDirectory ) ; if ( good ) { logBasic ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . RemoteDirectoryCreated " ) ) ; } } else { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . RemoteDirectoryNotExist " , realftpDirectory ) ) ; } } else if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . RemoteDirectoryExist " , realftpDirectory ) ) ; } } if ( good ) { List < FileObject > myFileList = getFiles ( realLocalDirectory ) ; Pattern pattern = null ; if ( ! Utils . isEmpty ( realwildcard ) ) { pattern = Pattern . compile ( realwildcard ) ; } for ( int i = 0 ; i < myFileList . size ( ) && ! parentJob . isStopped ( ) ; i ++ ) { FileObject myFile = myFileList . get ( i ) ; String localFilename = myFile . toString ( ) ; String remoteFilename = myFile . getName ( ) . getBaseName ( ) ; boolean getIt = true ; if ( pattern != null ) { Matcher matcher = pattern . matcher ( remoteFilename ) ; getIt = matcher . matches ( ) ; } if ( ! Utils . isEmpty ( realftpDirectory ) ) { remoteFilename = realftpDirectory + FTPUtils . FILE_SEPARATOR + remoteFilename ; } if ( onlyGettingNewFiles ) { getIt = ! sshFileExists ( client , remoteFilename ) ; } if ( getIt ) { nbfilestoput ++ ; boolean putok = putFile ( myFile , remoteFilename , client ) ; if ( ! putok ) { nbrerror ++ ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . CanNotPutFile " , localFilename ) ) ; } else { nbput ++ ; } if ( putok && ! afterFtpPut . equals ( " do _ nothing " ) ) { deleteOrMoveFiles ( myFile , realDestinationFolder ) ; } } } if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . JobEntryEnd1" ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . TotalFiles " , " " + nbfilestoput ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . TotalFilesPut " , " " + nbput ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . TotalFilesError " , " " + nbrerror ) ) ; logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Result . JobEntryEnd2" ) ) ; } if ( nbrerror == 0 ) { result . setResult ( true ) ; } } } } catch ( Exception e ) { result . setNrErrors ( nbrerror ) ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . ErrorFTP " , e . getMessage ( ) ) ) ; } finally { if ( conn != null ) { conn . close ( ) ; } if ( client != null ) { client . close ( ) ; } } } } catch ( Exception e ) { result . setResult ( false ) ; result . setNrErrors ( 1L ) ; logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . UnexpectedError " ) , e ) ; } return result ; }
AliaksandrShuhayeu/pentaho-kettle | private Connection getConnection ( String servername , int serverport , String proxyhost , int proxyport , String proxyusername , String proxypassword ) { Connection connect = new Connection ( servername , serverport ) ; if ( usehttpproxy ) { connect . setProxyData ( new HTTPProxyData ( proxyhost , proxyport ) ) ; if ( useBasicAuthentication ) { connect . setProxyData ( new HTTPProxyData ( proxyhost , proxyport , proxyusername , proxypassword ) ) ; } } return connect ; }
AliaksandrShuhayeu/pentaho-kettle | private boolean putFile ( FileObject localFile , String remotefilename , SFTPv3Client sftpClient ) { long filesize = - 1 ; InputStream in = null ; BufferedInputStream inBuf = null ; SFTPv3FileHandle sftpFileHandle = null ; boolean retval = false ; try { sftpFileHandle = sftpClient . createFileTruncate ( remotefilename ) ; in = KettleVFS . getInputStream ( localFile ) ; inBuf = new BufferedInputStream ( in ) ; byte [ ] buf = new byte [ 2048 ] ; long offset = 0 ; long length = localFile . getContent ( ) . getSize ( ) ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . SendingFile " , localFile . toString ( ) , " " + length , remotefilename ) ) ; } while ( true ) { int len = in . read ( buf , 0 , buf . length ) ; if ( len <= 0 ) { break ; } sftpClient . write ( sftpFileHandle , offset , buf , 0 , len ) ; offset += len ; } filesize = getFileSize ( sftpClient , remotefilename ) ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . FileOnRemoteHost " , remotefilename , " " + filesize ) ) ; } retval = true ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . ErrorCopyingFile " , localFile . toString ( ) ) + " : " + e . getMessage ( ) ) ; } finally { if ( in != null ) { try { in . close ( ) ; in = null ; } catch ( Exception ex ) { } } if ( inBuf != null ) { try { inBuf . close ( ) ; inBuf = null ; } catch ( Exception ex ) { } } if ( sftpFileHandle != null ) { try { sftpClient . closeFile ( sftpFileHandle ) ; sftpFileHandle = null ; } catch ( Exception ex ) { } } } return retval ; }
AliaksandrShuhayeu/pentaho-kettle | public boolean sshFileExists ( SFTPv3Client sftpClient , String filename ) { try { SFTPv3FileAttributes attributes = sftpClient . stat ( filename ) ; if ( attributes != null ) { return ( attributes . isRegularFile ( ) ) ; } else { return false ; } } catch ( Exception e ) { return false ; } }
AliaksandrShuhayeu/pentaho-kettle | public boolean sshDirectoryExists ( SFTPv3Client sftpClient , String directory ) { try { SFTPv3FileAttributes attributes = sftpClient . stat ( directory ) ; if ( attributes != null ) { return ( attributes . isDirectory ( ) ) ; } else { return false ; } } catch ( Exception e ) { return false ; } }
AliaksandrShuhayeu/pentaho-kettle | private boolean CreateRemoteFolder ( SFTPv3Client sftpClient , String foldername ) { boolean retval = false ; if ( ! sshDirectoryExists ( sftpClient , foldername ) ) { try { sftpClient . mkdir ( foldername , 0700 ) ; retval = true ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . Error . CreatingRemoteFolder " , foldername ) , e ) ; } } return retval ; }
AliaksandrShuhayeu/pentaho-kettle | public long getFileSize ( SFTPv3Client sftpClient , String filename ) throws Exception { return sftpClient . stat ( filename ) . size . longValue ( ) ; }
AliaksandrShuhayeu/pentaho-kettle | private List < FileObject > getFiles ( String localfolder ) throws KettleFileException { try { List < FileObject > myFileList = new ArrayList < FileObject > ( ) ; FileObject localFiles = KettleVFS . getFileObject ( localfolder , this ) ; FileObject [ ] children = localFiles . getChildren ( ) ; if ( children != null ) { for ( int i = 0 ; i < children . length ; i ++ ) { if ( children [ i ] . getType ( ) . equals ( FileType . FILE ) ) { myFileList . add ( children [ i ] ) ; } } } return myFileList ; } catch ( IOException e ) { throw new KettleFileException ( e ) ; } }
AliaksandrShuhayeu/pentaho-kettle | private boolean deleteOrMoveFiles ( FileObject file , String destinationFolder ) throws KettleException { try { boolean retval = false ; if ( afterFtpPut . equals ( " delete _ file " ) ) { file . delete ( ) ; retval = true ; if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . DeletedFile " , file . toString ( ) ) ) ; } } else if ( afterFtpPut . equals ( " move _ file " ) ) { FileObject destination = null ; FileObject source = null ; try { destination = KettleVFS . getFileObject ( destinationFolder + Const . FILE_SEPARATOR + file . getName ( ) . getBaseName ( ) , this ) ; file . moveTo ( destination ) ; retval = true ; } catch ( Exception e ) { logError ( BaseMessages . getString ( PKG , " JobSSH2PUT . Cant _ Move _ File . Label " , file . toString ( ) , destinationFolder , e . getMessage ( ) ) ) ; } finally { if ( destination != null ) { try { destination . close ( ) ; } catch ( Exception ex ) { } } if ( source != null ) { try { source . close ( ) ; } catch ( Exception ex ) { } } } if ( log . isDetailed ( ) ) { logDetailed ( BaseMessages . getString ( PKG , " JobSSH2PUT . Log . MovedFile " , file . toString ( ) , ftpDirectory ) ) ; } } return retval ; } catch ( Exception e ) { throw new KettleException ( e ) ; } }
AliaksandrShuhayeu/pentaho-kettle | @ Override public boolean evaluates ( ) { return true ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public List < ResourceReference > getResourceDependencies ( JobMeta jobMeta ) { List < ResourceReference > references = super . getResourceDependencies ( jobMeta ) ; if ( ! Utils . isEmpty ( serverName ) ) { String realServerName = jobMeta . environmentSubstitute ( serverName ) ; ResourceReference reference = new ResourceReference ( this ) ; reference . getEntries ( ) . add ( new ResourceEntry ( realServerName , ResourceType . SERVER ) ) ; references . add ( reference ) ; } return references ; }
AliaksandrShuhayeu/pentaho-kettle | @ Override public void check ( List < CheckResultInterface > remarks , JobMeta jobMeta , VariableSpace space , Repository repository , IMetaStore metaStore ) { JobEntryValidatorUtils . andValidator ( ) . validate ( this , " serverName " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notBlankValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " localDirectory " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notBlankValidator ( ) , JobEntryValidatorUtils . fileExistsValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " userName " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notBlankValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " password " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . notNullValidator ( ) ) ) ; JobEntryValidatorUtils . andValidator ( ) . validate ( this , " serverPort " , remarks , AndValidator . putValidators ( JobEntryValidatorUtils . integerValidator ( ) ) ) ; }
tharikaGitHub/carbon-apimgt | @ Before public void init ( ) { timer = Mockito . mock ( Timer . class ) ; timer = Mockito . mock ( Timer . class ) ; context = Mockito . mock ( Timer . Context . class ) ; throttleEvaluator = Mockito . mock ( ThrottleConditionEvaluator . class ) ; accessInformation = Mockito . mock ( AccessInformation . class ) ; Mockito . when ( timer . start ( ) ) . thenReturn ( context ) ; verbInfoDTO = new ArrayList < > ( ) ; verbInfo = new VerbInfoDTO ( ) ; verbInfo . setHttpVerb ( httpVerb ) ; verbInfo . setRequestKey ( apiContext + " / " + apiVersion + resourceUri + " : " + httpVerb ) ; verbInfo . setThrottling ( throttlingTier ) ; verbInfoDTO . add ( verbInfo ) ; conditionGroupDTO = new ConditionGroupDTO ( ) ; conditionGroupDTO . setConditionGroupId ( " _ default " ) ; conditionGroupDTOs = new ConditionGroupDTO [ 1 ] ; conditionGroupDTOs [ 0 ] = conditionGroupDTO ; apiLevelThrottleKey = apiContext + " : " + apiVersion ; resourceLevelThrottleKey = apiContext + " / " + apiVersion + resourceUri + " : " + httpVerb ; org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder serviceReferenceHolder = Mockito . mock ( org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder . class ) ; PowerMockito . mockStatic ( org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder . class ) ; Mockito . when ( org . wso2 . carbon . apimgt . impl . internal . ServiceReferenceHolder . getInstance ( ) ) . thenReturn ( serviceReferenceHolder ) ; APIManagerConfigurationService apiManagerConfigurationService = Mockito . mock ( APIManagerConfigurationService . class ) ; APIManagerConfiguration apiManagerConfiguration = Mockito . mock ( APIManagerConfiguration . class ) ; Mockito . when ( serviceReferenceHolder . getAPIManagerConfigurationService ( ) ) . thenReturn ( apiManagerConfigurationService ) ; Mockito . when ( apiManagerConfigurationService . getAPIManagerConfiguration ( ) ) . thenReturn ( apiManagerConfiguration ) ; Mockito . when ( apiManagerConfiguration . getExtensionListenerMap ( ) ) . thenReturn ( extensionListenerMap ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testDoNotThrottleWhenMsgIsAResponseAndAuthCtxNotAvailable ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContext ( apiContext , apiVersion ) ; messageContext . setProperty ( RESPONSE , " true " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testSubscriptionLevelThrottlingInitWhenThrottleCtxIsNull ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( RESPONSE , " true " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testSubscriptionLevelThrottlingInitialization ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( RESPONSE , " true " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenBlockingConditionsAreSatisfied ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; throttleDataHolder . addIpBlockingCondition ( " carbon . super " , 1 , " { \" fixedIp \" : \" 127.0.0.1 \" , \" invert \" : false } " , APIConstants . BLOCKING_CONDITIONS_IP ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; throttleDataHolder . removeIpBlockingCondition ( " carbon . super " , 1 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleContinueWhenAPITierIsNotAvailable ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; Assert . assertNull ( ( VerbInfoDTO ) messageContext . getProperty ( VERB_INFO_DTO ) ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgDoContinueWhenAllThrottlingLevelsAreNotThrolled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ServiceReferenceHolder . getInstance ( ) . setThrottleDataPublisher ( new ThrottleDataPublisher ( ) ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgDoThrottleWhenUserLevelThrottlingIsTriggerred ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; verbInfo . setApplicableLevel ( " userLevel " ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenAPILevelIsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String combinedResourceLevelThrottleKey = apiLevelThrottleKey + conditionGroupDTO . getConditionGroupId ( ) ; throttleDataHolder . addThrottledAPIKey ( apiLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; throttleDataHolder . addThrottleData ( combinedResourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Mockito . when ( throttleEvaluator . getApplicableConditions ( messageContext , authenticationContext , conditionGroupDTOs ) ) . thenReturn ( matchingConditions ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenResourceLevelIsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( " Unlimited " ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String combinedResourceLevelThrottleKey = resourceLevelThrottleKey + conditionGroupDTO . getConditionGroupId ( ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; throttleDataHolder . addThrottleData ( combinedResourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Mockito . when ( throttleEvaluator . getApplicableConditions ( messageContext , authenticationContext , conditionGroupDTOs ) ) . thenReturn ( matchingConditions ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenSubscriptionLevelIsThrottledAndStopOnQuotaReachIsEnabled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( true ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String subscriptionLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + apiContext + " : " + apiVersion ; throttleDataHolder . addThrottleData ( subscriptionLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgContinueWhenSubscriptionLevelIsThrottledAndStopOnQuotaReachIsDisabled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( false ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String subscriptionLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + apiContext + " : " + apiVersion ; throttleDataHolder . addThrottleData ( subscriptionLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenApplicationLevelIsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String applicationLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + authenticationContext . getUsername ( ) + " @ " + throttleHandler . getTenantDomain ( ) ; throttleDataHolder . addThrottleData ( applicationLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenProductionHardThrottlingLimitsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( false ) ; authenticationContext . setKeyType ( " PRODUCTION " ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenSandBoxHardThrottlingLimitsThrottled ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setSandboxMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setStopOnQuotaReach ( false ) ; authenticationContext . setKeyType ( " SANDBOX " ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; String subscriptionLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + apiContext + " : " + apiVersion ; String applicationLevelThrottleKey = authenticationContext . getApplicationId ( ) + " : " + authenticationContext . getUsername ( ) + " @ " + throttleHandler . getTenantDomain ( ) ; String combinedResourceLevelThrottleKey = resourceLevelThrottleKey + conditionGroupDTO . getConditionGroupId ( ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenHardThrottlingFailedWithThrottleException ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setKeyType ( " SANDBOX " ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; Mockito . doThrow ( ThrottleException . class ) . when ( accessInformation ) . isAccessAllowed ( ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenCustomThrottlingLimitExceeded ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; matchingConditions . add ( conditionGroupDTO ) ; throttleDataHolder . addKeyTemplate ( " $ user " , " $ user " ) ; throttleDataHolder . addKeyTemplate ( " testKeyTemplate " , " testKeyTemplateValue " ) ; throttleDataHolder . addThrottleData ( " testKeyTemplate " , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; throttleDataHolder . removeKeyTemplate ( " testKeyTemplate " ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWhenHittingSubscriptionLevelSpike ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setSandboxMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setKeyType ( " SANDBOX " ) ; authenticationContext . setSpikeArrestLimit ( 100 ) ; authenticationContext . setStopOnQuotaReach ( true ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; matchingConditions . add ( conditionGroupDTO ) ; throttleDataHolder . addKeyTemplate ( " $ user " , " $ user " ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testHandleResponse ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; Assert . assertTrue ( throttleHandler . handleResponse ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testCheckForStaledThrottleData ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ServiceReferenceHolder . getInstance ( ) . setThrottleDataPublisher ( new ThrottleDataPublisher ( ) ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator , accessInformation ) ; throttleHandler . setProductionMaxCount ( "100" ) ; SynapseEnvironment synapseEnvironment = Mockito . mock ( SynapseEnvironment . class ) ; throttleHandler . init ( synapseEnvironment ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; authenticationContext . setApiTier ( throttlingTier ) ; authenticationContext . setSpikeArrestLimit ( 0 ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; Mockito . when ( accessInformation . isAccessAllowed ( ) ) . thenReturn ( false ) ; matchingConditions . add ( conditionGroupDTO ) ; throttleDataHolder . addKeyTemplate ( " testKeyTemplate " , " testKeyTemplateValue " ) ; throttleDataHolder . addThrottleData ( " testKeyTemplate " , System . currentTimeMillis ( ) - 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
tharikaGitHub/carbon-apimgt | @ Test public void testMsgThrottleOutWithUserBlockingConditions ( ) { ThrottleDataHolder throttleDataHolder = new ThrottleDataHolder ( ) ; ThrottleHandler throttleHandler = new ThrottlingHandlerWrapper ( timer , throttleDataHolder , throttleEvaluator ) ; MessageContext messageContext = TestUtils . getMessageContextWithAuthContext ( apiContext , apiVersion ) ; messageContext . setProperty ( VERB_INFO_DTO , verbInfoDTO ) ; ( ( Axis2MessageContext ) messageContext ) . getAxis2MessageContext ( ) . getProperty ( org . apache . axis2 . context . MessageContext . TRANSPORT_HEADERS ) ; AuthenticationContext authenticationContext = ( AuthenticationContext ) messageContext . getProperty ( API_AUTH_CONTEXT ) ; verbInfo . setConditionGroups ( conditionGroupDTOs ) ; ArrayList < ConditionGroupDTO > matchingConditions = new ArrayList < > ( ) ; throttleDataHolder . addUserBlockingCondition ( blockedUserWithTenantDomain , blockedUserWithTenantDomain ) ; matchingConditions . add ( conditionGroupDTO ) ; authenticationContext . setApiTier ( " Unlimited " ) ; authenticationContext . setUsername ( blockedUserWithTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; authenticationContext . setUsername ( userWithTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; authenticationContext . setUsername ( blockedUserWithOutTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertFalse ( throttleHandler . handleRequest ( messageContext ) ) ; throttleDataHolder . removeUserBlockingCondition ( blockedUserWithTenantDomain ) ; authenticationContext . setUsername ( blockedUserWithTenantDomain ) ; messageContext . setProperty ( API_AUTH_CONTEXT , authenticationContext ) ; throttleDataHolder . addThrottledAPIKey ( resourceLevelThrottleKey , System . currentTimeMillis ( ) + 10000 ) ; Assert . assertTrue ( throttleHandler . handleRequest ( messageContext ) ) ; }
gokul/siddhi | public OverwriteTableIndexOperatorForCache ( CollectionExecutor collectionExecutor , String queryName , CacheTable cacheTable ) { super ( collectionExecutor , queryName , cacheTable ) ; }
gokul/siddhi | @ Override public ComplexEventChunk < StreamEvent > tryUpdate ( ComplexEventChunk < StateEvent > updatingOrAddingEventChunk , Object storeEvents , InMemoryCompiledUpdateSet compiledUpdateSet , AddingStreamEventExtractor addingStreamEventExtractor ) { updatingOrAddingEventChunk . reset ( ) ; while ( updatingOrAddingEventChunk . hasNext ( ) ) { StateEvent overwritingOrAddingEvent = updatingOrAddingEventChunk . next ( ) ; ( ( IndexedEventHolder ) storeEvents ) . overwrite ( addingStreamEventExtractor . getAddingStreamEvent ( overwritingOrAddingEvent ) ) ; } return null ; }
Squama/Master | @ RequestMapping ( value = " list " , method = RequestMethod . GET ) public String list ( ) { return VIEW_LIST ; }
Squama/Master | @ RequestMapping ( value = " progress " , method = RequestMethod . GET ) public String progress_demo ( ) { return " demos / progress " ; }
Squama/Master | @ RequestMapping ( value = " saveUser " , method = RequestMethod . POST ) @ ResponseBody public User saveUser ( User user ) { return userDemoService . saveUser ( user ) ; }
Squama/Master | @ RequestMapping ( value = " getUser " , method = RequestMethod . POST ) @ ResponseBody public User getUser ( String id ) { return userDemoService . get ( User . class , id ) ; }
sscdotopen/giraph-compensations | catch ( IllegalArgumentException iae ) { assertTrue ( iae . getMessage ( ) . startsWith ( " Line ▁ did ▁ not ▁ split ▁ correctly : ▁ " ) ) ; }
sscdotopen/giraph-compensations | catch ( IllegalArgumentException iae ) { assertTrue ( iae . getMessage ( ) . startsWith ( " Line ▁ did ▁ not ▁ split ▁ correctly : ▁ " ) ) ; }
sscdotopen/giraph-compensations | public void testHappyPath ( ) throws Exception { String input = " Hi\t0\tCiao\t1.123\tBomdia\t2.234\tOla\t3.345" ; when ( rr . getCurrentValue ( ) ) . thenReturn ( new Text ( input ) ) ; TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > vr = new TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > ( rr ) ; vr . initialize ( null , tac ) ; assertTrue ( " Should ▁ have ▁ been ▁ able ▁ to ▁ add ▁ a ▁ vertex " , vr . nextVertex ( ) ) ; BasicVertex < Text , DoubleWritable , DoubleWritable , BooleanWritable > vertex = vr . getCurrentVertex ( ) ; setGraphState ( vertex , graphState ) ; assertValidVertex ( conf , graphState , vertex , new Text ( " Hi " ) , new DoubleWritable ( 0 ) , new Edge < Text , DoubleWritable > ( new Text ( " Ciao " ) , new DoubleWritable ( 1.123d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " Bomdia " ) , new DoubleWritable ( 2.234d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " Ola " ) , new DoubleWritable ( 3.345d ) ) ) ; assertEquals ( vertex . getNumOutEdges ( ) , 3 ) ; }
sscdotopen/giraph-compensations | public void testLineSanitizer ( ) throws Exception { String input = " Bye\t0.01\tCiao\t1.001\tTchau\t2.0001\tAdios\t3.00001" ; AdjacencyListVertexReader . LineSanitizer toUpper = new AdjacencyListVertexReader . LineSanitizer ( ) { @ Override public String sanitize ( String s ) { return s . toUpperCase ( ) ; } } ; when ( rr . getCurrentValue ( ) ) . thenReturn ( new Text ( input ) ) ; TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > vr = new TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > ( rr , toUpper ) ; vr . initialize ( null , tac ) ; assertTrue ( " Should ▁ have ▁ been ▁ able ▁ to ▁ read ▁ vertex " , vr . nextVertex ( ) ) ; BasicVertex < Text , DoubleWritable , DoubleWritable , BooleanWritable > vertex = vr . getCurrentVertex ( ) ; setGraphState ( vertex , graphState ) ; assertValidVertex ( conf , graphState , vertex , new Text ( " BYE " ) , new DoubleWritable ( 0.01d ) , new Edge < Text , DoubleWritable > ( new Text ( " CIAO " ) , new DoubleWritable ( 1.001d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " TCHAU " ) , new DoubleWritable ( 2.0001d ) ) , new Edge < Text , DoubleWritable > ( new Text ( " ADIOS " ) , new DoubleWritable ( 3.00001d ) ) ) ; assertEquals ( vertex . getNumOutEdges ( ) , 3 ) ; }
sscdotopen/giraph-compensations | public void testDifferentSeparators ( ) throws Exception { String input = " alpha : 42 : beta : 99" ; when ( rr . getCurrentValue ( ) ) . thenReturn ( new Text ( input ) ) ; conf . set ( AdjacencyListVertexReader . LINE_TOKENIZE_VALUE , " : " ) ; TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > vr = new TextDoubleDoubleAdjacencyListVertexInputFormat . VertexReader < BooleanWritable > ( rr ) ; vr . initialize ( null , tac ) ; assertTrue ( " Should ▁ have ▁ been ▁ able ▁ to ▁ read ▁ vertex " , vr . nextVertex ( ) ) ; BasicVertex < Text , DoubleWritable , DoubleWritable , BooleanWritable > vertex = vr . getCurrentVertex ( ) ; setGraphState ( vertex , graphState ) ; assertValidVertex ( conf , graphState , vertex , new Text ( " alpha " ) , new DoubleWritable ( 42d ) , new Edge < Text , DoubleWritable > ( new Text ( " beta " ) , new DoubleWritable ( 99d ) ) ) ; assertEquals ( vertex . getNumOutEdges ( ) , 1 ) ; }
sscdotopen/giraph-compensations | @ Override public void compute ( Iterator < BooleanWritable > msgIterator ) throws IOException { }
podpage/J-lexa | public Header ( ) { fields = new ArrayList < > ( ) ; }
podpage/J-lexa | public RequestMethod getRequestMethod ( ) { return requestMethod ; }
podpage/J-lexa | public void setRequestMethod ( RequestMethod requestMethod ) { this . requestMethod = requestMethod ; }
podpage/J-lexa | public String getRequestURL ( ) { return requestURL ; }
podpage/J-lexa | public void setRequestURL ( String requestURL ) { this . requestURL = requestURL ; }
podpage/J-lexa | public ArrayList < HeaderField > getHeaderFields ( ) { return fields ; }
podpage/J-lexa | public void setHeaderFields ( ArrayList < HeaderField > fields ) { this . fields = fields ; }
podpage/J-lexa | public void addHeaderField ( HeaderField field ) { this . fields . add ( field ) ; }
podpage/J-lexa | public void removeHeaderField ( HeaderField field ) { this . fields . remove ( field ) ; }
podpage/J-lexa | public HeaderField getHeaderField ( HeaderField headerField ) { for ( HeaderField field : fields ) { if ( field . name ( ) . equals ( headerField . name ( ) ) ) { return field ; } } return null ; }
podpage/J-lexa | public boolean hasHeaderField ( HeaderField headerField ) { for ( HeaderField field : fields ) { if ( field . name ( ) . equals ( headerField . name ( ) ) ) { return true ; } } return false ; }
podpage/J-lexa | public ArrayList < HeaderField > getFields ( ) { return fields ; }
podpage/J-lexa | HeaderField ( String name , HeaderType type ) { this . name = name ; this . type = type ; }
podpage/J-lexa | public HeaderType getType ( ) { return type ; }
podpage/J-lexa | public String getContent ( ) { return content ; }
podpage/J-lexa | public HeaderField setContent ( String content ) { this . content = content ; return this ; }
podpage/J-lexa | public String getName ( ) { return name ; }
podpage/J-lexa | public HeaderField setName ( String name ) { if ( this . equals ( CUSTOM ) ) { this . name = name ; } return this ; }
podpage/J-lexa | @ Override public String toString ( ) { return name + " : ▁ " + content ; }
voyagersearch/Xponents | public RegexPattern ( String _family , String _id , String _description ) { family = _family ; id = _id ; description = _description ; }
voyagersearch/Xponents | public String toString ( ) { return id + " , ▁ Pattern : " + regex . pattern ( ) . toString ( ) ; }
jasonchaffee/apiman | public ApiNotFoundException ( ) { }
jasonchaffee/apiman | public ApiNotFoundException ( String message ) { super ( message ) ; }
jasonchaffee/apiman | @ Override public int getErrorCode ( ) { return ErrorCodes . API_NOT_FOUND ; }
jasonchaffee/apiman | @ Override public String getMoreInfoUrl ( ) { return ErrorCodes . API_NOT_FOUND_INFO ; }
gsteelman/utd | public BucketEliminator ( ) { }
gsteelman/utd | public BucketEliminator ( ArrayList < Function > functions , ArrayList < Variable > variables ) { this . functions = functions ; this . variables = variables ; }
gsteelman/utd | public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; s . append ( this . type + " \n " ) ; s . append ( this . orderHeuristic + " \n " ) ; return s . toString ( ) ; }
gsteelman/utd | public void setOrderHeuristic ( OrderHeuristicType orderHeuristic ) { this . orderHeuristic = orderHeuristic ; }
gsteelman/utd | public LogDouble eliminate ( ) { Stopwatch sw = new Stopwatch ( ) ; sw . start ( ) ; LogDouble probabilityOfEvidence = new LogDouble ( 1.0 ) ; ArrayList < Integer > order = getOrdering ( ) ; if ( order == null ) { return probabilityOfEvidence ; } else if ( order . isEmpty ( ) ) { return probabilityOfEvidence ; } ArrayList < ArrayList < Function > > bucketList = new ArrayList < ArrayList < Function > > ( order . size ( ) ) ; for ( int i = 0 ; i < order . size ( ) ; i ++ ) { bucketList . add ( new ArrayList < Function > ( ) ) ; } bucketList . trimToSize ( ) ; ArrayList < Integer > varInPos = new ArrayList < Integer > ( this . variables . size ( ) ) ; for ( int i = 0 ; i < this . variables . size ( ) ; i ++ ) { varInPos . add ( 0 ) ; } for ( int i = 0 ; i < order . size ( ) ; i ++ ) { varInPos . set ( order . get ( i ) , i ) ; } varInPos . trimToSize ( ) ; for ( Function f : this . functions ) { int pos = this . variables . size ( ) ; boolean allEvid = true ; for ( Variable v : f . variables ) { if ( v . isEvidence ( ) ) { continue ; } if ( varInPos . get ( v . getId ( ) ) < pos ) { pos = varInPos . get ( v . getId ( ) ) ; } allEvid = false ; } if ( allEvid ) { probabilityOfEvidence = probabilityOfEvidence . mul ( f . table . get ( Variable . getAddress ( f . variables ) ) ) ; } else { bucketList . get ( pos ) . add ( f ) ; } } for ( int i = 0 ; i < bucketList . size ( ) ; i ++ ) { if ( bucketList . get ( i ) . isEmpty ( ) ) { continue ; } HashSet < Variable > resultantVariables = new HashSet < Variable > ( ) ; for ( Function f : bucketList . get ( i ) ) { resultantVariables . addAll ( f . variables ) ; } for ( Iterator < Variable > itr = resultantVariables . iterator ( ) ; itr . hasNext ( ) ; ) { Variable v = itr . next ( ) ; if ( v . isEvidence ( ) ) { itr . remove ( ) ; } } resultantVariables . remove ( this . variables . get ( order . get ( i ) ) ) ; ArrayList < Variable > resultVariablesAsArrayList = new ArrayList < Variable > ( resultantVariables ) ; Function result = Function . productSumOut ( resultVariablesAsArrayList , bucketList . get ( i ) , false ) ; if ( result . isTrivial ( ) ) { probabilityOfEvidence = probabilityOfEvidence . mul ( result . table . get ( 0 ) ) ; continue ; } int pos = order . size ( ) ; for ( Variable v : result . variables ) { if ( varInPos . get ( v . getId ( ) ) < pos ) { pos = varInPos . get ( v . getId ( ) ) ; } } if ( pos < bucketList . size ( ) ) { bucketList . get ( pos ) . add ( result ) ; } bucketList . get ( i ) . clear ( ) ; } sw . stop ( ) ; return probabilityOfEvidence ; }
gsteelman/utd | protected String bucketListToString ( ArrayList < ArrayList < Function > > bl , ArrayList < Integer > o ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < bl . size ( ) ; i ++ ) { s . append ( o . get ( i ) ) ; s . append ( Function . functionCollectionToRealString ( bl . get ( i ) ) + " \n " ) ; } return s . toString ( ) ; }
gsteelman/utd | protected ArrayList < Integer > getOrdering ( ) { ArrayList < Integer > ordering = null ; ArrayList < HashSet < Integer > > interactionGraph = computeInteractionGraph ( ) ; if ( this . orderHeuristic == OrderHeuristicType . MIN_DEGREE ) { ordering = computeMinDegreeOrder ( interactionGraph ) ; } else { System . err . println ( " Error : ▁ unknown ▁ ordering ▁ heuristic . " ) ; } return ordering ; }
gsteelman/utd | protected ArrayList < HashSet < Integer > > computeInteractionGraph ( ) { ArrayList < HashSet < Integer > > interactionGraph = new ArrayList < HashSet < Integer > > ( this . variables . size ( ) ) ; for ( int i = 0 ; i < this . variables . size ( ) ; i ++ ) { interactionGraph . add ( new HashSet < Integer > ( ) ) ; } interactionGraph . trimToSize ( ) ; int vID1 = 0 ; int vID2 = 0 ; for ( int i = 0 ; i < this . functions . size ( ) ; i ++ ) { for ( int j = 0 ; j < functions . get ( i ) . variables . size ( ) ; j ++ ) { vID1 = functions . get ( i ) . variables . get ( j ) . getId ( ) ; if ( variables . get ( vID1 ) . isEvidence ( ) ) { continue ; } for ( int k = j + 1 ; k < this . functions . get ( i ) . variables . size ( ) ; k ++ ) { vID2 = functions . get ( i ) . variables . get ( k ) . getId ( ) ; if ( variables . get ( vID2 ) . isEvidence ( ) ) { continue ; } interactionGraph . get ( vID1 ) . add ( vID2 ) ; interactionGraph . get ( vID2 ) . add ( vID1 ) ; } } } return interactionGraph ; }
gsteelman/utd | protected String interactionGraphToString ( ArrayList < HashSet < Integer > > ig ) { StringBuilder s = new StringBuilder ( ) ; for ( HashSet < Integer > i : ig ) { for ( Integer e : i ) { s . append ( e + " ▁ " ) ; } s . append ( " \n " ) ; } return s . toString ( ) ; }
gsteelman/utd | protected ArrayList < Integer > computeMinDegreeOrder ( ArrayList < HashSet < Integer > > interactionGraph ) { ArrayList < HashSet < Integer > > ig = new ArrayList < HashSet < Integer > > ( interactionGraph . size ( ) ) ; for ( HashSet < Integer > c : interactionGraph ) { ig . add ( new HashSet < Integer > ( c ) ) ; } ArrayList < Boolean > processed = new ArrayList < Boolean > ( this . variables . size ( ) ) ; int numNonEvidVars = 0 ; for ( Variable v : this . variables ) { if ( v . isEvidence ( ) ) { processed . add ( true ) ; } else { numNonEvidVars ++ ; processed . add ( false ) ; } } processed . trimToSize ( ) ; ArrayList < Integer > minDegreeOrder = new ArrayList < Integer > ( numNonEvidVars ) ; ArrayList < HashSet < Integer > > clusters = new ArrayList < HashSet < Integer > > ( numNonEvidVars ) ; for ( int i = 0 ; i < numNonEvidVars ; i ++ ) { minDegreeOrder . add ( 0 ) ; clusters . add ( new HashSet < Integer > ( ) ) ; } minDegreeOrder . trimToSize ( ) ; clusters . trimToSize ( ) ; int min = 0 ; int max = 0 ; int var = 0 ; for ( int i = 0 ; i < numNonEvidVars ; i ++ ) { min = this . variables . size ( ) ; for ( int j = 0 ; j < ig . size ( ) ; j ++ ) { if ( processed . get ( j ) ) { continue ; } if ( ig . get ( j ) . size ( ) < min ) { min = ig . get ( j ) . size ( ) ; minDegreeOrder . set ( i , j ) ; } } var = minDegreeOrder . get ( i ) ; processed . set ( var , true ) ; for ( Integer a : ig . get ( var ) ) { for ( Integer b : ig . get ( var ) ) { if ( a == b ) { continue ; } ig . get ( a ) . add ( b ) ; ig . get ( b ) . add ( a ) ; } } clusters . set ( i , ig . get ( var ) ) ; if ( max < clusters . get ( i ) . size ( ) ) { max = clusters . get ( i ) . size ( ) ; } for ( HashSet < Integer > a : ig ) { a . remove ( var ) ; } ig . get ( var ) . clear ( ) ; } return minDegreeOrder ; }
gsteelman/utd | protected String orderingToString ( ArrayList < Integer > o ) { StringBuilder s = new StringBuilder ( ) ; for ( Integer i : o ) { s . append ( i + " \n " ) ; } return s . toString ( ) ; }
Sargul/dbeaver | public VersionUpdateDialog ( Shell parentShell , @ NotNull Version currentVersion , @ NotNull VersionDescriptor newVersion , boolean showConfig ) { super ( parentShell ) ; this . currentVersion = currentVersion ; this . newVersion = newVersion ; this . showConfig = showConfig ; earlyAccessURL = Platform . getProduct ( ) . getProperty ( " earlyAccessURL " ) ; }
Sargul/dbeaver | @ NotNull public VersionDescriptor getNewVersion ( ) { return newVersion ; }
Sargul/dbeaver | public boolean isShowConfig ( ) { return showConfig ; }
Sargul/dbeaver | public Font getBoldFont ( ) { return boldFont ; }
Sargul/dbeaver | @ Override protected boolean isResizable ( ) { return true ; }
Sargul/dbeaver | private boolean isNewVersionAvailable ( ) { return newVersion . getProgramVersion ( ) . compareTo ( currentVersion ) > 0 ; }
Sargul/dbeaver | @ Override protected Control createDialogArea ( Composite parent ) { getShell ( ) . setText ( CoreMessages . dialog_version_update_title ) ; Composite composite = new Composite ( parent , SWT . NONE ) ; composite . setLayoutData ( new GridData ( GridData . FILL_BOTH ) ) ; composite . setLayout ( new GridLayout ( 1 , false ) ) ; Composite propGroup = UIUtils . createControlGroup ( composite , CoreMessages . dialog_version_update_title , 2 , GridData . FILL_BOTH , 0 ) ; createTopArea ( composite ) ; boldFont = UIUtils . makeBoldFont ( composite . getFont ( ) ) ; final Label titleLabel = new Label ( propGroup , SWT . NONE ) ; titleLabel . setText ( NLS . bind ( ! isNewVersionAvailable ( ) ? CoreMessages . dialog_version_update_no_new_version : CoreMessages . dialog_version_update_available_new_version , GeneralUtils . getProductName ( ) ) ) ; GridData gd = new GridData ( GridData . FILL_HORIZONTAL ) ; gd . horizontalSpan = 2 ; titleLabel . setLayoutData ( gd ) ; titleLabel . setFont ( boldFont ) ; UIUtils . createControlLabel ( propGroup , CoreMessages . dialog_version_update_current_version ) ; new Label ( propGroup , SWT . NONE ) . setText ( currentVersion . toString ( ) ) ; UIUtils . createControlLabel ( propGroup , CoreMessages . dialog_version_update_new_version ) ; new Label ( propGroup , SWT . NONE ) . setText ( newVersion . getProgramVersion ( ) . toString ( ) + " ▁ ▁ ▁ ▁ ( " + newVersion . getUpdateTime ( ) + " ) " ) ; if ( isNewVersionAvailable ( ) ) { final Label notesLabel = UIUtils . createControlLabel ( propGroup , CoreMessages . dialog_version_update_notes ) ; gd = new GridData ( GridData . FILL_HORIZONTAL ) ; gd . horizontalSpan = 2 ; notesLabel . setLayoutData ( gd ) ; final Text notesText = new Text ( propGroup , SWT . READ_ONLY | SWT . WRAP | SWT . V_SCROLL ) ; String releaseNotes = CommonUtils . notEmpty ( newVersion . getReleaseNotes ( ) ) ; if ( releaseNotes . isEmpty ( ) ) { releaseNotes = CoreMessages . dialog_version_update_no_notes ; } releaseNotes = formatReleaseNotes ( releaseNotes ) ; notesText . setText ( releaseNotes ) ; gd = new GridData ( GridData . FILL_BOTH ) ; gd . horizontalSpan = 2 ; notesText . setLayoutData ( gd ) ; final Label hintLabel = new Label ( propGroup , SWT . NONE ) ; hintLabel . setText ( NLS . bind ( CoreMessages . dialog_version_update_press_more_info , CoreMessages . dialog_version_update_button_more_info , newVersion . getPlainVersion ( ) ) ) ; gd = new GridData ( GridData . FILL_HORIZONTAL ) ; gd . horizontalSpan = 2 ; hintLabel . setLayoutData ( gd ) ; hintLabel . setFont ( boldFont ) ; } createBottomArea ( composite ) ; return parent ; }
Sargul/dbeaver | protected void createTopArea ( Composite composite ) { }
Sargul/dbeaver | protected void createBottomArea ( Composite composite ) { }
Sargul/dbeaver | @ Override public boolean close ( ) { boldFont . dispose ( ) ; return super . close ( ) ; }
Sargul/dbeaver | @ Override protected void createButtonsForButtonBar ( Composite parent ) { if ( showConfig && isNewVersionAvailable ( ) ) { ( ( GridLayout ) parent . getLayout ( ) ) . numColumns ++ ; dontShowAgainCheck = UIUtils . createCheckbox ( parent , NLS . bind ( CoreMessages . dialog_version_update_ignore_version , newVersion . getPlainVersion ( ) ) , false ) ; } if ( isNewVersionAvailable ( ) ) { createButton ( parent , UPGRADE_ID , CoreMessages . dialog_version_update_button_upgrade , true ) ; } else { if ( ! CommonUtils . isEmpty ( earlyAccessURL ) ) { createButton ( parent , CHECK_EA_ID , CoreMessages . dialog_version_update_button_early_access , false ) ; } } createButton ( parent , INFO_ID , CoreMessages . dialog_version_update_button_more_info , false ) ; createButton ( parent , IDialogConstants . CLOSE_ID , IDialogConstants . CLOSE_LABEL , ! isNewVersionAvailable ( ) ) ; }
Sargul/dbeaver | @ Override protected void buttonPressed ( int buttonId ) { if ( dontShowAgainCheck != null && dontShowAgainCheck . getSelection ( ) ) { CoreApplicationActivator . getDefault ( ) . getPreferenceStore ( ) . setValue ( " suppressUpdateCheck . " + newVersion . getPlainVersion ( ) , true ) ; } if ( buttonId == INFO_ID ) { ShellUtils . launchProgram ( newVersion . getBaseURL ( ) ) ; } else if ( buttonId == UPGRADE_ID ) { final PlatformInstaller installer = getPlatformInstaller ( ) ; if ( installer != null ) { final AbstractJob job = new AbstractJob ( " Downloading ▁ installation ▁ file " ) { @ Override protected IStatus run ( DBRProgressMonitor monitor ) { final ApplicationDescriptor app = ApplicationRegistry . getInstance ( ) . getApplication ( ) ; final Path folder ; final Path file ; try { final String executableName = installer . getExecutableName ( app ) ; final String executableExtension = installer . getExecutableExtension ( ) ; folder = Files . createTempDirectory ( executableName ) ; file = Files . createFile ( folder . resolve ( executableName + ' . ' + executableExtension ) ) ; log . debug ( " Downloading ▁ installation ▁ file ▁ to ▁ " + file ) ; WebUtils . downloadRemoteFile ( monitor , " Obtaining ▁ installer " , getDownloadURL ( app , installer , newVersion ) , file . toFile ( ) , null ) ; } catch ( IOException e ) { return GeneralUtils . makeErrorStatus ( CoreMessages . dialog_version_update_downloader_error_cannot_download , e ) ; } catch ( InterruptedException e ) { log . debug ( " Canceled ▁ by ▁ user " , e ) ; return Status . OK_STATUS ; } if ( UIUtils . confirmAction ( CoreMessages . dialog_version_update_downloader_title , NLS . bind ( CoreMessages . dialog_version_update_downloader_confirm_install , app . getName ( ) ) ) ) { final IWorkbench workbench = PlatformUI . getWorkbench ( ) ; final IWorkbenchWindow workbenchWindow = UIUtils . getActiveWorkbenchWindow ( ) ; final IWorkbenchListener listener = new IWorkbenchListener ( ) { { workbench . addWorkbenchListener ( this ) ; } @ Override public boolean preShutdown ( IWorkbench workbench , boolean forced ) { return true ; } @ Override public void postShutdown ( IWorkbench workbench ) { try { installer . run ( file , log ) ; } catch ( Exception e ) { log . error ( " Failed ▁ to ▁ run ▁ the ▁ installer ▁ script " , e ) ; } } } ; UIUtils . asyncExec ( ( ) -> { ActionUtils . runCommand ( IWorkbenchCommandConstants . FILE_EXIT , workbenchWindow ) ; if ( ! workbench . isClosing ( ) ) { workbench . removeWorkbenchListener ( listener ) ; ShellUtils . launchProgram ( folder . toString ( ) ) ; } } ) ; } else { ShellUtils . showInSystemExplorer ( file . toAbsolutePath ( ) . toString ( ) ) ; } return Status . OK_STATUS ; } } ; job . setUser ( true ) ; job . schedule ( ) ; } else { ShellUtils . launchProgram ( getDownloadPageURL ( newVersion ) ) ; } } else if ( buttonId == CHECK_EA_ID ) { if ( ! CommonUtils . isEmpty ( earlyAccessURL ) ) { ShellUtils . launchProgram ( earlyAccessURL ) ; } } else if ( buttonId == IDialogConstants . PROCEED_ID ) { final IWorkbenchWindow window = UIUtils . getActiveWorkbenchWindow ( ) ; CheckForUpdateAction . activateStandardHandler ( window ) ; try { ActionUtils . runCommand ( CheckForUpdateAction . P2_UPDATE_COMMAND , PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) ) ; } finally { CheckForUpdateAction . deactivateStandardHandler ( window ) ; } } close ( ) ; }
Sargul/dbeaver | @ Nullable private PlatformInstaller getPlatformInstaller ( ) { switch ( Platform . getOS ( ) ) { case Platform . OS_WIN32 : return new WindowsInstaller ( ) ; case Platform . OS_MACOSX : return new MacintoshInstaller ( ) ; default : return null ; } }
Sargul/dbeaver | @ NotNull private String getDownloadURL ( @ NotNull ApplicationDescriptor application , @ NotNull PlatformInstaller installer , @ NotNull VersionDescriptor version ) { final String name = installer . getExecutableName ( application ) ; final String extension = installer . getExecutableExtension ( ) ; return CommonUtils . removeTrailingSlash ( version . getDownloadURL ( ) ) + ' / ' + name + ' . ' + extension ; }
Sargul/dbeaver | @ NotNull private String getDownloadPageURL ( @ NotNull VersionDescriptor version ) { String os = Platform . getOS ( ) ; switch ( os ) { case " win32" : os = " win " ; break ; case " macosx " : os = " mac " ; break ; default : os = " linux " ; break ; } String arch = Platform . getOSArch ( ) ; String dist = null ; if ( os . equals ( " linux " ) ) { try { RuntimeUtils . executeProcess ( " / usr / bin / apt - get " , " - - version " ) ; dist = " deb " ; } catch ( DBException e ) { dist = " rpm " ; } } return CommonUtils . removeTrailingSlash ( version . getBaseURL ( ) ) + " ? start " + " & os = " + os + " & arch = " + arch + ( dist == null ? " " : " & dist = " + dist ) ; }
Sargul/dbeaver | @ Override public void run ( @ NotNull Path executable , @ NotNull Log log ) throws Exception { final String path = executable . toString ( ) ; Runtime . getRuntime ( ) . exec ( new String [ ] { " cmd . exe " , " / C " , " start " , " / W " , path , " & & " , " del " , path , } ) ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableName ( @ NotNull ApplicationDescriptor application ) { return application . getId ( ) + " - latest - x86_64 - setup " ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableExtension ( ) { return " exe " ; }
Sargul/dbeaver | @ Override public void run ( @ NotNull Path executable , @ NotNull Log log ) throws Exception { final String path = CommonUtils . escapeBourneShellString ( executable . toString ( ) ) ; Runtime . getRuntime ( ) . exec ( new String [ ] { " / bin / sh " , " - c " , " open ▁ - F ▁ - W ▁ " + path + " ▁ & & ▁ rm ▁ " + path } ) ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableName ( @ NotNull ApplicationDescriptor application ) { return application . getId ( ) + " - latest - macos " ; }
Sargul/dbeaver | @ NotNull @ Override public String getExecutableExtension ( ) { return " dmg " ; }
dagnir/aws-sdk-java | public DeleteFlowLogsResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { DeleteFlowLogsResult deleteFlowLogsResult = new DeleteFlowLogsResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return deleteFlowLogsResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( " unsuccessful " , targetDepth ) ) { deleteFlowLogsResult . withUnsuccessful ( new ArrayList < UnsuccessfulItem > ( ) ) ; continue ; } if ( context . testExpression ( " unsuccessful / item " , targetDepth ) ) { deleteFlowLogsResult . withUnsuccessful ( UnsuccessfulItemStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return deleteFlowLogsResult ; } } } }
eFaps/eFaps-WebApp | public UploadField ( final String _wicketId , final IModel < AbstractUIField > _model , final boolean _multiple ) { super ( _wicketId , _model ) ; final Form < Void > form = new Form < > ( " form " ) ; add ( form ) ; final FileUploadField upload = new FileUploadField ( " upload " ) { private static final long serialVersionUID = 1L ; @ Override public String getInputName ( ) { return getFieldConfig ( ) . getName ( ) ; } @ Override protected void onComponentTag ( final ComponentTag _tag ) { super . onComponentTag ( _tag ) ; if ( _multiple ) { _tag . put ( " multiple " , " multiple " ) ; } } } ; form . add ( upload ) ; form . add ( new UploadProgressBar ( " progress " , form , upload ) ) ; this . fieldConfig = _model . getObject ( ) . getFieldConfiguration ( ) ; }
eFaps/eFaps-WebApp | @ Override public FieldConfiguration getFieldConfig ( ) { return this . fieldConfig ; }
eFaps/eFaps-WebApp | @ Override public IModel < String > getLabel ( ) { return Model . < String > of ( this . fieldConfig . getLabel ( ) ) ; }
inbloom/secure-data-service | public String [ ] getNameSpace ( ) { String [ ] copy = new String [ nameSpace . length ] ; System . arraycopy ( nameSpace , 0 , copy , 0 , nameSpace . length ) ; return copy ; }
inbloom/secure-data-service | public void setNameSpace ( String [ ] nameSpace ) { String [ ] copy = new String [ nameSpace . length ] ; System . arraycopy ( nameSpace , 0 , copy , 0 , nameSpace . length ) ; this . nameSpace = copy ; }
inbloom/secure-data-service | public List < ResourceEndPointTemplate > getResources ( ) { return resources ; }
inbloom/secure-data-service | public void setResources ( List < ResourceEndPointTemplate > resources ) { this . resources = resources ; }
GlenRSmith/elasticsearch | @ Override public double value ( ) { return getValue ( ) ; }
GlenRSmith/elasticsearch | @ Override public long getValue ( ) { return valueCount ; }
GlenRSmith/elasticsearch | @ Override public String getValueAsString ( ) { return Double . toString ( valueCount ) ; }
GlenRSmith/elasticsearch | @ Override public String getType ( ) { return ValueCountAggregationBuilder . NAME ; }
GlenRSmith/elasticsearch | @ Override protected XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { builder . field ( CommonFields . VALUE . getPreferredName ( ) , valueCount ) ; return builder ; }
haikuowuya/android_system_code | private HTTP ( ) { }
Geomatys/sis | SystemUnit ( final Class < Q > quantity , final UnitDimension dimension , final String symbol , final byte scope , final short epsg , final ScalarFactory < Q > factory ) { super ( symbol , scope , epsg ) ; this . quantity = quantity ; this . dimension = dimension ; this . factory = factory ; }
Geomatys/sis | ) private SystemUnit < ? > create ( final UnitDimension dim ) { if ( dim == dimension ) { return this ; } SystemUnit < ? > result = Units . get ( dim ) ; if ( result == null ) { result = new SystemUnit ( null , dim , null , ( byte ) 0 , ( short ) 0 , null ) ; } return result ; }
Geomatys/sis | @ Override public Dimension getDimension ( ) { return dimension ; }
Geomatys/sis | @ Override public SystemUnit < Q > getSystemUnit ( ) { return this ; }
Geomatys/sis | @ Override public Map < SystemUnit < ? > , Integer > getBaseUnits ( ) { final Map < UnitDimension , Integer > dim = dimension . getBaseDimensions ( ) ; if ( dim == null ) { return null ; } return ObjectConverters . derivedKeys ( dim , DimToUnit . INSTANCE , Integer . class ) ; }
Geomatys/sis | @ Override final Map < SystemUnit < ? > , Fraction > getBaseSystemUnits ( ) { return ObjectConverters . derivedKeys ( dimension . components , DimToUnit . INSTANCE , Fraction . class ) ; }
Geomatys/sis | private DimToUnit ( ) { }
Geomatys/sis | @ Override public Class < UnitDimension > getSourceClass ( ) { return UnitDimension . class ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public Class < SystemUnit < ? > > getTargetClass ( ) { return ( Class ) SystemUnit . class ; }
Geomatys/sis | @ Override public SystemUnit < ? > apply ( final UnitDimension dim ) { return Units . get ( dim ) ; }
Geomatys/sis | Object readResolve ( ) throws ObjectStreamException { return INSTANCE ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public < T extends Quantity < T > > Unit < T > asType ( final Class < T > type ) throws ClassCastException { ArgumentChecks . ensureNonNull ( " type " , type ) ; if ( type == quantity ) { if ( getSymbol ( ) == null ) { final SystemUnit < T > unit = Units . get ( type ) ; if ( unit != null ) { return unit ; } } return ( Unit < T > ) this ; } SystemUnit < T > unit = Units . get ( type ) ; if ( unit == null ) { unit = new SystemUnit < > ( type , dimension , null , ( byte ) 0 , ( short ) 0 , null ) ; } if ( ! dimension . equals ( unit . dimension ) ) { throw new ClassCastException ( Errors . format ( Errors . Keys . IncompatibleUnitDimension_5 , new Object [ ] { this , ( quantity != null ) ? quantity . getSimpleName ( ) : " ? " , dimension , type . getSimpleName ( ) , unit . dimension } ) ) ; } return unit ; }
Geomatys/sis | final boolean equalsIgnoreMetadata ( final Unit < Q > other ) { if ( quantity != null && other instanceof SystemUnit < ? > ) { final Class < ? > c = ( ( SystemUnit < Q > ) other ) . quantity ; if ( c != null ) { return ( quantity == c ) ; } } assert other == other . getSystemUnit ( ) : other ; return dimension . equals ( other . getDimension ( ) ) ; }
Geomatys/sis | @ Override public UnitConverter getConverterTo ( final Unit < Q > that ) throws UnconvertibleException { ArgumentChecks . ensureNonNull ( " that " , that ) ; final Unit < Q > step = that . getSystemUnit ( ) ; if ( step != this && ! equalsIgnoreMetadata ( step ) ) { throw new UnconvertibleException ( incompatible ( that ) ) ; } if ( step == that ) { return LinearConverter . IDENTITY ; } return that . getConverterTo ( step ) . inverse ( ) ; }
Geomatys/sis | @ Override public UnitConverter getConverterToAny ( final Unit < ? > that ) throws IncommensurableException { ArgumentChecks . ensureNonNull ( " that " , that ) ; final Unit < ? > step = that . getSystemUnit ( ) ; if ( step != this && ! isCompatible ( step ) ) { throw new IncommensurableException ( incompatible ( that ) ) ; } if ( step == that ) { return LinearConverter . IDENTITY ; } return that . getConverterToAny ( step ) . inverse ( ) ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public Unit < Q > alternate ( final String symbol ) { ArgumentChecks . ensureNonEmpty ( " symbol " , symbol ) ; for ( int i = 0 ; i < symbol . length ( ) ; ) { final int c = symbol . codePointAt ( i ) ; if ( ! isSymbolChar ( c ) ) { throw new IllegalArgumentException ( Errors . format ( Errors . Keys . IllegalCharacter_2 , " symbol " , String . valueOf ( Character . toChars ( c ) ) ) ) ; } i += Character . charCount ( c ) ; } if ( symbol . equals ( getSymbol ( ) ) ) { return this ; } final SystemUnit < Q > alt = new SystemUnit < > ( quantity , dimension , symbol , ( byte ) 0 , ( short ) 0 , factory ) ; if ( quantity != null ) { final Object existing = UnitRegistry . putIfAbsent ( symbol , alt ) ; if ( existing != null ) { if ( existing instanceof SystemUnit < ? > ) { final SystemUnit < ? > unit = ( SystemUnit < ? > ) existing ; if ( quantity . equals ( unit . quantity ) && dimension . equals ( unit . dimension ) ) { return ( SystemUnit < Q > ) unit ; } } throw new IllegalArgumentException ( Errors . format ( Errors . Keys . ElementAlreadyPresent_1 , symbol ) ) ; } UnitRegistry . putIfAbsent ( quantity , alt ) ; } return alt ; }
Geomatys/sis | @ Override public Unit < ? > multiply ( final Unit < ? > multiplier ) { ArgumentChecks . ensureNonNull ( " multiplier " , multiplier ) ; return combine ( multiplier , false ) ; }
Geomatys/sis | @ Override public Unit < ? > divide ( final Unit < ? > divisor ) { ArgumentChecks . ensureNonNull ( " divisor " , divisor ) ; return combine ( divisor , true ) ; }
Geomatys/sis | private < T extends Quantity < T > > Unit < ? > combine ( final Unit < T > other , final boolean divide ) { final Unit < T > step = other . getSystemUnit ( ) ; final Dimension dim = step . getDimension ( ) ; Unit < ? > result = create ( divide ? dimension . divide ( dim ) : dimension . multiply ( dim ) ) ; if ( step != other ) { UnitConverter c = other . getConverterTo ( step ) ; if ( ! c . isLinear ( ) ) { throw new IllegalArgumentException ( Errors . format ( Errors . Keys . NonRatioUnit_1 , other ) ) ; } if ( divide ) c = c . inverse ( ) ; result = result . transform ( c ) ; } return result ; }
Geomatys/sis | @ Override public Unit < ? > pow ( final int n ) { return create ( dimension . pow ( n ) ) ; }
Geomatys/sis | @ Override public Unit < ? > root ( final int n ) { return create ( dimension . root ( n ) ) ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " unchecked " ) public Unit < Q > transform ( UnitConverter operation ) { ArgumentChecks . ensureNonNull ( " operation " , operation ) ; AbstractUnit < Q > base = this ; if ( this == Units . KILOGRAM ) { base = ( AbstractUnit < Q > ) Units . GRAM ; operation = operation . concatenate ( LinearConverter . forPrefix ( ' k ' ) ) ; } return ConventionalUnit . create ( base , operation ) ; }
Geomatys/sis | ) final void related ( final int n ) { if ( related != null ) { throw new IllegalStateException ( ) ; } related = new ConventionalUnit [ n ] ; }
Geomatys/sis | @ Override @ SuppressWarnings ( " ReturnOfCollectionOrArrayField " ) final ConventionalUnit < Q > [ ] related ( ) { return related ; }
Geomatys/sis | @ Override public boolean equals ( final Object other , final ComparisonMode mode ) { if ( other == this ) { return true ; } if ( super . equals ( other , mode ) ) { final SystemUnit < ? > that = ( SystemUnit < ? > ) other ; return Objects . equals ( quantity , that . quantity ) && dimension . equals ( that . dimension ) ; } return false ; }
Geomatys/sis | @ Override public int hashCode ( ) { return super . hashCode ( ) + 37 * dimension . hashCode ( ) ; }
Geomatys/sis | @ Override public Quantity < Q > create ( final Number value , final Unit < Q > unit ) { final double v = AbstractConverter . doubleValue ( value ) ; if ( factory != null ) { return factory . create ( v , unit ) ; } else { return ScalarFallback . factory ( v , unit , quantity ) ; } }
lmjacksoniii/hazelcast | protected HazelcastInstanceProxy ( HazelcastInstanceImpl original ) { this . original = original ; name = original . getName ( ) ; }
lmjacksoniii/hazelcast | @ Override public String getName ( ) { return name ; }
lmjacksoniii/hazelcast | @ Override public < K , V > IMap < K , V > getMap ( String name ) { return getOriginal ( ) . getMap ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > IQueue < E > getQueue ( String name ) { return getOriginal ( ) . getQueue ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > ITopic < E > getTopic ( String name ) { return getOriginal ( ) . getTopic ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > ITopic < E > getReliableTopic ( String name ) { return getOriginal ( ) . getReliableTopic ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > ISet < E > getSet ( String name ) { return getOriginal ( ) . getSet ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > IList < E > getList ( String name ) { return getOriginal ( ) . getList ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < K , V > MultiMap < K , V > getMultiMap ( String name ) { return getOriginal ( ) . getMultiMap ( name ) ; }
lmjacksoniii/hazelcast | @ Override public JobTracker getJobTracker ( String name ) { return getOriginal ( ) . getJobTracker ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > Ringbuffer < E > getRingbuffer ( String name ) { return getOriginal ( ) . getRingbuffer ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ILock getLock ( String key ) { return getOriginal ( ) . getLock ( key ) ; }
lmjacksoniii/hazelcast | @ Override public IExecutorService getExecutorService ( String name ) { return getOriginal ( ) . getExecutorService ( name ) ; }
lmjacksoniii/hazelcast | @ Override public DurableExecutorService getDurableExecutorService ( String name ) { return getOriginal ( ) . getDurableExecutorService ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < T > T executeTransaction ( TransactionalTask < T > task ) throws TransactionException { return getOriginal ( ) . executeTransaction ( task ) ; }
lmjacksoniii/hazelcast | @ Override public < T > T executeTransaction ( TransactionOptions options , TransactionalTask < T > task ) throws TransactionException { return getOriginal ( ) . executeTransaction ( options , task ) ; }
lmjacksoniii/hazelcast | @ Override public TransactionContext newTransactionContext ( ) { return getOriginal ( ) . newTransactionContext ( ) ; }
lmjacksoniii/hazelcast | @ Override public TransactionContext newTransactionContext ( TransactionOptions options ) { return getOriginal ( ) . newTransactionContext ( options ) ; }
lmjacksoniii/hazelcast | @ Override public IdGenerator getIdGenerator ( String name ) { return getOriginal ( ) . getIdGenerator ( name ) ; }
lmjacksoniii/hazelcast | @ Override public IAtomicLong getAtomicLong ( String name ) { return getOriginal ( ) . getAtomicLong ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < K , V > ReplicatedMap < K , V > getReplicatedMap ( String name ) { return getOriginal ( ) . getReplicatedMap ( name ) ; }
lmjacksoniii/hazelcast | @ Override public < E > IAtomicReference < E > getAtomicReference ( String name ) { return getOriginal ( ) . getAtomicReference ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ICountDownLatch getCountDownLatch ( String name ) { return getOriginal ( ) . getCountDownLatch ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ISemaphore getSemaphore ( String name ) { return getOriginal ( ) . getSemaphore ( name ) ; }
lmjacksoniii/hazelcast | @ Override public ICacheManager getCacheManager ( ) { return getOriginal ( ) . getCacheManager ( ) ; }
lmjacksoniii/hazelcast | @ Override public Cluster getCluster ( ) { return getOriginal ( ) . getCluster ( ) ; }
lmjacksoniii/hazelcast | @ Override public Member getLocalEndpoint ( ) { return getOriginal ( ) . getLocalEndpoint ( ) ; }
lmjacksoniii/hazelcast | @ Override public Collection < DistributedObject > getDistributedObjects ( ) { return getOriginal ( ) . getDistributedObjects ( ) ; }
lmjacksoniii/hazelcast | @ Override public Config getConfig ( ) { return getOriginal ( ) . getConfig ( ) ; }
lmjacksoniii/hazelcast | @ Override public PartitionService getPartitionService ( ) { return getOriginal ( ) . getPartitionService ( ) ; }
lmjacksoniii/hazelcast | @ Override public QuorumService getQuorumService ( ) { return getOriginal ( ) . getQuorumService ( ) ; }
lmjacksoniii/hazelcast | @ Override public ClientService getClientService ( ) { return getOriginal ( ) . getClientService ( ) ; }
lmjacksoniii/hazelcast | @ Override public LoggingService getLoggingService ( ) { return getOriginal ( ) . getLoggingService ( ) ; }
lmjacksoniii/hazelcast | @ Override public LifecycleService getLifecycleService ( ) { final HazelcastInstanceImpl hz = original ; return hz != null ? hz . getLifecycleService ( ) : new TerminatedLifecycleService ( ) ; }
lmjacksoniii/hazelcast | @ Override public < T extends DistributedObject > T getDistributedObject ( String serviceName , String name ) { return getOriginal ( ) . getDistributedObject ( serviceName , name ) ; }
lmjacksoniii/hazelcast | @ Override public String addDistributedObjectListener ( DistributedObjectListener distributedObjectListener ) { return getOriginal ( ) . addDistributedObjectListener ( distributedObjectListener ) ; }
lmjacksoniii/hazelcast | @ Override public boolean removeDistributedObjectListener ( String registrationId ) { return getOriginal ( ) . removeDistributedObjectListener ( registrationId ) ; }
lmjacksoniii/hazelcast | @ Override public ConcurrentMap < String , Object > getUserContext ( ) { return getOriginal ( ) . getUserContext ( ) ; }
lmjacksoniii/hazelcast | @ Override public HazelcastXAResource getXAResource ( ) { return getOriginal ( ) . getXAResource ( ) ; }
lmjacksoniii/hazelcast | @ Override public CardinalityEstimator getCardinalityEstimator ( String name ) { return getOriginal ( ) . getCardinalityEstimator ( name ) ; }
lmjacksoniii/hazelcast | @ Override public IScheduledExecutorService getScheduledExecutorService ( String name ) { return getOriginal ( ) . getScheduledExecutorService ( name ) ; }
lmjacksoniii/hazelcast | @ Override public void shutdown ( ) { getLifecycleService ( ) . shutdown ( ) ; }
lmjacksoniii/hazelcast | @ Override public InternalSerializationService getSerializationService ( ) { return getOriginal ( ) . getSerializationService ( ) ; }
lmjacksoniii/hazelcast | public HazelcastInstanceImpl getOriginal ( ) { final HazelcastInstanceImpl hazelcastInstance = original ; if ( hazelcastInstance == null ) { throw new HazelcastInstanceNotActiveException ( ) ; } return hazelcastInstance ; }
lmjacksoniii/hazelcast | @ Override public String toString ( ) { final HazelcastInstanceImpl hazelcastInstance = original ; if ( hazelcastInstance != null ) { return hazelcastInstance . toString ( ) ; } return " HazelcastInstance ▁ { NOT ▁ ACTIVE } " ; }
lmjacksoniii/hazelcast | @ Override public int hashCode ( ) { return name != null ? name . hashCode ( ) : 0 ; }
lmjacksoniii/hazelcast | @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || ! ( o instanceof HazelcastInstance ) ) { return false ; } HazelcastInstance that = ( HazelcastInstance ) o ; return ! ( name != null ? ! name . equals ( that . getName ( ) ) : that . getName ( ) != null ) ; }
dydeve/web | private InternMapStorage ( Map < K , V > storage , InternStorage . ValueConstructor < K , V > valueConstructor ) { this . storage = storage ; this . valueConstructor = valueConstructor ; }
dydeve/web | @ Override public V interned ( K key ) { V existingKey = storage . get ( key ) ; V newKey = null ; if ( existingKey == null ) { newKey = valueConstructor . create ( key ) ; existingKey = storage . putIfAbsent ( key , newKey ) ; } return existingKey != null ? existingKey : newKey ; }
dydeve/web | @ Override public int size ( ) { return storage . size ( ) ; }
DragonSphereZ/DragonSphereZ | public SimpleAura ( String idName , String particle , DynamicLocation center , List < Player > players ) { super ( idName , particle , center , players ) ; pulseTick = 2 ; }
DragonSphereZ/DragonSphereZ | @ Override public void onRun ( ) { center . update ( ) ; x = random . nextDouble ( ) ; y = random . nextDouble ( ) ; z = random . nextDouble ( ) ; x = x * 4 - 2 ; y = y * 3 ; z = z * 4 - 2 ; Vector3d vector = new Vector3d ( x , y , z ) ; display ( vector ) ; }
leeyikjiun/scf4j | public TroveIntFloatMapAdapter ( TIntFloatMap map ) { this . map = map ; }
leeyikjiun/scf4j | public void clear ( ) { map . clear ( ) ; }
leeyikjiun/scf4j | public boolean containsKey ( int key ) { return map . containsKey ( key ) ; }
leeyikjiun/scf4j | public boolean containsValue ( float value ) { return map . containsValue ( value ) ; }
leeyikjiun/scf4j | public float get ( int key ) { return map . get ( key ) ; }
leeyikjiun/scf4j | public boolean isEmpty ( ) { return map . isEmpty ( ) ; }
leeyikjiun/scf4j | public float put ( int key , float value ) { return map . put ( key , value ) ; }
leeyikjiun/scf4j | public float remove ( int key ) { return map . remove ( key ) ; }
leeyikjiun/scf4j | public int size ( ) { return map . size ( ) ; }
peterarsentev/junior | @ Test public void whenZeroAndTenThenTen ( ) { Point first = new Point ( 0 , 0 ) ; Point second = new Point ( 0 , 10 ) ; double result = first . distance ( second ) ; first . info ( ) ; second . info ( ) ; System . out . println ( String . format ( " Result ▁ is ▁ % s " , result ) ) ; assertThat ( result , is ( 10D ) ) ; }
peterarsentev/junior | @ Test public void whenCheckItself ( ) { Point point = new Point ( 0 , 0 ) ; double result = point . distance ( point ) ; assertThat ( result , is ( 0D ) ) ; }
peterarsentev/junior | @ Test public void whenShowInfo ( ) { Point first = new Point ( 1 , 1 ) ; first . info ( ) ; Point second = new Point ( 2 , 2 ) ; second . info ( ) ; }
bbottema/java-reflection | @ Override public DataSource apply ( File file ) { return new FileDataSource ( file ) ; }
bbottema/java-reflection | @ Override public byte [ ] apply ( File file ) { try { return Files . readAllBytes ( file . toPath ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( " Was ▁ unable ▁ to ▁ read ▁ file ▁ content " , e ) ; } }
bbottema/java-reflection | @ Override public InputStream apply ( File file ) { try { return new FileInputStream ( file ) ; } catch ( FileNotFoundException e ) { throw new AssertionError ( " File ▁ found , ▁ but ▁ also ▁ not ▁ found ? ▁ Is ▁ this ▁ the ▁ real ▁ life . . . " , e ) ; } }
blinkfox/zealot | @ Test ( expected = FieldEmptyException . class ) public void testFieldEmptyException ( ) { throw new FieldEmptyException ( " xml标签属性字段未找到的异常 " ) ; }
ngbalk/SLOGO | public PowNode ( ) { super ( ) ; myType = " Pow " ; }
ngbalk/SLOGO | @ Override public List < AbstractAction > evaluate ( ) { myValue = Math . pow ( myChildren . get ( 0 ) . evaluate ( ) . get ( 0 ) . getValue ( ) , myChildren . get ( 1 ) . evaluate ( ) . get ( 0 ) . getValue ( ) ) ; myActions . add ( new ConstantAction ( myValue ) ) ; return myActions ; }
jhftrifork/elasticsearch | public ClusterState ( @ NotNull SerializableState zooKeeperStateDriver , @ NotNull FrameworkState frameworkState , @ NotNull TaskInfoFactory taskInfoFactory ) { if ( zooKeeperStateDriver == null || frameworkState == null ) { throw new NullPointerException ( ) ; } this . zooKeeperStateDriver = zooKeeperStateDriver ; this . frameworkState = frameworkState ; this . taskInfoFactory = taskInfoFactory ; frameworkState . onStatusUpdate ( this :: updateTask ) ; }
jhftrifork/elasticsearch | public List < TaskInfo > getTaskList ( ) { List < TaskInfo > taskInfoList = null ; try { taskInfoList = zooKeeperStateDriver . get ( getKey ( ) ) ; } catch ( IOException e ) { LOGGER . info ( " Unable ▁ to ▁ get ▁ key ▁ for ▁ cluster ▁ state ▁ due ▁ to ▁ invalid ▁ frameworkID . " , e ) ; } return taskInfoList == null ? new ArrayList < > ( 0 ) : taskInfoList ; }
jhftrifork/elasticsearch | public Map < String , Task > getGuiTaskList ( ) { Map < String , Task > tasks = new HashMap < > ( ) ; getTaskList ( ) . forEach ( taskInfo -> tasks . put ( taskInfo . getTaskId ( ) . getValue ( ) , taskInfoFactory . parse ( taskInfo , getStatus ( taskInfo . getTaskId ( ) ) . getStatus ( ) ) ) ) ; return tasks ; }
jhftrifork/elasticsearch | public ESTaskStatus getStatus ( TaskID taskID ) throws IllegalArgumentException { return getStatus ( getTask ( taskID ) ) ; }
jhftrifork/elasticsearch | private ESTaskStatus getStatus ( TaskInfo taskInfo ) { return new ESTaskStatus ( zooKeeperStateDriver , frameworkState . getFrameworkID ( ) , taskInfo , new StatePath ( zooKeeperStateDriver ) ) ; }
jhftrifork/elasticsearch | public void addTask ( ESTaskStatus esTask ) { addTask ( esTask . getTaskInfo ( ) ) ; }
jhftrifork/elasticsearch | public void addTask ( TaskInfo taskInfo ) { LOGGER . debug ( " Adding ▁ TaskInfo ▁ to ▁ cluster ▁ for ▁ task : ▁ " + taskInfo . getTaskId ( ) . getValue ( ) ) ; if ( exists ( taskInfo . getTaskId ( ) ) ) { removeTask ( taskInfo ) ; } List < TaskInfo > taskList = getTaskList ( ) ; taskList . add ( taskInfo ) ; setTaskInfoList ( taskList ) ; }
jhftrifork/elasticsearch | public void removeTask ( TaskInfo taskInfo ) throws InvalidParameterException { List < TaskInfo > taskList = getTaskList ( ) ; LOGGER . debug ( " Removing ▁ TaskInfo ▁ from ▁ cluster ▁ for ▁ task : ▁ " + taskInfo . getTaskId ( ) . getValue ( ) ) ; if ( ! taskList . remove ( taskInfo ) ) { throw new InvalidParameterException ( " TaskInfo ▁ does ▁ not ▁ exist ▁ in ▁ list : ▁ " + taskInfo . getTaskId ( ) . getValue ( ) ) ; } getStatus ( taskInfo ) . destroy ( ) ; setTaskInfoList ( taskList ) ; }
jhftrifork/elasticsearch | public Boolean exists ( TaskID taskId ) { try { getTask ( taskId ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
jhftrifork/elasticsearch | public TaskInfo getTask ( TaskID taskID ) throws IllegalArgumentException { List < TaskInfo > taskInfoList = getTaskList ( ) ; TaskInfo taskInfo = null ; for ( TaskInfo info : taskInfoList ) { if ( info . getTaskId ( ) . getValue ( ) . equals ( taskID . getValue ( ) ) ) { taskInfo = info ; break ; } } if ( taskInfo == null ) { throw new IllegalArgumentException ( " Could ▁ not ▁ find ▁ executor ▁ with ▁ that ▁ task ▁ ID : ▁ " + taskID . getValue ( ) ) ; } return taskInfo ; }
jhftrifork/elasticsearch | public TaskInfo getTask ( Protos . ExecutorID executorID ) throws IllegalArgumentException { if ( executorID . getValue ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( " ExecutorID . value ( ) ▁ is ▁ blank . ▁ Cannot ▁ be ▁ blank . " ) ; } List < TaskInfo > taskInfoList = getTaskList ( ) ; TaskInfo taskInfo = null ; for ( TaskInfo info : taskInfoList ) { if ( info . getExecutor ( ) . getExecutorId ( ) . getValue ( ) . equals ( executorID . getValue ( ) ) ) { taskInfo = info ; break ; } } if ( taskInfo == null ) { throw new IllegalArgumentException ( " Could ▁ not ▁ find ▁ executor ▁ with ▁ that ▁ executor ▁ ID : ▁ " + executorID . getValue ( ) ) ; } return taskInfo ; }
jhftrifork/elasticsearch | public void update ( Protos . TaskStatus status ) throws IllegalArgumentException { if ( ! exists ( status . getTaskId ( ) ) ) { throw new IllegalArgumentException ( " Task ▁ does ▁ not ▁ exist ▁ in ▁ zk . " ) ; } getStatus ( status . getTaskId ( ) ) . setStatus ( status ) ; }
jhftrifork/elasticsearch | public boolean taskInError ( Protos . TaskStatus status ) { return getStatus ( status . getTaskId ( ) ) . taskInError ( ) ; }
jhftrifork/elasticsearch | private void updateTask ( Protos . TaskStatus status ) { if ( ! exists ( status . getTaskId ( ) ) ) { LOGGER . warn ( " Could ▁ not ▁ find ▁ task ▁ in ▁ cluster ▁ state . " ) ; return ; } try { Protos . TaskInfo taskInfo = getTask ( status . getTaskId ( ) ) ; LOGGER . debug ( " Updating ▁ task ▁ status ▁ for ▁ executor : ▁ " + status . getExecutorId ( ) . getValue ( ) + " ▁ [ " + status . getTaskId ( ) . getValue ( ) + " , ▁ " + status . getTimestamp ( ) + " , ▁ " + status . getState ( ) + " ] " ) ; update ( status ) ; if ( taskInError ( status ) ) { LOGGER . error ( " Task ▁ in ▁ error ▁ state . ▁ Removing ▁ state ▁ for ▁ executor : ▁ " + status . getExecutorId ( ) . getValue ( ) + " , ▁ due ▁ to : ▁ " + status . getState ( ) ) ; removeTask ( taskInfo ) ; } } catch ( IllegalStateException | IllegalArgumentException e ) { LOGGER . error ( " Unable ▁ to ▁ write ▁ executor ▁ state ▁ to ▁ zookeeper " , e ) ; } }
jhftrifork/elasticsearch | private String logTaskList ( List < TaskInfo > taskInfoList ) { List < String > res = new ArrayList < > ( ) ; for ( TaskInfo t : taskInfoList ) { res . add ( t . getTaskId ( ) . getValue ( ) ) ; } return Arrays . toString ( res . toArray ( ) ) ; }
jhftrifork/elasticsearch | private void setTaskInfoList ( List < TaskInfo > taskInfoList ) { LOGGER . debug ( " Writing ▁ executor ▁ state ▁ list : ▁ " + logTaskList ( taskInfoList ) ) ; try { new StatePath ( zooKeeperStateDriver ) . mkdir ( getKey ( ) ) ; zooKeeperStateDriver . set ( getKey ( ) , taskInfoList ) ; } catch ( IOException ex ) { LOGGER . error ( " Could ▁ not ▁ write ▁ list ▁ of ▁ executor ▁ states ▁ to ▁ zookeeper : ▁ " , ex ) ; } }
jhftrifork/elasticsearch | private String getKey ( ) { return frameworkState . getFrameworkID ( ) . getValue ( ) + " / " + STATE_LIST ; }
pphdsny/ArithmeticTest | public int maxSatisfied ( int [ ] customers , int [ ] grumpy , int X ) { int [ ] dp = new int [ customers . length + 1 ] ; int [ ] zoreDp = new int [ customers . length + 1 ] ; int max = X > customers . length ? customers . length : X ; int sum = 0 ; for ( int i = 0 ; i < customers . length ; i ++ ) { if ( i < X ) { dp [ i + 1 ] = sum += customers [ i ] ; } zoreDp [ i + 1 ] = ( grumpy [ i ] == 0 ) ? customers [ i ] + zoreDp [ i ] : zoreDp [ i ] ; } int retMax = dp [ max ] + zoreDp [ customers . length ] - zoreDp [ max ] ; for ( int i = X ; i < customers . length ; i ++ ) { dp [ i + 1 ] = dp [ i ] - customers [ i - X ] + customers [ i ] ; int otherZore = zoreDp [ customers . length ] - zoreDp [ i + 1 ] + zoreDp [ i - X + 1 ] ; retMax = Math . max ( retMax , dp [ i + 1 ] + otherZore ) ; } return retMax ; }
FDevman/VIDEVOX-Beta | public AudioTTS ( JSONObject json ) throws VidevoxException { this ( ( String ) json . get ( NAME ) , ( String ) json . get ( SPEECH ) , ( double ) json . get ( START ) ) ; _active = ( boolean ) json . get ( ACTIVE ) ; }
FDevman/VIDEVOX-Beta | public AudioTTS ( String name , String speech , double offset ) throws VidevoxException { _name = name ; _startOffset = offset ; _speech = speech ; String path = " / tmp " ; logger . debug ( " this ( String , ▁ String , ▁ double ) ▁ - ▁ path ▁ found ▁ at : ▁ " + path ) ; _audioFile = new File ( path + " / " + name ) ; textToMP3 ( _audioFile , _speech ) ; _audioFile = ModelHelper . enforceFileExtension ( _audioFile , " . mp3" ) ; logger . debug ( " AudioTTS ( String , ▁ String , ▁ double ) ▁ - ▁ New ▁ TTS ▁ file : ▁ " + _audioFile . getAbsolutePath ( ) ) ; }
FDevman/VIDEVOX-Beta | public JSONObject toJSON ( ) { JSONObject json = new JSONObject ( ) ; json . put ( FILE , _audioFile . getAbsolutePath ( ) ) ; json . put ( START , _startOffset ) ; json . put ( ACTIVE , _active ) ; json . put ( SPEECH , _speech ) ; json . put ( NAME , _name ) ; return json ; }
FDevman/VIDEVOX-Beta | @ Override public boolean equals ( Object o ) { if ( o == this ) return true ; if ( o == null ) return false ; if ( ! ( o instanceof AudioTTS ) ) return false ; AudioTTS other = ( AudioTTS ) o ; if ( other . _audioFile . equals ( _audioFile ) && other . _startOffset == _startOffset ) { return true ; } else { return false ; } }
kkhatua/drill | private ScanFieldDeterminer ( ) { }
kkhatua/drill | public void addProjected ( SchemaPath path ) { projected . add ( path ) ; }
kkhatua/drill | public void addReferenced ( SchemaPath path ) { referenced . add ( path ) ; }
kkhatua/drill | public void addReferenced ( Collection < SchemaPath > paths ) { referenced . addAll ( paths ) ; }
kkhatua/drill | public void addProjected ( Collection < SchemaPath > paths ) { projected . addAll ( paths ) ; }
kkhatua/drill | @ Override public FieldList clone ( ) { FieldList newList = new FieldList ( ) ; for ( SchemaPath p : projected ) { newList . addProjected ( p ) ; } for ( SchemaPath p : referenced ) { newList . addReferenced ( p ) ; } return newList ; }
kkhatua/drill | @ Override public Void visitScan ( Scan scan , FieldList value ) { if ( value == null ) { scanFields . put ( scan , new FieldList ( ) ) ; } else { scanFields . put ( scan , value ) ; } return null ; }
kkhatua/drill | @ Override public Void visitStore ( Store store , FieldList value ) { store . getInput ( ) . accept ( this , value ) ; return null ; }
kkhatua/drill | @ Override public Void visitGroupingAggregate ( GroupingAggregate groupBy , FieldList value ) { FieldList list = new FieldList ( ) ; for ( NamedExpression e : groupBy . getExprs ( ) ) { list . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } for ( NamedExpression e : groupBy . getKeys ( ) ) { list . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } groupBy . getInput ( ) . accept ( this , list ) ; return null ; }
kkhatua/drill | @ Override public Void visitFilter ( Filter filter , FieldList value ) { value . addReferenced ( filter . getExpr ( ) . accept ( finder , null ) ) ; return null ; }
kkhatua/drill | @ Override public Void visitProject ( Project project , FieldList value ) { FieldList fl = new FieldList ( ) ; for ( NamedExpression e : project . getSelections ( ) ) { fl . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } return null ; }
kkhatua/drill | @ Override public Void visitValues ( Values constant , FieldList value ) { return null ; }
kkhatua/drill | @ Override public Void visitOrder ( Order order , FieldList fl ) { for ( Ordering o : order . getOrderings ( ) ) { fl . addReferenced ( o . getExpr ( ) . accept ( finder , null ) ) ; } return null ; }
kkhatua/drill | @ Override public Void visitJoin ( Join join , FieldList fl ) { { FieldList leftList = fl . clone ( ) ; for ( JoinCondition c : join . getConditions ( ) ) { leftList . addReferenced ( c . getLeft ( ) . accept ( finder , null ) ) ; } join . getLeft ( ) . accept ( this , leftList ) ; } { FieldList rightList = fl . clone ( ) ; for ( JoinCondition c : join . getConditions ( ) ) { rightList . addReferenced ( c . getRight ( ) . accept ( finder , null ) ) ; } join . getLeft ( ) . accept ( this , rightList ) ; } return null ; }
kkhatua/drill | @ Override public Void visitLimit ( Limit limit , FieldList value ) { limit . getInput ( ) . accept ( this , value ) ; return null ; }
kkhatua/drill | @ Override public Void visitUnion ( Union union , FieldList value ) { for ( LogicalOperator o : union . getInputs ( ) ) { o . accept ( this , value . clone ( ) ) ; } return null ; }
kkhatua/drill | @ Override public Set < SchemaPath > visitSchemaPath ( SchemaPath path , Void value ) { Set < SchemaPath > set = Sets . newHashSet ( ) ; set . add ( path ) ; return set ; }
kkhatua/drill | @ Override public Set < SchemaPath > visitUnknown ( LogicalExpression e , Void value ) { Set < SchemaPath > paths = Sets . newHashSet ( ) ; for ( LogicalExpression ex : e ) { paths . addAll ( ex . accept ( this , null ) ) ; } return paths ; }
lmmx/ppi-calcs | public NetworkException ( String message ) { super ( message ) ; }
Novemser/TomcatTest | @ Test public void test0001 ( ) { TestResource . testExpression ( " DN - 21-0010" , " $ { true ▁ & & ▁ false } " , " false " ) ; }
Novemser/TomcatTest | @ Test public void test0002 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0011" , " $ { true ▁ & & ▁ null } " , " false " ) ; }
Novemser/TomcatTest | @ Test public void test0003 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0012" , " $ { null ▁ & & ▁ null } " , " false " ) ; }
Novemser/TomcatTest | @ Test public void test0004 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0013" , " $ { false ▁ & & ▁ null } " , " false " ) ; }
Flibio/Ultimate-Spleef | protected UArena ( String arenaName , ArenaData data ) { super ( arenaName , Sponge . getGame ( ) , UltimateSpleef . access ) ; overrideData ( data ) ; getData ( ) . addPreventHungerLoss ( ArenaStates . ALL ) ; getData ( ) . addPreventPlayerDamage ( ArenaStates . ALL ) ; getData ( ) . addPreventBlockModify ( ArenaStates . ALL ) ; lobbySpawn = getData ( ) . getLocation ( " lobby " ) . get ( ) ; circleCenter = getData ( ) . getLocation ( " circlecenter " ) . get ( ) ; dedicated = data . getVariable ( " dedicated " , Boolean . class ) . get ( ) ; circleRad = ( int ) getData ( ) . getLocation ( " circleedge " ) . get ( ) . getPosition ( ) . distance ( circleCenter . getPosition ( ) ) ; blocks = getCircle ( circleCenter , circleRad ) ; getData ( ) . setTriggerPlayerEvents ( dedicated ) ; addArenaStateRunnable ( ArenaStates . LOBBY_COUNTDOWN , lobbyCountdown ) ; addArenaStateRunnable ( ArenaStates . GAME_COUNTDOWN , gameCountdown ) ; addArenaStateRunnable ( ArenaStates . GAME_PLAYING , gamePlaying ) ; addArenaStateRunnable ( ArenaStates . GAME_OVER , gameOver ) ; resetArena ( ) ; Sponge . getScheduler ( ) . createTaskBuilder ( ) . execute ( r -> { if ( lobbyWaiting ) { if ( lobbyTimer == 0 ) { lobbyWaiting = false ; if ( onlinePlayers . size ( ) >= minPlayers ) { arenaStateChange ( ArenaStates . LOBBY_COUNTDOWN ) ; } } lobbyTimer -- ; } else { lobbyTimer = 15 ; } } ) . async ( ) . interval ( 1 , TimeUnit . SECONDS ) . submit ( UltimateSpleef . access ) ; Sponge . getScheduler ( ) . createTaskBuilder ( ) . execute ( r -> { onlinePlayers . forEach ( uuid -> { Optional < Player > pOpt = resolvePlayer ( uuid ) ; if ( pOpt . isPresent ( ) ) { Sponge . getScheduler ( ) . createTaskBuilder ( ) . execute ( c -> { pOpt . get ( ) . offer ( Keys . FOOD_LEVEL , 20 ) ; } ) . submit ( UltimateSpleef . access ) ; } } ) ; } ) . async ( ) . interval ( 5 , TimeUnit . SECONDS ) . submit ( UltimateSpleef . access ) ; }
Flibio/Ultimate-Spleef | @ Override public void addOnlinePlayer ( Player player ) { if ( getOnlinePlayers ( ) . size ( ) >= maxPlayers ) { failed ( player , " arena . full " ) ; } else { ArenaState currentState = getCurrentState ( ) ; if ( currentState . equals ( ArenaStates . LOBBY_COUNTDOWN ) || currentState . equals ( ArenaStates . LOBBY_WAITING ) ) { resetPlayer ( player ) ; broadcast ( messages . getMessage ( " arena . join " , " player " , player . getName ( ) ) ) ; onlinePlayers . add ( player . getUniqueId ( ) ) ; if ( ! lobbyWaiting ) { if ( onlinePlayers . size ( ) >= minPlayers ) { arenaStateChange ( ArenaStates . LOBBY_COUNTDOWN ) ; } } } else { failed ( player , " arena . inprogress " ) ; } } }
Flibio/Ultimate-Spleef | @ Override public void removeOnlinePlayer ( Player player ) { onlinePlayers . remove ( player . getUniqueId ( ) ) ; broadcast ( messages . getMessage ( " arena . exit " , " player " , player . getName ( ) ) ) ; ArenaState currentState = getCurrentState ( ) ; if ( currentState . equals ( ArenaStates . LOBBY_COUNTDOWN ) && onlinePlayers . size ( ) < minPlayers ) { lobbyCountdown . cancelCountdown ( ) ; arenaStateChange ( ArenaStates . LOBBY_WAITING ) ; broadcast ( messages . getMessage ( " arena . lobbycountstop " ) ) ; } else if ( currentState . equals ( ArenaStates . GAME_PLAYING ) && onlinePlayers . size ( ) < minPlayers ) { arenaStateChange ( ArenaStates . LOBBY_WAITING ) ; broadcast ( messages . getMessage ( " arena . notenoughplayers " ) ) ; for ( Player p : resolvePlayers ( onlinePlayers ) ) { resetPlayer ( p ) ; } resetArena ( ) ; } else if ( currentState . equals ( ArenaStates . GAME_COUNTDOWN ) && onlinePlayers . size ( ) < minPlayers ) { gameCountdown . cancelCountdown ( ) ; arenaStateChange ( ArenaStates . LOBBY_WAITING ) ; broadcast ( messages . getMessage ( " arena . gamecountstop " ) ) ; for ( Player p : resolvePlayers ( onlinePlayers ) ) { resetPlayer ( p ) ; } resetArena ( ) ; } }
Flibio/Ultimate-Spleef | public List < Location < World > > getBlocks ( ) { return blocks ; }
Flibio/Ultimate-Spleef | public Location < World > getCenter ( ) { return circleCenter ; }
Flibio/Ultimate-Spleef | public void removeAlive ( UUID uuid ) { alivePlayers . remove ( uuid ) ; }
Flibio/Ultimate-Spleef | public List < UUID > getAlive ( ) { return alivePlayers ; }
Flibio/Ultimate-Spleef | public void resetOnlinePlayers ( ) { onlinePlayers . clear ( ) ; alivePlayers . clear ( ) ; }
Flibio/Ultimate-Spleef | private ArrayList < Location < World > > getCircle ( Location < World > center , int r ) { ArrayList < Location < World > > locations = new ArrayList < Location < World > > ( ) ; int cx = center . getBlockX ( ) ; int cy = center . getBlockY ( ) ; int cz = center . getBlockZ ( ) ; World w = center . getExtent ( ) ; int rSquared = r * r ; for ( int x = cx - r ; x <= cx + r ; x ++ ) { for ( int z = cz - r ; z <= cz + r ; z ++ ) { if ( ( cx - x ) * ( cx - x ) + ( cz - z ) * ( cz - z ) <= rSquared ) { locations . add ( new Location < World > ( w , x , cy , z ) ) ; } } } return locations ; }
Flibio/Ultimate-Spleef | public void resetArena ( ) { blocks . forEach ( block -> { block . setBlockType ( BlockTypes . QUARTZ_BLOCK ) ; block . sub ( 0 , 1 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 2 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 3 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 4 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . sub ( 0 , 5 , 0 ) . setBlockType ( BlockTypes . AIR ) ; block . getExtent ( ) . getEntities ( ) . forEach ( entity -> { if ( entity . getLocation ( ) . getPosition ( ) . distance ( block . getPosition ( ) ) < 1.5 ) { entity . remove ( ) ; } } ) ; } ) ; alivePlayers . addAll ( onlinePlayers ) ; lobbyWaiting = true ; lobbyTimer = 15 ; }
Flibio/Ultimate-Spleef | private void resetPlayer ( Player player ) { player . setLocationSafely ( lobbySpawn . add ( 0 , 1 , 0 ) ) ; player . offer ( Keys . GAME_MODE , GameModes . SURVIVAL ) ; player . offer ( Keys . HEALTH , 20.0 ) ; player . offer ( Keys . FOOD_LEVEL , 20 ) ; }
Flibio/Ultimate-Spleef | private void failed ( Player player , String messageKey ) { if ( dedicated ) { player . kick ( messages . getMessage ( messageKey ) ) ; } else { player . sendMessage ( messages . getMessage ( messageKey ) ) ; } }
vivantech/kc_fixes | public String getProposalNumber ( ) { return proposalNumber ; }
vivantech/kc_fixes | public void setProposalNumber ( String proposalNumber ) { this . proposalNumber = proposalNumber ; }
vivantech/kc_fixes | public String getBudgetStatusCode ( ) { return budgetStatusCode ; }
vivantech/kc_fixes | public void setBudgetStatusCode ( String budgetStatusCode ) { this . budgetStatusCode = budgetStatusCode ; }
vivantech/kc_fixes | public void setBudgetStatus ( BudgetStatus budgetStatus ) { this . budgetStatus = budgetStatus ; }
vivantech/kc_fixes | public BudgetStatus getBudgetStatus ( ) { return budgetStatus ; }
yuweijun/learning-programming | public OkHttpTimeoutExample ( ) { client = new OkHttpClient . Builder ( ) . connectTimeout ( 10 , TimeUnit . SECONDS ) . writeTimeout ( 10 , TimeUnit . SECONDS ) . readTimeout ( 30 , TimeUnit . SECONDS ) . build ( ) ; }
yuweijun/learning-programming | public void run ( ) throws IOException { Request request = new Request . Builder ( ) . url ( " https : // httpbin . org / delay / 2" ) . build ( ) ; Response response = client . newCall ( request ) . execute ( ) ; System . out . println ( " Response ▁ completed : ▁ " + response ) ; }
googleapis/google-api-java-client-services | public java . lang . String getResourceName ( ) { return resourceName ; }
googleapis/google-api-java-client-services | public SdfDownloadTask setResourceName ( java . lang . String resourceName ) { this . resourceName = resourceName ; return this ; }
googleapis/google-api-java-client-services | @ Override public SdfDownloadTask set ( String fieldName , Object value ) { return ( SdfDownloadTask ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public SdfDownloadTask clone ( ) { return ( SdfDownloadTask ) super . clone ( ) ; }
gauravlall/oneops | @ Test public void simpleLogTest ( ) { LoggingMsgService service = new LoggingMsgService ( ) ; XMPPSubscriber subscriber = new XMPPSubscriber ( ) ; NotificationMessage msg = new NotificationMessage ( ) ; msg . setNsPath ( " / a / b / c / d / e / f " ) ; msg . setSource ( " sourceOpen " ) ; msg . setSubject ( " subjectOfMsg " ) ; msg . setText ( " message - text - xya " ) ; msg . setType ( NotificationType . deployment ) ; msg . setSeverity ( NotificationSeverity . critical ) ; msg . setTemplateName ( " template12" ) ; msg . setTimestamp ( System . currentTimeMillis ( ) ) ; boolean res = service . postMessage ( msg , subscriber ) ; assert ( res ) ; }
cnishina/jmeter-client | public String buildFromTemplate ( ) { String content = Utils . getStringFromFile ( RESOURCE ) ; for ( Entry < String , String > entry : map . entrySet ( ) ) { String match = entry . getKey ( ) . replace ( " { { " , " \\ { \\ { " ) . replace ( " } } " , " \\ } \\ } " ) ; content = content . replaceAll ( match , entry . getValue ( ) ) ; } return content ; }
J0-J0/cateringManagement | if ( " add " . equals ( action ) ) { addCart ( request , response ) ; return ; }
J0-J0/cateringManagement | else if ( " delete " . equals ( action ) ) { deleteCart ( request , response ) ; return ; }
J0-J0/cateringManagement | else if ( " update " . equals ( action ) ) { updateCart ( request , response ) ; return ; }
J0-J0/cateringManagement | private void updateCart ( HttpServletRequest request , HttpServletResponse response ) { int cartId = Integer . parseInt ( request . getParameter ( " cartId " ) ) ; int num = Integer . parseInt ( request . getParameter ( " num " ) ) ; float sum = Float . parseFloat ( request . getParameter ( " sum " ) ) ; DaoFactory daoFactory = new DaoFactory ( ) ; try { daoFactory . beginConnectionScope ( ) ; daoFactory . beginTransaction ( ) ; CartDao cartDao = daoFactory . createCartDao ( ) ; cartDao . updateCart ( cartId , num , sum ) ; daoFactory . endTransaction ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; daoFactory . abortTransaction ( ) ; } finally { daoFactory . endConnectionScope ( ) ; } }
J0-J0/cateringManagement | private void deleteCart ( HttpServletRequest request , HttpServletResponse response ) { int cartId = Integer . parseInt ( request . getParameter ( " cartId " ) ) ; DaoFactory daoFactory = new DaoFactory ( ) ; try { daoFactory . beginConnectionScope ( ) ; daoFactory . beginTransaction ( ) ; CartDao cartDao = daoFactory . createCartDao ( ) ; cartDao . deleteCart ( cartId ) ; daoFactory . endTransaction ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; daoFactory . abortTransaction ( ) ; } finally { daoFactory . endConnectionScope ( ) ; } }
J0-J0/cateringManagement | private void addCart ( HttpServletRequest request , HttpServletResponse response ) throws IOException { response . setContentType ( " text / html ; charset = utf - 8" ) ; PrintWriter out = new PrintWriter ( response . getWriter ( ) , true ) ; int userId = 0 ; if ( StringUtil . isEmpty ( request . getParameter ( " userId " ) ) ) { out . println ( " Ìí¼ÓÊ § ° Ü £ ¬ Çë¼ì²éÊÇ · ñµÇÂ¼ £ ¡ " ) ; out . close ( ) ; return ; } else { userId = Integer . parseInt ( request . getParameter ( " userId " ) ) ; } int foodId = Integer . parseInt ( request . getParameter ( " foodId " ) ) ; String tmp = request . getParameter ( " num " ) ; int num = 0 ; if ( StringUtil . isNotEmpty ( tmp ) ) { num = Integer . parseInt ( tmp ) ; } DaoFactory daoFactory = new DaoFactory ( ) ; try { daoFactory . beginConnectionScope ( ) ; daoFactory . beginTransaction ( ) ; CartDao cartDao = daoFactory . createCartDao ( ) ; boolean flag = cartDao . selectCart ( userId , foodId ) ; if ( ! flag ) { FoodDao foodDao = daoFactory . createFoodDao ( ) ; MerchantDao merchantDao = daoFactory . createMerchantDao ( ) ; Food food = foodDao . selectFood ( foodId ) ; Merchant merchant = merchantDao . selectMerchant ( food . getMerchantId ( ) ) ; Cart cart = cartDao . createCart ( merchant . getMerchantId ( ) , merchant . getMerchantName ( ) , userId , food , num ) ; cartDao . addCart ( cart ) ; out . println ( " Ìí¼Ó³É¹ ¦ £ ¡ " ) ; out . close ( ) ; daoFactory . endTransaction ( ) ; } else { } daoFactory . endTransaction ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; daoFactory . abortTransaction ( ) ; } finally { daoFactory . endConnectionScope ( ) ; } }
byrao123/clickfortech | private MapProviderFactory ( ) { super ( ) ; }
byrao123/clickfortech | private MapProvider getMapProvider ( String providerClassName ) { MapProvider mp = null ; if ( this . mapProviderMap . containsKey ( providerClassName ) ) { mp = this . mapProviderMap . get ( providerClassName ) ; } else { String clzName = null ; if ( providerClassName . indexOf ( " . " ) >= 0 ) { clzName = providerClassName ; } else { clzName = MAP_PROVIDER_PACKAGE + " . " + providerClassName ; } try { Class providerClass = Class . forName ( clzName ) ; mp = ( MapProvider ) providerClass . newInstance ( ) ; this . mapProviderMap . put ( providerClassName , mp ) ; } catch ( Throwable t ) { Print . logError ( " MapProvider ▁ creation ▁ error : ▁ " + clzName + " ▁ [ " + t ) ; mp = null ; } } return mp ; }
izeye/spring-boot | public DispatcherServletConfiguration ( ServerProperties server , WebMvcProperties webMvcProperties , ObjectProvider < MultipartConfigElement > multipartConfigProvider ) { this . server = server ; this . webMvcProperties = webMvcProperties ; this . multipartConfig = multipartConfigProvider . getIfAvailable ( ) ; }
izeye/spring-boot | @ Bean ( name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) public DispatcherServlet dispatcherServlet ( ) { DispatcherServlet dispatcherServlet = new DispatcherServlet ( ) ; dispatcherServlet . setDispatchOptionsRequest ( this . webMvcProperties . isDispatchOptionsRequest ( ) ) ; dispatcherServlet . setDispatchTraceRequest ( this . webMvcProperties . isDispatchTraceRequest ( ) ) ; dispatcherServlet . setThrowExceptionIfNoHandlerFound ( this . webMvcProperties . isThrowExceptionIfNoHandlerFound ( ) ) ; return dispatcherServlet ; }
izeye/spring-boot | @ Bean ( name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) public ServletRegistrationBean dispatcherServletRegistration ( ) { ServletRegistrationBean registration = new ServletRegistrationBean ( dispatcherServlet ( ) , this . server . getServletMapping ( ) ) ; registration . setName ( DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; if ( this . multipartConfig != null ) { registration . setMultipartConfig ( this . multipartConfig ) ; } return registration ; }
izeye/spring-boot | @ Bean @ ConditionalOnBean ( MultipartResolver . class ) @ ConditionalOnMissingBean ( name = DispatcherServlet . MULTIPART_RESOLVER_BEAN_NAME ) public MultipartResolver multipartResolver ( MultipartResolver resolver ) { return resolver ; }
izeye/spring-boot | @ Override public ConditionOutcome getMatchOutcome ( ConditionContext context , AnnotatedTypeMetadata metadata ) { ConfigurableListableBeanFactory beanFactory = context . getBeanFactory ( ) ; ConditionOutcome outcome = checkServlets ( beanFactory ) ; if ( ! outcome . isMatch ( ) ) { return outcome ; } return checkServletRegistrations ( beanFactory ) ; }
izeye/spring-boot | private ConditionOutcome checkServlets ( ConfigurableListableBeanFactory beanFactory ) { List < String > servlets = Arrays . asList ( beanFactory . getBeanNamesForType ( DispatcherServlet . class , false , false ) ) ; boolean containsDispatcherBean = beanFactory . containsBean ( DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; if ( servlets . isEmpty ( ) ) { if ( containsDispatcherBean ) { return ConditionOutcome . noMatch ( " found ▁ no ▁ DispatcherServlet ▁ " + " but ▁ a ▁ non - DispatcherServlet ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; } return ConditionOutcome . match ( " no ▁ DispatcherServlet ▁ found " ) ; } if ( servlets . contains ( DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ) { return ConditionOutcome . noMatch ( " found ▁ DispatcherServlet ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; } if ( containsDispatcherBean ) { return ConditionOutcome . noMatch ( " found ▁ non - DispatcherServlet ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; } return ConditionOutcome . match ( " one ▁ or ▁ more ▁ DispatcherServlets ▁ " + " found ▁ and ▁ none ▁ is ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME ) ; }
izeye/spring-boot | private ConditionOutcome checkServletRegistrations ( ConfigurableListableBeanFactory beanFactory ) { List < String > registrations = Arrays . asList ( beanFactory . getBeanNamesForType ( ServletRegistrationBean . class , false , false ) ) ; boolean containsDispatcherRegistrationBean = beanFactory . containsBean ( DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; if ( registrations . isEmpty ( ) ) { if ( containsDispatcherRegistrationBean ) { return ConditionOutcome . noMatch ( " found ▁ no ▁ ServletRegistrationBean ▁ " + " but ▁ a ▁ non - ServletRegistrationBean ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; } return ConditionOutcome . match ( " no ▁ ServletRegistrationBean ▁ found " ) ; } if ( registrations . contains ( DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ) { return ConditionOutcome . noMatch ( " found ▁ ServletRegistrationBean ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; } if ( containsDispatcherRegistrationBean ) { return ConditionOutcome . noMatch ( " found ▁ non - ServletRegistrationBean ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; } return ConditionOutcome . match ( " one ▁ or ▁ more ▁ ServletRegistrationBeans ▁ is ▁ found ▁ and ▁ none ▁ is ▁ named ▁ " + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME ) ; }
UniversityOfHawaiiORS/rice | public NoteType ( ) { }
UniversityOfHawaiiORS/rice | public String getNoteTypeCode ( ) { return noteTypeCode ; }
UniversityOfHawaiiORS/rice | public void setNoteTypeCode ( String noteTypeCode ) { this . noteTypeCode = noteTypeCode ; }
UniversityOfHawaiiORS/rice | public String getNoteTypeDescription ( ) { return noteTypeDescription ; }
UniversityOfHawaiiORS/rice | public void setNoteTypeDescription ( String noteTypeDescription ) { this . noteTypeDescription = noteTypeDescription ; }
UniversityOfHawaiiORS/rice | public boolean isNoteTypeActiveIndicator ( ) { return noteTypeActiveIndicator ; }
UniversityOfHawaiiORS/rice | public void setNoteTypeActiveIndicator ( boolean noteTypeActiveIndicator ) { this . noteTypeActiveIndicator = noteTypeActiveIndicator ; }
UniversityOfHawaiiORS/rice | @ Override public boolean isActive ( ) { return noteTypeActiveIndicator ; }
UniversityOfHawaiiORS/rice | @ Override public void setActive ( boolean active ) { this . noteTypeActiveIndicator = active ; }
OpenCubicChunks/CubicChunks | @ Override public int getChunkPosY ( ) { return this . cubeY ; }
OpenCubicChunks/CubicChunks | @ Override public void initCubic ( World world , int cubeY ) { if ( this . isCubic ) { throw new IllegalStateException ( " Already ▁ initialized ! " ) ; } this . cubeY = cubeY ; this . isCubic = true ; }
OpenCubicChunks/CubicChunks | @ Override public CubePos getCubePos ( ) { return new CubePos ( getX ( ) , getY ( ) , getZ ( ) ) ; }
OpenCubicChunks/CubicChunks | I ) V " , ordinal = 0 ) , locals = LocalCapture . CAPTURE_FAILHARD ) private void writeYToNbt ( int chunkX , int chunkZ , CallbackInfoReturnable < NBTTagCompound > cir , NBTTagCompound tag ) { tag . setInteger ( " ChunkY " , this . cubeY ) ; }
OpenCubicChunks/CubicChunks | @ Inject ( method = " readStructureComponentsFromNBT " , at = @ At ( " HEAD " ) ) private void readYFromNBT ( World world , NBTTagCompound tag , CallbackInfo cbi ) { if ( tag . hasKey ( " ChunkY " ) ) { this . isCubic = true ; this . cubeY = tag . getInteger ( " ChunkY " ) ; } }
OpenCubicChunks/CubicChunks | @ Override public int getX ( ) { return getChunkPosX ( ) ; }
OpenCubicChunks/CubicChunks | @ Override public int getY ( ) { return getChunkPosY ( ) ; }
OpenCubicChunks/CubicChunks | @ Override public int getZ ( ) { return getChunkPosZ ( ) ; }
OpenCubicChunks/CubicChunks | @ Override public boolean isCubic ( ) { return this . isCubic ; }
danielkec/Ansible | @ Test public void testPrintWelcome ( ) throws Exception { }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . start , in . end , in . buffer , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . start , in . end , in . buffer , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . start , in . start + 16 , in . buffer , 0 ) ; } }
dremio/dremio-oss | public void setup ( ) { }
dremio/dremio-oss | public void eval ( ) { out . isSet = 1 ; if ( in . isSet == 0 ) { out . value = 0 ; } else { out . value = com . dremio . common . expression . fn . impl . HashHelper . hash64 ( in . value , 0 ) ; } }
hyang04/jruyi | @ Override public void onMessage ( IMessage message ) { Object action = message . removeProperty ( IoConstants . MP_SESSION_ACTION ) ; if ( action != null ) { if ( action == SessionAction . OPEN ) { connect ( message ) ; } else { if ( action == SessionAction . CLOSE ) { IChannel channel = getChannel ( message ) ; if ( channel != null ) channel . close ( ) ; } else m_logger . warn ( StrUtil . buildString ( this , " , ▁ Unknown ▁ Session ▁ Action : ▁ " , action ) ) ; message . close ( ) ; } return ; } IChannel channel = getChannel ( message ) ; if ( channel == null ) { m_logger . warn ( StrUtil . buildString ( this , " , ▁ Session [ " + IoConstants . MP_ACTIVE_SESSION + " ] ▁ Not ▁ Found : ▁ " , message ) ) ; return ; } channel . write ( message . detach ( ) , false ) ; message . close ( ) ; }
hyang04/jruyi | @ Override public void onMessageSent ( IChannel channel , Object data ) { int timeout = m_conf . readTimeout ( ) ; if ( timeout > 0 ) channel . scheduleReadTimeout ( timeout ) ; else if ( timeout == 0 ) onChannelReadTimedOut ( channel ) ; }
hyang04/jruyi | @ Override public void onMessageReceived ( IChannel channel , Object data ) { if ( channel . cancelTimeout ( ) ) enqueue ( channel , data ) ; else if ( data instanceof ICloseable ) ( ( ICloseable ) data ) . close ( ) ; }
hyang04/jruyi | @ Override public void onChannelOpened ( IChannel channel ) { super . onChannelOpened ( channel ) ; fireSessionEvent ( channel , SessionEvent . OPENED , ( IMessage ) channel . detach ( ) ) ; }
hyang04/jruyi | @ Override public void onChannelClosed ( IChannel channel ) { super . onChannelClosed ( channel ) ; fireSessionEvent ( channel , SessionEvent . CLOSED ) ; }
hyang04/jruyi | @ Override public void onChannelConnectTimedOut ( IChannel channel ) { super . onChannelConnectTimedOut ( channel ) ; fireSessionEvent ( channel , SessionEvent . CONN_TIMEDOUT ) ; }
hyang04/jruyi | @ Override public void onChannelReadTimedOut ( IChannel channel ) { super . onChannelReadTimedOut ( channel ) ; fireSessionEvent ( channel , SessionEvent . READ_TIMEDOUT ) ; }
hyang04/jruyi | @ Override public void onChannelException ( IChannel channel , Throwable t ) { IMessage message = ( IMessage ) channel . detach ( ) ; if ( message != null ) { if ( channel != getChannel ( message ) ) { m_logger . error ( StrUtil . buildString ( this , " ▁ got ▁ an ▁ error ▁ on ▁ connecting : ▁ " , message ) , t ) ; if ( configuration ( ) . sessionEventMask ( ) . notifyConnError ( ) ) { fireSessionEvent ( null , SessionEvent . CONN_ERROR , message ) ; return ; } } else { m_logger . error ( StrUtil . buildString ( this , " ▁ got ▁ an ▁ error ▁ on ▁ sending / recving : ▁ " , message ) , t ) ; if ( configuration ( ) . sessionEventMask ( ) . notifyRwError ( ) ) { fireSessionEvent ( null , SessionEvent . RW_ERROR , message ) ; return ; } } message . close ( ) ; } }
hyang04/jruyi | @ Override public void startInternal ( ) { m_logger . info ( StrUtil . buildString ( " Starting ▁ " , this , " . . . " ) ) ; super . startInternal ( ) ; m_logger . info ( StrUtil . buildString ( this , " ▁ started " ) ) ; }
hyang04/jruyi | @ Override public final void stopInternal ( ) { m_logger . info ( StrUtil . buildString ( " Stopping ▁ " , this , " . . . " ) ) ; super . stopInternal ( ) ; m_logger . info ( StrUtil . buildString ( this , " ▁ stopped " ) ) ; }
hyang04/jruyi | @ Override TcpClientConf configuration ( ) { return m_conf ; }
hyang04/jruyi | @ Override String getFactoryPid ( ) { return " org . jruyi . io . tcpclient . longconn " ; }
hyang04/jruyi | @ Override TcpClientConf updateConf ( Map < String , ? > props ) { TcpClientConf conf = m_conf ; if ( props == null ) m_conf = null ; else { TcpClientConf newConf = new TcpClientConf ( ) ; newConf . initialize ( props ) ; m_conf = newConf ; } return conf ; }
hyang04/jruyi | private void enqueue ( IChannel channel , Object data ) { IProducer producer = producer ( ) ; IMessage message = producer . createMessage ( ) ; message . putProperty ( IoConstants . MP_ACTIVE_SESSION , channel ) ; message . attach ( data ) ; producer . send ( message ) ; }
hyang04/jruyi | private IChannel getChannel ( IMessage message ) { return ( IChannel ) message . getProperty ( IoConstants . MP_ACTIVE_SESSION ) ; }
hyang04/jruyi | private void fireSessionEvent ( IChannel channel , SessionEvent event ) { IProducer producer = producer ( ) ; IMessage message = producer . createMessage ( ) ; message . putProperty ( IoConstants . MP_SESSION_EVENT , event ) ; message . putProperty ( IoConstants . MP_ACTIVE_SESSION , channel ) ; producer . send ( message ) ; }
hyang04/jruyi | private void fireSessionEvent ( IChannel channel , SessionEvent event , IMessage message ) { message . putProperty ( IoConstants . MP_SESSION_EVENT , event ) ; if ( channel != null ) message . putProperty ( IoConstants . MP_ACTIVE_SESSION , channel ) ; producer ( ) . send ( message ) ; }
FHannes/intellij-community | public void testSingleTokenAnchor ( ) { PsiFile file = myFixture . configureByText ( " a . xml " , " < " ) ; PsiAnchor anchor = PsiAnchor . create ( assertInstanceOf ( file . findElementAt ( 0 ) , XmlToken . class ) ) ; WriteCommandAction . runWriteCommandAction ( getProject ( ) , ( ) -> file . getViewProvider ( ) . getDocument ( ) . replaceString ( 0 , 1 , " ▁ " ) ) ; PsiDocumentManager . getInstance ( getProject ( ) ) . commitAllDocuments ( ) ; assertInstanceOf ( file . findElementAt ( 0 ) , PsiWhiteSpace . class ) ; assertNull ( anchor . retrieve ( ) ) ; }
FHannes/intellij-community | public void testInjectedAnchor ( ) { new MyTestInjector ( getPsiManager ( ) ) . injectAll ( myFixture . getTestRootDisposable ( ) ) ; myFixture . configureByText ( " a . java " , " class ▁ X ▁ { ▁ String ▁ java = \" class ▁ < caret > Foo ▁ { } \" } " ) ; PsiClass cls = ( PsiClass ) myFixture . getElementAtCaret ( ) ; assertEquals ( " Foo " , cls . getName ( ) ) ; PsiAnchor anchor = PsiAnchor . create ( cls ) ; myFixture . type ( ' \n ' ) ; PsiDocumentManager . getInstance ( getProject ( ) ) . commitAllDocuments ( ) ; assertNull ( anchor . retrieve ( ) ) ; }
msurdi/redeye | GenericType < List < Entry > > entryListType = new GenericType < List < Entry > > ( ) { }
msurdi/redeye | GenericType < List < Query > > queryListType = new GenericType < List < Query > > ( ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . mapshow ) ; LocationManager lm = ( LocationManager ) getSystemService ( Context . LOCATION_SERVICE ) ; LocationListener llistener = new mylocationlistener ( ) ; lm . requestLocationUpdates ( LocationManager . GPS_PROVIDER , 0 , 0 , llistener ) ; mapSearchBox = ( EditText ) findViewById ( R . id . mapSearchBox ) ; Button mapSearch = ( Button ) findViewById ( R . id . search ) ; Button mapViewType = ( Button ) findViewById ( R . id . mapTypeChange ) ; inputManager = ( InputMethodManager ) getSystemService ( Context . INPUT_METHOD_SERVICE ) ; mapSearch . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { inputManager . hideSoftInputFromWindow ( getCurrentFocus ( ) . getWindowToken ( ) , InputMethodManager . HIDE_NOT_ALWAYS ) ; if ( mapSearchBox . getText ( ) . toString ( ) . trim ( ) . length ( ) <= 0 ) { Toast . makeText ( MapShow . this , " Popraw ▁ puste ▁ pole ! " , Toast . LENGTH_SHORT ) . show ( ) ; } else { search = mapSearchBox . getText ( ) . toString ( ) ; try { Geocoder geocoder = new Geocoder ( getApplicationContext ( ) , Locale . getDefault ( ) ) ; List < Address > nazwy = geocoder . getFromLocationName ( search , 1 ) ; if ( nazwy . size ( ) == 0 ) { System . out . println ( " Error " ) ; } address = nazwy . get ( 0 ) ; LatLng searchedLocation = new LatLng ( address . getLatitude ( ) , address . getLongitude ( ) ) ; googleMap . moveCamera ( CameraUpdateFactory . newLatLng ( searchedLocation ) ) ; googleMap . animateCamera ( CameraUpdateFactory . zoomTo ( 16 ) ) ; } catch ( Exception e ) { Log . e ( " " , " Wystapil ▁ blad ▁ ! ▁ " , e ) ; } } } } ) ; mapViewType . setOnClickListener ( new OnClickListener ( ) { int mapFlag = 0 ; @ Override public void onClick ( View v ) { if ( mapFlag == 0 ) { googleMap . setMapType ( GoogleMap . MAP_TYPE_SATELLITE ) ; mapFlag = 1 ; } else if ( mapFlag == 1 ) { googleMap . setMapType ( GoogleMap . MAP_TYPE_NORMAL ) ; mapFlag = 0 ; } } } ) ; googleMap = ( ( MapFragment ) getFragmentManager ( ) . findFragmentById ( R . id . map ) ) . getMap ( ) ; if ( LocationMessage . locationMapView == null ) { Toast . makeText ( MapShow . this , " Poczekaj ▁ na ▁ pobranie ▁ aktualnej ▁ lokalizacji . " , Toast . LENGTH_SHORT ) . show ( ) ; } else { currentLocationMapShow = new LatLng ( LocationMessage . locationMapView . getLatitude ( ) , LocationMessage . locationMapView . getLongitude ( ) ) ; } googleMap . moveCamera ( CameraUpdateFactory . newLatLng ( currentLocationMapShow ) ) ; googleMap . animateCamera ( CameraUpdateFactory . zoomTo ( 18 ) ) ; googleMap . setOnMapLongClickListener ( new GoogleMap . OnMapLongClickListener ( ) { @ Override public void onMapLongClick ( LatLng point ) { marker = new MarkerOptions ( ) . position ( new LatLng ( point . latitude , point . longitude ) ) . title ( " New ▁ Marker " ) ; markerLatitude = point . latitude ; markerLongitude = point . longitude ; googleMap . addMarker ( marker ) ; mapShowed = " true " ; Toast . makeText ( MapShow . this , " Wskazano ▁ lokalizacje ! " , Toast . LENGTH_LONG ) . show ( ) ; final Dialog dialog = new Dialog ( MapShow . this ) ; dialog . setContentView ( R . layout . dialog ) ; dialog . setTitle ( " Wybrano ▁ lokalizacje " ) ; TextView text = ( TextView ) dialog . findViewById ( R . id . text ) ; text . setText ( " Lokalizacja ▁ docelowa ▁ jest ▁ poprawna ? " ) ; Button buttonYes = ( Button ) dialog . findViewById ( R . id . dialogButtonYes ) ; Button buttonNo = ( Button ) dialog . findViewById ( R . id . dialogButtonNo ) ; dialog . show ( ) ; buttonNo . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { googleMap . clear ( ) ; dialog . dismiss ( ) ; Toast . makeText ( MapShow . this , " Zmien ▁ lokalizacje " , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; buttonYes . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { dialog . dismiss ( ) ; finish ( ) ; } } ) ; } } ) ; }
MarcinBaranski/ArrivedSMS | @ Override public void onLocationChanged ( Location location ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onStatusChanged ( String provider , int status , Bundle extras ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onProviderEnabled ( String provider ) { }
MarcinBaranski/ArrivedSMS | @ Override public void onProviderDisabled ( String provider ) { }
mkeijzer/push-forth | private SymbolTable ( ) { }
csviri/bodylimiter | public InvalidContentLengthException ( long maxLength , long actualLength ) { super ( " Actual ▁ content ▁ length ▁ is ▁ larger ▁ than ▁ maximum ▁ allowed . ▁ Actual : ▁ " + actualLength + " , ▁ Max : ▁ " + maxLength ) ; }
mztaylor/rice-git | @ Override protected String getBookmarkUrl ( ) { return BOOKMARK_URL ; }
mztaylor/rice-git | @ Override protected void navigate ( ) throws Exception { waitAndClickDemoLink ( ) ; waitAndClickByLinkText ( " Travel ▁ Account ▁ Type ▁ Inquiry " ) ; }
mztaylor/rice-git | @ Test @ Ignore public void testTravelAccountTypeInquiryNav ( ) throws Exception { testTravelAccountTypeInquiry ( ) ; passed ( ) ; }
mztaylor/rice-git | @ Test public void testTravelAccountTypeInquiryBookmark ( ) throws Exception { testTravelAccountTypeInquiry ( ) ; passed ( ) ; }
mztaylor/rice-git | protected void testTravelAccountTypeInquiry ( ) throws Exception { waitForElementPresentByXpath ( " // a [ contains ( text ( ) , ' IAT ' ) ] " ) ; assertTextPresent ( LabsInquiryBase . LABELED_IAT_TEXT ) ; }
dagnir/aws-sdk-java | public java . util . List < OrderableDBInstanceOption > getOrderableDBInstanceOptions ( ) { if ( orderableDBInstanceOptions == null ) { orderableDBInstanceOptions = new com . amazonaws . internal . SdkInternalList < OrderableDBInstanceOption > ( ) ; } return orderableDBInstanceOptions ; }
dagnir/aws-sdk-java | public void setOrderableDBInstanceOptions ( java . util . Collection < OrderableDBInstanceOption > orderableDBInstanceOptions ) { if ( orderableDBInstanceOptions == null ) { this . orderableDBInstanceOptions = null ; return ; } this . orderableDBInstanceOptions = new com . amazonaws . internal . SdkInternalList < OrderableDBInstanceOption > ( orderableDBInstanceOptions ) ; }
dagnir/aws-sdk-java | public DescribeOrderableDBInstanceOptionsResult withOrderableDBInstanceOptions ( OrderableDBInstanceOption ... orderableDBInstanceOptions ) { if ( this . orderableDBInstanceOptions == null ) { setOrderableDBInstanceOptions ( new com . amazonaws . internal . SdkInternalList < OrderableDBInstanceOption > ( orderableDBInstanceOptions . length ) ) ; } for ( OrderableDBInstanceOption ele : orderableDBInstanceOptions ) { this . orderableDBInstanceOptions . add ( ele ) ; } return this ; }
dagnir/aws-sdk-java | public DescribeOrderableDBInstanceOptionsResult withOrderableDBInstanceOptions ( java . util . Collection < OrderableDBInstanceOption > orderableDBInstanceOptions ) { setOrderableDBInstanceOptions ( orderableDBInstanceOptions ) ; return this ; }
dagnir/aws-sdk-java | public void setMarker ( String marker ) { this . marker = marker ; }
dagnir/aws-sdk-java | public String getMarker ( ) { return this . marker ; }
dagnir/aws-sdk-java | public DescribeOrderableDBInstanceOptionsResult withMarker ( String marker ) { setMarker ( marker ) ; return this ; }
dagnir/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getOrderableDBInstanceOptions ( ) != null ) sb . append ( " OrderableDBInstanceOptions : ▁ " ) . append ( getOrderableDBInstanceOptions ( ) ) . append ( " , " ) ; if ( getMarker ( ) != null ) sb . append ( " Marker : ▁ " ) . append ( getMarker ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dagnir/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeOrderableDBInstanceOptionsResult == false ) return false ; DescribeOrderableDBInstanceOptionsResult other = ( DescribeOrderableDBInstanceOptionsResult ) obj ; if ( other . getOrderableDBInstanceOptions ( ) == null ^ this . getOrderableDBInstanceOptions ( ) == null ) return false ; if ( other . getOrderableDBInstanceOptions ( ) != null && other . getOrderableDBInstanceOptions ( ) . equals ( this . getOrderableDBInstanceOptions ( ) ) == false ) return false ; if ( other . getMarker ( ) == null ^ this . getMarker ( ) == null ) return false ; if ( other . getMarker ( ) != null && other . getMarker ( ) . equals ( this . getMarker ( ) ) == false ) return false ; return true ; }
dagnir/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getOrderableDBInstanceOptions ( ) == null ) ? 0 : getOrderableDBInstanceOptions ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMarker ( ) == null ) ? 0 : getMarker ( ) . hashCode ( ) ) ; return hashCode ; }
dagnir/aws-sdk-java | @ Override public DescribeOrderableDBInstanceOptionsResult clone ( ) { try { return ( DescribeOrderableDBInstanceOptionsResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
phorust/BitSlayer | public Item ( float x , float y , float width , float height , int strInc , int defInc , int speedInc , int healthRegen , int healthSteal ) { super ( x , y , width , height ) ; }
andrewgaul/aws-sdk-java | public ConfigurationOptionDescription unmarshall ( StaxUnmarshallerContext context ) throws Exception { ConfigurationOptionDescription configurationOptionDescription = new ConfigurationOptionDescription ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 2 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return configurationOptionDescription ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( " Namespace " , targetDepth ) ) { configurationOptionDescription . setNamespace ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " Name " , targetDepth ) ) { configurationOptionDescription . setName ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " DefaultValue " , targetDepth ) ) { configurationOptionDescription . setDefaultValue ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " ChangeSeverity " , targetDepth ) ) { configurationOptionDescription . setChangeSeverity ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " UserDefined " , targetDepth ) ) { configurationOptionDescription . setUserDefined ( BooleanStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " ValueType " , targetDepth ) ) { configurationOptionDescription . setValueType ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " ValueOptions / member " , targetDepth ) ) { configurationOptionDescription . getValueOptions ( ) . add ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " MinValue " , targetDepth ) ) { configurationOptionDescription . setMinValue ( IntegerStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " MaxValue " , targetDepth ) ) { configurationOptionDescription . setMaxValue ( IntegerStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " MaxLength " , targetDepth ) ) { configurationOptionDescription . setMaxLength ( IntegerStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " Regex " , targetDepth ) ) { configurationOptionDescription . setRegex ( OptionRestrictionRegexStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return configurationOptionDescription ; } } } }
mschieder/jira-pvp-sso | @ Override public List < SecurityService > getServices ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLoginURL ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLoginForwardPath ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLinkLoginURL ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLogoutURL ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getOriginalURLKey ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public Authenticator getAuthenticator ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public AuthenticationContext getAuthenticationContext ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public SecurityController getController ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public RoleMapper getRoleMapper ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public ElevatedSecurityGuard getElevatedSecurityGuard ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public RememberMeService getRememberMeService ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public RedirectPolicy getRedirectPolicy ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public < T extends Interceptor > List < T > getInterceptors ( Class < T > desiredInterceptorClass ) { return null ; }
mschieder/jira-pvp-sso | @ Override public void destroy ( ) { }
mschieder/jira-pvp-sso | @ Override public String getLoginCookiePath ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getLoginCookieKey ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getWebsudoRequestKey ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public boolean isInsecureCookie ( ) { return false ; }
mschieder/jira-pvp-sso | @ Override public int getAutoLoginCookieAge ( ) { return 0 ; }
mschieder/jira-pvp-sso | @ Override public String getCookieEncoding ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public String getAuthType ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public boolean isInvalidateSessionOnLogin ( ) { return false ; }
mschieder/jira-pvp-sso | @ Override public boolean isInvalidateSessionOnWebsudo ( ) { return false ; }
mschieder/jira-pvp-sso | @ Override public List < String > getInvalidateSessionExcludeList ( ) { return null ; }
mschieder/jira-pvp-sso | @ Override public List < String > getInvalidateWebsudoSessionExcludeList ( ) { return null ; }
pedrodonte/modulo-base | @ Override public VoUserRol nuevoRegistro ( VoUserRol registro ) throws ErrorDelSistemaException { try { DTORolDeUsuario dto = helperMapper . toDTO ( registro ) ; sgTbUserRolDAO . save ( dto ) ; } catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; } catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; } return registro ; }
pedrodonte/modulo-base | @ Override public VoUserRol actualizarRegistro ( VoUserRol registro ) throws ErrorDelSistemaException { try { DTORolDeUsuario dto = helperMapper . toDTO ( registro ) ; sgTbUserRolDAO . update ( dto ) ; } catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; } catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; } return registro ; }
pedrodonte/modulo-base | @ Override public void eliminarRegistro ( VoUserRol registro ) throws ErrorDelSistemaException { throw new UnsupportedOperationException ( " Metodo ▁ Sin ▁ Implementar " ) ; }
pedrodonte/modulo-base | for ( DTORolDeUsuario dto : sgTbUserRolDAO . findAll ( ) ) { VoUserRol vo = helperMapper . toVO ( dto ) ; registros . add ( vo ) ; }
pedrodonte/modulo-base | catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; }
pedrodonte/modulo-base | catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; }
pedrodonte/modulo-base | if ( dto == null ) { throw new RegistrosNoEncontradosException ( " No ▁ se ▁ encuentran ▁ registros ▁ para ▁ el ▁ parametro ▁ de ▁ entrada : " + id ) ; }
pedrodonte/modulo-base | catch ( HelperMapeoException e ) { e . printStackTrace ( ) ; }
pedrodonte/modulo-base | catch ( PersistenciaDAOException e ) { e . printStackTrace ( ) ; }
jssenyange/traccar | public Event ( String type , Position position ) { setType ( type ) ; setPositionId ( position . getId ( ) ) ; setDeviceId ( position . getDeviceId ( ) ) ; eventTime = position . getDeviceTime ( ) ; }
jssenyange/traccar | public Event ( String type , long deviceId ) { setType ( type ) ; setDeviceId ( deviceId ) ; eventTime = new Date ( ) ; }
jssenyange/traccar | public Event ( ) { }
jssenyange/traccar | public Date getEventTime ( ) { return eventTime ; }
jssenyange/traccar | public void setEventTime ( Date eventTime ) { this . eventTime = eventTime ; }
jssenyange/traccar | public long getPositionId ( ) { return positionId ; }
jssenyange/traccar | public void setPositionId ( long positionId ) { this . positionId = positionId ; }
jssenyange/traccar | public long getGeofenceId ( ) { return geofenceId ; }
jssenyange/traccar | public void setGeofenceId ( long geofenceId ) { this . geofenceId = geofenceId ; }
jssenyange/traccar | public long getMaintenanceId ( ) { return maintenanceId ; }
jssenyange/traccar | public void setMaintenanceId ( long maintenanceId ) { this . maintenanceId = maintenanceId ; }
Nygar/SdosExample | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_layout ) ; new Handler ( ) . postDelayed ( ( ) -> navigator . navigateToLogin ( this ) , 2000 ) ; }
Jon6193/Android-MVVM | @ Override public void onCreate ( ) { super . onCreate ( ) ; if ( LeakCanary . isInAnalyzerProcess ( this ) ) { return ; } LeakCanary . install ( this ) ; Stetho . initializeWithDefaults ( this ) ; if ( BuildConfig . DEBUG ) { Timber . plant ( new Timber . DebugTree ( ) ) ; Timber . plant ( new StethoTree ( ) ) ; } component = DaggerApplicationComponent . builder ( ) . applicationModule ( new ApplicationModule ( this ) ) . build ( ) ; component . inject ( this ) ; }
Jon6193/Android-MVVM | public AppGraph getComponent ( ) { return component ; }
perezd/bazel | private LinkOptions ( ImmutableList < String > linkOptions , Object symbolForEquality ) { this . linkOptions = Preconditions . checkNotNull ( linkOptions ) ; this . symbolForEquality = Preconditions . checkNotNull ( symbolForEquality ) ; }
perezd/bazel | public ImmutableList < String > get ( ) { return linkOptions ; }
perezd/bazel | @ Override public int hashCode ( ) { return symbolForEquality . hashCode ( ) ; }
perezd/bazel | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LinkOptions ) ) { return false ; } LinkOptions that = ( LinkOptions ) obj ; if ( ! this . symbolForEquality . equals ( that . symbolForEquality ) ) { return false ; } if ( this . linkOptions . equals ( that . linkOptions ) ) { return true ; } BugReport . sendBugReport ( new IllegalStateException ( " Unexpected ▁ inequality ▁ with ▁ equal ▁ symbols : ▁ " + this + " , ▁ " + that ) ) ; return false ; }
perezd/bazel | @ Override public String toString ( ) { return ' [ ' + Joiner . on ( " , " ) . join ( linkOptions ) + " ] ▁ ( owner : ▁ " + symbolForEquality ; }
perezd/bazel | public Artifact getArtifact ( ) { return artifact ; }
perezd/bazel | @ Override public Artifact getArtifactForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return artifact ; }
perezd/bazel | public NestedSet < Artifact > getDeclaredIncludeSrcs ( ) { return declaredIncludeSrcs ; }
perezd/bazel | @ Override public Depset getDeclaredIncludeSrcsForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return Depset . of ( Artifact . TYPE , getDeclaredIncludeSrcs ( ) ) ; }
perezd/bazel | @ Override public int hashCode ( ) { return artifact . hashCode ( ) ; }
perezd/bazel | @ Override public final boolean isImmutable ( ) { return true ; }
perezd/bazel | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof Linkstamp ) ) { return false ; } Linkstamp other = ( Linkstamp ) obj ; return artifact . equals ( other . artifact ) && Arrays . equals ( this . nestedDigest , other . nestedDigest ) ; }
perezd/bazel | public LinkerInput ( Label owner , ImmutableList < LibraryToLink > libraries , ImmutableList < LinkOptions > userLinkFlags , ImmutableList < Artifact > nonCodeInputs , ImmutableList < Linkstamp > linkstamps ) { this . owner = owner ; this . libraries = libraries ; this . userLinkFlags = userLinkFlags ; this . nonCodeInputs = nonCodeInputs ; this . linkstamps = linkstamps ; }
perezd/bazel | @ Override public boolean isImmutable ( ) { return true ; }
perezd/bazel | @ Override public Label getStarlarkOwner ( ) throws EvalException { if ( owner == null ) { throw Starlark . errorf ( " Owner ▁ is ▁ null . ▁ This ▁ means ▁ that ▁ some ▁ target ▁ upstream ▁ is ▁ of ▁ a ▁ rule ▁ type ▁ that ▁ uses ▁ the " + " ▁ old ▁ API ▁ of ▁ create _ linking _ context " ) ; } return owner ; }
perezd/bazel | public Label getOwner ( ) { return owner ; }
perezd/bazel | public List < LibraryToLink > getLibraries ( ) { return libraries ; }
perezd/bazel | @ Override public Sequence < LibraryToLink > getStarlarkLibrariesToLink ( StarlarkSemantics semantics ) { return StarlarkList . immutableCopyOf ( getLibraries ( ) ) ; }
perezd/bazel | public List < LinkOptions > getUserLinkFlags ( ) { return userLinkFlags ; }
perezd/bazel | @ Override public Sequence < String > getStarlarkUserLinkFlags ( ) { return StarlarkList . immutableCopyOf ( getUserLinkFlags ( ) . stream ( ) . map ( LinkOptions :: get ) . flatMap ( Collection :: stream ) . collect ( ImmutableList . toImmutableList ( ) ) ) ; }
perezd/bazel | public List < Artifact > getNonCodeInputs ( ) { return nonCodeInputs ; }
perezd/bazel | @ Override public Sequence < Artifact > getStarlarkNonCodeInputs ( ) { return StarlarkList . immutableCopyOf ( getNonCodeInputs ( ) ) ; }
perezd/bazel | public List < Linkstamp > getLinkstamps ( ) { return linkstamps ; }
perezd/bazel | @ StarlarkMethod ( name = " linkstamps " , documented = false , structField = true ) public Sequence < Linkstamp > getLinkstampsForStarlark ( ) { return StarlarkList . immutableCopyOf ( getLinkstamps ( ) ) ; }
perezd/bazel | @ Override public void debugPrint ( Printer printer ) { printer . append ( " < LinkerInput ( owner = " ) ; owner . debugPrint ( printer ) ; printer . append ( " , ▁ libraries = [ " ) ; for ( LibraryToLink libraryToLink : libraries ) { libraryToLink . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] , ▁ userLinkFlags = [ " ) ; printer . append ( Joiner . on ( " , ▁ " ) . join ( userLinkFlags ) ) ; printer . append ( " ] , ▁ nonCodeInputs = [ " ) ; for ( Artifact nonCodeInput : nonCodeInputs ) { nonCodeInput . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] ) > " ) ; }
perezd/bazel | public Builder addLibrary ( LibraryToLink library ) { this . libraries . add ( library ) ; return this ; }
perezd/bazel | public Builder addLibraries ( List < LibraryToLink > libraries ) { this . libraries . addAll ( libraries ) ; return this ; }
perezd/bazel | public Builder addUserLinkFlags ( List < LinkOptions > userLinkFlags ) { this . userLinkFlags . addAll ( userLinkFlags ) ; return this ; }
perezd/bazel | public Builder addLinkstamps ( List < Linkstamp > linkstamps ) { this . linkstamps . addAll ( linkstamps ) ; return this ; }
perezd/bazel | public Builder addNonCodeInputs ( List < Artifact > nonCodeInputs ) { this . nonCodeInputs . addAll ( nonCodeInputs ) ; return this ; }
perezd/bazel | public Builder setOwner ( Label owner ) { this . owner = owner ; return this ; }
perezd/bazel | public LinkerInput build ( ) { return new LinkerInput ( owner , libraries . build ( ) , userLinkFlags . build ( ) , nonCodeInputs . build ( ) , linkstamps . build ( ) ) ; }
perezd/bazel | @ Override public boolean equals ( Object otherObject ) { if ( ! ( otherObject instanceof LinkerInput ) ) { return false ; } LinkerInput other = ( LinkerInput ) otherObject ; if ( this == other ) { return true ; } return Objects . equal ( this . owner , other . owner ) && this . libraries . equals ( other . libraries ) && this . userLinkFlags . equals ( other . userLinkFlags ) && this . linkstamps . equals ( other . linkstamps ) && this . nonCodeInputs . equals ( other . nonCodeInputs ) ; }
perezd/bazel | @ Override public int hashCode ( ) { return Objects . hashCode ( libraries . hashCode ( ) , userLinkFlags . hashCode ( ) , linkstamps . hashCode ( ) , nonCodeInputs . hashCode ( ) ) ; }
perezd/bazel | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " userLinkFlags " , userLinkFlags ) . add ( " linkstamps " , linkstamps ) . add ( " libraries " , libraries ) . add ( " nonCodeInputs " , nonCodeInputs ) . toString ( ) ; }
perezd/bazel | @ Override public void debugPrint ( Printer printer ) { printer . append ( " < CcLinkingContext ( [ " ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { linkerInput . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] ) > " ) ; }
perezd/bazel | public CcLinkingContext ( NestedSet < LinkerInput > linkerInputs , @ Nullable ExtraLinkTimeLibraries extraLinkTimeLibraries ) { this . linkerInputs = linkerInputs ; this . extraLinkTimeLibraries = extraLinkTimeLibraries ; }
perezd/bazel | public List < Artifact > getStaticModeParamsForExecutableLibraries ( ) { ImmutableList . Builder < Artifact > libraryListBuilder = ImmutableList . builder ( ) ; for ( LibraryToLink libraryToLink : getLibraries ( ) . toList ( ) ) { if ( libraryToLink . getStaticLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getStaticLibrary ( ) ) ; } else if ( libraryToLink . getPicStaticLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getPicStaticLibrary ( ) ) ; } else if ( libraryToLink . getInterfaceLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getInterfaceLibrary ( ) ) ; } else { libraryListBuilder . add ( libraryToLink . getDynamicLibrary ( ) ) ; } } return libraryListBuilder . build ( ) ; }
perezd/bazel | public List < Artifact > getStaticModeParamsForDynamicLibraryLibraries ( ) { ImmutableList . Builder < Artifact > artifactListBuilder = ImmutableList . builder ( ) ; for ( LibraryToLink library : getLibraries ( ) . toList ( ) ) { if ( library . getPicStaticLibrary ( ) != null ) { artifactListBuilder . add ( library . getPicStaticLibrary ( ) ) ; } else if ( library . getStaticLibrary ( ) != null ) { artifactListBuilder . add ( library . getStaticLibrary ( ) ) ; } else if ( library . getInterfaceLibrary ( ) != null ) { artifactListBuilder . add ( library . getInterfaceLibrary ( ) ) ; } else { artifactListBuilder . add ( library . getDynamicLibrary ( ) ) ; } } return artifactListBuilder . build ( ) ; }
perezd/bazel | public List < Artifact > getDynamicLibrariesForRuntime ( boolean linkingStatically ) { return LibraryToLink . getDynamicLibrariesForRuntime ( linkingStatically , getLibraries ( ) . toList ( ) ) ; }
perezd/bazel | public NestedSet < LibraryToLink > getLibraries ( ) { NestedSetBuilder < LibraryToLink > libraries = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { libraries . addAll ( linkerInput . libraries ) ; } return libraries . build ( ) ; }
perezd/bazel | public NestedSet < LinkerInput > getLinkerInputs ( ) { return linkerInputs ; }
perezd/bazel | @ Override public Depset getStarlarkLinkerInputs ( ) { return Depset . of ( LinkerInput . TYPE , linkerInputs ) ; }
perezd/bazel | @ Override public Sequence < String > getStarlarkUserLinkFlags ( ) { return StarlarkList . immutableCopyOf ( getFlattenedUserLinkFlags ( ) ) ; }
perezd/bazel | @ Override public Object getStarlarkLibrariesToLink ( StarlarkSemantics semantics ) { if ( semantics . getBool ( BuildLanguageOptions . INCOMPATIBLE_DEPSET_FOR_LIBRARIES_TO_LINK_GETTER ) ) { return Depset . of ( LibraryToLink . TYPE , getLibraries ( ) ) ; } else { return StarlarkList . immutableCopyOf ( getLibraries ( ) . toList ( ) ) ; } }
perezd/bazel | @ Override public Depset getStarlarkNonCodeInputs ( ) { return Depset . of ( Artifact . TYPE , getNonCodeInputs ( ) ) ; }
perezd/bazel | @ Override public ExtraLinkTimeLibraryApi getGoLinkCArchiveForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; ExtraLinkTimeLibrary goLinkCArchive = null ; if ( extraLinkTimeLibraries != null ) { for ( ExtraLinkTimeLibrary extraLibrary : extraLinkTimeLibraries . getExtraLibraries ( ) ) { if ( goLinkCArchive != null ) { throw new EvalException ( " multiple ▁ GoLinkCArchive ▁ entries ▁ in ▁ go _ link _ c _ archive " ) ; } goLinkCArchive = extraLibrary ; } } return goLinkCArchive ; }
perezd/bazel | public NestedSet < LinkOptions > getUserLinkFlags ( ) { NestedSetBuilder < LinkOptions > userLinkFlags = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { userLinkFlags . addAll ( linkerInput . getUserLinkFlags ( ) ) ; } return userLinkFlags . build ( ) ; }
perezd/bazel | public ImmutableList < String > getFlattenedUserLinkFlags ( ) { return getUserLinkFlags ( ) . toList ( ) . stream ( ) . map ( LinkOptions :: get ) . flatMap ( Collection :: stream ) . collect ( ImmutableList . toImmutableList ( ) ) ; }
perezd/bazel | public NestedSet < Linkstamp > getLinkstamps ( ) { NestedSetBuilder < Linkstamp > linkstamps = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { linkstamps . addAll ( linkerInput . getLinkstamps ( ) ) ; } return linkstamps . build ( ) ; }
perezd/bazel | @ Override public Depset getLinkstampsForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return Depset . of ( Linkstamp . TYPE , getLinkstamps ( ) ) ; }
perezd/bazel | public NestedSet < Artifact > getNonCodeInputs ( ) { NestedSetBuilder < Artifact > nonCodeInputs = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { nonCodeInputs . addAll ( linkerInput . getNonCodeInputs ( ) ) ; } return nonCodeInputs . build ( ) ; }
perezd/bazel | public ExtraLinkTimeLibraries getExtraLinkTimeLibraries ( ) { return extraLinkTimeLibraries ; }
perezd/bazel | @ Override public ExtraLinkTimeLibraries getExtraLinkTimeLibrariesForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return getExtraLinkTimeLibraries ( ) ; }
perezd/bazel | public Builder setOwner ( Label owner ) { linkerInputBuilder . setOwner ( owner ) ; return this ; }
perezd/bazel | public Builder addLibrary ( LibraryToLink library ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLibrary ( library ) ; return this ; }
perezd/bazel | public Builder addLibraries ( List < LibraryToLink > libraries ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLibraries ( libraries ) ; return this ; }
perezd/bazel | public Builder addUserLinkFlags ( List < LinkOptions > userLinkFlags ) { hasDirectLinkerInput = true ; linkerInputBuilder . addUserLinkFlags ( userLinkFlags ) ; return this ; }
perezd/bazel | public Builder addLinkstamps ( List < Linkstamp > linkstamps ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLinkstamps ( linkstamps ) ; return this ; }
perezd/bazel | Builder addNonCodeInputs ( List < Artifact > nonCodeInputs ) { hasDirectLinkerInput = true ; linkerInputBuilder . addNonCodeInputs ( nonCodeInputs ) ; return this ; }
perezd/bazel | public Builder addTransitiveLinkerInputs ( NestedSet < LinkerInput > linkerInputs ) { this . linkerInputs . addTransitive ( linkerInputs ) ; return this ; }
perezd/bazel | public Builder setExtraLinkTimeLibraries ( ExtraLinkTimeLibraries extraLinkTimeLibraries ) { Preconditions . checkState ( this . extraLinkTimeLibraries == null ) ; this . extraLinkTimeLibraries = extraLinkTimeLibraries ; return this ; }
perezd/bazel | public CcLinkingContext build ( ) { if ( hasDirectLinkerInput ) { linkerInputs . add ( linkerInputBuilder . build ( ) ) ; } return new CcLinkingContext ( linkerInputs . build ( ) , extraLinkTimeLibraries ) ; }
perezd/bazel | @ Override public boolean equals ( Object otherObject ) { if ( ! ( otherObject instanceof CcLinkingContext ) ) { return false ; } CcLinkingContext other = ( CcLinkingContext ) otherObject ; if ( this == other ) { return true ; } return this . linkerInputs . shallowEquals ( other . linkerInputs ) ; }
perezd/bazel | @ Override public int hashCode ( ) { return linkerInputs . shallowHashCode ( ) ; }
perezd/bazel | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " linkerInputs " , linkerInputs ) . toString ( ) ; }
lvweiwolf/poi-3.16 | public List < CTAdjPoint2D > getPt ( ) { if ( pt == null ) { pt = new ArrayList < CTAdjPoint2D > ( ) ; } return this . pt ; }
lvweiwolf/poi-3.16 | public boolean isSetPt ( ) { return ( ( this . pt != null ) && ( ! this . pt . isEmpty ( ) ) ) ; }
lvweiwolf/poi-3.16 | public void unsetPt ( ) { this . pt = null ; }
googleads/googleads-java-lib | public List < ApiError > getErrors ( ) { if ( errors == null ) { errors = new ArrayList < ApiError > ( ) ; } return this . errors ; }
jatin9896/incubator-carbondata | EscapeSequences ( String name , char escapeChar ) { this . name = name ; this . escapeChar = escapeChar ; }
jatin9896/incubator-carbondata | public String getName ( ) { return this . name ; }
jatin9896/incubator-carbondata | public String getEscapeChar ( ) { return String . valueOf ( this . escapeChar ) ; }
viktozhu/java-beginners | public Circle ( int x1 , int x2 , int radius ) { this . x1 = x1 ; this . x2 = x2 ; this . radius = radius ; }
viktozhu/java-beginners | @ Override public double getSquare ( ) { return Math . PI * radius * radius ; }
viktozhu/java-beginners | @ Override public double getPerimeter ( ) { return 2 * Math . PI * radius ; }
snorochevskiy/JTranslate | @ RequestMapping ( value = " / all " , method = RequestMethod . GET ) public Set < TranslationProjectDto > listProjects ( ) { Set < TranslationProjectDto > projects = new HashSet < > ( ) ; for ( TranslationProjectEntity p : translationsDao . getAllTranslationProjects ( ) ) { projects . add ( TranslationProjectMapper . map ( p ) ) ; } return projects ; }
snorochevskiy/JTranslate | / subprojects " , method = RequestMethod . GET ) public Set < TranslationSubprojectDto > listSubprojects ( @ PathVariable ( " id " ) Long projectId ) { Set < TranslationSubprojectDto > subprojects = new HashSet < > ( ) ; for ( TranslationSubprojectEntity p : translationsDao . getAllSubprojects ( projectId ) ) { subprojects . add ( TranslationSubprojectMapper . map ( p ) ) ; } return subprojects ; }
snorochevskiy/JTranslate | @ RequestMapping ( value = " / create " , method = RequestMethod . POST ) public void createProject ( @ RequestBody TranslationProjectDto projectDto ) { translationsDao . createProject ( TranslationProjectMapper . map ( projectDto ) ) ; }
snorochevskiy/JTranslate | / create - subproject " , method = RequestMethod . POST ) public void createSubroject ( @ RequestBody TranslationSubprojectDto subprojectDto ) { translationsDao . createSubproject ( TranslationSubprojectMapper . map ( subprojectDto ) ) ; }
johnaoahra80/hibernate-semantic-query | public SqmUpdateStatementImpl ( SqmRoot entityFromElement ) { this . entityFromElement = entityFromElement ; }
johnaoahra80/hibernate-semantic-query | @ Override public SqmRoot getEntityFromElement ( ) { return entityFromElement ; }
johnaoahra80/hibernate-semantic-query | @ Override public SqmSetClause getSetClause ( ) { return setClause ; }
johnaoahra80/hibernate-semantic-query | @ Override public SqmWhereClause getWhereClause ( ) { return whereClause ; }
johnaoahra80/hibernate-semantic-query | @ Override public String toString ( ) { return String . format ( Locale . ROOT , " update ▁ % s ▁ % s ▁ % s " , entityFromElement , " [ no ▁ set ▁ clause ] " , whereClause ) ; }
johnaoahra80/hibernate-semantic-query | @ Override public < T > T accept ( SemanticQueryWalker < T > walker ) { return walker . visitUpdateStatement ( this ) ; }
StephanEwen/incubator-flink | @ Override protected TypeSerializer < Boolean > createSerializer ( ) { return new BooleanSerializer ( ) ; }
StephanEwen/incubator-flink | @ Override protected int getLength ( ) { return 1 ; }
StephanEwen/incubator-flink | @ Override protected Class < Boolean > getTypeClass ( ) { return Boolean . class ; }
StephanEwen/incubator-flink | @ Override protected Boolean [ ] getTestData ( ) { Random rnd = new Random ( 874597969123412341L ) ; return new Boolean [ ] { Boolean . valueOf ( true ) , Boolean . valueOf ( false ) , Boolean . valueOf ( rnd . nextBoolean ( ) ) , Boolean . valueOf ( rnd . nextBoolean ( ) ) , Boolean . valueOf ( rnd . nextBoolean ( ) ) } ; }
aws/aws-sdk-java | public AddApplicationOutputRequestProtocolMarshaller ( com . amazonaws . protocol . json . SdkJsonProtocolFactory protocolFactory ) { this . protocolFactory = protocolFactory ; }
aws/aws-sdk-java | public Request < AddApplicationOutputRequest > marshall ( AddApplicationOutputRequest addApplicationOutputRequest ) { if ( addApplicationOutputRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { final ProtocolRequestMarshaller < AddApplicationOutputRequest > protocolMarshaller = protocolFactory . createProtocolMarshaller ( SDK_OPERATION_BINDING , addApplicationOutputRequest ) ; protocolMarshaller . startMarshalling ( ) ; AddApplicationOutputRequestMarshaller . getInstance ( ) . marshall ( addApplicationOutputRequest , protocolMarshaller ) ; return protocolMarshaller . finishMarshalling ( ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
ninqing/tddl | @ Override protected Boolean computeInner ( Object [ ] args , ExecutionContext ec ) { Object arg = args [ 0 ] ; return arg == null ; }
ninqing/tddl | @ Override public String [ ] getFunctionNames ( ) { return new String [ ] { " IS ▁ NULL " } ; }
narfman0/freeboot | @ Override public void receive ( PlayerState message , Socket origin ) { for ( NetBeing netBeing : message . getPlayersList ( ) ) { UUID uuid = UUIDConvert . convert ( netBeing . getUuid ( ) ) ; if ( worldManager . getPlayer ( ) != null && uuid . equals ( worldManager . getPlayer ( ) . getUuid ( ) ) ) break ; Player remotePlayer = worldManager . getRemotePlayer ( uuid ) ; if ( remotePlayer == null ) { remotePlayer = new Player ( netBeing ) ; worldManager . getRemotePlayers ( ) . put ( remotePlayer . getUuid ( ) , remotePlayer ) ; if ( remotePlayer . getHp ( ) > 0 ) remotePlayer . respawn ( worldManager , netBeing . getPosX ( ) , netBeing . getPosY ( ) ) ; Log . log ( " GameplayScreen . receive " , " Received ▁ first ▁ player ▁ update : ▁ " + netBeing . getName ( ) ) ; } else if ( remotePlayer . getPosition ( ) != null ) remotePlayer . updateFromMessage ( worldManager , netBeing ) ; } }
narfman0/freeboot | @ Override public Class < ? extends Message > getSubscription ( ) { return PlayerState . class ; }
sekys/ivis | public DrawingJPanel ( Dimension size ) { this . size = size ; imageBuffer = new BufferedImage ( size . width , size . height , BufferedImage . TYPE_INT_ARGB ) ; graphics = imageBuffer . createGraphics ( ) ; }
sekys/ivis | public Dimension getPreferredSize ( ) { return size ; }
sekys/ivis | public void paintComponent ( Graphics graphic ) { super . paintComponent ( graphic ) ; ( ( Graphics2D ) graphic ) . drawImage ( imageBuffer , null , null ) ; }
sekys/ivis | public void fill ( int color ) { int x , y ; for ( x = 0 ; x < size . width ; x ++ ) { for ( y = 0 ; y < size . height ; y ++ ) { imageBuffer . setRGB ( x , y , color ) ; } } }
sekys/ivis | public void drawString ( String txt , Color color , float x , float y ) { graphics . setPaint ( color ) ; graphics . setFont ( new Font ( " Tahoma " , Font . BOLD , 12 ) ) ; graphics . drawString ( txt , ( int ) ( x * size . width ) , ( int ) ( y * size . height ) ) ; }
sekys/ivis | public void putPixel ( int x , int y , int rgb ) { imageBuffer . setRGB ( x , y , rgb ) ; }
sekys/ivis | public Graphics2D getGraphic ( ) { return graphics ; }
sekys/ivis | public void resize ( ) { throw new UnsupportedOperationException ( ) ; }
VivianLuwenHuangfu/processors | public Trie ( ) { root = new TrieNode ( ' ▁ ' , null ) ; sb = new StringBuilder ( ) ; }
VivianLuwenHuangfu/processors | public TrieNode addValue ( String value , TrieSymbolTable table , int code ) throws SymbolException { TrieNode node = root ; final char [ ] chars = value . toCharArray ( ) ; for ( int i = chars . length - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) { node = node . getOrAddChild ( true , chars [ i ] , table , code ) ; } else { node = node . getOrAddChild ( false , chars [ i ] , table , code ) ; } } return node ; }
VivianLuwenHuangfu/processors | public TrieNode addValue ( StringBuilder symbol , TrieSymbolTable table , int code ) throws SymbolException { TrieNode node = root ; for ( int i = symbol . length ( ) - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) { node = node . getOrAddChild ( true , symbol . charAt ( i ) , table , code ) ; } else { node = node . getOrAddChild ( false , symbol . charAt ( i ) , table , code ) ; } } return node ; }
VivianLuwenHuangfu/processors | public String getValue ( TrieNode node , TrieSymbolTable table ) { sb . setLength ( 0 ) ; TrieNode tmp = node ; while ( tmp != root ) { sb . append ( tmp . getCharacter ( ) ) ; tmp = tmp . getParent ( ) ; } return sb . toString ( ) ; }
VivianLuwenHuangfu/processors | public Integer getEntry ( String value , TrieSymbolTable table ) { TrieNode node = root ; final char [ ] chars = value . toCharArray ( ) ; int i = chars . length - 1 ; for ( ; i >= 0 && node != null ; i -- ) { node = node . getChild ( chars [ i ] ) ; } if ( i < 0 && node != null ) { return node . getEntry ( table ) ; } return null ; }
VivianLuwenHuangfu/processors | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; return ( ( root == null ) ? ( ( Trie ) obj ) . root == null : root . equals ( ( ( Trie ) obj ) . root ) ) ; }
VivianLuwenHuangfu/processors | public int hashCode ( ) { return 31 * 7 + ( null == root ? 0 : root . hashCode ( ) ) ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( properName == null ) ? 0 : properName . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Animal other = ( Animal ) obj ; if ( properName == null ) { if ( other . properName != null ) return false ; } else if ( ! properName . equals ( other . properName ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( animals == null ) ? 0 : animals . hashCode ( ) ) ; result = prime * result + ( ( largestAnimal == null ) ? 0 : largestAnimal . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Zoo other = ( Zoo ) obj ; if ( animals == null ) { if ( other . animals != null ) return false ; } else if ( ! animals . equals ( other . animals ) ) return false ; if ( largestAnimal == null ) { if ( other . largestAnimal != null ) return false ; } else if ( ! largestAnimal . equals ( other . largestAnimal ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + Float . floatToIntBits ( normalBodyTemperature ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Mammal other = ( Mammal ) obj ; if ( Float . floatToIntBits ( normalBodyTemperature ) != Float . floatToIntBits ( other . normalBodyTemperature ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someBearField == null ) ? 0 : someBearField . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Bear other = ( Bear ) obj ; if ( someBearField == null ) { if ( other . someBearField != null ) return false ; } else if ( ! someBearField . equals ( other . someBearField ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someTigerField == null ) ? 0 : someTigerField . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Tiger other = ( Tiger ) obj ; if ( someTigerField == null ) { if ( other . someTigerField != null ) return false ; } else if ( ! someTigerField . equals ( other . someTigerField ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someElephantField == null ) ? 0 : someElephantField . hashCode ( ) ) ; return result ; }
dyu/protostuff-1.0.x | public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Elephant other = ( Elephant ) obj ; if ( someElephantField == null ) { if ( other . someElephantField != null ) return false ; } else if ( ! someElephantField . equals ( other . someElephantField ) ) return false ; return true ; }
dyu/protostuff-1.0.x | public void testProtobuf ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo p = filledZoo ( ) ; byte [ ] data = ProtobufIOUtil . toByteArray ( p , schema , buf ( ) ) ; Zoo p2 = new Zoo ( ) ; ProtobufIOUtil . mergeFrom ( data , p2 , schema ) ; assertEquals ( p , p2 ) ; List < Zoo > list = new ArrayList < Zoo > ( ) ; list . add ( p ) ; list . add ( p2 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ProtobufIOUtil . writeListTo ( out , list , schema , buf ( ) ) ; byte [ ] listData = out . toByteArray ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( listData ) ; List < Zoo > parsedList = ProtobufIOUtil . parseListFrom ( in , schema ) ; assertEquals ( list , parsedList ) ; }
dyu/protostuff-1.0.x | public void testProtostuff ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo p = filledZoo ( ) ; byte [ ] data = ProtostuffIOUtil . toByteArray ( p , schema , buf ( ) ) ; Zoo p2 = new Zoo ( ) ; ProtostuffIOUtil . mergeFrom ( data , 0 , data . length , p2 , schema ) ; assertEquals ( p , p2 ) ; List < Zoo > list = new ArrayList < Zoo > ( ) ; list . add ( p ) ; list . add ( p2 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ProtostuffIOUtil . writeListTo ( out , list , schema , buf ( ) ) ; byte [ ] listData = out . toByteArray ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( listData ) ; List < Zoo > parsedList = ProtostuffIOUtil . parseListFrom ( in , schema ) ; assertEquals ( list , parsedList ) ; }
dyu/protostuff-1.0.x | public void testPipe ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Pipe . Schema < Zoo > pipeSchema = ( ( MappedSchema < Zoo > ) schema ) . pipeSchema ; Zoo p = filledZoo ( ) ; ProtostuffPipeTest . roundTrip ( p , schema , pipeSchema ) ; }
dyu/protostuff-1.0.x | public void testMerge ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; final String properName = " elephant " ; Elephant elephant = new Elephant ( ) ; elephant . someElephantField = " elephantField " ; elephant . normalBodyTemperature = 25f ; elephant . properName = properName ; Zoo zoo = new Zoo ( ) ; zoo . largestAnimal = elephant ; Elephant sickElephant = new Elephant ( ) ; sickElephant . normalBodyTemperature = 50f ; sickElephant . someElephantField = " sickElephantField " ; Zoo mergeZoo = new Zoo ( ) ; mergeZoo . largestAnimal = sickElephant ; byte [ ] data = ProtostuffIOUtil . toByteArray ( mergeZoo , schema , buf ( ) ) ; ProtostuffIOUtil . mergeFrom ( data , zoo , schema ) ; assertTrue ( zoo . largestAnimal == elephant ) ; assertTrue ( elephant . normalBodyTemperature == 50f ) ; assertEquals ( elephant . someElephantField , " sickElephantField " ) ; assertTrue ( properName == elephant . properName ) ; }
dyu/protostuff-1.0.x | public void testOverwrite ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo zoo = new Zoo ( ) ; zoo . largestAnimal = filledBear ( ) ; Zoo overwriteZoo = new Zoo ( ) ; overwriteZoo . largestAnimal = filledTiger ( ) ; byte [ ] data = ProtostuffIOUtil . toByteArray ( overwriteZoo , schema , buf ( ) ) ; ProtostuffIOUtil . mergeFrom ( data , zoo , schema ) ; assertTrue ( zoo . largestAnimal instanceof Tiger ) ; }
statsbiblioteket/summa | public FilterPump ( Configuration configuration ) throws IOException { classLog . trace ( " Constructing ▁ FilterPump ▁ with ▁ config ▁ class ▁ " + configuration . getClass ( ) ) ; chainName = configuration . getString ( Filter . CONF_FILTER_NAME , chainName ) ; classLog . trace ( " Creating ▁ chain ▁ log ▁ for ▁ chain : ▁ " + chainName ) ; log = LogFactory . getLog ( FilterPump . class . getName ( ) + " # " + chainName ) ; log . info ( " Constructing ▁ FilterPump ▁ for ▁ chain ▁ ' " + chainName + " ' " ) ; sequence = new FilterSequence ( configuration ) ; everyStatus = configuration . getInt ( CONF_STATUS_EVERY , DEFAULT_STATUS_EVERY ) ; log . debug ( " Constructed ▁ filter ▁ sequence " ) ; }
statsbiblioteket/summa | ) protected void runMethod ( ) { log . debug ( " Running ▁ FilterChain ▁ ' " + chainName + " ' " ) ; Profiler profiler = new Profiler ( ) ; profiler . setBpsSpan ( 1000 ) ; Payload pumped ; try { long startTime ; while ( getStatus ( ) == STATUS . running ) { startTime = System . nanoTime ( ) ; if ( ! sequence . hasNext ( ) ) { profiler . beat ( ) ; log . info ( String . format ( " Finished ▁ pumping ▁ ' % s ' ▁ % d ▁ times ▁ in ▁ % s , ▁ overall ▁ average ▁ speed ▁ was ▁ % s ▁ pumps / sec " , chainName , profiler . getBeats ( ) , profiler . getSpendTime ( ) , profiler . getBps ( false ) ) ) ; break ; } pumped = sequence . next ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " Pump ▁ received ▁ ▁ " + ( pumped . getRecord ( ) == null ? pumped : pumped . getRecord ( ) ) ) ; } profiler . beat ( ) ; logStatistics ( profiler , startTime , pumped ) ; } } catch ( Throwable t ) { String error = " Throwable ▁ caught ▁ running ▁ FilterPump " ; log . error ( error , t ) ; setError ( error , t ) ; } log . debug ( " Finished ▁ run ▁ with ▁ status ▁ " + getStatus ( ) ) ; if ( STATUS . error == getStatus ( ) ) { log . warn ( " The ▁ run ▁ was ▁ finished ▁ with ▁ error ▁ ' " + getErrorMessage ( ) , getErrorCause ( ) ) ; } else { log . debug ( " No ▁ error ▁ in ▁ run , ▁ calling ▁ close ( true ) " ) ; } close ( true ) ; }
statsbiblioteket/summa | private void logStatistics ( Profiler profiler , long startTime , Payload last ) { if ( ! ( log . isTraceEnabled ( ) || ( log . isDebugEnabled ( ) && profiler . getBeats ( ) % DEBUG_FEEDBACK == 0 ) || ( log . isInfoEnabled ( ) && profiler . getBeats ( ) % everyStatus == 0 ) ) ) { return ; } String ms = Double . toString ( ( System . nanoTime ( ) - startTime ) / 1000000.0 ) ; String currentAverage = profiler . getBps ( true ) < 10 ? Double . toString ( profiler . getBps ( true ) ) : Integer . toString ( ( int ) profiler . getBps ( true ) ) ; String overallAverage = profiler . getBps ( false ) < 10 ? Double . toString ( profiler . getBps ( false ) ) : Integer . toString ( ( int ) profiler . getBps ( false ) ) ; String message = String . format ( " % d ▁ pumps ▁ performed ▁ in ▁ % s , ▁ average ▁ speed ▁ for ▁ the ▁ last ▁ % d ▁ pumps ▁ was ▁ % s ▁ pumps / sec , ▁ overall ▁ average ▁ was ▁ " + " % s ▁ pumps / sec , ▁ last ▁ pump ▁ took ▁ % s ▁ ms ▁ and ▁ delivered ▁ % s " , profiler . getBeats ( ) , profiler . getSpendTime ( ) , profiler . getBpsSpan ( ) , currentAverage , overallAverage , ms , last == null ? " no ▁ Payload " : last . getId ( ) ) ; if ( profiler . getBeats ( ) % everyStatus == 0 ) { log . info ( message ) ; } else if ( profiler . getBeats ( ) % DEBUG_FEEDBACK == 0 ) { log . debug ( message ) ; } else { log . trace ( message ) ; } }
statsbiblioteket/summa | @ Override public void stop ( ) { log . info ( " Stopping ▁ filter ▁ pump ▁ " + getChainName ( ) ) ; super . stop ( ) ; sequence . close ( true ) ; log . info ( String . format ( " Filter ▁ pump ▁ % s ▁ stopped " , getChainName ( ) ) ) ; }
statsbiblioteket/summa | private void close ( boolean success ) { sequence . close ( success ) ; }
statsbiblioteket/summa | public String getChainName ( ) { return chainName ; }
statsbiblioteket/summa | @ Override public String toString ( ) { StringWriter sw = new StringWriter ( 500 ) ; sw . append ( getStatus ( ) . toString ( ) ) . append ( " : ▁ " ) ; sw . append ( sequence . toString ( ) ) ; sw . append ( " ▁ pump " ) ; return sw . toString ( ) ; }
statsbiblioteket/summa | public List < Filter > getFilters ( ) { return sequence . getFilters ( ) ; }
betfair/cougar | @ Test public void doTest ( ) throws Exception { CougarManager cougarManager1 = CougarManager . getInstance ( ) ; HttpCallBean httpCallBeanBaseline = cougarManager1 . getNewHttpCallBean ( ) ; CougarManager cougarManagerBaseline = cougarManager1 ; httpCallBeanBaseline . setServiceName ( " baseline " , " cougarBaseline " ) ; httpCallBeanBaseline . setVersion ( " v2" ) ; CougarManager cougarManager2 = CougarManager . getInstance ( ) ; HttpCallBean getNewHttpCallBean2 = cougarManager2 . getNewHttpCallBean ( "87.248.113.14" ) ; cougarManager2 = cougarManager2 ; cougarManager2 . setCougarFaultControllerJMXMBeanAttrbiute ( " DetailedFaults " , " false " ) ; getNewHttpCallBean2 . setOperationName ( " i32SimpleTypeOperation " ) ; getNewHttpCallBean2 . setServiceName ( " baseline " , " cougarBaseline " ) ; getNewHttpCallBean2 . setVersion ( " v2" ) ; Map map3 = new HashMap ( ) ; map3 . put ( " HeaderParam " , " " ) ; getNewHttpCallBean2 . setHeaderParams ( map3 ) ; Map map4 = new HashMap ( ) ; map4 . put ( " queryParam " , "43523434" ) ; getNewHttpCallBean2 . setQueryParams ( map4 ) ; getNewHttpCallBean2 . setRestPostQueryObjects ( DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . parse ( new ByteArrayInputStream ( " < message > < bodyParameter > - 50 < / bodyParameter > < / message > " . getBytes ( ) ) ) ) ; Timestamp getTimeAsTimeStamp11 = new Timestamp ( System . currentTimeMillis ( ) ) ; cougarManager2 . makeRestCougarHTTPCalls ( getNewHttpCallBean2 ) ; XMLHelpers xMLHelpers6 = new XMLHelpers ( ) ; Document createAsDocument13 = xMLHelpers6 . getXMLObjectFromString ( " < fault > < faultcode > Client < / faultcode > < faultstring > DSC - 0044 < / faultstring > < detail / > < / fault > " ) ; Map < CougarMessageProtocolRequestTypeEnum , Object > convertResponseToRestTypes14 = cougarManager2 . convertResponseToRestTypes ( createAsDocument13 , getNewHttpCallBean2 ) ; HttpResponseBean response7 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTXMLXML ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTXML ) , response7 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response7 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response7 . getHttpStatusText ( ) ) ; HttpResponseBean response8 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONJSON ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTJSON ) , response8 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response8 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response8 . getHttpStatusText ( ) ) ; HttpResponseBean response9 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTXMLJSON ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTJSON ) , response9 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response9 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response9 . getHttpStatusText ( ) ) ; HttpResponseBean response10 = getNewHttpCallBean2 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONXML ) ; AssertionUtils . multiAssertEquals ( convertResponseToRestTypes14 . get ( CougarMessageProtocolRequestTypeEnum . RESTXML ) , response10 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response10 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response10 . getHttpStatusText ( ) ) ; }
Bonsanto/db-component | public String getSentence ( ) { return sentence ; }
Bonsanto/db-component | public void setSentence ( String sentence ) { this . sentence = sentence ; cleanQuery ( ) ; }
Bonsanto/db-component | private void cleanQuery ( ) { this . sentence = this . sentence . replaceAll ( " \t + " , " ▁ " ) . replaceAll ( " \n + " , " ▁ " ) . replaceAll ( " ▁ + " , " ▁ " ) ; }
Bonsanto/db-component | public Query ( String sentence ) { this . sentence = sentence ; }
Bonsanto/db-component | public Query ( ) { }
yukare/jaguaribe | public void load ( String fileName ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder ; try { builder = factory . newDocumentBuilder ( ) ; Document doc ; try { doc = builder . parse ( fileName ) ; Element root = doc . getDocumentElement ( ) ; if ( root != null ) { this . setRoot ( new XMLItem ( ) ) ; this . rootItem . setName ( root . getTagName ( ) ) ; this . rootItem . setText ( root . getTextContent ( ) ) ; NodeList list = root . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { if ( ! list . item ( i ) . getNodeName ( ) . equals ( " # text " ) ) { this . parseChild ( list . item ( i ) , this . rootItem ) ; } } } } catch ( SAXException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , " There ▁ was ▁ an ▁ error ▁ while ▁ parsing ▁ the ▁ file . " , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( ParserConfigurationException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
yukare/jaguaribe | private void parseChild ( Node node , XMLItem parent ) { XMLItem item = new XMLItem ( ) ; item . setName ( node . getNodeName ( ) ) ; item . setText ( node . getTextContent ( ) ) ; NamedNodeMap attributes = node . getAttributes ( ) ; if ( attributes != null ) { for ( int a = 0 ; a < attributes . getLength ( ) ; a ++ ) { Node attr = attributes . item ( a ) ; item . addAttr ( attr . getNodeName ( ) , attr . getTextContent ( ) ) ; } } parent . addChild ( item ) ; NodeList subNodes = node . getChildNodes ( ) ; for ( int j = 0 ; j < subNodes . getLength ( ) ; j ++ ) { Node child = subNodes . item ( j ) ; if ( ! child . getNodeName ( ) . equals ( " # text " ) ) { this . parseChild ( child , item ) ; } } }
yukare/jaguaribe | public XMLItem getRoot ( ) { return this . rootItem ; }
yukare/jaguaribe | private void saveAddChild ( XMLItem item , Element parent , Document doc ) { Element el = doc . createElement ( item . getName ( ) ) ; el . setTextContent ( item . getText ( ) ) ; ArrayList < XMLAttr > attr = item . getAllAttr ( ) ; for ( XMLAttr entry : attr ) { el . setAttribute ( entry . getKey ( ) , entry . getValue ( ) ) ; } parent . appendChild ( el ) ; for ( XMLItem it : item . getChildren ( ) ) { this . saveAddChild ( it , el , doc ) ; } }
yukare/jaguaribe | public void save ( String filename ) { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder ; try { builder = factory . newDocumentBuilder ( ) ; Document doc = builder . newDocument ( ) ; Element root = doc . createElement ( this . rootItem . getName ( ) ) ; ArrayList < XMLAttr > attr = this . rootItem . getAllAttr ( ) ; for ( XMLAttr entry : attr ) { root . setAttribute ( entry . getKey ( ) , entry . getValue ( ) ) ; } doc . appendChild ( root ) ; for ( XMLItem item : this . rootItem . getChildren ( ) ) { this . saveAddChild ( item , root , doc ) ; } DOMSource source = new DOMSource ( doc ) ; PrintStream ps ; try { ps = new PrintStream ( filename ) ; StreamResult result = new StreamResult ( ps ) ; TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer ; try { transformer = transformerFactory . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . INDENT , " yes " ) ; transformer . setOutputProperty ( " { http : // xml . apache . org / xslt } indent - amount " , "2" ) ; try { transformer . transform ( source , result ) ; } catch ( TransformerException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( TransformerConfigurationException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } catch ( ParserConfigurationException ex ) { Logger . getLogger ( XMLTree . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
yukare/jaguaribe | public void setRoot ( XMLItem root ) { this . rootItem = root ; }
Instagram/cassandra | public SerializationHelper ( TableMetadata metadata , int version , Flag flag , ColumnFilter columnsToFetch ) { this . flag = flag ; this . version = version ; this . columnsToFetch = columnsToFetch ; this . droppedColumns = metadata . droppedColumns ; this . hasDroppedColumns = droppedColumns . size ( ) > 0 ; }
Instagram/cassandra | public SerializationHelper ( TableMetadata metadata , int version , Flag flag ) { this ( metadata , version , flag , null ) ; }
Instagram/cassandra | public boolean includes ( ColumnMetadata column ) { return columnsToFetch == null || columnsToFetch . fetches ( column ) ; }
Instagram/cassandra | public boolean includes ( Cell cell , LivenessInfo rowLiveness ) { if ( columnsToFetch == null ) return true ; ColumnMetadata column = cell . column ( ) ; if ( column . isComplex ( ) ) { if ( ! includes ( cell . path ( ) ) ) return false ; return ! canSkipValue ( cell . path ( ) ) || cell . timestamp ( ) >= rowLiveness . timestamp ( ) ; } else { return columnsToFetch . fetchedColumnIsQueried ( column ) || cell . timestamp ( ) >= rowLiveness . timestamp ( ) ; } }
Instagram/cassandra | public boolean includes ( CellPath path ) { return path == null || tester == null || tester . fetches ( path ) ; }
Instagram/cassandra | public boolean canSkipValue ( ColumnMetadata column ) { return columnsToFetch != null && ! columnsToFetch . fetchedColumnIsQueried ( column ) ; }
Instagram/cassandra | public boolean canSkipValue ( CellPath path ) { return path != null && tester != null && ! tester . fetchedCellIsQueried ( path ) ; }
Instagram/cassandra | public void startOfComplexColumn ( ColumnMetadata column ) { this . tester = columnsToFetch == null ? null : columnsToFetch . newTester ( column ) ; this . currentDroppedComplex = droppedColumns . get ( column . name . bytes ) ; }
Instagram/cassandra | public void endOfComplexColumn ( ) { this . tester = null ; }
Instagram/cassandra | public boolean isDropped ( Cell cell , boolean isComplex ) { if ( ! hasDroppedColumns ) return false ; DroppedColumn dropped = isComplex ? currentDroppedComplex : droppedColumns . get ( cell . column ( ) . name . bytes ) ; return dropped != null && cell . timestamp ( ) <= dropped . droppedTime ; }
Instagram/cassandra | public boolean isDroppedComplexDeletion ( DeletionTime complexDeletion ) { return currentDroppedComplex != null && complexDeletion . markedForDeleteAt ( ) <= currentDroppedComplex . droppedTime ; }
Instagram/cassandra | public ByteBuffer maybeClearCounterValue ( ByteBuffer value ) { return flag == Flag . FROM_REMOTE || ( flag == Flag . LOCAL && CounterContext . instance ( ) . shouldClearLocal ( value ) ) ? CounterContext . instance ( ) . clearAllLocal ( value ) : value ; }
CandleCandle/camel | public HttpServerInitializerFactory ( ) { }
CandleCandle/camel | public HttpServerInitializerFactory ( NettyHttpConsumer nettyConsumer ) { this . consumer = nettyConsumer ; this . configuration = nettyConsumer . getConfiguration ( ) ; try { this . sslContext = createSSLContext ( consumer . getContext ( ) , consumer . getConfiguration ( ) ) ; } catch ( Exception e ) { throw ObjectHelper . wrapRuntimeCamelException ( e ) ; } if ( sslContext != null ) { LOG . info ( " Created ▁ SslContext ▁ { } " , sslContext ) ; } }
CandleCandle/camel | @ Override public ServerInitializerFactory createPipelineFactory ( NettyConsumer nettyConsumer ) { return new HttpServerInitializerFactory ( ( NettyHttpConsumer ) nettyConsumer ) ; }
CandleCandle/camel | @ Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; SslHandler sslHandler = configureServerSSLOnDemand ( ) ; if ( sslHandler != null ) { LOG . debug ( " Server ▁ SSL ▁ handler ▁ configured ▁ and ▁ added ▁ as ▁ an ▁ interceptor ▁ against ▁ the ▁ ChannelPipeline : ▁ { } " , sslHandler ) ; pipeline . addLast ( " ssl " , sslHandler ) ; } pipeline . addLast ( " decoder " , new HttpRequestDecoder ( 4096 , configuration . getMaxHeaderSize ( ) , 8192 ) ) ; List < ChannelHandler > decoders = consumer . getConfiguration ( ) . getDecoders ( ) ; for ( int x = 0 ; x < decoders . size ( ) ; x ++ ) { ChannelHandler decoder = decoders . get ( x ) ; if ( decoder instanceof ChannelHandlerFactory ) { decoder = ( ( ChannelHandlerFactory ) decoder ) . newChannelHandler ( ) ; } pipeline . addLast ( " decoder - " + x , decoder ) ; } pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( configuration . getChunkedMaxContentLength ( ) ) ) ; pipeline . addLast ( " encoder " , new HttpResponseEncoder ( ) ) ; List < ChannelHandler > encoders = consumer . getConfiguration ( ) . getEncoders ( ) ; for ( int x = 0 ; x < encoders . size ( ) ; x ++ ) { ChannelHandler encoder = encoders . get ( x ) ; if ( encoder instanceof ChannelHandlerFactory ) { encoder = ( ( ChannelHandlerFactory ) encoder ) . newChannelHandler ( ) ; } pipeline . addLast ( " encoder - " + x , encoder ) ; } if ( supportCompressed ( ) ) { pipeline . addLast ( " deflater " , new HttpContentCompressor ( ) ) ; } int port = consumer . getConfiguration ( ) . getPort ( ) ; ChannelHandler handler = consumer . getEndpoint ( ) . getComponent ( ) . getMultiplexChannelHandler ( port ) . getChannelHandler ( ) ; if ( consumer . getConfiguration ( ) . isUsingExecutorService ( ) ) { EventExecutorGroup applicationExecutor = consumer . getEndpoint ( ) . getComponent ( ) . getExecutorService ( ) ; pipeline . addLast ( applicationExecutor , " handler " , handler ) ; } else { pipeline . addLast ( " handler " , handler ) ; } }
CandleCandle/camel | private SSLContext createSSLContext ( CamelContext camelContext , NettyServerBootstrapConfiguration configuration ) throws Exception { if ( ! configuration . isSsl ( ) ) { return null ; } SSLContext answer ; if ( configuration . getSslContextParameters ( ) != null ) { answer = configuration . getSslContextParameters ( ) . createSSLContext ( ) ; } else { if ( configuration . getKeyStoreFile ( ) == null && configuration . getKeyStoreResource ( ) == null ) { LOG . debug ( " keystorefile ▁ is ▁ null " ) ; } if ( configuration . getTrustStoreFile ( ) == null && configuration . getTrustStoreResource ( ) == null ) { LOG . debug ( " truststorefile ▁ is ▁ null " ) ; } if ( configuration . getPassphrase ( ) . toCharArray ( ) == null ) { LOG . debug ( " passphrase ▁ is ▁ null " ) ; } SSLEngineFactory sslEngineFactory ; if ( configuration . getKeyStoreFile ( ) != null || configuration . getTrustStoreFile ( ) != null ) { sslEngineFactory = new SSLEngineFactory ( ) ; answer = sslEngineFactory . createSSLContext ( camelContext . getClassResolver ( ) , configuration . getKeyStoreFormat ( ) , configuration . getSecurityProvider ( ) , " file : " + configuration . getKeyStoreFile ( ) . getPath ( ) , " file : " + configuration . getTrustStoreFile ( ) . getPath ( ) , configuration . getPassphrase ( ) . toCharArray ( ) ) ; } else { sslEngineFactory = new SSLEngineFactory ( ) ; answer = sslEngineFactory . createSSLContext ( camelContext . getClassResolver ( ) , configuration . getKeyStoreFormat ( ) , configuration . getSecurityProvider ( ) , configuration . getKeyStoreResource ( ) , configuration . getTrustStoreResource ( ) , configuration . getPassphrase ( ) . toCharArray ( ) ) ; } } return answer ; }
CandleCandle/camel | private SslHandler configureServerSSLOnDemand ( ) throws Exception { if ( ! consumer . getConfiguration ( ) . isSsl ( ) ) { return null ; } if ( consumer . getConfiguration ( ) . getSslHandler ( ) != null ) { return consumer . getConfiguration ( ) . getSslHandler ( ) ; } else if ( sslContext != null ) { SSLEngine engine = sslContext . createSSLEngine ( ) ; engine . setUseClientMode ( false ) ; engine . setNeedClientAuth ( consumer . getConfiguration ( ) . isNeedClientAuth ( ) ) ; if ( consumer . getConfiguration ( ) . getSslContextParameters ( ) == null ) { engine . setEnabledProtocols ( consumer . getConfiguration ( ) . getEnabledProtocols ( ) . split ( " , " ) ) ; } return new SslHandler ( engine ) ; } return null ; }
CandleCandle/camel | private boolean supportCompressed ( ) { return consumer . getEndpoint ( ) . getConfiguration ( ) . isCompression ( ) ; }
CEPFU/importer | public YQLRunner ( ) { httpClient = HttpClientBuilder . create ( ) . build ( ) ; }
CEPFU/importer | public JSONObject getYQLResponseJSON ( String query ) throws IOException { JSONObject jsonResponse = new JSONObject ( getYQLResponseString ( query ) ) ; return jsonResponse . getJSONObject ( " query " ) . getJSONObject ( " results " ) ; }
CEPFU/importer | public String getYQLResponseString ( String query ) throws IOException { HttpGet getRequest = new HttpGet ( prepareURL ( query ) ) ; getRequest . addHeader ( " accept " , " application / json " ) ; HttpResponse response = httpClient . execute ( getRequest ) ; String output = " " ; BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String tmp = null ; while ( ( tmp = bufferedReader . readLine ( ) ) != null ) { output += tmp ; } return output ; }
CEPFU/importer | private String prepareURL ( String query ) throws UnsupportedEncodingException { return BASE_URL + QUERY_PARAMETER + URLEncoder . encode ( query , " UTF - 8" ) + OUTPUT_FORMAT ; }
rohit5ram/carjoin | private TripShareDAO ( Context context ) { this . context = context ; this . dbHelper = DatabaseHelper . getInstance ( context ) ; }
rohit5ram/carjoin | public synchronized Cursor getTripShareCursor ( ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , TripShare . FIELDS , null , null , null , null , null , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
rohit5ram/carjoin | public synchronized Cursor getTripShareById ( String id ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , TripShare . FIELDS , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { id } , null , null , null , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
rohit5ram/carjoin | public synchronized boolean putTripShare ( final TripShare tripShare ) { boolean success = false ; int result = 0 ; try { final SQLiteDatabase db = dbHelper . getWritableDatabase ( ) ; if ( tripShare . id != null ) { result += db . update ( TripShare . TABLE_NAME , tripShare . getContent ( ) , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { tripShare . id } ) ; } if ( result > 0 ) { success = true ; } else { final long rowId = db . insert ( TripShare . TABLE_NAME , null , tripShare . getContent ( ) ) ; if ( rowId > - 1 ) { success = true ; } } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return success ; }
rohit5ram/carjoin | public synchronized String getTripShareId ( ) { String tripShareId = " " ; Cursor tripShareCursor = getTripShareCursor ( ) ; try { if ( tripShareCursor != null && tripShareCursor . moveToLast ( ) ) { TripShare tripShare = new TripShare ( tripShareCursor ) ; tripShareId = tripShare . id ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } finally { try { if ( tripShareCursor != null ) { tripShareCursor . close ( ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } } return tripShareId ; }
rohit5ram/carjoin | public synchronized TripShare getTripShare ( ) { Cursor tripShareCursor = getTripShareCursor ( ) ; TripShare tripShare = null ; try { if ( tripShareCursor != null && tripShareCursor . moveToLast ( ) ) { tripShare = new TripShare ( tripShareCursor ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } finally { try { if ( tripShareCursor != null ) { tripShareCursor . close ( ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } } return tripShare ; }
rohit5ram/carjoin | public synchronized boolean deleteTripShare ( TripShare tripShare ) { int result = - 1 ; try { final SQLiteDatabase db = dbHelper . getWritableDatabase ( ) ; result = db . delete ( TripShare . TABLE_NAME , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { String . valueOf ( tripShare . id ) } ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } boolean success = false ; if ( result > 0 ) { success = true ; } return success ; }
rohit5ram/carjoin | public synchronized Cursor getTripShare ( String [ ] projection , String selection , String [ ] selectionArgs , String sortOrder ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , projection , selection , selectionArgs , null , null , sortOrder , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
0359xiaodong/elasticsearch | @ Test public void testBytesAndNumericRepresentation ( ) throws Exception { IndexWriter writer = new IndexWriter ( new RAMDirectory ( ) , new IndexWriterConfig ( Lucene . VERSION , Lucene . STANDARD_ANALYZER ) ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " properties " ) . startObject ( " field1" ) . field ( " type " , " integer " ) . field ( " store " , " yes " ) . endObject ( ) . startObject ( " field2" ) . field ( " type " , " float " ) . field ( " store " , " yes " ) . endObject ( ) . startObject ( " field3" ) . field ( " type " , " long " ) . field ( " store " , " yes " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = createIndex ( " test " ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = mapper . parse ( " type " , "1" , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( " field1" , 1 ) . field ( " field2" , 1.1 ) . startArray ( " field3" ) . value ( 1 ) . value ( 2 ) . value ( 3 ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; writer . addDocument ( doc . rootDoc ( ) , doc . analyzer ( ) ) ; FieldType fieldType = new FieldType ( ) ; fieldType . setStored ( true ) ; fieldType . setNumericType ( FieldType . NumericType . INT ) ; Document doc2 = new Document ( ) ; doc2 . add ( new StoredField ( " field1" , new BytesRef ( Numbers . intToBytes ( 1 ) ) ) ) ; doc2 . add ( new StoredField ( " field2" , new BytesRef ( Numbers . floatToBytes ( 1.1f ) ) ) ) ; doc2 . add ( new StoredField ( " field3" , new BytesRef ( Numbers . longToBytes ( 1l ) ) ) ) ; doc2 . add ( new StoredField ( " field3" , new BytesRef ( Numbers . longToBytes ( 2l ) ) ) ) ; doc2 . add ( new StoredField ( " field3" , new BytesRef ( Numbers . longToBytes ( 3l ) ) ) ) ; writer . addDocument ( doc2 ) ; DirectoryReader reader = DirectoryReader . open ( writer , true ) ; IndexSearcher searcher = new IndexSearcher ( reader ) ; Set < String > fields = new HashSet < > ( Arrays . asList ( " field1" , " field2" , " field3" ) ) ; CustomFieldsVisitor fieldsVisitor = new CustomFieldsVisitor ( fields , false ) ; searcher . doc ( 0 , fieldsVisitor ) ; fieldsVisitor . postProcess ( mapper ) ; assertThat ( fieldsVisitor . fields ( ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field1" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Integer ) fieldsVisitor . fields ( ) . get ( " field1" ) . get ( 0 ) , equalTo ( 1 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field2" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Float ) fieldsVisitor . fields ( ) . get ( " field2" ) . get ( 0 ) , equalTo ( 1.1f ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field3" ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 0 ) , equalTo ( 1l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 1 ) , equalTo ( 2l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 2 ) , equalTo ( 3l ) ) ; fieldsVisitor . reset ( ) ; searcher . doc ( 1 , fieldsVisitor ) ; fieldsVisitor . postProcess ( mapper ) ; assertThat ( fieldsVisitor . fields ( ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field1" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Integer ) fieldsVisitor . fields ( ) . get ( " field1" ) . get ( 0 ) , equalTo ( 1 ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field2" ) . size ( ) , equalTo ( 1 ) ) ; assertThat ( ( Float ) fieldsVisitor . fields ( ) . get ( " field2" ) . get ( 0 ) , equalTo ( 1.1f ) ) ; assertThat ( fieldsVisitor . fields ( ) . get ( " field3" ) . size ( ) , equalTo ( 3 ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 0 ) , equalTo ( 1l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 1 ) , equalTo ( 2l ) ) ; assertThat ( ( Long ) fieldsVisitor . fields ( ) . get ( " field3" ) . get ( 2 ) , equalTo ( 3l ) ) ; reader . close ( ) ; writer . close ( ) ; }
Regger2011/java_pdt-34 | @ Test public void testGroupModification ( ) { app . getNavigationHelper ( ) . gotoGroupsPage ( ) ; if ( ! app . getGroupHelper ( ) . isThereAGroup ( ) ) { app . getGroupHelper ( ) . createGroup ( new GroupData ( " test " , null , null ) ) ; } app . getNavigationHelper ( ) . selection ( ) ; app . getGroupHelper ( ) . initGroupModification ( ) ; app . getGroupHelper ( ) . fillGroupForm ( new GroupData ( " tEsT1" , " tEsT2" , " tEsT3" ) ) ; app . getGroupHelper ( ) . submitUpdateGroupModification ( ) ; app . getGroupHelper ( ) . returnToGroupPage ( ) ; }
VegardT/GlycanSearcherVT | public GraphOutputSearch ( ) { }
VegardT/GlycanSearcherVT | public void GraphAlgorithm4 ( DirectedGraph < String , Graph . GlycoEdge > testGraph , ArrayList < String > startArray , double largestMass ) throws IOException { ArrayList < Set < GlycoEdge > > edgesToRemove = new ArrayList ( ) ; GlycanSearcherUtilities utilities = new GlycanSearcherUtilities ( ) ; Double max = null ; Set < String > vertexSet = testGraph . vertexSet ( ) ; Integer size = 1 ; ArrayList < String > vertexesToRemove = new ArrayList ( ) ; while ( size != 0 ) { for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Xylose " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Fucose " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Neu5Ac " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexSet ) { String [ ] words = utilities . GetNames ( s ) ; for ( int i = 0 ; i < words . length ; i = i + 1 ) { String check = words [ i ] ; if ( " Neu5Ac - H2O | " . equals ( check ) ) { if ( words . length < 1 ) { if ( words [ i ] . equals ( words [ i + 1 ] ) ) { vertexesToRemove . add ( s ) ; } } else { } } } } for ( String s : vertexesToRemove ) { testGraph . removeVertex ( s ) ; } size = vertexesToRemove . size ( ) ; vertexesToRemove . clear ( ) ; } count = count + 1 ; System . out . println ( " THIS ▁ IS ▁ GRAPH ▁ NUMBER ▁ " + count ) ; graphs . add ( testGraph ) ; }
VegardT/GlycanSearcherVT | public ArrayList < DirectedGraph < String , Graph . GlycoEdge > > GetGlycanGraph ( ) { return graphs ; }
VegardT/GlycanSearcherVT | public ArrayList < String > GetGlycanCombination ( ) { return null ; }
bclozel/spring-boot | @ Test public void fromRestTemplateBuilder ( ) { RestTemplateBuilder builder = mock ( RestTemplateBuilder . class ) ; RestTemplate delegate = new RestTemplate ( ) ; given ( builder . build ( ) ) . willReturn ( delegate ) ; assertThat ( new TestRestTemplate ( builder ) . getRestTemplate ( ) ) . isEqualTo ( delegate ) ; }
bclozel/spring-boot | @ Test public void simple ( ) { assertThat ( new TestRestTemplate ( ) . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( HttpComponentsClientHttpRequestFactory . class ) ; }
bclozel/spring-boot | @ Test public void doNotReplaceCustomRequestFactory ( ) { RestTemplateBuilder builder = new RestTemplateBuilder ( ) . requestFactory ( OkHttp3ClientHttpRequestFactory . class ) ; TestRestTemplate testRestTemplate = new TestRestTemplate ( builder ) ; assertThat ( testRestTemplate . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( OkHttp3ClientHttpRequestFactory . class ) ; }
bclozel/spring-boot | @ Test public void getRootUriRootUriSetViaRestTemplateBuilder ( ) { String rootUri = " http : // example . com " ; RestTemplateBuilder delegate = new RestTemplateBuilder ( ) . rootUri ( rootUri ) ; assertThat ( new TestRestTemplate ( delegate ) . getRootUri ( ) ) . isEqualTo ( rootUri ) ; }
bclozel/spring-boot | @ Test public void getRootUriRootUriSetViaLocalHostUriTemplateHandler ( ) { String rootUri = " http : // example . com " ; TestRestTemplate template = new TestRestTemplate ( ) ; LocalHostUriTemplateHandler templateHandler = mock ( LocalHostUriTemplateHandler . class ) ; given ( templateHandler . getRootUri ( ) ) . willReturn ( rootUri ) ; template . setUriTemplateHandler ( templateHandler ) ; assertThat ( template . getRootUri ( ) ) . isEqualTo ( rootUri ) ; }
bclozel/spring-boot | @ Test public void getRootUriRootUriNotSet ( ) { assertThat ( new TestRestTemplate ( ) . getRootUri ( ) ) . isEqualTo ( " " ) ; }
bclozel/spring-boot | @ Test public void authenticated ( ) { assertThat ( new TestRestTemplate ( " user " , " password " ) . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( InterceptingClientHttpRequestFactory . class ) ; }
bclozel/spring-boot | @ Test public void options ( ) { TestRestTemplate template = new TestRestTemplate ( HttpClientOption . ENABLE_REDIRECTS ) ; CustomHttpComponentsClientHttpRequestFactory factory = ( CustomHttpComponentsClientHttpRequestFactory ) template . getRestTemplate ( ) . getRequestFactory ( ) ; RequestConfig config = factory . getRequestConfig ( ) ; assertThat ( config . isRedirectsEnabled ( ) ) . isTrue ( ) ; }
bclozel/spring-boot | @ Test public void restOperationsAreAvailable ( ) { RestTemplate delegate = mock ( RestTemplate . class ) ; given ( delegate . getRequestFactory ( ) ) . willReturn ( new SimpleClientHttpRequestFactory ( ) ) ; given ( delegate . getUriTemplateHandler ( ) ) . willReturn ( new DefaultUriBuilderFactory ( ) ) ; RestTemplateBuilder builder = mock ( RestTemplateBuilder . class ) ; given ( builder . build ( ) ) . willReturn ( delegate ) ; TestRestTemplate restTemplate = new TestRestTemplate ( builder ) ; ReflectionUtils . doWithMethods ( RestOperations . class , new MethodCallback ( ) { @ Override public void doWith ( Method method ) throws IllegalArgumentException { Method equivalent = ReflectionUtils . findMethod ( TestRestTemplate . class , method . getName ( ) , method . getParameterTypes ( ) ) ; assertThat ( equivalent ) . as ( " Method ▁ % s ▁ not ▁ found " , method ) . isNotNull ( ) ; assertThat ( Modifier . isPublic ( equivalent . getModifiers ( ) ) ) . as ( " Method ▁ % s ▁ should ▁ have ▁ been ▁ public " , equivalent ) . isTrue ( ) ; try { equivalent . invoke ( restTemplate , mockArguments ( method . getParameterTypes ( ) ) ) ; } catch ( Exception ex ) { throw new IllegalStateException ( ex ) ; } } private Object [ ] mockArguments ( Class < ? > [ ] parameterTypes ) throws Exception { Object [ ] arguments = new Object [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { arguments [ i ] = mockArgument ( parameterTypes [ i ] ) ; } return arguments ; } @ SuppressWarnings ( " rawtypes " ) private Object mockArgument ( Class < ? > type ) throws Exception { if ( String . class . equals ( type ) ) { return " String " ; } if ( Object [ ] . class . equals ( type ) ) { return new Object [ 0 ] ; } if ( URI . class . equals ( type ) ) { return new URI ( " http : // localhost " ) ; } if ( HttpMethod . class . equals ( type ) ) { return HttpMethod . GET ; } if ( Class . class . equals ( type ) ) { return Object . class ; } if ( RequestEntity . class . equals ( type ) ) { return new RequestEntity ( HttpMethod . GET , new URI ( " http : // localhost " ) ) ; } return mock ( type ) ; } } , ( method ) -> Modifier . isPublic ( method . getModifiers ( ) ) ) ; }
bclozel/spring-boot | @ Test public void withBasicAuthAddsBasicAuthInterceptorWhenNotAlreadyPresent ( ) { TestRestTemplate originalTemplate = new TestRestTemplate ( ) ; TestRestTemplate basicAuthTemplate = originalTemplate . withBasicAuth ( " user " , " password " ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getMessageConverters ( ) ) . containsExactlyElementsOf ( originalTemplate . getRestTemplate ( ) . getMessageConverters ( ) ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( InterceptingClientHttpRequestFactory . class ) ; assertThat ( ReflectionTestUtils . getField ( basicAuthTemplate . getRestTemplate ( ) . getRequestFactory ( ) , " requestFactory " ) ) . isInstanceOf ( CustomHttpComponentsClientHttpRequestFactory . class ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getUriTemplateHandler ( ) ) . isSameAs ( originalTemplate . getRestTemplate ( ) . getUriTemplateHandler ( ) ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getInterceptors ( ) ) . hasSize ( 1 ) ; assertBasicAuthorizationInterceptorCredentials ( basicAuthTemplate , " user " , " password " ) ; }
bclozel/spring-boot | @ Test public void withBasicAuthReplacesBasicAuthInterceptorWhenAlreadyPresent ( ) { TestRestTemplate original = new TestRestTemplate ( " foo " , " bar " ) . withBasicAuth ( " replace " , " replace " ) ; TestRestTemplate basicAuth = original . withBasicAuth ( " user " , " password " ) ; assertThat ( basicAuth . getRestTemplate ( ) . getMessageConverters ( ) ) . containsExactlyElementsOf ( original . getRestTemplate ( ) . getMessageConverters ( ) ) ; assertThat ( basicAuth . getRestTemplate ( ) . getRequestFactory ( ) ) . isInstanceOf ( InterceptingClientHttpRequestFactory . class ) ; assertThat ( ReflectionTestUtils . getField ( basicAuth . getRestTemplate ( ) . getRequestFactory ( ) , " requestFactory " ) ) . isInstanceOf ( CustomHttpComponentsClientHttpRequestFactory . class ) ; assertThat ( basicAuth . getRestTemplate ( ) . getUriTemplateHandler ( ) ) . isSameAs ( original . getRestTemplate ( ) . getUriTemplateHandler ( ) ) ; assertThat ( basicAuth . getRestTemplate ( ) . getInterceptors ( ) ) . hasSize ( 1 ) ; assertBasicAuthorizationInterceptorCredentials ( basicAuth , " user " , " password " ) ; }
bclozel/spring-boot | @ Test public void withBasicAuthDoesNotResetErrorHandler ( ) { TestRestTemplate originalTemplate = new TestRestTemplate ( " foo " , " bar " ) ; ResponseErrorHandler errorHandler = mock ( ResponseErrorHandler . class ) ; originalTemplate . getRestTemplate ( ) . setErrorHandler ( errorHandler ) ; TestRestTemplate basicAuthTemplate = originalTemplate . withBasicAuth ( " user " , " password " ) ; assertThat ( basicAuthTemplate . getRestTemplate ( ) . getErrorHandler ( ) ) . isSameAs ( errorHandler ) ; }
bclozel/spring-boot | @ Test public void deleteHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( TestRestTemplate :: delete ) ; }
bclozel/spring-boot | @ Test public void exchangeWithRequestEntityAndClassHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( new RequestEntity < String > ( HttpMethod . GET , relativeUri ) , String . class ) ) ; }
bclozel/spring-boot | @ Test public void exchangeWithRequestEntityAndParameterizedTypeReferenceHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( new RequestEntity < String > ( HttpMethod . GET , relativeUri ) , new ParameterizedTypeReference < String > ( ) { } ) ) ; }
bclozel/spring-boot | @ Test public void exchangeHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( relativeUri , HttpMethod . GET , new HttpEntity < > ( new byte [ 0 ] ) , String . class ) ) ; }
bclozel/spring-boot | @ Test public void exchangeWithParameterizedTypeReferenceHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . exchange ( relativeUri , HttpMethod . GET , new HttpEntity < > ( new byte [ 0 ] ) , new ParameterizedTypeReference < String > ( ) { } ) ) ; }
bclozel/spring-boot | @ Test public void executeHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . execute ( relativeUri , HttpMethod . GET , null , null ) ) ; }
bclozel/spring-boot | @ Test public void getForEntityHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . getForEntity ( relativeUri , String . class ) ) ; }
bclozel/spring-boot | @ Test public void getForObjectHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . getForObject ( relativeUri , String . class ) ) ; }
bclozel/spring-boot | @ Test public void headForHeadersHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( TestRestTemplate :: headForHeaders ) ; }
bclozel/spring-boot | @ Test public void optionsForAllowHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( TestRestTemplate :: optionsForAllow ) ; }
bclozel/spring-boot | @ Test public void patchForObjectHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . patchForObject ( relativeUri , " hello " , String . class ) ) ; }
bclozel/spring-boot | @ Test public void postForEntityHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . postForEntity ( relativeUri , " hello " , String . class ) ) ; }
bclozel/spring-boot | @ Test public void postForLocationHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . postForLocation ( relativeUri , " hello " ) ) ; }
bclozel/spring-boot | @ Test public void postForObjectHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . postForObject ( relativeUri , " hello " , String . class ) ) ; }
bclozel/spring-boot | @ Test public void putHandlesRelativeUris ( ) throws IOException { verifyRelativeUriHandling ( ( testRestTemplate , relativeUri ) -> testRestTemplate . put ( relativeUri , " hello " ) ) ; }
bclozel/spring-boot | private void verifyRelativeUriHandling ( TestRestTemplateCallback callback ) throws IOException { ClientHttpRequestFactory requestFactory = mock ( ClientHttpRequestFactory . class ) ; MockClientHttpRequest request = new MockClientHttpRequest ( ) ; request . setResponse ( new MockClientHttpResponse ( new byte [ 0 ] , HttpStatus . OK ) ) ; URI absoluteUri = URI . create ( " http : // localhost : 8080 / a / b / c . txt ? param = % 7Bsomething % 7D " ) ; given ( requestFactory . createRequest ( eq ( absoluteUri ) , any ( HttpMethod . class ) ) ) . willReturn ( request ) ; TestRestTemplate template = new TestRestTemplate ( ) ; template . getRestTemplate ( ) . setRequestFactory ( requestFactory ) ; LocalHostUriTemplateHandler uriTemplateHandler = new LocalHostUriTemplateHandler ( new MockEnvironment ( ) ) ; template . setUriTemplateHandler ( uriTemplateHandler ) ; callback . doWithTestRestTemplate ( template , URI . create ( " / a / b / c . txt ? param = % 7Bsomething % 7D " ) ) ; verify ( requestFactory ) . createRequest ( eq ( absoluteUri ) , any ( HttpMethod . class ) ) ; }
bclozel/spring-boot | private void assertBasicAuthorizationInterceptorCredentials ( TestRestTemplate testRestTemplate , String username , String password ) { @ SuppressWarnings ( " unchecked " ) List < ClientHttpRequestInterceptor > requestFactoryInterceptors = ( List < ClientHttpRequestInterceptor > ) ReflectionTestUtils . getField ( testRestTemplate . getRestTemplate ( ) . getRequestFactory ( ) , " interceptors " ) ; assertThat ( requestFactoryInterceptors ) . hasSize ( 1 ) ; ClientHttpRequestInterceptor interceptor = requestFactoryInterceptors . get ( 0 ) ; assertThat ( interceptor ) . isInstanceOf ( BasicAuthorizationInterceptor . class ) ; assertThat ( ReflectionTestUtils . getField ( interceptor , " username " ) ) . isEqualTo ( username ) ; assertThat ( ReflectionTestUtils . getField ( interceptor , " password " ) ) . isEqualTo ( password ) ; }
jenshadlich/aws-sdk-java | public void setTopic ( String topic ) { this . topic = topic ; }
jenshadlich/aws-sdk-java | public String getTopic ( ) { return this . topic ; }
jenshadlich/aws-sdk-java | public PublishRequest withTopic ( String topic ) { setTopic ( topic ) ; return this ; }
jenshadlich/aws-sdk-java | public void setQos ( Integer qos ) { this . qos = qos ; }
jenshadlich/aws-sdk-java | public Integer getQos ( ) { return this . qos ; }
jenshadlich/aws-sdk-java | public PublishRequest withQos ( Integer qos ) { setQos ( qos ) ; return this ; }
jenshadlich/aws-sdk-java | public void setPayload ( java . nio . ByteBuffer payload ) { this . payload = payload ; }
jenshadlich/aws-sdk-java | public java . nio . ByteBuffer getPayload ( ) { return this . payload ; }
jenshadlich/aws-sdk-java | public PublishRequest withPayload ( java . nio . ByteBuffer payload ) { setPayload ( payload ) ; return this ; }
jenshadlich/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getTopic ( ) != null ) sb . append ( " Topic : ▁ " + getTopic ( ) + " , " ) ; if ( getQos ( ) != null ) sb . append ( " Qos : ▁ " + getQos ( ) + " , " ) ; if ( getPayload ( ) != null ) sb . append ( " Payload : ▁ " + getPayload ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
jenshadlich/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof PublishRequest == false ) return false ; PublishRequest other = ( PublishRequest ) obj ; if ( other . getTopic ( ) == null ^ this . getTopic ( ) == null ) return false ; if ( other . getTopic ( ) != null && other . getTopic ( ) . equals ( this . getTopic ( ) ) == false ) return false ; if ( other . getQos ( ) == null ^ this . getQos ( ) == null ) return false ; if ( other . getQos ( ) != null && other . getQos ( ) . equals ( this . getQos ( ) ) == false ) return false ; if ( other . getPayload ( ) == null ^ this . getPayload ( ) == null ) return false ; if ( other . getPayload ( ) != null && other . getPayload ( ) . equals ( this . getPayload ( ) ) == false ) return false ; return true ; }
jenshadlich/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getTopic ( ) == null ) ? 0 : getTopic ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getQos ( ) == null ) ? 0 : getQos ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getPayload ( ) == null ) ? 0 : getPayload ( ) . hashCode ( ) ) ; return hashCode ; }
jenshadlich/aws-sdk-java | @ Override public PublishRequest clone ( ) { return ( PublishRequest ) super . clone ( ) ; }
hastef88/carbon-business-messaging | if ( qpidPath != null ) { andesConfDir = Paths . get ( qpidPath ) . toString ( ) ; }
hastef88/carbon-business-messaging | if ( isSSLOnly ( ) ) { return " amqp : // " + userName + " : " + accessKey + " @ " + CARBON_CLIENT_ID + " / " + CARBON_VIRTUAL_HOST_NAME + " ? brokerlist = ' tcp : // " + CARBON_DEFAULT_HOSTNAME + " : " + CARBON_SSL_PORT + " ? ssl = ' true ' & trust _ store = ' " + trustStore . getStoreLocation ( ) + " ' & trust _ store _ password = ' " + trustStore . getPassword ( ) + " ' & key _ store = ' " + keyStore . getStoreLocation ( ) + " ' & key _ store _ password = ' " + trustStore . getPassword ( ) + " ' ' " ; }
alexsh/cw-omnibus | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; beamFragment = ( BeamFragment ) getSupportFragmentManager ( ) . findFragmentById ( android . R . id . content ) ; if ( beamFragment == null ) { beamFragment = new BeamFragment ( ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . add ( android . R . id . content , beamFragment ) . commit ( ) ; } adapter = NfcAdapter . getDefaultAdapter ( this ) ; findViewById ( android . R . id . content ) . post ( new Runnable ( ) { public void run ( ) { handleIntent ( getIntent ( ) ) ; } } ) ; }
alexsh/cw-omnibus | @ Override public void onNewIntent ( Intent i ) { handleIntent ( i ) ; }
alexsh/cw-omnibus | @ Override public void onStop ( ) { disablePush ( ) ; super . onStop ( ) ; }
alexsh/cw-omnibus | void enablePush ( ) { adapter . setNdefPushMessageCallback ( this , this ) ; }
alexsh/cw-omnibus | void disablePush ( ) { adapter . setNdefPushMessageCallback ( null , this ) ; }
alexsh/cw-omnibus | boolean hasNFC ( ) { return ( adapter != null ) ; }
alexsh/cw-omnibus | private void handleIntent ( Intent i ) { if ( NfcAdapter . ACTION_NDEF_DISCOVERED . equals ( i . getAction ( ) ) ) { Parcelable [ ] rawMsgs = i . getParcelableArrayExtra ( NfcAdapter . EXTRA_NDEF_MESSAGES ) ; NdefMessage msg = ( NdefMessage ) rawMsgs [ 0 ] ; String url = new String ( msg . getRecords ( ) [ 0 ] . getPayload ( ) ) ; beamFragment . loadUrl ( url ) ; } }
alexsh/cw-omnibus | @ Override public NdefMessage createNdefMessage ( NfcEvent arg0 ) { NdefRecord uriRecord = new NdefRecord ( NdefRecord . TNF_MIME_MEDIA , MIME_TYPE . getBytes ( Charset . forName ( " US - ASCII " ) ) , new byte [ 0 ] , beamFragment . getUrl ( ) . getBytes ( Charset . forName ( " US - ASCII " ) ) ) ; NdefMessage msg = new NdefMessage ( new NdefRecord [ ] { uriRecord , NdefRecord . createApplicationRecord ( " com . commonsware . android . webbeam " ) } ) ; return ( msg ) ; }
OnePaaS/aws-sdk-java | public void setAssociationDescription ( AssociationDescription associationDescription ) { this . associationDescription = associationDescription ; }
OnePaaS/aws-sdk-java | public AssociationDescription getAssociationDescription ( ) { return this . associationDescription ; }
OnePaaS/aws-sdk-java | public UpdateAssociationStatusResult withAssociationDescription ( AssociationDescription associationDescription ) { setAssociationDescription ( associationDescription ) ; return this ; }
OnePaaS/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getAssociationDescription ( ) != null ) sb . append ( " AssociationDescription : ▁ " + getAssociationDescription ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
OnePaaS/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof UpdateAssociationStatusResult == false ) return false ; UpdateAssociationStatusResult other = ( UpdateAssociationStatusResult ) obj ; if ( other . getAssociationDescription ( ) == null ^ this . getAssociationDescription ( ) == null ) return false ; if ( other . getAssociationDescription ( ) != null && other . getAssociationDescription ( ) . equals ( this . getAssociationDescription ( ) ) == false ) return false ; return true ; }
OnePaaS/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getAssociationDescription ( ) == null ) ? 0 : getAssociationDescription ( ) . hashCode ( ) ) ; return hashCode ; }
OnePaaS/aws-sdk-java | @ Override public UpdateAssociationStatusResult clone ( ) { try { return ( UpdateAssociationStatusResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
dcapwell/jmh-tests | @ Benchmark public int baseline ( ) { return 1 ; }
dcapwell/jmh-tests | @ Benchmark public int inherent ( ) { return math . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int inherentTop ( ) { return math . finalTopAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int inherentBottom ( ) { return math . finalBottomAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalInherent ( ) { return finalMath . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalInherentTop ( ) { return finalMath . finalTopAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalInherentBottom ( ) { return finalMath . finalBottomAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int klass ( ) { return Math . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int klassFinalMethod ( ) { return Math . finalAdd ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalClass ( ) { return FinalMath . add ( left , right ) ; }
dcapwell/jmh-tests | @ Benchmark public int finalClassFinalMethod ( ) { return FinalMath . finalAdd ( left , right ) ; }
dcapwell/jmh-tests | private FinalMath ( ) { }
dcapwell/jmh-tests | private Math ( ) { }
dcapwell/jmh-tests | @ Override public int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public final int finalBottomAdd ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public final int finalTopAdd ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | @ Override public final int finalTopAdd ( int i , int j ) { return i + j ; }
EMResearch/EMB | public LocalPropertyDescriptor ( String propertyName , PropertyParser parser ) { this ( propertyName , parser , DEFAULT_PREFIX , DEFAULT_POSTFIX ) ; }
EMResearch/EMB | public LocalPropertyDescriptor ( String propertyName , PropertyParser parser , String prefix , String postfix ) { this . propertyName = propertyName ; this . parser = parser ; this . prefix = prefix ; this . postfix = postfix ; }
EMResearch/EMB | @ Override public String get ( Vertex vertex ) { if ( vertex . keys ( ) . contains ( propertyName ) ) { String value = parser . parse ( vertex . value ( propertyName ) ) ; if ( value != null ) { return String . format ( " % s % s % s " , prefix , value , postfix ) ; } } return null ; }
hernad/oo-netbeans | public NewTemplateTypesDialog ( ComponentTypePropertyEditor editor , PolyStruct plStruct ) { this . editor = editor ; this . plStruct = plStruct ; initComponents ( ) ; Node node = ( Node ) IdlTypeTreeCreator . createTemplateNode ( plStruct ) ; manager . setRootContext ( node ) ; PropertySheet propSheet = ( PropertySheet ) jPanel1 ; propSheet . setNodes ( new Node [ ] { node } ) ; }
hernad/oo-netbeans | private void initComponents ( ) { jPanel1 = new PropertySheet ( ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( this ) ; this . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( jPanel1 , javax . swing . GroupLayout . DEFAULT_SIZE , 376 , Short . MAX_VALUE ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( jPanel1 , javax . swing . GroupLayout . DEFAULT_SIZE , 244 , Short . MAX_VALUE ) . addContainerGap ( ) ) ) ; }
hernad/oo-netbeans | private void performOK ( ) { StringBuffer result = new StringBuffer ( ) ; Node [ ] nodes = manager . getRootContext ( ) . getChildren ( ) . getNodes ( ) ; try { String structName = plStruct . getSimpleProperty ( plStruct . PROPERTY_CONTAINER_PACKAGE ) . concat ( " . " ) . concat ( plStruct . getSimpleProperty ( plStruct . PROPERTY_CONTAINER_NAME ) ) ; result . append ( structName ) . append ( " < ▁ " ) ; } catch ( UnknownOpenOfficeOrgPropertyException ex ) { LogWriter . getLogWriter ( ) . printStackTrace ( ex ) ; } for ( int i = 0 ; i < nodes . length ; i ++ ) { NbNodeObject nodeObject = ( NbNodeObject ) nodes [ i ] . getLookup ( ) . lookup ( NbNodeObject . class ) ; if ( nodeObject instanceof TemplateType ) { TemplateType templType = ( TemplateType ) nodeObject ; try { String type = templType . getSimpleProperty ( templType . PROPERTY_CONTAINER_TYPE ) ; if ( i != 0 ) { result . append ( " , " ) ; } result . append ( type ) ; } catch ( UnknownOpenOfficeOrgPropertyException ex ) { LogWriter . getLogWriter ( ) . printStackTrace ( ex ) ; } } } result . append ( " ▁ > " ) ; FeatureDescriptor desc = editor . getPropertyEnv ( ) . getFeatureDescriptor ( ) ; SimpleOpenOfficeOrgProperty . SimpleProperty prop = ( SimpleOpenOfficeOrgProperty . SimpleProperty ) desc ; editor . setAsText ( result . toString ( ) ) ; prop . setValue ( result . toString ( ) ) ; }
hernad/oo-netbeans | public ExplorerManager getExplorerManager ( ) { return manager ; }
hernad/oo-netbeans | public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( " OK " ) ) { performOK ( ) ; } }
AutonomousCarProject/AutonomousCar | default void setImage ( IPixel [ ] [ ] image ) { }
AutonomousCarProject/AutonomousCar | default int getFrameNo ( ) { return 0 ; }
apache/calcite | @ Test void convertAutomaton ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . repeat ( 1 , 2 ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . startState , is ( new DeterministicAutomaton . MultiState ( new Automaton . State ( 0 ) , new Automaton . State ( 2 ) ) ) ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 2 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 2 ) ) ; }
apache/calcite | @ Test void convertAutomaton2 ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . symbol ( " B " ) . or ( ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 2 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 1 ) ) ; }
apache/calcite | @ Test void convertAutomaton3 ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . symbol ( " B " ) . star ( ) . seq ( ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 3 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 2 ) ) ; }
apache/calcite | @ Test void convertAutomaton4 ( ) { final Pattern . PatternBuilder builder = Pattern . builder ( ) ; final Pattern pattern = builder . symbol ( " A " ) . symbol ( " B " ) . optional ( ) . seq ( ) . symbol ( " A " ) . seq ( ) . build ( ) ; final Automaton automaton = pattern . toAutomaton ( ) ; final DeterministicAutomaton da = new DeterministicAutomaton ( automaton ) ; assertThat ( da . getTransitions ( ) . size ( ) , is ( 4 ) ) ; assertThat ( da . getEndStates ( ) . size ( ) , is ( 1 ) ) ; }
Lekanich/intellij-community | @ Before public void setUp ( ) throws Throwable { PlatformTestCase . initPlatformLangPrefix ( ) ; IdeaTestApplication . getInstance ( null ) ; myTestName = createTestName ( ) ; myProjectFixture = IdeaTestFixtureFactory . getFixtureFactory ( ) . createFixtureBuilder ( myTestName ) . getFixture ( ) ; edt ( new ThrowableRunnable < Exception > ( ) { @ Override public void run ( ) throws Exception { myProjectFixture . setUp ( ) ; } } ) ; myProject = myProjectFixture . getProject ( ) ; ( ( ProjectComponent ) ChangeListManager . getInstance ( myProject ) ) . projectOpened ( ) ; ( ( ProjectComponent ) VcsDirtyScopeManager . getInstance ( myProject ) ) . projectOpened ( ) ; myProjectRoot = myProject . getBasePath ( ) ; myProjectDir = myProject . getBaseDir ( ) ; myTestRoot = myProjectRoot ; myPlatformFacade = ServiceManager . getService ( myProject , GitPlatformFacade . class ) ; myGit = ServiceManager . getService ( myProject , Git . class ) ; mySettings = myPlatformFacade . getSettings ( myProject ) ; mySettings . getAppSettings ( ) . setPathToGit ( GitExecutor . PathHolder . GIT_EXECUTABLE ) ; myVcsHelper = GitTestUtil . overrideService ( myProject , AbstractVcsHelper . class , MockVcsHelper . class ) ; myChangeListManager = ( ChangeListManagerImpl ) myPlatformFacade . getChangeListManager ( myProject ) ; myNotificator = ( TestVcsNotifier ) ServiceManager . getService ( myProject , VcsNotifier . class ) ; myVcs = GitVcs . getInstance ( myProject ) ; virtualCommits = new GitTestVirtualCommitsHolder ( ) ; myAsyncTasks = new ArrayList < Future > ( ) ; cd ( myProjectRoot ) ; myRepository = GitTestUtil . createRepository ( myProject , myProjectRoot ) ; ProjectLevelVcsManagerImpl vcsManager = ( ProjectLevelVcsManagerImpl ) ProjectLevelVcsManager . getInstance ( myProject ) ; AbstractVcs vcs = vcsManager . findVcsByName ( " Git " ) ; Assert . assertEquals ( 1 , vcsManager . getRootsUnderVcs ( vcs ) . length ) ; GitTestUtil . assumeSupportedGitVersion ( myVcs ) ; LOG . info ( getStartTestMarker ( ) ) ; }
Lekanich/intellij-community | private String getStartTestMarker ( ) { return " Starting ▁ " + myTestName ; }
Lekanich/intellij-community | private String createTestName ( ) { return getClass ( ) . getName ( ) + " - " + new Random ( ) . nextInt ( ) ; }
Lekanich/intellij-community | @ Before ( value = " @ remote " , order = 1 ) public void setUpRemoteOperations ( ) { myHttpAuthService = ( GitHttpAuthTestService ) ServiceManager . getService ( GitHttpAuthService . class ) ; }
Lekanich/intellij-community | @ Before ( value = " @ nestedroot " , order = 2 ) public void setUpStandardMultipleRootsConfig ( ) { cd ( myProjectRoot ) ; File community = mkdir ( " community " ) ; GitTestUtil . createRepository ( myProject , community . getPath ( ) ) ; }
Lekanich/intellij-community | @ After ( value = " @ remote " , order = 5 ) public void tearDownRemoteOperations ( ) { }
Lekanich/intellij-community | for ( Future future : myAsyncTasks ) { future . get ( 30 , TimeUnit . SECONDS ) ; }
Lekanich/intellij-community | @ After ( order = 3 ) public void tearDownFixture ( ) throws Exception { edt ( new ThrowableRunnable < Exception > ( ) { @ Override public void run ( ) throws Exception { myProjectFixture . tearDown ( ) ; } } ) ; }
Lekanich/intellij-community | @ After ( order = 2 ) public void cleanupDir ( ) { FileUtil . delete ( new File ( myTestRoot ) ) ; }
Lekanich/intellij-community | @ After ( order = 1 ) public void cleanupWorld ( ) throws IllegalAccessException { for ( Field field : GitCucumberWorld . class . getDeclaredFields ( ) ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { field . set ( null , null ) ; } } }
Lekanich/intellij-community | @ After ( order = 0 ) public void dumpToLog ( @ NotNull Scenario result ) { if ( result . isFailed ( ) ) { TestLoggerFactory . dumpLogToStdout ( getStartTestMarker ( ) ) ; } }
jbb-project/jbb | public PostDto toDto ( Post post ) { PostAuthor author = post . getAuthor ( ) ; return PostDto . builder ( ) . id ( post . getId ( ) ) . topicId ( post . getTopicId ( ) ) . authorMemberId ( author . isMember ( ) ? author . getAuthorMemberId ( ) : null ) . anonymousName ( author . isAnonymous ( ) ? author . getAnonAuthorName ( ) : null ) . subject ( post . getSubject ( ) ) . postedAt ( post . getPostedAt ( ) ) . build ( ) ; }
jbb-project/jbb | public PostContentDto toContentDto ( FullPost post ) { PostAuthor author = post . getAuthor ( ) ; return PostContentDto . builder ( ) . id ( post . getId ( ) ) . topicId ( post . getTopicId ( ) ) . authorMemberId ( author . isMember ( ) ? author . getAuthorMemberId ( ) : null ) . anonymousName ( author . isAnonymous ( ) ? author . getAnonAuthorName ( ) : null ) . subject ( post . getSubject ( ) ) . postedAt ( post . getPostedAt ( ) ) . content ( post . getContent ( ) ) . build ( ) ; }
SaiVDivya04/Automation-Code- | public SafariDriverFactory ( final DriverConfig cfg ) { super ( cfg ) ; }
SaiVDivya04/Automation-Code- | @ Override public WebDriver createWebDriver ( ) { DesiredCapabilities cap = new SafariCapabilitiesFactory ( ) . createCapabilities ( webDriverConfig ) ; System . out . println ( " Begin ▁ Safari " ) ; synchronized ( this . getClass ( ) ) { driver = new SafariDriver ( cap ) ; } System . out . println ( " safari ▁ started " ) ; this . setWebDriver ( driver ) ; setImplicitWaitTimeout ( webDriverConfig . getImplicitWaitTimeout ( ) ) ; if ( webDriverConfig . getPageLoadTimeout ( ) >= 0 ) { TestLogging . log ( " Safari ▁ doesn ' t ▁ support ▁ pageLoadTimeout " ) ; } return driver ; }
JLengenfeld/deckcompare | public Deck importDeck ( @ NonNull URL url ) { try { return importDeck ( new File ( url . toURI ( ) ) ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( format ( " The ▁ provided ▁ URL ▁ ' % s ' ▁ cannot ▁ be ▁ converted ▁ to ▁ a ▁ URI . " , url ) , e ) ; } }
JLengenfeld/deckcompare | public Deck importDeck ( @ NonNull File file ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( format ( " File ▁ ' % s ' ▁ does ▁ not ▁ exist ! " , file ) ) ; } Deck deck = new Deck ( ) ; try { JAXBContext jaxbContext = JAXBContext . newInstance ( Deck . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; deck = ( Deck ) jaxbUnmarshaller . unmarshal ( file ) ; } catch ( JAXBException e ) { throw new ImportException ( " Could ▁ not ▁ import ▁ deck " , e ) ; } return deck ; }
snxamdf/gdmedicine | @ Override public BaseService < Role , String > getService ( ) { return roleService ; }
snxamdf/gdmedicine | @ Override public Module < Role > getModule ( ) { return new Module < Role > ( SYS . PROJECT , " role " , CTL . BMS , Role . class ) ; }
snxamdf/gdmedicine | @ RequestMapping ( " / user / distr " ) public String userRoleDist ( HttpServletRequest request , Model model ) { Iterable < Users > users = usersService . findAll ( new Filter ( " deletion " , Operator . EQ , "0" ) ) ; Iterable < Role > roles = roleService . findAll ( new Filter ( " deletion " , Operator . EQ , "0" ) ) ; model . addAttribute ( " users " , users ) ; model . addAttribute ( " roles " , roles ) ; return " sys / bms . role . user . distr . form " ; }
snxamdf/gdmedicine | @ ResponseBody @ RequestMapping ( " / user / get " ) public Result < List < UserRoles > > getRolesByUserId ( String uid ) { return Results . success ( userRolesRepository . findByUserId ( uid ) ) ; }
snxamdf/gdmedicine | @ ResponseBody @ RequestMapping ( " / user / distr / save " ) public Result < String > userRoleDistSave ( HttpServletRequest request , String user , Model model ) { if ( user == null || " - 1" . equals ( user ) ) { return Results . fault ( - 1 , " 请选择用户 " ) ; } String [ ] roles = request . getParameterValues ( " roles " ) ; if ( roles == null ) { return Results . fault ( - 1 , " 请选择权限 " ) ; } userRolesRepository . deleteByUserId ( user ) ; for ( String role : roles ) { UserRoles ur = new UserRoles ( ) ; ur . setUserId ( user ) ; ur . setRoleId ( role ) ; userRolesRepository . save ( ur ) ; } return Results . success ( " ok " ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | private Utilities ( ) { throw new UnsupportedOperationException ( " do ▁ not ▁ call " ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | @ Override public int compare ( ActionRequestValue ar1 , ActionRequestValue ar2 ) { int value = ar1 . getPriority ( ) . compareTo ( ar2 . getPriority ( ) ) ; if ( value == 0 ) { value = ActionRequestValue . compareActionCode ( ar1 . getActionRequested ( ) , ar2 . getActionRequested ( ) , true ) ; if ( value == 0 ) { if ( ( ar1 . getActionRequestId ( ) != null ) && ( ar2 . getActionRequestId ( ) != null ) ) { value = ar1 . getActionRequestId ( ) . compareTo ( ar2 . getActionRequestId ( ) ) ; } else { value = 0 ; } } } return value ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | @ Override public int compare ( ActionRequestValue ar1 , ActionRequestValue ar2 ) { if ( ! ar1 . getChildrenRequests ( ) . isEmpty ( ) ) { Collections . sort ( ar1 . getChildrenRequests ( ) , this ) ; } if ( ! ar2 . getChildrenRequests ( ) . isEmpty ( ) ) { Collections . sort ( ar2 . getChildrenRequests ( ) , this ) ; } int routeLevelCompareVal = ar1 . getRouteLevel ( ) . compareTo ( ar2 . getRouteLevel ( ) ) ; if ( routeLevelCompareVal != 0 ) { return routeLevelCompareVal ; } if ( ar1 . isActive ( ) && ar2 . isPending ( ) ) { return - 1 ; } else if ( ar2 . isActive ( ) && ar1 . isPending ( ) ) { return 1 ; } return super . compare ( ar1 , ar2 ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException ( @ Nullable String message ) { this ( message , null ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException ( @ Nullable Throwable throwable ) { this ( null , throwable ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException ( @ Nullable String message , @ Nullable Throwable throwable ) { super ( throwable ) ; putMessage ( message == null && throwable != null ? throwable . getMessage ( ) : message ) ; }
Duct-and-rice/KrswtkhrWiki4Android | public RemoteLogException put ( String key , String value ) { props . put ( key , value ) ; return this ; }
Duct-and-rice/KrswtkhrWiki4Android | @ Override public String getMessage ( ) { super . getMessage ( ) ; return propsToJsonMsg ( ) ; }
Duct-and-rice/KrswtkhrWiki4Android | private void putMessage ( @ Nullable String message ) { if ( message != null ) { props . put ( " message " , message ) ; } }
Duct-and-rice/KrswtkhrWiki4Android | private String propsToJsonMsg ( ) { return new JSONObject ( props ) . toString ( ) ; }
rinde/vanLon17-GPEM-code | @ Override public Collection < GPFunc < GpGlobal > > create ( ) { return Arrays . asList ( new If4 < GpGlobal > ( ) , new Add < GpGlobal > ( ) , new Sub < GpGlobal > ( ) , new Div < GpGlobal > ( ) , new Mul < GpGlobal > ( ) , new Pow < GpGlobal > ( ) , new Neg < GpGlobal > ( ) , new Min < GpGlobal > ( ) , new Max < GpGlobal > ( ) , new Constant < GpGlobal > ( 10 ) , new Constant < GpGlobal > ( 2 ) , new Constant < GpGlobal > ( 1 ) , new Constant < GpGlobal > ( 0 ) , new InsertionFlexibility ( ) , new InsertionCost ( ) , new InsertionTravelTime ( ) , new InsertionTardiness ( ) , new InsertionOverTime ( ) , new TimeLeft ( ) , new Slack ( ) , new Ado ( ) , new Mido ( ) , new Mado ( ) , new RouteLength ( ) , new PickupUrgency ( ) , new DeliveryUrgency ( ) ) ; }
anujbhan/airavata | public String getDeploymentID ( ) { return deploymentID ; }
anujbhan/airavata | public void setDeploymentID ( String deploymentID ) { this . deploymentID = deploymentID ; }
anujbhan/airavata | public String getName ( ) { return name ; }
anujbhan/airavata | public void setName ( String name ) { this . name = name ; }
anujbhan/airavata | public String getValue ( ) { return value ; }
anujbhan/airavata | public void setValue ( String value ) { this . value = value ; }
anujbhan/airavata | public ApplicationDeployment getApplicationDeployment ( ) { return applicationDeployment ; }
anujbhan/airavata | public void setApplicationDeployment ( ApplicationDeployment applicationDeployment ) { this . applicationDeployment = applicationDeployment ; }
medicayun/medicayundicom | public VMFFindScp ( QueryRetrieveScpService service ) { super ( service , true ) ; }
medicayun/medicayundicom | protected MultiDimseRsp newMultiCFindRsp ( Dataset rqData ) throws SQLException { if ( ! " IMAGE " . equals ( rqData . getString ( Tags . QueryRetrieveLevel ) ) ) return super . newMultiCFindRsp ( rqData ) ; final String studyIUID = rqData . getString ( Tags . StudyInstanceUID ) ; final String [ ] seriesIUIDs = rqData . getStrings ( Tags . SeriesInstanceUID ) ; if ( seriesIUIDs == null || seriesIUIDs . length == 0 ) throw new IllegalArgumentException ( " Missing ▁ Series ▁ Instance ▁ UID " ) ; return new VMFMultiCFindRsp ( studyIUID , seriesIUIDs ) ; }
medicayun/medicayundicom | public VMFMultiCFindRsp ( String studyIUID , String [ ] seriesIUIDs ) { keys = DcmObjectFactory . getInstance ( ) . newDataset ( ) ; keys . putUI ( Tags . StudyInstanceUID , studyIUID ) ; this . seriesIUIDs = seriesIUIDs ; }
medicayun/medicayundicom | public DimseListener getCancelListener ( ) { return new DimseListener ( ) { public void dimseReceived ( Association assoc , Dimse dimse ) { canceled = true ; } } ; }
medicayun/medicayundicom | public Dataset next ( ActiveAssociation assoc , Dimse rq , Command rspCmd ) throws DcmServiceException { rspCmd . putUS ( Tags . Status , Status . Cancel ) ; while ( next < seriesIUIDs . length ) { if ( canceled ) return null ; keys . putUI ( Tags . SeriesInstanceUID , seriesIUIDs [ next ++ ] ) ; try { QueryCmd queryCmd = QueryCmd . createInstanceQuery ( keys , false , service . isNoMatchForNoValue ( ) ) ; try { queryCmd . execute ( ) ; if ( ! queryCmd . next ( ) ) continue ; final Dataset dataset = queryCmd . getDataset ( ) ; VMFBuilder builder = new VMFBuilder ( service , dataset , service . getVMFConfig ( dataset . getString ( Tags . SOPClassUID ) ) ) ; while ( queryCmd . next ( ) ) { if ( canceled ) return null ; builder . addFrame ( queryCmd . getDataset ( ) ) ; } if ( canceled ) return null ; rspCmd . putUS ( Tags . Status , Status . Pending ) ; return builder . getResult ( ) ; } finally { queryCmd . close ( ) ; } } catch ( Exception e ) { throw new DcmServiceException ( Status . UnableToProcess , e ) ; } } rspCmd . putUS ( Tags . Status , Status . Success ) ; return null ; }
medicayun/medicayundicom | public void release ( ) { }
pwjazz/mwanzia | public AuthenticationException ( ) { super ( ) ; }
pwjazz/mwanzia | public AuthenticationException ( String arg0 , Throwable arg1 ) { super ( arg0 , arg1 ) ; }
pwjazz/mwanzia | public AuthenticationException ( String arg0 ) { super ( arg0 ) ; }
pwjazz/mwanzia | public AuthenticationException ( Throwable arg0 ) { super ( arg0 ) ; }
apereo/cas | @ Override @ JsonIgnore public boolean isServiceAccessAllowed ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . isServiceAccessAllowed ( ) ; }
apereo/cas | @ Override @ JsonIgnore public void setServiceAccessAllowed ( final boolean enabled ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; this . groovyStrategyInstance . setServiceAccessAllowed ( enabled ) ; }
apereo/cas | @ Override @ JsonIgnore public boolean isServiceAccessAllowedForSso ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . isServiceAccessAllowedForSso ( ) ; }
apereo/cas | @ Override @ JsonIgnore public boolean doPrincipalAttributesAllowServiceAccess ( final String principal , final Map < String , Object > attributes ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . doPrincipalAttributesAllowServiceAccess ( principal , attributes ) ; }
apereo/cas | @ JsonIgnore @ Override public URI getUnauthorizedRedirectUrl ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . getUnauthorizedRedirectUrl ( ) ; }
apereo/cas | @ Override @ JsonIgnore public RegisteredServiceDelegatedAuthenticationPolicy getDelegatedAuthenticationPolicy ( ) { buildGroovyAccessStrategyInstanceIfNeeded ( ) ; return this . groovyStrategyInstance . getDelegatedAuthenticationPolicy ( ) ; }
apereo/cas | @ Override @ JsonIgnore public Map < String , Set < String > > getRequiredAttributes ( ) { return this . groovyStrategyInstance . getRequiredAttributes ( ) ; }
apereo/cas | @ SneakyThrows private void buildGroovyAccessStrategyInstanceIfNeeded ( ) { if ( this . groovyStrategyInstance == null ) { val groovyResource = ResourceUtils . getResourceFrom ( SpringExpressionLanguageValueResolver . getInstance ( ) . resolve ( this . groovyScript ) ) ; this . groovyStrategyInstance = ScriptingUtils . getObjectInstanceFromGroovyResource ( groovyResource , RegisteredServiceAccessStrategy . class ) ; } }
erichwang/presto | @ Benchmark public List < Page > runPagesIndexSortBenchmark ( PagesIndexSortBenchmarkData data ) { PagesIndex . TestingFactory pagesIndexFactory = new PagesIndex . TestingFactory ( false ) ; PagesIndex pageIndex = pagesIndexFactory . newPagesIndex ( data . getTypes ( ) , data . getTotalPositions ( ) ) ; for ( Page page : data . getPages ( ) ) { pageIndex . addPage ( page ) ; } pageIndex . sort ( data . getSortChannels ( ) , data . getSortOrders ( ) ) ; return Streams . stream ( pageIndex . getSortedPages ( ) ) . collect ( toImmutableList ( ) ) ; }
erichwang/presto | @ Test public void verifyPagesIndexSortBenchmark ( ) { PagesIndexSortBenchmarkData state = new PagesIndexSortBenchmarkData ( ) ; state . setup ( ) ; List < Page > pages = runPagesIndexSortBenchmark ( state ) ; int positionCount = pages . stream ( ) . mapToInt ( Page :: getPositionCount ) . sum ( ) ; assertEquals ( positionCount , state . getTotalPositions ( ) ) ; }
erichwang/presto | @ Setup public void setup ( ) { super . setup ( numSortChannels , totalChannels , 1 , pagesCount ) ; }
erichwang/presto | @ Benchmark public List < Page > runPagesMergeSortBenchmark ( MergeSortedBenchmarkData data ) { WorkProcessor < Page > sortedPagesWork = mergeSortedPages ( data . getSplitPages ( ) . stream ( ) . map ( WorkProcessor :: fromIterable ) . collect ( toImmutableList ( ) ) , ORDERING_COMPILER . compilePageWithPositionComparator ( data . getSortTypes ( ) , data . getSortChannels ( ) , data . getSortOrders ( ) ) , data . getOutputChannels ( ) , data . getTypes ( ) , ( pageBuilder , pageWithPosition ) -> pageBuilder . isFull ( ) , false , newSimpleAggregatedMemoryContext ( ) , new DriverYieldSignal ( ) ) ; ImmutableList . Builder < Page > sortedPages = ImmutableList . builder ( ) ; while ( true ) { sortedPagesWork . process ( ) ; if ( sortedPagesWork . isFinished ( ) ) { return sortedPages . build ( ) ; } sortedPages . add ( sortedPagesWork . getResult ( ) ) ; } }
erichwang/presto | @ Test public void verifyPagesMergeSortBenchmark ( ) { MergeSortedBenchmarkData state = new MergeSortedBenchmarkData ( ) ; state . setup ( ) ; List < Page > pages = runPagesMergeSortBenchmark ( state ) ; int positionCount = pages . stream ( ) . mapToInt ( Page :: getPositionCount ) . sum ( ) ; assertEquals ( positionCount , state . getTotalPositions ( ) ) ; }
erichwang/presto | @ Setup public void setup ( ) { super . setup ( numSortChannels , totalChannels , numMergeSources , pagesCount ) ; }
erichwang/presto | protected void setup ( int numSortChannels , int totalChannels , int numMergeSources , int pagesCount ) { types = nCopies ( totalChannels , BIGINT ) ; sortChannels = new ArrayList < > ( ) ; for ( int i = 0 ; i < numSortChannels ; i ++ ) { sortChannels . add ( i ) ; } sortTypes = nCopies ( numSortChannels , BIGINT ) ; sortOrders = nCopies ( numSortChannels , ASC_NULLS_FIRST ) ; outputChannels = new ArrayList < > ( ) ; for ( int i = 0 ; i < totalChannels ; i ++ ) { outputChannels . add ( i ) ; } createPages ( totalChannels , pagesCount ) ; createPageProducers ( numMergeSources ) ; }
erichwang/presto | private void createPages ( int totalChannels , int pagesCount ) { int positionCount = PageBuilderStatus . DEFAULT_MAX_PAGE_SIZE_IN_BYTES / ( totalChannels * 8 ) ; pages = new ArrayList < > ( pagesCount ) ; for ( int numPage = 0 ; numPage < pagesCount ; numPage ++ ) { pages . add ( createSequencePage ( types , positionCount ) ) ; } totalPositions = positionCount * pagesCount ; }
erichwang/presto | private void createPageProducers ( int numMergeSources ) { AtomicInteger counter = new AtomicInteger ( 0 ) ; splitPages = pages . stream ( ) . collect ( Collectors . groupingBy ( it -> counter . getAndIncrement ( ) % numMergeSources ) ) . values ( ) . stream ( ) . collect ( toImmutableList ( ) ) ; }
erichwang/presto | List < Page > getPages ( ) { return pages ; }
erichwang/presto | int getTotalPositions ( ) { return totalPositions ; }
erichwang/presto | List < List < Page > > getSplitPages ( ) { return splitPages ; }
erichwang/presto | List < Type > getTypes ( ) { return types ; }
erichwang/presto | List < Integer > getSortChannels ( ) { return sortChannels ; }
erichwang/presto | List < Type > getSortTypes ( ) { return sortTypes ; }
erichwang/presto | List < SortOrder > getSortOrders ( ) { return sortOrders ; }
erichwang/presto | List < Integer > getOutputChannels ( ) { return outputChannels ; }
Fokko/druid | @ Override public void configure ( Binder binder ) { JsonConfigProvider . bind ( binder , " druid . emitter . http " , HttpEmitterConfig . class ) ; JsonConfigProvider . bind ( binder , " druid . emitter . http . ssl " , HttpEmitterSSLClientConfig . class ) ; configureSsl ( binder ) ; }
Fokko/druid | @ Provides @ ManageLifecycle @ Named ( " http " ) public Emitter getEmitter ( Supplier < HttpEmitterConfig > config , Supplier < HttpEmitterSSLClientConfig > sslConfig , @ Nullable SSLContext sslContext , Lifecycle lifecycle , ObjectMapper jsonMapper ) { return new HttpPostEmitter ( config . get ( ) , lifecycle . addCloseableInstance ( createAsyncHttpClient ( " HttpPostEmitter - AsyncHttpClient - % d " , " HttpPostEmitter - AsyncHttpClient - Timer - % d " , getEffectiveSSLContext ( sslConfig . get ( ) , sslContext ) ) ) , jsonMapper ) ; }
hotchemi/wearzaim | public SendLoginStatusService ( ) { super ( TAG ) ; }
hotchemi/wearzaim | @ Override public void onHandleIntent ( Intent intent ) { GoogleApiClient googleApiClient = new GoogleApiClient . Builder ( this ) . addApi ( Wearable . API ) . build ( ) ; ConnectionResult result = googleApiClient . blockingConnect ( CONNECT_TIMEOUT_MS , TimeUnit . MILLISECONDS ) ; if ( ! result . isSuccess ( ) ) { Log . e ( TAG , " Failed ▁ to ▁ connect ▁ to ▁ GoogleApiClient . " ) ; return ; } String login = intent . getStringExtra ( KEY_LOGIN ) ; Wearable . MessageApi . sendMessage ( googleApiClient , REQUEST_PATH , RESET_PATH , Base64Utils . encode ( login ) ) ; }
coderkiss/ImageLoader | @ SuppressLint ( " UseSparseArrays " ) protected ImageLoader ( ) { if ( config == null ) { config = new LoaderConfig ( ) ; } config = config . build ( ) ; loadingView = Collections . synchronizedMap ( new HashMap < Integer , ViewPack > ( ) ) ; pathLocks = new WeakHashMap < String , ReentrantLock > ( ) ; }
coderkiss/ImageLoader | public void resume ( ) { if ( ! config . paused . get ( ) ) { LogUtil . w ( TAG , " image ▁ loader ▁ not ▁ paused ! " ) ; return ; } config . paused . set ( false ) ; synchronized ( config . pauseLock ) { config . pauseLock . notifyAll ( ) ; } }
coderkiss/ImageLoader | public void pause ( ) { if ( config . paused . get ( ) ) { LogUtil . w ( TAG , " image ▁ loader ▁ already ▁ paused ! " ) ; return ; } config . paused . set ( true ) ; }
coderkiss/ImageLoader | public void stop ( ) { for ( int vid : loadingView . keySet ( ) ) { loadingView . get ( vid ) . collect ( ) ; } loadingView . clear ( ) ; pathLocks . clear ( ) ; ( ( ExecutorService ) config . remoteExecutor ) . shutdownNow ( ) ; ( ( ExecutorService ) config . nativeExecutor ) . shutdownNow ( ) ; }
coderkiss/ImageLoader | public void destroy ( ) { }
coderkiss/ImageLoader | public void load ( String path , LoaderListener listener ) { load ( null , path , listener , false ) ; }
coderkiss/ImageLoader | public void load ( String path , LoaderListener listener , boolean origin ) { load ( null , path , listener , origin ) ; }
coderkiss/ImageLoader | public void load ( ImageView imageView , String path ) { load ( imageView , path , null , false ) ; }
coderkiss/ImageLoader | public void load ( ImageView imageView , String path , boolean origin ) { load ( imageView , path , null , false ) ; }
coderkiss/ImageLoader | public void load ( ImageView imageView , String path , LoaderListener listener ) { load ( imageView , path , null , false ) ; }
coderkiss/ImageLoader | public synchronized void load ( ImageView imageView , String path , LoaderListener listener , boolean origin ) { if ( StringUtil . isEmpty ( path ) ) { return ; } imageView . setImageBitmap ( null ) ; String key = config . namer . create ( path ) ; ViewPack vp = new ViewPack ( imageView , path ) ; if ( loadingView . containsKey ( vp . getId ( ) ) ) { ViewPack oldPack = loadingView . remove ( vp . getId ( ) ) ; String oldPath = oldPack . getPath ( ) ; LogUtil . d ( TAG , " collect ▁ old ▁ view ▁ " + oldPath ) ; oldPack . collect ( ) ; } loadingView . put ( vp . getId ( ) , vp ) ; LoadHandler loader = new LoadHandler ( ) ; ReentrantLock lock = getLock ( path ) ; LoaderInfo loadInfo = new LoaderInfo ( path , key , vp , lock ) ; loadInfo . origin = origin ; loadInfo . loader = this ; loader . listener = listener ; loader . config = config ; loader . loadInfo = loadInfo ; boolean disk = config . diskCache . contains ( key ) ; boolean mem = config . memCache . contains ( key ) ; if ( mem || disk ) { config . nativeExecutor . execute ( loader ) ; } else { config . remoteExecutor . execute ( loader ) ; } }
coderkiss/ImageLoader | private ReentrantLock getLock ( String path ) { ReentrantLock lock = pathLocks . get ( path ) ; if ( lock == null ) { lock = new ReentrantLock ( ) ; pathLocks . put ( path , lock ) ; } return lock ; }
coderkiss/ImageLoader | public synchronized boolean cancel ( ImageView imageView ) { ViewPack viewPack = new ViewPack ( imageView , null ) ; viewPack = loadingView . remove ( viewPack . getId ( ) ) ; if ( viewPack != null ) { String path = viewPack . getPath ( ) ; LogUtil . d ( TAG , " cancel ▁ load ▁ " + path ) ; viewPack . collect ( ) ; } return viewPack != null ; }
coderkiss/ImageLoader | public synchronized boolean cancel ( String path ) { if ( StringUtil . isEmpty ( path ) ) { LogUtil . w ( TAG , " invalid ▁ path " ) ; return false ; } boolean removed = false ; Iterator < Integer > iterator = loadingView . keySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { int vid = iterator . next ( ) ; ViewPack vp = loadingView . get ( vid ) ; if ( path . equals ( vp . getPath ( ) ) ) { iterator . remove ( ) ; LogUtil . d ( TAG , " cancel ▁ load ▁ " + path ) ; vp . collect ( ) ; removed = true ; } } return removed ; }
CheezeCake/muStreamerClient | public final void __completed ( Ice . AsyncResult __result ) { IMusicServerPrx __proxy = ( IMusicServerPrx ) __result . getProxy ( ) ; StreamToken __ret = null ; try { __ret = __proxy . end_setupStreaming ( __result ) ; } catch ( Ice . LocalException __ex ) { exception ( __ex ) ; return ; } response ( __ret ) ; }
shalk/TIJ4Code | public void foo ( ) { System . out . println ( " abstract ▁ foo " ) ; }
tillrohrmann/flink | protected AbstractHandler ( @ Nonnull GatewayRetriever < ? extends T > leaderRetriever , @ Nonnull Time timeout , @ Nonnull Map < String , String > responseHeaders , @ Nonnull UntypedResponseMessageHeaders < R , M > untypedResponseMessageHeaders ) { super ( leaderRetriever , timeout , responseHeaders ) ; this . untypedResponseMessageHeaders = Preconditions . checkNotNull ( untypedResponseMessageHeaders ) ; this . inFlightRequestTracker = new InFlightRequestTracker ( ) ; }
tillrohrmann/flink | @ Override protected void respondAsLeader ( ChannelHandlerContext ctx , RoutedRequest routedRequest , T gateway ) { HttpRequest httpRequest = routedRequest . getRequest ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " Received ▁ request ▁ " + httpRequest . uri ( ) + ' . ' ) ; } FileUploads uploadedFiles = null ; try { if ( ! inFlightRequestTracker . registerRequest ( ) ) { log . debug ( " The ▁ handler ▁ instance ▁ for ▁ { } ▁ had ▁ already ▁ been ▁ closed . " , untypedResponseMessageHeaders . getTargetRestEndpointURL ( ) ) ; ctx . channel ( ) . close ( ) ; return ; } if ( ! ( httpRequest instanceof FullHttpRequest ) ) { log . error ( " Implementation ▁ error : ▁ Received ▁ a ▁ request ▁ that ▁ wasn ' t ▁ a ▁ FullHttpRequest . " ) ; throw new RestHandlerException ( " Bad ▁ request ▁ received . " , HttpResponseStatus . BAD_REQUEST ) ; } final ByteBuf msgContent = ( ( FullHttpRequest ) httpRequest ) . content ( ) ; uploadedFiles = FileUploadHandler . getMultipartFileUploads ( ctx ) ; if ( ! untypedResponseMessageHeaders . acceptsFileUploads ( ) && ! uploadedFiles . getUploadedFiles ( ) . isEmpty ( ) ) { throw new RestHandlerException ( " File ▁ uploads ▁ not ▁ allowed . " , HttpResponseStatus . BAD_REQUEST ) ; } R request ; if ( msgContent . capacity ( ) == 0 ) { try { request = MAPPER . readValue ( " { } " , untypedResponseMessageHeaders . getRequestClass ( ) ) ; } catch ( JsonParseException | JsonMappingException je ) { throw new RestHandlerException ( " Bad ▁ request ▁ received . ▁ Request ▁ did ▁ not ▁ conform ▁ to ▁ expected ▁ format . " , HttpResponseStatus . BAD_REQUEST , je ) ; } } else { try { InputStream in = new ByteBufInputStream ( msgContent ) ; request = MAPPER . readValue ( in , untypedResponseMessageHeaders . getRequestClass ( ) ) ; } catch ( JsonParseException | JsonMappingException je ) { throw new RestHandlerException ( String . format ( " Request ▁ did ▁ not ▁ match ▁ expected ▁ format ▁ % s . " , untypedResponseMessageHeaders . getRequestClass ( ) . getSimpleName ( ) ) , HttpResponseStatus . BAD_REQUEST , je ) ; } } final HandlerRequest < R , M > handlerRequest ; try { handlerRequest = new HandlerRequest < R , M > ( request , untypedResponseMessageHeaders . getUnresolvedMessageParameters ( ) , routedRequest . getRouteResult ( ) . pathParams ( ) , routedRequest . getRouteResult ( ) . queryParams ( ) , uploadedFiles . getUploadedFiles ( ) ) ; } catch ( HandlerRequestException hre ) { log . error ( " Could ▁ not ▁ create ▁ the ▁ handler ▁ request . " , hre ) ; throw new RestHandlerException ( String . format ( " Bad ▁ request , ▁ could ▁ not ▁ parse ▁ parameters : ▁ % s " , hre . getMessage ( ) ) , HttpResponseStatus . BAD_REQUEST , hre ) ; } log . trace ( " Starting ▁ request ▁ processing . " ) ; CompletableFuture < Void > requestProcessingFuture = respondToRequest ( ctx , httpRequest , handlerRequest , gateway ) ; final FileUploads finalUploadedFiles = uploadedFiles ; requestProcessingFuture . handle ( ( Void ignored , Throwable throwable ) -> { if ( throwable != null ) { return handleException ( ExceptionUtils . stripCompletionException ( throwable ) , ctx , httpRequest ) ; } return CompletableFuture . < Void > completedFuture ( null ) ; } ) . thenCompose ( Function . identity ( ) ) . whenComplete ( ( Void ignored , Throwable throwable ) -> { if ( throwable != null ) { log . warn ( " An ▁ exception ▁ occurred ▁ while ▁ handling ▁ another ▁ exception . " , throwable ) ; } finalizeRequestProcessing ( finalUploadedFiles ) ; } ) ; } catch ( Throwable e ) { final FileUploads finalUploadedFiles = uploadedFiles ; handleException ( e , ctx , httpRequest ) . whenComplete ( ( Void ignored , Throwable throwable ) -> finalizeRequestProcessing ( finalUploadedFiles ) ) ; } }
tillrohrmann/flink | private void finalizeRequestProcessing ( FileUploads uploadedFiles ) { inFlightRequestTracker . deregisterRequest ( ) ; cleanupFileUploads ( uploadedFiles ) ; }
tillrohrmann/flink | private CompletableFuture < Void > handleException ( Throwable throwable , ChannelHandlerContext ctx , HttpRequest httpRequest ) { ClusterEntryPointExceptionUtils . tryEnrichClusterEntryPointError ( throwable ) ; FlinkHttpObjectAggregator flinkHttpObjectAggregator = ctx . pipeline ( ) . get ( FlinkHttpObjectAggregator . class ) ; if ( flinkHttpObjectAggregator == null ) { log . warn ( " The ▁ connection ▁ was ▁ unexpectedly ▁ closed ▁ by ▁ the ▁ client . " ) ; return CompletableFuture . completedFuture ( null ) ; } int maxLength = flinkHttpObjectAggregator . maxContentLength ( ) - OTHER_RESP_PAYLOAD_OVERHEAD ; if ( throwable instanceof RestHandlerException ) { RestHandlerException rhe = ( RestHandlerException ) throwable ; String stackTrace = ExceptionUtils . stringifyException ( rhe ) ; String truncatedStackTrace = Ascii . truncate ( stackTrace , maxLength , " . . . " ) ; if ( log . isDebugEnabled ( ) ) { log . error ( " Exception ▁ occurred ▁ in ▁ REST ▁ handler . " , rhe ) ; } else if ( rhe . logException ( ) ) { log . error ( " Exception ▁ occurred ▁ in ▁ REST ▁ handler : ▁ { } " , rhe . getMessage ( ) ) ; } return HandlerUtils . sendErrorResponse ( ctx , httpRequest , new ErrorResponseBody ( truncatedStackTrace ) , rhe . getHttpResponseStatus ( ) , responseHeaders ) ; } else { log . error ( " Unhandled ▁ exception . " , throwable ) ; String stackTrace = String . format ( " < Exception ▁ on ▁ server ▁ side : % n % s % nEnd ▁ of ▁ exception ▁ on ▁ server ▁ side > " , ExceptionUtils . stringifyException ( throwable ) ) ; String truncatedStackTrace = Ascii . truncate ( stackTrace , maxLength , " . . . " ) ; return HandlerUtils . sendErrorResponse ( ctx , httpRequest , new ErrorResponseBody ( Arrays . asList ( " Internal ▁ server ▁ error . " , truncatedStackTrace ) ) , HttpResponseStatus . INTERNAL_SERVER_ERROR , responseHeaders ) ; } }
tillrohrmann/flink | @ Override public final CompletableFuture < Void > closeAsync ( ) { synchronized ( lock ) { if ( terminationFuture == null ) { this . terminationFuture = FutureUtils . composeAfterwards ( closeHandlerAsync ( ) , inFlightRequestTracker :: awaitAsync ) ; } else { log . warn ( " The ▁ handler ▁ instance ▁ for ▁ { } ▁ had ▁ already ▁ been ▁ closed , ▁ but ▁ another ▁ attempt ▁ at ▁ closing ▁ it ▁ was ▁ made . " , untypedResponseMessageHeaders . getTargetRestEndpointURL ( ) ) ; } return this . terminationFuture ; } }
tillrohrmann/flink | protected CompletableFuture < Void > closeHandlerAsync ( ) { return CompletableFuture . completedFuture ( null ) ; }
tillrohrmann/flink | private void cleanupFileUploads ( @ Nullable FileUploads uploadedFiles ) { if ( uploadedFiles != null ) { try { uploadedFiles . close ( ) ; } catch ( IOException e ) { log . warn ( " Could ▁ not ▁ cleanup ▁ uploaded ▁ files . " , e ) ; } } }
QuantumRand/cordova-plugin-geofence | public ReceiveTransitionsIntentService ( ) { super ( " ReceiveTransitionsIntentService " ) ; beepHelper = new BeepHelper ( ) ; store = new GeoNotificationStore ( this ) ; Logger . setLogger ( new Logger ( GeofencePlugin . TAG , this , false ) ) ; }
QuantumRand/cordova-plugin-geofence | @ Override protected void onHandleIntent ( Intent intent ) { Logger logger = Logger . getLogger ( ) ; logger . log ( Log . DEBUG , " ReceiveTransitionsIntentService ▁ - ▁ onHandleIntent " ) ; Intent broadcastIntent = new Intent ( GeofenceTransitionIntent ) ; notifier = new GeoNotificationNotifier ( ( NotificationManager ) this . getSystemService ( Context . NOTIFICATION_SERVICE ) , this ) ; GeofencingEvent geofencingEvent = GeofencingEvent . fromIntent ( intent ) ; if ( geofencingEvent . hasError ( ) ) { int errorCode = geofencingEvent . getErrorCode ( ) ; String error = " Location ▁ Services ▁ error : ▁ " + Integer . toString ( errorCode ) ; logger . log ( Log . ERROR , error ) ; broadcastIntent . putExtra ( " error " , error ) ; } else { int transitionType = geofencingEvent . getGeofenceTransition ( ) ; if ( ( transitionType == Geofence . GEOFENCE_TRANSITION_ENTER ) || ( transitionType == Geofence . GEOFENCE_TRANSITION_EXIT ) ) { logger . log ( Log . DEBUG , " Geofence ▁ transition ▁ detected " ) ; List < Geofence > triggerList = geofencingEvent . getTriggeringGeofences ( ) ; List < GeoNotification > geoNotifications = new ArrayList < GeoNotification > ( ) ; for ( Geofence fence : triggerList ) { String fenceId = fence . getRequestId ( ) ; GeoNotification geoNotification = store . getGeoNotification ( fenceId ) ; if ( geoNotification != null ) { if ( geoNotification . notification != null ) { if ( geoNotification . isScheduled ( ) && geoNotification . isFrequencyOk ( ) ) { geoNotification . notification . setLastTriggered ( ) ; store . setGeoNotification ( geoNotification ) ; notifier . notify ( geoNotification . notification ) ; } } geoNotification . transitionType = transitionType ; geoNotifications . add ( geoNotification ) ; } } if ( geoNotifications . size ( ) > 0 ) { broadcastIntent . putExtra ( " transitionData " , Gson . get ( ) . toJson ( geoNotifications ) ) ; GeofencePlugin . onTransitionReceived ( geoNotifications ) ; } } else { String error = " Geofence ▁ transition ▁ error : ▁ " + transitionType ; logger . log ( Log . ERROR , error ) ; broadcastIntent . putExtra ( " error " , error ) ; } } sendBroadcast ( broadcastIntent ) ; }
jivesoftware/leaps-and-bounds | @ Test public void test ( ) { }
JavaSaBr/jME3-SpaceShift-Editor | protected BaseFileEditor ( ) { this . operationControl = createOperationControl ( ) ; this . changeCounter = new AtomicInteger ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected @ NotNull EditorOperationControl createOperationControl ( ) { return new EditorOperationControl ( this ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FromAnyThread public void execute ( @ NotNull final EditorOperation operation ) { operationControl . execute ( operation ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread @ Override protected boolean handleKeyActionImpl ( @ NotNull final KeyCode keyCode , final boolean isPressed , final boolean isControlDown , final boolean isShiftDown , final boolean isButtonMiddleDown ) { if ( isPressed && isControlDown && keyCode == KeyCode . Z ) { undo ( ) ; return true ; } else if ( isPressed && isControlDown && isShiftDown && keyCode == KeyCode . Z ) { redo ( ) ; return true ; } else if ( isPressed && isControlDown && keyCode == KeyCode . Y ) { redo ( ) ; return true ; } return super . handleKeyActionImpl ( keyCode , isPressed , isControlDown , isShiftDown , isButtonMiddleDown ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public void incrementChange ( ) { final int result = changeCounter . incrementAndGet ( ) ; setDirty ( result != 0 ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public void decrementChange ( ) { final int result = changeCounter . decrementAndGet ( ) ; setDirty ( result != 0 ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FromAnyThread public void redo ( ) { operationControl . redo ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FromAnyThread public void undo ( ) { operationControl . undo ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected @ NotNull EditorOperationControl getOperationControl ( ) { return operationControl ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public void openFile ( @ NotNull final Path file ) { super . openFile ( file ) ; try { doOpenFile ( file ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } EXECUTOR_MANAGER . addFxTask ( this :: loadState ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected void loadState ( ) { final Supplier < EditorState > stateFactory = getEditorStateFactory ( ) ; if ( stateFactory == null ) { return ; } final WorkspaceManager workspaceManager = WorkspaceManager . getInstance ( ) ; final Workspace currentWorkspace = notNull ( workspaceManager . getCurrentWorkspace ( ) ) ; editorState = currentWorkspace . getEditorState ( getEditFile ( ) , stateFactory ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected @ Nullable Supplier < EditorState > getEditorStateFactory ( ) { return null ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FxThread protected void doOpenFile ( @ NotNull final Path file ) throws IOException { }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected void setIgnoreListeners ( final boolean ignoreListeners ) { this . ignoreListeners = ignoreListeners ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected boolean isIgnoreListeners ( ) { return ignoreListeners ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected @ NotNull StackPane createRoot ( ) { return new StackPane ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public @ Nullable BorderPane get3DArea ( ) { return null ; }
JavaSaBr/jME3-SpaceShift-Editor | @ FromAnyThread protected @ Nullable S getEditorState ( ) { return editorState ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread public boolean isInside ( final double sceneX , final double sceneY , @ NotNull final Class < ? extends Event > eventType ) { return false ; }
sajavadi/pinot | private SegmentPrunerProvider ( ) { }
jgaupp/arx | public ComponentStatusLabel ( Composite parent , int style ) { super ( parent , checkStyle ( style ) ) ; if ( ( style & ( SWT . CENTER | SWT . RIGHT ) ) == 0 ) style |= SWT . LEFT ; if ( ( style & SWT . CENTER ) != 0 ) align = SWT . CENTER ; if ( ( style & SWT . RIGHT ) != 0 ) align = SWT . RIGHT ; if ( ( style & SWT . LEFT ) != 0 ) align = SWT . LEFT ; addPaintListener ( new PaintListener ( ) { public void paintControl ( PaintEvent event ) { onPaint ( event ) ; } } ) ; addTraverseListener ( new TraverseListener ( ) { public void keyTraversed ( TraverseEvent event ) { if ( event . detail == SWT . TRAVERSE_MNEMONIC ) { onMnemonic ( event ) ; } } } ) ; addListener ( SWT . Dispose , new Listener ( ) { public void handleEvent ( Event event ) { onDispose ( event ) ; } } ) ; initAccessible ( ) ; }
jgaupp/arx | public Point computeSize ( int wHint , int hHint , boolean changed ) { checkWidget ( ) ; Point e = getTotalSize ( image , text ) ; if ( wHint == SWT . DEFAULT ) { e . x += leftMargin + rightMargin ; } else { e . x = wHint ; } if ( hHint == SWT . DEFAULT ) { e . y += topMargin + bottomMargin ; } else { e . y = hHint ; } return e ; }
jgaupp/arx | @ Override public void dispose ( ) { super . dispose ( ) ; }
jgaupp/arx | public int getAlignment ( ) { return align ; }
jgaupp/arx | public int getBottomMargin ( ) { return bottomMargin ; }
jgaupp/arx | public Image getImage ( ) { return image ; }
jgaupp/arx | public int getLeftMargin ( ) { return leftMargin ; }
jgaupp/arx | public int getRightMargin ( ) { return rightMargin ; }
jgaupp/arx | public int getStyle ( ) { int style = super . getStyle ( ) ; switch ( align ) { case SWT . RIGHT : style |= SWT . RIGHT ; break ; case SWT . CENTER : style |= SWT . CENTER ; break ; case SWT . LEFT : style |= SWT . LEFT ; break ; } return style ; }
jgaupp/arx | public String getText ( ) { return text ; }
jgaupp/arx | public String getToolTipText ( ) { checkWidget ( ) ; return appToolTipText ; }
jgaupp/arx | public int getTopMargin ( ) { return topMargin ; }
jgaupp/arx | public void setAlignment ( int align ) { checkWidget ( ) ; if ( align != SWT . LEFT && align != SWT . RIGHT && align != SWT . CENTER ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( this . align != align ) { this . align = align ; redraw ( ) ; } }
jgaupp/arx | public void setBackground ( Color color ) { super . setBackground ( color ) ; if ( backgroundImage == null && gradientColors == null && gradientPercents == null ) { if ( color == null ) { if ( background == null ) return ; } else { if ( color . equals ( background ) ) return ; } } background = color ; backgroundImage = null ; gradientColors = null ; gradientPercents = null ; redraw ( ) ; }
jgaupp/arx | public void setBackground ( Color [ ] colors , int [ ] percents ) { setBackground ( colors , percents , false ) ; }
jgaupp/arx | public void setBackground ( Color [ ] colors , int [ ] percents , boolean vertical ) { checkWidget ( ) ; if ( colors != null ) { if ( percents == null || percents . length != colors . length - 1 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( getDisplay ( ) . getDepth ( ) < 15 ) { colors = new Color [ ] { colors [ colors . length - 1 ] } ; percents = new int [ ] { } ; } for ( int i = 0 ; i < percents . length ; i ++ ) { if ( percents [ i ] < 0 || percents [ i ] > 100 ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } if ( i > 0 && percents [ i ] < percents [ i - 1 ] ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } } } final Color background = getBackground ( ) ; if ( backgroundImage == null ) { if ( ( gradientColors != null ) && ( colors != null ) && ( gradientColors . length == colors . length ) ) { boolean same = false ; for ( int i = 0 ; i < gradientColors . length ; i ++ ) { same = ( gradientColors [ i ] == colors [ i ] ) || ( ( gradientColors [ i ] == null ) && ( colors [ i ] == background ) ) || ( ( gradientColors [ i ] == background ) && ( colors [ i ] == null ) ) ; if ( ! same ) break ; } if ( same ) { for ( int i = 0 ; i < gradientPercents . length ; i ++ ) { same = gradientPercents [ i ] == percents [ i ] ; if ( ! same ) break ; } } if ( same && this . gradientVertical == vertical ) return ; } } else { backgroundImage = null ; } if ( colors == null ) { gradientColors = null ; gradientPercents = null ; gradientVertical = false ; } else { gradientColors = new Color [ colors . length ] ; for ( int i = 0 ; i < colors . length ; ++ i ) gradientColors [ i ] = ( colors [ i ] != null ) ? colors [ i ] : background ; gradientPercents = new int [ percents . length ] ; for ( int i = 0 ; i < percents . length ; ++ i ) gradientPercents [ i ] = percents [ i ] ; gradientVertical = vertical ; } redraw ( ) ; }
jgaupp/arx | public void setBackground ( Image image ) { checkWidget ( ) ; if ( image == backgroundImage ) return ; if ( image != null ) { gradientColors = null ; gradientPercents = null ; } backgroundImage = image ; redraw ( ) ; }
jgaupp/arx | public void setBottomMargin ( int bottomMargin ) { checkWidget ( ) ; if ( this . bottomMargin == bottomMargin || bottomMargin < 0 ) return ; this . bottomMargin = bottomMargin ; redraw ( ) ; }
jgaupp/arx | public void setFont ( Font font ) { super . setFont ( font ) ; redraw ( ) ; }
jgaupp/arx | public void setGIF ( InputStream inputStream ) { checkWidget ( ) ; if ( thread != null ) { thread . stop ( ) ; this . getDisplay ( ) . timerExec ( - 1 , thread ) ; } ImageLoader loader = new ImageLoader ( ) ; try { loader . load ( inputStream ) ; } catch ( Exception e ) { this . image = null ; return ; } if ( loader . data [ 0 ] != null ) this . image = new Image ( this . getDisplay ( ) , loader . data [ 0 ] ) ; if ( loader . data . length > 1 ) { thread = new ComponentStatusLabelGIFHandler ( this , loader ) ; thread . run ( ) ; } redraw ( ) ; }
jgaupp/arx | public void setGIF ( String path ) { try { this . setGIF ( new FileInputStream ( new File ( path ) ) ) ; } catch ( FileNotFoundException e ) { this . image = null ; return ; } }
jgaupp/arx | public void setImage ( Image image ) { checkWidget ( ) ; if ( thread != null ) { thread . stop ( ) ; getDisplay ( ) . timerExec ( - 1 , thread ) ; } if ( image != this . image ) { this . image = image ; redraw ( ) ; } }
jgaupp/arx | public void setLeftMargin ( int leftMargin ) { checkWidget ( ) ; if ( this . leftMargin == leftMargin || leftMargin < 0 ) return ; this . leftMargin = leftMargin ; redraw ( ) ; }
jgaupp/arx | public void setMargins ( int leftMargin , int topMargin , int rightMargin , int bottomMargin ) { checkWidget ( ) ; this . leftMargin = Math . max ( 0 , leftMargin ) ; this . topMargin = Math . max ( 0 , topMargin ) ; this . rightMargin = Math . max ( 0 , rightMargin ) ; this . bottomMargin = Math . max ( 0 , bottomMargin ) ; redraw ( ) ; }
jgaupp/arx | public void setProgressProvider ( ComponentStatusLabelProgressProvider provider ) { this . progressProvider = provider ; }
jgaupp/arx | public void setRightMargin ( int rightMargin ) { checkWidget ( ) ; if ( this . rightMargin == rightMargin || rightMargin < 0 ) return ; this . rightMargin = rightMargin ; redraw ( ) ; }
jgaupp/arx | public void setText ( String text ) { checkWidget ( ) ; if ( text == null ) text = " " ; if ( ! text . equals ( this . text ) ) { this . text = text ; redraw ( ) ; } }
jgaupp/arx | public void setToolTipText ( String string ) { super . setToolTipText ( string ) ; appToolTipText = super . getToolTipText ( ) ; }
jgaupp/arx | public void setTopMargin ( int topMargin ) { checkWidget ( ) ; if ( this . topMargin == topMargin || topMargin < 0 ) return ; this . topMargin = topMargin ; redraw ( ) ; }
jgaupp/arx | public void updateImage ( Image image ) { this . image = image ; this . redraw ( ) ; }
jgaupp/arx | private void drawBevelRect ( GC gc , int x , int y , int w , int h , Color topleft , Color bottomright ) { gc . setForeground ( bottomright ) ; gc . drawLine ( x + w , y , x + w , y + h ) ; gc . drawLine ( x , y + h , x + w , y + h ) ; gc . setForeground ( topleft ) ; gc . drawLine ( x , y , x + w - 1 , y ) ; gc . drawLine ( x , y , x , y + h - 1 ) ; }
jgaupp/arx | private Point getTotalSize ( Image image , String text ) { Point size = new Point ( 0 , 0 ) ; if ( image != null ) { Rectangle r = image . getBounds ( ) ; size . x += r . width ; size . y += r . height ; } GC gc = new GC ( this ) ; if ( text != null && text . length ( ) > 0 ) { Point e = gc . textExtent ( text , DRAW_FLAGS ) ; size . x += e . x ; size . y = Math . max ( size . y , e . y ) ; if ( image != null ) size . x += GAP ; } else { size . y = Math . max ( size . y , gc . getFontMetrics ( ) . getHeight ( ) ) ; } gc . dispose ( ) ; return size ; }
jgaupp/arx | private void initAccessible ( ) { Accessible accessible = getAccessible ( ) ; accessible . addAccessibleListener ( new AccessibleAdapter ( ) { public void getHelp ( AccessibleEvent e ) { e . result = getToolTipText ( ) ; } public void getKeyboardShortcut ( AccessibleEvent e ) { char mnemonic = _findMnemonic ( ComponentStatusLabel . this . text ) ; if ( mnemonic != ' \0' ) { e . result = " Alt + " + mnemonic ; } } public void getName ( AccessibleEvent e ) { e . result = getText ( ) ; } } ) ; accessible . addAccessibleControlListener ( new AccessibleControlAdapter ( ) { public void getChildAtPoint ( AccessibleControlEvent e ) { e . childID = ACC . CHILDID_SELF ; } public void getChildCount ( AccessibleControlEvent e ) { e . detail = 0 ; } public void getLocation ( AccessibleControlEvent e ) { Rectangle rect = getDisplay ( ) . map ( getParent ( ) , null , getBounds ( ) ) ; e . x = rect . x ; e . y = rect . y ; e . width = rect . width ; e . height = rect . height ; } public void getRole ( AccessibleControlEvent e ) { e . detail = ACC . ROLE_LABEL ; } public void getState ( AccessibleControlEvent e ) { e . detail = ACC . STATE_READONLY ; } } ) ; }
jgaupp/arx | private void paintBorder ( GC gc , Rectangle r ) { Display disp = getDisplay ( ) ; Color c1 = null ; Color c2 = null ; int style = getStyle ( ) ; if ( ( style & SWT . SHADOW_IN ) != 0 ) { c1 = disp . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; c2 = disp . getSystemColor ( SWT . COLOR_WIDGET_HIGHLIGHT_SHADOW ) ; } if ( ( style & SWT . SHADOW_OUT ) != 0 ) { c1 = disp . getSystemColor ( SWT . COLOR_WIDGET_LIGHT_SHADOW ) ; c2 = disp . getSystemColor ( SWT . COLOR_WIDGET_NORMAL_SHADOW ) ; } if ( c1 != null && c2 != null ) { gc . setLineWidth ( 1 ) ; drawBevelRect ( gc , r . x , r . y , r . width - 1 , r . height - 1 , c1 , c2 ) ; } }
jgaupp/arx | private String [ ] splitString ( String text ) { String [ ] lines = new String [ 1 ] ; int start = 0 , pos ; do { pos = text . indexOf ( ' \n ' , start ) ; if ( pos == - 1 ) { lines [ lines . length - 1 ] = text . substring ( start ) ; } else { boolean crlf = ( pos > 0 ) && ( text . charAt ( pos - 1 ) == ' \r ' ) ; lines [ lines . length - 1 ] = text . substring ( start , pos - ( crlf ? 1 : 0 ) ) ; start = pos + 1 ; String [ ] newLines = new String [ lines . length + 1 ] ; System . arraycopy ( lines , 0 , newLines , 0 , lines . length ) ; lines = newLines ; } } while ( pos != - 1 ) ; return lines ; }
jgaupp/arx | protected String shortenText ( GC gc , String t , int width ) { if ( t == null ) return null ; int w = gc . textExtent ( ELLIPSIS , DRAW_FLAGS ) . x ; if ( width <= w ) return t ; int l = t . length ( ) ; int max = l / 2 ; int min = 0 ; int mid = ( max + min ) / 2 - 1 ; if ( mid <= 0 ) return t ; TextLayout layout = new TextLayout ( getDisplay ( ) ) ; layout . setText ( t ) ; mid = validateOffset ( layout , mid ) ; while ( min < mid && mid < max ) { String s1 = t . substring ( 0 , mid ) ; String s2 = t . substring ( validateOffset ( layout , l - mid ) , l ) ; int l1 = gc . textExtent ( s1 , DRAW_FLAGS ) . x ; int l2 = gc . textExtent ( s2 , DRAW_FLAGS ) . x ; if ( l1 + w + l2 > width ) { max = mid ; mid = validateOffset ( layout , ( max + min ) / 2 ) ; } else if ( l1 + w + l2 < width ) { min = mid ; mid = validateOffset ( layout , ( max + min ) / 2 ) ; } else { min = max ; } } String result = mid == 0 ? t : t . substring ( 0 , mid ) + ELLIPSIS + t . substring ( validateOffset ( layout , l - mid ) , l ) ; layout . dispose ( ) ; return result ; }
jgaupp/arx | char _findMnemonic ( String string ) { if ( string == null ) return ' \0' ; int index = 0 ; int length = string . length ( ) ; do { while ( index < length && string . charAt ( index ) != ' & ' ) index ++ ; if ( ++ index >= length ) return ' \0' ; if ( string . charAt ( index ) != ' & ' ) return Character . toLowerCase ( string . charAt ( index ) ) ; index ++ ; } while ( index < length ) ; return ' \0' ; }
jgaupp/arx | void onDispose ( Event event ) { if ( ignoreDispose ) { ignoreDispose = false ; return ; } ignoreDispose = true ; notifyListeners ( event . type , event ) ; event . type = SWT . NONE ; gradientColors = null ; gradientPercents = null ; backgroundImage = null ; text = null ; image = null ; appToolTipText = null ; }
jgaupp/arx | void onMnemonic ( TraverseEvent event ) { char mnemonic = _findMnemonic ( text ) ; if ( mnemonic == ' \0' ) return ; if ( Character . toLowerCase ( event . character ) != mnemonic ) return ; Composite control = this . getParent ( ) ; while ( control != null ) { Control [ ] children = control . getChildren ( ) ; int index = 0 ; while ( index < children . length ) { if ( children [ index ] == this ) break ; index ++ ; } index ++ ; if ( index < children . length ) { if ( children [ index ] . setFocus ( ) ) { event . doit = true ; event . detail = SWT . TRAVERSE_NONE ; } } control = control . getParent ( ) ; } }
jgaupp/arx | void onPaint ( PaintEvent event ) { Rectangle rect = getClientArea ( ) ; if ( rect . width == 0 || rect . height == 0 ) return ; boolean shortenText = false ; String t = text ; Image img = image ; int availableWidth = Math . max ( 0 , rect . width - ( leftMargin + rightMargin ) ) ; Point extent = getTotalSize ( img , t ) ; if ( extent . x > availableWidth ) { img = null ; extent = getTotalSize ( img , t ) ; if ( extent . x > availableWidth ) { shortenText = true ; } } GC gc = event . gc ; String [ ] lines = text == null ? null : splitString ( text ) ; if ( shortenText ) { extent . x = 0 ; for ( int i = 0 ; i < lines . length ; i ++ ) { Point e = gc . textExtent ( lines [ i ] , DRAW_FLAGS ) ; if ( e . x > availableWidth ) { lines [ i ] = shortenText ( gc , lines [ i ] , availableWidth ) ; extent . x = Math . max ( extent . x , getTotalSize ( null , lines [ i ] ) . x ) ; } else { extent . x = Math . max ( extent . x , e . x ) ; } } if ( appToolTipText == null ) { super . setToolTipText ( text ) ; } } else { super . setToolTipText ( appToolTipText ) ; } int x = rect . x + leftMargin ; if ( align == SWT . CENTER ) { x = ( rect . width - extent . x ) / 2 ; } if ( align == SWT . RIGHT ) { x = rect . width - rightMargin - extent . x ; } try { if ( backgroundImage != null ) { Rectangle imageRect = backgroundImage . getBounds ( ) ; gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; int xPos = 0 ; while ( xPos < rect . width ) { int yPos = 0 ; while ( yPos < rect . height ) { gc . drawImage ( backgroundImage , xPos , yPos ) ; yPos += imageRect . height ; } xPos += imageRect . width ; } } else if ( gradientColors != null ) { final Color oldBackground = gc . getBackground ( ) ; if ( gradientColors . length == 1 ) { if ( gradientColors [ 0 ] != null ) gc . setBackground ( gradientColors [ 0 ] ) ; gc . fillRectangle ( 0 , 0 , rect . width , rect . height ) ; } else { final Color oldForeground = gc . getForeground ( ) ; Color lastColor = gradientColors [ 0 ] ; if ( lastColor == null ) lastColor = oldBackground ; int pos = 0 ; for ( int i = 0 ; i < gradientPercents . length ; ++ i ) { gc . setForeground ( lastColor ) ; lastColor = gradientColors [ i + 1 ] ; if ( lastColor == null ) lastColor = oldBackground ; gc . setBackground ( lastColor ) ; if ( gradientVertical ) { final int gradientHeight = ( gradientPercents [ i ] * rect . height / 100 ) - pos ; gc . fillGradientRectangle ( 0 , pos , rect . width , gradientHeight , true ) ; pos += gradientHeight ; } else { final int gradientWidth = ( gradientPercents [ i ] * rect . width / 100 ) - pos ; gc . fillGradientRectangle ( pos , 0 , gradientWidth , rect . height , false ) ; pos += gradientWidth ; } } if ( gradientVertical && pos < rect . height ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( 0 , pos , rect . width , rect . height - pos ) ; } if ( ! gradientVertical && pos < rect . width ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( pos , 0 , rect . width - pos , rect . height ) ; } gc . setForeground ( oldForeground ) ; } gc . setBackground ( oldBackground ) ; } else { if ( background != null || ( getStyle ( ) & SWT . DOUBLE_BUFFERED ) == 0 ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; } } } catch ( SWTException e ) { if ( ( getStyle ( ) & SWT . DOUBLE_BUFFERED ) == 0 ) { gc . setBackground ( getBackground ( ) ) ; gc . fillRectangle ( rect ) ; } } int style = getStyle ( ) ; if ( ( style & SWT . SHADOW_IN ) != 0 || ( style & SWT . SHADOW_OUT ) != 0 ) { paintBorder ( gc , rect ) ; } Rectangle imageRect = null ; int lineHeight = 0 , textHeight = 0 , imageHeight = 0 ; if ( img != null ) { imageRect = img . getBounds ( ) ; imageHeight = imageRect . height ; } if ( lines != null ) { lineHeight = gc . getFontMetrics ( ) . getHeight ( ) ; textHeight = lines . length * lineHeight ; } int imageY = 0 , midPoint = 0 , lineY = 0 ; if ( imageHeight > textHeight ) { if ( topMargin == DEFAULT_MARGIN && bottomMargin == DEFAULT_MARGIN ) imageY = rect . y + ( rect . height - imageHeight ) / 2 ; else imageY = topMargin ; midPoint = imageY + imageHeight / 2 ; lineY = midPoint - textHeight / 2 ; } else { if ( topMargin == DEFAULT_MARGIN && bottomMargin == DEFAULT_MARGIN ) lineY = rect . y + ( rect . height - textHeight ) / 2 ; else lineY = topMargin ; midPoint = lineY + textHeight / 2 ; imageY = midPoint - imageHeight / 2 ; } if ( img != null ) { gc . drawImage ( img , 0 , 0 , imageRect . width , imageHeight , x , imageY , imageRect . width , imageHeight ) ; x += imageRect . width + GAP ; extent . x -= imageRect . width + GAP ; } if ( lines != null ) { gc . setForeground ( getForeground ( ) ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { int lineX = x ; if ( lines . length > 1 ) { if ( align == SWT . CENTER ) { int lineWidth = gc . textExtent ( lines [ i ] , DRAW_FLAGS ) . x ; lineX = x + Math . max ( 0 , ( extent . x - lineWidth ) / 2 ) ; } if ( align == SWT . RIGHT ) { int lineWidth = gc . textExtent ( lines [ i ] , DRAW_FLAGS ) . x ; lineX = Math . max ( x , rect . x + rect . width - rightMargin - lineWidth ) ; } } if ( i == lines . length - 1 && progressProvider != null && progressProvider . getProgress ( ) != 0 ) { gc . drawText ( lines [ i ] + " ▁ ( " + progressProvider . getProgress ( ) + " % ) " , lineX , lineY , DRAW_FLAGS ) ; } else { gc . drawText ( lines [ i ] , lineX , lineY , DRAW_FLAGS ) ; } lineY += lineHeight ; } } }
jgaupp/arx | int validateOffset ( TextLayout layout , int offset ) { int nextOffset = layout . getNextOffset ( offset , SWT . MOVEMENT_CLUSTER ) ; if ( nextOffset != offset ) return layout . getPreviousOffset ( nextOffset , SWT . MOVEMENT_CLUSTER ) ; return offset ; }
SDRC-India/collect | public AlertDialog createDialog ( final Context context , final AuthDialogUtilityResultListener resultListener ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; final View dialogView = LayoutInflater . from ( context ) . inflate ( R . layout . server_auth_dialog , null ) ; final EditText username = ( EditText ) dialogView . findViewById ( R . id . username_edit ) ; final EditText password = ( EditText ) dialogView . findViewById ( R . id . password_edit ) ; final SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context ) ; username . setText ( getUserName ( settings ) ) ; password . setText ( getPassword ( settings ) ) ; builder . setTitle ( context . getString ( R . string . server_requires_auth ) ) ; builder . setMessage ( context . getString ( R . string . server_auth_credentials , getServer ( settings , context ) ) ) ; builder . setView ( dialogView ) ; builder . setPositiveButton ( context . getString ( R . string . ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Collect . getInstance ( ) . getActivityLogger ( ) . logAction ( this , TAG , " OK " ) ; String userNameValue = username . getText ( ) . toString ( ) ; String passwordValue = password . getText ( ) . toString ( ) ; saveCredentials ( settings , userNameValue , passwordValue ) ; setWebCredentialsFromPreferences ( context ) ; resultListener . updatedCredentials ( ) ; } } ) ; builder . setNegativeButton ( context . getString ( R . string . cancel ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Collect . getInstance ( ) . getActivityLogger ( ) . logAction ( this , TAG , " Cancel " ) ; resultListener . cancelledUpdatingCredentials ( ) ; } } ) ; builder . setCancelable ( false ) ; return builder . create ( ) ; }
SDRC-India/collect | private void saveCredentials ( SharedPreferences settings , String userName , String password ) { settings . edit ( ) . putString ( PreferenceKeys . KEY_USERNAME , userName ) . putString ( PreferenceKeys . KEY_PASSWORD , password ) . commit ( ) ; }
lj3lj3/XBridge | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; this . addPreferencesFromResource ( R . xml . preference_xbridge ) ; addRebootPreference ( this ) ; keyXda = getString ( R . string . key_xda ) ; keySizeOfIconInNoti = getString ( R . string . key_size_of_icon_in_noti ) ; }
lj3lj3/XBridge | @ Override public View onCreateView ( @ NonNull LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { Log . d ( TAG , " keys : " + PlayAction . keyShow + AppOpsAction . keyShow + AppSettingsAction . keyShow + ClipBoardAction . keyShow + SearchAction . keyShow ) ; playPreference = ( SwitchPreference ) this . findPreference ( PlayAction . keyShow ) ; appOpsPreference = ( SwitchPreference ) this . findPreference ( AppOpsAction . keyShow ) ; appSettingsPreference = ( SwitchPreference ) this . findPreference ( AppSettingsAction . keyShow ) ; clipBoardPreference = ( SwitchPreference ) this . findPreference ( ClipBoardAction . keyShow ) ; searchPreference = ( SwitchPreference ) this . findPreference ( SearchAction . keyShow ) ; xPrivacyPreference = ( SwitchPreference ) this . findPreference ( XPrivacyAction . keyShow ) ; appInfoPreference = ( SwitchPreference ) this . findPreference ( AppInfoAction . keyShow ) ; notifyCleanPreference = ( SwitchPreference ) this . findPreference ( NotifyCleanAction . keyShow ) ; lightningWallPreference = ( SwitchPreference ) this . findPreference ( LightningWallAction . keyShow ) ; xhaloFloatingWindowPreference = ( SwitchPreference ) this . findPreference ( XHaloFloatingWindowAction . keyShow ) ; myAndroidToolsPreference = ( SwitchPreference ) this . findPreference ( MyAndroidToolsAction . keyShow ) ; sizeOfIconInNotiPreference = this . findPreference ( keySizeOfIconInNoti ) ; playPreference . setOnPreferenceChangeListener ( this ) ; appOpsPreference . setOnPreferenceChangeListener ( this ) ; appSettingsPreference . setOnPreferenceChangeListener ( this ) ; clipBoardPreference . setOnPreferenceChangeListener ( this ) ; searchPreference . setOnPreferenceChangeListener ( this ) ; xPrivacyPreference . setOnPreferenceChangeListener ( this ) ; appInfoPreference . setOnPreferenceChangeListener ( this ) ; notifyCleanPreference . setOnPreferenceChangeListener ( this ) ; lightningWallPreference . setOnPreferenceChangeListener ( this ) ; xhaloFloatingWindowPreference . setOnPreferenceChangeListener ( this ) ; myAndroidToolsPreference . setOnPreferenceChangeListener ( this ) ; return super . onCreateView ( inflater , container , savedInstanceState ) ; }
lj3lj3/XBridge | @ Override public void onStart ( ) { super . onStart ( ) ; ActionBar actionBar = this . getActivity ( ) . getActionBar ( ) ; if ( actionBar != null ) { actionBar . setTitle ( R . string . app_name ) ; } if ( need2Load ) { loadPreferenceValue ( ) ; need2Load = false ; } new IconLoader ( ) . execute ( ) ; }
lj3lj3/XBridge | public void loadPreferenceValue ( ) { playPreference . setChecked ( PlayAction . isShow ) ; appOpsPreference . setChecked ( AppOpsAction . isShow ) ; appSettingsPreference . setChecked ( AppSettingsAction . isShow ) ; clipBoardPreference . setChecked ( ClipBoardAction . isShow ) ; searchPreference . setChecked ( SearchAction . isShow ) ; xPrivacyPreference . setChecked ( XPrivacyAction . isShow ) ; appInfoPreference . setChecked ( AppInfoAction . isShow ) ; notifyCleanPreference . setChecked ( NotifyCleanAction . isShow ) ; lightningWallPreference . setChecked ( LightningWallAction . isShow ) ; xhaloFloatingWindowPreference . setChecked ( XHaloFloatingWindowAction . isShow ) ; myAndroidToolsPreference . setChecked ( MyAndroidToolsAction . isShow ) ; sizeOfIconInNotiPreference . setSummary ( SizeInputFragment . size + " % " ) ; Log . d ( TAG , " values : " + " PlayAction : " + PlayAction . isShow + " , AppOpsAction : " + AppOpsAction . isShow + " , AppSettingsAction : " + AppSettingsAction . isShow + " , ClipBoardAction : " + ClipBoardAction . isShow + " , SearchAction : " + SearchAction . isShow + " , XPrivacyAction : " + XPrivacyAction . isShow + " , AppInfoAction : " + AppInfoAction . isShow + " , XHaloFloatingWindowAction : " + XHaloFloatingWindowAction . isShow + " , NotifyCleanAction : " + NotifyCleanAction . isShow ) ; }
lj3lj3/XBridge | @ Override public boolean onPreferenceTreeClick ( PreferenceScreen preferenceScreen , @ NonNull Preference preference ) { super . onPreferenceTreeClick ( preferenceScreen , preference ) ; String prefKey = preference . getKey ( ) ; Log . d ( TAG , " clicked ▁ preference : ▁ " + prefKey ) ; PreferenceFragment fragment = null ; DialogFragment dialogFragment = null ; String tag = null ; Bundle bundle = new Bundle ( ) ; if ( PlayAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_play ) ; fragment = PlayFragment . getFragment ( bundle ) ; tag = PlayFragment . TAG ; } else if ( AppOpsAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_appops ) ; fragment = AppOpsFragment . getFragment ( bundle ) ; tag = AppOpsFragment . TAG ; } else if ( AppSettingsAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_appsettings ) ; fragment = AppSettingsFragment . getFragment ( bundle ) ; tag = AppSettingsFragment . TAG ; } else if ( ClipBoardAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_clipboard ) ; fragment = ClipBoardFragment . getFragment ( bundle ) ; tag = ClipBoardFragment . TAG ; } else if ( SearchAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_search ) ; fragment = SearchFragment . getFragment ( bundle ) ; tag = SearchFragment . TAG ; } else if ( XPrivacyAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_xprivacy ) ; fragment = XPrivacyFragment . getFragment ( bundle ) ; tag = XPrivacyFragment . TAG ; } else if ( AppInfoAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_appinfo ) ; fragment = AppInfoFragment . getFragment ( bundle ) ; tag = AppInfoFragment . TAG ; } else if ( NotifyCleanAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_notifyclean ) ; fragment = NotifyCleanFragment . getFragment ( bundle ) ; tag = NotifyCleanFragment . TAG ; } else if ( LightningWallAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_lightningwall ) ; fragment = LightningWallFragment . getFragment ( bundle ) ; tag = LightningWallFragment . TAG ; } else if ( XHaloFloatingWindowAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_xhalofloatingwindow ) ; fragment = XHaloFloatingWindowFragment . getFragment ( bundle ) ; tag = XHaloFloatingWindowFragment . TAG ; } else if ( MyAndroidToolsAction . keyShow . equals ( prefKey ) ) { bundle . putInt ( HeaderPreferenceFragment . ARGS_TITLE , R . string . title_myandroidtools ) ; fragment = MyAndroidToolsFragment . getFragment ( bundle ) ; tag = MyAndroidToolsFragment . TAG ; } else if ( keySizeOfIconInNoti . equals ( prefKey ) ) { dialogFragment = SizeInputFragment . getDialogFragment ( bundle ) ; tag = SizeInputFragment . TAG ; } else if ( keyXda . equals ( prefKey ) ) { Action . viewInXda ( this . getActivity ( ) . getApplicationContext ( ) ) ; return true ; } if ( dialogFragment != null ) { Log . d ( TAG , " dialog ▁ fragment ▁ is ▁ ok : ▁ " + dialogFragment ) ; dialogFragment . show ( this . getFragmentManager ( ) , tag ) ; } else if ( fragment != null ) { Log . d ( TAG , " fragment ▁ is ▁ ok : ▁ " + fragment ) ; this . getFragmentManager ( ) . beginTransaction ( ) . replace ( R . id . container , fragment , tag ) . setTransition ( FragmentTransaction . TRANSIT_FRAGMENT_OPEN ) . addToBackStack ( tag ) . commit ( ) ; this . getFragmentManager ( ) . executePendingTransactions ( ) ; } else { Log . w ( TAG , " on ▁ click ▁ fragment ▁ is ▁ null , ▁ key : ▁ " + prefKey ) ; return false ; } return true ; }
lj3lj3/XBridge | @ Override public boolean onPreferenceChange ( Preference preference , Object newValue ) { Log . d ( TAG , " changed ▁ preference : ▁ " + preference + " , ▁ newValue : ▁ " + newValue ) ; return false ; }
lj3lj3/XBridge | @ Override public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . menu_xbridge , menu ) ; super . onCreateOptionsMenu ( menu , inflater ) ; }
lj3lj3/XBridge | @ Override public void onPrepareOptionsMenu ( Menu menu ) { MenuItem debugItem = menu . findItem ( R . id . debug ) ; debugItem . setChecked ( Log . debug ) ; super . onPrepareOptionsMenu ( menu ) ; }
lj3lj3/XBridge | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . debug ) { boolean isChecked = ! item . isChecked ( ) ; item . setChecked ( isChecked ) ; Log . debug = isChecked ; Log . i ( TAG , " debug ▁ is ▁ checked : ▁ " + isChecked ) ; MainPreferences . getEditablePreferences ( getPreferenceManager ( ) ) . edit ( ) . putBoolean ( Log . keyDebug , isChecked ) . commit ( ) ; return true ; } return super . onOptionsItemSelected ( item ) ; }
lj3lj3/XBridge | @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; ActionBar actionBar = this . getActivity ( ) . getActionBar ( ) ; if ( actionBar != null ) { actionBar . setDisplayHomeAsUpEnabled ( false ) ; } }
lj3lj3/XBridge | public void setNeed2Load ( boolean need2Load ) { this . need2Load = need2Load ; }
lj3lj3/XBridge | @ Override protected Object doInBackground ( Object [ ] params ) { PackageManager packageManager = getActivity ( ) . getPackageManager ( ) ; iconInfo = AppInfoFragment . getPkgIcon ( packageManager ) ; iconAppOps = AppOpsFragment . getPkgIcon ( packageManager ) ; iconAppSettings = AppSettingsFragment . getPkgIcon ( packageManager ) ; iconPlay = PlayFragment . getPkgIcon ( packageManager ) ; iconXPrivacy = XPrivacyFragment . getPkgIcon ( packageManager ) ; iconNotifyClean = NotifyCleanFragment . getPkgIcon ( packageManager ) ; iconLightningWall = LightningWallFragment . getPkgIcon ( packageManager ) ; iconXHaloFloatingWindow = XHaloFloatingWindowFragment . getPkgIcon ( packageManager ) ; iconMyAndroidTools = MyAndroidToolsFragment . getPkgIcon ( packageManager ) ; Log . d ( TAG , " load ▁ icons ▁ done : " + " iconInfo : " + iconInfo + " , iconAppOps : " + iconAppOps + " , iconAppSettings : " + iconAppSettings + " , iconPlay : " + iconPlay + " , iconNotifyClean : " + iconNotifyClean + " , iconLightningWall : " + iconLightningWall + " , iconXHaloFloatingWindow : " + iconXHaloFloatingWindow + " , iconMyAndroidTools : " + iconMyAndroidTools + " , iconXPrivacy : " + iconXPrivacy ) ; return null ; }
lj3lj3/XBridge | @ Override protected void onPostExecute ( Object o ) { playPreference . setIcon ( iconPlay ) ; appOpsPreference . setIcon ( iconAppOps ) ; appSettingsPreference . setIcon ( iconAppSettings ) ; xPrivacyPreference . setIcon ( iconXPrivacy ) ; appInfoPreference . setIcon ( iconInfo ) ; notifyCleanPreference . setIcon ( iconNotifyClean ) ; lightningWallPreference . setIcon ( iconLightningWall ) ; xhaloFloatingWindowPreference . setIcon ( iconXHaloFloatingWindow ) ; myAndroidToolsPreference . setIcon ( iconMyAndroidTools ) ; super . onPostExecute ( o ) ; }
data-integrations/wrangler | public Expression ( String value ) { this . value = value ; }
data-integrations/wrangler | @ Override public String value ( ) { return value ; }
data-integrations/wrangler | @ Override public TokenType type ( ) { return TokenType . EXPRESSION ; }
data-integrations/wrangler | @ Override public JsonElement toJson ( ) { JsonObject object = new JsonObject ( ) ; object . addProperty ( " type " , TokenType . EXPRESSION . name ( ) ) ; object . addProperty ( " value " , value ) ; return object ; }
lukas-krecan/ShedLock | @ Override @ NonNull public Optional < SimpleLock > lock ( @ NonNull LockConfiguration lockConfiguration ) { synchronized ( locks ) { String lockName = lockConfiguration . getName ( ) ; if ( isLocked ( lockName ) ) { return Optional . empty ( ) ; } else { LockRecord lockRecord = new LockRecord ( lockConfiguration . getLockAtMostUntil ( ) ) ; locks . put ( lockName , lockRecord ) ; logger . debug ( " Locked ▁ { } " , lockConfiguration ) ; return Optional . of ( new InMemoryLock ( lockConfiguration ) ) ; } } }
lukas-krecan/ShedLock | boolean isLocked ( String lockName ) { synchronized ( locks ) { LockRecord lockRecord = locks . get ( lockName ) ; return lockRecord != null && lockRecord . lockedUntil . isAfter ( now ( ) ) ; } }
lukas-krecan/ShedLock | private void doUnlock ( LockConfiguration lockConfiguration ) { synchronized ( locks ) { locks . put ( lockConfiguration . getName ( ) , new LockRecord ( lockConfiguration . getLockAtLeastUntil ( ) ) ) ; logger . debug ( " Unlocked ▁ { } " , lockConfiguration ) ; } }
lukas-krecan/ShedLock | private Optional < SimpleLock > doExtend ( LockConfiguration newConfiguration ) { synchronized ( locks ) { String lockName = newConfiguration . getName ( ) ; if ( isLocked ( lockName ) ) { locks . put ( lockName , new LockRecord ( newConfiguration . getLockAtMostUntil ( ) ) ) ; logger . debug ( " Extended ▁ { } " , newConfiguration ) ; return Optional . of ( new InMemoryLock ( newConfiguration ) ) ; } else { return Optional . empty ( ) ; } } }
lukas-krecan/ShedLock | private LockRecord ( Instant lockedUntil ) { this . lockedUntil = lockedUntil ; }
lukas-krecan/ShedLock | private InMemoryLock ( LockConfiguration lockConfiguration ) { super ( lockConfiguration ) ; }
lukas-krecan/ShedLock | @ Override protected void doUnlock ( ) { InMemoryLockProvider . this . doUnlock ( lockConfiguration ) ; }
lukas-krecan/ShedLock | @ Override protected Optional < SimpleLock > doExtend ( LockConfiguration newConfiguration ) { return InMemoryLockProvider . this . doExtend ( newConfiguration ) ; }
apache/incubator-asterixdb | private ArrayRepeatTypeComputer ( ) { }
apache/incubator-asterixdb | @ Override protected IAType getResultType ( ILogicalExpression expr , IAType ... strippedInputTypes ) throws AlgebricksException { return AUnionType . createNullableType ( new AOrderedListType ( strippedInputTypes [ 0 ] , null ) ) ; }
Sausageo/jmeter-plugins | public void show ( Component component , String message , String title , int messageType ) { JOptionPane . showMessageDialog ( component , message , title , messageType ) ; }
jansorg/BashSupport | private final MockFunction parserFunction = new MockFunction ( ) { @ Override public boolean apply ( BashPsiBuilder psi ) { ReadCommand d = new ReadCommand ( ) ; return d . parseIfValid ( psi ) . isParsedSuccessfully ( ) ; } }
jansorg/BashSupport | @ Test public void testIsValid ( ) { mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD ) ; mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , WORD ) ; mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , WORD , WORD , WORD ) ; mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , WORD , ASSIGNMENT_WORD , LEFT_SQUARE , WORD , RIGHT_SQUARE ) ; }
jansorg/BashSupport | @ Test public void testIssue125 ( ) throws Exception { mockTest ( parserFunction , Lists . newArrayList ( " read " ) , WORD , STRING2 , ASSIGNMENT_WORD , LEFT_SQUARE , ARITH_NUMBER , RIGHT_SQUARE ) ; }
jansorg/BashSupport | @ Test public void testBuiltin ( ) { LanguageBuiltins . localVarDefCommands . contains ( " read " ) ; }
google/fest | private Pause ( ) { }
TM00/MarkingAssistant | @ FXML void configureButtonPressed ( ActionEvent event ) { final Stage dialog = new Stage ( ) ; dialog . initModality ( Modality . WINDOW_MODAL ) ; dialog . initOwner ( Main . primaryStage ) ; dialog . setTitle ( " Exam ▁ Configurations " ) ; dialog . getIcons ( ) . addAll ( ResourceLoader . getIcons ( " check _ mark . ico " ) ) ; dialog . setX ( Main . primaryStage . getX ( ) ) ; dialog . setY ( Main . primaryStage . getY ( ) + Main . primaryStage . getWidth ( ) / 2 ) ; try { FXMLLoader fxmlLoader = new FXMLLoader ( this . getClass ( ) . getResource ( " ConfigureGui . fxml " ) ) ; AnchorPane page = ( AnchorPane ) fxmlLoader . load ( ) ; ConfigureController fooController = ( ConfigureController ) fxmlLoader . getController ( ) ; fooController . setStage ( dialog ) ; fooController . setParent ( this ) ; fooController . loadData ( ) ; Scene dialogScene = new Scene ( page ) ; dialog . setScene ( dialogScene ) ; dialog . show ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
TM00/MarkingAssistant | public void doneConfiguring ( ) { System . out . println ( " Done ▁ with ▁ configure . . . " ) ; ExamExcelHandler . loadConstantsFromConfigData ( ) ; loadExcelFile ( ) ; }
TM00/MarkingAssistant | @ FXML void chooseFilePressed ( ActionEvent event ) { File f = ExamExcelHandler . getFile ( ) ; chooseFileButton . setText ( f . getName ( ) ) ; filePath = f . getAbsolutePath ( ) ; ExamExcelHandler . setFilePath_to_excel ( filePath ) ; ExamExcelHandler . loadConstantsFromConfigData ( ) ; list = ExamExcelHandler . readExamStudentListFromFile ( ) ; autoTex . getEntries ( ) . addAll ( list . getObservableList ( ) ) ; autoTex . setCaseSensitive ( false ) ; }
TM00/MarkingAssistant | @ FXML void addMarkPressed ( ActionEvent event ) { String selected = autoTex . getText ( ) ; ExamStudent student = list . getStudent ( selected ) ; if ( student != null ) { int counter = 0 ; ConfigListData dat , total = null ; for ( StudentExamListData studentExamListData : data ) { student . setMark ( studentExamListData . getQuestionNumber ( ) + " " , studentExamListData . getMark ( ) ) ; dat = Main . configData . questionData . get ( counter ) ; System . out . println ( " name ▁ = ▁ " + dat . getName ( ) ) ; if ( ! dat . getName ( ) . equals ( " TOTAL " ) && Main . configData . writeQuestions ) { excelView . setCellValue ( student . getRowNumber ( ) , ExcelUtils . getExcelColumnIndex ( dat . getExcelColumn ( ) ) , studentExamListData . getMark ( ) + " " ) ; } counter ++ ; } for ( ConfigListData d : Main . configData . questionData ) { if ( d . getName ( ) . equals ( " TOTAL " ) ) { total = Main . configData . questionData . get ( counter ) ; break ; } } if ( Main . configData . writeTotal && total != null ) { excelView . setCellValue ( student . getRowNumber ( ) , ExcelUtils . getExcelColumnIndex ( total . getExcelColumn ( ) ) , student . getTotalMark ( ) + " " ) ; } double percentage = student . getTotalMark ( ) / Main . configData . totalPaper * 100 ; DecimalFormat df = new DecimalFormat ( " # # . 0" ) ; infoText . appendText ( " Total ▁ for ▁ " + student . getStudentNumber ( ) + " ▁ = ▁ " + student . getTotalMark ( ) + " \n " ) ; infoText . appendText ( " \t ▁ Percentage ▁ = ▁ " + df . format ( percentage ) + " ▁ % ▁ " + " \n \n " ) ; autoTex . setText ( " " ) ; autoTex . requestFocus ( ) ; } else { displayText ( " No ▁ student ▁ found ▁ by ▁ the ▁ name ▁ " + selected + " ▁ try ▁ again " , false ) ; } }
TM00/MarkingAssistant | @ FXML void writeMarks ( ActionEvent event ) { if ( Main . settings . playLoadingSound ) SoundPlayer . startLoopSound ( ) ; Alert alert = new Alert ( AlertType . INFORMATION ) ; alert . setTitle ( " Busy ▁ Writing " ) ; alert . setHeaderText ( " Please ▁ wait . . . " ) ; File f = ResourceLoader . getRandomGif ( ) ; Image image ; try { image = new Image ( f . toURI ( ) . toURL ( ) . toString ( ) ) ; ImageView view = new ImageView ( image ) ; alert . setGraphic ( view ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } alert . getDialogPane ( ) . lookupButton ( ButtonType . OK ) . setDisable ( true ) ; Stage stage1 = ( Stage ) alert . getDialogPane ( ) . getScene ( ) . getWindow ( ) ; stage1 . getIcons ( ) . addAll ( ResourceLoader . getIcons ( " check _ mark . ico " ) ) ; alert . setX ( Main . primaryStage . getX ( ) ) ; alert . setY ( Main . primaryStage . getY ( ) + Main . primaryStage . getWidth ( ) / 2 ) ; alert . show ( ) ; Task < Integer > task = new Task < Integer > ( ) { @ Override protected Integer call ( ) throws Exception { System . out . println ( " Started " ) ; ExamExcelHandler . writeExamStudentMarksToFile ( list , Main . configData . writeQuestions , Main . configData . writeTotal ) ; System . out . println ( " DONE ! ! " ) ; displayText ( " Succesfully ▁ written ▁ to ▁ the ▁ file . . . " , true ) ; displayText ( " Total ▁ students ▁ marked ▁ = ▁ " + list . numMarked ( ) , true ) ; return new Integer ( 2 ) ; } @ Override protected void succeeded ( ) { super . succeeded ( ) ; updateMessage ( " Done ! " ) ; System . out . println ( " Done ! " ) ; Platform . runLater ( ( ) -> { SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void cancelled ( ) { super . cancelled ( ) ; updateMessage ( " Cancelled ! " ) ; System . out . println ( " Cancelled " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void failed ( ) { super . failed ( ) ; updateMessage ( " Failed ! " ) ; System . out . println ( " Failed " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } } ; Thread th = new Thread ( task ) ; th . setDaemon ( false ) ; th . start ( ) ; }
TM00/MarkingAssistant | @ FXML void initialize ( ) { assert hBoxContainer != null : " fx : id = \" hBoxContainer \" ▁ was ▁ not ▁ injected : ▁ check ▁ your ▁ FXML ▁ file ▁ ' Gui . fxml ' . " ; assert marksListView != null : " fx : id = \" marksListView \" ▁ was ▁ not ▁ injected : ▁ check ▁ your ▁ FXML ▁ file ▁ ' Gui . fxml ' . " ; Main . createMenu ( menu ) ; Menu fileMenu = OtherUtils . getMenuFromBar ( menu , " File " ) ; if ( fileMenu != null ) { MenuItem choose = new MenuItem ( " Choose ▁ File " ) ; choose . setAccelerator ( KeyCombination . keyCombination ( " Ctrl + O " ) ) ; choose . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { chooseFilePressed ( null ) ; } } ) ; fileMenu . getItems ( ) . add ( 0 , choose ) ; } Menu EditMenu = OtherUtils . getMenuFromBar ( menu , " Edit " ) ; if ( EditMenu != null ) { MenuItem config = new MenuItem ( " Configure " ) ; config . setAccelerator ( KeyCombination . keyCombination ( " Ctrl + C " ) ) ; config . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { configureButtonPressed ( null ) ; } } ) ; MenuItem refresh = new MenuItem ( " Refresh ▁ data " ) ; refresh . setAccelerator ( KeyCombination . keyCombination ( " Ctrl + R " ) ) ; refresh . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { loadExcelFile ( ) ; } } ) ; EditMenu . getItems ( ) . add ( 0 , config ) ; EditMenu . getItems ( ) . add ( 1 , refresh ) ; } Menu helpMenu = OtherUtils . getMenuFromBar ( menu , " Help " ) ; if ( helpMenu != null ) { MenuItem help = new MenuItem ( " How ▁ to ▁ use " ) ; help . setAccelerator ( KeyCombination . keyCombination ( " Shortcut + H " ) ) ; help . setOnAction ( new EventHandler < ActionEvent > ( ) { public void handle ( ActionEvent t ) { Main . showHelp ( getHelpString ( ) ) ; } } ) ; helpMenu . getItems ( ) . add ( 0 , help ) ; } autoTex . addCustomHandler ( this ) ; hBoxContainer . getChildren ( ) . addAll ( autoTex ) ; mainPane . setOnDragOver ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { event . acceptTransferModes ( TransferMode . COPY ) ; event . consume ( ) ; } } ) ; mainPane . setOnDragEntered ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { event . consume ( ) ; } } ) ; mainPane . setOnDragExited ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { event . consume ( ) ; } } ) ; mainPane . setOnDragDropped ( new EventHandler < DragEvent > ( ) { @ Override public void handle ( DragEvent event ) { Dragboard db = event . getDragboard ( ) ; boolean success = false ; if ( db . hasFiles ( ) ) { success = true ; if ( db . getFiles ( ) . size ( ) == 1 ) { File file = db . getFiles ( ) . get ( 0 ) ; chooseFileButton . setText ( file . getName ( ) ) ; filePath = file . getAbsolutePath ( ) ; System . out . println ( filePath ) ; displayExcelView ( ) ; } } event . setDropCompleted ( success ) ; event . consume ( ) ; } } ) ; this . infoText . setFocusTraversable ( false ) ; this . chooseFileButton . setFocusTraversable ( false ) ; this . autoTex . requestFocus ( ) ; ExamStudent . outText = this ; String def = " Welcome ▁ to ▁ the ▁ exam ▁ mark ▁ logging ▁ program ! ! \n " + " This ▁ program ▁ lets ▁ you ▁ log ▁ marks ▁ for ▁ different \n " + " questions ▁ to ▁ an ▁ excel ▁ file \n " + " HOW ▁ IT ▁ WORKS : ▁ You ▁ first ▁ need ▁ to ▁ create ▁ the ▁ column ( s ) ▁ you ▁ want ▁ the ▁ marks ▁ to ▁ be ▁ entered ▁ in ▁ in ▁ your ▁ excel ▁ file . " + " Then ▁ close ▁ the ▁ excel ▁ file . ▁ Drag ▁ and ▁ drop ▁ the ▁ selected ▁ excel ▁ file ▁ to ▁ which ▁ the ▁ marks ▁ should ▁ be ▁ added . ▁ " + " \n ▁ After ▁ loading ▁ the ▁ file , ▁ a ▁ display ▁ of ▁ the ▁ file ▁ should ▁ open . ▁ Now ▁ you ▁ mus ▁ press ▁ the ▁ configure ▁ buttom ▁ to " + " ▁ tell ▁ the ▁ program ▁ where ▁ the ▁ marks ▁ should ▁ go ▁ and ▁ how ▁ to ▁ locate ▁ the ▁ candiates ▁ with ▁ their ▁ details . ▁ Press ▁ save ▁ & ▁ Return ▁ when ▁ you ' re ▁ done . " + " The ▁ student ▁ details ▁ are ▁ now ▁ read ▁ by ▁ the ▁ program . ▁ You ▁ may ▁ continue ▁ to ▁ enter ▁ the ▁ student ▁ name / number ▁ " + " and ▁ select ▁ one ▁ of ▁ the ▁ suggestions ▁ by ▁ pressing ▁ the ▁ ENTER ▁ key . ▁ Now ▁ you ▁ can ▁ enter ▁ that ▁ student ' s ▁ marks ▁ for ▁ each ▁ question ▁ in ▁ the ▁ table " + " below ▁ and ▁ press ▁ the ▁ \" Add ▁ Mark \" ▁ button ▁ to ▁ load ▁ in ▁ into ▁ the ▁ program . ▁ This ▁ mark ▁ will ▁ not ▁ be ▁ added ▁ into ▁ the ▁ Excel ▁ file ▁ yet , ▁ so ▁ you ▁ can ▁ simply " + " ▁ re - enter ▁ it ▁ if ▁ you ▁ made ▁ a ▁ mistake . \n " + " After ▁ adding ▁ the ▁ marks , ▁ press ▁ the ▁ \" Write ▁ to ▁ file \" ▁ button ▁ to ▁ export ▁ the ▁ newly ▁ added ▁ student ▁ data ▁ to ▁ the " + " excel ▁ file . ▁ This ▁ may ▁ take ▁ a ▁ while ▁ depending ▁ on ▁ the ▁ amount ▁ of ▁ students \n " + " FYI ▁ the ▁ excel ▁ file ▁ should ▁ be ▁ in ▁ a ▁ specific ▁ format ▁ such ▁ as ▁ the ▁ one ▁ from ▁ the ▁ example . ▁ Also ▁ keep ▁ a ▁ copy ▁ of ▁ the ▁ file ▁ in ▁ case ▁ something ▁ goes ▁ wrong ▁ and ▁ avoid ▁ losing ▁ the ▁ file . ▁ " + " Additional ▁ settings ▁ can ▁ be ▁ set ▁ " + " by ▁ using ▁ the ▁ settings ▁ menu . ▁ \n \n " ; this . infoText . setText ( def ) ; }
TM00/MarkingAssistant | private void reFreshData ( ) { ArrayList < ConfigListData > d = Main . configData . questionData ; data = FXCollections . observableArrayList ( ) ; data . clear ( ) ; for ( ConfigListData c : d ) { if ( ! c . getName ( ) . equals ( " TOTAL " ) ) data . add ( new StudentExamListData ( c . getNumber ( ) , c . getName ( ) ) ) ; } }
TM00/MarkingAssistant | private void setupListView ( ) { reFreshData ( ) ; marksListView . setItems ( data ) ; marksListView . setCellFactory ( new Callback < ListView < StudentExamListData > , ListCell < StudentExamListData > > ( ) { @ Override public ListCell < StudentExamListData > call ( ListView < StudentExamListData > arg0 ) { return new ListCell < StudentExamListData > ( ) { @ Override protected void updateItem ( StudentExamListData item , boolean bln ) { super . updateItem ( item , bln ) ; if ( item != null ) { Label number = new Label ( item . getQuestionNumber ( ) + " " ) ; Label name = new Label ( item . getDescription ( ) + " " ) ; TextField col = new TextField ( " " ) ; col . setOnKeyReleased ( new EventHandler < Event > ( ) { @ Override public void handle ( Event arg0 ) { try { item . setMark ( Double . parseDouble ( col . getText ( ) ) ) ; } catch ( NumberFormatException e ) { } } } ) ; number . setPrefWidth ( 30 ) ; name . setPrefWidth ( 90 ) ; col . setPrefWidth ( 30 ) ; HBox hBox = new HBox ( number , name , col ) ; hBox . setSpacing ( 10 ) ; hBox . setAlignment ( Pos . CENTER ) ; setGraphic ( hBox ) ; } } } ; } } ) ; marksListView . requestFocus ( ) ; }
TM00/MarkingAssistant | @ Override public void displayText ( String text , boolean doublenl ) { infoText . appendText ( text + " \n " ) ; if ( doublenl ) { infoText . appendText ( " \n " ) ; } }
TM00/MarkingAssistant | private void loadExcelFile ( ) { if ( Main . settings . playLoadingSound ) SoundPlayer . startLoopSound ( ) ; Alert alert = new Alert ( AlertType . INFORMATION ) ; alert . setTitle ( " Busy ▁ Reading " ) ; alert . setHeaderText ( " Please ▁ wait . . . " ) ; File f = ResourceLoader . getRandomGif ( ) ; Image image ; try { image = new Image ( f . toURI ( ) . toURL ( ) . toString ( ) ) ; ImageView view = new ImageView ( image ) ; alert . setGraphic ( view ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } alert . getDialogPane ( ) . lookupButton ( ButtonType . OK ) . setDisable ( true ) ; Stage stage1 = ( Stage ) alert . getDialogPane ( ) . getScene ( ) . getWindow ( ) ; stage1 . getIcons ( ) . addAll ( ResourceLoader . getIcons ( " check _ mark . ico " ) ) ; alert . setX ( Main . primaryStage . getX ( ) ) ; alert . setY ( Main . primaryStage . getY ( ) + Main . primaryStage . getWidth ( ) / 2 ) ; alert . show ( ) ; Task < Integer > task = new Task < Integer > ( ) { @ Override protected Integer call ( ) throws Exception { System . out . println ( " Started " ) ; ExamExcelHandler . setFilePath_to_excel ( filePath ) ; System . out . println ( "1 . . . " ) ; ExamExcelHandler . loadConstantsFromConfigData ( ) ; System . out . println ( "2 . . . " ) ; list = ExamExcelHandler . readExamStudentListFromFile ( ) ; System . out . println ( "3 . . . " ) ; autoTex . getEntries ( ) . addAll ( list . getObservableList ( ) ) ; autoTex . setCaseSensitive ( false ) ; if ( excelView == null ) { excelView = new ExcelView ( filePath , 0 , false ) ; excelView . showInNewWindow ( ) ; } else { try { excelView . updateView ( ) ; } catch ( Exception e ) { displayText ( " An ▁ error ▁ occured ▁ while ▁ updating ▁ the ▁ Spreadsheet " , false ) ; e . printStackTrace ( ) ; } } return new Integer ( 2 ) ; } @ Override protected void succeeded ( ) { super . succeeded ( ) ; updateMessage ( " Done ! " ) ; System . out . println ( " Done ! " ) ; Platform . runLater ( ( ) -> { SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void cancelled ( ) { super . cancelled ( ) ; updateMessage ( " Cancelled ! " ) ; System . out . println ( " Cancelled " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } @ Override protected void failed ( ) { super . failed ( ) ; updateMessage ( " Failed ! " ) ; System . out . println ( " Failed " ) ; Platform . runLater ( ( ) -> { infoText . appendText ( " \n An ▁ error ▁ ocurred ▁ " ) ; SoundPlayer . stopPlayingSound ( ) ; alert . close ( ) ; } ) ; } } ; Thread th = new Thread ( task ) ; th . setDaemon ( false ) ; th . start ( ) ; }
TM00/MarkingAssistant | private void displayExcelView ( ) { if ( excelView == null ) { excelView = new ExcelView ( filePath , 0 , false ) ; excelView . showInNewWindow ( ) ; } else { try { excelView . updateView ( ) ; } catch ( Exception e ) { displayText ( " An ▁ error ▁ occured ▁ while ▁ updating ▁ the ▁ Spreadsheet " , false ) ; e . printStackTrace ( ) ; } } }
TM00/MarkingAssistant | private String getHelpString ( ) { String s = " " ; s += " Welcome ▁ to ▁ the ▁ Written ▁ help ▁ page ! \n \n " ; s += " To ▁ use ▁ the ▁ software , ▁ follow ▁ these ▁ steps " ; s += "1 . ▁ Make ▁ sure ▁ the ▁ column ▁ you ▁ want ▁ to ▁ capture ▁ the ▁ marks ▁ to ▁ have ▁ been ▁ created ▁ in ▁ your ▁ Excel ▁ file \n \n " ; s += "2 . ▁ Make ▁ sure ▁ your ▁ Excel ▁ file ▁ is ▁ closed ▁ and ▁ backed ▁ up ▁ to ▁ avoid ▁ corrupting ▁ the ▁ file \n \n " ; s += "3 . ▁ Drag ▁ and ▁ drop ▁ your ▁ Excel ▁ file ▁ anywhere ▁ into ▁ the ▁ window , ▁ after ▁ the ▁ drop ▁ a ▁ loading ▁ bar ▁ will ▁ appear \n \n " ; s += "4 . ▁ A ▁ uneditable ▁ preview ▁ of ▁ the ▁ file ▁ will ▁ open , ▁ this ▁ may ▁ stay ▁ open ▁ during ▁ the ▁ capturing . ▁ Press ▁ the ▁ \" Configure \" ▁ button ▁ and ▁ a ▁ new ▁ window ▁ will ▁ pop ▁ up \n \n " ; s += "5 . ▁ Enter ▁ the ▁ column ▁ letters ▁ where ▁ the ▁ specific ▁ information ▁ is ▁ located ▁ in ▁ your ▁ file , ▁ you ▁ may ▁ scroll ▁ the ▁ preview ▁ to ▁ search ▁ where ▁ the ▁ info ▁ is . ▁ " + " If ▁ not ▁ all ▁ the ▁ info ▁ is ▁ present , ▁ don ' t ▁ panic , ▁ only ▁ the ▁ student ▁ number ▁ and ▁ surname ▁ letters ▁ are ▁ essential . ▁ You ▁ may ▁ simply ▁ enter ▁ dummy ▁ letters ▁ to ▁ the ▁ rest . ▁ " + " The ▁ row ▁ number ▁ is ▁ the ▁ number ▁ of ▁ the ▁ row ▁ ( indicated ▁ on ▁ the ▁ left ▁ on ▁ the ▁ preview ) ▁ where ▁ the ▁ first ▁ student ▁ information ▁ is ▁ stored ▁ after ▁ all ▁ the ▁ headings ▁ etc . \n \n " ; s += "6 . ▁ Press ▁ \" Save ▁ and ▁ Return \" . ▁ The ▁ number ▁ of ▁ students ▁ recorded ▁ will ▁ be ▁ indicated ▁ in ▁ the ▁ prompt , ▁ or ▁ inform ▁ you ▁ when ▁ an ▁ error ▁ has ▁ occured \n \n " ; s += "7 . ▁ Nou ▁ you ▁ may ▁ capture ▁ the ▁ marks ▁ by ▁ searching ▁ for ▁ the ▁ students ▁ by ▁ surname ▁ or ▁ number ▁ in ▁ the ▁ \" search ▁ student \" ▁ field . ▁ Suggestions ▁ will ▁ appear ▁ and ▁ you ▁ can ▁ scroll " + " ▁ with ▁ the ▁ arrow ▁ keys ▁ or ▁ mouse ▁ and ▁ select ▁ with ▁ the ▁ ENTER ▁ key ▁ or ▁ double ▁ mouse ▁ click \n \n " ; s += "8 . ▁ After ▁ the ▁ student ▁ is ▁ located ▁ the ▁ mark ▁ can ▁ be ▁ entered ▁ in ▁ the ▁ \" Enter ▁ mark \" ▁ field \n \n " ; s += "9 . ▁ Repeat ▁ steps ▁ 7 ▁ and ▁ 8 ▁ for ▁ all ▁ the ▁ written ▁ tests \n \n " ; s += "10 . ▁ After ▁ all ▁ the ▁ marks ▁ have ▁ been ▁ entered , ▁ press ▁ the ▁ \" Write ▁ marks ▁ to ▁ file \" ▁ button ▁ to ▁ export ▁ all ▁ the ▁ captures ▁ marks ▁ to ▁ the ▁ Excel ▁ file ▁ and ▁ voila , ▁ you ' re ▁ done ▁ : ) " ; return s ; }
TM00/MarkingAssistant | @ Override public void handleCustonTextEvent ( String description ) { System . err . println ( " Exam ▁ reporting ▁ for ▁ actions . . . ▁ from ▁ handleCustonTextEvent ▁ des : ▁ " + description ) ; setupListView ( ) ; }
barcellosLuizFernando/fechamento | public CadUsuarios2 ( ConexaoMySQL conn ) { initComponents ( ) ; this . cn = conn ; }
barcellosLuizFernando/fechamento | public void MontaLista ( ) { if ( ! " " . equals ( txtPesquisar . getText ( ) ) ) { lista . setColumnCount ( 0 ) ; lista . setRowCount ( 0 ) ; cn . iniciarTransacao ( ) ; String sql = " SELECT ▁ * ▁ FROM ▁ cad _ usuario ▁ " + " WHERE ▁ UPPER ( nome ) ▁ " + " LIKE ▁ ' % " + txtPesquisar . getText ( ) . toUpperCase ( ) + " % ' ▁ OR ▁ departamento ▁ " + " LIKE ▁ ' % " + txtPesquisar . getText ( ) + " % ' " + " ▁ ORDER ▁ BY ▁ nome " ; cn . executeConsulta ( sql ) ; lista . addColumn ( " Código " ) ; lista . addColumn ( " Nome " ) ; lista . addColumn ( " Departamento " ) ; lista . addColumn ( " Função " ) ; lista . addColumn ( " Login " ) ; try { while ( cn . rs . next ( ) ) { lista . addRow ( new String [ ] { cn . rs . getString ( " codigo " ) , cn . rs . getString ( " nome " ) , cn . rs . getString ( " departamento " ) , cn . rs . getString ( " funcao " ) , cn . rs . getString ( " login " ) } ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , " Erro ▁ ao ▁ consultar ▁ o ▁ banco ▁ de ▁ dados : ▁ " + ex ) ; } cn . finalizarTransacao ( ) ; tabCadUser . setModel ( lista ) ; } else { lista . setColumnCount ( 0 ) ; lista . setRowCount ( 0 ) ; tabCadUser . setModel ( lista ) ; btnEditarUser . setEnabled ( false ) ; btnCadastrarUser . setEnabled ( true ) ; } }
barcellosLuizFernando/fechamento | public void Selecao ( ) { int linha = tabCadUser . getSelectedRow ( ) ; txtCodUser . setText ( tabCadUser . getValueAt ( linha , 0 ) . toString ( ) ) ; txtNomeUser . setText ( tabCadUser . getValueAt ( linha , 1 ) . toString ( ) ) ; txtDptoUser . setText ( tabCadUser . getValueAt ( linha , 2 ) . toString ( ) ) ; txtFuncUser . setText ( tabCadUser . getValueAt ( linha , 3 ) . toString ( ) ) ; txtLoginUser . setText ( tabCadUser . getValueAt ( linha , 4 ) . toString ( ) ) ; }
barcellosLuizFernando/fechamento | private void initComponents ( ) { jScrollPane1 = new javax . swing . JScrollPane ( ) ; jTable1 = new javax . swing . JTable ( ) ; jScrollPane3 = new javax . swing . JScrollPane ( ) ; jTable2 = new javax . swing . JTable ( ) ; jPanel1 = new javax . swing . JPanel ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; jLabel2 = new javax . swing . JLabel ( ) ; jLabel3 = new javax . swing . JLabel ( ) ; txtDptoUser = new javax . swing . JTextField ( ) ; txtFuncUser = new javax . swing . JTextField ( ) ; jLabel4 = new javax . swing . JLabel ( ) ; txtNomeUser = new javax . swing . JTextField ( ) ; txtCodUser = new javax . swing . JLabel ( ) ; txtLoginUser = new javax . swing . JTextField ( ) ; jLabel6 = new javax . swing . JLabel ( ) ; jLabel7 = new javax . swing . JLabel ( ) ; txtPesquisar = new javax . swing . JTextField ( ) ; btnCadastrarUser = new javax . swing . JButton ( ) ; btnGravarUser = new javax . swing . JButton ( ) ; btnCancelarUser = new javax . swing . JButton ( ) ; btnEditarUser = new javax . swing . JButton ( ) ; txtSenhaUser = new javax . swing . JPasswordField ( ) ; jLabel8 = new javax . swing . JLabel ( ) ; txtAtivoUser = new javax . swing . JComboBox ( ) ; jLabel5 = new javax . swing . JLabel ( ) ; txtStatus = new javax . swing . JLabel ( ) ; jScrollPane2 = new javax . swing . JScrollPane ( ) ; tabCadUser = new javax . swing . JTable ( ) ; jTable1 . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { { null , null , null , null } , { null , null , null , null } , { null , null , null , null } , { null , null , null , null } } , new String [ ] { " Title ▁ 1" , " Title ▁ 2" , " Title ▁ 3" , " Title ▁ 4" } ) ) ; jScrollPane1 . setViewportView ( jTable1 ) ; jTable2 . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { { null , null , null , null } , { null , null , null , null } , { null , null , null , null } , { null , null , null , null } } , new String [ ] { " Title ▁ 1" , " Title ▁ 2" , " Title ▁ 3" , " Title ▁ 4" } ) ) ; jScrollPane3 . setViewportView ( jTable2 ) ; setClosable ( true ) ; setIconifiable ( true ) ; setTitle ( " Cadastro ▁ de ▁ Usuários " ) ; setVisible ( true ) ; addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyPressed ( java . awt . event . KeyEvent evt ) { formKeyPressed ( evt ) ; } public void keyReleased ( java . awt . event . KeyEvent evt ) { formKeyReleased ( evt ) ; } } ) ; jLabel1 . setText ( " Nome " ) ; jLabel2 . setText ( " Departamento " ) ; jLabel3 . setText ( " Função " ) ; txtDptoUser . setEnabled ( false ) ; txtFuncUser . setEnabled ( false ) ; jLabel4 . setText ( " Código " ) ; txtNomeUser . setEnabled ( false ) ; txtCodUser . setText ( " ▁ " ) ; txtLoginUser . setEnabled ( false ) ; jLabel6 . setText ( " Login " ) ; jLabel7 . setText ( " Senha " ) ; txtPesquisar . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyReleased ( java . awt . event . KeyEvent evt ) { txtPesquisarKeyReleased ( evt ) ; } } ) ; btnCadastrarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Cadastrar . png " ) ) ) ; btnCadastrarUser . setText ( " Cadastrar " ) ; btnCadastrarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnCadastrarUserActionPerformed ( evt ) ; } } ) ; btnGravarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Gravar . png " ) ) ) ; btnGravarUser . setText ( " Gravar " ) ; btnGravarUser . setEnabled ( false ) ; btnGravarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnGravarUserActionPerformed ( evt ) ; } } ) ; btnCancelarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Cancelar . png " ) ) ) ; btnCancelarUser . setText ( " Cancelar " ) ; btnCancelarUser . setEnabled ( false ) ; btnCancelarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnCancelarUserActionPerformed ( evt ) ; } } ) ; btnEditarUser . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / img / Editar . png " ) ) ) ; btnEditarUser . setText ( " Editar " ) ; btnEditarUser . setEnabled ( false ) ; btnEditarUser . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnEditarUserActionPerformed ( evt ) ; } } ) ; txtSenhaUser . setEnabled ( false ) ; jLabel8 . setText ( " Ativo " ) ; txtAtivoUser . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { " S " , " N " } ) ) ; txtAtivoUser . setEnabled ( false ) ; txtAtivoUser . setFocusable ( false ) ; jLabel5 . setText ( " Status " ) ; txtStatus . setText ( " ▁ " ) ; javax . swing . GroupLayout jPanel1Layout = new javax . swing . GroupLayout ( jPanel1 ) ; jPanel1 . setLayout ( jPanel1Layout ) ; jPanel1Layout . setHorizontalGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel1 ) . addGap ( 18 , 18 , 18 ) . addComponent ( txtNomeUser ) ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel4 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( txtCodUser ) . addGap ( 80 , 80 , 80 ) . addComponent ( jLabel5 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( txtStatus ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addComponent ( jLabel8 ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( txtAtivoUser , javax . swing . GroupLayout . PREFERRED_SIZE , 45 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING , false ) . addGroup ( javax . swing . GroupLayout . Alignment . LEADING , jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel6 ) . addGap ( 18 , 18 , 18 ) . addComponent ( txtLoginUser ) ) . addGroup ( javax . swing . GroupLayout . Alignment . LEADING , jPanel1Layout . createSequentialGroup ( ) . addComponent ( jLabel2 ) . addGap ( 19 , 19 , 19 ) . addComponent ( txtDptoUser , javax . swing . GroupLayout . PREFERRED_SIZE , 131 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( jLabel3 ) . addComponent ( jLabel7 ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addComponent ( txtFuncUser , javax . swing . GroupLayout . PREFERRED_SIZE , 167 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) . addComponent ( txtSenhaUser ) ) ) ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , jPanel1Layout . createSequentialGroup ( ) . addGap ( 10 , 10 , 10 ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , jPanel1Layout . createSequentialGroup ( ) . addComponent ( txtPesquisar ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btnCadastrarUser ) ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , jPanel1Layout . createSequentialGroup ( ) . addGap ( 0 , 0 , Short . MAX_VALUE ) . addComponent ( btnEditarUser ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btnCancelarUser ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( btnGravarUser ) ) ) ) ) . addContainerGap ( ) ) ) ; jPanel1Layout . setVerticalGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( jPanel1Layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( btnCadastrarUser ) . addComponent ( txtPesquisar , javax . swing . GroupLayout . PREFERRED_SIZE , 31 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel4 ) . addComponent ( txtCodUser ) . addComponent ( jLabel8 ) . addComponent ( txtAtivoUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jLabel5 ) . addComponent ( txtStatus ) ) . addGap ( 18 , 18 , 18 ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel1 ) . addComponent ( txtNomeUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addGap ( 18 , 18 , 18 ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel2 ) . addComponent ( txtDptoUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jLabel3 ) . addComponent ( txtFuncUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , 18 , Short . MAX_VALUE ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( jLabel6 ) . addComponent ( txtLoginUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jLabel7 ) . addComponent ( txtSenhaUser , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( jPanel1Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( btnGravarUser ) . addComponent ( btnCancelarUser ) . addComponent ( btnEditarUser ) ) . addContainerGap ( ) ) ) ; tabCadUser . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { } , new String [ ] { } ) ) ; tabCadUser . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mouseClicked ( java . awt . event . MouseEvent evt ) { tabCadUserMouseClicked ( evt ) ; } } ) ; tabCadUser . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyReleased ( java . awt . event . KeyEvent evt ) { tabCadUserKeyReleased ( evt ) ; } } ) ; jScrollPane2 . setViewportView ( tabCadUser ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jPanel1 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( jScrollPane2 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( jPanel1 , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( jScrollPane2 , javax . swing . GroupLayout . PREFERRED_SIZE , 165 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ) ; pack ( ) ; }
barcellosLuizFernando/fechamento | private void btnGravarUserActionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! " " . equals ( txtDptoUser . getText ( ) ) && ! " " . equals ( txtFuncUser . getText ( ) ) && ! " " . equals ( txtLoginUser . getText ( ) ) && ! " " . equals ( txtNomeUser . getText ( ) ) ) { String dptoUser = txtDptoUser . getText ( ) ; String funcaoUser = txtFuncUser . getText ( ) ; String loginUser = txtLoginUser . getText ( ) ; String nomeUser = txtNomeUser . getText ( ) ; String senhaUser = new String ( this . txtSenhaUser . getPassword ( ) ) ; String ativoUser = txtAtivoUser . getSelectedItem ( ) . toString ( ) ; cn . iniciarTransacao ( ) ; if ( txtStatus . getText ( ) == " CADASTRANDO " ) { String sql = " INSERT ▁ INTO ▁ CAD _ USUARIO ▁ ( NOME , ▁ DEPARTAMENTO , ▁ FUNCAO , ▁ ATIVO , ▁ LOGIN , ▁ SENHA ) ▁ VALUES ▁ ( ' " + nomeUser + " ' , ' " + dptoUser + " ' , ' " + funcaoUser + " ' , ' " + ativoUser + " ' , ' " + loginUser + " ' , ' " + senhaUser + " ' ) " ; cn . executeAtualizacao ( sql ) ; } else { String sql = " UPDATE ▁ CAD _ USUARIO ▁ SET ▁ NOME ▁ = ▁ ' " + nomeUser + " ' , ▁ DEPARTAMENTO ▁ = ▁ ' " + dptoUser + " ' , ▁ FUNCAO ▁ = ▁ ' " + funcaoUser + " ' , ▁ ATIVO ▁ = ▁ ' " + ativoUser + " ' ▁ WHERE ▁ codigo ▁ = ▁ " + Integer . parseInt ( txtCodUser . getText ( ) ) ; cn . executeAtualizacao ( sql ) ; } cn . finalizarTransacao ( ) ; txtDptoUser . setText ( " " ) ; txtFuncUser . setText ( " " ) ; txtLoginUser . setText ( " " ) ; txtNomeUser . setText ( " " ) ; txtSenhaUser . setText ( " " ) ; txtAtivoUser . setToolTipText ( " " ) ; txtCodUser . setText ( " ▁ " ) ; txtStatus . setText ( " " ) ; txtNomeUser . setEnabled ( false ) ; txtAtivoUser . setEnabled ( false ) ; txtDptoUser . setEnabled ( false ) ; txtLoginUser . setEnabled ( false ) ; txtFuncUser . setEnabled ( false ) ; txtNomeUser . setEnabled ( false ) ; txtPesquisar . setEnabled ( true ) ; btnEditarUser . setEnabled ( false ) ; btnGravarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( false ) ; btnCadastrarUser . setEnabled ( true ) ; MontaLista ( ) ; } else { JOptionPane . showMessageDialog ( rootPane , " Algum ▁ campo ▁ está ▁ em ▁ Branco . " ) ; } }
barcellosLuizFernando/fechamento | private void txtPesquisarKeyReleased ( java . awt . event . KeyEvent evt ) { MontaLista ( ) ; }
barcellosLuizFernando/fechamento | private void tabCadUserMouseClicked ( java . awt . event . MouseEvent evt ) { btnEditarUser . setEnabled ( true ) ; Selecao ( ) ; }
barcellosLuizFernando/fechamento | private void tabCadUserKeyReleased ( java . awt . event . KeyEvent evt ) { Selecao ( ) ; }
barcellosLuizFernando/fechamento | private void btnEditarUserActionPerformed ( java . awt . event . ActionEvent evt ) { txtNomeUser . setEnabled ( true ) ; txtAtivoUser . setEnabled ( true ) ; txtDptoUser . setEnabled ( true ) ; txtLoginUser . setEnabled ( true ) ; txtFuncUser . setEnabled ( true ) ; txtPesquisar . setEnabled ( false ) ; btnGravarUser . setEnabled ( true ) ; btnEditarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( true ) ; btnCadastrarUser . setEnabled ( false ) ; txtStatus . setText ( " EDITANDO " ) ; }
barcellosLuizFernando/fechamento | private void btnCancelarUserActionPerformed ( java . awt . event . ActionEvent evt ) { txtNomeUser . setEnabled ( false ) ; txtCodUser . setText ( " ▁ " ) ; txtAtivoUser . setEnabled ( false ) ; txtDptoUser . setEnabled ( false ) ; txtLoginUser . setEnabled ( false ) ; txtFuncUser . setEnabled ( false ) ; txtSenhaUser . setEnabled ( false ) ; txtStatus . setText ( " ▁ " ) ; txtPesquisar . setEnabled ( true ) ; btnGravarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( false ) ; btnEditarUser . setEnabled ( true ) ; btnCadastrarUser . setEnabled ( true ) ; MontaLista ( ) ; }
barcellosLuizFernando/fechamento | private void btnCadastrarUserActionPerformed ( java . awt . event . ActionEvent evt ) { txtNomeUser . setText ( " " ) ; txtCodUser . setText ( " NOVO " ) ; txtDptoUser . setText ( " " ) ; txtLoginUser . setText ( " " ) ; txtFuncUser . setText ( " " ) ; txtPesquisar . setText ( " " ) ; txtPesquisar . setEnabled ( false ) ; txtNomeUser . setEnabled ( true ) ; txtAtivoUser . setEnabled ( true ) ; txtDptoUser . setEnabled ( true ) ; txtLoginUser . setEnabled ( true ) ; txtFuncUser . setEnabled ( true ) ; txtSenhaUser . setEnabled ( true ) ; txtStatus . setText ( " CADASTRANDO " ) ; btnGravarUser . setEnabled ( true ) ; btnEditarUser . setEnabled ( false ) ; btnCancelarUser . setEnabled ( true ) ; btnCadastrarUser . setEnabled ( false ) ; }
barcellosLuizFernando/fechamento | private void formKeyPressed ( java . awt . event . KeyEvent evt ) { }
barcellosLuizFernando/fechamento | private void formKeyReleased ( java . awt . event . KeyEvent evt ) { }
Complexible/clearbit | public int getGlobalRank ( ) { return mGlobalRank ; }
Complexible/clearbit | public void setGlobalRank ( final int theGlobalRank ) { mGlobalRank = theGlobalRank ; }
Complexible/clearbit | public int getUsRank ( ) { return mUsRank ; }
Complexible/clearbit | public void setUsRank ( final int theUsRank ) { mUsRank = theUsRank ; }
Complexible/clearbit | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( " Alexa " ) . add ( " US ▁ Rank " , mUsRank ) . add ( " Global ▁ Rank " , mGlobalRank ) . toString ( ) ; }
Complexible/clearbit | @ Override public int hashCode ( ) { return Objects . hashCode ( mUsRank , mGlobalRank ) ; }
Complexible/clearbit | @ Override public boolean equals ( final Object theObj ) { if ( theObj == this ) { return true ; } else if ( theObj instanceof Alexa ) { Alexa aAlexa = ( Alexa ) theObj ; return mUsRank == aAlexa . mUsRank && mGlobalRank == aAlexa . mGlobalRank ; } else { return false ; } }
JSDemos/android-sdk-20 | public PhotoViewPager ( Context context ) { super ( context ) ; initialize ( ) ; }
JSDemos/android-sdk-20 | public PhotoViewPager ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; initialize ( ) ; }
JSDemos/android-sdk-20 | private void initialize ( ) { setPageTransformer ( true , new PageTransformer ( ) { @ Override public void transformPage ( View page , float position ) { if ( position < 0 || position >= 1.f ) { page . setTranslationX ( 0 ) ; page . setAlpha ( 1.f ) ; page . setScaleX ( 1 ) ; page . setScaleY ( 1 ) ; } else { page . setTranslationX ( - position * page . getWidth ( ) ) ; page . setAlpha ( Math . max ( 0 , 1.f - position ) ) ; final float scale = Math . max ( 0 , 1.f - position * 0.3f ) ; page . setScaleX ( scale ) ; page . setScaleY ( scale ) ; } } } ) ; }
JSDemos/android-sdk-20 | @ Override public boolean onInterceptTouchEvent ( MotionEvent ev ) { final InterceptType intercept = ( mListener != null ) ? mListener . onTouchIntercept ( mActivatedX , mActivatedY ) : InterceptType . NONE ; final boolean ignoreScrollLeft = ( intercept == InterceptType . BOTH || intercept == InterceptType . LEFT ) ; final boolean ignoreScrollRight = ( intercept == InterceptType . BOTH || intercept == InterceptType . RIGHT ) ; final int action = ev . getAction ( ) & MotionEventCompat . ACTION_MASK ; if ( action == MotionEvent . ACTION_CANCEL || action == MotionEvent . ACTION_UP ) { mActivePointerId = INVALID_POINTER ; } switch ( action ) { case MotionEvent . ACTION_MOVE : { if ( ignoreScrollLeft || ignoreScrollRight ) { final int activePointerId = mActivePointerId ; if ( activePointerId == INVALID_POINTER ) { break ; } final int pointerIndex = MotionEventCompat . findPointerIndex ( ev , activePointerId ) ; final float x = MotionEventCompat . getX ( ev , pointerIndex ) ; if ( ignoreScrollLeft && ignoreScrollRight ) { mLastMotionX = x ; return false ; } else if ( ignoreScrollLeft && ( x > mLastMotionX ) ) { mLastMotionX = x ; return false ; } else if ( ignoreScrollRight && ( x < mLastMotionX ) ) { mLastMotionX = x ; return false ; } } break ; } case MotionEvent . ACTION_DOWN : { mLastMotionX = ev . getX ( ) ; mActivatedX = ev . getRawX ( ) ; mActivatedY = ev . getRawY ( ) ; mActivePointerId = MotionEventCompat . getPointerId ( ev , 0 ) ; break ; } case MotionEventCompat . ACTION_POINTER_UP : { final int pointerIndex = MotionEventCompat . getActionIndex ( ev ) ; final int pointerId = MotionEventCompat . getPointerId ( ev , pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == 0 ? 1 : 0 ; mLastMotionX = MotionEventCompat . getX ( ev , newPointerIndex ) ; mActivePointerId = MotionEventCompat . getPointerId ( ev , newPointerIndex ) ; } break ; } } return super . onInterceptTouchEvent ( ev ) ; }
JSDemos/android-sdk-20 | public void setOnInterceptTouchListener ( OnInterceptTouchListener l ) { mListener = l ; }
nafae/developer | public BiddingTransitionErrorReason getReason ( ) { return reason ; }
nafae/developer | public void setReason ( BiddingTransitionErrorReason value ) { this . reason = value ; }
bitraten/arx | public LayoutDefinition ( final Composite parent , final Controller controller ) { Composite compositeLeft ; Composite compositeRight ; Composite compositeTopRight ; Composite compositeCenterRight ; Composite compositeBottomRight ; center = new Composite ( parent , SWT . NONE ) ; center . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; final GridLayout centerLayout = SWTUtil . createGridLayout ( 2 ) ; centerLayout . makeColumnsEqualWidth = true ; center . setLayout ( centerLayout ) ; compositeLeft = new Composite ( center , SWT . NONE ) ; compositeLeft . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; compositeLeft . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; compositeRight = new Composite ( center , SWT . NONE ) ; compositeRight . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; compositeRight . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; compositeTopRight = new Composite ( compositeRight , SWT . NONE ) ; compositeTopRight . setLayoutData ( SWTUtil . createFillGridData ( ) ) ; compositeTopRight . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; compositeCenterRight = new Composite ( compositeRight , SWT . NONE ) ; compositeCenterRight . setLayoutData ( SWTUtil . createFillHorizontallyGridData ( ) ) ; compositeCenterRight . setLayout ( new FillLayout ( ) ) ; compositeBottomRight = new Composite ( compositeRight , SWT . NONE ) ; compositeBottomRight . setLayoutData ( SWTUtil . createFillHorizontallyGridData ( ) ) ; compositeBottomRight . setLayout ( SWTUtil . createGridLayout ( 1 ) ) ; new ViewDataInput ( compositeLeft , controller , true ) ; new ViewSubsetDefinition ( compositeLeft , controller ) ; new LayoutAttributeSettings ( compositeTopRight , controller ) ; new LayoutCriteria ( compositeCenterRight , controller ) ; new LayoutTransformationModel ( compositeBottomRight , controller ) ; }
cfieber/orca | public PackageInfo ( Stage stage , String packageType , String versionDelimiter , boolean extractBuildDetails , boolean extractVersion , ObjectMapper mapper ) { this . stage = stage ; this . packageType = packageType ; this . versionDelimiter = versionDelimiter ; this . extractBuildDetails = extractBuildDetails ; this . extractVersion = extractVersion ; this . mapper = mapper ; this . buildDetailExtractor = new BuildDetailExtractor ( ) ; if ( stage . getContext ( ) . containsKey ( " package " ) ) { String packages = stage . getContext ( ) . get ( " package " ) . toString ( ) ; for ( String p : packages . split ( " ▁ " ) ) { packageFilePatterns . add ( Pattern . compile ( format ( " % s . * \\ . % s " , p , packageType ) ) ) ; } } }
cfieber/orca | @ VisibleForTesting private boolean isUrl ( String potentialUrl ) { return potentialUrl . matches ( " \\ b ( https ? | ssh ) : \\ / \\ / . * " ) ; }
cfieber/orca | public Map < String , Object > findTargetPackage ( boolean allowMissingPackageInstallation ) { Map < String , Object > requestMap = new HashMap < > ( ) ; requestMap . putAll ( stage . getContext ( ) ) ; if ( stage . getExecution ( ) . getType ( ) == PIPELINE ) { Map trigger = mapper . convertValue ( stage . getExecution ( ) . getTrigger ( ) , Map . class ) ; Map buildInfo = null ; if ( requestMap . get ( " buildInfo " ) != null ) { buildInfo = mapper . convertValue ( requestMap . get ( " buildInfo " ) , Map . class ) ; } if ( buildInfo == null || ( buildInfo . get ( " artifacts " ) != null && ! ( ( Collection ) buildInfo . get ( " artifacts " ) ) . isEmpty ( ) ) ) { Map < String , Object > upstreamBuildInfo = findBuildInfoInUpstreamStage ( stage , packageFilePatterns ) ; if ( ! upstreamBuildInfo . isEmpty ( ) ) { buildInfo = upstreamBuildInfo ; } } if ( buildInfo == null ) { buildInfo = emptyMap ( ) ; } return createAugmentedRequest ( trigger , buildInfo , requestMap , allowMissingPackageInstallation ) ; } return requestMap ; }
cfieber/orca | @ VisibleForTesting private Map < String , Object > createAugmentedRequest ( Map < String , Object > trigger , Map < String , Object > buildInfo , Map < String , Object > request , boolean allowMissingPackageInstallation ) { Map < String , Object > artifactSourceBuildInfo = getArtifactSourceBuildInfo ( trigger ) ; List < Map < String , Object > > triggerArtifacts = Optional . ofNullable ( ( List < Map < String , Object > > ) artifactSourceBuildInfo . get ( " artifacts " ) ) . orElse ( emptyList ( ) ) ; List < Map < String , Object > > buildArtifacts = Optional . ofNullable ( ( List < Map < String , Object > > ) buildInfo . get ( " artifacts " ) ) . orElse ( emptyList ( ) ) ; if ( request . get ( " package " ) == null || request . get ( " package " ) . equals ( " " ) || isUrl ( request . get ( " package " ) . toString ( ) ) ) { return request ; } if ( buildInfo . isEmpty ( ) || buildArtifacts . isEmpty ( ) ) { Optional < Map < String , Object > > parentBuildInfo = Optional . ofNullable ( ( Map ) trigger . get ( " parentExecution " ) ) . map ( it -> ( Map ) it . get ( " trigger " ) ) . map ( it -> ( Map < String , Object > ) it . get ( " buildInfo " ) ) ; if ( triggerArtifacts . isEmpty ( ) && ( trigger . get ( " buildInfo " ) != null || parentBuildInfo . isPresent ( ) ) ) { throw new IllegalStateException ( " Jenkins ▁ job ▁ detected ▁ but ▁ no ▁ artifacts ▁ found , ▁ please ▁ archive ▁ the ▁ packages ▁ in ▁ your ▁ job ▁ and ▁ try ▁ again . " ) ; } } if ( buildArtifacts . isEmpty ( ) && triggerArtifacts . isEmpty ( ) ) { return request ; } List < String > missingPrefixes = new ArrayList < > ( ) ; String fileExtension = format ( " . % s " , packageType ) ; String reqPkg = Optional . ofNullable ( request . get ( " package " ) . toString ( ) ) . orElseGet ( ( ) -> buildArtifacts . stream ( ) . findFirst ( ) . map ( it -> it . get ( " fileName " ) . toString ( ) . split ( versionDelimiter ) [ 0 ] ) . orElseGet ( ( ) -> triggerArtifacts . stream ( ) . findFirst ( ) . map ( it -> it . get ( " fileName " ) . toString ( ) . split ( versionDelimiter ) [ 0 ] ) . orElse ( null ) ) ) ; List < String > requestPackages = Arrays . asList ( reqPkg . split ( " ▁ " ) ) ; for ( int index = 0 ; index < requestPackages . size ( ) ; index ++ ) { String requestPackage = requestPackages . get ( index ) ; String prefix = requestPackage + versionDelimiter ; Map < String , Object > triggerArtifact = filterArtifacts ( triggerArtifacts , prefix , fileExtension ) ; Map < String , Object > buildArtifact = filterArtifacts ( buildArtifacts , prefix , fileExtension ) ; if ( ! triggerArtifact . isEmpty ( ) && ! buildArtifact . isEmpty ( ) && ! triggerArtifact . get ( " fileName " ) . equals ( buildArtifact . get ( " fileName " ) ) ) { throw new IllegalStateException ( " Found ▁ build ▁ artifact ▁ in ▁ Jenkins ▁ stage ▁ and ▁ Pipeline ▁ Trigger " ) ; } String packageName = null ; String packageVersion = null ; if ( ! triggerArtifact . isEmpty ( ) ) { packageName = extractPackageName ( triggerArtifact , fileExtension ) ; if ( extractVersion ) { packageVersion = extractPackageVersion ( triggerArtifact , prefix , fileExtension ) ; } } if ( ! buildArtifact . isEmpty ( ) ) { packageName = extractPackageName ( buildArtifact , fileExtension ) ; if ( extractVersion ) { packageVersion = extractPackageVersion ( buildArtifact , prefix , fileExtension ) ; } } if ( packageVersion != null ) { request . put ( " packageVersion " , packageVersion ) ; } if ( triggerArtifact . isEmpty ( ) && buildArtifact . isEmpty ( ) ) { missingPrefixes . add ( prefix ) ; } requestPackages . set ( index , packageName != null ? packageName : requestPackage ) ; if ( packageName != null ) { if ( extractBuildDetails ) { Map < String , Object > buildInfoForDetails = ! buildArtifact . isEmpty ( ) ? buildInfo : artifactSourceBuildInfo ; buildDetailExtractor . tryToExtractBuildDetails ( buildInfoForDetails , request ) ; } } } if ( ! missingPrefixes . isEmpty ( ) && ! allowMissingPackageInstallation ) { throw new IllegalStateException ( format ( " Unable ▁ to ▁ find ▁ deployable ▁ artifact ▁ starting ▁ with ▁ % s ▁ and ▁ ending ▁ with ▁ % s ▁ in ▁ % s ▁ and ▁ % s . ▁ Make ▁ sure ▁ your ▁ deb ▁ package ▁ file ▁ name ▁ complies ▁ with ▁ the ▁ naming ▁ convention : ▁ name _ version - release _ arch . " , missingPrefixes , fileExtension , buildArtifacts , triggerArtifacts . stream ( ) . map ( it -> it . get ( " fileName " ) ) . collect ( toList ( ) ) ) ) ; } request . put ( " package " , requestPackages . stream ( ) . collect ( joining ( " ▁ " ) ) ) ; return request ; }
cfieber/orca | Map < String , Object > getArtifactSourceBuildInfo ( Map < String , Object > trigger ) { Map < String , Object > buildInfo = Optional . ofNullable ( ( Map < String , Object > ) trigger . get ( " buildInfo " ) ) . orElse ( emptyMap ( ) ) ; Map < String , Object > parentExecution = Optional . ofNullable ( ( Map < String , Object > ) trigger . get ( " parentExecution " ) ) . orElse ( emptyMap ( ) ) ; if ( buildInfo . get ( " artifacts " ) != null ) { return buildInfo ; } if ( parentExecution . get ( " trigger " ) != null ) { return getArtifactSourceBuildInfo ( ( Map < String , Object > ) parentExecution . get ( " trigger " ) ) ; } return emptyMap ( ) ; }
cfieber/orca | private String extractPackageName ( Map artifact , String fileExtension ) { String fileName = artifact . get ( " fileName " ) . toString ( ) ; return fileName . substring ( 0 , fileName . lastIndexOf ( fileExtension ) ) ; }
cfieber/orca | private String extractPackageVersion ( Map < String , Object > artifact , String filePrefix , String fileExtension ) { String fileName = artifact . get ( " fileName " ) . toString ( ) ; String version = fileName . substring ( fileName . indexOf ( filePrefix ) + filePrefix . length ( ) , fileName . lastIndexOf ( fileExtension ) ) ; if ( version . contains ( versionDelimiter ) ) { version = version . substring ( 0 , version . indexOf ( versionDelimiter ) ) ; } return version ; }
cfieber/orca | private Map < String , Object > filterArtifacts ( List < Map < String , Object > > artifacts , String prefix , String fileExtension ) { if ( packageType . equals ( " rpm " ) ) { return filterRPMArtifacts ( artifacts , prefix ) ; } else { return artifacts . stream ( ) . filter ( it -> it . get ( " fileName " ) != null && it . get ( " fileName " ) . toString ( ) . startsWith ( prefix ) && it . get ( " fileName " ) . toString ( ) . endsWith ( fileExtension ) ) . findFirst ( ) . orElse ( emptyMap ( ) ) ; } }
cfieber/orca | private Map < String , Object > filterRPMArtifacts ( List < Map < String , Object > > artifacts , String prefix ) { return artifacts . stream ( ) . filter ( artifact -> { String [ ] parts = artifact . get ( " fileName " ) . toString ( ) . split ( versionDelimiter ) ; if ( parts . length >= 3 ) { parts = Arrays . copyOfRange ( parts , 0 , parts . length - 2 ) ; String appName = Arrays . stream ( parts ) . collect ( joining ( versionDelimiter ) ) ; return format ( " % s % s " , appName , versionDelimiter ) . equals ( prefix ) ; } return false ; } ) . findFirst ( ) . orElse ( emptyMap ( ) ) ; }
haojiankang/spring-cloud | public FeignRemoteCallMessageConvert ( ) { init ( ) ; }
haojiankang/spring-cloud | protected void init ( ) { setDefaultCharset ( DEFAULT_CHARSET ) ; DefaultPrettyPrinter prettyPrinter = new DefaultPrettyPrinter ( ) ; prettyPrinter . indentObjectsWith ( new DefaultIndenter ( " ▁ ▁ " , " \n data : " ) ) ; }
haojiankang/spring-cloud | @ Override protected boolean supports ( Class < ? > clazz ) { return ! BeanUtils . isSimpleType ( clazz ) ; }
haojiankang/spring-cloud | @ Override protected MediaType getDefaultContentType ( Object object ) throws IOException { if ( object instanceof MappingJacksonValue ) { object = ( ( MappingJacksonValue ) object ) . getValue ( ) ; } return super . getDefaultContentType ( object ) ; }
haojiankang/spring-cloud | @ Override protected Long getContentLength ( Object object , MediaType contentType ) throws IOException { if ( object instanceof MappingJacksonValue ) { object = ( ( MappingJacksonValue ) object ) . getValue ( ) ; } return super . getContentLength ( object , contentType ) ; }
haojiankang/spring-cloud | @ Override public boolean canRead ( Class < ? > clazz , MediaType mediaType ) { return false ; }
haojiankang/spring-cloud | public FeignRemoteCallMessageConvert addMediaType ( String type , String subtype ) { mediaTypes . add ( new MediaType ( type , subtype ) ) ; return this ; }
haojiankang/spring-cloud | public FeignRemoteCallMessageConvert addMediaType ( MediaType mediaType ) { mediaTypes . add ( mediaType ) ; return this ; }
haojiankang/spring-cloud | @ Override public List < MediaType > getSupportedMediaTypes ( ) { return mediaTypes ; }
JanewzhWang/dasein-cloud-core | private AffinityGroupFilterOptions ( boolean matchesAny ) { this . matchesAny = matchesAny ; }
JanewzhWang/dasein-cloud-core | public String getRegex ( ) { return regex ; }
JanewzhWang/dasein-cloud-core | public String getDataCenterId ( ) { return dataCenterId ; }
JanewzhWang/dasein-cloud-core | public boolean hasCriteria ( ) { return ( dataCenterId != null || regex != null ) ; }
JanewzhWang/dasein-cloud-core | public boolean isMatchesAny ( ) { return matchesAny ; }
JanewzhWang/dasein-cloud-core | public @ Nonnull AffinityGroupFilterOptions matchingAll ( ) { this . matchesAny = false ; return this ; }
JanewzhWang/dasein-cloud-core | public @ Nonnull AffinityGroupFilterOptions matchingRegex ( @ Nonnull String regex ) { this . regex = regex ; return this ; }
JanewzhWang/dasein-cloud-core | public @ Nonnull AffinityGroupFilterOptions withDataCenterId ( @ Nonnull String dataCenterId ) { this . dataCenterId = dataCenterId ; return this ; }
JanewzhWang/dasein-cloud-core | public boolean matches ( @ Nonnull AffinityGroup affinityGroup ) { if ( regex != null ) { boolean matches = ( affinityGroup . getAffinityGroupName ( ) . matches ( regex ) || affinityGroup . getDescription ( ) . matches ( regex ) ) ; if ( ! matches && ! matchesAny ) { return false ; } else if ( matches && matchesAny ) { return true ; } } if ( dataCenterId != null ) { boolean matches = dataCenterId . equals ( affinityGroup . getDataCenterId ( ) ) ; if ( ! matches && ! matchesAny ) { return false ; } else if ( matches && matchesAny ) { return true ; } } return ! matchesAny ; }
272029252/Metamorphosis | @ Override public byte getType ( ) { return ADD_OP ; }
272029252/Metamorphosis | public AddMsgOperation ( final MessageStore store , final long msgId , final PutCommand putCmd ) { super ( ) ; this . store = store ; this . msgId = msgId ; this . putCmd = putCmd ; }
272029252/Metamorphosis | public AddMsgLocation ( final long offset , final int length , final int checksum , final String storeDesc ) { super ( offset , length ) ; this . checksum = checksum ; this . storeDesc = storeDesc ; }
272029252/Metamorphosis | public ByteBuffer encode ( ) { if ( this . buf == null ) { final byte [ ] storeDescBytes = ByteUtils . getBytes ( this . storeDesc ) ; final ByteBuffer buf = ByteBuffer . allocate ( 4 + 4 + 8 + 4 + this . storeDesc . length ( ) ) ; buf . putLong ( this . getOffset ( ) ) ; buf . putInt ( this . getLength ( ) ) ; buf . putInt ( this . checksum ) ; buf . putInt ( storeDescBytes . length ) ; buf . put ( storeDescBytes ) ; buf . flip ( ) ; this . buf = buf ; } return this . buf ; }
272029252/Metamorphosis | JournalLocation getLocation ( ) { return this . location ; }
272029252/Metamorphosis | public Tx ( final JournalLocation location ) { this . location = location ; }
272029252/Metamorphosis | public void add ( final MessageStore store , final long msgId , final PutCommand putCmd ) { final AddMsgOperation addMsgOperation = new AddMsgOperation ( store , msgId , putCmd ) ; Queue < TxOperation > ops = this . operations . get ( store ) ; if ( ops == null ) { ops = new ConcurrentLinkedQueue < TxOperation > ( ) ; final Queue < TxOperation > oldOps = this . operations . putIfAbsent ( store , ops ) ; if ( oldOps != null ) { ops = oldOps ; } } ops . add ( addMsgOperation ) ; }
272029252/Metamorphosis | public Map < MessageStore , List < Long > > getMsgIds ( ) { final Map < MessageStore , List < Long > > rt = new LinkedHashMap < MessageStore , List < Long > > ( ) ; for ( final Map . Entry < MessageStore , Queue < TxOperation > > entry : this . operations . entrySet ( ) ) { final MessageStore store = entry . getKey ( ) ; final Queue < TxOperation > opQueue = entry . getValue ( ) ; final List < Long > ids = new ArrayList < Long > ( ) ; rt . put ( store , ids ) ; for ( final TxOperation to : opQueue ) { if ( to . getType ( ) == TxOperation . ADD_OP ) { ids . add ( ( ( AddMsgOperation ) to ) . msgId ) ; } } } return rt ; }
272029252/Metamorphosis | public PutCommand [ ] getRequests ( ) { final List < PutCommand > list = new ArrayList < PutCommand > ( this . operations . size ( ) * 2 ) ; for ( final Map . Entry < MessageStore , Queue < TxOperation > > entry : this . operations . entrySet ( ) ) { for ( final TxOperation op : entry . getValue ( ) ) { if ( op . getType ( ) == TxOperation . ADD_OP ) { list . add ( ( ( AddMsgOperation ) op ) . putCmd ) ; } } } final PutCommand [ ] rt = new PutCommand [ list . size ( ) ] ; return list . toArray ( rt ) ; }
272029252/Metamorphosis | public Map < MessageStore , List < PutCommand > > getPutCommands ( ) { final Map < MessageStore , List < PutCommand > > rt = new LinkedHashMap < MessageStore , List < PutCommand > > ( ) ; for ( final Map . Entry < MessageStore , Queue < TxOperation > > entry : this . operations . entrySet ( ) ) { final MessageStore store = entry . getKey ( ) ; final Queue < TxOperation > opQueue = entry . getValue ( ) ; final List < PutCommand > ids = new ArrayList < PutCommand > ( ) ; rt . put ( store , ids ) ; for ( final TxOperation to : opQueue ) { if ( to . getType ( ) == TxOperation . ADD_OP ) { ids . add ( ( ( AddMsgOperation ) to ) . putCmd ) ; } } } return rt ; }
272029252/Metamorphosis | public Map < MessageStore , Queue < TxOperation > > getOperations ( ) { return this . operations ; }
272029252/Metamorphosis | public JournalTransactionStore ( final String dataPath , final MessageStoreManager storeManager , final MetaConfig metaConfig ) throws Exception { this . journalStore = new JournalStore ( dataPath , storeManager , this , metaConfig . getMaxCheckpoints ( ) , metaConfig . getFlushTxLogAtCommit ( ) ) ; this . scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { @ Override public void run ( ) { try { JournalTransactionStore . this . makeCheckpoint ( ) ; } catch ( final Exception e ) { log . error ( " Execute ▁ checkpoint ▁ failed " , e ) ; } } } , metaConfig . getCheckpointInterval ( ) , metaConfig . getCheckpointInterval ( ) , TimeUnit . MILLISECONDS ) ; MetaMBeanServer . registMBean ( this , null ) ; }
272029252/Metamorphosis | @ Override public void prepare ( final TransactionId txid ) throws IOException { Tx tx = null ; synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } if ( tx == null ) { return ; } final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . XA_PREPARE ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( false ) . build ( ) ; final TxCommand msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . setForce ( true ) . build ( ) ; this . journalStore . write ( msg , null , tx . location , false ) ; synchronized ( this . preparedTransactions ) { this . preparedTransactions . put ( txid , tx ) ; } }
272029252/Metamorphosis | public JournalStore getJournalStore ( ) { return this . journalStore ; }
272029252/Metamorphosis | public void replayPrepare ( final TransactionId txid ) throws IOException { Tx tx = null ; synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } if ( tx == null ) { return ; } synchronized ( this . preparedTransactions ) { this . preparedTransactions . put ( txid , tx ) ; } }
272029252/Metamorphosis | public Tx getInflyTx ( final Object txid ) { synchronized ( this . inflightTransactions ) { return this . inflightTransactions . get ( txid ) ; } }
272029252/Metamorphosis | @ Override public int getActiveTransactionCount ( ) { int count = 0 ; synchronized ( this . preparedTransactions ) { count += this . preparedTransactions . size ( ) ; } synchronized ( this . inflightTransactions ) { count += this . inflightTransactions . size ( ) ; } return count ; }
272029252/Metamorphosis | Tx getPreparedTx ( final Object txid ) { synchronized ( this . preparedTransactions ) { return this . preparedTransactions . get ( txid ) ; } }
272029252/Metamorphosis | public Tx getTx ( final Object txid , final JournalLocation location ) { synchronized ( this . inflightTransactions ) { Tx tx = this . inflightTransactions . get ( txid ) ; if ( tx == null ) { tx = new Tx ( location ) ; this . inflightTransactions . put ( txid , tx ) ; } return tx ; } }
272029252/Metamorphosis | @ Override public void commit ( final TransactionId txid , final boolean wasPrepared ) throws IOException { final Tx tx ; if ( wasPrepared ) { synchronized ( this . preparedTransactions ) { tx = this . preparedTransactions . remove ( txid ) ; } } else { synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } } if ( tx == null ) { return ; } final Map < MessageStore , List < Long > > msgIds = tx . getMsgIds ( ) ; final Map < MessageStore , List < PutCommand > > putCommands = tx . getPutCommands ( ) ; final Map < String , AddMsgLocation > locations = new LinkedHashMap < String , JournalTransactionStore . AddMsgLocation > ( ) ; final int count = msgIds . size ( ) ; for ( final Map . Entry < MessageStore , List < Long > > entry : msgIds . entrySet ( ) ) { final MessageStore msgStore = entry . getKey ( ) ; final List < Long > ids = entry . getValue ( ) ; final List < PutCommand > cmds = putCommands . get ( msgStore ) ; msgStore . append ( ids , cmds , new AppendCallback ( ) { @ Override public void appendComplete ( final Location location ) { final int checkSum = CheckSum . crc32 ( MessageUtils . makeMessageBuffer ( ids , cmds ) . array ( ) ) ; final String description = msgStore . getDescription ( ) ; synchronized ( locations ) { locations . put ( description , new AddMsgLocation ( location . getOffset ( ) , location . getLength ( ) , checkSum , description ) ) ; if ( locations . size ( ) == count ) { final ByteBuffer localtionBytes = AddMsgLocationUtils . encodeLocation ( locations ) ; TxCommand msg = null ; final int attachmentLen = localtionBytes . remaining ( ) ; if ( txid . isXATransaction ( ) ) { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . XA_COMMIT ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( wasPrepared ) . setDataLength ( attachmentLen ) . build ( ) ; msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; } else { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . LOCAL_COMMIT ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( wasPrepared ) . setDataLength ( attachmentLen ) . build ( ) ; msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; } try { JournalTransactionStore . this . journalStore . write ( msg , localtionBytes , tx . location , true ) ; } catch ( final IOException e ) { throw new RuntimeException ( " Write ▁ tx ▁ log ▁ failed " , e ) ; } } } } } ) ; } }
272029252/Metamorphosis | public Tx replayCommit ( final TransactionId txid , final boolean wasPrepared ) throws IOException { if ( wasPrepared ) { synchronized ( this . preparedTransactions ) { return this . preparedTransactions . remove ( txid ) ; } } else { synchronized ( this . inflightTransactions ) { return this . inflightTransactions . remove ( txid ) ; } } }
272029252/Metamorphosis | @ Override public void rollback ( final TransactionId txid ) throws IOException { Tx tx = null ; synchronized ( this . inflightTransactions ) { tx = this . inflightTransactions . remove ( txid ) ; } if ( tx == null ) { synchronized ( this . preparedTransactions ) { tx = this . preparedTransactions . remove ( txid ) ; } } if ( tx != null ) { if ( txid . isXATransaction ( ) ) { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . XA_ROLLBACK ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( false ) . build ( ) ; final TxCommand msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; this . journalStore . write ( msg , null , tx . location , true ) ; } else { final TransactionOperation to = TransactionOperation . newBuilder ( ) . setType ( TransactionType . LOCAL_ROLLBACK ) . setTransactionId ( txid . getTransactionKey ( ) ) . setWasPrepared ( false ) . build ( ) ; final TxCommand msg = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . TX_OP ) . setCmdContent ( to . toByteString ( ) ) . build ( ) ; this . journalStore . write ( msg , null , tx . location , true ) ; } } }
272029252/Metamorphosis | public void replayRollback ( final TransactionId txid ) throws IOException { boolean inflight = false ; synchronized ( this . inflightTransactions ) { inflight = this . inflightTransactions . remove ( txid ) != null ; } if ( ! inflight ) { synchronized ( this . preparedTransactions ) { this . preparedTransactions . remove ( txid ) ; } } }
272029252/Metamorphosis | @ Override public void init ( ) { }
272029252/Metamorphosis | @ Override public void dispose ( ) { this . scheduledExecutorService . shutdown ( ) ; try { this . journalStore . close ( ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } }
272029252/Metamorphosis | @ Override public synchronized void recover ( final TransactionRecoveryListener listener ) throws IOException { Map < Object , Tx > copyMap = null ; synchronized ( this . inflightTransactions ) { copyMap = new HashMap < Object , JournalTransactionStore . Tx > ( this . inflightTransactions ) ; } for ( final Map . Entry < Object , Tx > entry : copyMap . entrySet ( ) ) { this . rollback ( ( TransactionId ) entry . getKey ( ) ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( " Rollback ▁ inflight ▁ transaction : " + entry . getKey ( ) ) ; } } this . doingRecover = true ; try { Map < TransactionId , Tx > txs = null ; synchronized ( this . preparedTransactions ) { txs = new LinkedHashMap < TransactionId , Tx > ( this . preparedTransactions ) ; } for ( final Map . Entry < TransactionId , Tx > entry : txs . entrySet ( ) ) { final Object txid = entry . getKey ( ) ; final Tx tx = entry . getValue ( ) ; listener . recover ( ( XATransactionId ) txid , tx . getRequests ( ) ) ; } } finally { this . doingRecover = false ; } }
272029252/Metamorphosis | @ Override public void addMessage ( final MessageStore store , final long msgId , final PutCommand putCmd , JournalLocation location ) throws IOException { if ( location == null ) { final AppendMessageCommand appendCmd = AppendMessageCommand . newBuilder ( ) . setMessageId ( msgId ) . setPutCommand ( ByteString . copyFrom ( putCmd . encode ( ) . array ( ) ) ) . build ( ) ; final TxCommand txCommand = TxCommand . newBuilder ( ) . setCmdType ( TxCommandType . APPEND_MSG ) . setCmdContent ( appendCmd . toByteString ( ) ) . build ( ) ; final Tx tx = this . getInflyTx ( putCmd . getTransactionId ( ) ) ; if ( tx != null ) { location = this . journalStore . write ( txCommand , null , tx . location , false ) ; } else { location = this . journalStore . write ( txCommand , null , null , false ) ; } } final Tx tx = this . getTx ( putCmd . getTransactionId ( ) , location ) ; tx . add ( store , msgId , putCmd ) ; }
272029252/Metamorphosis | @ Override public void makeCheckpoint ( ) throws Exception { this . journalStore . checkpoint ( ) ; }
272029252/Metamorphosis | public JournalLocation checkpoint ( ) throws IOException { JournalLocation rc = null ; synchronized ( this . inflightTransactions ) { for ( final Iterator < Tx > iter = this . inflightTransactions . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { final Tx tx = iter . next ( ) ; final JournalLocation location = tx . location ; if ( rc == null || rc . compareTo ( location ) > 0 ) { rc = location ; } } } synchronized ( this . preparedTransactions ) { for ( final Iterator < Tx > iter = this . preparedTransactions . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { final Tx tx = iter . next ( ) ; final JournalLocation location = tx . location ; if ( rc == null || rc . compareTo ( location ) > 0 ) { rc = location ; } } return rc ; } }
272029252/Metamorphosis | public boolean isDoingRecover ( ) { return this . doingRecover ; }
alien4cloud/alien4cloud | @ Override protected void processWorkflowOperation ( Csar csar , Topology topology , RemoveStepOperation operation , Workflow workflow ) { log . debug ( " removing ▁ step ▁ [ ▁ { } ▁ ] ▁ from ▁ workflow ▁ [ ▁ { } ▁ ] ▁ from ▁ topology ▁ [ ▁ { } ▁ ] " , operation . getStepId ( ) , workflow . getName ( ) , topology . getId ( ) ) ; workflowBuilderService . removeStep ( topology , csar , workflow . getName ( ) , operation . getStepId ( ) ) ; }
PurelyApplied/geode | @ Test public void verifyCQPermissions ( ) throws Exception { String query = " select ▁ * ▁ from ▁ / AuthRegion " ; int serverPort = server . getPort ( ) ; client1 = cluster . startClientVM ( 1 , c2 -> c2 . withCredential ( " test " , " test " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client2 = cluster . startClientVM ( 2 , c1 -> c1 . withCredential ( " clusterManageQuery " , " clusterManageQuery " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client3 = cluster . startClientVM ( 3 , c -> c . withCredential ( " clusterManageQuery , dataRead " , " clusterManageQuery , dataRead " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client1 . invoke ( ( ) -> { final Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; assertNotAuthorized ( cq :: execute , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( cq :: executeWithInitialResults , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( qs :: getAllDurableCqsFromServer , " CLUSTER : READ " ) ; } ) ; client2 . invoke ( ( ) -> { final Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; assertNotAuthorized ( cq :: execute , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( cq :: executeWithInitialResults , " DATA : READ : AuthRegion " ) ; cq . close ( ) ; } ) ; client3 . invoke ( ( ) -> { Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; cq . execute ( ) ; cq . stop ( ) ; } ) ; }
exemplator/exemplator | public Selection ( Position start , Position end ) { this . start = start ; this . end = end ; }
exemplator/exemplator | public Position getStart ( ) { return start ; }
exemplator/exemplator | public Position getEnd ( ) { return end ; }
GunoH/intellij-community | default Tuple2 < Optional < A > , Optional < B > > project ( ) { return null ; }
GunoH/intellij-community | public Tuple2 ( A a , B b ) { }
GunoH/intellij-community | public < R > R into ( BiFunction < A , B , R > fn ) { return null ; }
GunoH/intellij-community | default Tuple2 project ( ) { return null ; }
GunoH/intellij-community | public void into ( ) { }
jdkoren/squidb | private ThreadLocal < Set < T > > notifyObjectAccumulator = new ThreadLocal < Set < T > > ( ) { protected Set < T > initialValue ( ) { return new HashSet < > ( ) ; } }
jdkoren/squidb | public DataChangedNotifier ( ) { }
jdkoren/squidb | public DataChangedNotifier ( SqlTable < ? > ... tables ) { SquidUtilities . addAll ( this . tables , tables ) ; }
jdkoren/squidb | public DataChangedNotifier ( Collection < ? extends SqlTable < ? > > tables ) { this . tables . addAll ( tables ) ; }
jdkoren/squidb | public Set < SqlTable < ? > > whichTables ( ) { return tables ; }
jdkoren/squidb | public void setEnabled ( boolean enabled ) { this . enabled = enabled ; }
jdkoren/squidb | final boolean onDataChanged ( SqlTable < ? > table , SquidDatabase database , DBOperation operation , AbstractModel modelValues , long rowId ) { if ( ! enabled ) { return false ; } return accumulateNotificationObjects ( notifyObjectAccumulator . get ( ) , table , database , operation , modelValues , rowId ) ; }
jdkoren/squidb | final void flushAccumulatedNotifications ( SquidDatabase database , boolean shouldSendNotifications ) { Set < T > accumulatedNotifications = notifyObjectAccumulator . get ( ) ; if ( enabled && shouldSendNotifications ) { sendNotificationsToAll ( database , accumulatedNotifications ) ; } accumulatedNotifications . clear ( ) ; }
jdkoren/squidb | protected void sendNotificationsToAll ( SquidDatabase database , Set < T > notifyObjects ) { for ( T notifyObject : notifyObjects ) { sendNotification ( database , notifyObject ) ; } }
brandtg/switchboard | public StopEventParser ( ) { super ( StopEvent . EVENT_TYPE ) ; }
brandtg/switchboard | public void parse ( XInputStream is , BinlogEventV4Header header , BinlogParserContext context ) throws IOException { final StopEvent event = new StopEvent ( header ) ; context . getEventListener ( ) . onEvents ( event ) ; }
Politbook/politbook_android | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View rootView = inflater . inflate ( R . layout . fragment_state , container , false ) ; mlvStates = ( ListView ) rootView . findViewById ( R . id . lvStates ) ; loadData ( ) ; initListener ( ) ; return rootView ; }
Politbook/politbook_android | private void loadData ( ) { if ( getArguments ( ) != null ) { changeState = getArguments ( ) . getBoolean ( KEY_CHANGE_STATE ) ; } initState ( ) ; mAdapterState = new AdapterState ( getActivity ( ) , mStates , Util . getUfDefault ( this . getActivity ( ) ) ) ; mlvStates . setAdapter ( mAdapterState ) ; }
Politbook/politbook_android | @ Override public void onResume ( ) { super . onResume ( ) ; }
Politbook/politbook_android | private void initListener ( ) { mlvStates . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > adapterView , View view , int i , long l ) { if ( Util . isNetworkAvailable ( view . getContext ( ) ) ) { Util . setUfDefault ( view . getContext ( ) , mStates . get ( i ) . getUf ( ) ) ; PersistenceManager . getInstance ( ) . removeCandidates ( ) ; Util . setFilterParty ( getActivity ( ) , "1" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "3" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "5" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "6" , 0 ) ; Util . setFilterParty ( getActivity ( ) , "7" , 0 ) ; Intent intent = new Intent ( getActivity ( ) , MainActivity . class ) ; startActivity ( intent ) ; getActivity ( ) . finish ( ) ; } else Toast . makeText ( view . getContext ( ) , R . string . no_connection , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; }
Politbook/politbook_android | private void initState ( ) { mStates = new ArrayList < State > ( ) ; mStates . add ( new State ( " AC " , " Acre " , R . drawable . acre ) ) ; mStates . add ( new State ( " AL " , " Alagoas " , R . drawable . alagoas ) ) ; mStates . add ( new State ( " AM " , " Amazonas " , R . drawable . amazonas ) ) ; mStates . add ( new State ( " AP " , " Amapa " , R . drawable . amapa ) ) ; mStates . add ( new State ( " BA " , " Bahia " , R . drawable . bahia ) ) ; mStates . add ( new State ( " CE " , " Ceará " , R . drawable . ceara ) ) ; mStates . add ( new State ( " DF " , " Distrito ▁ Federal " , R . drawable . distritofederal ) ) ; mStates . add ( new State ( " ES " , " Espírito ▁ Santo " , R . drawable . espiritosanto ) ) ; mStates . add ( new State ( " GO " , " Goiás " , R . drawable . goias ) ) ; mStates . add ( new State ( " MA " , " Maranhão " , R . drawable . maranhao ) ) ; mStates . add ( new State ( " MG " , " Minas ▁ Gerais " , R . drawable . minhasgeral ) ) ; mStates . add ( new State ( " MS " , " Mato ▁ Grosso ▁ do ▁ Sul " , R . drawable . matogrossodosul ) ) ; mStates . add ( new State ( " MT " , " Mato ▁ Grosso " , R . drawable . matogrosso ) ) ; mStates . add ( new State ( " PA " , " Pará " , R . drawable . para ) ) ; mStates . add ( new State ( " PB " , " Paraíba " , R . drawable . paraiba ) ) ; mStates . add ( new State ( " PE " , " Pernambuco " , R . drawable . pernambuco ) ) ; mStates . add ( new State ( " PI " , " Piauí " , R . drawable . piaui ) ) ; mStates . add ( new State ( " PR " , " Paraná " , R . drawable . parana ) ) ; mStates . add ( new State ( " RJ " , " Rio ▁ de ▁ Janeiro " , R . drawable . riodejaneiro ) ) ; mStates . add ( new State ( " RN " , " Rio ▁ Grande ▁ do ▁ Norte " , R . drawable . riograndedonorte ) ) ; mStates . add ( new State ( " RO " , " Rondônia " , R . drawable . rondonia ) ) ; mStates . add ( new State ( " RR " , " Roraima " , R . drawable . roraima ) ) ; mStates . add ( new State ( " RS " , " Rio ▁ Grande ▁ do ▁ Sul " , R . drawable . riograndedosul ) ) ; mStates . add ( new State ( " SC " , " Santa ▁ Catarina " , R . drawable . santacatarina ) ) ; mStates . add ( new State ( " SE " , " Sergipe " , R . drawable . sergipe ) ) ; mStates . add ( new State ( " SP " , " São ▁ Paulo " , R . drawable . saopaulo ) ) ; mStates . add ( new State ( " TO " , " Tocantins " , R . drawable . tocantins ) ) ; }
wintersandroid/lego-display-sequencer | public SequenceThread ( ) { setKey ( null ) ; baseDatabaseReference = null ; }
wintersandroid/lego-display-sequencer | public SequenceThread ( @ NonNull DatabaseReference baseDatabaseReference , String name ) { this . name = name ; this . baseDatabaseReference = baseDatabaseReference ; setKey ( baseDatabaseReference . child ( DATABASE_REFERENCE_PARENT ) . push ( ) . getKey ( ) ) ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . NAME ) public String getName ( ) { return name ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . NAME ) public void setName ( String name ) { this . name = name ; }
wintersandroid/lego-display-sequencer | @ Exclude int count ( ) { return sequenceList . size ( ) ; }
wintersandroid/lego-display-sequencer | @ Exclude void addItems ( @ NonNull List < Sequence > sequences ) { this . sequenceList . clear ( ) ; this . sequenceList . addAll ( sequences ) ; sortSequences ( ) ; }
wintersandroid/lego-display-sequencer | @ Exclude @ Nullable public Sequence getItem ( int index ) { return index < sequenceList . size ( ) ? sequenceList . get ( index ) : null ; }
wintersandroid/lego-display-sequencer | @ Exclude public void removeItem ( int index ) { if ( index < sequenceList . size ( ) ) { Sequence sequenceItem = sequenceList . get ( index ) ; getDatabaseReference ( ) . child ( DATABASE_REFERENCE_ITEMS ) . child ( sequenceItem . getKey ( ) ) . removeValue ( ) ; sequenceList . remove ( index ) ; } }
wintersandroid/lego-display-sequencer | @ Exclude public void moveItem ( int indexFrom , int indexTo ) { Collections . swap ( sequenceList , indexFrom , indexTo ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public void itemMoveFinished ( ) { long sequenceOrder = FIRST_SEQUENCE_NUMBER ; for ( int index = 0 ; index < sequenceList . size ( ) ; index ++ ) { Sequence item = sequenceList . get ( index ) ; item . setSequenceOrder ( sequenceOrder ++ ) ; getDatabaseReference ( ) . child ( DATABASE_REFERENCE_ITEMS ) . child ( item . getKey ( ) ) . setValue ( item ) ; } }
wintersandroid/lego-display-sequencer | @ Exclude public void write ( ) { getDatabaseReference ( ) . setValue ( this ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public int appendItem ( Sequence item1 ) { int index = sequenceList . indexOf ( item1 ) ; if ( index < 0 ) { sequenceList . add ( item1 ) ; index = sequenceList . indexOf ( item1 ) ; } return index ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( DATABASE_REFERENCE_ITEMS ) public Map < String , Object > getItemsHashMap ( ) { Map < String , Object > itemsOut = new HashMap < > ( ) ; for ( Sequence item : sequenceList ) { itemsOut . put ( item . getKey ( ) , item ) ; } return itemsOut ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( DATABASE_REFERENCE_ITEMS ) public void setItemsString ( Map < String , Map < String , Object > > items ) { sequenceList . clear ( ) ; Log . d ( TAG , " items ▁ string ▁ " + items . toString ( ) ) ; for ( String key : items . keySet ( ) ) { Log . d ( TAG , " key ▁ " + key ) ; Map < String , Object > properties = items . get ( key ) ; Log . d ( TAG , " values ▁ " + properties . toString ( ) ) ; Sequence sequence = new Sequence ( this , key , properties ) ; appendItem ( sequence ) ; } this . sequenceList . sort ( Comparator . comparingLong ( Sequence :: getSequenceOrder ) ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public int getItemsSize ( ) { return sequenceList . size ( ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public DatabaseReference getDatabaseReference ( ) { return baseDatabaseReference . child ( DATABASE_REFERENCE_PARENT ) . child ( getKey ( ) ) ; }
wintersandroid/lego-display-sequencer | @ Override public String toString ( ) { return " SequenceThread { " + " name = ' " + name + ' \' ' + " , ▁ sequenceList = " + sequenceList . toString ( ) + ' } ' ; }
wintersandroid/lego-display-sequencer | @ Exclude public void showEditor ( Context context ) { BasicAlerts . enterLineDialog ( context , R . string . new_sequence_thread , R . string . name , getName ( ) , value -> { if ( ! TextUtils . isEmpty ( value ) ) { setName ( value ) ; write ( ) ; } } , null ) ; }
wintersandroid/lego-display-sequencer | public void sortSequences ( ) { this . sequenceList . sort ( Comparator . comparingLong ( Sequence :: getSequenceOrder ) ) ; }
wintersandroid/lego-display-sequencer | @ Exclude public DatabaseReference getItemsDatabaseReference ( ) { return getDatabaseReference ( ) . child ( DATABASE_REFERENCE_ITEMS ) ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING ) public boolean isRunning ( ) { return running ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING ) public void setRunning ( boolean running ) { this . running = running ; }
wintersandroid/lego-display-sequencer | @ Exclude @ Nullable public Sequence getRunningSequence ( ) { return running ? getSequenceByOrderNumber ( runningSequenceOrderNumber ) : null ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . CONTINUOUS_RUNNING ) public boolean isContinuousRunning ( ) { return continuousRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . CONTINUOUS_RUNNING ) public void setContinuousRunning ( boolean continuousRunning ) { this . continuousRunning = continuousRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ORDER_NUMBER ) public long getRunningSequenceOrderNumber ( ) { return runningSequenceOrderNumber ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ORDER_NUMBER ) public void setRunningSequenceOrderNumber ( long runningSequenceOrderNumber ) { this . runningSequenceOrderNumber = runningSequenceOrderNumber ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ITEM_ORDER_NUMBER ) public long getRunningSequenceItemOrderNumber ( ) { return runningSequenceItemOrderNumber ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . RUNNING_SEQUENCE_ITEM_ORDER_NUMBER ) public void setRunningSequenceItemOrderNumber ( long runningSequenceItemOrderNumber ) { this . runningSequenceItemOrderNumber = runningSequenceItemOrderNumber ; }
wintersandroid/lego-display-sequencer | @ Nullable @ Exclude public Sequence getSequenceByKey ( String sequenceKey ) { for ( Sequence sequence : sequenceList ) { if ( sequence . getKey ( ) . equals ( sequenceKey ) ) { return sequence ; } } return null ; }
wintersandroid/lego-display-sequencer | @ Nullable @ Exclude public Sequence getSequenceByOrderNumber ( long orderNumber ) { for ( Sequence sequence : sequenceList ) { if ( sequence . getSequenceOrder ( ) == orderNumber ) { return sequence ; } } return null ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . PAUSE_RUNNING ) public boolean isPauseRunning ( ) { return pauseRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . PAUSE_RUNNING ) public void setPauseRunning ( boolean pauseRunning ) { this . pauseRunning = pauseRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . STOP_RUNNING ) public boolean isStopRunning ( ) { return stopRunning ; }
wintersandroid/lego-display-sequencer | @ PropertyName ( FirebaseProperties . STOP_RUNNING ) public void setStopRunning ( boolean stopRunning ) { if ( this . stopRunning && stopRunning ) { cancelRun ( ) ; stopRunning = false ; } this . stopRunning = stopRunning ; }
wintersandroid/lego-display-sequencer | public void startRunning ( boolean continuous ) { this . running = false ; this . continuousRunning = continuous ; setRunningSequenceOrderNumber ( - 1 ) ; setRunningSequenceItemOrderNumber ( - 1 ) ; if ( ! sequenceList . isEmpty ( ) ) { Sequence sequence = sequenceList . get ( 0 ) ; SequenceItem item = sequence . startSequence ( ) ; if ( item != null ) { setRunningSequenceOrderNumber ( sequence . getSequenceOrder ( ) ) ; setRunningSequenceItemOrderNumber ( item . getSequenceOrder ( ) ) ; running = true ; } } }
wintersandroid/lego-display-sequencer | @ Exclude public Sequence getNextSequence ( ) { Sequence currentSequence = getRunningSequence ( ) ; Sequence nextSequence = null ; running = false ; if ( ! stopRunning ) { if ( currentSequence != null ) { nextSequence = getSequenceByOrderNumber ( currentSequence . getSequenceOrder ( ) + 1 ) ; if ( nextSequence == null ) { if ( continuousRunning ) { nextSequence = getSequenceByOrderNumber ( FIRST_SEQUENCE_NUMBER ) ; } } if ( nextSequence != null ) { SequenceItem item = nextSequence . startSequence ( ) ; if ( item != null ) { setRunningSequenceOrderNumber ( nextSequence . getSequenceOrder ( ) ) ; setRunningSequenceItemOrderNumber ( item . getSequenceOrder ( ) ) ; running = true ; } } } } if ( ! running || nextSequence == null ) { setRunningSequenceOrderNumber ( - 1 ) ; setRunningSequenceItemOrderNumber ( - 1 ) ; nextSequence = null ; stopRunning = false ; } return nextSequence ; }
wintersandroid/lego-display-sequencer | @ Exclude public boolean hasSequence ( @ NonNull Sequence sequence ) { return getSequenceByKey ( sequence . getKey ( ) ) != null ; }
wintersandroid/lego-display-sequencer | @ Exclude public boolean hasSequenceItem ( @ NonNull SequenceItem sequenceItem ) { for ( Sequence sequence : sequenceList ) { if ( sequence . hasItem ( sequenceItem ) ) { return true ; } } return false ; }
wintersandroid/lego-display-sequencer | @ Exclude public SequenceItem getRunningSequenceItem ( ) { if ( getRunningSequence ( ) != null ) { return getRunningSequence ( ) . getItemBySequenceOrderNumber ( getRunningSequenceItemOrderNumber ( ) ) ; } return null ; }
wintersandroid/lego-display-sequencer | public void cancelRun ( ) { Log . d ( TAG , " cancelRun " ) ; SequenceItem sequenceItem = getRunningSequenceItem ( ) ; if ( sequenceItem != null ) { Log . d ( TAG , " Canceling ▁ Sequence ▁ Item ▁ ▁ " + sequenceItem . toString ( ) ) ; sequenceItem . cancel ( ) ; } running = false ; setRunningSequenceOrderNumber ( - 1 ) ; setRunningSequenceItemOrderNumber ( - 1 ) ; }
wintersandroid/lego-display-sequencer | @ Exclude @ Override public String getSpinnerText ( @ NonNull Context context ) { return getName ( ) ; }
don-philipe/graphhopper | ) public void canToggleTurnCostsOnOff_legacy ( String mode ) { assertError ( mode , " my _ car _ turn _ costs " , true , null , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' edge _ based ' ▁ parameter . ▁ You ▁ used ▁ ' edge _ based = true ' " ) ; assertError ( mode , " my _ car _ turn _ costs " , false , null , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' edge _ based ' ▁ parameter . ▁ You ▁ used ▁ ' edge _ based = false ' " ) ; assertError ( mode , " my _ car _ turn _ costs " , null , true , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' turn _ costs ' ▁ parameter . ▁ You ▁ used ▁ ' turn _ costs = true ' " ) ; assertError ( mode , " my _ car _ turn _ costs " , null , false , emptyList ( ) , " Since ▁ you ▁ are ▁ using ▁ the ▁ ' profile ' ▁ parameter , ▁ do ▁ not ▁ use ▁ the ▁ ' turn _ costs ' ▁ parameter . ▁ You ▁ used ▁ ' turn _ costs = false " ) ; assertDistance ( mode , null , null , emptyList ( ) , 1044 ) ; assertDistance ( mode , true , null , emptyList ( ) , 1044 ) ; assertDistance ( mode , null , true , emptyList ( ) , 1044 ) ; assertDistance ( mode , false , null , emptyList ( ) , 400 ) ; assertDistance ( mode , null , false , emptyList ( ) , 400 ) ; }
don-philipe/graphhopper | ) public void curbsides_legacy ( String mode ) { assertDistance ( mode , null , null , Arrays . asList ( " left " , " left " ) , 1459 ) ; assertDistance ( mode , true , null , Arrays . asList ( " left " , " left " ) , 1459 ) ; assertDistance ( mode , null , true , Arrays . asList ( " left " , " left " ) , 1459 ) ; assertError ( mode , null , false , null , Arrays . asList ( " left " , " left " ) , " Disabling ▁ ' edge _ based ' ▁ when ▁ using ▁ ' curbside ' ▁ is ▁ not ▁ allowed " ) ; assertError ( mode , null , null , false , Arrays . asList ( " left " , " left " ) , " Disabling ▁ ' turn _ costs ' ▁ when ▁ using ▁ ' curbside ' ▁ is ▁ not ▁ allowed " ) ; }
don-philipe/graphhopper | private void assertDistance ( String mode , Boolean edgeBased , Boolean turnCosts , List < String > curbsides , double expectedDistance ) { assertDistance ( doGet ( mode , null , edgeBased , turnCosts , curbsides ) , expectedDistance ) ; assertDistance ( doPost ( mode , null , edgeBased , turnCosts , curbsides ) , expectedDistance ) ; }
don-philipe/graphhopper | private void assertError ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides , String ... expectedErrors ) { assertError ( doGet ( mode , profile , edgeBased , turnCosts , curbsides ) , expectedErrors ) ; assertError ( doPost ( mode , profile , edgeBased , turnCosts , curbsides ) , expectedErrors ) ; }
don-philipe/graphhopper | private void assertDistance ( Response response , double expectedDistance ) { JsonNode json = response . readEntity ( JsonNode . class ) ; assertEquals ( 200 , response . getStatus ( ) , json . toString ( ) ) ; JsonNode infoJson = json . get ( " info " ) ; assertFalse ( infoJson . has ( " errors " ) ) ; JsonNode path = json . get ( " paths " ) . get ( 0 ) ; double distance = path . get ( " distance " ) . asDouble ( ) ; assertEquals ( expectedDistance , distance , 1 ) ; }
don-philipe/graphhopper | private void assertError ( Response response , String ... expectedErrors ) { assert expectedErrors . length > 0 ; JsonNode json = response . readEntity ( JsonNode . class ) ; assertEquals ( 400 , response . getStatus ( ) , json . toString ( ) ) ; for ( String e : expectedErrors ) { assertTrue ( json . get ( " message " ) . toString ( ) . contains ( e ) , json . get ( " message " ) . toString ( ) ) ; } }
don-philipe/graphhopper | private String getUrlParams ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { String urlParams = " point = 55.813357,37.5958585 & point = 55.811042,37.594689" ; for ( String curbside : curbsides ) urlParams += " & curbside = " + curbside ; if ( mode . equals ( " LM " ) ) urlParams += " & ch . disable = true " ; if ( mode . equals ( " flex " ) ) urlParams += " & ch . disable = true & lm . disable = true " ; if ( edgeBased != null ) urlParams += " & edge _ based = " + edgeBased ; if ( turnCosts != null ) urlParams += " & turn _ costs = " + turnCosts ; if ( profile != null ) urlParams += " & profile = " + profile ; return urlParams ; }
don-philipe/graphhopper | private String getJsonStr ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { String jsonStr = " { " ; jsonStr += " \" points \" : ▁ [ [37.5958585,55.813357 ] , [37.594689,55.811042 ] ] " ; if ( ! curbsides . isEmpty ( ) ) { assert curbsides . size ( ) == 2 ; jsonStr += " , ▁ \" curbsides \" : ▁ [ \" " + curbsides . get ( 0 ) + " \" , \" " + curbsides . get ( 1 ) + " \" ] " ; } if ( mode . equals ( " LM " ) ) jsonStr += " , ▁ \" ch . disable \" : ▁ true " ; if ( mode . equals ( " flex " ) ) jsonStr += " , ▁ \" ch . disable \" : ▁ true , ▁ \" lm . disable \" : ▁ true " ; if ( edgeBased != null ) jsonStr += " , ▁ \" edge _ based \" : ▁ " + edgeBased ; if ( turnCosts != null ) jsonStr += " , ▁ \" turn _ costs \" : ▁ " + turnCosts ; if ( profile != null ) jsonStr += " , ▁ \" profile \" : ▁ \" " + profile + " \" " ; jsonStr += " } " ; return jsonStr ; }
don-philipe/graphhopper | private Response doGet ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { return clientTarget ( app , " / route ? " + getUrlParams ( mode , profile , edgeBased , turnCosts , curbsides ) ) . request ( ) . buildGet ( ) . invoke ( ) ; }
don-philipe/graphhopper | private Response doPost ( String mode , String profile , Boolean edgeBased , Boolean turnCosts , List < String > curbsides ) { return clientTarget ( app , " / route ? " ) . request ( ) . post ( Entity . json ( getJsonStr ( mode , profile , edgeBased , turnCosts , curbsides ) ) ) ; }
Altiscale/archiva | @ Test public void testBuildSnapshot ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 2.3-20141119.064321-40 . jar " ) ) ) . isEqualTo ( " jar " ) ; }
Altiscale/archiva | @ Test public void testBuildPom ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . pom " ) ) ) . isEqualTo ( " pom " ) ; }
Altiscale/archiva | @ Test public void testBuildJar ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 - sources . jar " ) ) ) . isEqualTo ( " jar " ) ; }
Altiscale/archiva | @ Test public void testBuildTarGz ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . tar . gz " ) ) ) . isEqualTo ( " tar . gz " ) ; }
Altiscale/archiva | @ Test public void testBuildPomZip ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . pom . zip " ) ) ) . isEqualTo ( " pom . zip " ) ; }
Altiscale/archiva | @ Test public void testBuildR00 ( ) { assertThat ( builder . getExtensionFromFile ( new File ( " / tmp / foo - 1.0 . r00" ) ) ) . isEqualTo ( " r00" ) ; }
jacarrichan/eoffice | public EmpProfileDaoImpl ( ) { super ( EmpProfile . class ) ; }
jacarrichan/eoffice | public boolean checkProfileNo ( final String profileNo ) { Long count = ( Long ) this . getHibernateTemplate ( ) . execute ( new HibernateCallback ( ) { public Object doInHibernate ( Session session ) throws HibernateException , SQLException { Query query = session . createQuery ( " select ▁ count ( * ) ▁ from ▁ EmpProfile ▁ ep ▁ where ▁ ep . profileNo ▁ = ▁ ? " ) ; query . setString ( 0 , profileNo ) ; return query . uniqueResult ( ) ; } } ) ; return count . longValue ( ) == 0L ; }
arthurthouzeau/SudokuSolverGUI | public SudokuBoard ( int size ) { SIZE = size ; board = new int [ size ] [ size ] ; }
arthurthouzeau/SudokuSolverGUI | public void set ( int value , int row , int col ) { board [ row ] [ col ] = value ; }
arthurthouzeau/SudokuSolverGUI | public int get ( int row , int col ) { return board [ row ] [ col ] ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialRange ( ) { for ( int i = 0 ; i < SIZE ; i ++ ) { for ( int j = 0 ; j < SIZE ; j ++ ) { if ( board [ i ] [ j ] < 0 || board [ i ] [ j ] > SIZE ) return false ; } } return true ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialRows ( ) { BitSet bits = new BitSet ( SIZE + 1 ) ; for ( int i = 0 ; i < SIZE ; i ++ ) { for ( int j = 0 ; j < SIZE ; j ++ ) { if ( board [ i ] [ j ] != 0 && bits . get ( board [ i ] [ j ] ) ) return false ; bits . set ( board [ i ] [ j ] ) ; } bits . clear ( ) ; } return true ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialCols ( ) { BitSet bits = new BitSet ( SIZE + 1 ) ; for ( int j = 0 ; j < SIZE ; j ++ ) { for ( int i = 0 ; i < SIZE ; i ++ ) { if ( board [ i ] [ j ] != 0 && bits . get ( board [ i ] [ j ] ) ) return false ; bits . set ( board [ i ] [ j ] ) ; } bits . clear ( ) ; } return true ; }
arthurthouzeau/SudokuSolverGUI | private boolean checkInitialBoxes ( ) { BitSet bits = new BitSet ( SIZE + 1 ) ; int sqrtSize = ( int ) Math . sqrt ( SIZE ) ; for ( int i = 0 ; i < SIZE ; i += sqrtSize ) { for ( int j = 0 ; j < SIZE ; j += sqrtSize ) { for ( int k = 0 ; k < sqrtSize ; k ++ ) { for ( int l = 0 ; l < sqrtSize ; l ++ ) { if ( board [ i + k ] [ j + l ] != 0 && bits . get ( board [ i + k ] [ j + l ] ) ) return false ; bits . set ( board [ i + k ] [ j + l ] ) ; } } bits . clear ( ) ; } } return true ; }
arthurthouzeau/SudokuSolverGUI | public boolean checkInitialBoard ( ) { return ( checkInitialRange ( ) && checkInitialRows ( ) && checkInitialCols ( ) && checkInitialBoxes ( ) ) ; }
arthurthouzeau/SudokuSolverGUI | public boolean isNumValid ( int [ ] cell , int num ) { int sqrtSize = ( int ) Math . sqrt ( SIZE ) ; int boxRow = ( cell [ 0 ] / sqrtSize ) * sqrtSize ; int boxCol = ( cell [ 1 ] / sqrtSize ) * sqrtSize ; for ( int i = 0 ; i < SIZE ; i ++ ) { if ( get ( cell [ 0 ] , i ) == num || get ( i , cell [ 1 ] ) == num || get ( boxRow + ( i % sqrtSize ) , boxCol + ( i / sqrtSize ) ) == num ) return false ; } return true ; }
arthurthouzeau/SudokuSolverGUI | public void writeToCSV ( String outputFile ) throws IOException { String [ ] [ ] output = new String [ SIZE ] [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { for ( int j = 0 ; j < SIZE ; j ++ ) { output [ i ] [ j ] = String . valueOf ( get ( i , j ) ) ; } } try ( CSVWriter writer = new CSVWriter ( new FileWriter ( outputFile ) , ' , ' , CSVWriter . NO_QUOTE_CHARACTER ) ) { for ( String [ ] record : output ) writer . writeNext ( record ) ; } }
samtstern/quickstart-android | @ Before public void setUp ( ) { rootMatcher = withDecorView ( not ( is ( mActivityRule . getActivity ( ) . getWindow ( ) . getDecorView ( ) ) ) ) ; }
samtstern/quickstart-android | @ After public void tearDown ( ) { getView ( R . id . collapse_button ) . perform ( click ( ) ) ; }
samtstern/quickstart-android | @ Test public void testFiamDisplaysOnForegroundCampaign ( ) { reopen_app ( ) ; getView ( R . id . modal_root ) . check ( matches ( isDisplayed ( ) ) ) ; }
samtstern/quickstart-android | @ Test public void testFiamDisplaysContextualTriggerCampaign ( ) { onView ( withId ( R . id . eventTriggerButton ) ) . perform ( click ( ) ) ; getView ( R . id . modal_root ) . check ( matches ( isDisplayed ( ) ) ) ; }
samtstern/quickstart-android | private void reopen_app ( ) { press_recent ( ) ; press_back ( ) ; }
samtstern/quickstart-android | private void press_recent ( ) { try { UiDevice . getInstance ( getInstrumentation ( ) ) . pressRecentApps ( ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } sleep ( ) ; }
samtstern/quickstart-android | private void press_back ( ) { UiDevice . getInstance ( getInstrumentation ( ) ) . pressBack ( ) ; sleep ( ) ; }
samtstern/quickstart-android | private void sleep ( ) { try { Thread . sleep ( 3000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
samtstern/quickstart-android | @ NonNull private ViewInteraction getView ( @ IdRes int id ) { return onView ( withId ( id ) ) . inRoot ( rootMatcher ) ; }
aws/aws-sdk-java | public AWSServiceCatalogException ( String message ) { super ( message ) ; }
dagnir/aws-sdk-java | public InternalErrorException ( String message ) { super ( message ) ; }
gems-uff/dominoes | switch ( grain ) { case FILE : sql = " SELECT ▁ Distinct ( TF . NewName ) ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " ; sql = sql . concat ( " WHERE ▁ TF . newname ▁ ! = ▁ ' null ' ▁ AND ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ " ) ; sql = sql . concat ( " TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' " ) ; sql = sql . concat ( " AND ▁ TF . Newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " NewName " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName , ▁ TFL . newName ▁ as ▁ FileName ▁ " ; sql = sql . concat ( " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " ) ; sql = sql . concat ( " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ FileName ▁ ! = ▁ ' null ' ▁ " ) ; sql = sql . concat ( " AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ FileName ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " GROUP ▁ BY ▁ TCL . name , ▁ TF . name ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; rs . close ( ) ; break ; }
gems-uff/dominoes | switch ( grain ) { case FILE : { int count = 0 ; if ( cubeOptions == CubeOptions . Max_Commit_Month ) { sql = " SELECT ▁ TU . name , ▁ TC . date , ▁ TC . hashcode , ▁ TF . newname ▁ FROM ▁ TFILE ▁ TF , ▁ " ; sql = sql . concat ( " TUSER ▁ TU , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ WHERE ▁ TF . newname ▁ ! = ▁ ' null ' ▁ AND ▁ " ) ; sql = sql . concat ( " TC . userid ▁ = ▁ TU . id ▁ AND ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ " ) ; sql = sql . concat ( " TC . repoid ▁ = ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TF . newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . date ▁ desc , ▁ TC . hashcode ; " ) ; rs = smt . executeQuery ( sql ) ; Map < String , Integer > max_per_month = Commits_Month ( _repository ) ; int num_commits_per_layer = minimum ; for ( Map . Entry < String , Integer > entry : max_per_month . entrySet ( ) ) { if ( entry . getValue ( ) > minimum ) { num_commits_per_layer = entry . getValue ( ) ; System . out . println ( " Month : ▁ " + entry . getKey ( ) + " ▁ Value : ▁ " + entry . getValue ( ) ) ; } else { System . out . println ( " Using ▁ minimum : ▁ " + num_commits_per_layer ) ; } break ; } List < CommitGroup > commitGroups = new ArrayList < CommitGroup > ( ) ; int currentMonth = - 1 , currentYear = - 1 ; String currentCommitId = null ; while ( rs . next ( ) ) { String commitId = rs . getString ( " hashcode " ) ; if ( currentCommitId == null || currentCommitId . compareTo ( commitId ) != 0 ) { Calendar commitDate = Calendar . getInstance ( ) ; commitDate . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; int month = commitDate . get ( Calendar . MONTH ) ; int year = commitDate . get ( Calendar . YEAR ) ; if ( currentMonth != month || currentYear != year ) { currentMonth = month ; currentYear = year ; CommitGroup _commitGroup = new CommitGroup ( ) ; _commitGroup . matrix = new Matrix2D ( descriptor ) ; _commitGroup . year = year ; _commitGroup . month = month ; commitGroups . add ( _commitGroup ) ; } for ( CommitGroup _c : commitGroups ) if ( _c . count <= num_commits_per_layer ) _c . count ++ ; currentCommitId = commitId ; } for ( CommitGroup _c : commitGroups ) { if ( _c . count <= num_commits_per_layer ) _c . matrix . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; } } Collections . reverse ( commitGroups ) ; CommitGroup _k = commitGroups . get ( commitGroups . size ( ) - 1 ) ; _k . matrix . ExportCSV ( " Teste . txt " ) ; int _count = 0 ; for ( CommitGroup _c : commitGroups ) { cube . AddLayer ( CUBE_DEPTH_PREFIX + _count , _c . matrix ) ; _count ++ ; } } else if ( cubeOptions == CubeOptions . Month ) { sql = " SELECT ▁ TU . name , ▁ TC . date , ▁ TC . hashcode , ▁ TF . newname ▁ FROM ▁ TFILE ▁ TF , ▁ " ; sql = sql . concat ( " TUSER ▁ TU , ▁ TCOMMIT ▁ TC ▁ WHERE ▁ TF . newname ▁ ! = ▁ ' null ' ▁ AND ▁ " ) ; sql = sql . concat ( " TC . userid ▁ = ▁ TU . id ▁ AND ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ " ) ; sql = sql . concat ( " TC . id ▁ in ▁ ( ▁ " ) ; sql = sql . concat ( " SELECT ▁ TC . id ▁ FROM ▁ tcommit ▁ TC , ▁ trepository ▁ TR ▁ " ) ; sql = sql . concat ( " WHERE ▁ TC . repoid ▁ = ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . date , ▁ TC . hashcode ) ; " ) ; rs = smt . executeQuery ( sql ) ; Calendar refDateC = null ; Matrix2D layer = null ; int numRegs = 0 ; while ( rs . next ( ) ) { if ( refDateC == null ) { refDateC = Calendar . getInstance ( ) ; refDateC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; layer = new Matrix2D ( descriptor ) ; layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; } else { Calendar currentDateC = Calendar . getInstance ( ) ; Date _dt = sdf . parse ( rs . getString ( " date " ) ) ; currentDateC . setTime ( _dt ) ; if ( refDateC . get ( Calendar . MONTH ) - currentDateC . get ( Calendar . MONTH ) != 0 || refDateC . get ( Calendar . YEAR ) - currentDateC . get ( Calendar . YEAR ) != 0 ) { System . out . println ( " M " + ( refDateC . get ( Calendar . MONTH ) + 1 ) + " - year " + Integer . toString ( refDateC . get ( Calendar . YEAR ) ) . substring ( 2 ) + " : ▁ " + numRegs ) ; numRegs = 0 ; refDateC = currentDateC ; cube . AddLayer ( CUBE_DEPTH_PREFIX + count , layer ) ; layer = new Matrix2D ( descriptor ) ; count ++ ; } layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; numRegs ++ ; } } } else if ( cubeOptions == CubeOptions . Week ) { Calendar refDateStartC = null ; Calendar refDateEndC = null ; Matrix2D layer = null ; int numRegs = 0 ; SimpleDateFormat sdf2 = new SimpleDateFormat ( " yyyy - MM - dd " ) ; while ( rs . next ( ) ) { if ( refDateStartC == null ) { refDateStartC = Calendar . getInstance ( ) ; refDateStartC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; refDateEndC = Calendar . getInstance ( ) ; refDateEndC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; refDateEndC . add ( Calendar . DAY_OF_WEEK , 7 ) ; layer = new Matrix2D ( descriptor ) ; layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; } else { Calendar currentDateC = Calendar . getInstance ( ) ; Date _dt = sdf . parse ( rs . getString ( " date " ) ) ; currentDateC . setTime ( _dt ) ; if ( currentDateC . compareTo ( refDateEndC ) > 0 ) { System . out . println ( " M " + ( refDateStartC . get ( Calendar . MONTH ) + 1 ) + " - year " + Integer . toString ( refDateStartC . get ( Calendar . YEAR ) ) . substring ( 2 ) + " : ▁ " + numRegs ) ; numRegs = 0 ; refDateStartC . setTime ( _dt ) ; refDateEndC . setTime ( _dt ) ; ; refDateEndC . add ( Calendar . DAY_OF_WEEK , 7 ) ; cube . AddLayer ( CUBE_DEPTH_PREFIX + count , layer ) ; layer = new Matrix2D ( descriptor ) ; count ++ ; } layer . AddToElement ( rs . getString ( " name " ) , rs . getString ( " NewName " ) , 1 ) ; numRegs ++ ; } } } rs . close ( ) ; } break ; case METHOD : { int count = 0 ; if ( cubeOptions == CubeOptions . Max_Commit_Month ) { sql = " SELECT ▁ TC . id , ▁ TC . date , ▁ TC . hashcode , ▁ TU . name ▁ as ▁ username , ▁ TCL . name ▁ as ▁ ClassName , ▁ " ; sql = sql . concat ( " TF . name ▁ as ▁ FuncName , ▁ TFL . newname ▁ FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ " ) ; sql = sql . concat ( " TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TUser ▁ TU , ▁ trepository ▁ TR ▁ WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ " ) ; sql = sql . concat ( " AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ TFL . newname ▁ ! = ▁ ' null ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TC . userid ▁ = ▁ TU . id ▁ AND ▁ tc . repoid ▁ = ▁ ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' " ) ; sql = sql . concat ( " AND ▁ TFL . newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ tc . date ▁ desc , ▁ tc . hashcode ; " ) ; rs = smt . executeQuery ( sql ) ; Map < String , Integer > max_per_month = Commits_Month ( _repository ) ; int num_commits_per_layer = minimum ; for ( Map . Entry < String , Integer > entry : max_per_month . entrySet ( ) ) { if ( entry . getValue ( ) > minimum ) { num_commits_per_layer = entry . getValue ( ) * multiplicator ; System . out . println ( " Month : ▁ " + entry . getKey ( ) + " ▁ Value : ▁ " + entry . getValue ( ) + " ▁ Multiplicator : ▁ " + multiplicator + " Using : ▁ " + num_commits_per_layer ) ; } else { } System . out . println ( " Month : ▁ " + entry . getKey ( ) + " ▁ Value : ▁ " + entry . getValue ( ) + " ▁ Multiplicator : ▁ " + multiplicator + " Using : ▁ " + num_commits_per_layer ) ; } List < CommitGroup > commitGroups = new ArrayList < CommitGroup > ( ) ; int currentMonth = - 1 , currentYear = - 1 ; String currentCommitId = null ; while ( rs . next ( ) ) { String commitId = rs . getString ( " hashcode " ) ; if ( currentCommitId == null || currentCommitId . compareTo ( commitId ) != 0 ) { Calendar commitDate = Calendar . getInstance ( ) ; commitDate . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; int month = commitDate . get ( Calendar . MONTH ) ; int year = commitDate . get ( Calendar . YEAR ) ; if ( currentMonth != month || currentYear != year ) { currentMonth = month ; currentYear = year ; CommitGroup _commitGroup = new CommitGroup ( ) ; _commitGroup . matrix = new Matrix2D ( descriptor ) ; _commitGroup . year = year ; _commitGroup . month = month ; commitGroups . add ( _commitGroup ) ; } for ( CommitGroup _c : commitGroups ) if ( _c . count <= num_commits_per_layer ) _c . count ++ ; currentCommitId = commitId ; } for ( CommitGroup _c : commitGroups ) { if ( _c . count <= num_commits_per_layer ) _c . matrix . AddToElement ( rs . getString ( " username " ) , rs . getString ( " newname " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; } } Collections . reverse ( commitGroups ) ; int _count = 0 ; for ( CommitGroup _c : commitGroups ) { cube . AddLayer ( CUBE_DEPTH_PREFIX + _count , _c . matrix ) ; _count ++ ; } } else if ( cubeOptions == CubeOptions . Month ) { sql = " SELECT ▁ TC . id , ▁ TC . date , ▁ TC . hashcode , ▁ TU . name ▁ as ▁ username , ▁ TCL . name ▁ as ▁ ClassName , ▁ " ; sql = sql . concat ( " TF . name ▁ as ▁ FuncName , ▁ TFL . newname ▁ FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ " ) ; sql = sql . concat ( " TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TUser ▁ TU ▁ WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ " ) ; sql = sql . concat ( " AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ TFL . newname ▁ ! = ▁ ' null ' ▁ " ) ; if ( startDate != null ) sql = sql . concat ( " AND ▁ TC . date ▁ > = ▁ ' " + sdf . format ( startDate ) + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TC . userid ▁ = ▁ TU . id ▁ AND ▁ TC . id ▁ in ▁ ( ▁ " ) ; sql = sql . concat ( " SELECT ▁ TC . id ▁ FROM ▁ tcommit ▁ TC , ▁ trepository ▁ TR ▁ " ) ; sql = sql . concat ( " WHERE ▁ tc . repoid ▁ = ▁ ▁ tr . id ▁ and ▁ TR . name ▁ = ▁ ' " + _repository + " ' " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ tc . date , ▁ tc . hashcode ) ; " ) ; rs = smt . executeQuery ( sql ) ; Calendar refDateC = null ; Matrix2D layer = null ; int numRegs = 0 ; while ( rs . next ( ) ) { if ( refDateC == null ) { refDateC = Calendar . getInstance ( ) ; refDateC . setTime ( sdf . parse ( rs . getString ( " date " ) ) ) ; layer = new Matrix2D ( descriptor ) ; layer . AddToElement ( rs . getString ( " username " ) , rs . getString ( " newname " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; } else { Calendar currentDateC = Calendar . getInstance ( ) ; Date _dt = sdf . parse ( rs . getString ( " date " ) ) ; currentDateC . setTime ( _dt ) ; if ( refDateC . get ( Calendar . MONTH ) - currentDateC . get ( Calendar . MONTH ) != 0 || refDateC . get ( Calendar . YEAR ) - currentDateC . get ( Calendar . YEAR ) != 0 ) { System . out . println ( " M " + ( refDateC . get ( Calendar . MONTH ) + 1 ) + " - year " + Integer . toString ( refDateC . get ( Calendar . YEAR ) ) . substring ( 2 ) + " : ▁ " + numRegs ) ; numRegs = 0 ; refDateC = currentDateC ; cube . AddLayer ( CUBE_DEPTH_PREFIX + count , layer ) ; layer = new Matrix2D ( descriptor ) ; count ++ ; } layer . AddToElement ( rs . getString ( " username " ) , rs . getString ( " newname " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; numRegs ++ ; } } } rs . close ( ) ; } break ; }
ilscipio/scipio-erp | public XmlRpcClient ( XmlRpcClientConfig config , String keyStoreComponent , String keyStoreName , String keyAlias ) { this ( config ) ; this . keyStoreComponent = keyStoreComponent ; this . keyStoreName = keyStoreName ; this . keyAlias = keyAlias ; this . setTransportFactory ( this . getClientTransportFactory ( ) ) ; }
ilscipio/scipio-erp | public XmlRpcClient ( XmlRpcClientConfig config ) { super ( ) ; this . setConfig ( config ) ; }
ilscipio/scipio-erp | public XmlRpcTransportFactory getClientTransportFactory ( ) { if ( keyStoreComponent == null || keyStoreName == null || keyAlias == null ) { return this . getTransportFactory ( ) ; } ComponentConfig . KeystoreInfo ks = ComponentConfig . getKeystoreInfo ( keyStoreComponent , keyStoreName ) ; KeyStore keyStore = null ; try { keyStore = KeyStoreUtil . getStore ( ks . createResourceHandler ( ) . getURL ( ) , ks . getPassword ( ) , ks . getType ( ) ) ; } catch ( Exception e ) { Debug . logError ( e , " Unable ▁ to ▁ load ▁ keystore : ▁ " + keyStoreName , module ) ; } return new AliasSupportedTransportFactory ( this , keyStore , ks . getPassword ( ) , keyAlias ) ; }
radicalbit/ambari | public ComponentResourceDefinition ( ) { super ( Resource . Type . Component ) ; }
radicalbit/ambari | @ Override public String getPluralName ( ) { return " components " ; }
radicalbit/ambari | @ Override public String getSingularName ( ) { return " component " ; }
radicalbit/ambari | @ Override public Set < SubResourceDefinition > getSubResourceDefinitions ( ) { return Collections . singleton ( new SubResourceDefinition ( Resource . Type . HostComponent , Collections . singleton ( Resource . Type . Host ) , true ) ) ; }
radicalbit/ambari | @ Override public List < PostProcessor > getPostProcessors ( ) { List < PostProcessor > listProcessors = super . getPostProcessors ( ) ; listProcessors . add ( new ComponentHrefProcessor ( ) ) ; return listProcessors ; }
radicalbit/ambari | @ Override public void process ( Request request , TreeNode < Resource > resultNode , String href ) { TreeNode < Resource > parent = resultNode . getParent ( ) ; if ( parent . getParent ( ) != null && parent . getParent ( ) . getObject ( ) . getType ( ) == Resource . Type . HostComponent ) { Resource r = resultNode . getObject ( ) ; Schema schema = ClusterControllerHelper . getClusterController ( ) . getSchema ( r . getType ( ) ) ; Object serviceId = r . getPropertyValue ( schema . getKeyPropertyId ( Resource . Type . Service ) ) ; Object componentId = r . getPropertyValue ( schema . getKeyPropertyId ( r . getType ( ) ) ) ; href = href . substring ( 0 , href . indexOf ( " / hosts / " ) + 1 ) + " services / " + serviceId + " / components / " + componentId ; resultNode . setProperty ( " href " , href ) ; } else { super . process ( request , resultNode , href ) ; } }
lpandzic/beanvalidation-api | public FooValidationProvider ( ) { createdValidationProviders . add ( new SoftReference < FooValidationProvider > ( this ) ) ; }
lpandzic/beanvalidation-api | public Configuration createSpecializedConfiguration ( BootstrapState state ) { return null ; }
lpandzic/beanvalidation-api | public Configuration < ? > createGenericConfiguration ( BootstrapState state ) { return new DummyConfiguration ( ) ; }
lpandzic/beanvalidation-api | public ValidatorFactory buildValidatorFactory ( ConfigurationState configurationState ) { return new DummyValidatorFactory ( ) ; }
lpandzic/beanvalidation-api | public Configuration ignoreXmlConfiguration ( ) { return null ; }
lpandzic/beanvalidation-api | public Configuration messageInterpolator ( MessageInterpolator interpolator ) { return null ; }
lpandzic/beanvalidation-api | public Configuration traversableResolver ( TraversableResolver resolver ) { return null ; }
lpandzic/beanvalidation-api | public Configuration constraintValidatorFactory ( ConstraintValidatorFactory constraintValidatorFactory ) { return null ; }
lpandzic/beanvalidation-api | public Configuration parameterNameProvider ( ParameterNameProvider parameterNameProvider ) { return null ; }
lpandzic/beanvalidation-api | public Configuration addMapping ( InputStream stream ) { return null ; }
lpandzic/beanvalidation-api | public Configuration addProperty ( String name , String value ) { return null ; }
lpandzic/beanvalidation-api | public MessageInterpolator getDefaultMessageInterpolator ( ) { return null ; }
lpandzic/beanvalidation-api | public TraversableResolver getDefaultTraversableResolver ( ) { return null ; }
lpandzic/beanvalidation-api | public ConstraintValidatorFactory getDefaultConstraintValidatorFactory ( ) { return null ; }
lpandzic/beanvalidation-api | public ParameterNameProvider getDefaultParameterNameProvider ( ) { return null ; }
lpandzic/beanvalidation-api | public BootstrapConfiguration getBootstrapConfiguration ( ) { return null ; }
lpandzic/beanvalidation-api | public ValidatorFactory buildValidatorFactory ( ) { return new DummyValidatorFactory ( ) ; }
lpandzic/beanvalidation-api | @ Override public Validator getValidator ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public ValidatorContext usingContext ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public MessageInterpolator getMessageInterpolator ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public TraversableResolver getTraversableResolver ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public ConstraintValidatorFactory getConstraintValidatorFactory ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public ParameterNameProvider getParameterNameProvider ( ) { return null ; }
lpandzic/beanvalidation-api | @ Override public < T > T unwrap ( Class < T > type ) { return null ; }
lpandzic/beanvalidation-api | @ Override public void close ( ) { }
pikaqiuHX/basic | public Integer getMenuId ( ) { return menuId ; }
pikaqiuHX/basic | public void setMenuId ( Integer menuId ) { this . menuId = menuId ; }
pikaqiuHX/basic | public Integer getPid ( ) { return pid ; }
pikaqiuHX/basic | public void setPid ( Integer pid ) { this . pid = pid ; }
pikaqiuHX/basic | public String getMenuName ( ) { return menuName ; }
pikaqiuHX/basic | public void setMenuName ( String menuName ) { this . menuName = menuName == null ? null : menuName . trim ( ) ; }
pikaqiuHX/basic | public String getMenuImg ( ) { return menuImg ; }
pikaqiuHX/basic | public void setMenuImg ( String menuImg ) { this . menuImg = menuImg == null ? null : menuImg . trim ( ) ; }
pikaqiuHX/basic | public String getLinkUrl ( ) { return linkUrl ; }
pikaqiuHX/basic | public void setLinkUrl ( String linkUrl ) { this . linkUrl = linkUrl == null ? null : linkUrl . trim ( ) ; }
pikaqiuHX/basic | public Integer getPriority ( ) { return priority ; }
pikaqiuHX/basic | public void setPriority ( Integer priority ) { this . priority = priority ; }
pikaqiuHX/basic | public Boolean getIsDelete ( ) { return isDelete ; }
pikaqiuHX/basic | public void setIsDelete ( Boolean isDelete ) { this . isDelete = isDelete ; }
pikaqiuHX/basic | public String getPermission ( ) { return permission ; }
pikaqiuHX/basic | public void setPermission ( String permission ) { this . permission = permission == null ? null : permission . trim ( ) ; }
gkatsikas/onos | public ControlMetric ( ControlMetricType metricType , MetricValue metricValue ) { this . metricType = metricType ; this . metricValue = metricValue ; }
gkatsikas/onos | public ControlMetricType metricType ( ) { return metricType ; }
gkatsikas/onos | public MetricValue metricValue ( ) { return metricValue ; }
Hexeption/Youtube-Hacked-Client-1.8 | public ItemEgg ( ) { this . maxStackSize = 16 ; this . setCreativeTab ( CreativeTabs . tabMaterials ) ; }
Hexeption/Youtube-Hacked-Client-1.8 | public ItemStack onItemRightClick ( ItemStack itemStackIn , World worldIn , EntityPlayer playerIn ) { if ( ! playerIn . capabilities . isCreativeMode ) { -- itemStackIn . stackSize ; } worldIn . playSoundAtEntity ( playerIn , " random . bow " , 0.5F , 0.4F / ( itemRand . nextFloat ( ) * 0.4F + 0.8F ) ) ; if ( ! worldIn . isRemote ) { worldIn . spawnEntityInWorld ( new EntityEgg ( worldIn , playerIn ) ) ; } playerIn . triggerAchievement ( StatList . objectUseStats [ Item . getIdFromItem ( this ) ] ) ; return itemStackIn ; }
CHINA-JD/presto | public ByteCodeGeneratorContext ( ByteCodeExpressionVisitor byteCodeGenerator , Scope scope , CallSiteBinder callSiteBinder , FunctionRegistry registry ) { checkNotNull ( byteCodeGenerator , " byteCodeGenerator ▁ is ▁ null " ) ; checkNotNull ( scope , " scope ▁ is ▁ null " ) ; checkNotNull ( callSiteBinder , " callSiteBinder ▁ is ▁ null " ) ; checkNotNull ( registry , " registry ▁ is ▁ null " ) ; this . byteCodeGenerator = byteCodeGenerator ; this . scope = scope ; this . callSiteBinder = callSiteBinder ; this . registry = registry ; this . wasNull = scope . getVariable ( " wasNull " ) ; }
CHINA-JD/presto | public Scope getScope ( ) { return scope ; }
CHINA-JD/presto | public CallSiteBinder getCallSiteBinder ( ) { return callSiteBinder ; }
CHINA-JD/presto | public ByteCodeNode generate ( RowExpression expression ) { return expression . accept ( byteCodeGenerator , scope ) ; }
CHINA-JD/presto | public FunctionRegistry getRegistry ( ) { return registry ; }
CHINA-JD/presto | public ByteCodeNode generateCall ( FunctionInfo function , List < ByteCodeNode > arguments ) { Binding binding = callSiteBinder . bind ( function . getMethodHandle ( ) ) ; return generateInvocation ( scope , function , arguments , binding ) ; }
CHINA-JD/presto | public Variable wasNull ( ) { return wasNull ; }
Rajith90/carbon-apimgt | public TargetFaultDataCollector ( AnalyticsDataProvider provider , FaultEventType subType , RequestDataPublisher processor ) { super ( provider , subType , processor ) ; }
Rajith90/carbon-apimgt | public TargetFaultDataCollector ( AnalyticsDataProvider provider ) { this ( provider , FaultEventType . TARGET_CONNECTIVITY , new FaultyRequestDataPublisher ( ) ) ; this . provider = provider ; }
Rajith90/carbon-apimgt | @ Override public void collectFaultData ( Event faultyEvent ) { log . debug ( " handling ▁ target ▁ failure ▁ analytics ▁ events " ) ; Application application ; if ( provider . isAuthenticated ( ) && provider . isAnonymous ( ) ) { application = getAnonymousApp ( ) ; } else { application = provider . getApplication ( ) ; } faultyEvent . setApplication ( application ) ; this . processRequest ( faultyEvent ) ; }
janzoner/picasso | @ Before public void setUp ( ) { initMocks ( this ) ; }
janzoner/picasso | @ Config ( reportSdk = 12 ) @ Test public void initAddsAttachListenerWhichDefersLayoutListener ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( target ) . addOnAttachStateChangeListener ( attachListenerCaptor . capture ( ) ) ; verifyNoMoreInteractions ( observer ) ; OnAttachStateChangeListener listener = attachListenerCaptor . getValue ( ) ; listener . onViewAttachedToWindow ( target ) ; verify ( target ) . removeOnAttachStateChangeListener ( listener ) ; verify ( observer ) . addOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Config ( reportSdk = 12 ) @ Test public void initAttachedTargetSkipsAttachListener ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; doReturn ( mock ( IBinder . class ) ) . when ( target ) . getWindowToken ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( observer ) . addOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void initAttachesLayoutListenerApi11 ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( observer ) . addOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Config ( reportSdk = 12 ) @ Test public void cancelRemovesAttachListener ( ) { ImageView target = mockFitImageViewTarget ( true ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; verify ( target ) . addOnAttachStateChangeListener ( attachListenerCaptor . capture ( ) ) ; request . cancel ( ) ; verify ( target ) . removeOnAttachStateChangeListener ( attachListenerCaptor . getValue ( ) ) ; }
janzoner/picasso | @ Test public void cancelRemovesLayoutListenerApi11 ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; request . cancel ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void cancelTwiceOnlyPerformsOnce ( ) { ImageView target = mockFitImageViewTarget ( true ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target ) ; request . cancel ( ) ; request . cancel ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void cancelClearsCallback ( ) { ImageView target = mockFitImageViewTarget ( true ) ; Callback callback = mockCallback ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( mock ( RequestCreator . class ) , target , callback ) ; assertThat ( request . callback ) . isNotNull ( ) ; request . cancel ( ) ; assertThat ( request . callback ) . isNull ( ) ; }
janzoner/picasso | @ Test public void cancelClearsTag ( ) { ImageView target = mockFitImageViewTarget ( true ) ; RequestCreator creator = mock ( RequestCreator . class ) ; when ( creator . getTag ( ) ) . thenReturn ( " TAG " ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . cancel ( ) ; verify ( creator ) . clearTag ( ) ; }
janzoner/picasso | @ Test public void onLayoutSkipsIfTargetIsNull ( ) { ImageView target = mockFitImageViewTarget ( true ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; ViewTreeObserver viewTreeObserver = target . getViewTreeObserver ( ) ; request . target . clear ( ) ; request . onPreDraw ( ) ; verifyZeroInteractions ( creator ) ; verify ( viewTreeObserver ) . addOnPreDrawListener ( request ) ; verifyNoMoreInteractions ( viewTreeObserver ) ; }
janzoner/picasso | @ Test public void onLayoutSkipsIfViewTreeObserverIsDead ( ) { ImageView target = mockFitImageViewTarget ( false ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; ViewTreeObserver viewTreeObserver = target . getViewTreeObserver ( ) ; request . onPreDraw ( ) ; verify ( viewTreeObserver ) . addOnPreDrawListener ( request ) ; verify ( viewTreeObserver ) . isAlive ( ) ; verifyNoMoreInteractions ( viewTreeObserver ) ; verifyZeroInteractions ( creator ) ; }
janzoner/picasso | @ Test public void waitsForAnotherLayoutIfWidthOrHeightIsZero ( ) { ImageView target = mockFitImageViewTarget ( true ) ; when ( target . getWidth ( ) ) . thenReturn ( 0 ) ; when ( target . getHeight ( ) ) . thenReturn ( 0 ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . onPreDraw ( ) ; verify ( target . getViewTreeObserver ( ) , never ( ) ) . removeOnPreDrawListener ( request ) ; verifyZeroInteractions ( creator ) ; }
janzoner/picasso | @ Test public void cancelSkipsWithNullTarget ( ) { ImageView target = mockFitImageViewTarget ( true ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . target . clear ( ) ; request . cancel ( ) ; verify ( target . getViewTreeObserver ( ) , never ( ) ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void cancelSkipsIfViewTreeObserverIsDead ( ) { ImageView target = mockFitImageViewTarget ( false ) ; RequestCreator creator = mock ( RequestCreator . class ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . cancel ( ) ; verify ( target . getViewTreeObserver ( ) , never ( ) ) . removeOnPreDrawListener ( request ) ; }
janzoner/picasso | @ Test public void preDrawSubmitsRequestAndCleansUp ( ) { Picasso picasso = mock ( Picasso . class ) ; when ( picasso . transformRequest ( any ( Request . class ) ) ) . thenAnswer ( TRANSFORM_REQUEST_ANSWER ) ; RequestCreator creator = new RequestCreator ( picasso , URI_1 , 0 ) ; ImageView target = mockFitImageViewTarget ( true ) ; when ( target . getWidth ( ) ) . thenReturn ( 100 ) ; when ( target . getHeight ( ) ) . thenReturn ( 100 ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . onPreDraw ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; verify ( picasso ) . enqueueAndSubmit ( actionCaptor . capture ( ) ) ; Action value = actionCaptor . getValue ( ) ; assertThat ( value ) . isInstanceOf ( ImageViewAction . class ) ; assertThat ( value . getRequest ( ) . targetWidth ) . isEqualTo ( 100 ) ; assertThat ( value . getRequest ( ) . targetHeight ) . isEqualTo ( 100 ) ; }
janzoner/picasso | @ Test public void multiplePreDrawsOnlyTriggersOnce ( ) { Picasso picasso = mock ( Picasso . class ) ; when ( picasso . transformRequest ( any ( Request . class ) ) ) . thenAnswer ( TRANSFORM_REQUEST_ANSWER ) ; RequestCreator creator = new RequestCreator ( picasso , URI_1 , 0 ) ; ImageView target = mockFitImageViewTarget ( true ) ; when ( target . getWidth ( ) ) . thenReturn ( 100 ) ; when ( target . getHeight ( ) ) . thenReturn ( 100 ) ; ViewTreeObserver observer = target . getViewTreeObserver ( ) ; DeferredRequestCreator request = new DeferredRequestCreator ( creator , target ) ; request . onPreDraw ( ) ; request . onPreDraw ( ) ; verify ( observer ) . removeOnPreDrawListener ( request ) ; verify ( picasso ) . enqueueAndSubmit ( actionCaptor . capture ( ) ) ; }
jphp-compiler/jphp | @ Override public Class < ? > [ ] getOperationClasses ( ) { return new Class < ? > [ ] { long [ ] . class } ; }
jphp-compiler/jphp | @ Override public long [ ] convert ( Environment env , TraceInfo trace , Memory arg ) throws Throwable { return arg . toValue ( ArrayMemory . class ) . toLongArray ( ) ; }
jphp-compiler/jphp | @ Override public Memory unconvert ( Environment env , TraceInfo trace , long [ ] arg ) throws Throwable { return ArrayMemory . ofLongs ( arg ) . toConstant ( ) ; }
jphp-compiler/jphp | @ Override public void applyTypeHinting ( ParameterEntity parameter ) { parameter . setType ( HintType . ARRAY ) ; }
bedward70/bedward70-fitnesse-io | public RecallBinding ( String symbolName ) { super ( ) ; this . symbolName = symbolName ; }
bedward70/bedward70-fitnesse-io | public Object getValue ( ) throws RuntimeException { if ( ! Fixture . hasSymbol ( symbolName ) ) { throw new FitFailureException ( " No ▁ such ▁ symbol : ▁ " + symbolName ) ; } else { Object value = Fixture . getSymbol ( symbolName ) ; return value ; } }
bedward70/bedward70-fitnesse-io | public QueryBinding ( TypeAdapter adapter ) { super ( ) ; this . adapter = adapter ; }
bedward70/bedward70-fitnesse-io | @ Override public Object getValue ( ) throws RuntimeException { try { return adapter . get ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
bedward70/bedward70-fitnesse-io | public DefaultBuilding ( String name ) { super ( ) ; this . name = name ; }
bedward70/bedward70-fitnesse-io | @ Override public Object getValue ( ) throws RuntimeException { return name ; }
motorina0/flowable-engine | public BlueprintContextELResolver ( ) { }
motorina0/flowable-engine | public BlueprintContextELResolver ( BlueprintContainer blueprintContainer ) { this . blueprintContainer = blueprintContainer ; }
motorina0/flowable-engine | public void setBlueprintContainer ( BlueprintContainer blueprintContainer ) { this . blueprintContainer = blueprintContainer ; }
motorina0/flowable-engine | public Object getValue ( ELContext context , Object base , Object property ) { if ( base == null ) { String key = ( String ) property ; for ( String componentId : ( Set < String > ) blueprintContainer . getComponentIds ( ) ) { if ( componentId . equals ( key ) ) { context . setPropertyResolved ( true ) ; return blueprintContainer . getComponentInstance ( key ) ; } } } return null ; }
motorina0/flowable-engine | public boolean isReadOnly ( ELContext context , Object base , Object property ) { return true ; }
motorina0/flowable-engine | public void setValue ( ELContext context , Object base , Object property , Object value ) { }
motorina0/flowable-engine | public Class < ? > getCommonPropertyType ( ELContext context , Object arg ) { return Object . class ; }
motorina0/flowable-engine | public Iterator < FeatureDescriptor > getFeatureDescriptors ( ELContext context , Object arg ) { return null ; }
motorina0/flowable-engine | public Class < ? > getType ( ELContext context , Object arg1 , Object arg2 ) { return Object . class ; }
is-apps/WebproxyPortlet | @ Before public void setUp ( ) { MockitoAnnotations . initMocks ( this ) ; when ( request . getPortletSession ( ) ) . thenReturn ( session ) ; when ( session . getAttribute ( URLRewritingFilter . REWRITTEN_URLS_KEY ) ) . thenReturn ( rewrittenUrls ) ; when ( request . getPreferences ( ) ) . thenReturn ( preferences ) ; when ( preferences . getValues ( URLRewritingFilter . WHITELIST_REGEXES_KEY , new String [ ] { } ) ) . thenReturn ( new String [ ] { } ) ; filter = spy ( new URLRewritingFilter ( ) ) ; proxyResponse = new GenericContentResponseImpl ( ) ; proxyResponse . setProxiedLocation ( " http : // external . site . com / somewhere / index . html ? q = a & b = t " ) ; final Map < String , Set < String > > urlAttributes = new HashMap < String , Set < String > > ( ) ; urlAttributes . put ( " a " , Collections . singleton ( " href " ) ) ; urlAttributes . put ( " img " , Collections . singleton ( " src " ) ) ; urlAttributes . put ( " form " , Collections . singleton ( " action " ) ) ; urlAttributes . put ( " script " , Collections . singleton ( " src " ) ) ; filter . setActionElements ( urlAttributes ) ; filter . setResourceElements ( new HashMap < String , Set < String > > ( ) ) ; }
is-apps/WebproxyPortlet | @ Test public void testRelativeUrls ( ) { final Document document = Jsoup . parse ( " < div > < a ▁ href = \" / link / with / slash . html \" > Link < / a > < a ▁ href = \" link / without / slash . html \" > Link < / a > < / div > " ) ; filter . filter ( document , proxyResponse , request , response ) ; final String result = " < div > < ahref = \" http : // external . site . com / link / with / slash . html \" > Link < / a > < ahref = \" http : // external . site . com / somewhere / link / without / slash . html \" > Link < / a > < / div > " ; final String expected = document . body ( ) . html ( ) . replace ( " ▁ " , " " ) . replace ( " \n " , " " ) ; assertEquals ( result , expected ) ; }
is-apps/WebproxyPortlet | @ Test public void testProxiedUrls ( ) { when ( preferences . getValues ( URLRewritingFilter . WHITELIST_REGEXES_KEY , new String [ ] { } ) ) . thenReturn ( new String [ ] { " ^ http : // external . site . com " } ) ; doReturn ( " portletUrl " ) . when ( filter ) . createActionUrl ( any ( RenderResponse . class ) , any ( String . class ) ) ; final Document document = Jsoup . parse ( " < div > < a ▁ href = \" / link / with / slash . html \" > Link < / a > < a ▁ href = \" link / without / slash . html \" > Link < / a > < / div > " ) ; filter . filter ( document , proxyResponse , request , response ) ; final String result = " < div > < ahref = \" portletUrl \" > Link < / a > < ahref = \" portletUrl \" > Link < / a > < / div > " ; final String expected = document . body ( ) . html ( ) . replace ( " ▁ " , " " ) . replace ( " \n " , " " ) ; assertEquals ( result , expected ) ; }
is-apps/WebproxyPortlet | @ Test public void testGetBaseUrl ( ) throws URISyntaxException { final String result = filter . getBaseServerUrl ( " http : // somewhere . com / some / path ? query = nothing " ) ; assertEquals ( result , " http : // somewhere . com " ) ; }
is-apps/WebproxyPortlet | @ Test public void testFilterInlineScripts ( ) { final String expectedInlineScriptResult = " < div > test < / div > < scriptlanguage = \" JavaScript \" > functionhelloWorld ( ) { alert ( \" HellofromWebProxyPortlet ! \" ) ; } < / script > " ; final Document document = Jsoup . parse ( " < div > test < / div > < script ▁ language = \" JavaScript \" > \n " + " function ▁ helloWorld ( ) \n " + " { ▁ alert ▁ ( \" Hello ▁ from ▁ WebProxyPortlet ! \" ) ; ▁ } \n " + " < / script > " ) ; filter . filter ( document , proxyResponse , request , response ) ; final String result = document . body ( ) . html ( ) . replace ( " ▁ " , " " ) . replace ( " \n " , " " ) ; assertEquals ( expectedInlineScriptResult , result ) ; }
thombergs/wicked-charts | public ConstLabel ( final String text ) { super ( ) ; this . text = text ; }
thombergs/wicked-charts | public String getText ( ) { return text ; }
thombergs/wicked-charts | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( text == null ) ? 0 : text . hashCode ( ) ) ; return result ; }
thombergs/wicked-charts | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ConstLabel other = ( ConstLabel ) obj ; if ( text == null ) { if ( other . text != null ) return false ; } else if ( ! text . equals ( other . text ) ) return false ; return true ; }
thombergs/wicked-charts | @ Override public String toString ( ) { return " ConstLabel ▁ [ text = " + text + " ] " ; }
almighty/keycloak | @ Before public void beforeAbstractKeycloakTest ( ) throws Exception { adminClient = testContext . getAdminClient ( ) ; if ( adminClient == null ) { String authServerContextRoot = suiteContext . getAuthServerInfo ( ) . getContextRoot ( ) . toString ( ) ; adminClient = AdminClientUtil . createAdminClient ( suiteContext . isAdapterCompatTesting ( ) , authServerContextRoot ) ; testContext . setAdminClient ( adminClient ) ; } getTestingClient ( ) ; adminUser = createAdminUserRepresentation ( ) ; setDefaultPageUriParameters ( ) ; TestEventsLogger . setDriver ( driver ) ; if ( ! AuthServerTestEnricher . AUTH_SERVER_CLUSTER ) { updateMasterAdminPassword ( ) ; } if ( testContext . getTestRealmReps ( ) == null ) { importTestRealms ( ) ; if ( ! isImportAfterEachMethod ( ) ) { testContext . setTestRealmReps ( testRealmReps ) ; } } oauth . init ( adminClient , driver ) ; }
almighty/keycloak | @ After public void afterAbstractKeycloakTest ( ) { if ( resetTimeOffset ) { resetTimeOffset ( ) ; } if ( isImportAfterEachMethod ( ) ) { log . info ( " removing ▁ test ▁ realms ▁ after ▁ test ▁ method " ) ; for ( RealmRepresentation testRealm : testRealmReps ) { removeRealm ( testRealm . getRealm ( ) ) ; } } else { List < RealmRepresentation > realms = testContext . getTestRealmReps ( ) ; for ( RealmRepresentation realm : realms ) { adminClient . realm ( realm . getRealm ( ) ) . logoutAll ( ) ; } for ( TestCleanup cleanup : testContext . getCleanups ( ) . values ( ) ) { cleanup . executeCleanup ( ) ; } testContext . getCleanups ( ) . clear ( ) ; } }
almighty/keycloak | protected TestCleanup getCleanup ( String realmName ) { return testContext . getOrCreateCleanup ( realmName ) ; }
almighty/keycloak | protected TestCleanup getCleanup ( ) { return getCleanup ( " test " ) ; }
almighty/keycloak | protected boolean isImportAfterEachMethod ( ) { return false ; }
almighty/keycloak | protected void updateMasterAdminPassword ( ) { if ( ! suiteContext . isAdminPasswordUpdated ( ) ) { log . debug ( " updating ▁ admin ▁ password " ) ; welcomePage . navigateTo ( ) ; if ( ! welcomePage . isPasswordSet ( ) ) { welcomePage . setPassword ( " admin " , " admin " ) ; } suiteContext . setAdminPasswordUpdated ( true ) ; } }
almighty/keycloak | public void deleteAllCookiesForMasterRealm ( ) { deleteAllCookiesForRealm ( accountPage ) ; }
almighty/keycloak | protected void deleteAllCookiesForRealm ( Account realmAccountPage ) { realmAccountPage . navigateTo ( ) ; log . info ( " deleting ▁ cookies ▁ in ▁ ' " + realmAccountPage . getAuthRealm ( ) + " ' ▁ realm " ) ; driver . manage ( ) . deleteAllCookies ( ) ; }
almighty/keycloak | protected void deleteAllCookiesForRealm ( String realmName ) { driver . navigate ( ) . to ( oauth . AUTH_SERVER_ROOT + " / realms / " + realmName + " / account " ) ; log . info ( " deleting ▁ cookies ▁ in ▁ ' " + realmName + " ' ▁ realm " ) ; driver . manage ( ) . deleteAllCookies ( ) ; }
almighty/keycloak | public void setDefaultPageUriParameters ( ) { masterRealmPage . setAuthRealm ( MASTER ) ; loginPage . setAuthRealm ( MASTER ) ; }
almighty/keycloak | public KeycloakTestingClient getTestingClient ( ) { if ( testingClient == null ) { testingClient = testContext . getTestingClient ( ) ; if ( testingClient == null ) { String authServerContextRoot = suiteContext . getAuthServerInfo ( ) . getContextRoot ( ) . toString ( ) ; testingClient = KeycloakTestingClient . getInstance ( authServerContextRoot + " / auth " ) ; testContext . setTestingClient ( testingClient ) ; } } return testingClient ; }
almighty/keycloak | public TestContext getTestContext ( ) { return testContext ; }
almighty/keycloak | public Keycloak getAdminClient ( ) { return adminClient ; }
almighty/keycloak | private void addTestRealms ( ) { log . debug ( " loading ▁ test ▁ realms " ) ; if ( testRealmReps == null ) { testRealmReps = new ArrayList < > ( ) ; } if ( testRealmReps . isEmpty ( ) ) { addTestRealms ( testRealmReps ) ; } }
almighty/keycloak | public void importTestRealms ( ) { addTestRealms ( ) ; log . info ( " importing ▁ test ▁ realms " ) ; for ( RealmRepresentation testRealm : testRealmReps ) { importRealm ( testRealm ) ; } }
almighty/keycloak | private UserRepresentation createAdminUserRepresentation ( ) { UserRepresentation adminUserRep = new UserRepresentation ( ) ; adminUserRep . setUsername ( ADMIN ) ; setPasswordFor ( adminUserRep , ADMIN ) ; return adminUserRep ; }
almighty/keycloak | public void importRealm ( RealmRepresentation realm ) { log . debug ( " importing ▁ realm : ▁ " + realm . getRealm ( ) ) ; try { RealmResource realmResource = adminClient . realms ( ) . realm ( realm . getRealm ( ) ) ; RealmRepresentation rRep = realmResource . toRepresentation ( ) ; log . debug ( " realm ▁ already ▁ exists ▁ on ▁ server , ▁ re - importing " ) ; realmResource . remove ( ) ; } catch ( NotFoundException nfe ) { } adminClient . realms ( ) . create ( realm ) ; }
almighty/keycloak | public void removeRealm ( String realmName ) { log . info ( " removing ▁ realm : ▁ " + realmName ) ; try { adminClient . realms ( ) . realm ( realmName ) . remove ( ) ; } catch ( NotFoundException e ) { } }
almighty/keycloak | public RealmsResource realmsResouce ( ) { return adminClient . realms ( ) ; }
almighty/keycloak | public String createUser ( String realm , String username , String password , String ... requiredActions ) { List < String > requiredUserActions = Arrays . asList ( requiredActions ) ; UserRepresentation homer = new UserRepresentation ( ) ; homer . setEnabled ( true ) ; homer . setUsername ( username ) ; homer . setRequiredActions ( requiredUserActions ) ; return ApiUtil . createUserAndResetPasswordWithAdminClient ( adminClient . realm ( realm ) , homer , password ) ; }
almighty/keycloak | public void setRequiredActionEnabled ( String realm , String requiredAction , boolean enabled , boolean defaultAction ) { AuthenticationManagementResource managementResource = adminClient . realm ( realm ) . flows ( ) ; RequiredActionProviderRepresentation action = managementResource . getRequiredAction ( requiredAction ) ; action . setEnabled ( enabled ) ; action . setDefaultAction ( defaultAction ) ; managementResource . updateRequiredAction ( requiredAction , action ) ; }
almighty/keycloak | public void setRequiredActionEnabled ( String realm , String userId , String requiredAction , boolean enabled ) { UsersResource usersResource = adminClient . realm ( realm ) . users ( ) ; UserResource userResource = usersResource . get ( userId ) ; UserRepresentation userRepresentation = userResource . toRepresentation ( ) ; List < String > requiredActions = userRepresentation . getRequiredActions ( ) ; if ( enabled && ! requiredActions . contains ( requiredAction ) ) { requiredActions . add ( requiredAction ) ; } else if ( ! enabled && requiredActions . contains ( requiredAction ) ) { requiredActions . remove ( requiredAction ) ; } userResource . update ( userRepresentation ) ; }
almighty/keycloak | public void setTimeOffset ( int offset ) { String response = invokeTimeOffset ( offset ) ; resetTimeOffset = offset != 0 ; log . debugv ( " Set ▁ time ▁ offset , ▁ response ▁ { 0 } " , response ) ; }
almighty/keycloak | public void resetTimeOffset ( ) { String response = invokeTimeOffset ( 0 ) ; resetTimeOffset = false ; log . debugv ( " Reset ▁ time ▁ offset , ▁ response ▁ { 0 } " , response ) ; }
almighty/keycloak | public int getCurrentTime ( ) { return Time . currentTime ( ) ; }
almighty/keycloak | private String invokeTimeOffset ( int offset ) { Time . setOffset ( offset ) ; Map result = testingClient . testing ( ) . setTimeOffset ( Collections . singletonMap ( " offset " , String . valueOf ( offset ) ) ) ; return String . valueOf ( result ) ; }
almighty/keycloak | private void loadConstantsProperties ( ) throws ConfigurationException { constantsProperties = new PropertiesConfiguration ( System . getProperty ( " testsuite . constants " ) ) ; constantsProperties . setThrowExceptionOnMissing ( true ) ; }
almighty/keycloak | protected PropertiesConfiguration getConstantsProperties ( ) throws ConfigurationException { if ( constantsProperties == null ) { loadConstantsProperties ( ) ; } return constantsProperties ; }
almighty/keycloak | public URI getAuthServerRoot ( ) { try { return KeycloakUriBuilder . fromUri ( suiteContext . getAuthServerInfo ( ) . getContextRoot ( ) . toURI ( ) ) . path ( " / auth / " ) . build ( ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } }
JavaSaBr/jME3-SpaceShift-Editor | public GlobalBottomToolSplitPane ( @ NotNull Scene scene ) { super ( scene , EditorConfig . getInstance ( ) ) ; setOrientation ( Orientation . VERTICAL ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void addElements ( @ NotNull TabToolComponent toolComponent , @ NotNull Node other ) { getItems ( ) . setAll ( other , toolComponent ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void addListeners ( @ NotNull TabToolComponent toolComponent ) { ObservableUtils . onChange ( toolComponent . heightProperty ( ) , this :: handleToolChanged ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void bindToScene ( ) { ObservableUtils . onChange ( scene . heightProperty ( ) , number -> handleSceneChanged ( getSceneSize ( ) ) ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected boolean loadCollapsed ( ) { return getConfig ( ) . isGlobalBottomToolCollapsed ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected int loadSize ( ) { return getConfig ( ) . getGlobalBottomToolHeight ( ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void storeCollapsed ( boolean collapsed ) { getConfig ( ) . setGlobalBottomToolCollapsed ( collapsed ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected void storeSize ( int size ) { getConfig ( ) . setGlobalBottomToolHeight ( size ) ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected double getCollapsedPosition ( ) { return 1 ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected double getSceneSize ( ) { var height = scene . getHeight ( ) ; return Double . compare ( height , 0D ) == 0 ? scene . getHeight ( ) : height ; }
JavaSaBr/jME3-SpaceShift-Editor | @ Override @ FxThread protected double getExpandPosition ( double toolSize , double sceneSize ) { return 1D - super . getExpandPosition ( toolSize , sceneSize ) ; }
Nzen/PD-Litmus | public LitmusFrame ( ) { java . util . LinkedList < Transmix > hierarchy = new java . util . LinkedList < > ( ) ; hierarchy . add ( new Transmix ( " C : \\ users \\ Nzen \\ Downloads " , readSpecificFile ( " hasCode . html " ) ) ) ; Litmus semanticColor = new Litmus ( ) ; hierarchy = semanticColor . stain ( hierarchy ) ; printSpecificFile ( hierarchy ) ; System . out . println ( " LF ( ) ▁ file ▁ pooped , ▁ go ▁ check ▁ it " ) ; }
Nzen/PD-Litmus | final public String readSpecificFile ( String fileName ) { String got = " " ; try { java . nio . file . Path relPath = java . nio . file . Paths . get ( fileName ) ; byte [ ] encoded = java . nio . file . Files . readAllBytes ( relPath ) ; got = new String ( encoded , java . nio . charset . StandardCharsets . UTF_8 ) ; } catch ( java . io . IOException ioe ) { System . err . println ( " LF . rsf ( ) ▁ didn ' t ▁ get ▁ a ▁ real ▁ file " ) ; } return got ; }
Nzen/PD-Litmus | final public void printSpecificFile ( java . util . LinkedList < Transmix > postPlugin ) { String outFile = " hasCodeResult . html " ; java . nio . file . Path relPath = java . nio . file . Paths . get ( outFile ) ; try { java . io . BufferedWriter paper = java . nio . file . Files . newBufferedWriter ( relPath , java . nio . charset . StandardCharsets . UTF_8 , java . nio . file . StandardOpenOption . TRUNCATE_EXISTING ) ; paper . append ( postPlugin . getFirst ( ) . gContent ( ) ) ; paper . close ( ) ; } catch ( java . io . IOException ioe ) { System . err . println ( " LF . rsf ( ) ▁ had ▁ some ▁ I / O ▁ problem . ▁ there ' s ▁ like ▁ five ▁ options " ) ; } }
spohnan/geowave | public HdfsUrlStreamHandlerFactory ( ) { this ( null ) ; }
spohnan/geowave | public HdfsUrlStreamHandlerFactory ( final URLStreamHandlerFactory delegate ) { this . delegate = Optional . ofNullable ( delegate ) ; }
spohnan/geowave | @ Override public URLStreamHandler createURLStreamHandler ( final String protocol ) { final URLStreamHandler urlStreamHandler = super . createURLStreamHandler ( protocol ) ; if ( urlStreamHandler != null ) { return urlStreamHandler ; } return delegate . map ( factory -> factory . createURLStreamHandler ( protocol ) ) . orElse ( null ) ; }
boneman1231/org.apache.felix | public HttpServiceImpl ( Bundle bundle , ServletContext context , HandlerRegistry handlerRegistry , ServletContextAttributeListener servletAttributeListener , boolean sharedContextAttributes ) { this . bundle = bundle ; this . handlerRegistry = handlerRegistry ; this . localServlets = new HashSet < Servlet > ( ) ; this . localFilters = new HashSet < Filter > ( ) ; this . contextManager = new ServletContextManager ( this . bundle , context , servletAttributeListener , sharedContextAttributes ) ; }
boneman1231/org.apache.felix | private ExtServletContext getServletContext ( HttpContext context ) { if ( context == null ) { context = createDefaultHttpContext ( ) ; } return this . contextManager . getServletContext ( context ) ; }
boneman1231/org.apache.felix | public void registerFilter ( Filter filter , String pattern , Dictionary initParams , int ranking , HttpContext context ) throws ServletException { if ( filter == null ) { throw new IllegalArgumentException ( " Filter ▁ must ▁ not ▁ be ▁ null " ) ; } FilterHandler handler = new FilterHandler ( getServletContext ( context ) , filter , pattern , ranking ) ; handler . setInitParams ( initParams ) ; this . handlerRegistry . addFilter ( handler ) ; this . localFilters . add ( filter ) ; }
boneman1231/org.apache.felix | public void unregisterFilter ( Filter filter ) { unregisterFilter ( filter , true ) ; }
boneman1231/org.apache.felix | public void unregisterServlet ( Servlet servlet ) { unregisterServlet ( servlet , true ) ; }
boneman1231/org.apache.felix | if ( servlet == null ) { throw new IllegalArgumentException ( " Servlet ▁ must ▁ not ▁ be ▁ null " ) ; }
boneman1231/org.apache.felix | if ( ! isAliasValid ( alias ) ) { throw new IllegalArgumentException ( " Malformed ▁ servlet ▁ alias ▁ [ " + alias + " ] " ) ; }
boneman1231/org.apache.felix | public void registerResources ( String alias , String name , HttpContext context ) throws NamespaceException { if ( ! isNameValid ( name ) ) { throw new IllegalArgumentException ( " Malformed ▁ resource ▁ name ▁ [ " + name + " ] " ) ; } try { Servlet servlet = new ResourceServlet ( name ) ; registerServlet ( alias , servlet , null , context ) ; } catch ( ServletException e ) { SystemLogger . error ( " Failed ▁ to ▁ register ▁ resources " , e ) ; } }
boneman1231/org.apache.felix | public void unregister ( String alias ) { unregisterServlet ( this . handlerRegistry . getServletByAlias ( alias ) ) ; }
boneman1231/org.apache.felix | public HttpContext createDefaultHttpContext ( ) { return new DefaultHttpContext ( this . bundle ) ; }
boneman1231/org.apache.felix | public void unregisterAll ( ) { HashSet < Servlet > servlets = new HashSet < Servlet > ( this . localServlets ) ; for ( Servlet servlet : servlets ) { unregisterServlet ( servlet , false ) ; } HashSet < Filter > filters = new HashSet < Filter > ( this . localFilters ) ; for ( Filter fiter : filters ) { unregisterFilter ( fiter , false ) ; } }
boneman1231/org.apache.felix | private void unregisterFilter ( Filter filter , final boolean destroy ) { if ( filter != null ) { this . handlerRegistry . removeFilter ( filter , destroy ) ; this . localFilters . remove ( filter ) ; } }
boneman1231/org.apache.felix | private void unregisterServlet ( Servlet servlet , final boolean destroy ) { if ( servlet != null ) { this . handlerRegistry . removeServlet ( servlet , destroy ) ; this . localServlets . remove ( servlet ) ; } }
boneman1231/org.apache.felix | private boolean isNameValid ( String name ) { if ( name == null ) { return false ; } if ( ! name . equals ( " / " ) && name . endsWith ( " / " ) ) { return false ; } return true ; }
boneman1231/org.apache.felix | private boolean isAliasValid ( String alias ) { if ( alias == null ) { return false ; } if ( ! alias . equals ( " / " ) && ( ! alias . startsWith ( " / " ) || alias . endsWith ( " / " ) ) ) { return false ; } return true ; }
freeVM/freeVM | public void testNullClip ( ) { try { GraphicsConfiguration gconf = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; VolatileImage vim = gconf . createCompatibleVolatileImage ( 10 , 10 ) ; Graphics2D g2 = ( Graphics2D ) vim . getGraphics ( ) ; g2 . setClip ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( " Cannot ▁ set ▁ null ▁ clip " ) ; } }
freeVM/freeVM | public void testCopyArea ( ) { GraphicsConfiguration gconf = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; VolatileImage vim = gconf . createCompatibleVolatileImage ( 20 , 20 ) ; Graphics2D g2 = ( Graphics2D ) vim . getGraphics ( ) ; g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( 0 , 0 , 20 , 20 ) ; g2 . setColor ( Color . RED ) ; g2 . fillRect ( 2 , 2 , 1 , 1 ) ; g2 . copyArea ( 2 , 2 , 1 , 1 , 2 , 4 ) ; int pix [ ] = vim . getSnapshot ( ) . getRaster ( ) . getPixel ( 4 , 6 , ( int [ ] ) null ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 0 ] , 255 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 1 ] , 0 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 2 ] , 0 ) ; g2 . setTransform ( AffineTransform . getTranslateInstance ( 2 , 2 ) ) ; g2 . copyArea ( 0 , 0 , 1 , 1 , 4 , 8 ) ; pix = vim . getSnapshot ( ) . getRaster ( ) . getPixel ( 6 , 10 , ( int [ ] ) null ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 0 ] , 255 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 1 ] , 0 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 2 ] , 0 ) ; }
Joybeanx/yogg | public YoggException ( ) { super ( ) ; }
Joybeanx/yogg | public YoggException ( String message ) { super ( message ) ; }
Joybeanx/yogg | public YoggException ( String messageTemplate , Object ... args ) { super ( String . format ( messageTemplate , args ) ) ; }
Joybeanx/yogg | public YoggException ( String message , Throwable cause ) { super ( message , cause ) ; }
Joybeanx/yogg | public YoggException ( Throwable cause , String messageTemplate , Object ... args ) { super ( String . format ( messageTemplate , args ) , cause ) ; }
Joybeanx/yogg | public YoggException ( Throwable cause ) { super ( cause ) ; }
no-go/oLEDBluetoothMap | public void setNRF51822 ( boolean b , boolean isSlow ) { if ( b ) { CCCD = UUID . fromString ( CCCD_nRF ) ; RX_SERVICE_UUID = UUID . fromString ( SERV_nRF ) ; RX_CHAR_UUID = UUID . fromString ( RXUID_nRF ) ; TX_CHAR_UUID = UUID . fromString ( TXUID_nRF ) ; byteMS = MS_nRF ; } else { CCCD = UUID . fromString ( CCCD_HM10 ) ; RX_SERVICE_UUID = UUID . fromString ( SERV_HM10 ) ; RX_CHAR_UUID = UUID . fromString ( RXUID_HM10 ) ; TX_CHAR_UUID = UUID . fromString ( TXUID_HM10 ) ; byteMS = MS_HM10 ; } if ( isSlow ) byteMS = 180 ; }
no-go/oLEDBluetoothMap | private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback ( ) { @ Override public void onConnectionStateChange ( BluetoothGatt gatt , int status , int newState ) { String intentAction ; if ( newState == BluetoothProfile . STATE_CONNECTED ) { intentAction = ACTION_GATT_CONNECTED ; broadcastUpdate ( intentAction ) ; Log . i ( TAG , " Connected ▁ to ▁ GATT ▁ server . " ) ; Log . i ( TAG , " Attempting ▁ to ▁ start ▁ service ▁ discovery : " + mBluetoothGatt . discoverServices ( ) ) ; } else if ( newState == BluetoothProfile . STATE_DISCONNECTED ) { intentAction = ACTION_GATT_DISCONNECTED ; Log . i ( TAG , " Disconnected ▁ from ▁ GATT ▁ server . " ) ; broadcastUpdate ( intentAction ) ; } } @ Override public void onServicesDiscovered ( BluetoothGatt gatt , int status ) { if ( status == BluetoothGatt . GATT_SUCCESS ) { Log . w ( TAG , " mBluetoothGatt ▁ = ▁ " + mBluetoothGatt ) ; broadcastUpdate ( ACTION_GATT_SERVICES_DISCOVERED ) ; } else { Log . w ( TAG , " onServicesDiscovered ▁ received : ▁ " + status ) ; } } @ Override public void onCharacteristicRead ( BluetoothGatt gatt , BluetoothGattCharacteristic characteristic , int status ) { if ( status == BluetoothGatt . GATT_SUCCESS ) { broadcastUpdate ( ACTION_DATA_AVAILABLE , characteristic ) ; } } @ Override public void onCharacteristicChanged ( BluetoothGatt gatt , BluetoothGattCharacteristic characteristic ) { broadcastUpdate ( ACTION_DATA_AVAILABLE , characteristic ) ; } }
no-go/oLEDBluetoothMap | private void broadcastUpdate ( final String action ) { final Intent intent = new Intent ( action ) ; LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( intent ) ; }
no-go/oLEDBluetoothMap | private void broadcastUpdate ( final String action , final BluetoothGattCharacteristic characteristic ) { final Intent intent = new Intent ( action ) ; if ( TX_CHAR_UUID . equals ( characteristic . getUuid ( ) ) ) { Log . d ( TAG , characteristic . getValue ( ) . toString ( ) ) ; intent . putExtra ( EXTRA_DATA , characteristic . getValue ( ) ) ; } else { } LocalBroadcastManager . getInstance ( this ) . sendBroadcast ( intent ) ; }
no-go/oLEDBluetoothMap | UartService getService ( ) { return UartService . this ; }
no-go/oLEDBluetoothMap | @ Override public IBinder onBind ( Intent intent ) { return mBinder ; }
no-go/oLEDBluetoothMap | @ Override public boolean onUnbind ( Intent intent ) { close ( ) ; return super . onUnbind ( intent ) ; }
no-go/oLEDBluetoothMap | public boolean initialize ( ) { if ( mBluetoothManager == null ) { mBluetoothManager = ( BluetoothManager ) getSystemService ( Context . BLUETOOTH_SERVICE ) ; if ( mBluetoothManager == null ) return false ; } mBluetoothAdapter = mBluetoothManager . getAdapter ( ) ; if ( mBluetoothAdapter == null ) return false ; return true ; }
no-go/oLEDBluetoothMap | public boolean connect ( final String address ) { if ( mBluetoothAdapter == null || address == null ) return false ; if ( mBluetoothDeviceAddress != null && address . equals ( mBluetoothDeviceAddress ) && mBluetoothGatt != null ) { if ( mBluetoothGatt . connect ( ) ) { return true ; } else { return false ; } } final BluetoothDevice device = mBluetoothAdapter . getRemoteDevice ( address ) ; if ( device == null ) return false ; mBluetoothGatt = device . connectGatt ( this , false , mGattCallback ) ; mBluetoothDeviceAddress = address ; return true ; }
no-go/oLEDBluetoothMap | public void disconnect ( ) { if ( mBluetoothAdapter == null || mBluetoothGatt == null ) return ; mBluetoothGatt . disconnect ( ) ; }
no-go/oLEDBluetoothMap | public void close ( ) { if ( mBluetoothGatt == null ) { return ; } mBluetoothDeviceAddress = null ; mBluetoothGatt . close ( ) ; mBluetoothGatt = null ; }
no-go/oLEDBluetoothMap | public void readCharacteristic ( BluetoothGattCharacteristic characteristic ) { if ( mBluetoothAdapter == null || mBluetoothGatt == null ) { return ; } mBluetoothGatt . readCharacteristic ( characteristic ) ; }
no-go/oLEDBluetoothMap | public void enableTXNotification ( ) { BluetoothGattService RxService = mBluetoothGatt . getService ( RX_SERVICE_UUID ) ; if ( RxService == null ) { broadcastUpdate ( DEVICE_DOES_NOT_SUPPORT_UART ) ; return ; } BluetoothGattCharacteristic TxChar = RxService . getCharacteristic ( TX_CHAR_UUID ) ; if ( TxChar == null ) { broadcastUpdate ( DEVICE_DOES_NOT_SUPPORT_UART ) ; return ; } mBluetoothGatt . setCharacteristicNotification ( TxChar , true ) ; BluetoothGattDescriptor descriptor = TxChar . getDescriptor ( CCCD ) ; descriptor . setValue ( BluetoothGattDescriptor . ENABLE_NOTIFICATION_VALUE ) ; mBluetoothGatt . writeDescriptor ( descriptor ) ; }
no-go/oLEDBluetoothMap | public void writeRXCharacteristic ( byte [ ] val ) { new AsyncTask < byte [ ] , Void , Void > ( ) { @ Override protected Void doInBackground ( byte [ ] ... bytes ) { byte [ ] value = bytes [ 0 ] ; int packs = ( int ) Math . ceil ( ( float ) value . length / ( float ) BYTE_LIMIT ) ; int finish = BYTE_LIMIT ; int offset ; for ( int i = 0 ; i < packs ; i ++ ) { offset = i * BYTE_LIMIT ; if ( ( offset + BYTE_LIMIT ) >= value . length ) { finish = value . length - offset ; } byte [ ] outputBytes = new byte [ finish ] ; System . arraycopy ( value , offset , outputBytes , 0 , finish ) ; BluetoothGattService RxService = mBluetoothGatt . getService ( RX_SERVICE_UUID ) ; BluetoothGattCharacteristic RxChar = RxService . getCharacteristic ( RX_CHAR_UUID ) ; RxChar . setValue ( outputBytes ) ; mBluetoothGatt . writeCharacteristic ( RxChar ) ; try { Thread . sleep ( byteMS ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } return null ; } } . execute ( val ) ; }
no-go/oLEDBluetoothMap | public List < BluetoothGattService > getSupportedGattServices ( ) { if ( mBluetoothGatt == null ) return null ; return mBluetoothGatt . getServices ( ) ; }
sunsuk7tp/MyCassandra | protected RenameColumnFamily ( ) { }
sunsuk7tp/MyCassandra | private KSMetaData makeNewKeyspaceDefinition ( KSMetaData ksm ) { CFMetaData oldCfm = ksm . cfMetaData ( ) . get ( oldName ) ; List < CFMetaData > newCfs = new ArrayList < CFMetaData > ( ksm . cfMetaData ( ) . values ( ) ) ; newCfs . remove ( oldCfm ) ; assert newCfs . size ( ) == ksm . cfMetaData ( ) . size ( ) - 1 ; CFMetaData newCfm = CFMetaData . rename ( oldCfm , newName ) ; newCfs . add ( newCfm ) ; return new KSMetaData ( ksm . name , ksm . strategyClass , ksm . strategyOptions , ksm . replicationFactor , newCfs . toArray ( new CFMetaData [ newCfs . size ( ) ] ) ) ; }
sunsuk7tp/MyCassandra | @ Override public void applyModels ( ) throws IOException { KSMetaData oldKsm = DatabaseDescriptor . getTableDefinition ( tableName ) ; CFMetaData . purge ( oldKsm . cfMetaData ( ) . get ( oldName ) ) ; KSMetaData ksm = makeNewKeyspaceDefinition ( DatabaseDescriptor . getTableDefinition ( tableName ) ) ; try { CFMetaData . map ( ksm . cfMetaData ( ) . get ( newName ) ) ; } catch ( ConfigurationException ex ) { throw new RuntimeException ( ex ) ; } DatabaseDescriptor . setTableDefinition ( ksm , newVersion ) ; if ( ! clientMode ) { Table . open ( ksm . name ) . renameCf ( cfId , newName ) ; } }
sunsuk7tp/MyCassandra | public void subdeflate ( org . apache . cassandra . db . migration . avro . Migration mi ) { org . apache . cassandra . db . migration . avro . RenameColumnFamily rcf = new org . apache . cassandra . db . migration . avro . RenameColumnFamily ( ) ; rcf . ksname = new org . apache . avro . util . Utf8 ( tableName ) ; rcf . cfid = cfId ; rcf . old_cfname = new org . apache . avro . util . Utf8 ( oldName ) ; rcf . new_cfname = new org . apache . avro . util . Utf8 ( newName ) ; mi . migration = rcf ; }
sunsuk7tp/MyCassandra | public void subinflate ( org . apache . cassandra . db . migration . avro . Migration mi ) { org . apache . cassandra . db . migration . avro . RenameColumnFamily rcf = ( org . apache . cassandra . db . migration . avro . RenameColumnFamily ) mi . migration ; tableName = rcf . ksname . toString ( ) ; cfId = rcf . cfid ; oldName = rcf . old_cfname . toString ( ) ; newName = rcf . new_cfname . toString ( ) ; }
sunsuk7tp/MyCassandra | @ Override public String toString ( ) { return String . format ( " Rename ▁ column ▁ family ▁ ( % d ) ▁ % s . % s ▁ to ▁ % s . % s " , cfId , tableName , oldName , tableName , newName ) ; }
jbonofre/beam | @ ProcessElement public void processElement ( ProcessContext context , BoundedWindow window ) { context . output ( " MainOutput " + context . element ( ) ) ; context . output ( additionalOutput , " AdditionalOutput " + context . element ( ) ) ; this . window = window ; }
jbonofre/beam | @ FinishBundle public void finishBundle ( FinishBundleContext context ) { if ( window != null ) { context . output ( " FinishBundle " , window . maxTimestamp ( ) , window ) ; window = null ; } }
jbonofre/beam | @ Test public void testCreatingAndProcessingDoFn ( ) throws Exception { String pTransformId = " pTransformId " ; String mainOutputId = "101" ; String additionalOutputId = "102" ; DoFnInfo < ? , ? > doFnInfo = DoFnInfo . forFn ( new TestDoFn ( ) , WindowingStrategy . globalDefault ( ) , ImmutableList . of ( ) , StringUtf8Coder . of ( ) , Long . parseLong ( mainOutputId ) , ImmutableMap . of ( Long . parseLong ( mainOutputId ) , TestDoFn . mainOutput , Long . parseLong ( additionalOutputId ) , TestDoFn . additionalOutput ) ) ; RunnerApi . FunctionSpec functionSpec = RunnerApi . FunctionSpec . newBuilder ( ) . setUrn ( ParDoTranslation . CUSTOM_JAVA_DO_FN_URN ) . setPayload ( ByteString . copyFrom ( SerializableUtils . serializeToByteArray ( doFnInfo ) ) ) . build ( ) ; RunnerApi . PTransform pTransform = RunnerApi . PTransform . newBuilder ( ) . setSpec ( functionSpec ) . putInputs ( " inputA " , " inputATarget " ) . putInputs ( " inputB " , " inputBTarget " ) . putOutputs ( mainOutputId , " mainOutputTarget " ) . putOutputs ( additionalOutputId , " additionalOutputTarget " ) . build ( ) ; List < WindowedValue < String > > mainOutputValues = new ArrayList < > ( ) ; List < WindowedValue < String > > additionalOutputValues = new ArrayList < > ( ) ; Multimap < String , FnDataReceiver < WindowedValue < ? > > > consumers = HashMultimap . create ( ) ; consumers . put ( " mainOutputTarget " , ( FnDataReceiver ) ( FnDataReceiver < WindowedValue < String > > ) mainOutputValues :: add ) ; consumers . put ( " additionalOutputTarget " , ( FnDataReceiver ) ( FnDataReceiver < WindowedValue < String > > ) additionalOutputValues :: add ) ; List < ThrowingRunnable > startFunctions = new ArrayList < > ( ) ; List < ThrowingRunnable > finishFunctions = new ArrayList < > ( ) ; new FnApiDoFnRunner . Factory < > ( ) . createRunnerForPTransform ( PipelineOptionsFactory . create ( ) , null , null , pTransformId , pTransform , Suppliers . ofInstance ( "57L " ) :: get , Collections . emptyMap ( ) , Collections . emptyMap ( ) , Collections . emptyMap ( ) , consumers , startFunctions :: add , finishFunctions :: add ) ; Iterables . getOnlyElement ( startFunctions ) . run ( ) ; mainOutputValues . clear ( ) ; assertThat ( consumers . keySet ( ) , containsInAnyOrder ( " inputATarget " , " inputBTarget " , " mainOutputTarget " , " additionalOutputTarget " ) ) ; Iterables . getOnlyElement ( consumers . get ( " inputATarget " ) ) . accept ( valueInGlobalWindow ( " A1" ) ) ; Iterables . getOnlyElement ( consumers . get ( " inputATarget " ) ) . accept ( valueInGlobalWindow ( " A2" ) ) ; Iterables . getOnlyElement ( consumers . get ( " inputBTarget " ) ) . accept ( valueInGlobalWindow ( " B " ) ) ; assertThat ( mainOutputValues , contains ( valueInGlobalWindow ( " MainOutputA1" ) , valueInGlobalWindow ( " MainOutputA2" ) , valueInGlobalWindow ( " MainOutputB " ) ) ) ; assertThat ( additionalOutputValues , contains ( valueInGlobalWindow ( " AdditionalOutputA1" ) , valueInGlobalWindow ( " AdditionalOutputA2" ) , valueInGlobalWindow ( " AdditionalOutputB " ) ) ) ; mainOutputValues . clear ( ) ; additionalOutputValues . clear ( ) ; Iterables . getOnlyElement ( finishFunctions ) . run ( ) ; assertThat ( mainOutputValues , contains ( timestampedValueInGlobalWindow ( " FinishBundle " , GlobalWindow . INSTANCE . maxTimestamp ( ) ) ) ) ; mainOutputValues . clear ( ) ; }
jbonofre/beam | @ Override public String createAccumulator ( ) { return " " ; }
jbonofre/beam | @ Override public String addInput ( String accumulator , String input ) { return accumulator . concat ( input ) ; }
jbonofre/beam | @ Override public String mergeAccumulators ( Iterable < String > accumulators ) { StringBuilder builder = new StringBuilder ( ) ; for ( String value : accumulators ) { builder . append ( value ) ; } return builder . toString ( ) ; }
jbonofre/beam | @ Override public String extractOutput ( String accumulator ) { return accumulator ; }
jbonofre/beam | @ Override public String createAccumulator ( Context c ) { return " " ; }
jbonofre/beam | @ Override public String addInput ( String accumulator , String input , Context c ) { return accumulator . concat ( input ) ; }
jbonofre/beam | @ Override public String mergeAccumulators ( Iterable < String > accumulators , Context c ) { StringBuilder builder = new StringBuilder ( ) ; for ( String value : accumulators ) { builder . append ( value ) ; } return builder . toString ( ) ; }
jbonofre/beam | @ Override public String extractOutput ( String accumulator , Context c ) { return accumulator ; }
jbonofre/beam | @ ProcessElement public void processElement ( ProcessContext context , @ StateId ( " value " ) ValueState < String > valueState , @ StateId ( " bag " ) BagState < String > bagState , @ StateId ( " combine " ) CombiningState < String , String , String > combiningState , @ StateId ( " combineWithContext " ) CombiningState < String , String , String > combiningWithContextState ) { context . output ( " value : " + valueState . read ( ) ) ; valueState . write ( context . element ( ) . getValue ( ) ) ; context . output ( " bag : " + Iterables . toString ( bagState . read ( ) ) ) ; bagState . add ( context . element ( ) . getValue ( ) ) ; context . output ( " combine : " + combiningState . read ( ) ) ; combiningState . add ( context . element ( ) . getValue ( ) ) ; context . output ( " combineWithContext : " + combiningWithContextState . read ( ) ) ; combiningWithContextState . add ( context . element ( ) . getValue ( ) ) ; }
jbonofre/beam | @ Test public void testUsingUserState ( ) throws Exception { String mainOutputId = "101" ; DoFnInfo < ? , ? > doFnInfo = DoFnInfo . forFn ( new TestStatefulDoFn ( ) , WindowingStrategy . globalDefault ( ) , ImmutableList . of ( ) , KvCoder . of ( StringUtf8Coder . of ( ) , StringUtf8Coder . of ( ) ) , Long . parseLong ( mainOutputId ) , ImmutableMap . of ( Long . parseLong ( mainOutputId ) , new TupleTag < String > ( " mainOutput " ) ) ) ; RunnerApi . FunctionSpec functionSpec = RunnerApi . FunctionSpec . newBuilder ( ) . setUrn ( ParDoTranslation . CUSTOM_JAVA_DO_FN_URN ) . setPayload ( ByteString . copyFrom ( SerializableUtils . serializeToByteArray ( doFnInfo ) ) ) . build ( ) ; RunnerApi . PTransform pTransform = RunnerApi . PTransform . newBuilder ( ) . setSpec ( functionSpec ) . putInputs ( " input " , " inputTarget " ) . putOutputs ( mainOutputId , " mainOutputTarget " ) . build ( ) ; FakeBeamFnStateClient fakeClient = new FakeBeamFnStateClient ( ImmutableMap . of ( key ( " value " , " X " ) , encode ( " X0" ) , key ( " bag " , " X " ) , encode ( " X0" ) , key ( " combine " , " X " ) , encode ( " X0" ) , key ( " combineWithContext " , " X " ) , encode ( " X0" ) ) ) ; List < WindowedValue < String > > mainOutputValues = new ArrayList < > ( ) ; Multimap < String , FnDataReceiver < WindowedValue < ? > > > consumers = HashMultimap . create ( ) ; consumers . put ( " mainOutputTarget " , ( FnDataReceiver ) ( FnDataReceiver < WindowedValue < String > > ) mainOutputValues :: add ) ; List < ThrowingRunnable > startFunctions = new ArrayList < > ( ) ; List < ThrowingRunnable > finishFunctions = new ArrayList < > ( ) ; new FnApiDoFnRunner . Factory < > ( ) . createRunnerForPTransform ( PipelineOptionsFactory . create ( ) , null , fakeClient , TEST_PTRANSFORM_ID , pTransform , Suppliers . ofInstance ( "57L " ) :: get , Collections . emptyMap ( ) , Collections . emptyMap ( ) , Collections . emptyMap ( ) , consumers , startFunctions :: add , finishFunctions :: add ) ; Iterables . getOnlyElement ( startFunctions ) . run ( ) ; mainOutputValues . clear ( ) ; assertThat ( consumers . keySet ( ) , containsInAnyOrder ( " inputTarget " , " mainOutputTarget " ) ) ; FnDataReceiver < WindowedValue < ? > > mainInput = Iterables . getOnlyElement ( consumers . get ( " inputTarget " ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " X " , " X1" ) ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " Y " , " Y1" ) ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " X " , " X2" ) ) ) ; mainInput . accept ( valueInGlobalWindow ( KV . of ( " Y " , " Y2" ) ) ) ; assertThat ( mainOutputValues , contains ( valueInGlobalWindow ( " value : X0" ) , valueInGlobalWindow ( " bag : [ X0 ] " ) , valueInGlobalWindow ( " combine : X0" ) , valueInGlobalWindow ( " combineWithContext : X0" ) , valueInGlobalWindow ( " value : null " ) , valueInGlobalWindow ( " bag : [ ] " ) , valueInGlobalWindow ( " combine : " ) , valueInGlobalWindow ( " combineWithContext : " ) , valueInGlobalWindow ( " value : X1" ) , valueInGlobalWindow ( " bag : [ X0 , ▁ X1 ] " ) , valueInGlobalWindow ( " combine : X0X1" ) , valueInGlobalWindow ( " combineWithContext : X0X1" ) , valueInGlobalWindow ( " value : Y1" ) , valueInGlobalWindow ( " bag : [ Y1 ] " ) , valueInGlobalWindow ( " combine : Y1" ) , valueInGlobalWindow ( " combineWithContext : Y1" ) ) ) ; mainOutputValues . clear ( ) ; Iterables . getOnlyElement ( finishFunctions ) . run ( ) ; assertThat ( mainOutputValues , empty ( ) ) ; assertEquals ( ImmutableMap . < StateKey , ByteString > builder ( ) . put ( key ( " value " , " X " ) , encode ( " X2" ) ) . put ( key ( " bag " , " X " ) , encode ( " X0" , " X1" , " X2" ) ) . put ( key ( " combine " , " X " ) , encode ( " X0X1X2" ) ) . put ( key ( " combineWithContext " , " X " ) , encode ( " X0X1X2" ) ) . put ( key ( " value " , " Y " ) , encode ( " Y2" ) ) . put ( key ( " bag " , " Y " ) , encode ( " Y1" , " Y2" ) ) . put ( key ( " combine " , " Y " ) , encode ( " Y1Y2" ) ) . put ( key ( " combineWithContext " , " Y " ) , encode ( " Y1Y2" ) ) . build ( ) , fakeClient . getData ( ) ) ; mainOutputValues . clear ( ) ; }
jbonofre/beam | private StateKey key ( String userStateId , String key ) throws IOException { return StateKey . newBuilder ( ) . setBagUserState ( StateKey . BagUserState . newBuilder ( ) . setPtransformId ( TEST_PTRANSFORM_ID ) . setUserStateId ( userStateId ) . setKey ( encode ( key ) ) . setWindow ( ByteString . copyFrom ( CoderUtils . encodeToByteArray ( GlobalWindow . Coder . INSTANCE , GlobalWindow . INSTANCE ) ) ) ) . build ( ) ; }
jbonofre/beam | private ByteString encode ( String ... values ) throws IOException { ByteString . Output out = ByteString . newOutput ( ) ; for ( String value : values ) { StringUtf8Coder . of ( ) . encode ( value , out ) ; } return out . toByteString ( ) ; }
jbonofre/beam | @ Test public void testRegistration ( ) { for ( Registrar registrar : ServiceLoader . load ( Registrar . class ) ) { if ( registrar instanceof FnApiDoFnRunner . Registrar ) { assertThat ( registrar . getPTransformRunnerFactories ( ) , IsMapContaining . hasKey ( ParDoTranslation . CUSTOM_JAVA_DO_FN_URN ) ) ; return ; } } fail ( " Expected ▁ registrar ▁ not ▁ found . " ) ; }
aws/aws-sdk-java | public void setPredictorArn ( String predictorArn ) { this . predictorArn = predictorArn ; }
aws/aws-sdk-java | public String getPredictorArn ( ) { return this . predictorArn ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withPredictorArn ( String predictorArn ) { setPredictorArn ( predictorArn ) ; return this ; }
aws/aws-sdk-java | public void setPredictorName ( String predictorName ) { this . predictorName = predictorName ; }
aws/aws-sdk-java | public String getPredictorName ( ) { return this . predictorName ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withPredictorName ( String predictorName ) { setPredictorName ( predictorName ) ; return this ; }
aws/aws-sdk-java | public void setForecastHorizon ( Integer forecastHorizon ) { this . forecastHorizon = forecastHorizon ; }
aws/aws-sdk-java | public Integer getForecastHorizon ( ) { return this . forecastHorizon ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastHorizon ( Integer forecastHorizon ) { setForecastHorizon ( forecastHorizon ) ; return this ; }
aws/aws-sdk-java | public java . util . List < String > getForecastTypes ( ) { return forecastTypes ; }
aws/aws-sdk-java | public void setForecastTypes ( java . util . Collection < String > forecastTypes ) { if ( forecastTypes == null ) { this . forecastTypes = null ; return ; } this . forecastTypes = new java . util . ArrayList < String > ( forecastTypes ) ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastTypes ( String ... forecastTypes ) { if ( this . forecastTypes == null ) { setForecastTypes ( new java . util . ArrayList < String > ( forecastTypes . length ) ) ; } for ( String ele : forecastTypes ) { this . forecastTypes . add ( ele ) ; } return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastTypes ( java . util . Collection < String > forecastTypes ) { setForecastTypes ( forecastTypes ) ; return this ; }
aws/aws-sdk-java | public void setForecastFrequency ( String forecastFrequency ) { this . forecastFrequency = forecastFrequency ; }
aws/aws-sdk-java | public String getForecastFrequency ( ) { return this . forecastFrequency ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastFrequency ( String forecastFrequency ) { setForecastFrequency ( forecastFrequency ) ; return this ; }
aws/aws-sdk-java | public java . util . List < String > getForecastDimensions ( ) { return forecastDimensions ; }
aws/aws-sdk-java | public void setForecastDimensions ( java . util . Collection < String > forecastDimensions ) { if ( forecastDimensions == null ) { this . forecastDimensions = null ; return ; } this . forecastDimensions = new java . util . ArrayList < String > ( forecastDimensions ) ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastDimensions ( String ... forecastDimensions ) { if ( this . forecastDimensions == null ) { setForecastDimensions ( new java . util . ArrayList < String > ( forecastDimensions . length ) ) ; } for ( String ele : forecastDimensions ) { this . forecastDimensions . add ( ele ) ; } return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withForecastDimensions ( java . util . Collection < String > forecastDimensions ) { setForecastDimensions ( forecastDimensions ) ; return this ; }
aws/aws-sdk-java | public java . util . List < String > getDatasetImportJobArns ( ) { return datasetImportJobArns ; }
aws/aws-sdk-java | public void setDatasetImportJobArns ( java . util . Collection < String > datasetImportJobArns ) { if ( datasetImportJobArns == null ) { this . datasetImportJobArns = null ; return ; } this . datasetImportJobArns = new java . util . ArrayList < String > ( datasetImportJobArns ) ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withDatasetImportJobArns ( String ... datasetImportJobArns ) { if ( this . datasetImportJobArns == null ) { setDatasetImportJobArns ( new java . util . ArrayList < String > ( datasetImportJobArns . length ) ) ; } for ( String ele : datasetImportJobArns ) { this . datasetImportJobArns . add ( ele ) ; } return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withDatasetImportJobArns ( java . util . Collection < String > datasetImportJobArns ) { setDatasetImportJobArns ( datasetImportJobArns ) ; return this ; }
aws/aws-sdk-java | public void setDataConfig ( DataConfig dataConfig ) { this . dataConfig = dataConfig ; }
aws/aws-sdk-java | public DataConfig getDataConfig ( ) { return this . dataConfig ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withDataConfig ( DataConfig dataConfig ) { setDataConfig ( dataConfig ) ; return this ; }
aws/aws-sdk-java | public void setEncryptionConfig ( EncryptionConfig encryptionConfig ) { this . encryptionConfig = encryptionConfig ; }
aws/aws-sdk-java | public EncryptionConfig getEncryptionConfig ( ) { return this . encryptionConfig ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withEncryptionConfig ( EncryptionConfig encryptionConfig ) { setEncryptionConfig ( encryptionConfig ) ; return this ; }
aws/aws-sdk-java | public void setReferencePredictorSummary ( ReferencePredictorSummary referencePredictorSummary ) { this . referencePredictorSummary = referencePredictorSummary ; }
aws/aws-sdk-java | public ReferencePredictorSummary getReferencePredictorSummary ( ) { return this . referencePredictorSummary ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withReferencePredictorSummary ( ReferencePredictorSummary referencePredictorSummary ) { setReferencePredictorSummary ( referencePredictorSummary ) ; return this ; }
aws/aws-sdk-java | public void setEstimatedTimeRemainingInMinutes ( Long estimatedTimeRemainingInMinutes ) { this . estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes ; }
aws/aws-sdk-java | public Long getEstimatedTimeRemainingInMinutes ( ) { return this . estimatedTimeRemainingInMinutes ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withEstimatedTimeRemainingInMinutes ( Long estimatedTimeRemainingInMinutes ) { setEstimatedTimeRemainingInMinutes ( estimatedTimeRemainingInMinutes ) ; return this ; }
aws/aws-sdk-java | public void setStatus ( String status ) { this . status = status ; }
aws/aws-sdk-java | public String getStatus ( ) { return this . status ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withStatus ( String status ) { setStatus ( status ) ; return this ; }
aws/aws-sdk-java | public void setMessage ( String message ) { this . message = message ; }
aws/aws-sdk-java | public String getMessage ( ) { return this . message ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withMessage ( String message ) { setMessage ( message ) ; return this ; }
aws/aws-sdk-java | public void setCreationTime ( java . util . Date creationTime ) { this . creationTime = creationTime ; }
aws/aws-sdk-java | public java . util . Date getCreationTime ( ) { return this . creationTime ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withCreationTime ( java . util . Date creationTime ) { setCreationTime ( creationTime ) ; return this ; }
aws/aws-sdk-java | public void setLastModificationTime ( java . util . Date lastModificationTime ) { this . lastModificationTime = lastModificationTime ; }
aws/aws-sdk-java | public java . util . Date getLastModificationTime ( ) { return this . lastModificationTime ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withLastModificationTime ( java . util . Date lastModificationTime ) { setLastModificationTime ( lastModificationTime ) ; return this ; }
aws/aws-sdk-java | public void setOptimizationMetric ( String optimizationMetric ) { this . optimizationMetric = optimizationMetric ; }
aws/aws-sdk-java | public String getOptimizationMetric ( ) { return this . optimizationMetric ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withOptimizationMetric ( String optimizationMetric ) { setOptimizationMetric ( optimizationMetric ) ; return this ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withOptimizationMetric ( OptimizationMetric optimizationMetric ) { this . optimizationMetric = optimizationMetric . toString ( ) ; return this ; }
aws/aws-sdk-java | public void setExplainabilityInfo ( ExplainabilityInfo explainabilityInfo ) { this . explainabilityInfo = explainabilityInfo ; }
aws/aws-sdk-java | public ExplainabilityInfo getExplainabilityInfo ( ) { return this . explainabilityInfo ; }
aws/aws-sdk-java | public DescribeAutoPredictorResult withExplainabilityInfo ( ExplainabilityInfo explainabilityInfo ) { setExplainabilityInfo ( explainabilityInfo ) ; return this ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getPredictorArn ( ) != null ) sb . append ( " PredictorArn : ▁ " ) . append ( getPredictorArn ( ) ) . append ( " , " ) ; if ( getPredictorName ( ) != null ) sb . append ( " PredictorName : ▁ " ) . append ( getPredictorName ( ) ) . append ( " , " ) ; if ( getForecastHorizon ( ) != null ) sb . append ( " ForecastHorizon : ▁ " ) . append ( getForecastHorizon ( ) ) . append ( " , " ) ; if ( getForecastTypes ( ) != null ) sb . append ( " ForecastTypes : ▁ " ) . append ( getForecastTypes ( ) ) . append ( " , " ) ; if ( getForecastFrequency ( ) != null ) sb . append ( " ForecastFrequency : ▁ " ) . append ( getForecastFrequency ( ) ) . append ( " , " ) ; if ( getForecastDimensions ( ) != null ) sb . append ( " ForecastDimensions : ▁ " ) . append ( getForecastDimensions ( ) ) . append ( " , " ) ; if ( getDatasetImportJobArns ( ) != null ) sb . append ( " DatasetImportJobArns : ▁ " ) . append ( getDatasetImportJobArns ( ) ) . append ( " , " ) ; if ( getDataConfig ( ) != null ) sb . append ( " DataConfig : ▁ " ) . append ( getDataConfig ( ) ) . append ( " , " ) ; if ( getEncryptionConfig ( ) != null ) sb . append ( " EncryptionConfig : ▁ " ) . append ( getEncryptionConfig ( ) ) . append ( " , " ) ; if ( getReferencePredictorSummary ( ) != null ) sb . append ( " ReferencePredictorSummary : ▁ " ) . append ( getReferencePredictorSummary ( ) ) . append ( " , " ) ; if ( getEstimatedTimeRemainingInMinutes ( ) != null ) sb . append ( " EstimatedTimeRemainingInMinutes : ▁ " ) . append ( getEstimatedTimeRemainingInMinutes ( ) ) . append ( " , " ) ; if ( getStatus ( ) != null ) sb . append ( " Status : ▁ " ) . append ( getStatus ( ) ) . append ( " , " ) ; if ( getMessage ( ) != null ) sb . append ( " Message : ▁ " ) . append ( getMessage ( ) ) . append ( " , " ) ; if ( getCreationTime ( ) != null ) sb . append ( " CreationTime : ▁ " ) . append ( getCreationTime ( ) ) . append ( " , " ) ; if ( getLastModificationTime ( ) != null ) sb . append ( " LastModificationTime : ▁ " ) . append ( getLastModificationTime ( ) ) . append ( " , " ) ; if ( getOptimizationMetric ( ) != null ) sb . append ( " OptimizationMetric : ▁ " ) . append ( getOptimizationMetric ( ) ) . append ( " , " ) ; if ( getExplainabilityInfo ( ) != null ) sb . append ( " ExplainabilityInfo : ▁ " ) . append ( getExplainabilityInfo ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeAutoPredictorResult == false ) return false ; DescribeAutoPredictorResult other = ( DescribeAutoPredictorResult ) obj ; if ( other . getPredictorArn ( ) == null ^ this . getPredictorArn ( ) == null ) return false ; if ( other . getPredictorArn ( ) != null && other . getPredictorArn ( ) . equals ( this . getPredictorArn ( ) ) == false ) return false ; if ( other . getPredictorName ( ) == null ^ this . getPredictorName ( ) == null ) return false ; if ( other . getPredictorName ( ) != null && other . getPredictorName ( ) . equals ( this . getPredictorName ( ) ) == false ) return false ; if ( other . getForecastHorizon ( ) == null ^ this . getForecastHorizon ( ) == null ) return false ; if ( other . getForecastHorizon ( ) != null && other . getForecastHorizon ( ) . equals ( this . getForecastHorizon ( ) ) == false ) return false ; if ( other . getForecastTypes ( ) == null ^ this . getForecastTypes ( ) == null ) return false ; if ( other . getForecastTypes ( ) != null && other . getForecastTypes ( ) . equals ( this . getForecastTypes ( ) ) == false ) return false ; if ( other . getForecastFrequency ( ) == null ^ this . getForecastFrequency ( ) == null ) return false ; if ( other . getForecastFrequency ( ) != null && other . getForecastFrequency ( ) . equals ( this . getForecastFrequency ( ) ) == false ) return false ; if ( other . getForecastDimensions ( ) == null ^ this . getForecastDimensions ( ) == null ) return false ; if ( other . getForecastDimensions ( ) != null && other . getForecastDimensions ( ) . equals ( this . getForecastDimensions ( ) ) == false ) return false ; if ( other . getDatasetImportJobArns ( ) == null ^ this . getDatasetImportJobArns ( ) == null ) return false ; if ( other . getDatasetImportJobArns ( ) != null && other . getDatasetImportJobArns ( ) . equals ( this . getDatasetImportJobArns ( ) ) == false ) return false ; if ( other . getDataConfig ( ) == null ^ this . getDataConfig ( ) == null ) return false ; if ( other . getDataConfig ( ) != null && other . getDataConfig ( ) . equals ( this . getDataConfig ( ) ) == false ) return false ; if ( other . getEncryptionConfig ( ) == null ^ this . getEncryptionConfig ( ) == null ) return false ; if ( other . getEncryptionConfig ( ) != null && other . getEncryptionConfig ( ) . equals ( this . getEncryptionConfig ( ) ) == false ) return false ; if ( other . getReferencePredictorSummary ( ) == null ^ this . getReferencePredictorSummary ( ) == null ) return false ; if ( other . getReferencePredictorSummary ( ) != null && other . getReferencePredictorSummary ( ) . equals ( this . getReferencePredictorSummary ( ) ) == false ) return false ; if ( other . getEstimatedTimeRemainingInMinutes ( ) == null ^ this . getEstimatedTimeRemainingInMinutes ( ) == null ) return false ; if ( other . getEstimatedTimeRemainingInMinutes ( ) != null && other . getEstimatedTimeRemainingInMinutes ( ) . equals ( this . getEstimatedTimeRemainingInMinutes ( ) ) == false ) return false ; if ( other . getStatus ( ) == null ^ this . getStatus ( ) == null ) return false ; if ( other . getStatus ( ) != null && other . getStatus ( ) . equals ( this . getStatus ( ) ) == false ) return false ; if ( other . getMessage ( ) == null ^ this . getMessage ( ) == null ) return false ; if ( other . getMessage ( ) != null && other . getMessage ( ) . equals ( this . getMessage ( ) ) == false ) return false ; if ( other . getCreationTime ( ) == null ^ this . getCreationTime ( ) == null ) return false ; if ( other . getCreationTime ( ) != null && other . getCreationTime ( ) . equals ( this . getCreationTime ( ) ) == false ) return false ; if ( other . getLastModificationTime ( ) == null ^ this . getLastModificationTime ( ) == null ) return false ; if ( other . getLastModificationTime ( ) != null && other . getLastModificationTime ( ) . equals ( this . getLastModificationTime ( ) ) == false ) return false ; if ( other . getOptimizationMetric ( ) == null ^ this . getOptimizationMetric ( ) == null ) return false ; if ( other . getOptimizationMetric ( ) != null && other . getOptimizationMetric ( ) . equals ( this . getOptimizationMetric ( ) ) == false ) return false ; if ( other . getExplainabilityInfo ( ) == null ^ this . getExplainabilityInfo ( ) == null ) return false ; if ( other . getExplainabilityInfo ( ) != null && other . getExplainabilityInfo ( ) . equals ( this . getExplainabilityInfo ( ) ) == false ) return false ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getPredictorArn ( ) == null ) ? 0 : getPredictorArn ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getPredictorName ( ) == null ) ? 0 : getPredictorName ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastHorizon ( ) == null ) ? 0 : getForecastHorizon ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastTypes ( ) == null ) ? 0 : getForecastTypes ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastFrequency ( ) == null ) ? 0 : getForecastFrequency ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getForecastDimensions ( ) == null ) ? 0 : getForecastDimensions ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getDatasetImportJobArns ( ) == null ) ? 0 : getDatasetImportJobArns ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getDataConfig ( ) == null ) ? 0 : getDataConfig ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getEncryptionConfig ( ) == null ) ? 0 : getEncryptionConfig ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getReferencePredictorSummary ( ) == null ) ? 0 : getReferencePredictorSummary ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getEstimatedTimeRemainingInMinutes ( ) == null ) ? 0 : getEstimatedTimeRemainingInMinutes ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getStatus ( ) == null ) ? 0 : getStatus ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMessage ( ) == null ) ? 0 : getMessage ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getCreationTime ( ) == null ) ? 0 : getCreationTime ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getLastModificationTime ( ) == null ) ? 0 : getLastModificationTime ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getOptimizationMetric ( ) == null ) ? 0 : getOptimizationMetric ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getExplainabilityInfo ( ) == null ) ? 0 : getExplainabilityInfo ( ) . hashCode ( ) ) ; return hashCode ; }
aws/aws-sdk-java | @ Override public DescribeAutoPredictorResult clone ( ) { try { return ( DescribeAutoPredictorResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
deeplearning4j/nd4j-benchmark | public MaxOpRunner ( ) { Nd4j . factory ( ) . setOrder ( ' c ' ) ; arr = Nd4j . create ( 12000 , 12000 ) ; }
deeplearning4j/nd4j-benchmark | @ Override public void runOp ( ) { arr . sum ( 1 ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testConnectWithId ( ) { GridConnection < GridNode > connection = new LocalGridNodeConnection ( " test - id " ) ; GridNode gnode = connection . connect ( ) ; assertNotNull ( gnode ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testConnectWithGivenGridNode ( ) { GridNode gnode = new GridNodeImpl ( ) ; GridConnection < GridNode > connection = new LocalGridNodeConnection ( gnode ) ; assertSame ( gnode , connection . connect ( ) ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testGetFactoryService ( ) { GridConnection < GridNode > connection = new LocalGridNodeConnection ( " test - id " ) ; GridNode gnode = connection . connect ( ) ; KnowledgeBuilderFactoryService kbfService = gnode . get ( KnowledgeBuilderFactoryService . class ) ; assertNotNull ( kbfService ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testSetObject ( ) { GridConnection < GridNode > connection = new LocalGridNodeConnection ( " test - id " ) ; GridNode gnode = connection . connect ( ) ; KnowledgeBaseFactoryService kbfService = gnode . get ( KnowledgeBaseFactoryService . class ) ; KnowledgeBase kbase = kbfService . newKnowledgeBase ( ) ; gnode . set ( " id1" , kbase ) ; assertSame ( kbase , gnode . get ( " id1" , KnowledgeBase . class ) ) ; }
mariofusco/droolsjbpm-integration | @ Test public void testNodeCreationAndWhitePagesRegistration ( ) { Grid grid = new GridImpl ( new HashMap < String , Object > ( ) ) ; GridPeerConfiguration conf = new GridPeerConfiguration ( ) ; GridPeerServiceConfiguration wplConf = new WhitePagesLocalConfiguration ( ) ; conf . addConfiguration ( wplConf ) ; conf . configure ( grid ) ; GridNode gnode = grid . createGridNode ( " test1 @ local " ) ; WhitePages pages = grid . get ( WhitePages . class ) ; GridServiceDescription < GridNode > gsd = pages . create ( " test1 @ local " ) ; GridServiceDescription < GridNode > serviceDescription = pages . lookup ( " test1 @ local " ) ; GridConnection connection = grid . get ( ConnectionFactoryService . class ) . createConnection ( gsd ) ; assertSame ( gnode , connection . connect ( ) ) ; }
mariofusco/droolsjbpm-integration | private InetAddress getLocalAddress ( ) { try { return InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( " Unable ▁ to ▁ lookup ▁ local ▁ address " , e ) ; } }
bobmcwhirter/drools | public SubProcessParameterOutMappingCellEditor ( Composite parent , SubProcessNode subProcessNode ) { super ( parent ) ; this . subProcessNode = subProcessNode ; }
bobmcwhirter/drools | protected EditBeanDialog createDialog ( Shell shell ) { return new SubProcessParameterOutMappingDialog ( shell , subProcessNode ) ; }
bobmcwhirter/drools | protected String getLabelText ( Object value ) { return " " ; }
WilliamRen/bbossgroups-3.5 | public final void setUnless ( String value ) throws JspException { if ( ! ( value == null || CURRENT . equals ( value ) || INDEXED . equals ( value ) ) ) { throw new JspTagException ( " value ▁ for ▁ attribute ▁ \" unless \" ▁ " + " must ▁ be ▁ either ▁ \" current \" ▁ or ▁ \" indexed \" . " ) ; } unless = value ; }
WilliamRen/bbossgroups-3.5 | public final String getUnless ( ) { return unless ; }
WilliamRen/bbossgroups-3.5 | public int doStartTag ( ) throws JspException { super . doStartTag ( ) ; long jumpPage = getJumpPage ( ) ; if ( CURRENT . equals ( unless ) ) { if ( jumpPage == this . pagerContext . getPageNumber ( ) ) return SKIP_BODY ; } else if ( INDEXED . equals ( unless ) ) { long firstPage = pagerContext . getFirstIndexPage ( ) ; long lastPage = pagerContext . getLastIndexPage ( firstPage ) ; if ( jumpPage >= firstPage && jumpPage <= lastPage ) return SKIP_BODY ; } setPageAttributes ( jumpPage ) ; return EVAL_BODY_INCLUDE ; }
WilliamRen/bbossgroups-3.5 | public void release ( ) { unless = null ; super . release ( ) ; }
navalev/azure-sdk-for-java | public String databaseName ( ) { return this . databaseName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withDatabaseName ( String databaseName ) { this . databaseName = databaseName ; return this ; }
navalev/azure-sdk-for-java | public String id ( ) { return this . id ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withId ( String id ) { this . id = id ; return this ; }
navalev/azure-sdk-for-java | public String logicalName ( ) { return this . logicalName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withLogicalName ( String logicalName ) { this . logicalName = logicalName ; return this ; }
navalev/azure-sdk-for-java | public String physicalFullName ( ) { return this . physicalFullName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withPhysicalFullName ( String physicalFullName ) { this . physicalFullName = physicalFullName ; return this ; }
navalev/azure-sdk-for-java | public String restoreFullName ( ) { return this . restoreFullName ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withRestoreFullName ( String restoreFullName ) { this . restoreFullName = restoreFullName ; return this ; }
navalev/azure-sdk-for-java | public DatabaseFileType fileType ( ) { return this . fileType ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withFileType ( DatabaseFileType fileType ) { this . fileType = fileType ; return this ; }
navalev/azure-sdk-for-java | public Double sizeMB ( ) { return this . sizeMB ; }
navalev/azure-sdk-for-java | public DatabaseFileInfo withSizeMB ( Double sizeMB ) { this . sizeMB = sizeMB ; return this ; }
allotria/intellij-community | private VirtualEnvSdkFlavor ( ) { }
allotria/intellij-community | @ Override public boolean isPlatformIndependent ( ) { return true ; }
allotria/intellij-community | @ NotNull @ Override public Collection < String > suggestHomePaths ( @ Nullable Module module , @ Nullable UserDataHolder context ) { return ReadAction . compute ( ( ) -> { final List < String > candidates = new ArrayList < > ( ) ; if ( module != null ) { VirtualFile baseDir = BasePySdkExtKt . getBaseDir ( module ) ; if ( baseDir == null && context != null && context . getUserData ( PySdkExtKt . getBASE_DIR ( ) ) != null ) { baseDir = VfsUtil . findFile ( context . getUserData ( PySdkExtKt . getBASE_DIR ( ) ) , false ) ; } if ( baseDir != null ) { candidates . addAll ( findInBaseDirectory ( baseDir ) ) ; } } final VirtualFile path = getDefaultLocation ( ) ; if ( path != null ) { candidates . addAll ( findInBaseDirectory ( path ) ) ; } final VirtualFile pyEnvLocation = getPyEnvDefaultLocations ( ) ; if ( pyEnvLocation != null ) { candidates . addAll ( findInBaseDirectory ( pyEnvLocation ) ) ; } return candidates ; } ) ; }
allotria/intellij-community | @ Override public boolean isValidSdkPath ( @ NotNull File file ) { if ( ! super . isValidSdkPath ( file ) ) return false ; return PythonSdkUtil . getVirtualEnvRoot ( file . getPath ( ) ) != null ; }
allotria/intellij-community | @ Override public Icon getIcon ( ) { return PythonIcons . Python . Virtualenv ; }
V2GClarity/RISE-V2G | public WaitForChargingStatusReq ( V2GCommunicationSessionSECC commSessionContext ) { super ( commSessionContext ) ; chargingStatusRes = new ChargingStatusResType ( ) ; }
V2GClarity/RISE-V2G | @ Override public ReactionToIncomingMessage processIncomingMessage ( Object message ) { if ( isIncomingMessageValid ( message , ChargingStatusReqType . class , chargingStatusRes ) ) { chargingStatusRes . setEVSEID ( getCommSessionContext ( ) . getACEvseController ( ) . getEvseID ( ) ) ; chargingStatusRes . setSAScheduleTupleID ( getCommSessionContext ( ) . getChosenSAScheduleTuple ( ) ) ; chargingStatusRes . setACEVSEStatus ( getCommSessionContext ( ) . getACEvseController ( ) . getACEVSEStatus ( EVSENotificationType . NONE ) ) ; if ( getCommSessionContext ( ) . getSelectedPaymentOption ( ) . equals ( PaymentOptionType . EXTERNAL_PAYMENT ) ) { chargingStatusRes . setReceiptRequired ( false ) ; } else { chargingStatusRes . setReceiptRequired ( false ) ; } MeterInfoType meterInfo = getCommSessionContext ( ) . getACEvseController ( ) . getMeterInfo ( ) ; chargingStatusRes . setMeterInfo ( meterInfo ) ; getCommSessionContext ( ) . setSentMeterInfo ( meterInfo ) ; if ( chargingStatusRes . isReceiptRequired ( ) ) { return getSendMessage ( chargingStatusRes , V2GMessages . METERING_RECEIPT_REQ ) ; } else { ( ( ForkState ) getCommSessionContext ( ) . getStates ( ) . get ( V2GMessages . FORK ) ) . getAllowedRequests ( ) . add ( V2GMessages . CHARGING_STATUS_REQ ) ; ( ( ForkState ) getCommSessionContext ( ) . getStates ( ) . get ( V2GMessages . FORK ) ) . getAllowedRequests ( ) . add ( V2GMessages . POWER_DELIVERY_REQ ) ; return getSendMessage ( chargingStatusRes , V2GMessages . FORK ) ; } } else { if ( chargingStatusRes . getResponseCode ( ) . equals ( ResponseCodeType . FAILED_SEQUENCE_ERROR ) ) { BodyBaseType responseMessage = getSequenceErrorResMessage ( new ChargingStatusResType ( ) , message ) ; return getSendMessage ( responseMessage , V2GMessages . NONE , chargingStatusRes . getResponseCode ( ) ) ; } else { setMandatoryFieldsForFailedRes ( chargingStatusRes , chargingStatusRes . getResponseCode ( ) ) ; } } return getSendMessage ( chargingStatusRes , V2GMessages . NONE , chargingStatusRes . getResponseCode ( ) ) ; }
V2GClarity/RISE-V2G | @ Override public BodyBaseType getResponseMessage ( ) { return chargingStatusRes ; }
wangyangjun/RealtimeStreamBenchmark | public Workload ( OperatorCreator creator ) throws WorkloadException { this . operatorCreator = creator ; Configure . LoadConfigure ( ) ; parallelism = Configure . clusterHosts * Configure . hostCores ; properties = new Properties ( ) ; String configFile = this . getClass ( ) . getSimpleName ( ) + " . properties " ; try { properties . load ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( configFile ) ) ; } catch ( IOException e ) { throw new WorkloadException ( " Read ▁ configure ▁ file ▁ " + configFile + " ▁ failed " ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( " Read ▁ configure ▁ file : ▁ " + configFile + " ▁ failed " ) ; } }
wangyangjun/RealtimeStreamBenchmark | protected OperatorCreator getOperatorCreator ( ) { return operatorCreator ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < WithTime < String > > stringStreamWithTime ( String componentId ) { String topic = properties . getProperty ( " topic " ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . stringStreamFromKafkaWithTime ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < Point > getPointStream ( String componentId ) { String topic = properties . getProperty ( " topic " ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . pointStreamFromKafka ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < String > kafkaStreamOperator ( String componentId ) { String topic = properties . getProperty ( " topic " ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . stringStreamFromKafka ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | protected WorkloadOperator < String > kafkaStreamOperator2 ( String componentId ) { String topic = properties . getProperty ( " topic2" ) ; String groupId = properties . getProperty ( " group . id " ) ; String kafkaServers = properties . getProperty ( " bootstrap . servers " ) ; String zkConnectStr = properties . getProperty ( " zookeeper . connect " ) ; String offset = properties . getProperty ( " auto . offset . reset " ) ; return this . getOperatorCreator ( ) . stringStreamFromKafka ( zkConnectStr , kafkaServers , groupId , topic , offset , componentId , parallelism ) ; }
wangyangjun/RealtimeStreamBenchmark | public void Start ( ) { logger . info ( " Start ▁ workload : ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; try { Process ( ) ; this . getOperatorCreator ( ) . Start ( ) ; } catch ( Exception e ) { logger . error ( " WorkloadException ▁ caught ▁ when ▁ run ▁ workload ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; e . printStackTrace ( ) ; } logger . info ( " The ▁ end ▁ of ▁ workload : ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; }
LearnLib/alex | public boolean isSymbolsOnly ( ) { return symbolsOnly ; }
LearnLib/alex | public void setSymbolsOnly ( boolean symbolsOnly ) { this . symbolsOnly = symbolsOnly ; }
LearnLib/alex | public List < Long > getSymbolIds ( ) { return symbolIds ; }
LearnLib/alex | public void setSymbolIds ( List < Long > symbolIds ) { this . symbolIds = symbolIds ; }
TopQuadrant/shacl | public DistinctExpression ( RDFNode expr , NodeExpression input ) { super ( expr , input ) ; }
TopQuadrant/shacl | @ Override public ExtendedIterator < RDFNode > eval ( RDFNode focusNode , NodeExpressionContext context ) { return distinct ( evalInput ( focusNode , context ) ) ; }
TopQuadrant/shacl | @ Override public Resource getOutputShape ( Resource contextShape ) { return getInput ( ) . getOutputShape ( contextShape ) ; }
TopQuadrant/shacl | @ Override public String getTypeId ( ) { return " distinct " ; }
TopQuadrant/shacl | @ Override public void visit ( NodeExpressionVisitor visitor ) { visitor . visit ( this ) ; }
gcorreageek/dhl | @ Override public String getCurrentAuditor ( ) { String userName = SecurityUtils . getCurrentUserLogin ( ) ; return ( userName != null ? userName : Constants . SYSTEM_ACCOUNT ) ; }
rvprg/pet | public RemoveCatchingUpMemberResult ( Boolean result , MemberId leaderId ) { super ( result , leaderId ) ; }
shirdrn/platform-api | public NamedThreadFactory ( String poolName ) { if ( poolName != null && ! poolName . trim ( ) . isEmpty ( ) ) { this . poolName = poolName ; } SecurityManager s = System . getSecurityManager ( ) ; group = ( s != null ) ? s . getThreadGroup ( ) : Thread . currentThread ( ) . getThreadGroup ( ) ; }
shirdrn/platform-api | public NamedThreadFactory ( ) { this ( " POOL " ) ; }
shirdrn/platform-api | @ Override public Thread newThread ( Runnable r ) { String threadName = poolName + " - " + formatter . format ( threadNumber . getAndIncrement ( ) ) ; Thread t = new Thread ( group , r , threadName , 0 ) ; if ( t . isDaemon ( ) ) t . setDaemon ( false ) ; if ( t . getPriority ( ) != Thread . NORM_PRIORITY ) t . setPriority ( Thread . NORM_PRIORITY ) ; return t ; }
cadc/glue-stack | public Organisation getOrganisation ( ) { return this . organisation ; }
cadc/glue-stack | public void setOrganisation ( Organisation organisation ) { this . organisation = organisation ; }
AsciiBunny/Bunny-Control-System | public BunnyServer ( int port , int clients , String name ) { PORT = port ; NAME = name ; AMMOUNT_OF_CLIENTS = clients ; }
AsciiBunny/Bunny-Control-System | public BunnyServer ( ) { PORT = 9999 ; NAME = " BunnyServer " ; AMMOUNT_OF_CLIENTS = 3 ; }
AsciiBunny/Bunny-Control-System | public void run ( ) { try { clients = new ClientHandler [ AMMOUNT_OF_CLIENTS ] ; serverSocket = new ServerSocket ( PORT ) ; System . out . println ( " Waiting ▁ for ▁ clients " ) ; while ( true ) { Socket s = serverSocket . accept ( ) ; System . out . println ( " Client ▁ connected ▁ from ▁ " + s . getLocalAddress ( ) . getHostName ( ) ) ; createClient ( s ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
AsciiBunny/Bunny-Control-System | public void handle ( int id , String name , ArrayList < String > inputs ) { ArrayList < String > coms = new ArrayList < String > ( ) ; if ( inputs . get ( 0 ) . startsWith ( " / " ) ) { switch ( inputs . get ( 0 ) ) { case " / exit " : coms . add ( NAME ) ; coms . add ( " Client ▁ < " + name + " > ▁ has ▁ left " ) ; coms . add ( " / end " ) ; coms . add ( " / playerquit " ) ; coms . add ( name ) ; coms . add ( " / end " ) ; clients [ id ] . stop ( ) ; clients [ id ] = null ; System . out . println ( " Client ▁ " + name + " ▁ has ▁ left " ) ; break ; case " / changename " : coms . add ( NAME ) ; coms . add ( " Client ▁ < " + name + " > ▁ has ▁ changed ▁ names ▁ to ▁ < " + inputs . get ( 1 ) + " > . " ) ; coms . add ( " / end " ) ; coms . add ( " / changedname " ) ; coms . add ( name ) ; coms . add ( inputs . get ( 1 ) ) ; coms . add ( " / end " ) ; clients [ id ] . setName ( inputs . get ( 1 ) ) ; break ; case " / kick " : coms . add ( NAME ) ; coms . add ( " Client ▁ < " + inputs . get ( 1 ) + " > ▁ just ▁ got ▁ kicked ▁ out , ▁ was ▁ he ▁ being ▁ naughty ? " ) ; coms . add ( " / end " ) ; coms . add ( " / playerquit " ) ; coms . add ( inputs . get ( 1 ) ) ; coms . add ( " / end " ) ; for ( ClientHandler client : clients ) { if ( client != null ) { if ( client . getName ( ) . equals ( inputs . get ( 1 ) ) ) { System . out . println ( client . getName ( ) + " ▁ got ▁ kicked " ) ; clients [ client . getID ( ) ] = null ; client . kick ( ) ; } } } break ; case " / say " : coms . add ( NAME ) ; coms . add ( inputs . get ( 1 ) ) ; coms . add ( " / end " ) ; break ; case " / pm " : for ( ClientHandler client : clients ) { if ( client != null ) { if ( client . getName ( ) . equals ( inputs . get ( 1 ) ) ) { client . printString ( name ) ; client . printString ( " pm : ▁ " + inputs . get ( 2 ) ) ; client . printString ( " / end " ) ; } } } break ; default : clients [ id ] . printString ( NAME ) ; clients [ id ] . printString ( " Command ▁ is ▁ not ▁ recognized , ▁ please ▁ try ▁ again . " ) ; clients [ id ] . printString ( " / end " ) ; break ; } } else { coms . add ( name ) ; coms . add ( inputs . get ( 0 ) ) ; coms . add ( " / end " ) ; } for ( ClientHandler client : clients ) { if ( client != null ) { for ( String string : coms ) { client . printString ( string ) ; } } } }
AsciiBunny/Bunny-Control-System | private void createClient ( Socket s ) throws InterruptedException { ClientHandler client = new ClientHandler ( s , this ) ; boolean joined = false ; for ( int i = 0 ; i < clients . length ; i ++ ) { if ( clients [ i ] == null ) { clients [ i ] = client ; client . setID ( i ) ; System . out . println ( " Client ▁ " + client . getName ( ) + " ▁ joined ▁ on ▁ ID : ▁ " + client . getID ( ) ) ; joined = true ; break ; } } Thread t = new Thread ( client ) ; t . start ( ) ; Thread . sleep ( 2 ) ; if ( joined ) { for ( ClientHandler handler : clients ) { if ( handler != null ) { client . send ( " / newplayer " , handler . getName ( ) ) ; if ( handler != client ) { handler . send ( " / newplayer " , client . getName ( ) ) ; handler . send ( client . getName ( ) + " ▁ has ▁ come ▁ to ▁ chat ! " ) ; } } } } else { client . send ( " Sorry , ▁ but ▁ the ▁ server ▁ is ▁ full ! ▁ Try ▁ again ▁ later . " ) ; client . printString ( " / kicked " ) ; client . printString ( " / end " ) ; } }
maxdosanjos/JavaSE | public Agenda ( ) throws IOException { List < Contato > contatos = this . arquivo . ler ( ) ; for ( Contato contato : contatos ) { try { this . inserir ( contato ) ; } catch ( AgendaException e ) { e . printStackTrace ( ) ; } } }
maxdosanjos/JavaSE | if ( this . contatosMap . containsKey ( nome ) ) { throw new AgendaException ( " contato ▁ " + nome + " ▁ já ▁ existe " ) ; }
maxdosanjos/JavaSE | if ( contatosLetra == null ) { contatosLetra = new ArrayList < > ( ) ; contatosPorLetra . put ( letraInicial , contatosLetra ) ; }
maxdosanjos/JavaSE | public Contato obterContato ( String nome ) { return this . contatosMap . get ( nome ) ; }
maxdosanjos/JavaSE | public List < Contato > listarContatoPorLetra ( char letra ) { List < Contato > contatos = contatosPorLetra . get ( Character . toUpperCase ( letra ) ) ; if ( contatos == null ) { contatos = new ArrayList < > ( ) ; } return contatos ; }
maxdosanjos/JavaSE | public List < Contato > listarContatoPorParteNome ( String parteNome ) { String regex = " \\ w * " + parteNome + " \\ w * " ; Pattern p = Pattern . compile ( regex , Pattern . CASE_INSENSITIVE ) ; List < Contato > contatosEncontrados = new ArrayList < > ( ) ; Collection < Contato > contatosCadastrados = this . contatosMap . values ( ) ; for ( Contato contato : contatosCadastrados ) { Matcher m = p . matcher ( contato . getNome ( ) ) ; if ( m . matches ( ) ) { contatosEncontrados . add ( contato ) ; } } return contatosEncontrados ; }
maxdosanjos/JavaSE | private void verificarExistenciaContato ( String nome ) throws AgendaException { if ( ! this . contatosMap . containsKey ( nome ) ) { throw new AgendaException ( " Contato ▁ " + nome + " ▁ não ▁ existe ! " ) ; } }
MuShiiii/commons-io | public NullInputStreamTest ( final String name ) { super ( name ) ; }
MuShiiii/commons-io | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; }
MuShiiii/commons-io | @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; }
MuShiiii/commons-io | public void testRead ( ) throws Exception { final int size = 5 ; final InputStream input = new TestNullInputStream ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { assertEquals ( " Check ▁ Size ▁ [ " + i + " ] " , size - i , input . available ( ) ) ; assertEquals ( " Check ▁ Value ▁ [ " + i + " ] " , i , input . read ( ) ) ; } assertEquals ( " Available ▁ after ▁ contents ▁ all ▁ read " , 0 , input . available ( ) ) ; assertEquals ( " End ▁ of ▁ File " , - 1 , input . read ( ) ) ; assertEquals ( " Available ▁ after ▁ End ▁ of ▁ File " , 0 , input . available ( ) ) ; try { final int result = input . read ( ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ IOException , ▁ byte = [ " + result + " ] " ) ; } catch ( final IOException e ) { assertEquals ( " Read ▁ after ▁ end ▁ of ▁ file " , e . getMessage ( ) ) ; } input . close ( ) ; assertEquals ( " Available ▁ after ▁ close " , size , input . available ( ) ) ; }
MuShiiii/commons-io | public void testReadByteArray ( ) throws Exception { final byte [ ] bytes = new byte [ 10 ] ; final InputStream input = new TestNullInputStream ( 15 ) ; final int count1 = input . read ( bytes ) ; assertEquals ( " Read ▁ 1" , bytes . length , count1 ) ; for ( int i = 0 ; i < count1 ; i ++ ) { assertEquals ( " Check ▁ Bytes ▁ 1" , i , bytes [ i ] ) ; } final int count2 = input . read ( bytes ) ; assertEquals ( " Read ▁ 2" , 5 , count2 ) ; for ( int i = 0 ; i < count2 ; i ++ ) { assertEquals ( " Check ▁ Bytes ▁ 2" , count1 + i , bytes [ i ] ) ; } final int count3 = input . read ( bytes ) ; assertEquals ( " Read ▁ 3 ▁ ( EOF ) " , - 1 , count3 ) ; try { final int count4 = input . read ( bytes ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ IOException , ▁ byte = [ " + count4 + " ] " ) ; } catch ( final IOException e ) { assertEquals ( " Read ▁ after ▁ end ▁ of ▁ file " , e . getMessage ( ) ) ; } input . close ( ) ; final int offset = 2 ; final int lth = 4 ; final int count5 = input . read ( bytes , offset , lth ) ; assertEquals ( " Read ▁ 5" , lth , count5 ) ; for ( int i = offset ; i < lth ; i ++ ) { assertEquals ( " Check ▁ Bytes ▁ 2" , i , bytes [ i ] ) ; } }
MuShiiii/commons-io | public void testEOFException ( ) throws Exception { final InputStream input = new TestNullInputStream ( 2 , false , true ) ; assertEquals ( " Read ▁ 1" , 0 , input . read ( ) ) ; assertEquals ( " Read ▁ 2" , 1 , input . read ( ) ) ; try { final int result = input . read ( ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ EOFException , ▁ byte = [ " + result + " ] " ) ; } catch ( final EOFException e ) { } input . close ( ) ; }
MuShiiii/commons-io | public void testMarkAndReset ( ) throws Exception { int position = 0 ; final int readlimit = 10 ; final InputStream input = new TestNullInputStream ( 100 , true , false ) ; assertTrue ( " Mark ▁ Should ▁ be ▁ Supported " , input . markSupported ( ) ) ; try { input . reset ( ) ; fail ( " Read ▁ limit ▁ exceeded , ▁ expected ▁ IOException ▁ " ) ; } catch ( final IOException e ) { assertEquals ( " No ▁ Mark ▁ IOException ▁ message " , " No ▁ position ▁ has ▁ been ▁ marked " , e . getMessage ( ) ) ; } for ( ; position < 3 ; position ++ ) { assertEquals ( " Read ▁ Before ▁ Mark ▁ [ " + position + " ] " , position , input . read ( ) ) ; } input . mark ( readlimit ) ; for ( int i = 0 ; i < 3 ; i ++ ) { assertEquals ( " Read ▁ After ▁ Mark ▁ [ " + i + " ] " , position + i , input . read ( ) ) ; } input . reset ( ) ; for ( int i = 0 ; i < readlimit + 1 ; i ++ ) { assertEquals ( " Read ▁ After ▁ Reset ▁ [ " + i + " ] " , position + i , input . read ( ) ) ; } try { input . reset ( ) ; fail ( " Read ▁ limit ▁ exceeded , ▁ expected ▁ IOException ▁ " ) ; } catch ( final IOException e ) { assertEquals ( " Read ▁ limit ▁ IOException ▁ message " , " Marked ▁ position ▁ [ " + position + " ] ▁ is ▁ no ▁ longer ▁ valid ▁ - ▁ passed ▁ the ▁ read ▁ limit ▁ [ " + readlimit + " ] " , e . getMessage ( ) ) ; } input . close ( ) ; }
MuShiiii/commons-io | public void testMarkNotSupported ( ) throws Exception { final InputStream input = new TestNullInputStream ( 100 , false , true ) ; assertFalse ( " Mark ▁ Should ▁ NOT ▁ be ▁ Supported " , input . markSupported ( ) ) ; try { input . mark ( 5 ) ; fail ( " mark ( ) ▁ should ▁ throw ▁ UnsupportedOperationException " ) ; } catch ( final UnsupportedOperationException e ) { assertEquals ( " mark ( ) ▁ error ▁ message " , " Mark ▁ not ▁ supported " , e . getMessage ( ) ) ; } try { input . reset ( ) ; fail ( " reset ( ) ▁ should ▁ throw ▁ UnsupportedOperationException " ) ; } catch ( final UnsupportedOperationException e ) { assertEquals ( " reset ( ) ▁ error ▁ message " , " Mark ▁ not ▁ supported " , e . getMessage ( ) ) ; } input . close ( ) ; }
MuShiiii/commons-io | public void testSkip ( ) throws Exception { final InputStream input = new TestNullInputStream ( 10 , true , false ) ; assertEquals ( " Read ▁ 1" , 0 , input . read ( ) ) ; assertEquals ( " Read ▁ 2" , 1 , input . read ( ) ) ; assertEquals ( " Skip ▁ 1" , 5 , input . skip ( 5 ) ) ; assertEquals ( " Read ▁ 3" , 7 , input . read ( ) ) ; assertEquals ( " Skip ▁ 2" , 2 , input . skip ( 5 ) ) ; assertEquals ( " Skip ▁ 3 ▁ ( EOF ) " , - 1 , input . skip ( 5 ) ) ; try { input . skip ( 5 ) ; fail ( " Expected ▁ IOException ▁ for ▁ skipping ▁ after ▁ end ▁ of ▁ file " ) ; } catch ( final IOException e ) { assertEquals ( " Skip ▁ after ▁ EOF ▁ IOException ▁ message " , " Skip ▁ after ▁ end ▁ of ▁ file " , e . getMessage ( ) ) ; } input . close ( ) ; }
MuShiiii/commons-io | public TestNullInputStream ( final int size ) { super ( size ) ; }
MuShiiii/commons-io | public TestNullInputStream ( final int size , final boolean markSupported , final boolean throwEofException ) { super ( size , markSupported , throwEofException ) ; }
MuShiiii/commons-io | @ Override protected int processByte ( ) { return ( int ) getPosition ( ) - 1 ; }
MuShiiii/commons-io | @ Override protected void processBytes ( final byte [ ] bytes , final int offset , final int length ) { final int startPos = ( int ) getPosition ( ) - length ; for ( int i = offset ; i < length ; i ++ ) { bytes [ i ] = ( byte ) ( startPos + i ) ; } }
ollide/Xposed-IncognitoTab | @ Override public void handleLoadPackage ( final XC_LoadPackage . LoadPackageParam lpp ) throws Throwable { if ( lpp . packageName . equals ( PackageName . CHROME ) || lpp . packageName . equals ( PackageName . CHROME_BETA ) ) { hookChromeMethods ( lpp ) ; } }
ollide/Xposed-IncognitoTab | private void hookChromeMethods ( XC_LoadPackage . LoadPackageParam lpp ) { final String packageName = lpp . packageName ; final ClassLoader classLoader = lpp . classLoader ; final Class < ? > chromeLauncherActivity = XposedHelpers . findClass ( " com . google . android . apps . chrome . document . ChromeLauncherActivity " , classLoader ) ; XposedHelpers . findAndHookMethod ( " com . google . android . apps . chrome . document . ChromeLauncherActivity " , classLoader , " onCreate " , Bundle . class , new XC_MethodHook ( ) { @ Override protected void afterHookedMethod ( MethodHookParam param ) throws Throwable { super . afterHookedMethod ( param ) ; Activity chromeActivity = ( Activity ) param . thisObject ; String incognitoUrl = chromeActivity . getIntent ( ) . getStringExtra ( EXTRA_INCOGNITO_URL ) ; if ( incognitoUrl != null ) { if ( ChromeUtils . isDocumentMode ( classLoader , packageName , chromeActivity ) ) { XposedHelpers . callStaticMethod ( chromeLauncherActivity , " launchInstance " , chromeActivity , true , 0 , incognitoUrl , 201 , 6 , false , null ) ; } else { didOpen = false ; url = incognitoUrl ; } } } } ) ; final Class < ? > loadUrlParamsClass = XposedHelpers . findClass ( " org . chromium . content _ public . browser . LoadUrlParams " , classLoader ) ; final Class < ? > tabLaunchTypeClass = XposedHelpers . findClass ( " org . chromium . chrome . browser . tabmodel . TabModel . TabLaunchType " , classLoader ) ; XposedHelpers . findAndHookMethod ( " com . google . android . apps . chrome . tab . ChromeTab " , classLoader , " didStartPageLoad " , String . class , boolean . class , new XC_MethodHook ( ) { @ Override protected void beforeHookedMethod ( MethodHookParam param ) throws Throwable { super . beforeHookedMethod ( param ) ; if ( ! didOpen && url != null ) { didOpen = true ; Object chromeTab = param . thisObject ; Object chromeActivity = XposedHelpers . getObjectField ( chromeTab , " mActivity " ) ; Object tabCreator = XposedHelpers . callMethod ( chromeActivity , " getTabCreator " , true ) ; Constructor < ? > constructor = loadUrlParamsClass . getConstructor ( String . class ) ; Object loadUrlParams = constructor . newInstance ( url ) ; Enum tabLaunchType = Enum . valueOf ( ( Class < ? extends Enum > ) tabLaunchTypeClass , " FROM _ MENU _ OR _ OVERVIEW " ) ; XposedHelpers . callMethod ( tabCreator , " createNewTab " , loadUrlParams , tabLaunchType , chromeTab ) ; } } } ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | public LuceneReindexAlgorithm ( ) throws Exception { super ( ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | public void setIndexedObjects ( String indexedObjects ) { this . indexedObjects = indexedObjects ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void compute ( ) throws Exception { if ( fullTextEntityManager == null ) { fullTextEntityManager = Search . getFullTextEntityManager ( manager ) ; } computeLuceneIndexes ( indexedObjects ) ; fullTextEntityManager . close ( ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void reset ( ) throws Exception { if ( fullTextEntityManager == null ) { fullTextEntityManager = Search . getFullTextEntityManager ( manager ) ; } clearLuceneIndexes ( ) ; fullTextEntityManager . close ( ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | private void computeLuceneIndexes ( String indexedObjects ) throws Exception { Set < String > objectsToReindex = new HashSet < > ( ) ; if ( indexedObjects == null || indexedObjects . isEmpty ( ) ) { objectsToReindex . add ( " ConceptJpa " ) ; objectsToReindex . add ( " ProjectJpa " ) ; } else { String [ ] objects = indexedObjects . replaceAll ( " ▁ " , " " ) . split ( " , " ) ; for ( String object : objects ) objectsToReindex . add ( object ) ; } Logger . getLogger ( getClass ( ) ) . info ( " Starting ▁ reindexing ▁ for : " ) ; for ( String objectToReindex : objectsToReindex ) { Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ " + objectToReindex ) ; } FullTextEntityManager fullTextEntityManager = Search . getFullTextEntityManager ( manager ) ; if ( objectsToReindex . contains ( " ConceptJpa " ) ) { Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ Creating ▁ indexes ▁ for ▁ ConceptJpa " ) ; fullTextEntityManager . purgeAll ( ConceptJpa . class ) ; fullTextEntityManager . flushToIndexes ( ) ; fullTextEntityManager . createIndexer ( ConceptJpa . class ) . batchSizeToLoadObjects ( 100 ) . cacheMode ( CacheMode . NORMAL ) . threadsToLoadObjects ( 4 ) . startAndWait ( ) ; objectsToReindex . remove ( " ConceptJpa " ) ; } if ( objectsToReindex . contains ( " ProjectJpa " ) ) { Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ Creating ▁ indexes ▁ for ▁ ProjectJpa " ) ; fullTextEntityManager . purgeAll ( ProjectJpa . class ) ; fullTextEntityManager . flushToIndexes ( ) ; fullTextEntityManager . createIndexer ( ProjectJpa . class ) . batchSizeToLoadObjects ( 100 ) . cacheMode ( CacheMode . NORMAL ) . threadsToLoadObjects ( 4 ) . startAndWait ( ) ; objectsToReindex . remove ( " ProjectJpa " ) ; } if ( objectsToReindex . size ( ) != 0 ) { throw new Exception ( " The ▁ following ▁ objects ▁ were ▁ specified ▁ for ▁ re - indexing , ▁ but ▁ do ▁ not ▁ exist ▁ as ▁ indexed ▁ objects : ▁ " + objectsToReindex . toString ( ) ) ; } Logger . getLogger ( getClass ( ) ) . info ( " done ▁ . . . " ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | private void clearLuceneIndexes ( ) throws Exception { fullTextEntityManager . purgeAll ( ConceptJpa . class ) ; fullTextEntityManager . purgeAll ( ProjectJpa . class ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | public void fireProgressEvent ( int pct , String note ) { ProgressEvent pe = new ProgressEvent ( this , pct , pct , note ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { listeners . get ( i ) . updateProgress ( pe ) ; } Logger . getLogger ( getClass ( ) ) . info ( " ▁ ▁ ▁ ▁ " + pct + " % ▁ " + note ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void addProgressListener ( ProgressListener l ) { listeners . add ( l ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void removeProgressListener ( ProgressListener l ) { listeners . remove ( l ) ; }
WestCoastInformatics/SNOMED-Terminology-Server | @ Override public void cancel ( ) { requestCancel = true ; }
Syncleus/AetherMUD | public UseCommand ( GameManager gameManager ) { super ( gameManager , validTriggers , description , correctUsage ) ; }
Syncleus/AetherMUD | @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { execCommand ( ctx , e , ( ) -> { UseItemOn useItemOn = new UseItemOn ( originalMessageParts ) ; if ( Strings . isNullOrEmpty ( useItemOn . getItem ( ) ) ) { write ( " No ▁ item ▁ specified . " ) ; return ; } Optional < ItemInstance > inventoryItemOptional = player . getInventoryItem ( useItemOn . getItem ( ) ) ; if ( ! inventoryItemOptional . isPresent ( ) ) { write ( " Useable ▁ item ▁ is ▁ not ▁ found ▁ in ▁ your ▁ inventory . \r \n " ) ; return ; } gameManager . getItemUseHandler ( ) . handle ( player , inventoryItemOptional . get ( ) , useItemOn ) ; } ) ; }
Syncleus/AetherMUD | public UseItemOn ( List < String > originalMessageParts ) { originalMessageParts . remove ( 0 ) ; String fullCommand = Joiner . on ( " ▁ " ) . join ( originalMessageParts ) ; if ( fullCommand . endsWith ( " ▁ on " ) ) fullCommand = fullCommand . substring ( 0 , fullCommand . length ( ) - 3 ) ; item = getItem ( fullCommand ) ; target = getItemTarget ( fullCommand ) ; }
Syncleus/AetherMUD | public Optional < String > getTarget ( ) { return target ; }
Syncleus/AetherMUD | public String getItem ( ) { return item ; }
Mun1z/PROJECT-MANAGER | public long getId ( ) { return id ; }
Mun1z/PROJECT-MANAGER | public void setId ( long id ) { this . id = id ; }
Mun1z/PROJECT-MANAGER | public String getDescricaoGeral ( ) { return descricaoGeral ; }
Mun1z/PROJECT-MANAGER | public void setDescricaoGeral ( String descricaoGeral ) { this . descricaoGeral = descricaoGeral ; }
Mun1z/PROJECT-MANAGER | public String getDataDeCriacao ( ) { return dataDeCriacao ; }
Mun1z/PROJECT-MANAGER | public void setDataDeCriacao ( String dataDeCriacao ) { this . dataDeCriacao = dataDeCriacao ; }
Mun1z/PROJECT-MANAGER | public String getDataDeFinalizacao ( ) { return dataDeFinalizacao ; }
Mun1z/PROJECT-MANAGER | public void setDataDeFinalizacao ( String dataDeFinalizacao ) { this . dataDeFinalizacao = dataDeFinalizacao ; }
blue-fly/smartglass | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_setup1 ) ; }
blue-fly/smartglass | public void next ( View view ) { showNext ( ) ; }
blue-fly/smartglass | @ Override public void showPref ( ) { }
blue-fly/smartglass | @ Override public void showNext ( ) { Intent i = new Intent ( Setup1Activity . this , Setup2Activity . class ) ; startActivity ( i ) ; finish ( ) ; overridePendingTransition ( R . anim . page_next , R . anim . page_exit ) ; }
nicksellen/reka | public RekaDeployOperation ( ApplicationManager manager , BaseDirs basedirs , Function < Data , Path > dataPathFn , Function < Data , Path > appPathFn ) { this . manager = manager ; this . basedirs = basedirs ; this . dataPathFn = dataPathFn ; this . appPathFn = appPathFn ; }
nicksellen/reka | @ Override public void call ( MutableData data , OperationContext ctx , OperationResult res ) { Path dataPath = dataPathFn . apply ( data ) ; Path appPath = appPathFn . apply ( data ) ; data . putString ( " identity " , appPath . slashes ( ) ) ; int version = manager . nextVersion ( appPath ) ; AppDirs dirs = basedirs . resolve ( appPath , version ) ; Data val = data . at ( dataPath ) ; if ( ! val . isPresent ( ) ) throw runtime ( " no ▁ data ▁ at ▁ % s " , dataPath . dots ( ) ) ; if ( ! val . isContent ( ) ) throw runtime ( " not ▁ content ▁ at ▁ % s " , dataPath . dots ( ) ) ; if ( ! val . content ( ) . type ( ) . equals ( Content . Type . BINARY ) ) throw runtime ( " must ▁ be ▁ binary ▁ content ▁ at ▁ % s " , dataPath . dots ( ) ) ; BinaryContent bc = ( BinaryContent ) val . content ( ) ; if ( ! " application / zip " . equals ( bc . contentType ( ) ) ) throw runtime ( " must ▁ be ▁ application / zip ▁ content ▁ at ▁ % s " , dataPath . dots ( ) ) ; log . info ( " unpacking ▁ { } ▁ to ▁ { } " , appPath . slashes ( ) , dirs . app ( ) ) ; dirs . mkdirs ( ) ; deleteRecursively ( dirs . app ( ) ) ; unzip ( bc . asBytes ( ) , dirs . app ( ) ) ; File appdir = dirs . app ( ) . toFile ( ) ; File mainreka = dirs . app ( ) . resolve ( " main . reka " ) . toFile ( ) ; checkArgument ( appdir . exists ( ) , " app ▁ dir ▁ does ▁ not ▁ exist ▁ [ % s ] " , appdir ) ; checkArgument ( appdir . isDirectory ( ) , " app ▁ dir ▁ is ▁ not ▁ directory ▁ [ % s ] " , appdir ) ; checkArgument ( mainreka . exists ( ) , " main . reka ▁ does ▁ not ▁ exist " ) ; checkArgument ( ! mainreka . isDirectory ( ) , " main . reka ▁ is ▁ a ▁ directory " ) ; log . info ( " deploying ▁ { } " , appPath . slashes ( ) ) ; manager . deploySource ( appPath , - 1 , FileSource . from ( mainreka ) , new DeploySubscriber ( ) { @ Override public void ok ( Identity identity , int version , Application application ) { log . info ( " deploying ▁ { } ▁ ok " , identity ) ; data . putString ( " message " , " created ▁ application ! " ) ; res . done ( ) ; for ( int v = version - 3 ; v >= 0 ; v -- ) { deleteRecursively ( basedirs . resolve ( identity . path ( ) , v ) . app ( ) ) ; } } @ Override public void error ( Identity identity , Throwable t ) { t = unwrap ( t ) ; log . error ( " failed ▁ to ▁ deploy ▁ [ { } ] ▁ - ▁ { } " , identity . name ( ) , t . getMessage ( ) ) ; res . error ( t ) ; deleteRecursively ( dirs . app ( ) ) ; } } ) ; }
Martinfx/yodaqa | public QuestionConcept ( String title , int pageId ) { this . title = title ; this . pageId = pageId ; }
Martinfx/yodaqa | public String getTitle ( ) { return title ; }
Martinfx/yodaqa | public int getPageId ( ) { return pageId ; }
graham22/Classic | public ModbusResponse getResponse ( ) { ReadExceptionStatusResponse response = null ; response = new ReadExceptionStatusResponse ( ) ; response . setHeadless ( isHeadless ( ) ) ; if ( ! isHeadless ( ) ) { response . setTransactionID ( getTransactionID ( ) ) ; response . setProtocolID ( getProtocolID ( ) ) ; } response . setUnitID ( getUnitID ( ) ) ; response . setFunctionCode ( getFunctionCode ( ) ) ; return response ; }
graham22/Classic | public ModbusResponse createResponse ( ) { throw new RuntimeException ( ) ; }
graham22/Classic | public void writeData ( DataOutput dout ) throws IOException { dout . write ( getMessage ( ) ) ; }
graham22/Classic | public void readData ( DataInput din ) throws IOException { }
graham22/Classic | public byte [ ] getMessage ( ) { byte results [ ] = new byte [ 0 ] ; return results ; }
graham22/Classic | public ReadExceptionStatusRequest ( ) { super ( ) ; setFunctionCode ( Modbus . READ_EXCEPTION_STATUS ) ; setDataLength ( 0 ) ; }
miniway/presto | public InternalTable ( Map < String , Integer > columnIndexes , Iterable < Page > pages ) { this . columnIndexes = ImmutableMap . copyOf ( requireNonNull ( columnIndexes , " columnIndexes ▁ is ▁ null " ) ) ; this . pages = ImmutableList . copyOf ( requireNonNull ( pages , " pages ▁ is ▁ null " ) ) ; }
miniway/presto | public int getColumnIndex ( String columnName ) { Integer index = columnIndexes . get ( columnName ) ; checkArgument ( index != null , " Column ▁ % s ▁ not ▁ found " , columnName ) ; return index ; }
miniway/presto | public List < Page > getPages ( ) { return pages ; }
miniway/presto | public Builder ( List < String > columnNames , List < Type > types ) { requireNonNull ( columnNames , " columnNames ▁ is ▁ null " ) ; ImmutableMap . Builder < String , Integer > columnIndexes = ImmutableMap . builder ( ) ; int columnIndex = 0 ; for ( String columnName : columnNames ) { columnIndexes . put ( columnName , columnIndex ++ ) ; } this . columnIndexes = columnIndexes . build ( ) ; this . types = ImmutableList . copyOf ( requireNonNull ( types , " types ▁ is ▁ null " ) ) ; checkArgument ( columnNames . size ( ) == types . size ( ) , " Column ▁ name ▁ count ▁ does ▁ not ▁ match ▁ type ▁ count : ▁ columnNames = % s , ▁ types = % s " , columnNames , types . size ( ) ) ; pages = new ArrayList < > ( ) ; pageBuilder = new PageBuilder ( types ) ; }
miniway/presto | public Builder add ( Object ... values ) { pageBuilder . declarePosition ( ) ; for ( int i = 0 ; i < types . size ( ) ; i ++ ) { writeNativeValue ( types . get ( i ) , pageBuilder . getBlockBuilder ( i ) , values [ i ] ) ; } if ( pageBuilder . isFull ( ) ) { flushPage ( ) ; } return this ; }
miniway/presto | public InternalTable build ( ) { flushPage ( ) ; return new InternalTable ( columnIndexes , pages ) ; }
miniway/presto | private void flushPage ( ) { if ( ! pageBuilder . isEmpty ( ) ) { pages . add ( pageBuilder . build ( ) ) ; pageBuilder . reset ( ) ; } }
rokn/Count_Words_2015 | public RoundCall ( QName fname , Vector arguments ) { super ( fname , arguments ) ; }
rokn/Count_Words_2015 | public void translate ( ClassGenerator classGen , MethodGenerator methodGen ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; argument ( ) . translate ( classGen , methodGen ) ; il . append ( new INVOKESTATIC ( cpg . addMethodref ( BASIS_LIBRARY_CLASS , " roundF " , " ( D ) D " ) ) ) ; }
flyzsd/java-code-snippets | private JMXConnectorServerFactory ( ) { }
gosu-lang/old-gosu-repo | @ Override public Element getState ( ) { final Element element = new Element ( GOSU_COMPILER_SETTINGS_TAG ) ; element . setAttribute ( ExternalCompilerMemory , String . valueOf ( myExternalCompilerMemory ) ) ; element . setAttribute ( ExternalToIncrementalCompilerLimit , String . valueOf ( myExternalToIncrementalCompiler ) ) ; return element ; }
gosu-lang/old-gosu-repo | @ Override public void loadState ( Element state ) { setExternalCompilerMemory ( Integer . valueOf ( state . getAttributeValue ( ExternalCompilerMemory , String . valueOf ( DEFAULT_Xmx ) ) ) ) ; setExternalToIncrementalCompiler ( Integer . valueOf ( state . getAttributeValue ( ExternalToIncrementalCompilerLimit , String . valueOf ( DEFAULT_INCREMENTAL_LIMIT ) ) ) ) ; }
gosu-lang/old-gosu-repo | public int getExternalCompilerMemory ( ) { return myExternalCompilerMemory ; }
gosu-lang/old-gosu-repo | public void setExternalCompilerMemory ( int myExternalCompilerMemory ) { this . myExternalCompilerMemory = myExternalCompilerMemory ; }
gosu-lang/old-gosu-repo | public int getExternalToIncrementalCompilerLimit ( ) { return myExternalToIncrementalCompiler ; }
gosu-lang/old-gosu-repo | public void setExternalToIncrementalCompiler ( int myExternalToIncrementalCompiler ) { this . myExternalToIncrementalCompiler = myExternalToIncrementalCompiler ; }
iansoftdev/all-blockchain | public Long getId ( ) { return id ; }
iansoftdev/all-blockchain | public Korbit setId ( Long id ) { this . id = id ; return this ; }
iansoftdev/all-blockchain | public String getSymbol ( ) { return symbol ; }
iansoftdev/all-blockchain | public Korbit setSymbol ( String symbol ) { this . symbol = symbol ; return this ; }
iansoftdev/all-blockchain | public String getTimestamp ( ) { return timestamp ; }
iansoftdev/all-blockchain | public Korbit setTimestamp ( String timestamp ) { this . timestamp = timestamp ; return this ; }
iansoftdev/all-blockchain | public String getLast ( ) { return last ; }
iansoftdev/all-blockchain | public Korbit setLast ( String last ) { this . last = last ; return this ; }
iansoftdev/all-blockchain | public String getBid ( ) { return bid ; }
iansoftdev/all-blockchain | public Korbit setBid ( String bid ) { this . bid = bid ; return this ; }
iansoftdev/all-blockchain | public String getAsk ( ) { return ask ; }
iansoftdev/all-blockchain | public Korbit setAsk ( String ask ) { this . ask = ask ; return this ; }
iansoftdev/all-blockchain | public String getLow ( ) { return low ; }
iansoftdev/all-blockchain | public Korbit setLow ( String low ) { this . low = low ; return this ; }
iansoftdev/all-blockchain | public String getHigh ( ) { return high ; }
iansoftdev/all-blockchain | public Korbit setHigh ( String high ) { this . high = high ; return this ; }
iansoftdev/all-blockchain | public String getVolume ( ) { return volume ; }
iansoftdev/all-blockchain | public Korbit setVolume ( String volume ) { this . volume = volume ; return this ; }
iansoftdev/all-blockchain | public String getChange ( ) { return change ; }
iansoftdev/all-blockchain | public Korbit setChange ( String change ) { this . change = change ; return this ; }
iansoftdev/all-blockchain | public String getChangePercent ( ) { return changePercent ; }
iansoftdev/all-blockchain | public Korbit setChangePercent ( String changePercent ) { this . changePercent = changePercent ; return this ; }
iansoftdev/all-blockchain | public ZonedDateTime getCreatedat ( ) { return createdat ; }
iansoftdev/all-blockchain | public Korbit setCreatedat ( ZonedDateTime createdat ) { this . createdat = createdat ; return this ; }
Orange-OpenSource/maven-plugins | @ Override public void setUp ( ) { tester = new WicketTester ( new WicketApplication ( ) ) ; }
Orange-OpenSource/maven-plugins | public void testRenderMyPage ( ) { tester . startPage ( HomePage . class ) ; tester . assertRenderedPage ( HomePage . class ) ; tester . assertLabel ( " message " , " If ▁ you ▁ see ▁ this ▁ message ▁ wicket ▁ is ▁ properly ▁ configured ▁ and ▁ running " ) ; }
dushmis/dagger | @ AssistedInject PrivateMethodRequestRepresentation ( @ Assisted BindingRequest request , @ Assisted ContributionBinding binding , @ Assisted RequestRepresentation wrappedRequestRepresentation , ComponentImplementation componentImplementation , DaggerTypes types , CompilerOptions compilerOptions ) { super ( componentImplementation . shardImplementation ( binding ) , types ) ; this . binding = checkNotNull ( binding ) ; this . request = checkNotNull ( request ) ; this . wrappedRequestRepresentation = checkNotNull ( wrappedRequestRepresentation ) ; this . shardImplementation = componentImplementation . shardImplementation ( binding ) ; this . compilerOptions = compilerOptions ; this . types = types ; }
dushmis/dagger | @ Override protected CodeBlock methodCall ( ) { return CodeBlock . of ( " $ N ( ) " , methodName ( ) ) ; }
dushmis/dagger | @ Override protected TypeMirror returnType ( ) { if ( request . isRequestKind ( RequestKind . INSTANCE ) && binding . contributedPrimitiveType ( ) . isPresent ( ) ) { return binding . contributedPrimitiveType ( ) . get ( ) ; } TypeMirror requestedType = request . requestedType ( binding . contributedType ( ) , types ) ; return types . accessibleType ( requestedType , shardImplementation . name ( ) ) ; }
dushmis/dagger | private String methodName ( ) { if ( methodName == null ) { methodName = shardImplementation . getUniqueMethodName ( request ) ; shardImplementation . addMethod ( PRIVATE_METHOD , methodBuilder ( methodName ) . addModifiers ( PRIVATE ) . returns ( TypeName . get ( returnType ( ) ) ) . addStatement ( " return ▁ $ L " , wrappedRequestRepresentation . getDependencyExpression ( shardImplementation . name ( ) ) . codeBlock ( ) ) . build ( ) ) ; } return methodName ; }
bruceadowns/miru | @ JsonCreator public MiruAuthzExpression ( @ JsonProperty ( " values " ) List < String > values ) { this . values = values ; }
bruceadowns/miru | public long sizeInBytes ( ) { long sizeInBytes = 0 ; for ( String value : values ) { sizeInBytes += 2 * value . length ( ) ; } return sizeInBytes ; }
bruceadowns/miru | @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } MiruAuthzExpression that = ( MiruAuthzExpression ) o ; return ! ( values != null ? ! values . equals ( that . values ) : that . values != null ) ; }
bruceadowns/miru | @ Override public int hashCode ( ) { return values != null ? values . hashCode ( ) : 0 ; }
bruceadowns/miru | @ Override public String toString ( ) { return " MiruAuthzExpression { " + " values = " + values + ' } ' ; }
MCAds/Plugin | if ( Main . config ( ) . getBoolean ( " featured " ) ) { DocumentBuilderFactory dbFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder dBuilder = dbFactory . newDocumentBuilder ( ) ; String xmlFile = Main . dataFolder ( ) + " / cache / featured / " + type + " . xml " ; Document doc = dBuilder . parse ( xmlFile ) ; doc . getDocumentElement ( ) . normalize ( ) ; NodeList nList = doc . getElementsByTagName ( type ) ; for ( int temp = 0 ; temp < nList . getLength ( ) ; temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; ads . add ( eElement . getTextContent ( ) ) ; } } }
MCAds/Plugin | for ( String ad : userAds ) { ads . add ( ad ) ; }
MCAds/Plugin | if ( Main . config ( ) . getBoolean ( " images " ) ) { NodeList nodeList = doc . getElementsByTagName ( " image " ) ; for ( int temp = 0 ; temp < nodeList . getLength ( ) ; temp ++ ) { Node nNode = nodeList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; File imageFile = new File ( Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; if ( ! imageFile . exists ( ) ) { Cache . image ( eElement . getTextContent ( ) ) ; } if ( type == " chat " ) { if ( eElement . hasAttribute ( " height " ) ) { imageHeight = Integer . parseInt ( eElement . getAttribute ( " height " ) ) ; } else { imageHeight = 8 ; } image = Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ; } if ( type == " hologram " ) { if ( eElement . hasAttribute ( " height " ) ) { lines . put ( Integer . parseInt ( eElement . getAttribute ( " height " ) ) , " image : " + Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; } else { lines . put ( 8 , " image : " + Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; } } } } }
MCAds/Plugin | temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; if ( eElement . hasAttribute ( " number " ) ) { lines . put ( Integer . parseInt ( eElement . getAttribute ( " number " ) ) , eElement . getTextContent ( ) ) ; } else { lines . put ( temp , eElement . getTextContent ( ) ) ; } } }
MCAds/Plugin | catch ( Exception e ) { lines . clear ( ) ; System . out . println ( " There ▁ is ▁ an ▁ error ▁ with ▁ the ▁ ad ▁ file ▁ at ▁ " + random ) ; if ( type == " scoreboard " ) { int number = Phrases . config . getStringList ( " ad _ error _ scoreboard " ) . size ( ) ; for ( String line : Phrases . config . getStringList ( " ad _ error _ scoreboard " ) ) { number -- ; lines . put ( number , line ) ; } } else { lines . put ( 1 , Phrases . config . getString ( " ad _ error " ) ) ; } }
MCAds/Plugin | temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; ads . add ( eElement . getTextContent ( ) ) ; } }
MCAds/Plugin | public void config ( ) throws IOException { file = new File ( Main . dataFolder ( ) , " ads . yml " ) ; config = YamlConfiguration . loadConfiguration ( file ) ; config . options ( ) . copyDefaults ( true ) ; Reader textResource = Main . textResource ( " ads . yml " ) ; config . setDefaults ( YamlConfiguration . loadConfiguration ( textResource ) ) ; config . save ( file ) ; }
jentrata/jentrata | public boolean isSendReceipt ( ) { return sendReceipt ; }
jentrata/jentrata | public void setSendReceipt ( boolean sendReceipt ) { this . sendReceipt = sendReceipt ; }
jentrata/jentrata | public ReplyPatternType getSendReceiptReplyPattern ( ) { return sendReceiptReplyPattern ; }
jentrata/jentrata | public void setSendReceiptReplyPattern ( ReplyPatternType sendReceiptReplyPattern ) { this . sendReceiptReplyPattern = sendReceiptReplyPattern ; }
jentrata/jentrata | public boolean isSendReceiptNonRepudiation ( ) { return sendReceiptNonRepudiation ; }
jentrata/jentrata | public void setSendReceiptNonRepudiation ( boolean sendReceiptNonRepudiation ) { this . sendReceiptNonRepudiation = sendReceiptNonRepudiation ; }
jentrata/jentrata | public Signature getSignature ( ) { return signature ; }
jentrata/jentrata | public void setSignature ( Signature signature ) { this . signature = signature ; }
jentrata/jentrata | public boolean isDisableBSPEnforcement ( ) { return disableBSPEnforcement ; }
jentrata/jentrata | public void setDisableBSPEnforcement ( boolean disableBSPEnforcement ) { this . disableBSPEnforcement = disableBSPEnforcement ; }
jentrata/jentrata | public boolean isInclusiveNamespacesEnabled ( ) { return inclusiveNamespacesEnabled ; }
jentrata/jentrata | public void setInclusiveNamespacesEnabled ( boolean inclusiveNamespacesEnabled ) { this . inclusiveNamespacesEnabled = inclusiveNamespacesEnabled ; }
AliaksandrShuhayeu/pentaho-kettle | @ Before public void setUp ( ) throws Exception { mockHelper = StepMockUtil . getStepMockHelper ( MappingMeta . class , " MappingUnitTest " ) ; mapping = new Mapping ( mockHelper . stepMeta , mockHelper . stepDataInterface , 0 , mockHelper . transMeta , mockHelper . trans ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test public void pickupTargetStepsFor_OutputIsNotDefined ( ) throws Exception { StepMeta singleMeta = new StepMeta ( " single " , null ) ; StepMeta copiedMeta = new StepMeta ( " copied " , null ) ; Mockito . when ( mockHelper . transMeta . findNextSteps ( mockHelper . stepMeta ) ) . thenReturn ( Arrays . asList ( singleMeta , copiedMeta ) ) ; StepInterface single = Mockito . mock ( StepInterface . class ) ; Mockito . when ( mockHelper . trans . findStepInterfaces ( " single " ) ) . thenReturn ( Collections . singletonList ( single ) ) ; StepInterface copy1 = Mockito . mock ( StepInterface . class ) ; StepInterface copy2 = Mockito . mock ( StepInterface . class ) ; Mockito . when ( mockHelper . trans . findStepInterfaces ( " copied " ) ) . thenReturn ( Arrays . asList ( copy1 , copy2 ) ) ; MappingIODefinition definition = new MappingIODefinition ( null , null ) ; StepInterface [ ] targetSteps = mapping . pickupTargetStepsFor ( definition ) ; assertThat ( Arrays . asList ( targetSteps ) , JUnitMatchers . hasItems ( is ( single ) , is ( copy1 ) , is ( copy2 ) ) ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test public void pickupTargetStepsFor_OutputIsDefined ( ) throws Exception { StepInterface copy1 = Mockito . mock ( StepInterface . class ) ; StepInterface copy2 = Mockito . mock ( StepInterface . class ) ; Mockito . when ( mockHelper . trans . findStepInterfaces ( " copied " ) ) . thenReturn ( Arrays . asList ( copy1 , copy2 ) ) ; MappingIODefinition definition = new MappingIODefinition ( null , " copied " ) ; StepInterface [ ] targetSteps = mapping . pickupTargetStepsFor ( definition ) ; assertThat ( Arrays . asList ( targetSteps ) , JUnitMatchers . hasItems ( is ( copy1 ) , is ( copy2 ) ) ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test ( expected = KettleException . class ) public void pickupTargetStepsFor_OutputIsDefined_ThrowsExceptionIfFindsNone ( ) throws Exception { MappingIODefinition definition = new MappingIODefinition ( null , " non - existing " ) ; mapping . pickupTargetStepsFor ( definition ) ; }
AliaksandrShuhayeu/pentaho-kettle | @ Test public void testDispose ( ) throws Exception { MappingMeta meta = Mockito . mock ( MappingMeta . class ) ; MappingData data = Mockito . mock ( MappingData . class ) ; Mockito . when ( data . getMappingTrans ( ) ) . thenReturn ( mockHelper . trans ) ; MappingInput [ ] mappingInputs = { Mockito . mock ( MappingInput . class ) } ; MappingOutput [ ] mappingOutputs = { Mockito . mock ( MappingOutput . class ) } ; Mockito . when ( mockHelper . trans . findMappingInput ( ) ) . thenReturn ( mappingInputs ) ; Mockito . when ( mockHelper . trans . findMappingOutput ( ) ) . thenReturn ( mappingOutputs ) ; data . mappingTransMeta = mockHelper . transMeta ; Mockito . when ( data . mappingTransMeta . getTransformationType ( ) ) . thenReturn ( TransMeta . TransformationType . SingleThreaded ) ; data . singleThreadedTransExcecutor = Mockito . mock ( SingleThreadedTransExecutor . class ) ; Mockito . when ( data . singleThreadedTransExcecutor . oneIteration ( ) ) . thenReturn ( true ) ; data . mappingTrans = mockHelper . trans ; Mockito . when ( mockHelper . trans . isFinished ( ) ) . thenReturn ( false ) ; Mapping mapping = Mockito . spy ( new Mapping ( mockHelper . stepMeta , data , 0 , mockHelper . transMeta , mockHelper . trans ) ) ; String stepName = " StepName " ; mapping . setStepname ( stepName ) ; mapping . processRow ( meta , data ) ; mapping . dispose ( meta , data ) ; Mockito . verify ( mockHelper . trans , Mockito . times ( 1 ) ) . removeActiveSubTransformation ( stepName ) ; }
apacheignite/ignite | if ( osLow . contains ( " win " ) ) { if ( osLow . contains ( "95" ) ) win95 = true ; else if ( osLow . contains ( "98" ) ) win98 = true ; else if ( osLow . contains ( " nt " ) ) winNt = true ; else if ( osLow . contains ( "2000" ) ) win2k = true ; else if ( osLow . contains ( " vista " ) ) winVista = true ; else if ( osLow . contains ( " xp " ) ) winXp = true ; else if ( osLow . contains ( "2003" ) ) win2003 = true ; else if ( osLow . contains ( "2008" ) ) win2008 = true ; else if ( osLow . contains ( "7" ) ) win7 = true ; else if ( osLow . contains ( "8.1" ) ) win81 = true ; else if ( osLow . contains ( "8" ) ) win8 = true ; else unknownWin = true ; }
apacheignite/ignite | ) if ( osLow . contains ( os ) ) { unix = true ; break ; }
apacheignite/ignite | catch ( NoSuchMethodException e ) { throw withCause ( new AssertionError ( " Object ▁ class ▁ does ▁ not ▁ have ▁ empty ▁ constructor ▁ ( is ▁ JDK ▁ corrupted ? ) . " ) , e ) ; }
apacheignite/ignite | catch ( NoSuchMethodException | ClassNotFoundException | IllegalAccessException | InvocationTargetException ignored ) { }
apacheignite/ignite | if ( Boolean . parseBoolean ( System . getProperty ( IGNITE_DISABLE_HOSTNAME_VERIFIER ) ) ) { HttpsURLConnection . setDefaultHostnameVerifier ( new HostnameVerifier ( ) { @ Override public boolean verify ( String hostname , SSLSession sslSes ) { return true ; } } ) ; }
apacheignite/ignite | for ( Class < ? > cls : evtHolderClasses ) { for ( Field field : cls . getFields ( ) ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) && field . getType ( ) . equals ( int . class ) ) { if ( field . getName ( ) . startsWith ( " EVT _ " ) ) { try { int type = field . getInt ( null ) ; String prev = GRID_EVT_NAMES . put ( type , field . getName ( ) . substring ( " EVT _ " . length ( ) ) ) ; assert prev == null : " Duplicate ▁ event ▁ [ type = " + type + " , ▁ name1 = " + prev + " , ▁ name2 = " + field . getName ( ) + ' ] ' ; } catch ( IllegalAccessException e ) { throw new IgniteException ( e ) ; } } } } }
apacheignite/ignite | if ( EVTS_ALL == null || EVTS_ALL_MINUS_METRIC_UPDATE == null ) { try { Field f1 = EventType . class . getDeclaredField ( " EVTS _ ALL " ) ; Field f2 = EventType . class . getDeclaredField ( " EVTS _ ALL _ MINUS _ METRIC _ UPDATE " ) ; assert f1 != null ; assert f2 != null ; UNSAFE . putObjectVolatile ( UNSAFE . staticFieldBase ( f1 ) , UNSAFE . staticFieldOffset ( f1 ) , gridEvents ( ) ) ; UNSAFE . putObjectVolatile ( UNSAFE . staticFieldBase ( f2 ) , UNSAFE . staticFieldOffset ( f2 ) , gridEvents ( EVT_NODE_METRICS_UPDATED ) ) ; assert EVTS_ALL != null ; assert EVTS_ALL . length == GRID_EVTS . length ; assert EVTS_ALL_MINUS_METRIC_UPDATE != null ; assert EVTS_ALL_MINUS_METRIC_UPDATE . length == GRID_EVTS . length - 1 ; for ( int type : GRID_EVTS ) { assert containsIntArray ( EVTS_ALL , type ) ; if ( type != EVT_NODE_METRICS_UPDATED ) assert containsIntArray ( EVTS_ALL_MINUS_METRIC_UPDATE , type ) ; } assert ! containsIntArray ( EVTS_ALL_MINUS_METRIC_UPDATE , EVT_NODE_METRICS_UPDATED ) ; } catch ( NoSuchFieldException e ) { throw new IgniteException ( e ) ; } }
apacheignite/ignite | if ( len > 0 ) { arr = new Object [ len ] ; for ( int i = 0 ; i < len ; i ++ ) arr [ i ] = in . readObject ( ) ; }
apacheignite/ignite | if ( len > 0 ) { arr = new Class < ? > [ len ] ; for ( int i = 0 ; i < len ; i ++ ) arr [ i ] = ( Class < ? > ) in . readObject ( ) ; }
apacheignite/ignite | if ( locAddr . isAnyLocalAddress ( ) ) { IgniteBiTuple < Collection < String > , Collection < String > > res = cachedLocalAddr ; if ( res == null ) { List < InetAddress > localAddrs = new ArrayList < > ( ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) { for ( InetAddress addr : asIterable ( itf . getInetAddresses ( ) ) ) { if ( ! addr . isLinkLocalAddress ( ) ) localAddrs . add ( addr ) ; } } localAddrs = filterReachable ( localAddrs ) ; for ( InetAddress addr : localAddrs ) addresses ( addr , addrs , hostNames ) ; if ( F . isEmpty ( addrs ) ) throw new IgniteCheckedException ( " No ▁ network ▁ addresses ▁ found ▁ ( is ▁ networking ▁ enabled ? ) . " ) ; res = F . t ( addrs , hostNames ) ; cachedLocalAddr = res ; } return res ; }
apacheignite/ignite | @ Override public boolean verify ( String hostname , SSLSession ses ) { return true ; }
mifos/1.4.x | public OfficeListTagTest ( ) { super ( ) ; initialize ( ) ; }
mifos/1.4.x | public OfficeListTagTest ( String name ) { super ( name ) ; initialize ( ) ; }
mifos/1.4.x | private void initialize ( ) { MifosLogManager . configureLogging ( ) ; SpringUtil . initializeSpring ( ) ; }
mifos/1.4.x | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; result = new XmlBuilder ( ) ; userContext = TestUtils . makeUser ( ) ; }
mifos/1.4.x | public void testNoBranches ( ) throws Exception { new OfficeListTag ( ) . getBranchOffices ( result , null , userContext , null , " Branch " ) ; assertWellFormedFragment ( result . toString ( ) ) ; }
mifos/1.4.x | public void testBranches ( ) throws Exception { createSomeOffices ( ) ; Assert . assertEquals ( 1 , regional . getBranchOnlyChildren ( ) . size ( ) ) ; List < OfficeBO > officeList = new ArrayList < OfficeBO > ( ) ; officeList . add ( regional ) ; new OfficeListTag ( ) . getBranchOffices ( result , officeList , userContext , branch , " Branch " ) ; String html = result . toString ( ) ; assertWellFormedFragment ( html ) ; StringAssert . assertContains ( " Trinidad & amp ; Tobago " , html ) ; }
mifos/1.4.x | public void testNothingAboveBranches ( ) throws Exception { new OfficeListTag ( ) . getAboveBranches ( result , null , null , null , null ) ; Assert . assertEquals ( " " , result . toString ( ) ) ; }
mifos/1.4.x | public void testAboveBranches ( ) throws Exception { List < OfficeBO > offices = new ArrayList < OfficeBO > ( ) ; offices . add ( makeOffice ( " Trinidad & Tobago " , OfficeLevel . HEADOFFICE ) ) ; offices . add ( makeOffice ( " Ontario & Quebec " , OfficeLevel . REGIONALOFFICE ) ) ; offices . add ( makeOffice ( " Alberta " , OfficeLevel . REGIONALOFFICE ) ) ; offices . add ( makeOffice ( " Vancouver " , OfficeLevel . SUBREGIONALOFFICE ) ) ; offices . add ( makeOffice ( " Toronto & Ottawa " , OfficeLevel . SUBREGIONALOFFICE ) ) ; offices . add ( makeOffice ( " SoHo " , OfficeLevel . AREAOFFICE ) ) ; offices . add ( makeOffice ( " Tribeca & Chelsea " , OfficeLevel . AREAOFFICE ) ) ; new OfficeListTag ( ) . getAboveBranches ( result , offices , " Province ▁ < State > " , " County ▁ < Duchy > " , " Parish ▁ < City > " ) ; String html = result . toString ( ) ; assertWellFormedFragment ( html ) ; StringAssert . assertContains ( " Toronto & amp ; Ottawa " , html ) ; }
mifos/1.4.x | public void testAssertWellFormed ( ) throws Exception { assertWellFormedFragment ( " < foo ▁ / > " ) ; assertWellFormedFragment ( " x ▁ y ▁ z " ) ; assertWellFormedFragment ( " x ▁ < p > this ▁ < b > shows ▁ it ▁ off < / b > < / p > ▁ z " ) ; try { assertWellFormedFragment ( " < unclosed > " ) ; Assert . fail ( " Didn ' t ▁ get ▁ assertion ▁ failure " ) ; } catch ( DocumentException e ) { } }
mifos/1.4.x | public void testGetLink ( ) throws Exception { OfficeListTag tag = new OfficeListTag ( " action " , " method " , " flow " ) ; XmlBuilder link = tag . getLink ( ( short ) 234 , " My ▁ Office " ) ; Assert . assertEquals ( " < a ▁ href = \" action ? method = method & amp ; " + " office . officeId = 234 & amp ; office . officeName = My % 20Office & amp ; " + " officeId = 234 & amp ; officeName = My % 20Office & amp ; " + " currentFlowKey = flow \" > My ▁ Office < / a > " , link . getOutput ( ) ) ; }
mifos/1.4.x | public void testGetOfficeListOnlyBranchs ( ) throws Exception { createSomeOffices ( ) ; OfficeListTag tag = new OfficeListTag ( " action " , " method " , " flow " ) ; tag . setOnlyBranchOffices ( " onlybranchOffices " ) ; String html = tag . getOfficeList ( userContext , headRegionalBranch ( ) , branch , Collections . singletonList ( regional ) , headRegional ( ) ) ; StringAssert . assertNotContains ( " East & amp ; West ▁ Indies " , html ) ; StringAssert . assertContains ( " West ▁ Indies ▁ Only " , html ) ; StringAssert . assertContains ( " Trinidad & amp ; Tobago " , html ) ; }
mifos/1.4.x | public void testGetOfficeListAllOffices ( ) throws Exception { createSomeOffices ( ) ; OfficeListTag tag = new OfficeListTag ( " action " , " method " , " flow " ) ; tag . setOnlyBranchOffices ( null ) ; String html = tag . getOfficeList ( userContext , headRegionalBranch ( ) , branch , Collections . singletonList ( regional ) , headRegional ( ) ) ; StringAssert . assertContains ( " East & amp ; West ▁ Indies " , html ) ; StringAssert . assertContains ( " West ▁ Indies ▁ Only " , html ) ; StringAssert . assertContains ( " Trinidad & amp ; Tobago " , html ) ; }
mifos/1.4.x | private List < OfficeView > headRegionalBranch ( ) { List < OfficeView > levels = new ArrayList < OfficeView > ( ) ; levels . add ( new OfficeView ( null , null , OfficeLevel . HEADOFFICE , " Head " , 0 ) ) ; levels . add ( new OfficeView ( null , null , OfficeLevel . REGIONALOFFICE , " Regional " , 0 ) ) ; levels . add ( new OfficeView ( null , null , OfficeLevel . BRANCHOFFICE , " Branch " , 0 ) ) ; return Collections . unmodifiableList ( levels ) ; }
mifos/1.4.x | private List < OfficeBO > headRegional ( ) { List < OfficeBO > offices = new ArrayList < OfficeBO > ( ) ; offices . add ( head ) ; offices . add ( regional ) ; return Collections . unmodifiableList ( offices ) ; }
mifos/1.4.x | private void createSomeOffices ( ) throws OfficeException { head = makeOffice ( " East & West ▁ Indies " , OfficeLevel . HEADOFFICE ) ; regional = makeOffice ( " West ▁ Indies ▁ Only " , OfficeLevel . REGIONALOFFICE , head ) ; head . setChildren ( Collections . singleton ( regional ) ) ; branch = OfficeBO . makeForTest ( userContext , OfficeLevel . BRANCHOFFICE , regional , "1.1.1.1" , null , " Trinidad & Tobago " , " Trin " , null , OperationMode . LOCAL_SERVER , OfficeStatus . ACTIVE ) ; regional . setChildren ( Collections . singleton ( branch ) ) ; }
mifos/1.4.x | private OfficeBO makeOffice ( String name , OfficeLevel level ) throws OfficeException { return makeOffice ( name , level , null ) ; }
mifos/1.4.x | private OfficeBO makeOffice ( String name , OfficeLevel level , OfficeBO parent ) throws OfficeException { String shortName = name . substring ( 0 , 3 ) ; return OfficeBO . makeForTest ( userContext , level , parent , "1.1" , null , name , shortName , null , OperationMode . LOCAL_SERVER , OfficeStatus . ACTIVE ) ; }
markovandooren/chameleon | public OpenTypeHierarchyAction ( int actionType , HierarchyView view ) { super ( " Open ▁ Type ▁ hierarchy " , AS_RADIO_BUTTON ) ; this . view = view ; String iconName ; String description ; if ( actionType == SUBTYPE ) { this . actionName = " Sub ▁ Type ▁ hierarchy " ; description = " Open ▁ the ▁ sub - type ▁ hierarchy ▁ of ▁ the ▁ type ▁ selected ▁ in ▁ the ▁ editor " ; iconName = " subtype _ hierarchy . gif " ; } else if ( actionType == SUPERTYPE ) { this . actionName = " Super ▁ Type ▁ hierarchy " ; description = " Open ▁ the ▁ super - type ▁ hierarchy ▁ of ▁ the ▁ type ▁ selected ▁ in ▁ the ▁ editor " ; iconName = " supertype _ hierarchy . gif " ; } else { throw new ChameleonProgrammerException ( " Action ▁ type ▁ not ▁ supported . ▁ Must ▁ be ▁ SUBTYPEHIERARCHY ▁ or ▁ SUPERTYPEHIERARCHY " ) ; } this . hierarchy_type = actionType ; setText ( description ) ; setToolTipText ( description ) ; setDescription ( description ) ; setImageDescriptor ( ChameleonEditorPlugin . getImageDescriptor ( iconName ) ) ; }
markovandooren/chameleon | @ Override public void run ( ) { run = ! run ; if ( run ) { Type rootType = getRootType ( ) ; ChameleonEditor editor = ChameleonEditor . getActiveEditor ( ) ; setEditor ( editor ) ; if ( rootType != null && editor != null ) { Language lang = editor . getDocument ( ) . language ( ) ; IContentProvider contentProvider ; if ( hierarchy_type == SUBTYPE ) { contentProvider = new SubTypeHierarchyContentProvider ( editor . getDocument ( ) . getProjectNature ( ) . getModel ( ) ) ; } else if ( hierarchy_type == SUPERTYPE ) { contentProvider = new SuperTypeHierarchyContentProvider ( ) ; } else { throw new ChameleonProgrammerException ( " Action ▁ type ▁ not ▁ supported . ▁ Must ▁ be ▁ SUBTYPEHIERARCHY ▁ or ▁ SUPERTYPEHIERARCHY " ) ; } view . getHierarchyViewer ( ) . setContentProvider ( contentProvider ) ; view . getHierarchyViewer ( ) . setLabelProvider ( new ChameleonLabelProvider ( lang , false , false , false ) ) ; view . getMemberViewer ( ) . setLabelProvider ( new ChameleonLabelProvider ( lang , true , false , false ) ) ; view . getHierarchyViewer ( ) . setInput ( new RootType ( rootType , getEditor ( ) ) ) ; view . getHierarchyViewer ( ) . setSelection ( new StructuredSelection ( rootType ) ) ; view . getLabel ( ) . setText ( actionName + " ▁ of ▁ type ▁ " + rootType . getFullyQualifiedName ( ) ) ; } else { if ( editor == null ) { ChameleonEditorPlugin . showMessageBox ( " No ▁ Chameleon ▁ editor ▁ found " , " The ▁ currently ▁ active ▁ editor ▁ must ▁ be ▁ a ▁ Chameleon ▁ editor . \n The ▁ Chameleon ▁ Type ▁ Hierarchy ▁ cannot ▁ be ▁ shown . " , SWT . ICON_ERROR ) ; } else if ( rootType == null ) { ChameleonEditorPlugin . showMessageBox ( " No ▁ type ▁ found " , " There ▁ is ▁ no ▁ type ▁ found ▁ whose ▁ type ▁ hierarchy ▁ must ▁ be ▁ shown . \n First ▁ select ▁ an ▁ appropriate ▁ type ▁ in ▁ the ▁ Chameleon ▁ editor . " , SWT . ICON_ERROR ) ; } } } }
markovandooren/chameleon | private Type getRootType ( ) { try { ChameleonEditor editor = getCurrentEditor ( ) ; setEditor ( editor ) ; if ( editor != null ) { ChameleonEditor chamEditor = editor ; EclipseDocument doc = chamEditor . getDocument ( ) ; ISelectionProvider selectionProvider = chamEditor . getSelectionProvider ( ) ; if ( selectionProvider != null ) { ISelection sel = selectionProvider . getSelection ( ) ; if ( sel instanceof TextSelection ) { TextSelection textSel = ( TextSelection ) sel ; final int offset = textSel . getOffset ( ) ; SafePredicate < EclipseEditorTag > predicate = new SafePredicate < EclipseEditorTag > ( ) { @ Override public boolean eval ( EclipseEditorTag editorTag ) { return editorTag . includes ( offset ) && ( ( editorTag . element ( ) instanceof Type ) || ( editorTag . element ( ) instanceof TypeReference ) ) ; } } ; Collection < EclipseEditorTag > tags = new TreeSet < EclipseEditorTag > ( EclipseEditorTag . lengthComparator ) ; doc . getEditorTagsWithPredicate ( predicate , tags ) ; if ( tags != null && tags . size ( ) > 0 ) { for ( EclipseEditorTag tag : tags ) { if ( tag != null && tag . element ( ) instanceof Type ) { return ( Type ) tag . element ( ) ; } else if ( tag != null && tag . element ( ) instanceof TypeReference ) { return ( ( TypeReference ) tag . element ( ) ) . getElement ( ) ; } } } } } return chamEditor . getDocument ( ) . document ( ) . lexical ( ) . descendants ( Type . class ) . iterator ( ) . next ( ) ; } } catch ( ModelException e ) { } return null ; }
markovandooren/chameleon | @ Override public void doubleClick ( DoubleClickEvent event ) { if ( event . getSelection ( ) instanceof IStructuredSelection ) { IStructuredSelection selection = ( IStructuredSelection ) event . getSelection ( ) ; Object firstObject = selection . getFirstElement ( ) ; if ( firstObject instanceof HierarchyTypeNode ) { try { Type type = ( ( HierarchyTypeNode ) firstObject ) . getType ( ) ; ChameleonEditor . showInEditor ( type , true , true , getEditor ( ) ) ; } catch ( ModelException e ) { e . printStackTrace ( ) ; } } else if ( firstObject instanceof Element ) { ChameleonEditor . showInEditor ( ( Element ) firstObject , true , true , getEditor ( ) ) ; } new TypeChangedListener ( view ) . selectionChanged ( view . getHierarchyViewer ( ) . getSelection ( ) ) ; } else if ( event . getSelection ( ) . isEmpty ( ) ) { getEditor ( ) . resetHighlightRange ( ) ; } }
markovandooren/chameleon | @ Override public void selectionChanged ( SelectionChangedEvent event ) { if ( event . getSelection ( ) instanceof IStructuredSelection ) { IStructuredSelection selection = ( IStructuredSelection ) event . getSelection ( ) ; Object firstObject = selection . getFirstElement ( ) ; if ( firstObject instanceof HierarchyTypeNode ) { try { Type type = ( ( HierarchyTypeNode ) firstObject ) . getType ( ) ; ChameleonEditor . showInEditor ( type , false , false , getEditor ( ) ) ; } catch ( ModelException e ) { e . printStackTrace ( ) ; } } else if ( firstObject instanceof Element ) { ChameleonEditor . showInEditor ( ( Element ) firstObject , false , false , getEditor ( ) ) ; } } else if ( event . getSelection ( ) . isEmpty ( ) ) { getEditor ( ) . resetHighlightRange ( ) ; } }
markovandooren/chameleon | protected ChameleonEditor getEditor ( ) { if ( editor == null ) editor = ChameleonEditor . getActiveEditor ( ) ; return editor ; }
markovandooren/chameleon | protected ChameleonEditor getCurrentEditor ( ) { ChameleonEditor currEditor = ChameleonEditor . getActiveEditor ( ) ; if ( currEditor != null ) { editor = currEditor ; } return editor ; }
markovandooren/chameleon | protected void setEditor ( ChameleonEditor editor ) { this . editor = editor ; }
guedeWebGate/org.openntf.base | FieldChoicesdialogs ( String v ) { value = v ; }
guedeWebGate/org.openntf.base | public String value ( ) { return value ; }
maxalthoff/intro-to-java-exercises | public Histogram ( ) { this . counts = new int [ 26 ] ; maxValue = 0 ; paneHeight = 400 ; drawHistogram ( ) ; }
maxalthoff/intro-to-java-exercises | public void drawHistogram ( ) { getChildren ( ) . clear ( ) ; for ( int i = 0 , x = 0 ; i < counts . length ; i ++ , x += 25 ) { double rHeight = ( double ) counts [ i ] / maxValue * paneHeight ; Rectangle r = new Rectangle ( 20 , rHeight ) ; r . setX ( x ) ; r . setY ( paneHeight - rHeight ) ; r . setFill ( Color . WHITE ) ; r . setStroke ( Color . BLACK ) ; Text t = new Text ( ( char ) ( i + 65 ) + " " ) ; t . setX ( x + 5 ) ; t . setY ( paneHeight + 15 ) ; getChildren ( ) . addAll ( r , t ) ; } }
maxalthoff/intro-to-java-exercises | public void setCounts ( int [ ] counts ) { this . counts = counts ; maxValue = getMaxValue ( ) ; drawHistogram ( ) ; }
maxalthoff/intro-to-java-exercises | public int getMaxValue ( ) { int m = counts [ 0 ] ; for ( int i = 1 ; i < counts . length ; i ++ ) { if ( counts [ i ] > m ) { m = counts [ i ] ; } } return m ; }
sapirgolan/MFIBlocking | private CandidateMatchComparator ( ) { }
sapirgolan/MFIBlocking | @ Override public int compare ( CandidateMatch o1 , CandidateMatch o2 ) { return ( int ) ( Math . signum ( o1 . getScore ( ) - o2 . getScore ( ) ) ) ; }
55minutes/fiftyfive-wicket-2.x | ( WebApplication application , WebRequest request , Response response ) { super ( application , request , response ) ; }
55minutes/fiftyfive-wicket-2.x | @ Override protected void logRuntimeException ( RuntimeException e ) { LoggingUtils . logRuntimeException ( LOGGER , e ) ; }
zuoweitan/Hitalk | @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( 4 , 2 + 2 ) ; }
zuoweitan/Hitalk | @ Test public void hello_world ( ) { System . out . print ( " Hello ▁ World " ) ; }
zuoweitan/Hitalk | @ Test public void textLong ( ) { System . out . println ( getAndAddRequest ( new AtomicLong ( ) , Long . MAX_VALUE ) ) ; }
zuoweitan/Hitalk | @ Test public void testRetrofit ( ) { }
zuoweitan/Hitalk | @ Test public void testPath ( ) { String path = " dadad / dadad / adasdasdasd . jpg " ; Pattern pattern = Pattern . compile ( " . * \\ . jpg | \\ . png | \\ . gif | \\ . bmp " ) ; Matcher matcher = pattern . matcher ( path . toLowerCase ( ) ) ; while ( matcher . find ( ) ) { System . out . println ( matcher . groupCount ( ) ) ; } }
zuoweitan/Hitalk | @ Test public void testGson ( ) throws ClassNotFoundException { HashMap < String , Integer > entries = new HashMap < > ( ) ; entries . put ( " abc " , 1 ) ; System . out . println ( new Gson ( ) . toJson ( entries ) ) ; HashMap hashMap = new Gson ( ) . fromJson ( new Gson ( ) . toJson ( entries ) , entries . getClass ( ) ) ; Type type = new TypeToken < HashMap < String , Integer > > ( ) { } . getType ( ) ; }
zuoweitan/Hitalk | protected AVObject encoder ( ) { return null ; }
zuoweitan/Hitalk | protected A decoder ( AVObject avObject ) { return null ; }
zuoweitan/Hitalk | @ Override public String toString ( ) { return a + " : " + b ; }
zuoweitan/Hitalk | @ Override protected AVObject encoder ( ) { AVObject avObject = new AVObject ( ) ; avObject . put ( " b " , b ) ; return avObject ; }
zuoweitan/Hitalk | @ Override protected A decoder ( AVObject avObject ) { return null ; }
zuoweitan/Hitalk | @ Test public void testSync ( ) throws InterruptedException { System . out . println ( " stat ▁ at ▁ time ▁ = ▁ " + new Date ( ) ) ; final CountDownLatch lock = new CountDownLatch ( 1 ) ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { Thread . sleep ( 5000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } lock . countDown ( ) ; } } ) . start ( ) ; lock . await ( ) ; System . out . println ( " do ▁ next ▁ at ▁ time ▁ = ▁ " + new Date ( ) ) ; }
zuoweitan/Hitalk | public Parent ( ) { this ( 0 ) ; }
zuoweitan/Hitalk | public Parent ( int i ) { this . i = i ; printi ( ) ; }
zuoweitan/Hitalk | protected void printi ( ) { i += 1 ; System . out . println ( i ) ; System . out . println ( this ) ; }
zuoweitan/Hitalk | public Child ( ) { }
zuoweitan/Hitalk | public Child ( int i ) { super ( i ) ; System . out . println ( " HHHHHHHH " ) ; }
zuoweitan/Hitalk | @ Override protected void printi ( ) { super . printi ( ) ; }
zuoweitan/Hitalk | @ Test public void testClass ( ) { new Child ( ) ; }
zuoweitan/Hitalk | @ Test public void testClassReflect ( ) { Class < ? > [ ] declaredClasses = getClass ( ) . getDeclaredClasses ( ) ; for ( Class < ? > declaredClass : declaredClasses ) { LayoutInject layoutInject = declaredClass . getAnnotation ( LayoutInject . class ) ; if ( layoutInject != null ) { System . out . println ( layoutInject . name ( ) ) ; } } }
zuoweitan/Hitalk | @ Test public void testMd5 ( ) { System . out . println ( Md5Utils . stringToMD5 ( " 重庆邮电大学 " ) ) ; }
zuoweitan/Hitalk | @ Test public void testSparseArray ( ) { SparseArray array = new SparseArray ( ) ; array . put ( 1 , "12" ) ; array . put ( 2 , 3 ) ; System . out . println ( array . get ( 1 ) . getClass ( ) ) ; System . out . println ( array . get ( 2 ) . getClass ( ) ) ; }
zuoweitan/Hitalk | @ Test public void testArrayList ( ) { ArrayList a = new ArrayList ( ) ; a . add ( 1 ) ; System . out . println ( a ) ; a . remove ( 1 ) ; a . add ( 0 , 1 ) ; System . out . println ( a ) ; }
zuoweitan/Hitalk | @ Test public void testPinyin ( ) { for ( int i = 0 ; i < 100000 ; i ++ ) { String aa = CharacterParser . getInstance ( ) . getSelling ( " 无非凡 " ) ; if ( ! aa . startsWith ( " wu " ) ) { System . err . println ( " error " ) ; break ; } } new Thread ( ( ) -> { for ( int i = 0 ; i < 100000 ; i ++ ) { String aa = CharacterParser . getInstance ( ) . getSelling ( " 无非凡 " ) ; if ( ! aa . startsWith ( " wu " ) ) { System . err . println ( " error ▁ 2" ) ; break ; } } } ) . start ( ) ; new Thread ( ( ) -> { for ( int i = 0 ; i < 100000 ; i ++ ) { String aa = CharacterParser . getInstance ( ) . getSelling ( " 无非凡 " ) ; if ( ! aa . startsWith ( " wu " ) ) { System . err . println ( " error ▁ 3" ) ; break ; } } } ) . start ( ) ; }
zuoweitan/Hitalk | @ Test public void testStateMachine ( ) { TestStateMachine testStateMachine = new TestStateMachine ( " TestStateMachine " ) ; testStateMachine . sendMessage ( 1 ) ; }
zuoweitan/Hitalk | protected TestStateMachine ( String name ) { super ( name ) ; addState ( aState ) ; addState ( bState , aState ) ; addState ( cState , bState ) ; addState ( dState , bState ) ; addState ( eState , aState ) ; setInitialState ( cState ) ; start ( ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " AState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " AState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " BState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " BState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " CState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public boolean processMessage ( Message msg ) { transitionTo ( dState ) ; return super . processMessage ( msg ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " CState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " DState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " DState ▁ exit " ) ; }
zuoweitan/Hitalk | @ Override public void enter ( ) { super . enter ( ) ; Log . i ( " zuowei " , " EState ▁ enter " ) ; }
zuoweitan/Hitalk | @ Override public void exit ( ) { super . exit ( ) ; Log . i ( " zuowei " , " EState ▁ exit " ) ; }
JetBrains/TeamCity.VsOnline.WorkItems | @ NotNull public IssueData parse ( @ NotNull final String issueString ) throws Exception { try { final Map map = new ObjectMapper ( ) . readValue ( issueString , Map . class ) ; return parseIssueData ( map ) ; } catch ( Exception e ) { LOG . error ( " Could ▁ not ▁ parse ▁ issue ▁ json . ▁ Error ▁ message ▁ is : ▁ " + e . getMessage ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Could ▁ not ▁ parse ▁ issue ▁ json . ▁ Response ▁ ( cut ▁ to ▁ first ▁ 100 ▁ symbols ) : ▁ [ " + issueString . substring ( Math . min ( 100 , issueString . length ( ) - 1 ) ) ) ; } throw e ; } }
JetBrains/TeamCity.VsOnline.WorkItems | private IssueData parseIssueData ( @ NotNull final Map map ) throws Exception { final Map fields = getContainer ( map , Containers . CONTAINER_FIELDS ) ; final Map links = getContainer ( map , Containers . CONTAINER_LINKS ) ; final Map html = getContainer ( links , Containers . CONTAINER_HTML ) ; final String href = getField ( html , Fields . FIELD_HREF ) ; final String actualProject = getField ( fields , Fields . FIELD_PROJECT ) ; return new IssueData ( String . valueOf ( map . get ( " id " ) ) , CollectionsUtil . asMap ( IssueData . SUMMARY_FIELD , getField ( fields , Fields . FIELD_SUMMARY ) , IssueData . STATE_FIELD , getField ( fields , Fields . FIELD_STATE ) , IssueData . TYPE_FIELD , getField ( fields , Fields . FIELD_TYPE ) , IssueDataFields . ID_FIELD_PROJECT , actualProject , IssueDataFields . ID_FIELD_HREF , href ) , false , " Feature " . equals ( getField ( fields , Fields . FIELD_TYPE ) ) , href ) ; }
JetBrains/TeamCity.VsOnline.WorkItems | private Map getContainer ( final Map map , @ NotNull final String name ) { return ( Map ) map . get ( name ) ; }
JetBrains/TeamCity.VsOnline.WorkItems | private String getField ( final Map map , @ NotNull final String name ) { return ( String ) map . get ( name ) ; }
aws/aws-sdk-java | public void setReplacementStrategy ( String replacementStrategy ) { this . replacementStrategy = replacementStrategy ; }
aws/aws-sdk-java | public String getReplacementStrategy ( ) { return this . replacementStrategy ; }
aws/aws-sdk-java | public SpotCapacityRebalance withReplacementStrategy ( String replacementStrategy ) { setReplacementStrategy ( replacementStrategy ) ; return this ; }
aws/aws-sdk-java | public SpotCapacityRebalance withReplacementStrategy ( ReplacementStrategy replacementStrategy ) { this . replacementStrategy = replacementStrategy . toString ( ) ; return this ; }
aws/aws-sdk-java | public void setTerminationDelay ( Integer terminationDelay ) { this . terminationDelay = terminationDelay ; }
aws/aws-sdk-java | public Integer getTerminationDelay ( ) { return this . terminationDelay ; }
aws/aws-sdk-java | public SpotCapacityRebalance withTerminationDelay ( Integer terminationDelay ) { setTerminationDelay ( terminationDelay ) ; return this ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getReplacementStrategy ( ) != null ) sb . append ( " ReplacementStrategy : ▁ " ) . append ( getReplacementStrategy ( ) ) . append ( " , " ) ; if ( getTerminationDelay ( ) != null ) sb . append ( " TerminationDelay : ▁ " ) . append ( getTerminationDelay ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof SpotCapacityRebalance == false ) return false ; SpotCapacityRebalance other = ( SpotCapacityRebalance ) obj ; if ( other . getReplacementStrategy ( ) == null ^ this . getReplacementStrategy ( ) == null ) return false ; if ( other . getReplacementStrategy ( ) != null && other . getReplacementStrategy ( ) . equals ( this . getReplacementStrategy ( ) ) == false ) return false ; if ( other . getTerminationDelay ( ) == null ^ this . getTerminationDelay ( ) == null ) return false ; if ( other . getTerminationDelay ( ) != null && other . getTerminationDelay ( ) . equals ( this . getTerminationDelay ( ) ) == false ) return false ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getReplacementStrategy ( ) == null ) ? 0 : getReplacementStrategy ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getTerminationDelay ( ) == null ) ? 0 : getTerminationDelay ( ) . hashCode ( ) ) ; return hashCode ; }
aws/aws-sdk-java | @ Override public SpotCapacityRebalance clone ( ) { try { return ( SpotCapacityRebalance ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
NationalSecurityAgency/ghidra | public ProgramDecisionTree ( ) { super ( ) ; List < Class < ? extends ProgramConstraint > > classes = ClassSearcher . getClasses ( ProgramConstraint . class ) ; for ( Class < ? extends ProgramConstraint > constraintClass : classes ) { try { ProgramConstraint contraint = constraintClass . newInstance ( ) ; registerConstraintType ( contraint . getName ( ) , constraintClass ) ; } catch ( Exception e ) { Msg . error ( this , " Can ' t ▁ create ▁ constraint ▁ instance ▁ for ▁ " + constraintClass . getName ( ) , e ) ; } } }
Swaathik/cellbase | public BuildCommandExecutor ( CliOptionsParser . BuildCommandOptions buildCommandOptions ) { super ( buildCommandOptions . commonOptions . logLevel , buildCommandOptions . commonOptions . verbose , buildCommandOptions . commonOptions . conf ) ; this . buildCommandOptions = buildCommandOptions ; if ( buildCommandOptions . input != null ) { input = Paths . get ( buildCommandOptions . input ) ; } if ( buildCommandOptions . output != null ) { output = Paths . get ( buildCommandOptions . output ) ; } if ( buildCommandOptions . common != null ) { common = Paths . get ( buildCommandOptions . common ) ; } else { common = input . getParent ( ) . getParent ( ) . resolve ( " common " ) ; } this . ensemblScriptsFolder = new File ( System . getProperty ( " basedir " ) + " / bin / ensembl - scripts / " ) ; this . proteinScriptsFolder = new File ( System . getProperty ( " basedir " ) + " / bin / protein / " ) ; }
Swaathik/cellbase | public void execute ( ) { try { checkParameters ( ) ; if ( ! Files . exists ( output ) ) { Files . createDirectories ( output ) ; } for ( CellBaseConfiguration . SpeciesProperties . Species sp : configuration . getAllSpecies ( ) ) { if ( buildCommandOptions . species . equalsIgnoreCase ( sp . getScientificName ( ) ) || buildCommandOptions . species . equalsIgnoreCase ( sp . getCommonName ( ) ) || buildCommandOptions . species . equalsIgnoreCase ( sp . getId ( ) ) ) { species = sp ; break ; } } if ( species == null ) { logger . error ( " Species ▁ ' { } ' ▁ not ▁ valid " , buildCommandOptions . species ) ; } if ( buildCommandOptions . data != null ) { String [ ] buildOptions ; if ( buildCommandOptions . data . equals ( " all " ) ) { buildOptions = new String [ ] { EtlCommons . GENOME_INFO_DATA , EtlCommons . GENOME_DATA , EtlCommons . GENE_DATA , EtlCommons . DISGENET_DATA , EtlCommons . HPO_DATA , EtlCommons . CONSERVATION_DATA , EtlCommons . REGULATION_DATA , EtlCommons . PROTEIN_DATA , EtlCommons . PPI_DATA , EtlCommons . PROTEIN_FUNCTIONAL_PREDICTION_DATA , EtlCommons . VARIATION_DATA , EtlCommons . VARIATION_FUNCTIONAL_SCORE_DATA , EtlCommons . CLINvar_DATA , EtlCommons . COSMIC_DATA , EtlCommons . GWAS_DATA , } ; } else { buildOptions = buildCommandOptions . data . split ( " , " ) ; } for ( int i = 0 ; i < buildOptions . length ; i ++ ) { String buildOption = buildOptions [ i ] ; logger . info ( " Building ▁ ' { } ' ▁ data " , buildOption ) ; CellBaseParser parser = null ; switch ( buildOption ) { case EtlCommons . GENOME_INFO_DATA : buildGenomeInfo ( ) ; break ; case EtlCommons . GENOME_DATA : parser = buildGenomeSequence ( ) ; break ; case EtlCommons . GENE_DATA : parser = buildGene ( ) ; break ; case EtlCommons . DISGENET_DATA : parser = buildDisgenet ( ) ; break ; case EtlCommons . HPO_DATA : parser = buildHpo ( ) ; break ; case EtlCommons . VARIATION_DATA : parser = buildVariation ( ) ; break ; case EtlCommons . VARIATION_FUNCTIONAL_SCORE_DATA : parser = buildCadd ( ) ; break ; case EtlCommons . REGULATION_DATA : parser = buildRegulation ( ) ; break ; case EtlCommons . PROTEIN_DATA : parser = buildProtein ( ) ; break ; case EtlCommons . PPI_DATA : parser = getInteractionParser ( ) ; break ; case EtlCommons . CONSERVATION_DATA : parser = buildConservation ( ) ; break ; case EtlCommons . DRUG_DATA : parser = buildDrugParser ( ) ; break ; case EtlCommons . CLINvar_DATA : parser = buildClinvar ( ) ; break ; case EtlCommons . COSMIC_DATA : parser = buildCosmic ( ) ; break ; case EtlCommons . GWAS_DATA : parser = buildGwas ( ) ; break ; default : logger . error ( " Build ▁ option ▁ ' " + buildCommandOptions . data + " ' ▁ is ▁ not ▁ valid " ) ; break ; } if ( parser != null ) { try { parser . parse ( ) ; } catch ( Exception e ) { logger . error ( " Error ▁ executing ▁ ' build ' ▁ command ▁ " + buildCommandOptions . data + " : ▁ " + e . getMessage ( ) , e ) ; } parser . disconnect ( ) ; } } } } catch ( ParameterException e ) { logger . error ( " Error ▁ parsing ▁ build ▁ command ▁ line ▁ parameters : ▁ " + e . getMessage ( ) , e ) ; } catch ( IOException e ) { logger . error ( e . getMessage ( ) ) ; } }
Swaathik/cellbase | private void copyVersionFiles ( List < Path > pathList ) { for ( Path path : pathList ) { try { Files . copy ( path , output . resolve ( path . getFileName ( ) ) , StandardCopyOption . REPLACE_EXISTING ) ; } catch ( IOException e ) { logger . warn ( " Version ▁ file ▁ { } ▁ not ▁ found ▁ - ▁ skipping " , path . toString ( ) ) ; } } }
Swaathik/cellbase | private void checkParameters ( ) throws IOException { if ( ! Files . exists ( input ) || ! Files . isDirectory ( input ) ) { throw new IOException ( " Input ▁ parameter ▁ ' " + input . toString ( ) + " ' ▁ does ▁ not ▁ exist ▁ or ▁ is ▁ not ▁ a ▁ directory " ) ; } if ( ! Files . exists ( common ) || ! Files . isDirectory ( common ) ) { throw new IOException ( " Common ▁ parameter ▁ ' " + common . toString ( ) + " ' ▁ does ▁ not ▁ exist ▁ or ▁ is ▁ not ▁ a ▁ directory " ) ; } }
Swaathik/cellbase | private void buildGenomeInfo ( ) { try { String outputFileName = output . resolve ( " genome _ info . json " ) . toAbsolutePath ( ) . toString ( ) ; List < String > args = new ArrayList < > ( ) ; args . addAll ( Arrays . asList ( " - - species " , species . getScientificName ( ) , " - o " , outputFileName , " - - ensembl - libs " , configuration . getDownload ( ) . getEnsembl ( ) . getLibs ( ) ) ) ; if ( ! configuration . getSpecies ( ) . getVertebrates ( ) . contains ( species ) && ! species . getScientificName ( ) . equals ( " Drosophila ▁ melanogaster " ) ) { args . add ( " - - phylo " ) ; args . add ( " no - vertebrate " ) ; } String geneInfoLogFileName = output . resolve ( " genome _ info . log " ) . toAbsolutePath ( ) . toString ( ) ; boolean downloadedGenomeInfo ; downloadedGenomeInfo = runCommandLineProcess ( ensemblScriptsFolder , " . / genome _ info . pl " , args , geneInfoLogFileName ) ; if ( downloadedGenomeInfo ) { logger . info ( outputFileName + " ▁ created ▁ OK " ) ; } else { logger . error ( " Genome ▁ info ▁ for ▁ " + species . getScientificName ( ) + " ▁ cannot ▁ be ▁ downloaded " ) ; } } catch ( IOException | InterruptedException e ) { e . printStackTrace ( ) ; } }
Swaathik/cellbase | private CellBaseParser buildGenomeSequence ( ) { copyVersionFiles ( Collections . singletonList ( input . resolve ( " genome / genomeVersion . json " ) ) ) ; Path fastaFile = getFastaReferenceGenome ( ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " genome _ sequence " ) ; return new GenomeSequenceFastaParser ( fastaFile , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildGene ( ) { Path geneFolderPath = input . resolve ( " gene " ) ; copyVersionFiles ( Arrays . asList ( geneFolderPath . resolve ( " geneDrug / dgidbVersion . json " ) , geneFolderPath . resolve ( " ensemblCoreVersion . json " ) , geneFolderPath . resolve ( " uniprotXrefVersion . json " ) , geneFolderPath . resolve ( common . resolve ( " expression / geneExpressionAtlasVersion . json " ) ) , geneFolderPath . resolve ( " hpoVersion . json " ) , geneFolderPath . resolve ( " disgenetVersion . json " ) ) ) ; Path genomeFastaFilePath = getFastaReferenceGenome ( ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " gene " ) ; return new GeneParser ( geneFolderPath , genomeFastaFilePath , species , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildVariation ( ) { Path variationFolderPath = input . resolve ( " variation " ) ; copyVersionFiles ( Arrays . asList ( variationFolderPath . resolve ( " ensemblVariationVersion . json " ) ) ) ; CellBaseFileSerializer serializer = new CellBaseJsonFileSerializer ( output , null , true , true , true ) ; return new VariationParser ( variationFolderPath , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildCadd ( ) { Path variationFunctionalScorePath = input . resolve ( " variation _ functional _ score " ) ; copyVersionFiles ( Arrays . asList ( variationFunctionalScorePath . resolve ( " caddVersion . json " ) ) ) ; Path caddFilePath = variationFunctionalScorePath . resolve ( CADD_INPUT_FILE_NAME ) ; CellBaseFileSerializer serializer = new CellBaseJsonFileSerializer ( output , " cadd " ) ; return new CaddScoreParser ( caddFilePath , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildRegulation ( ) { Path regulatoryRegionFilesDir = input . resolve ( " regulation " ) ; copyVersionFiles ( Arrays . asList ( regulatoryRegionFilesDir . resolve ( " ensemblRegulationVersion . json " ) , common . resolve ( " mirbase / mirbaseVersion . json " ) , regulatoryRegionFilesDir . resolve ( " targetScanVersion . json " ) , regulatoryRegionFilesDir . resolve ( " miRTarBaseVersion . json " ) ) ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " regulatory _ region " ) ; return new RegulatoryRegionParser ( regulatoryRegionFilesDir , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildProtein ( ) { Path proteinFolder = common . resolve ( " protein " ) ; copyVersionFiles ( Arrays . asList ( proteinFolder . resolve ( " uniprotVersion . json " ) , proteinFolder . resolve ( " interproVersion . json " ) ) ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " protein " ) ; return new ProteinParser ( proteinFolder . resolve ( " uniprot _ chunks " ) , common . resolve ( " protein " ) . resolve ( " protein2ipr . dat . gz " ) , species . getScientificName ( ) , serializer ) ; }
Swaathik/cellbase | if ( proteinFunctionPredictionMatricesObtaines ) { logger . info ( " Protein ▁ function ▁ prediction ▁ matrices ▁ created ▁ OK " ) ; }
Swaathik/cellbase | private CellBaseParser getInteractionParser ( ) { Path proteinFolder = common . resolve ( " protein " ) ; Path psimiTabFile = proteinFolder . resolve ( " intact . txt " ) ; copyVersionFiles ( Arrays . asList ( proteinFolder . resolve ( " intactVersion . json " ) ) ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " protein _ protein _ interaction " ) ; return new InteractionParser ( psimiTabFile , species . getScientificName ( ) , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildDrugParser ( ) { throw new ParameterException ( " ' drug ' ▁ builder ▁ is ▁ not ▁ implemented ▁ yet " ) ; }
Swaathik/cellbase | private CellBaseParser buildConservation ( ) { Path conservationFilesDir = input . resolve ( " conservation " ) ; copyVersionFiles ( Arrays . asList ( conservationFilesDir . resolve ( " gerpVersion . json " ) , conservationFilesDir . resolve ( " phastConsVersion . json " ) , conservationFilesDir . resolve ( " phyloPVersion . json " ) ) ) ; int conservationChunkSize = MongoDBCollectionConfiguration . CONSERVATION_CHUNK_SIZE ; CellBaseFileSerializer serializer = new CellBaseJsonFileSerializer ( output ) ; return new ConservationParser ( conservationFilesDir , conservationChunkSize , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildClinvar ( ) { Path clinvarFolder = input . resolve ( " clinical " ) ; copyVersionFiles ( Arrays . asList ( clinvarFolder . resolve ( " clinvarVersion . json " ) ) ) ; Path clinvarFile = clinvarFolder . resolve ( " ClinVar . xml . gz " ) ; Path clinvarSummaryFile = clinvarFolder . resolve ( " variant _ summary . txt . gz " ) ; Path efosFilePath = clinvarFolder . resolve ( " ClinVar _ Traits _ EFO _ Names . csv " ) ; if ( ! efosFilePath . toFile ( ) . exists ( ) ) { efosFilePath = null ; } String assembly = buildCommandOptions . assembly ; checkMandatoryOption ( " assembly " , assembly ) ; if ( ! assembly . equals ( ClinVarParser . GRCH37_ASSEMBLY ) && ! assembly . equals ( ClinVarParser . GRCH38_ASSEMBLY ) ) { throw new ParameterException ( " Assembly ▁ ' " + assembly + " ' ▁ is ▁ not ▁ valid . ▁ Possible ▁ values : ▁ " + ClinVarParser . GRCH37_ASSEMBLY + " , ▁ " + ClinVarParser . GRCH38_ASSEMBLY ) ; } CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " clinvar " ) ; return new ClinVarParser ( clinvarFile , clinvarSummaryFile , efosFilePath , assembly , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildCosmic ( ) { Path cosmicFilePath = input . resolve ( " CosmicMutantExport . tsv " ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " cosmic " ) ; return new CosmicParser ( cosmicFilePath , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildGwas ( ) throws IOException { Path inputDir = getInputDirFromCommandLine ( ) . resolve ( " clinical " ) ; copyVersionFiles ( Arrays . asList ( inputDir . resolve ( " gwasVersion . json " ) ) ) ; Path gwasFile = inputDir . resolve ( GWAS_INPUT_FILE_NAME ) ; FileUtils . checkPath ( gwasFile ) ; Path dbsnpFile = inputDir . resolve ( DBSNP_INPUT_FILE_NAME ) ; FileUtils . checkPath ( dbsnpFile ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " gwas " ) ; return new GwasParser ( gwasFile , dbsnpFile , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildDisgenet ( ) throws IOException { Path inputDir = getInputDirFromCommandLine ( ) . resolve ( " gene _ disease _ association " ) ; copyVersionFiles ( Collections . singletonList ( inputDir . resolve ( " disgenetVersion . json " ) ) ) ; Path disgenetFile = inputDir . resolve ( DISGENET_INPUT_FILE_NAME ) ; FileUtils . checkPath ( disgenetFile ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " disgenet " ) ; return new DisgenetParser ( disgenetFile , serializer ) ; }
Swaathik/cellbase | private CellBaseParser buildHpo ( ) throws IOException { Path inputDir = getInputDirFromCommandLine ( ) . resolve ( " gene _ disease _ association " ) ; copyVersionFiles ( Collections . singletonList ( inputDir . resolve ( " hpoVersion . json " ) ) ) ; Path hpoFilePath = inputDir . resolve ( HPO_INPUT_FILE_NAME ) ; FileUtils . checkPath ( hpoFilePath ) ; CellBaseSerializer serializer = new CellBaseJsonFileSerializer ( output , " hpo " ) ; return new DisgenetParser ( hpoFilePath , serializer ) ; }
Swaathik/cellbase | private Path getInputDirFromCommandLine ( ) { File inputDirectory = new File ( input . toString ( ) ) ; if ( inputDirectory . exists ( ) ) { if ( inputDirectory . isDirectory ( ) ) { return input ; } else { throw new ParameterException ( " ' " + input + " ' ▁ is ▁ not ▁ a ▁ directory " ) ; } } else { throw new ParameterException ( " Folder ▁ ' " + input + " ' ▁ doesn ' t ▁ exist " ) ; } }
Swaathik/cellbase | private Path getFastaReferenceGenome ( ) { Path fastaFile = null ; try { DirectoryStream < Path > stream = Files . newDirectoryStream ( input . resolve ( " genome " ) , entry -> { return entry . toString ( ) . endsWith ( " . fa . gz " ) ; } ) ; for ( Path entry : stream ) { fastaFile = entry ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return fastaFile ; }
Swaathik/cellbase | private void checkMandatoryOption ( String option , String value ) { if ( value == null ) { throw new ParameterException ( " ' " + option + " ' ▁ option ▁ is ▁ mandatory ▁ for ▁ ' " + buildCommandOptions . data + " ' ▁ builder " ) ; } }
Buzzardo/spring-boot | BindException ( ConfigurationPropertyName name , Bindable < ? > target , ConfigurationProperty property , Throwable cause ) { super ( buildMessage ( name , target ) , cause ) ; this . name = name ; this . target = target ; this . property = property ; }
Buzzardo/spring-boot | public ConfigurationPropertyName getName ( ) { return this . name ; }
Buzzardo/spring-boot | public Bindable < ? > getTarget ( ) { return this . target ; }
Buzzardo/spring-boot | public ConfigurationProperty getProperty ( ) { return this . property ; }
Buzzardo/spring-boot | @ Override public Origin getOrigin ( ) { return Origin . from ( this . name ) ; }
pgorla/usergrid | @ Autowired public void setEntityManagerFactory ( EntityManagerFactory emf ) { this . emf = emf ; }
pgorla/usergrid | @ Autowired public void setManagementService ( ManagementService managementService ) { this . managementService = managementService ; }
pgorla/usergrid | public SignInAsProvider facebook ( Application application ) { FacebookProvider facebookProvider = new FacebookProvider ( emf . getEntityManager ( application . getUuid ( ) ) , managementService ) ; facebookProvider . configure ( ) ; return facebookProvider ; }
pgorla/usergrid | public SignInAsProvider foursquare ( Application application ) { FoursquareProvider foursquareProvider = new FoursquareProvider ( emf . getEntityManager ( application . getUuid ( ) ) , managementService ) ; foursquareProvider . configure ( ) ; return foursquareProvider ; }
pgorla/usergrid | public SignInAsProvider pingident ( Application application ) { PingIdentityProvider pingIdentityProvider = new PingIdentityProvider ( emf . getEntityManager ( application . getUuid ( ) ) , managementService ) ; pingIdentityProvider . configure ( ) ; return pingIdentityProvider ; }
Andrevmatias/Compilador | public IdentificadorParametro ( String nome , int deslocamento , Tipo tipo , TipoPassagemParametro tipoPassagem ) { super ( nome ) ; this . deslocamento = deslocamento ; this . tipo = tipo ; this . tipoPassagem = tipoPassagem ; }
Andrevmatias/Compilador | public int getDeslocamento ( ) { return deslocamento ; }
Andrevmatias/Compilador | public Tipo getTipo ( ) { return tipo ; }
Andrevmatias/Compilador | public TipoPassagemParametro getTipoPassagem ( ) { return tipoPassagem ; }
Andrevmatias/Compilador | public void setDeslocamento ( int deslocamento ) { this . deslocamento = deslocamento ; }
Andrevmatias/Compilador | public void setTipo ( Tipo tipo ) { this . tipo = tipo ; }
Andrevmatias/Compilador | public void setTipoPassagem ( TipoPassagemParametro tipoPassagem ) { this . tipoPassagem = tipoPassagem ; }
arminghofrani/chalkboard | public TimetableClassList ( Context context , ArrayList < StandardClass > classesArrayList ) { layoutInflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; this . classesArrayList = classesArrayList ; }
arminghofrani/chalkboard | public void setClassesArrayList ( ArrayList < StandardClass > update ) { classesArrayList . clear ( ) ; classesArrayList . addAll ( update ) ; notifyDataSetChanged ( ) ; }
arminghofrani/chalkboard | @ Override public int getCount ( ) { return classesArrayList . size ( ) ; }
arminghofrani/chalkboard | @ Override public Object getItem ( int position ) { return classesArrayList . get ( position ) ; }
arminghofrani/chalkboard | @ Override public long getItemId ( int position ) { return position ; }
arminghofrani/chalkboard | @ Override public View getView ( int position , View convertView , ViewGroup parent ) { final StandardClass standardClass = classesArrayList . get ( position ) ; boolean subtitle = false ; if ( standardClass . hasLocation ( ) ) { convertView = layoutInflater . inflate ( R . layout . view_timed_class_child_with_subtitle , parent , false ) ; subtitle = true ; } else if ( standardClass . hasTeacher ( ) ) { convertView = layoutInflater . inflate ( R . layout . view_timed_class_child_with_subtitle , parent , false ) ; subtitle = true ; } else { convertView = layoutInflater . inflate ( R . layout . view_timed_class_child_without_subtitle , parent , false ) ; } ( ( TextView ) convertView . findViewById ( subtitle ? R . id . view_timed_class_child_with_subtitle_title_text_view : R . id . view_timed_class_child_without_subtitle_title_text_view ) ) . setText ( standardClass . getName ( ) ) ; if ( subtitle ) { if ( standardClass . hasLocation ( ) ) { if ( standardClass . hasTeacher ( ) ) ( ( TextView ) convertView . findViewById ( R . id . view_timed_class_child_with_subtitle_subtitle_text_view ) ) . setText ( standardClass . getLocation ( ) + " ▁ • ▁ " + standardClass . getTeacher ( ) ) ; else ( ( TextView ) convertView . findViewById ( R . id . view_timed_class_child_with_subtitle_subtitle_text_view ) ) . setText ( standardClass . getLocation ( ) ) ; } else { ( ( TextView ) convertView . findViewById ( R . id . view_timed_class_child_with_subtitle_subtitle_text_view ) ) . setText ( standardClass . getTeacher ( ) ) ; } } ( ( TextView ) convertView . findViewById ( subtitle ? R . id . view_timed_class_child_with_subtitle_time_text_view : R . id . view_timed_class_child_without_subtitle_time_text_view ) ) . setText ( standardClass . getStartTimeString ( true ) + " \n " + standardClass . getEndTimeString ( true ) ) ; ( ( ImageView ) convertView . findViewById ( subtitle ? R . id . view_timed_class_child_with_subtitle_color_indicator_image_view : R . id . view_timed_class_child_without_subtitle_color_indicator_image_view ) ) . setColorFilter ( standardClass . getColor ( ) ) ; return convertView ; }
camunda/camunda-bpm-platform | @ Test public void testDeployProcessArchive ( ) { Assert . assertNotNull ( processEngineService . getProcessEngine ( " engine1" ) ) ; }
trejkaz/derby | public String getModuleToTestProtocolName ( ) { return AccessFactory . MODULE ; }
trejkaz/derby | protected void runTests ( ) throws T_Fail { AccessFactory store = null ; TransactionController tc = null ; boolean pass = false ; out . println ( " executing ▁ heap ▁ test " ) ; if ( startParams == null ) { startParams = new Properties ( ) ; } startParams . put ( Property . NO_AUTO_BOOT , Boolean . TRUE . toString ( ) ) ; startParams . put ( Property . DELETE_ON_CREATE , Boolean . TRUE . toString ( ) ) ; startParams = T_Util . setEncryptionParam ( startParams ) ; try { store = ( AccessFactory ) createPersistentService ( getModuleToTestProtocolName ( ) , testService , startParams ) ; } catch ( StandardException mse ) { throw T_Fail . exceptionFail ( mse ) ; } if ( store == null ) { throw T_Fail . testFailMsg ( getModuleToTestProtocolName ( ) + " ▁ service ▁ not ▁ started . " ) ; } REPORT ( " ( unitTestMain ) ▁ Testing ▁ " + testService ) ; try { tc = store . getTransaction ( getContextService ( ) . getCurrentContextManager ( ) ) ; if ( t_001 ( tc ) ) { pass = true ; } tc . commit ( ) ; tc . destroy ( ) ; } catch ( StandardException e ) { System . out . println ( " got ▁ an ▁ exception . " ) ; String msg = e . getMessage ( ) ; if ( msg == null ) msg = e . getClass ( ) . getName ( ) ; REPORT ( msg ) ; throw T_Fail . exceptionFail ( e ) ; } if ( ! pass ) throw T_Fail . testFailMsg ( " T _ Heap ▁ test ▁ failed " ) ; }
tjones879/YAPM | public RootLayoutController ( ) { rootBorderPane = new BorderPane ( ) ; rootBorderPane . setCenter ( createFeedScrollPane ( ) ) ; rootBorderPane . setBottom ( createBottomHBox ( ) ) ; rootBorderPane . setLeft ( createLeftVBox ( ) ) ; MediaPlayerUtil . getIsPlaying ( ) . addListener ( new ChangeListener < Boolean > ( ) { @ Override public void changed ( ObservableValue < ? extends Boolean > observable , Boolean oldValue , Boolean newValue ) { updatePlayPauseButton ( newValue ) ; } } ) ; MediaPlayerUtil . getIsMuted ( ) . addListener ( new ChangeListener < Boolean > ( ) { @ Override public void changed ( ObservableValue < ? extends Boolean > observable , Boolean oldValue , Boolean newValue ) { updateVolumeButton ( newValue ) ; } } ) ; MediaPlayerUtil . getMediaPlayer ( ) . currentTimeProperty ( ) . addListener ( new ChangeListener < Duration > ( ) { @ Override public void changed ( ObservableValue < ? extends Duration > observable , Duration oldValue , Duration newValue ) { updateProgressBar ( ( int ) newValue . toSeconds ( ) ) ; updateCurrPlayTime ( ( int ) newValue . toSeconds ( ) ) ; } } ) ; }
tjones879/YAPM | private ScrollPane createFeedScrollPane ( ) { ScrollPane feedScrollPane = new ScrollPane ( ) ; feedScrollPane . setFitToWidth ( true ) ; feedScrollPane . setHbarPolicy ( ScrollPane . ScrollBarPolicy . NEVER ) ; feedScrollPane . setVbarPolicy ( ScrollPane . ScrollBarPolicy . NEVER ) ; feedScrollPane . addEventFilter ( ScrollEvent . ANY , ( event ) -> { double pos = feedScrollPane . getVvalue ( ) ; double posMin = feedScrollPane . getVmin ( ) ; double posMax = feedScrollPane . getVmax ( ) ; if ( event . getDeltaY ( ) > 0 ) { feedScrollPane . setVvalue ( pos == posMin ? posMin : pos - .225 ) ; } else { feedScrollPane . setVvalue ( pos == posMax ? posMax : pos + .225 ) ; } event . consume ( ) ; } ) ; feedTilePane = new TilePane ( ) ; feedTilePane . setPadding ( new Insets ( 5 , 5 , 5 , 5 ) ) ; feedTilePane . setHgap ( 5 ) ; feedTilePane . setVgap ( 10 ) ; feedTilePane . setTileAlignment ( Pos . CENTER ) ; feedTilePane . setAlignment ( Pos . CENTER ) ; feedScrollPane . setContent ( feedTilePane ) ; return feedScrollPane ; }
tjones879/YAPM | private HBox createBottomHBox ( ) { currPlayThumbnail = createThumbnail ( MediaPlayerUtil . getCurrPlaying ( ) . getThumbnail ( ) . getUrl ( ) , 40 ) ; currPlayTitle = new Label ( MediaPlayerUtil . getCurrPlaying ( ) . getTitle ( ) ) ; currPlayTitle . setWrapText ( true ) ; currPlayTitle . setPrefWidth ( leftVBoxWidth - 52.5 ) ; AnchorPane progressNodes = new AnchorPane ( ) ; progressBar = new ProgressBar ( ) ; progressBar . setProgress ( .5 ) ; progressBar . setPrefHeight ( 3 ) ; progressBar . setMinHeight ( 3 ) ; progressBar . setMaxHeight ( 3 ) ; progressBar . setOnMouseClicked ( event -> handleProgressBarClick ( event ) ) ; currPlayTime = new Label ( "0:00" ) ; maxPlayTime = new Label ( "0:00" ) ; progressNodes . getChildren ( ) . addAll ( progressBar , currPlayTime , maxPlayTime ) ; progressNodes . setBottomAnchor ( progressBar , 22. ) ; progressNodes . setLeftAnchor ( progressBar , 2. ) ; progressNodes . setRightAnchor ( progressBar , 2. ) ; progressNodes . setBottomAnchor ( currPlayTime , 2. ) ; progressNodes . setLeftAnchor ( currPlayTime , 2. ) ; progressNodes . setBottomAnchor ( maxPlayTime , 2. ) ; progressNodes . setRightAnchor ( maxPlayTime , 2. ) ; skipBackButton = createIcon ( skipBackIcon ) ; skipBackButton . setOnMouseClicked ( event -> handleSkipBackButton ( ) ) ; playPauseButton = createIcon ( playIcon ) ; playPauseButton . setOnMouseClicked ( event -> handlePlayPauseButton ( ) ) ; skipForwardButton = createIcon ( skipForwardIcon ) ; skipForwardButton . setOnMouseClicked ( event -> handleSkipForwardButton ( ) ) ; volumeButton = createIcon ( speakerIcon ) ; volumeButton . setOnMouseClicked ( event -> handleVolumeButtonClick ( ) ) ; volumeButton . setOnMouseEntered ( event -> handleVolumeButtonEnter ( ) ) ; HBox hBox = new HBox ( currPlayThumbnail , currPlayTitle , progressNodes , skipBackButton , playPauseButton , skipForwardButton , volumeButton ) ; hBox . setHgrow ( progressNodes , Priority . ALWAYS ) ; hBox . setAlignment ( Pos . CENTER ) ; hBox . setSpacing ( 6 ) ; hBox . setPadding ( new Insets ( 2 , 2 , 2 , 1.5 ) ) ; return hBox ; }
tjones879/YAPM | private VBox createLeftVBox ( ) { SVGPath menuButton = new SVGPath ( ) ; menuButton . setContent ( " " ) ; TextField searchField = new TextField ( ) ; searchField . setOnKeyTyped ( event -> { } ) ; HBox searchBox = new HBox ( menuButton , searchField ) ; searchBox . setHgrow ( searchField , Priority . ALWAYS ) ; GridPane menuGrid = new GridPane ( ) ; menuGrid . addRow ( 0 ) ; menuGrid . addRow ( 1 ) ; menuGrid . addRow ( 2 ) ; playingListGrid = new GridPane ( ) ; ColumnConstraints thumbnailColumn = new ColumnConstraints ( ) ; thumbnailColumn . setPercentWidth ( 25 ) ; playingListGrid . getColumnConstraints ( ) . add ( 0 , thumbnailColumn ) ; ScrollPane playListScrollPane = new ScrollPane ( playingListGrid ) ; VBox vBox = new VBox ( ) ; vBox . getChildren ( ) . addAll ( searchBox , menuGrid , playListScrollPane ) ; vBox . setPrefWidth ( leftVBoxWidth ) ; vBox . setFillWidth ( true ) ; return vBox ; }
tjones879/YAPM | public void updatePlayingList ( List < Episode > playingEpisodes ) { int i = 0 ; for ( Episode episode : playingEpisodes ) { ImageView playingListThumbnail = createThumbnail ( episode . getThumbnail ( ) . getUrl ( ) , 50 ) ; Label playingListLabel = new Label ( episode . getTitle ( ) ) ; playingListGrid . addRow ( i , playingListThumbnail , playingListLabel ) ; i ++ ; } }
tjones879/YAPM | public void updateFeedTilePane ( List < Feed > feedList ) { for ( Feed feed : feedList ) { VBox vBox = new VBox ( ) ; vBox . setOnMouseClicked ( event -> { } ) ; ImageView feedThumbnail = createThumbnail ( feed . getThumbnail ( ) . getUrl ( ) , feedThumbnailWidth ) ; Label feedTitle = new Label ( feed . getTitle ( ) ) ; feedTitle . setMaxWidth ( 175 ) ; feedTitle . setWrapText ( true ) ; feedTitle . setAlignment ( Pos . CENTER ) ; feedTitle . setTextAlignment ( TextAlignment . CENTER ) ; vBox . getChildren ( ) . addAll ( feedThumbnail , feedTitle ) ; feedTilePane . getChildren ( ) . add ( vBox ) ; } }
tjones879/YAPM | private void handleSkipBackButton ( ) { MediaPlayerUtil . skipBack ( ) ; }
tjones879/YAPM | private void handlePlayPauseButton ( ) { MediaPlayerUtil . handlePlayPause ( ) ; }
tjones879/YAPM | private void handleSkipForwardButton ( ) { MediaPlayerUtil . skipForward ( ) ; }
tjones879/YAPM | private void handleVolumeButtonClick ( ) { MediaPlayerUtil . toggleMute ( ) ; }
tjones879/YAPM | private void handleVolumeButtonEnter ( ) { }
tjones879/YAPM | private void handleProgressBarClick ( MouseEvent mouseEvent ) { double mouseX = mouseEvent . getX ( ) ; Bounds bounds = progressBar . getLayoutBounds ( ) ; double seekTime = ( ( mouseX - bounds . getMinX ( ) ) / bounds . getMaxX ( ) ) * 1000 * MediaPlayerUtil . getCurrPlaying ( ) . getLength ( ) ; MediaPlayerUtil . seek ( seekTime ) ; }
tjones879/YAPM | private void updatePlayPauseButton ( Boolean nowPlaying ) { if ( nowPlaying ) { playPauseButton . setImage ( pauseIcon ) ; } else { playPauseButton . setImage ( playIcon ) ; } }
tjones879/YAPM | private void updateVolumeButton ( Boolean nowMuted ) { if ( nowMuted ) { volumeButton . setImage ( mutedSpeakerIcon ) ; } else { volumeButton . setImage ( speakerIcon ) ; } }
tjones879/YAPM | public void updateEpisodeNodes ( ) { Episode episode = MediaPlayerUtil . getCurrPlaying ( ) ; currPlayThumbnail = createThumbnail ( episode . getThumbnail ( ) . getUrl ( ) , 50 ) ; currPlayTitle . setText ( episode . getTitle ( ) ) ; currPlayTime . setText ( "0:00" ) ; maxPlayTime . setText ( TimeUtil . formatTime ( episode . getLength ( ) ) ) ; }
tjones879/YAPM | private void updateProgressBar ( int currTime ) { double maxTime = MediaPlayerUtil . getMediaPlayer ( ) . getTotalDuration ( ) . toSeconds ( ) ; progressBar . setProgress ( currTime / maxTime ) ; }
tjones879/YAPM | public void updateCurrPlayTime ( int currTime ) { currPlayTime . setText ( TimeUtil . formatTime ( currTime ) ) ; }
tjones879/YAPM | public BorderPane getRootBorderPane ( ) { return rootBorderPane ; }
tjones879/YAPM | private ImageView createThumbnail ( String imageUrl , int imageWidth ) { ImageView thumbnail = new ImageView ( imageUrl ) ; thumbnail . setPreserveRatio ( true ) ; thumbnail . setSmooth ( true ) ; thumbnail . setCache ( true ) ; thumbnail . setFitWidth ( imageWidth ) ; thumbnail . setFitHeight ( imageWidth ) ; return thumbnail ; }
tjones879/YAPM | private ImageView createIcon ( Image image ) { ImageView imageView = new ImageView ( image ) ; imageView . setFitWidth ( 25 ) ; imageView . setFitHeight ( 25 ) ; imageView . setSmooth ( true ) ; imageView . setCache ( true ) ; return imageView ; }
apache/sqoop | public SqlServerRecordReader ( DBInputFormat . DBInputSplit split , Class < T > inputClass , Configuration conf , Connection conn , DBConfiguration dbConfig , String cond , String [ ] fields , String table ) throws SQLException { super ( split , inputClass , conf , conn , dbConfig , cond , fields , table , " MICROSOFT ▁ SQL ▁ SERVER " ) ; }
apache/sqoop | @ Override protected String getSelectQuery ( ) { StringBuilder query = new StringBuilder ( ) ; DataDrivenDBInputFormat . DataDrivenDBInputSplit dataSplit = ( DataDrivenDBInputFormat . DataDrivenDBInputSplit ) getSplit ( ) ; DBConfiguration dbConf = getDBConf ( ) ; String [ ] fieldNames = getFieldNames ( ) ; String tableName = getTableName ( ) ; String conditions = getConditions ( ) ; StringBuilder conditionClauses = new StringBuilder ( ) ; conditionClauses . append ( " ( ▁ " ) . append ( dataSplit . getLowerClause ( ) ) ; conditionClauses . append ( " ▁ ) ▁ AND ▁ ( ▁ " ) . append ( dataSplit . getUpperClause ( ) ) ; conditionClauses . append ( " ▁ ) " ) ; if ( dbConf . getInputQuery ( ) == null ) { query . append ( " SELECT ▁ " ) ; for ( int i = 0 ; i < fieldNames . length ; i ++ ) { query . append ( fieldNames [ i ] ) ; if ( i != fieldNames . length - 1 ) { query . append ( " , ▁ " ) ; } } query . append ( " ▁ FROM ▁ " ) . append ( tableName ) ; String tableHints = dbConf . getConf ( ) . get ( SQLServerManager . TABLE_HINTS_PROP ) ; if ( tableHints != null ) { LOG . info ( " Using ▁ table ▁ hints : ▁ " + tableHints ) ; query . append ( " ▁ WITH ▁ ( " ) . append ( tableHints ) . append ( " ) " ) ; } query . append ( " ▁ WHERE ▁ " ) ; if ( conditions != null && conditions . length ( ) > 0 ) { query . append ( " ( ▁ " ) . append ( conditions ) . append ( " ▁ ) ▁ AND ▁ " ) ; } query . append ( conditionClauses . toString ( ) ) ; } else { String inputQuery = dbConf . getInputQuery ( ) ; if ( inputQuery . indexOf ( DataDrivenDBInputFormat . SUBSTITUTE_TOKEN ) == - 1 ) { LOG . error ( " Could ▁ not ▁ find ▁ the ▁ clause ▁ substitution ▁ token ▁ " + DataDrivenDBInputFormat . SUBSTITUTE_TOKEN + " ▁ in ▁ the ▁ query : ▁ [ " + inputQuery + " ] . ▁ Parallel ▁ splits ▁ may ▁ not ▁ work ▁ correctly . " ) ; } query . append ( inputQuery . replace ( DataDrivenDBInputFormat . SUBSTITUTE_TOKEN , conditionClauses . toString ( ) ) ) ; } LOG . info ( " Using ▁ query : ▁ " + query . toString ( ) ) ; return query . toString ( ) ; }
swimmesberger/FileTree | public PropertiesDialog ( File f ) { super ( ) ; this . f = f ; setLocationRelativeTo ( ( JFrame ) null ) ; initUI ( ) ; this . pack ( ) ; }
swimmesberger/FileTree | private void initUI ( ) { this . setLayout ( new GridLayout ( 5 , 2 ) ) ; AssociationService as = new AssociationService ( ) ; Association fileExtensionAssociation = as . getFileExtensionAssociation ( FilenameUtils . getExtension ( f . toString ( ) ) ) ; this . add ( new JLabel ( " Default ▁ Application : " ) ) ; this . add ( new JLabel ( fileExtensionAssociation . getActionByVerb ( " open " ) . getCommand ( ) ) ) ; }
aemay2/hapi-fhir | @ Bean public DaoConfig daoConfig ( ) { DaoConfig retVal = new DaoConfig ( ) ; retVal . addSupportedSubscriptionType ( Subscription . SubscriptionChannelType . EMAIL ) ; retVal . addSupportedSubscriptionType ( Subscription . SubscriptionChannelType . RESTHOOK ) ; retVal . addSupportedSubscriptionType ( Subscription . SubscriptionChannelType . WEBSOCKET ) ; retVal . setWebsocketContextPath ( " / websocketDstu3" ) ; retVal . setAllowContainsSearches ( true ) ; retVal . setAllowMultipleDelete ( true ) ; retVal . setAllowInlineMatchUrlReferences ( true ) ; retVal . setAllowExternalReferences ( true ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " http : // hapi . fhir . org / baseDstu3" ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " https : // hapi . fhir . org / baseDstu3" ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " http : // fhirtest . uhn . ca / baseDstu3" ) ; retVal . getTreatBaseUrlsAsLocal ( ) . add ( " https : // fhirtest . uhn . ca / baseDstu3" ) ; retVal . setCountSearchResultsUpTo ( TestR4Config . COUNT_SEARCH_RESULTS_UP_TO ) ; retVal . setIndexMissingFields ( DaoConfig . IndexEnabledEnum . ENABLED ) ; retVal . setFetchSizeDefaultMaximum ( 10000 ) ; retVal . setReindexThreadCount ( 1 ) ; retVal . setExpungeEnabled ( true ) ; retVal . setFilterParameterEnabled ( true ) ; retVal . setDefaultSearchParamsCanBeOverridden ( false ) ; retVal . getModelConfig ( ) . setIndexOnContainedResources ( true ) ; return retVal ; }
aemay2/hapi-fhir | @ Bean public ModelConfig modelConfig ( ) { return daoConfig ( ) . getModelConfig ( ) ; }
aemay2/hapi-fhir | @ Override @ Bean public ValidationSettings validationSettings ( ) { ValidationSettings retVal = super . validationSettings ( ) ; retVal . setLocalReferenceValidationDefaultPolicy ( ReferenceValidationPolicy . CHECK_VALID ) ; return retVal ; }
aemay2/hapi-fhir | @ Override @ Bean ( autowire = Autowire . BY_TYPE ) public DatabaseBackedPagingProvider databaseBackedPagingProvider ( ) { DatabaseBackedPagingProvider retVal = super . databaseBackedPagingProvider ( ) ; retVal . setDefaultPageSize ( 20 ) ; retVal . setMaximumPageSize ( 500 ) ; return retVal ; }
aemay2/hapi-fhir | @ Bean public PublicSecurityInterceptor securityInterceptor ( ) { return new PublicSecurityInterceptor ( ) ; }
aemay2/hapi-fhir | @ Bean ( name = " myPersistenceDataSourceDstu3" , destroyMethod = " close " ) public DataSource dataSource ( ) { BasicDataSource retVal = new BasicDataSource ( ) ; if ( CommonConfig . isLocalTestMode ( ) ) { retVal . setUrl ( " jdbc : derby : memory : fhirtest _ dstu3 ; create = true " ) ; } else { retVal . setDriver ( new org . postgresql . Driver ( ) ) ; retVal . setUrl ( " jdbc : postgresql : // localhost / fhirtest _ dstu3" ) ; } retVal . setUsername ( myDbUsername ) ; retVal . setPassword ( myDbPassword ) ; retVal . setDefaultQueryTimeout ( 20 ) ; retVal . setTestOnBorrow ( true ) ; DataSource dataSource = ProxyDataSourceBuilder . create ( retVal ) . logSlowQueryBySlf4j ( 10000 , TimeUnit . MILLISECONDS ) . afterQuery ( new CurrentThreadCaptureQueriesListener ( ) ) . countQuery ( ) . build ( ) ; return dataSource ; }
aemay2/hapi-fhir | @ Override @ Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory ( ConfigurableListableBeanFactory theConfigurableListableBeanFactory ) { LocalContainerEntityManagerFactoryBean retVal = super . entityManagerFactory ( theConfigurableListableBeanFactory ) ; retVal . setPersistenceUnitName ( " PU _ HapiFhirJpaDstu3" ) ; retVal . setDataSource ( dataSource ( ) ) ; retVal . setJpaProperties ( jpaProperties ( ) ) ; return retVal ; }
aemay2/hapi-fhir | private Properties jpaProperties ( ) { Properties extraProperties = new Properties ( ) ; if ( CommonConfig . isLocalTestMode ( ) ) { extraProperties . put ( " hibernate . dialect " , DerbyTenSevenHapiFhirDialect . class . getName ( ) ) ; } else { extraProperties . put ( " hibernate . dialect " , HapiFhirPostgres94Dialect . class . getName ( ) ) ; } extraProperties . put ( " hibernate . format _ sql " , " false " ) ; extraProperties . put ( " hibernate . show _ sql " , " false " ) ; extraProperties . put ( " hibernate . hbm2ddl . auto " , " update " ) ; extraProperties . put ( " hibernate . jdbc . batch _ size " , "20" ) ; extraProperties . put ( " hibernate . cache . use _ query _ cache " , " false " ) ; extraProperties . put ( " hibernate . cache . use _ second _ level _ cache " , " false " ) ; extraProperties . put ( " hibernate . cache . use _ structured _ entries " , " false " ) ; extraProperties . put ( " hibernate . cache . use _ minimal _ puts " , " false " ) ; extraProperties . put ( BackendSettings . backendKey ( BackendSettings . TYPE ) , " lucene " ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneBackendSettings . ANALYSIS_CONFIGURER ) , HapiLuceneAnalysisConfigurer . class . getName ( ) ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneIndexSettings . DIRECTORY_TYPE ) , " local - filesystem " ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneIndexSettings . DIRECTORY_ROOT ) , myFhirLuceneLocation ) ; extraProperties . put ( BackendSettings . backendKey ( LuceneBackendSettings . LUCENE_VERSION ) , " LUCENE _ CURRENT " ) ; return extraProperties ; }
aemay2/hapi-fhir | @ Bean @ Lazy public RequestValidatingInterceptor requestValidatingInterceptor ( ) { RequestValidatingInterceptor requestValidator = new RequestValidatingInterceptor ( ) ; requestValidator . setFailOnSeverity ( null ) ; requestValidator . setAddResponseHeaderOnSeverity ( null ) ; requestValidator . setAddResponseOutcomeHeaderOnSeverity ( ResultSeverityEnum . INFORMATION ) ; requestValidator . addValidatorModule ( instanceValidator ( ) ) ; requestValidator . setIgnoreValidatorExceptions ( true ) ; return requestValidator ; }
aemay2/hapi-fhir | @ Bean @ Primary public JpaTransactionManager hapiTransactionManager ( EntityManagerFactory entityManagerFactory ) { JpaTransactionManager retVal = new JpaTransactionManager ( ) ; retVal . setEntityManagerFactory ( entityManagerFactory ) ; return retVal ; }
lmjacksoniii/hazelcast | public RequestMemberIdAssignment ( ) { }
lmjacksoniii/hazelcast | public RequestMemberIdAssignment ( String name , String jobId ) { super ( name , jobId ) ; }
lmjacksoniii/hazelcast | @ Override public Object getResponse ( ) { return result ; }
lmjacksoniii/hazelcast | @ Override public void run ( ) throws Exception { MapReduceService mapReduceService = getService ( ) ; JobSupervisor supervisor = mapReduceService . getJobSupervisor ( getName ( ) , getJobId ( ) ) ; if ( supervisor == null ) { result = new RequestPartitionResult ( NO_SUPERVISOR , - 1 ) ; return ; } MemberAssigningJobProcessInformationImpl processInformation = getProcessInformation ( supervisor ) ; int memberId = processInformation . assignMemberId ( getCallerAddress ( ) , getCallerUuid ( ) , supervisor . getConfiguration ( ) ) ; if ( memberId == - 1 ) { result = new RequestPartitionResult ( NO_MORE_PARTITIONS , - 1 ) ; return ; } result = new RequestPartitionResult ( SUCCESSFUL , memberId ) ; }
lmjacksoniii/hazelcast | @ Override public int getFactoryId ( ) { return MapReduceDataSerializerHook . F_ID ; }
lmjacksoniii/hazelcast | @ Override public int getId ( ) { return MapReduceDataSerializerHook . REQUEST_MEMBERID_ASSIGNMENT ; }
lmjacksoniii/hazelcast | private MemberAssigningJobProcessInformationImpl getProcessInformation ( JobSupervisor supervisor ) { return ( MemberAssigningJobProcessInformationImpl ) supervisor . getJobProcessInformation ( ) ; }
Alachisoft/TayzGrid | private RegisterBulkKeyNotifResponseProtocol ( ) { }
Alachisoft/TayzGrid | private RegisterBulkKeyNotifResponse ( ) { initFields ( ) ; }
Alachisoft/TayzGrid | private RegisterBulkKeyNotifResponse ( boolean noInit ) { }
Alachisoft/TayzGrid | public RegisterBulkKeyNotifResponse getDefaultInstanceForType ( ) { return defaultInstance ; }
Alachisoft/TayzGrid | protected com . google . protobuf . GeneratedMessage . FieldAccessorTable internalGetFieldAccessorTable ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_fieldAccessorTable ; }
Alachisoft/TayzGrid | private void initFields ( ) { }
Alachisoft/TayzGrid | public final boolean isInitialized ( ) { return true ; }
Alachisoft/TayzGrid | public int getSerializedSize ( ) { int size = memoizedSerializedSize ; if ( size != - 1 ) return size ; size = 0 ; size += getUnknownFields ( ) . getSerializedSize ( ) ; memoizedSerializedSize = size ; return size ; }
Alachisoft/TayzGrid | if ( builder . mergeDelimitedFrom ( input ) ) { return builder . buildParsed ( ) ; }
Alachisoft/TayzGrid | if ( builder . mergeDelimitedFrom ( input , extensionRegistry ) ) { return builder . buildParsed ( ) ; }
Alachisoft/TayzGrid | public Builder newBuilderForType ( ) { return newBuilder ( ) ; }
Alachisoft/TayzGrid | public Builder toBuilder ( ) { return newBuilder ( this ) ; }
Alachisoft/TayzGrid | private Builder ( ) { }
Alachisoft/TayzGrid | protected com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse internalGetResult ( ) { return result ; }
Alachisoft/TayzGrid | public Builder clear ( ) { if ( result == null ) { throw new IllegalStateException ( " Cannot ▁ call ▁ clear ( ) ▁ after ▁ build ( ) . " ) ; } result = new com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ( ) ; return this ; }
Alachisoft/TayzGrid | public Builder clone ( ) { return create ( ) . mergeFrom ( result ) ; }
Alachisoft/TayzGrid | public com . google . protobuf . Descriptors . Descriptor getDescriptorForType ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . getDescriptor ( ) ; }
Alachisoft/TayzGrid | public com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse getDefaultInstanceForType ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . getDefaultInstance ( ) ; }
Alachisoft/TayzGrid | public boolean isInitialized ( ) { return result . isInitialized ( ) ; }
Alachisoft/TayzGrid | public com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse build ( ) { if ( result != null && ! isInitialized ( ) ) { throw newUninitializedMessageException ( result ) ; } return buildPartial ( ) ; }
Alachisoft/TayzGrid | if ( ! isInitialized ( ) ) { throw newUninitializedMessageException ( result ) . asInvalidProtocolBufferException ( ) ; }
Alachisoft/TayzGrid | public com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse buildPartial ( ) { if ( result == null ) { throw new IllegalStateException ( " build ( ) ▁ has ▁ already ▁ been ▁ called ▁ on ▁ this ▁ Builder . " ) ; } com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse returnMe = result ; result = null ; return returnMe ; }
Alachisoft/TayzGrid | public Builder mergeFrom ( com . google . protobuf . Message other ) { if ( other instanceof com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ) { return mergeFrom ( ( com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ) other ) ; } else { super . mergeFrom ( other ) ; return this ; } }
Alachisoft/TayzGrid | public Builder mergeFrom ( com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse other ) { if ( other == com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . getDefaultInstance ( ) ) return this ; this . mergeUnknownFields ( other . getUnknownFields ( ) ) ; return this ; }
Alachisoft/TayzGrid | while ( true ) { int tag = input . readTag ( ) ; switch ( tag ) { case 0 : this . setUnknownFields ( unknownFields . build ( ) ) ; return this ; default : { if ( ! parseUnknownField ( input , unknownFields , extensionRegistry , tag ) ) { this . setUnknownFields ( unknownFields . build ( ) ) ; return this ; } break ; } } }
Alachisoft/TayzGrid | com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner assigner = new com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner ( ) { public com . google . protobuf . ExtensionRegistry assignDescriptors ( com . google . protobuf . Descriptors . FileDescriptor root ) { descriptor = root ; internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_descriptor = getDescriptor ( ) . getMessageTypes ( ) . get ( 0 ) ; internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_fieldAccessorTable = new com . google . protobuf . GeneratedMessage . FieldAccessorTable ( internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_descriptor , new java . lang . String [ ] { } , com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . class , com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse . Builder . class ) ; return null ; } }
MovingBlocks/box2d-editor | public void initialize ( ) { String [ ] texturesNearest = new String [ ] { " data / transparent - light . png " , " data / transparent - dark . png " , " data / white . png " } ; String [ ] texturesLinear = new String [ ] { " data / ball . png " , " data / v00 . png " , " data / v01 . png " , " data / v10 . png " , " data / unknown . png " } ; for ( String tex : texturesNearest ) load ( tex , Texture . class ) ; for ( String tex : texturesLinear ) load ( tex , Texture . class ) ; while ( update ( ) == false ) { } for ( String tex : texturesLinear ) { get ( tex , Texture . class ) . setFilter ( Texture . TextureFilter . Linear , Texture . TextureFilter . Linear ) ; } unknownRegion = new TextureRegion ( get ( " data / unknown . png " , Texture . class ) ) ; Ctx . bodies . getModels ( ) . addListChangedListener ( new ObservableList . ListChangeListener < RigidBodyModel > ( ) { @ Override public void changed ( Object source , List < RigidBodyModel > added , List < RigidBodyModel > removed ) { for ( RigidBodyModel body : removed ) { TextureRegion region = rigidBodiesRegions . remove ( body ) ; if ( region != null ) region . getTexture ( ) . dispose ( ) ; } for ( RigidBodyModel body : added ) { load ( body ) ; } } } ) ; }
MovingBlocks/box2d-editor | public TextureRegion getRegion ( RigidBodyModel body ) { if ( ! body . isImagePathValid ( ) ) return unknownRegion ; if ( body . getImagePath ( ) == null ) return null ; if ( ! rigidBodiesRegions . containsKey ( body ) ) load ( body ) ; return rigidBodiesRegions . get ( body ) ; }
MovingBlocks/box2d-editor | private void load ( RigidBodyModel body ) { if ( ! body . isImagePathValid ( ) ) return ; if ( body . getImagePath ( ) == null ) return ; File file = Ctx . io . getImageFile ( body . getImagePath ( ) ) ; TextureRegion region = TextureUtils . getPOTTexture ( file . getPath ( ) ) ; rigidBodiesRegions . put ( body , region ) ; }
egustafson/sandbox | @ Test public void testLoad ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " INTC " ; LocalDate fromDate = new LocalDate ( 2007 , 7 , 6 ) ; LocalDate toDate = new LocalDate ( 2008 , 2 , 5 ) ; List < String > results = yq . loadHistory ( symbol , fromDate , toDate ) ; for ( String line : results ) { System . out . println ( line ) ; } }
egustafson/sandbox | @ Test public void testLoadRecords ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " INTC " ; LocalDate fromDate = new LocalDate ( 2007 , 7 , 1 ) ; LocalDate toDate = new LocalDate ( 2007 , 7 , 14 ) ; List < YahooHistoryRecord > records = yq . loadHistoryRecords ( symbol , fromDate , toDate ) ; for ( YahooHistoryRecord r : records ) { System . out . println ( r . toString ( ) ) ; } }
egustafson/sandbox | @ Test public void testQuote ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " MSFT " ; List < String > results = yq . quote ( symbol , " x " ) ; for ( String line : results ) { System . out . println ( line ) ; } }
egustafson/sandbox | @ Test public void testDividends ( ) { YahooQuote yq = new YahooQuote ( ) ; String symbol = " IBM " ; LocalDate fromDate = new LocalDate ( 1800 , 1 , 1 ) ; LocalDate toDate = new LocalDate ( 2009 , 1 , 1 ) ; List < String > results = yq . loadDividends ( symbol , fromDate , toDate ) ; for ( String line : results ) { System . out . println ( line ) ; } }
akkumar/jreversepro | public ExceptionThrown ( int rhsStart , int rhsEnd , int rhsHandler , String rhsType ) { startPc = rhsStart ; endPc = rhsEnd ; any = ( rhsType . equals ( JVMConstants . ANY ) ) ; if ( rhsHandler - rhsEnd == 1 ) { endPc = rhsHandler ; } excCatchTable = new HashMap < Integer , String > ( ) ; addCatchBlock ( rhsHandler , rhsType ) ; }
akkumar/jreversepro | public void addCatchBlock ( int rhsHandlerPc , String rhsType ) { rhsType = ( rhsType != null ) ? rhsType : JVMConstants . ANY ; excCatchTable . put ( Integer . valueOf ( rhsHandlerPc ) , rhsType ) ; }
akkumar/jreversepro | public int getStartPc ( ) { return startPc ; }
akkumar/jreversepro | public int getEndPc ( ) { return endPc ; }
akkumar/jreversepro | public Enumeration < Map . Entry < Integer , String > > getHandlers ( ) { return Collections . enumeration ( excCatchTable . entrySet ( ) ) ; }
akkumar/jreversepro | public String getExceptionClass ( int rhsHandlerPc ) { return excCatchTable . get ( Integer . valueOf ( rhsHandlerPc ) ) ; }
akkumar/jreversepro | @ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof ExceptionThrown ) ) { return false ; } else { return sameTryBlock ( ( ExceptionThrown ) obj ) ; } }
akkumar/jreversepro | public boolean sameTryBlock ( ExceptionThrown exc ) { return ( startPc == exc . startPc && endPc == exc . endPc ) ; }
akkumar/jreversepro | public boolean containsANYCatchBlock ( ) { return excCatchTable . containsValue ( JVMConstants . ANY ) ; }
akkumar/jreversepro | public boolean isAny ( ) { return any ; }
akkumar/jreversepro | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " " ) ; for ( Map . Entry < Integer , String > ent : excCatchTable . entrySet ( ) ) { sb . append ( " \t\t " + startPc + " \t " + endPc ) ; sb . append ( " \t " + ent . getKey ( ) ) ; sb . append ( " ▁ " + ent . getValue ( ) + " \n " ) ; } return sb . toString ( ) ; }
dennisxu1014/dennisxu-sample-android | public int getType ( ) { return mType ; }
dennisxu1014/dennisxu-sample-android | public void setType ( int type ) { this . mType = type ; }
dennisxu1014/dennisxu-sample-android | public String getPath ( ) { return mPath ; }
dennisxu1014/dennisxu-sample-android | public void setPath ( String mPath ) { this . mPath = mPath ; }
dennisxu1014/dennisxu-sample-android | public String getAction ( ) { return mAction ; }
dennisxu1014/dennisxu-sample-android | public void setAction ( String action ) { this . mAction = action ; }
dennisxu1014/dennisxu-sample-android | public Params getParams ( ) { return mParams ; }
dennisxu1014/dennisxu-sample-android | public void setParams ( Params params ) { this . mParams = params ; }
dennisxu1014/dennisxu-sample-android | public ParserType getParserType ( ) { return mParserType ; }
dennisxu1014/dennisxu-sample-android | public Class < ? > getExpectType ( ) { return mExpectType ; }
dennisxu1014/dennisxu-sample-android | public void setExpectType ( Class < ? > expectType ) { this . mExpectType = expectType ; }
dennisxu1014/dennisxu-sample-android | public void setParserType ( ParserType parserType ) { this . mParserType = parserType ; }
dennisxu1014/dennisxu-sample-android | private ParserType ( int value ) { this . mValue = value ; }
dennisxu1014/dennisxu-sample-android | public int getValue ( ) { return mValue ; }
dennisxu1014/dennisxu-sample-android | @ Override public boolean equals ( Object o ) { if ( o instanceof ParserType ) { ParserType type = ( ParserType ) o ; return type . getValue ( ) == getValue ( ) ; } else { return false ; } }
pniraula/InGen | public ExcelDoc ( Display display ) { FileInputStream file ; this . display = display ; try { display . addMessage ( " Reading ▁ Excel ▁ Doc " ) ; file = new FileInputStream ( new File ( CONFIG . getInputFile ( ) ) ) ; Workbook wb = WorkbookFactory . create ( file ) ; sheet = wb . getSheet ( CONFIG . getSheet ( ) ) ; display . addMessage ( " Excel ▁ file ▁ has ▁ been ▁ successfully ▁ read . " ) ; } catch ( Exception e ) { display . addMessage ( e . getMessage ( ) ) ; } }
pniraula/InGen | public String getValue ( Row row , int cellNo ) { Cell cell = row . getCell ( cellNo ) ; if ( cell != null ) { if ( cell . getCellType ( ) == Cell . CELL_TYPE_STRING ) return cell . getStringCellValue ( ) . trim ( ) . replaceAll ( " " , " " ) ; else if ( cell . getCellType ( ) == Cell . CELL_TYPE_BOOLEAN ) return Boolean . toString ( cell . getBooleanCellValue ( ) ) . toUpperCase ( ) . trim ( ) . replaceAll ( " " , " " ) ; else if ( cell . getCellType ( ) == Cell . CELL_TYPE_NUMERIC ) return Integer . toString ( ( int ) cell . getNumericCellValue ( ) ) . trim ( ) . replaceAll ( " " , " " ) ; else if ( cell . getCellType ( ) == Cell . CELL_TYPE_BLANK ) return " " ; } return " " ; }
pniraula/InGen | public Sheet getSheet ( ) { return sheet ; }
pniraula/InGen | public ArrayList < Row > getRows ( String table ) { ArrayList < Row > rows = new ArrayList < Row > ( ) ; Iterator < Row > rowIterator = this . sheet . rowIterator ( ) ; int counter = 0 ; while ( rowIterator . hasNext ( ) ) { if ( counter >= CONFIG . getStartPoint ( ) - 1 ) { Row row = rowIterator . next ( ) ; if ( getValue ( row , 5 ) . trim ( ) . equals ( table ) ) { rows . add ( row ) ; } } else { rowIterator . next ( ) ; } counter ++ ; } return rows ; }
pniraula/InGen | public boolean isEmpty ( Row row , int number ) { if ( getValue ( row , number ) . length ( ) > 0 ) return false ; return true ; }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void testEviction ( ) throws IOException { Configuration conf = new Configuration ( ) ; conf . set ( FileSystem . FS_DEFAULT_NAME_KEY , " hdfs : // localhost " ) ; final int MAX_CACHE_SIZE = 2 ; DFSClientCache cache = new DFSClientCache ( conf , MAX_CACHE_SIZE ) ; DFSClient c1 = cache . get ( " test1" ) ; assertTrue ( cache . get ( " test1" ) . toString ( ) . contains ( " ugi = test1" ) ) ; assertEquals ( c1 , cache . get ( " test1" ) ) ; assertFalse ( isDfsClientClose ( c1 ) ) ; cache . get ( " test2" ) ; assertTrue ( isDfsClientClose ( c1 ) ) ; assertEquals ( MAX_CACHE_SIZE - 1 , cache . clientCache . size ( ) ) ; }
Zooz/Zooz-Java | public AdditionalExternalServicesErrorResponse ( ) { }
Zooz/Zooz-Java | public AdditionalExternalServicesErrorResponse ( String errorCode , String errorMessage ) { this . errorCode = errorCode ; this . errorMessage = errorMessage ; }
Zooz/Zooz-Java | public String getErrorCode ( ) { return errorCode ; }
Zooz/Zooz-Java | public void setErrorCode ( String errorCode ) { this . errorCode = errorCode ; }
Zooz/Zooz-Java | public String getErrorMessage ( ) { return errorMessage ; }
Zooz/Zooz-Java | public void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; }
dstozek/mind-notes | public void onModuleLoad ( ) { String mapKey = Window . Location . getParameter ( " map " ) ; if ( mapKey == null ) return ; MindmapStorageServiceAsync storage = GWT . create ( MindmapStorageService . class ) ; storage . loadMindmapPublic ( mapKey , new AsyncCallback < MindMap > ( ) { @ Override public void onSuccess ( MindMap result ) { showMap ( result ) ; } @ Override public void onFailure ( Throwable caught ) { showError ( new MindNotesViewerUI ( ) , " I ' m ▁ sorry , ▁ I ▁ cannot ▁ show ▁ you ▁ this ▁ map . ▁ " ) ; } } ) ; }
dstozek/mind-notes | protected void showError ( final MindNotesViewerUI ui , String string ) { DOM . getElementById ( " loader " ) . removeFromParent ( ) ; ui . errorDialogLabel . setText ( string ) ; ui . errorDialog . setPopupPositionAndShow ( new PositionCallback ( ) { @ Override public void setPosition ( int offsetWidth , int offsetHeight ) { ui . errorDialog . setPopupPosition ( ( Window . getClientWidth ( ) - offsetWidth ) / 2 , ( Window . getClientHeight ( ) - offsetHeight ) / 2 ) ; } } ) ; }
dstozek/mind-notes | private void showMap ( final MindMap result ) { MindNotesViewerUI ui = new MindNotesViewerUI ( ) ; final MindMapViewer presenter = new MindMapViewer ( ) ; presenter . setView ( ui . getMindMapView ( ) ) ; ui . setMapTitle ( result . getTitle ( ) ) ; RootLayoutPanel . get ( ) . add ( ui ) ; DOM . getElementById ( " loader " ) . removeFromParent ( ) ; final MindMap mindMap = new MindMap ( ) ; mindMap . setTitle ( " Viewer " ) ; mindMap . getRootNode ( ) . setText ( " Viewer ▁ Mindmap " ) ; DeferredCommand . addCommand ( new Command ( ) { @ Override public void execute ( ) { presenter . setMindMap ( result ) ; } } ) ; }
JaredHatfield/shak-jarvis | public HolidayList ( ) { this . available = new ArrayList < String > ( ) ; ResourceBundle resource = ResourceBundle . getBundle ( " Holidays " , Locale . getDefault ( ) ) ; this . names = new HashMap < String , String > ( ) ; Enumeration < String > keys = resource . getKeys ( ) ; while ( keys . hasMoreElements ( ) ) { String key = keys . nextElement ( ) ; names . put ( key , resource . getString ( key ) ) ; } this . holidays = new TreeMap < Integer , Map < Integer , Map < Integer , List < String > > > > ( ) ; int thisYear = Calendar . getInstance ( ) . get ( Calendar . YEAR ) ; this . populateYear ( thisYear ) ; }
JaredHatfield/shak-jarvis | public synchronized List < String > getHolidays ( Calendar calendar ) { int year = calendar . get ( Calendar . YEAR ) ; int month = calendar . get ( Calendar . MONTH ) + 1 ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; return this . getHolidays ( year , month , day ) ; }
JaredHatfield/shak-jarvis | public synchronized List < String > getHolidays ( int year , int month , int day ) { List < String > holidayNames = new ArrayList < String > ( ) ; List < String > holidayEvents = this . getEvents ( year , month , day ) ; for ( String holidayEvent : holidayEvents ) { holidayNames . add ( this . names . get ( holidayEvent ) ) ; } return holidayNames ; }
JaredHatfield/shak-jarvis | List < String > getEvents ( int year , int month , int day ) { List < String > events = new ArrayList < String > ( ) ; if ( ! this . holidays . containsKey ( year ) ) { this . populateYear ( year ) ; } if ( ! this . holidays . get ( year ) . containsKey ( month ) ) { return events ; } else if ( ! this . holidays . get ( year ) . get ( month ) . containsKey ( day ) ) { return events ; } events = this . holidays . get ( year ) . get ( month ) . get ( day ) ; return events ; }
JaredHatfield/shak-jarvis | void add ( int year , int month , int day , String name ) { this . holidays . get ( year ) . get ( month + 1 ) . get ( day ) . add ( name ) ; if ( ! this . available . contains ( name ) ) { this . available . add ( name ) ; } }
JaredHatfield/shak-jarvis | List < String > getAllHolidays ( ) { return Collections . unmodifiableList ( this . available ) ; }
JaredHatfield/shak-jarvis | Map < String , String > getAllHolidayNames ( ) { return Collections . unmodifiableMap ( this . names ) ; }
JaredHatfield/shak-jarvis | private void populateYear ( int yearNumber ) { Map < Integer , Map < Integer , List < String > > > year = new TreeMap < Integer , Map < Integer , List < String > > > ( ) ; this . holidays . put ( yearNumber , year ) ; for ( int monthNumber = 1 ; monthNumber <= 12 ; monthNumber ++ ) { Map < Integer , List < String > > month = new TreeMap < Integer , List < String > > ( ) ; year . put ( monthNumber , month ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . set ( Calendar . YEAR , yearNumber ) ; calendar . set ( Calendar . MONTH , monthNumber - 1 ) ; int numDays = calendar . getActualMaximum ( Calendar . DATE ) ; for ( int dayNumber = 1 ; dayNumber <= numDays ; dayNumber ++ ) { List < String > day = new ArrayList < String > ( ) ; month . put ( dayNumber , day ) ; } } FixedHolidays . populate ( yearNumber , this ) ; VariableHolidays . populate ( yearNumber , this ) ; }
HenryHarper/Acquire-Reboot | public DaemonJvmOptions ( PathToFileResolver resolver ) { super ( resolver ) ; final JvmOptions currentProcessJvmOptions = new CurrentProcess ( ) . getJvmOptions ( ) ; systemProperties ( currentProcessJvmOptions . getImmutableSystemProperties ( ) ) ; handleDaemonImmutableProperties ( currentProcessJvmOptions . getMutableSystemProperties ( ) ) ; }
HenryHarper/Acquire-Reboot | private void handleDaemonImmutableProperties ( Map < String , Object > systemProperties ) { for ( Map . Entry < String , ? > entry : systemProperties . entrySet ( ) ) { if ( IMMUTABLE_DAEMON_SYSTEM_PROPERTIES . contains ( entry . getKey ( ) ) ) { immutableSystemProperties . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } }
HenryHarper/Acquire-Reboot | public Map < String , Object > getImmutableDaemonProperties ( ) { return CollectionUtils . filter ( immutableSystemProperties , new Spec < Map . Entry < String , Object > > ( ) { @ Override public boolean isSatisfiedBy ( Map . Entry < String , Object > element ) { return IMMUTABLE_DAEMON_SYSTEM_PROPERTIES . contains ( element . getKey ( ) ) ; } } ) ; }
HenryHarper/Acquire-Reboot | public void systemProperty ( String name , Object value ) { if ( IMMUTABLE_DAEMON_SYSTEM_PROPERTIES . contains ( name ) ) { immutableSystemProperties . put ( name , value ) ; } else { super . systemProperty ( name , value ) ; } }
HenryHarper/Acquire-Reboot | public List < String > getAllSingleUseImmutableJvmArgs ( ) { List < String > immutableDaemonParameters = new ArrayList < String > ( ) ; formatSystemProperties ( getImmutableDaemonProperties ( ) , immutableDaemonParameters ) ; final List < String > jvmArgs = getAllImmutableJvmArgs ( ) ; jvmArgs . removeAll ( immutableDaemonParameters ) ; return jvmArgs ; }
dragonzhou/humor | public Sequence ( int id ) { this . id = id ; }
dragonzhou/humor | public void addItemset ( Itemset itemset ) { itemsets . add ( itemset ) ; numberOfItems += itemset . size ( ) ; }
dragonzhou/humor | public void addItem ( Item item ) { itemsets . get ( size ( ) - 1 ) . addItem ( item ) ; numberOfItems ++ ; }
dragonzhou/humor | public void addItem ( int indexItemset , Item item ) { itemsets . get ( indexItemset ) . addItem ( item ) ; numberOfItems ++ ; }
dragonzhou/humor | public void addItem ( int indexItemset , int indexItem , Item item ) { itemsets . get ( indexItemset ) . addItem ( indexItem , item ) ; numberOfItems ++ ; }
dragonzhou/humor | public Itemset remove ( int indexItemset ) { Itemset itemset = itemsets . remove ( indexItemset ) ; numberOfItems -= itemset . size ( ) ; return itemset ; }
dragonzhou/humor | public Item remove ( int indexItemset , int indexItem ) { numberOfItems -- ; return itemsets . get ( indexItem ) . removeItem ( indexItem ) ; }
dragonzhou/humor | public void remove ( int indexItemset , Item item ) { itemsets . get ( indexItemset ) . removeItem ( item ) ; numberOfItems -- ; }
dragonzhou/humor | public Sequence cloneSequence ( ) { Sequence sequence = new Sequence ( getId ( ) ) ; for ( Itemset itemset : itemsets ) { sequence . addItemset ( itemset . cloneItemSet ( ) ) ; } return sequence ; }
dragonzhou/humor | @ Override public String toString ( ) { StringBuilder r = new StringBuilder ( " " ) ; for ( Itemset itemset : itemsets ) { r . append ( " { t = " ) ; r . append ( itemset . getTimestamp ( ) ) ; r . append ( " , ▁ " ) ; for ( Item item : itemset . getItems ( ) ) { String string = item . toString ( ) ; r . append ( string ) ; r . append ( ' ▁ ' ) ; } r . append ( ' } ' ) ; } return r . append ( " ▁ ▁ ▁ ▁ " ) . toString ( ) ; }
dragonzhou/humor | public int getId ( ) { return id ; }
dragonzhou/humor | public List < Itemset > getItemsets ( ) { return itemsets ; }
dragonzhou/humor | public Itemset get ( int index ) { return itemsets . get ( index ) ; }
dragonzhou/humor | public int size ( ) { return itemsets . size ( ) ; }
dragonzhou/humor | public int length ( ) { return numberOfItems ; }
dragonzhou/humor | public long getTimeLength ( ) { return itemsets . get ( itemsets . size ( ) - 1 ) . getTimestamp ( ) - itemsets . get ( 0 ) . getTimestamp ( ) ; }
dragonzhou/humor | public Sequence cloneSequenceMinusItems ( Map < Item , BitSet > mapSequenceID , double relativeMinSup ) { Sequence sequence = new Sequence ( getId ( ) ) ; for ( Itemset itemset : itemsets ) { Itemset newItemset = itemset . cloneItemSetMinusItems ( mapSequenceID , relativeMinSup ) ; if ( newItemset . size ( ) != 0 ) { sequence . addItemset ( newItemset ) ; } } return sequence ; }
dragonzhou/humor | public void setID ( int id ) { this . id = id ; }
iamsandipan/prosperity-new | public String getLogin ( ) { return login ; }
iamsandipan/prosperity-new | public void setLogin ( String login ) { this . login = login ; }
iamsandipan/prosperity-new | public String getHashPassword ( ) { return hashPassword ; }
iamsandipan/prosperity-new | public void setHashPassword ( String password ) { this . hashPassword = password ; }
iamsandipan/prosperity-new | public String getPhone ( ) { return phone ; }
iamsandipan/prosperity-new | public void setPhone ( String phone ) { this . phone = phone ; }
iamsandipan/prosperity-new | public String getId ( ) { return id ; }
iamsandipan/prosperity-new | public void setId ( String id ) { this . id = id ; }
MiniPlayer/log-island | private Record getRecord1 ( ) { Record record1 = new StandardRecord ( ) ; record1 . setField ( " string1" , FieldType . STRING , " value1" ) ; record1 . setField ( " string2" , FieldType . STRING , " value2" ) ; record1 . setField ( " long1" , FieldType . LONG , 1 ) ; record1 . setField ( " long2" , FieldType . LONG , 2 ) ; return record1 ; }
MiniPlayer/log-island | @ Test public void testNothingToRemove ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " " ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 4 ) ; outputRecord . assertFieldEquals ( " string1" , " value1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long1" , 1 ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
MiniPlayer/log-island | @ Test public void testRemoveOneField ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " string1" ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 3 ) ; outputRecord . assertFieldNotExists ( " string1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long1" , 1 ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
MiniPlayer/log-island | @ Test public void testRemove2Fields ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " string1 , long1" ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 2 ) ; outputRecord . assertFieldNotExists ( " string1" ) ; outputRecord . assertFieldNotExists ( " long1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
MiniPlayer/log-island | @ Test public void testRemoveNonExistingField ( ) { Record record1 = getRecord1 ( ) ; TestRunner testRunner = TestRunners . newTestRunner ( new RemoveFields ( ) ) ; testRunner . setProperty ( RemoveFields . FIELDS_TO_REMOVE , " string3" ) ; testRunner . assertValid ( ) ; testRunner . enqueue ( record1 ) ; testRunner . run ( ) ; testRunner . assertAllInputRecordsProcessed ( ) ; testRunner . assertOutputRecordsCount ( 1 ) ; MockRecord outputRecord = testRunner . getOutputRecords ( ) . get ( 0 ) ; outputRecord . assertRecordSizeEquals ( 4 ) ; outputRecord . assertFieldEquals ( " string1" , " value1" ) ; outputRecord . assertFieldEquals ( " string2" , " value2" ) ; outputRecord . assertFieldEquals ( " long1" , 1 ) ; outputRecord . assertFieldEquals ( " long2" , 2 ) ; }
Danny02/deltaspike | @ Override public Boolean isActivated ( Class < ? extends Deactivatable > targetClass ) { return ! DefaultMockFilter . class . equals ( targetClass ) ; }
didiez/keycloak | public String getRealmId ( ) { return realmId ; }
didiez/keycloak | public void setRealmId ( String realmId ) { this . realmId = realmId ; }
didiez/keycloak | public String getUserId ( ) { return userId ; }
didiez/keycloak | public void setUserId ( String userId ) { this . userId = userId ; }
didiez/keycloak | public int getLastSessionRefresh ( ) { return lastSessionRefresh ; }
didiez/keycloak | public void setLastSessionRefresh ( int lastSessionRefresh ) { this . lastSessionRefresh = lastSessionRefresh ; }
didiez/keycloak | public String getData ( ) { return data ; }
didiez/keycloak | public void setData ( String data ) { this . data = data ; }
didiez/keycloak | public List < PersistentClientSessionEntity > getClientSessions ( ) { return clientSessions ; }
didiez/keycloak | public void setClientSessions ( List < PersistentClientSessionEntity > clientSessions ) { this . clientSessions = clientSessions ; }
everttigchelaar/camel-svn | public MailConfiguration ( ) { }
everttigchelaar/camel-svn | public MailConfiguration copy ( ) { try { MailConfiguration copy = ( MailConfiguration ) clone ( ) ; copy . recipients = new HashMap < Message . RecipientType , String > ( ) ; copy . recipients . putAll ( this . recipients ) ; return copy ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } }
everttigchelaar/camel-svn | public void configure ( URI uri ) { String value = uri . getHost ( ) ; if ( value != null ) { setHost ( value ) ; } if ( ! isIgnoreUriScheme ( ) ) { String scheme = uri . getScheme ( ) ; if ( scheme != null ) { setProtocol ( scheme ) ; } } String userInfo = uri . getUserInfo ( ) ; if ( userInfo != null ) { setUsername ( userInfo ) ; } int port = uri . getPort ( ) ; if ( port > 0 ) { setPort ( port ) ; } else if ( port <= 0 && this . port <= 0 ) { setPort ( MailUtils . getDefaultPortForProtocol ( uri . getScheme ( ) ) ) ; } }
everttigchelaar/camel-svn | protected JavaMailSenderImpl createJavaMailSender ( ) { JavaMailSenderImpl answer = new JavaMailSenderImpl ( ) ; if ( javaMailProperties != null ) { answer . setJavaMailProperties ( javaMailProperties ) ; } else { answer . setJavaMailProperties ( createJavaMailProperties ( ) ) ; if ( additionalJavaMailProperties != null ) { answer . getJavaMailProperties ( ) . putAll ( additionalJavaMailProperties ) ; } } if ( defaultEncoding != null ) { answer . setDefaultEncoding ( defaultEncoding ) ; } if ( host != null ) { answer . setHost ( host ) ; } if ( port >= 0 ) { answer . setPort ( port ) ; } if ( username != null ) { answer . setUsername ( username ) ; } if ( password != null ) { answer . setPassword ( password ) ; } if ( protocol != null ) { answer . setProtocol ( protocol ) ; } if ( session != null ) { answer . setSession ( session ) ; } else { Session session = Session . getInstance ( answer . getJavaMailProperties ( ) , getAuthenticator ( ) ) ; session . setDebug ( debugMode ) ; answer . setSession ( session ) ; } return answer ; }
everttigchelaar/camel-svn | private Properties createJavaMailProperties ( ) { Properties properties = ( Properties ) System . getProperties ( ) . clone ( ) ; properties . put ( " mail . " + protocol + " . connectiontimeout " , connectionTimeout ) ; properties . put ( " mail . " + protocol + " . timeout " , connectionTimeout ) ; properties . put ( " mail . " + protocol + " . host " , host ) ; properties . put ( " mail . " + protocol + " . port " , " " + port ) ; if ( username != null ) { properties . put ( " mail . " + protocol + " . user " , username ) ; properties . put ( " mail . user " , username ) ; properties . put ( " mail . " + protocol + " . auth " , " true " ) ; } else { properties . put ( " mail . " + protocol + " . auth " , " false " ) ; } properties . put ( " mail . " + protocol + " . rsetbeforequit " , " true " ) ; properties . put ( " mail . transport . protocol " , protocol ) ; properties . put ( " mail . store . protocol " , protocol ) ; properties . put ( " mail . host " , host ) ; if ( debugMode ) { properties . put ( " javax . net . debug " , " all " ) ; } if ( dummyTrustManager && isSecureProtocol ( ) ) { properties . put ( " mail . " + protocol + " . socketFactory . class " , " org . apache . camel . component . mail . security . DummySSLSocketFactory " ) ; properties . put ( " mail . " + protocol + " . socketFactory . fallback " , " false " ) ; properties . put ( " mail . " + protocol + " . socketFactory . port " , " " + port ) ; } return properties ; }
everttigchelaar/camel-svn | public boolean isSecureProtocol ( ) { return this . protocol . equalsIgnoreCase ( " smtps " ) || this . protocol . equalsIgnoreCase ( " pop3s " ) || this . protocol . equalsIgnoreCase ( " imaps " ) ; }
everttigchelaar/camel-svn | public Authenticator getAuthenticator ( ) { return new Authenticator ( ) { protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( getUsername ( ) , getPassword ( ) ) ; } } ; }
everttigchelaar/camel-svn | public String getMailStoreLogInformation ( ) { String ssl = " " ; if ( isSecureProtocol ( ) ) { ssl = " ▁ ( SSL ▁ enabled " + ( dummyTrustManager ? " ▁ using ▁ DummyTrustManager ) " : " ) " ) ; } return protocol + " : // " + host + " : " + port + ssl + " , ▁ folder = " + folderName ; }
everttigchelaar/camel-svn | public JavaMailSender getJavaMailSender ( ) { return javaMailSender ; }
everttigchelaar/camel-svn | public void setJavaMailSender ( JavaMailSender javaMailSender ) { this . javaMailSender = javaMailSender ; }
everttigchelaar/camel-svn | public String getDefaultEncoding ( ) { return defaultEncoding ; }
everttigchelaar/camel-svn | public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; }
everttigchelaar/camel-svn | public String getHost ( ) { return host ; }
everttigchelaar/camel-svn | public void setHost ( String host ) { this . host = host ; }
everttigchelaar/camel-svn | public Properties getJavaMailProperties ( ) { return javaMailProperties ; }
everttigchelaar/camel-svn | public void setJavaMailProperties ( Properties javaMailProperties ) { this . javaMailProperties = javaMailProperties ; }
everttigchelaar/camel-svn | public Properties getAdditionalJavaMailProperties ( ) { if ( additionalJavaMailProperties == null ) { additionalJavaMailProperties = new Properties ( ) ; } return additionalJavaMailProperties ; }
everttigchelaar/camel-svn | public void setAdditionalJavaMailProperties ( Properties additionalJavaMailProperties ) { this . additionalJavaMailProperties = additionalJavaMailProperties ; }
everttigchelaar/camel-svn | public String getPassword ( ) { return password ; }
everttigchelaar/camel-svn | public void setPassword ( String password ) { this . password = password ; }
everttigchelaar/camel-svn | public String getSubject ( ) { return subject ; }
everttigchelaar/camel-svn | public void setSubject ( String subject ) { this . subject = subject ; }
everttigchelaar/camel-svn | public int getPort ( ) { return port ; }
everttigchelaar/camel-svn | public void setPort ( int port ) { this . port = port ; }
everttigchelaar/camel-svn | public String getProtocol ( ) { return protocol ; }
everttigchelaar/camel-svn | public void setProtocol ( String protocol ) { this . protocol = protocol ; }
everttigchelaar/camel-svn | public Session getSession ( ) { return session ; }
everttigchelaar/camel-svn | public void setSession ( Session session ) { this . session = session ; }
everttigchelaar/camel-svn | public String getUsername ( ) { return username ; }
everttigchelaar/camel-svn | public void setUsername ( String username ) { this . username = username ; if ( getRecipients ( ) . size ( ) == 0 ) { String address = username ; if ( address . indexOf ( " @ " ) == - 1 ) { address += " @ " + host ; } setTo ( address ) ; } }
everttigchelaar/camel-svn | public String getFrom ( ) { return from ; }
everttigchelaar/camel-svn | public void setFrom ( String from ) { this . from = from ; }
everttigchelaar/camel-svn | public boolean isDelete ( ) { return delete ; }
everttigchelaar/camel-svn | public void setDelete ( boolean delete ) { this . delete = delete ; }
everttigchelaar/camel-svn | public String getFolderName ( ) { return folderName ; }
everttigchelaar/camel-svn | public void setFolderName ( String folderName ) { this . folderName = folderName ; }
everttigchelaar/camel-svn | public boolean isIgnoreUriScheme ( ) { return ignoreUriScheme ; }
everttigchelaar/camel-svn | public void setIgnoreUriScheme ( boolean ignoreUriScheme ) { this . ignoreUriScheme = ignoreUriScheme ; }
everttigchelaar/camel-svn | public boolean isUnseen ( ) { return unseen ; }
everttigchelaar/camel-svn | public void setUnseen ( boolean unseen ) { this . unseen = unseen ; }
everttigchelaar/camel-svn | public void setTo ( String address ) { recipients . put ( Message . RecipientType . TO , address ) ; }
everttigchelaar/camel-svn | public void setCC ( String address ) { recipients . put ( Message . RecipientType . CC , address ) ; }
everttigchelaar/camel-svn | public void setBCC ( String address ) { recipients . put ( Message . RecipientType . BCC , address ) ; }
everttigchelaar/camel-svn | public Map < Message . RecipientType , String > getRecipients ( ) { return recipients ; }
everttigchelaar/camel-svn | public int getFetchSize ( ) { return fetchSize ; }
everttigchelaar/camel-svn | public void setFetchSize ( int fetchSize ) { this . fetchSize = fetchSize ; }
everttigchelaar/camel-svn | public boolean isDebugMode ( ) { return debugMode ; }
everttigchelaar/camel-svn | public void setDebugMode ( boolean debugMode ) { this . debugMode = debugMode ; }
everttigchelaar/camel-svn | public long getConnectionTimeout ( ) { return connectionTimeout ; }
everttigchelaar/camel-svn | public void setConnectionTimeout ( long connectionTimeout ) { this . connectionTimeout = connectionTimeout ; }
everttigchelaar/camel-svn | public boolean isDummyTrustManager ( ) { return dummyTrustManager ; }
everttigchelaar/camel-svn | public void setDummyTrustManager ( boolean dummyTrustManager ) { this . dummyTrustManager = dummyTrustManager ; }
everttigchelaar/camel-svn | public String getContentType ( ) { return contentType ; }
everttigchelaar/camel-svn | public void setContentType ( String contentType ) { this . contentType = contentType ; }
everttigchelaar/camel-svn | public String getAlternativeBodyHeader ( ) { return alternativeBodyHeader ; }
everttigchelaar/camel-svn | public void setAlternativeBodyHeader ( String alternativeBodyHeader ) { this . alternativeBodyHeader = alternativeBodyHeader ; }
everttigchelaar/camel-svn | public boolean isUseInlineAttachments ( ) { return useInlineAttachments ; }
everttigchelaar/camel-svn | public void setUseInlineAttachments ( boolean useInlineAttachments ) { this . useInlineAttachments = useInlineAttachments ; }
everttigchelaar/camel-svn | public boolean isIgnoreUnsupportedCharset ( ) { return ignoreUnsupportedCharset ; }
everttigchelaar/camel-svn | public void setIgnoreUnsupportedCharset ( boolean ignoreUnsupportedCharset ) { this . ignoreUnsupportedCharset = ignoreUnsupportedCharset ; }
JackSprat/Knifeybot | public String getHost ( ) { return this . host ; }
JackSprat/Knifeybot | public String getHostPortPair ( ) { return this . hostPortPair != null ? this . hostPortPair : this . host + " : " + this . port ; }
JackSprat/Knifeybot | public boolean isProxySet ( ) { return this . proxy != null ; }
JackSprat/Knifeybot | public void setProxy ( MySQLConnection proxy ) { this . proxy = proxy ; this . realProxy = this . proxy instanceof MultiHostMySQLConnection ? ( ( MultiHostMySQLConnection ) proxy ) . getThisAsProxy ( ) : null ; }
JackSprat/Knifeybot | private MySQLConnection getProxy ( ) { return ( this . proxy != null ) ? this . proxy : ( MySQLConnection ) this ; }
JackSprat/Knifeybot | @ Deprecated public MySQLConnection getLoadBalanceSafeProxy ( ) { return getMultiHostSafeProxy ( ) ; }
JackSprat/Knifeybot | public MySQLConnection getMultiHostSafeProxy ( ) { return this . getProxy ( ) ; }
JackSprat/Knifeybot | public Object getConnectionMutex ( ) { return ( this . realProxy != null ) ? this . realProxy : getProxy ( ) ; }
JackSprat/Knifeybot | ExceptionInterceptorChain ( String interceptorClasses ) throws SQLException { this . interceptors = Util . loadExtensions ( ConnectionImpl . this , ConnectionImpl . this . props , interceptorClasses , " Connection . BadExceptionInterceptor " , this ) ; }
JackSprat/Knifeybot | void addRingZero ( ExceptionInterceptor interceptor ) throws SQLException { this . interceptors . add ( 0 , interceptor ) ; }
JackSprat/Knifeybot | public SQLException interceptException ( SQLException sqlEx , Connection conn ) { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { sqlEx = ( ( ExceptionInterceptor ) iter . next ( ) ) . interceptException ( sqlEx , ConnectionImpl . this ) ; } } return sqlEx ; }
JackSprat/Knifeybot | public void destroy ( ) { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( ExceptionInterceptor ) iter . next ( ) ) . destroy ( ) ; } } }
JackSprat/Knifeybot | public void init ( Connection conn , Properties properties ) throws SQLException { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( ExceptionInterceptor ) iter . next ( ) ) . init ( conn , properties ) ; } } }
JackSprat/Knifeybot | public List < Extension > getInterceptors ( ) { return this . interceptors ; }
JackSprat/Knifeybot | CompoundCacheKey ( String partOne , String partTwo ) { this . componentOne = partOne ; this . componentTwo = partTwo ; this . hashCode = ( ( ( this . componentOne != null ) ? this . componentOne : " " ) + this . componentTwo ) . hashCode ( ) ; }
JackSprat/Knifeybot | @ Override public boolean equals ( Object obj ) { if ( obj instanceof CompoundCacheKey ) { CompoundCacheKey another = ( CompoundCacheKey ) obj ; boolean firstPartEqual = false ; if ( this . componentOne == null ) { firstPartEqual = ( another . componentOne == null ) ; } else { firstPartEqual = this . componentOne . equals ( another . componentOne ) ; } return ( firstPartEqual && this . componentTwo . equals ( another . componentTwo ) ) ; } return false ; }
JackSprat/Knifeybot | @ Override public int hashCode ( ) { return this . hashCode ; }
JackSprat/Knifeybot | if ( Util . isJdbc4 ( ) ) { try { JDBC_4_CONNECTION_CTOR = Class . forName ( " com . mysql . jdbc . JDBC4Connection " ) . getConstructor ( new Class [ ] { String . class , Integer . TYPE , Properties . class , String . class , String . class } ) ; } catch ( SecurityException e ) { throw new RuntimeException ( e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } }
JackSprat/Knifeybot | public Timer getCancelTimer ( ) { synchronized ( getConnectionMutex ( ) ) { if ( this . cancelTimer == null ) { boolean createdNamedTimer = false ; try { Constructor < Timer > ctr = Timer . class . getConstructor ( new Class [ ] { String . class , Boolean . TYPE } ) ; this . cancelTimer = ctr . newInstance ( new Object [ ] { " MySQL ▁ Statement ▁ Cancellation ▁ Timer " , Boolean . TRUE } ) ; createdNamedTimer = true ; } catch ( Throwable t ) { createdNamedTimer = false ; } if ( ! createdNamedTimer ) { this . cancelTimer = new Timer ( true ) ; } } return this . cancelTimer ; } }
JackSprat/Knifeybot | protected ConnectionImpl ( ) { }
JackSprat/Knifeybot | public ConnectionImpl ( String hostToConnectTo , int portToConnectTo , Properties info , String databaseToConnectTo , String url ) throws SQLException { this . connectionCreationTimeMillis = System . currentTimeMillis ( ) ; if ( databaseToConnectTo == null ) { databaseToConnectTo = " " ; } this . origHostToConnectTo = hostToConnectTo ; this . origPortToConnectTo = portToConnectTo ; this . origDatabaseToConnectTo = databaseToConnectTo ; try { Blob . class . getMethod ( " truncate " , new Class [ ] { Long . TYPE } ) ; this . isRunningOnJDK13 = false ; } catch ( NoSuchMethodException nsme ) { this . isRunningOnJDK13 = true ; } this . sessionCalendar = new GregorianCalendar ( ) ; this . utcCalendar = new GregorianCalendar ( ) ; this . utcCalendar . setTimeZone ( TimeZone . getTimeZone ( " GMT " ) ) ; this . log = LogFactory . getLogger ( getLogger ( ) , LOGGER_INSTANCE_NAME , getExceptionInterceptor ( ) ) ; if ( NonRegisteringDriver . isHostPropertiesList ( hostToConnectTo ) ) { Properties hostSpecificProps = NonRegisteringDriver . expandHostKeyValues ( hostToConnectTo ) ; Enumeration < ? > propertyNames = hostSpecificProps . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String propertyName = propertyNames . nextElement ( ) . toString ( ) ; String propertyValue = hostSpecificProps . getProperty ( propertyName ) ; info . setProperty ( propertyName , propertyValue ) ; } } else { if ( hostToConnectTo == null ) { this . host = " localhost " ; this . hostPortPair = this . host + " : " + portToConnectTo ; } else { this . host = hostToConnectTo ; if ( hostToConnectTo . indexOf ( " : " ) == - 1 ) { this . hostPortPair = this . host + " : " + portToConnectTo ; } else { this . hostPortPair = this . host ; } } } this . port = portToConnectTo ; this . database = databaseToConnectTo ; this . myURL = url ; this . user = info . getProperty ( NonRegisteringDriver . USER_PROPERTY_KEY ) ; this . password = info . getProperty ( NonRegisteringDriver . PASSWORD_PROPERTY_KEY ) ; if ( ( this . user == null ) || this . user . equals ( " " ) ) { this . user = " " ; } if ( this . password == null ) { this . password = " " ; } this . props = info ; initializeDriverProperties ( info ) ; this . defaultTimeZone = TimeUtil . getDefaultTimeZone ( getCacheDefaultTimezone ( ) ) ; this . isClientTzUTC = ! this . defaultTimeZone . useDaylightTime ( ) && this . defaultTimeZone . getRawOffset ( ) == 0 ; if ( getUseUsageAdvisor ( ) ) { this . pointOfOrigin = LogUtils . findCallingClassAndMethod ( new Throwable ( ) ) ; } else { this . pointOfOrigin = " " ; } try { this . dbmd = getMetaData ( false , false ) ; initializeSafeStatementInterceptors ( ) ; createNewIO ( false ) ; unSafeStatementInterceptors ( ) ; } catch ( SQLException ex ) { cleanup ( ex ) ; throw ex ; } catch ( Exception ex ) { cleanup ( ex ) ; StringBuilder mesg = new StringBuilder ( 128 ) ; if ( ! getParanoid ( ) ) { mesg . append ( " Cannot ▁ connect ▁ to ▁ MySQL ▁ server ▁ on ▁ " ) ; mesg . append ( this . host ) ; mesg . append ( " : " ) ; mesg . append ( this . port ) ; mesg . append ( " . \n \n " ) ; mesg . append ( " Make ▁ sure ▁ that ▁ there ▁ is ▁ a ▁ MySQL ▁ server ▁ " ) ; mesg . append ( " running ▁ on ▁ the ▁ machine / port ▁ you ▁ are ▁ trying ▁ " ) ; mesg . append ( " to ▁ connect ▁ to ▁ and ▁ that ▁ the ▁ machine ▁ this ▁ software ▁ is ▁ running ▁ on ▁ " ) ; mesg . append ( " is ▁ able ▁ to ▁ connect ▁ to ▁ this ▁ host / port ▁ ( i . e . ▁ not ▁ firewalled ) . ▁ " ) ; mesg . append ( " Also ▁ make ▁ sure ▁ that ▁ the ▁ server ▁ has ▁ not ▁ been ▁ started ▁ with ▁ the ▁ - - skip - networking ▁ " ) ; mesg . append ( " flag . \n \n " ) ; } else { mesg . append ( " Unable ▁ to ▁ connect ▁ to ▁ database . " ) ; } SQLException sqlEx = SQLError . createSQLException ( mesg . toString ( ) , SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } NonRegisteringDriver . trackConnection ( this ) ; }
JackSprat/Knifeybot | public void unSafeStatementInterceptors ( ) throws SQLException { ArrayList < StatementInterceptorV2 > unSafedStatementInterceptors = new ArrayList < StatementInterceptorV2 > ( this . statementInterceptors . size ( ) ) ; for ( int i = 0 ; i < this . statementInterceptors . size ( ) ; i ++ ) { NoSubInterceptorWrapper wrappedInterceptor = ( NoSubInterceptorWrapper ) this . statementInterceptors . get ( i ) ; unSafedStatementInterceptors . add ( wrappedInterceptor . getUnderlyingInterceptor ( ) ) ; } this . statementInterceptors = unSafedStatementInterceptors ; if ( this . io != null ) { this . io . setStatementInterceptors ( this . statementInterceptors ) ; } }
JackSprat/Knifeybot | public void initializeSafeStatementInterceptors ( ) throws SQLException { this . isClosed = false ; List < Extension > unwrappedInterceptors = Util . loadExtensions ( this , this . props , getStatementInterceptors ( ) , " MysqlIo . BadStatementInterceptor " , getExceptionInterceptor ( ) ) ; this . statementInterceptors = new ArrayList < StatementInterceptorV2 > ( unwrappedInterceptors . size ( ) ) ; for ( int i = 0 ; i < unwrappedInterceptors . size ( ) ; i ++ ) { Extension interceptor = unwrappedInterceptors . get ( i ) ; if ( interceptor instanceof StatementInterceptor ) { if ( ReflectiveStatementInterceptorAdapter . getV2PostProcessMethod ( interceptor . getClass ( ) ) != null ) { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( new ReflectiveStatementInterceptorAdapter ( ( StatementInterceptor ) interceptor ) ) ) ; } else { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( new V1toV2StatementInterceptorAdapter ( ( StatementInterceptor ) interceptor ) ) ) ; } } else { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( ( StatementInterceptorV2 ) interceptor ) ) ; } } }
JackSprat/Knifeybot | public List < StatementInterceptorV2 > getStatementInterceptorsInstances ( ) { return this . statementInterceptors ; }
JackSprat/Knifeybot | private void addToHistogram ( int [ ] histogramCounts , long [ ] histogramBreakpoints , long value , int numberOfTimes , long currentLowerBound , long currentUpperBound ) { if ( histogramCounts == null ) { createInitialHistogram ( histogramBreakpoints , currentLowerBound , currentUpperBound ) ; } else { for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { if ( histogramBreakpoints [ i ] >= value ) { histogramCounts [ i ] += numberOfTimes ; break ; } } } }
JackSprat/Knifeybot | private void addToPerformanceHistogram ( long value , int numberOfTimes ) { checkAndCreatePerformanceHistogram ( ) ; addToHistogram ( this . perfMetricsHistCounts , this . perfMetricsHistBreakpoints , value , numberOfTimes , this . shortestQueryTimeMs == Long . MAX_VALUE ? 0 : this . shortestQueryTimeMs , this . longestQueryTimeMs ) ; }
JackSprat/Knifeybot | private void addToTablesAccessedHistogram ( long value , int numberOfTimes ) { checkAndCreateTablesAccessedHistogram ( ) ; addToHistogram ( this . numTablesMetricsHistCounts , this . numTablesMetricsHistBreakpoints , value , numberOfTimes , this . minimumNumberTablesAccessed == Long . MAX_VALUE ? 0 : this . minimumNumberTablesAccessed , this . maximumNumberTablesAccessed ) ; }
JackSprat/Knifeybot | private void buildCollationMapping ( ) throws SQLException { Map < Integer , String > indexToCharset = null ; Map < Number , String > sortedCollationMap = null ; Map < Integer , String > customCharset = null ; Map < String , Integer > customMblen = null ; if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { indexToCharset = dynamicIndexToCharsetMapByUrl . get ( getURL ( ) ) ; sortedCollationMap = dynamicIndexToCollationMapByUrl . get ( getURL ( ) ) ; customCharset = customIndexToCharsetMapByUrl . get ( getURL ( ) ) ; customMblen = customCharsetToMblenMapByUrl . get ( getURL ( ) ) ; } } if ( indexToCharset == null ) { indexToCharset = new HashMap < Integer , String > ( ) ; if ( versionMeetsMinimum ( 4 , 1 , 0 ) && getDetectCustomCollations ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet results = null ; try { sortedCollationMap = new TreeMap < Number , String > ( ) ; customCharset = new HashMap < Integer , String > ( ) ; customMblen = new HashMap < String , Integer > ( ) ; stmt = getMetadataSafeStatement ( ) ; try { results = stmt . executeQuery ( " SHOW ▁ COLLATION " ) ; if ( versionMeetsMinimum ( 5 , 0 , 0 ) ) { Util . resultSetToMap ( sortedCollationMap , results , 3 , 2 ) ; } else { while ( results . next ( ) ) { sortedCollationMap . put ( results . getLong ( 3 ) , results . getString ( 2 ) ) ; } } } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } for ( Iterator < Map . Entry < Number , String > > indexIter = sortedCollationMap . entrySet ( ) . iterator ( ) ; indexIter . hasNext ( ) ; ) { Map . Entry < Number , String > indexEntry = indexIter . next ( ) ; int collationIndex = indexEntry . getKey ( ) . intValue ( ) ; String charsetName = indexEntry . getValue ( ) ; indexToCharset . put ( collationIndex , charsetName ) ; if ( collationIndex >= CharsetMapping . MAP_SIZE || ! charsetName . equals ( CharsetMapping . getMysqlCharsetNameForCollationIndex ( collationIndex ) ) ) { customCharset . put ( collationIndex , charsetName ) ; } if ( ! CharsetMapping . CHARSET_NAME_TO_CHARSET . containsKey ( charsetName ) ) { customMblen . put ( charsetName , null ) ; } } if ( customMblen . size ( ) > 0 ) { try { results = stmt . executeQuery ( " SHOW ▁ CHARACTER ▁ SET " ) ; while ( results . next ( ) ) { String charsetName = results . getString ( " Charset " ) ; if ( customMblen . containsKey ( charsetName ) ) { customMblen . put ( charsetName , results . getInt ( " Maxlen " ) ) ; } } } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { dynamicIndexToCharsetMapByUrl . put ( getURL ( ) , indexToCharset ) ; dynamicIndexToCollationMapByUrl . put ( getURL ( ) , sortedCollationMap ) ; customIndexToCharsetMapByUrl . put ( getURL ( ) , customCharset ) ; customCharsetToMblenMapByUrl . put ( getURL ( ) , customMblen ) ; } } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } finally { if ( results != null ) { try { results . close ( ) ; } catch ( java . sql . SQLException sqlE ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( java . sql . SQLException sqlE ) { } } } } else { for ( int i = 1 ; i < CharsetMapping . MAP_SIZE ; i ++ ) { indexToCharset . put ( i , CharsetMapping . getMysqlCharsetNameForCollationIndex ( i ) ) ; } if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { dynamicIndexToCharsetMapByUrl . put ( getURL ( ) , indexToCharset ) ; } } } } this . indexToMysqlCharset = Collections . unmodifiableMap ( indexToCharset ) ; if ( customCharset != null ) { this . indexToCustomMysqlCharset = Collections . unmodifiableMap ( customCharset ) ; } if ( customMblen != null ) { this . mysqlCharsetToCustomMblen = Collections . unmodifiableMap ( customMblen ) ; } }
JackSprat/Knifeybot | private boolean canHandleAsServerPreparedStatement ( String sql ) throws SQLException { if ( sql == null || sql . length ( ) == 0 ) { return true ; } if ( ! this . useServerPreparedStmts ) { return false ; } if ( getCachePreparedStatements ( ) ) { synchronized ( this . serverSideStatementCheckCache ) { Boolean flag = ( Boolean ) this . serverSideStatementCheckCache . get ( sql ) ; if ( flag != null ) { return flag . booleanValue ( ) ; } boolean canHandle = canHandleAsServerPreparedStatementNoCache ( sql ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { this . serverSideStatementCheckCache . put ( sql , canHandle ? Boolean . TRUE : Boolean . FALSE ) ; } return canHandle ; } } return canHandleAsServerPreparedStatementNoCache ( sql ) ; }
JackSprat/Knifeybot | private boolean canHandleAsServerPreparedStatementNoCache ( String sql ) throws SQLException { if ( StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " CALL " ) ) { return false ; } boolean canHandleAsStatement = true ; if ( ! versionMeetsMinimum ( 5 , 0 , 7 ) && ( StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " SELECT " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " DELETE " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " INSERT " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " UPDATE " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " REPLACE " ) ) ) { int currentPos = 0 ; int statementLength = sql . length ( ) ; int lastPosToLook = statementLength - 7 ; boolean allowBackslashEscapes = ! this . noBackslashEscapes ; String quoteChar = this . useAnsiQuotes ? " \" " : " ' " ; boolean foundLimitWithPlaceholder = false ; while ( currentPos < lastPosToLook ) { int limitStart = StringUtils . indexOfIgnoreCase ( currentPos , sql , " LIMIT ▁ " , quoteChar , quoteChar , allowBackslashEscapes ? StringUtils . SEARCH_MODE__ALL : StringUtils . SEARCH_MODE__MRK_COM_WS ) ; if ( limitStart == - 1 ) { break ; } currentPos = limitStart + 7 ; while ( currentPos < statementLength ) { char c = sql . charAt ( currentPos ) ; if ( ! Character . isDigit ( c ) && ! Character . isWhitespace ( c ) && c != ' , ' && c != ' ? ' ) { break ; } if ( c == ' ? ' ) { foundLimitWithPlaceholder = true ; break ; } currentPos ++ ; } } canHandleAsStatement = ! foundLimitWithPlaceholder ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " XA ▁ " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " CREATE ▁ TABLE " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " DO " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " SET " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " SHOW ▁ WARNINGS " ) && versionMeetsMinimum ( 5 , 7 , 2 ) ) { canHandleAsStatement = false ; } return canHandleAsStatement ; }
JackSprat/Knifeybot | public void changeUser ( String userName , String newPassword ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( ( userName == null ) || userName . equals ( " " ) ) { userName = " " ; } if ( newPassword == null ) { newPassword = " " ; } this . sessionMaxRows = - 1 ; try { this . io . changeUser ( userName , newPassword , this . database ) ; } catch ( SQLException ex ) { if ( versionMeetsMinimum ( 5 , 6 , 13 ) && "28000" . equals ( ex . getSQLState ( ) ) ) { cleanup ( ex ) ; } throw ex ; } this . user = userName ; this . password = newPassword ; if ( versionMeetsMinimum ( 4 , 1 , 0 ) ) { configureClientCharacterSet ( true ) ; } setSessionVariables ( ) ; setupServerForTruncationChecks ( ) ; } }
JackSprat/Knifeybot | private boolean characterSetNamesMatches ( String mysqlEncodingName ) { return ( mysqlEncodingName != null && mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ client " ) ) && mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ connection " ) ) ) ; }
JackSprat/Knifeybot | private void checkAndCreatePerformanceHistogram ( ) { if ( this . perfMetricsHistCounts == null ) { this . perfMetricsHistCounts = new int [ HISTOGRAM_BUCKETS ] ; } if ( this . perfMetricsHistBreakpoints == null ) { this . perfMetricsHistBreakpoints = new long [ HISTOGRAM_BUCKETS ] ; } }
JackSprat/Knifeybot | private void checkAndCreateTablesAccessedHistogram ( ) { if ( this . numTablesMetricsHistCounts == null ) { this . numTablesMetricsHistCounts = new int [ HISTOGRAM_BUCKETS ] ; } if ( this . numTablesMetricsHistBreakpoints == null ) { this . numTablesMetricsHistBreakpoints = new long [ HISTOGRAM_BUCKETS ] ; } }
JackSprat/Knifeybot | public void checkClosed ( ) throws SQLException { if ( this . isClosed ) { throwConnectionClosedException ( ) ; } }
JackSprat/Knifeybot | public void throwConnectionClosedException ( ) throws SQLException { SQLException ex = SQLError . createSQLException ( " No ▁ operations ▁ allowed ▁ after ▁ connection ▁ closed . " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; if ( this . forceClosedReason != null ) { ex . initCause ( this . forceClosedReason ) ; } throw ex ; }
JackSprat/Knifeybot | private void checkServerEncoding ( ) throws SQLException { if ( getUseUnicode ( ) && ( getEncoding ( ) != null ) ) { return ; } String serverCharset = this . serverVariables . get ( " character _ set " ) ; if ( serverCharset == null ) { serverCharset = this . serverVariables . get ( " character _ set _ server " ) ; } String mappedServerEncoding = null ; if ( serverCharset != null ) { try { mappedServerEncoding = CharsetMapping . getJavaEncodingForMysqlCharset ( serverCharset ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } } if ( ! getUseUnicode ( ) && ( mappedServerEncoding != null ) ) { SingleByteCharsetConverter converter = getCharsetConverter ( mappedServerEncoding ) ; if ( converter != null ) { setUseUnicode ( true ) ; setEncoding ( mappedServerEncoding ) ; return ; } } if ( serverCharset != null ) { if ( mappedServerEncoding == null ) { if ( Character . isLowerCase ( serverCharset . charAt ( 0 ) ) ) { char [ ] ach = serverCharset . toCharArray ( ) ; ach [ 0 ] = Character . toUpperCase ( serverCharset . charAt ( 0 ) ) ; setEncoding ( new String ( ach ) ) ; } } if ( mappedServerEncoding == null ) { throw SQLError . createSQLException ( " Unknown ▁ character ▁ encoding ▁ on ▁ server ▁ ' " + serverCharset + " ' , ▁ use ▁ ' characterEncoding = ' ▁ property ▁ " + " ▁ to ▁ provide ▁ correct ▁ mapping " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } try { StringUtils . getBytes ( " abc " , mappedServerEncoding ) ; setEncoding ( mappedServerEncoding ) ; setUseUnicode ( true ) ; } catch ( UnsupportedEncodingException UE ) { throw SQLError . createSQLException ( " The ▁ driver ▁ can ▁ not ▁ map ▁ the ▁ character ▁ encoding ▁ ' " + getEncoding ( ) + " ' ▁ that ▁ your ▁ server ▁ is ▁ using ▁ " + " to ▁ a ▁ character ▁ encoding ▁ your ▁ JVM ▁ understands . ▁ You ▁ can ▁ specify ▁ this ▁ mapping ▁ manually ▁ by ▁ adding ▁ \" useUnicode = true \" ▁ " + " as ▁ well ▁ as ▁ \" characterEncoding = [ an _ encoding _ your _ jvm _ understands ] \" ▁ to ▁ your ▁ JDBC ▁ URL . " , "0S100" , getExceptionInterceptor ( ) ) ; } } }
JackSprat/Knifeybot | private void checkTransactionIsolationLevel ( ) throws SQLException { String txIsolationName = null ; if ( versionMeetsMinimum ( 4 , 0 , 3 ) ) { txIsolationName = " tx _ isolation " ; } else { txIsolationName = " transaction _ isolation " ; } String s = this . serverVariables . get ( txIsolationName ) ; if ( s != null ) { Integer intTI = mapTransIsolationNameToValue . get ( s ) ; if ( intTI != null ) { this . isolationLevel = intTI . intValue ( ) ; } } }
JackSprat/Knifeybot | public void abortInternal ( ) throws SQLException { if ( this . io != null ) { try { this . io . forceClose ( ) ; this . io . releaseResources ( ) ; } catch ( Throwable t ) { } this . io = null ; } this . isClosed = true ; }
JackSprat/Knifeybot | private void cleanup ( Throwable whyCleanedUp ) { try { if ( this . io != null ) { if ( isClosed ( ) ) { this . io . forceClose ( ) ; } else { realClose ( false , false , false , whyCleanedUp ) ; } } } catch ( SQLException sqlEx ) { } this . isClosed = true ; }
JackSprat/Knifeybot | @ Deprecated public void clearHasTriedMaster ( ) { this . hasTriedMasterFlag = false ; }
JackSprat/Knifeybot | public void clearWarnings ( ) throws SQLException { }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql ) throws SQLException { return clientPrepareStatement ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { java . sql . PreparedStatement pStmt = clientPrepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { return clientPrepareStatement ( sql , resultSetType , resultSetConcurrency , true ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , boolean processEscapeCodesIfNeeded ) throws SQLException { checkClosed ( ) ; String nativeSql = processEscapeCodesIfNeeded && getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; PreparedStatement pStmt = null ; if ( getCachePreparedStatements ( ) ) { PreparedStatement . ParseInfo pStmtInfo = this . cachedPreparedStatementParams . get ( nativeSql ) ; if ( pStmtInfo == null ) { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database ) ; this . cachedPreparedStatementParams . put ( nativeSql , pStmt . getParseInfo ( ) ) ; } else { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , pStmtInfo ) ; } } else { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database ) ; } pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) clientPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) clientPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return clientPrepareStatement ( sql , resultSetType , resultSetConcurrency , true ) ; }
JackSprat/Knifeybot | public void close ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . close ( ) ; } } . doForAll ( ) ; } realClose ( true , true , false , null ) ; } }
JackSprat/Knifeybot | private void closeAllOpenStatements ( ) throws SQLException { SQLException postponedException = null ; for ( Statement stmt : this . openStatements ) { try { ( ( StatementImpl ) stmt ) . realClose ( false , true ) ; } catch ( SQLException sqlEx ) { postponedException = sqlEx ; } } if ( postponedException != null ) { throw postponedException ; } }
JackSprat/Knifeybot | private void closeStatement ( java . sql . Statement stmt ) { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlEx ) { } stmt = null ; } }
JackSprat/Knifeybot | public void commit ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . commit ( ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( this . autoCommit && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ call ▁ commit ▁ when ▁ autocommit = true " , getExceptionInterceptor ( ) ) ; } else if ( this . transactionsSupported ) { if ( getUseLocalTransactionState ( ) && versionMeetsMinimum ( 5 , 0 , 0 ) ) { if ( ! this . io . inTransactionOnServer ( ) ) { return ; } } execSQL ( null , " commit " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } catch ( SQLException sqlException ) { if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlException . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ commit ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlException ; } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } return ; }
JackSprat/Knifeybot | private void configureCharsetProperties ( ) throws SQLException { if ( getEncoding ( ) != null ) { try { String testString = " abc " ; StringUtils . getBytes ( testString , getEncoding ( ) ) ; } catch ( UnsupportedEncodingException UE ) { String oldEncoding = getEncoding ( ) ; try { setEncoding ( CharsetMapping . getJavaEncodingForMysqlCharset ( oldEncoding ) ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( getEncoding ( ) == null ) { throw SQLError . createSQLException ( " Java ▁ does ▁ not ▁ support ▁ the ▁ MySQL ▁ character ▁ encoding ▁ ' " + oldEncoding + " ' . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } try { String testString = " abc " ; StringUtils . getBytes ( testString , getEncoding ( ) ) ; } catch ( UnsupportedEncodingException encodingEx ) { throw SQLError . createSQLException ( " Unsupported ▁ character ▁ encoding ▁ ' " + getEncoding ( ) + " ' . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } } } }
JackSprat/Knifeybot | private boolean configureClientCharacterSet ( boolean dontCheckServerMatch ) throws SQLException { String realJavaEncoding = getEncoding ( ) ; boolean characterSetAlreadyConfigured = false ; try { if ( versionMeetsMinimum ( 4 , 1 , 0 ) ) { characterSetAlreadyConfigured = true ; setUseUnicode ( true ) ; configureCharsetProperties ( ) ; realJavaEncoding = getEncoding ( ) ; try { if ( this . props != null && this . props . getProperty ( " com . mysql . jdbc . faultInjection . serverCharsetIndex " ) != null ) { this . io . serverCharsetIndex = Integer . parseInt ( this . props . getProperty ( " com . mysql . jdbc . faultInjection . serverCharsetIndex " ) ) ; } String serverEncodingToSet = CharsetMapping . getJavaEncodingForCollationIndex ( this . io . serverCharsetIndex ) ; if ( serverEncodingToSet == null || serverEncodingToSet . length ( ) == 0 ) { if ( realJavaEncoding != null ) { setEncoding ( realJavaEncoding ) ; } else { throw SQLError . createSQLException ( " Unknown ▁ initial ▁ character ▁ set ▁ index ▁ ' " + this . io . serverCharsetIndex + " ' ▁ received ▁ from ▁ server . ▁ Initial ▁ client ▁ character ▁ set ▁ can ▁ be ▁ forced ▁ via ▁ the ▁ ' characterEncoding ' ▁ property . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } if ( versionMeetsMinimum ( 4 , 1 , 0 ) && " ISO8859_1" . equalsIgnoreCase ( serverEncodingToSet ) ) { serverEncodingToSet = " Cp1252" ; } if ( " UnicodeBig " . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 16" . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 16LE " . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 32" . equalsIgnoreCase ( serverEncodingToSet ) ) { serverEncodingToSet = " UTF - 8" ; } setEncoding ( serverEncodingToSet ) ; } catch ( ArrayIndexOutOfBoundsException outOfBoundsEx ) { if ( realJavaEncoding != null ) { setEncoding ( realJavaEncoding ) ; } else { throw SQLError . createSQLException ( " Unknown ▁ initial ▁ character ▁ set ▁ index ▁ ' " + this . io . serverCharsetIndex + " ' ▁ received ▁ from ▁ server . ▁ Initial ▁ client ▁ character ▁ set ▁ can ▁ be ▁ forced ▁ via ▁ the ▁ ' characterEncoding ' ▁ property . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( getEncoding ( ) == null ) { setEncoding ( " ISO8859_1" ) ; } if ( getUseUnicode ( ) ) { if ( realJavaEncoding != null ) { if ( realJavaEncoding . equalsIgnoreCase ( " UTF - 8" ) || realJavaEncoding . equalsIgnoreCase ( " UTF8" ) ) { boolean utf8mb4Supported = versionMeetsMinimum ( 5 , 5 , 2 ) ; boolean useutf8mb4 = utf8mb4Supported && ( CharsetMapping . UTF8MB4_INDEXES . contains ( this . io . serverCharsetIndex ) ) ; if ( ! getUseOldUTF8Behavior ( ) ) { if ( dontCheckServerMatch || ! characterSetNamesMatches ( " utf8" ) || ( utf8mb4Supported && ! characterSetNamesMatches ( " utf8mb4" ) ) ) { execSQL ( null , " SET ▁ NAMES ▁ " + ( useutf8mb4 ? " utf8mb4" : " utf8" ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , useutf8mb4 ? " utf8mb4" : " utf8" ) ; this . serverVariables . put ( " character _ set _ connection " , useutf8mb4 ? " utf8mb4" : " utf8" ) ; } } else { execSQL ( null , " SET ▁ NAMES ▁ latin1" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , " latin1" ) ; this . serverVariables . put ( " character _ set _ connection " , " latin1" ) ; } setEncoding ( realJavaEncoding ) ; } else { String mysqlCharsetName = CharsetMapping . getMysqlCharsetForJavaEncoding ( realJavaEncoding . toUpperCase ( Locale . ENGLISH ) , this ) ; if ( mysqlCharsetName != null ) { if ( dontCheckServerMatch || ! characterSetNamesMatches ( mysqlCharsetName ) ) { execSQL ( null , " SET ▁ NAMES ▁ " + mysqlCharsetName , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , mysqlCharsetName ) ; this . serverVariables . put ( " character _ set _ connection " , mysqlCharsetName ) ; } } setEncoding ( realJavaEncoding ) ; } } else if ( getEncoding ( ) != null ) { String mysqlCharsetName = getServerCharset ( ) ; if ( getUseOldUTF8Behavior ( ) ) { mysqlCharsetName = " latin1" ; } boolean ucs2 = false ; if ( " ucs2" . equalsIgnoreCase ( mysqlCharsetName ) || " utf16" . equalsIgnoreCase ( mysqlCharsetName ) || " utf16le " . equalsIgnoreCase ( mysqlCharsetName ) || " utf32" . equalsIgnoreCase ( mysqlCharsetName ) ) { mysqlCharsetName = " utf8" ; ucs2 = true ; if ( getCharacterSetResults ( ) == null ) { setCharacterSetResults ( " UTF - 8" ) ; } } if ( dontCheckServerMatch || ! characterSetNamesMatches ( mysqlCharsetName ) || ucs2 ) { try { execSQL ( null , " SET ▁ NAMES ▁ " + mysqlCharsetName , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , mysqlCharsetName ) ; this . serverVariables . put ( " character _ set _ connection " , mysqlCharsetName ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } realJavaEncoding = getEncoding ( ) ; } } String onServer = null ; boolean isNullOnServer = false ; if ( this . serverVariables != null ) { onServer = this . serverVariables . get ( " character _ set _ results " ) ; isNullOnServer = onServer == null || " NULL " . equalsIgnoreCase ( onServer ) || onServer . length ( ) == 0 ; } if ( getCharacterSetResults ( ) == null ) { if ( ! isNullOnServer ) { try { execSQL ( null , " SET ▁ character _ set _ results ▁ = ▁ NULL " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , null ) ; } else { this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , onServer ) ; } } else { if ( getUseOldUTF8Behavior ( ) ) { try { execSQL ( null , " SET ▁ NAMES ▁ latin1" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , " latin1" ) ; this . serverVariables . put ( " character _ set _ connection " , " latin1" ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } String charsetResults = getCharacterSetResults ( ) ; String mysqlEncodingName = null ; if ( " UTF - 8" . equalsIgnoreCase ( charsetResults ) || " UTF8" . equalsIgnoreCase ( charsetResults ) ) { mysqlEncodingName = " utf8" ; } else if ( " null " . equalsIgnoreCase ( charsetResults ) ) { mysqlEncodingName = " NULL " ; } else { mysqlEncodingName = CharsetMapping . getMysqlCharsetForJavaEncoding ( charsetResults . toUpperCase ( Locale . ENGLISH ) , this ) ; } if ( mysqlEncodingName == null ) { throw SQLError . createSQLException ( " Can ' t ▁ map ▁ " + charsetResults + " ▁ given ▁ for ▁ characterSetResults ▁ to ▁ a ▁ supported ▁ MySQL ▁ encoding . " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } if ( ! mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ results " ) ) ) { StringBuilder setBuf = new StringBuilder ( " SET ▁ character _ set _ results ▁ = ▁ " . length ( ) + mysqlEncodingName . length ( ) ) ; setBuf . append ( " SET ▁ character _ set _ results ▁ = ▁ " ) . append ( mysqlEncodingName ) ; try { execSQL ( null , setBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , mysqlEncodingName ) ; if ( versionMeetsMinimum ( 5 , 5 , 0 ) ) { this . errorMessageEncoding = charsetResults ; } } else { this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , onServer ) ; } } if ( getConnectionCollation ( ) != null ) { StringBuilder setBuf = new StringBuilder ( " SET ▁ collation _ connection ▁ = ▁ " . length ( ) + getConnectionCollation ( ) . length ( ) ) ; setBuf . append ( " SET ▁ collation _ connection ▁ = ▁ " ) . append ( getConnectionCollation ( ) ) ; try { execSQL ( null , setBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } } else { realJavaEncoding = getEncoding ( ) ; } } finally { setEncoding ( realJavaEncoding ) ; } try { CharsetEncoder enc = Charset . forName ( getEncoding ( ) ) . newEncoder ( ) ; CharBuffer cbuf = CharBuffer . allocate ( 1 ) ; ByteBuffer bbuf = ByteBuffer . allocate ( 1 ) ; cbuf . put ( " \u00a5" ) ; cbuf . position ( 0 ) ; enc . encode ( cbuf , bbuf , true ) ; if ( bbuf . get ( 0 ) == ' \ \' ) { this . requiresEscapingEncoder = true ; } else { cbuf . clear ( ) ; bbuf . clear ( ) ; cbuf . put ( " \u20a9" ) ; cbuf . position ( 0 ) ; enc . encode ( cbuf , bbuf , true ) ; if ( bbuf . get ( 0 ) == ' \ \' ) { this . requiresEscapingEncoder = true ; } } } catch ( java . nio . charset . UnsupportedCharsetException ucex ) { try { byte bbuf [ ] = StringUtils . getBytes ( " \u00a5" , getEncoding ( ) ) ; if ( bbuf [ 0 ] == ' \ \' ) { this . requiresEscapingEncoder = true ; } else { bbuf = StringUtils . getBytes ( " \u20a9" , getEncoding ( ) ) ; if ( bbuf [ 0 ] == ' \ \' ) { this . requiresEscapingEncoder = true ; } } } catch ( UnsupportedEncodingException ueex ) { throw SQLError . createSQLException ( " Unable ▁ to ▁ use ▁ encoding : ▁ " + getEncoding ( ) , SQLError . SQL_STATE_GENERAL_ERROR , ueex , getExceptionInterceptor ( ) ) ; } } return characterSetAlreadyConfigured ; }
JackSprat/Knifeybot | private void configureTimezone ( ) throws SQLException { String configuredTimeZoneOnServer = this . serverVariables . get ( " timezone " ) ; if ( configuredTimeZoneOnServer == null ) { configuredTimeZoneOnServer = this . serverVariables . get ( " time _ zone " ) ; if ( " SYSTEM " . equalsIgnoreCase ( configuredTimeZoneOnServer ) ) { configuredTimeZoneOnServer = this . serverVariables . get ( " system _ time _ zone " ) ; } } String canonicalTimezone = getServerTimezone ( ) ; if ( ( getUseTimezone ( ) || ! getUseLegacyDatetimeCode ( ) ) && configuredTimeZoneOnServer != null ) { if ( canonicalTimezone == null || StringUtils . isEmptyOrWhitespaceOnly ( canonicalTimezone ) ) { try { canonicalTimezone = TimeUtil . getCanonicalTimezone ( configuredTimeZoneOnServer , getExceptionInterceptor ( ) ) ; } catch ( IllegalArgumentException iae ) { throw SQLError . createSQLException ( iae . getMessage ( ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } } if ( canonicalTimezone != null && canonicalTimezone . length ( ) > 0 ) { this . serverTimezoneTZ = TimeZone . getTimeZone ( canonicalTimezone ) ; if ( ! canonicalTimezone . equalsIgnoreCase ( " GMT " ) && this . serverTimezoneTZ . getID ( ) . equals ( " GMT " ) ) { throw SQLError . createSQLException ( " No ▁ timezone ▁ mapping ▁ entry ▁ for ▁ ' " + canonicalTimezone + " ' " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } this . isServerTzUTC = ! this . serverTimezoneTZ . useDaylightTime ( ) && this . serverTimezoneTZ . getRawOffset ( ) == 0 ; } }
JackSprat/Knifeybot | private void createInitialHistogram ( long [ ] breakpoints , long lowerBound , long upperBound ) { double bucketSize = ( ( ( double ) upperBound - ( double ) lowerBound ) / HISTOGRAM_BUCKETS ) * 1.25 ; if ( bucketSize < 1 ) { bucketSize = 1 ; } for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { breakpoints [ i ] = lowerBound ; lowerBound += bucketSize ; } }
JackSprat/Knifeybot | public void createNewIO ( boolean isForReconnect ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { Properties mergedProps = exposeAsProperties ( this . props ) ; if ( ! getHighAvailability ( ) ) { connectOneTryOnly ( isForReconnect , mergedProps ) ; return ; } connectWithRetries ( isForReconnect , mergedProps ) ; } }
JackSprat/Knifeybot | private void connectWithRetries ( boolean isForReconnect , Properties mergedProps ) throws SQLException { double timeout = getInitialTimeout ( ) ; boolean connectionGood = false ; Exception connectionException = null ; for ( int attemptCount = 0 ; ( attemptCount < getMaxReconnects ( ) ) && ! connectionGood ; attemptCount ++ ) { try { if ( this . io != null ) { this . io . forceClose ( ) ; } coreConnect ( mergedProps ) ; pingInternal ( false , 0 ) ; boolean oldAutoCommit ; int oldIsolationLevel ; boolean oldReadOnly ; String oldCatalog ; synchronized ( getConnectionMutex ( ) ) { this . connectionId = this . io . getThreadId ( ) ; this . isClosed = false ; oldAutoCommit = getAutoCommit ( ) ; oldIsolationLevel = this . isolationLevel ; oldReadOnly = isReadOnly ( false ) ; oldCatalog = getCatalog ( ) ; this . io . setStatementInterceptors ( this . statementInterceptors ) ; } initializePropsFromServer ( ) ; if ( isForReconnect ) { setAutoCommit ( oldAutoCommit ) ; if ( this . hasIsolationLevels ) { setTransactionIsolation ( oldIsolationLevel ) ; } setCatalog ( oldCatalog ) ; setReadOnly ( oldReadOnly ) ; } connectionGood = true ; break ; } catch ( Exception EEE ) { connectionException = EEE ; connectionGood = false ; } if ( connectionGood ) { break ; } if ( attemptCount > 0 ) { try { Thread . sleep ( ( long ) timeout * 1000 ) ; } catch ( InterruptedException IE ) { } } } if ( ! connectionGood ) { SQLException chainedEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnableToConnectWithRetries " , new Object [ ] { Integer . valueOf ( getMaxReconnects ( ) ) } ) , SQLError . SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE , getExceptionInterceptor ( ) ) ; chainedEx . initCause ( connectionException ) ; throw chainedEx ; } if ( getParanoid ( ) && ! getHighAvailability ( ) ) { this . password = null ; this . user = null ; } if ( isForReconnect ) { Iterator < Statement > statementIter = this . openStatements . iterator ( ) ; Stack < Statement > serverPreparedStatements = null ; while ( statementIter . hasNext ( ) ) { Statement statementObj = statementIter . next ( ) ; if ( statementObj instanceof ServerPreparedStatement ) { if ( serverPreparedStatements == null ) { serverPreparedStatements = new Stack < Statement > ( ) ; } serverPreparedStatements . add ( statementObj ) ; } } if ( serverPreparedStatements != null ) { while ( ! serverPreparedStatements . isEmpty ( ) ) { ( ( ServerPreparedStatement ) serverPreparedStatements . pop ( ) ) . rePrepare ( ) ; } } } }
JackSprat/Knifeybot | if ( protocol != null ) { if ( " tcp " . equalsIgnoreCase ( protocol ) ) { newHost = normalizeHost ( mergedProps . getProperty ( NonRegisteringDriver . HOST_PROPERTY_KEY ) ) ; newPort = parsePortNumber ( mergedProps . getProperty ( NonRegisteringDriver . PORT_PROPERTY_KEY , "3306" ) ) ; } else if ( " pipe " . equalsIgnoreCase ( protocol ) ) { setSocketFactoryClassName ( NamedPipeSocketFactory . class . getName ( ) ) ; String path = mergedProps . getProperty ( NonRegisteringDriver . PATH_PROPERTY_KEY ) ; if ( path != null ) { mergedProps . setProperty ( NamedPipeSocketFactory . NAMED_PIPE_PROP_NAME , path ) ; } } else { newHost = normalizeHost ( mergedProps . getProperty ( NonRegisteringDriver . HOST_PROPERTY_KEY ) ) ; newPort = parsePortNumber ( mergedProps . getProperty ( NonRegisteringDriver . PORT_PROPERTY_KEY , "3306" ) ) ; } }
JackSprat/Knifeybot | if ( parsedHostPortPair [ NonRegisteringDriver . PORT_NUMBER_INDEX ] != null ) { newPort = parsePortNumber ( parsedHostPortPair [ NonRegisteringDriver . PORT_NUMBER_INDEX ] ) ; }
JackSprat/Knifeybot | if ( versionMeetsMinimum ( 5 , 5 , 0 ) ) { this . errorMessageEncoding = this . io . getEncodingForHandshake ( ) ; }
JackSprat/Knifeybot | private String normalizeHost ( String hostname ) { if ( hostname == null || StringUtils . isEmptyOrWhitespaceOnly ( hostname ) ) { return " localhost " ; } return hostname ; }
JackSprat/Knifeybot | private int parsePortNumber ( String portAsString ) throws SQLException { int portNumber = 3306 ; try { portNumber = Integer . parseInt ( portAsString ) ; } catch ( NumberFormatException nfe ) { throw SQLError . createSQLException ( " Illegal ▁ connection ▁ port ▁ value ▁ ' " + portAsString + " ' " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } return portNumber ; }
JackSprat/Knifeybot | private void connectOneTryOnly ( boolean isForReconnect , Properties mergedProps ) throws SQLException { Exception connectionNotEstablishedBecause = null ; try { coreConnect ( mergedProps ) ; this . connectionId = this . io . getThreadId ( ) ; this . isClosed = false ; boolean oldAutoCommit = getAutoCommit ( ) ; int oldIsolationLevel = this . isolationLevel ; boolean oldReadOnly = isReadOnly ( false ) ; String oldCatalog = getCatalog ( ) ; this . io . setStatementInterceptors ( this . statementInterceptors ) ; initializePropsFromServer ( ) ; if ( isForReconnect ) { setAutoCommit ( oldAutoCommit ) ; if ( this . hasIsolationLevels ) { setTransactionIsolation ( oldIsolationLevel ) ; } setCatalog ( oldCatalog ) ; setReadOnly ( oldReadOnly ) ; } return ; } catch ( Exception EEE ) { if ( EEE instanceof SQLException && ( ( SQLException ) EEE ) . getErrorCode ( ) == MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD && ! getDisconnectOnExpiredPasswords ( ) ) { return ; } if ( this . io != null ) { this . io . forceClose ( ) ; } connectionNotEstablishedBecause = EEE ; if ( EEE instanceof SQLException ) { throw ( SQLException ) EEE ; } SQLException chainedEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnableToConnect " ) , SQLError . SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE , getExceptionInterceptor ( ) ) ; chainedEx . initCause ( connectionNotEstablishedBecause ) ; throw chainedEx ; } }
JackSprat/Knifeybot | private void createPreparedStatementCaches ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { int cacheSize = getPreparedStatementCacheSize ( ) ; try { Class < ? > factoryClass ; factoryClass = Class . forName ( getParseInfoCacheFactory ( ) ) ; @ SuppressWarnings ( " unchecked " ) CacheAdapterFactory < String , ParseInfo > cacheFactory = ( ( CacheAdapterFactory < String , ParseInfo > ) factoryClass . newInstance ( ) ) ; this . cachedPreparedStatementParams = cacheFactory . getInstance ( this , this . myURL , getPreparedStatementCacheSize ( ) , getPreparedStatementCacheSqlLimit ( ) , this . props ) ; } catch ( ClassNotFoundException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantFindCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( InstantiationException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( IllegalAccessException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } if ( getUseServerPreparedStmts ( ) ) { this . serverSideStatementCheckCache = new LRUCache ( cacheSize ) ; this . serverSideStatementCache = new LRUCache ( cacheSize ) { private static final long serialVersionUID = 7692318650375988114L ; @ Override protected boolean removeEldestEntry ( java . util . Map . Entry < Object , Object > eldest ) { if ( this . maxElements <= 1 ) { return false ; } boolean removeIt = super . removeEldestEntry ( eldest ) ; if ( removeIt ) { ServerPreparedStatement ps = ( ServerPreparedStatement ) eldest . getValue ( ) ; ps . isCached = false ; ps . setClosed ( false ) ; try { ps . close ( ) ; } catch ( SQLException sqlEx ) { } } return removeIt ; } } ; } } }
JackSprat/Knifeybot | public java . sql . Statement createStatement ( ) throws SQLException { return createStatement ( DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . Statement createStatement ( int resultSetType , int resultSetConcurrency ) throws SQLException { checkClosed ( ) ; StatementImpl stmt = new StatementImpl ( getMultiHostSafeProxy ( ) , this . database ) ; stmt . setResultSetType ( resultSetType ) ; stmt . setResultSetConcurrency ( resultSetConcurrency ) ; return stmt ; }
JackSprat/Knifeybot | public java . sql . Statement createStatement ( int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return createStatement ( resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public void dumpTestcaseQuery ( String query ) { System . err . println ( query ) ; }
JackSprat/Knifeybot | public Connection duplicate ( ) throws SQLException { return new ConnectionImpl ( this . origHostToConnectTo , this . origPortToConnectTo , this . props , this . origDatabaseToConnectTo , this . myURL ) ; }
JackSprat/Knifeybot | public ResultSetInternalMethods execSQL ( StatementImpl callingStatement , String sql , int maxRows , Buffer packet , int resultSetType , int resultSetConcurrency , boolean streamResults , String catalog , Field [ ] cachedMetadata ) throws SQLException { return execSQL ( callingStatement , sql , maxRows , packet , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata , false ) ; }
JackSprat/Knifeybot | public ResultSetInternalMethods execSQL ( StatementImpl callingStatement , String sql , int maxRows , Buffer packet , int resultSetType , int resultSetConcurrency , boolean streamResults , String catalog , Field [ ] cachedMetadata , boolean isBatch ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { long queryStartTime = 0 ; int endOfQueryPacketPosition = 0 ; if ( packet != null ) { endOfQueryPacketPosition = packet . getPosition ( ) ; } if ( getGatherPerformanceMetrics ( ) ) { queryStartTime = System . currentTimeMillis ( ) ; } this . lastQueryFinishedTime = 0 ; if ( ( getHighAvailability ( ) ) && ( this . autoCommit || getAutoReconnectForPools ( ) ) && this . needsPing && ! isBatch ) { try { pingInternal ( false , 0 ) ; this . needsPing = false ; } catch ( Exception Ex ) { createNewIO ( true ) ; } } try { if ( packet == null ) { String encoding = null ; if ( getUseUnicode ( ) ) { encoding = getEncoding ( ) ; } return this . io . sqlQueryDirect ( callingStatement , sql , encoding , null , maxRows , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata ) ; } return this . io . sqlQueryDirect ( callingStatement , null , null , packet , maxRows , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata ) ; } catch ( java . sql . SQLException sqlE ) { if ( getDumpQueriesOnException ( ) ) { String extractedSql = extractSqlFromPacket ( sql , packet , endOfQueryPacketPosition ) ; StringBuilder messageBuf = new StringBuilder ( extractedSql . length ( ) + 32 ) ; messageBuf . append ( " \n \n Query ▁ being ▁ executed ▁ when ▁ exception ▁ was ▁ thrown : \n " ) ; messageBuf . append ( extractedSql ) ; messageBuf . append ( " \n \n " ) ; sqlE = appendMessageToException ( sqlE , messageBuf . toString ( ) , getExceptionInterceptor ( ) ) ; } if ( ( getHighAvailability ( ) ) ) { this . needsPing = true ; } else { String sqlState = sqlE . getSQLState ( ) ; if ( ( sqlState != null ) && sqlState . equals ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE ) ) { cleanup ( sqlE ) ; } } throw sqlE ; } catch ( Exception ex ) { if ( getHighAvailability ( ) ) { this . needsPing = true ; } else if ( ex instanceof IOException ) { cleanup ( ex ) ; } SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnexpectedException " ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } finally { if ( getMaintainTimeStats ( ) ) { this . lastQueryFinishedTime = System . currentTimeMillis ( ) ; } if ( getGatherPerformanceMetrics ( ) ) { long queryTime = System . currentTimeMillis ( ) - queryStartTime ; registerQueryExecutionTime ( queryTime ) ; } } } }
JackSprat/Knifeybot | public String extractSqlFromPacket ( String possibleSqlQuery , Buffer queryPacket , int endOfQueryPacketPosition ) throws SQLException { String extractedSql = null ; if ( possibleSqlQuery != null ) { if ( possibleSqlQuery . length ( ) > getMaxQuerySizeToLog ( ) ) { StringBuilder truncatedQueryBuf = new StringBuilder ( possibleSqlQuery . substring ( 0 , getMaxQuerySizeToLog ( ) ) ) ; truncatedQueryBuf . append ( Messages . getString ( " MysqlIO . 25" ) ) ; extractedSql = truncatedQueryBuf . toString ( ) ; } else { extractedSql = possibleSqlQuery ; } } if ( extractedSql == null ) { int extractPosition = endOfQueryPacketPosition ; boolean truncated = false ; if ( endOfQueryPacketPosition > getMaxQuerySizeToLog ( ) ) { extractPosition = getMaxQuerySizeToLog ( ) ; truncated = true ; } extractedSql = StringUtils . toString ( queryPacket . getByteBuffer ( ) , 5 , ( extractPosition - 5 ) ) ; if ( truncated ) { extractedSql += Messages . getString ( " MysqlIO . 25" ) ; } } return extractedSql ; }
JackSprat/Knifeybot | public StringBuilder generateConnectionCommentBlock ( StringBuilder buf ) { buf . append ( " /* ▁ conn ▁ id ▁ " ) ; buf . append ( getId ( ) ) ; buf . append ( " ▁ clock : ▁ " ) ; buf . append ( System . currentTimeMillis ( ) ) ; buf . append ( " ▁ */ ▁ " ) ; return buf ; }
JackSprat/Knifeybot | public int getActiveStatementCount ( ) { return this . openStatements . size ( ) ; }
JackSprat/Knifeybot | public boolean getAutoCommit ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { return this . autoCommit ; } }
JackSprat/Knifeybot | public Calendar getCalendarInstanceForSessionOrNew ( ) { if ( getDynamicCalendars ( ) ) { return Calendar . getInstance ( ) ; } return getSessionLockedCalendar ( ) ; }
JackSprat/Knifeybot | public String getCatalog ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { return this . database ; } }
JackSprat/Knifeybot | public String getCharacterSetMetadata ( ) { synchronized ( getConnectionMutex ( ) ) { return this . characterSetMetadata ; } }
JackSprat/Knifeybot | public SingleByteCharsetConverter getCharsetConverter ( String javaEncodingName ) throws SQLException { if ( javaEncodingName == null ) { return null ; } if ( this . usePlatformCharsetConverters ) { return null ; } SingleByteCharsetConverter converter = null ; synchronized ( this . charsetConverterMap ) { Object asObject = this . charsetConverterMap . get ( javaEncodingName ) ; if ( asObject == CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) { return null ; } converter = ( SingleByteCharsetConverter ) asObject ; if ( converter == null ) { try { converter = SingleByteCharsetConverter . getInstance ( javaEncodingName , this ) ; if ( converter == null ) { this . charsetConverterMap . put ( javaEncodingName , CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) ; } else { this . charsetConverterMap . put ( javaEncodingName , converter ) ; } } catch ( UnsupportedEncodingException unsupEncEx ) { this . charsetConverterMap . put ( javaEncodingName , CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) ; converter = null ; } } } return converter ; }
JackSprat/Knifeybot | @ Deprecated public String getCharsetNameForIndex ( int charsetIndex ) throws SQLException { return getEncodingForIndex ( charsetIndex ) ; }
JackSprat/Knifeybot | public String getEncodingForIndex ( int charsetIndex ) throws SQLException { String javaEncoding = null ; if ( getUseOldUTF8Behavior ( ) ) { return getEncoding ( ) ; } if ( charsetIndex != MysqlDefs . NO_CHARSET_INFO ) { try { if ( this . indexToMysqlCharset . size ( ) > 0 ) { javaEncoding = CharsetMapping . getJavaEncodingForMysqlCharset ( this . indexToMysqlCharset . get ( charsetIndex ) , getEncoding ( ) ) ; } if ( javaEncoding == null ) { javaEncoding = CharsetMapping . getJavaEncodingForCollationIndex ( charsetIndex , getEncoding ( ) ) ; } } catch ( ArrayIndexOutOfBoundsException outOfBoundsEx ) { throw SQLError . createSQLException ( " Unknown ▁ character ▁ set ▁ index ▁ for ▁ field ▁ ' " + charsetIndex + " ' ▁ received ▁ from ▁ server . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( javaEncoding == null ) { javaEncoding = getEncoding ( ) ; } } else { javaEncoding = getEncoding ( ) ; } return javaEncoding ; }
JackSprat/Knifeybot | public TimeZone getDefaultTimeZone ( ) { return getCacheDefaultTimezone ( ) ? this . defaultTimeZone : TimeUtil . getDefaultTimeZone ( false ) ; }
JackSprat/Knifeybot | public String getErrorMessageEncoding ( ) { return this . errorMessageEncoding ; }
JackSprat/Knifeybot | public int getHoldability ( ) throws SQLException { return java . sql . ResultSet . CLOSE_CURSORS_AT_COMMIT ; }
JackSprat/Knifeybot | public long getId ( ) { return this . connectionId ; }
JackSprat/Knifeybot | public long getIdleFor ( ) { synchronized ( getConnectionMutex ( ) ) { if ( this . lastQueryFinishedTime == 0 ) { return 0 ; } long now = System . currentTimeMillis ( ) ; long idleTime = now - this . lastQueryFinishedTime ; return idleTime ; } }
JackSprat/Knifeybot | public MysqlIO getIO ( ) throws SQLException { if ( ( this . io == null ) || this . isClosed ) { throw SQLError . createSQLException ( " Operation ▁ not ▁ allowed ▁ on ▁ closed ▁ connection " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } return this . io ; }
JackSprat/Knifeybot | public Log getLog ( ) throws SQLException { return this . log ; }
JackSprat/Knifeybot | public int getMaxBytesPerChar ( String javaCharsetName ) throws SQLException { return getMaxBytesPerChar ( null , javaCharsetName ) ; }
JackSprat/Knifeybot | public int getMaxBytesPerChar ( Integer charsetIndex , String javaCharsetName ) throws SQLException { String charset = null ; int res = 1 ; try { if ( this . indexToCustomMysqlCharset != null ) { charset = this . indexToCustomMysqlCharset . get ( charsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetNameForCollationIndex ( charsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetForJavaEncoding ( javaCharsetName , this ) ; } Integer mblen = null ; if ( this . mysqlCharsetToCustomMblen != null ) { mblen = this . mysqlCharsetToCustomMblen . get ( charset ) ; } if ( mblen == null ) { mblen = CharsetMapping . getMblen ( charset ) ; } if ( mblen != null ) { res = mblen . intValue ( ) ; } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } return res ; }
JackSprat/Knifeybot | public java . sql . DatabaseMetaData getMetaData ( ) throws SQLException { return getMetaData ( true , true ) ; }
JackSprat/Knifeybot | private java . sql . DatabaseMetaData getMetaData ( boolean checkClosed , boolean checkForInfoSchema ) throws SQLException { if ( checkClosed ) { checkClosed ( ) ; } return com . mysql . jdbc . DatabaseMetaData . getInstance ( getMultiHostSafeProxy ( ) , this . database , checkForInfoSchema ) ; }
JackSprat/Knifeybot | public java . sql . Statement getMetadataSafeStatement ( ) throws SQLException { java . sql . Statement stmt = createStatement ( ) ; if ( stmt . getMaxRows ( ) != 0 ) { stmt . setMaxRows ( 0 ) ; } stmt . setEscapeProcessing ( false ) ; if ( stmt . getFetchSize ( ) != 0 ) { stmt . setFetchSize ( 0 ) ; } return stmt ; }
JackSprat/Knifeybot | public int getNetBufferLength ( ) { return this . netBufferLength ; }
JackSprat/Knifeybot | @ Deprecated public String getServerCharacterEncoding ( ) { return getServerCharset ( ) ; }
JackSprat/Knifeybot | public String getServerCharset ( ) { if ( this . io . versionMeetsMinimum ( 4 , 1 , 0 ) ) { String charset = null ; if ( this . indexToCustomMysqlCharset != null ) { charset = this . indexToCustomMysqlCharset . get ( this . io . serverCharsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetNameForCollationIndex ( this . io . serverCharsetIndex ) ; } return charset != null ? charset : this . serverVariables . get ( " character _ set _ server " ) ; } return this . serverVariables . get ( " character _ set " ) ; }
JackSprat/Knifeybot | public int getServerMajorVersion ( ) { return this . io . getServerMajorVersion ( ) ; }
JackSprat/Knifeybot | public int getServerMinorVersion ( ) { return this . io . getServerMinorVersion ( ) ; }
JackSprat/Knifeybot | public int getServerSubMinorVersion ( ) { return this . io . getServerSubMinorVersion ( ) ; }
JackSprat/Knifeybot | public TimeZone getServerTimezoneTZ ( ) { return this . serverTimezoneTZ ; }
JackSprat/Knifeybot | public String getServerVariable ( String variableName ) { if ( this . serverVariables != null ) { return this . serverVariables . get ( variableName ) ; } return null ; }
JackSprat/Knifeybot | public String getServerVersion ( ) { return this . io . getServerVersion ( ) ; }
JackSprat/Knifeybot | public Calendar getSessionLockedCalendar ( ) { return this . sessionCalendar ; }
JackSprat/Knifeybot | public int getTransactionIsolation ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . hasIsolationLevels && ! getUseLocalSessionState ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { stmt = getMetadataSafeStatement ( ) ; String query = null ; int offset = 0 ; if ( versionMeetsMinimum ( 4 , 0 , 3 ) ) { query = " SELECT ▁ @ @ session . tx _ isolation " ; offset = 1 ; } else { query = " SHOW ▁ VARIABLES ▁ LIKE ▁ ' transaction _ isolation ' " ; offset = 2 ; } rs = stmt . executeQuery ( query ) ; if ( rs . next ( ) ) { String s = rs . getString ( offset ) ; if ( s != null ) { Integer intTI = mapTransIsolationNameToValue . get ( s ) ; if ( intTI != null ) { return intTI . intValue ( ) ; } } throw SQLError . createSQLException ( " Could ▁ not ▁ map ▁ transaction ▁ isolation ▁ ' " + s + " ▁ to ▁ a ▁ valid ▁ JDBC ▁ level . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } throw SQLError . createSQLException ( " Could ▁ not ▁ retrieve ▁ transaction ▁ isolation ▁ level ▁ from ▁ server " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { } stmt = null ; } } } return this . isolationLevel ; } }
JackSprat/Knifeybot | public java . util . Map < String , Class < ? > > getTypeMap ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . typeMap == null ) { this . typeMap = new HashMap < String , Class < ? > > ( ) ; } return this . typeMap ; } }
JackSprat/Knifeybot | public String getURL ( ) { return this . myURL ; }
JackSprat/Knifeybot | public String getUser ( ) { return this . user ; }
JackSprat/Knifeybot | public Calendar getUtcCalendar ( ) { return this . utcCalendar ; }
JackSprat/Knifeybot | public SQLWarning getWarnings ( ) throws SQLException { return null ; }
JackSprat/Knifeybot | public boolean hasSameProperties ( Connection c ) { return this . props . equals ( c . getProperties ( ) ) ; }
JackSprat/Knifeybot | public Properties getProperties ( ) { return this . props ; }
JackSprat/Knifeybot | @ Deprecated public boolean hasTriedMaster ( ) { return this . hasTriedMasterFlag ; }
JackSprat/Knifeybot | public void incrementNumberOfPreparedExecutes ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfPreparedExecutes ++ ; this . numberOfQueriesIssued ++ ; } }
JackSprat/Knifeybot | public void incrementNumberOfPrepares ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfPrepares ++ ; } }
JackSprat/Knifeybot | public void incrementNumberOfResultSetsCreated ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfResultSetsCreated ++ ; } }
JackSprat/Knifeybot | private void initializeDriverProperties ( Properties info ) throws SQLException { initializeProperties ( info ) ; String exceptionInterceptorClasses = getExceptionInterceptors ( ) ; if ( exceptionInterceptorClasses != null && ! " " . equals ( exceptionInterceptorClasses ) ) { this . exceptionInterceptor = new ExceptionInterceptorChain ( exceptionInterceptorClasses ) ; } this . usePlatformCharsetConverters = getUseJvmCharsetConverters ( ) ; this . log = LogFactory . getLogger ( getLogger ( ) , LOGGER_INSTANCE_NAME , getExceptionInterceptor ( ) ) ; if ( getProfileSql ( ) || getUseUsageAdvisor ( ) ) { this . eventSink = ProfilerEventHandlerFactory . getInstance ( getMultiHostSafeProxy ( ) ) ; } if ( getCachePreparedStatements ( ) ) { createPreparedStatementCaches ( ) ; } if ( getNoDatetimeStringSync ( ) && getUseTimezone ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ enable ▁ noDatetimeStringSync ▁ and ▁ useTimezone ▁ configuration ▁ properties ▁ at ▁ the ▁ same ▁ time " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } if ( getCacheCallableStatements ( ) ) { this . parsedCallableStatementCache = new LRUCache ( getCallableStatementCacheSize ( ) ) ; } if ( getAllowMultiQueries ( ) ) { setCacheResultSetMetadata ( false ) ; } if ( getCacheResultSetMetadata ( ) ) { this . resultSetMetadataCache = new LRUCache ( getMetadataCacheSize ( ) ) ; } if ( getSocksProxyHost ( ) != null ) { setSocketFactoryClassName ( " com . mysql . jdbc . SocksProxySocketFactory " ) ; } }
JackSprat/Knifeybot | private void initializePropsFromServer ( ) throws SQLException { String connectionInterceptorClasses = getConnectionLifecycleInterceptors ( ) ; this . connectionLifecycleInterceptors = null ; if ( connectionInterceptorClasses != null ) { this . connectionLifecycleInterceptors = Util . loadExtensions ( this , this . props , connectionInterceptorClasses , " Connection . badLifecycleInterceptor " , getExceptionInterceptor ( ) ) ; } setSessionVariables ( ) ; if ( ! versionMeetsMinimum ( 4 , 1 , 0 ) ) { setTransformedBitIsBoolean ( false ) ; } this . parserKnowsUnicode = versionMeetsMinimum ( 4 , 1 , 0 ) ; if ( getUseServerPreparedStmts ( ) && versionMeetsMinimum ( 4 , 1 , 0 ) ) { this . useServerPreparedStmts = true ; if ( versionMeetsMinimum ( 5 , 0 , 0 ) && ! versionMeetsMinimum ( 5 , 0 , 3 ) ) { this . useServerPreparedStmts = false ; } } if ( versionMeetsMinimum ( 3 , 21 , 22 ) ) { loadServerVariables ( ) ; if ( versionMeetsMinimum ( 5 , 0 , 2 ) ) { this . autoIncrementIncrement = getServerVariableAsInt ( " auto _ increment _ increment " , 1 ) ; } else { this . autoIncrementIncrement = 1 ; } buildCollationMapping ( ) ; LicenseConfiguration . checkLicenseType ( this . serverVariables ) ; String lowerCaseTables = this . serverVariables . get ( " lower _ case _ table _ names " ) ; this . lowerCaseTableNames = " on " . equalsIgnoreCase ( lowerCaseTables ) || "1" . equalsIgnoreCase ( lowerCaseTables ) || "2" . equalsIgnoreCase ( lowerCaseTables ) ; this . storesLowerCaseTableName = "1" . equalsIgnoreCase ( lowerCaseTables ) || " on " . equalsIgnoreCase ( lowerCaseTables ) ; configureTimezone ( ) ; if ( this . serverVariables . containsKey ( " max _ allowed _ packet " ) ) { int serverMaxAllowedPacket = getServerVariableAsInt ( " max _ allowed _ packet " , - 1 ) ; if ( serverMaxAllowedPacket != - 1 && ( serverMaxAllowedPacket < getMaxAllowedPacket ( ) || getMaxAllowedPacket ( ) <= 0 ) ) { setMaxAllowedPacket ( serverMaxAllowedPacket ) ; } else if ( serverMaxAllowedPacket == - 1 && getMaxAllowedPacket ( ) == - 1 ) { setMaxAllowedPacket ( 65535 ) ; } if ( getUseServerPrepStmts ( ) ) { int preferredBlobSendChunkSize = getBlobSendChunkSize ( ) ; int packetHeaderSize = ServerPreparedStatement . BLOB_STREAM_READ_BUF_SIZE + 11 ; int allowedBlobSendChunkSize = Math . min ( preferredBlobSendChunkSize , getMaxAllowedPacket ( ) ) - packetHeaderSize ; if ( allowedBlobSendChunkSize <= 0 ) { throw SQLError . createSQLException ( " Connection ▁ setting ▁ too ▁ low ▁ for ▁ ' maxAllowedPacket ' . ▁ " + " When ▁ ' useServerPrepStmts = true ' , ▁ ' maxAllowedPacket ' ▁ must ▁ be ▁ higher ▁ than ▁ " + packetHeaderSize + " . ▁ Check ▁ also ▁ ' max _ allowed _ packet ' ▁ in ▁ MySQL ▁ configuration ▁ files . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } setBlobSendChunkSize ( String . valueOf ( allowedBlobSendChunkSize ) ) ; } } if ( this . serverVariables . containsKey ( " net _ buffer _ length " ) ) { this . netBufferLength = getServerVariableAsInt ( " net _ buffer _ length " , 16 * 1024 ) ; } checkTransactionIsolationLevel ( ) ; if ( ! versionMeetsMinimum ( 4 , 1 , 0 ) ) { checkServerEncoding ( ) ; } this . io . checkForCharsetMismatch ( ) ; if ( this . serverVariables . containsKey ( " sql _ mode " ) ) { String sqlModeAsString = this . serverVariables . get ( " sql _ mode " ) ; if ( StringUtils . isStrictlyNumeric ( sqlModeAsString ) ) { this . useAnsiQuotes = ( Integer . parseInt ( sqlModeAsString ) & 4 ) > 0 ; } else if ( sqlModeAsString != null ) { this . useAnsiQuotes = sqlModeAsString . indexOf ( " ANSI _ QUOTES " ) != - 1 ; this . noBackslashEscapes = sqlModeAsString . indexOf ( " NO _ BACKSLASH _ ESCAPES " ) != - 1 ; } } } boolean overrideDefaultAutocommit = isAutoCommitNonDefaultOnServer ( ) ; configureClientCharacterSet ( false ) ; try { this . errorMessageEncoding = CharsetMapping . getCharacterEncodingForErrorMessages ( this ) ; } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( versionMeetsMinimum ( 3 , 23 , 15 ) ) { this . transactionsSupported = true ; if ( ! overrideDefaultAutocommit ) { try { setAutoCommit ( true ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } } else { this . transactionsSupported = false ; } if ( versionMeetsMinimum ( 3 , 23 , 36 ) ) { this . hasIsolationLevels = true ; } else { this . hasIsolationLevels = false ; } this . hasQuotedIdentifiers = versionMeetsMinimum ( 3 , 23 , 6 ) ; this . io . resetMaxBuf ( ) ; if ( this . io . versionMeetsMinimum ( 4 , 1 , 0 ) ) { String characterSetResultsOnServerMysql = this . serverVariables . get ( JDBC_LOCAL_CHARACTER_SET_RESULTS ) ; if ( characterSetResultsOnServerMysql == null || StringUtils . startsWithIgnoreCaseAndWs ( characterSetResultsOnServerMysql , " NULL " ) || characterSetResultsOnServerMysql . length ( ) == 0 ) { String defaultMetadataCharsetMysql = this . serverVariables . get ( " character _ set _ system " ) ; String defaultMetadataCharset = null ; if ( defaultMetadataCharsetMysql != null ) { defaultMetadataCharset = CharsetMapping . getJavaEncodingForMysqlCharset ( defaultMetadataCharsetMysql ) ; } else { defaultMetadataCharset = " UTF - 8" ; } this . characterSetMetadata = defaultMetadataCharset ; } else { this . characterSetResultsOnServer = CharsetMapping . getJavaEncodingForMysqlCharset ( characterSetResultsOnServerMysql ) ; this . characterSetMetadata = this . characterSetResultsOnServer ; } } else { this . characterSetMetadata = getEncoding ( ) ; } if ( versionMeetsMinimum ( 4 , 1 , 0 ) && ! this . versionMeetsMinimum ( 4 , 1 , 10 ) && getAllowMultiQueries ( ) ) { if ( isQueryCacheEnabled ( ) ) { setAllowMultiQueries ( false ) ; } } if ( versionMeetsMinimum ( 5 , 0 , 0 ) && ( getUseLocalTransactionState ( ) || getElideSetAutoCommits ( ) ) && isQueryCacheEnabled ( ) && ! versionMeetsMinimum ( 5 , 1 , 32 ) ) { setUseLocalTransactionState ( false ) ; setElideSetAutoCommits ( false ) ; } setupServerForTruncationChecks ( ) ; }
JackSprat/Knifeybot | private boolean isQueryCacheEnabled ( ) { return " ON " . equalsIgnoreCase ( this . serverVariables . get ( " query _ cache _ type " ) ) && ! "0" . equalsIgnoreCase ( this . serverVariables . get ( " query _ cache _ size " ) ) ; }
JackSprat/Knifeybot | private int getServerVariableAsInt ( String variableName , int fallbackValue ) throws SQLException { try { return Integer . parseInt ( this . serverVariables . get ( variableName ) ) ; } catch ( NumberFormatException nfe ) { getLog ( ) . logWarn ( Messages . getString ( " Connection . BadValueInServerVariables " , new Object [ ] { variableName , this . serverVariables . get ( variableName ) , Integer . valueOf ( fallbackValue ) } ) ) ; return fallbackValue ; } }
JackSprat/Knifeybot | private boolean isAutoCommitNonDefaultOnServer ( ) throws SQLException { boolean overrideDefaultAutocommit = false ; String initConnectValue = this . serverVariables . get ( " init _ connect " ) ; if ( versionMeetsMinimum ( 4 , 1 , 2 ) && initConnectValue != null && initConnectValue . length ( ) > 0 ) { if ( ! getElideSetAutoCommits ( ) ) { java . sql . ResultSet rs = null ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; rs = stmt . executeQuery ( " SELECT ▁ @ @ session . autocommit " ) ; if ( rs . next ( ) ) { this . autoCommit = rs . getBoolean ( 1 ) ; if ( this . autoCommit != true ) { overrideDefaultAutocommit = true ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException sqlEx ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlEx ) { } } } } else { if ( this . getIO ( ) . isSetNeededForAutoCommitMode ( true ) ) { this . autoCommit = false ; overrideDefaultAutocommit = true ; } } } return overrideDefaultAutocommit ; }
JackSprat/Knifeybot | public boolean isClientTzUTC ( ) { return this . isClientTzUTC ; }
JackSprat/Knifeybot | public boolean isClosed ( ) { return this . isClosed ; }
JackSprat/Knifeybot | public boolean isCursorFetchEnabled ( ) throws SQLException { return ( versionMeetsMinimum ( 5 , 0 , 2 ) && getUseCursorFetch ( ) ) ; }
JackSprat/Knifeybot | public boolean isInGlobalTx ( ) { return this . isInGlobalTx ; }
JackSprat/Knifeybot | public boolean isMasterConnection ( ) { return false ; }
JackSprat/Knifeybot | public boolean isNoBackslashEscapesSet ( ) { return this . noBackslashEscapes ; }
JackSprat/Knifeybot | public boolean isReadInfoMsgEnabled ( ) { return this . readInfoMsg ; }
JackSprat/Knifeybot | public boolean isReadOnly ( ) throws SQLException { return isReadOnly ( true ) ; }
JackSprat/Knifeybot | public boolean isReadOnly ( boolean useSessionStatus ) throws SQLException { if ( useSessionStatus && ! this . isClosed && versionMeetsMinimum ( 5 , 6 , 5 ) && ! getUseLocalSessionState ( ) && getReadOnlyPropagatesToServer ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { try { stmt = getMetadataSafeStatement ( ) ; rs = stmt . executeQuery ( " select ▁ @ @ session . tx _ read _ only " ) ; if ( rs . next ( ) ) { return rs . getInt ( 1 ) != 0 ; } } catch ( SQLException ex1 ) { if ( ex1 . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw SQLError . createSQLException ( " Could ▁ not ▁ retrieve ▁ transation ▁ read - only ▁ status ▁ server " , SQLError . SQL_STATE_GENERAL_ERROR , ex1 , getExceptionInterceptor ( ) ) ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { } stmt = null ; } } } return this . readOnly ; }
JackSprat/Knifeybot | public boolean isRunningOnJDK13 ( ) { return this . isRunningOnJDK13 ; }
JackSprat/Knifeybot | public boolean isSameResource ( Connection otherConnection ) { synchronized ( getConnectionMutex ( ) ) { if ( otherConnection == null ) { return false ; } boolean directCompare = true ; String otherHost = ( ( ConnectionImpl ) otherConnection ) . origHostToConnectTo ; String otherOrigDatabase = ( ( ConnectionImpl ) otherConnection ) . origDatabaseToConnectTo ; String otherCurrentCatalog = ( ( ConnectionImpl ) otherConnection ) . database ; if ( ! nullSafeCompare ( otherHost , this . origHostToConnectTo ) ) { directCompare = false ; } else if ( otherHost != null && otherHost . indexOf ( ' , ' ) == - 1 && otherHost . indexOf ( ' : ' ) == - 1 ) { directCompare = ( ( ( ConnectionImpl ) otherConnection ) . origPortToConnectTo == this . origPortToConnectTo ) ; } if ( directCompare ) { if ( ! nullSafeCompare ( otherOrigDatabase , this . origDatabaseToConnectTo ) || ! nullSafeCompare ( otherCurrentCatalog , this . database ) ) { directCompare = false ; } } if ( directCompare ) { return true ; } String otherResourceId = ( ( ConnectionImpl ) otherConnection ) . getResourceId ( ) ; String myResourceId = getResourceId ( ) ; if ( otherResourceId != null || myResourceId != null ) { directCompare = nullSafeCompare ( otherResourceId , myResourceId ) ; if ( directCompare ) { return true ; } } return false ; } }
JackSprat/Knifeybot | public boolean isServerTzUTC ( ) { return this . isServerTzUTC ; }
JackSprat/Knifeybot | private void createConfigCacheIfNeeded ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . serverConfigCache != null ) { return ; } try { Class < ? > factoryClass ; factoryClass = Class . forName ( getServerConfigCacheFactory ( ) ) ; @ SuppressWarnings ( " unchecked " ) CacheAdapterFactory < String , Map < String , String > > cacheFactory = ( ( CacheAdapterFactory < String , Map < String , String > > ) factoryClass . newInstance ( ) ) ; this . serverConfigCache = cacheFactory . getInstance ( this , this . myURL , Integer . MAX_VALUE , Integer . MAX_VALUE , this . props ) ; ExceptionInterceptor evictOnCommsError = new ExceptionInterceptor ( ) { public void init ( Connection conn , Properties config ) throws SQLException { } public void destroy ( ) { } @ SuppressWarnings ( " synthetic - access " ) public SQLException interceptException ( SQLException sqlEx , Connection conn ) { if ( sqlEx . getSQLState ( ) != null && sqlEx . getSQLState ( ) . startsWith ( "08" ) ) { ConnectionImpl . this . serverConfigCache . invalidate ( getURL ( ) ) ; } return null ; } } ; if ( this . exceptionInterceptor == null ) { this . exceptionInterceptor = evictOnCommsError ; } else { ( ( ExceptionInterceptorChain ) this . exceptionInterceptor ) . addRingZero ( evictOnCommsError ) ; } } catch ( ClassNotFoundException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantFindCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( InstantiationException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( IllegalAccessException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } } }
JackSprat/Knifeybot | private void loadServerVariables ( ) throws SQLException { if ( getCacheServerConfiguration ( ) ) { createConfigCacheIfNeeded ( ) ; Map < String , String > cachedVariableMap = this . serverConfigCache . get ( getURL ( ) ) ; if ( cachedVariableMap != null ) { String cachedServerVersion = cachedVariableMap . get ( SERVER_VERSION_STRING_var_NAME ) ; if ( cachedServerVersion != null && this . io . getServerVersion ( ) != null && cachedServerVersion . equals ( this . io . getServerVersion ( ) ) ) { this . serverVariables = cachedVariableMap ; return ; } this . serverConfigCache . invalidate ( getURL ( ) ) ; } } java . sql . Statement stmt = null ; java . sql . ResultSet results = null ; try { stmt = getMetadataSafeStatement ( ) ; String version = this . dbmd . getDriverVersion ( ) ; if ( version != null && version . indexOf ( ' * ' ) != - 1 ) { StringBuilder buf = new StringBuilder ( version . length ( ) + 10 ) ; for ( int i = 0 ; i < version . length ( ) ; i ++ ) { char c = version . charAt ( i ) ; if ( c == ' * ' ) { buf . append ( " [ star ] " ) ; } else { buf . append ( c ) ; } } version = buf . toString ( ) ; } String versionComment = ( this . getParanoid ( ) || version == null ) ? " " : " /* ▁ " + version + " ▁ */ " ; this . serverVariables = new HashMap < String , String > ( ) ; try { if ( versionMeetsMinimum ( 5 , 1 , 0 ) ) { StringBuilder queryBuf = new StringBuilder ( versionComment ) . append ( " SELECT " ) ; queryBuf . append ( " ▁ ▁ @ @ session . auto _ increment _ increment ▁ AS ▁ auto _ increment _ increment " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ client ▁ AS ▁ character _ set _ client " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ connection ▁ AS ▁ character _ set _ connection " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ results ▁ AS ▁ character _ set _ results " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ server ▁ AS ▁ character _ set _ server " ) ; queryBuf . append ( " , ▁ @ @ init _ connect ▁ AS ▁ init _ connect " ) ; queryBuf . append ( " , ▁ @ @ interactive _ timeout ▁ AS ▁ interactive _ timeout " ) ; if ( ! versionMeetsMinimum ( 5 , 5 , 0 ) ) { queryBuf . append ( " , ▁ @ @ language ▁ AS ▁ language " ) ; } queryBuf . append ( " , ▁ @ @ license ▁ AS ▁ license " ) ; queryBuf . append ( " , ▁ @ @ lower _ case _ table _ names ▁ AS ▁ lower _ case _ table _ names " ) ; queryBuf . append ( " , ▁ @ @ max _ allowed _ packet ▁ AS ▁ max _ allowed _ packet " ) ; queryBuf . append ( " , ▁ @ @ net _ buffer _ length ▁ AS ▁ net _ buffer _ length " ) ; queryBuf . append ( " , ▁ @ @ net _ write _ timeout ▁ AS ▁ net _ write _ timeout " ) ; queryBuf . append ( " , ▁ @ @ query _ cache _ size ▁ AS ▁ query _ cache _ size " ) ; queryBuf . append ( " , ▁ @ @ query _ cache _ type ▁ AS ▁ query _ cache _ type " ) ; queryBuf . append ( " , ▁ @ @ sql _ mode ▁ AS ▁ sql _ mode " ) ; queryBuf . append ( " , ▁ @ @ system _ time _ zone ▁ AS ▁ system _ time _ zone " ) ; queryBuf . append ( " , ▁ @ @ time _ zone ▁ AS ▁ time _ zone " ) ; queryBuf . append ( " , ▁ @ @ tx _ isolation ▁ AS ▁ tx _ isolation " ) ; queryBuf . append ( " , ▁ @ @ wait _ timeout ▁ AS ▁ wait _ timeout " ) ; results = stmt . executeQuery ( queryBuf . toString ( ) ) ; if ( results . next ( ) ) { ResultSetMetaData rsmd = results . getMetaData ( ) ; for ( int i = 1 ; i <= rsmd . getColumnCount ( ) ; i ++ ) { this . serverVariables . put ( rsmd . getColumnLabel ( i ) , results . getString ( i ) ) ; } } } else { results = stmt . executeQuery ( versionComment + " SHOW ▁ VARIABLES " ) ; while ( results . next ( ) ) { this . serverVariables . put ( results . getString ( 1 ) , results . getString ( 2 ) ) ; } } results . close ( ) ; results = null ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } if ( getCacheServerConfiguration ( ) ) { this . serverVariables . put ( SERVER_VERSION_STRING_var_NAME , this . io . getServerVersion ( ) ) ; this . serverConfigCache . put ( getURL ( ) , this . serverVariables ) ; } } catch ( SQLException e ) { throw e ; } finally { if ( results != null ) { try { results . close ( ) ; } catch ( SQLException sqlE ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlE ) { } } } }
JackSprat/Knifeybot | public int getAutoIncrementIncrement ( ) { return this . autoIncrementIncrement ; }
JackSprat/Knifeybot | public boolean lowerCaseTableNames ( ) { return this . lowerCaseTableNames ; }
JackSprat/Knifeybot | public String nativeSQL ( String sql ) throws SQLException { if ( sql == null ) { return null ; } Object escapedSqlResult = EscapeProcessor . escapeSQL ( sql , serverSupportsConvertFn ( ) , getMultiHostSafeProxy ( ) ) ; if ( escapedSqlResult instanceof String ) { return ( String ) escapedSqlResult ; } return ( ( EscapeProcessorResult ) escapedSqlResult ) . escapedSql ; }
JackSprat/Knifeybot | private CallableStatement parseCallableStatement ( String sql ) throws SQLException { Object escapedSqlResult = EscapeProcessor . escapeSQL ( sql , serverSupportsConvertFn ( ) , getMultiHostSafeProxy ( ) ) ; boolean isFunctionCall = false ; String parsedSql = null ; if ( escapedSqlResult instanceof EscapeProcessorResult ) { parsedSql = ( ( EscapeProcessorResult ) escapedSqlResult ) . escapedSql ; isFunctionCall = ( ( EscapeProcessorResult ) escapedSqlResult ) . callingStoredFunction ; } else { parsedSql = ( String ) escapedSqlResult ; isFunctionCall = false ; } return CallableStatement . getInstance ( getMultiHostSafeProxy ( ) , parsedSql , this . database , isFunctionCall ) ; }
JackSprat/Knifeybot | public boolean parserKnowsUnicode ( ) { return this . parserKnowsUnicode ; }
JackSprat/Knifeybot | public void ping ( ) throws SQLException { pingInternal ( true , 0 ) ; }
JackSprat/Knifeybot | public void pingInternal ( boolean checkForClosedConnection , int timeoutMillis ) throws SQLException { if ( checkForClosedConnection ) { checkClosed ( ) ; } long pingMillisLifetime = getSelfDestructOnPingSecondsLifetime ( ) ; int pingMaxOperations = getSelfDestructOnPingMaxOperations ( ) ; if ( ( pingMillisLifetime > 0 && ( System . currentTimeMillis ( ) - this . connectionCreationTimeMillis ) > pingMillisLifetime ) || ( pingMaxOperations > 0 && pingMaxOperations <= this . io . getCommandCount ( ) ) ) { close ( ) ; throw SQLError . createSQLException ( Messages . getString ( " Connection . exceededConnectionLifetime " ) , SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE , getExceptionInterceptor ( ) ) ; } this . io . sendCommand ( MysqlDefs . PING , null , null , false , null , timeoutMillis ) ; }
JackSprat/Knifeybot | public java . sql . CallableStatement prepareCall ( String sql ) throws SQLException { return prepareCall ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { if ( versionMeetsMinimum ( 5 , 0 , 0 ) ) { CallableStatement cStmt = null ; if ( ! getCacheCallableStatements ( ) ) { cStmt = parseCallableStatement ( sql ) ; } else { synchronized ( this . parsedCallableStatementCache ) { CompoundCacheKey key = new CompoundCacheKey ( getCatalog ( ) , sql ) ; CallableStatement . CallableStatementParamInfo cachedParamInfo = ( CallableStatement . CallableStatementParamInfo ) this . parsedCallableStatementCache . get ( key ) ; if ( cachedParamInfo != null ) { cStmt = CallableStatement . getInstance ( getMultiHostSafeProxy ( ) , cachedParamInfo ) ; } else { cStmt = parseCallableStatement ( sql ) ; synchronized ( cStmt ) { cachedParamInfo = cStmt . paramInfo ; } this . parsedCallableStatementCache . put ( key , cachedParamInfo ) ; } } } cStmt . setResultSetType ( resultSetType ) ; cStmt . setResultSetConcurrency ( resultSetConcurrency ) ; return cStmt ; } throw SQLError . createSQLException ( " Callable ▁ statements ▁ not ▁ supported . " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; }
JackSprat/Knifeybot | public java . sql . CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } CallableStatement cStmt = ( com . mysql . jdbc . CallableStatement ) prepareCall ( sql , resultSetType , resultSetConcurrency ) ; return cStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql ) throws SQLException { return prepareStatement ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; PreparedStatement pStmt = null ; boolean canServerPrepare = true ; String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; if ( this . useServerPreparedStmts && getEmulateUnsupportedPstmts ( ) ) { canServerPrepare = canHandleAsServerPreparedStatement ( nativeSql ) ; } if ( this . useServerPreparedStmts && canServerPrepare ) { if ( this . getCachePreparedStatements ( ) ) { synchronized ( this . serverSideStatementCache ) { pStmt = ( com . mysql . jdbc . ServerPreparedStatement ) this . serverSideStatementCache . remove ( sql ) ; if ( pStmt != null ) { ( ( com . mysql . jdbc . ServerPreparedStatement ) pStmt ) . setClosed ( false ) ; pStmt . clearParameters ( ) ; } if ( pStmt == null ) { try { pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , resultSetType , resultSetConcurrency ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { ( ( com . mysql . jdbc . ServerPreparedStatement ) pStmt ) . isCached = true ; } pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; } catch ( SQLException sqlEx ) { if ( getEmulateUnsupportedPstmts ( ) ) { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { this . serverSideStatementCheckCache . put ( sql , Boolean . FALSE ) ; } } else { throw sqlEx ; } } } } } else { try { pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , resultSetType , resultSetConcurrency ) ; pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; } catch ( SQLException sqlEx ) { if ( getEmulateUnsupportedPstmts ( ) ) { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; } else { throw sqlEx ; } } } } else { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; } return pStmt ; } }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return prepareStatement ( sql , resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement prepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public void realClose ( boolean calledExplicitly , boolean issueRollback , boolean skipLocalTeardown , Throwable reason ) throws SQLException { SQLException sqlEx = null ; if ( this . isClosed ( ) ) { return ; } this . forceClosedReason = reason ; try { if ( ! skipLocalTeardown ) { if ( ! getAutoCommit ( ) && issueRollback ) { try { rollback ( ) ; } catch ( SQLException ex ) { sqlEx = ex ; } } reportMetrics ( ) ; if ( getUseUsageAdvisor ( ) ) { if ( ! calledExplicitly ) { String message = " Connection ▁ implicitly ▁ closed ▁ by ▁ Driver . ▁ You ▁ should ▁ call ▁ Connection . close ( ) ▁ from ▁ your ▁ code ▁ to ▁ free ▁ resources ▁ more ▁ efficiently ▁ and ▁ avoid ▁ resource ▁ leaks . " ; this . eventSink . consumeEvent ( new ProfilerEvent ( ProfilerEvent . TYPE_WARN , " " , this . getCatalog ( ) , this . getId ( ) , - 1 , - 1 , System . currentTimeMillis ( ) , 0 , Constants . MILLIS_I18N , null , this . pointOfOrigin , message ) ) ; } long connectionLifeTime = System . currentTimeMillis ( ) - this . connectionCreationTimeMillis ; if ( connectionLifeTime < 500 ) { String message = " Connection ▁ lifetime ▁ of ▁ < ▁ . 5 ▁ seconds . ▁ You ▁ might ▁ be ▁ un - necessarily ▁ creating ▁ short - lived ▁ connections ▁ and ▁ should ▁ investigate ▁ connection ▁ pooling ▁ to ▁ be ▁ more ▁ efficient . " ; this . eventSink . consumeEvent ( new ProfilerEvent ( ProfilerEvent . TYPE_WARN , " " , this . getCatalog ( ) , this . getId ( ) , - 1 , - 1 , System . currentTimeMillis ( ) , 0 , Constants . MILLIS_I18N , null , this . pointOfOrigin , message ) ) ; } } try { closeAllOpenStatements ( ) ; } catch ( SQLException ex ) { sqlEx = ex ; } if ( this . io != null ) { try { this . io . quit ( ) ; } catch ( Exception e ) { } } } else { this . io . forceClose ( ) ; } if ( this . statementInterceptors != null ) { for ( int i = 0 ; i < this . statementInterceptors . size ( ) ; i ++ ) { this . statementInterceptors . get ( i ) . destroy ( ) ; } } if ( this . exceptionInterceptor != null ) { this . exceptionInterceptor . destroy ( ) ; } } finally { this . openStatements . clear ( ) ; if ( this . io != null ) { this . io . releaseResources ( ) ; this . io = null ; } this . statementInterceptors = null ; this . exceptionInterceptor = null ; ProfilerEventHandlerFactory . removeInstance ( this ) ; synchronized ( getConnectionMutex ( ) ) { if ( this . cancelTimer != null ) { this . cancelTimer . cancel ( ) ; } } this . isClosed = true ; } if ( sqlEx != null ) { throw sqlEx ; } }
JackSprat/Knifeybot | public void recachePreparedStatement ( ServerPreparedStatement pstmt ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( getCachePreparedStatements ( ) && pstmt . isPoolable ( ) ) { synchronized ( this . serverSideStatementCache ) { this . serverSideStatementCache . put ( pstmt . originalSql , pstmt ) ; } } } }
JackSprat/Knifeybot | public void decachePreparedStatement ( ServerPreparedStatement pstmt ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( getCachePreparedStatements ( ) && pstmt . isPoolable ( ) ) { synchronized ( this . serverSideStatementCache ) { this . serverSideStatementCache . remove ( pstmt . originalSql ) ; } } } }
JackSprat/Knifeybot | public void registerQueryExecutionTime ( long queryTimeMs ) { if ( queryTimeMs > this . longestQueryTimeMs ) { this . longestQueryTimeMs = queryTimeMs ; repartitionPerformanceHistogram ( ) ; } addToPerformanceHistogram ( queryTimeMs , 1 ) ; if ( queryTimeMs < this . shortestQueryTimeMs ) { this . shortestQueryTimeMs = ( queryTimeMs == 0 ) ? 1 : queryTimeMs ; } this . numberOfQueriesIssued ++ ; this . totalQueryTimeMs += queryTimeMs ; }
JackSprat/Knifeybot | public void registerStatement ( Statement stmt ) { this . openStatements . addIfAbsent ( stmt ) ; }
JackSprat/Knifeybot | public void releaseSavepoint ( Savepoint arg0 ) throws SQLException { }
JackSprat/Knifeybot | private void repartitionHistogram ( int [ ] histCounts , long [ ] histBreakpoints , long currentLowerBound , long currentUpperBound ) { if ( this . oldHistCounts == null ) { this . oldHistCounts = new int [ histCounts . length ] ; this . oldHistBreakpoints = new long [ histBreakpoints . length ] ; } System . arraycopy ( histCounts , 0 , this . oldHistCounts , 0 , histCounts . length ) ; System . arraycopy ( histBreakpoints , 0 , this . oldHistBreakpoints , 0 , histBreakpoints . length ) ; createInitialHistogram ( histBreakpoints , currentLowerBound , currentUpperBound ) ; for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { addToHistogram ( histCounts , histBreakpoints , this . oldHistBreakpoints [ i ] , this . oldHistCounts [ i ] , currentLowerBound , currentUpperBound ) ; } }
JackSprat/Knifeybot | private void repartitionPerformanceHistogram ( ) { checkAndCreatePerformanceHistogram ( ) ; repartitionHistogram ( this . perfMetricsHistCounts , this . perfMetricsHistBreakpoints , this . shortestQueryTimeMs == Long . MAX_VALUE ? 0 : this . shortestQueryTimeMs , this . longestQueryTimeMs ) ; }
JackSprat/Knifeybot | private void repartitionTablesAccessedHistogram ( ) { checkAndCreateTablesAccessedHistogram ( ) ; repartitionHistogram ( this . numTablesMetricsHistCounts , this . numTablesMetricsHistBreakpoints , this . minimumNumberTablesAccessed == Long . MAX_VALUE ? 0 : this . minimumNumberTablesAccessed , this . maximumNumberTablesAccessed ) ; }
JackSprat/Knifeybot | private void reportMetrics ( ) { if ( getGatherPerformanceMetrics ( ) ) { StringBuilder logMessage = new StringBuilder ( 256 ) ; logMessage . append ( " * * ▁ Performance ▁ Metrics ▁ Report ▁ * * \n " ) ; logMessage . append ( " \n Longest ▁ reported ▁ query : ▁ " + this . longestQueryTimeMs + " ▁ ms " ) ; logMessage . append ( " \n Shortest ▁ reported ▁ query : ▁ " + this . shortestQueryTimeMs + " ▁ ms " ) ; logMessage . append ( " \n Average ▁ query ▁ execution ▁ time : ▁ " + ( this . totalQueryTimeMs / this . numberOfQueriesIssued ) + " ▁ ms " ) ; logMessage . append ( " \n Number ▁ of ▁ statements ▁ executed : ▁ " + this . numberOfQueriesIssued ) ; logMessage . append ( " \n Number ▁ of ▁ result ▁ sets ▁ created : ▁ " + this . numberOfResultSetsCreated ) ; logMessage . append ( " \n Number ▁ of ▁ statements ▁ prepared : ▁ " + this . numberOfPrepares ) ; logMessage . append ( " \n Number ▁ of ▁ prepared ▁ statement ▁ executions : ▁ " + this . numberOfPreparedExecutes ) ; if ( this . perfMetricsHistBreakpoints != null ) { logMessage . append ( " \n \n \tTiming ▁ Histogram : \n " ) ; int maxNumPoints = 20 ; int highestCount = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS ) ; i ++ ) { if ( this . perfMetricsHistCounts [ i ] > highestCount ) { highestCount = this . perfMetricsHistCounts [ i ] ; } } if ( highestCount == 0 ) { highestCount = 1 ; } for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS - 1 ) ; i ++ ) { if ( i == 0 ) { logMessage . append ( " \n \tless ▁ than ▁ " + this . perfMetricsHistBreakpoints [ i + 1 ] + " ▁ ms : ▁ \t " + this . perfMetricsHistCounts [ i ] ) ; } else { logMessage . append ( " \n \tbetween ▁ " + this . perfMetricsHistBreakpoints [ i ] + " ▁ and ▁ " + this . perfMetricsHistBreakpoints [ i + 1 ] + " ▁ ms : ▁ \t " + this . perfMetricsHistCounts [ i ] ) ; } logMessage . append ( " \t " ) ; int numPointsToGraph = ( int ) ( maxNumPoints * ( ( double ) this . perfMetricsHistCounts [ i ] / ( double ) highestCount ) ) ; for ( int j = 0 ; j < numPointsToGraph ; j ++ ) { logMessage . append ( " * " ) ; } if ( this . longestQueryTimeMs < this . perfMetricsHistCounts [ i + 1 ] ) { break ; } } if ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] < this . longestQueryTimeMs ) { logMessage . append ( " \n \tbetween ▁ " ) ; logMessage . append ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] ) ; logMessage . append ( " ▁ and ▁ " ) ; logMessage . append ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 1 ] ) ; logMessage . append ( " ▁ ms : ▁ \t " ) ; logMessage . append ( this . perfMetricsHistCounts [ HISTOGRAM_BUCKETS - 1 ] ) ; } } if ( this . numTablesMetricsHistBreakpoints != null ) { logMessage . append ( " \n \n \tTable ▁ Join ▁ Histogram : \n " ) ; int maxNumPoints = 20 ; int highestCount = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS ) ; i ++ ) { if ( this . numTablesMetricsHistCounts [ i ] > highestCount ) { highestCount = this . numTablesMetricsHistCounts [ i ] ; } } if ( highestCount == 0 ) { highestCount = 1 ; } for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS - 1 ) ; i ++ ) { if ( i == 0 ) { logMessage . append ( " \n \t " + this . numTablesMetricsHistBreakpoints [ i + 1 ] + " ▁ tables ▁ or ▁ less : ▁ \t\t " + this . numTablesMetricsHistCounts [ i ] ) ; } else { logMessage . append ( " \n \tbetween ▁ " + this . numTablesMetricsHistBreakpoints [ i ] + " ▁ and ▁ " + this . numTablesMetricsHistBreakpoints [ i + 1 ] + " ▁ tables : ▁ \t " + this . numTablesMetricsHistCounts [ i ] ) ; } logMessage . append ( " \t " ) ; int numPointsToGraph = ( int ) ( maxNumPoints * ( ( double ) this . numTablesMetricsHistCounts [ i ] / ( double ) highestCount ) ) ; for ( int j = 0 ; j < numPointsToGraph ; j ++ ) { logMessage . append ( " * " ) ; } if ( this . maximumNumberTablesAccessed < this . numTablesMetricsHistBreakpoints [ i + 1 ] ) { break ; } } if ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] < this . maximumNumberTablesAccessed ) { logMessage . append ( " \n \tbetween ▁ " ) ; logMessage . append ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] ) ; logMessage . append ( " ▁ and ▁ " ) ; logMessage . append ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 1 ] ) ; logMessage . append ( " ▁ tables : ▁ " ) ; logMessage . append ( this . numTablesMetricsHistCounts [ HISTOGRAM_BUCKETS - 1 ] ) ; } } this . log . logInfo ( logMessage ) ; this . metricsLastReportedMs = System . currentTimeMillis ( ) ; } }
JackSprat/Knifeybot | protected void reportMetricsIfNeeded ( ) { if ( getGatherPerformanceMetrics ( ) ) { if ( ( System . currentTimeMillis ( ) - this . metricsLastReportedMs ) > getReportMetricsIntervalMillis ( ) ) { reportMetrics ( ) ; } } }
JackSprat/Knifeybot | public void reportNumberOfTablesAccessed ( int numTablesAccessed ) { if ( numTablesAccessed < this . minimumNumberTablesAccessed ) { this . minimumNumberTablesAccessed = numTablesAccessed ; } if ( numTablesAccessed > this . maximumNumberTablesAccessed ) { this . maximumNumberTablesAccessed = numTablesAccessed ; repartitionTablesAccessedHistogram ( ) ; } addToTablesAccessedHistogram ( numTablesAccessed , 1 ) ; }
JackSprat/Knifeybot | public void resetServerState ( ) throws SQLException { if ( ! getParanoid ( ) && ( ( this . io != null ) && versionMeetsMinimum ( 4 , 0 , 6 ) ) ) { changeUser ( this . user , this . password ) ; } }
JackSprat/Knifeybot | public void rollback ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . rollback ( ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( this . autoCommit && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ call ▁ rollback ▁ when ▁ autocommit = true " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } else if ( this . transactionsSupported ) { try { rollbackNoChecks ( ) ; } catch ( SQLException sqlEx ) { if ( getIgnoreNonTxTables ( ) && ( sqlEx . getErrorCode ( ) == SQLError . ER_WARNING_NOT_COMPLETE_ROLLBACK ) ) { return ; } throw sqlEx ; } } } catch ( SQLException sqlException ) { if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlException . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ rollback ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlException ; } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } }
JackSprat/Knifeybot | public void rollback ( final Savepoint savepoint ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( versionMeetsMinimum ( 4 , 0 , 14 ) || versionMeetsMinimum ( 4 , 1 , 1 ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . rollback ( savepoint ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } StringBuilder rollbackQuery = new StringBuilder ( " ROLLBACK ▁ TO ▁ SAVEPOINT ▁ " ) ; rollbackQuery . append ( ' ` ' ) ; rollbackQuery . append ( savepoint . getSavepointName ( ) ) ; rollbackQuery . append ( ' ` ' ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; stmt . executeUpdate ( rollbackQuery . toString ( ) ) ; } catch ( SQLException sqlEx ) { int errno = sqlEx . getErrorCode ( ) ; if ( errno == 1181 ) { String msg = sqlEx . getMessage ( ) ; if ( msg != null ) { int indexOfError153 = msg . indexOf ( "153" ) ; if ( indexOfError153 != - 1 ) { throw SQLError . createSQLException ( " Savepoint ▁ ' " + savepoint . getSavepointName ( ) + " ' ▁ does ▁ not ▁ exist " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , errno , getExceptionInterceptor ( ) ) ; } } } if ( getIgnoreNonTxTables ( ) && ( sqlEx . getErrorCode ( ) != SQLError . ER_WARNING_NOT_COMPLETE_ROLLBACK ) ) { throw sqlEx ; } if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlEx . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ rollback ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlEx ; } finally { closeStatement ( stmt ) ; } } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } else { throw SQLError . createSQLFeatureNotSupportedException ( ) ; } } }
JackSprat/Knifeybot | private void rollbackNoChecks ( ) throws SQLException { if ( getUseLocalTransactionState ( ) && versionMeetsMinimum ( 5 , 0 , 0 ) ) { if ( ! this . io . inTransactionOnServer ( ) ) { return ; } } execSQL ( null , " rollback " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; return ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; PreparedStatement pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; pStmt . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; return ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return serverPrepareStatement ( sql , resultSetType , resultSetConcurrency ) ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) serverPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public java . sql . PreparedStatement serverPrepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) serverPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
JackSprat/Knifeybot | public boolean serverSupportsConvertFn ( ) throws SQLException { return versionMeetsMinimum ( 4 , 0 , 2 ) ; }
JackSprat/Knifeybot | public void setAutoCommit ( final boolean autoCommitFlag ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . setAutoCommit ( autoCommitFlag ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( getAutoReconnectForPools ( ) ) { setHighAvailability ( true ) ; } try { if ( this . transactionsSupported ) { boolean needsSetOnServer = true ; if ( this . getUseLocalSessionState ( ) && this . autoCommit == autoCommitFlag ) { needsSetOnServer = false ; } else if ( ! this . getHighAvailability ( ) ) { needsSetOnServer = this . getIO ( ) . isSetNeededForAutoCommitMode ( autoCommitFlag ) ; } this . autoCommit = autoCommitFlag ; if ( needsSetOnServer ) { execSQL ( null , autoCommitFlag ? " SET ▁ autocommit = 1" : " SET ▁ autocommit = 0" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } else { if ( ( autoCommitFlag == false ) && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " MySQL ▁ Versions ▁ Older ▁ than ▁ 3.23.15 ▁ do ▁ not ▁ support ▁ transactions " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } this . autoCommit = autoCommitFlag ; } } finally { if ( this . getAutoReconnectForPools ( ) ) { setHighAvailability ( false ) ; } } return ; } }
JackSprat/Knifeybot | public void setCatalog ( final String catalog ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( catalog == null ) { throw SQLError . createSQLException ( " Catalog ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . setCatalog ( catalog ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( getUseLocalSessionState ( ) ) { if ( this . lowerCaseTableNames ) { if ( this . database . equalsIgnoreCase ( catalog ) ) { return ; } } else { if ( this . database . equals ( catalog ) ) { return ; } } } String quotedId = this . dbmd . getIdentifierQuoteString ( ) ; if ( ( quotedId == null ) || quotedId . equals ( " ▁ " ) ) { quotedId = " " ; } StringBuilder query = new StringBuilder ( " USE ▁ " ) ; query . append ( StringUtils . quoteIdentifier ( catalog , quotedId , getPedantic ( ) ) ) ; execSQL ( null , query . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . database = catalog ; } }
JackSprat/Knifeybot | public void setFailedOver ( boolean flag ) { }
JackSprat/Knifeybot | public void setHoldability ( int arg0 ) throws SQLException { }
JackSprat/Knifeybot | public void setInGlobalTx ( boolean flag ) { this . isInGlobalTx = flag ; }
JackSprat/Knifeybot | @ Deprecated public void setPreferSlaveDuringFailover ( boolean flag ) { }
JackSprat/Knifeybot | public void setReadInfoMsgEnabled ( boolean flag ) { this . readInfoMsg = flag ; }
JackSprat/Knifeybot | public void setReadOnly ( boolean readOnlyFlag ) throws SQLException { checkClosed ( ) ; setReadOnlyInternal ( readOnlyFlag ) ; }
JackSprat/Knifeybot | public void setReadOnlyInternal ( boolean readOnlyFlag ) throws SQLException { if ( getReadOnlyPropagatesToServer ( ) && versionMeetsMinimum ( 5 , 6 , 5 ) ) { if ( ! getUseLocalSessionState ( ) || ( readOnlyFlag != this . readOnly ) ) { execSQL ( null , " set ▁ session ▁ transaction ▁ " + ( readOnlyFlag ? " read ▁ only " : " read ▁ write " ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } this . readOnly = readOnlyFlag ; }
JackSprat/Knifeybot | public java . sql . Savepoint setSavepoint ( ) throws SQLException { MysqlSavepoint savepoint = new MysqlSavepoint ( getExceptionInterceptor ( ) ) ; setSavepoint ( savepoint ) ; return savepoint ; }
JackSprat/Knifeybot | private void setSavepoint ( MysqlSavepoint savepoint ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( versionMeetsMinimum ( 4 , 0 , 14 ) || versionMeetsMinimum ( 4 , 1 , 1 ) ) { checkClosed ( ) ; StringBuilder savePointQuery = new StringBuilder ( " SAVEPOINT ▁ " ) ; savePointQuery . append ( ' ` ' ) ; savePointQuery . append ( savepoint . getSavepointName ( ) ) ; savePointQuery . append ( ' ` ' ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; stmt . executeUpdate ( savePointQuery . toString ( ) ) ; } finally { closeStatement ( stmt ) ; } } else { throw SQLError . createSQLFeatureNotSupportedException ( ) ; } } }
JackSprat/Knifeybot | public java . sql . Savepoint setSavepoint ( String name ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { MysqlSavepoint savepoint = new MysqlSavepoint ( name , getExceptionInterceptor ( ) ) ; setSavepoint ( savepoint ) ; return savepoint ; } }
JackSprat/Knifeybot | private void setSessionVariables ( ) throws SQLException { if ( this . versionMeetsMinimum ( 4 , 0 , 0 ) && getSessionVariables ( ) != null ) { List < String > variablesToSet = StringUtils . split ( getSessionVariables ( ) , " , " , " \" ' " , " \" ' " , false ) ; int numVariablesToSet = variablesToSet . size ( ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; for ( int i = 0 ; i < numVariablesToSet ; i ++ ) { String variableValuePair = variablesToSet . get ( i ) ; if ( variableValuePair . startsWith ( " @ " ) ) { stmt . executeUpdate ( " SET ▁ " + variableValuePair ) ; } else { stmt . executeUpdate ( " SET ▁ SESSION ▁ " + variableValuePair ) ; } } } finally { if ( stmt != null ) { stmt . close ( ) ; } } } }
JackSprat/Knifeybot | public void setTransactionIsolation ( int level ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( this . hasIsolationLevels ) { String sql = null ; boolean shouldSendSet = false ; if ( getAlwaysSendSetIsolation ( ) ) { shouldSendSet = true ; } else { if ( level != this . isolationLevel ) { shouldSendSet = true ; } } if ( getUseLocalSessionState ( ) ) { shouldSendSet = this . isolationLevel != level ; } if ( shouldSendSet ) { switch ( level ) { case java . sql . Connection . TRANSACTION_NONE : throw SQLError . createSQLException ( " Transaction ▁ isolation ▁ level ▁ NONE ▁ not ▁ supported ▁ by ▁ MySQL " , getExceptionInterceptor ( ) ) ; case java . sql . Connection . TRANSACTION_READ_COMMITTED : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ READ ▁ COMMITTED " ; break ; case java . sql . Connection . TRANSACTION_READ_UNCOMMITTED : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ READ ▁ UNCOMMITTED " ; break ; case java . sql . Connection . TRANSACTION_REPEATABLE_READ : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ REPEATABLE ▁ READ " ; break ; case java . sql . Connection . TRANSACTION_SERIALIZABLE : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ SERIALIZABLE " ; break ; default : throw SQLError . createSQLException ( " Unsupported ▁ transaction ▁ isolation ▁ level ▁ ' " + level + " ' " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; } execSQL ( null , sql , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . isolationLevel = level ; } } else { throw SQLError . createSQLException ( " Transaction ▁ Isolation ▁ Levels ▁ are ▁ not ▁ supported ▁ on ▁ MySQL ▁ versions ▁ older ▁ than ▁ 3.23.36 . " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; } } }
JackSprat/Knifeybot | public void setTypeMap ( java . util . Map < String , Class < ? > > map ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { this . typeMap = map ; } }
JackSprat/Knifeybot | private void setupServerForTruncationChecks ( ) throws SQLException { if ( getJdbcCompliantTruncation ( ) ) { if ( versionMeetsMinimum ( 5 , 0 , 2 ) ) { String currentSqlMode = this . serverVariables . get ( " sql _ mode " ) ; boolean strictTransTablesIsSet = StringUtils . indexOfIgnoreCase ( currentSqlMode , " STRICT _ TRANS _ TABLES " ) != - 1 ; if ( currentSqlMode == null || currentSqlMode . length ( ) == 0 || ! strictTransTablesIsSet ) { StringBuilder commandBuf = new StringBuilder ( " SET ▁ sql _ mode = ' " ) ; if ( currentSqlMode != null && currentSqlMode . length ( ) > 0 ) { commandBuf . append ( currentSqlMode ) ; commandBuf . append ( " , " ) ; } commandBuf . append ( " STRICT _ TRANS _ TABLES ' " ) ; execSQL ( null , commandBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; setJdbcCompliantTruncation ( false ) ; } else if ( strictTransTablesIsSet ) { setJdbcCompliantTruncation ( false ) ; } } } }
JackSprat/Knifeybot | public void shutdownServer ( ) throws SQLException { try { this . io . sendCommand ( MysqlDefs . SHUTDOWN , null , null , false , null , 0 ) ; } catch ( Exception ex ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnhandledExceptionDuringShutdown " ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } }
JackSprat/Knifeybot | public boolean supportsIsolationLevel ( ) { return this . hasIsolationLevels ; }
JackSprat/Knifeybot | public boolean supportsQuotedIdentifiers ( ) { return this . hasQuotedIdentifiers ; }
JackSprat/Knifeybot | public boolean supportsTransactions ( ) { return this . transactionsSupported ; }
JackSprat/Knifeybot | public void unregisterStatement ( Statement stmt ) { this . openStatements . remove ( stmt ) ; }
JackSprat/Knifeybot | public boolean useAnsiQuotedIdentifiers ( ) { synchronized ( getConnectionMutex ( ) ) { return this . useAnsiQuotes ; } }
JackSprat/Knifeybot | public boolean versionMeetsMinimum ( int major , int minor , int subminor ) throws SQLException { checkClosed ( ) ; return this . io . versionMeetsMinimum ( major , minor , subminor ) ; }
JackSprat/Knifeybot | public CachedResultSetMetaData getCachedMetaData ( String sql ) { if ( this . resultSetMetadataCache != null ) { synchronized ( this . resultSetMetadataCache ) { return ( CachedResultSetMetaData ) this . resultSetMetadataCache . get ( sql ) ; } } return null ; }
JackSprat/Knifeybot | public void initializeResultsMetadataFromCache ( String sql , CachedResultSetMetaData cachedMetaData , ResultSetInternalMethods resultSet ) throws SQLException { if ( cachedMetaData == null ) { cachedMetaData = new CachedResultSetMetaData ( ) ; resultSet . buildIndexMapping ( ) ; resultSet . initializeWithMetadata ( ) ; if ( resultSet instanceof UpdatableResultSet ) { ( ( UpdatableResultSet ) resultSet ) . checkUpdatability ( ) ; } resultSet . populateCachedMetaData ( cachedMetaData ) ; this . resultSetMetadataCache . put ( sql , cachedMetaData ) ; } else { resultSet . initializeFromCachedMetaData ( cachedMetaData ) ; resultSet . initializeWithMetadata ( ) ; if ( resultSet instanceof UpdatableResultSet ) { ( ( UpdatableResultSet ) resultSet ) . checkUpdatability ( ) ; } } }
JackSprat/Knifeybot | public String getStatementComment ( ) { return this . statementComment ; }
JackSprat/Knifeybot | public void setStatementComment ( String comment ) { this . statementComment = comment ; }
JackSprat/Knifeybot | public void reportQueryTime ( long millisOrNanos ) { synchronized ( getConnectionMutex ( ) ) { this . queryTimeCount ++ ; this . queryTimeSum += millisOrNanos ; this . queryTimeSumSquares += ( millisOrNanos * millisOrNanos ) ; this . queryTimeMean = ( ( this . queryTimeMean * ( this . queryTimeCount - 1 ) ) + millisOrNanos ) / this . queryTimeCount ; } }
JackSprat/Knifeybot | public boolean isAbonormallyLongQuery ( long millisOrNanos ) { synchronized ( getConnectionMutex ( ) ) { if ( this . queryTimeCount < 15 ) { return false ; } double stddev = Math . sqrt ( ( this . queryTimeSumSquares - ( ( this . queryTimeSum * this . queryTimeSum ) / this . queryTimeCount ) ) / ( this . queryTimeCount - 1 ) ) ; return millisOrNanos > ( this . queryTimeMean + 5 * stddev ) ; } }
JackSprat/Knifeybot | public void initializeExtension ( Extension ex ) throws SQLException { ex . init ( this , this . props ) ; }
JackSprat/Knifeybot | public void transactionBegun ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . transactionBegun ( ) ; } } ; iter . doForAll ( ) ; } } }
JackSprat/Knifeybot | public void transactionCompleted ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . transactionCompleted ( ) ; } } ; iter . doForAll ( ) ; } } }
JackSprat/Knifeybot | public boolean storesLowerCaseTableName ( ) { return this . storesLowerCaseTableName ; }
JackSprat/Knifeybot | @ Override public ExceptionInterceptor getExceptionInterceptor ( ) { return this . exceptionInterceptor ; }
JackSprat/Knifeybot | public boolean getRequiresEscapingEncoder ( ) { return this . requiresEscapingEncoder ; }
JackSprat/Knifeybot | public boolean isServerLocal ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { SocketFactory factory = getIO ( ) . socketFactory ; if ( factory instanceof SocketMetadata ) { return ( ( SocketMetadata ) factory ) . isLocallyConnected ( this ) ; } getLog ( ) . logWarn ( Messages . getString ( " Connection . NoMetadataOnSocketFactory " ) ) ; return false ; } }
JackSprat/Knifeybot | public int getSessionMaxRows ( ) { synchronized ( getConnectionMutex ( ) ) { return this . sessionMaxRows ; } }
JackSprat/Knifeybot | public void setSessionMaxRows ( int max ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . sessionMaxRows != max ) { this . sessionMaxRows = max ; execSQL ( null , " SET ▁ SQL _ SELECT _ LIMIT = " + ( this . sessionMaxRows == - 1 ? " DEFAULT " : this . sessionMaxRows ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } }
JackSprat/Knifeybot | public void setSchema ( String schema ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; } }
JackSprat/Knifeybot | public String getSchema ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; return null ; } }
JackSprat/Knifeybot | public void abort ( Executor executor ) throws SQLException { SecurityManager sec = System . getSecurityManager ( ) ; if ( sec != null ) { sec . checkPermission ( ABORT_PERM ) ; } if ( executor == null ) { throw SQLError . createSQLException ( " Executor ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } executor . execute ( new Runnable ( ) { public void run ( ) { try { abortInternal ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } } ) ; }
JackSprat/Knifeybot | public void setNetworkTimeout ( Executor executor , final int milliseconds ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { SecurityManager sec = System . getSecurityManager ( ) ; if ( sec != null ) { sec . checkPermission ( SET_NETWORK_TIMEOUT_PERM ) ; } if ( executor == null ) { throw SQLError . createSQLException ( " Executor ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } checkClosed ( ) ; final MysqlIO mysqlIo = this . io ; executor . execute ( new Runnable ( ) { public void run ( ) { try { setSocketTimeout ( milliseconds ) ; mysqlIo . setSocketTimeout ( milliseconds ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } } ) ; } }
JackSprat/Knifeybot | public int getNetworkTimeout ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; return getSocketTimeout ( ) ; } }
JackSprat/Knifeybot | public ProfilerEventHandler getProfilerEventHandlerInstance ( ) { return this . eventSink ; }
JackSprat/Knifeybot | public void setProfilerEventHandlerInstance ( ProfilerEventHandler h ) { this . eventSink = h ; }
abhishek24509/aribaweb | protected void sleep ( ) { _destinationElementId = null ; _sourceElementId = null ; super . sleep ( ) ; }
cloudrain21/hamsterdb | public void handleMessage ( int level , String message ) { m_counter ++ ; }
cloudrain21/hamsterdb | public void testSetErrorHandler ( ) { Environment env = new Environment ( ) ; MyErrorHandler eh = new MyErrorHandler ( ) ; try { Database . setErrorHandler ( eh ) ; env . create ( null ) ; } catch ( DatabaseException err ) { assertEquals ( Const . HAM_INV_PARAMETER , err . getErrno ( ) ) ; assertEquals ( 1 , eh . m_counter ) ; } Database . setErrorHandler ( null ) ; }
cloudrain21/hamsterdb | public void testGetVersion ( ) { Version v = Database . getVersion ( ) ; assertEquals ( 2 , v . major ) ; assertEquals ( 1 , v . minor ) ; }
cloudrain21/hamsterdb | public void testDatabase ( ) { Database db = new Database ( 0 ) ; db . close ( ) ; }
cloudrain21/hamsterdb | public void testGetDatabaseException ( ) { Environment env = new Environment ( ) ; try { env . create ( " jtest . db " ) ; Database db = env . createDatabase ( ( short ) 1 , 1234 ) ; } catch ( DatabaseException err ) { assertEquals ( Const . HAM_INV_PARAMETER , err . getErrno ( ) ) ; } env . close ( ) ; }
cloudrain21/hamsterdb | public int compare ( byte [ ] lhs , byte [ ] rhs ) { m_counter ++ ; return m_counter ; }
cloudrain21/hamsterdb | public void testSetComparator ( ) { byte [ ] k = new byte [ 5 ] ; byte [ ] r = new byte [ 5 ] ; Environment env = new Environment ( ) ; Database db ; MyComparator cmp = new MyComparator ( ) ; try { env . create ( " jtest . db " ) ; Parameter [ ] params = new Parameter [ 1 ] ; params [ 0 ] = new Parameter ( ) ; params [ 0 ] . name = Const . HAM_PARAM_KEY_TYPE ; params [ 0 ] . value = Const . HAM_TYPE_CUSTOM ; db = env . createDatabase ( ( short ) 1 , 0 , params ) ; db . setComparator ( cmp ) ; db . insert ( k , r ) ; k [ 0 ] = 1 ; db . insert ( k , r ) ; k [ 0 ] = 2 ; db . insert ( k , r ) ; db . close ( ) ; } catch ( DatabaseException err ) { fail ( " Exception ▁ " + err ) ; } assertEquals ( 2 , cmp . m_counter ) ; env . close ( ) ; }
cloudrain21/hamsterdb | public void testGetParameters ( ) { byte [ ] k = new byte [ 5 ] ; byte [ ] r = new byte [ 5 ] ; Parameter [ ] params = new Parameter [ 10 ] ; for ( int i = 0 ; i < params . length ; i ++ ) { params [ i ] = new Parameter ( ) ; } params [ 0 ] . name = Const . HAM_PARAM_KEYSIZE ; params [ 1 ] . name = Const . HAM_PARAM_DATABASE_NAME ; params [ 2 ] . name = Const . HAM_PARAM_FLAGS ; params [ 3 ] . name = Const . HAM_PARAM_MAX_KEYS_PER_PAGE ; Database db ; Environment env = new Environment ( ) ; try { env . create ( " jtest . db " ) ; db = env . createDatabase ( ( short ) 1 ) ; db . getParameters ( params ) ; db . close ( ) ; } catch ( DatabaseException err ) { fail ( " Exception ▁ " + err ) ; } assertEquals ( Const . HAM_KEY_SIZE_UNLIMITED , params [ 0 ] . value ) ; assertEquals ( 1 , params [ 1 ] . value ) ; assertEquals ( 0 , params [ 2 ] . value ) ; assertEquals ( 441 , params [ 3 ] . value ) ; env . close ( ) ; }
cloudrain21/hamsterdb | public void testGetKeyCount ( ) { byte [ ] k = new byte [ 5 ] ; byte [ ] r = new byte [ 5 ] ; Database db ; Environment env = new Environment ( ) ; try { env . create ( " jtest . db " ) ; db = env . createDatabase ( ( short ) 1 ) ; assertEquals ( 0 , db . getKeyCount ( ) ) ; db . insert ( k , r ) ; assertEquals ( 1 , db . getKeyCount ( ) ) ; k [ 0 ] = 1 ; db . insert ( k , r ) ; assertEquals ( 2 , db . getKeyCount ( ) ) ; k [ 0 ] = 2 ; db . insert ( k , r ) ; assertEquals ( 3 , db . getKeyCount ( ) ) ; db . close ( ) ; } catch ( DatabaseException err ) { fail ( " Exception ▁ " + err ) ; } env . close ( ) ; }
googleads/googleads-java-lib | public Stats getStats ( ) { return stats ; }
googleads/googleads-java-lib | public void setStats ( Stats value ) { this . stats = value ; }
googleads/googleads-java-lib | public List < LongStatsMapEntry > getCreativeSetStats ( ) { if ( creativeSetStats == null ) { creativeSetStats = new ArrayList < LongStatsMapEntry > ( ) ; } return this . creativeSetStats ; }
googleads/googleads-java-lib | public Money getCostInOrderCurrency ( ) { return costInOrderCurrency ; }
googleads/googleads-java-lib | public void setCostInOrderCurrency ( Money value ) { this . costInOrderCurrency = value ; }
google/copybara | public GitHubApiException ( int httpCode , @ Nullable ClientError error , String httpMethod , String path , @ Nullable String request , String response ) { super ( detailedError ( httpMethod , path , request , response , httpCode ) ) ; this . httpCode = httpCode ; this . responseCode = parseResponseCode ( httpCode ) ; this . error = error ; this . httpMethod = httpMethod ; this . path = path ; this . request = request ; this . response = response ; }
google/copybara | public ResponseCode getResponseCode ( ) { return responseCode ; }
google/copybara | public int getHttpCode ( ) { return httpCode ; }
google/copybara | public ClientError getError ( ) { return error ; }
google/copybara | public String getRawError ( ) { return detailedError ( httpMethod , path , request , response , httpCode ) ; }
google/copybara | ResponseCode ( int code ) { this . code = code ; }
google/copybara | public int getCode ( ) { return code ; }
ahmedvc/umple | public EllipticalShape ( String aCenter , String aSemiMajorAxis ) { super ( aCenter ) ; semiMajorAxis = aSemiMajorAxis ; }
ahmedvc/umple | public boolean setSemiMajorAxis ( String aSemiMajorAxis ) { boolean wasSet = false ; semiMajorAxis = aSemiMajorAxis ; wasSet = true ; return wasSet ; }
ahmedvc/umple | public String getSemiMajorAxis ( ) { return semiMajorAxis ; }
ahmedvc/umple | public void delete ( ) { super . delete ( ) ; }
ahmedvc/umple | public String toString ( ) { String outputString = " " ; return super . toString ( ) + " [ " + " semiMajorAxis " + " : " + getSemiMajorAxis ( ) + " ] " + outputString ; }
McLeodMoores/starling | public DataRegionSourceResource ( final RegionSource regionSource ) { ArgumentChecker . notNull ( regionSource , " regionSource " ) ; _regSource = regionSource ; }
McLeodMoores/starling | public RegionSource getRegionSource ( ) { return _regSource ; }
McLeodMoores/starling | @ GET public Response getHateaos ( @ Context final UriInfo uriInfo ) { return hateoasResponse ( uriInfo ) ; }
McLeodMoores/starling | @ GET @ Path ( " regions " ) public Response search ( @ QueryParam ( " versionAsOf " ) final String versionAsOf , @ QueryParam ( " correctedTo " ) final String correctedTo , @ QueryParam ( " id " ) final List < String > externalIdStrs ) { final VersionCorrection vc = VersionCorrection . parse ( versionAsOf , correctedTo ) ; final ExternalIdBundle bundle = ExternalIdBundle . parse ( externalIdStrs ) ; final Collection < ? extends Region > result = getRegionSource ( ) . get ( bundle , vc ) ; return responseOkObject ( FudgeListWrapper . of ( result ) ) ; }
McLeodMoores/starling | " ) public Response get ( @ PathParam ( " regionId " ) final String idStr , @ QueryParam ( " version " ) final String version , @ QueryParam ( " versionAsOf " ) final String versionAsOf , @ QueryParam ( " correctedTo " ) final String correctedTo ) { final ObjectId objectId = ObjectId . parse ( idStr ) ; if ( version != null ) { final Region result = getRegionSource ( ) . get ( objectId . atVersion ( version ) ) ; return responseOkObject ( result ) ; } final VersionCorrection vc = VersionCorrection . parse ( versionAsOf , correctedTo ) ; final Region result = getRegionSource ( ) . get ( objectId , vc ) ; return responseOkObject ( result ) ; }
McLeodMoores/starling | @ GET @ Path ( " regionSearches / highest " ) public Response searchHighest ( @ QueryParam ( " id " ) final List < String > externalIdStrs ) { final ExternalIdBundle bundle = ExternalIdBundle . parse ( externalIdStrs ) ; final Region result = getRegionSource ( ) . getHighestLevelRegion ( bundle ) ; return responseOkObject ( result ) ; }
gjordi/gwt-jsni | private JsArrayUtil ( ) { }
ionutsp17/JavaMainRepo | public CardPanel ( String imagePath ) { this . loadCardImage ( imagePath ) ; }
ionutsp17/JavaMainRepo | public void paintComponent ( Graphics g ) { g . drawImage ( this . cardImage , 2 , 2 , this ) ; }
ionutsp17/JavaMainRepo | public void loadCardImage ( String imagePath ) { this . cardImage = new ImageIcon ( imagePath ) . getImage ( ) ; }
danileyang/mmp | if ( queryParam != null ) { if ( uri . indexOf ( ' ? ' ) == - 1 ) { uri += ' ? ' ; } uri += uri . endsWith ( " ? " ) ? queryParam : ' & ' + queryParam ; }
danileyang/mmp | if ( httpProxy != null ) { RequestConfig config = RequestConfig . custom ( ) . setProxy ( httpProxy ) . build ( ) ; httpGet . setConfig ( config ) ; }
danileyang/mmp | if ( error . getErrorCode ( ) != 0 ) { throw new WxErrorException ( error ) ; }
danileyang/mmp | if ( queryParam != null ) { if ( uri . indexOf ( ' ? ' ) == - 1 ) { uri += ' ? ' ; } uri += uri . endsWith ( " ? " ) ? queryParam : ' & ' + queryParam ; }
danileyang/mmp | if ( httpProxy != null ) { RequestConfig config = RequestConfig . custom ( ) . setProxy ( httpProxy ) . build ( ) ; httpGet . setConfig ( config ) ; }
danileyang/mmp | if ( error . getErrorCode ( ) != 0 ) { throw new WxErrorException ( error ) ; }
daniel-beck/sorcerer | protected JsArray ( ) { }
daniel-beck/sorcerer | public final Iterable < T > iterable ( ) { return new Iterable < T > ( ) { public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { int index = 0 ; public boolean hasNext ( ) { return index < length ( ) ; } public T next ( ) { return get ( index ++ ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; }
gabelew/SimCity201 | public payment ( double a , DeliveryMan d , payState received , int num ) { delivery = d ; amount = a ; pState = received ; payNum = num ; }
gabelew/SimCity201 | public customer ( Customer c , float amount ) { cust = c ; owed = amount ; }
gabelew/SimCity201 | public Check ( Waiter waiter , String choice2 , int tableNumber2 , state created ) { w = waiter ; choice = choice2 ; tableNumber = tableNumber2 ; S = created ; }
gabelew/SimCity201 | public EBCashierRole ( ) { super ( ) ; payNumber = 0 ; }
gabelew/SimCity201 | public void msgHereIsCheck ( Waiter w , String choice , int tableNumber ) { Checks . add ( new Check ( w , choice , tableNumber , state . created ) ) ; stateChanged ( ) ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Creating ▁ check ▁ for ▁ table ▁ " + tableNumber ) ; }
gabelew/SimCity201 | public void msgPaying ( double amount , int tableNumber , boolean payInFull ) { for ( Check c : Checks ) { if ( c . tableNumber == tableNumber ) { if ( payInFull ) { c . S = state . paid ; } else { c . S = state . waiting ; } bank = bank + amount ; } } amount = ( Math . round ( 100 * amount ) / ( ( double ) 100 ) ) ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Received ▁ payment ▁ of ▁ " + amount + " ▁ for ▁ table ▁ " + tableNumber ) ; }
gabelew/SimCity201 | public void msgAddToTab ( double amount , Customer cust ) { exists = false ; for ( customer c : Customers ) { if ( c . cust == cust ) { c . owed = c . owed + ( float ) amount ; exists = true ; } } if ( ! exists ) { Customers . add ( new customer ( cust , ( float ) amount ) ) ; } }
gabelew/SimCity201 | public void msgHereIsInvoice ( double amount , DeliveryMan DM ) { receivedInvoice = true ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Received ▁ invoice ▁ from ▁ cook " ) ; stateChanged ( ) ; }
gabelew/SimCity201 | public boolean pickAndExecuteAnAction ( ) { try { if ( cashierState == CashState . releaveFromDuty ) { cashierState = CashState . none ; myPerson . releavedFromDuty ( this ) ; if ( replacementPerson != null ) { replacementPerson . waitingResponse . release ( ) ; } } if ( cashierState == CashState . goToWork ) { cashierState = CashState . working ; cashierGui . DoEnterRestaurant ( ) ; return true ; } if ( cashierState == CashState . leaving ) { boolean needsToPay = false ; for ( payment p : Payments ) { if ( p . pState != payState . owes ) { needsToPay = true ; } } if ( ! needsToPay ) { cashierState = CashState . none ; if ( ! " Saturday " . equals ( myPerson . dayOfWeek ) && ! " Sunday " . equals ( myPerson . dayOfWeek ) && myPerson . aBankIsOpen ( ) ) DepositBusinessCash ( ) ; cashierGui . DoLeaveRestaurant ( ) ; return true ; } } for ( payment p : Payments ) { if ( p . pState == payState . receivedBill && receivedInvoice && bank > 0 ) { payMarket ( p ) ; return true ; } if ( p . pState == payState . lastTime && bank > 0 ) { neverOrderFromMarketAgain ( p ) ; payMarket ( p ) ; return true ; } if ( p . pState == payState . owes && bank > 0 ) { payMarket ( p ) ; return true ; } } for ( Check c : Checks ) { if ( c . S == state . created ) { c . S = state . waiting ; createCheck ( c . choice , c . tableNumber , c . w ) ; return true ; } } for ( Check c : Checks ) { if ( c . S == state . paid ) { removeCheck ( c . tableNumber ) ; return true ; } } return false ; } catch ( ConcurrentModificationException e ) { return false ; } }
gabelew/SimCity201 | private void neverOrderFromMarketAgain ( payment p ) { restaurant . cook . msgNeverOrderFromMarketAgain ( ( ( DeliveryManRole ) p . delivery ) . Market ) ; }
gabelew/SimCity201 | private void payMarket ( payment p ) { if ( bank < p . amount ) { p . pState = payState . owes ; } else { receivedInvoice = false ; p . pState = payState . paid ; p . delivery . msgHereIsPayment ( p . amount , this ) ; bank = bank - p . amount ; Payments . remove ( p ) ; AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Payed ▁ market : ▁ " + p . amount ) ; } }
gabelew/SimCity201 | private void createCheck ( String choice , int tableNumber , Waiter waiter ) { ( ( EBWaiterRole ) waiter ) . msgCheckCreated ( menu . hm . get ( choice ) , tableNumber ) ; }
gabelew/SimCity201 | public void removeCheck ( int tableNumber ) { for ( Check c : Checks ) { if ( c . tableNumber == tableNumber ) { Checks . remove ( c ) ; } } }
gabelew/SimCity201 | private void DepositBusinessCash ( ) { double cash = bank - 1500 ; cash = ( Math . round ( 100 * cash ) / ( ( double ) 100 ) ) ; int balance = Double . compare ( cash , 0 ) ; if ( 1 == balance ) { bank -= cash ; myPerson . businessFunds += cash ; myPerson . msgDepositBusinessCash ( ) ; } AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Depositing ▁ business ▁ cash " ) ; }
gabelew/SimCity201 | public void msgHereIsBill ( DeliveryMan DMR , double bill ) { boolean exists = false ; for ( payment p : Payments ) { if ( p . delivery == DMR ) { if ( receivedInvoice ) { exists = true ; p . pState = payState . paying ; if ( p . amount != bill ) { p . pState = payState . lastTime ; } } } } if ( ! exists ) { Payments . add ( new payment ( bill , DMR , payState . receivedBill , payNumber ) ) ; } AlertLog . getInstance ( ) . logMessage ( AlertTag . REST_CASHIER , this . getName ( ) , " Received ▁ Bill ▁ from ▁ Delivery ▁ Man " ) ; stateChanged ( ) ; }
gabelew/SimCity201 | public void msgReleaveFromDuty ( PersonAgent p ) { replacementPerson = p ; cashierState = CashState . leaving ; this . stateChanged ( ) ; }
gabelew/SimCity201 | public void goesToWork ( ) { cashierState = CashState . goToWork ; stateChanged ( ) ; }
gabelew/SimCity201 | public void setRestaurant ( Restaurant r ) { restaurant = r ; }
gabelew/SimCity201 | public void setGui ( EBCashierGui g ) { cashierGui = g ; }
gabelew/SimCity201 | public EBCashierGui getGui ( ) { return cashierGui ; }
gabelew/SimCity201 | public void setGui ( Gui g ) { cashierGui = ( EBCashierGui ) g ; }
gabelew/SimCity201 | public void msgLeft ( ) { cashierState = CashState . releaveFromDuty ; stateChanged ( ) ; }
gabelew/SimCity201 | public void msgClosed ( ) { cashierState = CashState . leaving ; stateChanged ( ) ; }
neoteric-eu/neo-starters | private TestContext mockTestClassContext ( Object instance ) { TestContext testContext = mock ( TestContext . class ) ; given ( testContext . getTestClass ( ) ) . willReturn ( ( Class ) instance . getClass ( ) ) ; given ( testContext . getApplicationContext ( ) ) . willReturn ( applicationContext ) ; return testContext ; }
neoteric-eu/neo-starters | @ Before public void setCollection ( ) { mongoTemplate . getCollection ( COLLECTION_NAME ) . insert ( new BasicDBObject ( ) ) ; mongoTemplate . getCollection ( COLLECTION_NAME ) . createIndex ( ADDITIONAL_INDEX ) ; }
neoteric-eu/neo-starters | @ Test public void shouldClearCollectionAndLeaveIndex ( ) throws Exception { WithClearCollectionClassAnnotation instance = new WithClearCollectionClassAnnotation ( ) ; cleanUpListener . afterTestMethod ( mockTestClassContext ( instance ) ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . count ( ) ) . isEqualTo ( 0 ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . size ( ) ) . isEqualTo ( 2 ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . get ( 0 ) . get ( " key " ) ) . isEqualTo ( DEFAULT_INDEX ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . get ( 1 ) . get ( " key " ) ) . isEqualTo ( ADDITIONAL_INDEX ) ; }
neoteric-eu/neo-starters | @ Test public void shouldDropCollectionAndIndex ( ) throws Exception { WithClearDropCollectionClassAnnotation instance = new WithClearDropCollectionClassAnnotation ( ) ; cleanUpListener . afterTestMethod ( mockTestClassContext ( instance ) ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . count ( ) ) . isEqualTo ( 0 ) ; assertThat ( mongoTemplate . getCollection ( COLLECTION_NAME ) . getIndexInfo ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
apetresc/aws-sdk-for-java-on-gae | public Request < DeleteLoadBalancerListenersRequest > marshall ( DeleteLoadBalancerListenersRequest deleteLoadBalancerListenersRequest ) { Request < DeleteLoadBalancerListenersRequest > request = new DefaultRequest < DeleteLoadBalancerListenersRequest > ( deleteLoadBalancerListenersRequest , " AmazonElasticLoadBalancing " ) ; request . addParameter ( " Action " , " DeleteLoadBalancerListeners " ) ; request . addParameter ( " Version " , "2010-07-01" ) ; if ( deleteLoadBalancerListenersRequest != null ) { if ( deleteLoadBalancerListenersRequest . getLoadBalancerName ( ) != null ) { request . addParameter ( " LoadBalancerName " , StringUtils . fromString ( deleteLoadBalancerListenersRequest . getLoadBalancerName ( ) ) ) ; } } if ( deleteLoadBalancerListenersRequest != null ) { java . util . List < Integer > loadBalancerPortsList = deleteLoadBalancerListenersRequest . getLoadBalancerPorts ( ) ; int loadBalancerPortsListIndex = 1 ; for ( Integer loadBalancerPortsListValue : loadBalancerPortsList ) { if ( loadBalancerPortsListValue != null ) { request . addParameter ( " LoadBalancerPorts . member . " + loadBalancerPortsListIndex , StringUtils . fromInteger ( loadBalancerPortsListValue ) ) ; } loadBalancerPortsListIndex ++ ; } } return request ; }
Azure/azure-sdk-for-java | public Boolean isTrusted ( ) { return this . isTrusted ; }
Azure/azure-sdk-for-java | public GatewayCertificateAuthorityContractProperties withIsTrusted ( Boolean isTrusted ) { this . isTrusted = isTrusted ; return this ; }
Azure/azure-sdk-for-java | public void validate ( ) { }
jordiponsllaurado/TypeformVoice | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . submit ) ; Intent messageIntent = getIntent ( ) ; String message = messageIntent . getStringExtra ( EXTRA_MESSAGE ) ; mText = ( TextView ) findViewById ( R . id . welcome_text ) ; String json = " { " + " ▁ ▁ \" title \" : \" Challenge ▁ satisfaction ▁ survey \" , " + " \" settings \" : ▁ { " + " ▁ ▁ ▁ ▁ \" language \" : ▁ \" en \" " + " ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" thankyou _ screens \" : ▁ [ " + " ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" Thank ▁ you ▁ for ▁ participating ! \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ \" properties \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" show _ button \" : ▁ true , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" button _ text \" : ▁ \" start \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" button _ mode \" : ▁ \" redirect \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" redirect _ url \" : ▁ \" http : // www . typeform . com \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" share _ icons \" : ▁ false " + " ▁ ▁ ▁ ▁ } " + " } " + " ▁ ▁ ] , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" fields \" : ▁ [ " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" What ' s ▁ your ▁ name ? \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" type \" : ▁ \" short _ text \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" validations \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" required \" : ▁ false , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" max _ length \" : ▁ 20" + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" " + message + " \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" type \" : ▁ \" opinion _ scale \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" properties \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" description \" : ▁ \" \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" steps \" : ▁ 10 , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" start _ at _ one \" : ▁ true , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" labels \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" left \" : ▁ \" ▁ left ▁ label \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" center \" : ▁ \" center ▁ label \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" right \" : ▁ \" right ▁ label \" " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" validations \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" required \" : ▁ false " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ] " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " ; try { JSONObject jsonObject = new JSONObject ( json ) ; bob = new BobTheBuilder ( jsonObject ) ; bob . execute ( ) ; } catch ( JSONException e ) { } mTts = new TextToSpeech ( this , new TextToSpeech . OnInitListener ( ) { @ Override public void onInit ( int i ) { if ( i == TextToSpeech . SUCCESS ) { mTts . setOnUtteranceCompletedListener ( new TextToSpeech . OnUtteranceCompletedListener ( ) { @ Override public void onUtteranceCompleted ( String utteranceId ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { emailBtn = ( Button ) findViewById ( R . id . email ) ; emailBtn . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { String responseBody = bob . getResponseBody ( ) ; try { String jsonObj = new JSONObject ( responseBody ) . getString ( " id " ) ; Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( " message / rfc822" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { " all @ typeform . com " } ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , " Rate ▁ the ▁ Challenge ! " ) ; intent . setPackage ( " com . google . android . gm " ) ; intent . putExtra ( Intent . EXTRA_TEXT , Html . fromHtml ( " Please ▁ fill ▁ the ▁ following ▁ form : ▁ < a ▁ href = \" https : // pauboix . typeform . com / to " + jsonObj + " \" > Link < / a > " ) ) ; if ( intent . resolveActivity ( getPackageManager ( ) ) != null ) startActivity ( intent ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } } ) ; } } ) ; } } ) ; mTts . setLanguage ( Locale . getDefault ( ) ) ; HashMap < String , String > params = new HashMap < String , String > ( ) ; params . put ( TextToSpeech . Engine . KEY_PARAM_UTTERANCE_ID , " stringId " ) ; mTts . speak ( " Your ▁ Typeform ▁ is ▁ Done ! \n ▁ Do ▁ you ▁ want ▁ to ▁ send ▁ it ▁ out ▁ now ? " , TextToSpeech . QUEUE_FLUSH , params ) ; } else { mTts = null ; Log . e ( " MainActivity " , " Failed ▁ to ▁ initialize ▁ the ▁ TextToSpeech ▁ engine " ) ; } } } ) ; }
jordiponsllaurado/TypeformVoice | @ Override protected void onStop ( ) { stopVoiceRecorder ( ) ; mSpeechService = null ; super . onStop ( ) ; }
jordiponsllaurado/TypeformVoice | private final VoiceRecorder . Callback mVoiceCallback = new VoiceRecorder . Callback ( ) { @ Override public void onVoiceStart ( ) { if ( mSpeechService != null ) { mSpeechService . startRecognizing ( mVoiceRecorder . getSampleRate ( ) ) ; } } @ Override public void onVoice ( byte [ ] data , int size ) { if ( mSpeechService != null ) { mSpeechService . recognize ( data , size ) ; } } @ Override public void onVoiceEnd ( ) { if ( mSpeechService != null ) { mSpeechService . finishRecognizing ( ) ; } } }
jordiponsllaurado/TypeformVoice | private final ServiceConnection mServiceConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName componentName , IBinder binder ) { mSpeechService = SpeechService . from ( binder ) ; mSpeechService . addListener ( mSpeechServiceListener ) ; } @ Override public void onServiceDisconnected ( ComponentName componentName ) { mSpeechService = null ; } }
jordiponsllaurado/TypeformVoice | private final SpeechService . Listener mSpeechServiceListener = new SpeechService . Listener ( ) { @ Override public void onSpeechRecognized ( final String text , final boolean isFinal ) { if ( isFinal ) { mVoiceRecorder . dismiss ( ) ; } if ( mText != null && ! TextUtils . isEmpty ( text ) ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( isFinal ) { mVoiceRecorder . stop ( ) ; String responseBody = bob . getResponseBody ( ) ; Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( " message / rfc822" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { " all @ typeform . com " } ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , " Rate ▁ the ▁ Challenge ! " ) ; intent . setPackage ( " com . google . android . gm " ) ; intent . putExtra ( Intent . EXTRA_TEXT , responseBody ) ; if ( intent . resolveActivity ( getPackageManager ( ) ) != null ) startActivity ( intent ) ; } else { } } } ) ; } } }
jordiponsllaurado/TypeformVoice | private void startVoiceRecorder ( ) { if ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . RECORD_AUDIO ) == PackageManager . PERMISSION_GRANTED ) { if ( mVoiceRecorder != null ) { mVoiceRecorder . stop ( ) ; } mVoiceRecorder = new VoiceRecorder ( mVoiceCallback ) ; mVoiceRecorder . start ( ) ; } }
jordiponsllaurado/TypeformVoice | private void stopVoiceRecorder ( ) { if ( mVoiceRecorder != null ) { mVoiceRecorder . stop ( ) ; mVoiceRecorder = null ; } }
anninpavel/VTUZ_SE_Store | @ NonNull @ Override public Observable < RealmResults < StoreModel > > getAll ( ) { return RealmUtil . getRealm ( ) . where ( StoreModel . class ) . findAllSorted ( StoreModel . FIELD_NAME ) . asObservable ( ) . filter ( RealmResults :: isLoaded ) ; }
anninpavel/VTUZ_SE_Store | @ NonNull @ Override public Observable < StoreModel > getById ( @ NonNull String id ) { return RealmUtil . getRealm ( ) . where ( StoreModel . class ) . equalTo ( StoreModel . FIELD_ID , id ) . findFirst ( ) . asObservable ( ) ; }
anninpavel/VTUZ_SE_Store | @ Override public void asyncCreateStore ( @ NonNull String name ) { RealmUtil . getRealm ( ) . executeTransactionAsync ( realm -> { StoreModel store = realm . createObject ( StoreModel . class ) ; store . setId ( UUID . randomUUID ( ) . toString ( ) ) ; store . setName ( name ) ; } ) ; }
anninpavel/VTUZ_SE_Store | @ Override public void asyncSaveStore ( @ NonNull String id , @ NonNull String name ) { RealmUtil . getRealm ( ) . executeTransactionAsync ( realm -> { StoreModel store = realm . where ( StoreModel . class ) . equalTo ( StoreModel . FIELD_ID , id ) . findFirst ( ) ; if ( store != null && store . isValid ( ) ) { store . setName ( name ) ; } } ) ; }
anninpavel/VTUZ_SE_Store | @ Override public boolean canStoreRemoved ( @ NonNull String id ) { return RealmUtil . getRealm ( ) . where ( InvoiceModel . class ) . equalTo ( InvoiceModel . FIELD_STORE + " . " + StoreModel . FIELD_ID , id ) . count ( ) == 0 ; }
anninpavel/VTUZ_SE_Store | @ Override public void asyncRemoveStore ( @ NonNull String id ) { RealmUtil . getRealm ( ) . executeTransactionAsync ( realm -> { StoreModel store = realm . where ( StoreModel . class ) . equalTo ( StoreModel . FIELD_ID , id ) . findFirst ( ) ; if ( store != null && store . isValid ( ) ) { store . deleteFromRealm ( ) ; } } ) ; }
eswdd/disco | @ Test public void doTest ( ) throws Exception { DiscoManager discoManager1 = DiscoManager . getInstance ( ) ; HttpCallBean httpCallBeanBaseline = discoManager1 . getNewHttpCallBean ( ) ; DiscoManager discoManagerBaseline = discoManager1 ; httpCallBeanBaseline . setServiceName ( " baseline " , " discoBaseline " ) ; httpCallBeanBaseline . setVersion ( " v2" ) ; DiscoManager discoManager2 = DiscoManager . getInstance ( ) ; HttpCallBean getNewHttpCallBean2 = discoManager2 . getNewHttpCallBean ( "87.248.113.14" ) ; discoManager2 = discoManager2 ; discoManager2 . setDiscoFaultControllerJMXMBeanAttrbiute ( " DetailedFaults " , " false " ) ; getNewHttpCallBean2 . setOperationName ( " simpleMapOperation " ) ; getNewHttpCallBean2 . setServiceName ( " baseline " , " discoBaseline " ) ; getNewHttpCallBean2 . setVersion ( " v2" ) ; Timestamp getTimeAsTimeStamp8 = new Timestamp ( System . currentTimeMillis ( ) ) ; discoManager2 . makeRestDiscoHTTPCall ( getNewHttpCallBean2 , DiscoMessageProtocolRequestTypeEnum . RESTXML , DiscoMessageContentTypeEnum . XML ) ; discoManager2 . makeRestDiscoHTTPCall ( getNewHttpCallBean2 , DiscoMessageProtocolRequestTypeEnum . RESTXML , DiscoMessageContentTypeEnum . JSON ) ; XMLHelpers xMLHelpers4 = new XMLHelpers ( ) ; Document createAsDocument11 = xMLHelpers4 . getXMLObjectFromString ( " < fault > < faultcode > Client < / faultcode > < faultstring > DSC - 0044 < / faultstring > < detail / > < / fault > " ) ; JSONHelpers jSONHelpers5 = new JSONHelpers ( ) ; JSONObject convertXMLDocumentToJSONObjectRemoveRootElement12 = jSONHelpers5 . convertXMLDocumentToJSONObjectRemoveRootElement ( createAsDocument11 ) ; HttpResponseBean response6 = getNewHttpCallBean2 . getResponseObjectsByEnum ( DiscoMessageProtocolResponseTypeEnum . RESTXMLXML ) ; AssertionUtils . multiAssertEquals ( createAsDocument11 , response6 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response6 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response6 . getHttpStatusText ( ) ) ; HttpResponseBean response7 = getNewHttpCallBean2 . getResponseObjectsByEnum ( DiscoMessageProtocolResponseTypeEnum . RESTXMLJSON ) ; AssertionUtils . multiAssertEquals ( convertXMLDocumentToJSONObjectRemoveRootElement12 , response7 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 400 , response7 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " Bad ▁ Request " , response7 . getHttpStatusText ( ) ) ; DiscoManager discoManager10 = DiscoManager . getInstance ( ) ; discoManager10 . verifyAccessLogEntriesAfterDate ( getTimeAsTimeStamp8 , new AccessLogRequirement ( "87.248.113.14" , " / discoBaseline / v2 / simpleMapOperation " , " BadRequest " ) , new AccessLogRequirement ( "87.248.113.14" , " / discoBaseline / v2 / simpleMapOperation " , " BadRequest " ) ) ; }
joypupil/study | private SystemInfo ( ) { try { localHost = InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } }
joypupil/study | public String getIP ( ) { String ip = localHost . getHostAddress ( ) ; return ip ; }
joypupil/study | public String getHostName ( ) { return localHost . getHostName ( ) ; }
joypupil/study | public String getDiskNumber ( ) { String line = " " ; String HdSerial = " " ; try { Process proces = Runtime . getRuntime ( ) . exec ( " cmd ▁ / c ▁ dir ▁ c : " ) ; BufferedReader buffreader = new BufferedReader ( new InputStreamReader ( proces . getInputStream ( ) ) ) ; while ( ( line = buffreader . readLine ( ) ) != null ) { if ( line . indexOf ( " 卷的序列号是 ▁ " ) != - 1 ) { HdSerial = line . substring ( line . indexOf ( " 卷的序列号是 ▁ " ) + " 卷的序列号是 ▁ " . length ( ) , line . length ( ) ) ; break ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } return HdSerial ; }
joypupil/study | public String getMac ( ) { NetworkInterface byInetAddress ; try { byInetAddress = NetworkInterface . getByInetAddress ( localHost ) ; byte [ ] hardwareAddress = byInetAddress . getHardwareAddress ( ) ; return getMacFromBytes ( hardwareAddress ) ; } catch ( SocketException e ) { e . printStackTrace ( ) ; } return null ; }
joypupil/study | public String getSystemName ( ) { Properties sysProperty = System . getProperties ( ) ; String systemName = sysProperty . getProperty ( " os . name " ) ; return systemName ; }
joypupil/study | private String getMacFromBytes ( byte [ ] bytes ) { StringBuffer mac = new StringBuffer ( ) ; byte currentByte ; boolean first = false ; for ( byte b : bytes ) { if ( first ) { mac . append ( " - " ) ; } currentByte = ( byte ) ( ( b & 240 ) >> 4 ) ; mac . append ( Integer . toHexString ( currentByte ) ) ; currentByte = ( byte ) ( b & 15 ) ; mac . append ( Integer . toHexString ( currentByte ) ) ; first = true ; } return mac . toString ( ) . toUpperCase ( ) ; }
WU-ARL/RLI | public ChatMessage ( ONL . Reader rdr ) throws IOException { retrieve ( rdr ) ; }
WU-ARL/RLI | public ChatMessage ( String nm , String m ) { msg = new String ( m ) ; version = ( short ) ( ExpCoordinator . VERSION_BYTES >> 16 ) ; sender = new String ( nm ) ; }
WU-ARL/RLI | public void store ( DataOutputStream dout ) throws IOException { if ( dout == null ) ExpCoordinator . printer . print ( " NCCP . RequesterBase . storeHeader ▁ dout ▁ is ▁ null " ) ; dout . writeShort ( NCCP . MessageChat ) ; dout . writeShort ( version ) ; NCCP . writeString ( sender , dout ) ; NCCP . writeString ( msg , dout ) ; }
WU-ARL/RLI | public void retrieve ( ONL . Reader rdr ) throws IOException { version = ( short ) rdr . readShort ( ) ; sender = rdr . readString ( ) ; msg = rdr . readString ( ) ; }
WU-ARL/RLI | public short getVersion ( ) { return version ; }
WU-ARL/RLI | public String getMsg ( ) { return msg ; }
WU-ARL/RLI | public String getSender ( ) { return sender ; }
WU-ARL/RLI | public ObserveDaemon ( int sid , Observer o ) { super ( NCCPConnection . PEER , sid , ONLDaemon . OBSERVE ) ; ExpCoordinator . print ( new String ( " ObserverDaemon ▁ Observed ▁ sessionID : " + sid ) , 2 ) ; ExpCoordinator . print ( toString ( ) ) ; setProxy ( ExpCoordinator . theCoordinator . getProxy ( ) ) ; getProxy ( ) . addConnection ( this ) ; observer = o ; }
WU-ARL/RLI | if ( msgtype == NCCP . MessageChat ) { ExpCoordinator . printer . print ( " ▁ Chat ▁ Message " , 9 ) ; ChatMessage cmsg = new ChatMessage ( rdr ) ; observer . addChatMessage ( cmsg . getSender ( ) , cmsg . getMsg ( ) ) ; }
WU-ARL/RLI | if ( msg . isAck ( ) ) { ++ ackcount ; sendAck ( msg ) ; ExpCoordinator . printer . print ( new String ( " ObserveDaemon : : run ▁ message ▁ is ▁ ▁ NCCP . MessagePeriodic ▁ ack ▁ " + ackcount ) , 9 ) ; }
WU-ARL/RLI | private REND_Marker_class getNextMarker ( ) { return ( new REND_Marker_class ( ++ reqCount ) ) ; }
WU-ARL/RLI | public short getSID ( ) { return ( ( short ) getPort ( ) ) ; }
WU-ARL/RLI | public void setSID ( short sid ) { ExpCoordinator . print ( new String ( " ObserveDaemon . setSID ▁ " + sid ) , 2 ) ; setPort ( ( int ) sid ) ; }
WU-ARL/RLI | public void close ( ) { if ( ExpCoordinator . isObserver ( ) ) super . close ( ) ; else setConnected ( false ) ; }
wangsongpeng/jdk-src | private TemporalQueries ( ) { }
wangsongpeng/jdk-src | if ( temporal . isSupported ( OFFSET_SECONDS ) ) { return ZoneOffset . ofTotalSeconds ( temporal . get ( OFFSET_SECONDS ) ) ; }
wangsongpeng/jdk-src | if ( temporal . isSupported ( EPOCH_DAY ) ) { return LocalDate . ofEpochDay ( temporal . getLong ( EPOCH_DAY ) ) ; }
wangsongpeng/jdk-src | if ( temporal . isSupported ( NANO_OF_DAY ) ) { return LocalTime . ofNanoOfDay ( temporal . getLong ( NANO_OF_DAY ) ) ; }
rogerchina/activemq-artemis | public void start ( ) { bootstrap = new Bootstrap ( ) ; bootstrap . channel ( NioSocketChannel . class ) ; bootstrap . group ( new NioEventLoopGroup ( 10 ) ) ; bootstrap . handler ( new ChannelInitializer < Channel > ( ) { public void initChannel ( Channel channel ) throws Exception { } } ) ; }
rogerchina/activemq-artemis | public AMQPClientConnectionContext connect ( String host , int port ) throws Exception { SocketAddress remoteDestination = new InetSocketAddress ( host , port ) ; ChannelFuture future = bootstrap . connect ( remoteDestination ) ; future . awaitUninterruptibly ( ) ; AMQPClientSPI clientConnectionSPI = new AMQPClientSPI ( future . channel ( ) ) ; final AMQPClientConnectionContext connection = ( AMQPClientConnectionContext ) ProtonClientConnectionContextFactory . getFactory ( ) . createConnection ( clientConnectionSPI ) ; future . channel ( ) . pipeline ( ) . addLast ( new ChannelDuplexHandler ( ) { @ Override public void channelRead ( final ChannelHandlerContext ctx , final Object msg ) throws Exception { ByteBuf buffer = ( ByteBuf ) msg ; connection . inputBuffer ( buffer ) ; } } ) ; return connection ; }
justin-espedal/polydes | @ Override public void onStartup ( ) { super . onStartup ( ) ; _instance = this ; isInMenu = true ; menuName = " Paint ▁ Extension " ; isInGameCenter = true ; gameCenterName = " Paint ▁ Extension " ; }
justin-espedal/polydes | @ Override public void onActivate ( ) { }
justin-espedal/polydes | @ Override public JPanel onGameCenterActivate ( ) { return MainEditor . get ( ) ; }
justin-espedal/polydes | public JPanel getBlankPanel ( ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setBackground ( new Color ( 62 , 62 , 62 ) ) ; return panel ; }
justin-espedal/polydes | @ Override public void onDestroy ( ) { }
justin-espedal/polydes | @ Override public void onGameSave ( Game game ) { Fonts . get ( ) . saveChanges ( fontsFile ) ; Images . get ( ) . saveChanges ( imagesFile ) ; MainEditor . get ( ) . gameSaved ( ) ; }
justin-espedal/polydes | @ Override public void onGameBuild ( Game game ) { onGameSave ( game ) ; }
justin-espedal/polydes | @ Override public void onGameOpened ( Game game ) { extras = new File ( Locations . getGameLocation ( game ) + " extras / " + getManifest ( ) . id ) ; extras . mkdirs ( ) ; if ( extras . list ( ) . length == 0 ) loadDefaults ( ) ; fontsFile = new File ( extras , " fonts " ) ; imagesFile = new File ( extras , " images " ) ; Fonts . get ( ) . load ( fontsFile ) ; Images . get ( ) . load ( imagesFile ) ; }
justin-espedal/polydes | private void loadDefaults ( ) { File f ; try { f = new File ( extras , " fonts / Default ▁ Font . fnt " ) ; f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) FileHelper . writeStringToFile ( f . getAbsolutePath ( ) , Defaults . load ( " Default ▁ Font . fnt " ) ) ; f = new File ( extras , " fonts / Default ▁ Font . png " ) ; if ( ! f . exists ( ) ) FileHelper . writeToPNG ( f . getAbsolutePath ( ) , Defaults . loadImage ( " Default ▁ Font . png " ) ) ; f = new File ( extras , " images / Default ▁ Window . png " ) ; f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) FileHelper . writeToPNG ( f . getAbsolutePath ( ) , Defaults . loadImage ( " Default ▁ Window . png " ) ) ; f = new File ( extras , " images / Pointer . png " ) ; if ( ! f . exists ( ) ) FileHelper . writeToPNG ( f . getAbsolutePath ( ) , Defaults . loadImage ( " Pointer . png " ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
justin-espedal/polydes | @ Override public void onGameClosed ( Game game ) { super . onGameClosed ( game ) ; Fonts . get ( ) . unload ( ) ; Images . get ( ) . unload ( ) ; MainEditor . disposePages ( ) ; }
justin-espedal/polydes | @ Override public OptionsPanel onOptions ( ) { return null ; }
justin-espedal/polydes | @ Override protected boolean hasOptions ( ) { return false ; }
justin-espedal/polydes | @ Override public void onInstall ( ) { }
justin-espedal/polydes | @ Override public void onUninstall ( ) { }
indashnet/InDashNet.Open.UN2000 | public TextToSpeech ( Context context , OnInitListener listener ) { this ( context , listener , null ) ; }
indashnet/InDashNet.Open.UN2000 | public TextToSpeech ( Context context , OnInitListener listener , String engine ) { this ( context , listener , engine , null , true ) ; }
indashnet/InDashNet.Open.UN2000 | public TextToSpeech ( Context context , OnInitListener listener , String engine , String packageName , boolean useFallback ) { mContext = context ; mInitListener = listener ; mRequestedEngine = engine ; mUseFallback = useFallback ; mEarcons = new HashMap < String , Uri > ( ) ; mUtterances = new HashMap < String , Uri > ( ) ; mUtteranceProgressListener = null ; mEnginesHelper = new TtsEngines ( mContext ) ; if ( packageName != null ) { mPackageName = packageName ; } else { mPackageName = mContext . getPackageName ( ) ; } initTts ( ) ; }
indashnet/InDashNet.Open.UN2000 | private < R > R runActionNoReconnect ( Action < R > action , R errorResult , String method , boolean onlyEstablishedConnection ) { return runAction ( action , errorResult , method , false , onlyEstablishedConnection ) ; }
indashnet/InDashNet.Open.UN2000 | private < R > R runAction ( Action < R > action , R errorResult , String method ) { return runAction ( action , errorResult , method , true , true ) ; }
indashnet/InDashNet.Open.UN2000 | private < R > R runAction ( Action < R > action , R errorResult , String method , boolean reconnect , boolean onlyEstablishedConnection ) { synchronized ( mStartLock ) { if ( mServiceConnection == null ) { Log . w ( TAG , method + " ▁ failed : ▁ not ▁ bound ▁ to ▁ TTS ▁ engine " ) ; return errorResult ; } return mServiceConnection . runAction ( action , errorResult , method , reconnect , onlyEstablishedConnection ) ; } }
indashnet/InDashNet.Open.UN2000 | private int initTts ( ) { if ( mRequestedEngine != null ) { if ( mEnginesHelper . isEngineInstalled ( mRequestedEngine ) ) { if ( connectToEngine ( mRequestedEngine ) ) { mCurrentEngine = mRequestedEngine ; return SUCCESS ; } else if ( ! mUseFallback ) { mCurrentEngine = null ; dispatchOnInit ( ERROR ) ; return ERROR ; } } else if ( ! mUseFallback ) { Log . i ( TAG , " Requested ▁ engine ▁ not ▁ installed : ▁ " + mRequestedEngine ) ; mCurrentEngine = null ; dispatchOnInit ( ERROR ) ; return ERROR ; } } final String defaultEngine = getDefaultEngine ( ) ; if ( defaultEngine != null && ! defaultEngine . equals ( mRequestedEngine ) ) { if ( connectToEngine ( defaultEngine ) ) { mCurrentEngine = defaultEngine ; return SUCCESS ; } } final String highestRanked = mEnginesHelper . getHighestRankedEngineName ( ) ; if ( highestRanked != null && ! highestRanked . equals ( mRequestedEngine ) && ! highestRanked . equals ( defaultEngine ) ) { if ( connectToEngine ( highestRanked ) ) { mCurrentEngine = highestRanked ; return SUCCESS ; } } mCurrentEngine = null ; dispatchOnInit ( ERROR ) ; return ERROR ; }
indashnet/InDashNet.Open.UN2000 | private boolean connectToEngine ( String engine ) { Connection connection = new Connection ( ) ; Intent intent = new Intent ( Engine . INTENT_ACTION_TTS_SERVICE ) ; intent . setPackage ( engine ) ; boolean bound = mContext . bindService ( intent , connection , Context . BIND_AUTO_CREATE ) ; if ( ! bound ) { Log . e ( TAG , " Failed ▁ to ▁ bind ▁ to ▁ " + engine ) ; return false ; } else { Log . i ( TAG , " Sucessfully ▁ bound ▁ to ▁ " + engine ) ; mConnectingServiceConnection = connection ; return true ; } }
indashnet/InDashNet.Open.UN2000 | private void dispatchOnInit ( int result ) { synchronized ( mStartLock ) { if ( mInitListener != null ) { mInitListener . onInit ( result ) ; mInitListener = null ; } } }
indashnet/InDashNet.Open.UN2000 | private IBinder getCallerIdentity ( ) { return mServiceConnection . getCallerIdentity ( ) ; }
indashnet/InDashNet.Open.UN2000 | public void shutdown ( ) { synchronized ( mStartLock ) { if ( mConnectingServiceConnection != null ) { mContext . unbindService ( mConnectingServiceConnection ) ; mConnectingServiceConnection = null ; return ; } } runActionNoReconnect ( new Action < Void > ( ) { @ Override public Void run ( ITextToSpeechService service ) throws RemoteException { service . setCallback ( getCallerIdentity ( ) , null ) ; service . stop ( getCallerIdentity ( ) ) ; mServiceConnection . disconnect ( ) ; mServiceConnection = null ; mCurrentEngine = null ; return null ; } } , null , " shutdown " , false ) ; }
indashnet/InDashNet.Open.UN2000 | public int addSpeech ( String text , String packagename , int resourceId ) { synchronized ( mStartLock ) { mUtterances . put ( text , makeResourceUri ( packagename , resourceId ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | public int addSpeech ( String text , String filename ) { synchronized ( mStartLock ) { mUtterances . put ( text , Uri . parse ( filename ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | public int addEarcon ( String earcon , String packagename , int resourceId ) { synchronized ( mStartLock ) { mEarcons . put ( earcon , makeResourceUri ( packagename , resourceId ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | public int addEarcon ( String earcon , String filename ) { synchronized ( mStartLock ) { mEarcons . put ( earcon , Uri . parse ( filename ) ) ; return SUCCESS ; } }
indashnet/InDashNet.Open.UN2000 | private Uri makeResourceUri ( String packageName , int resourceId ) { return new Uri . Builder ( ) . scheme ( ContentResolver . SCHEME_ANDROID_RESOURCE ) . encodedAuthority ( packageName ) . appendEncodedPath ( String . valueOf ( resourceId ) ) . build ( ) ; }
indashnet/InDashNet.Open.UN2000 | public int speak ( final String text , final int queueMode , final HashMap < String , String > params ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { Uri utteranceUri = mUtterances . get ( text ) ; if ( utteranceUri != null ) { return service . playAudio ( getCallerIdentity ( ) , utteranceUri , queueMode , getParams ( params ) ) ; } else { return service . speak ( getCallerIdentity ( ) , text , queueMode , getParams ( params ) ) ; } } } , ERROR , " speak " ) ; }
indashnet/InDashNet.Open.UN2000 | public int playEarcon ( final String earcon , final int queueMode , final HashMap < String , String > params ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { Uri earconUri = mEarcons . get ( earcon ) ; if ( earconUri == null ) { return ERROR ; } return service . playAudio ( getCallerIdentity ( ) , earconUri , queueMode , getParams ( params ) ) ; } } , ERROR , " playEarcon " ) ; }
indashnet/InDashNet.Open.UN2000 | public int playSilence ( final long durationInMs , final int queueMode , final HashMap < String , String > params ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { return service . playSilence ( getCallerIdentity ( ) , durationInMs , queueMode , getParams ( params ) ) ; } } , ERROR , " playSilence " ) ; }
indashnet/InDashNet.Open.UN2000 | public Set < String > getFeatures ( final Locale locale ) { return runAction ( new Action < Set < String > > ( ) { @ Override public Set < String > run ( ITextToSpeechService service ) throws RemoteException { String [ ] features = service . getFeaturesForLanguage ( locale . getISO3Language ( ) , locale . getISO3Country ( ) , locale . getVariant ( ) ) ; if ( features != null ) { final Set < String > featureSet = new HashSet < String > ( ) ; Collections . addAll ( featureSet , features ) ; return featureSet ; } return null ; } } , null , " getFeatures " ) ; }
indashnet/InDashNet.Open.UN2000 | public boolean isSpeaking ( ) { return runAction ( new Action < Boolean > ( ) { @ Override public Boolean run ( ITextToSpeechService service ) throws RemoteException { return service . isSpeaking ( ) ; } } , false , " isSpeaking " ) ; }
indashnet/InDashNet.Open.UN2000 | public int stop ( ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { return service . stop ( getCallerIdentity ( ) ) ; } } , ERROR , " stop " ) ; }
indashnet/InDashNet.Open.UN2000 | public int setSpeechRate ( float speechRate ) { if ( speechRate > 0.0f ) { int intRate = ( int ) ( speechRate * 100 ) ; if ( intRate > 0 ) { synchronized ( mStartLock ) { mParams . putInt ( Engine . KEY_PARAM_RATE , intRate ) ; } return SUCCESS ; } } return ERROR ; }
indashnet/InDashNet.Open.UN2000 | public int setPitch ( float pitch ) { if ( pitch > 0.0f ) { int intPitch = ( int ) ( pitch * 100 ) ; if ( intPitch > 0 ) { synchronized ( mStartLock ) { mParams . putInt ( Engine . KEY_PARAM_PITCH , intPitch ) ; } return SUCCESS ; } } return ERROR ; }
indashnet/InDashNet.Open.UN2000 | public String getCurrentEngine ( ) { return mCurrentEngine ; }
indashnet/InDashNet.Open.UN2000 | public Locale getDefaultLanguage ( ) { return runAction ( new Action < Locale > ( ) { @ Override public Locale run ( ITextToSpeechService service ) throws RemoteException { String [ ] defaultLanguage = service . getClientDefaultLanguage ( ) ; return new Locale ( defaultLanguage [ 0 ] , defaultLanguage [ 1 ] , defaultLanguage [ 2 ] ) ; } } , null , " getDefaultLanguage " ) ; }
indashnet/InDashNet.Open.UN2000 | public int setLanguage ( final Locale loc ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { if ( loc == null ) { return LANG_NOT_SUPPORTED ; } String language = null , country = null ; try { language = loc . getISO3Language ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 639-2 / T ▁ language ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } try { country = loc . getISO3Country ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 3166 ▁ country ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } String variant = loc . getVariant ( ) ; int result = service . loadLanguage ( getCallerIdentity ( ) , language , country , variant ) ; if ( result >= LANG_AVAILABLE ) { if ( result < LANG_COUNTRY_var_AVAILABLE ) { variant = " " ; if ( result < LANG_COUNTRY_AVAILABLE ) { country = " " ; } } mParams . putString ( Engine . KEY_PARAM_LANGUAGE , language ) ; mParams . putString ( Engine . KEY_PARAM_COUNTRY , country ) ; mParams . putString ( Engine . KEY_PARAM_VARIANT , variant ) ; } return result ; } } , LANG_NOT_SUPPORTED , " setLanguage " ) ; }
indashnet/InDashNet.Open.UN2000 | public Locale getLanguage ( ) { return runAction ( new Action < Locale > ( ) { @ Override public Locale run ( ITextToSpeechService service ) { String lang = mParams . getString ( Engine . KEY_PARAM_LANGUAGE , " " ) ; String country = mParams . getString ( Engine . KEY_PARAM_COUNTRY , " " ) ; String variant = mParams . getString ( Engine . KEY_PARAM_VARIANT , " " ) ; return new Locale ( lang , country , variant ) ; } } , null , " getLanguage " ) ; }
indashnet/InDashNet.Open.UN2000 | public int isLanguageAvailable ( final Locale loc ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { String language = null , country = null ; try { language = loc . getISO3Language ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 639-2 / T ▁ language ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } try { country = loc . getISO3Country ( ) ; } catch ( MissingResourceException e ) { Log . w ( TAG , " Couldn ' t ▁ retrieve ▁ ISO ▁ 3166 ▁ country ▁ code ▁ for ▁ locale : ▁ " + loc , e ) ; return LANG_NOT_SUPPORTED ; } return service . isLanguageAvailable ( language , country , loc . getVariant ( ) ) ; } } , LANG_NOT_SUPPORTED , " isLanguageAvailable " ) ; }
indashnet/InDashNet.Open.UN2000 | public int synthesizeToFile ( final String text , final HashMap < String , String > params , final String filename ) { return runAction ( new Action < Integer > ( ) { @ Override public Integer run ( ITextToSpeechService service ) throws RemoteException { ParcelFileDescriptor fileDescriptor ; int returnValue ; try { File file = new File ( filename ) ; if ( file . exists ( ) && ! file . canWrite ( ) ) { Log . e ( TAG , " Can ' t ▁ write ▁ to ▁ " + filename ) ; return ERROR ; } fileDescriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_WRITE_ONLY | ParcelFileDescriptor . MODE_CREATE | ParcelFileDescriptor . MODE_TRUNCATE ) ; returnValue = service . synthesizeToFileDescriptor ( getCallerIdentity ( ) , text , fileDescriptor , getParams ( params ) ) ; fileDescriptor . close ( ) ; return returnValue ; } catch ( FileNotFoundException e ) { Log . e ( TAG , " Opening ▁ file ▁ " + filename + " ▁ failed " , e ) ; return ERROR ; } catch ( IOException e ) { Log . e ( TAG , " Closing ▁ file ▁ " + filename + " ▁ failed " , e ) ; return ERROR ; } } } , ERROR , " synthesizeToFile " ) ; }
indashnet/InDashNet.Open.UN2000 | private Bundle getParams ( HashMap < String , String > params ) { if ( params != null && ! params . isEmpty ( ) ) { Bundle bundle = new Bundle ( mParams ) ; copyIntParam ( bundle , params , Engine . KEY_PARAM_STREAM ) ; copyStringParam ( bundle , params , Engine . KEY_PARAM_UTTERANCE_ID ) ; copyFloatParam ( bundle , params , Engine . KEY_PARAM_VOLUME ) ; copyFloatParam ( bundle , params , Engine . KEY_PARAM_PAN ) ; copyStringParam ( bundle , params , Engine . KEY_FEATURE_NETWORK_SYNTHESIS ) ; copyStringParam ( bundle , params , Engine . KEY_FEATURE_EMBEDDED_SYNTHESIS ) ; if ( ! TextUtils . isEmpty ( mCurrentEngine ) ) { for ( Map . Entry < String , String > entry : params . entrySet ( ) ) { final String key = entry . getKey ( ) ; if ( key != null && key . startsWith ( mCurrentEngine ) ) { bundle . putString ( key , entry . getValue ( ) ) ; } } } return bundle ; } else { return mParams ; } }
indashnet/InDashNet.Open.UN2000 | private void copyStringParam ( Bundle bundle , HashMap < String , String > params , String key ) { String value = params . get ( key ) ; if ( value != null ) { bundle . putString ( key , value ) ; } }
indashnet/InDashNet.Open.UN2000 | private void copyIntParam ( Bundle bundle , HashMap < String , String > params , String key ) { String valueString = params . get ( key ) ; if ( ! TextUtils . isEmpty ( valueString ) ) { try { int value = Integer . parseInt ( valueString ) ; bundle . putInt ( key , value ) ; } catch ( NumberFormatException ex ) { } } }
indashnet/InDashNet.Open.UN2000 | private void copyFloatParam ( Bundle bundle , HashMap < String , String > params , String key ) { String valueString = params . get ( key ) ; if ( ! TextUtils . isEmpty ( valueString ) ) { try { float value = Float . parseFloat ( valueString ) ; bundle . putFloat ( key , value ) ; } catch ( NumberFormatException ex ) { } } }
indashnet/InDashNet.Open.UN2000 | @ Deprecated public int setOnUtteranceCompletedListener ( final OnUtteranceCompletedListener listener ) { mUtteranceProgressListener = UtteranceProgressListener . from ( listener ) ; return TextToSpeech . SUCCESS ; }
indashnet/InDashNet.Open.UN2000 | public int setOnUtteranceProgressListener ( UtteranceProgressListener listener ) { mUtteranceProgressListener = listener ; return TextToSpeech . SUCCESS ; }
indashnet/InDashNet.Open.UN2000 | @ Deprecated public int setEngineByPackageName ( String enginePackageName ) { mRequestedEngine = enginePackageName ; return initTts ( ) ; }
indashnet/InDashNet.Open.UN2000 | public String getDefaultEngine ( ) { return mEnginesHelper . getDefaultEngine ( ) ; }
indashnet/InDashNet.Open.UN2000 | public boolean areDefaultsEnforced ( ) { return false ; }
indashnet/InDashNet.Open.UN2000 | public List < EngineInfo > getEngines ( ) { return mEnginesHelper . getEngines ( ) ; }
indashnet/InDashNet.Open.UN2000 | private final ITextToSpeechCallback . Stub mCallback = new ITextToSpeechCallback . Stub ( ) { @ Override public void onDone ( String utteranceId ) { UtteranceProgressListener listener = mUtteranceProgressListener ; if ( listener != null ) { listener . onDone ( utteranceId ) ; } } @ Override public void onError ( String utteranceId ) { UtteranceProgressListener listener = mUtteranceProgressListener ; if ( listener != null ) { listener . onError ( utteranceId ) ; } } @ Override public void onStart ( String utteranceId ) { UtteranceProgressListener listener = mUtteranceProgressListener ; if ( listener != null ) { listener . onStart ( utteranceId ) ; } } }
indashnet/InDashNet.Open.UN2000 | public SetupConnectionAsyncTask ( ComponentName name ) { mName = name ; }
indashnet/InDashNet.Open.UN2000 | @ Override protected Integer doInBackground ( Void ... params ) { synchronized ( mStartLock ) { if ( isCancelled ( ) ) { return null ; } try { mService . setCallback ( getCallerIdentity ( ) , mCallback ) ; String [ ] defaultLanguage = mService . getClientDefaultLanguage ( ) ; mParams . putString ( Engine . KEY_PARAM_LANGUAGE , defaultLanguage [ 0 ] ) ; mParams . putString ( Engine . KEY_PARAM_COUNTRY , defaultLanguage [ 1 ] ) ; mParams . putString ( Engine . KEY_PARAM_VARIANT , defaultLanguage [ 2 ] ) ; Log . i ( TAG , " Set ▁ up ▁ connection ▁ to ▁ " + mName ) ; return SUCCESS ; } catch ( RemoteException re ) { Log . e ( TAG , " Error ▁ connecting ▁ to ▁ service , ▁ setCallback ( ) ▁ failed " ) ; return ERROR ; } } }
indashnet/InDashNet.Open.UN2000 | @ Override protected void onPostExecute ( Integer result ) { synchronized ( mStartLock ) { if ( mOnSetupConnectionAsyncTask == this ) { mOnSetupConnectionAsyncTask = null ; } mEstablished = true ; dispatchOnInit ( result ) ; } }
indashnet/InDashNet.Open.UN2000 | @ Override public void onServiceConnected ( ComponentName name , IBinder service ) { synchronized ( mStartLock ) { mConnectingServiceConnection = null ; Log . i ( TAG , " Connected ▁ to ▁ " + name ) ; if ( mOnSetupConnectionAsyncTask != null ) { mOnSetupConnectionAsyncTask . cancel ( false ) ; } mService = ITextToSpeechService . Stub . asInterface ( service ) ; mServiceConnection = Connection . this ; mEstablished = false ; mOnSetupConnectionAsyncTask = new SetupConnectionAsyncTask ( name ) ; mOnSetupConnectionAsyncTask . execute ( ) ; } }
indashnet/InDashNet.Open.UN2000 | public IBinder getCallerIdentity ( ) { return mCallback ; }
indashnet/InDashNet.Open.UN2000 | private boolean clearServiceConnection ( ) { synchronized ( mStartLock ) { boolean result = false ; if ( mOnSetupConnectionAsyncTask != null ) { result = mOnSetupConnectionAsyncTask . cancel ( false ) ; mOnSetupConnectionAsyncTask = null ; } mService = null ; if ( mServiceConnection == this ) { mServiceConnection = null ; } return result ; } }
indashnet/InDashNet.Open.UN2000 | @ Override public void onServiceDisconnected ( ComponentName name ) { Log . i ( TAG , " Asked ▁ to ▁ disconnect ▁ from ▁ " + name ) ; if ( clearServiceConnection ( ) ) { dispatchOnInit ( ERROR ) ; } }
indashnet/InDashNet.Open.UN2000 | public void disconnect ( ) { mContext . unbindService ( this ) ; clearServiceConnection ( ) ; }
indashnet/InDashNet.Open.UN2000 | public boolean isEstablished ( ) { return mService != null && mEstablished ; }
indashnet/InDashNet.Open.UN2000 | public < R > R runAction ( Action < R > action , R errorResult , String method , boolean reconnect , boolean onlyEstablishedConnection ) { synchronized ( mStartLock ) { try { if ( mService == null ) { Log . w ( TAG , method + " ▁ failed : ▁ not ▁ connected ▁ to ▁ TTS ▁ engine " ) ; return errorResult ; } if ( onlyEstablishedConnection && ! isEstablished ( ) ) { Log . w ( TAG , method + " ▁ failed : ▁ TTS ▁ engine ▁ connection ▁ not ▁ fully ▁ set ▁ up " ) ; return errorResult ; } return action . run ( mService ) ; } catch ( RemoteException ex ) { Log . e ( TAG , method + " ▁ failed " , ex ) ; if ( reconnect ) { disconnect ( ) ; initTts ( ) ; } return errorResult ; } } }
indashnet/InDashNet.Open.UN2000 | @ Override public String toString ( ) { return " EngineInfo { name = " + name + " } " ; }
tamacat/tamacat-httpd | public SubnetUtils ( String cidrNotation ) { calculate ( cidrNotation ) ; }
tamacat/tamacat-httpd | public SubnetUtils ( String address , String mask ) { calculate ( toCidrNotation ( address , mask ) ) ; }
tamacat/tamacat-httpd | public boolean isInclusiveHostCount ( ) { return inclusiveHostCount ; }
tamacat/tamacat-httpd | public void setInclusiveHostCount ( boolean inclusiveHostCount ) { this . inclusiveHostCount = inclusiveHostCount ; }
tamacat/tamacat-httpd | private SubnetInfo ( ) { }
tamacat/tamacat-httpd | private int netmask ( ) { return netmask ; }
tamacat/tamacat-httpd | private int network ( ) { return network ; }
tamacat/tamacat-httpd | private int address ( ) { return address ; }
tamacat/tamacat-httpd | private int broadcast ( ) { return broadcast ; }
tamacat/tamacat-httpd | private int low ( ) { return ( isInclusiveHostCount ( ) ? network ( ) : broadcast ( ) - network ( ) > 1 ? network ( ) + 1 : 0 ) ; }
tamacat/tamacat-httpd | private int high ( ) { return ( isInclusiveHostCount ( ) ? broadcast ( ) : broadcast ( ) - network ( ) > 1 ? broadcast ( ) - 1 : 0 ) ; }
tamacat/tamacat-httpd | public boolean isInRange ( String address ) { return isInRange ( toInteger ( address ) ) ; }
tamacat/tamacat-httpd | private boolean isInRange ( int address ) { int diff = address - low ( ) ; return ( diff >= 0 && ( diff <= ( high ( ) - low ( ) ) ) ) ; }
tamacat/tamacat-httpd | public String getBroadcastAddress ( ) { return format ( toArray ( broadcast ( ) ) ) ; }
tamacat/tamacat-httpd | public String getNetworkAddress ( ) { return format ( toArray ( network ( ) ) ) ; }
tamacat/tamacat-httpd | public String getNetmask ( ) { return format ( toArray ( netmask ( ) ) ) ; }
tamacat/tamacat-httpd | public String getAddress ( ) { return format ( toArray ( address ( ) ) ) ; }
tamacat/tamacat-httpd | public String getLowAddress ( ) { return format ( toArray ( low ( ) ) ) ; }
tamacat/tamacat-httpd | public String getHighAddress ( ) { return format ( toArray ( high ( ) ) ) ; }
tamacat/tamacat-httpd | public int getAddressCount ( ) { int count = broadcast ( ) - network ( ) + ( isInclusiveHostCount ( ) ? 1 : - 1 ) ; return count < 0 ? 0 : count ; }
tamacat/tamacat-httpd | public int asInteger ( String address ) { return toInteger ( address ) ; }
tamacat/tamacat-httpd | public String getCidrSignature ( ) { return toCidrNotation ( format ( toArray ( address ( ) ) ) , format ( toArray ( netmask ( ) ) ) ) ; }
tamacat/tamacat-httpd | public String [ ] getAllAddresses ( ) { int ct = getAddressCount ( ) ; String [ ] addresses = new String [ ct ] ; if ( ct == 0 ) { return addresses ; } for ( int add = low ( ) , j = 0 ; add <= high ( ) ; ++ add , ++ j ) { addresses [ j ] = format ( toArray ( add ) ) ; } return addresses ; }
tamacat/tamacat-httpd | @ Override public String toString ( ) { final StringBuilder buf = new StringBuilder ( ) ; buf . append ( " CIDR ▁ Signature : \t [ " ) . append ( getCidrSignature ( ) ) . append ( " ] " ) . append ( " ▁ Netmask : ▁ [ " ) . append ( getNetmask ( ) ) . append ( " ] \n " ) . append ( " Network : \t [ " ) . append ( getNetworkAddress ( ) ) . append ( " ] \n " ) . append ( " Broadcast : \t [ " ) . append ( getBroadcastAddress ( ) ) . append ( " ] \n " ) . append ( " First ▁ Address : \t [ " ) . append ( getLowAddress ( ) ) . append ( " ] \n " ) . append ( " Last ▁ Address : \t [ " ) . append ( getHighAddress ( ) ) . append ( " ] \n " ) . append ( " # ▁ Addresses : \t [ " ) . append ( getAddressCount ( ) ) . append ( " ] \n " ) ; return buf . toString ( ) ; }
tamacat/tamacat-httpd | public final SubnetInfo getInfo ( ) { return new SubnetInfo ( ) ; }
tamacat/tamacat-httpd | private void calculate ( String mask ) { Matcher matcher = cidrPattern . matcher ( mask ) ; if ( matcher . matches ( ) ) { address = matchAddress ( matcher ) ; int cidrPart = rangeCheck ( Integer . parseInt ( matcher . group ( 5 ) ) , 0 , NBITS ) ; for ( int j = 0 ; j < cidrPart ; ++ j ) { netmask |= ( 1 << 31 - j ) ; } network = ( address & netmask ) ; broadcast = network | ~ ( netmask ) ; } else { throw new IllegalArgumentException ( " Could ▁ not ▁ parse ▁ [ " + mask + " ] " ) ; } }
tamacat/tamacat-httpd | private int toInteger ( String address ) { Matcher matcher = addressPattern . matcher ( address ) ; if ( matcher . matches ( ) ) { return matchAddress ( matcher ) ; } else { throw new IllegalArgumentException ( " Could ▁ not ▁ parse ▁ [ " + address + " ] " ) ; } }
tamacat/tamacat-httpd | private int matchAddress ( Matcher matcher ) { int addr = 0 ; for ( int i = 1 ; i <= 4 ; ++ i ) { int n = ( rangeCheck ( Integer . parseInt ( matcher . group ( i ) ) , - 1 , 255 ) ) ; addr |= ( ( n & 0xff ) << 8 * ( 4 - i ) ) ; } return addr ; }
tamacat/tamacat-httpd | private int [ ] toArray ( int val ) { int ret [ ] = new int [ 4 ] ; for ( int j = 3 ; j >= 0 ; -- j ) { ret [ j ] |= ( ( val >>> 8 * ( 3 - j ) ) & ( 0xff ) ) ; } return ret ; }
tamacat/tamacat-httpd | private String format ( int [ ] octets ) { StringBuilder str = new StringBuilder ( ) ; for ( int i = 0 ; i < octets . length ; ++ i ) { str . append ( octets [ i ] ) ; if ( i != octets . length - 1 ) { str . append ( " . " ) ; } } return str . toString ( ) ; }
tamacat/tamacat-httpd | private int rangeCheck ( int value , int begin , int end ) { if ( value > begin && value <= end ) { return value ; } throw new IllegalArgumentException ( " Value ▁ [ " + value + " ] ▁ not ▁ in ▁ range ▁ ( " + begin + " , " + end + " ] " ) ; }
tamacat/tamacat-httpd | int pop ( int x ) { x = x - ( ( x >>> 1 ) & 0x55555555 ) ; x = ( x & 0x33333333 ) + ( ( x >>> 2 ) & 0x33333333 ) ; x = ( x + ( x >>> 4 ) ) & 0x0F0F0F0F ; x = x + ( x >>> 8 ) ; x = x + ( x >>> 16 ) ; return x & 0x0000003F ; }
tamacat/tamacat-httpd | private String toCidrNotation ( String addr , String mask ) { return addr + " / " + pop ( toInteger ( mask ) ) ; }
aws/aws-sdk-java | public DescribeAuditStreamConfigurationResult unmarshall ( JsonUnmarshallerContext context ) throws Exception { DescribeAuditStreamConfigurationResult describeAuditStreamConfigurationResult = new DescribeAuditStreamConfigurationResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; String currentParentElement = context . getCurrentParentElement ( ) ; int targetDepth = originalDepth + 1 ; JsonToken token = context . getCurrentToken ( ) ; if ( token == null ) token = context . nextToken ( ) ; if ( token == VALUE_NULL ) { return describeAuditStreamConfigurationResult ; } while ( true ) { if ( token == null ) break ; if ( token == FIELD_NAME || token == START_OBJECT ) { if ( context . testExpression ( " AuditStreamArn " , targetDepth ) ) { context . nextToken ( ) ; describeAuditStreamConfigurationResult . setAuditStreamArn ( context . getUnmarshaller ( String . class ) . unmarshall ( context ) ) ; } } else if ( token == END_ARRAY || token == END_OBJECT ) { if ( context . getLastParsedParentElement ( ) == null || context . getLastParsedParentElement ( ) . equals ( currentParentElement ) ) { if ( context . getCurrentDepth ( ) <= originalDepth ) break ; } } token = context . nextToken ( ) ; } return describeAuditStreamConfigurationResult ; }
darranl/directory-server | public AddETypeInfo2Entry ( ) { super ( " Add ▁ an ▁ ETypeInfo2Entry ▁ instance " ) ; }
darranl/directory-server | public void action ( ETypeInfo2Container eTypeInfo2Container ) throws DecoderException { TLV tlv = eTypeInfo2Container . getCurrentTLV ( ) ; if ( tlv . getLength ( ) == 0 ) { LOG . error ( I18n . err ( I18n . ERR_04066 ) ) ; throw new DecoderException ( I18n . err ( I18n . ERR_04067 ) ) ; } Asn1Decoder etypeInfo2EntryDecoder = new Asn1Decoder ( ) ; ETypeInfo2EntryContainer etypeInfo2EntryContainer = new ETypeInfo2EntryContainer ( ) ; etypeInfo2EntryContainer . setStream ( eTypeInfo2Container . getStream ( ) ) ; eTypeInfo2Container . rewind ( ) ; try { etypeInfo2EntryDecoder . decode ( eTypeInfo2Container . getStream ( ) , etypeInfo2EntryContainer ) ; } catch ( DecoderException de ) { throw de ; } tlv . setExpectedLength ( tlv . getExpectedLength ( ) - tlv . getLength ( ) ) ; eTypeInfo2Container . updateParent ( ) ; ETypeInfo2Entry etypeInfo2Entry = etypeInfo2EntryContainer . getETypeInfo2Entry ( ) ; eTypeInfo2Container . addEtypeInfo2Entry ( etypeInfo2Entry ) ; if ( IS_DEBUG ) { LOG . debug ( " ETYPE - INFO2 - ENTRY ▁ added ▁ : ▁ { } " , etypeInfo2Entry ) ; } eTypeInfo2Container . setGrammarEndAllowed ( true ) ; }
vam-google/google-cloud-java | @ Before public void setUp ( ) { rpcFactoryMock = EasyMock . createMock ( TranslateRpcFactory . class ) ; translateRpcMock = EasyMock . createMock ( TranslateRpc . class ) ; EasyMock . expect ( rpcFactoryMock . create ( EasyMock . anyObject ( TranslateOptions . class ) ) ) . andReturn ( translateRpcMock ) ; EasyMock . replay ( rpcFactoryMock ) ; options = TranslateOptions . newBuilder ( ) . setApiKey ( API_KEY ) . setServiceRpcFactory ( rpcFactoryMock ) . setRetrySettings ( NO_RETRY_SETTINGS ) . build ( ) ; }
vam-google/google-cloud-java | private void verify ( ) { EasyMock . verify ( rpcFactoryMock , translateRpcMock ) ; }
vam-google/google-cloud-java | private void initializeService ( ) { translate = options . getService ( ) ; }
vam-google/google-cloud-java | @ Test public void testGetOptions ( ) { EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertSame ( options , translate . getOptions ( ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testListSupportedLanguages ( ) { EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andReturn ( ImmutableList . of ( LANGUAGE1_PB , LANGUAGE2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( LANGUAGES1 , translate . listSupportedLanguages ( ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testListSupportedLanguagesWithOptions ( ) { EasyMock . expect ( translateRpcMock . listSupportedLanguages ( LANGUAGE_LIST_OPTIONS ) ) . andReturn ( ImmutableList . of ( LANGUAGE3_PB , LANGUAGE4_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( LANGUAGES2 , translate . listSupportedLanguages ( LanguageListOption . targetLanguage ( TARGET_LANGUAGE ) ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetect ( ) { String text = " text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( DETECTION1 , translate . detect ( text ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectMultipleDetections ( ) { String text = " text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB , DETECTION2_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " Multiple ▁ detections ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( text ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectNoDetection ( ) { String text = " text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . < DetectionsResourceItems > of ( ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " No ▁ detection ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( text ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectList ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . detect ( texts ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . of ( DETECTION2_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( DETECTION1 , DETECTION2 ) , translate . detect ( texts ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectListMultipleDetections ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . detect ( texts ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB , DETECTION2_PB ) , ImmutableList . of ( DETECTION1_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " Multiple ▁ detections ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( texts ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectListNoDetection ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . detect ( texts ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . < DetectionsResourceItems > of ( ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " No ▁ detection ▁ found ▁ for ▁ text : ▁ other ▁ text " ) ; translate . detect ( texts ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectVararg ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text1 , text2 ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . of ( DETECTION2_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( DETECTION1 , DETECTION2 ) , translate . detect ( text1 , text2 ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectVarargMultipleDetections ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text1 , text2 ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB , DETECTION2_PB ) , ImmutableList . of ( DETECTION1_PB ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " Multiple ▁ detections ▁ found ▁ for ▁ text : ▁ text " ) ; translate . detect ( text1 , text2 ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testDetectVarargNoDetection ( ) { String text1 = " text " ; String text2 = " other ▁ text " ; EasyMock . expect ( translateRpcMock . detect ( ImmutableList . of ( text1 , text2 ) ) ) . andReturn ( ImmutableList . < List < DetectionsResourceItems > > of ( ImmutableList . of ( DETECTION1_PB ) , ImmutableList . < DetectionsResourceItems > of ( ) ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; thrown . expect ( IllegalStateException . class ) ; thrown . expectMessage ( " No ▁ detection ▁ found ▁ for ▁ text : ▁ other ▁ text " ) ; translate . detect ( text1 , text2 ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslate ( ) { String text = " ¡ Hola ▁ Mundo ! " ; EasyMock . expect ( translateRpcMock . translate ( ImmutableList . of ( text ) , EMPTY_RPC_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION1_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( TRANSLATION1 , translate . translate ( text ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslateWithOptions ( ) { String text = " Hallo ▁ Welt ! " ; EasyMock . expect ( translateRpcMock . translate ( ImmutableList . of ( text ) , TRANSLATE_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( TRANSLATION2 , translate . translate ( text , TARGET_LANGUAGE_OPTION , SOURCE_LANGUAGE_OPTION , MODEL_OPTION , FORMAT_OPTION ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslateList ( ) { String text1 = " ¡ Hola ▁ Mundo ! " ; String text2 = " Hallo ▁ Welt ! " ; List < String > texts = ImmutableList . of ( text1 , text2 ) ; EasyMock . expect ( translateRpcMock . translate ( texts , EMPTY_RPC_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION1_PB , TRANSLATION2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( TRANSLATION1 , TRANSLATION2 ) , translate . translate ( texts ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testTranslateListWithOptions ( ) { String text = " Hallo ▁ Welt ! " ; List < String > texts = ImmutableList . of ( text ) ; EasyMock . expect ( translateRpcMock . translate ( texts , TRANSLATE_OPTIONS ) ) . andReturn ( ImmutableList . of ( TRANSLATION2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; initializeService ( ) ; assertEquals ( ImmutableList . of ( TRANSLATION2 ) , translate . translate ( texts , TARGET_LANGUAGE_OPTION , SOURCE_LANGUAGE_OPTION , MODEL_OPTION , FORMAT_OPTION ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testRetryableException ( ) { EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andThrow ( new TranslateException ( 500 , " internalError " ) ) . andReturn ( ImmutableList . of ( LANGUAGE1_PB , LANGUAGE2_PB ) ) ; EasyMock . replay ( translateRpcMock ) ; translate = options . toBuilder ( ) . setRetrySettings ( ServiceOptions . getDefaultRetrySettings ( ) ) . build ( ) . getService ( ) ; assertEquals ( LANGUAGES1 , translate . listSupportedLanguages ( ) ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testNonRetryableException ( ) { String exceptionMessage = " Not ▁ Implemented " ; EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andThrow ( new TranslateException ( 501 , exceptionMessage ) ) ; EasyMock . replay ( translateRpcMock ) ; translate = options . toBuilder ( ) . setRetrySettings ( ServiceOptions . getDefaultRetrySettings ( ) ) . build ( ) . getService ( ) ; thrown . expect ( TranslateException . class ) ; thrown . expectMessage ( exceptionMessage ) ; translate . listSupportedLanguages ( ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testRuntimeException ( ) { String exceptionMessage = " Artificial ▁ runtime ▁ exception " ; EasyMock . expect ( translateRpcMock . listSupportedLanguages ( EMPTY_RPC_OPTIONS ) ) . andThrow ( new RuntimeException ( exceptionMessage ) ) ; EasyMock . replay ( translateRpcMock ) ; translate = options . toBuilder ( ) . setRetrySettings ( ServiceOptions . getDefaultRetrySettings ( ) ) . build ( ) . getService ( ) ; thrown . expect ( TranslateException . class ) ; thrown . expectMessage ( exceptionMessage ) ; translate . listSupportedLanguages ( ) ; verify ( ) ; }
vam-google/google-cloud-java | @ Test public void testCredentialsOverridesApiKey ( ) { Credentials credentials = NoCredentials . getInstance ( ) ; TranslateOptions overridden = options . toBuilder ( ) . setCredentials ( credentials ) . build ( ) ; assertSame ( overridden . getCredentials ( ) , credentials ) ; assertNull ( overridden . getApiKey ( ) ) ; }
tfisher1226/ARIES | public void setUp ( ) throws Exception { isRequestExpected = true ; isAbortExpected = false ; }
tfisher1226/ARIES | public void tearDown ( ) throws Exception { expectedExceptionMessage = null ; expectedExceptionClass = null ; expectedExceptionCause = null ; }
tfisher1226/ARIES | protected void setupForExpectedAssertionFailure ( String exceptionMessage ) throws Exception { addExpectedException ( AssertionFailure . class , null , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedAssertionFailure ( Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { addExpectedException ( AssertionFailure . class , exceptionCause , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedIllegalArgument ( String exceptionMessage ) throws Exception { addExpectedException ( IllegalArgumentException . class , null , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedIllegalArgument ( Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { addExpectedException ( IllegalArgumentException . class , exceptionCause , exceptionMessage ) ; }
tfisher1226/ARIES | protected void setupForExpectedException ( Class < ? extends Throwable > exceptionClass , String exceptionMessage ) throws Exception { addExpectedException ( exceptionClass , null , exceptionMessage ) ; }
tfisher1226/ARIES | protected void addExpectedNullPointerException ( ) throws Exception { expectedException = new NullPointerException ( null ) ; expectedExceptionClass = NullPointerException . class ; expectedExceptionMessage = null ; }
tfisher1226/ARIES | protected void addExpectedServiceAbortedException ( String exceptionMessage ) throws Exception { expectedException = new AssertionFailure ( exceptionMessage ) ; expectedExceptionClass = AssertionFailure . class ; expectedExceptionMessage = exceptionMessage ; }
tfisher1226/ARIES | protected void addExpectedServiceAbortedException ( Class < ? > exceptionClass , String exceptionMessage ) throws Exception { expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage ) ; expectedExceptionClass = exceptionClass ; expectedExceptionMessage = exceptionMessage ; }
tfisher1226/ARIES | protected void addExpectedException ( Class < ? extends Throwable > exceptionClass , Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { if ( exceptionCause != null ) { Throwable instanceofCause = createException ( exceptionCause , " message " ) ; expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage , instanceofCause ) ; } else expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage ) ; expectedExceptionClass = exceptionClass ; expectedExceptionCause = exceptionCause ; expectedExceptionMessage = exceptionMessage ; }
tfisher1226/ARIES | protected < T > T createException ( Class < T > classObject , Object exceptionMessage ) throws Exception { return createException ( classObject , exceptionMessage , null ) ; }
tfisher1226/ARIES | protected < T > T createException ( Class < T > classObject , Object exceptionMessage , Throwable exceptionCause ) throws Exception { Class < ? > [ ] parameterTypes = new Class < ? > [ 2 ] ; parameterTypes [ 0 ] = String . class ; parameterTypes [ 1 ] = Throwable . class ; Constructor < ? > constructor = classObject . getConstructor ( parameterTypes ) ; Assert . notNull ( constructor , " Constructor ▁ not ▁ found ▁ for : ▁ " + classObject . getName ( ) ) ; @ SuppressWarnings ( " unchecked " ) T instance = ( T ) constructor . newInstance ( exceptionMessage , exceptionCause ) ; return instance ; }
tfisher1226/ARIES | protected void validateAfterException ( Throwable e ) { validateExceptionType ( e ) ; }
tfisher1226/ARIES | protected void validateExceptionType ( Throwable e ) { Assert . equals ( e . getClass ( ) , expectedExceptionClass ) ; Throwable exception = getExceptionForThrowable ( e ) ; if ( exception == null ) exception = e ; if ( expectedExceptionMessage != null ) { Assert . notNull ( exception . getMessage ( ) , " Exception ▁ message ▁ null , ▁ expecting : ▁ " + expectedExceptionMessage ) ; Assert . startsWith ( exception . getMessage ( ) , expectedExceptionMessage ) ; } if ( expectedExceptionCause != null ) { Assert . notNull ( exception . getCause ( ) , " Exception ▁ cause ▁ null , ▁ expecting : ▁ " + expectedExceptionCause . getName ( ) ) ; Assert . equals ( exception . getCause ( ) . getClass ( ) , expectedExceptionCause ) ; } }
tfisher1226/ARIES | protected Throwable getExceptionForThrowable ( Throwable e ) { if ( e instanceof RuntimeException == false ) return e ; Throwable cause = e . getCause ( ) ; if ( cause instanceof Error ) return cause ; if ( cause instanceof RuntimeException ) return getExceptionForThrowable ( cause ) ; return cause ; }
Whitewolfza/cipango | public Tel ( String token ) { if ( ! token . equals ( " uri " ) ) throw new IllegalArgumentException ( " Invalid ▁ expression : ▁ tel ▁ after ▁ " + token ) ; }
Whitewolfza/cipango | public Object extract ( Object input ) { URI uri = ( URI ) input ; if ( uri . isSipURI ( ) ) { SipURI sipuri = ( SipURI ) uri ; if ( " phone " . equals ( sipuri . getParameter ( " user " ) ) ) return stripVisuals ( sipuri . getUser ( ) ) ; } else if ( " tel " . equals ( uri . getScheme ( ) ) ) { return stripVisuals ( ( ( TelURL ) uri ) . getPhoneNumber ( ) ) ; } return null ; }
Whitewolfza/cipango | private String stripVisuals ( String s ) { StringBuffer buf = new StringBuffer ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( " - . ( ) " . indexOf ( c ) < 0 ) buf . append ( c ) ; } return buf . toString ( ) ; }
danielcavanagh/peeler | public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; list = Song . allSongs ( this ) ; setListAdapter ( new ArrayAdapter < Song > ( this , R . layout . list_item , list ) ) ; getListView ( ) . setTextFilterEnabled ( true ) ; }
danielcavanagh/peeler | protected void onListItemClick ( ListView l , View v , int position , long id ) { ( ( Peeler ) getParent ( ) ) . setSongList ( list , position ) ; ( ( Peeler ) getParent ( ) ) . switchToCurrentTab ( ) ; }
ReactiveX/RxJava | public CompletableTimer ( long delay , TimeUnit unit , Scheduler scheduler ) { this . delay = delay ; this . unit = unit ; this . scheduler = scheduler ; }
ReactiveX/RxJava | @ Override protected void subscribeActual ( final CompletableObserver observer ) { TimerDisposable parent = new TimerDisposable ( observer ) ; observer . onSubscribe ( parent ) ; parent . setFuture ( scheduler . scheduleDirect ( parent , delay , unit ) ) ; }
ReactiveX/RxJava | TimerDisposable ( final CompletableObserver downstream ) { this . downstream = downstream ; }
ReactiveX/RxJava | @ Override public void run ( ) { downstream . onComplete ( ) ; }
ReactiveX/RxJava | @ Override public void dispose ( ) { DisposableHelper . dispose ( this ) ; }
ReactiveX/RxJava | @ Override public boolean isDisposed ( ) { return DisposableHelper . isDisposed ( get ( ) ) ; }
ReactiveX/RxJava | void setFuture ( Disposable d ) { DisposableHelper . replace ( this , d ) ; }
india-rose/old-indiarose | public TakePhoto ( ScreenManager _screen ) { super ( _screen ) ; m_callback = new PhotoHandler ( ) ; previewSurface = new SurfaceView ( AppData . currentContext ) ; ButtonItem takeButton = new ButtonItem ( AppData . currentContext , TAKE ) ; ButtonItem cancelButton = new ButtonItem ( AppData . currentContext , CANCEL ) ; takeButton . setTextSize ( ScreenManager . fontSize ) ; cancelButton . setTextSize ( ScreenManager . fontSize ) ; takeButton . setTextColor ( Color . BLACK ) ; cancelButton . setTextColor ( Color . BLACK ) ; takeButton . setText ( R . string . takeImage ) ; cancelButton . setText ( R . string . cancelText ) ; try { Mapper . connect ( m_callback , " pictureTaken " , this , " savePhoto " ) ; Mapper . connect ( takeButton , " clicked " , this , " buttonEvent " ) ; Mapper . connect ( cancelButton , " clicked " , this , " buttonEvent " ) ; } catch ( MapperException e ) { Log . wtf ( " TakePhoto " , " unable ▁ to ▁ connect ▁ photo " , e ) ; } m_layout = new LinearLayout ( AppData . currentContext ) ; m_layout . setOrientation ( LinearLayout . VERTICAL ) ; LinearLayout buttonLayout = new LinearLayout ( AppData . currentContext ) ; buttonLayout . setOrientation ( LinearLayout . HORIZONTAL ) ; buttonLayout . addView ( cancelButton ) ; buttonLayout . addView ( takeButton ) ; m_layout . setGravity ( Gravity . CENTER ) ; m_layout . addView ( previewSurface , new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; m_layout . addView ( buttonLayout , new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ) ; previewHolder = previewSurface . getHolder ( ) ; previewHolder . addCallback ( surfaceCallback ) ; previewHolder . setType ( SurfaceHolder . SURFACE_TYPE_PUSH_BUFFERS ) ; ViewGroup . LayoutParams p = previewSurface . getLayoutParams ( ) ; int h = 300 ; int w = ( int ) ( 300.0 * this . m_screen . getWidth ( ) / this . m_screen . getHeight ( ) ) ; p . height = h ; p . width = w ; previewSurface . setLayoutParams ( p ) ; }
india-rose/old-indiarose | SurfaceHolder . Callback surfaceCallback = new SurfaceHolder . Callback ( ) { public void surfaceCreated ( SurfaceHolder holder ) { } public void surfaceChanged ( SurfaceHolder holder , int format , int width , int height ) { initPreview ( width , height ) ; startPreview ( ) ; } public void surfaceDestroyed ( SurfaceHolder holder ) { } }
india-rose/old-indiarose | private void initPreview ( int w , int h ) { if ( m_camera != null && previewHolder . getSurface ( ) != null ) { try { m_camera . setPreviewDisplay ( previewHolder ) ; } catch ( Throwable t ) { Log . e ( " PreviewDemo - surfaceCallback " , " Exception ▁ in ▁ setPreviewDisplay ( ) " , t ) ; Toast . makeText ( AppData . currentContext , t . getMessage ( ) , Toast . LENGTH_LONG ) . show ( ) ; } if ( ! cameraConfigured ) { Camera . Parameters parameters = m_camera . getParameters ( ) ; parameters . setPreviewSize ( w , h ) ; parameters . setPictureSize ( w , h ) ; m_camera . setParameters ( parameters ) ; cameraConfigured = true ; } } }
india-rose/old-indiarose | private void startPreview ( ) { if ( cameraConfigured && m_camera != null ) { m_camera . startPreview ( ) ; inPreview = true ; } }
india-rose/old-indiarose | public void savePhoto ( String _filename ) { m_camera . stopPreview ( ) ; try { Mapper . emit ( this , " photoTaken " , _filename ) ; } catch ( MapperException e ) { Log . wtf ( " TakePhoto " , " unable ▁ to ▁ emit ▁ photo ▁ saving " , e ) ; } this . m_screen . pop ( ) ; }
india-rose/old-indiarose | public void onPop ( ) { if ( m_camera != null ) { m_camera . release ( ) ; m_camera = null ; } }
india-rose/old-indiarose | public void onPush ( ) { m_camera = Camera . open ( ) ; }
india-rose/old-indiarose | @ Override public View getView ( ) { return m_layout ; }
india-rose/old-indiarose | public synchronized void buttonEvent ( ButtonItem _button ) { if ( ! m_takingPhoto ) { String id = _button . getIdentifier ( ) ; if ( id . equals ( CANCEL ) ) { this . m_screen . pop ( ) ; } else if ( id . equals ( TAKE ) ) { m_takingPhoto = true ; this . m_camera . takePicture ( null , null , this . m_callback ) ; } } }
FreeSunny/TvSample | public ApplicationTest ( ) { super ( Application . class ) ; }
quiteflame/BADOM | public ThrowAtScreen ( Creature player , int sx , int sy , Item item ) { super ( player , " Throw ▁ " + player . nameOf ( item ) + " ▁ at ? " , sx , sy ) ; this . item = item ; }
quiteflame/BADOM | public boolean isAcceptable ( int x , int y ) { if ( ! player . canSee ( x , y , player . z ) ) return false ; for ( Point p : new Line ( player . x , player . y , x , y ) ) { if ( ! player . realTile ( p . x , p . y , player . z ) . isGround ( ) ) return false ; } return true ; }
quiteflame/BADOM | public void selectWorldCoordinate ( int x , int y , int screenX , int screenY ) { player . throwItem ( item , x , y , player . z ) ; }
P0ke55/specbot | public TcpPacketSizer ( Session session ) { this . session = session ; }
P0ke55/specbot | @ Override public void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { int length = in . readableBytes ( ) ; out . ensureWritable ( this . session . getPacketProtocol ( ) . getPacketHeader ( ) . getLengthSize ( length ) + length ) ; this . session . getPacketProtocol ( ) . getPacketHeader ( ) . writeLength ( new ByteBufNetOutput ( out ) , length ) ; out . writeBytes ( in ) ; }
P0ke55/specbot | @ Override protected void decode ( ChannelHandlerContext ctx , ByteBuf buf , List < Object > out ) throws Exception { int size = this . session . getPacketProtocol ( ) . getPacketHeader ( ) . getLengthSize ( ) ; if ( size > 0 ) { buf . markReaderIndex ( ) ; byte [ ] lengthBytes = new byte [ size ] ; for ( int index = 0 ; index < lengthBytes . length ; index ++ ) { if ( ! buf . isReadable ( ) ) { buf . resetReaderIndex ( ) ; return ; } lengthBytes [ index ] = buf . readByte ( ) ; if ( ( this . session . getPacketProtocol ( ) . getPacketHeader ( ) . isLengthVariable ( ) && lengthBytes [ index ] >= 0 ) || index == size - 1 ) { int length = this . session . getPacketProtocol ( ) . getPacketHeader ( ) . readLength ( new ByteBufNetInput ( Unpooled . wrappedBuffer ( lengthBytes ) ) , buf . readableBytes ( ) ) ; if ( buf . readableBytes ( ) < length ) { buf . resetReaderIndex ( ) ; return ; } out . add ( buf . readBytes ( length ) ) ; return ; } } throw new CorruptedFrameException ( " Length ▁ is ▁ too ▁ long . " ) ; } else { out . add ( buf . readBytes ( buf . readableBytes ( ) ) ) ; } }
lordofthejars/arquillian-cube | public void install ( @ Observes ( precedence = 100 ) Configuration configuration ) { namespaceService . set ( serviceLoader . get ( ) . onlyOne ( NamespaceService . class , OpenshiftNamespaceService . class ) ) ; }
teffy/okhttp | private FormBody ( List < String > encodedNames , List < String > encodedValues ) { this . encodedNames = Util . immutableList ( encodedNames ) ; this . encodedValues = Util . immutableList ( encodedValues ) ; }
teffy/okhttp | public int size ( ) { return encodedNames . size ( ) ; }
teffy/okhttp | public String encodedName ( int index ) { return encodedNames . get ( index ) ; }
teffy/okhttp | public String name ( int index ) { return percentDecode ( encodedName ( index ) , true ) ; }
teffy/okhttp | public String encodedValue ( int index ) { return encodedValues . get ( index ) ; }
teffy/okhttp | public String value ( int index ) { return percentDecode ( encodedValue ( index ) , true ) ; }
teffy/okhttp | @ Override public MediaType contentType ( ) { return CONTENT_TYPE ; }
teffy/okhttp | @ Override public long contentLength ( ) { return writeOrCountBytes ( null , true ) ; }
teffy/okhttp | @ Override public void writeTo ( BufferedSink sink ) throws IOException { writeOrCountBytes ( sink , false ) ; }
teffy/okhttp | private long writeOrCountBytes ( BufferedSink sink , boolean countBytes ) { long byteCount = 0L ; Buffer buffer ; if ( countBytes ) { buffer = new Buffer ( ) ; } else { buffer = sink . buffer ( ) ; } for ( int i = 0 , size = encodedNames . size ( ) ; i < size ; i ++ ) { if ( i > 0 ) buffer . writeByte ( ' & ' ) ; buffer . writeUtf8 ( encodedNames . get ( i ) ) ; buffer . writeByte ( ' = ' ) ; buffer . writeUtf8 ( encodedValues . get ( i ) ) ; } if ( countBytes ) { byteCount = buffer . size ( ) ; buffer . clear ( ) ; } return byteCount ; }
teffy/okhttp | public Builder add ( String name , String value ) { names . add ( HttpUrl . canonicalize ( name , FORM_ENCODE_SET , false , true , true ) ) ; values . add ( HttpUrl . canonicalize ( value , FORM_ENCODE_SET , false , true , true ) ) ; return this ; }
teffy/okhttp | public Builder addEncoded ( String name , String value ) { names . add ( HttpUrl . canonicalize ( name , FORM_ENCODE_SET , true , true , true ) ) ; values . add ( HttpUrl . canonicalize ( value , FORM_ENCODE_SET , true , true , true ) ) ; return this ; }
teffy/okhttp | public FormBody build ( ) { return new FormBody ( names , values ) ; }
l1fan/GameAne | public void init ( ) throws JSONException { JSONObject jd = getJsonData ( ) ; Bundle md = getMetaData ( ) ; mAppId = jd . optString ( APPID , md . getString ( APPID , " " ) ) . replace ( " coolpad . " , " " ) ; mAppKey = jd . optString ( APPKEY , md . getString ( APPKEY ) ) ; mPrivateKey = jd . optString ( " privateKey " , md . getString ( " privateKey " ) ) ; mPublicKey = jd . optString ( " publicKey " , md . getString ( " publicKey " ) ) ; int ori = jd . optInt ( ORIENTATION , md . getInt ( ORIENTATION , 1 ) ) ; Activity act = getActivity ( ) ; CoolPadPay . init ( act , ori , mAppId ) ; dispatchData ( EVENT_INIT ) ; }
l1fan/GameAne | public void userLogin ( ) { mCool = Coolcloud . createInstance ( getActivity ( ) , mAppId , mAppKey ) ; mCool . login ( getActivity ( ) , " / user / getuserinfo " , new OnAuthListener ( ) { @ Override public void onError ( ErrInfo err ) { dispatchError ( EVENT_LOGIN , err . getError ( ) + err . getMessage ( ) ) ; } @ Override public void onDone ( Object arg ) { System . out . println ( arg . toString ( ) ) ; Bundle result = ( Bundle ) arg ; JSONObject data = new JSONObject ( ) ; mToken = result . getString ( Params . ACCESS_TOKEN ) ; mOpenId = result . getString ( Params . OPEN_ID ) ; try { data . put ( UID , mOpenId ) ; data . put ( TOKEN , mToken ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } dispatchData ( EVENT_LOGIN , data ) ; } @ Override public void onCancel ( ) { dispatchError ( EVENT_LOGIN , CODE_ERR_CANCEL , " login ▁ cancel " ) ; } } ) ; }
l1fan/GameAne | public void userLogout ( ) { mCool . logout ( getActivity ( ) , new OnAuthListener ( ) { @ Override public void onError ( ErrInfo err ) { dispatchError ( EVENT_LOGOUT , " logout ▁ fail : " + err . getError ( ) + err . getMessage ( ) ) ; } @ Override public void onDone ( Object arg0 ) { dispatchData ( EVENT_LOGOUT ) ; } @ Override public void onCancel ( ) { dispatchError ( EVENT_LOGOUT , CODE_ERR_CANCEL , " logout ▁ cancel " ) ; } } ) ; }
l1fan/GameAne | public void pay ( ) throws JSONException { JSONObject pay = getJsonData ( ) ; AccountBean account = CoolPadPay . buildAccount ( getActivity ( ) , mToken , mAppId , mOpenId ) ; String genUrl ; if ( pay . has ( " transid " ) || pay . has ( " transId " ) ) { genUrl = " transid = " + pay . optString ( " transid " , pay . optString ( " transId " ) ) + " & appid = " + mAppId ; } else { String uid = pay . optString ( UID ) ; String priKey = pay . optString ( " privateKey " , mPrivateKey ) ; genUrl = genUrl ( mAppId , uid , pay . optString ( EXT ) , priKey , pay . optInt ( PID ) , pay . optInt ( AMOUNT ) / 100.00 , pay . optString ( ORDER_ID ) , pay . optString ( NOTIFY_URL ) ) ; } CoolPadPay . startPay ( getActivity ( ) , genUrl , account , new IPayResultCallback ( ) { @ SuppressWarnings ( " deprecation " ) @ Override public void onPayResult ( int resultCode , String signValue , String resultInfo ) { switch ( resultCode ) { case CoolPadPay . PAY_SUCCESS : if ( TextUtils . isEmpty ( signValue ) ) { dispatchError ( EVENT_PAY , " pay ▁ fail : ▁ sign ▁ value ▁ is ▁ null " ) ; } else { int transdataLast = signValue . indexOf ( " & sign = " ) ; String transdata = URLDecoder . decode ( signValue . substring ( " transdata = " . length ( ) , transdataLast ) ) ; int signLast = signValue . indexOf ( " & signtype = " ) ; String sign = URLDecoder . decode ( signValue . substring ( transdataLast + " & sign = " . length ( ) , signLast ) ) ; String signtype = signValue . substring ( signLast + " & signtype = " . length ( ) ) ; boolean isSign = false ; try { isSign = RSAHelper . verify ( transdata , mPublicKey , sign ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( signtype . equals ( " RSA " ) && isSign ) { dispatchData ( EVENT_PAY ) ; } else { dispatchError ( EVENT_PAY , " pay ▁ fail : ▁ verify ▁ sign ▁ error " ) ; } } break ; default : dispatchError ( EVENT_PAY , " pay ▁ fail : " + resultCode + " : " + resultInfo ) ; break ; } } } ) ; }
l1fan/GameAne | private String genUrl ( String appid , String appuserid , String cpprivateinfo , String appPrivateKey , int waresid , double price , String cporderid , String url ) { String json = " " ; JSONObject obj = new JSONObject ( ) ; try { obj . put ( " appid " , appid ) ; obj . put ( " waresid " , waresid ) ; obj . put ( " cporderid " , cporderid ) ; obj . put ( " price " , price ) ; obj . put ( " appuserid " , appuserid ) ; String cpprivateinfo0 = cpprivateinfo ; if ( ! TextUtils . isEmpty ( cpprivateinfo0 ) ) { obj . put ( " cpprivateinfo " , cpprivateinfo0 ) ; } String notifyurl0 = url ; if ( ! TextUtils . isEmpty ( notifyurl0 ) ) { obj . put ( " notifyurl " , notifyurl0 ) ; } json = obj . toString ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } String sign = " " ; try { sign = RSAHelper . signForPKCS1 ( json , appPrivateKey ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return " transdata = " + URLEncoder . encode ( json ) + " & sign = " + URLEncoder . encode ( sign ) + " & signtype = " + " RSA " ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository ) { this ( repository , new ImportRules ( ) , new ArrayList < String > ( ) ) ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository , LogChannelInterface log ) { this ( repository , new ImportRules ( ) , Collections . < String > emptyList ( ) , log ) ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository , ImportRules importRules , List < String > limitDirs ) { this ( repository , importRules , limitDirs , new LogChannel ( " Repository ▁ import " ) ) ; }
mattyb149/pentaho-kettle | public RepositoryImporter ( Repository repository , ImportRules importRules , List < String > limitDirs , LogChannelInterface log ) { this . log = log ; this . rep = repository ; this . importRules = importRules ; this . limitDirs = limitDirs ; this . exceptions = new ArrayList < Exception > ( ) ; }
mattyb149/pentaho-kettle | private boolean isRemembered ( String rememberPropertyName ) { return ! " Y " . equalsIgnoreCase ( Props . getInstance ( ) . getProperty ( rememberPropertyName ) ) ; }
mattyb149/pentaho-kettle | private boolean getPromptResult ( String message , String rememberText , String rememberPropertyName ) { boolean result = false ; if ( ! askReplace ) { result = overwritePrompter . overwritePrompt ( message , rememberText , rememberPropertyName ) ; return result ; } if ( isRemembered ( rememberPropertyName ) ) { result = rememberPropertyNamesToOverwrite . contains ( rememberPropertyName ) ; return result ; } result = overwritePrompter . overwritePrompt ( message , rememberText , rememberPropertyName ) ; if ( result ) { rememberPropertyNamesToOverwrite . add ( rememberPropertyName ) ; } else { rememberPropertyNamesToOverwrite . remove ( rememberPropertyName ) ; } return result ; }
mattyb149/pentaho-kettle | @ Override public synchronized void importAll ( RepositoryImportFeedbackInterface feedback , String fileDirectory , String [ ] filenames , RepositoryDirectoryInterface baseDirectory , boolean overwrite , boolean continueOnError , String versionComment ) { this . baseDirectory = baseDirectory ; this . overwrite = overwrite ; this . continueOnError = continueOnError ; this . versionComment = versionComment ; String importPathCompatibility = System . getProperty ( Const . KETTLE_COMPATIBILITY_IMPORT_PATH_ADDITION_ON_VARIABLES , " N " ) ; this . needToCheckPathForVariables = " N " . equalsIgnoreCase ( importPathCompatibility ) ; askReplace = Props . getInstance ( ) . askAboutReplacingDatabaseConnections ( ) ; if ( askReplace ) { if ( feedback instanceof HasOverwritePrompter ) { Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_CS , " Y " ) ; Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_DB , " Y " ) ; Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_PS , " Y " ) ; Props . getInstance ( ) . setProperty ( IMPORT_ASK_ABOUT_REPLACE_SS , " Y " ) ; this . overwritePrompter = ( ( HasOverwritePrompter ) feedback ) . getOverwritePrompter ( ) ; } else { this . overwritePrompter = new OverwritePrompter ( ) { @ Override public boolean overwritePrompt ( String arg0 , String arg1 , String arg2 ) { throw new RuntimeException ( BaseMessages . getString ( PKG , " RepositoryImporter . CannotPrompt . Label " ) ) ; } } ; } } else { final boolean replaceExisting = Props . getInstance ( ) . replaceExistingDatabaseConnections ( ) ; this . overwritePrompter = new OverwritePrompter ( ) { @ Override public boolean overwritePrompt ( String arg0 , String arg1 , String arg2 ) { return replaceExisting ; } } ; } referencingObjects = new ArrayList < RepositoryObject > ( ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportXML . Label " ) ) ; try { loadSharedObjects ( ) ; RepositoryImportLocation . setRepositoryImportLocation ( baseDirectory ) ; for ( int ii = 0 ; ii < filenames . length ; ++ ii ) { final String filename = ( ! Const . isEmpty ( fileDirectory ) ) ? fileDirectory + Const . FILE_SEPARATOR + filenames [ ii ] : filenames [ ii ] ; if ( log . isBasic ( ) ) { log . logBasic ( " Import ▁ objects ▁ from ▁ XML ▁ file ▁ [ " + filename + " ] " ) ; } feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . WhichFile . Log " , filename ) ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . WhichDir . Label " ) ) ; try { RepositoryExportSaxParser parser = new RepositoryExportSaxParser ( filename , feedback ) ; parser . parse ( this ) ; } catch ( Exception e ) { addException ( e ) ; feedback . showError ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Message " ) , e ) ; } } for ( RepositoryObject repoObject : referencingObjects ) { switch ( repoObject . getObjectType ( ) ) { case TRANSFORMATION : TransMeta transMeta = rep . loadTransformation ( repoObject . getObjectId ( ) , null ) ; saveTransformationToRepo ( transMeta , feedback ) ; break ; case JOB : JobMeta jobMeta = rep . loadJob ( repoObject . getObjectId ( ) , null ) ; saveJobToRepo ( jobMeta , feedback ) ; break ; default : throw new KettleException ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorDetectFileType " ) ) ; } } feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportFinished . Log " ) ) ; } catch ( Exception e ) { addException ( e ) ; feedback . showError ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . ErrorGeneral . Message " ) , e ) ; } finally { RepositoryImportLocation . setRepositoryImportLocation ( null ) ; } }
mattyb149/pentaho-kettle | protected void loadSharedObjects ( ) throws KettleException { sharedObjects = new SharedObjects ( ) ; for ( ObjectId id : rep . getDatabaseIDs ( false ) ) { DatabaseMeta databaseMeta = rep . loadDatabaseMeta ( id , null ) ; validateImportedElement ( importRules , databaseMeta ) ; sharedObjects . storeObject ( databaseMeta ) ; } ObjectId [ ] slaveIDs = rep . getSlaveIDs ( false ) ; List < SlaveServer > slaveServers = new ArrayList < SlaveServer > ( slaveIDs . length ) ; for ( ObjectId id : slaveIDs ) { SlaveServer slaveServer = rep . loadSlaveServer ( id , null ) ; validateImportedElement ( importRules , slaveServer ) ; sharedObjects . storeObject ( slaveServer ) ; slaveServers . add ( slaveServer ) ; } for ( ObjectId id : rep . getClusterIDs ( false ) ) { ClusterSchema clusterSchema = rep . loadClusterSchema ( id , slaveServers , null ) ; validateImportedElement ( importRules , clusterSchema ) ; sharedObjects . storeObject ( clusterSchema ) ; } for ( ObjectId id : rep . getPartitionSchemaIDs ( false ) ) { PartitionSchema partitionSchema = rep . loadPartitionSchema ( id , null ) ; validateImportedElement ( importRules , partitionSchema ) ; sharedObjects . storeObject ( partitionSchema ) ; } }
mattyb149/pentaho-kettle | @ Override public void addLog ( String line ) { log . logBasic ( line ) ; }
mattyb149/pentaho-kettle | @ Override public void setLabel ( String labelText ) { log . logBasic ( labelText ) ; }
mattyb149/pentaho-kettle | @ Override public boolean transOverwritePrompt ( TransMeta transMeta ) { return overwrite ; }
mattyb149/pentaho-kettle | @ Override public boolean jobOverwritePrompt ( JobMeta jobMeta ) { return overwrite ; }
mattyb149/pentaho-kettle | @ Override public void updateDisplay ( ) { }
mattyb149/pentaho-kettle | @ Override public void showError ( String title , String message , Exception e ) { log . logError ( message , e ) ; }
mattyb149/pentaho-kettle | protected < T extends SharedObjectInterface > List < T > getSharedObjects ( Class < T > clazz ) { List < T > result = new ArrayList < T > ( ) ; for ( SharedObjectInterface sharedObject : sharedObjects . getObjectsMap ( ) . values ( ) ) { if ( clazz . isInstance ( sharedObject ) ) { result . add ( ( T ) sharedObject ) ; } } return result ; }
mattyb149/pentaho-kettle | private boolean equals ( Object obj1 , Object obj2 ) { if ( obj1 == null ) { if ( obj2 == null ) { return true ; } return false ; } if ( obj2 == null ) { return false ; } return obj1 . equals ( obj2 ) ; }
mattyb149/pentaho-kettle | protected boolean equals ( DatabaseMeta databaseMeta , DatabaseMeta databaseMeta2 ) { if ( ! equals ( databaseMeta . getName ( ) , databaseMeta2 . getName ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getPluginId ( ) , databaseMeta2 . getPluginId ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getAccessType ( ) , databaseMeta2 . getAccessType ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getHostname ( ) , databaseMeta2 . getHostname ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getDatabaseName ( ) , databaseMeta2 . getDatabaseName ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getDatabasePortNumberString ( ) , databaseMeta2 . getDatabasePortNumberString ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getUsername ( ) , databaseMeta2 . getUsername ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getPassword ( ) , databaseMeta2 . getPassword ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getServername ( ) , databaseMeta2 . getServername ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getDataTablespace ( ) , databaseMeta2 . getDataTablespace ( ) ) ) { return false ; } else if ( ! equals ( databaseMeta . getIndexTablespace ( ) , databaseMeta2 . getIndexTablespace ( ) ) ) { return false ; } Map < Object , Object > databaseMeta2Attributes = new HashMap < Object , Object > ( databaseMeta2 . getAttributes ( ) ) ; for ( Entry < Object , Object > databaseMetaEntry : new HashMap < Object , Object > ( databaseMeta . getAttributes ( ) ) . entrySet ( ) ) { Object value = databaseMeta2Attributes . remove ( databaseMetaEntry . getKey ( ) ) ; if ( ! equals ( value , databaseMetaEntry . getValue ( ) ) ) { return false ; } } if ( databaseMeta2Attributes . size ( ) > 0 ) { return false ; } return true ; }
mattyb149/pentaho-kettle | protected boolean equals ( SlaveServer slaveServer , SlaveServer slaveServer2 ) { if ( ! equals ( slaveServer . getName ( ) , slaveServer2 . getName ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getHostname ( ) , slaveServer2 . getHostname ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getPort ( ) , slaveServer2 . getPort ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getWebAppName ( ) , slaveServer2 . getWebAppName ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getUsername ( ) , slaveServer2 . getUsername ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getPassword ( ) , slaveServer2 . getPassword ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getProxyHostname ( ) , slaveServer2 . getProxyHostname ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getProxyPort ( ) , slaveServer2 . getProxyPort ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . getNonProxyHosts ( ) , slaveServer2 . getNonProxyHosts ( ) ) ) { return false ; } else if ( ! equals ( slaveServer . isMaster ( ) , slaveServer2 . isMaster ( ) ) ) { return false ; } return true ; }
mattyb149/pentaho-kettle | protected boolean equals ( PartitionSchema partitionSchema , PartitionSchema partitionSchema2 ) { if ( ! equals ( partitionSchema . getName ( ) , partitionSchema2 . getName ( ) ) ) { return false ; } else if ( ! equals ( partitionSchema . getPartitionIDs ( ) , partitionSchema2 . getPartitionIDs ( ) ) ) { return false ; } else if ( ! equals ( partitionSchema . isDynamicallyDefined ( ) , partitionSchema2 . isDynamicallyDefined ( ) ) ) { return false ; } else if ( ! equals ( partitionSchema . getNumberOfPartitionsPerSlave ( ) , partitionSchema2 . getNumberOfPartitionsPerSlave ( ) ) ) { return false ; } return true ; }
mattyb149/pentaho-kettle | protected boolean equals ( ClusterSchema clusterSchema , ClusterSchema clusterSchema2 ) { if ( ! equals ( clusterSchema . getName ( ) , clusterSchema2 . getName ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getBasePort ( ) , clusterSchema2 . getBasePort ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getSocketsBufferSize ( ) , clusterSchema2 . getSocketsBufferSize ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getSocketsFlushInterval ( ) , clusterSchema2 . getSocketsFlushInterval ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . isSocketsCompressed ( ) , clusterSchema2 . isSocketsCompressed ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . isDynamic ( ) , clusterSchema2 . isDynamic ( ) ) ) { return false ; } else if ( ! equals ( clusterSchema . getSlaveServers ( ) , clusterSchema2 . getSlaveServers ( ) ) ) { return false ; } return true ; }
mattyb149/pentaho-kettle | private void replaceSharedObjects ( AbstractMeta abstractMeta ) { for ( DatabaseMeta databaseMeta : getSharedObjects ( DatabaseMeta . class ) ) { int index = abstractMeta . indexOfDatabase ( databaseMeta ) ; if ( index < 0 ) { abstractMeta . addDatabase ( databaseMeta ) ; } else { DatabaseMeta imported = abstractMeta . getDatabase ( index ) ; imported . setObjectId ( databaseMeta . getObjectId ( ) ) ; if ( equals ( databaseMeta , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_DB ) ) { imported . replaceMeta ( databaseMeta ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } for ( SlaveServer slaveServer : getSharedObjects ( SlaveServer . class ) ) { int index = abstractMeta . getSlaveServers ( ) . indexOf ( slaveServer ) ; if ( index < 0 ) { abstractMeta . getSlaveServers ( ) . add ( slaveServer ) ; } else { SlaveServer imported = abstractMeta . getSlaveServers ( ) . get ( index ) ; imported . setObjectId ( slaveServer . getObjectId ( ) ) ; if ( equals ( slaveServer , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . SlaveServerExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_SS ) ) { imported . replaceMeta ( slaveServer ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } }
mattyb149/pentaho-kettle | protected void replaceSharedObjects ( TransMeta transMeta ) throws KettleException { replaceSharedObjects ( ( AbstractMeta ) transMeta ) ; for ( ClusterSchema clusterSchema : getSharedObjects ( ClusterSchema . class ) ) { int index = transMeta . getClusterSchemas ( ) . indexOf ( clusterSchema ) ; if ( index < 0 ) { transMeta . getClusterSchemas ( ) . add ( clusterSchema ) ; } else { ClusterSchema imported = transMeta . getClusterSchemas ( ) . get ( index ) ; imported . setObjectId ( clusterSchema . getObjectId ( ) ) ; if ( equals ( clusterSchema , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ClusterSchemaExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_CS ) ) { imported . replaceMeta ( clusterSchema ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } for ( PartitionSchema partitionSchema : getSharedObjects ( PartitionSchema . class ) ) { int index = transMeta . getPartitionSchemas ( ) . indexOf ( partitionSchema ) ; if ( index < 0 ) { transMeta . getPartitionSchemas ( ) . add ( partitionSchema ) ; } else { PartitionSchema imported = transMeta . getPartitionSchemas ( ) . get ( index ) ; imported . setObjectId ( partitionSchema . getObjectId ( ) ) ; if ( equals ( partitionSchema , imported ) || ! getPromptResult ( BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . PartitionSchemaExistsOverWrite . Message " , imported . getName ( ) ) , BaseMessages . getString ( PKG , " RepositoryImporter . Dialog . ConnectionExistsOverWrite . DontShowAnyMoreMessage " ) , IMPORT_ASK_ABOUT_REPLACE_PS ) ) { imported . replaceMeta ( partitionSchema ) ; imported . clearChanged ( ) ; } else { imported . setChanged ( ) ; } } } }
mattyb149/pentaho-kettle | protected void replaceSharedObjects ( JobMeta transMeta ) throws KettleException { replaceSharedObjects ( ( AbstractMeta ) transMeta ) ; }
mattyb149/pentaho-kettle | private void patchMappingSteps ( TransMeta transMeta ) { for ( StepMeta stepMeta : transMeta . getSteps ( ) ) { if ( stepMeta . isMapping ( ) ) { MappingMeta mappingMeta = ( MappingMeta ) stepMeta . getStepMetaInterface ( ) ; if ( mappingMeta . getSpecificationMethod ( ) == ObjectLocationSpecificationMethod . REPOSITORY_BY_NAME ) { if ( transDirOverride != null ) { mappingMeta . setDirectoryPath ( transDirOverride ) ; continue ; } String mappingMetaPath = resolvePath ( baseDirectory . getPath ( ) , mappingMeta . getDirectoryPath ( ) ) ; mappingMeta . setDirectoryPath ( mappingMetaPath ) ; } } } }
mattyb149/pentaho-kettle | private void patchJobEntries ( JobMeta jobMeta ) { for ( JobEntryCopy copy : jobMeta . getJobCopies ( ) ) { if ( copy . isTransformation ( ) ) { JobEntryTrans entry = ( JobEntryTrans ) copy . getEntry ( ) ; if ( entry . getSpecificationMethod ( ) == ObjectLocationSpecificationMethod . REPOSITORY_BY_NAME ) { if ( transDirOverride != null ) { entry . setDirectory ( transDirOverride ) ; continue ; } String entryPath = resolvePath ( baseDirectory . getPath ( ) , entry . getDirectory ( ) ) ; entry . setDirectory ( entryPath ) ; } } if ( copy . isJob ( ) ) { JobEntryJob entry = ( JobEntryJob ) copy . getEntry ( ) ; if ( entry . getSpecificationMethod ( ) == ObjectLocationSpecificationMethod . REPOSITORY_BY_NAME ) { if ( jobDirOverride != null ) { entry . setDirectory ( jobDirOverride ) ; continue ; } String entryPath = resolvePath ( baseDirectory . getPath ( ) , entry . getDirectory ( ) ) ; entry . setDirectory ( entryPath ) ; } } } }
mattyb149/pentaho-kettle | private String resolvePath ( String rootPath , String entryPath ) { String extraPath = Const . NVL ( entryPath , " / " ) ; if ( needToCheckPathForVariables ( ) ) { if ( containsVariables ( entryPath ) ) { return extraPath ; } } String newPath = Const . NVL ( rootPath , " / " ) ; if ( newPath . endsWith ( " / " ) && extraPath . startsWith ( " / " ) ) { newPath = newPath . substring ( 0 , newPath . length ( ) - 1 ) ; } else if ( ! newPath . endsWith ( " / " ) && ! extraPath . startsWith ( " / " ) ) { newPath += " / " ; } else if ( extraPath . equals ( " / " ) ) { extraPath = " " ; } return newPath + extraPath ; }
mattyb149/pentaho-kettle | boolean needToCheckPathForVariables ( ) { return needToCheckPathForVariables ; }
mattyb149/pentaho-kettle | protected void saveTransMeta ( TransMeta transMeta ) throws KettleException { rep . save ( transMeta , versionComment , this , overwrite ) ; }
mattyb149/pentaho-kettle | protected boolean importTransformation ( Node transnode , RepositoryImportFeedbackInterface feedback ) throws KettleException { TransMeta transMeta = createTransMetaForNode ( transnode ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportTrans . Label " , Integer . toString ( transformationNumber ) , transMeta . getName ( ) ) ) ; validateImportedElement ( importRules , transMeta ) ; String directoryPath = Const . NVL ( XMLHandler . getTagValue ( transnode , " info " , " directory " ) , Const . FILE_SEPARATOR ) ; if ( transDirOverride != null ) { directoryPath = transDirOverride ; } if ( directoryPath . startsWith ( " / " ) ) { directoryPath = directoryPath . substring ( 1 ) ; } if ( limitDirs . size ( ) > 0 && Const . indexOfString ( directoryPath , limitDirs ) < 0 ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedTransformationNotPartOfLimitingDirectories . Log " , transMeta . getName ( ) ) ) ; return true ; } RepositoryDirectoryInterface targetDirectory = getTargetDirectory ( directoryPath , transDirOverride , feedback ) ; ObjectId existingId = rep . getTransformationID ( transMeta . getName ( ) , targetDirectory ) ; if ( existingId != null && askOverwrite ) { overwrite = feedback . transOverwritePrompt ( transMeta ) ; askOverwrite = feedback . isAskingOverwriteConfirmation ( ) ; } else { updateDisplay ( ) ; } if ( existingId == null || overwrite ) { replaceSharedObjects ( transMeta ) ; transMeta . setObjectId ( existingId ) ; transMeta . setRepositoryDirectory ( targetDirectory ) ; patchMappingSteps ( transMeta ) ; try { if ( transMeta . getCreatedUser ( ) == null || transMeta . getCreatedUser ( ) . equals ( " - " ) ) { transMeta . setCreatedDate ( new Date ( ) ) ; if ( rep . getUserInfo ( ) != null ) { transMeta . setCreatedUser ( rep . getUserInfo ( ) . getLogin ( ) ) ; } else { transMeta . setCreatedUser ( null ) ; } } saveTransMeta ( transMeta ) ; feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . TransSaved . Log " , Integer . toString ( transformationNumber ) , transMeta . getName ( ) ) ) ; if ( transMeta . hasRepositoryReferences ( ) ) { referencingObjects . add ( new RepositoryObject ( transMeta . getObjectId ( ) , transMeta . getName ( ) , transMeta . getRepositoryDirectory ( ) , null , null , RepositoryObjectType . TRANSFORMATION , null , false ) ) ; } } catch ( Exception e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorSavingTrans . Log " , Integer . toString ( transformationNumber ) , transMeta . getName ( ) , Const . getStackTracker ( e ) ) ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } } else { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedExistingTransformation . Log " , transMeta . getName ( ) ) ) ; } return true ; }
mattyb149/pentaho-kettle | protected void saveJobMeta ( JobMeta jobMeta ) throws KettleException { if ( jobMeta . getCreatedUser ( ) == null || jobMeta . getCreatedUser ( ) . equals ( " - " ) ) { jobMeta . setCreatedDate ( new Date ( ) ) ; if ( rep . getUserInfo ( ) != null ) { jobMeta . setCreatedUser ( rep . getUserInfo ( ) . getLogin ( ) ) ; } else { jobMeta . setCreatedUser ( null ) ; } } rep . save ( jobMeta , versionComment , null , overwrite ) ; }
mattyb149/pentaho-kettle | protected boolean importJob ( Node jobnode , RepositoryImportFeedbackInterface feedback ) throws KettleException { JobMeta jobMeta = createJobMetaForNode ( jobnode ) ; feedback . setLabel ( BaseMessages . getString ( PKG , " RepositoryImporter . ImportJob . Label " , Integer . toString ( jobNumber ) , jobMeta . getName ( ) ) ) ; validateImportedElement ( importRules , jobMeta ) ; String directoryPath = Const . NVL ( XMLHandler . getTagValue ( jobnode , " directory " ) , Const . FILE_SEPARATOR ) ; if ( jobDirOverride != null ) { directoryPath = jobDirOverride ; } if ( directoryPath . startsWith ( " / " ) ) { directoryPath = directoryPath . substring ( 1 ) ; } if ( limitDirs . size ( ) > 0 && Const . indexOfString ( directoryPath , limitDirs ) < 0 ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedJobNotPartOfLimitingDirectories . Log " , jobMeta . getName ( ) ) ) ; return true ; } RepositoryDirectoryInterface targetDirectory = getTargetDirectory ( directoryPath , jobDirOverride , feedback ) ; ObjectId existintId = rep . getJobId ( jobMeta . getName ( ) , targetDirectory ) ; if ( existintId != null && askOverwrite ) { overwrite = feedback . jobOverwritePrompt ( jobMeta ) ; askOverwrite = feedback . isAskingOverwriteConfirmation ( ) ; } else { updateDisplay ( ) ; } if ( existintId == null || overwrite ) { replaceSharedObjects ( jobMeta ) ; jobMeta . setRepositoryDirectory ( targetDirectory ) ; jobMeta . setObjectId ( existintId ) ; patchJobEntries ( jobMeta ) ; try { saveJobMeta ( jobMeta ) ; if ( jobMeta . hasRepositoryReferences ( ) ) { referencingObjects . add ( new RepositoryObject ( jobMeta . getObjectId ( ) , jobMeta . getName ( ) , jobMeta . getRepositoryDirectory ( ) , null , null , RepositoryObjectType . JOB , null , false ) ) ; } feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . JobSaved . Log " , Integer . toString ( jobNumber ) , jobMeta . getName ( ) ) ) ; } catch ( Exception e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorSavingJob . Log " , Integer . toString ( jobNumber ) , jobMeta . getName ( ) , Const . getStackTracker ( e ) ) ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } } else { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . SkippedExistingJob . Log " , jobMeta . getName ( ) ) ) ; } return true ; }
mattyb149/pentaho-kettle | JobMeta createJobMetaForNode ( Node jobnode ) throws KettleXMLException { return new JobMeta ( jobnode , null , false , SpoonFactory . getInstance ( ) ) ; }
mattyb149/pentaho-kettle | private DocumentBuilder getOrCreateDb ( ) throws KettleXMLException { if ( documentBuilder == null ) { documentBuilder = XMLHandler . createDocumentBuilder ( false , true ) ; } return documentBuilder ; }
mattyb149/pentaho-kettle | @ Override public boolean transformationElementRead ( String xml , RepositoryImportFeedbackInterface feedback ) { try { Document doc = XMLHandler . loadXMLString ( getOrCreateDb ( ) , xml ) ; Node transformationNode = XMLHandler . getSubNode ( doc , RepositoryExportSaxParser . STRING_TRANSFORMATION ) ; if ( ! importTransformation ( transformationNode , feedback ) ) { return false ; } transformationNumber ++ ; } catch ( Exception e ) { feedback . showError ( BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringTransformationImport . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringTransformationImport . Message " ) , e ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } return true ; }
mattyb149/pentaho-kettle | @ Override public boolean jobElementRead ( String xml , RepositoryImportFeedbackInterface feedback ) { try { Document doc = XMLHandler . loadXMLString ( getOrCreateDb ( ) , xml ) ; Node jobNode = XMLHandler . getSubNode ( doc , RepositoryExportSaxParser . STRING_JOB ) ; if ( ! importJob ( jobNode , feedback ) ) { return false ; } jobNumber ++ ; } catch ( Exception e ) { showError ( BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringJobImport . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . UnexpectedErrorDuringJobImport . Message " ) , e ) ; if ( ! feedback . askContinueOnErrorQuestion ( BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Title " ) , BaseMessages . getString ( PKG , " RepositoryImporter . DoYouWantToContinue . Message " ) ) ) { return false ; } } return true ; }
mattyb149/pentaho-kettle | private RepositoryDirectoryInterface getTargetDirectory ( String directoryPath , String dirOverride , RepositoryImportFeedbackInterface feedback ) throws KettleException { RepositoryDirectoryInterface targetDirectory = null ; if ( dirOverride != null ) { targetDirectory = rep . findDirectory ( directoryPath ) ; if ( targetDirectory == null ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . CreateDir . Log " , directoryPath , getRepositoryRoot ( ) . toString ( ) ) ) ; targetDirectory = rep . createRepositoryDirectory ( getRepositoryRoot ( ) , directoryPath ) ; } } else { targetDirectory = baseDirectory . findDirectory ( directoryPath ) ; if ( targetDirectory == null ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . CreateDir . Log " , directoryPath , baseDirectory . toString ( ) ) ) ; targetDirectory = rep . createRepositoryDirectory ( baseDirectory , directoryPath ) ; } } return targetDirectory ; }
mattyb149/pentaho-kettle | private RepositoryDirectoryInterface getRepositoryRoot ( ) throws KettleException { if ( root == null ) { root = rep . loadRepositoryDirectoryTree ( ) ; } return root ; }
mattyb149/pentaho-kettle | @ Override public void fatalXmlErrorEncountered ( SAXParseException e ) { showError ( BaseMessages . getString ( PKG , " RepositoryImporter . ErrorInvalidXML . Message " ) , BaseMessages . getString ( PKG , " RepositoryImporter . ErrorInvalidXML . Title " ) , e ) ; }
mattyb149/pentaho-kettle | @ Override public boolean askContinueOnErrorQuestion ( String title , String message ) { return continueOnError ; }
mattyb149/pentaho-kettle | @ Override public void beginTask ( String message , int nrWorks ) { addLog ( message ) ; }
mattyb149/pentaho-kettle | @ Override public void done ( ) { }
mattyb149/pentaho-kettle | @ Override public boolean isCanceled ( ) { return false ; }
mattyb149/pentaho-kettle | @ Override public void setTaskName ( String taskName ) { addLog ( taskName ) ; }
mattyb149/pentaho-kettle | @ Override public void subTask ( String message ) { addLog ( message ) ; }
mattyb149/pentaho-kettle | @ Override public void worked ( int nrWorks ) { }
mattyb149/pentaho-kettle | public String getTransDirOverride ( ) { return transDirOverride ; }
mattyb149/pentaho-kettle | @ Override public void setTransDirOverride ( String transDirOverride ) { this . transDirOverride = transDirOverride ; }
mattyb149/pentaho-kettle | public String getJobDirOverride ( ) { return jobDirOverride ; }
mattyb149/pentaho-kettle | @ Override public void setJobDirOverride ( String jobDirOverride ) { this . jobDirOverride = jobDirOverride ; }
mattyb149/pentaho-kettle | @ Override public void setImportRules ( ImportRules importRules ) { this . importRules = importRules ; }
mattyb149/pentaho-kettle | public ImportRules getImportRules ( ) { return importRules ; }
mattyb149/pentaho-kettle | @ Override public boolean isAskingOverwriteConfirmation ( ) { return askOverwrite ; }
mattyb149/pentaho-kettle | private void addException ( Exception exception ) { if ( this . exceptions == null ) { this . exceptions = new ArrayList < Exception > ( ) ; } exceptions . add ( exception ) ; }
mattyb149/pentaho-kettle | @ Override public List < Exception > getExceptions ( ) { return exceptions ; }
mattyb149/pentaho-kettle | @ Override public void setLimitDirs ( List < String > limitDirs ) { this . limitDirs = new ArrayList < String > ( limitDirs ) ; }
mattyb149/pentaho-kettle | protected void setBaseDirectory ( RepositoryDirectoryInterface baseDirectory ) { this . baseDirectory = baseDirectory ; }
mattyb149/pentaho-kettle | public void setOverwrite ( boolean overwrite ) { this . overwrite = overwrite ; }
mattyb149/pentaho-kettle | public String getVersionComment ( ) { return versionComment ; }
mattyb149/pentaho-kettle | private void saveTransformationToRepo ( TransMeta transMeta , RepositoryImportFeedbackInterface feedback ) throws KettleException { try { transMeta . lookupRepositoryReferences ( rep ) ; } catch ( LookupReferencesException e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log " , transMeta . getName ( ) , RepositoryObjectType . TRANSFORMATION ) ) ; feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log . Cause " , e . objectTypePairsToString ( ) ) ) ; } rep . save ( transMeta , " import ▁ object ▁ reference ▁ specification " , null ) ; }
mattyb149/pentaho-kettle | private void saveJobToRepo ( JobMeta jobMeta , RepositoryImportFeedbackInterface feedback ) throws KettleException { try { jobMeta . lookupRepositoryReferences ( rep ) ; } catch ( LookupReferencesException e ) { feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log " , jobMeta . getName ( ) , RepositoryObjectType . JOB ) ) ; feedback . addLog ( BaseMessages . getString ( PKG , " RepositoryImporter . LookupRepoRefsError . Log . Cause " , e . objectTypePairsToString ( ) ) ) ; } rep . save ( jobMeta , " import ▁ object ▁ reference ▁ specification " , null ) ; }
OpenHFT/Chronicle-Network | public FatalFailureConnectionStrategy ( int attempts , boolean blocking ) { this . attempts = attempts ; this . blocking = blocking ; init ( ) ; }
OpenHFT/Chronicle-Network | private void init ( ) { if ( tcpBufferSize == 0 ) tcpBufferSize = Jvm . getInteger ( " tcp . client . buffer . size " , TCP_BUFFER ) ; if ( isClosed == null ) isClosed = new AtomicBoolean ( false ) ; if ( clientConnectionMonitor == null ) clientConnectionMonitor = new VanillaClientConnectionMonitor ( ) ; }
OpenHFT/Chronicle-Network | @ Override public ClientConnectionMonitor clientConnectionMonitor ( ) { return clientConnectionMonitor ; }
OpenHFT/Chronicle-Network | public FatalFailureConnectionStrategy clientConnectionMonitor ( ClientConnectionMonitor fatalFailureMonitor ) { this . clientConnectionMonitor = fatalFailureMonitor ; return this ; }
OpenHFT/Chronicle-Network | @ Nullable @ Override public ChronicleSocketChannel connect ( @ NotNull String name , @ NotNull SocketAddressSupplier socketAddressSupplier , boolean didLogIn , @ Nullable FatalFailureMonitor fatalFailureMonitor ) throws InterruptedException { if ( socketAddressSupplier . size ( ) == 0 && ! hasSentFatalFailure && fatalFailureMonitor != null ) { hasSentFatalFailure = true ; fatalFailureMonitor . onFatalFailure ( name , " no ▁ connections ▁ have ▁ not ▁ been ▁ configured " ) ; LockSupport . parkNanos ( PAUSE ) ; return null ; } int failures = 0 ; int maxFailures = socketAddressSupplier . size ( ) * attempts ; socketAddressSupplier . resetToPrimary ( ) ; for ( ; ; ) { throwExceptionIfClosed ( ) ; if ( Thread . currentThread ( ) . isInterrupted ( ) ) throw new InterruptedException ( ) ; if ( failures == maxFailures && fatalFailureMonitor != null ) { if ( ! hasSentFatalFailure ) { hasSentFatalFailure = true ; fatalFailureMonitor . onFatalFailure ( name , name ) ; } return null ; } ChronicleSocketChannel socketChannel = null ; try { @ Nullable final InetSocketAddress socketAddress = socketAddressSupplier . get ( ) ; if ( socketAddress == null ) { failures ++ ; socketAddressSupplier . failoverToNextAddress ( ) ; LockSupport . parkNanos ( PAUSE ) ; continue ; } long millis = TimeUnit . NANOSECONDS . toMillis ( PAUSE ) ; socketChannel = openSocketChannel ( socketAddress , tcpBufferSize , millis ) ; if ( socketChannel == null ) { Jvm . warn ( ) . on ( getClass ( ) , " unable ▁ to ▁ connected ▁ to ▁ " + socketAddressSupplier . toString ( ) + " , ▁ name = " + name ) ; failures ++ ; socketAddressSupplier . failoverToNextAddress ( ) ; LockSupport . parkNanos ( PAUSE ) ; continue ; } socketChannel . configureBlocking ( blocking ) ; if ( Jvm . isDebugEnabled ( getClass ( ) ) ) Jvm . debug ( ) . on ( getClass ( ) , " successfully ▁ connected ▁ to ▁ " + socketAddressSupplier ) ; hasSentFatalFailure = false ; failures = 0 ; return socketChannel ; } catch ( InterruptedException e ) { throw e ; } catch ( Throwable e ) { if ( socketChannel != null ) closeQuietly ( socketChannel ) ; failures ++ ; socketAddressSupplier . failoverToNextAddress ( ) ; LockSupport . parkNanos ( PAUSE ) ; } } }
OpenHFT/Chronicle-Network | @ Override public void close ( ) { isClosed . set ( true ) ; }
OpenHFT/Chronicle-Network | @ Override public boolean isClosed ( ) { return isClosed . get ( ) ; }
OpenHFT/Chronicle-Network | @ Override public FatalFailureConnectionStrategy open ( ) { isClosed . set ( false ) ; return this ; }
OpenHFT/Chronicle-Network | @ Override public void readMarshallable ( @ NotNull WireIn wire ) throws IORuntimeException { super . readMarshallable ( wire ) ; init ( ) ; }
MobileCloudNetworking/icnaas | @ Before public void setUp ( ) throws Exception { }
MobileCloudNetworking/icnaas | @ After public void tearDown ( ) throws Exception { }
MobileCloudNetworking/icnaas | @ Test public void testThumbnails ( ) throws Exception { Log . info ( Log . FAC_TEST , " Starting ▁ testThumbnails " ) ; byte [ ] fakeImageData1 = " xxx " . getBytes ( ) ; ContentName thumbNailBase = new ContentName ( testHelper . getTestNamespace ( " testThumbnails " ) , " thumbnailBaseFile " ) ; CCNStringObject cso = new CCNStringObject ( thumbNailBase , " thumbNailBase " , CCNFlowControl . SaveType . REPOSITORY , putHandle ) ; cso . save ( ) ; cso . close ( ) ; ContentName origVersion = SegmentationProfile . segmentRoot ( VersioningProfile . getLatestVersion ( thumbNailBase , cso . getContentPublisher ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle . defaultVerifier ( ) , getHandle ) . name ( ) ) ; ContentName thumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ simple ▁ thumbnail " ) ; RepositoryFileOutputStream thumbImage1 = new RepositoryFileOutputStream ( thumbName , putHandle ) ; thumbImage1 . write ( fakeImageData1 , 0 , fakeImageData1 . length ) ; thumbImage1 . close ( ) ; ContentName checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData1 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ second ▁ version ▁ of ▁ a ▁ thumbnail " ) ; byte [ ] fakeImageData2 = " yyy " . getBytes ( ) ; ContentName thumbName2 = VersioningProfile . updateVersion ( checkThumbName ) ; RepositoryFileOutputStream thumbImage2 = new RepositoryFileOutputStream ( thumbName2 , putHandle ) ; thumbImage2 . write ( fakeImageData2 , 0 , fakeImageData2 . length ) ; thumbImage2 . close ( ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData2 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ thumbnail ▁ associated ▁ with ▁ a ▁ second ▁ version ▁ of ▁ a ▁ file " ) ; cso = new CCNStringObject ( thumbNailBase , " thumbNailBase " , CCNFlowControl . SaveType . REPOSITORY , putHandle ) ; cso . save ( ) ; cso . close ( ) ; byte [ ] fakeImageData3 = " zzz " . getBytes ( ) ; thumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; RepositoryFileOutputStream thumbImage3 = new RepositoryFileOutputStream ( thumbName , putHandle ) ; thumbImage3 . write ( fakeImageData3 , 0 , fakeImageData3 . length ) ; thumbImage3 . close ( ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData3 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ a ▁ second ▁ thumbnail ▁ associated ▁ with ▁ a ▁ second ▁ version ▁ of ▁ a ▁ file " ) ; byte [ ] fakeImageData4 = " fff " . getBytes ( ) ; thumbName2 = VersioningProfile . updateVersion ( checkThumbName ) ; RepositoryFileOutputStream thumbImage4 = new RepositoryFileOutputStream ( thumbName2 , putHandle ) ; thumbImage4 . write ( fakeImageData4 , 0 , fakeImageData4 . length ) ; thumbImage4 . close ( ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( thumbNailBase , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData4 ) ; Log . info ( Log . FAC_TEST , " Check ▁ that ▁ we ▁ can ▁ retrieve ▁ the ▁ correct ▁ thumbnail ▁ associated ▁ with ▁ an ▁ arbitrary ▁ version ▁ of ▁ a ▁ file " ) ; checkThumbName = ThumbnailProfile . getLatestVersion ( origVersion , " image . png " . getBytes ( ) , SystemConfiguration . LONG_TIMEOUT , putHandle ) ; checkData ( checkThumbName , fakeImageData2 ) ; Log . info ( Log . FAC_TEST , " Completed ▁ testThumbnails " ) ; }
MobileCloudNetworking/icnaas | private void checkData ( ContentName name , byte [ ] check ) throws IOException { CCNInputStream input = new CCNInputStream ( name , getHandle ) ; byte [ ] buffer = new byte [ check . length ] ; Assert . assertTrue ( - 1 != input . read ( buffer ) ) ; Assert . assertArrayEquals ( buffer , check ) ; input . close ( ) ; }
integrated/jakarta-slide-server | public GroupNode ( ) { super ( ) ; }
integrated/jakarta-slide-server | public GroupNode ( String uri ) { super ( uri ) ; }
integrated/jakarta-slide-server | public GroupNode ( String uri , Vector children , Vector links ) { super ( uri , children , links ) ; }
CognizantOneDevOps/Insights | public boolean isUsecaseExisting ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; List < AutoMLConfig > resultList = getResultList ( " FROM ▁ AutoMLConfig ▁ a ▁ WHERE ▁ a . useCaseName ▁ = ▁ : usecase ▁ " , AutoMLConfig . class , parameters ) ; if ( resultList . isEmpty ( ) ) { return Boolean . FALSE ; } else { return Boolean . TRUE ; } } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public boolean createOrUpdate ( String usecase , String config , String prediction , String Mojo ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; List < AutoMLConfig > resultList = getResultList ( " FROM ▁ AutoMLConfig ▁ a ▁ WHERE ▁ a . usecase ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; AutoMLConfig autoMLConfig = null ; Long updatedDate = System . currentTimeMillis ( ) ; if ( ! resultList . isEmpty ( ) ) { autoMLConfig = resultList . get ( 0 ) ; } if ( autoMLConfig != null ) { if ( Mojo != null ) autoMLConfig . setMojoDeployed ( Mojo ) ; if ( prediction != null ) autoMLConfig . setPredictionColumn ( prediction ) ; autoMLConfig . setUpdatedDate ( updatedDate ) ; update ( autoMLConfig ) ; } else { autoMLConfig = new AutoMLConfig ( ) ; autoMLConfig . setUseCaseName ( usecase ) ; autoMLConfig . setConfigJson ( config ) ; autoMLConfig . setCreatedDate ( updatedDate ) ; autoMLConfig . setUpdatedDate ( updatedDate ) ; save ( autoMLConfig ) ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public int updateMLConfig ( AutoMLConfig config ) { int id = - 1 ; try { update ( config ) ; return 1 ; } catch ( Exception e ) { return id ; } }
CognizantOneDevOps/Insights | public int saveMLConfig ( AutoMLConfig config ) { int id = - 1 ; try { return ( int ) save ( config ) ; } catch ( Exception e ) { return id ; } }
CognizantOneDevOps/Insights | public String getPredictionColumn ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; AutoMLConfig result = getSingleResult ( " FROM ▁ AutoMLConfig ▁ AC ▁ WHERE ▁ AC . usecase ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; return result . getPredictionColumn ( ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public AutoMLConfig getMLConfigByUsecase ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; return getSingleResult ( " FROM ▁ AutoMLConfig ▁ AC ▁ WHERE ▁ AC . useCaseName ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public boolean deleteUsecase ( String usecase ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( USECASE , usecase ) ; AutoMLConfig autoMLConfig = getUniqueResult ( " FROM ▁ AutoMLConfig ▁ a ▁ WHERE ▁ a . useCaseName ▁ = ▁ : usecase " , AutoMLConfig . class , parameters ) ; if ( autoMLConfig != null ) { List < InsightsWorkflowExecutionHistory > executionHistory = workflowDal . getWorkflowExecutionHistoryByWorkflowId ( autoMLConfig . getWorkflowConfig ( ) . getWorkflowId ( ) ) ; if ( ! executionHistory . isEmpty ( ) ) { executionHistory . forEach ( eachExecution -> { workflowDal . deleteExecutionHistory ( eachExecution ) ; } ) ; } delete ( autoMLConfig ) ; } else { return false ; } return true ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public List < AutoMLConfig > fetchUsecases ( ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; return getResultList ( " FROM ▁ AutoMLConfig " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public AutoMLConfig fetchUseCasesByWorkflowId ( String workflowId ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; parameters . put ( " workflowId " , workflowId ) ; return getUniqueResult ( " FROM ▁ AutoMLConfig ▁ AMLC ▁ where ▁ AMLC . workflowConfig . workflowId ▁ = ▁ : workflowId " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
CognizantOneDevOps/Insights | public List < AutoMLConfig > getActiveUsecaseList ( ) { try { Map < String , Object > parameters = new HashMap < > ( ) ; return getResultList ( " FROM ▁ AutoMLConfig ▁ AMLC ▁ WHERE ▁ AMLC . isActive ▁ = ▁ true ▁ AND ▁ AMLC . status ▁ = ▁ ' MOJO _ DEPLOYED ' " , AutoMLConfig . class , parameters ) ; } catch ( Exception e ) { log . error ( e . getMessage ( ) ) ; throw e ; } }
salyh/geronimo-specs | private JsonCollectors ( ) { }
OpenAMEE/amee.platform.api | @ Override public void setAsText ( String text ) { if ( ! text . isEmpty ( ) ) { ValueDefinition valueDefinition = definitionService . getValueDefinition ( text ) ; if ( valueDefinition != null ) { setValue ( valueDefinition ) ; } else { throw new IllegalArgumentException ( " Invalid ▁ UID : ▁ " + text ) ; } } else { throw new IllegalArgumentException ( " UID ▁ is ▁ empty " ) ; } }
bptlab/processeditor | @ Override public ProcessEdge createDefaultEdge ( ProcessNode source , ProcessNode target ) { return new Connection ( source , target ) ; }
bptlab/processeditor | @ Override public List < ProcessLayouter > getLayouters ( ) { if ( layouters == null ) { layouters = new ArrayList < ProcessLayouter > ( ) ; layouters . add ( new SugiyamaLayoutAlgorithm ( true , Configuration . getProperties ( ) ) ) ; layouters . add ( new SugiyamaLayoutAlgorithm ( false , Configuration . getProperties ( ) ) ) ; } return layouters ; }
bptlab/processeditor | @ Override public List < Class < ? extends ProcessNode > > getNextNodesRecommendation ( ProcessModel model , ProcessNode node ) { List < Class < ? extends ProcessNode > > result = new LinkedList < Class < ? extends ProcessNode > > ( ) ; if ( node instanceof Event ) { result . add ( Function . class ) ; result . add ( ANDConnector . class ) ; } if ( node instanceof Function ) { result . add ( Event . class ) ; result . add ( XORConnector . class ) ; result . add ( ORConnector . class ) ; } if ( node instanceof XORConnector || node instanceof ORConnector ) { result . add ( Event . class ) ; } if ( node instanceof ANDConnector ) { result . add ( Function . class ) ; } return result ; }
lgdlkq/coolweather | @ Nullable @ Override public IBinder onBind ( Intent intent ) { return null ; }
lgdlkq/coolweather | @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { updateWeather ( ) ; updateBingPic ( ) ; AlarmManager manager = ( AlarmManager ) getSystemService ( ALARM_SERVICE ) ; int anHour = 8 * 60 * 60 * 1000 ; long triggerAtTime = SystemClock . elapsedRealtime ( ) + anHour ; Intent i = new Intent ( this , AutoUpdateService . class ) ; PendingIntent pi = PendingIntent . getService ( this , 0 , i , 0 ) ; manager . cancel ( pi ) ; manager . set ( AlarmManager . ELAPSED_REALTIME_WAKEUP , triggerAtTime , pi ) ; return super . onStartCommand ( intent , flags , startId ) ; }
lgdlkq/coolweather | private void updateBingPic ( ) { String requestBingPic = " http : // guolin . tech / api . bing _ pic " ; HttpUtil . sendOkHttpRequest ( requestBingPic , new Callback ( ) { @ Override public void onFailure ( Call call , IOException e ) { e . printStackTrace ( ) ; } @ Override public void onResponse ( Call call , Response response ) throws IOException { String bingPic = response . body ( ) . string ( ) ; SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( AutoUpdateService . this ) . edit ( ) ; editor . putString ( " bing _ pic " , bingPic ) ; editor . apply ( ) ; } } ) ; }
lgdlkq/coolweather | private void updateWeather ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; String weatherString = prefs . getString ( " weather " , null ) ; if ( weatherString != null ) { Weather weather = Utility . handleWeatherResponse ( weatherString ) ; String weatherId = weather . basic . weatherId ; String weatherUrl = " http : // guolin . tech / weather ? cityid = " + weatherId + " & key = df796160155949ff98dc040016043c0f " ; HttpUtil . sendOkHttpRequest ( weatherUrl , new Callback ( ) { @ Override public void onFailure ( Call call , IOException e ) { e . printStackTrace ( ) ; } @ Override public void onResponse ( Call call , Response response ) throws IOException { String responseText = response . body ( ) . string ( ) ; Weather weather = Utility . handleWeatherResponse ( responseText ) ; if ( weather != null && " ok " . equals ( weather . status ) ) { SharedPreferences . Editor editor = PreferenceManager . getDefaultSharedPreferences ( AutoUpdateService . this ) . edit ( ) ; editor . putString ( " weather " , responseText ) ; editor . apply ( ) ; } } } ) ; } }
hackingwu/EasyCMS | public String getId ( ) { return id ; }
hackingwu/EasyCMS | public void setId ( String id ) { this . id = id ; }
hackingwu/EasyCMS | public String getName ( ) { return name ; }
hackingwu/EasyCMS | public void setName ( String name ) { this . name = name ; }
hackingwu/EasyCMS | public String getState ( ) { return state ; }
hackingwu/EasyCMS | public void setState ( String state ) { this . state = state ; }
hackingwu/EasyCMS | public String getOrderNum ( ) { return orderNum ; }
hackingwu/EasyCMS | public void setOrderNum ( String orderNum ) { this . orderNum = orderNum ; }
hackingwu/EasyCMS | public String getUseSites ( ) { return useSites ; }
hackingwu/EasyCMS | public void setUseSites ( String useSites ) { this . useSites = useSites ; }
hackingwu/EasyCMS | public String getUseSiteNames ( ) { return useSiteNames ; }
hackingwu/EasyCMS | public void setUseSiteNames ( String useSiteNames ) { this . useSiteNames = useSiteNames ; }
hackingwu/EasyCMS | public User getAddUser ( ) { return addUser ; }
hackingwu/EasyCMS | public void setAddUser ( User addUser ) { this . addUser = addUser ; }
hackingwu/EasyCMS | public String getNoDel ( ) { return noDel ; }
hackingwu/EasyCMS | public void setNoDel ( String noDel ) { this . noDel = noDel ; }
hackingwu/EasyCMS | public String getStateStr ( ) { return state . equals ( "2" ) ? " 已删除 " : ( state . equals ( "0" ) ? " 否 " : " 是 " ) ; }
hackingwu/EasyCMS | public void setStateStr ( String stateStr ) { this . stateStr = stateStr ; }
amoudi87/hyracks | public InMemoryInvertedIndexInsertTest ( ) { super ( InvertedIndexType . INMEMORY , false ) ; }
Union-Investment/Crud2Go | public SQLContainerEventWrapper ( QueryDelegate delegate , DataContainer databaseContainer , EventRouter < CreateEventHandler , CreateEvent > onCreateEventRouter ) throws SQLException { super ( delegate ) ; this . databaseContainer = databaseContainer ; this . onCreateEventRouter = onCreateEventRouter ; }
Union-Investment/Crud2Go | @ Override public Object addItem ( ) throws UnsupportedOperationException { Object rowId = super . addItem ( ) ; RowItem rowItem = ( RowItem ) this . getItem ( rowId ) ; onCreateEventRouter . fireEvent ( new CreateEvent ( databaseContainer , databaseContainer . convertItemToRow ( rowItem , false , false ) ) ) ; return rowId ; }
Union-Investment/Crud2Go | @ Override public void fireContentsChange ( ) { super . fireContentsChange ( ) ; }
Union-Investment/Crud2Go | public void markRowAsModified ( Object itemId ) { try { RowItem item = ( RowItem ) getItemUnfiltered ( itemId ) ; Method method = SQLContainer . class . getDeclaredMethod ( " itemChangeNotification " , RowItem . class ) ; method . setAccessible ( true ) ; method . invoke ( this , item ) ; } catch ( NoSuchMethodException e ) { throw new TechnicalCrudPortletException ( " Error ▁ finding ▁ super . itemChangeNotification ( RowItem ) ▁ via ▁ reflection " , e ) ; } catch ( IllegalAccessException e ) { throw new TechnicalCrudPortletException ( " Error ▁ calling ▁ super . itemChangeNotification ( RowItem ) ▁ via ▁ reflection " , e ) ; } catch ( InvocationTargetException e ) { throw new TechnicalCrudPortletException ( " Error ▁ calling ▁ super . itemChangeNotification ( RowItem ) ▁ via ▁ reflection " , e ) ; } }
Union-Investment/Crud2Go | @ Override public int indexOfId ( Object itemId ) { if ( itemId instanceof TemporaryRowId || getItemUnfiltered ( itemId ) != null || ! ( getQueryDelegate ( ) instanceof IndexResolver ) ) { return super . indexOfId ( itemId ) ; } if ( itemId != null ) { IndexResolver tableQuery = ( IndexResolver ) getQueryDelegate ( ) ; Integer index = tableQuery . getIndexById ( ( RowId ) itemId ) ; if ( index != null ) { getIdByIndex ( index ) ; return index ; } } return - 1 ; }
Union-Investment/Crud2Go | public void replaceContainerFilter ( Filter filter ) { clearFiltersWithoutRefresh ( ) ; addContainerFilter ( filter ) ; }
Union-Investment/Crud2Go | private void clearFiltersWithoutRefresh ( ) { try { Field filtersField = SQLContainer . class . getDeclaredField ( " filters " ) ; filtersField . setAccessible ( true ) ; List < Filter > filters = ( List < Filter > ) filtersField . get ( this ) ; filters . clear ( ) ; } catch ( Exception e ) { throw new TechnicalCrudPortletException ( " ' filters ' ▁ field ▁ not ▁ accessible " , e ) ; } }
Union-Investment/Crud2Go | public void setSizeValidMilliSeconds ( int i ) { try { Field field = SQLContainer . class . getDeclaredField ( " sizeValidMilliSeconds " ) ; field . setAccessible ( true ) ; field . set ( this , i ) ; } catch ( SecurityException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } catch ( NoSuchFieldException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } catch ( IllegalArgumentException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } catch ( IllegalAccessException e ) { throw new TechnicalCrudPortletException ( " Error ▁ setting ▁ sizeValidMilliSeconds " , e ) ; } }
Union-Investment/Crud2Go | @ Override public List < Object > getItemIds ( int startIndex , int numberOfIds ) { try { return super . getItemIds ( startIndex , numberOfIds ) ; } catch ( IndexOutOfBoundsException e ) { LOGGER . info ( " Error ▁ getting ▁ item ▁ ids ▁ - ▁ database ▁ content ▁ may ▁ have ▁ changed " , e ) ; throw new BusinessException ( " portlet . crud . error . scrollingInconsistency " ) ; } }
huitseeker/deeplearning4j | public VariableMultiTimeseriesGenerator ( long seed , int numBatches , int batchSize , int values , int timestepsMin , int timestepsMax ) { this ( seed , numBatches , batchSize , values , timestepsMin , timestepsMax , 0 ) ; }
huitseeker/deeplearning4j | public VariableMultiTimeseriesGenerator ( long seed , int numBatches , int batchSize , int values , int timestepsMin , int timestepsMax , int firstMaxima ) { this . rng = new Random ( seed ) ; this . values = values ; this . batchSize = batchSize ; this . limit = numBatches ; this . maxTS = timestepsMax ; this . minTS = timestepsMin ; this . firstMaxima = firstMaxima ; if ( timestepsMax < timestepsMin ) throw new DL4JInvalidConfigException ( " timestepsMin ▁ should ▁ be ▁ < = ▁ timestepsMax " ) ; }
huitseeker/deeplearning4j | @ Override public MultiDataSet next ( int num ) { int localMaxima = isFirst && firstMaxima > 0 ? firstMaxima : minTS == maxTS ? minTS : rng . nextInt ( maxTS - minTS ) + minTS ; if ( isFirst ) log . info ( " Local ▁ maxima : ▁ { } " , localMaxima ) ; isFirst = false ; int [ ] shapeFeatures = new int [ ] { batchSize , values , localMaxima } ; int [ ] shapeLabels = new int [ ] { batchSize , 10 } ; int [ ] shapeFMasks = new int [ ] { batchSize , localMaxima } ; int [ ] shapeLMasks = new int [ ] { batchSize , 10 } ; INDArray features = Nd4j . createUninitialized ( shapeFeatures ) . assign ( counter . get ( ) ) ; INDArray labels = Nd4j . createUninitialized ( shapeLabels ) . assign ( counter . get ( ) + 0.25 ) ; INDArray fMasks = Nd4j . createUninitialized ( shapeFMasks ) . assign ( counter . get ( ) + 0.50 ) ; INDArray lMasks = Nd4j . createUninitialized ( shapeLMasks ) . assign ( counter . get ( ) + 0.75 ) ; counter . getAndIncrement ( ) ; return new org . nd4j . linalg . dataset . MultiDataSet ( new INDArray [ ] { features } , new INDArray [ ] { labels } , new INDArray [ ] { fMasks } , new INDArray [ ] { lMasks } ) ; }
huitseeker/deeplearning4j | @ Override public void setPreProcessor ( MultiDataSetPreProcessor preProcessor ) { }
huitseeker/deeplearning4j | @ Override public MultiDataSetPreProcessor getPreProcessor ( ) { return null ; }
huitseeker/deeplearning4j | @ Override public boolean resetSupported ( ) { return true ; }
huitseeker/deeplearning4j | @ Override public boolean asyncSupported ( ) { return true ; }
huitseeker/deeplearning4j | @ Override public void reset ( ) { isFirst = true ; counter . set ( 0 ) ; }
huitseeker/deeplearning4j | @ Override public boolean hasNext ( ) { return counter . get ( ) < limit ; }
huitseeker/deeplearning4j | @ Override public MultiDataSet next ( ) { return next ( batchSize ) ; }
huitseeker/deeplearning4j | @ Override public void remove ( ) { }
marpies/onesignal-ane | @ Override public Map < String , FREFunction > getFunctions ( ) { Map < String , FREFunction > functions = new HashMap < String , FREFunction > ( ) ; functions . put ( " init " , new InitFunction ( ) ) ; functions . put ( " sdkVersion " , new GetSDKVersionFunction ( ) ) ; functions . put ( " setSubscription " , new SetSubscriptionFunction ( ) ) ; functions . put ( " register " , new RegisterFunction ( ) ) ; functions . put ( " sendTags " , new SendTagsFunction ( ) ) ; functions . put ( " deleteTags " , new DeleteTagsFunction ( ) ) ; functions . put ( " getTags " , new GetTagsFunction ( ) ) ; functions . put ( " areNotificationsEnabled " , new AreNotificationsEnabledFunction ( ) ) ; functions . put ( " areNotificationsAvailable " , new AreNotificationsAvailableFunction ( ) ) ; functions . put ( " postNotification " , new PostNotificationFunction ( ) ) ; functions . put ( " idsAvailable " , new IdsAvailableFunction ( ) ) ; functions . put ( " clearNotifications " , new ClearNotificationsFunction ( ) ) ; functions . put ( " setRequiresUserPrivacyConsent " , new SetRequiresUserPrivacyConsentFunction ( ) ) ; functions . put ( " provideUserConsent " , new ProvideUserConsentFunction ( ) ) ; functions . put ( " userProvidedPrivacyConsent " , new GetUserProvidedPrivacyConsentFunction ( ) ) ; return functions ; }
marpies/onesignal-ane | @ Override public void dispose ( ) { AIR . setContext ( null ) ; }
mjball/Singularity | @ JsonCreator public S3UploadMetadata ( @ JsonProperty ( " directory " ) String directory , @ JsonProperty ( " fileGlob " ) String fileGlob , @ JsonProperty ( " s3Bucket " ) String s3Bucket , @ JsonProperty ( " s3KeyFormat " ) String s3KeyFormat , @ JsonProperty ( " finished " ) boolean finished ) { Preconditions . checkNotNull ( directory ) ; Preconditions . checkNotNull ( fileGlob ) ; Preconditions . checkNotNull ( s3Bucket ) ; Preconditions . checkNotNull ( s3KeyFormat ) ; this . directory = directory ; this . fileGlob = fileGlob ; this . s3Bucket = s3Bucket ; this . s3KeyFormat = s3KeyFormat ; this . finished = finished ; }
mjball/Singularity | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( directory == null ) ? 0 : directory . hashCode ( ) ) ; result = prime * result + ( ( fileGlob == null ) ? 0 : fileGlob . hashCode ( ) ) ; return result ; }
mjball/Singularity | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } S3UploadMetadata other = ( S3UploadMetadata ) obj ; if ( directory == null ) { if ( other . directory != null ) { return false ; } } else if ( ! directory . equals ( other . directory ) ) { return false ; } if ( fileGlob == null ) { if ( other . fileGlob != null ) { return false ; } } else if ( ! fileGlob . equals ( other . fileGlob ) ) { return false ; } return true ; }
mjball/Singularity | public String getDirectory ( ) { return directory ; }
mjball/Singularity | public String getFileGlob ( ) { return fileGlob ; }
mjball/Singularity | public String getS3Bucket ( ) { return s3Bucket ; }
mjball/Singularity | public String getS3KeyFormat ( ) { return s3KeyFormat ; }
mjball/Singularity | public boolean isFinished ( ) { return finished ; }
mjball/Singularity | @ Override public String toString ( ) { return " S3UploadMetadata ▁ [ directory = " + directory + " , ▁ fileGlob = " + fileGlob + " , ▁ s3Bucket = " + s3Bucket + " , ▁ s3KeyFormat = " + s3KeyFormat + " , ▁ finished = " + finished + " ] " ; }
kevgraham7/toolbox | public Warrior ( ) { dexterity = generateAttributeValue ( 60 , 70 ) ; }
kevgraham7/toolbox | @ Override public Map < String , Long > getAttributes ( ) { Map < String , Long > attributesMap = new HashMap < String , Long > ( ) ; attributesMap . put ( ATTRIBUTE_LABEL_DEXTERITY , dexterity ) ; return attributesMap ; }
readymanong/ZhbitAPP | public String getUserLoginnum ( ) { return userLoginnum ; }
readymanong/ZhbitAPP | public void setUserLoginnum ( String userLoginnum ) { this . userLoginnum = userLoginnum ; }
readymanong/ZhbitAPP | public String getUserRole ( ) { return userRole ; }
readymanong/ZhbitAPP | public void setUserRole ( String userRole ) { this . userRole = userRole ; }
readymanong/ZhbitAPP | public String getUserMessage ( ) { return userMessage ; }
readymanong/ZhbitAPP | public void setUserMessage ( String userMessage ) { this . userMessage = userMessage ; }
readymanong/ZhbitAPP | public String getUserName ( ) { return userName ; }
readymanong/ZhbitAPP | public void setUserName ( String userName ) { this . userName = userName ; }
baldimir/drools | public CommandBasedStatefulKnowledgeSession ( ExecutableRunner runner ) { this . runner = runner ; }
baldimir/drools | @ Deprecated public int getId ( ) { return runner . execute ( new GetIdCommand ( ) ) . intValue ( ) ; }
baldimir/drools | public long getIdentifier ( ) { return runner . execute ( new GetIdCommand ( ) ) ; }
baldimir/drools | public ProcessInstance getProcessInstance ( long id ) { GetProcessInstanceCommand command = new GetProcessInstanceCommand ( ) ; command . setProcessInstanceId ( id ) ; return runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance getProcessInstance ( long id , boolean readOnly ) { GetProcessInstanceCommand command = new GetProcessInstanceCommand ( ) ; command . setProcessInstanceId ( id ) ; command . setReadOnly ( readOnly ) ; return runner . execute ( command ) ; }
baldimir/drools | public void abortProcessInstance ( long id ) { AbortProcessInstanceCommand command = new AbortProcessInstanceCommand ( ) ; command . setProcessInstanceId ( id ) ; runner . execute ( command ) ; }
baldimir/drools | public ExecutableRunner getRunner ( ) { return runner ; }
baldimir/drools | public Collection < ProcessInstance > getProcessInstances ( ) { return runner . execute ( new GetProcessInstancesCommand ( ) ) ; }
baldimir/drools | public WorkItemManager getWorkItemManager ( ) { if ( workItemManager == null ) { workItemManager = new WorkItemManager ( ) { public void completeWorkItem ( long id , Map < String , Object > results ) { CompleteWorkItemCommand command = new CompleteWorkItemCommand ( ) ; command . setWorkItemId ( id ) ; command . setResults ( results ) ; runner . execute ( command ) ; } public void abortWorkItem ( long id ) { AbortWorkItemCommand command = new AbortWorkItemCommand ( ) ; command . setWorkItemId ( id ) ; runner . execute ( command ) ; } public void registerWorkItemHandler ( String workItemName , WorkItemHandler handler ) { RegisterWorkItemHandlerCommand command = new RegisterWorkItemHandlerCommand ( ) ; command . setWorkItemName ( workItemName ) ; command . setHandler ( handler ) ; runner . execute ( command ) ; } public WorkItem getWorkItem ( long id ) { GetWorkItemCommand command = new GetWorkItemCommand ( ) ; command . setWorkItemId ( id ) ; return runner . execute ( command ) ; } public void clear ( ) { throw new UnsupportedOperationException ( ) ; } public Set < WorkItem > getWorkItems ( ) { throw new UnsupportedOperationException ( ) ; } public void internalAbortWorkItem ( long id ) { throw new UnsupportedOperationException ( ) ; } public void internalAddWorkItem ( WorkItem workItem ) { throw new UnsupportedOperationException ( ) ; } public void internalExecuteWorkItem ( WorkItem workItem ) { throw new UnsupportedOperationException ( ) ; } @ Override public void signalEvent ( String type , Object event ) { SignalEventCommand command = new SignalEventCommand ( type , event ) ; runner . execute ( command ) ; } @ Override public void signalEvent ( String type , Object event , long processInstanceId ) { SignalEventCommand command = new SignalEventCommand ( processInstanceId , type , event ) ; runner . execute ( command ) ; } @ Override public void dispose ( ) { } @ Override public void retryWorkItem ( Long workItemID , Map < String , Object > params ) { ReTryWorkItemCommand command = new ReTryWorkItemCommand ( workItemID , params ) ; runner . execute ( command ) ; } } ; } return workItemManager ; }
baldimir/drools | public void signalEvent ( String type , Object event ) { SignalEventCommand command = new SignalEventCommand ( type , event ) ; runner . execute ( command ) ; }
baldimir/drools | public void signalEvent ( String type , Object event , long processInstanceId ) { SignalEventCommand command = new SignalEventCommand ( processInstanceId , type , event ) ; runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance startProcess ( String processId ) { return startProcess ( processId , null ) ; }
baldimir/drools | public ProcessInstance startProcess ( String processId , Map < String , Object > parameters ) { StartProcessCommand command = new StartProcessCommand ( ) ; command . setProcessId ( processId ) ; command . setParameters ( parameters ) ; return runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance createProcessInstance ( String processId , Map < String , Object > parameters ) { CreateProcessInstanceCommand command = new CreateProcessInstanceCommand ( ) ; command . setProcessId ( processId ) ; command . setParameters ( parameters ) ; return runner . execute ( command ) ; }
baldimir/drools | public ProcessInstance startProcessInstance ( long processInstanceId ) { StartProcessInstanceCommand command = new StartProcessInstanceCommand ( ) ; command . setProcessInstanceId ( processInstanceId ) ; return runner . execute ( command ) ; }
baldimir/drools | public void dispose ( ) { runner . execute ( new DisposeCommand ( ) ) ; }
baldimir/drools | public void destroy ( ) { runner . execute ( new DestroySessionCommand ( runner ) ) ; }
baldimir/drools | public int fireAllRules ( ) { return this . runner . execute ( new FireAllRulesCommand ( ) ) ; }
baldimir/drools | public int fireAllRules ( int max ) { return this . runner . execute ( new FireAllRulesCommand ( max ) ) ; }
baldimir/drools | public int fireAllRules ( AgendaFilter agendaFilter ) { return this . runner . execute ( new FireAllRulesCommand ( agendaFilter ) ) ; }
baldimir/drools | public int fireAllRules ( AgendaFilter agendaFilter , int max ) { return this . runner . execute ( new FireAllRulesCommand ( agendaFilter , max ) ) ; }
baldimir/drools | public void fireUntilHalt ( ) { this . runner . execute ( new FireUntilHaltCommand ( ) ) ; }
baldimir/drools | public void fireUntilHalt ( AgendaFilter agendaFilter ) { this . runner . execute ( new FireUntilHaltCommand ( agendaFilter ) ) ; }
baldimir/drools | public KieBase getKieBase ( ) { return this . runner . execute ( new GetKieBaseCommand ( ) ) ; }
baldimir/drools | public void registerChannel ( String name , Channel channel ) { this . runner . execute ( new RegisterChannelCommand ( name , channel ) ) ; }
baldimir/drools | public void unregisterChannel ( String name ) { this . runner . execute ( new UnregisterChannelCommand ( name ) ) ; }
baldimir/drools | public Map < String , Channel > getChannels ( ) { return ( Map < String , Channel > ) this . runner . execute ( new GetChannelsCommand ( ) ) ; }
baldimir/drools | public Agenda getAgenda ( ) { if ( agenda == null ) { agenda = new Agenda ( ) { public void clear ( ) { ClearAgendaCommand command = new ClearAgendaCommand ( ) ; runner . execute ( command ) ; } public ActivationGroup getActivationGroup ( final String name ) { return new ActivationGroup ( ) { public void clear ( ) { ClearActivationGroupCommand command = new ClearActivationGroupCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } public String getName ( ) { return name ; } } ; } public AgendaGroup getAgendaGroup ( final String name ) { return new AgendaGroup ( ) { public void clear ( ) { ClearAgendaGroupCommand command = new ClearAgendaGroupCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } public String getName ( ) { return name ; } public void setFocus ( ) { AgendaGroupSetFocusCommand command = new AgendaGroupSetFocusCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } } ; } public RuleFlowGroup getRuleFlowGroup ( final String name ) { return new RuleFlowGroup ( ) { public void clear ( ) { ClearRuleFlowGroupCommand command = new ClearRuleFlowGroupCommand ( ) ; command . setName ( name ) ; runner . execute ( command ) ; } public String getName ( ) { return name ; } } ; } } ; } return agenda ; }
baldimir/drools | public FactHandle getFactHandle ( Object object ) { return this . runner . execute ( new GetFactHandleCommand ( object ) ) ; }
baldimir/drools | public < T extends FactHandle > Collection < T > getFactHandles ( ) { return ( Collection < T > ) this . runner . execute ( new GetFactHandlesCommand ( ) ) ; }
baldimir/drools | public < T extends FactHandle > Collection < T > getFactHandles ( ObjectFilter filter ) { return ( Collection < T > ) this . runner . execute ( new GetFactHandlesCommand ( filter ) ) ; }
baldimir/drools | public Collection < ? extends Object > getObjects ( ) { return getObjects ( null ) ; }
baldimir/drools | public Collection < ? extends Object > getObjects ( ObjectFilter filter ) { Collection result = runner . execute ( new GetObjectsCommand ( filter ) ) ; return result ; }
baldimir/drools | public < T extends SessionClock > T getSessionClock ( ) { return ( T ) this . runner . execute ( new GetSessionClockCommand ( ) ) ; }
baldimir/drools | public EntryPoint getEntryPoint ( String name ) { return this . runner . execute ( new GetEntryPointCommand ( name ) ) ; }
baldimir/drools | public Collection < ? extends EntryPoint > getEntryPoints ( ) { return this . runner . execute ( new GetEntryPointsCommand ( ) ) ; }
baldimir/drools | public void halt ( ) { this . runner . execute ( new HaltCommand ( ) ) ; }
baldimir/drools | public FactHandle insert ( Object object ) { return runner . execute ( new InsertObjectCommand ( object ) ) ; }
baldimir/drools | public void submit ( AtomicAction action ) { throw new UnsupportedOperationException ( " It ▁ is ▁ not ▁ necessary ▁ to ▁ use ▁ submit ▁ with ▁ a ▁ command ▁ based ▁ session , ▁ commands ▁ are ▁ already ▁ atomic " ) ; }
baldimir/drools | @ Override public < T > T getKieRuntime ( Class < T > cls ) { throw new UnsupportedOperationException ( " Retrieving ▁ runtimes ▁ is ▁ not ▁ supported ▁ ▁ throught ▁ the ▁ command ▁ based ▁ session ▁ at ▁ this ▁ time . " ) ; }
baldimir/drools | public void retract ( FactHandle handle ) { runner . execute ( new DeleteCommand ( handle ) ) ; }
baldimir/drools | public void delete ( FactHandle handle ) { runner . execute ( new DeleteCommand ( handle ) ) ; }
baldimir/drools | public void delete ( FactHandle handle , FactHandle . State fhState ) { runner . execute ( new DeleteCommand ( handle , fhState ) ) ; }
baldimir/drools | public void update ( FactHandle handle , Object object ) { runner . execute ( new UpdateCommand ( handle , object ) ) ; }
baldimir/drools | public void update ( FactHandle handle , Object object , String ... modifiedProperties ) { runner . execute ( new UpdateCommand ( handle , object , modifiedProperties ) ) ; }
baldimir/drools | public void addEventListener ( RuleRuntimeEventListener listener ) { runner . execute ( new AddEventListenerCommand ( listener ) ) ; }
baldimir/drools | public void addEventListener ( AgendaEventListener listener ) { runner . execute ( new AddEventListenerCommand ( listener ) ) ; }
baldimir/drools | public Collection < AgendaEventListener > getAgendaEventListeners ( ) { return runner . execute ( new GetAgendaEventListenersCommand ( ) ) ; }
baldimir/drools | public Collection < RuleRuntimeEventListener > getRuleRuntimeEventListeners ( ) { return runner . execute ( new GetRuleRuntimeEventListenersCommand ( ) ) ; }
baldimir/drools | public void removeEventListener ( RuleRuntimeEventListener listener ) { runner . execute ( new RemoveEventListenerCommand ( listener ) ) ; }
baldimir/drools | public void removeEventListener ( AgendaEventListener listener ) { runner . execute ( new RemoveEventListenerCommand ( listener ) ) ; }
baldimir/drools | public void addEventListener ( ProcessEventListener listener ) { runner . execute ( new AddEventListenerCommand ( listener ) ) ; }
baldimir/drools | public Collection < ProcessEventListener > getProcessEventListeners ( ) { return runner . execute ( new GetProcessEventListenersCommand ( ) ) ; }
baldimir/drools | public void removeEventListener ( ProcessEventListener listener ) { runner . execute ( new RemoveEventListenerCommand ( listener ) ) ; }
baldimir/drools | public Object getGlobal ( String identifier ) { return runner . execute ( new GetGlobalCommand ( identifier ) ) ; }
baldimir/drools | public void setGlobal ( String identifier , Object object ) { this . runner . execute ( new SetGlobalCommand ( identifier , object ) ) ; }
baldimir/drools | public Globals getGlobals ( ) { return runner . execute ( new GetGlobalsCommand ( ) ) ; }
baldimir/drools | public Calendars getCalendars ( ) { return runner . execute ( new GetCalendarsCommand ( ) ) ; }
baldimir/drools | public Object getObject ( FactHandle factHandle ) { return runner . execute ( new GetObjectCommand ( factHandle ) ) ; }
baldimir/drools | public Environment getEnvironment ( ) { return runner . execute ( new GetEnvironmentCommand ( ) ) ; }
baldimir/drools | public < T > T execute ( Command < T > command ) { return ( T ) this . runner . execute ( command ) ; }
baldimir/drools | public QueryResults getQueryResults ( String query , Object ... arguments ) { QueryCommand cmd = new QueryCommand ( ( String ) null , query , arguments ) ; return this . runner . execute ( cmd ) ; }
baldimir/drools | public String getEntryPointId ( ) { return EntryPointId . DEFAULT . getEntryPointId ( ) ; }
baldimir/drools | public long getFactCount ( ) { return runner . execute ( new GetFactCountCommand ( ) ) ; }
baldimir/drools | public LiveQuery openLiveQuery ( String query , Object [ ] arguments , ViewChangedEventListener listener ) { return null ; }
baldimir/drools | public KieSessionConfiguration getSessionConfiguration ( ) { return ( ( RegistryContext ) runner . createContext ( ) ) . lookup ( KieSession . class ) . getSessionConfiguration ( ) ; }
baldimir/drools | @ Override public ProcessInstance startProcess ( String processId , CorrelationKey correlationKey , Map < String , Object > parameters ) { return this . runner . execute ( new StartCorrelatedProcessCommand ( processId , correlationKey , parameters ) ) ; }
baldimir/drools | @ Override public ProcessInstance createProcessInstance ( String processId , CorrelationKey correlationKey , Map < String , Object > parameters ) { return this . runner . execute ( new CreateCorrelatedProcessInstanceCommand ( processId , correlationKey , parameters ) ) ; }
baldimir/drools | @ Override public ProcessInstance getProcessInstance ( CorrelationKey correlationKey ) { return this . runner . execute ( new GetProcessInstanceByCorrelationKeyCommand ( correlationKey ) ) ; }
baldimir/drools | @ Override public ProcessInstance startProcessFromNodeIds ( String processId , CorrelationKey key , Map < String , Object > params , String ... nodeIds ) { StartProcessFromNodeIdsCommand command = new StartProcessFromNodeIdsCommand ( ) ; command . setProcessId ( processId ) ; command . setParameters ( params ) ; command . setNodeIds ( stream ( nodeIds ) . collect ( Collectors . toList ( ) ) ) ; command . setCorrelationKey ( key ) ; return runner . execute ( command ) ; }
baldimir/drools | @ Override public ProcessInstance startProcessFromNodeIds ( String processId , Map < String , Object > params , String ... nodeIds ) { return startProcessFromNodeIds ( processId , null , params , nodeIds ) ; }
emmanuelbernard/hibernate-validator | public ConstraintHelper ( ) { List < Class < ? extends ConstraintValidator < ? , ? > > > constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( AssertFalseValidator . class ) ; builtinConstraints . put ( AssertFalse . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( AssertTrueValidator . class ) ; builtinConstraints . put ( AssertTrue . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DecimalMaxValidatorForNumber . class ) ; constraintList . add ( DecimalMaxValidatorForString . class ) ; builtinConstraints . put ( DecimalMax . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DecimalMinValidatorForNumber . class ) ; constraintList . add ( DecimalMinValidatorForString . class ) ; builtinConstraints . put ( DecimalMin . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DigitsValidatorForString . class ) ; constraintList . add ( DigitsValidatorForNumber . class ) ; builtinConstraints . put ( Digits . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( FutureValidatorForCalendar . class ) ; constraintList . add ( FutureValidatorForDate . class ) ; if ( isJodaTimeInClasspath ( ) ) { constraintList . add ( FutureValidatorForAbstractInstant . class ) ; constraintList . add ( FutureValidatorForAbstractPartial . class ) ; } builtinConstraints . put ( Future . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( MaxValidatorForNumber . class ) ; constraintList . add ( MaxValidatorForString . class ) ; builtinConstraints . put ( Max . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( MinValidatorForNumber . class ) ; constraintList . add ( MinValidatorForString . class ) ; builtinConstraints . put ( Min . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( NotNullValidator . class ) ; builtinConstraints . put ( NotNull . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( NullValidator . class ) ; builtinConstraints . put ( Null . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( PastValidatorForCalendar . class ) ; constraintList . add ( PastValidatorForDate . class ) ; if ( isJodaTimeInClasspath ( ) ) { constraintList . add ( PastValidatorForAbstractInstant . class ) ; constraintList . add ( PastValidatorForAbstractPartial . class ) ; } builtinConstraints . put ( Past . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( PatternValidator . class ) ; builtinConstraints . put ( Pattern . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( SizeValidatorForString . class ) ; constraintList . add ( SizeValidatorForCollection . class ) ; constraintList . add ( SizeValidatorForArray . class ) ; constraintList . add ( SizeValidatorForMap . class ) ; constraintList . add ( SizeValidatorForArraysOfBoolean . class ) ; constraintList . add ( SizeValidatorForArraysOfByte . class ) ; constraintList . add ( SizeValidatorForArraysOfChar . class ) ; constraintList . add ( SizeValidatorForArraysOfDouble . class ) ; constraintList . add ( SizeValidatorForArraysOfFloat . class ) ; constraintList . add ( SizeValidatorForArraysOfInt . class ) ; constraintList . add ( SizeValidatorForArraysOfLong . class ) ; builtinConstraints . put ( Size . class , constraintList ) ; }
emmanuelbernard/hibernate-validator | public List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > getBuiltInConstraints ( Class < ? extends Annotation > annotationClass ) { final List < Class < ? extends ConstraintValidator < ? , ? > > > builtInList = builtinConstraints . get ( annotationClass ) ; if ( builtInList == null || builtInList . size ( ) == 0 ) { throw new ValidationException ( " Unable ▁ to ▁ find ▁ constraints ▁ for ▁ ▁ " + annotationClass ) ; } List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > constraints = new ArrayList < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > ( builtInList . size ( ) ) ; for ( Class < ? extends ConstraintValidator < ? , ? > > validatorClass : builtInList ) { @ SuppressWarnings ( " unchecked " ) Class < ConstraintValidator < ? extends Annotation , ? > > safeValidatorClass = ( Class < ConstraintValidator < ? extends Annotation , ? > > ) validatorClass ; constraints . add ( safeValidatorClass ) ; } return constraints ; }
emmanuelbernard/hibernate-validator | public boolean isBuiltinConstraint ( Class < ? extends Annotation > annotationType ) { return builtinConstraints . containsKey ( annotationType ) ; }
emmanuelbernard/hibernate-validator | public boolean isMultiValueConstraint ( Class < ? extends Annotation > annotationType ) { boolean isMultiValueConstraint = false ; final Method method = ReflectionHelper . getMethod ( annotationType , " value " ) ; if ( method != null ) { Class returnType = method . getReturnType ( ) ; if ( returnType . isArray ( ) && returnType . getComponentType ( ) . isAnnotation ( ) ) { @ SuppressWarnings ( " unchecked " ) Class < ? extends Annotation > componentType = ( Class < ? extends Annotation > ) returnType . getComponentType ( ) ; if ( isConstraintAnnotation ( componentType ) || isBuiltinConstraint ( componentType ) ) { isMultiValueConstraint = true ; } else { isMultiValueConstraint = false ; } } } return isMultiValueConstraint ; }
emmanuelbernard/hibernate-validator | public < A extends Annotation > List < Annotation > getMultiValueConstraints ( A annotation ) { List < Annotation > annotationList = new ArrayList < Annotation > ( ) ; try { final Method method = ReflectionHelper . getMethod ( annotation . getClass ( ) , " value " ) ; if ( method != null ) { Class returnType = method . getReturnType ( ) ; if ( returnType . isArray ( ) && returnType . getComponentType ( ) . isAnnotation ( ) ) { Annotation [ ] annotations = ( Annotation [ ] ) method . invoke ( annotation ) ; for ( Annotation a : annotations ) { Class < ? extends Annotation > annotationType = a . annotationType ( ) ; if ( isConstraintAnnotation ( annotationType ) || isBuiltinConstraint ( annotationType ) ) { annotationList . add ( a ) ; } } } } } catch ( IllegalAccessException iae ) { } catch ( InvocationTargetException ite ) { } return annotationList ; }
emmanuelbernard/hibernate-validator | public boolean isConstraintAnnotation ( Class < ? extends Annotation > annotationType ) { Constraint constraint = annotationType . getAnnotation ( Constraint . class ) ; if ( constraint == null ) { return false ; } assertMessageParameterExists ( annotationType ) ; assertGroupsParameterExists ( annotationType ) ; assertPayloadParameterExists ( annotationType ) ; assertNoParameterStartsWithValid ( annotationType ) ; return true ; }
emmanuelbernard/hibernate-validator | private void assertNoParameterStartsWithValid ( Class < ? extends Annotation > annotationType ) { final Method [ ] methods = ReflectionHelper . getMethods ( annotationType ) ; for ( Method m : methods ) { if ( m . getName ( ) . startsWith ( " valid " ) ) { String msg = " Parameters ▁ starting ▁ with ▁ ' valid ' ▁ are ▁ not ▁ allowed ▁ in ▁ a ▁ constraint . " ; throw new ConstraintDefinitionException ( msg ) ; } } }
emmanuelbernard/hibernate-validator | private void assertPayloadParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " payload " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ payload ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } Class < ? > [ ] defaultPayload = ( Class < ? > [ ] ) method . getDefaultValue ( ) ; if ( defaultPayload . length != 0 ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ payload ▁ " + " parameter ▁ default ▁ value ▁ is ▁ not ▁ the ▁ empty ▁ array . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " payload ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
emmanuelbernard/hibernate-validator | private void assertGroupsParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " groups " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ groups ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } Class < ? > [ ] defaultGroups = ( Class < ? > [ ] ) method . getDefaultValue ( ) ; if ( defaultGroups . length != 0 ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ groups ▁ " + " parameter ▁ default ▁ value ▁ is ▁ not ▁ the ▁ empty ▁ array . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " groups ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
emmanuelbernard/hibernate-validator | private void assertMessageParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " message " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ message ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } if ( method . getReturnType ( ) != String . class ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ message ▁ parameter ▁ " + " is ▁ not ▁ of ▁ type ▁ java . lang . String . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " groups ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
emmanuelbernard/hibernate-validator | public < T extends Annotation > List < Class < ? extends ConstraintValidator < T , ? > > > getConstraintValidatorDefinition ( Class < T > annotationClass ) { if ( annotationClass == null ) { throw new IllegalArgumentException ( " Class ▁ cannot ▁ be ▁ null " ) ; } final List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > list = constraintValidatorDefinitions . get ( annotationClass ) ; List < Class < ? extends ConstraintValidator < T , ? > > > constraintsValidators = new ArrayList < Class < ? extends ConstraintValidator < T , ? > > > ( list . size ( ) ) ; for ( Class < ? extends ConstraintValidator < ? , ? > > validatorClass : list ) { @ SuppressWarnings ( " unchecked " ) Class < ConstraintValidator < T , ? > > safeValidatorClass = ( Class < ConstraintValidator < T , ? > > ) validatorClass ; constraintsValidators . add ( safeValidatorClass ) ; } return constraintsValidators ; }
emmanuelbernard/hibernate-validator | public < A extends Annotation > void addConstraintValidatorDefinition ( Class < A > annotationClass , List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > definitionClasses ) { constraintValidatorDefinitions . putIfAbsent ( annotationClass , definitionClasses ) ; }
emmanuelbernard/hibernate-validator | public boolean containsConstraintValidatorDefinition ( Class < ? extends Annotation > annotationClass ) { return constraintValidatorDefinitions . containsKey ( annotationClass ) ; }
emmanuelbernard/hibernate-validator | public boolean isConstraintComposition ( Class < ? extends Annotation > annotationType ) { return annotationType == ConstraintComposition . class ; }
emmanuelbernard/hibernate-validator | private boolean isJodaTimeInClasspath ( ) { boolean isInClasspath ; try { ReflectionHelper . loadClass ( JODA_TIME_class_NAME , this . getClass ( ) ) ; isInClasspath = true ; } catch ( ValidationException e ) { isInClasspath = false ; } return isInClasspath ; }
AJ-72/testng | @ Test ( dataProvider = " dp _ name " ) public void should_find_exactly_one_data_provider ( boolean b ) { }
AJ-72/testng | @ DataProvider ( name = " dp _ name " ) Object [ ] [ ] whatever_implicit_name ( ) { return new Object [ ] [ ] { { true } } ; }
AJ-72/testng | @ DataProvider ( name = " whatever _ explicit _ name " ) Object [ ] [ ] dp_name ( ) { return new Object [ ] [ ] { { false } } ; }
nodchip/QMAClone | private final Runnable saveServerStatusRunner = new Runnable ( ) { public void run ( ) { saveServerStatus ( ) ; } }
nodchip/QMAClone | private final Runnable updateLoginUsersRunner = new Runnable ( ) { public void run ( ) { updateLoginUsers ( ) ; } }
nodchip/QMAClone | private final Runnable updateServerStatusRunner = new Runnable ( ) { @ Override public void run ( ) { try { updateServerStatus ( ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " サーバーステータスの更新に失敗しました " , e ) ; } } }
nodchip/QMAClone | @ Inject public ServerStatusManager ( Database database , GameManager gameManager , NormalModeProblemManager normalModeProblemManager , PlayerHistoryManager playerHistoryManager , MessageSender < PacketServerStatus > serverStatusMessageSender , ThreadPool threadPool ) { this . database = Preconditions . checkNotNull ( database ) ; this . gameManager = Preconditions . checkNotNull ( gameManager ) ; this . normalModeProblemManager = Preconditions . checkNotNull ( normalModeProblemManager ) ; this . playerHistoryManager = Preconditions . checkNotNull ( playerHistoryManager ) ; this . serverStatusMessageSender = Preconditions . checkNotNull ( serverStatusMessageSender ) ; threadPool . addMinuteTasks ( saveServerStatusRunner ) ; threadPool . addMinuteTasks ( updateLoginUsersRunner ) ; threadPool . scheduleAtFixedRate ( updateServerStatusRunner , UPDATE_DURATION , UPDATE_DURATION , TimeUnit . SECONDS ) ; try { updateServerStatus ( ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " サーバーステータスの更新に失敗しました " , e ) ; } loadPageView ( ) ; }
nodchip/QMAClone | private void loadPageView ( ) { PageView pageView ; try { pageView = database . loadPageView ( ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " ページビューの読み込みに失敗しました " , e ) ; return ; } numberOfPageView . addAndGet ( pageView . numberOfPageView ) ; numberOfTotalSessions . addAndGet ( pageView . numberOfSessions ) ; numberOfTotalPlayers . addAndGet ( pageView . numberOfPlayers ) ; }
nodchip/QMAClone | public void login ( ) { numberOfPageView . getAndIncrement ( ) ; }
nodchip/QMAClone | @ VisibleForTesting void updateServerStatus ( ) throws DatabaseException { PacketServerStatus status = new PacketServerStatus ( ) ; status . numberOfCurrentSessions = numberOfCurrentSessions . get ( ) ; status . numberOfTotalSessions = numberOfTotalSessions . get ( ) ; status . numberOfCurrentPlayers = numberOfCurrentPlayers . get ( ) ; status . numberOfTotalPlayers = numberOfTotalPlayers . get ( ) ; status . numberOfProblems = normalModeProblemManager . getNumberOfProblem ( ) ; status . numberOfPageView = numberOfPageView . get ( ) ; status . numberOfLoginPlayers = Math . max ( loginUsers . size ( ) , loginUserCodes . size ( ) ) ; status . numberOfActivePlayers = database . getNumberOfActiveUsers ( ) ; status . numberOfPlayersInWhole = gameManager . getNumberOfPlayersInWhole ( ) ; status . lastestPlayers = playerHistoryManager . get ( ) ; if ( Objects . equal ( serverStatus , status ) ) { return ; } serverStatus = status ; serverStatusMessageSender . send ( status ) ; }
nodchip/QMAClone | public PacketServerStatus getServerStatus ( ) { return serverStatus ; }
nodchip/QMAClone | public void saveServerStatus ( ) { PageView pageView = new PageView ( ) ; pageView . numberOfPageView = numberOfPageView . get ( ) ; pageView . numberOfPlayers = numberOfTotalPlayers . get ( ) ; pageView . numberOfSessions = numberOfTotalSessions . get ( ) ; if ( pageView . numberOfPageView < 10000 || pageView . numberOfPlayers < 10000 || pageView . numberOfSessions < 10000 ) { logger . info ( " ページビューが読み込まれていない可能性があります 。 再読み込みを行います 。 " ) ; loadPageView ( ) ; return ; } try { database . savePageView ( pageView ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " ページビューの保存に失敗しました " , e ) ; } }
nodchip/QMAClone | public void keepAlive ( int userCode ) { loginUserCodes . add ( userCode ) ; }
nodchip/QMAClone | public List < PacketUserData > getLoginUsers ( ) { return loginUsers ; }
nodchip/QMAClone | private void updateLoginUsers ( ) { Set < Integer > userCodes = loginUserCodes ; loginUserCodes = Collections . synchronizedSet ( new HashSet < Integer > ( ) ) ; List < PacketUserData > list = Lists . newArrayList ( ) ; for ( int userCode : userCodes ) { try { list . add ( database . getUserData ( userCode ) ) ; } catch ( DatabaseException e ) { logger . log ( Level . WARNING , " ユーザー情報の読み込みに失敗しました " , e ) ; } } loginUsers = list ; }
nodchip/QMAClone | public void changeStatics ( int sessionDelta , int playDelta ) { numberOfCurrentSessions . set ( gameManager . getNumberOfSessions ( ) ) ; numberOfCurrentPlayers . set ( gameManager . getNumberOfPlayers ( ) ) ; numberOfTotalSessions . addAndGet ( sessionDelta ) ; numberOfTotalPlayers . addAndGet ( playDelta ) ; }
nodchip/QMAClone | public MessageSender < PacketServerStatus > getServerStatusMessageSender ( ) { return serverStatusMessageSender ; }
caidongyun/hipster | public AbstractNode ( N previousNode , S state , A action ) { this . previousNode = previousNode ; this . state = state ; this . action = action ; }
caidongyun/hipster | @ Override public List < N > path ( ) { LinkedList < N > path = new LinkedList < N > ( ) ; N currentNode = ( N ) this ; while ( currentNode != null ) { path . addFirst ( currentNode ) ; currentNode = currentNode . previousNode ; } return path ; }
caidongyun/hipster | @ Override public N previousNode ( ) { return this . previousNode ; }
caidongyun/hipster | @ Override public S state ( ) { return state ; }
caidongyun/hipster | @ Override public A action ( ) { return action ; }
caidongyun/hipster | @ Override public String toString ( ) { return " Node { " + " action = " + action + " , ▁ state = " + this . state ( ) + ' } ' ; }
StCostea/k3po | public AstLongLengthBytesMatcher ( String captureName , ExpressionContext environment ) { super ( Long . SIZE / Byte . SIZE , captureName , environment ) ; }
StCostea/k3po | @ Override protected void describe ( StringBuilder buf ) { String captureName = getCaptureName ( ) ; if ( captureName == null ) { buf . append ( " long " ) ; } else { buf . append ( format ( " ( long : % s ) " , captureName ) ) ; } }
StCostea/k3po | @ Override public < R , P > R accept ( Visitor < R , P > visitor , P parameter ) { return visitor . visit ( this , parameter ) ; }
njacinto/Utils | public CollectionFilterIterator ( Iterator < T > it , Predicate < T > predicate ) { this . it = it != null ? it : Collections . emptyIterator ( ) ; this . predicate = predicate != null ? predicate : TruePredicate . getInstance ( ) ; this . next = getNext ( ) ; }
njacinto/Utils | public CollectionFilterIterator ( Iterable < T > collection , Predicate < T > predicate ) { this ( collection != null ? collection . iterator ( ) : null , predicate ) ; }
njacinto/Utils | @ Override public boolean hasNext ( ) { return next != END ; }
njacinto/Utils | @ Override public T next ( ) { if ( next == END ) { throw new NoSuchElementException ( " The ▁ underline ▁ collection ▁ has ▁ no ▁ elements . " ) ; } T ret = next ; next = getNext ( ) ; return ret ; }
njacinto/Utils | @ Override public void remove ( ) { throw new UnsupportedOperationException ( " The ▁ iterator ▁ doesn ' t ▁ allow ▁ changes . " ) ; }
njacinto/Utils | protected T getNext ( ) { T tmp ; while ( it . hasNext ( ) ) { if ( predicate . test ( tmp = it . next ( ) ) ) { return tmp ; } } return ( T ) END ; }
zhizhounq/azkaban-customization | @ Override public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; AzkabanWebServer server = ( AzkabanWebServer ) getApplication ( ) ; projectManager = server . getProjectManager ( ) ; scheduleManager = server . getScheduleManager ( ) ; }
zhizhounq/azkaban-customization | if ( hasParam ( req , " ajax " ) ) { handleAJAXAction ( req , resp , session ) ; }
zhizhounq/azkaban-customization | else if ( hasParam ( req , " calendar " ) ) { handleGetScheduleCalendar ( req , resp , session ) ; }
zhizhounq/azkaban-customization | if ( ajaxName . equals ( " slaInfo " ) ) { ajaxSlaInfo ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " setSla " ) ) { ajaxSetSla ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " loadFlow " ) ) { ajaxLoadFlows ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " loadHistory " ) ) { ajaxLoadHistory ( req , resp , session . getUser ( ) ) ; ret = null ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " scheduleFlow " ) ) { ajaxScheduleFlow ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | else if ( ajaxName . equals ( " fetchSchedule " ) ) { ajaxFetchSchedule ( req , ret , session . getUser ( ) ) ; }
zhizhounq/azkaban-customization | if ( ret != null ) { this . writeJSON ( resp , ret ) ; }
zhizhounq/azkaban-customization | private void ajaxSetSla ( HttpServletRequest req , HashMap < String , Object > ret , User user ) { try { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched = scheduleManager . getSchedule ( scheduleId ) ; Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( ! hasPermission ( project , user , Permission . Type . SCHEDULE ) ) { ret . put ( " error " , " User ▁ " + user + " ▁ does ▁ not ▁ have ▁ permission ▁ to ▁ set ▁ SLA ▁ for ▁ this ▁ flow . " ) ; return ; } String emailStr = getParam ( req , " slaEmails " ) ; String [ ] emailSplit = emailStr . split ( " \\ s * , \\ s * | \\ s * ; \\ s * | \\ s + " ) ; List < String > slaEmails = Arrays . asList ( emailSplit ) ; Map < String , String > settings = getParamGroup ( req , " settings " ) ; List < SlaOption > slaOptions = new ArrayList < SlaOption > ( ) ; for ( String set : settings . keySet ( ) ) { SlaOption sla ; try { sla = parseSlaSetting ( settings . get ( set ) ) ; } catch ( Exception e ) { throw new ServletException ( e ) ; } if ( sla != null ) { sla . getInfo ( ) . put ( SlaOption . INFO_FLOW_NAME , sched . getFlowName ( ) ) ; sla . getInfo ( ) . put ( SlaOption . INFO_EMAIL_LIST , slaEmails ) ; slaOptions . add ( sla ) ; } } sched . setSlaOptions ( slaOptions ) ; scheduleManager . insertSchedule ( sched ) ; if ( slaOptions != null ) { projectManager . postProjectEvent ( project , EventType . SLA , user . getUserId ( ) , " SLA ▁ for ▁ flow ▁ " + sched . getFlowName ( ) + " ▁ has ▁ been ▁ added / changed . " ) ; } } catch ( ServletException e ) { ret . put ( " error " , e . getMessage ( ) ) ; } catch ( ScheduleManagerException e ) { ret . put ( " error " , e . getMessage ( ) ) ; } }
zhizhounq/azkaban-customization | private SlaOption parseSlaSetting ( String set ) throws ScheduleManagerException { logger . info ( " Tryint ▁ to ▁ set ▁ sla ▁ with ▁ the ▁ following ▁ set : ▁ " + set ) ; String slaType ; List < String > slaActions = new ArrayList < String > ( ) ; Map < String , Object > slaInfo = new HashMap < String , Object > ( ) ; String [ ] parts = set . split ( " , " , - 1 ) ; String id = parts [ 0 ] ; String rule = parts [ 1 ] ; String duration = parts [ 2 ] ; String emailAction = parts [ 3 ] ; String killAction = parts [ 4 ] ; if ( emailAction . equals ( " true " ) || killAction . equals ( " true " ) ) { if ( emailAction . equals ( " true " ) ) { slaActions . add ( SlaOption . ACTION_ALERT ) ; slaInfo . put ( SlaOption . ALERT_TYPE , " email " ) ; } if ( killAction . equals ( " true " ) ) { slaActions . add ( SlaOption . ACTION_CANCEL_FLOW ) ; } if ( id . equals ( " " ) ) { if ( rule . equals ( " SUCCESS " ) ) { slaType = SlaOption . TYPE_FLOW_SUCCEED ; } else { slaType = SlaOption . TYPE_FLOW_FINISH ; } } else { slaInfo . put ( SlaOption . INFO_JOB_NAME , id ) ; if ( rule . equals ( " SUCCESS " ) ) { slaType = SlaOption . TYPE_JOB_SUCCEED ; } else { slaType = SlaOption . TYPE_JOB_FINISH ; } } ReadablePeriod dur ; try { dur = parseDuration ( duration ) ; } catch ( Exception e ) { throw new ScheduleManagerException ( " Unable ▁ to ▁ parse ▁ duration ▁ for ▁ a ▁ SLA ▁ that ▁ needs ▁ to ▁ take ▁ actions ! " , e ) ; } slaInfo . put ( SlaOption . INFO_DURATION , Utils . createPeriodString ( dur ) ) ; SlaOption r = new SlaOption ( slaType , slaActions , slaInfo ) ; logger . info ( " Parsing ▁ sla ▁ as ▁ id : " + id + " ▁ type : " + slaType + " ▁ rule : " + rule + " ▁ Duration : " + duration + " ▁ actions : " + slaActions ) ; return r ; } return null ; }
zhizhounq/azkaban-customization | private ReadablePeriod parseDuration ( String duration ) { int hour = Integer . parseInt ( duration . split ( " : " ) [ 0 ] ) ; int min = Integer . parseInt ( duration . split ( " : " ) [ 1 ] ) ; return Minutes . minutes ( min + hour * 60 ) . toPeriod ( ) ; }
zhizhounq/azkaban-customization | private void ajaxFetchSchedule ( HttpServletRequest req , HashMap < String , Object > ret , User user ) throws ServletException { int projectId = getIntParam ( req , " projectId " ) ; String flowId = getParam ( req , " flowId " ) ; try { Schedule schedule = scheduleManager . getSchedule ( projectId , flowId ) ; if ( schedule != null ) { Map < String , String > jsonObj = new HashMap < String , String > ( ) ; jsonObj . put ( " scheduleId " , Integer . toString ( schedule . getScheduleId ( ) ) ) ; jsonObj . put ( " submitUser " , schedule . getSubmitUser ( ) ) ; jsonObj . put ( " firstSchedTime " , utils . formatDateTime ( schedule . getFirstSchedTime ( ) ) ) ; jsonObj . put ( " nextExecTime " , utils . formatDateTime ( schedule . getNextExecTime ( ) ) ) ; jsonObj . put ( " period " , utils . formatPeriod ( schedule . getPeriod ( ) ) ) ; ret . put ( " schedule " , jsonObj ) ; } } catch ( ScheduleManagerException e ) { ret . put ( " error " , e ) ; } }
zhizhounq/azkaban-customization | private void ajaxSlaInfo ( HttpServletRequest req , HashMap < String , Object > ret , User user ) { int scheduleId ; try { scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched = scheduleManager . getSchedule ( scheduleId ) ; Project project = getProjectAjaxByPermission ( ret , sched . getProjectId ( ) , user , Type . READ ) ; if ( project == null ) { ret . put ( " error " , " Error ▁ loading ▁ project . ▁ Project ▁ " + sched . getProjectId ( ) + " ▁ doesn ' t ▁ exist " ) ; return ; } Flow flow = project . getFlow ( sched . getFlowName ( ) ) ; if ( flow == null ) { ret . put ( " error " , " Error ▁ loading ▁ flow . ▁ Flow ▁ " + sched . getFlowName ( ) + " ▁ doesn ' t ▁ exist ▁ in ▁ " + sched . getProjectId ( ) ) ; return ; } List < SlaOption > slaOptions = sched . getSlaOptions ( ) ; ExecutionOptions flowOptions = sched . getExecutionOptions ( ) ; if ( slaOptions != null && slaOptions . size ( ) > 0 ) { ret . put ( " slaEmails " , slaOptions . get ( 0 ) . getInfo ( ) . get ( SlaOption . INFO_EMAIL_LIST ) ) ; List < Object > setObj = new ArrayList < Object > ( ) ; for ( SlaOption sla : slaOptions ) { setObj . add ( sla . toWebObject ( ) ) ; } ret . put ( " settings " , setObj ) ; } else if ( flowOptions != null ) { if ( flowOptions . getFailureEmails ( ) != null ) { List < String > emails = flowOptions . getFailureEmails ( ) ; if ( emails . size ( ) > 0 ) { ret . put ( " slaEmails " , emails ) ; } } } else { if ( flow . getFailureEmails ( ) != null ) { List < String > emails = flow . getFailureEmails ( ) ; if ( emails . size ( ) > 0 ) { ret . put ( " slaEmails " , emails ) ; } } } List < String > allJobs = new ArrayList < String > ( ) ; for ( Node n : flow . getNodes ( ) ) { allJobs . add ( n . getId ( ) ) ; } ret . put ( " allJobNames " , allJobs ) ; } catch ( ServletException e ) { ret . put ( " error " , e ) ; } catch ( ScheduleManagerException e ) { ret . put ( " error " , e ) ; } }
zhizhounq/azkaban-customization | protected Project getProjectAjaxByPermission ( Map < String , Object > ret , int projectId , User user , Permission . Type type ) { Project project = projectManager . getProject ( projectId ) ; if ( project == null ) { ret . put ( " error " , " Project ▁ ' " + project + " ' ▁ not ▁ found . " ) ; } else if ( ! hasPermission ( project , user , type ) ) { ret . put ( " error " , " User ▁ ' " + user . getUserId ( ) + " ' ▁ doesn ' t ▁ have ▁ " + type . name ( ) + " ▁ permissions ▁ on ▁ " + project . getName ( ) ) ; } else { return project ; } return null ; }
zhizhounq/azkaban-customization | catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; }
zhizhounq/azkaban-customization | catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; }
zhizhounq/azkaban-customization | if ( hasParam ( req , " ajax " ) ) { handleAJAXAction ( req , resp , session ) ; }
zhizhounq/azkaban-customization | if ( hasParam ( req , " action " ) ) { String action = getParam ( req , " action " ) ; if ( action . equals ( " scheduleFlow " ) ) { ajaxScheduleFlow ( req , ret , session . getUser ( ) ) ; } else if ( action . equals ( " removeSched " ) ) { ajaxRemoveSched ( req , ret , session . getUser ( ) ) ; } else if ( action . equals ( " disableSched " ) ) { ajaxDisableSched ( req , ret , session . getUser ( ) ) ; } else if ( action . equals ( " enableSched " ) ) { ajaxEnableSched ( req , ret , session . getUser ( ) ) ; } }
zhizhounq/azkaban-customization | private void ajaxLoadFlows ( HttpServletRequest req , HashMap < String , Object > ret , User user ) throws ServletException { List < Schedule > schedules ; try { schedules = scheduleManager . getSchedules ( ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( schedules . size ( ) <= 0 ) return ; List < HashMap < String , Object > > output = new ArrayList < HashMap < String , Object > > ( ) ; ret . put ( " items " , output ) ; for ( Schedule schedule : schedules ) { try { writeScheduleData ( output , schedule ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } } }
zhizhounq/azkaban-customization | private void writeScheduleData ( List < HashMap < String , Object > > output , Schedule schedule ) throws ScheduleManagerException { Map < String , Object > stats = ScheduleStatisticManager . getStatistics ( schedule . getScheduleId ( ) , ( AzkabanWebServer ) getApplication ( ) ) ; HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " scheduleid " , schedule . getScheduleId ( ) ) ; data . put ( " flowname " , schedule . getFlowName ( ) ) ; data . put ( " projectname " , schedule . getProjectName ( ) ) ; data . put ( " time " , schedule . getFirstSchedTime ( ) ) ; DateTime time = DateTime . now ( ) ; long period = 0 ; if ( schedule . getPeriod ( ) != null ) { period = time . plus ( schedule . getPeriod ( ) ) . getMillis ( ) - time . getMillis ( ) ; } data . put ( " period " , period ) ; int length = 3600 * 1000 ; if ( stats . get ( " average " ) != null && stats . get ( " average " ) instanceof Integer ) { length = ( int ) ( Integer ) stats . get ( " average " ) ; if ( length == 0 ) { length = 3600 * 1000 ; } } data . put ( " length " , length ) ; data . put ( " history " , false ) ; data . put ( " stats " , stats ) ; output . add ( data ) ; }
zhizhounq/azkaban-customization | if ( startTime < today ) { useCache = true ; }
zhizhounq/azkaban-customization | if ( useCache ) { boolean cacheExists = false ; synchronized ( this ) { cacheExists = cache . exists ( ) && cache . isFile ( ) ; } if ( cacheExists ) { InputStream cacheInput = new BufferedInputStream ( new FileInputStream ( cache ) ) ; IOUtils . copy ( cacheInput , resp . getOutputStream ( ) ) ; return ; } }
zhizhounq/azkaban-customization | catch ( ExecutorManagerException e ) { logger . error ( e ) ; }
zhizhounq/azkaban-customization | for ( ExecutableFlow historyItem : history ) { if ( historyItem . getScheduleId ( ) >= 0 || loadAll != 0 ) { writeHistoryData ( output , historyItem ) ; } }
zhizhounq/azkaban-customization | synchronized ( this ) { if ( ! useCache || cache . exists ( ) ) { JSONUtils . toJSON ( ret , resp . getOutputStream ( ) , false ) ; return ; } }
zhizhounq/azkaban-customization | synchronized ( this ) { cacheTemp . renameTo ( cache ) ; }
zhizhounq/azkaban-customization | private void writeHistoryData ( List < HashMap < String , Object > > output , ExecutableFlow history ) { HashMap < String , Object > data = new HashMap < String , Object > ( ) ; data . put ( " scheduleid " , history . getScheduleId ( ) ) ; Project project = projectManager . getProject ( history . getProjectId ( ) ) ; data . put ( " flowname " , history . getFlowId ( ) ) ; data . put ( " projectname " , project . getName ( ) ) ; data . put ( " time " , history . getStartTime ( ) ) ; data . put ( " period " , "0" ) ; long endTime = history . getEndTime ( ) ; if ( endTime == - 1 ) { endTime = System . currentTimeMillis ( ) ; } data . put ( " length " , endTime - history . getStartTime ( ) ) ; data . put ( " history " , true ) ; data . put ( " status " , history . getStatus ( ) . getNumVal ( ) ) ; output . add ( data ) ; }
zhizhounq/azkaban-customization | private void ajaxRemoveSched ( HttpServletRequest req , Map < String , Object > ret , User user ) throws ServletException { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched ; try { sched = scheduleManager . getSchedule ( scheduleId ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( sched == null ) { ret . put ( " message " , " Schedule ▁ with ▁ ID ▁ " + scheduleId + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + sched . getProjectId ( ) + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ remove ▁ schedule ▁ with ▁ id ▁ " + scheduleId ) ; return ; } scheduleManager . removeSchedule ( sched ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ▁ has ▁ removed ▁ schedule ▁ " + sched . getScheduleName ( ) ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + sched . toString ( ) + " ▁ has ▁ been ▁ removed . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , " flow ▁ " + sched . getFlowName ( ) + " ▁ removed ▁ from ▁ Schedules . " ) ; return ; }
zhizhounq/azkaban-customization | private void ajaxDisableSched ( HttpServletRequest req , Map < String , Object > ret , User user ) throws ServletException { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched ; try { sched = scheduleManager . getSchedule ( scheduleId ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( sched == null ) { ret . put ( " message " , " Schedule ▁ with ▁ ID ▁ " + scheduleId + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + sched . getProjectId ( ) + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ disable ▁ schedule ▁ with ▁ id ▁ " + scheduleId ) ; return ; } scheduleManager . disableSchedule ( sched ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ▁ has ▁ disabled ▁ schedule ▁ " + sched . getScheduleName ( ) ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + sched . toString ( ) + " ▁ has ▁ been ▁ disabled . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , " flow ▁ " + sched . getFlowName ( ) + " ▁ disabled ▁ from ▁ Schedules . " ) ; return ; }
zhizhounq/azkaban-customization | private void ajaxEnableSched ( HttpServletRequest req , Map < String , Object > ret , User user ) throws ServletException { int scheduleId = getIntParam ( req , " scheduleId " ) ; Schedule sched ; try { sched = scheduleManager . getSchedule ( scheduleId ) ; } catch ( ScheduleManagerException e ) { throw new ServletException ( e ) ; } if ( sched == null ) { ret . put ( " message " , " Schedule ▁ with ▁ ID ▁ " + scheduleId + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } Project project = projectManager . getProject ( sched . getProjectId ( ) ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + sched . getProjectId ( ) + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ enable ▁ schedule ▁ with ▁ id ▁ " + scheduleId ) ; return ; } scheduleManager . enableSchedule ( sched ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ▁ has ▁ enabled ▁ schedule ▁ " + sched . getScheduleName ( ) ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + sched . toString ( ) + " ▁ has ▁ been ▁ enabled . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , " flow ▁ " + sched . getFlowName ( ) + " ▁ enabled ▁ from ▁ Schedules . " ) ; return ; }
zhizhounq/azkaban-customization | private void ajaxScheduleFlow ( HttpServletRequest req , HashMap < String , Object > ret , User user ) throws ServletException { String projectName = getParam ( req , " projectName " ) ; String flowName = getParam ( req , " flow " ) ; int projectId = getIntParam ( req , " projectId " ) ; Project project = projectManager . getProject ( projectId ) ; if ( project == null ) { ret . put ( " message " , " Project ▁ " + projectName + " ▁ does ▁ not ▁ exist " ) ; ret . put ( " status " , " error " ) ; return ; } if ( ! hasPermission ( project , user , Type . SCHEDULE ) ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Permission ▁ denied . ▁ Cannot ▁ execute ▁ " + flowName ) ; return ; } Flow flow = project . getFlow ( flowName ) ; if ( flow == null ) { ret . put ( " status " , " error " ) ; ret . put ( " message " , " Flow ▁ " + flowName + " ▁ cannot ▁ be ▁ found ▁ in ▁ project ▁ " + project ) ; return ; } String scheduleTime = getParam ( req , " scheduleTime " ) ; String scheduleDate = getParam ( req , " scheduleDate " ) ; DateTime firstSchedTime ; try { firstSchedTime = parseDateTime ( scheduleDate , scheduleTime ) ; } catch ( Exception e ) { ret . put ( " error " , " Invalid ▁ date ▁ and / or ▁ time ▁ ' " + scheduleDate + " ▁ " + scheduleTime ) ; return ; } ReadablePeriod thePeriod = null ; try { if ( hasParam ( req , " is _ recurring " ) && getParam ( req , " is _ recurring " ) . equals ( " on " ) ) { thePeriod = Schedule . parsePeriodString ( getParam ( req , " period " ) ) ; } } catch ( Exception e ) { ret . put ( " error " , e . getMessage ( ) ) ; } ExecutionOptions flowOptions = null ; try { flowOptions = HttpRequestUtils . parseFlowOptions ( req ) ; } catch ( Exception e ) { ret . put ( " error " , e . getMessage ( ) ) ; } int scheduleRetries = Trigger . TRIGGER_RETRIES ; Boolean retriesCheck = false ; try { if ( hasParam ( req , " retriesCheck " ) && getParam ( req , " retriesCheck " ) . equals ( " on " ) ) { retriesCheck = true ; scheduleRetries = getIntParam ( req , " scheduleRetries " ) ; } } catch ( Exception e ) { ret . put ( " error " , e . getMessage ( ) ) ; } List < SlaOption > slaOptions = null ; Schedule schedule = scheduleManager . scheduleFlow ( - 1 , projectId , projectName , flowName , TriggerStatus . READY . toString ( ) , firstSchedTime . getMillis ( ) , firstSchedTime . getZone ( ) , thePeriod , DateTime . now ( ) . getMillis ( ) , firstSchedTime . getMillis ( ) , firstSchedTime . getMillis ( ) , user . getUserId ( ) , flowOptions , slaOptions , retriesCheck , scheduleRetries ) ; logger . info ( " User ▁ ' " + user . getUserId ( ) + " ' ▁ has ▁ scheduled ▁ " + " [ " + projectName + flowName + " ▁ ( " + projectId + " ) " + " ] . " ) ; projectManager . postProjectEvent ( project , EventType . SCHEDULE , user . getUserId ( ) , " Schedule ▁ " + schedule . toString ( ) + " ▁ has ▁ been ▁ added . " ) ; ret . put ( " status " , " success " ) ; ret . put ( " message " , projectName + " . " + flowName + " ▁ scheduled . " ) ; }
zhizhounq/azkaban-customization | private DateTime parseDateTime ( String scheduleDate , String scheduleTime ) { String [ ] parts = scheduleTime . split ( " , " , - 1 ) ; int hour = Integer . parseInt ( parts [ 0 ] ) ; int minutes = Integer . parseInt ( parts [ 1 ] ) ; boolean isPm = parts [ 2 ] . equalsIgnoreCase ( " pm " ) ; DateTimeZone timezone = parts [ 3 ] . equals ( " UTC " ) ? DateTimeZone . UTC : DateTimeZone . getDefault ( ) ; DateTime day = null ; if ( scheduleDate == null || scheduleDate . trim ( ) . length ( ) == 0 ) { day = new LocalDateTime ( ) . toDateTime ( ) ; } else { day = DateTimeFormat . forPattern ( " MM / dd / yyyy " ) . withZone ( timezone ) . parseDateTime ( scheduleDate ) ; } hour %= 12 ; if ( isPm ) hour += 12 ; DateTime firstSchedTime = day . withHourOfDay ( hour ) . withMinuteOfHour ( minutes ) . withSecondOfMinute ( 0 ) ; return firstSchedTime ; }
anoordover/camel | @ Override protected JndiRegistry createRegistry ( ) throws Exception { JndiRegistry jndi = super . createRegistry ( ) ; jndi . bind ( " generator " , new MyFileNameGenerator ( ) ) ; return jndi ; }
anoordover/camel | protected String getLanguageName ( ) { return " file " ; }
anoordover/camel | @ Test public void testConstantExpression ( ) throws Exception { assertExpression ( " MyBigFile . txt " , " MyBigFile . txt " ) ; }
anoordover/camel | @ Test public void testMessageId ( ) throws Exception { assertExpression ( " $ { id } " , exchange . getIn ( ) . getMessageId ( ) ) ; assertExpression ( " $ { id } . bak " , exchange . getIn ( ) . getMessageId ( ) + " . bak " ) ; }
anoordover/camel | @ Test public void testInvalidSyntax ( ) throws Exception { assertExpression ( " $ { file : onlyname } " , file . getName ( ) ) ; try { assertExpression ( " $ { file : onlyName } " , file . getName ( ) ) ; fail ( " Should ▁ have ▁ thrown ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ file ▁ language ▁ syntax : ▁ onlyName ▁ at ▁ location ▁ 0" ) ) ; } }
anoordover/camel | @ Test public void testFile ( ) throws Exception { assertExpression ( " $ { file : ext } " , " txt " ) ; assertExpression ( " $ { file : name . ext } " , " txt " ) ; assertExpression ( " $ { file : name . ext . single } " , " txt " ) ; assertExpression ( " $ { file : name } " , " test " + File . separator + file . getName ( ) ) ; assertExpression ( " $ { file : name . noext } " , " test " + File . separator + " hello " ) ; assertExpression ( " $ { file : name . noext . single } " , " test " + File . separator + " hello " ) ; assertExpression ( " $ { file : onlyname } " , file . getName ( ) ) ; assertExpression ( " $ { file : onlyname . noext } " , " hello " ) ; assertExpression ( " $ { file : onlyname . noext . single } " , " hello " ) ; assertExpression ( " $ { file : parent } " , file . getParent ( ) ) ; assertExpression ( " $ { file : path } " , file . getPath ( ) ) ; assertExpression ( " $ { file : absolute } " , FileUtil . isAbsolute ( file ) ) ; assertExpression ( " $ { file : absolute . path } " , file . getAbsolutePath ( ) ) ; assertExpression ( " $ { file : length } " , file . length ( ) ) ; assertExpression ( " $ { file : size } " , file . length ( ) ) ; Long modified = SimpleLanguage . simple ( " $ { file : modified } " ) . evaluate ( exchange , Long . class ) ; assertEquals ( file . lastModified ( ) , modified . longValue ( ) ) ; }
anoordover/camel | @ Test public void testFileUsingAlternativeStartToken ( ) throws Exception { assertExpression ( " $ simple { file : ext } " , " txt " ) ; assertExpression ( " $ simple { file : name . ext } " , " txt " ) ; assertExpression ( " $ simple { file : name } " , " test " + File . separator + file . getName ( ) ) ; assertExpression ( " $ simple { file : name . noext } " , " test " + File . separator + " hello " ) ; assertExpression ( " $ simple { file : onlyname } " , file . getName ( ) ) ; assertExpression ( " $ simple { file : onlyname . noext } " , " hello " ) ; assertExpression ( " $ simple { file : parent } " , file . getParent ( ) ) ; assertExpression ( " $ simple { file : path } " , file . getPath ( ) ) ; assertExpression ( " $ simple { file : absolute } " , FileUtil . isAbsolute ( file ) ) ; assertExpression ( " $ simple { file : absolute . path } " , file . getAbsolutePath ( ) ) ; assertExpression ( " $ simple { file : length } " , file . length ( ) ) ; assertExpression ( " $ simple { file : size } " , file . length ( ) ) ; long modified = SimpleLanguage . simple ( " $ { file : modified } " ) . evaluate ( exchange , long . class ) ; assertEquals ( file . lastModified ( ) , modified ) ; }
anoordover/camel | @ Test public void testDate ( ) throws Exception { String now = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( ) ) ; assertExpression ( " backup - $ { date : now : yyyyMMdd } " , " backup - " + now ) ; String expected = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( file . lastModified ( ) ) ) ; assertExpression ( " backup - $ { date : file : yyyyMMdd } " , " backup - " + expected ) ; assertExpression ( " backup - $ { date : header . birthday : yyyyMMdd } " , " backup - 19740420" ) ; assertExpression ( " hello - $ { date : out . header . special : yyyyMMdd } " , " hello - 20080808" ) ; try { this . assertExpression ( " nodate - $ { date : header . xxx : yyyyMMdd } " , null ) ; fail ( " Should ▁ have ▁ thrown ▁ IllegalArgumentException " ) ; } catch ( IllegalArgumentException e ) { } }
anoordover/camel | @ Test public void testDateUsingAlternativeStartToken ( ) throws Exception { String now = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( ) ) ; assertExpression ( " backup - $ simple { date : now : yyyyMMdd } " , " backup - " + now ) ; String expected = new SimpleDateFormat ( " yyyyMMdd " ) . format ( new Date ( file . lastModified ( ) ) ) ; assertExpression ( " backup - $ simple { date : file : yyyyMMdd } " , " backup - " + expected ) ; assertExpression ( " backup - $ simple { date : header . birthday : yyyyMMdd } " , " backup - 19740420" ) ; assertExpression ( " hello - $ simple { date : out . header . special : yyyyMMdd } " , " hello - 20080808" ) ; try { this . assertExpression ( " nodate - $ simple { date : header . xxx : yyyyMMdd } " , null ) ; fail ( " Should ▁ have ▁ thrown ▁ IllegalArgumentException " ) ; } catch ( IllegalArgumentException e ) { } }
anoordover/camel | @ Test public void testSimpleAndFile ( ) throws Exception { assertExpression ( " backup - $ { in . header . foo } - $ { file : name . noext } . bak " , " backup - abc - test " + File . separator + " hello . bak " ) ; assertExpression ( " backup - $ { in . header . foo } - $ { file : onlyname . noext } . bak " , " backup - abc - hello . bak " ) ; }
anoordover/camel | @ Test public void testSimpleAndFileAndBean ( ) throws Exception { assertExpression ( " backup - $ { in . header . foo } - $ { bean : generator } - $ { file : name . noext } . bak " , " backup - abc - generatorbybean - test " + File . separator + " hello . bak " ) ; assertExpression ( " backup - $ { in . header . foo } - $ { bean : generator } - $ { file : onlyname . noext } . bak " , " backup - abc - generatorbybean - hello . bak " ) ; }
anoordover/camel | @ Test public void testBean ( ) throws Exception { assertExpression ( " backup - $ { bean : generator } . txt " , " backup - generatorbybean . txt " ) ; assertExpression ( " backup - $ { bean : generator . generateFilename } . txt " , " backup - generatorbybean . txt " ) ; }
anoordover/camel | @ Test public void testNoEscapeAllowed ( ) throws Exception { exchange . getIn ( ) . setHeader ( Exchange . FILE_NAME , " hello . txt " ) ; assertExpression ( " target\ \n ewdir \\ onwindows \\ $ { file : name } " , " target\ \n ewdir \\ onwindows \\ hello . txt " ) ; }
anoordover/camel | @ Test public void testFileNameDoubleExtension ( ) throws Exception { file = new File ( " target / filelanguage / test / bigfile . tar . gz " ) ; String uri = " file : // target / filelanguage ? fileExist = Override " ; GenericFile < File > gf = FileConsumer . asGenericFile ( " target / filelanguage " , file , null , false ) ; FileEndpoint endpoint = getMandatoryEndpoint ( uri , FileEndpoint . class ) ; Exchange answer = endpoint . createExchange ( gf ) ; endpoint . configureMessage ( gf , answer . getIn ( ) ) ; assertEquals ( " bigfile . tar . gz " , file . getName ( ) ) ; assertExpression ( answer , " $ { file : onlyname } " , " bigfile . tar . gz " ) ; assertExpression ( answer , " $ { file : ext } " , " tar . gz " ) ; }
anoordover/camel | public Exchange createExchange ( ) { String uri = " file : // target / filelanguage ? fileExist = Override " ; template . sendBodyAndHeader ( uri , " Hello ▁ World " , Exchange . FILE_NAME , " test / hello . txt " ) ; file = new File ( " target / filelanguage / test / hello . txt " ) ; GenericFile < File > gf = FileConsumer . asGenericFile ( " target / filelanguage " , file , null , false ) ; FileEndpoint endpoint = getMandatoryEndpoint ( uri , FileEndpoint . class ) ; Exchange answer = endpoint . createExchange ( gf ) ; endpoint . configureMessage ( gf , answer . getIn ( ) ) ; Calendar cal = Calendar . getInstance ( ) ; cal . set ( 1974 , Calendar . APRIL , 20 ) ; answer . getIn ( ) . setHeader ( " birthday " , cal . getTime ( ) ) ; cal . set ( 2008 , Calendar . AUGUST , 8 ) ; answer . getOut ( ) . setHeader ( " special " , cal . getTime ( ) ) ; return answer ; }
anoordover/camel | @ Test public void testIllegalSyntax ( ) throws Exception { try { assertExpression ( " $ { file . name } " , " " ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ function : ▁ file . name ▁ at ▁ location ▁ 0" ) ) ; } try { assertExpression ( " hey ▁ $ { xxx } ▁ how ▁ are ▁ you ? " , " " ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ function : ▁ xxx ▁ at ▁ location ▁ 4" ) ) ; } try { assertExpression ( " $ { xxx } " , " " ) ; fail ( " Should ▁ have ▁ thrown ▁ an ▁ exception " ) ; } catch ( ExpressionIllegalSyntaxException e ) { assertTrue ( e . getMessage ( ) . startsWith ( " Unknown ▁ function : ▁ xxx ▁ at ▁ location ▁ 0" ) ) ; } }
anoordover/camel | @ Test public void testConstantFilename ( ) throws Exception { assertExpression ( " hello . txt " , " hello . txt " ) ; }
anoordover/camel | public String generateFilename ( Exchange exchange ) { return " generatorbybean " ; }
MerritCR/merrit | @ Inject MergeSuperSet ( @ GerritServerConfig Config cfg , ChangeData . Factory changeDataFactory , Provider < InternalChangeQuery > queryProvider , GitRepositoryManager repoManager ) { this . cfg = cfg ; this . changeDataFactory = changeDataFactory ; this . queryProvider = queryProvider ; this . repoManager = repoManager ; }
MerritCR/merrit | if ( Submit . wholeTopicEnabled ( cfg ) ) { return completeChangeSetIncludingTopics ( db , new ChangeSet ( cd ) , user ) ; }
MerritCR/merrit | for ( Project . NameKey project : pc . keySet ( ) ) { try ( Repository repo = repoManager . openRepository ( project ) ; RevWalk rw = CodeReviewCommit . newRevWalk ( repo ) ) { for ( Change . Id cId : pc . get ( project ) ) { ChangeData cd = changeDataFactory . create ( db , project , cId ) ; cd . changeControl ( user ) ; SubmitTypeRecord str = cd . submitTypeRecord ( ) ; if ( ! str . isOk ( ) ) { logErrorAndThrow ( " Failed ▁ to ▁ get ▁ submit ▁ type ▁ for ▁ " + cd . getId ( ) + " : ▁ " + str . errorMessage ) ; } if ( str . type == SubmitType . CHERRY_PICK ) { ret . add ( cd ) ; continue ; } PatchSet ps = cd . currentPatchSet ( ) ; String objIdStr = ps . getRevision ( ) . get ( ) ; RevCommit commit = rw . parseCommit ( ObjectId . fromString ( objIdStr ) ) ; Branch . NameKey destBranch = cd . change ( ) . getDest ( ) ; repo . getRefDatabase ( ) . refresh ( ) ; Ref ref = repo . getRefDatabase ( ) . getRef ( destBranch . get ( ) ) ; rw . reset ( ) ; rw . sort ( RevSort . TOPO ) ; rw . markStart ( commit ) ; if ( ref != null ) { RevCommit head = rw . parseCommit ( ref . getObjectId ( ) ) ; rw . markUninteresting ( head ) ; } List < String > hashes = new ArrayList < > ( ) ; hashes . add ( objIdStr ) ; for ( RevCommit c : rw ) { if ( ! c . equals ( commit ) ) { hashes . add ( c . name ( ) ) ; } } if ( ! hashes . isEmpty ( ) ) { Iterable < ChangeData > destChanges = query ( ) . byCommitsOnBranchNotMerged ( repo , db , cd . change ( ) . getDest ( ) , hashes ) ; for ( ChangeData chd : destChanges ) { ret . add ( chd ) ; } } } } }
MerritCR/merrit | while ( ! done ) { List < ChangeData > chgs = new ArrayList < > ( ) ; done = true ; for ( ChangeData cd : newCs . changes ( ) ) { chgs . add ( cd ) ; String topic = cd . change ( ) . getTopic ( ) ; if ( ! Strings . isNullOrEmpty ( topic ) && ! topicsTraversed . contains ( topic ) ) { chgs . addAll ( query ( ) . byTopicOpen ( topic ) ) ; done = false ; topicsTraversed . add ( topic ) ; } } changes = new ChangeSet ( chgs ) ; newCs = completeChangeSetWithoutTopic ( db , changes , user ) ; }
MerritCR/merrit | private InternalChangeQuery query ( ) { Set < String > fields = ImmutableSet . of ( ChangeField . CHANGE . getName ( ) , ChangeField . PATCH_SET . getName ( ) ) ; return queryProvider . get ( ) . setRequestedFields ( fields ) ; }
MerritCR/merrit | private void logError ( String msg ) { if ( log . isErrorEnabled ( ) ) { log . error ( msg ) ; } }
MerritCR/merrit | private void logErrorAndThrow ( String msg ) throws OrmException { logError ( msg ) ; throw new OrmException ( msg ) ; }
NovaViper/ZeroQuest | protected void func_151542_a ( long p_151542_1_ , int p_151542_3_ , int p_151542_4_ , Block [ ] p_151542_5_ , double p_151542_6_ , double p_151542_8_ , double p_151542_10_ ) { this . func_151541_a ( p_151542_1_ , p_151542_3_ , p_151542_4_ , p_151542_5_ , p_151542_6_ , p_151542_8_ , p_151542_10_ , 1.0F + this . rand . nextFloat ( ) * 6.0F , 0.0F , 0.0F , - 1 , - 1 , 0.5D ) ; }
NovaViper/ZeroQuest | protected void func_151541_a ( long p_151541_1_ , int p_151541_3_ , int p_151541_4_ , Block [ ] p_151541_5_ , double p_151541_6_ , double p_151541_8_ , double p_151541_10_ , float p_151541_12_ , float p_151541_13_ , float p_151541_14_ , int p_151541_15_ , int p_151541_16_ , double p_151541_17_ ) { double d4 = ( double ) ( p_151541_3_ * 16 + 8 ) ; double d5 = ( double ) ( p_151541_4_ * 16 + 8 ) ; float f3 = 0.0F ; float f4 = 0.0F ; Random random = new Random ( p_151541_1_ ) ; if ( p_151541_16_ <= 0 ) { int j1 = this . range * 16 - 16 ; p_151541_16_ = j1 - random . nextInt ( j1 / 4 ) ; } boolean flag2 = false ; if ( p_151541_15_ == - 1 ) { p_151541_15_ = p_151541_16_ / 2 ; flag2 = true ; } int k1 = random . nextInt ( p_151541_16_ / 2 ) + p_151541_16_ / 4 ; for ( boolean flag = random . nextInt ( 6 ) == 0 ; p_151541_15_ < p_151541_16_ ; ++ p_151541_15_ ) { double d6 = 1.5D + ( double ) ( MathHelper . sin ( ( float ) p_151541_15_ * ( float ) Math . PI / ( float ) p_151541_16_ ) * p_151541_12_ * 1.0F ) ; double d7 = d6 * p_151541_17_ ; float f5 = MathHelper . cos ( p_151541_14_ ) ; float f6 = MathHelper . sin ( p_151541_14_ ) ; p_151541_6_ += ( double ) ( MathHelper . cos ( p_151541_13_ ) * f5 ) ; p_151541_8_ += ( double ) f6 ; p_151541_10_ += ( double ) ( MathHelper . sin ( p_151541_13_ ) * f5 ) ; if ( flag ) { p_151541_14_ *= 0.92F ; } else { p_151541_14_ *= 0.7F ; } p_151541_14_ += f4 * 0.1F ; p_151541_13_ += f3 * 0.1F ; f4 *= 0.9F ; f3 *= 0.75F ; f4 += ( random . nextFloat ( ) - random . nextFloat ( ) ) * random . nextFloat ( ) * 2.0F ; f3 += ( random . nextFloat ( ) - random . nextFloat ( ) ) * random . nextFloat ( ) * 4.0F ; if ( ! flag2 && p_151541_15_ == k1 && p_151541_12_ > 1.0F && p_151541_16_ > 0 ) { this . func_151541_a ( random . nextLong ( ) , p_151541_3_ , p_151541_4_ , p_151541_5_ , p_151541_6_ , p_151541_8_ , p_151541_10_ , random . nextFloat ( ) * 0.5F + 0.5F , p_151541_13_ - ( ( float ) Math . PI / 2F ) , p_151541_14_ / 3.0F , p_151541_15_ , p_151541_16_ , 1.0D ) ; this . func_151541_a ( random . nextLong ( ) , p_151541_3_ , p_151541_4_ , p_151541_5_ , p_151541_6_ , p_151541_8_ , p_151541_10_ , random . nextFloat ( ) * 0.5F + 0.5F , p_151541_13_ + ( ( float ) Math . PI / 2F ) , p_151541_14_ / 3.0F , p_151541_15_ , p_151541_16_ , 1.0D ) ; return ; } if ( flag2 || random . nextInt ( 4 ) != 0 ) { double d8 = p_151541_6_ - d4 ; double d9 = p_151541_10_ - d5 ; double d10 = ( double ) ( p_151541_16_ - p_151541_15_ ) ; double d11 = ( double ) ( p_151541_12_ + 2.0F + 16.0F ) ; if ( d8 * d8 + d9 * d9 - d10 * d10 > d11 * d11 ) { return ; } if ( p_151541_6_ >= d4 - 16.0D - d6 * 2.0D && p_151541_10_ >= d5 - 16.0D - d6 * 2.0D && p_151541_6_ <= d4 + 16.0D + d6 * 2.0D && p_151541_10_ <= d5 + 16.0D + d6 * 2.0D ) { int i4 = MathHelper . floor_double ( p_151541_6_ - d6 ) - p_151541_3_ * 16 - 1 ; int l1 = MathHelper . floor_double ( p_151541_6_ + d6 ) - p_151541_3_ * 16 + 1 ; int j4 = MathHelper . floor_double ( p_151541_8_ - d7 ) - 1 ; int i2 = MathHelper . floor_double ( p_151541_8_ + d7 ) + 1 ; int k4 = MathHelper . floor_double ( p_151541_10_ - d6 ) - p_151541_4_ * 16 - 1 ; int j2 = MathHelper . floor_double ( p_151541_10_ + d6 ) - p_151541_4_ * 16 + 1 ; if ( i4 < 0 ) { i4 = 0 ; } if ( l1 > 16 ) { l1 = 16 ; } if ( j4 < 1 ) { j4 = 1 ; } if ( i2 > 248 ) { i2 = 248 ; } if ( k4 < 0 ) { k4 = 0 ; } if ( j2 > 16 ) { j2 = 16 ; } boolean flag3 = false ; int k2 ; int j3 ; for ( k2 = i4 ; ! flag3 && k2 < l1 ; ++ k2 ) { for ( int l2 = k4 ; ! flag3 && l2 < j2 ; ++ l2 ) { for ( int i3 = i2 + 1 ; ! flag3 && i3 >= j4 - 1 ; -- i3 ) { j3 = ( k2 * 16 + l2 ) * 256 + i3 ; if ( i3 >= 0 && i3 < 256 ) { Block block = p_151541_5_ [ j3 ] ; if ( isOceanBlock ( p_151541_5_ , j3 , k2 , i3 , l2 , p_151541_3_ , p_151541_4_ ) ) { flag3 = true ; } if ( i3 != j4 - 1 && k2 != i4 && k2 != l1 - 1 && l2 != k4 && l2 != j2 - 1 ) { i3 = j4 ; } } } } } if ( ! flag3 ) { for ( k2 = i4 ; k2 < l1 ; ++ k2 ) { double d13 = ( ( double ) ( k2 + p_151541_3_ * 16 ) + 0.5D - p_151541_6_ ) / d6 ; for ( j3 = k4 ; j3 < j2 ; ++ j3 ) { double d14 = ( ( double ) ( j3 + p_151541_4_ * 16 ) + 0.5D - p_151541_10_ ) / d6 ; int k3 = ( k2 * 16 + j3 ) * 256 + i2 ; boolean flag1 = false ; if ( d13 * d13 + d14 * d14 < 1.0D ) { for ( int l3 = i2 - 1 ; l3 >= j4 ; -- l3 ) { double d12 = ( ( double ) l3 + 0.5D - p_151541_8_ ) / d7 ; if ( d12 > - 0.7D && d13 * d13 + d12 * d12 + d14 * d14 < 1.0D ) { Block block1 = p_151541_5_ [ k3 ] ; if ( isTopBlock ( p_151541_5_ , k3 , k2 , l3 , j3 , p_151541_3_ , p_151541_4_ ) ) { flag1 = true ; } digBlock ( p_151541_5_ , k3 , k2 , l3 , j3 , p_151541_3_ , p_151541_4_ , flag1 ) ; } -- k3 ; } } } } if ( flag2 ) { break ; } } } } } }
NovaViper/ZeroQuest | protected void func_151538_a ( World p_151538_1_ , int p_151538_2_ , int p_151538_3_ , int p_151538_4_ , int p_151538_5_ , Block [ ] p_151538_6_ ) { int i1 = this . rand . nextInt ( this . rand . nextInt ( this . rand . nextInt ( 15 ) + 1 ) + 1 ) ; if ( this . rand . nextInt ( 7 ) != 0 ) { i1 = 0 ; } for ( int j1 = 0 ; j1 < i1 ; ++ j1 ) { double d0 = ( double ) ( p_151538_2_ * 16 + this . rand . nextInt ( 16 ) ) ; double d1 = ( double ) this . rand . nextInt ( this . rand . nextInt ( 120 ) + 8 ) ; double d2 = ( double ) ( p_151538_3_ * 16 + this . rand . nextInt ( 16 ) ) ; int k1 = 1 ; if ( this . rand . nextInt ( 4 ) == 0 ) { this . func_151542_a ( this . rand . nextLong ( ) , p_151538_4_ , p_151538_5_ , p_151538_6_ , d0 , d1 , d2 ) ; k1 += this . rand . nextInt ( 4 ) ; } for ( int l1 = 0 ; l1 < k1 ; ++ l1 ) { float f = this . rand . nextFloat ( ) * ( float ) Math . PI * 2.0F ; float f1 = ( this . rand . nextFloat ( ) - 0.5F ) * 2.0F / 8.0F ; float f2 = this . rand . nextFloat ( ) * 2.0F + this . rand . nextFloat ( ) ; if ( this . rand . nextInt ( 10 ) == 0 ) { f2 *= this . rand . nextFloat ( ) * this . rand . nextFloat ( ) * 3.0F + 1.0F ; } this . func_151541_a ( this . rand . nextLong ( ) , p_151538_4_ , p_151538_5_ , p_151538_6_ , d0 , d1 , d2 , f2 , f , f1 , 0 , 0 , 1.0D ) ; } } }
NovaViper/ZeroQuest | protected boolean isOceanBlock ( Block [ ] data , int index , int x , int y , int z , int chunkX , int chunkZ ) { return data [ index ] == Blocks . water ; }
NovaViper/ZeroQuest | private boolean isExceptionBiome ( BiomeGenBase biome ) { if ( biome == BiomeGenBase . mushroomIsland ) return true ; if ( biome == BiomeGenBase . beach ) return true ; if ( biome == ModBiomes . destroZone ) return true ; return false ; }
NovaViper/ZeroQuest | private boolean isTopBlock ( Block [ ] data , int index , int x , int y , int z , int chunkX , int chunkZ ) { BiomeGenBase biome = worldObj . getBiomeGenForCoords ( x + chunkX * 16 , z + chunkZ * 16 ) ; return ( isExceptionBiome ( biome ) ? data [ index ] == Blocks . grass : data [ index ] == biome . topBlock ) ; }
NovaViper/ZeroQuest | protected void digBlock ( Block [ ] data , int index , int x , int y , int z , int chunkX , int chunkZ , boolean foundTop ) { BiomeGenBase biome = worldObj . getBiomeGenForCoords ( x + chunkX * 16 , z + chunkZ * 16 ) ; Block top = ( isExceptionBiome ( biome ) ? Blocks . grass : biome . topBlock ) ; Block filler = ( isExceptionBiome ( biome ) ? Blocks . dirt : biome . fillerBlock ) ; Block block = data [ index ] ; if ( block == Blocks . stone || block == filler || block == top ) { if ( y < 10 ) { data [ index ] = Blocks . lava ; } else { data [ index ] = null ; if ( foundTop && data [ index - 1 ] == filler ) { data [ index - 1 ] = top ; } } } }
mazlixek/gwt-ol3 | public Projection ( ProjectionOptions projectionOptions ) { }
AntoineAugusti/incubator-zeppelin | public Factory ( ) { }
AntoineAugusti/incubator-zeppelin | public Client getClient ( org . apache . thrift . protocol . TProtocol prot ) { return new Client ( prot ) ; }
AntoineAugusti/incubator-zeppelin | public Client getClient ( org . apache . thrift . protocol . TProtocol iprot , org . apache . thrift . protocol . TProtocol oprot ) { return new Client ( iprot , oprot ) ; }
AntoineAugusti/incubator-zeppelin | public Client ( org . apache . thrift . protocol . TProtocol prot ) { super ( prot , prot ) ; }
AntoineAugusti/incubator-zeppelin | public Client ( org . apache . thrift . protocol . TProtocol iprot , org . apache . thrift . protocol . TProtocol oprot ) { super ( iprot , oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | if ( result . isSetSuccess ( ) ) { return result . success ; }
AntoineAugusti/incubator-zeppelin | public Factory ( org . apache . thrift . async . TAsyncClientManager clientManager , org . apache . thrift . protocol . TProtocolFactory protocolFactory ) { this . clientManager = clientManager ; this . protocolFactory = protocolFactory ; }
AntoineAugusti/incubator-zeppelin | public AsyncClient getAsyncClient ( org . apache . thrift . transport . TNonblockingTransport transport ) { return new AsyncClient ( protocolFactory , clientManager , transport ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncClient ( org . apache . thrift . protocol . TProtocolFactory protocolFactory , org . apache . thrift . async . TAsyncClientManager clientManager , org . apache . thrift . transport . TNonblockingTransport transport ) { super ( protocolFactory , clientManager , transport ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | if ( getState ( ) != org . apache . thrift . async . TAsyncMethodCall . State . RESPONSE_READ ) { throw new IllegalStateException ( " Method ▁ call ▁ not ▁ finished ! " ) ; }
AntoineAugusti/incubator-zeppelin | public Processor ( I iface ) { super ( iface , getProcessMap ( new HashMap < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > ( ) ) ) ; }
AntoineAugusti/incubator-zeppelin | protected Processor ( I iface , Map < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > processMap ) { super ( iface , getProcessMap ( processMap ) ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter ( ) { super ( " createInterpreter " ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args getEmptyArgsInstance ( ) { return new createInterpreter_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public open ( ) { super ( " open " ) ; }
AntoineAugusti/incubator-zeppelin | public open_args getEmptyArgsInstance ( ) { return new open_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public close ( ) { super ( " close " ) ; }
AntoineAugusti/incubator-zeppelin | public close_args getEmptyArgsInstance ( ) { return new close_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public interpret ( ) { super ( " interpret " ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_args getEmptyArgsInstance ( ) { return new interpret_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public cancel ( ) { super ( " cancel " ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_args getEmptyArgsInstance ( ) { return new cancel_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getProgress ( ) { super ( " getProgress " ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args getEmptyArgsInstance ( ) { return new getProgress_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getFormType ( ) { super ( " getFormType " ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args getEmptyArgsInstance ( ) { return new getFormType_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public completion ( ) { super ( " completion " ) ; }
AntoineAugusti/incubator-zeppelin | public completion_args getEmptyArgsInstance ( ) { return new completion_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public shutdown ( ) { super ( " shutdown " ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_args getEmptyArgsInstance ( ) { return new shutdown_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getStatus ( ) { super ( " getStatus " ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args getEmptyArgsInstance ( ) { return new getStatus_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public getEvent ( ) { super ( " getEvent " ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_args getEmptyArgsInstance ( ) { return new getEvent_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate ( ) { super ( " angularObjectUpdate " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args getEmptyArgsInstance ( ) { return new angularObjectUpdate_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd ( ) { super ( " angularObjectAdd " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args getEmptyArgsInstance ( ) { return new angularObjectAdd_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove ( ) { super ( " angularObjectRemove " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args getEmptyArgsInstance ( ) { return new angularObjectRemove_args ( ) ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public AsyncProcessor ( I iface ) { super ( iface , getProcessMap ( new HashMap < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > ( ) ) ) ; }
AntoineAugusti/incubator-zeppelin | protected AsyncProcessor ( I iface , Map < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > processMap ) { super ( iface , getProcessMap ( processMap ) ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter ( ) { super ( " createInterpreter " ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args getEmptyArgsInstance ( ) { return new createInterpreter_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { createInterpreter_result result = new createInterpreter_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; createInterpreter_result result = new createInterpreter_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , createInterpreter_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . createInterpreter ( args . className , args . properties , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public open ( ) { super ( " open " ) ; }
AntoineAugusti/incubator-zeppelin | public open_args getEmptyArgsInstance ( ) { return new open_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { open_result result = new open_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; open_result result = new open_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , open_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . open ( args . className , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public close ( ) { super ( " close " ) ; }
AntoineAugusti/incubator-zeppelin | public close_args getEmptyArgsInstance ( ) { return new close_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { close_result result = new close_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; close_result result = new close_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , close_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . close ( args . className , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public interpret ( ) { super ( " interpret " ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_args getEmptyArgsInstance ( ) { return new interpret_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < RemoteInterpreterResult > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < RemoteInterpreterResult > ( ) { public void onComplete ( RemoteInterpreterResult o ) { interpret_result result = new interpret_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; interpret_result result = new interpret_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , interpret_args args , org . apache . thrift . async . AsyncMethodCallback < RemoteInterpreterResult > resultHandler ) throws TException { iface . interpret ( args . className , args . st , args . interpreterContext , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public cancel ( ) { super ( " cancel " ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_args getEmptyArgsInstance ( ) { return new cancel_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { cancel_result result = new cancel_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; cancel_result result = new cancel_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , cancel_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . cancel ( args . className , args . interpreterContext , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress ( ) { super ( " getProgress " ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args getEmptyArgsInstance ( ) { return new getProgress_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Integer > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Integer > ( ) { public void onComplete ( Integer o ) { getProgress_result result = new getProgress_result ( ) ; result . success = o ; result . setSuccessIsSet ( true ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getProgress_result result = new getProgress_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getProgress_args args , org . apache . thrift . async . AsyncMethodCallback < Integer > resultHandler ) throws TException { iface . getProgress ( args . className , args . interpreterContext , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType ( ) { super ( " getFormType " ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args getEmptyArgsInstance ( ) { return new getFormType_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < String > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < String > ( ) { public void onComplete ( String o ) { getFormType_result result = new getFormType_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getFormType_result result = new getFormType_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getFormType_args args , org . apache . thrift . async . AsyncMethodCallback < String > resultHandler ) throws TException { iface . getFormType ( args . className , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public completion ( ) { super ( " completion " ) ; }
AntoineAugusti/incubator-zeppelin | public completion_args getEmptyArgsInstance ( ) { return new completion_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < List < String > > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < List < String > > ( ) { public void onComplete ( List < String > o ) { completion_result result = new completion_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; completion_result result = new completion_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , completion_args args , org . apache . thrift . async . AsyncMethodCallback < List < String > > resultHandler ) throws TException { iface . completion ( args . className , args . buf , args . cursor , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown ( ) { super ( " shutdown " ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_args getEmptyArgsInstance ( ) { return new shutdown_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { shutdown_result result = new shutdown_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; shutdown_result result = new shutdown_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , shutdown_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . shutdown ( resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus ( ) { super ( " getStatus " ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args getEmptyArgsInstance ( ) { return new getStatus_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < String > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < String > ( ) { public void onComplete ( String o ) { getStatus_result result = new getStatus_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getStatus_result result = new getStatus_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getStatus_args args , org . apache . thrift . async . AsyncMethodCallback < String > resultHandler ) throws TException { iface . getStatus ( args . jobId , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent ( ) { super ( " getEvent " ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_args getEmptyArgsInstance ( ) { return new getEvent_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < RemoteInterpreterEvent > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < RemoteInterpreterEvent > ( ) { public void onComplete ( RemoteInterpreterEvent o ) { getEvent_result result = new getEvent_result ( ) ; result . success = o ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; getEvent_result result = new getEvent_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , getEvent_args args , org . apache . thrift . async . AsyncMethodCallback < RemoteInterpreterEvent > resultHandler ) throws TException { iface . getEvent ( resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate ( ) { super ( " angularObjectUpdate " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args getEmptyArgsInstance ( ) { return new angularObjectUpdate_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { angularObjectUpdate_result result = new angularObjectUpdate_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; angularObjectUpdate_result result = new angularObjectUpdate_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , angularObjectUpdate_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . angularObjectUpdate ( args . name , args . noteId , args . object , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd ( ) { super ( " angularObjectAdd " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args getEmptyArgsInstance ( ) { return new angularObjectAdd_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { angularObjectAdd_result result = new angularObjectAdd_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; angularObjectAdd_result result = new angularObjectAdd_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , angularObjectAdd_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . angularObjectAdd ( args . name , args . noteId , args . object , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove ( ) { super ( " angularObjectRemove " ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args getEmptyArgsInstance ( ) { return new angularObjectRemove_args ( ) ; }
AntoineAugusti/incubator-zeppelin | public AsyncMethodCallback < Void > getResultHandler ( final AsyncFrameBuffer fb , final int seqid ) { final org . apache . thrift . AsyncProcessFunction fcall = this ; return new AsyncMethodCallback < Void > ( ) { public void onComplete ( Void o ) { angularObjectRemove_result result = new angularObjectRemove_result ( ) ; try { fcall . sendResponse ( fb , result , org . apache . thrift . protocol . TMessageType . REPLY , seqid ) ; return ; } catch ( Exception e ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , e ) ; } fb . close ( ) ; } public void onError ( Exception e ) { byte msgType = org . apache . thrift . protocol . TMessageType . REPLY ; org . apache . thrift . TBase msg ; angularObjectRemove_result result = new angularObjectRemove_result ( ) ; { msgType = org . apache . thrift . protocol . TMessageType . EXCEPTION ; msg = ( org . apache . thrift . TBase ) new org . apache . thrift . TApplicationException ( org . apache . thrift . TApplicationException . INTERNAL_ERROR , e . getMessage ( ) ) ; } try { fcall . sendResponse ( fb , msg , msgType , seqid ) ; return ; } catch ( Exception ex ) { LOGGER . error ( " Exception ▁ writing ▁ to ▁ internal ▁ frame ▁ buffer " , ex ) ; } fb . close ( ) ; } } ; }
AntoineAugusti/incubator-zeppelin | protected boolean isOneway ( ) { return false ; }
AntoineAugusti/incubator-zeppelin | public void start ( I iface , angularObjectRemove_args args , org . apache . thrift . async . AsyncMethodCallback < Void > resultHandler ) throws TException { iface . angularObjectRemove ( args . name , args . noteId , resultHandler ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args ( ) { }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args ( String className , Map < String , String > properties ) { this ( ) ; this . className = className ; this . properties = properties ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args ( createInterpreter_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetProperties ( ) ) { Map < String , String > __this__properties = new HashMap < String , String > ( other . properties ) ; this . properties = __this__properties ; } }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args deepCopy ( ) { return new createInterpreter_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . properties = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public int getPropertiesSize ( ) { return ( this . properties == null ) ? 0 : this . properties . size ( ) ; }
AntoineAugusti/incubator-zeppelin | public void putToProperties ( String key , String val ) { if ( this . properties == null ) { this . properties = new HashMap < String , String > ( ) ; } this . properties . put ( key , val ) ; }
AntoineAugusti/incubator-zeppelin | public Map < String , String > getProperties ( ) { return this . properties ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_args setProperties ( Map < String , String > properties ) { this . properties = properties ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetProperties ( ) { this . properties = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetProperties ( ) { return this . properties != null ; }
AntoineAugusti/incubator-zeppelin | public void setPropertiesIsSet ( boolean value ) { if ( ! value ) { this . properties = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case PROPERTIES : if ( value == null ) { unsetProperties ( ) ; } else { setProperties ( ( Map < String , String > ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case PROPERTIES : return getProperties ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case PROPERTIES : return isSetProperties ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof createInterpreter_args ) return this . equals ( ( createInterpreter_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( createInterpreter_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_properties = true && this . isSetProperties ( ) ; boolean that_present_properties = true && that . isSetProperties ( ) ; if ( this_present_properties || that_present_properties ) { if ( ! ( this_present_properties && that_present_properties ) ) return false ; if ( ! this . properties . equals ( that . properties ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_properties = true && ( isSetProperties ( ) ) ; list . add ( present_properties ) ; if ( present_properties ) list . add ( properties ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( createInterpreter_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetProperties ( ) ) . compareTo ( other . isSetProperties ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetProperties ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . properties , other . properties ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " createInterpreter _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " properties : " ) ; if ( this . properties == null ) { sb . append ( " null " ) ; } else { sb . append ( this . properties ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_argsStandardScheme getScheme ( ) { return new createInterpreter_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . MAP ) { { org . apache . thrift . protocol . TMap _map0 = iprot . readMapBegin ( ) ; struct . properties = new HashMap < String , String > ( 2 * _map0 . size ) ; String _key1 ; String _val2 ; for ( int _i3 = 0 ; _i3 < _map0 . size ; ++ _i3 ) { _key1 = iprot . readString ( ) ; _val2 = iprot . readString ( ) ; struct . properties . put ( _key1 , _val2 ) ; } iprot . readMapEnd ( ) ; } struct . setPropertiesIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . properties != null ) { oprot . writeFieldBegin ( PROPERTIES_FIELD_DESC ) ; { oprot . writeMapBegin ( new org . apache . thrift . protocol . TMap ( org . apache . thrift . protocol . TType . STRING , org . apache . thrift . protocol . TType . STRING , struct . properties . size ( ) ) ) ; for ( Map . Entry < String , String > _iter4 : struct . properties . entrySet ( ) ) { oprot . writeString ( _iter4 . getKey ( ) ) ; oprot . writeString ( _iter4 . getValue ( ) ) ; } oprot . writeMapEnd ( ) ; } oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_argsTupleScheme getScheme ( ) { return new createInterpreter_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetProperties ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetProperties ( ) ) { { oprot . writeI32 ( struct . properties . size ( ) ) ; for ( Map . Entry < String , String > _iter5 : struct . properties . entrySet ( ) ) { oprot . writeString ( _iter5 . getKey ( ) ) ; oprot . writeString ( _iter5 . getValue ( ) ) ; } } }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { { org . apache . thrift . protocol . TMap _map6 = new org . apache . thrift . protocol . TMap ( org . apache . thrift . protocol . TType . STRING , org . apache . thrift . protocol . TType . STRING , iprot . readI32 ( ) ) ; struct . properties = new HashMap < String , String > ( 2 * _map6 . size ) ; String _key7 ; String _val8 ; for ( int _i9 = 0 ; _i9 < _map6 . size ; ++ _i9 ) { _key7 = iprot . readString ( ) ; _val8 = iprot . readString ( ) ; struct . properties . put ( _key7 , _val8 ) ; } } struct . setPropertiesIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_result ( ) { }
AntoineAugusti/incubator-zeppelin | public createInterpreter_result ( createInterpreter_result other ) { }
AntoineAugusti/incubator-zeppelin | public createInterpreter_result deepCopy ( ) { return new createInterpreter_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof createInterpreter_result ) return this . equals ( ( createInterpreter_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( createInterpreter_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( createInterpreter_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " createInterpreter _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_resultStandardScheme getScheme ( ) { return new createInterpreter_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public createInterpreter_resultTupleScheme getScheme ( ) { return new createInterpreter_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public open_args ( ) { }
AntoineAugusti/incubator-zeppelin | public open_args ( String className ) { this ( ) ; this . className = className ; }
AntoineAugusti/incubator-zeppelin | public open_args ( open_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } }
AntoineAugusti/incubator-zeppelin | public open_args deepCopy ( ) { return new open_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public open_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof open_args ) return this . equals ( ( open_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( open_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( open_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " open _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public open_argsStandardScheme getScheme ( ) { return new open_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public open_argsTupleScheme getScheme ( ) { return new open_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public open_result ( ) { }
AntoineAugusti/incubator-zeppelin | public open_result ( open_result other ) { }
AntoineAugusti/incubator-zeppelin | public open_result deepCopy ( ) { return new open_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof open_result ) return this . equals ( ( open_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( open_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( open_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " open _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public open_resultStandardScheme getScheme ( ) { return new open_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public open_resultTupleScheme getScheme ( ) { return new open_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public close_args ( ) { }
AntoineAugusti/incubator-zeppelin | public close_args ( String className ) { this ( ) ; this . className = className ; }
AntoineAugusti/incubator-zeppelin | public close_args ( close_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } }
AntoineAugusti/incubator-zeppelin | public close_args deepCopy ( ) { return new close_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public close_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof close_args ) return this . equals ( ( close_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( close_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( close_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " close _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public close_argsStandardScheme getScheme ( ) { return new close_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public close_argsTupleScheme getScheme ( ) { return new close_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public close_result ( ) { }
AntoineAugusti/incubator-zeppelin | public close_result ( close_result other ) { }
AntoineAugusti/incubator-zeppelin | public close_result deepCopy ( ) { return new close_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof close_result ) return this . equals ( ( close_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( close_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( close_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " close _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public close_resultStandardScheme getScheme ( ) { return new close_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public close_resultTupleScheme getScheme ( ) { return new close_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public interpret_args ( ) { }
AntoineAugusti/incubator-zeppelin | public interpret_args ( String className , String st , RemoteInterpreterContext interpreterContext ) { this ( ) ; this . className = className ; this . st = st ; this . interpreterContext = interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public interpret_args ( interpret_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetSt ( ) ) { this . st = other . st ; } if ( other . isSetInterpreterContext ( ) ) { this . interpreterContext = new RemoteInterpreterContext ( other . interpreterContext ) ; } }
AntoineAugusti/incubator-zeppelin | public interpret_args deepCopy ( ) { return new interpret_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . st = null ; this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public interpret_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public String getSt ( ) { return this . st ; }
AntoineAugusti/incubator-zeppelin | public interpret_args setSt ( String st ) { this . st = st ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSt ( ) { this . st = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSt ( ) { return this . st != null ; }
AntoineAugusti/incubator-zeppelin | public void setStIsSet ( boolean value ) { if ( ! value ) { this . st = null ; } }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterContext getInterpreterContext ( ) { return this . interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public interpret_args setInterpreterContext ( RemoteInterpreterContext interpreterContext ) { this . interpreterContext = interpreterContext ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetInterpreterContext ( ) { this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetInterpreterContext ( ) { return this . interpreterContext != null ; }
AntoineAugusti/incubator-zeppelin | public void setInterpreterContextIsSet ( boolean value ) { if ( ! value ) { this . interpreterContext = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case ST : if ( value == null ) { unsetSt ( ) ; } else { setSt ( ( String ) value ) ; } break ; case INTERPRETER_CONTEXT : if ( value == null ) { unsetInterpreterContext ( ) ; } else { setInterpreterContext ( ( RemoteInterpreterContext ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case ST : return getSt ( ) ; case INTERPRETER_CONTEXT : return getInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case ST : return isSetSt ( ) ; case INTERPRETER_CONTEXT : return isSetInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof interpret_args ) return this . equals ( ( interpret_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( interpret_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_st = true && this . isSetSt ( ) ; boolean that_present_st = true && that . isSetSt ( ) ; if ( this_present_st || that_present_st ) { if ( ! ( this_present_st && that_present_st ) ) return false ; if ( ! this . st . equals ( that . st ) ) return false ; } boolean this_present_interpreterContext = true && this . isSetInterpreterContext ( ) ; boolean that_present_interpreterContext = true && that . isSetInterpreterContext ( ) ; if ( this_present_interpreterContext || that_present_interpreterContext ) { if ( ! ( this_present_interpreterContext && that_present_interpreterContext ) ) return false ; if ( ! this . interpreterContext . equals ( that . interpreterContext ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_st = true && ( isSetSt ( ) ) ; list . add ( present_st ) ; if ( present_st ) list . add ( st ) ; boolean present_interpreterContext = true && ( isSetInterpreterContext ( ) ) ; list . add ( present_interpreterContext ) ; if ( present_interpreterContext ) list . add ( interpreterContext ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( interpret_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetSt ( ) ) . compareTo ( other . isSetSt ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSt ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . st , other . st ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetInterpreterContext ( ) ) . compareTo ( other . isSetInterpreterContext ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetInterpreterContext ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . interpreterContext , other . interpreterContext ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " interpret _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " st : " ) ; if ( this . st == null ) { sb . append ( " null " ) ; } else { sb . append ( this . st ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " interpreterContext : " ) ; if ( this . interpreterContext == null ) { sb . append ( " null " ) ; } else { sb . append ( this . interpreterContext ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( interpreterContext != null ) { interpreterContext . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_argsStandardScheme getScheme ( ) { return new interpret_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . st = iprot . readString ( ) ; struct . setStIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . st != null ) { oprot . writeFieldBegin ( ST_FIELD_DESC ) ; oprot . writeString ( struct . st ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . interpreterContext != null ) { oprot . writeFieldBegin ( INTERPRETER_CONTEXT_FIELD_DESC ) ; struct . interpreterContext . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_argsTupleScheme getScheme ( ) { return new interpret_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSt ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSt ( ) ) { oprot . writeString ( struct . st ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { struct . interpreterContext . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . st = iprot . readString ( ) ; struct . setStIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public interpret_result ( ) { }
AntoineAugusti/incubator-zeppelin | public interpret_result ( RemoteInterpreterResult success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public interpret_result ( interpret_result other ) { if ( other . isSetSuccess ( ) ) { this . success = new RemoteInterpreterResult ( other . success ) ; } }
AntoineAugusti/incubator-zeppelin | public interpret_result deepCopy ( ) { return new interpret_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterResult getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public interpret_result setSuccess ( RemoteInterpreterResult success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( RemoteInterpreterResult ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof interpret_result ) return this . equals ( ( interpret_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( interpret_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( interpret_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " interpret _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( success != null ) { success . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_resultStandardScheme getScheme ( ) { return new interpret_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . success = new RemoteInterpreterResult ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; struct . success . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public interpret_resultTupleScheme getScheme ( ) { return new interpret_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { struct . success . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = new RemoteInterpreterResult ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public cancel_args ( ) { }
AntoineAugusti/incubator-zeppelin | public cancel_args ( String className , RemoteInterpreterContext interpreterContext ) { this ( ) ; this . className = className ; this . interpreterContext = interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public cancel_args ( cancel_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetInterpreterContext ( ) ) { this . interpreterContext = new RemoteInterpreterContext ( other . interpreterContext ) ; } }
AntoineAugusti/incubator-zeppelin | public cancel_args deepCopy ( ) { return new cancel_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public cancel_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterContext getInterpreterContext ( ) { return this . interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public cancel_args setInterpreterContext ( RemoteInterpreterContext interpreterContext ) { this . interpreterContext = interpreterContext ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetInterpreterContext ( ) { this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetInterpreterContext ( ) { return this . interpreterContext != null ; }
AntoineAugusti/incubator-zeppelin | public void setInterpreterContextIsSet ( boolean value ) { if ( ! value ) { this . interpreterContext = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case INTERPRETER_CONTEXT : if ( value == null ) { unsetInterpreterContext ( ) ; } else { setInterpreterContext ( ( RemoteInterpreterContext ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case INTERPRETER_CONTEXT : return getInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case INTERPRETER_CONTEXT : return isSetInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof cancel_args ) return this . equals ( ( cancel_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( cancel_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_interpreterContext = true && this . isSetInterpreterContext ( ) ; boolean that_present_interpreterContext = true && that . isSetInterpreterContext ( ) ; if ( this_present_interpreterContext || that_present_interpreterContext ) { if ( ! ( this_present_interpreterContext && that_present_interpreterContext ) ) return false ; if ( ! this . interpreterContext . equals ( that . interpreterContext ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_interpreterContext = true && ( isSetInterpreterContext ( ) ) ; list . add ( present_interpreterContext ) ; if ( present_interpreterContext ) list . add ( interpreterContext ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( cancel_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetInterpreterContext ( ) ) . compareTo ( other . isSetInterpreterContext ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetInterpreterContext ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . interpreterContext , other . interpreterContext ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " cancel _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " interpreterContext : " ) ; if ( this . interpreterContext == null ) { sb . append ( " null " ) ; } else { sb . append ( this . interpreterContext ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( interpreterContext != null ) { interpreterContext . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_argsStandardScheme getScheme ( ) { return new cancel_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . interpreterContext != null ) { oprot . writeFieldBegin ( INTERPRETER_CONTEXT_FIELD_DESC ) ; struct . interpreterContext . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_argsTupleScheme getScheme ( ) { return new cancel_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { struct . interpreterContext . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public cancel_result ( ) { }
AntoineAugusti/incubator-zeppelin | public cancel_result ( cancel_result other ) { }
AntoineAugusti/incubator-zeppelin | public cancel_result deepCopy ( ) { return new cancel_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof cancel_result ) return this . equals ( ( cancel_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( cancel_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( cancel_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " cancel _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_resultStandardScheme getScheme ( ) { return new cancel_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public cancel_resultTupleScheme getScheme ( ) { return new cancel_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getProgress_args ( String className , RemoteInterpreterContext interpreterContext ) { this ( ) ; this . className = className ; this . interpreterContext = interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args ( getProgress_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetInterpreterContext ( ) ) { this . interpreterContext = new RemoteInterpreterContext ( other . interpreterContext ) ; } }
AntoineAugusti/incubator-zeppelin | public getProgress_args deepCopy ( ) { return new getProgress_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterContext getInterpreterContext ( ) { return this . interpreterContext ; }
AntoineAugusti/incubator-zeppelin | public getProgress_args setInterpreterContext ( RemoteInterpreterContext interpreterContext ) { this . interpreterContext = interpreterContext ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetInterpreterContext ( ) { this . interpreterContext = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetInterpreterContext ( ) { return this . interpreterContext != null ; }
AntoineAugusti/incubator-zeppelin | public void setInterpreterContextIsSet ( boolean value ) { if ( ! value ) { this . interpreterContext = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case INTERPRETER_CONTEXT : if ( value == null ) { unsetInterpreterContext ( ) ; } else { setInterpreterContext ( ( RemoteInterpreterContext ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case INTERPRETER_CONTEXT : return getInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case INTERPRETER_CONTEXT : return isSetInterpreterContext ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getProgress_args ) return this . equals ( ( getProgress_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getProgress_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_interpreterContext = true && this . isSetInterpreterContext ( ) ; boolean that_present_interpreterContext = true && that . isSetInterpreterContext ( ) ; if ( this_present_interpreterContext || that_present_interpreterContext ) { if ( ! ( this_present_interpreterContext && that_present_interpreterContext ) ) return false ; if ( ! this . interpreterContext . equals ( that . interpreterContext ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_interpreterContext = true && ( isSetInterpreterContext ( ) ) ; list . add ( present_interpreterContext ) ; if ( present_interpreterContext ) list . add ( interpreterContext ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getProgress_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetInterpreterContext ( ) ) . compareTo ( other . isSetInterpreterContext ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetInterpreterContext ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . interpreterContext , other . interpreterContext ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getProgress _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " interpreterContext : " ) ; if ( this . interpreterContext == null ) { sb . append ( " null " ) ; } else { sb . append ( this . interpreterContext ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( interpreterContext != null ) { interpreterContext . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_argsStandardScheme getScheme ( ) { return new getProgress_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . interpreterContext != null ) { oprot . writeFieldBegin ( INTERPRETER_CONTEXT_FIELD_DESC ) ; struct . interpreterContext . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_argsTupleScheme getScheme ( ) { return new getProgress_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetInterpreterContext ( ) ) { struct . interpreterContext . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . interpreterContext = new RemoteInterpreterContext ( ) ; struct . interpreterContext . read ( iprot ) ; struct . setInterpreterContextIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getProgress_result ( int success ) { this ( ) ; this . success = success ; setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result ( getProgress_result other ) { __isset_bitfield = other . __isset_bitfield ; this . success = other . success ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result deepCopy ( ) { return new getProgress_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { setSuccessIsSet ( false ) ; this . success = 0 ; }
AntoineAugusti/incubator-zeppelin | public int getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getProgress_result setSuccess ( int success ) { this . success = success ; setSuccessIsSet ( true ) ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { __isset_bitfield = EncodingUtils . clearBit ( __isset_bitfield , __SUCCESS_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return EncodingUtils . testBit ( __isset_bitfield , __SUCCESS_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { __isset_bitfield = EncodingUtils . setBit ( __isset_bitfield , __SUCCESS_ISSET_ID , value ) ; }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( Integer ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return Integer . valueOf ( getSuccess ( ) ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getProgress_result ) return this . equals ( ( getProgress_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getProgress_result that ) { if ( that == null ) return false ; boolean this_present_success = true ; boolean that_present_success = true ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( this . success != that . success ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getProgress_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getProgress _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; sb . append ( this . success ) ; first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_resultStandardScheme getScheme ( ) { return new getProgress_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . I32 ) { struct . success = iprot . readI32 ( ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; oprot . writeI32 ( struct . success ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getProgress_resultTupleScheme getScheme ( ) { return new getProgress_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeI32 ( struct . success ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = iprot . readI32 ( ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getFormType_args ( String className ) { this ( ) ; this . className = className ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args ( getFormType_args other ) { if ( other . isSetClassName ( ) ) { this . className = other . className ; } }
AntoineAugusti/incubator-zeppelin | public getFormType_args deepCopy ( ) { return new getFormType_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public getFormType_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getFormType_args ) return this . equals ( ( getFormType_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getFormType_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getFormType_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getFormType _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_argsStandardScheme getScheme ( ) { return new getFormType_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_argsTupleScheme getScheme ( ) { return new getFormType_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getFormType_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getFormType_result ( String success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public getFormType_result ( getFormType_result other ) { if ( other . isSetSuccess ( ) ) { this . success = other . success ; } }
AntoineAugusti/incubator-zeppelin | public getFormType_result deepCopy ( ) { return new getFormType_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public String getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getFormType_result setSuccess ( String success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getFormType_result ) return this . equals ( ( getFormType_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getFormType_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getFormType_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getFormType _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_resultStandardScheme getScheme ( ) { return new getFormType_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; oprot . writeString ( struct . success ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getFormType_resultTupleScheme getScheme ( ) { return new getFormType_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeString ( struct . success ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public completion_args ( ) { }
AntoineAugusti/incubator-zeppelin | public completion_args ( String className , String buf , int cursor ) { this ( ) ; this . className = className ; this . buf = buf ; this . cursor = cursor ; setCursorIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | public completion_args ( completion_args other ) { __isset_bitfield = other . __isset_bitfield ; if ( other . isSetClassName ( ) ) { this . className = other . className ; } if ( other . isSetBuf ( ) ) { this . buf = other . buf ; } this . cursor = other . cursor ; }
AntoineAugusti/incubator-zeppelin | public completion_args deepCopy ( ) { return new completion_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . className = null ; this . buf = null ; setCursorIsSet ( false ) ; this . cursor = 0 ; }
AntoineAugusti/incubator-zeppelin | public String getClassName ( ) { return this . className ; }
AntoineAugusti/incubator-zeppelin | public completion_args setClassName ( String className ) { this . className = className ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetClassName ( ) { this . className = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetClassName ( ) { return this . className != null ; }
AntoineAugusti/incubator-zeppelin | public void setClassNameIsSet ( boolean value ) { if ( ! value ) { this . className = null ; } }
AntoineAugusti/incubator-zeppelin | public String getBuf ( ) { return this . buf ; }
AntoineAugusti/incubator-zeppelin | public completion_args setBuf ( String buf ) { this . buf = buf ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetBuf ( ) { this . buf = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetBuf ( ) { return this . buf != null ; }
AntoineAugusti/incubator-zeppelin | public void setBufIsSet ( boolean value ) { if ( ! value ) { this . buf = null ; } }
AntoineAugusti/incubator-zeppelin | public int getCursor ( ) { return this . cursor ; }
AntoineAugusti/incubator-zeppelin | public completion_args setCursor ( int cursor ) { this . cursor = cursor ; setCursorIsSet ( true ) ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetCursor ( ) { __isset_bitfield = EncodingUtils . clearBit ( __isset_bitfield , __CURSOR_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetCursor ( ) { return EncodingUtils . testBit ( __isset_bitfield , __CURSOR_ISSET_ID ) ; }
AntoineAugusti/incubator-zeppelin | public void setCursorIsSet ( boolean value ) { __isset_bitfield = EncodingUtils . setBit ( __isset_bitfield , __CURSOR_ISSET_ID , value ) ; }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case class_NAME : if ( value == null ) { unsetClassName ( ) ; } else { setClassName ( ( String ) value ) ; } break ; case BUF : if ( value == null ) { unsetBuf ( ) ; } else { setBuf ( ( String ) value ) ; } break ; case CURSOR : if ( value == null ) { unsetCursor ( ) ; } else { setCursor ( ( Integer ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case class_NAME : return getClassName ( ) ; case BUF : return getBuf ( ) ; case CURSOR : return Integer . valueOf ( getCursor ( ) ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case class_NAME : return isSetClassName ( ) ; case BUF : return isSetBuf ( ) ; case CURSOR : return isSetCursor ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof completion_args ) return this . equals ( ( completion_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( completion_args that ) { if ( that == null ) return false ; boolean this_present_className = true && this . isSetClassName ( ) ; boolean that_present_className = true && that . isSetClassName ( ) ; if ( this_present_className || that_present_className ) { if ( ! ( this_present_className && that_present_className ) ) return false ; if ( ! this . className . equals ( that . className ) ) return false ; } boolean this_present_buf = true && this . isSetBuf ( ) ; boolean that_present_buf = true && that . isSetBuf ( ) ; if ( this_present_buf || that_present_buf ) { if ( ! ( this_present_buf && that_present_buf ) ) return false ; if ( ! this . buf . equals ( that . buf ) ) return false ; } boolean this_present_cursor = true ; boolean that_present_cursor = true ; if ( this_present_cursor || that_present_cursor ) { if ( ! ( this_present_cursor && that_present_cursor ) ) return false ; if ( this . cursor != that . cursor ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_className = true && ( isSetClassName ( ) ) ; list . add ( present_className ) ; if ( present_className ) list . add ( className ) ; boolean present_buf = true && ( isSetBuf ( ) ) ; list . add ( present_buf ) ; if ( present_buf ) list . add ( buf ) ; boolean present_cursor = true ; list . add ( present_cursor ) ; if ( present_cursor ) list . add ( cursor ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( completion_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetClassName ( ) ) . compareTo ( other . isSetClassName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetClassName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . className , other . className ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetBuf ( ) ) . compareTo ( other . isSetBuf ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetBuf ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . buf , other . buf ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetCursor ( ) ) . compareTo ( other . isSetCursor ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetCursor ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . cursor , other . cursor ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " completion _ args ( " ) ; boolean first = true ; sb . append ( " className : " ) ; if ( this . className == null ) { sb . append ( " null " ) ; } else { sb . append ( this . className ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " buf : " ) ; if ( this . buf == null ) { sb . append ( " null " ) ; } else { sb . append ( this . buf ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " cursor : " ) ; sb . append ( this . cursor ) ; first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public completion_argsStandardScheme getScheme ( ) { return new completion_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . buf = iprot . readString ( ) ; struct . setBufIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . I32 ) { struct . cursor = iprot . readI32 ( ) ; struct . setCursorIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . className != null ) { oprot . writeFieldBegin ( class_NAME_FIELD_DESC ) ; oprot . writeString ( struct . className ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . buf != null ) { oprot . writeFieldBegin ( BUF_FIELD_DESC ) ; oprot . writeString ( struct . buf ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public completion_argsTupleScheme getScheme ( ) { return new completion_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetBuf ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetCursor ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetClassName ( ) ) { oprot . writeString ( struct . className ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetBuf ( ) ) { oprot . writeString ( struct . buf ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetCursor ( ) ) { oprot . writeI32 ( struct . cursor ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . className = iprot . readString ( ) ; struct . setClassNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . buf = iprot . readString ( ) ; struct . setBufIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . cursor = iprot . readI32 ( ) ; struct . setCursorIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public completion_result ( ) { }
AntoineAugusti/incubator-zeppelin | public completion_result ( List < String > success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public completion_result ( completion_result other ) { if ( other . isSetSuccess ( ) ) { List < String > __this__success = new ArrayList < String > ( other . success ) ; this . success = __this__success ; } }
AntoineAugusti/incubator-zeppelin | public completion_result deepCopy ( ) { return new completion_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public int getSuccessSize ( ) { return ( this . success == null ) ? 0 : this . success . size ( ) ; }
AntoineAugusti/incubator-zeppelin | public java . util . Iterator < String > getSuccessIterator ( ) { return ( this . success == null ) ? null : this . success . iterator ( ) ; }
AntoineAugusti/incubator-zeppelin | public void addToSuccess ( String elem ) { if ( this . success == null ) { this . success = new ArrayList < String > ( ) ; } this . success . add ( elem ) ; }
AntoineAugusti/incubator-zeppelin | public List < String > getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public completion_result setSuccess ( List < String > success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( List < String > ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof completion_result ) return this . equals ( ( completion_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( completion_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( completion_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " completion _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public completion_resultStandardScheme getScheme ( ) { return new completion_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . LIST ) { { org . apache . thrift . protocol . TList _list10 = iprot . readListBegin ( ) ; struct . success = new ArrayList < String > ( _list10 . size ) ; String _elem11 ; for ( int _i12 = 0 ; _i12 < _list10 . size ; ++ _i12 ) { _elem11 = iprot . readString ( ) ; struct . success . add ( _elem11 ) ; } iprot . readListEnd ( ) ; } struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; { oprot . writeListBegin ( new org . apache . thrift . protocol . TList ( org . apache . thrift . protocol . TType . STRING , struct . success . size ( ) ) ) ; for ( String _iter13 : struct . success ) { oprot . writeString ( _iter13 ) ; } oprot . writeListEnd ( ) ; } oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public completion_resultTupleScheme getScheme ( ) { return new completion_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { { oprot . writeI32 ( struct . success . size ( ) ) ; for ( String _iter14 : struct . success ) { oprot . writeString ( _iter14 ) ; } } }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { { org . apache . thrift . protocol . TList _list15 = new org . apache . thrift . protocol . TList ( org . apache . thrift . protocol . TType . STRING , iprot . readI32 ( ) ) ; struct . success = new ArrayList < String > ( _list15 . size ) ; String _elem16 ; for ( int _i17 = 0 ; _i17 < _list15 . size ; ++ _i17 ) { _elem16 = iprot . readString ( ) ; struct . success . add ( _elem16 ) ; } } struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public shutdown_args ( ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_args ( shutdown_args other ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_args deepCopy ( ) { return new shutdown_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof shutdown_args ) return this . equals ( ( shutdown_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( shutdown_args that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( shutdown_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " shutdown _ args ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_argsStandardScheme getScheme ( ) { return new shutdown_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_argsTupleScheme getScheme ( ) { return new shutdown_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public shutdown_result ( ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_result ( shutdown_result other ) { }
AntoineAugusti/incubator-zeppelin | public shutdown_result deepCopy ( ) { return new shutdown_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof shutdown_result ) return this . equals ( ( shutdown_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( shutdown_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( shutdown_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " shutdown _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_resultStandardScheme getScheme ( ) { return new shutdown_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public shutdown_resultTupleScheme getScheme ( ) { return new shutdown_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getStatus_args ( String jobId ) { this ( ) ; this . jobId = jobId ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args ( getStatus_args other ) { if ( other . isSetJobId ( ) ) { this . jobId = other . jobId ; } }
AntoineAugusti/incubator-zeppelin | public getStatus_args deepCopy ( ) { return new getStatus_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . jobId = null ; }
AntoineAugusti/incubator-zeppelin | public String getJobId ( ) { return this . jobId ; }
AntoineAugusti/incubator-zeppelin | public getStatus_args setJobId ( String jobId ) { this . jobId = jobId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetJobId ( ) { this . jobId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetJobId ( ) { return this . jobId != null ; }
AntoineAugusti/incubator-zeppelin | public void setJobIdIsSet ( boolean value ) { if ( ! value ) { this . jobId = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case JOB_ID : if ( value == null ) { unsetJobId ( ) ; } else { setJobId ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case JOB_ID : return getJobId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case JOB_ID : return isSetJobId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getStatus_args ) return this . equals ( ( getStatus_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getStatus_args that ) { if ( that == null ) return false ; boolean this_present_jobId = true && this . isSetJobId ( ) ; boolean that_present_jobId = true && that . isSetJobId ( ) ; if ( this_present_jobId || that_present_jobId ) { if ( ! ( this_present_jobId && that_present_jobId ) ) return false ; if ( ! this . jobId . equals ( that . jobId ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_jobId = true && ( isSetJobId ( ) ) ; list . add ( present_jobId ) ; if ( present_jobId ) list . add ( jobId ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getStatus_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetJobId ( ) ) . compareTo ( other . isSetJobId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetJobId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . jobId , other . jobId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getStatus _ args ( " ) ; boolean first = true ; sb . append ( " jobId : " ) ; if ( this . jobId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . jobId ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_argsStandardScheme getScheme ( ) { return new getStatus_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . jobId = iprot . readString ( ) ; struct . setJobIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . jobId != null ) { oprot . writeFieldBegin ( JOB_ID_FIELD_DESC ) ; oprot . writeString ( struct . jobId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_argsTupleScheme getScheme ( ) { return new getStatus_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetJobId ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetJobId ( ) ) { oprot . writeString ( struct . jobId ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . jobId = iprot . readString ( ) ; struct . setJobIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getStatus_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getStatus_result ( String success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public getStatus_result ( getStatus_result other ) { if ( other . isSetSuccess ( ) ) { this . success = other . success ; } }
AntoineAugusti/incubator-zeppelin | public getStatus_result deepCopy ( ) { return new getStatus_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public String getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getStatus_result setSuccess ( String success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getStatus_result ) return this . equals ( ( getStatus_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getStatus_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getStatus_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getStatus _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_resultStandardScheme getScheme ( ) { return new getStatus_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; oprot . writeString ( struct . success ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getStatus_resultTupleScheme getScheme ( ) { return new getStatus_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { oprot . writeString ( struct . success ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = iprot . readString ( ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getEvent_args ( ) { }
AntoineAugusti/incubator-zeppelin | public getEvent_args ( getEvent_args other ) { }
AntoineAugusti/incubator-zeppelin | public getEvent_args deepCopy ( ) { return new getEvent_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getEvent_args ) return this . equals ( ( getEvent_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getEvent_args that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getEvent_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getEvent _ args ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_argsStandardScheme getScheme ( ) { return new getEvent_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_argsTupleScheme getScheme ( ) { return new getEvent_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public getEvent_result ( ) { }
AntoineAugusti/incubator-zeppelin | public getEvent_result ( RemoteInterpreterEvent success ) { this ( ) ; this . success = success ; }
AntoineAugusti/incubator-zeppelin | public getEvent_result ( getEvent_result other ) { if ( other . isSetSuccess ( ) ) { this . success = new RemoteInterpreterEvent ( other . success ) ; } }
AntoineAugusti/incubator-zeppelin | public getEvent_result deepCopy ( ) { return new getEvent_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public RemoteInterpreterEvent getSuccess ( ) { return this . success ; }
AntoineAugusti/incubator-zeppelin | public getEvent_result setSuccess ( RemoteInterpreterEvent success ) { this . success = success ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetSuccess ( ) { this . success = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetSuccess ( ) { return this . success != null ; }
AntoineAugusti/incubator-zeppelin | public void setSuccessIsSet ( boolean value ) { if ( ! value ) { this . success = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unsetSuccess ( ) ; } else { setSuccess ( ( RemoteInterpreterEvent ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case SUCCESS : return getSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SUCCESS : return isSetSuccess ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof getEvent_result ) return this . equals ( ( getEvent_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( getEvent_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_success = true && ( isSetSuccess ( ) ) ; list . add ( present_success ) ; if ( present_success ) list . add ( success ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( getEvent_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetSuccess ( ) ) . compareTo ( other . isSetSuccess ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetSuccess ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . success , other . success ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " getEvent _ result ( " ) ; boolean first = true ; sb . append ( " success : " ) ; if ( this . success == null ) { sb . append ( " null " ) ; } else { sb . append ( this . success ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( success != null ) { success . validate ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_resultStandardScheme getScheme ( ) { return new getEvent_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . success = new RemoteInterpreterEvent ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . success != null ) { oprot . writeFieldBegin ( SUCCESS_FIELD_DESC ) ; struct . success . write ( oprot ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public getEvent_resultTupleScheme getScheme ( ) { return new getEvent_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetSuccess ( ) ) { struct . success . write ( oprot ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . success = new RemoteInterpreterEvent ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args ( String name , String noteId , String object ) { this ( ) ; this . name = name ; this . noteId = noteId ; this . object = object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args ( angularObjectUpdate_args other ) { if ( other . isSetName ( ) ) { this . name = other . name ; } if ( other . isSetNoteId ( ) ) { this . noteId = other . noteId ; } if ( other . isSetObject ( ) ) { this . object = other . object ; } }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args deepCopy ( ) { return new angularObjectUpdate_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . name = null ; this . noteId = null ; this . object = null ; }
AntoineAugusti/incubator-zeppelin | public String getName ( ) { return this . name ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args setName ( String name ) { this . name = name ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetName ( ) { this . name = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetName ( ) { return this . name != null ; }
AntoineAugusti/incubator-zeppelin | public void setNameIsSet ( boolean value ) { if ( ! value ) { this . name = null ; } }
AntoineAugusti/incubator-zeppelin | public String getNoteId ( ) { return this . noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args setNoteId ( String noteId ) { this . noteId = noteId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetNoteId ( ) { this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetNoteId ( ) { return this . noteId != null ; }
AntoineAugusti/incubator-zeppelin | public void setNoteIdIsSet ( boolean value ) { if ( ! value ) { this . noteId = null ; } }
AntoineAugusti/incubator-zeppelin | public String getObject ( ) { return this . object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_args setObject ( String object ) { this . object = object ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetObject ( ) { this . object = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetObject ( ) { return this . object != null ; }
AntoineAugusti/incubator-zeppelin | public void setObjectIsSet ( boolean value ) { if ( ! value ) { this . object = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case NAME : if ( value == null ) { unsetName ( ) ; } else { setName ( ( String ) value ) ; } break ; case NOTE_ID : if ( value == null ) { unsetNoteId ( ) ; } else { setNoteId ( ( String ) value ) ; } break ; case OBJECT : if ( value == null ) { unsetObject ( ) ; } else { setObject ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case NAME : return getName ( ) ; case NOTE_ID : return getNoteId ( ) ; case OBJECT : return getObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case NAME : return isSetName ( ) ; case NOTE_ID : return isSetNoteId ( ) ; case OBJECT : return isSetObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectUpdate_args ) return this . equals ( ( angularObjectUpdate_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectUpdate_args that ) { if ( that == null ) return false ; boolean this_present_name = true && this . isSetName ( ) ; boolean that_present_name = true && that . isSetName ( ) ; if ( this_present_name || that_present_name ) { if ( ! ( this_present_name && that_present_name ) ) return false ; if ( ! this . name . equals ( that . name ) ) return false ; } boolean this_present_noteId = true && this . isSetNoteId ( ) ; boolean that_present_noteId = true && that . isSetNoteId ( ) ; if ( this_present_noteId || that_present_noteId ) { if ( ! ( this_present_noteId && that_present_noteId ) ) return false ; if ( ! this . noteId . equals ( that . noteId ) ) return false ; } boolean this_present_object = true && this . isSetObject ( ) ; boolean that_present_object = true && that . isSetObject ( ) ; if ( this_present_object || that_present_object ) { if ( ! ( this_present_object && that_present_object ) ) return false ; if ( ! this . object . equals ( that . object ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_name = true && ( isSetName ( ) ) ; list . add ( present_name ) ; if ( present_name ) list . add ( name ) ; boolean present_noteId = true && ( isSetNoteId ( ) ) ; list . add ( present_noteId ) ; if ( present_noteId ) list . add ( noteId ) ; boolean present_object = true && ( isSetObject ( ) ) ; list . add ( present_object ) ; if ( present_object ) list . add ( object ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectUpdate_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetName ( ) ) . compareTo ( other . isSetName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . name , other . name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetNoteId ( ) ) . compareTo ( other . isSetNoteId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetNoteId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . noteId , other . noteId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetObject ( ) ) . compareTo ( other . isSetObject ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetObject ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . object , other . object ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectUpdate _ args ( " ) ; boolean first = true ; sb . append ( " name : " ) ; if ( this . name == null ) { sb . append ( " null " ) ; } else { sb . append ( this . name ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " noteId : " ) ; if ( this . noteId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . noteId ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " object : " ) ; if ( this . object == null ) { sb . append ( " null " ) ; } else { sb . append ( this . object ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_argsStandardScheme getScheme ( ) { return new angularObjectUpdate_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . name != null ) { oprot . writeFieldBegin ( NAME_FIELD_DESC ) ; oprot . writeString ( struct . name ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . noteId != null ) { oprot . writeFieldBegin ( NOTE_ID_FIELD_DESC ) ; oprot . writeString ( struct . noteId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . object != null ) { oprot . writeFieldBegin ( OBJECT_FIELD_DESC ) ; oprot . writeString ( struct . object ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_argsTupleScheme getScheme ( ) { return new angularObjectUpdate_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { oprot . writeString ( struct . name ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { oprot . writeString ( struct . noteId ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { oprot . writeString ( struct . object ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_result ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_result ( angularObjectUpdate_result other ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_result deepCopy ( ) { return new angularObjectUpdate_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectUpdate_result ) return this . equals ( ( angularObjectUpdate_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectUpdate_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectUpdate_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectUpdate _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_resultStandardScheme getScheme ( ) { return new angularObjectUpdate_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectUpdate_resultTupleScheme getScheme ( ) { return new angularObjectUpdate_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args ( String name , String noteId , String object ) { this ( ) ; this . name = name ; this . noteId = noteId ; this . object = object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args ( angularObjectAdd_args other ) { if ( other . isSetName ( ) ) { this . name = other . name ; } if ( other . isSetNoteId ( ) ) { this . noteId = other . noteId ; } if ( other . isSetObject ( ) ) { this . object = other . object ; } }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args deepCopy ( ) { return new angularObjectAdd_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . name = null ; this . noteId = null ; this . object = null ; }
AntoineAugusti/incubator-zeppelin | public String getName ( ) { return this . name ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args setName ( String name ) { this . name = name ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetName ( ) { this . name = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetName ( ) { return this . name != null ; }
AntoineAugusti/incubator-zeppelin | public void setNameIsSet ( boolean value ) { if ( ! value ) { this . name = null ; } }
AntoineAugusti/incubator-zeppelin | public String getNoteId ( ) { return this . noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args setNoteId ( String noteId ) { this . noteId = noteId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetNoteId ( ) { this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetNoteId ( ) { return this . noteId != null ; }
AntoineAugusti/incubator-zeppelin | public void setNoteIdIsSet ( boolean value ) { if ( ! value ) { this . noteId = null ; } }
AntoineAugusti/incubator-zeppelin | public String getObject ( ) { return this . object ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_args setObject ( String object ) { this . object = object ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetObject ( ) { this . object = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetObject ( ) { return this . object != null ; }
AntoineAugusti/incubator-zeppelin | public void setObjectIsSet ( boolean value ) { if ( ! value ) { this . object = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case NAME : if ( value == null ) { unsetName ( ) ; } else { setName ( ( String ) value ) ; } break ; case NOTE_ID : if ( value == null ) { unsetNoteId ( ) ; } else { setNoteId ( ( String ) value ) ; } break ; case OBJECT : if ( value == null ) { unsetObject ( ) ; } else { setObject ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case NAME : return getName ( ) ; case NOTE_ID : return getNoteId ( ) ; case OBJECT : return getObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case NAME : return isSetName ( ) ; case NOTE_ID : return isSetNoteId ( ) ; case OBJECT : return isSetObject ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectAdd_args ) return this . equals ( ( angularObjectAdd_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectAdd_args that ) { if ( that == null ) return false ; boolean this_present_name = true && this . isSetName ( ) ; boolean that_present_name = true && that . isSetName ( ) ; if ( this_present_name || that_present_name ) { if ( ! ( this_present_name && that_present_name ) ) return false ; if ( ! this . name . equals ( that . name ) ) return false ; } boolean this_present_noteId = true && this . isSetNoteId ( ) ; boolean that_present_noteId = true && that . isSetNoteId ( ) ; if ( this_present_noteId || that_present_noteId ) { if ( ! ( this_present_noteId && that_present_noteId ) ) return false ; if ( ! this . noteId . equals ( that . noteId ) ) return false ; } boolean this_present_object = true && this . isSetObject ( ) ; boolean that_present_object = true && that . isSetObject ( ) ; if ( this_present_object || that_present_object ) { if ( ! ( this_present_object && that_present_object ) ) return false ; if ( ! this . object . equals ( that . object ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_name = true && ( isSetName ( ) ) ; list . add ( present_name ) ; if ( present_name ) list . add ( name ) ; boolean present_noteId = true && ( isSetNoteId ( ) ) ; list . add ( present_noteId ) ; if ( present_noteId ) list . add ( noteId ) ; boolean present_object = true && ( isSetObject ( ) ) ; list . add ( present_object ) ; if ( present_object ) list . add ( object ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectAdd_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetName ( ) ) . compareTo ( other . isSetName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . name , other . name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetNoteId ( ) ) . compareTo ( other . isSetNoteId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetNoteId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . noteId , other . noteId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetObject ( ) ) . compareTo ( other . isSetObject ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetObject ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . object , other . object ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectAdd _ args ( " ) ; boolean first = true ; sb . append ( " name : " ) ; if ( this . name == null ) { sb . append ( " null " ) ; } else { sb . append ( this . name ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " noteId : " ) ; if ( this . noteId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . noteId ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " object : " ) ; if ( this . object == null ) { sb . append ( " null " ) ; } else { sb . append ( this . object ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_argsStandardScheme getScheme ( ) { return new angularObjectAdd_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . name != null ) { oprot . writeFieldBegin ( NAME_FIELD_DESC ) ; oprot . writeString ( struct . name ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . noteId != null ) { oprot . writeFieldBegin ( NOTE_ID_FIELD_DESC ) ; oprot . writeString ( struct . noteId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . object != null ) { oprot . writeFieldBegin ( OBJECT_FIELD_DESC ) ; oprot . writeString ( struct . object ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_argsTupleScheme getScheme ( ) { return new angularObjectAdd_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { optionals . set ( 2 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { oprot . writeString ( struct . name ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { oprot . writeString ( struct . noteId ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetObject ( ) ) { oprot . writeString ( struct . object ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 2 ) ) { struct . object = iprot . readString ( ) ; struct . setObjectIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_result ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_result ( angularObjectAdd_result other ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_result deepCopy ( ) { return new angularObjectAdd_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectAdd_result ) return this . equals ( ( angularObjectAdd_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectAdd_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectAdd_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectAdd _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_resultStandardScheme getScheme ( ) { return new angularObjectAdd_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectAdd_resultTupleScheme getScheme ( ) { return new angularObjectAdd_resultTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args ( String name , String noteId ) { this ( ) ; this . name = name ; this . noteId = noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args ( angularObjectRemove_args other ) { if ( other . isSetName ( ) ) { this . name = other . name ; } if ( other . isSetNoteId ( ) ) { this . noteId = other . noteId ; } }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args deepCopy ( ) { return new angularObjectRemove_args ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { this . name = null ; this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public String getName ( ) { return this . name ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args setName ( String name ) { this . name = name ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetName ( ) { this . name = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetName ( ) { return this . name != null ; }
AntoineAugusti/incubator-zeppelin | public void setNameIsSet ( boolean value ) { if ( ! value ) { this . name = null ; } }
AntoineAugusti/incubator-zeppelin | public String getNoteId ( ) { return this . noteId ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_args setNoteId ( String noteId ) { this . noteId = noteId ; return this ; }
AntoineAugusti/incubator-zeppelin | public void unsetNoteId ( ) { this . noteId = null ; }
AntoineAugusti/incubator-zeppelin | public boolean isSetNoteId ( ) { return this . noteId != null ; }
AntoineAugusti/incubator-zeppelin | public void setNoteIdIsSet ( boolean value ) { if ( ! value ) { this . noteId = null ; } }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case NAME : if ( value == null ) { unsetName ( ) ; } else { setName ( ( String ) value ) ; } break ; case NOTE_ID : if ( value == null ) { unsetNoteId ( ) ; } else { setNoteId ( ( String ) value ) ; } break ; } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { case NAME : return getName ( ) ; case NOTE_ID : return getNoteId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case NAME : return isSetName ( ) ; case NOTE_ID : return isSetNoteId ( ) ; } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectRemove_args ) return this . equals ( ( angularObjectRemove_args ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectRemove_args that ) { if ( that == null ) return false ; boolean this_present_name = true && this . isSetName ( ) ; boolean that_present_name = true && that . isSetName ( ) ; if ( this_present_name || that_present_name ) { if ( ! ( this_present_name && that_present_name ) ) return false ; if ( ! this . name . equals ( that . name ) ) return false ; } boolean this_present_noteId = true && this . isSetNoteId ( ) ; boolean that_present_noteId = true && that . isSetNoteId ( ) ; if ( this_present_noteId || that_present_noteId ) { if ( ! ( this_present_noteId && that_present_noteId ) ) return false ; if ( ! this . noteId . equals ( that . noteId ) ) return false ; } return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; boolean present_name = true && ( isSetName ( ) ) ; list . add ( present_name ) ; if ( present_name ) list . add ( name ) ; boolean present_noteId = true && ( isSetNoteId ( ) ) ; list . add ( present_noteId ) ; if ( present_noteId ) list . add ( noteId ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectRemove_args other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = Boolean . valueOf ( isSetName ( ) ) . compareTo ( other . isSetName ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetName ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . name , other . name ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = Boolean . valueOf ( isSetNoteId ( ) ) . compareTo ( other . isSetNoteId ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetNoteId ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . noteId , other . noteId ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectRemove _ args ( " ) ; boolean first = true ; sb . append ( " name : " ) ; if ( this . name == null ) { sb . append ( " null " ) ; } else { sb . append ( this . name ) ; } first = false ; if ( ! first ) sb . append ( " , ▁ " ) ; sb . append ( " noteId : " ) ; if ( this . noteId == null ) { sb . append ( " null " ) ; } else { sb . append ( this . noteId ) ; } first = false ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_argsStandardScheme getScheme ( ) { return new angularObjectRemove_argsStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . name != null ) { oprot . writeFieldBegin ( NAME_FIELD_DESC ) ; oprot . writeString ( struct . name ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . noteId != null ) { oprot . writeFieldBegin ( NOTE_ID_FIELD_DESC ) ; oprot . writeString ( struct . noteId ) ; oprot . writeFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_argsTupleScheme getScheme ( ) { return new angularObjectRemove_argsTupleScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { optionals . set ( 0 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { optionals . set ( 1 ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetName ( ) ) { oprot . writeString ( struct . name ) ; }
AntoineAugusti/incubator-zeppelin | if ( struct . isSetNoteId ( ) ) { oprot . writeString ( struct . noteId ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 0 ) ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | if ( incoming . get ( 1 ) ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; }
AntoineAugusti/incubator-zeppelin | for ( _Fields field : EnumSet . allOf ( _Fields . class ) ) { byName . put ( field . getFieldName ( ) , field ) ; }
AntoineAugusti/incubator-zeppelin | _Fields ( short thriftId , String fieldName ) { _thriftId = thriftId ; _fieldName = fieldName ; }
AntoineAugusti/incubator-zeppelin | public short getThriftFieldId ( ) { return _thriftId ; }
AntoineAugusti/incubator-zeppelin | public String getFieldName ( ) { return _fieldName ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_result ( ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_result ( angularObjectRemove_result other ) { }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_result deepCopy ( ) { return new angularObjectRemove_result ( this ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public void clear ( ) { }
AntoineAugusti/incubator-zeppelin | public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { } }
AntoineAugusti/incubator-zeppelin | public Object getFieldValue ( _Fields field ) { switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { } throw new IllegalStateException ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof angularObjectRemove_result ) return this . equals ( ( angularObjectRemove_result ) that ) ; return false ; }
AntoineAugusti/incubator-zeppelin | public boolean equals ( angularObjectRemove_result that ) { if ( that == null ) return false ; return true ; }
AntoineAugusti/incubator-zeppelin | @ Override public int hashCode ( ) { List < Object > list = new ArrayList < Object > ( ) ; return list . hashCode ( ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public int compareTo ( angularObjectRemove_result other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; return 0 ; }
AntoineAugusti/incubator-zeppelin | public _Fields fieldForId ( int fieldId ) { return _Fields . findByThriftId ( fieldId ) ; }
AntoineAugusti/incubator-zeppelin | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " angularObjectRemove _ result ( " ) ; boolean first = true ; sb . append ( " ) " ) ; return sb . toString ( ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | catch ( org . apache . thrift . TException te ) { throw new java . io . IOException ( te ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_resultStandardScheme getScheme ( ) { return new angularObjectRemove_resultStandardScheme ( ) ; }
AntoineAugusti/incubator-zeppelin | while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; }
AntoineAugusti/incubator-zeppelin | public angularObjectRemove_resultTupleScheme getScheme ( ) { return new angularObjectRemove_resultTupleScheme ( ) ; }
kzm4269/plen__Scenography_for_Android | protected ReadOnlyProperty ( @ NonNull Observable < T > observable ) { mObservable = Observable . concat ( Observable . just ( null ) , observable ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull public final Observable < T > asObservable ( ) { return mObservable . skip ( 1 ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull public final Optional < T > get ( ) { return getLatest ( ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull protected Optional < T > getLatest ( ) { try { return Optional . ofNullable ( mObservable . toBlocking ( ) . latest ( ) . iterator ( ) . next ( ) ) ; } catch ( NoSuchElementException e ) { return Optional . ofNullable ( mObservable . toBlocking ( ) . last ( ) ) ; } }
iYefeng/Odin | public Agent ( Configure conf ) { super ( conf ) ; this . workersPool = WorkersPool . getSingleton ( ) ; }
iYefeng/Odin | public WorkersPool getWorkersPool ( ) { return workersPool ; }
iYefeng/Odin | public void init ( ) { }
iYefeng/Odin | public void start ( ) { }
iYefeng/Odin | public void stop ( ) { }
xzjxylophone/RXJavaDemo | public int getId ( ) { return id ; }
xzjxylophone/RXJavaDemo | public void setId ( int id ) { this . id = id ; }
xzjxylophone/RXJavaDemo | public String getUserName ( ) { return userName == null ? " " : userName ; }
xzjxylophone/RXJavaDemo | public void setUserName ( String userName ) { this . userName = userName == null ? null : userName . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getRealName ( ) { return realName == null ? " " : realName ; }
xzjxylophone/RXJavaDemo | public void setRealName ( String realName ) { this . realName = realName == null ? null : realName . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getPwd ( ) { return pwd == null ? " " : pwd ; }
xzjxylophone/RXJavaDemo | public void setPwd ( String pwd ) { this . pwd = pwd == null ? null : pwd . trim ( ) ; }
xzjxylophone/RXJavaDemo | public int getSex ( ) { return sex ; }
xzjxylophone/RXJavaDemo | public void setSex ( int sex ) { this . sex = sex ; }
xzjxylophone/RXJavaDemo | public Date getBirthdate ( ) { return birthdate ; }
xzjxylophone/RXJavaDemo | public void setBirthdate ( Date birthdate ) { this . birthdate = birthdate ; }
xzjxylophone/RXJavaDemo | public String getMobile ( ) { return mobile == null ? " " : mobile ; }
xzjxylophone/RXJavaDemo | public void setMobile ( String mobile ) { this . mobile = mobile == null ? null : mobile . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getEmail ( ) { return email == null ? " " : email ; }
xzjxylophone/RXJavaDemo | public void setEmail ( String email ) { this . email = email == null ? null : email . trim ( ) ; }
xzjxylophone/RXJavaDemo | public int getStatus ( ) { return status ; }
xzjxylophone/RXJavaDemo | public void setStatus ( int status ) { this . status = status ; }
xzjxylophone/RXJavaDemo | public int getCreateUser ( ) { return createUser ; }
xzjxylophone/RXJavaDemo | public void setCreateUser ( int createUser ) { this . createUser = createUser ; }
xzjxylophone/RXJavaDemo | public Date getCreateTime ( ) { return createTime ; }
xzjxylophone/RXJavaDemo | public void setCreateTime ( Date createTime ) { this . createTime = createTime ; }
xzjxylophone/RXJavaDemo | public int getUpdateUser ( ) { return updateUser ; }
xzjxylophone/RXJavaDemo | public void setUpdateUser ( int updateUser ) { this . updateUser = updateUser ; }
xzjxylophone/RXJavaDemo | public Date getUpdateTime ( ) { return updateTime ; }
xzjxylophone/RXJavaDemo | public void setUpdateTime ( Date updateTime ) { this . updateTime = updateTime ; }
xzjxylophone/RXJavaDemo | public int getDelFlag ( ) { return delFlag ; }
xzjxylophone/RXJavaDemo | public void setDelFlag ( int delFlag ) { this . delFlag = delFlag ; }
xzjxylophone/RXJavaDemo | public String getField1 ( ) { return field1 == null ? " " : field1 ; }
xzjxylophone/RXJavaDemo | public void setField1 ( String field1 ) { this . field1 = field1 == null ? null : field1 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField2 ( ) { return field2 == null ? " " : field2 ; }
xzjxylophone/RXJavaDemo | public void setField2 ( String field2 ) { this . field2 = field2 == null ? null : field2 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField3 ( ) { return field3 == null ? " " : field3 ; }
xzjxylophone/RXJavaDemo | public void setField3 ( String field3 ) { this . field3 = field3 == null ? null : field3 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField4 ( ) { return field4 == null ? " " : field4 ; }
xzjxylophone/RXJavaDemo | public void setField4 ( String field4 ) { this . field4 = field4 == null ? null : field4 . trim ( ) ; }
xzjxylophone/RXJavaDemo | public String getField5 ( ) { return field5 == null ? " " : field5 ; }
xzjxylophone/RXJavaDemo | public void setField5 ( String field5 ) { this . field5 = field5 == null ? null : field5 . trim ( ) ; }
AbfrmBlr/ehcache3 | @ Test public void testGetField ( ) throws Exception { @ SuppressWarnings ( " unchecked " ) StatefulSerializer < Serializable > s = new CompactJavaSerializer < > ( null ) ; s . init ( new TransientStateRepository ( ) ) ; ClassLoader loaderA = createClassNameRewritingLoader ( Foo_A . class ) ; Serializable a = ( Serializable ) loaderA . loadClass ( newClassName ( Foo_A . class ) ) . newInstance ( ) ; ByteBuffer encodedA = s . serialize ( a ) ; pushTccl ( createClassNameRewritingLoader ( Foo_B . class ) ) ; try { s . read ( encodedA . duplicate ( ) ) ; } finally { popTccl ( ) ; } pushTccl ( createClassNameRewritingLoader ( Foo_C . class ) ) ; try { s . read ( encodedA . duplicate ( ) ) ; } finally { popTccl ( ) ; } }
AbfrmBlr/ehcache3 | if ( ! fields . defaulted ( " blargh " ) ) { throw new Error ( ) ; }
AbfrmBlr/ehcache3 | catch ( IllegalArgumentException ex ) { }
AbfrmBlr/ehcache3 | if ( ( fields . get ( " z " , false ) != true ) || ( fields . get ( " b " , ( byte ) 0 ) != 5 ) || ( fields . get ( " c " , '0' ) != '5' ) || ( fields . get ( " s " , ( short ) 0 ) != 5 ) || ( fields . get ( " i " , 0 ) != 5 ) || ( fields . get ( " j " , 0l ) != 5 ) || ( fields . get ( " f " , 0.0f ) != 5.0f ) || ( fields . get ( " d " , 0.0 ) != 5.0 ) || ( ! fields . get ( " str " , null ) . equals ( "5" ) ) ) { throw new Error ( ) ; }
AbfrmBlr/ehcache3 | if ( ( fields . get ( " z " , false ) != true ) || ( fields . get ( " b " , ( byte ) 0 ) != 5 ) || ( fields . get ( " c " , '0' ) != '5' ) || ( fields . get ( " s " , ( short ) 0 ) != 5 ) || ( fields . get ( " i " , 0 ) != 5 ) || ( fields . get ( " j " , 0l ) != 5 ) || ( fields . get ( " f " , 0.0f ) != 5.0f ) || ( fields . get ( " d " , 0.0 ) != 5.0 ) || ( ! fields . get ( " str " , null ) . equals ( "5" ) ) ) { throw new Error ( ) ; }
DBSI-BI/saiku | public void setDatasourceManager ( IDatasourceManager dms ) { this . datasourceManager = dms ; }
DBSI-BI/saiku | public void init ( ) { try { DefaultFileSystemManager dfsm = ( DefaultFileSystemManager ) VFS . getManager ( ) ; if ( ! dfsm . hasProvider ( " mondrian " ) ) { dfsm . addProvider ( " mondrian " , this ) ; } } catch ( FileSystemException e ) { } }
DBSI-BI/saiku | public FileObject findFile ( FileObject fileObject , String catalog , FileSystemOptions fileSystemOptions ) throws FileSystemException { return new RepositoryVfsFileObject ( catalog , this . datasourceManager ) ; }
DBSI-BI/saiku | public FileObject createFileSystem ( String s , FileObject fileObject , FileSystemOptions fileSystemOptions ) throws FileSystemException { return null ; }
DBSI-BI/saiku | public FileSystemConfigBuilder getConfigBuilder ( ) { return null ; }
DBSI-BI/saiku | public Collection getCapabilities ( ) { return null ; }
DBSI-BI/saiku | public FileName parseUri ( FileName fileName , String s ) throws FileSystemException { return null ; }
dukechain/Qassandra | private LeveledManifest ( ColumnFamilyStore cfs , int maxSSTableSizeInMB , SizeTieredCompactionStrategyOptions options ) { this . cfs = cfs ; this . maxSSTableSizeInBytes = maxSSTableSizeInMB * 1024 * 1024 ; this . options = options ; int n = ( int ) Math . log10 ( 1000 * 1000 * 1000 / maxSSTableSizeInMB ) ; generations = new List [ n ] ; lastCompactedKeys = new RowPosition [ n ] ; for ( int i = 0 ; i < generations . length ; i ++ ) { generations [ i ] = new ArrayList < SSTableReader > ( ) ; lastCompactedKeys [ i ] = cfs . partitioner . getMinimumToken ( ) . minKeyBound ( ) ; } }
dukechain/Qassandra | public synchronized void add ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level < generations . length : " Invalid ▁ level ▁ " + level + " ▁ out ▁ of ▁ " + ( generations . length - 1 ) ; logDistribution ( ) ; logger . debug ( " Adding ▁ { } ▁ to ▁ L { } " , reader , level ) ; generations [ level ] . add ( reader ) ; }
dukechain/Qassandra | private int skipLevels ( int newLevel , Iterable < SSTableReader > added ) { while ( maxBytesForLevel ( newLevel ) < SSTableReader . getTotalBytes ( added ) && generations [ ( newLevel + 1 ) ] . isEmpty ( ) ) { newLevel ++ ; } return newLevel ; }
dukechain/Qassandra | public synchronized void replace ( Iterable < SSTableReader > removed , Iterable < SSTableReader > added ) { assert ! Iterables . isEmpty ( removed ) ; logDistribution ( ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Replacing ▁ [ " + toString ( removed ) + " ] " ) ; for ( SSTableReader sstable : removed ) remove ( sstable ) ; if ( ! added . iterator ( ) . hasNext ( ) ) return ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Adding ▁ [ { } ] " , toString ( added ) ) ; int minLevel = Integer . MAX_VALUE ; for ( SSTableReader ssTableReader : added ) { minLevel = Math . min ( minLevel , ssTableReader . getSSTableLevel ( ) ) ; add ( ssTableReader ) ; } lastCompactedKeys [ minLevel ] = SSTable . sstableOrdering . max ( added ) . last ; }
dukechain/Qassandra | public synchronized void repairOverlappingSSTables ( int level ) { SSTableReader previous = null ; Collections . sort ( generations [ level ] , SSTable . sstableComparator ) ; List < SSTableReader > outOfOrderSSTables = new ArrayList < SSTableReader > ( ) ; for ( SSTableReader current : generations [ level ] ) { if ( previous != null && current . first . compareTo ( previous . last ) <= 0 ) { logger . warn ( String . format ( " At ▁ level ▁ % d , ▁ % s ▁ [ % s , ▁ % s ] ▁ overlaps ▁ % s ▁ [ % s , ▁ % s ] . ▁ ▁ This ▁ could ▁ be ▁ caused ▁ by ▁ a ▁ bug ▁ in ▁ Cassandra ▁ 1.1.0 ▁ . . ▁ 1.1.3 ▁ or ▁ due ▁ to ▁ the ▁ fact ▁ that ▁ you ▁ have ▁ dropped ▁ sstables ▁ from ▁ another ▁ node ▁ into ▁ the ▁ data ▁ directory . ▁ " + " Sending ▁ back ▁ to ▁ L0 . ▁ ▁ If ▁ you ▁ didn ' t ▁ drop ▁ in ▁ sstables , ▁ and ▁ have ▁ not ▁ yet ▁ run ▁ scrub , ▁ you ▁ should ▁ do ▁ so ▁ since ▁ you ▁ may ▁ also ▁ have ▁ rows ▁ out - of - order ▁ within ▁ an ▁ sstable " , level , previous , previous . first , previous . last , current , current . first , current . last ) ) ; outOfOrderSSTables . add ( current ) ; } else { previous = current ; } } if ( ! outOfOrderSSTables . isEmpty ( ) ) { for ( SSTableReader sstable : outOfOrderSSTables ) sendBackToL0 ( sstable ) ; } }
dukechain/Qassandra | private synchronized void sendBackToL0 ( SSTableReader sstable ) { remove ( sstable ) ; String metaDataFile = sstable . descriptor . filenameFor ( Component . STATS ) ; try { mutateLevel ( sstable . getSSTableMetadata ( ) , sstable . descriptor , metaDataFile , 0 ) ; sstable . reloadSSTableMetadata ( ) ; add ( sstable ) ; } catch ( IOException e ) { throw new RuntimeException ( " Could ▁ not ▁ reload ▁ sstable ▁ meta ▁ data " , e ) ; } }
dukechain/Qassandra | private String toString ( Iterable < SSTableReader > sstables ) { StringBuilder builder = new StringBuilder ( ) ; for ( SSTableReader sstable : sstables ) { builder . append ( sstable . descriptor . cfname ) . append ( ' - ' ) . append ( sstable . descriptor . generation ) . append ( " ( L " ) . append ( sstable . getSSTableLevel ( ) ) . append ( " ) , ▁ " ) ; } return builder . toString ( ) ; }
dukechain/Qassandra | @ VisibleForTesting long maxBytesForLevel ( int level ) { if ( level == 0 ) return 4L * maxSSTableSizeInBytes ; double bytes = Math . pow ( 10 , level ) * maxSSTableSizeInBytes ; if ( bytes > Long . MAX_VALUE ) throw new RuntimeException ( " At ▁ most ▁ " + Long . MAX_VALUE + " ▁ bytes ▁ may ▁ be ▁ in ▁ a ▁ compaction ▁ level ; ▁ your ▁ maxSSTableSize ▁ must ▁ be ▁ absurdly ▁ high ▁ to ▁ compute ▁ " + bytes ) ; return ( long ) bytes ; }
dukechain/Qassandra | public synchronized Pair < ? extends Collection < SSTableReader > , Integer > getCompactionCandidates ( ) { for ( int i = generations . length - 1 ; i > 0 ; i -- ) { List < SSTableReader > sstables = generations [ i ] ; if ( sstables . isEmpty ( ) ) continue ; Set < SSTableReader > sstablesInLevel = Sets . newHashSet ( sstables ) ; Set < SSTableReader > remaining = Sets . difference ( sstablesInLevel , cfs . getDataTracker ( ) . getCompacting ( ) ) ; double score = ( double ) SSTableReader . getTotalBytes ( remaining ) / ( double ) maxBytesForLevel ( i ) ; logger . debug ( " Compaction ▁ score ▁ for ▁ level ▁ { } ▁ is ▁ { } " , i , score ) ; if ( score > 1.001 ) { if ( generations [ 0 ] . size ( ) > MAX_COMPACTING_L0 ) { Iterable < SSTableReader > candidates = cfs . getDataTracker ( ) . getUncompactingSSTables ( generations [ 0 ] ) ; List < Pair < SSTableReader , Long > > pairs = SizeTieredCompactionStrategy . createSSTableAndLengthPairs ( AbstractCompactionStrategy . filterSuspectSSTables ( candidates ) ) ; List < List < SSTableReader > > buckets = SizeTieredCompactionStrategy . getBuckets ( pairs , options . bucketHigh , options . bucketLow , options . minSSTableSize ) ; List < SSTableReader > mostInteresting = SizeTieredCompactionStrategy . mostInterestingBucket ( buckets , 4 , 32 ) ; if ( ! mostInteresting . isEmpty ( ) ) return Pair . create ( mostInteresting , 0 ) ; } Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Compaction ▁ candidates ▁ for ▁ L { } ▁ are ▁ { } " , i , toString ( candidates ) ) ; if ( ! candidates . isEmpty ( ) ) return Pair . create ( candidates , getNextLevel ( candidates ) ) ; } } if ( generations [ 0 ] . isEmpty ( ) ) return null ; Collection < SSTableReader > candidates = getCandidatesFor ( 0 ) ; if ( candidates . isEmpty ( ) ) return null ; return Pair . create ( candidates , getNextLevel ( candidates ) ) ; }
dukechain/Qassandra | public synchronized int getLevelSize ( int i ) { if ( i >= generations . length ) throw new ArrayIndexOutOfBoundsException ( " Maximum ▁ valid ▁ generation ▁ is ▁ " + ( generations . length - 1 ) ) ; return generations [ i ] . size ( ) ; }
dukechain/Qassandra | public synchronized int [ ] getAllLevelSize ( ) { int [ ] counts = new int [ generations . length ] ; for ( int i = 0 ; i < counts . length ; i ++ ) counts [ i ] = generations [ i ] . size ( ) ; return counts ; }
dukechain/Qassandra | private void logDistribution ( ) { if ( logger . isDebugEnabled ( ) ) { for ( int i = 0 ; i < generations . length ; i ++ ) { if ( ! generations [ i ] . isEmpty ( ) ) { logger . debug ( " L { } ▁ contains ▁ { } ▁ SSTables ▁ ( { } ▁ bytes ) ▁ in ▁ { } " , i , generations [ i ] . size ( ) , SSTableReader . getTotalBytes ( generations [ i ] ) , this ) ; } } } }
dukechain/Qassandra | @ VisibleForTesting public int remove ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level >= 0 : reader + " ▁ not ▁ present ▁ in ▁ manifest : ▁ " + level ; generations [ level ] . remove ( reader ) ; return level ; }
dukechain/Qassandra | private Collection < SSTableReader > getCandidatesFor ( int level ) { assert ! generations [ level ] . isEmpty ( ) ; logger . debug ( " Choosing ▁ candidates ▁ for ▁ L { } " , level ) ; final Set < SSTableReader > compacting = cfs . getDataTracker ( ) . getCompacting ( ) ; if ( level == 0 ) { Set < SSTableReader > candidates = new HashSet < SSTableReader > ( ) ; Set < SSTableReader > remaining = new HashSet < SSTableReader > ( ) ; Iterables . addAll ( remaining , Iterables . filter ( generations [ 0 ] , Predicates . not ( suspectP ) ) ) ; for ( SSTableReader sstable : ageSortedSSTables ( remaining ) ) { if ( candidates . contains ( sstable ) ) continue ; for ( SSTableReader newCandidate : Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , remaining ) ) ) { if ( ! compacting . contains ( newCandidate ) ) { candidates . add ( newCandidate ) ; remaining . remove ( newCandidate ) ; } } if ( candidates . size ( ) > MAX_COMPACTING_L0 ) { candidates = new HashSet < SSTableReader > ( ageSortedSSTables ( candidates ) . subList ( 0 , MAX_COMPACTING_L0 ) ) ; break ; } } if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) { candidates = Sets . union ( candidates , overlapping ( candidates , generations [ 1 ] ) ) ; Iterable < SSTableReader > compactingL0 = Iterables . filter ( generations [ 0 ] , Predicates . in ( compacting ) ) ; if ( ! Sets . intersection ( candidates , compacting ) . isEmpty ( ) || ! overlapping ( candidates , compactingL0 ) . isEmpty ( ) ) return Collections . emptyList ( ) ; } return candidates . size ( ) > 1 ? candidates : Collections . < SSTableReader > emptyList ( ) ; } Collections . sort ( generations [ level ] , SSTable . sstableComparator ) ; int start = 0 ; for ( int i = 0 ; i < generations [ level ] . size ( ) ; i ++ ) { SSTableReader sstable = generations [ level ] . get ( i ) ; if ( sstable . first . compareTo ( lastCompactedKeys [ level ] ) > 0 ) { start = i ; break ; } } for ( int i = 0 ; i < generations [ level ] . size ( ) ; i ++ ) { SSTableReader sstable = generations [ level ] . get ( ( start + i ) % generations [ level ] . size ( ) ) ; Set < SSTableReader > candidates = Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , generations [ level + 1 ] ) ) ; if ( Iterables . any ( candidates , suspectP ) ) continue ; if ( Sets . intersection ( candidates , compacting ) . isEmpty ( ) ) return candidates ; } return Collections . emptyList ( ) ; }
dukechain/Qassandra | private List < SSTableReader > ageSortedSSTables ( Collection < SSTableReader > candidates ) { List < SSTableReader > ageSortedCandidates = new ArrayList < SSTableReader > ( candidates ) ; Collections . sort ( ageSortedCandidates , SSTable . maxTimestampComparator ) ; return ageSortedCandidates ; }
dukechain/Qassandra | @ Override public String toString ( ) { return " Manifest @ " + hashCode ( ) ; }
dukechain/Qassandra | public int getLevelCount ( ) { for ( int i = generations . length - 1 ; i >= 0 ; i -- ) { if ( generations [ i ] . size ( ) > 0 ) return i ; } return 0 ; }
dukechain/Qassandra | public synchronized SortedSet < SSTableReader > getLevelSorted ( int level , Comparator < SSTableReader > comparator ) { return ImmutableSortedSet . copyOf ( comparator , generations [ level ] ) ; }
dukechain/Qassandra | public List < SSTableReader > getLevel ( int i ) { return generations [ i ] ; }
dukechain/Qassandra | public synchronized int getEstimatedTasks ( ) { long tasks = 0 ; long [ ] estimated = new long [ generations . length ] ; for ( int i = generations . length - 1 ; i >= 0 ; i -- ) { List < SSTableReader > sstables = generations [ i ] ; estimated [ i ] = Math . max ( 0L , SSTableReader . getTotalBytes ( sstables ) - maxBytesForLevel ( i ) ) / maxSSTableSizeInBytes ; tasks += estimated [ i ] ; } logger . debug ( " Estimating ▁ { } ▁ compactions ▁ to ▁ do ▁ for ▁ { } . { } " , Arrays . toString ( estimated ) , cfs . table . getName ( ) , cfs . name ) ; return Ints . checkedCast ( tasks ) ; }
dukechain/Qassandra | public int getNextLevel ( Collection < SSTableReader > sstables ) { int maximumLevel = Integer . MIN_VALUE ; int minimumLevel = Integer . MAX_VALUE ; for ( SSTableReader sstable : sstables ) { maximumLevel = Math . max ( sstable . getSSTableLevel ( ) , maximumLevel ) ; minimumLevel = Math . min ( sstable . getSSTableLevel ( ) , minimumLevel ) ; } int newLevel ; if ( minimumLevel == 0 && minimumLevel == maximumLevel && SSTable . getTotalBytes ( sstables ) < maxSSTableSizeInBytes ) { newLevel = 0 ; } else { newLevel = minimumLevel == maximumLevel ? maximumLevel + 1 : maximumLevel ; newLevel = skipLevels ( newLevel , sstables ) ; assert newLevel > 0 ; } return newLevel ; }
Bernardo-MG/Tabletop-Pendragon-Model | public DefaultPet ( final DefaultPet pet ) { super ( ) ; checkNotNull ( pet , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ pet " ) ; name = pet . name ; rolltable = pet . rolltable ; }
Bernardo-MG/Tabletop-Pendragon-Model | public DefaultPet ( final String name , final IntervalTable < AnimalYearResult > rolltable ) { super ( ) ; checkNotNull ( name , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ name " ) ; checkNotNull ( rolltable , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ roll ▁ table " ) ; this . name = name ; this . rolltable = rolltable ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final DefaultPet createNewInstance ( ) { return new DefaultPet ( this ) ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final boolean equals ( final Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; DefaultPet other = ( DefaultPet ) obj ; return Objects . equals ( name , other . name ) ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final IntervalTable < AnimalYearResult > getAnnualCheckMap ( ) { return rolltable ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final String getName ( ) { return name ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final int hashCode ( ) { return Objects . hashCode ( name ) ; }
Bernardo-MG/Tabletop-Pendragon-Model | @ Override public final String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " name " , name ) . toString ( ) ; }
GrandathePanda/MarioAIImplementation | private Tile ( String debug , int code , int ... zLevels ) { this . debug = debug ; this . code = code ; this . zLevels = zLevels ; }
GrandathePanda/MarioAIImplementation | public int getCode ( ) { return code ; }
GrandathePanda/MarioAIImplementation | public int [ ] getZLevels ( ) { return zLevels ; }
GrandathePanda/MarioAIImplementation | public boolean isZLevel ( int zLevel ) { for ( int level : zLevels ) { if ( zLevel == level ) return true ; } return false ; }
GrandathePanda/MarioAIImplementation | public String getDebug ( ) { return debug ; }
CodeSmell/camel | @ Test public void testConsume ( ) throws Exception { if ( ! canTest ( ) ) { return ; } context . addRoutes ( createRouteBuilder ( ) ) ; context . start ( ) ; Stomp stomp = createStompClient ( ) ; final BlockingConnection producerConnection = stomp . connectBlocking ( ) ; StompFrame frame = new StompFrame ( SEND ) ; frame . addHeader ( DESTINATION , StompFrame . encodeHeader ( " test " ) ) ; frame . addHeader ( MESSAGE_ID , StompFrame . encodeHeader ( " msg : 1" ) ) ; frame . content ( utf8 ( " Important ▁ Message ▁ 1" ) ) ; producerConnection . send ( frame ) ; MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 1 ) ; mock . message ( 0 ) . header ( " content - length " ) . isNull ( ) ; mock . await ( 5 , TimeUnit . SECONDS ) ; mock . assertIsSatisfied ( ) ; }
CodeSmell/camel | @ Override protected RouteBuilder createRouteBuilder ( ) { return new RouteBuilder ( ) { public void configure ( ) { fromF ( " stomp : test ? brokerURL = tcp : // localhost : % s & headerFilterStrategy = # customHeaderFilterStrategy " , getPort ( ) ) . transform ( body ( ) . convertToString ( ) ) . to ( " mock : result " ) ; } } ; }
CodeSmell/camel | ConsumerHeaderFilterStrategy ( ) { getInFilter ( ) . add ( " content - length " ) ; }
cit-lab/pinpoint | @ Override public List < AgentInfoBo > get ( String applicationName ) { List < AgentInfoBo > agentInfoList = new ArrayList < AgentInfoBo > ( ) ; long currentTime = System . currentTimeMillis ( ) ; Range range = new Range ( currentTime , currentTime ) ; SortedMap < String , List < AgentInfoBo > > applicationAgentList = agentInfoService . getApplicationAgentList ( applicationName , range ) ; for ( Map . Entry < String , List < AgentInfoBo > > entry : applicationAgentList . entrySet ( ) ) { AgentInfoBo agentInfo = ListUtils . getFirst ( entry . getValue ( ) , null ) ; ListUtils . addIfValueNotNull ( agentInfoList , agentInfo ) ; } return agentInfoList ; }
cit-lab/pinpoint | @ Override public Map < String , TActiveThreadResponse > getActiveThreadStatus ( List < AgentInfoBo > agentInfoList ) throws TException { byte [ ] activeThread = serialize ( new TActiveThread ( ) ) ; return getActiveThreadStatus ( agentInfoList , activeThread ) ; }
cit-lab/pinpoint | @ Override public Map < String , TActiveThreadResponse > getActiveThreadStatus ( List < AgentInfoBo > agentInfoList , byte [ ] payload ) throws TException { Map < String , Future < ResponseMessage > > futureMap = invoke ( agentInfoList , payload ) ; Map < String , TActiveThreadResponse > responseMap = new HashMap < String , TActiveThreadResponse > ( ) ; for ( Map . Entry < String , Future < ResponseMessage > > futureEntry : futureMap . entrySet ( ) ) { String hostName = futureEntry . getKey ( ) ; Future < ResponseMessage > future = futureEntry . getValue ( ) ; future . await ( ) ; ResponseMessage responseMessage = future . getResult ( ) ; TBase result = deserialize ( responseMessage . getMessage ( ) ) ; if ( result instanceof TActiveThreadResponse ) { responseMap . put ( hostName , ( TActiveThreadResponse ) result ) ; } } return responseMap ; }
cit-lab/pinpoint | private Map < String , Future < ResponseMessage > > invoke ( List < AgentInfoBo > agentInfoList , byte [ ] payload ) throws TException { Map < String , Future < ResponseMessage > > futureMap = new HashMap < String , Future < ResponseMessage > > ( ) ; for ( AgentInfoBo agentInfo : agentInfoList ) { TCommandTransfer transferObject = createCommandTransferObject ( agentInfo , payload ) ; PinpointServer collector = pinpointSocketManager . getCollector ( agentInfo ) ; Future < ResponseMessage > future = collector . request ( serialize ( transferObject ) ) ; futureMap . put ( agentInfo . getHostName ( ) , future ) ; } return futureMap ; }
cit-lab/pinpoint | private byte [ ] serialize ( TBase tBase ) throws TException { return SerializationUtils . serialize ( tBase , commandSerializerFactory ) ; }
cit-lab/pinpoint | private TBase deserialize ( byte [ ] objectData ) throws TException { return SerializationUtils . deserialize ( objectData , commandDeserializerFactory ) ; }
cit-lab/pinpoint | private TCommandTransfer createCommandTransferObject ( AgentInfoBo agentInfo , byte [ ] payload ) { TCommandTransfer transferObject = new TCommandTransfer ( ) ; transferObject . setApplicationName ( agentInfo . getApplicationName ( ) ) ; transferObject . setAgentId ( agentInfo . getAgentId ( ) ) ; transferObject . setStartTime ( agentInfo . getStartTime ( ) ) ; transferObject . setPayload ( payload ) ; return transferObject ; }
OkBuilds/OkBuck | @ Before public void setUp ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; builder = new TransformInvocationBuilder ( ) ; }
OkBuilds/OkBuck | @ Test public void addInput_shouldAddAnInput ( ) throws Exception { TransformInvocation invocation = builder . addInput ( transformInput ) . setOutputProvider ( outputProvider ) . build ( ) ; assertThat ( invocation . getInputs ( ) ) . containsExactly ( transformInput ) ; assertThat ( invocation . getReferencedInputs ( ) ) . isEmpty ( ) ; assertThat ( invocation . getOutputProvider ( ) ) . isEqualTo ( outputProvider ) ; }
OkBuilds/OkBuck | @ Test public void addReferencedInput_shouldAddReferencedInput ( ) throws Exception { TransformInvocation invocation = builder . addReferencedInput ( transformInput ) . setOutputProvider ( outputProvider ) . build ( ) ; assertThat ( invocation . getInputs ( ) ) . isEmpty ( ) ; assertThat ( invocation . getReferencedInputs ( ) ) . containsExactly ( transformInput ) ; assertThat ( invocation . getOutputProvider ( ) ) . isEqualTo ( outputProvider ) ; }
OkBuilds/OkBuck | @ Test ( expected = IllegalArgumentException . class ) public void whenOutputProviderNotSet_shouldThrowException ( ) throws Exception { builder . build ( ) ; }
aesteve/nubes | @ Override public Vertx resolve ( RoutingContext context ) { return context . vertx ( ) ; }
nmorel/gwt-jackson-rest | RestRequestCallback ( ObjectReader < R > responseConverter , RestCallback < R > callback ) { this . responseConverter = responseConverter ; this . callback = callback ; }
nmorel/gwt-jackson-rest | @ Override public void onResponseReceived ( Request request , Response response ) { if ( isSuccessStatusCode ( response ) ) { if ( null != callback ) { R result ; if ( null != responseConverter && null != response . getText ( ) && ! response . getText ( ) . isEmpty ( ) ) { try { result = responseConverter . read ( response . getText ( ) ) ; } catch ( Exception e ) { onError ( request , e ) ; return ; } } else { result = null ; } callback . onSuccess ( response , result ) ; } } else { if ( null != callback ) { callback . onError ( response ) ; } else { throw new RestException ( " An ▁ error ▁ occured . ▁ Status ▁ : ▁ " + response . getStatusCode ( ) ) ; } } }
nmorel/gwt-jackson-rest | private boolean isSuccessStatusCode ( Response response ) { int statusCode = response . getStatusCode ( ) ; return ( statusCode >= 200 && statusCode < 300 ) || statusCode == 304 ; }
nmorel/gwt-jackson-rest | @ Override public void onError ( Request request , Throwable exception ) { if ( null == callback ) { throw new RestException ( exception ) ; } else { callback . onFailure ( exception ) ; } }
virajsenevirathne/wso2-commons-vfs | private FtpsClientFactory ( ) { }
Esri/spatial-framework-for-hadoop | public GeometryJsonDeserializer ( ) { }
yangalex930/Tunnel | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; requestWindowFeature ( Window . FEATURE_NO_TITLE ) ; setContentView ( R . layout . image_mark ) ; imageView = ( MarkImageView ) findViewById ( R . id . imageView ) ; Bitmap bitmap = null ; final String imagePath = getIntent ( ) . getStringExtra ( " ImagePath " ) ; bitmap = BitmapFactory . decodeFile ( imagePath ) ; final Rect rect = getIntent ( ) . getParcelableExtra ( " Rect " ) ; if ( rect != null ) { bmpCropping = Bitmap . createBitmap ( bitmap , rect . left , rect . top , rect . width ( ) , rect . height ( ) ) ; Toast . makeText ( this , R . string . notify_select_start , Toast . LENGTH_SHORT ) . show ( ) ; } final MeasureInfo mi = getIntent ( ) . getParcelableExtra ( " MeasureInfo " ) ; if ( mi != null ) { bmpCropping = Bitmap . createBitmap ( bitmap , mi . cropRect . left , mi . cropRect . top , mi . cropRect . width ( ) , mi . cropRect . height ( ) ) ; imageView . setMarkRect ( mi . markRect ) ; Toast . makeText ( ImageMarkActivity . this , String . format ( getString ( R . string . notify_slope ) , mi . slope ) , Toast . LENGTH_SHORT ) . show ( ) ; } bitmap . recycle ( ) ; imageView . setImageBitmap ( bmpCropping ) ; imageView . setOnMarkListener ( new MarkImageView . onMarkListener ( ) { @ Override public void onMarkStart ( ) { Toast . makeText ( ImageMarkActivity . this , R . string . notify_select_end , Toast . LENGTH_SHORT ) . show ( ) ; } @ Override public void onMarkFinish ( ) { if ( ! GlobalSwitch . bCorrectionMode ) { Toast . makeText ( ImageMarkActivity . this , String . format ( getString ( R . string . notify_slope ) , ( int ) imageView . getSlopeRate ( ) ) , Toast . LENGTH_SHORT ) . show ( ) ; } else { Toast . makeText ( ImageMarkActivity . this , String . format ( getString ( R . string . notify_degree_diff ) , imageView . getDegreeDiff ( ) ) , Toast . LENGTH_LONG ) . show ( ) ; } } } ) ; ImageButton cancel = ( ImageButton ) findViewById ( R . id . cancel ) ; cancel . setVisibility ( View . VISIBLE ) ; cancel . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { finish ( ) ; } } ) ; findViewById ( R . id . textView1 ) . setVisibility ( View . VISIBLE ) ; ImageButton ok = ( ImageButton ) findViewById ( R . id . ok ) ; ok . setVisibility ( View . VISIBLE ) ; ok . setEnabled ( mi == null ) ; ok . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( ! imageView . isMarkFinished ( ) ) { return ; } String msg ; if ( ! GlobalSwitch . bCorrectionMode ) { msg = String . format ( getString ( R . string . save_result ) , imageView . getSlopeRate ( ) ) ; } else { msg = String . format ( getString ( R . string . save_correct_result ) , imageView . getDegreeDiff ( ) ) ; } new AlertDialog . Builder ( ImageMarkActivity . this ) . setTitle ( R . string . notification ) . setMessage ( msg ) . setNegativeButton ( getString ( R . string . ok ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { if ( ! GlobalSwitch . bCorrectionMode ) { String cacheImage = BitmapUtil . renameBitmapCache ( imagePath ) ; if ( cacheImage != null ) { ExifUtil . saveMeasureInfo ( cacheImage , rect , imageView . getMarkRect ( ) , imageView . getSlopeRate ( ) ) ; } else { Toast . makeText ( ImageMarkActivity . this , R . string . save_failure , Toast . LENGTH_LONG ) . show ( ) ; } } else { Orientation . putCorrection ( imageView . getDegreeDiff ( ) ) ; } Class < ? extends Activity > cls ; if ( GlobalSwitch . bCorrectionMode ) { GlobalSwitch . bCorrectionMode = false ; cls = MainActivity . class ; } else if ( GlobalSwitch . bOpenFromCapture ) { cls = ImageCaptureActivity . class ; } else { GlobalSwitch . bOpenFromCapture = true ; cls = ImageGridActivity . class ; } Intent intent = new Intent ( ImageMarkActivity . this , cls ) ; intent . setFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivity ( intent ) ; } } ) . setPositiveButton ( getString ( R . string . cancel ) , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { } } ) . create ( ) . show ( ) ; } } ) ; findViewById ( R . id . textView3 ) . setVisibility ( View . VISIBLE ) ; ImageButton clear = ( ImageButton ) findViewById ( R . id . mid ) ; clear . setVisibility ( View . VISIBLE ) ; clear . setEnabled ( mi == null ) ; clear . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { imageView . reset ( ) ; } } ) ; findViewById ( R . id . textView2 ) . setVisibility ( View . VISIBLE ) ; }
k24/retrofit-promise-qiita4jv2 | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Comment comment = ( Comment ) o ; if ( ! created_at . equals ( comment . created_at ) ) return false ; if ( ! id . equals ( comment . id ) ) return false ; if ( ! rendered_body . equals ( comment . rendered_body ) ) return false ; if ( ! updated_at . equals ( comment . updated_at ) ) return false ; return user != null ? user . equals ( comment . user ) : comment . user == null ; }
k24/retrofit-promise-qiita4jv2 | @ Override public int hashCode ( ) { int result = created_at . hashCode ( ) ; result = 31 * result + id . hashCode ( ) ; result = 31 * result + rendered_body . hashCode ( ) ; result = 31 * result + updated_at . hashCode ( ) ; result = 31 * result + ( user != null ? user . hashCode ( ) : 0 ) ; return result ; }
k24/retrofit-promise-qiita4jv2 | @ Override public String toString ( ) { return " Comment { " + " created _ at = ' " + created_at + ' \' ' + " , ▁ id = ' " + id + ' \' ' + " , ▁ rendered _ body = ' " + rendered_body + ' \' ' + " , ▁ updated _ at = ' " + updated_at + ' \' ' + " , ▁ user = " + user + " } ▁ " + super . toString ( ) ; }
ButterflyNetwork/bazel | FlowStatement ( FileLocations locs , TokenKind kind , int offset ) { super ( locs ) ; this . kind = kind ; this . offset = offset ; }
ButterflyNetwork/bazel | public TokenKind getKind ( ) { return kind ; }
ButterflyNetwork/bazel | @ Override public String toString ( ) { return kind . toString ( ) + " \n " ; }
ButterflyNetwork/bazel | @ Override public int getStartOffset ( ) { return offset ; }
ButterflyNetwork/bazel | @ Override public int getEndOffset ( ) { return offset + kind . toString ( ) . length ( ) ; }
ButterflyNetwork/bazel | @ Override public void accept ( NodeVisitor visitor ) { visitor . visit ( this ) ; }
ButterflyNetwork/bazel | @ Override public Statement . Kind kind ( ) { return Statement . Kind . FLOW ; }
leechoongyon/HadoopSourceAnalyze | private void writeFile ( FileSystem fileSys , Path name , int repl ) throws IOException { FSDataOutputStream stm = fileSys . create ( name , true , fileSys . getConf ( ) . getInt ( CommonConfigurationKeys . IO_FILE_BUFFER_SIZE_KEY , 4096 ) , ( short ) repl , blockSize ) ; byte [ ] buffer = new byte [ fileSize ] ; Random rand = new Random ( seed ) ; rand . nextBytes ( buffer ) ; stm . write ( buffer ) ; stm . close ( ) ; }
leechoongyon/HadoopSourceAnalyze | private void checkFile ( FileSystem fileSys , Path name , int repl ) throws IOException { Configuration conf = fileSys . getConf ( ) ; ClientProtocol namenode = NameNodeProxies . createProxy ( conf , fileSys . getUri ( ) , ClientProtocol . class ) . getProxy ( ) ; waitForBlockReplication ( name . toString ( ) , namenode , Math . min ( numDatanodes , repl ) , - 1 ) ; LocatedBlocks locations = namenode . getBlockLocations ( name . toString ( ) , 0 , Long . MAX_VALUE ) ; FileStatus stat = fileSys . getFileStatus ( name ) ; BlockLocation [ ] blockLocations = fileSys . getFileBlockLocations ( stat , 0L , Long . MAX_VALUE ) ; assertTrue ( blockLocations . length == locations . locatedBlockCount ( ) ) ; for ( int i = 0 ; i < blockLocations . length ; i ++ ) { LocatedBlock blk = locations . get ( i ) ; DatanodeInfo [ ] datanodes = blk . getLocations ( ) ; String [ ] topologyPaths = blockLocations [ i ] . getTopologyPaths ( ) ; assertTrue ( topologyPaths . length == datanodes . length ) ; for ( int j = 0 ; j < topologyPaths . length ; j ++ ) { boolean found = false ; for ( int k = 0 ; k < racks . length ; k ++ ) { if ( topologyPaths [ j ] . startsWith ( racks [ k ] ) ) { found = true ; break ; } } assertTrue ( found ) ; } } boolean isOnSameRack = true , isNotOnSameRack = true ; for ( LocatedBlock blk : locations . getLocatedBlocks ( ) ) { DatanodeInfo [ ] datanodes = blk . getLocations ( ) ; if ( datanodes . length <= 1 ) break ; if ( datanodes . length == 2 ) { isNotOnSameRack = ! ( datanodes [ 0 ] . getNetworkLocation ( ) . equals ( datanodes [ 1 ] . getNetworkLocation ( ) ) ) ; break ; } isOnSameRack = false ; isNotOnSameRack = false ; for ( int i = 0 ; i < datanodes . length - 1 ; i ++ ) { LOG . info ( " datanode ▁ " + i + " : ▁ " + datanodes [ i ] ) ; boolean onRack = false ; for ( int j = i + 1 ; j < datanodes . length ; j ++ ) { if ( datanodes [ i ] . getNetworkLocation ( ) . equals ( datanodes [ j ] . getNetworkLocation ( ) ) ) { onRack = true ; } } if ( onRack ) { isOnSameRack = true ; } if ( ! onRack ) { isNotOnSameRack = true ; } if ( isOnSameRack && isNotOnSameRack ) break ; } if ( ! isOnSameRack || ! isNotOnSameRack ) break ; } assertTrue ( isOnSameRack ) ; assertTrue ( isNotOnSameRack ) ; }
leechoongyon/HadoopSourceAnalyze | private void cleanupFile ( FileSystem fileSys , Path name ) throws IOException { assertTrue ( fileSys . exists ( name ) ) ; fileSys . delete ( name , true ) ; assertTrue ( ! fileSys . exists ( name ) ) ; }
leechoongyon/HadoopSourceAnalyze | private void testBadBlockReportOnTransfer ( boolean corruptBlockByDeletingBlockFile ) throws Exception { Configuration conf = new HdfsConfiguration ( ) ; FileSystem fs = null ; DFSClient dfsClient = null ; LocatedBlocks blocks = null ; int replicaCount = 0 ; short replFactor = 1 ; MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 2 ) . build ( ) ; cluster . waitActive ( ) ; fs = cluster . getFileSystem ( ) ; dfsClient = new DFSClient ( new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) , conf ) ; Path file1 = new Path ( " / tmp / testBadBlockReportOnTransfer / file1" ) ; DFSTestUtil . createFile ( fs , file1 , 1024 , replFactor , 0 ) ; DFSTestUtil . waitReplication ( fs , file1 , replFactor ) ; ExtendedBlock block = DFSTestUtil . getFirstBlock ( fs , file1 ) ; int blockFilesCorrupted = corruptBlockByDeletingBlockFile ? cluster . corruptBlockOnDataNodesByDeletingBlockFile ( block ) : cluster . corruptBlockOnDataNodes ( block ) ; assertEquals ( " Corrupted ▁ too ▁ few ▁ blocks " , replFactor , blockFilesCorrupted ) ; replFactor = 2 ; fs . setReplication ( file1 , replFactor ) ; blocks = dfsClient . getNamenode ( ) . getBlockLocations ( file1 . toString ( ) , 0 , Long . MAX_VALUE ) ; while ( blocks . get ( 0 ) . isCorrupt ( ) != true ) { try { LOG . info ( " Waiting ▁ until ▁ block ▁ is ▁ marked ▁ as ▁ corrupt . . . " ) ; Thread . sleep ( 1000 ) ; } catch ( InterruptedException ie ) { } blocks = dfsClient . getNamenode ( ) . getBlockLocations ( file1 . toString ( ) , 0 , Long . MAX_VALUE ) ; } replicaCount = blocks . get ( 0 ) . getLocations ( ) . length ; assertTrue ( replicaCount == 1 ) ; cluster . shutdown ( ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test public void testBadBlockReportOnTransfer ( ) throws Exception { testBadBlockReportOnTransfer ( false ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test public void testBadBlockReportOnTransferMissingBlockFile ( ) throws Exception { testBadBlockReportOnTransfer ( true ) ; }
leechoongyon/HadoopSourceAnalyze | public void runReplication ( boolean simulated ) throws IOException { Configuration conf = new HdfsConfiguration ( ) ; conf . setBoolean ( DFSConfigKeys . DFS_NAMENODE_REPLICATION_CONSIDERLOAD_KEY , false ) ; if ( simulated ) { SimulatedFSDataset . setFactory ( conf ) ; } MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDatanodes ) . racks ( racks ) . build ( ) ; cluster . waitActive ( ) ; InetSocketAddress addr = new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) ; DFSClient client = new DFSClient ( addr , conf ) ; DatanodeInfo [ ] info = client . datanodeReport ( DatanodeReportType . LIVE ) ; assertEquals ( " Number ▁ of ▁ Datanodes ▁ " , numDatanodes , info . length ) ; FileSystem fileSys = cluster . getFileSystem ( ) ; try { Path file1 = new Path ( " / smallblocktest . dat " ) ; writeFile ( fileSys , file1 , 3 ) ; checkFile ( fileSys , file1 , 3 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 10 ) ; checkFile ( fileSys , file1 , 10 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 4 ) ; checkFile ( fileSys , file1 , 4 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 1 ) ; checkFile ( fileSys , file1 , 1 ) ; cleanupFile ( fileSys , file1 ) ; writeFile ( fileSys , file1 , 2 ) ; checkFile ( fileSys , file1 , 2 ) ; cleanupFile ( fileSys , file1 ) ; } finally { fileSys . close ( ) ; cluster . shutdown ( ) ; } }
leechoongyon/HadoopSourceAnalyze | @ Test public void testReplicationSimulatedStorag ( ) throws IOException { runReplication ( true ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test public void testReplication ( ) throws IOException { runReplication ( false ) ; }
leechoongyon/HadoopSourceAnalyze | private void waitForBlockReplication ( String filename , ClientProtocol namenode , int expected , long maxWaitSec ) throws IOException { waitForBlockReplication ( filename , namenode , expected , maxWaitSec , false , false ) ; }
leechoongyon/HadoopSourceAnalyze | private void waitForBlockReplication ( String filename , ClientProtocol namenode , int expected , long maxWaitSec , boolean isUnderConstruction , boolean noOverReplication ) throws IOException { long start = Time . monotonicNow ( ) ; LOG . info ( " Checking ▁ for ▁ block ▁ replication ▁ for ▁ " + filename ) ; while ( true ) { boolean replOk = true ; LocatedBlocks blocks = namenode . getBlockLocations ( filename , 0 , Long . MAX_VALUE ) ; for ( Iterator < LocatedBlock > iter = blocks . getLocatedBlocks ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { LocatedBlock block = iter . next ( ) ; if ( isUnderConstruction && ! iter . hasNext ( ) ) { break ; } int actual = block . getLocations ( ) . length ; if ( noOverReplication ) { assertTrue ( actual <= expected ) ; } if ( actual < expected ) { LOG . info ( " Not ▁ enough ▁ replicas ▁ for ▁ " + block . getBlock ( ) + " ▁ yet . ▁ Expecting ▁ " + expected + " , ▁ got ▁ " + actual + " . " ) ; replOk = false ; break ; } } if ( replOk ) { return ; } if ( maxWaitSec > 0 && ( Time . monotonicNow ( ) - start ) > ( maxWaitSec * 1000 ) ) { throw new IOException ( " Timedout ▁ while ▁ waiting ▁ for ▁ all ▁ blocks ▁ to ▁ " + " ▁ be ▁ replicated ▁ for ▁ " + filename ) ; } try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ignored ) { } } }
leechoongyon/HadoopSourceAnalyze | @ Test public void testPendingReplicationRetry ( ) throws IOException { MiniDFSCluster cluster = null ; int numDataNodes = 4 ; String testFile = " / replication - test - file " ; Path testPath = new Path ( testFile ) ; byte buffer [ ] = new byte [ 1024 ] ; for ( int i = 0 ; i < buffer . length ; i ++ ) { buffer [ i ] = '1' ; } try { Configuration conf = new HdfsConfiguration ( ) ; conf . set ( DFSConfigKeys . DFS_REPLICATION_KEY , Integer . toString ( numDataNodes ) ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes ) . build ( ) ; cluster . waitActive ( ) ; DFSClient dfsClient = new DFSClient ( new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) , conf ) ; OutputStream out = cluster . getFileSystem ( ) . create ( testPath ) ; out . write ( buffer ) ; out . close ( ) ; waitForBlockReplication ( testFile , dfsClient . getNamenode ( ) , numDataNodes , - 1 ) ; ExtendedBlock block = dfsClient . getNamenode ( ) . getBlockLocations ( testFile , 0 , Long . MAX_VALUE ) . get ( 0 ) . getBlock ( ) ; List < MaterializedReplica > replicas = new ArrayList < > ( ) ; for ( int dnIndex = 0 ; dnIndex < 3 ; dnIndex ++ ) { replicas . add ( cluster . getMaterializedReplica ( dnIndex , block ) ) ; } assertEquals ( 3 , replicas . size ( ) ) ; cluster . shutdown ( ) ; int fileCount = 0 ; for ( MaterializedReplica replica : replicas ) { if ( fileCount == 0 ) { LOG . info ( " Deleting ▁ block ▁ " + replica ) ; replica . deleteData ( ) ; } else { LOG . info ( " Corrupting ▁ file ▁ " + replica ) ; replica . corruptData ( ) ; } fileCount ++ ; } LOG . info ( " Restarting ▁ minicluster ▁ after ▁ deleting ▁ a ▁ replica ▁ and ▁ corrupting ▁ 2 ▁ crcs " ) ; conf = new HdfsConfiguration ( ) ; conf . set ( DFSConfigKeys . DFS_REPLICATION_KEY , Integer . toString ( numDataNodes ) ) ; conf . set ( DFSConfigKeys . DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY , Integer . toString ( 2 ) ) ; conf . set ( " dfs . datanode . block . write . timeout . sec " , Integer . toString ( 5 ) ) ; conf . set ( DFSConfigKeys . DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY , "0.75f " ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes * 2 ) . format ( false ) . build ( ) ; cluster . waitActive ( ) ; dfsClient = new DFSClient ( new InetSocketAddress ( " localhost " , cluster . getNameNodePort ( ) ) , conf ) ; waitForBlockReplication ( testFile , dfsClient . getNamenode ( ) , numDataNodes , - 1 ) ; } finally { if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | @ Test public void testReplicateLenMismatchedBlock ( ) throws Exception { MiniDFSCluster cluster = new MiniDFSCluster . Builder ( new HdfsConfiguration ( ) ) . numDataNodes ( 2 ) . build ( ) ; try { cluster . waitActive ( ) ; changeBlockLen ( cluster , - 1 ) ; changeBlockLen ( cluster , 1 ) ; } finally { cluster . shutdown ( ) ; } }
leechoongyon/HadoopSourceAnalyze | i ++ ) { if ( DFSTestUtil . changeReplicaLength ( cluster , block , i , lenDelta ) ) { break ; } }
leechoongyon/HadoopSourceAnalyze | if ( lenDelta < 0 ) { while ( ! blocks . get ( 0 ) . isCorrupt ( ) || REPLICATION_FACTOR != blocks . get ( 0 ) . getLocations ( ) . length ) { Thread . sleep ( 100 ) ; blocks = dfsClient . getNamenode ( ) . getBlockLocations ( fileName . toString ( ) , 0 , fileLen ) ; } }
leechoongyon/HadoopSourceAnalyze | while ( REPLICATION_FACTOR + 1 != blocks . get ( 0 ) . getLocations ( ) . length ) { Thread . sleep ( 100 ) ; blocks = dfsClient . getNamenode ( ) . getBlockLocations ( fileName . toString ( ) , 0 , fileLen ) ; }
leechoongyon/HadoopSourceAnalyze | @ Test ( timeout = 30000 ) public void testReplicationWhenBlockCorruption ( ) throws Exception { MiniDFSCluster cluster = null ; try { Configuration conf = new HdfsConfiguration ( ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_REPLICATION_PENDING_TIMEOUT_SEC_KEY , 1 ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 3 ) . storagesPerDatanode ( 1 ) . build ( ) ; FileSystem fs = cluster . getFileSystem ( ) ; Path filePath = new Path ( " / test " ) ; FSDataOutputStream create = fs . create ( filePath ) ; fs . setReplication ( filePath , ( short ) 1 ) ; create . write ( new byte [ 1024 ] ) ; create . close ( ) ; ExtendedBlock block = DFSTestUtil . getFirstBlock ( fs , filePath ) ; int numReplicaCreated = 0 ; for ( final DataNode dn : cluster . getDataNodes ( ) ) { if ( ! dn . getFSDataset ( ) . contains ( block ) ) { cluster . getFsDatasetTestUtils ( dn ) . injectCorruptReplica ( block ) ; numReplicaCreated ++ ; } } assertEquals ( 2 , numReplicaCreated ) ; fs . setReplication ( filePath , ( short ) 3 ) ; cluster . restartDataNodes ( ) ; cluster . waitActive ( ) ; cluster . triggerBlockReports ( ) ; DFSTestUtil . waitReplication ( fs , filePath , ( short ) 3 ) ; } finally { if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | @ Test ( timeout = 60000 ) public void testNoExtraReplicationWhenBlockReceivedIsLate ( ) throws Exception { LOG . info ( " Test ▁ block ▁ replication ▁ when ▁ blockReceived ▁ is ▁ late " ) ; final short numDataNodes = 3 ; final short replication = 3 ; final Configuration conf = new Configuration ( ) ; conf . setInt ( DFSConfigKeys . DFS_BLOCK_SIZE_KEY , 1024 ) ; final MiniDFSCluster cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes ) . build ( ) ; final String testFile = " / replication - test - file " ; final Path testPath = new Path ( testFile ) ; final BlockManager bm = cluster . getNameNode ( ) . getNamesystem ( ) . getBlockManager ( ) ; try { cluster . waitActive ( ) ; NameNode nn = cluster . getNameNode ( ) ; DataNode dn = cluster . getDataNodes ( ) . get ( 0 ) ; DatanodeProtocolClientSideTranslatorPB spy = InternalDataNodeTestUtils . spyOnBposToNN ( dn , nn ) ; DelayAnswer delayer = new GenericTestUtils . DelayAnswer ( LOG ) ; Mockito . doAnswer ( delayer ) . when ( spy ) . blockReceivedAndDeleted ( Mockito . < DatanodeRegistration > anyObject ( ) , Mockito . anyString ( ) , Mockito . < StorageReceivedDeletedBlocks [ ] > anyObject ( ) ) ; FileSystem fs = cluster . getFileSystem ( ) ; DFSTestUtil . createFile ( fs , testPath , 1500 , replication , 0 ) ; BlockManagerTestUtil . computeAllPendingWork ( bm ) ; assertTrue ( pendingReplicationCount ( bm ) > 0 ) ; delayer . waitForCall ( ) ; delayer . proceed ( ) ; delayer . waitForResult ( ) ; for ( DataNode d : cluster . getDataNodes ( ) ) { DataNodeTestUtils . triggerHeartbeat ( d ) ; } try { GenericTestUtils . waitFor ( new Supplier < Boolean > ( ) { @ Override public Boolean get ( ) { return pendingReplicationCount ( bm ) == 0 ; } } , 100 , 3000 ) ; } catch ( TimeoutException e ) { fail ( " timed ▁ out ▁ while ▁ waiting ▁ for ▁ no ▁ pending ▁ replication . " ) ; } assertNoReplicationWasPerformed ( cluster ) ; } finally { if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | @ Test ( timeout = 60000 ) public void testReplicationWhileUnderConstruction ( ) throws Exception { LOG . info ( " Test ▁ block ▁ replication ▁ in ▁ under ▁ construction " ) ; MiniDFSCluster cluster = null ; final short numDataNodes = 6 ; final short replication = 3 ; String testFile = " / replication - test - file " ; Path testPath = new Path ( testFile ) ; FSDataOutputStream stm = null ; try { Configuration conf = new Configuration ( ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( numDataNodes ) . build ( ) ; cluster . waitActive ( ) ; FileSystem fs = cluster . getFileSystem ( ) ; stm = AppendTestUtil . createFile ( fs , testPath , replication ) ; byte [ ] buffer = AppendTestUtil . initBuffer ( AppendTestUtil . BLOCK_SIZE ) ; stm . write ( buffer ) ; stm . write ( buffer ) ; stm . write ( buffer , 0 , 1 ) ; stm . hflush ( ) ; waitForBlockReplication ( testFile , cluster . getNameNodeRpc ( ) , replication , 30000 , true , true ) ; assertNoReplicationWasPerformed ( cluster ) ; List < LocatedBlock > blocks ; FSDataInputStream in = fs . open ( testPath ) ; try { blocks = DFSTestUtil . getAllBlocks ( in ) ; } finally { in . close ( ) ; } LocatedBlock lb = blocks . get ( 0 ) ; LocatedBlock lbOneReplica = new LocatedBlock ( lb . getBlock ( ) , new DatanodeInfo [ ] { lb . getLocations ( ) [ 0 ] } ) ; cluster . getNameNodeRpc ( ) . reportBadBlocks ( new LocatedBlock [ ] { lbOneReplica } ) ; waitForBlockReplication ( testFile , cluster . getNameNodeRpc ( ) , replication , 30000 , true , true ) ; } finally { if ( stm != null ) { IOUtils . closeStream ( stm ) ; } if ( cluster != null ) { cluster . shutdown ( ) ; } } }
leechoongyon/HadoopSourceAnalyze | private long pendingReplicationCount ( BlockManager bm ) { BlockManagerTestUtil . updateState ( bm ) ; return bm . getPendingReplicationBlocksCount ( ) ; }
leechoongyon/HadoopSourceAnalyze | private void assertNoReplicationWasPerformed ( MiniDFSCluster cluster ) { for ( DataNode dn : cluster . getDataNodes ( ) ) { MetricsRecordBuilder rb = getMetrics ( dn . getMetrics ( ) . name ( ) ) ; assertCounter ( " BlocksReplicated " , 0L , rb ) ; } }
marcelstoer/open-data-smn | public SmnHealthCheck ( GeoAdmin geoAdmin ) { this . geoAdmin = geoAdmin ; }
marcelstoer/open-data-smn | @ Override protected Result check ( ) throws IOException { if ( geoAdmin . getSmnData ( ) . getAllRecords ( ) . size ( ) > 0 ) { return Result . healthy ( ) ; } else { return Result . unhealthy ( " No ▁ SMN ▁ data ▁ available . " ) ; } }
ddebrunner/quarks | protected AbstractGraphJob ( ) { this . currentState = State . CONSTRUCTED ; this . nextState = currentState ; }
ddebrunner/quarks | @ Override public synchronized State getCurrentState ( ) { return currentState ; }
ddebrunner/quarks | @ Override public synchronized State getNextState ( ) { return nextState ; }
ddebrunner/quarks | protected synchronized boolean inTransition ( ) { return getNextState ( ) != getCurrentState ( ) ; }
ddebrunner/quarks | protected synchronized void setNextState ( State value ) { this . nextState = value ; }
ddebrunner/quarks | protected synchronized void completeTransition ( ) { if ( inTransition ( ) ) { currentState = nextState ; } }
jlyw/babel-app | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_onboarding ) ; run ( ) ; }
jlyw/babel-app | private void addBottomDots ( int currentPage ) { dots = new TextView [ layouts . length ] ; dotsLayout . removeAllViews ( ) ; for ( int i = 0 ; i < dots . length ; i ++ ) { dots [ i ] = new TextView ( this ) ; dots [ i ] . setText ( Html . fromHtml ( " & #8226 ; " ) ) ; dots [ i ] . setTextSize ( 35 ) ; dots [ i ] . setTextColor ( Color . parseColor ( " # FFFFFF " ) ) ; dotsLayout . addView ( dots [ i ] ) ; } if ( dots . length > 0 ) dots [ currentPage ] . setTextColor ( Color . parseColor ( " # 8e3d3f " ) ) ; }
jlyw/babel-app | private int getItem ( int i ) { return viewPager . getCurrentItem ( ) + i ; }
jlyw/babel-app | private void launchHomeScreen ( ) { startActivity ( new Intent ( OnboardingActivity . this , MainActivity . class ) ) ; finish ( ) ; }
jlyw/babel-app | ViewPager . OnPageChangeListener viewPagerPageChangeListener = new ViewPager . OnPageChangeListener ( ) { @ Override public void onPageSelected ( int position ) { addBottomDots ( position ) ; if ( position == layouts . length - 1 ) { btnNext . setText ( getString ( R . string . start ) ) ; btnSkip . setVisibility ( View . GONE ) ; } else { btnNext . setText ( getString ( R . string . next ) ) ; btnSkip . setVisibility ( View . VISIBLE ) ; } } @ Override public void onPageScrolled ( int arg0 , float arg1 , int arg2 ) { } @ Override public void onPageScrollStateChanged ( int arg0 ) { } }
jlyw/babel-app | private void changeStatusBarColor ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { Window window = getWindow ( ) ; window . addFlags ( WindowManager . LayoutParams . FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS ) ; window . setStatusBarColor ( Color . TRANSPARENT ) ; } }
jlyw/babel-app | @ Override public void run ( ) { android . os . Process . setThreadPriority ( android . os . Process . THREAD_PRIORITY_BACKGROUND ) ; if ( Build . VERSION . SDK_INT >= 21 ) { getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LAYOUT_STABLE | View . SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN ) ; } viewPager = ( ViewPager ) findViewById ( R . id . view_pager ) ; dotsLayout = ( LinearLayout ) findViewById ( R . id . layoutDots ) ; btnSkip = ( Button ) findViewById ( R . id . btn_skip ) ; btnNext = ( Button ) findViewById ( R . id . btn_next ) ; layouts = new int [ ] { R . layout . onboarding_slide_1 , R . layout . onboarding_slide_2 , R . layout . onboarding_slide_3 , R . layout . onboarding_slide_4 } ; addBottomDots ( 0 ) ; changeStatusBarColor ( ) ; myViewPagerAdapter = new MyViewPagerAdapter ( ) ; viewPager . setAdapter ( myViewPagerAdapter ) ; viewPager . addOnPageChangeListener ( viewPagerPageChangeListener ) ; btnSkip . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { launchHomeScreen ( ) ; } } ) ; btnNext . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { int current = getItem ( + 1 ) ; if ( current < layouts . length ) { viewPager . setCurrentItem ( current ) ; } else { launchHomeScreen ( ) ; } } } ) ; }
jlyw/babel-app | public MyViewPagerAdapter ( ) { }
jlyw/babel-app | @ Override public Object instantiateItem ( ViewGroup container , int position ) { layoutInflater = ( LayoutInflater ) getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; View view = layoutInflater . inflate ( layouts [ position ] , container , false ) ; container . addView ( view ) ; return view ; }
jlyw/babel-app | @ Override public int getCount ( ) { return layouts . length ; }
jlyw/babel-app | @ Override public boolean isViewFromObject ( View view , Object obj ) { return view == obj ; }
jlyw/babel-app | @ Override public void destroyItem ( ViewGroup container , int position , Object object ) { View view = ( View ) object ; container . removeView ( view ) ; }
Stratio/cassandra | protected SchemaAlteringStatement ( ) { super ( null ) ; this . isColumnFamilyLevel = false ; }
Stratio/cassandra | protected SchemaAlteringStatement ( CFName name ) { super ( name ) ; this . isColumnFamilyLevel = true ; }
Stratio/cassandra | public int getBoundTerms ( ) { return 0 ; }
Stratio/cassandra | @ Override public void prepareKeyspace ( ClientState state ) throws InvalidRequestException { if ( isColumnFamilyLevel ) super . prepareKeyspace ( state ) ; }
Stratio/cassandra | @ Override public Prepared prepare ( ) { return new Prepared ( this ) ; }
Stratio/cassandra | public ResultMessage execute ( QueryState state , QueryOptions options ) throws RequestValidationException { announceMigration ( ) ; String tableName = cfName == null || columnFamily ( ) == null ? " " : columnFamily ( ) ; return new ResultMessage . SchemaChange ( changeType ( ) , keyspace ( ) , tableName ) ; }
Stratio/cassandra | public ResultMessage executeInternal ( QueryState state ) { throw new UnsupportedOperationException ( ) ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public RemoteRuntimeEngine ( RemoteConfiguration configuration ) { this . config = configuration ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public KieSession getKieSession ( ) { return new KieSessionClientCommandObject ( config ) ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public TaskService getTaskService ( ) { return new TaskServiceClientCommandObject ( config ) ; }
BeatCoding/droolsjbpm-integration-beatcoding-version-6.2.0.Final | public AuditService getAuditService ( ) { return new AuditServiceClientCommandObject ( config ) ; }
aws/aws-sdk-java | public GetMedicalTranscriptionJobRequestProtocolMarshaller ( com . amazonaws . protocol . json . SdkJsonProtocolFactory protocolFactory ) { this . protocolFactory = protocolFactory ; }
aws/aws-sdk-java | public Request < GetMedicalTranscriptionJobRequest > marshall ( GetMedicalTranscriptionJobRequest getMedicalTranscriptionJobRequest ) { if ( getMedicalTranscriptionJobRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { final ProtocolRequestMarshaller < GetMedicalTranscriptionJobRequest > protocolMarshaller = protocolFactory . createProtocolMarshaller ( SDK_OPERATION_BINDING , getMedicalTranscriptionJobRequest ) ; protocolMarshaller . startMarshalling ( ) ; GetMedicalTranscriptionJobRequestMarshaller . getInstance ( ) . marshall ( getMedicalTranscriptionJobRequest , protocolMarshaller ) ; return protocolMarshaller . finishMarshalling ( ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
asedunov/intellij-community | @ NotNull @ Override protected String extractRootPath ( @ NotNull final String path ) { return " / " ; }
asedunov/intellij-community | @ Nullable private FSItem convert ( @ NotNull VirtualFile file ) { final VirtualFile parentFile = file . getParent ( ) ; if ( parentFile == null ) return myRoot ; FSItem parentItem = convert ( parentFile ) ; if ( parentItem == null || ! parentItem . isDirectory ( ) ) { return null ; } return parentItem . findChild ( file . getName ( ) ) ; }
asedunov/intellij-community | @ Override @ NotNull public VirtualFile createChildDirectory ( Object requestor , @ NotNull VirtualFile parent , @ NotNull String dir ) throws IOException { final FSItem fsItem = convert ( parent ) ; assert fsItem != null && fsItem . isDirectory ( ) ; final FSDir fsDir = ( FSDir ) fsItem ; final FSItem existingDir = fsDir . findChild ( dir ) ; if ( existingDir == null ) { fsDir . addChild ( new FSDir ( fsDir , dir ) ) ; } else if ( ! existingDir . isDirectory ( ) ) { throw new IOException ( " Directory ▁ already ▁ contains ▁ a ▁ file ▁ named ▁ " + dir ) ; } return new FakeVirtualFile ( parent , dir ) ; }
asedunov/intellij-community | @ NotNull @ Override public VirtualFile createChildFile ( Object requestor , @ NotNull VirtualFile parent , @ NotNull String file ) throws IOException { final FSItem fsItem = convert ( parent ) ; if ( fsItem == null ) { FSRecords . invalidateCaches ( ) ; throw new IllegalStateException ( " cannot ▁ find ▁ parent ▁ directory : ▁ " + parent . getPath ( ) ) ; } assert fsItem . isDirectory ( ) : " parent ▁ is ▁ not ▁ a ▁ directory : ▁ " + parent . getPath ( ) ; final FSDir fsDir = ( FSDir ) fsItem ; assert fsDir . findChild ( file ) == null : " File ▁ " + file + " ▁ already ▁ exists ▁ in ▁ " + parent . getPath ( ) ; fsDir . addChild ( new FSFile ( fsDir , file ) ) ; return new FakeVirtualFile ( parent , file ) ; }
asedunov/intellij-community | @ NotNull @ Override public VirtualFile copyFile ( Object requestor , @ NotNull VirtualFile file , @ NotNull VirtualFile newParent , @ NotNull String copyName ) throws IOException { return VfsUtilCore . copyFile ( requestor , file , newParent , copyName ) ; }
asedunov/intellij-community | @ Override public void deleteFile ( final Object requestor , @ NotNull final VirtualFile file ) throws IOException { final FSItem fsItem = convert ( file ) ; if ( fsItem == null ) { FSRecords . invalidateCaches ( ) ; throw new IllegalStateException ( " failed ▁ to ▁ delete ▁ file ▁ " + file . getPath ( ) ) ; } fsItem . getParent ( ) . removeChild ( fsItem ) ; }
asedunov/intellij-community | @ Override public void moveFile ( final Object requestor , @ NotNull final VirtualFile file , @ NotNull final VirtualFile newParent ) throws IOException { final FSItem fsItem = convert ( file ) ; assert fsItem != null : " failed ▁ to ▁ move ▁ file ▁ " + file . getPath ( ) ; final FSItem newParentItem = convert ( newParent ) ; assert newParentItem != null && newParentItem . isDirectory ( ) : " failed ▁ to ▁ find ▁ move ▁ target ▁ " + file . getPath ( ) ; FSDir newDir = ( FSDir ) newParentItem ; if ( newDir . findChild ( file . getName ( ) ) != null ) { throw new IOException ( " Directory ▁ already ▁ contains ▁ a ▁ file ▁ named ▁ " + file . getName ( ) ) ; } fsItem . getParent ( ) . removeChild ( fsItem ) ; newDir . addChild ( fsItem ) ; fsItem . myParent = newDir ; }
asedunov/intellij-community | @ Override public void renameFile ( final Object requestor , @ NotNull final VirtualFile file , @ NotNull final String newName ) throws IOException { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; fsItem . setName ( newName ) ; }
asedunov/intellij-community | @ Override @ NotNull public String getProtocol ( ) { return " temp " ; }
asedunov/intellij-community | @ Override public boolean exists ( @ NotNull final VirtualFile fileOrDirectory ) { return convert ( fileOrDirectory ) != null ; }
asedunov/intellij-community | @ Override @ NotNull public String [ ] list ( @ NotNull final VirtualFile file ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; return fsItem . list ( ) ; }
asedunov/intellij-community | @ NotNull @ Override public String getCanonicallyCasedName ( @ NotNull VirtualFile file ) { return file . getName ( ) ; }
asedunov/intellij-community | @ Override public boolean isDirectory ( @ NotNull final VirtualFile file ) { return convert ( file ) instanceof FSDir ; }
asedunov/intellij-community | @ Override public long getTimeStamp ( @ NotNull final VirtualFile file ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null : " cannot ▁ find ▁ item ▁ for ▁ path ▁ " + file . getPath ( ) ; return fsItem . myTimestamp ; }
asedunov/intellij-community | @ Override public void setTimeStamp ( @ NotNull final VirtualFile file , final long timeStamp ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; fsItem . myTimestamp = timeStamp > 0 ? timeStamp : LocalTimeCounter . currentTime ( ) ; }
asedunov/intellij-community | @ Override public boolean isWritable ( @ NotNull final VirtualFile file ) { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; return fsItem . myWritable ; }
asedunov/intellij-community | @ Override public void setWritable ( @ NotNull final VirtualFile file , final boolean writableFlag ) throws IOException { final FSItem fsItem = convert ( file ) ; assert fsItem != null ; fsItem . myWritable = writableFlag ; }
asedunov/intellij-community | @ Override @ NotNull public byte [ ] contentsToByteArray ( @ NotNull final VirtualFile file ) throws IOException { final FSItem fsItem = convert ( file ) ; if ( fsItem == null ) throw new FileNotFoundException ( " Cannot ▁ find ▁ temp ▁ for ▁ " + file . getPath ( ) ) ; assert fsItem instanceof FSFile : fsItem ; return ( ( FSFile ) fsItem ) . myContent ; }
asedunov/intellij-community | @ Override @ NotNull public InputStream getInputStream ( @ NotNull final VirtualFile file ) throws IOException { return new BufferExposingByteArrayInputStream ( contentsToByteArray ( file ) ) ; }
asedunov/intellij-community | @ Override @ NotNull public OutputStream getOutputStream ( @ NotNull final VirtualFile file , final Object requestor , final long modStamp , final long timeStamp ) throws IOException { return new ByteArrayOutputStream ( ) { @ Override public void close ( ) throws IOException { super . close ( ) ; final FSItem fsItem = convert ( file ) ; assert fsItem instanceof FSFile ; ( ( FSFile ) fsItem ) . myContent = toByteArray ( ) ; setTimeStamp ( file , modStamp ) ; } } ; }
asedunov/intellij-community | @ Override public long getLength ( @ NotNull final VirtualFile file ) { try { return contentsToByteArray ( file ) . length ; } catch ( IOException e ) { return 0 ; } }
asedunov/intellij-community | FSItem ( @ Nullable FSDir parent , @ NotNull String name ) { myParent = parent ; myName = name ; myTimestamp = LocalTimeCounter . currentTime ( ) ; myWritable = true ; }
asedunov/intellij-community | @ Nullable public FSItem findChild ( final String name ) { return null ; }
asedunov/intellij-community | void setName ( @ NotNull String name ) { myName = name ; }
asedunov/intellij-community | public FSDir getParent ( ) { return myParent ; }
asedunov/intellij-community | @ NotNull public String [ ] list ( ) { return ArrayUtil . EMPTY_STRING_ARRAY ; }
asedunov/intellij-community | @ Override public String toString ( ) { return getClass ( ) . getSimpleName ( ) + " : ▁ " + myName ; }
asedunov/intellij-community | FSDir ( @ Nullable FSDir parent , @ NotNull String name ) { super ( parent , name ) ; }
asedunov/intellij-community | @ Override @ Nullable public FSItem findChild ( final String name ) { for ( FSItem child : myChildren ) { if ( name . equals ( child . myName ) ) { return child ; } } return null ; }
asedunov/intellij-community | @ Override public boolean isDirectory ( ) { return true ; }
asedunov/intellij-community | void addChild ( @ NotNull FSItem item ) { myChildren . add ( item ) ; }
asedunov/intellij-community | void removeChild ( @ NotNull FSItem fsItem ) { if ( fsItem . myName . equals ( " src " ) && getParent ( ) == null ) { throw new RuntimeException ( " removing ▁ src ▁ directory " ) ; } myChildren . remove ( fsItem ) ; }
asedunov/intellij-community | @ NotNull @ Override public String [ ] list ( ) { String [ ] names = ArrayUtil . newStringArray ( myChildren . size ( ) ) ; for ( int i = 0 ; i < names . length ; i ++ ) { names [ i ] = myChildren . get ( i ) . myName ; } return names ; }
asedunov/intellij-community | FSFile ( @ NotNull FSDir parent , @ NotNull String name ) { super ( parent , name ) ; }
asedunov/intellij-community | @ Override public boolean isDirectory ( ) { return false ; }
asedunov/intellij-community | @ Override public FileAttributes getAttributes ( @ NotNull final VirtualFile file ) { final FSItem item = convert ( file ) ; if ( item == null ) return null ; final long length = item instanceof FSFile ? ( ( FSFile ) item ) . myContent . length : 0 ; return new FileAttributes ( item . isDirectory ( ) , false , false , false , length , item . myTimestamp , item . myWritable ) ; }
asedunov/intellij-community | @ NotNull @ Override public Set < WatchRequest > replaceWatchedRoots ( @ NotNull Collection < WatchRequest > watchRequests , @ Nullable Collection < String > recursiveRoots , @ Nullable Collection < String > flatRoots ) { throw new IncorrectOperationException ( ) ; }
asedunov/intellij-community | @ NotNull @ Override protected String normalize ( @ NotNull String path ) { return path ; }
bihe/login.binggl.net.ninja | public EmbeddedMongod ( ) { }
bihe/login.binggl.net.ninja | public void startup ( ) { wrapEx ( ( ) -> { IMongodConfig mongodConfig = new MongodConfigBuilder ( ) . version ( Version . Main . PRODUCTION ) . net ( new Net ( PORT , Network . localhostIsIPv6 ( ) ) ) . build ( ) ; mongodExe = starter . prepare ( mongodConfig ) ; mongod = mongodExe . start ( ) ; } ) ; }
bihe/login.binggl.net.ninja | public void shutdown ( ) { wrapEx ( ( ) -> { mongod . stop ( ) ; mongodExe . stop ( ) ; } ) ; }
akjava/akjava_gwtlib | private SpeechUtils ( ) { }
emil-wcislo/sbql4j8 | public String getBugId ( ) { return BUG_ID ; }
emil-wcislo/sbql4j8 | public String getBugName ( ) { return getClass ( ) . getName ( ) ; }
smartcat-labs/data-loader | public CircularRangeValueInt ( Range < Integer > range , Integer increment ) { super ( range , increment ) ; }
smartcat-labs/data-loader | @ Override protected Integer zero ( ) { return 0 ; }
smartcat-labs/data-loader | @ Override protected boolean isIncrementGreaterThanRangeSize ( ) { return Math . abs ( range . getBeginning ( ) - range . getEnd ( ) ) <= Math . abs ( increment ) ; }
smartcat-labs/data-loader | @ Override protected Integer peekNextValue ( ) { return val + increment ; }
huihoo/olat | @ Override public void setUp ( ) throws Exception { Context context = Context . setupContext ( getFullName ( ) , SetupType . TWO_NODE_CLUSTER ) ; WorkflowHelper . deleteLearningResources ( context . getStandardAdminOlatLoginInfos ( 1 ) . getUsername ( ) , COURSE_NAME_PREFIX ) ; File file = WorkflowHelper . locateFile ( IMPORTABLE_COURSE_PATH ) ; WorkflowHelper . importCourse ( file , COURSE_NAME , COURSE_NAME_PREFIX ) ; OLATWorkflowHelper workflowAdmin = context . getOLATWorkflowHelper ( context . getStandardAdminOlatLoginInfos ( 1 ) ) ; workflowAdmin . getLearningResources ( ) . searchMyResource ( COURSE_NAME ) . assignOwner ( context . getStandardAuthorOlatLoginInfos ( 1 ) . getUsername ( ) ) ; }
huihoo/olat | public void testEditAndConfigurePodcast ( ) throws Exception { Context context = Context . getContext ( ) ; OLATWorkflowHelper workflowAuthor = context . getOLATWorkflowHelper ( context . getStandardAuthorOlatLoginInfos ( 1 ) ) ; CourseEditor courseEditor = workflowAuthor . getLearningResources ( ) . showCourseContent ( COURSE_NAME ) . getCourseEditor ( ) ; courseEditor . publishCourse ( ) ; CourseRun courseRun = courseEditor . closeToCourseRun ( ) ; PodcastRun podcastRun = courseRun . selectPodcast ( PODCAST_INTERN ) ; File mp3File = WorkflowHelper . locateFile ( Context . FILE_RESOURCES_PATH + AUDIO_FILE_NAME ) ; String remoteFilePath = Context . getContext ( ) . provideFileRemotely ( mp3File ) ; podcastRun . createEpisode ( PODCAST_EPISODE_TITLE , PODCAST_EPISODE_DESCRIPTION , remoteFilePath ) ; assertTrue ( podcastRun . isTextPresent ( " audio " ) ) ; assertTrue ( podcastRun . isTextPresent ( PODCAST_EPISODE_DESCRIPTION ) ) ; podcastRun . editEpisode ( PODCAST_EPISODE_TITLE , PODCAST_EPISODE_DESCRIPTION_MODIFIED , null ) ; assertTrue ( podcastRun . isTextPresent ( PODCAST_EPISODE_DESCRIPTION_MODIFIED ) ) ; podcastRun . commentEpisode ( PODCAST_EPISODE_TITLE , EPISODE_COMMENT ) ; assertTrue ( podcastRun . hasComments ( PODCAST_EPISODE_TITLE , 1 ) ) ; CourseEditor courseEditor1 = courseRun . getCourseEditor ( ) ; PodcastEditor podcastEditor = ( PodcastEditor ) courseEditor1 . selectCourseElement ( PODCAST_INTERN ) ; podcastEditor . changeAccessBlockedForLearners ( CourseElementEditor . ACCESS_TYPE . PRESENT ) ; podcastEditor . changeAccessBlockedForLearners ( CourseElementEditor . ACCESS_TYPE . READ_AND_WRITE ) ; courseEditor1 . publishCourse ( ) ; CourseRun courseRun1 = courseEditor1 . closeToCourseRun ( ) ; OLATWorkflowHelper workflowStudent = context . getOLATWorkflowHelper ( context . getStandardStudentOlatLoginInfos ( 2 ) ) ; CourseRun courseRun2 = workflowStudent . getLearningResources ( ) . searchAndShowCourseContent ( COURSE_NAME ) ; PodcastRun podcastRun2 = courseRun2 . selectPodcast ( PODCAST_INTERN ) ; assertTrue ( podcastRun2 . isTextPresent ( PODCAST_EPISODE_DESCRIPTION_MODIFIED ) ) ; podcastRun2 . createEpisode ( PODCAST_EPISODE_2_TITLE , PODCAST_EPISODE_2_DESCRIPTION , remoteFilePath ) ; assertTrue ( podcastRun2 . isTextPresent ( " audio " ) ) ; assertTrue ( podcastRun2 . isTextPresent ( PODCAST_EPISODE_2_DESCRIPTION ) ) ; PodcastRun podcastRun1 = courseRun1 . selectPodcast ( PODCAST_INTERN ) ; assertTrue ( podcastRun1 . isTextPresent ( " audio " ) ) ; assertTrue ( podcastRun1 . isTextPresent ( PODCAST_EPISODE_2_DESCRIPTION ) ) ; podcastRun1 . createEpisode ( PODCAST_EPISODE_3_TITLE , PODCAST_EPISODE_3_DESCRIPTION , remoteFilePath ) ; assertTrue ( podcastRun1 . isTextPresent ( PODCAST_EPISODE_3_DESCRIPTION ) ) ; podcastRun2 = courseRun2 . selectPodcast ( PODCAST_INTERN ) ; assertTrue ( podcastRun2 . isTextPresent ( PODCAST_EPISODE_3_DESCRIPTION ) ) ; }
jerryyeezus/nlp-summarization | public NivreArcEagerFactory ( DependencyParserConfig _manager ) { super ( _manager ) ; }
jerryyeezus/nlp-summarization | public TransitionSystem makeTransitionSystem ( ) throws MaltChainedException { if ( manager . isLoggerInfoEnabled ( ) ) { manager . logInfoMessage ( " ▁ ▁ Transition ▁ system ▁ ▁ ▁ ▁ : ▁ Arc - Eager \n " ) ; } return new ArcEager ( manager . getPropagationManager ( ) ) ; }
jerryyeezus/nlp-summarization | public OracleGuide makeOracleGuide ( GuideUserHistory history ) throws MaltChainedException { if ( manager . isLoggerInfoEnabled ( ) ) { manager . logInfoMessage ( " ▁ ▁ Oracle ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ : ▁ Arc - Eager \n " ) ; } return new ArcEagerOracle ( manager , history ) ; }
rokn/Count_Words_2015 | protected Mac ( MacSpi macSpi , Provider provider , String algorithm ) { this . spi = macSpi ; this . provider = provider ; this . algorithm = algorithm ; serviceIterator = null ; lock = null ; }
rokn/Count_Words_2015 | private Mac ( Service s , Iterator t , String algorithm ) { firstService = s ; serviceIterator = t ; this . algorithm = algorithm ; lock = new Object ( ) ; }
rokn/Count_Words_2015 | public final String getAlgorithm ( ) { return this . algorithm ; }
rokn/Count_Words_2015 | void chooseFirstProvider ( ) { if ( ( spi != null ) || ( serviceIterator == null ) ) { return ; } synchronized ( lock ) { if ( spi != null ) { return ; } if ( debug != null ) { int w = -- warnCount ; if ( w >= 0 ) { debug . println ( " Mac . init ( ) ▁ not ▁ first ▁ method ▁ " + " called , ▁ disabling ▁ delayed ▁ provider ▁ selection " ) ; if ( w == 0 ) { debug . println ( " Further ▁ warnings ▁ of ▁ this ▁ type ▁ will ▁ " + " be ▁ suppressed " ) ; } new Exception ( " Call ▁ trace " ) . printStackTrace ( ) ; } } Exception lastException = null ; while ( ( firstService != null ) || serviceIterator . hasNext ( ) ) { Service s ; if ( firstService != null ) { s = firstService ; firstService = null ; } else { s = ( Service ) serviceIterator . next ( ) ; } if ( JceSecurity . canUseProvider ( s . getProvider ( ) ) == false ) { continue ; } try { Object obj = s . newInstance ( null ) ; if ( obj instanceof MacSpi == false ) { continue ; } spi = ( MacSpi ) obj ; provider = s . getProvider ( ) ; firstService = null ; serviceIterator = null ; return ; } catch ( NoSuchAlgorithmException e ) { lastException = e ; } } ProviderException e = new ProviderException ( " Could ▁ not ▁ construct ▁ MacSpi ▁ instance " ) ; if ( lastException != null ) { e . initCause ( lastException ) ; } throw e ; } }
rokn/Count_Words_2015 | synchronized ( lock ) { if ( spi != null ) { spi . engineInit ( key , params ) ; return ; } Exception lastException = null ; while ( ( firstService != null ) || serviceIterator . hasNext ( ) ) { Service s ; if ( firstService != null ) { s = firstService ; firstService = null ; } else { s = ( Service ) serviceIterator . next ( ) ; } if ( s . supportsParameter ( key ) == false ) { continue ; } if ( JceSecurity . canUseProvider ( s . getProvider ( ) ) == false ) { continue ; } try { MacSpi spi = ( MacSpi ) s . newInstance ( null ) ; spi . engineInit ( key , params ) ; provider = s . getProvider ( ) ; this . spi = spi ; firstService = null ; serviceIterator = null ; return ; } catch ( Exception e ) { if ( lastException == null ) { lastException = e ; } } } if ( lastException instanceof InvalidKeyException ) { throw ( InvalidKeyException ) lastException ; } if ( lastException instanceof InvalidAlgorithmParameterException ) { throw ( InvalidAlgorithmParameterException ) lastException ; } if ( lastException instanceof RuntimeException ) { throw ( RuntimeException ) lastException ; } String kName = ( key != null ) ? key . getClass ( ) . getName ( ) : " ( null ) " ; throw new InvalidKeyException ( " No ▁ installed ▁ provider ▁ supports ▁ this ▁ key : ▁ " + kName , lastException ) ; }
rokn/Count_Words_2015 | public final Provider getProvider ( ) { chooseFirstProvider ( ) ; return this . provider ; }
rokn/Count_Words_2015 | public final int getMacLength ( ) { chooseFirstProvider ( ) ; return spi . engineGetMacLength ( ) ; }
rokn/Count_Words_2015 | public final void init ( Key key ) throws InvalidKeyException { try { if ( spi != null ) { spi . engineInit ( key , null ) ; } else { chooseProvider ( key , null ) ; } } catch ( InvalidAlgorithmParameterException e ) { throw new InvalidKeyException ( " init ( ) ▁ failed " , e ) ; } initialized = true ; }
rokn/Count_Words_2015 | if ( spi != null ) { spi . engineInit ( key , params ) ; }
rokn/Count_Words_2015 | public final void update ( byte input ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } spi . engineUpdate ( input ) ; }
rokn/Count_Words_2015 | public final void update ( byte [ ] input ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } if ( input != null ) { spi . engineUpdate ( input , 0 , input . length ) ; } }
rokn/Count_Words_2015 | public final void update ( byte [ ] input , int offset , int len ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } if ( input != null ) { if ( ( offset < 0 ) || ( len > ( input . length - offset ) ) || ( len < 0 ) ) throw new IllegalArgumentException ( " Bad ▁ arguments " ) ; spi . engineUpdate ( input , offset , len ) ; } }
rokn/Count_Words_2015 | public final void update ( ByteBuffer input ) { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } if ( input == null ) { throw new IllegalArgumentException ( " Buffer ▁ must ▁ not ▁ be ▁ null " ) ; } spi . engineUpdate ( input ) ; }
rokn/Count_Words_2015 | public final byte [ ] doFinal ( ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } byte [ ] mac = spi . engineDoFinal ( ) ; spi . engineReset ( ) ; return mac ; }
rokn/Count_Words_2015 | if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; }
rokn/Count_Words_2015 | if ( output == null || output . length - outOffset < macLen ) { throw new ShortBufferException ( " Cannot ▁ store ▁ MAC ▁ in ▁ output ▁ buffer " ) ; }
rokn/Count_Words_2015 | public final byte [ ] doFinal ( byte [ ] input ) throws IllegalStateException { chooseFirstProvider ( ) ; if ( initialized == false ) { throw new IllegalStateException ( " MAC ▁ not ▁ initialized " ) ; } update ( input ) ; return doFinal ( ) ; }
rokn/Count_Words_2015 | public final void reset ( ) { chooseFirstProvider ( ) ; spi . engineReset ( ) ; }
rokn/Count_Words_2015 | public final Object clone ( ) throws CloneNotSupportedException { chooseFirstProvider ( ) ; Mac that = ( Mac ) super . clone ( ) ; that . spi = ( MacSpi ) this . spi . clone ( ) ; return that ; }
fwingy/LightPlayer | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( Build . VERSION . SDK_INT >= 21 ) { getActivity ( ) . getWindow ( ) . setStatusBarColor ( Color . TRANSPARENT ) ; getActivity ( ) . getWindow ( ) . getDecorView ( ) . setSystemUiVisibility ( View . SYSTEM_UI_FLAG_LAYOUT_STABLE | View . SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN ) ; } }
fwingy/LightPlayer | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_playback_layout , container , false ) ; mSharedPreferences = getActivity ( ) . getSharedPreferences ( LIGHT_MAIN_PREFS_NAME , 0 ) ; initWidget ( view ) ; return view ; }
fwingy/LightPlayer | private void initWidget ( View view ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) ; mCDView = ( CDView ) view . findViewById ( R . id . cd_circle_view ) ; mBackArrow = ( ImageView ) view . findViewById ( R . id . back_arrow ) ; mTitleTextView = ( MarqueeTextView ) view . findViewById ( R . id . playback_layout_title ) ; mArtistTextView = ( TextView ) view . findViewById ( R . id . playback_layout_artist ) ; mSharedImageButton = ( ImageButton ) view . findViewById ( R . id . share_button ) ; mElapsedTime = ( TextView ) view . findViewById ( R . id . text_time_elapsed ) ; mSeekBar = ( SeekBar ) view . findViewById ( R . id . sb_play_progress ) ; mDuration = ( TextView ) view . findViewById ( R . id . text_duration ) ; mPlayModeButton = ( ImageButton ) view . findViewById ( R . id . play_mode_button ) ; mPreButton = ( ImageButton ) view . findViewById ( R . id . ib_play_pre ) ; mPlayButton = ( ImageButton ) view . findViewById ( R . id . ib_play_start ) ; mNextButton = ( ImageButton ) view . findViewById ( R . id . ib_play_next ) ; mAddToPlaylistButton = ( ImageButton ) view . findViewById ( R . id . playlist_add ) ; mLayoutContainer = ( LinearLayout ) view . findViewById ( R . id . playback_layout_root_group ) ; mSharedImageButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { Intent intent = new Intent ( ) ; int position = AudioLab . getAudioLab ( getContext ( ) ) . getCurrentPosition ( ) ; Audio audio = AudioLab . getAudioLab ( getContext ( ) ) . getAudioList ( ) . get ( position ) ; File file = new File ( audio . getData ( ) ) ; Uri uri = Uri . fromFile ( file ) ; intent . setAction ( Intent . ACTION_SEND ) ; intent . putExtra ( Intent . EXTRA_STREAM , uri ) ; intent . setType ( " audio / mpeg " ) ; startActivity ( Intent . createChooser ( intent , getString ( R . string . send_to ) ) ) ; } } ) ; int playMode = mSharedPreferences . getInt ( PREFS_KEY_PLAY_MODE , 9999 ) ; if ( playMode == 9999 ) { mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_REPEAT_LIST ) . apply ( ) ; } switch ( mSharedPreferences . getInt ( PREFS_KEY_PLAY_MODE , 9999 ) ) { case PLAY_MODE_REPEAT_SELF : mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_one_white_36dp ) ) ; break ; case PLAY_MODE_REPEAT_LIST : mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_white_36dp ) ) ; break ; case PLAY_MODE_SHUFFLE : mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_shuffle_white_36dp ) ) ; } mSeekBar . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { @ Override public void onProgressChanged ( SeekBar seekBar , int progress , boolean fromUser ) { mElapsedTime . setText ( FormatUtil . formatDuration ( seekBar . getProgress ( ) ) ) ; } @ Override public void onStartTrackingTouch ( SeekBar seekBar ) { flagDraging = 1 ; } @ Override public void onStopTrackingTouch ( SeekBar seekBar ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . seek ( seekBar . getProgress ( ) ) ; mHandler . postDelayed ( new Runnable ( ) { @ Override public void run ( ) { flagDraging = 0 ; } } , 100 ) ; } } ) ; mBackArrow . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { getActivity ( ) . onBackPressed ( ) ; } } ) ; final Toast toastMode = Toast . makeText ( getContext ( ) , " " , Toast . LENGTH_SHORT ) ; mPlayModeButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { switch ( mSharedPreferences . getInt ( PREFS_KEY_PLAY_MODE , 9999 ) ) { case PLAY_MODE_REPEAT_SELF : ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setLooping ( false ) ; mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_REPEAT_LIST ) . apply ( ) ; mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_white_36dp ) ) ; toastMode . setText ( getString ( R . string . toast_play_mode_circulation ) ) ; toastMode . show ( ) ; ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setNotificationChangeMode ( R . drawable . ic_repeat_black_36dp ) ; break ; case PLAY_MODE_REPEAT_LIST : mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_SHUFFLE ) . apply ( ) ; mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_shuffle_white_36dp ) ) ; toastMode . setText ( getString ( R . string . toast_play_mode_random ) ) ; toastMode . show ( ) ; ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setNotificationChangeMode ( R . drawable . ic_shuffle_black_36dp ) ; break ; case PLAY_MODE_SHUFFLE : ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setLooping ( true ) ; mSharedPreferences . edit ( ) . putInt ( PREFS_KEY_PLAY_MODE , PLAY_MODE_REPEAT_SELF ) . apply ( ) ; mPlayModeButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_repeat_one_white_36dp ) ) ; toastMode . setText ( getString ( R . string . toast_play_mode_single_track ) ) ; toastMode . show ( ) ; ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . setNotificationChangeMode ( R . drawable . ic_repeat_one_black_36dp ) ; break ; } } } ) ; mPreButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . pre ( ) ; } } ) ; mPlayButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { PlayService playService = ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) ; if ( playService . isPlaying ( ) ) { playService . pause ( ) ; } else { playService . resume ( ) ; } } } ) ; mNextButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . next ( ) ; } } ) ; int currentAudioPosition = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getCurrentPosition ( ) ; Audio audio = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getAudioList ( ) . get ( currentAudioPosition ) ; mLoadCDBitmapTask = new LoadCDBitmapTask ( ) ; mLoadBgBitmapTask = new LoadBgBitmapTask ( ) ; mLoadCDBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; mLoadBgBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; }
fwingy/LightPlayer | public void onPositionChanged ( int position ) { Audio audio = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getAudioList ( ) . get ( position ) ; updateView ( audio ) ; }
fwingy/LightPlayer | public void onProgressChanged ( int progress ) { updateDynamicViews ( progress ) ; }
fwingy/LightPlayer | public void onPlay ( ) { Log . i ( " PlayBackFragme的onPlay " , " 调用了 " ) ; mCDView . start ( ) ; mPlayButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_pause_circle_outline_white_48dp ) ) ; }
fwingy/LightPlayer | public void onPaused ( ) { mCDView . pause ( ) ; mPlayButton . setImageDrawable ( ContextCompat . getDrawable ( getActivity ( ) , R . drawable . ic_play_circle_outline_white_48dp ) ) ; }
fwingy/LightPlayer | @ Override protected Bitmap doInBackground ( Audio ... params ) { Bitmap bitmap ; Audio audio = params [ 0 ] ; bitmap = ImageUtil . loadBitmapForCDFromUri ( audio . getAlbumArt ( ) ) ; try { if ( bitmap == null ) { bitmap = defaultBitmap ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return bitmap ; }
fwingy/LightPlayer | @ Override protected void onPostExecute ( Bitmap bitmap ) { Log . i ( " 任务执行完了 " , " " ) ; mCDView . setImage ( bitmap ) ; }
fwingy/LightPlayer | @ Override protected BitmapDrawable doInBackground ( Audio ... params ) { BitmapDrawable bitmapDrawable = null ; Audio audio = params [ 0 ] ; Bitmap bitmap = ImageUtil . loadBitmapForScreenBgFromUri ( audio . getAlbumArt ( ) ) ; try { if ( bitmap != null ) { Bitmap blurBitmap = FastBlurUtil . doBlur ( bitmap , 8 , true ) ; bitmapDrawable = new BitmapDrawable ( getResources ( ) , blurBitmap ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return bitmapDrawable ; }
fwingy/LightPlayer | @ Override protected void onPostExecute ( BitmapDrawable bitmapDrawable ) { if ( bitmapDrawable != null ) { mLayoutContainer . setBackground ( bitmapDrawable ) ; } else { mLayoutContainer . setBackgroundColor ( ContextCompat . getColor ( getActivity ( ) , R . color . fullscreenblack ) ) ; } }
fwingy/LightPlayer | @ Override public void onDestroy ( ) { super . onDestroy ( ) ; if ( mLoadCDBitmapTask != null ) { mLoadCDBitmapTask . cancel ( true ) ; mLoadCDBitmapTask = null ; } if ( mLoadBgBitmapTask != null ) { mLoadBgBitmapTask . cancel ( true ) ; mLoadBgBitmapTask = null ; } if ( defaultBitmap != null ) { defaultBitmap = null ; } }
fwingy/LightPlayer | public void serviceConected ( ) { if ( ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) . isPlaying ( ) ) { onPlay ( ) ; } else { onPaused ( ) ; } int currentPosition = AudioLab . getAudioLab ( getActivity ( ) . getApplicationContext ( ) ) . getCurrentPosition ( ) ; Audio audio = AudioLab . getAudioLab ( getActivity ( ) ) . getAudioList ( ) . get ( currentPosition ) ; updateView ( audio ) ; }
fwingy/LightPlayer | public void updateView ( Audio audio ) { PlayService playService = ( ( PlayBackActivity ) getActivity ( ) ) . getPlayService ( ) ; if ( mLoadCDBitmapTask . getStatus ( ) == AsyncTask . Status . RUNNING ) { mLoadCDBitmapTask . cancel ( true ) ; } mLoadCDBitmapTask = null ; if ( mLoadBgBitmapTask . getStatus ( ) == AsyncTask . Status . RUNNING ) { mLoadBgBitmapTask . cancel ( true ) ; } mLoadBgBitmapTask = null ; mLoadCDBitmapTask = new LoadCDBitmapTask ( ) ; mLoadBgBitmapTask = new LoadBgBitmapTask ( ) ; mLoadCDBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; mLoadBgBitmapTask . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR , audio ) ; mSeekBar . setMax ( audio . getDuration ( ) ) ; if ( playService . getDuration ( ) != - 1 ) { mDuration . setText ( FormatUtil . formatDuration ( playService . getDuration ( ) ) ) ; } else { mDuration . setText ( FormatUtil . formatDuration ( 0 ) ) ; } mTitleTextView . setText ( audio . getTitle ( ) ) ; mArtistTextView . setText ( audio . getArtist ( ) ) ; }
fwingy/LightPlayer | private void updateDynamicViews ( int progress ) { if ( flagDraging == 0 ) { if ( mElapsedTime != null ) { mElapsedTime . setText ( FormatUtil . formatDuration ( progress ) ) ; } if ( mSeekBar != null ) { mSeekBar . setProgress ( progress ) ; } } }
talsma-ict/umldoclet | public RegexOptional ( IRegex partial ) { super ( partial ) ; }
talsma-ict/umldoclet | @ Override protected String getFullSlow ( ) { final StringBuilder sb = new StringBuilder ( " ( ? : " ) ; sb . append ( partials ( ) . get ( 0 ) . getPattern ( ) ) ; sb . append ( " ) ? " ) ; return sb . toString ( ) ; }
talsma-ict/umldoclet | public boolean match ( StringLocated full ) { throw new UnsupportedOperationException ( ) ; }
RCasatta/geobit-chain | @ Test public void blockchainTest ( ) { BalanceProvider balanceProv = new BlockChainHTTPClient ( ) ; Long result = balanceProv . getBalance ( address ) ; assertNotNull ( result ) ; assertTrue ( result > 0 ) ; ReceivedProvider receivedProv = new BlockChainHTTPClient ( ) ; Long result2 = receivedProv . getReceived ( address ) ; assertNotNull ( result2 ) ; assertTrue ( result2 > 0 ) ; System . out . println ( " received = " + result2 ) ; result = balanceProv . getBalance ( "1G1qk5jKudDjkJ21JafGXq3VghESxHJKCp " ) ; assertNotNull ( result ) ; assertTrue ( result >= 0 ) ; result2 = receivedProv . getReceived ( "1G1qk5jKudDjkJ21JafGXq3VghESxHJKCp " ) ; assertNotNull ( result2 ) ; assertTrue ( result2 >= 0 ) ; TransactionProvider transProv = new BlockChainHTTPClient ( ) ; Transaction t = transProv . getTransaction ( " dc3fdb02f11c037f90c25a83e188bfc6ede64327dd658a33cc981fc5750564c3" ) ; assertNotNull ( t ) ; System . out . println ( " t = " + t ) ; Date d ; try { d = SimpleDateFormats . m_ISO8601Local . parse ( "2012-10-09T17:22:30Z " ) ; System . out . println ( d . getTime ( ) ) ; System . out . println ( d ) ; Date d2 = new Date ( 1349803350L * 1000L ) ; System . out . println ( d2 ) ; System . out . println ( SimpleDateFormats . m_ISO8601Local . format ( d2 ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } TransHexProvider transHexProv = new BlockChainHTTPClient ( ) ; String hex = transHexProv . getTransHex ( " dc3fdb02f11c037f90c25a83e188bfc6ede64327dd658a33cc981fc5750564c3" ) ; System . out . println ( " hex = " + hex ) ; assertEquals ( "01000000017d9d5ee684871124984352a619a2ba7e47dcbe938fe03d309954c5c37dead35b000000006b483045022100ef2ff0eaa8592ba063b23cb5ed4426ec8da75e084eb5d0c639e7ab557244b6c0022062faf9cad264d5d940f5f41b764da8150b20e3ea38f04154cd3aee7674dce600012103e932232ef41a3d2ef858ec3d6eb4ea13b28a096fa5e9a85761f7f578deea1e0effffffff0230d12501000000001976a9146f4c339296f9cb2d45419564f45121ccd84d505188acb8560000000000001976a914a781df4fda5411ecf867101cb18212403d07b6eb88ac00000000" , hex ) ; }
RCasatta/geobit-chain | @ Test public void blockchainUnspentTest ( ) { AddressUnspentsProvider uns = new BlockChainHTTPClient ( ) ; AddressTransactions tr = uns . getAddressUnspents ( "1G8sGKyw4wFGQXBZxk4df6uvCxGb1jR5sJ " ) ; System . out . println ( tr ) ; assertNotNull ( tr ) ; }
code4wt/nutch-learning | public NodeWalker ( Node rootNode ) { nodes = new Stack < > ( ) ; nodes . add ( rootNode ) ; }
code4wt/nutch-learning | public Node nextNode ( ) { if ( ! hasNext ( ) ) { return null ; } currentNode = nodes . pop ( ) ; currentChildren = currentNode . getChildNodes ( ) ; int childLen = ( currentChildren != null ) ? currentChildren . getLength ( ) : 0 ; for ( int i = childLen - 1 ; i >= 0 ; i -- ) { nodes . add ( currentChildren . item ( i ) ) ; } return currentNode ; }
code4wt/nutch-learning | public void skipChildren ( ) { int childLen = ( currentChildren != null ) ? currentChildren . getLength ( ) : 0 ; for ( int i = 0 ; i < childLen ; i ++ ) { Node child = nodes . peek ( ) ; if ( child . equals ( currentChildren . item ( i ) ) ) { nodes . pop ( ) ; } } }
code4wt/nutch-learning | public Node getCurrentNode ( ) { return currentNode ; }
code4wt/nutch-learning | public boolean hasNext ( ) { return ( nodes . size ( ) > 0 ) ; }
infinitiessoft/skyport-hazelcast | @ Override public int getTypeId ( ) { return SerializationConstants . VM_TYPE ; }
infinitiessoft/skyport-hazelcast | @ Override public void destroy ( ) { }
infinitiessoft/skyport-hazelcast | @ Override public void write ( ObjectDataOutput out , Vm object ) throws IOException { out . writeObject ( object . getId ( ) ) ; out . writeUTF ( object . getDesc ( ) ) ; out . writeInt ( object . getVersion ( ) ) ; out . writeUTF ( object . getConfig ( ) ) ; out . writeObject ( object . getCpunum ( ) ) ; out . writeObject ( object . getMemorysize ( ) ) ; out . writeObject ( object . getCreationdate ( ) ) ; out . writeObject ( object . getDisks ( ) ) ; out . writeObject ( object . getNics ( ) ) ; out . writeUTF ( object . getName ( ) ) ; out . writeUTF ( object . getResourceid ( ) ) ; out . writeUTF ( object . getTemplateid ( ) ) ; out . writeUTF ( object . getOs ( ) ) ; out . writeUTF ( object . getVmtype ( ) ) ; out . writeUTF ( object . getHypervisortype ( ) ) ; out . writeUTF ( object . getStatus ( ) ) ; out . writeUTF ( object . getTimeZone ( ) ) ; out . writeUTF ( object . getVmid ( ) ) ; out . writeUTF ( object . getRunningonhostid ( ) ) ; out . writeUTF ( object . getIp ( ) ) ; out . writeUTF ( object . getCdisopath ( ) ) ; out . writeUTF ( object . getInfo ( ) ) ; out . writeObject ( object . getStatistics ( ) ) ; out . writeUTF ( object . getDomain ( ) ) ; out . writeUTF ( object . getDisplayType ( ) ) ; out . writeUTF ( object . getBootDevice ( ) ) ; out . writeUTF ( object . getFlavorId ( ) ) ; out . writeUTF ( object . getKeyName ( ) ) ; out . writeUTF ( object . getType ( ) ) ; out . writeUTF ( object . getGroup ( ) ) ; out . writeUTF ( object . getKey ( ) ) ; out . writeUTF ( object . getConfigid ( ) ) ; }
infinitiessoft/skyport-hazelcast | @ Override public Vm read ( ObjectDataInput in ) throws IOException { Vm ret = new Vm ( ) ; Long id = in . readObject ( ) ; ret . setId ( id ) ; ret . setDesc ( in . readUTF ( ) ) ; ret . setVersion ( in . readInt ( ) ) ; ret . setConfig ( in . readUTF ( ) ) ; Integer cpunum = in . readObject ( ) ; ret . setCpunum ( cpunum ) ; Long memorysize = in . readObject ( ) ; ret . setMemorysize ( memorysize ) ; Date creationdate = in . readObject ( ) ; ret . setCreationdate ( creationdate ) ; Disks disks = in . readObject ( ) ; ret . setDisks ( disks ) ; NetworkAdapters nics = in . readObject ( ) ; ret . setNics ( nics ) ; ret . setName ( in . readUTF ( ) ) ; ret . setResourceid ( in . readUTF ( ) ) ; ret . setTemplateid ( in . readUTF ( ) ) ; ret . setOs ( in . readUTF ( ) ) ; ret . setVmtype ( in . readUTF ( ) ) ; ret . setHypervisortype ( in . readUTF ( ) ) ; ret . setStatus ( in . readUTF ( ) ) ; ret . setTimeZone ( in . readUTF ( ) ) ; ret . setVmid ( in . readUTF ( ) ) ; ret . setRunningonhostid ( in . readUTF ( ) ) ; ret . setIp ( in . readUTF ( ) ) ; ret . setCdisopath ( in . readUTF ( ) ) ; ret . setInfo ( in . readUTF ( ) ) ; Statistics statistics = in . readObject ( ) ; ret . setStatistics ( statistics ) ; ret . setDomain ( in . readUTF ( ) ) ; ret . setDisplayType ( in . readUTF ( ) ) ; ret . setBootDevice ( in . readUTF ( ) ) ; ret . setFlavorId ( in . readUTF ( ) ) ; ret . setKeyName ( in . readUTF ( ) ) ; ret . setType ( in . readUTF ( ) ) ; ret . setGroup ( in . readUTF ( ) ) ; ret . setKey ( in . readUTF ( ) ) ; ret . setConfigid ( in . readUTF ( ) ) ; return ret ; }
tommista/android-net | ObjectRef ( ) { }
tommista/android-net | Builder ( ) { }
mevdschee/tqdev-metrics | public InstrumentedConnection ( Connection connection , MetricRegistry registry ) { this . connection = connection ; this . registry = registry ; }
mevdschee/tqdev-metrics | @ Override public Statement createStatement ( ) throws SQLException { return new InstrumentedStatement ( connection . createStatement ( ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public CallableStatement prepareCall ( String sql ) throws SQLException { return new InstrumentedCallableStatement ( sql , connection . prepareCall ( sql ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public String nativeSQL ( String sql ) throws SQLException { return connection . nativeSQL ( sql ) ; }
mevdschee/tqdev-metrics | @ Override public void setAutoCommit ( boolean autoCommit ) throws SQLException { this . autoCommit = autoCommit ; connection . setAutoCommit ( autoCommit ) ; }
mevdschee/tqdev-metrics | @ Override public boolean getAutoCommit ( ) throws SQLException { return connection . getAutoCommit ( ) ; }
mevdschee/tqdev-metrics | @ Override public void commit ( ) throws SQLException { connection . commit ( ) ; }
mevdschee/tqdev-metrics | @ Override public void rollback ( ) throws SQLException { connection . rollback ( ) ; }
mevdschee/tqdev-metrics | @ Override public void close ( ) throws SQLException { connection . close ( ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isClosed ( ) throws SQLException { return connection . isClosed ( ) ; }
mevdschee/tqdev-metrics | @ Override public DatabaseMetaData getMetaData ( ) throws SQLException { return connection . getMetaData ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setReadOnly ( boolean readOnly ) throws SQLException { connection . setReadOnly ( readOnly ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isReadOnly ( ) throws SQLException { return connection . isReadOnly ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setCatalog ( String catalog ) throws SQLException { connection . setCatalog ( catalog ) ; }
mevdschee/tqdev-metrics | @ Override public String getCatalog ( ) throws SQLException { return connection . getCatalog ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setTransactionIsolation ( int level ) throws SQLException { connection . setTransactionIsolation ( level ) ; }
mevdschee/tqdev-metrics | @ Override public int getTransactionIsolation ( ) throws SQLException { return connection . getTransactionIsolation ( ) ; }
mevdschee/tqdev-metrics | @ Override public SQLWarning getWarnings ( ) throws SQLException { return connection . getWarnings ( ) ; }
mevdschee/tqdev-metrics | @ Override public void clearWarnings ( ) throws SQLException { connection . clearWarnings ( ) ; }
mevdschee/tqdev-metrics | @ Override public Statement createStatement ( int resultSetType , int resultSetConcurrency ) throws SQLException { return new InstrumentedStatement ( connection . createStatement ( resultSetType , resultSetConcurrency ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , resultSetType , resultSetConcurrency ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { return new InstrumentedCallableStatement ( sql , connection . prepareCall ( sql , resultSetType , resultSetConcurrency ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public Map < String , Class < ? > > getTypeMap ( ) throws SQLException { return connection . getTypeMap ( ) ; }
mevdschee/tqdev-metrics | @ Override public void setTypeMap ( Map < String , Class < ? > > map ) throws SQLException { connection . setTypeMap ( map ) ; }
mevdschee/tqdev-metrics | @ Override public void setHoldability ( int holdability ) throws SQLException { connection . setHoldability ( holdability ) ; }
mevdschee/tqdev-metrics | @ Override public int getHoldability ( ) throws SQLException { return connection . getHoldability ( ) ; }
mevdschee/tqdev-metrics | @ Override public Savepoint setSavepoint ( ) throws SQLException { return connection . setSavepoint ( ) ; }
mevdschee/tqdev-metrics | @ Override public Savepoint setSavepoint ( String name ) throws SQLException { return connection . setSavepoint ( name ) ; }
mevdschee/tqdev-metrics | @ Override public void rollback ( Savepoint savepoint ) throws SQLException { connection . rollback ( savepoint ) ; }
mevdschee/tqdev-metrics | @ Override public void releaseSavepoint ( Savepoint savepoint ) throws SQLException { connection . releaseSavepoint ( savepoint ) ; }
mevdschee/tqdev-metrics | @ Override public Statement createStatement ( int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return new InstrumentedStatement ( connection . createStatement ( resultSetType , resultSetConcurrency , resultSetHoldability ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , resultSetType , resultSetConcurrency , resultSetHoldability ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return new InstrumentedCallableStatement ( sql , connection . prepareCall ( sql , resultSetType , resultSetConcurrency , resultSetHoldability ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int autoGeneratedKeys ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , autoGeneratedKeys ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , int [ ] columnIndexes ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , columnIndexes ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public PreparedStatement prepareStatement ( String sql , String [ ] columnNames ) throws SQLException { return new InstrumentedPreparedStatement ( sql , connection . prepareStatement ( sql , columnNames ) , registry ) ; }
mevdschee/tqdev-metrics | @ Override public Clob createClob ( ) throws SQLException { return connection . createClob ( ) ; }
mevdschee/tqdev-metrics | @ Override public Blob createBlob ( ) throws SQLException { return connection . createBlob ( ) ; }
mevdschee/tqdev-metrics | @ Override public NClob createNClob ( ) throws SQLException { return connection . createNClob ( ) ; }
mevdschee/tqdev-metrics | @ Override public SQLXML createSQLXML ( ) throws SQLException { return connection . createSQLXML ( ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isValid ( int timeout ) throws SQLException { return connection . isValid ( timeout ) ; }
mevdschee/tqdev-metrics | @ Override public void setClientInfo ( String name , String value ) throws SQLClientInfoException { connection . setClientInfo ( name , value ) ; }
mevdschee/tqdev-metrics | @ Override public void setClientInfo ( Properties properties ) throws SQLClientInfoException { connection . setClientInfo ( properties ) ; }
mevdschee/tqdev-metrics | @ Override public String getClientInfo ( String name ) throws SQLException { return connection . getClientInfo ( name ) ; }
mevdschee/tqdev-metrics | @ Override public Properties getClientInfo ( ) throws SQLException { return connection . getClientInfo ( ) ; }
mevdschee/tqdev-metrics | @ Override public Array createArrayOf ( String typeName , Object [ ] elements ) throws SQLException { return connection . createArrayOf ( typeName , elements ) ; }
mevdschee/tqdev-metrics | @ Override public Struct createStruct ( String typeName , Object [ ] attributes ) throws SQLException { return connection . createStruct ( typeName , attributes ) ; }
mevdschee/tqdev-metrics | @ Override public void setSchema ( String schema ) throws SQLException { connection . setSchema ( schema ) ; }
mevdschee/tqdev-metrics | @ Override public String getSchema ( ) throws SQLException { return connection . getSchema ( ) ; }
mevdschee/tqdev-metrics | @ Override public void abort ( Executor executor ) throws SQLException { connection . abort ( executor ) ; }
mevdschee/tqdev-metrics | @ Override public void setNetworkTimeout ( Executor executor , int milliseconds ) throws SQLException { connection . setNetworkTimeout ( executor , milliseconds ) ; }
mevdschee/tqdev-metrics | @ Override public int getNetworkTimeout ( ) throws SQLException { return connection . getNetworkTimeout ( ) ; }
mevdschee/tqdev-metrics | @ Override public < T > T unwrap ( Class < T > iface ) throws SQLException { return connection . unwrap ( iface ) ; }
mevdschee/tqdev-metrics | @ Override public boolean isWrapperFor ( Class < ? > iface ) throws SQLException { return connection . isWrapperFor ( iface ) ; }
nmldiegues/jvm-stm | public int hashCode ( ) { return year * 31 + month ; }
nmldiegues/jvm-stm | public boolean equals ( Object other ) { if ( other instanceof GYearMonth ) { GYearMonth gmy = ( GYearMonth ) other ; return gmy . year == year && gmy . month == month ; } return false ; }
nmldiegues/jvm-stm | public int compareTo ( Object other ) { if ( other instanceof GYearMonth ) { GYearMonth gmy = ( GYearMonth ) other ; if ( gmy . year == year ) { if ( gmy . month == month ) return 0 ; return ( month < gmy . month ) ? - 1 : 1 ; } return ( year < gmy . year ) ? - 1 : 1 ; } return 0 ; }
nmldiegues/jvm-stm | GYearMonthType ( ) { super ( new QName ( XMLConstants . W3C_XML_SCHEMA_NS_URI , " gYearMonth " ) , TypeLibrary . ANY_SIMPLE_TYPE ) ; }
nmldiegues/jvm-stm | public int [ ] getConstrainingFacets ( ) { return CONSTRAINING_FACETS ; }
nmldiegues/jvm-stm | public void checkValid ( String value , ValidationContext context ) throws DatatypeException { super . checkValid ( value , context ) ; int len = value . length ( ) ; int state = 0 ; int start = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; if ( c == ' - ' && i == 0 ) { start ++ ; continue ; } if ( c >= 0x30 && c <= 0x39 ) continue ; switch ( state ) { case 0 : if ( c == ' - ' ) { String year = value . substring ( start , i ) ; if ( year . length ( ) < 4 || Integer . parseInt ( year ) == 0 ) throw new DatatypeException ( i , " illegal ▁ GYear ▁ value " ) ; state = 1 ; start = i + 1 ; continue ; } break ; } throw new DatatypeException ( i , " illegal ▁ GYear ▁ value " ) ; } switch ( state ) { case 1 : if ( len - start != 2 ) throw new DatatypeException ( " illegal ▁ GYear ▁ value " ) ; break ; default : throw new DatatypeException ( " illegal ▁ GYear ▁ value " ) ; } }
nmldiegues/jvm-stm | public Object createValue ( String literal , ValidationContext context ) { try { int offset = 5 ; if ( literal . charAt ( 0 ) == ' - ' ) offset ++ ; GYearMonth ret = new GYearMonth ( ) ; ret . year = Integer . parseInt ( literal . substring ( 0 , offset ) ) ; ret . month = Integer . parseInt ( literal . substring ( offset + 1 ) ) ; return ret ; } catch ( Exception e ) { return null ; } }
Teiid-Designer/modeshape | public ParsingException ( String message , int lineNumber , int columnNumber ) { super ( message ) ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; }
Teiid-Designer/modeshape | public ParsingException ( String message , Throwable cause , int lineNumber , int columnNumber ) { super ( message , cause ) ; this . lineNumber = lineNumber ; this . columnNumber = columnNumber ; }
Teiid-Designer/modeshape | public int getLineNumber ( ) { return lineNumber ; }
Teiid-Designer/modeshape | public int getColumnNumber ( ) { return columnNumber ; }
akhettar/camel | private HL723Converter ( ) { }
impro3-nerdle/nerdle | private SingletonGraph ( ) { try { propertiesConfiguration = new PropertiesConfiguration ( ResourceManager . getResourcePath ( File . separator + " graphs . properties " ) ) ; } catch ( ConfigurationException e ) { e . printStackTrace ( ) ; } String [ ] graphStrings = propertiesConfiguration . getStringArray ( " graphs " ) ; String graphsBasePath = propertiesConfiguration . getString ( " basePath " ) ; graphs = new HashMap < String , TinkerGraph > ( ) ; for ( String graph : graphStrings ) { TinkerGraph g = new TinkerGraph ( graphsBasePath + File . separator + graph , TinkerGraph . FileType . GRAPHSON ) ; g . createKeyIndex ( NerdleGraphTransformer . PROPERTY_LEMMA , Vertex . class ) ; graphs . put ( graph , g ) ; } }
impro3-nerdle/nerdle | public HashMap < String , TinkerGraph > getGraphs ( ) { return graphs ; }
mrodrigues/ASD-Teaching-Tool | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_select_game ) ; initialContext = this ; }
mrodrigues/ASD-Teaching-Tool | @ Override protected void onResume ( ) { super . onResume ( ) ; Integer visibility = null ; if ( Question . published ( ) . isEmpty ( ) ) { visibility = View . GONE ; } else { visibility = View . VISIBLE ; } findViewById ( R . id . startQuestions ) . setVisibility ( visibility ) ; }
mrodrigues/ASD-Teaching-Tool | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . select_game , menu ) ; return true ; }
mrodrigues/ASD-Teaching-Tool | public void startQuestionsMenu ( View v ) { Intent intent = new Intent ( this , QuestionActivity . class ) ; intent . putExtra ( QuestionActivity . EXTRA_QUESTIONS_IDS , Question . publishedIds ( ) ) ; intent . putExtra ( QuestionActivity . EXTRA_QUESTION_ID_INDEX , 0 ) ; startActivity ( intent ) ; }
mrodrigues/ASD-Teaching-Tool | public void startPecsMenu ( View v ) { startActivity ( new Intent ( this , PecsActivity . class ) ) ; }
mrodrigues/ASD-Teaching-Tool | public void startConfigMenu ( View v ) { startActivity ( new Intent ( this , ConfigActivity . class ) ) ; }
huihoo/olat | public DialogCourseNode ( ) { super ( TYPE ) ; updateModuleConfigDefaults ( true ) ; }
huihoo/olat | @ Override public TabbableController createEditController ( final UserRequest ureq , final WindowControl wControl , final ICourse course , final UserCourseEnvironment euce ) { updateModuleConfigDefaults ( false ) ; final DialogCourseNodeEditController childTabCntrllr = new DialogCourseNodeEditController ( ureq , wControl , this , course , euce ) ; final CourseNode chosenNode = course . getEditorTreeModel ( ) . getCourseNode ( euce . getCourseEditorEnv ( ) . getCurrentCourseNodeId ( ) ) ; return new NodeEditController ( ureq , wControl , course . getEditorTreeModel ( ) , course , chosenNode , course . getCourseEnvironment ( ) . getCourseGroupManager ( ) , euce , childTabCntrllr ) ; }
huihoo/olat | @ Override public NodeRunConstructionResult createNodeRunConstructionResult ( final UserRequest ureq , final WindowControl wControl , final UserCourseEnvironment userCourseEnv , final NodeEvaluation ne , final String nodecmd ) { final DialogCourseNodeRunController ctrl = new DialogCourseNodeRunController ( ureq , userCourseEnv , wControl , this , ne ) ; final Controller wrappedCtrl = TitledWrapperHelper . getWrapper ( ureq , wControl , ctrl , this , " o _ dialog _ icon " ) ; return new NodeRunConstructionResult ( wrappedCtrl ) ; }
huihoo/olat | @ Override public StatusDescription [ ] isConfigValid ( final CourseEditorEnv cev ) { oneClickStatusCache = null ; final String translatorStr = PackageUtil . getPackageName ( DialogCourseNodeEditController . class ) ; final List sds = isConfigValidWithTranslator ( cev , translatorStr , getConditionExpressions ( ) ) ; oneClickStatusCache = StatusDescriptionHelper . sort ( sds ) ; return oneClickStatusCache ; }
huihoo/olat | @ Override public RepositoryEntry getReferencedRepositoryEntry ( ) { return null ; }
huihoo/olat | @ Override public boolean needsReferenceToARepositoryEntry ( ) { return false ; }
huihoo/olat | @ Override public StatusDescription isConfigValid ( ) { if ( oneClickStatusCache != null ) { return oneClickStatusCache [ 0 ] ; } return StatusDescription . NOERROR ; }
huihoo/olat | @ Override public void updateModuleConfigDefaults ( final boolean isNewNode ) { final ModuleConfiguration config = getModuleConfiguration ( ) ; if ( isNewNode ) { config . setConfigurationVersion ( 1 ) ; config . set ( DialogConfigForm . DIALOG_CONFIG_INTEGRATION , DialogConfigForm . CONFIG_INTEGRATION_VALUE_INLINE ) ; } }
huihoo/olat | @ Override public String informOnDelete ( final Locale locale , final ICourse course ) { return null ; }
huihoo/olat | @ Override public void cleanupOnDelete ( final ICourse course ) { final DialogElementsPropertyManager depm = DialogElementsPropertyManager . getInstance ( ) ; final DialogPropertyElements findDialogElements = depm . findDialogElements ( course . getResourceableId ( ) , getIdent ( ) ) ; if ( findDialogElements != null ) { final List < DialogElement > dialogElments = findDialogElements . getDialogPropertyElements ( ) ; for ( final DialogElement dialogElement : dialogElments ) { final Long forumKey = dialogElement . getForumKey ( ) ; getForumService ( ) . deleteForum ( forumKey ) ; } } depm . deleteProperty ( course . getResourceableId ( ) , this . getIdent ( ) ) ; }
huihoo/olat | private ForumService getForumService ( ) { return ( ForumService ) CoreSpringFactory . getBean ( ForumService . class ) ; }
huihoo/olat | @ Override public boolean archiveNodeData ( final Locale locale , final ICourse course , final File exportDirectory , final String charset ) { boolean dataFound = false ; final DialogElementsPropertyManager depm = DialogElementsPropertyManager . getInstance ( ) ; final DialogPropertyElements elements = depm . findDialogElements ( course . getCourseEnvironment ( ) . getCoursePropertyManager ( ) , this ) ; List list = new ArrayList ( ) ; if ( elements != null ) { list = elements . getDialogPropertyElements ( ) ; } for ( final Iterator iter = list . iterator ( ) ; iter . hasNext ( ) ; ) { final DialogElement element = ( DialogElement ) iter . next ( ) ; doArchiveElement ( element , exportDirectory ) ; dataFound = true ; } return dataFound ; }
huihoo/olat | public void doArchiveElement ( final DialogElement element , final File exportDirectory ) { final VFSContainer forumContainer = getForumService ( ) . getForumContainer ( element . getForumKey ( ) ) ; final VFSItem dialogFile = forumContainer . getItems ( new VFSLeafFilter ( ) ) . get ( 0 ) ; final VFSContainer exportContainer = new LocalFolderImpl ( exportDirectory ) ; final java . text . SimpleDateFormat formatter = new java . text . SimpleDateFormat ( " yyyy - MM - dd ' T ' HH _ mm _ ss _ SSS " ) ; final String exportDirName = getShortTitle ( ) + " _ " + element . getForumKey ( ) + " _ " + formatter . format ( new Date ( System . currentTimeMillis ( ) ) ) ; final VFSContainer diaNodeElemExportContainer = exportContainer . createChildContainer ( exportDirName ) ; diaNodeElemExportContainer . setLocalSecurityCallback ( new FullAccessCallback ( ) ) ; diaNodeElemExportContainer . copyFrom ( dialogFile ) ; final ForumArchiveManager fam = ForumArchiveManager . getInstance ( ) ; final ForumFormatter ff = new ForumRTFFormatter ( diaNodeElemExportContainer , false ) ; fam . applyFormatter ( ff , element . getForumKey ( ) . longValue ( ) , null ) ; }
huihoo/olat | @ Override protected void calcAccessAndVisibility ( final ConditionInterpreter ci , final NodeEvaluation nodeEval ) { final boolean reader = ( getPreConditionReader ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionReader ( ) ) ) ; nodeEval . putAccessStatus ( " reader " , reader ) ; final boolean poster = ( getPreConditionPoster ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionPoster ( ) ) ) ; nodeEval . putAccessStatus ( " poster " , poster ) ; final boolean moderator = ( getPreConditionModerator ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionModerator ( ) ) ) ; nodeEval . putAccessStatus ( " moderator " , moderator ) ; final boolean visible = ( getPreConditionVisibility ( ) . getConditionExpression ( ) == null ? true : ci . evaluateCondition ( getPreConditionVisibility ( ) ) ) ; nodeEval . setVisible ( visible ) ; }
huihoo/olat | public Condition getPreConditionModerator ( ) { if ( this . preConditionModerator == null ) { this . preConditionModerator = new Condition ( ) ; this . preConditionModerator . setEasyModeCoachesAndAdmins ( true ) ; this . preConditionModerator . setEasyModeAlwaysAllowCoachesAndAdmins ( true ) ; this . preConditionModerator . setConditionExpression ( " ( ▁ ▁ ( ▁ isCourseCoach ( 0 ) ▁ | ▁ isCourseAdministrator ( 0 ) ▁ ) ▁ ) " ) ; } this . preConditionModerator . setConditionId ( " moderator " ) ; return this . preConditionModerator ; }
huihoo/olat | public void setPreConditionModerator ( Condition preConditionMod ) { if ( preConditionMod == null ) { preConditionMod = getPreConditionModerator ( ) ; } preConditionMod . setConditionId ( " moderator " ) ; this . preConditionModerator = preConditionMod ; }
huihoo/olat | public Condition getPreConditionPoster ( ) { if ( preConditionPoster == null ) { preConditionPoster = new Condition ( ) ; } preConditionPoster . setConditionId ( " poster " ) ; return preConditionPoster ; }
huihoo/olat | public void setPreConditionPoster ( Condition preConditionPoster ) { if ( preConditionPoster == null ) { preConditionPoster = getPreConditionPoster ( ) ; } preConditionPoster . setConditionId ( " poster " ) ; this . preConditionPoster = preConditionPoster ; }
huihoo/olat | public Condition getPreConditionReader ( ) { if ( preConditionReader == null ) { preConditionReader = new Condition ( ) ; } preConditionReader . setConditionId ( " reader " ) ; return preConditionReader ; }
huihoo/olat | public void setPreConditionReader ( Condition preConditionReader ) { if ( preConditionReader == null ) { preConditionReader = getPreConditionReader ( ) ; } preConditionReader . setConditionId ( " reader " ) ; this . preConditionReader = preConditionReader ; }
lifechurch/nuclei-android | public OffsetAdapterTests ( ) { super ( OffsetTestActivity . class ) ; }
lifechurch/nuclei-android | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; getActivity ( ) ; }
lifechurch/nuclei-android | public void testOffsetTests ( ) { onView ( withId ( R . id . items ) ) . check ( matches ( atPosition ( 1 , withText ( Integer . toString ( Integer . MAX_VALUE - 1 ) ) ) ) ) ; onView ( withId ( R . id . items ) ) . check ( matches ( atPosition ( 10 , withText ( Integer . toString ( Integer . MAX_VALUE - 2 ) ) ) ) ) ; for ( int i = 0 ; i < 102 ; i ++ ) { int v = i ; if ( v >= 10 ) { if ( v == 10 ) v = Integer . MAX_VALUE ; v -= 2 ; } else if ( v >= 1 ) { if ( v == 1 ) v = Integer . MAX_VALUE ; v -- ; } onView ( withId ( R . id . items ) ) . perform ( scrollToPosition ( i ) ) ; onView ( withId ( R . id . items ) ) . check ( matches ( atPosition ( i , withText ( Integer . toString ( v ) ) ) ) ) ; } }
asomov/snakeyaml | public void testGet_snippet ( ) { Mark mark = new Mark ( " test1" , 0 , 0 , 0 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; assertEquals ( " ▁ ▁ ▁ ▁ * The ▁ first ▁ line . \n ▁ ▁ ▁ ▁ ^ " , mark . get_snippet ( ) ) ; mark = new Mark ( " test1" , 0 , 0 , 0 , " The ▁ first * line . \n The ▁ last ▁ line . " . toCharArray ( ) , 9 ) ; assertEquals ( " ▁ ▁ ▁ ▁ The ▁ first * line . \n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ^ " , mark . get_snippet ( ) ) ; }
asomov/snakeyaml | public void testToString ( ) { Mark mark = new Mark ( " test1" , 0 , 0 , 0 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; String [ ] lines = mark . toString ( ) . split ( " \n " ) ; assertEquals ( " ▁ in ▁ test1 , ▁ line ▁ 1 , ▁ column ▁ 1 : " , lines [ 0 ] ) ; assertEquals ( " * The ▁ first ▁ line . " , lines [ 1 ] . trim ( ) ) ; assertEquals ( " ^ " , lines [ 2 ] . trim ( ) ) ; }
asomov/snakeyaml | public void testPosition ( ) { Mark mark = new Mark ( " test1" , 17 , 29 , 213 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; assertEquals ( " index ▁ is ▁ used ▁ in ▁ JRuby " , 17 , mark . getIndex ( ) ) ; assertEquals ( 29 , mark . getLine ( ) ) ; assertEquals ( 213 , mark . getColumn ( ) ) ; }
asomov/snakeyaml | public void testGetBuffer ( ) { Mark mark = new Mark ( " test1" , 0 , 29 , 213 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 0 ) ; int [ ] buffer = new int [ ] { 42 , 84 , 104 , 101 , 32 , 102 , 105 , 114 , 115 , 116 , 32 , 108 , 105 , 110 , 101 , 46 , 10 , 84 , 104 , 101 , 32 , 108 , 97 , 115 , 116 , 32 , 108 , 105 , 110 , 101 , 46 } ; assertTrue ( buffer . length == mark . getBuffer ( ) . length ) ; boolean match = true ; for ( int i = 0 ; i < buffer . length ; i ++ ) { if ( buffer [ i ] != mark . getBuffer ( ) [ i ] ) { match = false ; break ; } } assertTrue ( match ) ; }
asomov/snakeyaml | public void testGetPointer ( ) { Mark mark = new Mark ( " test1" , 0 , 29 , 213 , " * The ▁ first ▁ line . \n The ▁ last ▁ line . " . toCharArray ( ) , 5 ) ; assertEquals ( 5 , mark . getPointer ( ) ) ; }
HiDrive/hidrive-android-sdk | private void setErrorCode ( int errorCode ) { this . errorCode = errorCode ; }
HiDrive/hidrive-android-sdk | public int getErrorCode ( ) { return errorCode ; }
HiDrive/hidrive-android-sdk | private void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; }
HiDrive/hidrive-android-sdk | public String getErrorMessage ( ) { return errorMessage ; }
HiDrive/hidrive-android-sdk | private void setErrorDetails ( String errorDetails ) { this . errorDetails = errorDetails ; }
HiDrive/hidrive-android-sdk | public String getErrorDetails ( ) { return errorDetails ; }
HiDrive/hidrive-android-sdk | public GatewayError ( int code , String message , String details ) { this . setErrorCode ( code ) ; this . setErrorMessage ( message ) ; this . setErrorDetails ( details ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public GameButton ( TextureRegion region , float x , float y ) { this ( region , x , y , 1.0f , 0.98f ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public GameButton ( TextureRegion region , float x , float y , float width , float height ) { sprite . setRegion ( region ) ; sprite . setBounds ( x , y - height , width , height ) ; isEnabled = true ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void draw ( SpriteBatch spriteBatch ) { sprite . draw ( spriteBatch ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public boolean check ( float x , float y ) { if ( isEnabled && GameHelper . tapPointInsideRectangle ( x , y , sprite . getX ( ) , sprite . getY ( ) + sprite . getHeight ( ) , sprite . getWidth ( ) , sprite . getHeight ( ) ) ) { onClick ( ) ; return true ; } return false ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void translate ( float posX , float posY ) { sprite . setPosition ( posX , posY ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void changeTexture ( TextureRegion region ) { sprite . setRegion ( region ) ; }
igorcrevar/RollOverSphere---a-simple-libgdx-game | public void setIsEnabled ( boolean isEnabled ) { this . isEnabled = isEnabled ; }
DrDavidJ/EvoPortal | public ComputeJobDetail ( PageParameters params ) { String idStr = params . getString ( " jobID " ) ; final int jobID = Integer . parseInt ( idStr ) ; final ComputeJob job = ComputeJobsDataProvider . get ( jobID ) ; add ( new Label ( " id " , idStr ) ) ; add ( new Label ( " name " , job . getLabel ( ) ) ) ; add ( new Label ( " submitted " , new Date ( job . getSubmitTime ( ) ) . toString ( ) ) ) ; add ( new Label ( " status " , GlobalConstants . getStatusMsg ( job . getStatus ( ) ) ) ) ; add ( new Label ( " nodes " , " " + job . getNodes ( ) ) ) ; add ( new Label ( " processors " , " " + ( job . getNodes ( ) * 4 ) ) ) ; add ( new Label ( " timeRequested " , TimeUtil . millisToLongDHMS ( job . getTimeRequested ( ) ) ) ) ; add ( new Label ( " timeUsed " , TimeUtil . millisToLongDHMS ( job . getTimeUsed ( ) ) ) ) ; final String owner = job . getOwner ( ) ; String dirToZipFileString = GlobalConstants . getProperty ( " local . fileroot " ) + owner + " / " + jobID ; File dirToZipFile = new File ( dirToZipFileString ) ; if ( dirToZipFile != null && dirToZipFile . exists ( ) ) { String dirToZip = dirToZipFile . getPath ( ) ; File zipFile = new File ( jobID + " . zip " ) ; ZipFileLink zipLink = new ZipFileLink ( " zipLink " , zipFile , dirToZip ) ; add ( zipLink ) ; } else { add ( new Link ( " zipLink " ) { @ Override public void onClick ( ) { } } . setEnabled ( false ) ) ; } OutputFilesDataProvider outputFilesProvider = new OutputFilesDataProvider ( owner , jobID ) ; OutputFilesDataView outputFilesDataView = new OutputFilesDataView ( " outputFiles " , outputFilesProvider , jobID ) ; add ( outputFilesDataView ) ; setOutputMarkupId ( true ) ; add ( new AjaxSelfUpdatingTimerBehavior ( Duration . seconds ( 15 ) ) { @ Override protected void onPostProcessTarget ( AjaxRequestTarget target ) { super . onPostProcessTarget ( target ) ; if ( ' S ' != job . getStatus ( ) ) { ComputeJob refreshedJob = ComputeJobsDataProvider . get ( jobID ) ; get ( " status " ) . replaceWith ( new Label ( " status " , GlobalConstants . getStatusMsg ( refreshedJob . getStatus ( ) ) ) ) ; get ( " timeUsed " ) . replaceWith ( new Label ( " timeUsed " , Long . toString ( refreshedJob . getTimeUsed ( ) ) ) ) ; OutputFilesDataProvider outputFilesProvider = new OutputFilesDataProvider ( owner , jobID ) ; get ( " outputFiles " ) . replaceWith ( new OutputFilesDataView ( " outputFiles " , outputFilesProvider , jobID ) ) ; String dirToZipFileString = GlobalConstants . getProperty ( " local . fileroot " ) + owner + " / " + jobID ; File dirToZipFile = new File ( dirToZipFileString ) ; if ( dirToZipFile != null ) { String dirToZip = dirToZipFile . getPath ( ) ; File zipFile = new File ( jobID + " . zip " ) ; get ( " zipLink " ) . replaceWith ( new ZipFileLink ( " zipLink " , zipFile , dirToZip ) . setDeleteAfterDownload ( true ) ) ; } else { get ( " zipLink " ) . replaceWith ( new Link ( " zipLink " ) { @ Override public void onClick ( ) { } } . setEnabled ( false ) ) ; } } } } ) ; }
DrDavidJ/EvoPortal | public ComputeJobDetail ( ) { setResponsePage ( ComputeJobs . class ) ; }
DrDavidJ/EvoPortal | public ZipFileLink ( String id , File zipFile , String dirToZip ) { super ( id , zipFile ) ; ZipOutputStream zos = null ; try { zos = new ZipOutputStream ( new FileOutputStream ( zipFile ) ) ; zipDir ( dirToZip , zos ) ; } catch ( IOException ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } finally { try { zos . close ( ) ; } catch ( IOException ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } } }
DrDavidJ/EvoPortal | private void zipDir ( String dir2zip , ZipOutputStream zos ) throws IOException { File zipDir = new File ( dir2zip ) ; String [ ] dirList = zipDir . list ( ) ; byte [ ] readBuffer = new byte [ 2048 ] ; int bytesIn = 0 ; for ( int i = 0 ; i < dirList . length ; i ++ ) { File f = new File ( zipDir , dirList [ i ] ) ; if ( f . isDirectory ( ) ) { String filePath = f . getPath ( ) ; zipDir ( filePath , zos ) ; continue ; } FileInputStream fis = new FileInputStream ( f ) ; ZipEntry anEntry = new ZipEntry ( f . getName ( ) ) ; zos . putNextEntry ( anEntry ) ; while ( ( bytesIn = fis . read ( readBuffer ) ) != - 1 ) { zos . write ( readBuffer , 0 , bytesIn ) ; } fis . close ( ) ; } }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsAreEqual ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" ) ; assertEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentUUIDs ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "456" ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentParentUUIDs ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" , null , null , null , "456" ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" , null , null , null , "789" ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentTypes ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" , null , ITEM , null , null ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" , null , CONTEXT , null , null ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testEqualsWhenItemsHaveDifferentLabels ( ) { final DecisionNavigatorItem item1 = new DecisionNavigatorItem ( "123" , " Node1" , null , null , null ) ; final DecisionNavigatorItem item2 = new DecisionNavigatorItem ( "123" , " Node0" , null , null , null ) ; assertNotEquals ( item1 , item2 ) ; }
Rikkola/kie-wb-common | @ Test public void testOnClick ( ) { final Command command = mock ( Command . class ) ; final DecisionNavigatorItem item = new DecisionNavigatorItem ( " uuid " , " label " , ITEM , command , null ) ; item . onClick ( ) ; verify ( command ) . execute ( ) ; }
Rikkola/kie-wb-common | @ Test public void testRemoveChild ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( " item " ) ; final DecisionNavigatorItem child = new DecisionNavigatorItem ( " child " ) ; item . getChildren ( ) . add ( child ) ; item . removeChild ( child ) ; assertEquals ( Collections . emptySet ( ) , item . getChildren ( ) ) ; }
Rikkola/kie-wb-common | @ Test public void testAddChild ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( " item " ) ; final DecisionNavigatorItem child = new DecisionNavigatorItem ( " child " ) ; final TreeSet < DecisionNavigatorItem > expectedChildren = new TreeSet < DecisionNavigatorItem > ( ) { { add ( child ) ; } } ; item . addChild ( child ) ; item . addChild ( child ) ; assertEquals ( expectedChildren , item . getChildren ( ) ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenObjectIsNotADecisionNavigatorItem ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" ) ; final Object object = null ; final int result = item . compareTo ( object ) ; assertTrue ( result > 0 ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenItemAndObjectAreEqual ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" ) ; final Object object = new DecisionNavigatorItem ( "123" ) ; final int result = item . compareTo ( object ) ; assertEquals ( 0 , result ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenItemOrderingNameIsGreaterThanObjectOrderingName ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" , " Hat " , null , null , null ) ; final Object object = new DecisionNavigatorItem ( "456" , " Red " , null , null , null ) ; final int result = item . compareTo ( object ) ; assertTrue ( result < 0 ) ; }
Rikkola/kie-wb-common | @ Test public void testCompareToWhenItemOrderingNameIsLessThanObjectOrderingName ( ) { final DecisionNavigatorItem item = new DecisionNavigatorItem ( "123" , " Red " , null , null , null ) ; final Object object = new DecisionNavigatorItem ( "456" , " Hat " , null , null , null ) ; final int result = item . compareTo ( object ) ; assertTrue ( result > 0 ) ; }
smanvi-pivotal/geode | public SizingFlagDUnitTest ( ) { super ( ) ; }
smanvi-pivotal/geode | @ Test public void testRRMemLRU ( ) { doRRMemLRUTest ( ) ; }
smanvi-pivotal/geode | @ Test public void testRRMemLRUDeltaAndFlag ( ) { doRRMemLRUDeltaTest ( true ) ; }
smanvi-pivotal/geode | @ Test public void testRRMemLRUDelta ( ) { doRRMemLRUDeltaTest ( false ) ; }
smanvi-pivotal/geode | @ Test public void testRRListener ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; addListener ( vm0 ) ; addListener ( vm1 ) ; doListenerTestRR ( vm0 , vm1 ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRU ( ) { doPRMemLRUTest ( ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUAndFlagDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , false , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , false , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUAndFlagDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , false , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testPRMemLRUDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , false , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testPRNoLRUDelta ( ) { doPRNoLRUDeltaTest ( false ) ; }
smanvi-pivotal/geode | @ Test public void testPRNoLRUAndFlagDelta ( ) { doPRNoLRUDeltaTest ( true ) ; }
smanvi-pivotal/geode | @ Test public void testPRListener ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; addListener ( vm0 ) ; addListener ( vm1 ) ; doListenerTestPR ( vm0 , vm1 ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRU ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPRHeapLRU ( vm0 ) ; createPRHeapLRU ( vm1 ) ; put ( vm0 , new TestKey ( " a " ) , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; long origSize0 = getSizeFromPRStats ( vm0 ) ; assertTrue ( " Size ▁ was ▁ " + origSize0 , 1000 > origSize0 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origSize1 = getSizeFromPRStats ( vm1 ) ; assertTrue ( " Size ▁ was ▁ " + origSize1 , 1000 > origSize1 ) ; get ( vm0 , new TestKey ( " a " ) , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , new TestKey ( " a " ) , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertEquals ( 3 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; }
smanvi-pivotal/geode | @ Test public void testRRHeapLRU ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRRHeapLRU ( vm0 ) ; createRRHeapLRU ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; get ( vm1 , " a " , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaWithFlagPutOnPrimary ( ) { doPRDeltaTestLRU ( false , true , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , true , true , false ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaWithFlagPutOnSecondary ( ) { doPRDeltaTestLRU ( false , true , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testPRHeapLRUDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , true , false , true ) ; }
smanvi-pivotal/geode | @ Test public void testLargeDelta ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , false ) ; setDeltaRecalculatesSize ( vm1 , false ) ; createPR ( vm0 , false ) ; createPR ( vm1 , false ) ; int BIG_DELTA_SIZE = 32 * 1024 * 2 ; StringBuilder sb = new StringBuilder ( BIG_DELTA_SIZE ) ; for ( int i = 0 ; i < BIG_DELTA_SIZE ; i ++ ) { sb . append ( '7' ) ; } TestDelta delta1 = new TestDelta ( true , sb . toString ( ) ) ; assignPRBuckets ( vm0 ) ; boolean vm0isPrimary = prHostsBucketForKey ( vm0 , 0 ) ; if ( ! vm0isPrimary ) { assertEquals ( true , prHostsBucketForKey ( vm1 , 0 ) ) ; } VM primaryVm ; VM secondaryVm ; if ( vm0isPrimary ) { primaryVm = vm0 ; secondaryVm = vm1 ; } else { primaryVm = vm1 ; secondaryVm = vm0 ; } put ( secondaryVm , 0 , delta1 ) ; }
smanvi-pivotal/geode | void doPRDeltaTestLRU ( boolean shouldSizeChange , boolean heapLRU , boolean putOnPrimary , boolean wasDelta ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; if ( heapLRU ) { createPRHeapLRU ( vm0 ) ; createPRHeapLRU ( vm1 ) ; } else { createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; } assignPRBuckets ( vm0 ) ; boolean vm0isPrimary = prHostsBucketForKey ( vm0 , 0 ) ; if ( ! vm0isPrimary ) { assertEquals ( true , prHostsBucketForKey ( vm1 , 0 ) ) ; } VM primaryVm ; VM secondaryVm ; if ( vm0isPrimary ) { primaryVm = vm0 ; secondaryVm = vm1 ; } else { primaryVm = vm1 ; secondaryVm = vm0 ; } TestDelta delta1 = new TestDelta ( false , "12345" ) ; if ( putOnPrimary ) { put ( primaryVm , 0 , delta1 ) ; } else { put ( secondaryVm , 0 , delta1 ) ; } if ( putOnPrimary ) { assertValueType ( primaryVm , 0 , ValueType . CD_DESERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( primaryVm ) ) ; } else { assertValueType ( primaryVm , 0 , ValueType . CD_SERIALIZED ) ; assertEquals ( 0 , getObjectSizerInvocations ( primaryVm ) ) ; } assertValueType ( secondaryVm , 0 , ValueType . CD_SERIALIZED ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( primaryVm ) ; long origEvictionSize1 = getSizeFromEvictionStats ( secondaryVm ) ; long origPRSize0 = getSizeFromPRStats ( primaryVm ) ; long origPRSize1 = getSizeFromPRStats ( secondaryVm ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; if ( putOnPrimary ) { put ( primaryVm , 0 , delta1 ) ; } else { put ( secondaryVm , 0 , delta1 ) ; } assertValueType ( primaryVm , 0 , ValueType . CD_DESERIALIZED ) ; assertValueType ( secondaryVm , 0 , ValueType . CD_DESERIALIZED ) ; if ( shouldSizeChange ) { assertEquals ( 2 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( secondaryVm ) ) ; } else if ( wasDelta ) { assertEquals ( 0 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; } else { assertEquals ( 1 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; } long finalEvictionSize0 = getSizeFromEvictionStats ( primaryVm ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( secondaryVm ) ; long finalPRSize0 = getSizeFromPRStats ( primaryVm ) ; long finalPRSize1 = getSizeFromPRStats ( secondaryVm ) ; if ( shouldSizeChange ) { assertTrue ( finalEvictionSize0 - origEvictionSize0 != 0 ) ; assertTrue ( finalPRSize0 - origPRSize0 != 0 ) ; assertTrue ( finalEvictionSize1 - origEvictionSize1 != 0 ) ; assertTrue ( finalPRSize1 - origPRSize1 != 0 ) ; } else { assertEquals ( 0 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 0 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 0 , finalPRSize1 - origPRSize1 ) ; } }
smanvi-pivotal/geode | private void addListener ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Add ▁ listener " ) { public void run ( ) { Cache cache = getCache ( ) ; Region region = cache . getRegion ( " region " ) ; try { region . getAttributesMutator ( ) . addCacheListener ( new TestCacheListener ( ) ) ; } catch ( Exception e ) { Assert . fail ( " couldn ' t ▁ create ▁ index " , e ) ; } } } ) ; }
smanvi-pivotal/geode | private void doListenerTestRR ( VM vm0 , VM vm1 ) { assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertTrue ( origEvictionSize0 >= 100000 ) ; assertTrue ( origEvictionSize1 >= 100000 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm1 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100000 , finalEvictionSize1 - origEvictionSize1 ) ; }
smanvi-pivotal/geode | private void doListenerTestPR ( VM vm0 , VM vm1 ) { assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long origPRSize0 = getSizeFromPRStats ( vm1 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertTrue ( origEvictionSize1 >= 100000 ) ; assertTrue ( origEvictionSize0 >= 100000 ) ; assertTrue ( origPRSize0 <= 500 ) ; assertTrue ( origPRSize1 <= 500 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm1 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100000 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 100 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 100 , finalPRSize1 - origPRSize1 ) ; }
smanvi-pivotal/geode | private void doRRMemLRUTest ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; Object v = new TestObject ( 200 , 200000 ) ; get ( vm1 , " a " , v ) ; int vSize = CachedDeserializableFactory . calcSerializedMemSize ( v ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; long evictionSizeAfterGet = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 200000 + CachedDeserializableFactory . overhead ( ) - vSize , evictionSizeAfterGet - finalEvictionSize1 ) ; put ( vm0 , " b " , new TestObject ( 100 , 1000000 ) ) ; assertEquals ( 1 , getEvictions ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm1 ) ) ; get ( vm1 , " b " , new TestObject ( 100 , 1000000 ) ) ; assertEquals ( 1 , getEvictions ( vm1 ) ) ; }
smanvi-pivotal/geode | private void doPRMemLRUTest ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; put ( vm0 , 0 , new TestObject ( 100 , 100000 ) ) ; assertValueType ( vm0 , 0 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 0 , ValueType . CD_SERIALIZED ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long origPRSize0 = getSizeFromPRStats ( vm0 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; put ( vm0 , 0 , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; assertEquals ( 100 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 100 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 100 , finalPRSize1 - origPRSize1 ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; Object v = new TestObject ( 200 , 200000 ) ; get ( vm0 , 0 , v ) ; int vSize = CachedDeserializableFactory . calcSerializedMemSize ( v ) ; assertValueType ( vm0 , 0 , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , 0 , ValueType . CD_SERIALIZED ) ; long evictionSizeAfterGet = getSizeFromEvictionStats ( vm0 ) ; long prSizeAfterGet = getSizeFromPRStats ( vm0 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 200000 + CachedDeserializableFactory . overhead ( ) - vSize , evictionSizeAfterGet - finalEvictionSize0 ) ; assertEquals ( 0 , prSizeAfterGet - finalPRSize0 ) ; put ( vm0 , 113 , new TestObject ( 100 , 1024 * 1024 ) ) ; assertValueType ( vm0 , 113 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 113 , ValueType . CD_SERIALIZED ) ; long evictionSizeAfterPutVm1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 0 , getEvictions ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm1 ) ) ; get ( vm1 , 113 , new TestObject ( 100 , 1024 * 1024 ) ) ; long evictionSizeAfterGetVm1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , 113 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 113 , ValueType . EVICTED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 2 , getEvictions ( vm1 ) ) ; }
smanvi-pivotal/geode | private void doRRMemLRUDeltaTest ( boolean shouldSizeChange ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; TestDelta delta1 = new TestDelta ( false , "12345" ) ; put ( vm0 , " a " , delta1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; put ( vm0 , " a " , delta1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 5 , finalEvictionSize0 - origEvictionSize0 ) ; if ( shouldSizeChange ) { assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertTrue ( finalEvictionSize1 - origEvictionSize1 != 0 ) ; } else { assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 0 , finalEvictionSize1 - origEvictionSize1 ) ; } }
smanvi-pivotal/geode | private void doPRNoLRUDeltaTest ( boolean shouldSizeChange ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; createPR ( vm0 , false ) ; createPR ( vm1 , false ) ; TestDelta delta1 = new TestDelta ( false , "12345" ) ; put ( vm0 , " a " , delta1 ) ; long origPRSize0 = getSizeFromPRStats ( vm0 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; put ( vm0 , " a " , delta1 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; if ( shouldSizeChange ) { assertTrue ( finalPRSize0 - origPRSize0 != 0 ) ; assertTrue ( finalPRSize1 - origPRSize1 != 0 ) ; } else { assertEquals ( 0 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 0 , finalPRSize1 - origPRSize1 ) ; } }
smanvi-pivotal/geode | private long getSizeFromPRStats ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; if ( region instanceof PartitionedRegion ) { long total = 0 ; PartitionedRegion pr = ( ( PartitionedRegion ) region ) ; for ( int i = 0 ; i < pr . getPartitionAttributes ( ) . getTotalNumBuckets ( ) ; i ++ ) { total += pr . getDataStore ( ) . getBucketSize ( i ) ; } return total ; } else { return 0L ; } } } ) ; }
smanvi-pivotal/geode | private long getSizeFromEvictionStats ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getSizeFromEvictionStats ( region ) ; } } ) ; }
smanvi-pivotal/geode | private long getEvictions ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getEvictions ( region ) ; } } ) ; }
smanvi-pivotal/geode | private int getObjectSizerInvocations ( VM vm0 ) { return ( Integer ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getObjectSizerInvocations ( region ) ; } } ) ; }
smanvi-pivotal/geode | private void assignPRBuckets ( VM vm ) { vm . invoke ( new SerializableRunnable ( " assignPRBuckets " ) { public void run ( ) { Cache cache = getCache ( ) ; PartitionRegionHelper . assignBucketsToPartitions ( cache . getRegion ( " region " ) ) ; } } ) ; }
smanvi-pivotal/geode | private boolean prHostsBucketForKey ( VM vm , final Object key ) { Boolean result = ( Boolean ) vm . invoke ( new SerializableCallable ( " prHostsBucketForKey " ) { public Object call ( ) { Cache cache = getCache ( ) ; DistributedMember myId = cache . getDistributedSystem ( ) . getDistributedMember ( ) ; Region region = cache . getRegion ( " region " ) ; DistributedMember hostMember = PartitionRegionHelper . getPrimaryMemberForKey ( region , key ) ; if ( hostMember == null ) { throw new IllegalStateException ( " bucket ▁ for ▁ key ▁ " + key + " ▁ is ▁ not ▁ hosted ! " ) ; } boolean res = Boolean . valueOf ( myId . equals ( hostMember ) ) ; return res ; } } ) ; return result . booleanValue ( ) ; }
smanvi-pivotal/geode | private void put ( VM vm0 , final Object key , final Object value ) { vm0 . invoke ( new SerializableRunnable ( " Put ▁ data " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; region . put ( key , value ) ; } } ) ; }
smanvi-pivotal/geode | private void get ( VM vm0 , final Object key , final Object value ) { vm0 . invoke ( new SerializableRunnable ( " Put ▁ data " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; assertEquals ( value , region . get ( key ) ) ; } } ) ; }
smanvi-pivotal/geode | protected int getObjectSizerInvocations ( LocalRegion region ) { TestObjectSizer sizer = ( TestObjectSizer ) region . getEvictionAttributes ( ) . getObjectSizer ( ) ; int result = sizer . invocations . get ( ) ; region . getCache ( ) . getLogger ( ) . info ( " objectSizerInvocations = " + result ) ; return result ; }
smanvi-pivotal/geode | private long getSizeFromEvictionStats ( LocalRegion region ) { long result = region . getEvictionCounter ( ) ; return result ; }
smanvi-pivotal/geode | private long getEvictions ( LocalRegion region ) { return region . getTotalEvictions ( ) ; }
smanvi-pivotal/geode | private void setDeltaRecalculatesSize ( VM vm , final boolean shouldSizeChange ) { vm . invoke ( new SerializableRunnable ( " setDeltaRecalculatesSize " ) { public void run ( ) { GemFireCacheImpl . DELTAS_RECALCULATE_SIZE = shouldSizeChange ; } } ) ; }
smanvi-pivotal/geode | private void createRR ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setDiskSynchronous ( true ) ; attr . setDataPolicy ( DataPolicy . REPLICATE ) ; attr . setScope ( Scope . DISTRIBUTED_ACK ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUMemoryAttributes ( 1 , new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; Region region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | private void assertValueType ( VM vm , final Object key , final ValueType expectedType ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; Object value = region . getValueInVM ( key ) ; switch ( expectedType ) { case RAW_VALUE : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , ! ( value instanceof CachedDeserializable ) ) ; break ; case CD_SERIALIZED : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , value instanceof CachedDeserializable ) ; assertTrue ( " Value ▁ not ▁ serialized " , ( ( CachedDeserializable ) value ) . getValue ( ) instanceof byte [ ] ) ; break ; case CD_DESERIALIZED : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , value instanceof CachedDeserializable ) ; assertTrue ( " Value ▁ was ▁ serialized " , ! ( ( ( CachedDeserializable ) value ) . getValue ( ) instanceof byte [ ] ) ) ; break ; case EVICTED : assertEquals ( null , value ) ; break ; } } } ) ; }
smanvi-pivotal/geode | private File [ ] getMyDiskDirs ( ) { long random = new Random ( ) . nextLong ( ) ; File file = new File ( Long . toString ( random ) ) ; file . mkdirs ( ) ; return new File [ ] { file } ; }
smanvi-pivotal/geode | private void createPR ( VM vm , final boolean enableLRU ) { vm . invoke ( new SerializableRunnable ( " Create ▁ pr " ) { public void run ( ) { Cache cache = getCache ( ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setDiskSynchronous ( true ) ; PartitionAttributesFactory < Integer , TestDelta > paf = new PartitionAttributesFactory < Integer , TestDelta > ( ) ; paf . setRedundantCopies ( 1 ) ; if ( enableLRU ) { paf . setLocalMaxMemory ( 1 ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUMemoryAttributes ( new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; } PartitionAttributes < Integer , TestDelta > prAttr = paf . create ( ) ; attr . setPartitionAttributes ( prAttr ) ; attr . setDataPolicy ( DataPolicy . PARTITION ) ; attr . setSubscriptionAttributes ( new SubscriptionAttributes ( InterestPolicy . ALL ) ) ; Region < Integer , TestDelta > region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | private void createRRHeapLRU ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; ResourceManager manager = cache . getResourceManager ( ) ; manager . setCriticalHeapPercentage ( 95 ) ; manager . setEvictionHeapPercentage ( 90 ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUHeapAttributes ( new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; attr . setDataPolicy ( DataPolicy . REPLICATE ) ; attr . setScope ( Scope . DISTRIBUTED_ACK ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; Region region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | private void createPRHeapLRU ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ pr " ) { public void run ( ) { Cache cache = getCache ( ) ; ResourceManager manager = cache . getResourceManager ( ) ; manager . setCriticalHeapPercentage ( 95 ) ; manager . setEvictionHeapPercentage ( 90 ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; PartitionAttributesFactory < Integer , TestDelta > paf = new PartitionAttributesFactory < Integer , TestDelta > ( ) ; paf . setRedundantCopies ( 1 ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUHeapAttributes ( new TestObjectSizer ( ) , EvictionAction . LOCAL_DESTROY ) ) ; PartitionAttributes < Integer , TestDelta > prAttr = paf . create ( ) ; attr . setPartitionAttributes ( prAttr ) ; attr . setDataPolicy ( DataPolicy . PARTITION ) ; attr . setSubscriptionAttributes ( new SubscriptionAttributes ( InterestPolicy . ALL ) ) ; Region < Integer , TestDelta > region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
smanvi-pivotal/geode | public int sizeof ( Object o ) { if ( InternalDistributedSystem . getLoggerI18n ( ) . fineEnabled ( ) ) { InternalDistributedSystem . getLoggerI18n ( ) . fine ( " TestObjectSizer ▁ invoked " ) ; } if ( o instanceof TestObject ) { invocations . incrementAndGet ( ) ; return ( ( TestObject ) o ) . sizeForSizer ; } if ( o instanceof TestDelta ) { invocations . incrementAndGet ( ) ; return ( ( TestDelta ) o ) . info . length ( ) ; } if ( o instanceof Integer ) { return 0 ; } if ( o instanceof TestKey ) { invocations . incrementAndGet ( ) ; return ( ( TestKey ) o ) . value . length ( ) ; } throw new RuntimeException ( " Unpected ▁ type ▁ to ▁ be ▁ sized ▁ " + o . getClass ( ) + " , ▁ object = " + o ) ; }
smanvi-pivotal/geode | public TestKey ( ) { }
smanvi-pivotal/geode | public TestKey ( String value ) { this . value = value ; }
smanvi-pivotal/geode | public void toData ( DataOutput out ) throws IOException { DataSerializer . writeString ( value , out ) ; }
smanvi-pivotal/geode | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value == null ) ? 0 : value . hashCode ( ) ) ; return result ; }
smanvi-pivotal/geode | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof TestKey ) ) return false ; TestKey other = ( TestKey ) obj ; if ( value == null ) { if ( other . value != null ) return false ; } else if ( ! value . equals ( other . value ) ) return false ; return true ; }
smanvi-pivotal/geode | public TestObject ( ) { }
smanvi-pivotal/geode | public TestObject ( int sizeForSerialization , int sizeForSizer ) { super ( ) ; this . sizeForSizer = sizeForSizer ; this . sizeForSerialization = sizeForSerialization ; }
smanvi-pivotal/geode | public void toData ( DataOutput out ) throws IOException { out . writeInt ( sizeForSizer ) ; out . writeInt ( sizeForSerialization ) ; out . write ( new byte [ sizeForSerialization ] ) ; }
smanvi-pivotal/geode | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + sizeForSerialization ; result = prime * result + sizeForSizer ; return result ; }
smanvi-pivotal/geode | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof TestObject ) ) return false ; TestObject other = ( TestObject ) obj ; if ( sizeForSerialization != other . sizeForSerialization ) return false ; if ( sizeForSizer != other . sizeForSizer ) return false ; return true ; }
smanvi-pivotal/geode | @ Override public String toString ( ) { return " TestObject ▁ [ sizeForSerialization = " + sizeForSerialization + " , ▁ sizeForSizer = " + sizeForSizer + " ] " ; }
smanvi-pivotal/geode | @ Override public void afterCreate ( EntryEvent event ) { event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . fine ( " invoked ▁ afterCreate ▁ with ▁ " + event ) ; event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . info ( LocalizedStrings . DEBUG , " value ▁ is ▁ " + event . getNewValue ( ) ) ; }
smanvi-pivotal/geode | @ Override public void afterUpdate ( EntryEvent event ) { event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . fine ( " invoked ▁ afterUpdate ▁ with ▁ " ) ; event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . info ( LocalizedStrings . DEBUG , " value ▁ is ▁ " + event . getNewValue ( ) ) ; }
DDTH/ddth-queue | public TestInmemQueueBoundSmallEphemeralDisabled ( String testName ) { super ( testName ) ; }
DDTH/ddth-queue | @ Override protected IQueue < String , byte [ ] > initQueueInstance ( ) throws Exception { if ( System . getProperty ( " skipTestsInmem " ) != null ) { return null ; } int size = 128 ; InmemQueue < String , byte [ ] > queue = new UniversalInmemQueue ( ) ; queue . setBoundary ( size ) . setEphemeralDisabled ( true ) . init ( ) ; return queue ; }
IBM-Bluemix/BluemixBoutique | public ItemListResource ( ) { InitialContext ic ; try { ic = new InitialContext ( ) ; userTran = ( UserTransaction ) ic . lookup ( " java : comp / UserTransaction " ) ; } catch ( NamingException e ) { System . err . println ( " ERROR ▁ obtaining ▁ UserTransaction " ) ; } }
IBM-Bluemix/BluemixBoutique | @ POST public Response create ( @ FormParam ( " name " ) String name , @ FormParam ( " imgsrc " ) String imgsrc , @ FormParam ( " itemNumber " ) String itemNumber , @ FormParam ( " description " ) String description , @ FormParam ( " price " ) String price ) { ITEM item = new ITEM ( ) ; item . setName ( name ) ; item . setImgSrc ( imgsrc ) ; item . setItemNumber ( itemNumber ) ; item . setDescription ( description ) ; item . setPrice ( price ) ; EntityManager em = getEm ( ) ; try { userTran . begin ( ) ; em . persist ( item ) ; userTran . commit ( ) ; return Response . ok ( item . toString ( ) ) . build ( ) ; } catch ( Exception e ) { System . err . println ( " ERROR ▁ creating ▁ record " ) ; return Response . status ( Status . INTERNAL_SERVER_ERROR ) . build ( ) ; } }
IBM-Bluemix/BluemixBoutique | @ DELETE public Response delete ( @ QueryParam ( " id " ) long id ) { EntityManager em = getEm ( ) ; try { userTran . begin ( ) ; ITEM item = em . find ( ITEM . class , id ) ; if ( item != null ) { em . remove ( item ) ; userTran . commit ( ) ; } else { return Response . status ( Status . NOT_FOUND ) . build ( ) ; } } catch ( Exception e ) { System . err . println ( " ERROR ▁ deleting ▁ record " ) ; return Response . status ( Status . INTERNAL_SERVER_ERROR ) . build ( ) ; } return Response . ok ( ) . build ( ) ; }
IBM-Bluemix/BluemixBoutique | @ PUT public Response update ( @ FormParam ( " id " ) long id , @ FormParam ( " name " ) String name , @ FormParam ( " age " ) int age ) { EntityManager em = getEm ( ) ; ITEM item = em . find ( ITEM . class , id ) ; if ( item != null ) { item . setName ( name ) ; try { userTran . begin ( ) ; em . refresh ( item ) ; userTran . commit ( ) ; } catch ( Exception e ) { System . err . println ( " ERROR ▁ updating ▁ record " ) ; } finally { em . close ( ) ; } return Response . ok ( ) . build ( ) ; } else return Response . status ( Status . NOT_FOUND ) . build ( ) ; }
IBM-Bluemix/BluemixBoutique | @ GET @ Produces ( MediaType . APPLICATION_JSON ) public Response get ( @ QueryParam ( " id " ) long id ) throws Exception { EntityManager em = getEm ( ) ; if ( id == 0 ) { List < ITEM > list = em . createQuery ( " SELECT ▁ t ▁ FROM ▁ ITEM ▁ t " , ITEM . class ) . getResultList ( ) ; String json = " { \" id \" : \" all \" , ▁ \" body \" : " + list . toString ( ) + " } " ; return Response . ok ( json ) . build ( ) ; } ITEM item = null ; try { userTran . begin ( ) ; item = em . find ( ITEM . class , id ) ; userTran . commit ( ) ; } catch ( Exception e ) { em . close ( ) ; } if ( item != null ) return Response . ok ( item . toString ( ) ) . build ( ) ; else return Response . status ( Status . NOT_FOUND ) . build ( ) ; }
redkale/redkale-plugins | @ Override public boolean acceptsConf ( AnyValue config ) { return " search " . equalsIgnoreCase ( config . getValue ( " dbtype " ) ) ; }
redkale/redkale-plugins | @ Override public Class < ? extends DataSource > sourceClass ( ) { return OpenSearchSource . class ; }
xuegongzi/rabbitframework | @ Override public boolean configure ( final FeatureContext context ) { final Configuration config = context . getConfiguration ( ) ; if ( ! config . isRegistered ( FreemarkerViewProcessor . class ) ) { context . register ( FreemarkerViewProcessor . class ) ; if ( ! config . isRegistered ( MvcFeature . class ) ) { context . register ( MvcFeature . class ) ; } return true ; } return false ; }
StreamReduce/streamreduce-core | @ Override public MessageDetailsType getMessageDetailsType ( ) { return MessageDetailsType . NODEBELLY ; }
StreamReduce/streamreduce-core | public Builder ( ) { theObject = new NodebellyMessageDetails ( ) ; }
StreamReduce/streamreduce-core | public Builder title ( String title ) { theObject . title = title . trim ( ) ; return this ; }
StreamReduce/streamreduce-core | public Builder details ( String details ) { theObject . details = details . trim ( ) ; return this ; }
StreamReduce/streamreduce-core | public Builder structure ( Map < String , Object > structure ) { theObject . structure = structure ; return this ; }
StreamReduce/streamreduce-core | public NodebellyMessageDetails build ( ) { return theObject ; }
StreamReduce/streamreduce-core | public String getDetails ( ) { return details ; }
ibauersachs/jitsi | public NotificationGroup ( String groupName ) { this . groupName = groupName ; }
ibauersachs/jitsi | @ Override public Object getDescriptor ( ) { return groupName ; }
ibauersachs/jitsi | @ Override public String getDisplayName ( ) { return groupName ; }
ibauersachs/jitsi | @ Override public int getSourceIndex ( ) { return 0 ; }
ibauersachs/jitsi | @ Override public UIGroup getParentGroup ( ) { return null ; }
ibauersachs/jitsi | @ Override public boolean isGroupCollapsed ( ) { return false ; }
ibauersachs/jitsi | @ Override public int countOnlineChildContacts ( ) { return contacts . size ( ) ; }
ibauersachs/jitsi | @ Override public int countChildContacts ( ) { return contacts . size ( ) ; }
ibauersachs/jitsi | @ Override public String getId ( ) { return null ; }
ibauersachs/jitsi | @ Override public GroupNode getGroupNode ( ) { return groupNode ; }
ibauersachs/jitsi | @ Override public void setGroupNode ( GroupNode groupNode ) { this . groupNode = groupNode ; }
ibauersachs/jitsi | @ Override public JPopupMenu getRightButtonMenu ( ) { return null ; }
ibauersachs/jitsi | public Iterator < ? extends UIContact > getNotifications ( ) { return contacts . values ( ) . iterator ( ) ; }
ibauersachs/jitsi | public void messageWaitingNotify ( MessageWaitingEvent event ) { Iterator < NotificationMessage > messages = event . getMessages ( ) ; if ( messages != null ) { Enumeration < String > contactIdentifiers = contacts . keys ( ) ; while ( contactIdentifiers . hasMoreElements ( ) ) { String identifier = contactIdentifiers . nextElement ( ) ; boolean toRemove = true ; messages = event . getMessages ( ) ; while ( messages . hasNext ( ) ) { NotificationMessage message = messages . next ( ) ; String messageIdentifier = message . getFromContact ( ) + message . getMessageDetails ( ) ; if ( identifier . equals ( messageIdentifier ) ) { toRemove = false ; break ; } } if ( toRemove ) { removeNotificationContact ( contacts . get ( identifier ) ) ; contacts . remove ( identifier ) ; } } messages = event . getMessages ( ) ; while ( messages . hasNext ( ) ) { NotificationMessage message = messages . next ( ) ; if ( message . getMessageGroup ( ) . equals ( groupName ) ) { String messageIdentifier = message . getFromContact ( ) + message . getMessageDetails ( ) ; NotificationContact contact = contacts . get ( messageIdentifier ) ; boolean isNew = false ; if ( contact == null ) { contact = new NotificationContact ( this , event . getSourceProvider ( ) , event . getMessageType ( ) , message ) ; contacts . put ( messageIdentifier , contact ) ; isNew = true ; } contact . setMessageAccount ( event . getAccount ( ) ) ; addNotificationContact ( contact , isNew ) ; } } } else { ProtocolProviderService protocolProvider = event . getSourceProvider ( ) ; NotificationContact contact = contacts . get ( protocolProvider . toString ( ) ) ; boolean isNew = false ; if ( contact == null ) { contact = new NotificationContact ( this , protocolProvider , event . getMessageType ( ) , null ) ; contacts . put ( protocolProvider . toString ( ) , contact ) ; isNew = true ; } contact . setMessageAccount ( event . getAccount ( ) ) ; contact . setUnreadUrgentMessageCount ( event . getUnreadUrgentMessages ( ) ) ; contact . setUnreadMessageCount ( event . getUnreadMessages ( ) ) ; contact . setReadMessageCount ( event . getReadMessages ( ) ) ; addNotificationContact ( contact , isNew ) ; } }
ibauersachs/jitsi | private void addNotificationContact ( NotificationContact contact , boolean isNew ) { TreeContactList contactList = GuiActivator . getContactList ( ) ; if ( contactList . getCurrentFilter ( ) . isMatching ( contact ) ) { if ( isNew ) contactList . addContact ( contact , this , true , true ) ; else contactList . refreshContact ( contact ) ; } if ( contact . getUnreadMessageCount ( ) > 0 ) { if ( uiNotificationGroup == null ) uiNotificationGroup = new UINotificationGroup ( getDisplayName ( ) , GuiActivator . getResources ( ) . getI18NString ( " service . gui . VOICEMAIL _ TOOLTIP " ) ) ; UINotificationManager . addNotification ( new UINotification ( contact . getDisplayName ( ) , contact . getDisplayName ( ) + " ▁ : ▁ " + contact . getDisplayDetails ( ) , System . currentTimeMillis ( ) , uiNotificationGroup , contact . getUnreadMessageCount ( ) ) ) ; } }
ibauersachs/jitsi | private void removeNotificationContact ( NotificationContact contact ) { TreeContactList contactList = GuiActivator . getContactList ( ) ; if ( contactList . getCurrentFilter ( ) . isMatching ( contact ) ) { contactList . removeContact ( contact ) ; } }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public DbCalendarReminderSensor ( ) { }
Telecooperation/assistance-platform-client-sdk-android | public DbCalendarReminderSensor ( Long id ) { this . id = id ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public DbCalendarReminderSensor ( Long id , long reminderId , Long eventId , Integer method , Integer minutes , Boolean isNew , Boolean isUpdated , Boolean isDeleted , String created , Long deviceId ) { this . id = id ; this . reminderId = reminderId ; this . eventId = eventId ; this . method = method ; this . minutes = minutes ; this . isNew = isNew ; this . isUpdated = isUpdated ; this . isDeleted = isDeleted ; this . created = created ; this . deviceId = deviceId ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void __setDaoSession ( DaoSession daoSession ) { this . daoSession = daoSession ; myDao = daoSession != null ? daoSession . getDbCalendarReminderSensorDao ( ) : null ; }
Telecooperation/assistance-platform-client-sdk-android | public Long getId ( ) { return id ; }
Telecooperation/assistance-platform-client-sdk-android | public void setId ( Long id ) { this . id = id ; }
Telecooperation/assistance-platform-client-sdk-android | public long getReminderId ( ) { return reminderId ; }
Telecooperation/assistance-platform-client-sdk-android | public void setReminderId ( long reminderId ) { this . reminderId = reminderId ; }
Telecooperation/assistance-platform-client-sdk-android | public Long getEventId ( ) { return eventId ; }
Telecooperation/assistance-platform-client-sdk-android | public void setEventId ( Long eventId ) { this . eventId = eventId ; }
Telecooperation/assistance-platform-client-sdk-android | public Integer getMethod ( ) { return method ; }
Telecooperation/assistance-platform-client-sdk-android | public void setMethod ( Integer method ) { this . method = method ; }
Telecooperation/assistance-platform-client-sdk-android | public Integer getMinutes ( ) { return minutes ; }
Telecooperation/assistance-platform-client-sdk-android | public void setMinutes ( Integer minutes ) { this . minutes = minutes ; }
Telecooperation/assistance-platform-client-sdk-android | public Boolean getIsNew ( ) { return isNew ; }
Telecooperation/assistance-platform-client-sdk-android | public void setIsNew ( Boolean isNew ) { this . isNew = isNew ; }
Telecooperation/assistance-platform-client-sdk-android | public Boolean getIsUpdated ( ) { return isUpdated ; }
Telecooperation/assistance-platform-client-sdk-android | public void setIsUpdated ( Boolean isUpdated ) { this . isUpdated = isUpdated ; }
Telecooperation/assistance-platform-client-sdk-android | public Boolean getIsDeleted ( ) { return isDeleted ; }
Telecooperation/assistance-platform-client-sdk-android | public void setIsDeleted ( Boolean isDeleted ) { this . isDeleted = isDeleted ; }
Telecooperation/assistance-platform-client-sdk-android | @ NotNull public String getCreated ( ) { return created ; }
Telecooperation/assistance-platform-client-sdk-android | public void setCreated ( @ NotNull String created ) { this . created = created ; }
Telecooperation/assistance-platform-client-sdk-android | public Long getDeviceId ( ) { return deviceId ; }
Telecooperation/assistance-platform-client-sdk-android | public void setDeviceId ( Long deviceId ) { this . deviceId = deviceId ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public DbDevice getDbDevice ( ) { Long __key = this . deviceId ; if ( dbDevice__resolvedKey == null || ! dbDevice__resolvedKey . equals ( __key ) ) { __throwIfDetached ( ) ; DbDeviceDao targetDao = daoSession . getDbDeviceDao ( ) ; DbDevice dbDeviceNew = targetDao . load ( __key ) ; synchronized ( this ) { dbDevice = dbDeviceNew ; dbDevice__resolvedKey = __key ; } } return dbDevice ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void setDbDevice ( DbDevice dbDevice ) { synchronized ( this ) { this . dbDevice = dbDevice ; deviceId = dbDevice == null ? null : dbDevice . getId ( ) ; dbDevice__resolvedKey = deviceId ; } }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void delete ( ) { __throwIfDetached ( ) ; myDao . delete ( this ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void update ( ) { __throwIfDetached ( ) ; myDao . update ( this ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated public void refresh ( ) { __throwIfDetached ( ) ; myDao . refresh ( this ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Generated private void __throwIfDetached ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } }
ogregoire/imgn | @ BeforeEach protected void setUp ( ) { sink = new TestByteSink ( ) ; }
ogregoire/imgn | @ Test public void testOpenBufferedStream ( ) throws IOException { OutputStream out = sink . openBufferedStream ( ) ; assertThat ( sink . wasStreamOpened ( ) ) . isTrue ( ) ; assertThat ( sink . wasStreamClosed ( ) ) . isFalse ( ) ; out . write ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; out . close ( ) ; assertThat ( sink . wasStreamClosed ( ) ) . isTrue ( ) ; assertThat ( sink . getBytes ( ) ) . isEqualTo ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; }
ogregoire/imgn | @ Test public void testWrite_bytes ( ) { assertThat ( sink . getBytes ( ) ) . isEqualTo ( new byte [ 0 ] ) ; sink . write ( bytes ) ; assertThat ( sink . wasStreamOpened ( ) && sink . wasStreamClosed ( ) ) . isTrue ( ) ; assertThat ( sink . getBytes ( ) ) . isEqualTo ( bytes ) ; }
ogregoire/imgn | @ Test public void testWriteFrom_inputStream ( ) throws IOException { ByteArrayInputStream in = new ByteArrayInputStream ( bytes ) ; sink . writeFrom ( in ) ; assertThat ( sink . wasStreamOpened ( ) && sink . wasStreamClosed ( ) ) . isTrue ( ) ; assertThat ( sink . getBytes ( ) ) . isEqualTo ( bytes ) ; }
ogregoire/imgn | @ Test public void testWriteFromStream_doesNotCloseThatStream ( ) throws IOException { TestInputStream in = new TestInputStream ( new ByteArrayInputStream ( new byte [ 10 ] ) ) ; assertThat ( in . closed ( ) ) . isFalse ( ) ; sink . writeFrom ( in ) ; assertThat ( in . closed ( ) ) . isFalse ( ) ; }
ogregoire/imgn | @ Test public void testClosesOnErrors_copyingFromByteSourceThatThrows ( ) { for ( TestOption option : EnumSet . of ( OPEN_THROWS , READ_THROWS , CLOSE_THROWS ) ) { TestByteSource failSource = new TestByteSource ( new byte [ 10 ] , option ) ; TestByteSink okSink = new TestByteSink ( ) ; assertThatThrownBy ( ( ) -> { failSource . copyTo ( okSink ) ; } ) . isInstanceOf ( UncheckedIOException . class ) ; assertThat ( ! okSink . wasStreamOpened ( ) || okSink . wasStreamClosed ( ) ) . isTrue ( ) ; } }
ogregoire/imgn | @ Test public void testClosesOnErrors_whenWriteThrows ( ) { TestByteSink failSink = new TestByteSink ( WRITE_THROWS ) ; assertThatThrownBy ( ( ) -> { new TestByteSource ( new byte [ 10 ] ) . copyTo ( failSink ) ; } ) . isInstanceOf ( UncheckedIOException . class ) ; assertThat ( failSink . wasStreamClosed ( ) ) . isTrue ( ) ; }
ogregoire/imgn | @ Test public void testClosesOnErrors_writingFromInputStreamThatThrows ( ) { TestByteSink okSink = new TestByteSink ( ) ; assertThatThrownBy ( ( ) -> { TestInputStream in = new TestInputStream ( new ByteArrayInputStream ( new byte [ 10 ] ) , READ_THROWS ) ; okSink . writeFrom ( in ) ; } ) . isInstanceOf ( UncheckedIOException . class ) ; assertThat ( okSink . wasStreamClosed ( ) ) . isTrue ( ) ; }
BryceARich/TransactionsMR | @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; helper . setUp ( ) ; servlet = new MapReduceServlet ( ) ; }
BryceARich/TransactionsMR | @ Override public void tearDown ( ) throws Exception { helper . tearDown ( ) ; super . tearDown ( ) ; }
BryceARich/TransactionsMR | public void testBailsOnBadHandler ( ) throws Exception { HttpServletRequest request = createMockRequest ( " fizzle " , true , true ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; replay ( request , response ) ; try { servlet . doPost ( request , response ) ; fail ( " Should ▁ have ▁ thrown ▁ RuntimeException " ) ; } catch ( RuntimeException e ) { } verify ( request , response ) ; }
BryceARich/TransactionsMR | public void testCommandError ( ) throws Exception { HttpServletRequest request = createMockRequest ( MapReduceServletImpl . COMMAND_PATH + " / " + StatusHandler . GET_JOB_DETAIL_PATH , false , true ) ; expect ( request . getMethod ( ) ) . andReturn ( " GET " ) . anyTimes ( ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; PrintWriter responseWriter = createMock ( PrintWriter . class ) ; responseWriter . write ( ' { ' ) ; responseWriter . write ( " \" error _ class \" " ) ; responseWriter . write ( ' : ' ) ; responseWriter . write ( " \" java . lang . RuntimeException \" " ) ; responseWriter . write ( ' , ' ) ; responseWriter . write ( " \" error _ message \" " ) ; responseWriter . write ( ' : ' ) ; responseWriter . write ( " \" Full ▁ stack ▁ trace ▁ is ▁ available ▁ in ▁ the ▁ server ▁ logs . ▁ " + " Message : ▁ blargh \" " ) ; responseWriter . write ( ' } ' ) ; responseWriter . flush ( ) ; expect ( request . getParameter ( " mapreduce _ id " ) ) . andThrow ( new RuntimeException ( " blargh " ) ) ; response . setContentType ( " application / json " ) ; expect ( response . getWriter ( ) ) . andReturn ( responseWriter ) . anyTimes ( ) ; replay ( request , response , responseWriter ) ; servlet . doPost ( request , response ) ; verify ( request , response , responseWriter ) ; }
BryceARich/TransactionsMR | public void testControllerCSRF ( ) throws Exception { HttpServletRequest request = createMockRequest ( CONTROLLER_PATH , false , true ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; response . sendError ( 403 , " Received ▁ unexpected ▁ non - task ▁ queue ▁ request . " ) ; replay ( request , response ) ; servlet . doPost ( request , response ) ; verify ( request , response ) ; }
BryceARich/TransactionsMR | public void testGetJobDetailCSRF ( ) throws Exception { HttpServletRequest request = createMockRequest ( MapReduceServletImpl . COMMAND_PATH + " / " + StatusHandler . GET_JOB_DETAIL_PATH , true , false ) ; expect ( request . getMethod ( ) ) . andReturn ( " POST " ) . anyTimes ( ) ; HttpServletResponse response = createMock ( HttpServletResponse . class ) ; response . setContentType ( " application / json " ) ; EasyMock . expectLastCall ( ) . anyTimes ( ) ; response . sendError ( 403 , " Received ▁ unexpected ▁ non - XMLHttpRequest ▁ command . " ) ; replay ( request , response ) ; servlet . doGet ( request , response ) ; verify ( request , response ) ; }
BryceARich/TransactionsMR | public void testStaticResources_jQuery ( ) throws Exception { HttpServletResponse resp = createMock ( HttpServletResponse . class ) ; resp . setContentType ( " text / javascript " ) ; resp . setHeader ( " Cache - Control " , " public ; ▁ max - age = 300" ) ; ServletOutputStream sos = createMock ( ServletOutputStream . class ) ; expect ( resp . getOutputStream ( ) ) . andReturn ( sos ) ; sos . write ( ( byte [ ] ) EasyMock . anyObject ( ) , EasyMock . eq ( 0 ) , EasyMock . anyInt ( ) ) ; EasyMock . expectLastCall ( ) . atLeastOnce ( ) ; sos . flush ( ) ; EasyMock . expectLastCall ( ) . anyTimes ( ) ; replay ( resp , sos ) ; MapReduceServletImpl . handleStaticResources ( " jquery . js " , resp ) ; verify ( resp , sos ) ; }
BryceARich/TransactionsMR | public void testStaticResources_status ( ) throws Exception { HttpServletResponse resp = createMock ( HttpServletResponse . class ) ; resp . sendRedirect ( " / _ ah / pipeline / list ? class _ path = " + MapReduceJob . class . getName ( ) ) ; replay ( resp ) ; MapReduceServletImpl . handleStaticResources ( " status " , resp ) ; verify ( resp ) ; }
codes13/android-drawable-creator | DensityType ( String folderName ) { this . folderName = folderName ; }
codes13/android-drawable-creator | public String getFolderName ( ) { return folderName ; }
antoinesd/weld-core | public SimpleExtension getSimpleExtension ( ) { return simpleExtension ; }
tejksat/docker-java | @ CheckForNull public Long getParallelism ( ) { return parallelism ; }
tejksat/docker-java | public UpdateConfig withParallelism ( long parallelism ) { this . parallelism = parallelism ; return this ; }
tejksat/docker-java | @ CheckForNull public Long getDelay ( ) { return delay ; }
tejksat/docker-java | public UpdateConfig setDelay ( Long delay ) { this . delay = delay ; return this ; }
tejksat/docker-java | @ CheckForNull public UpdateFailureAction getFailureAction ( ) { return failureAction ; }
tejksat/docker-java | public UpdateConfig withFailureAction ( UpdateFailureAction failureAction ) { this . failureAction = failureAction ; return this ; }
tejksat/docker-java | public UpdateConfig withParallelism ( Long parallelism ) { this . parallelism = parallelism ; return this ; }
tejksat/docker-java | public UpdateConfig withDelay ( Long delay ) { this . delay = delay ; return this ; }
tejksat/docker-java | public Float getMaxFailureRatio ( ) { return maxFailureRatio ; }
tejksat/docker-java | public UpdateConfig withMaxFailureRatio ( Float maxFailureRatio ) { this . maxFailureRatio = maxFailureRatio ; return this ; }
tejksat/docker-java | public Long getMonitor ( ) { return monitor ; }
tejksat/docker-java | public UpdateConfig withMonitor ( Long monitor ) { this . monitor = monitor ; return this ; }
tejksat/docker-java | public UpdateOrder getOrder ( ) { return order ; }
tejksat/docker-java | public UpdateConfig withOrder ( UpdateOrder order ) { this . order = order ; return this ; }
gzussa/javacodegen | public Service ( ) { super ( ) ; }
gzussa/javacodegen | public Service ( String fileName , String packageName ) { super ( fileName , packageName ) ; }
gzussa/javacodegen | public String getName ( ) { return getFileName ( ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsTrueIfGivenDayIsAWorkDay ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 26 ) ; boolean returnValue = DateUtil . isWorkDay ( date ) ; Assert . assertTrue ( " Should ▁ return ▁ true ▁ for ▁ a ▁ work ▁ day " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsFalseIfGivenDayIsNotAWorkDay ( ) { DateMidnight date = new DateMidnight ( 2014 , 11 , 23 ) ; boolean returnValue = DateUtil . isWorkDay ( date ) ; Assert . assertFalse ( " Should ▁ return ▁ false ▁ for ▁ not ▁ a ▁ work ▁ day " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectFirstDayOfMonth ( ) { int year = 2014 ; int month = 11 ; DateMidnight firstDayOfMonth = new DateMidnight ( year , month , 1 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ first ▁ day ▁ of ▁ month " , firstDayOfMonth , DateUtil . getFirstDayOfMonth ( year , month ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectLastDayOfMonth ( ) { int year = 2014 ; int month = 11 ; DateMidnight lastDayOfMonth = new DateMidnight ( year , month , 30 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ last ▁ day ▁ of ▁ month " , lastDayOfMonth , DateUtil . getLastDayOfMonth ( year , month ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectLastDayOfMonthForSpecialMonths ( ) { int year = 2014 ; int month = 2 ; DateMidnight lastDayOfMonth = new DateMidnight ( year , month , 28 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ last ▁ day ▁ of ▁ month " , lastDayOfMonth , DateUtil . getLastDayOfMonth ( year , month ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectFirstDayOfYear ( ) { int year = 2014 ; DateMidnight firstDayOfYear = new DateMidnight ( year , 1 , 1 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ first ▁ day ▁ of ▁ year " , firstDayOfYear , DateUtil . getFirstDayOfYear ( year ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsCorrectLastDayOfYear ( ) { int year = 2014 ; DateMidnight lastDayOfYear = new DateMidnight ( year , 12 , 31 ) ; Assert . assertEquals ( " Not ▁ the ▁ correct ▁ last ▁ day ▁ of ▁ year " , lastDayOfYear , DateUtil . getLastDayOfYear ( year ) ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsTrueForChristmasEve ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 24 ) ; boolean returnValue = DateUtil . isChristmasEve ( date ) ; Assert . assertTrue ( " Should ▁ return ▁ true ▁ for ▁ 24th ▁ December " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsFalseForNotChristmasEve ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 25 ) ; boolean returnValue = DateUtil . isChristmasEve ( date ) ; Assert . assertFalse ( " Should ▁ return ▁ false ▁ for ▁ 25th ▁ December " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsTrueForNewYearsEve ( ) { DateMidnight date = new DateMidnight ( 2014 , 12 , 31 ) ; boolean returnValue = DateUtil . isNewYearsEve ( date ) ; Assert . assertTrue ( " Should ▁ return ▁ true ▁ for ▁ 31st ▁ December " , returnValue ) ; }
Intera/urlaubsverwaltung | @ Test public void ensureReturnsFalseForNotNewYearsEve ( ) { DateMidnight date = new DateMidnight ( 2011 , 12 , 25 ) ; boolean returnValue = DateUtil . isNewYearsEve ( date ) ; Assert . assertFalse ( " Should ▁ return ▁ false ▁ for ▁ 25th ▁ December " , returnValue ) ; }
fnp/pylucene | public void testFilter ( ) throws Exception { TokenStream stream = new MockTokenizer ( new StringReader ( " Do ▁ have ▁ a ▁ nice ▁ day " ) , MockTokenizer . WHITESPACE , false ) ; ReverseStringFilter filter = new ReverseStringFilter ( TEST_VERSION_CURRENT , stream ) ; assertTokenStreamContents ( filter , new String [ ] { " oD " , " evah " , " a " , " ecin " , " yad " } ) ; }
fnp/pylucene | public void testFilterWithMark ( ) throws Exception { TokenStream stream = new MockTokenizer ( new StringReader ( " Do ▁ have ▁ a ▁ nice ▁ day " ) , MockTokenizer . WHITESPACE , false ) ; ReverseStringFilter filter = new ReverseStringFilter ( TEST_VERSION_CURRENT , stream , ' \u0001' ) ; assertTokenStreamContents ( filter , new String [ ] { " \u0001oD " , " \u0001evah " , " \u0001a " , " \u0001ecin " , " \u0001yad " } ) ; }
fnp/pylucene | public void testReverseString ( ) throws Exception { assertEquals ( " A " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " A " ) ) ; assertEquals ( " BA " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " AB " ) ) ; assertEquals ( " CBA " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " ABC " ) ) ; }
fnp/pylucene | public void testReverseChar ( ) throws Exception { char [ ] buffer = { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 2 , 3 ) ; assertEquals ( " ABEDCF " , new String ( buffer ) ) ; }
fnp/pylucene | public void testBackCompat ( ) throws Exception { assertEquals ( " \uDF05\uD866\uDF05\uD866" , ReverseStringFilter . reverse ( " 𩬅𩬅 " ) ) ; }
fnp/pylucene | public void testReverseSupplementary ( ) throws Exception { assertEquals ( " 𩬅艱鍟䇹愯瀛 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 瀛愯䇹鍟艱𩬅 " ) ) ; assertEquals ( " a𩬅艱鍟䇹愯瀛 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 瀛愯䇹鍟艱𩬅a " ) ) ; assertEquals ( " fedcba𩬅 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 𩬅abcdef " ) ) ; assertEquals ( " fedcba𩬅z " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " z𩬅abcdef " ) ) ; assertEquals ( " gfe𩬅dcba " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " abcd𩬅efg " ) ) ; }
fnp/pylucene | public void testReverseSupplementaryChar ( ) throws Exception { char [ ] buffer = " abc瀛愯䇹鍟艱𩬅 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abc𩬅艱鍟䇹愯瀛 " , new String ( buffer ) ) ; buffer = " abc瀛愯䇹鍟艱𩬅d " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 8 ) ; assertEquals ( " abcd𩬅艱鍟䇹愯瀛 " , new String ( buffer ) ) ; buffer = " abc𩬅瀛愯䇹鍟艱 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abc艱鍟䇹愯瀛𩬅 " , new String ( buffer ) ) ; buffer = " abcd𩬅瀛愯䇹鍟艱 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 8 ) ; assertEquals ( " abc艱鍟䇹愯瀛𩬅d " , new String ( buffer ) ) ; buffer = " abc瀛愯𩬅def " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abcfed𩬅愯瀛 " , new String ( buffer ) ) ; }
timrdf/csv2rdf4lod | public DateTimePatternQuerylet ( Resource context , int csvColumnIndex ) { super ( context , csvColumnIndex ) ; }
timrdf/csv2rdf4lod | @ Override public String getQueryString ( Resource context ) { this . addNamespace ( " rdfs " , " xsd " , " ov " , " conversion " ) ; String select = " distinct ▁ ? pattern ▁ ? range ▁ ? timezone " ; String graphPattern = " ? cp ▁ conversion : enhance ▁ [ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \n " + " ▁ ▁ ▁ " + columnPO ( ) + " ; ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \n " + " ▁ ▁ ▁ conversion : pattern ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ? pattern ; ▁ ▁ \n " + " ▁ ▁ ▁ conversion : range ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ? range ; ▁ ▁ ▁ ▁ \n " + " ] ▁ . ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \n " + " optional ▁ { ▁ ? cp ▁ conversion : datetime _ timezone ▁ ? timezone ; ▁ } " ; String orderBy = " " ; return this . composeQuery ( select , context , graphPattern , orderBy ) ; }
timrdf/csv2rdf4lod | @ Override public void handleBindingSet ( BindingSet bindingSet ) { String pattern = bindingSet . getValue ( " pattern " ) . stringValue ( ) ; String range = bindingSet . getValue ( " range " ) . stringValue ( ) ; this . patterns . put ( pattern , ValueFactoryImpl . getInstance ( ) . createURI ( range ) ) ; if ( bindingSet . hasBinding ( " timezone " ) ) { this . timezone = Integer . parseInt ( bindingSet . getValue ( " timezone " ) . stringValue ( ) ) ; } System . err . println ( ColumnEnhancementQuerylet . REPORT_INDENT + getClass ( ) . getSimpleName ( ) + " ( " + this . csvColumnIndex + " ) ▁ . " + pattern + " . ▁ timezone : ▁ . " + timezone + " . ▁ a ▁ " + range ) ; }
timrdf/csv2rdf4lod | public HashMap < String , URI > get ( ) { return this . patterns ; }
timrdf/csv2rdf4lod | public int getTimezone ( ) { return this . timezone ; }
jdrider/rhodes | public String [ ] getDeletedObjects ( ) { return mDeletedObjects ; }
jdrider/rhodes | public String [ ] getUpdatedObjects ( ) { return mUpdatedObjects ; }
jdrider/rhodes | public String [ ] getCreatedObjects ( ) { return mCreatedObjects ; }
jdrider/rhodes | public int [ ] getDeletedSourceIds ( ) { return mDeletedSrcIds ; }
jdrider/rhodes | public int [ ] getUpdatedSourceIds ( ) { return mUpdatedSrcIds ; }
jdrider/rhodes | public int [ ] getCreatedSourceIds ( ) { return mCreatedSrcIds ; }
Talend/data-prep | private DataSetGetSchema ( final String dataSetId ) { super ( GenericCommand . DATASET_GROUP ) ; this . dataSetId = dataSetId ; on ( HttpStatus . NO_CONTENT ) . then ( asNull ( ) ) ; }
Talend/data-prep | @ PostConstruct private void initConfiguration ( ) { URI datasetURI ; try { datasetURI = new URIBuilder ( datasetServiceUrl + " / api / v1 / datasets / " + dataSetId + " / schema " ) . build ( ) ; } catch ( URISyntaxException e ) { throw new TDPException ( UNEXPECTED_EXCEPTION , e ) ; } execute ( ( ) -> { HttpGet httpGet = new HttpGet ( datasetURI ) ; httpGet . setHeader ( ACCEPT , AvroUtils . AVRO_JSON_MIME_TYPES_UNOFFICIAL_VALID_VALUE ) ; return httpGet ; } ) ; on ( HttpStatus . OK ) . then ( ( req , res ) -> { try ( InputStream inputStream = res . getEntity ( ) . getContent ( ) ) { return new Schema . Parser ( ) . parse ( inputStream ) ; } catch ( IOException e ) { throw new TDPException ( UNEXPECTED_EXCEPTION , e ) ; } finally { req . releaseConnection ( ) ; } } ) ; }
thomasmaurel/ensj-healthcheck | public EnaAnalysisTypes ( ) { super ( ) ; }
thomasmaurel/ensj-healthcheck | @ Override protected String getEgDescription ( ) { return " Test ▁ for ▁ whether ▁ ENA - specific ▁ analysis ▁ types ▁ remain " ; }
thomasmaurel/ensj-healthcheck | @ Override protected boolean runTest ( final DatabaseRegistryEntry dbre ) { final Pattern enaPattern = Pattern . compile ( " . * ena . * " , Pattern . CASE_INSENSITIVE ) ; final EnsTestCase test = this ; List < String > failures = getTemplate ( dbre ) . queryForList ( TEST_SQL , new RowMapper < String > ( ) { @ Override public String mapRow ( ResultSet resultSet , int position ) throws SQLException { String logicName = resultSet . getString ( 1 ) ; String description = resultSet . getString ( 2 ) ; String displayLabel = resultSet . getString ( 3 ) ; String webData = resultSet . getString ( 4 ) ; if ( ! StringUtils . isEmpty ( logicName ) && enaPattern . matcher ( logicName ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ logic _ name ▁ contains ▁ the ▁ string ▁ ' ena ' " ) ; } if ( ! StringUtils . isEmpty ( description ) && enaPattern . matcher ( description ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ description ▁ contains ▁ the ▁ string ▁ ' ena ' : ▁ " + description ) ; } if ( ! StringUtils . isEmpty ( displayLabel ) && enaPattern . matcher ( displayLabel ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ display _ Label ▁ contains ▁ the ▁ string ▁ ' ena ' : ▁ " + displayLabel ) ; } if ( ! StringUtils . isEmpty ( webData ) && enaPattern . matcher ( webData ) . matches ( ) ) { ReportManager . problem ( test , dbre . getConnection ( ) , " Analysis ▁ " + logicName + " ▁ web _ Data ▁ contains ▁ the ▁ string ▁ ' ena ' : ▁ " + webData ) ; } return logicName ; } } ) ; return failures . size ( ) == 0 ; }
Timpy/Glimmer | public String getTerm ( ) { return term ; }
Timpy/Glimmer | public void setTerm ( String term ) { this . term = term ; }
Timpy/Glimmer | public int getTermFrequency ( ) { return termFrequency ; }
Timpy/Glimmer | public void setTermFrequency ( int termFrequency ) { this . termFrequency = termFrequency ; }
Timpy/Glimmer | public int getOccurrenceCount ( ) { return occurrenceCount ; }
Timpy/Glimmer | public void setOccurrenceCount ( int occurrenceCount ) { this . occurrenceCount = occurrenceCount ; }
Timpy/Glimmer | public long getSumOfMaxTermPositions ( ) { return sumOfMaxTermPositions ; }
Timpy/Glimmer | public void setSumOfMaxTermPositions ( long sumOfMaxTermPositions ) { this . sumOfMaxTermPositions = sumOfMaxTermPositions ; }
Timpy/Glimmer | public void set ( IndexRecordWriterTermValue that ) { this . term = that . term ; this . termFrequency = that . termFrequency ; this . occurrenceCount = that . occurrenceCount ; this . sumOfMaxTermPositions = that . sumOfMaxTermPositions ; }
Timpy/Glimmer | @ Override public void readFields ( DataInput arg0 ) throws IOException { }
Timpy/Glimmer | @ Override public void write ( DataOutput arg0 ) throws IOException { }
Timpy/Glimmer | @ Override public int compareTo ( IndexRecordWriterValue value ) { if ( value instanceof IndexRecordWriterTermValue ) { IndexRecordWriterTermValue that = ( IndexRecordWriterTermValue ) value ; long i = term . compareTo ( that . term ) ; if ( i != 0 ) { i = termFrequency - that . termFrequency ; if ( i != 0 ) { i = occurrenceCount - that . occurrenceCount ; if ( i != 0 ) { i = sumOfMaxTermPositions - that . sumOfMaxTermPositions ; } } } if ( i > 0 ) { return 1 ; } else if ( i < 0 ) { return - 1 ; } return 0 ; } return - 1 ; }
Timpy/Glimmer | @ Override public boolean equals ( Object o ) { if ( o instanceof IndexRecordWriterTermValue ) { IndexRecordWriterTermValue that = ( IndexRecordWriterTermValue ) o ; if ( termFrequency == that . termFrequency && occurrenceCount == that . occurrenceCount && sumOfMaxTermPositions == that . sumOfMaxTermPositions ) { return term . equals ( that . term ) ; } } return false ; }
Timpy/Glimmer | @ Override public int hashCode ( ) { int hash = 11 ; hash = 31 * hash + term . hashCode ( ) ; hash = 31 * hash + termFrequency ; hash = 31 * hash + occurrenceCount ; hash = 31 * hash + ( int ) ( sumOfMaxTermPositions ^ ( sumOfMaxTermPositions >>> 32 ) ) ; return hash ; }
Timpy/Glimmer | @ Override public String toString ( ) { return term + ' : ' + termFrequency + ' : ' + occurrenceCount + ' : ' + sumOfMaxTermPositions ; }
vivantech/kc_fixes | public Integer getModuleNumber ( ) { return moduleNumber ; }
vivantech/kc_fixes | public void setModuleNumber ( Integer moduleNumber ) { this . moduleNumber = moduleNumber ; }
vivantech/kc_fixes | public String getProposalNumber ( ) { return proposalNumber ; }
vivantech/kc_fixes | public void setProposalNumber ( String proposalNumber ) { this . proposalNumber = proposalNumber ; }
vivantech/kc_fixes | public String getUserId ( ) { return userId ; }
vivantech/kc_fixes | public void setUserId ( String userId ) { this . userId = userId ; }
vivantech/kc_fixes | public String getAccessType ( ) { return accessType ; }
vivantech/kc_fixes | public void setAccessType ( String accessType ) { this . accessType = accessType ; }
vivantech/kc_fixes | public String getPersonName ( ) { return personName ; }
vivantech/kc_fixes | public void setPersonName ( String personName ) { this . personName = personName ; }
quarkusio/quarkus | @ Test void testHeadersWithSubresource ( ) { Client client = RestClientBuilder . newBuilder ( ) . baseUri ( baseUri ) . build ( Client . class ) ; assertThat ( client . cookieSub ( " bar " , " bar2" ) . send ( " bar3" , " bar4" ) ) . isEqualTo ( " bar : bar2 : bar3 : bar4" ) ; }
quarkusio/quarkus | @ Test void testNullHeaders ( ) { Client client = RestClientBuilder . newBuilder ( ) . baseUri ( baseUri ) . build ( Client . class ) ; assertThat ( client . cookieSub ( " bar " , null ) . send ( null , " bar4" ) ) . isEqualTo ( " bar : null : null : bar4" ) ; }
quarkusio/quarkus | @ GET public String returnHeaders ( @ HeaderParam ( " foo " ) String header , @ HeaderParam ( " foo2" ) String header2 , @ HeaderParam ( " foo3" ) String header3 , @ HeaderParam ( " foo4" ) String header4 ) { return header + " : " + header2 + " : " + header3 + " : " + header4 ; }
ecarm002/incubator-asterixdb | @ Override public IScalarEvaluatorFactory createEvaluatorFactory ( final IScalarEvaluatorFactory [ ] args ) { return new IScalarEvaluatorFactory ( ) { private static final long serialVersionUID = 1L ; private final int baseOffset = stringOffset ; @ Override public IScalarEvaluator createScalarEvaluator ( IHyracksTaskContext ctx ) throws HyracksDataException { return new AbstractBinaryStringIntEval ( ctx , args [ 0 ] , args [ 1 ] , StringPositionDescriptor . this . getIdentifier ( ) , sourceLoc ) { @ Override protected int compute ( UTF8StringPointable left , UTF8StringPointable right ) throws IOException { int pos = UTF8StringPointable . find ( left , right , false ) ; return pos < 0 ? pos : pos + baseOffset ; } } ; } } ; }
ecarm002/incubator-asterixdb | @ Override public FunctionIdentifier getIdentifier ( ) { return BuiltinFunctions . STRING_POSITION ; }
nkurihar/pulsar | @ BeforeMethod public void before ( ) { pulsarSourceBuilder = PulsarSourceBuilder . builder ( new TestDeserializationSchema ( ) ) ; }
nkurihar/pulsar | @ Test public void testBuild ( ) { SourceFunction sourceFunction = pulsarSourceBuilder . serviceUrl ( " testServiceUrl " ) . topic ( " testTopic " ) . subscriptionName ( " testSubscriptionName " ) . build ( ) ; Assert . assertNotNull ( sourceFunction ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testBuildWithoutSettingRequiredProperties ( ) { pulsarSourceBuilder . build ( ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testServiceUrlWithNull ( ) { pulsarSourceBuilder . serviceUrl ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testServiceUrlWithBlank ( ) { pulsarSourceBuilder . serviceUrl ( " ▁ " ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicWithNull ( ) { pulsarSourceBuilder . topic ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicWithBlank ( ) { pulsarSourceBuilder . topic ( " ▁ " ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicsWithNull ( ) { pulsarSourceBuilder . topics ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicsWithBlank ( ) { pulsarSourceBuilder . topics ( Arrays . asList ( " ▁ " , " ▁ " ) ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicPatternWithNull ( ) { pulsarSourceBuilder . topicsPattern ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicPatternAlreadySet ( ) { pulsarSourceBuilder . topicsPattern ( Pattern . compile ( " persistent : // tenants / ns / topic - * " ) ) ; pulsarSourceBuilder . topicsPattern ( Pattern . compile ( " persistent : // tenants / ns / topic - my - * " ) ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testTopicPattenStringWithNull ( ) { pulsarSourceBuilder . topicsPatternString ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testSubscriptionNameWithNull ( ) { pulsarSourceBuilder . subscriptionName ( null ) ; }
nkurihar/pulsar | @ Test ( expectedExceptions = IllegalArgumentException . class ) public void testSubscriptionNameWithBlank ( ) { pulsarSourceBuilder . subscriptionName ( " ▁ " ) ; }
nkurihar/pulsar | @ Override public T deserialize ( byte [ ] bytes ) throws IOException { return null ; }
nkurihar/pulsar | @ Override public boolean isEndOfStream ( T t ) { return false ; }
nkurihar/pulsar | @ Override public TypeInformation < T > getProducedType ( ) { return null ; }
jalian-systems/marathonv5 | @ Override public void start ( Stage stage ) { Scene scene = new Scene ( new Group ( ) ) ; stage . setTitle ( " Checkbox ▁ Sample " ) ; stage . setWidth ( 250 ) ; stage . setHeight ( 150 ) ; rect . setArcHeight ( 10 ) ; rect . setArcWidth ( 10 ) ; rect . setFill ( Color . rgb ( 41 , 41 , 41 ) ) ; for ( int i = 0 ; i < names . length ; i ++ ) { final Image image = images [ i ] = new Image ( getClass ( ) . getResourceAsStream ( names [ i ] + " . png " ) ) ; final ImageView icon = icons [ i ] = new ImageView ( ) ; final CheckBox cb = cbs [ i ] = new CheckBox ( names [ i ] ) ; cb . selectedProperty ( ) . addListener ( ( ObservableValue < ? extends Boolean > ov , Boolean old_val , Boolean new_val ) -> { icon . setImage ( new_val ? image : null ) ; } ) ; } VBox vbox = new VBox ( ) ; vbox . getChildren ( ) . addAll ( cbs ) ; vbox . setSpacing ( 5 ) ; HBox hbox = new HBox ( ) ; hbox . getChildren ( ) . addAll ( icons ) ; hbox . setPadding ( new Insets ( 0 , 0 , 0 , 5 ) ) ; StackPane stack = new StackPane ( ) ; stack . getChildren ( ) . add ( rect ) ; stack . getChildren ( ) . add ( hbox ) ; StackPane . setAlignment ( rect , Pos . TOP_CENTER ) ; HBox root = new HBox ( ) ; root . getChildren ( ) . add ( vbox ) ; root . getChildren ( ) . add ( stack ) ; root . setSpacing ( 40 ) ; root . setPadding ( new Insets ( 20 , 10 , 10 , 20 ) ) ; ( ( Group ) scene . getRoot ( ) ) . getChildren ( ) . add ( root ) ; stage . setScene ( scene ) ; stage . show ( ) ; }
thankpoint/thanks4java | @ Override default String getAlgorithm ( ) { return ALGORITHM_SHA1PRNG ; }
grasscrm/gdesigner | public BoundednessChecker ( PTNetInterpreter interpreter , PTNet net ) { this . net = net ; this . interpreter = interpreter ; this . markings_strings = new HashSet < String > ( ) ; this . markings_stack = new ArrayList < int [ ] > ( ) ; }
grasscrm/gdesigner | public boolean checkBoundedness ( ) { return doCheck ( net . getInitialMarking ( ) ) ; }
grasscrm/gdesigner | protected boolean doCheck ( Marking marking ) { String markingStr = marking . toString ( ) ; if ( markings_strings . contains ( markingStr ) ) return true ; markings_strings . add ( markingStr ) ; int [ ] m_b = getMarking ( marking ) ; if ( hasFoundInferiorMarking ( m_b ) ) return false ; markings_stack . add ( m_b ) ; List < Transition > transitions = interpreter . getEnabledTransitions ( net , marking ) ; for ( Transition t : transitions ) { Marking newmarking = interpreter . fireTransition ( net , marking , t ) ; if ( ! doCheck ( newmarking ) ) return false ; } markings_stack . remove ( markings_stack . size ( ) - 1 ) ; return true ; }
grasscrm/gdesigner | protected int [ ] getMarking ( Marking marking ) { int [ ] mb = new int [ net . getPlaces ( ) . size ( ) ] ; int i = 0 ; for ( Iterator < Place > it = net . getPlaces ( ) . iterator ( ) ; it . hasNext ( ) ; i ++ ) { Place p = it . next ( ) ; mb [ i ] = marking . getNumTokens ( p ) ; } return mb ; }
grasscrm/gdesigner | protected boolean hasFoundInferiorMarking ( int [ ] mb ) { for ( Iterator < int [ ] > it = markings_stack . iterator ( ) ; it . hasNext ( ) ; ) { int [ ] mb2 = it . next ( ) ; boolean found = true ; for ( int i = 0 ; i < mb . length ; i ++ ) { if ( mb2 [ i ] > mb [ i ] ) { found = false ; break ; } } if ( found ) return true ; } return false ; }
McJty/EFab | @ Override public void render ( GridTE te , double x , double y , double z , float partialTicks , int destroyStage , float alpha ) { super . render ( te , x , y , z , partialTicks , destroyStage , alpha ) ; if ( te . getWorld ( ) . isAirBlock ( te . getPos ( ) ) ) { return ; } GlStateManager . pushMatrix ( ) ; GlStateManager . translate ( x + .5 , y , z + .5 ) ; GlStateManager . disableRescaleNormal ( ) ; rotateFacing ( te ) ; renderHandles ( te ) ; GlStateManager . popMatrix ( ) ; }
McJty/EFab | private void renderHandles ( GridTE tileEntity ) { bindTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) ; boolean half = GridBlock . isHalfBlock ( tileEntity . getWorld ( ) , tileEntity . getPos ( ) ) ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 3 ; y ++ ) { renderHandle ( tileEntity , x , y , half ) ; } } }
alpinweiss/filegen | public SheetProcessor ( ParameterVault parameterVault , CountDownLatch startSignal , CountDownLatch doneSignal , CellStyle cs , SXSSFSheet sheet , int columnCount , Map < Integer , Input2TableInfo > input2TableInfoMap , OutputWriterHolder outputWriterHolder ) { this . parameterVault = parameterVault ; this . startSignal = startSignal ; this . doneSignal = doneSignal ; this . cs = cs ; this . sheet = sheet ; this . columnCount = columnCount ; this . input2TableInfoMap = input2TableInfoMap ; this . outputWriterHolder = outputWriterHolder ; }
alpinweiss/filegen | public SheetProcessor ( OutputWriterHolder outputWriterHolder ) { this . outputWriterHolder = outputWriterHolder ; }
alpinweiss/filegen | @ Override public void run ( ) { try { startSignal . await ( ) ; generateSheetData ( parameterVault , cs , sheet , columnCount , input2TableInfoMap ) ; doneSignal . countDown ( ) ; } catch ( InterruptedException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } }
alpinweiss/filegen | public void generateSheetData ( ParameterVault parameterVault , CellStyle cs , SXSSFSheet sheet , int columnCount , Map < Integer , Input2TableInfo > hashMap ) { Cell cell ; int idx = 0 ; int idy = 0 ; Row row = sheet . createRow ( idx ) ; Input2TableInfo input2TableInfo ; for ( Integer key : hashMap . keySet ( ) ) { input2TableInfo = hashMap . get ( key ) ; cell = row . createCell ( idy ) ; cell . setCellValue ( input2TableInfo . getFieldText ( ) ) ; cell . setCellStyle ( cs ) ; sheet . setColumnWidth ( idy , ( input2TableInfo . getFieldText ( ) . trim ( ) . length ( ) * 500 ) ) ; idy ++ ; } ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; for ( int i = 1 ; i < parameterVault . rowCount ( ) + 1 ; i ++ ) { row = sheet . createRow ( i ) ; if ( i != 0 && i % 10000 == 0 ) { outputWriterHolder . writeValueInLine ( Thread . currentThread ( ) . getName ( ) + " ▁ Processed ▁ " + i + " ▁ rows " ) ; } for ( int colCount = 0 ; colCount < columnCount ; colCount ++ ) { final Cell dataCell = row . createCell ( colCount ) ; input2TableInfo = hashMap . get ( colCount ) ; final CellStyle cellStyle = input2TableInfo . getCellStyle ( ) ; input2TableInfo . generator ( ) . generate ( parameterVault . setIterationNumber ( i ) , randomGenerator , new ValueVault ( ) { @ Override public void storeValue ( DataWrapper wrapper ) { FieldType fieldType = wrapper . getFieldType ( ) ; switch ( fieldType ) { case DATE : dataCell . setCellValue ( wrapper . getDateValue ( ) ) ; dataCell . setCellStyle ( cellStyle ) ; break ; case FLOAT : case INTEGER : dataCell . setCellType ( Cell . CELL_TYPE_NUMERIC ) ; dataCell . setCellValue ( wrapper . getNumberValue ( ) ) ; break ; case AUTONUMBER : dataCell . setCellType ( Cell . CELL_TYPE_NUMERIC ) ; dataCell . setCellValue ( wrapper . getNumberValue ( ) ) ; case SEQUENCE : default : dataCell . setCellValue ( wrapper . getStringValue ( ) ) ; } } } ) ; } } }
PRIDE-Utilities/jmzml | public String getRef ( ) { return ref ; }
PRIDE-Utilities/jmzml | public void setRef ( String value ) { this . ref = value ; }
PRIDE-Utilities/jmzml | public ReferenceableParamGroup getReferenceableParamGroup ( ) { return referenceableParamGroup ; }
PRIDE-Utilities/jmzml | public void setReferenceableParamGroup ( ReferenceableParamGroup referenceableParamGroup ) { this . referenceableParamGroup = referenceableParamGroup ; if ( referenceableParamGroup != null ) { this . ref = referenceableParamGroup . getId ( ) ; } }
facebook/fresco | private ImagePerfUtils ( ) { }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order ) { this . router = router ; this . order = order ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , HttpMethod method , String path ) { this ( router , order ) ; methods . add ( method ) ; checkPath ( path ) ; setPath ( path ) ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , String path ) { this ( router , order ) ; checkPath ( path ) ; setPath ( path ) ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , HttpMethod method , String regex , boolean bregex ) { this ( router , order ) ; methods . add ( method ) ; setRegex ( regex ) ; }
sibay/vertx-web | RouteImpl ( RouterImpl router , int order , String regex , boolean bregex ) { this ( router , order ) ; setRegex ( regex ) ; }
sibay/vertx-web | @ Override public synchronized Route method ( HttpMethod method ) { methods . add ( method ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route path ( String path ) { checkPath ( path ) ; setPath ( path ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route pathRegex ( String regex ) { setRegex ( regex ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route produces ( String contentType ) { ParsableMIMEValue value = new ParsableMIMEValue ( contentType ) . forceParse ( ) ; produces . add ( value ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route consumes ( String contentType ) { ParsableMIMEValue value = new ParsableMIMEValue ( contentType ) . forceParse ( ) ; consumes . add ( value ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route order ( int order ) { if ( added ) { throw new IllegalStateException ( " Can ' t ▁ change ▁ order ▁ after ▁ route ▁ is ▁ active " ) ; } this . order = order ; return this ; }
sibay/vertx-web | @ Override public synchronized Route last ( ) { return order ( Integer . MAX_VALUE ) ; }
sibay/vertx-web | @ Override public synchronized Route handler ( Handler < RoutingContext > contextHandler ) { if ( this . contextHandler != null ) { log . warn ( " Setting ▁ handler ▁ for ▁ a ▁ route ▁ more ▁ than ▁ once ! " ) ; } this . contextHandler = contextHandler ; checkAdd ( ) ; return this ; }
sibay/vertx-web | @ Override public Route blockingHandler ( Handler < RoutingContext > contextHandler ) { return blockingHandler ( contextHandler , true ) ; }
sibay/vertx-web | @ Override public synchronized Route blockingHandler ( Handler < RoutingContext > contextHandler , boolean ordered ) { return handler ( new BlockingHandlerDecorator ( contextHandler , ordered ) ) ; }
sibay/vertx-web | @ Override public synchronized Route failureHandler ( Handler < RoutingContext > exceptionHandler ) { if ( this . failureHandler != null ) { log . warn ( " Setting ▁ failureHandler ▁ for ▁ a ▁ route ▁ more ▁ than ▁ once ! " ) ; } this . failureHandler = exceptionHandler ; checkAdd ( ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route remove ( ) { router . remove ( this ) ; return this ; }
sibay/vertx-web | @ Override public synchronized Route disable ( ) { enabled = false ; return this ; }
sibay/vertx-web | @ Override public synchronized Route enable ( ) { enabled = true ; return this ; }
sibay/vertx-web | @ Override public Route useNormalisedPath ( boolean useNormalisedPath ) { this . useNormalisedPath = useNormalisedPath ; return this ; }
sibay/vertx-web | @ Override public String getPath ( ) { return path ; }
sibay/vertx-web | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( " Route [ ▁ " ) ; sb . append ( " path : " ) . append ( path ) ; sb . append ( " ▁ pattern : " ) . append ( pattern ) ; sb . append ( " ▁ handler : " ) . append ( contextHandler ) ; sb . append ( " ▁ failureHandler : " ) . append ( failureHandler ) ; sb . append ( " ▁ order : " ) . append ( order ) ; sb . append ( " ▁ methods : [ " ) ; int cnt = 0 ; for ( HttpMethod method : methods ) { sb . append ( method ) ; cnt ++ ; if ( cnt < methods . size ( ) ) { sb . append ( " , " ) ; } } sb . append ( " ] ] @ " ) . append ( System . identityHashCode ( this ) ) ; return sb . toString ( ) ; }
sibay/vertx-web | synchronized void handleContext ( RoutingContext context ) { if ( contextHandler != null ) { contextHandler . handle ( context ) ; } }
sibay/vertx-web | synchronized void handleFailure ( RoutingContext context ) { if ( failureHandler != null ) { failureHandler . handle ( context ) ; } }
sibay/vertx-web | synchronized boolean matches ( RoutingContext context , String mountPoint , boolean failure ) { if ( failure && failureHandler == null || ! failure && contextHandler == null ) { return false ; } if ( ! enabled ) { return false ; } HttpServerRequest request = context . request ( ) ; if ( ! methods . isEmpty ( ) && ! methods . contains ( request . method ( ) ) ) { return false ; } if ( path != null && pattern == null && ! pathMatches ( mountPoint , context ) ) { return false ; } if ( pattern != null ) { String path = useNormalisedPath ? Utils . normalizePath ( context . request ( ) . path ( ) ) : context . request ( ) . path ( ) ; if ( mountPoint != null ) { path = path . substring ( mountPoint . length ( ) ) ; } Matcher m = pattern . matcher ( path ) ; if ( m . matches ( ) ) { if ( m . groupCount ( ) > 0 ) { Map < String , String > params = new HashMap < > ( m . groupCount ( ) ) ; if ( groups != null ) { for ( int i = 0 ; i < groups . size ( ) ; i ++ ) { final String k = groups . get ( i ) ; final String value = Utils . urlDecode ( m . group ( " p " + i ) , false ) ; if ( ! request . params ( ) . contains ( k ) ) { params . put ( k , value ) ; } else { context . pathParams ( ) . put ( k , value ) ; } } } else { for ( int i = 0 ; i < m . groupCount ( ) ; i ++ ) { String group = m . group ( i + 1 ) ; if ( group != null ) { final String k = " param " + i ; final String value = Utils . urlDecode ( group , false ) ; if ( ! request . params ( ) . contains ( k ) ) { params . put ( k , value ) ; } else { context . pathParams ( ) . put ( k , value ) ; } } } } request . params ( ) . addAll ( params ) ; context . pathParams ( ) . putAll ( params ) ; } } else { return false ; } } if ( ! consumes . isEmpty ( ) ) { MIMEHeader contentType = context . parsedHeaders ( ) . contentType ( ) ; MIMEHeader consumal = contentType . findMatchedBy ( consumes ) ; if ( consumal == null ) { return false ; } } List < MIMEHeader > acceptableTypes = context . parsedHeaders ( ) . accept ( ) ; if ( ! produces . isEmpty ( ) && ! acceptableTypes . isEmpty ( ) ) { MIMEHeader selectedAccept = context . parsedHeaders ( ) . findBestUserAcceptedIn ( acceptableTypes , produces ) ; if ( selectedAccept != null ) { context . setAcceptableContentType ( selectedAccept . rawValue ( ) ) ; return true ; } return false ; } return true ; }
sibay/vertx-web | RouterImpl router ( ) { return router ; }
sibay/vertx-web | private boolean pathMatches ( String mountPoint , RoutingContext ctx ) { String thePath = mountPoint == null ? path : mountPoint + path ; String requestPath ; if ( useNormalisedPath ) { requestPath = Utils . normalizePath ( ctx . request ( ) . path ( ) ) ; } else { requestPath = ctx . request ( ) . path ( ) ; if ( requestPath == null ) { requestPath = " / " ; } } if ( exactPath ) { return pathMatchesExact ( requestPath , thePath ) ; } else { if ( thePath . endsWith ( " / " ) && requestPath . equals ( removeTrailing ( thePath ) ) ) { return true ; } return requestPath . startsWith ( thePath ) ; } }
sibay/vertx-web | private boolean pathMatchesExact ( String path1 , String path2 ) { return removeTrailing ( path1 ) . equals ( removeTrailing ( path2 ) ) ; }
sibay/vertx-web | private String removeTrailing ( String path ) { int i = path . length ( ) ; if ( path . charAt ( i - 1 ) == ' / ' ) { path = path . substring ( 0 , i - 1 ) ; } return path ; }
sibay/vertx-web | private void setPath ( String path ) { if ( path . indexOf ( ' : ' ) != - 1 ) { createPatternRegex ( path ) ; this . path = path ; } else { if ( path . charAt ( path . length ( ) - 1 ) != ' * ' ) { exactPath = true ; this . path = path ; } else { exactPath = false ; this . path = path . substring ( 0 , path . length ( ) - 1 ) ; } } }
sibay/vertx-web | private void setRegex ( String regex ) { pattern = Pattern . compile ( regex ) ; }
sibay/vertx-web | private void createPatternRegex ( String path ) { path = RE_OPERATORS_NO_STAR . matcher ( path ) . replaceAll ( " \\ \\ $ 1" ) ; if ( path . charAt ( path . length ( ) - 1 ) == ' * ' ) { path = path . substring ( 0 , path . length ( ) - 1 ) + " . * " ; } Matcher m = Pattern . compile ( " : ( [ A - Za - z ] [ A - Za - z0-9 _ ] * ) " ) . matcher ( path ) ; StringBuffer sb = new StringBuffer ( ) ; groups = new ArrayList < > ( ) ; int index = 0 ; while ( m . find ( ) ) { String param = " p " + index ; String group = m . group ( ) . substring ( 1 ) ; if ( groups . contains ( group ) ) { throw new IllegalArgumentException ( " Cannot ▁ use ▁ identifier ▁ " + group + " ▁ more ▁ than ▁ once ▁ in ▁ pattern ▁ string " ) ; } m . appendReplacement ( sb , " ( ? < " + param + " > [ ^ / ] + ) " ) ; groups . add ( group ) ; index ++ ; } m . appendTail ( sb ) ; path = sb . toString ( ) ; pattern = Pattern . compile ( path ) ; }
sibay/vertx-web | private void checkPath ( String path ) { if ( " " . equals ( path ) || path . charAt ( 0 ) != ' / ' ) { throw new IllegalArgumentException ( " Path ▁ must ▁ start ▁ with ▁ / " ) ; } }
sibay/vertx-web | int order ( ) { return order ; }
sibay/vertx-web | private void checkAdd ( ) { if ( ! added ) { router . add ( this ) ; added = true ; } }
bendraaisma/gnuob-soap | @ Override @ Transient public boolean isDetached ( ) { return newArrayList ( isAbstractTypeDetached ( ) , isAddressDetached ( ) ) . stream ( ) . filter ( e -> e . booleanValue ( ) ) . count ( ) > ZERO ; }
bendraaisma/gnuob-soap | @ Transient private boolean isAddressDetached ( ) { return address != null && address . isDetached ( ) ; }
bendraaisma/gnuob-soap | @ Override public Context accept ( final IContextVisitor visitor ) { return visitor . visit ( this ) ; }
bendraaisma/gnuob-soap | , orphanRemoval = true ) public Address getAddress ( ) { return address ; }
bendraaisma/gnuob-soap | @ XmlElement ( required = true ) @ Column ( name = BUYER_EMAIL_COLUMN_NAME , nullable = false ) public String getBuyerEmail ( ) { return buyerEmail ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = BUYER_MARKETING_EMAIL_COLUMN_NAME ) public String getBuyerMarketingEmail ( ) { return buyerMarketingEmail ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = CONTACT_PHONE_COLUMN_NAME ) public String getContactPhone ( ) { return contactPhone ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = DATE_OF_BIRTH_COLUMN_NAME ) public Date getDateOfBirth ( ) { return dateOfBirth ; }
bendraaisma/gnuob-soap | @ XmlElement ( required = true ) @ Column ( name = FIRST_NAME_COLUMN_NAME , nullable = false ) public String getFirstName ( ) { return firstName ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = FRIENDLY_NAME_COLUMN_NAME ) public String getFriendlyName ( ) { if ( isBlank ( friendlyName ) ) { if ( isNotBlank ( getMiddleName ( ) ) ) { friendlyName = getFirstName ( ) + " ▁ " + getMiddleName ( ) + " ▁ " + getLastName ( ) ; } else { friendlyName = getFirstName ( ) + " ▁ " + getLastName ( ) ; } } return friendlyName ; }
bendraaisma/gnuob-soap | @ XmlElement ( required = true ) @ Column ( name = LAST_NAME_COLUMN_NAME , nullable = false ) public String getLastName ( ) { return lastName ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = MIDDLE_NAME_COLUMN_NAME ) public String getMiddleName ( ) { return middleName ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_COLUMN_NAME ) public String getPayer ( ) { return payer ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_BUSINESS_COLUMN_NAME ) public String getPayerBusiness ( ) { return payerBusiness ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_ID_COLUMN_NAME ) public String getPayerId ( ) { return payerId ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = PAYER_STATUS_COLUMN_NAME ) public String getPayerStatus ( ) { return payerStatus ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = SALUTATION_COLUMN_NAME ) public String getSalutation ( ) { return salutation ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = SUFFIX_COLUMN_NAME ) public String getSuffix ( ) { return suffix ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = TAX_ID_COLUMN_NAME ) public String getTaxId ( ) { return taxId ; }
bendraaisma/gnuob-soap | @ XmlElement @ Column ( name = TAX_ID_TYPE_COLUMN_NAME ) public String getTaxIdType ( ) { return taxIdType ; }
bendraaisma/gnuob-soap | public void setAddress ( final Address address ) { this . address = address ; }
bendraaisma/gnuob-soap | public void setBuyerEmail ( final String buyerEmail ) { this . buyerEmail = buyerEmail ; }
bendraaisma/gnuob-soap | public void setBuyerMarketingEmail ( final String buyerMarketingEmail ) { this . buyerMarketingEmail = buyerMarketingEmail ; }
bendraaisma/gnuob-soap | public void setContactPhone ( final String contactPhone ) { this . contactPhone = contactPhone ; }
bendraaisma/gnuob-soap | public void setDateOfBirth ( final Date dateOfBirth ) { this . dateOfBirth = dateOfBirth ; }
bendraaisma/gnuob-soap | public void setFirstName ( final String firstName ) { this . firstName = firstName ; }
bendraaisma/gnuob-soap | public void setFriendlyName ( final String friendlyName ) { this . friendlyName = friendlyName ; }
bendraaisma/gnuob-soap | public void setLastName ( final String lastName ) { this . lastName = lastName ; }
bendraaisma/gnuob-soap | public void setMiddleName ( final String middleName ) { this . middleName = middleName ; }
bendraaisma/gnuob-soap | public void setPayer ( final String payer ) { this . payer = payer ; }
bendraaisma/gnuob-soap | public void setPayerBusiness ( final String payerBusiness ) { this . payerBusiness = payerBusiness ; }
bendraaisma/gnuob-soap | public void setPayerId ( final String payerId ) { this . payerId = payerId ; }
bendraaisma/gnuob-soap | public void setPayerStatus ( final String payerStatus ) { this . payerStatus = payerStatus ; }
bendraaisma/gnuob-soap | public void setSalutation ( final String salutation ) { this . salutation = salutation ; }
bendraaisma/gnuob-soap | public void setSuffix ( final String suffix ) { this . suffix = suffix ; }
bendraaisma/gnuob-soap | public void setTaxId ( final String taxId ) { this . taxId = taxId ; }
bendraaisma/gnuob-soap | public void setTaxIdType ( final String taxIdType ) { this . taxIdType = taxIdType ; }
charlesccychen/beam | LoadTest ( String [ ] args , Class < OptionsT > testOptions , String metricsNamespace ) throws IOException { this . metricsNamespace = metricsNamespace ; this . runtimeMonitor = new TimeMonitor < > ( metricsNamespace , " runtime " ) ; this . options = LoadTestOptions . readFromArgs ( args , testOptions ) ; this . sourceOptions = fromJsonString ( options . getSourceOptions ( ) , SyntheticBoundedIO . SyntheticSourceOptions . class ) ; this . stepOptions = fromJsonString ( options . getStepOptions ( ) , SyntheticStep . Options . class ) ; this . pipeline = Pipeline . create ( options ) ; }
charlesccychen/beam | public PipelineResult run ( ) throws IOException { long testStartTime = System . currentTimeMillis ( ) ; loadTest ( ) ; PipelineResult result = pipeline . run ( ) ; result . waitUntilFinish ( ) ; LoadTestResult testResult = LoadTestResult . create ( result , metricsNamespace , testStartTime ) ; ConsoleResultPublisher . publish ( testResult ) ; if ( options . getPublishToBigQuery ( ) ) { publishResultToBigQuery ( testResult ) ; } return result ; }
charlesccychen/beam | private void publishResultToBigQuery ( LoadTestResult testResult ) { String dataset = options . getBigQueryDataset ( ) ; String table = options . getBigQueryTable ( ) ; checkBigQueryOptions ( dataset , table ) ; ImmutableMap < String , String > schema = ImmutableMap . < String , String > builder ( ) . put ( " timestamp " , " timestamp " ) . put ( " runtime " , " float " ) . put ( " total _ bytes _ count " , " integer " ) . build ( ) ; BigQueryResultsPublisher . create ( dataset , schema ) . publish ( testResult , table ) ; }
charlesccychen/beam | < T extends SyntheticOptions > T fromJsonString ( String json , Class < T > type ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; T result = mapper . readValue ( json , type ) ; result . validate ( ) ; return result ; }
charlesccychen/beam | Optional < SyntheticStep > createStep ( String stepOptions ) throws IOException { if ( stepOptions != null && ! stepOptions . isEmpty ( ) ) { return Optional . of ( new SyntheticStep ( fromJsonString ( stepOptions , SyntheticStep . Options . class ) ) ) ; } else { return Optional . empty ( ) ; } }
charlesccychen/beam | PCollection < KV < byte [ ] , byte [ ] > > applyStepIfPresent ( PCollection < KV < byte [ ] , byte [ ] > > input , String name , Optional < SyntheticStep > syntheticStep ) { if ( syntheticStep . isPresent ( ) ) { return input . apply ( name , ParDo . of ( syntheticStep . get ( ) ) ) ; } else { return input ; } }
Kokil/opengse | private MutableWebAppContextParam ( ) { super ( ) ; }
Kokil/opengse | public String getParamName ( ) { return paramName ; }
Kokil/opengse | public void setParamName ( final String paramName ) { this . paramName = paramName ; }
Kokil/opengse | public String getParamValue ( ) { return paramValue ; }
Kokil/opengse | public void setParamValue ( final String paramValue ) { this . paramValue = paramValue ; }
msebire/intellij-community | SSAInstructionState ( int writeCount , int instructionIdx ) { myWriteCount = writeCount ; myInstructionIdx = instructionIdx ; }
msebire/intellij-community | public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof SSAInstructionState ) ) return false ; final SSAInstructionState ssaInstructionState = ( SSAInstructionState ) o ; if ( myInstructionIdx != ssaInstructionState . myInstructionIdx ) return false ; return Math . min ( 2 , myWriteCount ) == Math . min ( 2 , ssaInstructionState . myWriteCount ) ; }
msebire/intellij-community | public int hashCode ( ) { int result = Math . min ( 2 , myWriteCount ) ; result = 29 * result + myInstructionIdx ; return result ; }
msebire/intellij-community | int getWriteCount ( ) { return myWriteCount ; }
msebire/intellij-community | int getInstructionIdx ( ) { return myInstructionIdx ; }
msebire/intellij-community | ConvertReturnClientVisitor ( @ NotNull ControlFlow flow , @ NotNull ReturnStatementsVisitor visitor ) { super ( flow ) ; myAffectedReturns = new ArrayList < > ( ) ; myVisitor = visitor ; }
msebire/intellij-community | @ Override public void visitGoToInstruction ( final GoToInstruction instruction , final int offset , final int nextOffset ) { super . visitGoToInstruction ( instruction , offset , nextOffset ) ; if ( instruction . isReturn ) { final PsiElement element = myFlow . getElement ( offset ) ; if ( element instanceof PsiReturnStatement ) { final PsiReturnStatement returnStatement = ( PsiReturnStatement ) element ; myAffectedReturns . add ( returnStatement ) ; } } }
msebire/intellij-community | void afterProcessing ( ) throws IncorrectOperationException { myVisitor . visit ( myAffectedReturns ) ; }
msebire/intellij-community | ReturnPresentClientVisitor ( @ NotNull ControlFlow flow ) { myFlow = flow ; isNormalCompletion = new boolean [ myFlow . getSize ( ) + 1 ] ; isNormalCompletion [ myFlow . getSize ( ) ] = true ; }
msebire/intellij-community | @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; boolean isNormal = instruction . offset == nextOffset && nextOffset != offset + 1 ? ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] : isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; }
msebire/intellij-community | @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; isNormalCompletion [ offset ] |= ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] ; }
msebire/intellij-community | @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; isNormalCompletion [ offset ] |= ! instruction . isReturn && isNormalCompletion [ nextOffset ] ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > myFlow . getSize ( ) ) nextOffset = myFlow . getSize ( ) ; boolean isNormal = isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; }
msebire/intellij-community | @ Override @ NotNull public Boolean getResult ( ) { return ! isNormalCompletion [ 0 ] ; }
msebire/intellij-community | UnreachableStatementClientVisitor ( @ NotNull ControlFlow flow ) { myFlow = flow ; }
msebire/intellij-community | @ Override public PsiElement getResult ( ) { for ( int i = 0 ; i < processedInstructions . length ; i ++ ) { if ( ! processedInstructions [ i ] ) { PsiElement element = myFlow . getElement ( i ) ; final PsiElement unreachableParent = getUnreachableExpressionParent ( element ) ; if ( unreachableParent != null ) return unreachableParent ; if ( element == null || ! PsiUtil . isStatement ( element ) ) continue ; if ( element . getParent ( ) instanceof PsiExpression ) continue ; while ( element instanceof PsiExpression ) { element = element . getParent ( ) ; } if ( element instanceof PsiStatement && element . getParent ( ) instanceof PsiForStatement && element == ( ( PsiForStatement ) element . getParent ( ) ) . getUpdate ( ) ) { continue ; } final int endOffset = myFlow . getEndOffset ( element ) ; if ( endOffset != i + 1 ) continue ; final int startOffset = myFlow . getStartOffset ( element ) ; if ( 0 <= startOffset && startOffset < processedInstructions . length && processedInstructions [ startOffset ] ) continue ; final PsiElement enclosingStatement = getEnclosingUnreachableStatement ( element ) ; return enclosingStatement != null ? enclosingStatement : element ; } } return null ; }
msebire/intellij-community | ControlFlowEdge ( int from , int to ) { myFrom = from ; myTo = to ; }
msebire/intellij-community | @ Override public String toString ( ) { return myFrom + " - > " + myTo ; }
msebire/intellij-community | WalkThroughStack ( int initialSize ) { if ( initialSize < 2 ) initialSize = 2 ; oldOffsets = new int [ initialSize ] ; newOffsets = new int [ initialSize ] ; }
msebire/intellij-community | void push ( int oldOffset , int newOffset ) { LOG . assertTrue ( oldOffset >= 0 , " negative ▁ offset ▁ is ▁ pushed ▁ to ▁ walk - through ▁ stack " ) ; if ( size >= newOffsets . length ) { oldOffsets = ArrayUtil . realloc ( oldOffsets , size * 3 / 2 ) ; newOffsets = ArrayUtil . realloc ( newOffsets , size * 3 / 2 ) ; } oldOffsets [ size ] = oldOffset ; newOffsets [ size ] = newOffset ; size ++ ; }
msebire/intellij-community | void push ( int offset ) { push ( offset , - 1 ) ; }
msebire/intellij-community | int peekOldOffset ( ) { return oldOffsets [ size - 1 ] ; }
msebire/intellij-community | int popNewOffset ( ) { return newOffsets [ -- size ] ; }
msebire/intellij-community | boolean isEmpty ( ) { return size == 0 ; }
msebire/intellij-community | @ Override public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( s . length ( ) != 0 ) s . append ( ' ▁ ' ) ; if ( newOffsets [ i ] != - 1 ) { s . append ( ' ( ' ) . append ( oldOffsets [ i ] ) . append ( " - > " ) . append ( newOffsets [ i ] ) . append ( ' ) ' ) ; } else { s . append ( ' [ ' ) . append ( oldOffsets [ i ] ) . append ( ' ] ' ) ; } } return s . toString ( ) ; }
msebire/intellij-community | @ NotNull public CopyOnWriteList add ( @ NotNull VariableInfo value ) { CopyOnWriteList newList = new CopyOnWriteList ( ) ; List < VariableInfo > list = getList ( ) ; for ( final VariableInfo variableInfo : list ) { if ( ! value . equals ( variableInfo ) ) { newList . list . add ( variableInfo ) ; } } newList . list . add ( value ) ; return newList ; }
msebire/intellij-community | @ NotNull public CopyOnWriteList remove ( @ NotNull VariableInfo value ) { CopyOnWriteList newList = new CopyOnWriteList ( ) ; List < VariableInfo > list = getList ( ) ; for ( final VariableInfo variableInfo : list ) { if ( ! value . equals ( variableInfo ) ) { newList . list . add ( variableInfo ) ; } } return newList ; }
msebire/intellij-community | @ NotNull public List < VariableInfo > getList ( ) { return list ; }
msebire/intellij-community | CopyOnWriteList ( ) { this ( Collections . emptyList ( ) ) ; }
msebire/intellij-community | CopyOnWriteList ( @ NotNull VariableInfo ... infos ) { this ( Arrays . asList ( infos ) ) ; }
msebire/intellij-community | CopyOnWriteList ( @ NotNull Collection < ? extends VariableInfo > infos ) { list = new SmartList < > ( infos ) ; }
msebire/intellij-community | @ NotNull public CopyOnWriteList addAll ( @ NotNull CopyOnWriteList addList ) { CopyOnWriteList newList = new CopyOnWriteList ( ) ; List < VariableInfo > list = getList ( ) ; newList . list . addAll ( list ) ; List < VariableInfo > toAdd = addList . getList ( ) ; for ( final VariableInfo variableInfo : toAdd ) { if ( ! newList . list . contains ( variableInfo ) ) { newList . list . add ( variableInfo ) ; } } return newList ; }
msebire/intellij-community | public VariableInfo ( @ NotNull PsiVariable variable , @ Nullable PsiElement expression ) { this . variable = variable ; this . expression = expression ; }
msebire/intellij-community | public boolean equals ( Object o ) { return this == o || o instanceof VariableInfo && variable . equals ( ( ( VariableInfo ) o ) . variable ) ; }
msebire/intellij-community | public int hashCode ( ) { return variable . hashCode ( ) ; }
msebire/intellij-community | ReadBeforeWriteClientVisitor ( @ NotNull ControlFlow flow , boolean localVariablesOnly ) { myFlow = flow ; this . localVariablesOnly = localVariablesOnly ; readVariables = new CopyOnWriteList [ myFlow . getSize ( ) + 1 ] ; }
msebire/intellij-community | @ Override public void visitReadVariableInstruction ( ReadVariableInstruction instruction , int offset , int nextOffset ) { CopyOnWriteList readVars = readVariables [ Math . min ( nextOffset , myFlow . getSize ( ) ) ] ; final PsiVariable variable = instruction . variable ; if ( ! localVariablesOnly || ! isMethodParameter ( variable ) ) { final PsiReferenceExpression expression = getEnclosingReferenceExpression ( myFlow . getElement ( offset ) , variable ) ; if ( expression != null ) { readVars = CopyOnWriteList . add ( readVars , new VariableInfo ( variable , expression ) ) ; } } merge ( offset , readVars , readVariables ) ; }
msebire/intellij-community | @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { CopyOnWriteList readVars = readVariables [ Math . min ( nextOffset , myFlow . getSize ( ) ) ] ; if ( readVars == null ) return ; final PsiVariable variable = instruction . variable ; if ( ! localVariablesOnly || ! isMethodParameter ( variable ) ) { readVars = readVars . remove ( new VariableInfo ( variable , null ) ) ; } merge ( offset , readVars , readVariables ) ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { merge ( offset , readVariables [ Math . min ( nextOffset , myFlow . getSize ( ) ) ] , readVariables ) ; }
msebire/intellij-community | @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { visitInstruction ( instruction , offset , nextOffset ) ; for ( int i = instruction . procBegin ; i <= instruction . procEnd ; i ++ ) { readVariables [ i ] = null ; } }
msebire/intellij-community | @ Override @ NotNull public List < PsiReferenceExpression > getResult ( ) { return getResult ( 0 ) ; }
msebire/intellij-community | @ NotNull public List < PsiReferenceExpression > getResult ( int startOffset ) { final CopyOnWriteList topReadVariables = readVariables [ startOffset ] ; if ( topReadVariables == null ) return Collections . emptyList ( ) ; final List < PsiReferenceExpression > result = new ArrayList < > ( ) ; List < VariableInfo > list = topReadVariables . getList ( ) ; for ( final VariableInfo variableInfo : list ) { result . add ( ( PsiReferenceExpression ) variableInfo . expression ) ; } return result ; }
msebire/intellij-community | InitializedTwiceClientVisitor ( @ NotNull ControlFlow flow , final int startOffset ) { myFlow = flow ; myStartOffset = startOffset ; writtenVariables = new CopyOnWriteList [ myFlow . getSize ( ) + 1 ] ; writtenTwiceVariables = new CopyOnWriteList [ myFlow . getSize ( ) + 1 ] ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { final int safeNextOffset = Math . min ( nextOffset , myFlow . getSize ( ) ) ; CopyOnWriteList writeVars = writtenVariables [ safeNextOffset ] ; CopyOnWriteList writeTwiceVars = writtenTwiceVariables [ safeNextOffset ] ; if ( instruction instanceof WriteVariableInstruction ) { final PsiVariable variable = ( ( WriteVariableInstruction ) instruction ) . variable ; final PsiElement latestWriteVarExpression = getLatestWriteVarExpression ( writeVars , variable ) ; if ( latestWriteVarExpression == null ) { final PsiElement expression = getExpression ( myFlow . getElement ( offset ) ) ; writeVars = CopyOnWriteList . add ( writeVars , new VariableInfo ( variable , expression ) ) ; } else { writeTwiceVars = CopyOnWriteList . add ( writeTwiceVars , new VariableInfo ( variable , latestWriteVarExpression ) ) ; } } merge ( offset , writeVars , writtenVariables ) ; merge ( offset , writeTwiceVars , writtenTwiceVariables ) ; }
msebire/intellij-community | @ Override @ NotNull public Collection < VariableInfo > getResult ( ) { final CopyOnWriteList writtenTwiceVariable = writtenTwiceVariables [ myStartOffset ] ; if ( writtenTwiceVariable == null ) return Collections . emptyList ( ) ; return writtenTwiceVariable . getList ( ) ; }
msebire/intellij-community | ControlFlowGraph ( int size ) { nextOffsets = new int [ size ] [ ] ; }
msebire/intellij-community | @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > size ( ) ) nextOffset = size ( ) ; addArc ( offset , nextOffset ) ; }
msebire/intellij-community | void addArc ( int offset , int nextOffset ) { if ( nextOffsets [ offset ] == null ) { nextOffsets [ offset ] = new int [ ] { nextOffset , - 1 } ; } else { int [ ] targets = nextOffsets [ offset ] ; if ( ArrayUtil . indexOf ( targets , nextOffset ) < 0 ) { int freeIndex = ArrayUtil . indexOf ( targets , - 1 ) ; if ( freeIndex >= 0 ) { targets [ freeIndex ] = nextOffset ; } else { int oldLength = targets . length ; nextOffsets [ offset ] = targets = ArrayUtil . realloc ( targets , oldLength * 3 / 2 ) ; Arrays . fill ( targets , oldLength , targets . length , - 1 ) ; targets [ oldLength ] = nextOffset ; } } } }
msebire/intellij-community | @ NotNull int [ ] getNextOffsets ( int offset ) { return nextOffsets [ offset ] != null ? nextOffsets [ offset ] : ArrayUtil . EMPTY_INT_ARRAY ; }
msebire/intellij-community | int size ( ) { return nextOffsets . length ; }
msebire/intellij-community | @ Override public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < nextOffsets . length ; i ++ ) { int [ ] targets = nextOffsets [ i ] ; if ( targets != null && targets . length != 0 && targets [ 0 ] != - 1 ) { if ( s . length ( ) != 0 ) s . append ( ' ▁ ' ) ; s . append ( ' ( ' ) . append ( i ) . append ( " - > " ) ; for ( int j = 0 ; j < targets . length && targets [ j ] != - 1 ; j ++ ) { if ( j != 0 ) s . append ( " , " ) ; s . append ( targets [ j ] ) ; } s . append ( ' ) ' ) ; } } return s . toString ( ) ; }
msebire/intellij-community | boolean depthFirstSearch ( final int startOffset ) { return depthFirstSearch ( startOffset , new BitSet ( size ( ) ) ) ; }
msebire/intellij-community | boolean depthFirstSearch ( final int startOffset , @ NotNull BitSet visitedOffsets ) { IntStack walkThroughStack = new IntStack ( Math . max ( size ( ) / 2 , 2 ) ) ; visitedOffsets . clear ( ) ; walkThroughStack . push ( startOffset ) ; while ( ! walkThroughStack . empty ( ) ) { int currentOffset = walkThroughStack . pop ( ) ; if ( currentOffset < size ( ) && ! visitedOffsets . get ( currentOffset ) ) { visitedOffsets . set ( currentOffset ) ; int [ ] nextOffsets = getNextOffsets ( currentOffset ) ; for ( int nextOffset : nextOffsets ) { if ( nextOffset == - 1 ) break ; if ( isComplete ( currentOffset , nextOffset ) ) { return true ; } walkThroughStack . push ( nextOffset ) ; } } } return false ; }
msebire/intellij-community | @ Override public Void getResult ( ) { return null ; }
msebire/intellij-community | boolean isComplete ( int offset , int nextOffset ) { return false ; }
msebire/intellij-community | void buildFrom ( @ NotNull ControlFlow flow ) { ControlFlowUtil . depthFirstSearch ( flow , this , 0 , flow . getSize ( ) ) ; }
briljant/briljant | @ Test public void testArrayMethods ( ) throws Exception { Series s = Series . of ( " dsadsa " , 20.0 , 30.0 , 40.0 ) ; s . setIndex ( Index . of ( " a " , " b " , " c " , " d " ) ) ; System . out . println ( s . getIndex ( ) ) ; s = s . reindex ( Index . of ( " AAA " , " BBB " , " CCC " , " DDD " ) ) ; Series b = s . reshape ( 2 , 2 ) ; System . out . println ( b . getIndex ( ) ) ; System . out . println ( b ) ; for ( Object key : s . getIndex ( ) ) { System . out . println ( key + " ▁ " + b . get ( key ) + b . get ( key ) . getClass ( ) ) ; } System . out . println ( b . asArray ( ) ) ; List < Series > vsplit = Arrays . vsplit ( b , 2 ) ; System . out . println ( vsplit . get ( 0 ) ) ; }
briljant/briljant | @ Test public void testSet_BooleanArray ( ) throws Exception { Series a = getBuilder ( ) . addAll ( Series . of ( 1 , 2 , 3 , 4 , 5 ) ) . build ( ) ; Series expected = getBuilder ( ) . addAll ( Series . of ( 1 , 2 , 320 , 320 , 320 ) ) . build ( ) ; a . set ( a . where ( Double . class , v -> v > 2 ) , 320 ) ; System . out . println ( IntSeries . range ( 2000 ) . sort ( SortOrder . ASC ) ) ; Assert . assertEquals ( expected , a ) ; }
briljant/briljant | @ Test public void testHead ( ) throws Exception { Series a = new TypeInferenceBuilder ( ) . set ( " a " , 10 ) . set ( " b " , 100 ) . set ( " c " , 1 ) . set ( " d " , 11 ) . build ( ) ; System . out . println ( a ) ; Series sort = a . sort ( SortOrder . ASC ) ; System . out . println ( sort ) ; }
briljant/briljant | @ Test public void testTestSort ( ) throws Exception { Series a = new TypeInferenceBuilder ( ) . set ( 40 , 3 ) . set ( 30 , 2 ) . set ( 20 , 4 ) . set ( 10 , 1 ) . build ( ) ; Series v = a . sort ( SortOrder . DESC ) ; System . out . println ( v . asList ( Object . class ) ) ; System . out . println ( v ) ; }
plasma-framework/plasma | public synchronized String getElementText ( ) throws XMLStreamException { if ( closed ) { throw new XMLStreamException ( " Stream ▁ has ▁ been ▁ closed " ) ; } StringBuffer buffer = new StringBuffer ( ) ; while ( true ) { XMLEvent event = nextEvent ( ) ; if ( event . isCharacters ( ) ) { if ( event . getEventType ( ) != XMLEvent . SPACE ) { buffer . append ( event . asCharacters ( ) . getData ( ) ) ; } } else if ( event . isEndElement ( ) ) { break ; } else { throw new XMLStreamException ( " Non - text ▁ event ▁ encountered ▁ in ▁ getElementText ( ) : ▁ " + event ) ; } } return buffer . toString ( ) ; }
plasma-framework/plasma | public XMLEvent nextTag ( ) throws XMLStreamException { if ( closed ) { throw new XMLStreamException ( " Stream ▁ has ▁ been ▁ closed " ) ; } XMLEvent event ; do { if ( hasNext ( ) ) { event = nextEvent ( ) ; if ( event . isStartElement ( ) || event . isEndElement ( ) ) { return event ; } else if ( event . isCharacters ( ) ) { if ( ! event . asCharacters ( ) . isWhiteSpace ( ) ) { throw new XMLStreamException ( " Non - ignorable ▁ space ▁ encountered " ) ; } } else if ( ! ( event instanceof Comment ) ) { throw new XMLStreamException ( " Non - ignorable ▁ event ▁ encountered : ▁ " + event ) ; } } else { throw new XMLStreamException ( " Ran ▁ out ▁ of ▁ events ▁ in ▁ nextTag ( ) " ) ; } } while ( ! event . isStartElement ( ) && ! event . isEndElement ( ) ) ; return event ; }
plasma-framework/plasma | public Object getProperty ( String name ) throws IllegalArgumentException { throw new IllegalArgumentException ( " Property ▁ not ▁ supported : ▁ " + name ) ; }
plasma-framework/plasma | public synchronized void close ( ) throws XMLStreamException { if ( ! closed ) { closed = true ; } }
plasma-framework/plasma | public Object next ( ) { try { return nextEvent ( ) ; } catch ( XMLStreamException e ) { NoSuchElementException ex = new NoSuchElementException ( " Error ▁ getting ▁ next ▁ event " ) ; ex . initCause ( e ) ; throw ex ; } }
plasma-framework/plasma | public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
Karm/undertow | private ConnectionUtils ( ) { }
domokato/gdx-ai | public Box2dCollisionAvoidanceTest ( SteeringBehaviorsTest container ) { super ( container , " Collision ▁ Avoidance " ) ; }
domokato/gdx-ai | @ Override public void create ( ) { super . create ( ) ; drawDebug = true ; shapeRenderer = new ShapeRenderer ( ) ; spriteBatch = new SpriteBatch ( ) ; characters = new Array < Box2dSteeringEntity > ( ) ; proximities = new Array < Box2dRadiusProximity > ( ) ; for ( int i = 0 ; i < 60 ; i ++ ) { final Box2dSteeringEntity character = createSteeringEntity ( world , container . greenFish , false ) ; character . setMaxLinearSpeed ( 2 ) ; character . setMaxLinearAcceleration ( 4 ) ; Box2dRadiusProximity proximity = new Box2dRadiusProximity ( character , world , character . getBoundingRadius ( ) * 4 ) ; proximities . add ( proximity ) ; if ( i == 0 ) char0Proximity = proximity ; CollisionAvoidance < Vector2 > collisionAvoidanceSB = new CollisionAvoidance < Vector2 > ( character , proximity ) ; Wander < Vector2 > wanderSB = new Wander < Vector2 > ( character ) . setFaceEnabled ( false ) . setLimiter ( new LinearAccelerationLimiter ( 5 ) ) . setWanderOffset ( 3 ) . setWanderOrientation ( 5 ) . setWanderRadius ( 1 ) . setWanderRate ( MathUtils . PI2 * 4 ) ; PrioritySteering < Vector2 > prioritySteeringSB = new PrioritySteering < Vector2 > ( character , 0.0001f ) ; prioritySteeringSB . add ( collisionAvoidanceSB ) ; prioritySteeringSB . add ( wanderSB ) ; character . setSteeringBehavior ( prioritySteeringSB ) ; setRandomNonOverlappingPosition ( character , characters , Box2dSteeringTest . pixelsToMeters ( 5 ) ) ; characters . add ( character ) ; } inputProcessor = null ; Table detailTable = new Table ( container . skin ) ; detailTable . row ( ) ; final Label labelMaxLinAcc = new Label ( " Max . Linear ▁ Acc . [ " + characters . get ( 0 ) . getMaxLinearAcceleration ( ) + " ] " , container . skin ) ; detailTable . add ( labelMaxLinAcc ) ; detailTable . row ( ) ; Slider maxLinAcc = new Slider ( 0 , 30 , .1f , false , container . skin ) ; maxLinAcc . setValue ( characters . get ( 0 ) . getMaxLinearAcceleration ( ) ) ; maxLinAcc . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { Slider slider = ( Slider ) actor ; for ( int i = 0 ; i < characters . size ; i ++ ) characters . get ( i ) . setMaxLinearAcceleration ( slider . getValue ( ) ) ; labelMaxLinAcc . setText ( " Max . Linear ▁ Acc . [ " + slider . getValue ( ) + " ] " ) ; } } ) ; detailTable . add ( maxLinAcc ) ; detailTable . row ( ) ; final Label labelProximityRadius = new Label ( " Proximity ▁ Radius ▁ [ " + proximities . get ( 0 ) . getDetectionRadius ( ) + " ] " , container . skin ) ; detailTable . add ( labelProximityRadius ) ; detailTable . row ( ) ; Slider proximityRadius = new Slider ( 0 , 10 , .1f , false , container . skin ) ; proximityRadius . setValue ( proximities . get ( 0 ) . getDetectionRadius ( ) ) ; proximityRadius . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { Slider slider = ( Slider ) actor ; for ( int i = 0 ; i < proximities . size ; i ++ ) proximities . get ( i ) . setDetectionRadius ( slider . getValue ( ) ) ; labelProximityRadius . setText ( " Proximity ▁ Radius ▁ [ " + slider . getValue ( ) + " ] " ) ; } } ) ; detailTable . add ( proximityRadius ) ; detailTable . row ( ) ; addSeparator ( detailTable ) ; detailTable . row ( ) ; final Label labelMaxLinSpeed = new Label ( " Max . Linear ▁ Speed . [ " + characters . get ( 0 ) . getMaxLinearSpeed ( ) + " ] " , container . skin ) ; detailTable . add ( labelMaxLinSpeed ) ; detailTable . row ( ) ; Slider maxLinSpeed = new Slider ( 0 , 20 , .5f , false , container . skin ) ; maxLinSpeed . setValue ( characters . get ( 0 ) . getMaxLinearSpeed ( ) ) ; maxLinSpeed . addListener ( new ChangeListener ( ) { @ Override public void changed ( ChangeEvent event , Actor actor ) { Slider slider = ( Slider ) actor ; for ( int i = 0 ; i < characters . size ; i ++ ) characters . get ( i ) . setMaxLinearSpeed ( slider . getValue ( ) ) ; labelMaxLinSpeed . setText ( " Max . Linear ▁ Speed . [ " + slider . getValue ( ) + " ] " ) ; } } ) ; detailTable . add ( maxLinSpeed ) ; detailTable . row ( ) ; CheckBox debug = new CheckBox ( " Draw ▁ Proximity " , container . skin ) ; debug . setChecked ( drawDebug ) ; debug . addListener ( new ClickListener ( ) { @ Override public void clicked ( InputEvent event , float x , float y ) { CheckBox checkBox = ( CheckBox ) event . getListenerActor ( ) ; drawDebug = checkBox . isChecked ( ) ; } } ) ; detailTable . add ( debug ) ; detailWindow = createDetailWindow ( detailTable ) ; }
domokato/gdx-ai | @ Override public void update ( ) { super . update ( ) ; float deltaTime = GdxAI . getTimepiece ( ) . getDeltaTime ( ) ; for ( int i = 0 ; i < characters . size ; i ++ ) { characters . get ( i ) . update ( deltaTime ) ; } }
domokato/gdx-ai | @ Override public void draw ( ) { spriteBatch . begin ( ) ; for ( int i = 0 ; i < characters . size ; i ++ ) { Box2dSteeringEntity character = characters . get ( i ) ; character . draw ( spriteBatch ) ; } spriteBatch . end ( ) ; if ( drawDebug ) { Steerable < Vector2 > steerable = characters . get ( 0 ) ; shapeRenderer . begin ( ShapeType . Line ) ; shapeRenderer . setColor ( 0 , 1 , 0 , 1 ) ; int centerX = Box2dSteeringTest . metersToPixels ( steerable . getPosition ( ) . x ) ; int centerY = Box2dSteeringTest . metersToPixels ( steerable . getPosition ( ) . y ) ; int radius = Box2dSteeringTest . metersToPixels ( char0Proximity . getDetectionRadius ( ) ) ; shapeRenderer . circle ( centerX , centerY , radius ) ; shapeRenderer . end ( ) ; } }
domokato/gdx-ai | @ Override public void dispose ( ) { super . dispose ( ) ; shapeRenderer . dispose ( ) ; spriteBatch . dispose ( ) ; }
kevinearls/camel | protected AbstractXmlApplicationContext createApplicationContext ( ) { return new ClassPathXmlApplicationContext ( " org / apache / camel / spring / config / PackageResolverTest . xml " ) ; }
kevinearls/camel | @ Test public void testSetAcceptableSchema ( ) throws Exception { DefaultPackageScanClassResolver resolver = ( DefaultPackageScanClassResolver ) context . getPackageScanClassResolver ( ) ; assertNotNull ( resolver ) ; assertTrue ( " We ▁ should ▁ accept ▁ the ▁ test : ! " , resolver . isAcceptableScheme ( " test : // test " ) ) ; assertTrue ( " We ▁ should ▁ accept ▁ the ▁ test2 : ! " , resolver . isAcceptableScheme ( " test2 : // test " ) ) ; }
jack0707/coldweather | private ColdWeatherDB ( Context context ) { ColdWeatherOpendHelper dbHelper = new ColdWeatherOpendHelper ( context , DB_NAME , null , VERSION ) ; db = dbHelper . getWritableDatabase ( ) ; }
jack0707/coldweather | public void saveProvince ( Province province ) { if ( province != null ) { ContentValues values = new ContentValues ( ) ; values . put ( " province _ name " , province . getProvinceName ( ) ) ; values . put ( " province _ code " , province . getProvinceCode ( ) ) ; db . insert ( " Province " , null , values ) ; } }
jack0707/coldweather | public List < Province > loadProvinces ( ) { List < Province > list = new ArrayList < > ( ) ; Cursor cursor = db . query ( " Province " , null , null , null , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { do { Province province = new Province ( ) ; province . setId ( cursor . getInt ( cursor . getColumnIndex ( " id " ) ) ) ; province . setProvinceName ( cursor . getString ( cursor . getColumnIndex ( " province _ name " ) ) ) ; province . setProvinceCode ( cursor . getString ( cursor . getColumnIndex ( " province _ code " ) ) ) ; list . add ( province ) ; } while ( cursor . moveToNext ( ) ) ; } return list ; }
jack0707/coldweather | public void saveCity ( City city ) { if ( city != null ) { ContentValues values = new ContentValues ( ) ; values . put ( " city _ name " , city . getCityName ( ) ) ; values . put ( " city _ code " , city . getCityCode ( ) ) ; values . put ( " province _ id " , city . getProvinceId ( ) ) ; db . insert ( " City " , null , values ) ; } }
jack0707/coldweather | public List < City > loadCities ( int provinceId ) { List < City > list = new ArrayList < City > ( ) ; System . out . println ( " hello " ) ; Cursor cursor = db . query ( " City " , null , " province _ id ▁ = ▁ ? " , new String [ ] { String . valueOf ( provinceId ) } , null , null , null ) ; System . out . println ( "1" ) ; if ( cursor . moveToFirst ( ) ) { do { City city = new City ( ) ; System . out . println ( " faile " ) ; city . setId ( cursor . getInt ( cursor . getColumnIndex ( " id " ) ) ) ; city . setCityName ( cursor . getString ( cursor . getColumnIndex ( " city _ name " ) ) ) ; city . setCityCode ( cursor . getString ( cursor . getColumnIndex ( " city _ code " ) ) ) ; city . setProvinceId ( provinceId ) ; list . add ( city ) ; System . out . println ( " success " ) ; } while ( cursor . moveToNext ( ) ) ; } return list ; }
jack0707/coldweather | public void saveCounty ( County county ) { if ( county != null ) { ContentValues values = new ContentValues ( ) ; values . put ( " county _ name " , county . getCountyName ( ) ) ; values . put ( " county _ code " , county . getCountyCode ( ) ) ; values . put ( " city _ id " , county . getCityId ( ) ) ; db . insert ( " County " , null , values ) ; } }
jack0707/coldweather | public List < County > loadCounties ( int cityId ) { List < County > list = new ArrayList < County > ( ) ; Cursor cursor = db . query ( " County " , null , " city _ id ▁ = ▁ ? " , new String [ ] { String . valueOf ( cityId ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { do { County county = new County ( ) ; county . setId ( cursor . getInt ( cursor . getColumnIndex ( " id " ) ) ) ; county . setCountyName ( cursor . getString ( cursor . getColumnIndex ( " county _ name " ) ) ) ; county . setCountyCode ( cursor . getString ( cursor . getColumnIndex ( " county _ code " ) ) ) ; county . setCityId ( cityId ) ; list . add ( county ) ; } while ( cursor . moveToNext ( ) ) ; } return list ; }
nihaocun/kirbydownload | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; Theme . setClassTheme ( this ) ; setContentView ( R . layout . activity_main ) ; setApply ( ) ; toolbar = ( Toolbar ) findViewById ( R . id . 标题栏 ) ; setSupportActionBar ( toolbar ) ; toolbar . setSubtitle ( R . string . ziyuan ) ; replaceFragment ( new MainGameFragment ( ) ) ; u = BmobUser . getCurrentUser ( MyUser . class ) ; bmb = ( BoomMenuButton ) findViewById ( R . id . bmb ) ; assert bmb != null ; initBmb ( ) ; thePay ( ) ; }
nihaocun/kirbydownload | private void thePay ( ) { SharedPreferences 状态 = getSharedPreferences ( " boolean " , 0 ) ; boolean 状态 _ = 状态 . getBoolean ( " thefirst _ main " , false ) ; if ( 状态 _ == false ) { int pay_code = ( int ) ( 1 + Math . random ( ) * ( 10 - 1 + 1 ) ) ; if ( pay_code == 1 || pay_code == 3 || pay_code == 7 || pay_code == 10 ) { showPay ( ) ; } } }
nihaocun/kirbydownload | private void initBmb ( ) { if ( null == u ) { HamButton . Builder user = new HamButton . Builder ( ) . normalTextRes ( R . string . login_title ) . normalImageRes ( R . drawable . ic_account ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { replaceFragment ( new MainLoginFragment ( ) ) ; toolbar . setSubtitle ( R . string . login_title ) ; } } ) ; bmb . addBuilder ( user ) ; } else { HamButton . Builder user = new HamButton . Builder ( ) . normalText ( getResources ( ) . getString ( R . string . hello ) + u . getUsername ( ) ) . normalImageRes ( R . drawable . ic_account ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { Intent user = new Intent ( MainActivity . this , UserActivity . class ) ; IntentUtil . startActivityWithAnim ( user , MainActivity . this ) ; } } ) ; bmb . addBuilder ( user ) ; } HamButton . Builder game = new HamButton . Builder ( ) . normalTextRes ( R . string . ziyuan ) . normalImageRes ( R . drawable . ic_game ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . ziyuan ) ; replaceFragment ( new MainGameFragment ( ) ) ; } } ) ; bmb . addBuilder ( game ) ; HamButton . Builder jsz = new HamButton . Builder ( ) . normalTextRes ( R . string . jsz_title ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . jsz_title ) ; replaceFragment ( new MainJszFragment ( ) ) ; } } ) ; bmb . addBuilder ( jsz ) ; HamButton . Builder video = new HamButton . Builder ( ) . normalTextRes ( R . string . video_title ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . video_title ) ; replaceFragment ( new MainVideoFragment ( ) ) ; } } ) ; bmb . addBuilder ( video ) ; HamButton . Builder mess = new HamButton . Builder ( ) . normalTextRes ( R . string . talk ) . normalImageRes ( R . drawable . ic_talk2 ) . listener ( new OnBMClickListener ( ) { @ Override public void onBoomButtonClick ( int p1 ) { toolbar . setSubtitle ( R . string . talk ) ; replaceFragment ( new MainMessFragment ( ) ) ; } } ) ; bmb . addBuilder ( mess ) ; }
nihaocun/kirbydownload | private void showPay ( ) { AlertDialog . Builder dialog = new AlertDialog . Builder ( this ) . setTitle ( " 捐赠 " ) . setMessage ( " 你好 ， 我是kirby ▁ ▁ download的开发者 , 感谢你使用我开发的app \n 这个app从开发到服务器一直都是我自费的 ， 作为一个学生 ， 实在是坚持不住 。 所以 ， 请求各位大佬投喂 ， 或者点击免费捐赠也可以的哦 ， 谢谢٩(๑ • ◡ - ๑)۶" ) . setPositiveButton ( " 捐赠 " , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent pay = new Intent ( MainActivity . this , PayActivity . class ) ; IntentUtil . startActivityWithAnim ( pay , MainActivity . this ) ; } } ) . setNegativeButton ( " 取消 " , null ) . setNeutralButton ( " 不再提醒 " , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { SharedPreferences . Editor t = getSharedPreferences ( " boolean " , 0 ) . edit ( ) ; t . putBoolean ( " thefirst _ main " , true ) ; t . apply ( ) ; } } ) ; dialog . show ( ) ; }
nihaocun/kirbydownload | public void replaceFragment ( Fragment fragment ) { FragmentManager fragmentManager = getSupportFragmentManager ( ) ; FragmentTransaction transaction = fragmentManager . beginTransaction ( ) ; transaction . replace ( R . id . main_fragment , fragment ) ; transaction . commit ( ) ; }
nihaocun/kirbydownload | private void setApply ( ) { SharedPreferences . Editor y = getSharedPreferences ( " string " , 0 ) . edit ( ) ; y . putString ( " 主机名称 " , "0" ) ; y . putString ( " 游戏或模拟器名称 " , "0" ) ; y . apply ( ) ; }
nihaocun/kirbydownload | @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; SharedPreferences . Editor y = getSharedPreferences ( " string " , 0 ) . edit ( ) ; y . putString ( " 主机名称 " , "0" ) ; y . putString ( " 游戏或模拟器名称 " , "0" ) ; y . apply ( ) ; }
nihaocun/kirbydownload | public void setCustomTheme ( int i ) { Theme . setTheme ( MainActivity . this , i ) ; SharedPreferences . Editor y = getSharedPreferences ( " customtheme " , 0 ) . edit ( ) ; y . putInt ( " id " , i ) ; y . apply ( ) ; open ( ) ; }
nihaocun/kirbydownload | public void open ( ) { Intent intent = getIntent ( ) ; overridePendingTransition ( android . R . anim . fade_in , android . R . anim . fade_out ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NO_ANIMATION ) ; finish ( ) ; IntentUtil . startActivityWithAnim ( intent , MainActivity . this ) ; }
nihaocun/kirbydownload | public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . toolbar , menu ) ; return true ; }
nihaocun/kirbydownload | @ Override public void onOpenAnimationStart ( ) { }
nihaocun/kirbydownload | @ Override public void onOpenAnimationEnd ( ) { }
nihaocun/kirbydownload | @ Override public void onCloseAnimationStart ( ) { SharedPreferences console = getSharedPreferences ( " string " , 0 ) ; String edit_ 内容 = console . getString ( " Message " , " " ) ; MessageBmob mess = new MessageBmob ( ) ; mess . setMessage ( edit_ 内容 ) ; mess . setNickname ( u . getUsername ( ) ) ; mess . save ( new SaveListener < String > ( ) { @ Override public void done ( String objectId , BmobException e ) { if ( e == null ) { MainMessFragment main_mess = ( MainMessFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . main_fragment ) ; main_mess . getMessage ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . mess_true ) + objectId , Toast . LENGTH_SHORT ) . show ( ) ; SharedPreferences y = getSharedPreferences ( " string " , 0 ) ; SharedPreferences . Editor edit = y . edit ( ) ; edit . putString ( " Message " , " " ) ; edit . apply ( ) ; } else { Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . mess_false ) + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; }
nihaocun/kirbydownload | @ Override public void onCloseAnimationEnd ( ) { }
nihaocun/kirbydownload | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : drawerLayout . openDrawer ( GravityCompat . START ) ; break ; case R . id . theme : SharedPreferences c = getSharedPreferences ( " customtheme " , 0 ) ; final int itemSelected = c . getInt ( " id " , 0 ) ; AlertDialog . Builder theme = new AlertDialog . Builder ( MainActivity . this ) ; theme . setTitle ( R . string . theme_title ) ; Integer [ ] res = new Integer [ ] { R . drawable . buletheme , R . drawable . redtheme , R . drawable . purpletheme , R . drawable . lindigotheme , R . drawable . tealtheme , R . drawable . greentheme , R . drawable . orangetheme , R . drawable . browntheme , R . drawable . bluegreytheme , R . drawable . yellowtheme , R . drawable . kirbytheme , R . drawable . darktheme } ; List < Integer > list = Arrays . asList ( res ) ; ColorListAdapter adapter = new ColorListAdapter ( MainActivity . this , list ) ; adapter . setCheckItem ( itemSelected ) ; GridView gridView = ( GridView ) LayoutInflater . from ( MainActivity . this ) . inflate ( R . layout . colors_panel_layout , null ) ; gridView . setStretchMode ( GridView . STRETCH_COLUMN_WIDTH ) ; gridView . setCacheColorHint ( 0 ) ; gridView . setAdapter ( adapter ) ; theme . setView ( gridView ) ; final AlertDialog dialog = theme . show ( ) ; gridView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { dialog . dismiss ( ) ; if ( itemSelected != position ) { setCustomTheme ( position ) ; } } } ) ; break ; case R . id . about : Intent about = new Intent ( MainActivity . this , AboutActivity . class ) ; IntentUtil . startActivityWithAnim ( about , MainActivity . this ) ; break ; case R . id . app : AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; builder . setTitle ( R . string . tj_app ) ; String [ ] items = { " ZArchiver \n " + getResources ( ) . getString ( R . string . app_ZArchiver ) } ; builder . setItems ( items , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { switch ( i ) { case 0 : downloadappApk ( " ZArchiver " ) ; break ; } } } ) ; builder . create ( ) ; builder . show ( ) ; break ; case R . id . pay : Intent pay = new Intent ( MainActivity . this , PayActivity . class ) ; IntentUtil . startActivityWithAnim ( pay , MainActivity . this ) ; break ; default : } return true ; }
nihaocun/kirbydownload | public void downloadappApk ( final String app_name ) { progressDialog = new ProgressDialog ( MainActivity . this ) ; progressDialog . setMessage ( getResources ( ) . getString ( R . string . link_bmob ) ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_HORIZONTAL ) ; progressDialog . setMax ( 100 ) ; progressDialog . show ( ) ; BmobQuery < moniqi > query = new BmobQuery < moniqi > ( ) ; query . addWhereEqualTo ( " name " , app_name ) ; query . findObjects ( new FindListener < moniqi > ( ) { private BmobFile moniqiApk ; @ Override public void done ( List < moniqi > p1 , BmobException p2 ) { if ( p2 == null ) { for ( moniqi apk : p1 ) { moniqiApk = apk . getApk ( ) ; } appFileDownload ( moniqiApk , app_name ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . link_fail ) + p2 , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; }
nihaocun/kirbydownload | private void appFileDownload ( BmobFile moniqiApk , final String app_name ) { File saveFile = new File ( " / storage / emulated / 0 / Android / data / com . kirby . runanjing / files / " + moniqiApk . getFilename ( ) ) ; moniqiApk . download ( saveFile , new DownloadFileListener ( ) { @ Override public void onStart ( ) { progressDialog . setMessage ( getResources ( ) . getString ( R . string . downloading ) + app_name ) ; } @ Override public void done ( String savePath , BmobException e ) { if ( e == null ) { progressDialog . dismiss ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . download_susses ) + savePath , Toast . LENGTH_SHORT ) . show ( ) ; Install . installApk ( MainActivity . this , savePath ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( MainActivity . this , getResources ( ) . getString ( R . string . download_fail ) + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } @ Override public void onProgress ( Integer value , long newworkSpeed ) { progressDialog . setProgress ( value ) ; } } ) ; }
nihaocun/kirbydownload | public void theDownload ( Context con , String game_name ) { gameContext = con ; switch ( game_name ) { case " 星之卡比 ▁ 梦之泉DX " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3kURIBIZ " , " https : // eyun . baidu . com / s / 3o86TXDS " , " https : // eyun . baidu . com / s / 3dF22BWP " ) ; break ; case " 星之卡比 ▁ 镜之大迷宫 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3hs7Mjsg " , " https : // eyun . baidu . com / s / 3c5qBl8" , " https : // eyun . baidu . com / s / 3i5t6Z3J " ) ; break ; case " 星之卡比 ▁ 3" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKTD8EZ " , " https : // eyun . baidu . com / s / 3gfwui2n " , " " ) ; break ; case " 星之卡比 ▁ 超豪华版 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3qXEc4Xm " , " https : // eyun . baidu . com / s / 3nu8IVpv " , " " ) ; break ; case " 星之卡比 ▁ 卡比梦幻都 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3hsvCjfI " , " https : // eyun . baidu . com / s / 3jHCmNps " , " " ) ; break ; case " [ 仅美国 ] 星之卡比 ▁ 卡比魔方气泡 " : showDownloadDialog ( game_name , R . string . game_name1 , R . string . us , R . string . nu , R . string . nu , " https : // eyun . baidu . com / s / 3eSuusSi " , " " , " " ) ; break ; case " [ 仅日本 ] 星之卡比 ▁ 卡比宝石星DX " : showDownloadDialog ( game_name , R . string . game_name2 , R . string . jp , R . string . nu , R . string . nu , " https : // eyun . baidu . com / s / 3kVDhaS3" , " " , " " ) ; break ; case " 星之卡比 ▁ 64" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3jHPKdMY " , " https : // eyun . baidu . com / s / 3jHPKdMY " , " " ) ; break ; case " 星之卡比 ▁ 飞天赛车 " : showDownloadDialog ( game_name , R . string . game_name , R . string . us , R . string . nu , R . string . nu , " https : // eyun . baidu . com / s / 3qYAoXGC " , " " , " " ) ; break ; case " 星之卡比 ▁ 重返梦幻岛 " : break ; case " 星之卡比 ▁ 毛线卡比 " : break ; case " 星之卡比 ▁ 触摸卡比 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3hsqS3S4" , " https : // eyun . baidu . com / s / 3c27V89i " , " https : // eyun . baidu . com / s / 3i5Pwsxn " ) ; break ; case " 星之卡比 ▁ 超究豪华版 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3i4Ricbb " , " https : // eyun . baidu . com / s / 3nvCwXlB " , " https : // eyun . baidu . com / s / 3c2EblZi " ) ; break ; case " 星之卡比 ▁ 呐喊团 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3bo4Z5TH " , " https : // eyun . baidu . com / s / 3czmilC " , " https : // eyun . baidu . com / s / 3hr4PxbA " ) ; break ; case " 星之卡比 ▁ 集合 ！ 卡比 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . zh , " https : // eyun . baidu . com / s / 3geO4mbx " , " https : // eyun . baidu . com / s / 3eSijdHS " , " https : // eyun . baidu . com / s / 3o80PA6e " ) ; break ; case " 星之卡比 ▁ 1" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKN6dIz " , " https : // eyun . baidu . com / s / 3pKZHpaF " , " " ) ; break ; case " 星之卡比 ▁ 2" : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3i57Kjjv " , " https : // eyun . baidu . com / s / 3jI4urlW " , " " ) ; break ; case " 星之卡比 ▁ 卡比宝石星 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3miFgbtI " , " https : // eyun . baidu . com / s / 3nvtzunn " , " " ) ; break ; case " 星之卡比 ▁ 卡比打砖块 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3i5Dkqah " , " https : // eyun . baidu . com / s / 3ge7808r " , " " ) ; break ; case " 星之卡比 ▁ 卡比弹珠台 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3i48QqMh " , " https : // eyun . baidu . com / s / 3eSwv1DK " , " " ) ; break ; case " 星之卡比 ▁ 滚滚卡比 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKP9eav " , " https : // eyun . baidu . com / s / 3nuQZavJ " , " " ) ; break ; case " 星之卡比 ▁ 梦之泉物语 " : showDownloadDialog ( game_name , R . string . game_name , R . string . jp , R . string . us , R . string . nu , " https : // eyun . baidu . com / s / 3pKXFx8n " , " https : // eyun . baidu . com / s / 3pKZHpaF " , " https : // eyun . baidu . com / s / 3i4HC8FN " ) ; break ; case " GBA模拟器 \n My ▁ Boy ! " : showOtherDownloadDialog ( " gba " , game_name ) ; break ; case " SFC模拟器 \n Snes9x ▁ EX + " : showOtherDownloadDialog ( " sfc " , game_name ) ; break ; case " N64模拟器 \n Tendo64" : showOtherDownloadDialog ( " n64" , game_name ) ; break ; case " NDS模拟器 \n DraStic " : showOtherDownloadDialog ( " nds " , game_name ) ; break ; case " NGC & WII模拟器 \n Dolphin " : showOtherDownloadDialog ( " wii " , game_name ) ; break ; case " GB & GBC模拟器 \n My ▁ OldBoy ! " : showOtherDownloadDialog ( " gb " , game_name ) ; break ; case " FC模拟器 \n NES . emu " : showOtherDownloadDialog ( " fc " , game_name ) ; break ; } }
nihaocun/kirbydownload | public void downloadMoniqiApk ( final String game_name ) { progressDialog = new ProgressDialog ( gameContext ) ; progressDialog . setMessage ( gameContext . getString ( R . string . link_bmob ) ) ; progressDialog . setProgressStyle ( ProgressDialog . STYLE_HORIZONTAL ) ; progressDialog . setMax ( 100 ) ; progressDialog . show ( ) ; BmobQuery < moniqi > query = new BmobQuery < moniqi > ( ) ; query . addWhereEqualTo ( " name " , game_name ) ; query . findObjects ( new FindListener < moniqi > ( ) { private BmobFile moniqiApk ; @ Override public void done ( List < moniqi > p1 , BmobException p2 ) { if ( p2 == null ) { for ( moniqi apk : p1 ) { moniqiApk = apk . getApk ( ) ; } moniqiFileDownload ( moniqiApk , game_name ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( gameContext , gameContext . getString ( R . string . link_fail ) + p2 , Toast . LENGTH_SHORT ) . show ( ) ; } } } ) ; }
nihaocun/kirbydownload | private void moniqiFileDownload ( BmobFile moniqiApk , final String game_name ) { File saveFile = new File ( " / storage / emulated / 0 / Android / data / com . kirby . runanjing / files / " + moniqiApk . getFilename ( ) ) ; moniqiApk . download ( saveFile , new DownloadFileListener ( ) { @ Override public void onStart ( ) { progressDialog . setMessage ( gameContext . getString ( R . string . downloading ) + game_name ) ; } @ Override public void done ( String savePath , BmobException e ) { if ( e == null ) { progressDialog . dismiss ( ) ; Toast . makeText ( gameContext , gameContext . getString ( R . string . download_susses ) + savePath , Toast . LENGTH_SHORT ) . show ( ) ; Install . installApk ( gameContext , savePath ) ; } else { progressDialog . dismiss ( ) ; Toast . makeText ( gameContext , gameContext . getString ( R . string . download_fail ) + e . getMessage ( ) , Toast . LENGTH_SHORT ) . show ( ) ; } } @ Override public void onProgress ( Integer value , long newworkSpeed ) { progressDialog . setProgress ( value ) ; } } ) ; }
nihaocun/kirbydownload | private void showOtherDownloadDialog ( final String downloadName , String game_name ) { AlertDialog . Builder dialog = new AlertDialog . Builder ( gameContext ) . setTitle ( game_name ) . setMessage ( R . string . download_dia_mess ) . setPositiveButton ( R . string . dia_download , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { downloadMoniqiApk ( downloadName ) ; } } ) ; dialog . show ( ) ; }
nihaocun/kirbydownload | public void showDownloadDialog ( String name , int mess , Integer pos , Integer neg , Integer neu , final String pos_url , final String neg_url , final String neu_url ) { AlertDialog . Builder dialog = new AlertDialog . Builder ( gameContext ) . setTitle ( name ) . setMessage ( mess ) . setPositiveButton ( pos , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent web = new Intent ( ) ; web . setAction ( " android . intent . action . VIEW " ) ; Uri content_url = Uri . parse ( pos_url ) ; web . setData ( content_url ) ; gameContext . startActivity ( web ) ; } } ) . setNegativeButton ( neg , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent web = new Intent ( ) ; web . setAction ( " android . intent . action . VIEW " ) ; Uri content_url = Uri . parse ( neg_url ) ; web . setData ( content_url ) ; gameContext . startActivity ( web ) ; } } ) . setNeutralButton ( neu , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { Intent web = new Intent ( ) ; web . setAction ( " android . intent . action . VIEW " ) ; Uri content_url = Uri . parse ( neu_url ) ; web . setData ( content_url ) ; gameContext . startActivity ( web ) ; } } ) ; dialog . show ( ) ; }
sendy943/jfinal-wxmall | public void setId ( java . lang . Long id ) { set ( " id " , id ) ; }
sendy943/jfinal-wxmall | public java . lang . Long getId ( ) { return get ( " id " ) ; }
sendy943/jfinal-wxmall | public void setNick ( java . lang . String nick ) { set ( " nick " , nick ) ; }
sendy943/jfinal-wxmall | public java . lang . String getNick ( ) { return get ( " nick " ) ; }
sendy943/jfinal-wxmall | public void setPhone ( java . lang . String phone ) { set ( " phone " , phone ) ; }
sendy943/jfinal-wxmall | public java . lang . String getPhone ( ) { return get ( " phone " ) ; }
sendy943/jfinal-wxmall | public void setPassword ( java . lang . String password ) { set ( " password " , password ) ; }
sendy943/jfinal-wxmall | public java . lang . String getPassword ( ) { return get ( " password " ) ; }
sendy943/jfinal-wxmall | public void setUserLevel ( java . lang . Integer userLevel ) { set ( " user _ level " , userLevel ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getUserLevel ( ) { return get ( " user _ level " ) ; }
sendy943/jfinal-wxmall | public void setLoginTime ( java . util . Date loginTime ) { set ( " login _ time " , loginTime ) ; }
sendy943/jfinal-wxmall | public java . util . Date getLoginTime ( ) { return get ( " login _ time " ) ; }
sendy943/jfinal-wxmall | public void setEmail ( java . lang . String email ) { set ( " email " , email ) ; }
sendy943/jfinal-wxmall | public java . lang . String getEmail ( ) { return get ( " email " ) ; }
sendy943/jfinal-wxmall | public void setStartDate ( java . util . Date startDate ) { set ( " start _ date " , startDate ) ; }
sendy943/jfinal-wxmall | public java . util . Date getStartDate ( ) { return get ( " start _ date " ) ; }
sendy943/jfinal-wxmall | public void setEndDate ( java . util . Date endDate ) { set ( " end _ date " , endDate ) ; }
sendy943/jfinal-wxmall | public java . util . Date getEndDate ( ) { return get ( " end _ date " ) ; }
sendy943/jfinal-wxmall | public void setVersionNo ( java . lang . Integer versionNo ) { set ( " version _ no " , versionNo ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getVersionNo ( ) { return get ( " version _ no " ) ; }
sendy943/jfinal-wxmall | public void setLoginIp ( java . lang . String loginIp ) { set ( " login _ ip " , loginIp ) ; }
sendy943/jfinal-wxmall | public java . lang . String getLoginIp ( ) { return get ( " login _ ip " ) ; }
sendy943/jfinal-wxmall | public void setAdmiLoginFailureCount ( java . lang . Integer admiLoginFailureCount ) { set ( " admi _ login _ failure _ count " , admiLoginFailureCount ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getAdmiLoginFailureCount ( ) { return get ( " admi _ login _ failure _ count " ) ; }
sendy943/jfinal-wxmall | public void setActive ( java . lang . Integer active ) { set ( " active " , active ) ; }
sendy943/jfinal-wxmall | public java . lang . Integer getActive ( ) { return get ( " active " ) ; }
sendy943/jfinal-wxmall | public void setCreated ( java . util . Date created ) { set ( " created " , created ) ; }
sendy943/jfinal-wxmall | public java . util . Date getCreated ( ) { return get ( " created " ) ; }
sendy943/jfinal-wxmall | public void setUpdated ( java . util . Date updated ) { set ( " updated " , updated ) ; }
sendy943/jfinal-wxmall | public java . util . Date getUpdated ( ) { return get ( " updated " ) ; }
standy66/fizteh-ads-2014 | protected void recalculate ( ) { String suffix = appended . stream ( ) . map ( x -> x . toString ( ) ) . collect ( Collectors . joining ( ) ) ; String prefix = prepended . stream ( ) . map ( x -> x . toString ( ) ) . collect ( Collectors . joining ( ) ) ; sample = String . join ( " " , prefix , sample . substring ( 0 , sample . length ( ) - 1 ) , suffix , String . valueOf ( ( char ) 0 ) ) ; samplePi = PiFunctionImpl . getPiFunction ( sample ) ; sampleLength = sample . length ( ) ; appended . clear ( ) ; prepended . clear ( ) ; }
standy66/fizteh-ads-2014 | public void appendCharToTemplate ( char c ) throws IllegalStateException { if ( sample == null ) { throw new IllegalStateException ( " no ▁ template ▁ was ▁ set " ) ; } appended . add ( c ) ; if ( appended . size ( ) + prepended . size ( ) > sample . length ( ) ) { recalculate ( ) ; } }
standy66/fizteh-ads-2014 | public void prependCharToTemplate ( char c ) throws IllegalStateException { if ( sample == null ) { throw new IllegalStateException ( " no ▁ template ▁ was ▁ set " ) ; } prepended . add ( c ) ; if ( appended . size ( ) + prepended . size ( ) > sample . length ( ) ) { recalculate ( ) ; } }
standy66/fizteh-ads-2014 | while ( buffer . size ( ) < neededSize && ! stream . isEmpty ( ) ) { buffer . add ( stream . nextChar ( ) ) ; }
standy66/fizteh-ads-2014 | if ( buffer . size ( ) < neededSize ) { return new ArrayList < > ( ) ; }
mzubairahmed/externalapi | @ JsonProperty ( " Code " ) public String getCode ( ) { return code ; }
mzubairahmed/externalapi | @ JsonProperty ( " Code " ) public void setCode ( String code ) { this . code = code ; }
mzubairahmed/externalapi | @ JsonProperty ( " Description " ) public String getDescription ( ) { return description ; }
mzubairahmed/externalapi | @ JsonProperty ( " Description " ) public void setDescription ( String description ) { this . description = description ; }
mzubairahmed/externalapi | @ JsonProperty ( " DisplayName " ) public String getDisplayName ( ) { return displayName ; }
mzubairahmed/externalapi | @ JsonProperty ( " DisplayName " ) public void setDisplayName ( String displayName ) { this . displayName = displayName ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaLevelCode " ) public String getCriteriaLevelCode ( ) { return criteriaLevelCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaLevelCode " ) public void setCriteriaLevelCode ( String criteriaLevelCode ) { this . criteriaLevelCode = criteriaLevelCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaGroupCode " ) public String getCriteriaGroupCode ( ) { return criteriaGroupCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaGroupCode " ) public void setCriteriaGroupCode ( String criteriaGroupCode ) { this . criteriaGroupCode = criteriaGroupCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaTypeCode " ) public String getCriteriaTypeCode ( ) { return criteriaTypeCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " CriteriaTypeCode " ) public void setCriteriaTypeCode ( String criteriaTypeCode ) { this . criteriaTypeCode = criteriaTypeCode ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowBasePrice " ) public Boolean getIsAllowBasePrice ( ) { return isAllowBasePrice ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowBasePrice " ) public void setIsAllowBasePrice ( Boolean isAllowBasePrice ) { this . isAllowBasePrice = isAllowBasePrice ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowUpcharge " ) public Boolean getIsAllowUpcharge ( ) { return isAllowUpcharge ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsAllowUpcharge " ) public void setIsAllowUpcharge ( Boolean isAllowUpcharge ) { this . isAllowUpcharge = isAllowUpcharge ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsFlag " ) public Boolean getIsFlag ( ) { return isFlag ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsFlag " ) public void setIsFlag ( Boolean isFlag ) { this . isFlag = isFlag ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsProductNumberAssignmentAllowed " ) public Boolean getIsProductNumberAssignmentAllowed ( ) { return isProductNumberAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsProductNumberAssignmentAllowed " ) public void setIsProductNumberAssignmentAllowed ( Boolean isProductNumberAssignmentAllowed ) { this . isProductNumberAssignmentAllowed = isProductNumberAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsMediaAssignmentAllowed " ) public Boolean getIsMediaAssignmentAllowed ( ) { return isMediaAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " IsMediaAssignmentAllowed " ) public void setIsMediaAssignmentAllowed ( Boolean isMediaAssignmentAllowed ) { this . isMediaAssignmentAllowed = isMediaAssignmentAllowed ; }
mzubairahmed/externalapi | @ JsonProperty ( " CodeValueGroups " ) public List < CodeValueGroup > getCodeValueGroups ( ) { return codeValueGroups ; }
mzubairahmed/externalapi | @ JsonProperty ( " CodeValueGroups " ) public void setCodeValueGroups ( List < CodeValueGroup > codeValueGroups ) { this . codeValueGroups = codeValueGroups ; }
Alachisoft/TayzGrid | if ( cParam . getIsUsage ( ) ) { AssemblyUsage . PrintUsage ( ) ; return ; }
Alachisoft/TayzGrid | if ( ! ValidateParameters ( ) ) { return ; }
Alachisoft/TayzGrid | if ( IsValidAddress ( cParam . getClientNode ( ) ) ) { NCache . setServerName ( cParam . getClientNode ( ) ) ; }
Alachisoft/TayzGrid | catch ( RuntimeException exp ) { System . err . println ( " Failed ▁ to ▁ Connect ▁ to ▁ IP ▁ " + cParam . getClientNode ( ) + " . " ) ; System . err . println ( " Error ▁ Detail : ▁ " + exp . getMessage ( ) ) ; return ; }
Alachisoft/TayzGrid | if ( cParam . getPort ( ) != - 1 ) { NCache . setPort ( cParam . getPort ( ) ) ; }
Alachisoft/TayzGrid | if ( cParam . getServer ( ) != null && ! cParam . getServer ( ) . equals ( " " ) ) { NCache . setServerName ( cParam . getServer ( ) ) ; }
Alachisoft/TayzGrid | if ( config == null ) { System . err . println ( " Error ▁ : ▁ The ▁ cache ▁ doesnot ▁ exist " ) ; return ; }
Alachisoft/TayzGrid | if ( config . getCacheSettings ( ) . getCacheType ( ) . equals ( " clustered - cache " ) && ! config . getCacheSettings ( ) . getInProc ( ) ) { for ( Address node : config . getCacheDeployment ( ) . getServers ( ) . GetAllConfiguredNodes ( ) ) { currentServerNodes . add ( node . getIpAddress ( ) . getHostAddress ( ) . toString ( ) ) ; } }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getClientNodes ( ) != null ) { for ( ClientNode clientNode : config . getCacheDeployment ( ) . getClientNodes ( ) . getNodesList ( ) ) { if ( cParam . getClientNode ( ) . equals ( clientNode . getName ( ) ) ) { System . err . println ( " Error : ▁ " + clientNode . getName ( ) + " ▁ already ▁ part ▁ of ▁ \" " + cParam . getCacheId ( ) + " \" " ) ; return ; } currentClientNodes . add ( clientNode . getName ( ) ) ; } }
Alachisoft/TayzGrid | catch ( Exception ex ) { if ( ex . getMessage ( ) != null ) System . err . println ( " Error : ▁ " + ex . getMessage ( ) ) ; }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getClientNodes ( ) == null ) { config . getCacheDeployment ( ) . setClientNodes ( new ClientNodes ( ) ) ; }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getClientNodes ( ) . getNodesList ( ) == null ) { config . getCacheDeployment ( ) . getClientNodes ( ) . setNodesList ( new java . util . ArrayList < ClientNode > ( ) ) ; }
Alachisoft/TayzGrid | for ( String node : currentServerNodes ) { NCache . setServerName ( node ) ; cacheServer = NCache . GetCacheServer ( new TimeSpan ( 0 , 0 , 30 ) ) ; cacheServer . ApplyCacheConfiguration ( cParam . getCacheId ( ) , config , null , null , false ) ; }
Alachisoft/TayzGrid | if ( currentClientNodes . size ( ) > 0 ) { oldClientNode = currentClientNodes . get ( 0 ) ; NCache . setServerName ( oldClientNode ) ; cacheServer = NCache . GetCacheServer ( new TimeSpan ( 0 , 0 , 30 ) ) ; clientConfig = cacheServer . GetClientConfiguration ( cParam . getCacheId ( ) ) ; }
Alachisoft/TayzGrid | if ( cParam . getClientBindingIp ( ) != null && ! cParam . getClientBindingIp ( ) . equals ( " " ) ) { cacheConfig . setBindIp ( cParam . getClientBindingIp ( ) ) ; }
Alachisoft/TayzGrid | if ( config . getCacheDeployment ( ) . getServers ( ) . getNodeIdentities ( ) != null && config . getCacheDeployment ( ) . getServers ( ) . getNodeIdentities ( ) . length != 0 ) { cacheConfig . setServersPriorityList ( new CacheServerList ( ) ) ; for ( NodeIdentity identity : config . getCacheDeployment ( ) . getServers ( ) . getNodeIdentities ( ) ) { com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer server = new com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer ( ) ; server . setServerName ( identity . getNodeName ( ) ) ; server . setPriority ( identity . getNodePriority ( ) ) ; cacheConfig . getServersPriorityList ( ) . setServersList ( identity . getNodePriority ( ) - 1 , server ) ; } }
Alachisoft/TayzGrid | if ( isSuccessFull ) { System . out . println ( " SuccessFully ▁ added ▁ client ▁ node " ) ; }
Alachisoft/TayzGrid | catch ( Exception ex ) { if ( ex . getMessage ( ) != null ) System . err . println ( " Error : ▁ " + ex . getMessage ( ) ) ; }
dagnir/aws-sdk-java | public void setProductCode ( String productCode ) { this . productCode = productCode ; }
dagnir/aws-sdk-java | public String getProductCode ( ) { return this . productCode ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withProductCode ( String productCode ) { setProductCode ( productCode ) ; return this ; }
dagnir/aws-sdk-java | public java . util . Map < String , java . util . List < String > > getFilter ( ) { return filter ; }
dagnir/aws-sdk-java | public void setFilter ( java . util . Map < String , java . util . List < String > > filter ) { this . filter = filter ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withFilter ( java . util . Map < String , java . util . List < String > > filter ) { setFilter ( filter ) ; return this ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest addFilterEntry ( String key , java . util . List < String > value ) { if ( null == this . filter ) { this . filter = new java . util . HashMap < String , java . util . List < String > > ( ) ; } if ( this . filter . containsKey ( key ) ) throw new IllegalArgumentException ( " Duplicated ▁ keys ▁ ( " + key . toString ( ) + " ) ▁ are ▁ provided . " ) ; this . filter . put ( key , value ) ; return this ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest clearFilterEntries ( ) { this . filter = null ; return this ; }
dagnir/aws-sdk-java | public void setNextToken ( String nextToken ) { this . nextToken = nextToken ; }
dagnir/aws-sdk-java | public String getNextToken ( ) { return this . nextToken ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withNextToken ( String nextToken ) { setNextToken ( nextToken ) ; return this ; }
dagnir/aws-sdk-java | public void setMaxResults ( Integer maxResults ) { this . maxResults = maxResults ; }
dagnir/aws-sdk-java | public Integer getMaxResults ( ) { return this . maxResults ; }
dagnir/aws-sdk-java | public GetEntitlementsRequest withMaxResults ( Integer maxResults ) { setMaxResults ( maxResults ) ; return this ; }
dagnir/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getProductCode ( ) != null ) sb . append ( " ProductCode : ▁ " ) . append ( getProductCode ( ) ) . append ( " , " ) ; if ( getFilter ( ) != null ) sb . append ( " Filter : ▁ " ) . append ( getFilter ( ) ) . append ( " , " ) ; if ( getNextToken ( ) != null ) sb . append ( " NextToken : ▁ " ) . append ( getNextToken ( ) ) . append ( " , " ) ; if ( getMaxResults ( ) != null ) sb . append ( " MaxResults : ▁ " ) . append ( getMaxResults ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dagnir/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof GetEntitlementsRequest == false ) return false ; GetEntitlementsRequest other = ( GetEntitlementsRequest ) obj ; if ( other . getProductCode ( ) == null ^ this . getProductCode ( ) == null ) return false ; if ( other . getProductCode ( ) != null && other . getProductCode ( ) . equals ( this . getProductCode ( ) ) == false ) return false ; if ( other . getFilter ( ) == null ^ this . getFilter ( ) == null ) return false ; if ( other . getFilter ( ) != null && other . getFilter ( ) . equals ( this . getFilter ( ) ) == false ) return false ; if ( other . getNextToken ( ) == null ^ this . getNextToken ( ) == null ) return false ; if ( other . getNextToken ( ) != null && other . getNextToken ( ) . equals ( this . getNextToken ( ) ) == false ) return false ; if ( other . getMaxResults ( ) == null ^ this . getMaxResults ( ) == null ) return false ; if ( other . getMaxResults ( ) != null && other . getMaxResults ( ) . equals ( this . getMaxResults ( ) ) == false ) return false ; return true ; }
dagnir/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getProductCode ( ) == null ) ? 0 : getProductCode ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getFilter ( ) == null ) ? 0 : getFilter ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getNextToken ( ) == null ) ? 0 : getNextToken ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMaxResults ( ) == null ) ? 0 : getMaxResults ( ) . hashCode ( ) ) ; return hashCode ; }
dagnir/aws-sdk-java | @ Override public GetEntitlementsRequest clone ( ) { return ( GetEntitlementsRequest ) super . clone ( ) ; }
argonium/wordfinder | private ExactMatchFilter ( ) { super ( ) ; }
argonium/wordfinder | public ExactMatchFilter ( final String word , final boolean bIgnoreCase ) { term = word ; ignoreCase = bIgnoreCase ; }
argonium/wordfinder | public boolean accept ( final String word ) { if ( ( word == null ) && ( term == null ) ) { return true ; } else if ( ( word == null ) || ( term == null ) ) { return false ; } if ( ignoreCase ) { return ( term . equalsIgnoreCase ( word ) ) ; } else { return ( term . equals ( word ) ) ; } }
Silveryard/CarLauncher | @ Override protected File getAPFFile ( ) { return getProject ( ) . file ( " BluetoothPlayer / build / apf / de _ silveryard _ car _ BluetoothPlayer _ 1_0 - SNAPSHOT . apf " ) ; }
camsas/Musketeer | == - 1 && minValue != null ) { context . write ( new Text ( " ALL " ) , new Text ( String . valueOf ( minValue ) + selectedCols ) ) ; }
djechelon/spring-security | protected AbstractPermission ( int mask ) { this . mask = mask ; this . code = ' * ' ; }
djechelon/spring-security | protected AbstractPermission ( int mask , char code ) { this . mask = mask ; this . code = code ; }
djechelon/spring-security | @ Override public final boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( ! ( obj instanceof Permission ) ) { return false ; } Permission other = ( Permission ) obj ; return ( this . mask == other . getMask ( ) ) ; }
djechelon/spring-security | @ Override public final int hashCode ( ) { return this . mask ; }
djechelon/spring-security | @ Override public final String toString ( ) { return this . getClass ( ) . getSimpleName ( ) + " [ " + getPattern ( ) + " = " + this . mask + " ] " ; }
djechelon/spring-security | @ Override public final int getMask ( ) { return this . mask ; }
djechelon/spring-security | @ Override public String getPattern ( ) { return AclFormattingUtils . printBinary ( this . mask , this . code ) ; }
sbt/ivy | public ExactPatternMatcher ( ) { super ( EXACT ) ; }
sbt/ivy | protected Matcher newMatcher ( String expression ) { return new ExactMatcher ( expression ) ; }
sbt/ivy | public ExactMatcher ( String expression ) { this . expression = expression ; }
sbt/ivy | public boolean matches ( String input ) { if ( input == null ) { throw new NullPointerException ( ) ; } return input . equals ( expression ) ; }
sbt/ivy | public boolean isExact ( ) { return true ; }
vjanmey/EpicMudfia | @ Override public String ID ( ) { return " GardenSnake " ; }
vjanmey/EpicMudfia | public GardenSnake ( ) { super ( ) ; username = " a ▁ garden ▁ snake " ; setDescription ( " A ▁ harmless ▁ little ▁ green ▁ string . " ) ; setDisplayText ( " A ▁ little ▁ garden ▁ snake ▁ slithers ▁ around ▁ looking ▁ for ▁ bugs . " ) ; CMLib . factions ( ) . setAlignment ( this , Faction . Align . NEUTRAL ) ; setMoney ( 0 ) ; basePhyStats ( ) . setDamage ( 1 ) ; baseCharStats ( ) . setStat ( CharStats . STAT_INTELLIGENCE , 1 ) ; basePhyStats ( ) . setAbility ( 0 ) ; basePhyStats ( ) . setLevel ( 1 ) ; basePhyStats ( ) . setArmor ( 90 ) ; baseCharStats ( ) . setMyRace ( CMClass . getRace ( " GardenSnake " ) ) ; baseCharStats ( ) . getMyRace ( ) . startRacing ( this , false ) ; baseState . setHitPoints ( CMLib . dice ( ) . roll ( basePhyStats ( ) . level ( ) , 20 , basePhyStats ( ) . level ( ) ) ) ; recoverMaxState ( ) ; resetToMaxState ( ) ; recoverPhyStats ( ) ; recoverCharStats ( ) ; }
shakamunyi/drill | @ Test public void testDirectConnectionConnectTriesEqualsDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; " + " tries = 2" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionConnectTriesGreaterThanDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 5" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionConnectTriesLessThanDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 1" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionInvalidConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = abc " , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof InvalidConnectionInfoException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionZeroConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 0" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testDirectConnectionNegativeConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = - 5" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
shakamunyi/drill | @ Test public void testZKSuccessfulConnectionZeroConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = 0" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
shakamunyi/drill | @ Test public void testZKSuccessfulConnectionNegativeConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = - 1" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
shakamunyi/drill | @ Test public void testZKSuccessfulConnectionGreaterThanConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = 7" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
shakamunyi/drill | @ Test public void testZKConnectionInvalidConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = abc " , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof InvalidConnectionInfoException ) ; } }
housejester/jsondumper | public void append ( Object obj , Writer writer ) throws IOException { writer . append ( " " + ( ( Date ) obj ) . getTime ( ) ) ; }
mociek124/java_pft | public FtpHelper ( ApplicationManager app ) { this . app = app ; ftp = new FTPClient ( ) ; }
mociek124/java_pft | public void upload ( File file , String target , String backup ) throws IOException { ftp . connect ( app . getProperty ( " ftp . host " ) ) ; ftp . login ( app . getProperty ( " ftp . login " ) , app . getProperty ( " ftp . password " ) ) ; ftp . deleteFile ( backup ) ; ftp . rename ( target , backup ) ; ftp . enterLocalPassiveMode ( ) ; ftp . storeFile ( target , new FileInputStream ( file ) ) ; ftp . disconnect ( ) ; }
mociek124/java_pft | public void restore ( String backup , String target ) throws IOException { ftp . connect ( app . getProperty ( " ftp . host " ) ) ; ftp . login ( app . getProperty ( " ftp . login " ) , app . getProperty ( " ftp . password " ) ) ; ftp . deleteFile ( target ) ; ftp . rename ( backup , target ) ; ftp . disconnect ( ) ; }
wentch/redkale | public HttpScope attr ( Map < String , Object > map ) { if ( map == null ) return this ; if ( this . attributes == null ) this . attributes = new LinkedHashMap < > ( ) ; this . attributes . putAll ( map ) ; return this ; }
wentch/redkale | public HttpScope attr ( String name , Object value ) { if ( this . attributes == null ) this . attributes = new LinkedHashMap < > ( ) ; this . attributes . put ( name , value ) ; return this ; }
wentch/redkale | public < T > T find ( String name ) { return this . attributes == null ? null : ( T ) this . attributes . get ( name ) ; }
wentch/redkale | public < T > T find ( HttpScope parent , String name ) { T rs = this . attributes == null ? null : ( T ) this . attributes . get ( name ) ; if ( rs != null ) return rs ; return parent == null ? null : parent . find ( name ) ; }
wentch/redkale | public void forEach ( BiConsumer < String , Object > action ) { if ( this . attributes == null ) return ; this . attributes . forEach ( action ) ; }
wentch/redkale | public String getReferid ( ) { return referid ; }
wentch/redkale | public void setReferid ( String referid ) { this . referid = referid ; }
wentch/redkale | public Map < String , Object > getAttributes ( ) { return attributes ; }
wentch/redkale | @ ConvertDisabled ( type = ConvertType . JSON ) public void setAttributes ( Map < String , Object > attributes ) { this . attributes = attributes ; }
wentch/redkale | @ Override public String toString ( ) { return JsonConvert . root ( ) . convertTo ( this ) ; }
miniway/presto | private ConvexHullAggregation ( ) { }
clairton/repository-vraptor | public Record ( final Object value , final Comparator comparator ) { this . value = value ; this . comparator = comparator ; }
msgpack/msgpack-java | @ Override public boolean isNilValue ( ) { return getValueType ( ) . isNilType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isBooleanValue ( ) { return getValueType ( ) . isBooleanType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isNumberValue ( ) { return getValueType ( ) . isNumberType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isIntegerValue ( ) { return getValueType ( ) . isIntegerType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isFloatValue ( ) { return getValueType ( ) . isFloatType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isRawValue ( ) { return getValueType ( ) . isRawType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isBinaryValue ( ) { return getValueType ( ) . isBinaryType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isStringValue ( ) { return getValueType ( ) . isStringType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isArrayValue ( ) { return getValueType ( ) . isArrayType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isMapValue ( ) { return getValueType ( ) . isMapType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isExtensionValue ( ) { return getValueType ( ) . isExtensionType ( ) ; }
msgpack/msgpack-java | @ Override public boolean isTimestampValue ( ) { return false ; }
msgpack/msgpack-java | @ Override public ImmutableNilValue asNilValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableBooleanValue asBooleanValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableNumberValue asNumberValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableIntegerValue asIntegerValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableFloatValue asFloatValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableRawValue asRawValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableBinaryValue asBinaryValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableStringValue asStringValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableArrayValue asArrayValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableMapValue asMapValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableExtensionValue asExtensionValue ( ) { throw new MessageTypeCastException ( ) ; }
msgpack/msgpack-java | @ Override public ImmutableTimestampValue asTimestampValue ( ) { throw new MessageTypeCastException ( ) ; }
jentfoo/aws-sdk-java | public ChangeBatch unmarshall ( StaxUnmarshallerContext context ) throws Exception { ChangeBatch changeBatch = new ChangeBatch ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return changeBatch ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( " Comment " , targetDepth ) ) { changeBatch . setComment ( StringStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } if ( context . testExpression ( " Changes " , targetDepth ) ) { changeBatch . withChanges ( new ArrayList < Change > ( ) ) ; continue ; } if ( context . testExpression ( " Changes / Change " , targetDepth ) ) { changeBatch . withChanges ( ChangeStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return changeBatch ; } } } }
Azure/azure-sdk-for-java | MachineEventsProcessor ( Duration reportingInterval ) { this . reportingInterval = reportingInterval ; }
Azure/azure-sdk-for-java | void onEvent ( EventContext eventContext ) { final PartitionContext partitionContext = eventContext . getPartitionContext ( ) ; final EventData event = eventContext . getEventData ( ) ; final String contents = event . getBodyAsString ( ) ; final int temperature ; try { temperature = Integer . parseInt ( contents ) ; } catch ( NumberFormatException ex ) { logger . warn ( " Unable ▁ to ▁ parse ▁ temperature ▁ data . ▁ Partition : ▁ # { } . ▁ Seq ▁ # { } . ▁ Contents : ▁ # { } . ▁ Error : ▁ { } " , partitionContext . getPartitionId ( ) , event . getSequenceNumber ( ) , contents , ex ) ; return ; } final String machineId = event . getPartitionKey ( ) ; if ( machineId == null || machineId . isEmpty ( ) ) { logger . warn ( " PartitionKey ▁ is ▁ not ▁ set ▁ on ▁ event . ▁ Partition : ▁ # { } . ▁ Seq ▁ # { } . ▁ Contents : ▁ # { } . " , partitionContext . getPartitionId ( ) , event . getSequenceNumber ( ) , contents ) ; return ; } partitionsProcessing . compute ( partitionContext . getPartitionId ( ) , ( key , value ) -> { if ( value == null ) { value = new HashSet < > ( ) ; } value . add ( machineId ) ; return value ; } ) ; final MachineInformation information = machineInformation . computeIfAbsent ( machineId , key -> new MachineInformation ( key , reportingInterval ) ) ; information . onTemperatureEvent ( event . getEnqueuedTime ( ) , temperature ) ; eventContext . updateCheckpoint ( ) ; }
Azure/azure-sdk-for-java | void onInitialize ( InitializationContext initializationContext ) { final PartitionContext partition = initializationContext . getPartitionContext ( ) ; partitionsProcessing . computeIfAbsent ( partition . getPartitionId ( ) , key -> new HashSet < > ( ) ) ; }
Azure/azure-sdk-for-java | void onError ( ErrorContext errorContext ) { final PartitionContext partition = errorContext . getPartitionContext ( ) ; logger . error ( " Error ▁ occurred ▁ processing ▁ partition ▁ ' { } ' ? ▁ { } " , partition . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; }
Azure/azure-sdk-for-java | void onClose ( CloseContext closeContext ) { final PartitionContext partition = closeContext . getPartitionContext ( ) ; final Set < String > machineIds = partitionsProcessing . remove ( partition . getPartitionId ( ) ) ; logger . info ( " Stopped ▁ processing ▁ partition ▁ ' { } ' . ▁ Reason : ▁ ' { } ' " , partition . getPartitionId ( ) , closeContext . getCloseReason ( ) ) ; for ( String id : machineIds ) { final MachineInformation information = machineInformation . remove ( id ) ; if ( information == null ) { continue ; } logger . info ( " Stopped ▁ processing ▁ temperatures ▁ for ▁ machine : ▁ { } " , information . getIdentifier ( ) ) ; information . close ( ) ; } }
Azure/azure-sdk-for-java | @ Override public void close ( ) { if ( isDisposed . getAndSet ( true ) ) { return ; } partitionsProcessing . clear ( ) ; machineInformation . forEach ( ( key , value ) -> value . close ( ) ) ; machineInformation . clear ( ) ; }
Azure/azure-sdk-for-java | MachineInformation ( String identifier , Duration reportingInterval ) { this . identifier = identifier ; this . averageTemperatures = Flux . interval ( reportingInterval ) . takeUntilOther ( onDispose ) . map ( unused -> { final Instant timeCalculated = Instant . now ( ) ; final List < Integer > temperaturesInInterval = temperatures . getAndSet ( new ArrayList < > ( ) ) ; if ( temperaturesInInterval . size ( ) == 0 ) { logger . info ( " [ { } ] : ▁ Average : ▁ null " , this . identifier ) ; return new AverageTemperature ( timeCalculated , null ) ; } final int sum = temperaturesInInterval . stream ( ) . reduce ( 0 , Integer :: sum ) ; double average = sum / ( double ) temperaturesInInterval . size ( ) ; logger . info ( " [ { } ] : ▁ Average : ▁ { } " , this . identifier , average ) ; return new AverageTemperature ( timeCalculated , average ) ; } ) . publish ( ) ; averageTemperatures . connect ( ) ; }
Azure/azure-sdk-for-java | void onTemperatureEvent ( Instant dateEnqueued , int temperature ) { lastReported = dateEnqueued ; temperatures . getAndUpdate ( list -> { list . add ( temperature ) ; return list ; } ) ; }
Azure/azure-sdk-for-java | String getIdentifier ( ) { return identifier ; }
Azure/azure-sdk-for-java | Flux < AverageTemperature > getAverageTemperatures ( ) { return averageTemperatures ; }
Azure/azure-sdk-for-java | public Instant getLastReported ( ) { return lastReported ; }
Azure/azure-sdk-for-java | @ Override public void close ( ) { if ( isDisposed . getAndSet ( true ) ) { return ; } final FluxSink < Boolean > sink = onDispose . sink ( ) ; sink . next ( true ) ; sink . complete ( ) ; }
Azure/azure-sdk-for-java | AverageTemperature ( Instant timeCalculated , Double temperature ) { this . timeCalculated = timeCalculated ; this . temperature = temperature ; }
Azure/azure-sdk-for-java | public Instant getTimeCalculated ( ) { return timeCalculated ; }
Azure/azure-sdk-for-java | public Double getTemperature ( ) { return temperature ; }
xasx/assertj-core | private ShouldEndWith ( Object actual , Object expected , ComparisonStrategy comparisonStrategy ) { super ( " % nExpecting : % n ▁ < % s > % nto ▁ end ▁ with : % n ▁ < % s > % n % s " , actual , expected , comparisonStrategy ) ; }
bstopp/acs-aem-commons | public RefreshFolderTumbnailsTest ( ) { }
bstopp/acs-aem-commons | @ Before public void setUp ( ) { rr = mock ( ResourceResolver . class ) ; doAnswer ( ( Answer ) ( InvocationOnMock invocation ) -> { String path = ( String ) invocation . getArguments ( ) [ 0 ] ; return getResource ( path ) ; } ) . when ( rr ) . getResource ( anyString ( ) ) ; noThumbnail = mockResource ( " / missingThumbnail " ) ; manualThumbnail = mockResource ( " / manual " ) ; mockResource ( " / manual / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / manual / jcr : content / manualThumbnail . png " ) ; automaticThumbnail = mockResource ( " / automatic " ) ; mockResource ( " / automatic / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / automatic / jcr : content / folderThumbnail " , attachBinary ( 2048 ) ) ; placeholderThumbnail = mockResource ( " / placeholder " ) ; mockResource ( " / placeholder / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / placeholder / jcr : content / folderThumbnail " , attachBinary ( 950 ) ) ; outdatedThumbnail = mockResource ( " / outdated " ) ; mockResource ( " / outdated / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / outdated / jcr : content / folderThumbnail " , attachBinary ( 2048 ) ) ; mockResource ( " / outdated / jcr : content / folderThumbnail / jcr : content " , modifiedDateAndPaths ( previousDate , " / automatic " , " / manual " , " / placeholder " ) ) ; currentThumbnail = mockResource ( " / current " ) ; mockResource ( " / current / jcr : content " , modifiedDate ( currentDate ) ) ; mockResource ( " / current / jcr : content / folderThumbnail " , attachBinary ( 2048 ) ) ; mockResource ( " / current / jcr : content / folderThumbnail / jcr : content " , modifiedDateAndPaths ( currentDate , " / automatic " , " / manual " , " / placeholder " ) ) ; }
bstopp/acs-aem-commons | @ Test public void basicAssertions ( ) throws IOException { assertTrue ( RefreshFolderTumbnails . isThumbnailMissing ( noThumbnail ) ) ; assertTrue ( RefreshFolderTumbnails . isPlaceholderThumbnail ( placeholderThumbnail ) ) ; assertTrue ( RefreshFolderTumbnails . isThumbnailManual ( manualThumbnail ) ) ; assertTrue ( RefreshFolderTumbnails . isThumbnailAutomatic ( automaticThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanMissingThumbnail ( ) throws Exception { assertTrue ( MISSING . shouldReplace ( noThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( automaticThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( manualThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( placeholderThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( outdatedThumbnail ) ) ; assertFalse ( MISSING . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanOutdatedThumbnail ( ) throws Exception { assertTrue ( OUTDATED . shouldReplace ( noThumbnail ) ) ; assertTrue ( OUTDATED . shouldReplace ( automaticThumbnail ) ) ; assertFalse ( OUTDATED . shouldReplace ( manualThumbnail ) ) ; assertTrue ( OUTDATED . shouldReplace ( placeholderThumbnail ) ) ; assertTrue ( OUTDATED . shouldReplace ( outdatedThumbnail ) ) ; assertFalse ( OUTDATED . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanAutomaticOrMissing ( ) throws Exception { assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( noThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( automaticThumbnail ) ) ; assertFalse ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( manualThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( placeholderThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( outdatedThumbnail ) ) ; assertTrue ( ALL_AUTOMATIC_OR_MISSING . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | @ Test public void scanAll ( ) throws Exception { assertTrue ( ALL . shouldReplace ( noThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( automaticThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( manualThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( placeholderThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( outdatedThumbnail ) ) ; assertTrue ( ALL . shouldReplace ( currentThumbnail ) ) ; }
bstopp/acs-aem-commons | public Resource mockResource ( String path , BiConsumer < String , Resource > ... setupFunctions ) { Resource res = mock ( Resource . class ) ; when ( res . getPath ( ) ) . thenReturn ( path ) ; when ( res . getResourceResolver ( ) ) . thenReturn ( rr ) ; doAnswer ( ( Answer ) ( InvocationOnMock invocation ) -> { String relPath = ( String ) invocation . getArguments ( ) [ 0 ] ; return getResource ( path + " / " + relPath ) ; } ) . when ( res ) . getChild ( anyString ( ) ) ; for ( BiConsumer < String , Resource > setup : setupFunctions ) { setup . accept ( path , res ) ; } resources . put ( path , res ) ; return res ; }
bstopp/acs-aem-commons | public Resource getResource ( String path ) { return resources . get ( path ) ; }
bstopp/acs-aem-commons | private BiConsumer < String , Resource > attachBinary ( int size ) { return ( path , res ) -> { when ( res . adaptTo ( InputStream . class ) ) . thenReturn ( new ByteArrayInputStream ( new byte [ size ] ) ) ; } ; }
bstopp/acs-aem-commons | private BiConsumer < String , Resource > modifiedDate ( Date date ) { return ( path , res ) -> { Map < String , Object > map = new HashMap < > ( ) ; map . put ( " jcr : lastModified " , date ) ; when ( res . getValueMap ( ) ) . thenReturn ( new ValueMapDecorator ( map ) ) ; } ; }
bstopp/acs-aem-commons | private BiConsumer < String , Resource > modifiedDateAndPaths ( Date date , String ... paths ) { return ( path , res ) -> { Map < String , Object > map = new HashMap < > ( ) ; map . put ( " jcr : lastModified " , date ) ; map . put ( " dam : folderThumbnailPaths " , paths ) ; when ( res . getValueMap ( ) ) . thenReturn ( new ValueMapDecorator ( map ) ) ; } ; }
bootique/bootique-kafka-client | default DefaultKafkaProducerBuilder < byte [ ] , String > charValueProducer ( ) { return producer ( new ByteArraySerializer ( ) , new StringSerializer ( ) ) ; }
bootique/bootique-kafka-client | default DefaultKafkaProducerBuilder < byte [ ] , byte [ ] > binaryProducer ( ) { return producer ( new ByteArraySerializer ( ) , new ByteArraySerializer ( ) ) ; }
bootique/bootique-kafka-client | default < V > DefaultKafkaProducerBuilder < byte [ ] , V > binaryKeyProducer ( Serializer < V > valueSerializer ) { return producer ( new ByteArraySerializer ( ) , valueSerializer ) ; }
unchartedsoftware/aperture-tiles | protected TileDataMetadataImpl ( ) { _metaData = null ; }
unchartedsoftware/aperture-tiles | @ Override public Collection < String > getMetaDataProperties ( ) { if ( null == _metaData ) return null ; return _metaData . keySet ( ) ; }
unchartedsoftware/aperture-tiles | @ Override public String getMetaData ( String property ) { if ( null != _metaData ) return _metaData . get ( property ) ; return null ; }
unchartedsoftware/aperture-tiles | @ Override public void setMetaData ( String property , Object value ) { if ( null == _metaData ) { _metaData = new HashMap < > ( ) ; } if ( null == value ) { _metaData . put ( property , null ) ; } else { _metaData . put ( property , value . toString ( ) ) ; } }
igarashitm/camel | protected CamelContext createCamelContext ( ) throws Exception { return createSpringCamelContext ( this , " org / apache / camel / spring / processor / logProcessorWithProvidedLoggerTest . xml " ) ; }
Donnerbart/hazelcast | @ Test public void testVersionPattern ( ) { assertTrue ( VERSION_PATTERN . matcher ( "3.1" ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1 - SNAPSHOT " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1 - RC " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1 - RC1 - SNAPSHOT " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1" ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1 - RC " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1 - SNAPSHOT " ) . matches ( ) ) ; assertTrue ( VERSION_PATTERN . matcher ( "3.1.1 - RC1 - SNAPSHOT " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( " $ { project . version } " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( " project . version " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3" ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 . RC " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 . SNAPSHOT " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 - RC " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 - SNAPSHOT " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3 . " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3.1 . RC " ) . matches ( ) ) ; assertFalse ( VERSION_PATTERN . matcher ( "3.1 . SNAPSHOT " ) . matches ( ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenNull_returnNull ( ) throws Exception { assertEquals ( " " , StringUtil . getterIntoProperty ( " " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenEmpty_returnEmptyString ( ) throws Exception { assertEquals ( " " , StringUtil . getterIntoProperty ( " " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGet_returnUnchanged ( ) throws Exception { assertEquals ( " get " , StringUtil . getterIntoProperty ( " get " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGetFoo_returnFoo ( ) throws Exception { assertEquals ( " foo " , StringUtil . getterIntoProperty ( " getFoo " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGetF_returnF ( ) throws Exception { assertEquals ( " f " , StringUtil . getterIntoProperty ( " getF " ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenGetNumber_returnNumber ( ) throws Exception { assertEquals ( "8" , StringUtil . getterIntoProperty ( " get8" ) ) ; }
Donnerbart/hazelcast | @ Test public void getterIntoProperty_whenPropertyIsLowerCase_DoNotChange ( ) throws Exception { assertEquals ( " getfoo " , StringUtil . getterIntoProperty ( " getfoo " ) ) ; }
Donnerbart/hazelcast | @ Test public void test_lowerCaseFirstChar ( ) { assertEquals ( " " , StringUtil . lowerCaseFirstChar ( " " ) ) ; assertEquals ( " . " , StringUtil . lowerCaseFirstChar ( " . " ) ) ; assertEquals ( " ▁ " , StringUtil . lowerCaseFirstChar ( " ▁ " ) ) ; assertEquals ( " a " , StringUtil . lowerCaseFirstChar ( " a " ) ) ; assertEquals ( " a " , StringUtil . lowerCaseFirstChar ( " A " ) ) ; assertEquals ( " aBC " , StringUtil . lowerCaseFirstChar ( " ABC " ) ) ; assertEquals ( " abc " , StringUtil . lowerCaseFirstChar ( " Abc " ) ) ; }
Donnerbart/hazelcast | @ Test public void testSplitByComma ( ) throws Exception { assertNull ( StringUtil . splitByComma ( null , true ) ) ; assertArrayEquals ( arr ( " " ) , StringUtil . splitByComma ( " " , true ) ) ; assertArrayEquals ( arr ( " " ) , StringUtil . splitByComma ( " ▁ " , true ) ) ; assertArrayEquals ( arr ( ) , StringUtil . splitByComma ( " ▁ " , false ) ) ; assertArrayEquals ( arr ( " a " ) , StringUtil . splitByComma ( " a " , true ) ) ; assertArrayEquals ( arr ( " a " ) , StringUtil . splitByComma ( " a " , false ) ) ; assertArrayEquals ( arr ( " aa " , " bbb " , " c " ) , StringUtil . splitByComma ( " aa , bbb , c " , true ) ) ; assertArrayEquals ( arr ( " aa " , " bbb " , " c " , " " ) , StringUtil . splitByComma ( " ▁ aa\t , \n bbb ▁ ▁ ▁ , \r ▁ c , ▁ ▁ " , true ) ) ; assertArrayEquals ( arr ( " aa " , " bbb " , " c " ) , StringUtil . splitByComma ( " ▁ ▁ aa ▁ , \n , \r \tbbb ▁ ▁ , c ▁ , ▁ " , false ) ) ; }
Donnerbart/hazelcast | @ Test public void testArrayIntersection ( ) throws Exception { assertArrayEquals ( arr ( " test " ) , StringUtil . intersection ( arr ( " x " , " test " , " y " , " z " ) , arr ( " a " , " b " , " test " ) ) ) ; assertArrayEquals ( arr ( " " ) , StringUtil . intersection ( arr ( " " , " z " ) , arr ( " a " , " " ) ) ) ; assertArrayEquals ( arr ( ) , StringUtil . intersection ( arr ( " " , " z " ) , arr ( " a " ) ) ) ; }
Donnerbart/hazelcast | @ Test public void testArraySubraction ( ) throws Exception { assertNull ( StringUtil . subraction ( null , arr ( " a " , " test " , " b " , " a " ) ) ) ; assertArrayEquals ( arr ( " a " , " test " , " b " , " a " ) , StringUtil . subraction ( arr ( " a " , " test " , " b " , " a " ) , null ) ) ; assertArrayEquals ( arr ( " test " ) , StringUtil . subraction ( arr ( " a " , " test " , " b " , " a " ) , arr ( " a " , " b " ) ) ) ; assertArrayEquals ( arr ( ) , StringUtil . subraction ( arr ( ) , arr ( " a " , " b " ) ) ) ; assertArrayEquals ( arr ( " a " , " b " ) , StringUtil . subraction ( arr ( " a " , " b " ) , arr ( ) ) ) ; assertArrayEquals ( arr ( ) , StringUtil . subraction ( arr ( " a " , " test " , " b " , " a " ) , arr ( " a " , " b " , " test " ) ) ) ; }
Donnerbart/hazelcast | @ Test public void testEqualsIgnoreCase ( ) throws Exception { assertFalse ( StringUtil . equalsIgnoreCase ( null , null ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( null , " a " ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( " a " , null ) ) ; assertTrue ( StringUtil . equalsIgnoreCase ( " TEST " , " test " ) ) ; assertTrue ( StringUtil . equalsIgnoreCase ( " test " , " TEST " ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( " test " , " TEST2" ) ) ; Locale defaultLocale = Locale . getDefault ( ) ; Locale . setDefault ( new Locale ( " tr " ) ) ; try { assertTrue ( StringUtil . equalsIgnoreCase ( " EXIT " , " exit " ) ) ; assertFalse ( StringUtil . equalsIgnoreCase ( " exıt " , " EXIT " ) ) ; } finally { Locale . setDefault ( defaultLocale ) ; } }
Donnerbart/hazelcast | private String [ ] arr ( String ... strings ) { return strings ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( ) { super ( ) ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( String message ) { super ( message ) ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( String message , Throwable cause ) { super ( message , cause ) ; }
kubikrubikvkube/yandexDirectJavaApi | public ApiResponseException ( Throwable cause ) { super ( cause ) ; }
ibek/jbpm | @ Before @ Override public void deployKieJar ( ) { if ( kieJar == null ) { kieJar = archive . deployMigrationV1KieJar ( ) . getIdentifier ( ) ; } if ( kieJar2 == null ) { kieJar2 = archive . deployMigrationV2KieJar ( ) . getIdentifier ( ) ; } }
ibek/jbpm | @ After @ Override public void cleanup ( ) { super . cleanup ( ) ; kieJar2 = null ; }
ibek/jbpm | @ Test public void testUpgradeProcessInstance ( ) throws Exception { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; TaskSummary task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; MigrationReport report = migrationService . migrate ( kieJar , processInstanceId , kieJar2 , EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( report ) . isNotNull ( ) ; Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; userTaskService . completeAutoProgress ( task . getId ( ) , USER_YODA , null ) ; tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; }
ibek/jbpm | @ Test public void testUpgradeProcessInstanceWithNodeMapping ( ) throws Exception { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; TaskSummary task = tasks . get ( 0 ) ; Assertions . assertThat ( tasks . get ( 0 ) . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; Map < String , String > nodeMapping = new HashMap < String , String > ( ) ; nodeMapping . put ( " _ 4E8E7545 - FB70-494E - 9136-2B9ABE655889" , " _ 56FB3E50 - DEDD - 415B - 94DD - 0357C91836B9" ) ; MigrationReport report = migrationService . migrate ( kieJar , processInstanceId , kieJar2 , EVALUATION_PROCESS_ID_V2 , nodeMapping ) ; Assertions . assertThat ( report ) . isNotNull ( ) ; Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 1 ) ; task = tasks . get ( 0 ) ; Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( task . getProcessInstanceId ( ) ) . isEqualTo ( processInstanceId ) ; }
ibek/jbpm | @ Test public void testUpgradeProcessInstances ( ) throws Exception { List < Long > ids = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; ids . add ( processInstanceId ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; } List < MigrationReport > reports = migrationService . migrate ( kieJar , ids , kieJar2 , EVALUATION_PROCESS_ID_V2 ) ; Assertions . assertThat ( reports ) . isNotNull ( ) ; for ( MigrationReport report : reports ) { Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; } tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; userTaskService . completeAutoProgress ( task . getId ( ) , USER_YODA , null ) ; } tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; } }
ibek/jbpm | @ Test public void testUpgradeProcessInstancesWithNodeMapping ( ) throws Exception { List < Long > ids = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { Long processInstanceId = processService . startProcess ( kieJar , EVALUATION_PROCESS_ID_V1 ) ; ids . add ( processInstanceId ) ; if ( processInstanceId != null ) { archive . getPids ( ) . add ( processInstanceId ) ; } } List < TaskSummary > tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Evaluate ▁ items " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V1 ) ; } Map < String , String > nodeMapping = new HashMap < String , String > ( ) ; nodeMapping . put ( " _ 4E8E7545 - FB70-494E - 9136-2B9ABE655889" , " _ 56FB3E50 - DEDD - 415B - 94DD - 0357C91836B9" ) ; List < MigrationReport > reports = migrationService . migrate ( kieJar , ids , kieJar2 , EVALUATION_PROCESS_ID_V2 , nodeMapping ) ; Assertions . assertThat ( reports ) . isNotNull ( ) ; for ( MigrationReport report : reports ) { Assertions . assertThat ( report . isSuccessful ( ) ) . isTrue ( ) ; } tasks = runtimeDataService . getTasksAssignedAsPotentialOwner ( USER_YODA , new QueryFilter ( 0 , 10 ) ) ; Assertions . assertThat ( tasks . size ( ) ) . isEqualTo ( 5 ) ; for ( TaskSummary task : tasks ) { Assertions . assertThat ( task . getName ( ) ) . isEqualTo ( " Approve " ) ; Assertions . assertThat ( task . getDeploymentId ( ) ) . isEqualTo ( kieJar2 ) ; Assertions . assertThat ( task . getProcessId ( ) ) . isEqualTo ( EVALUATION_PROCESS_ID_V2 ) ; } }
Azure/azure-sdk-for-java | public String name ( ) { return this . name ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withName ( String name ) { this . name = name ; return this ; }
Azure/azure-sdk-for-java | public ClientDiscoveryDisplay display ( ) { return this . display ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withDisplay ( ClientDiscoveryDisplay display ) { this . display = display ; return this ; }
Azure/azure-sdk-for-java | public String origin ( ) { return this . origin ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withOrigin ( String origin ) { this . origin = origin ; return this ; }
Azure/azure-sdk-for-java | public ClientDiscoveryForProperties properties ( ) { return this . properties ; }
Azure/azure-sdk-for-java | public ClientDiscoveryValueForSingleApiInner withProperties ( ClientDiscoveryForProperties properties ) { this . properties = properties ; return this ; }
Azure/azure-sdk-for-java | public void validate ( ) { if ( display ( ) != null ) { display ( ) . validate ( ) ; } if ( properties ( ) != null ) { properties ( ) . validate ( ) ; } }
GunoH/intellij-community | public InternalTestDiscoveryListener ( ) { myTracesFile = System . getProperty ( " org . jetbrains . instrumentation . trace . file " ) ; if ( myTracesFile == null ) throw new IllegalArgumentException ( ) ; myModuleName = System . getProperty ( " org . jetbrains . instrumentation . main . module " ) ; if ( myModuleName == null ) throw new IllegalArgumentException ( ) ; System . out . println ( getClass ( ) . getSimpleName ( ) + " ▁ instantiated ▁ with ▁ module = ' " + myModuleName + " ' ▁ , ▁ directory = ' " + myTracesFile + " ' " ) ; }
GunoH/intellij-community | private Object getIndex ( ) { if ( myDiscoveryIndex == null ) { Project project = ProjectManager . getInstance ( ) . getDefaultProject ( ) ; try { myDiscoveryIndexClass = Class . forName ( " com . intellij . execution . testDiscovery . TestDiscoveryIndex " ) ; myDiscoveryIndex = myDiscoveryIndexClass . getConstructor ( Project . class , String . class ) . newInstance ( project , myTracesFile ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } } return myDiscoveryIndex ; }
GunoH/intellij-community | @ Override public void close ( ) { System . out . println ( " Start ▁ compacting ▁ to ▁ index " ) ; try { Object index = getIndex ( ) ; Method method = Class . forName ( " com . intellij . execution . testDiscovery . TestDiscoveryExtension " ) . getMethod ( " processTracesFile " , String . class , String . class , String . class , myDiscoveryIndexClass ) ; method . invoke ( null , myTracesFile , myModuleName , " j " , index ) ; System . out . println ( " Compacting ▁ done . " ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } zipOutput ( myTracesFile ) ; }
nikelin/Redshape-AS | public ReferenceStatement ( String value ) { super ( value ) ; }
PATRIC3/p3_solr | public ScaleFloatFunction ( ValueSource source , float min , float max ) { this . source = source ; this . min = min ; this . max = max ; }
PATRIC3/p3_solr | @ Override public String description ( ) { return " scale ( " + source . description ( ) + " , " + min + " , " + max + " ) " ; }
PATRIC3/p3_solr | private ScaleInfo createScaleInfo ( Map context , LeafReaderContext readerContext ) throws IOException { final List < LeafReaderContext > leaves = ReaderUtil . getTopLevelContext ( readerContext ) . leaves ( ) ; float minVal = Float . POSITIVE_INFINITY ; float maxVal = Float . NEGATIVE_INFINITY ; for ( LeafReaderContext leaf : leaves ) { int maxDoc = leaf . reader ( ) . maxDoc ( ) ; FunctionValues vals = source . getValues ( context , leaf ) ; for ( int i = 0 ; i < maxDoc ; i ++ ) { if ( ! vals . exists ( i ) ) { continue ; } float val = vals . floatVal ( i ) ; if ( ( Float . floatToRawIntBits ( val ) & ( 0xff << 23 ) ) == 0xff << 23 ) { continue ; } if ( val < minVal ) { minVal = val ; } if ( val > maxVal ) { maxVal = val ; } } } if ( minVal == Float . POSITIVE_INFINITY ) { minVal = maxVal = 0 ; } ScaleInfo scaleInfo = new ScaleInfo ( ) ; scaleInfo . minVal = minVal ; scaleInfo . maxVal = maxVal ; context . put ( ScaleFloatFunction . this , scaleInfo ) ; return scaleInfo ; }
PATRIC3/p3_solr | @ Override public FunctionValues getValues ( Map context , LeafReaderContext readerContext ) throws IOException { ScaleInfo scaleInfo = ( ScaleInfo ) context . get ( ScaleFloatFunction . this ) ; if ( scaleInfo == null ) { scaleInfo = createScaleInfo ( context , readerContext ) ; } final float scale = ( scaleInfo . maxVal - scaleInfo . minVal == 0 ) ? 0 : ( max - min ) / ( scaleInfo . maxVal - scaleInfo . minVal ) ; final float minSource = scaleInfo . minVal ; final float maxSource = scaleInfo . maxVal ; final FunctionValues vals = source . getValues ( context , readerContext ) ; return new FloatDocValues ( this ) { @ Override public boolean exists ( int doc ) { return vals . exists ( doc ) ; } @ Override public float floatVal ( int doc ) { return ( vals . floatVal ( doc ) - minSource ) * scale + min ; } @ Override public String toString ( int doc ) { return " scale ( " + vals . toString ( doc ) + " , toMin = " + min + " , toMax = " + max + " , fromMin = " + minSource + " , fromMax = " + maxSource + " ) " ; } } ; }
PATRIC3/p3_solr | @ Override public void createWeight ( Map context , IndexSearcher searcher ) throws IOException { source . createWeight ( context , searcher ) ; }
PATRIC3/p3_solr | @ Override public int hashCode ( ) { int h = Float . floatToIntBits ( min ) ; h = h * 29 ; h += Float . floatToIntBits ( max ) ; h = h * 29 ; h += source . hashCode ( ) ; return h ; }
PATRIC3/p3_solr | @ Override public boolean equals ( Object o ) { if ( ScaleFloatFunction . class != o . getClass ( ) ) return false ; ScaleFloatFunction other = ( ScaleFloatFunction ) o ; return this . min == other . min && this . max == other . max && this . source . equals ( other . source ) ; }
chhh/MSFTBX | public String getOrganizationRef ( ) { return organizationRef ; }
chhh/MSFTBX | public void setOrganizationRef ( String value ) { this . organizationRef = value ; }
selvasingh/azure-sdk-for-java | public Permission ( ) { super ( ) ; }
selvasingh/azure-sdk-for-java | public Permission ( String jsonString ) { super ( jsonString ) ; }
selvasingh/azure-sdk-for-java | public Permission setId ( String id ) { super . setId ( id ) ; return this ; }
selvasingh/azure-sdk-for-java | public String getResourceLink ( ) { return super . getString ( Constants . Properties . RESOURCE_LINK ) ; }
selvasingh/azure-sdk-for-java | public void setResourceLink ( String resourceLink ) { BridgeInternal . setProperty ( this , Constants . Properties . RESOURCE_LINK , resourceLink ) ; }
selvasingh/azure-sdk-for-java | public PermissionMode getPermissionMode ( ) { String value = super . getString ( Constants . Properties . PERMISSION_MODE ) ; return PermissionMode . valueOf ( StringUtils . upperCase ( value ) ) ; }
selvasingh/azure-sdk-for-java | public void setPermissionMode ( PermissionMode permissionMode ) { BridgeInternal . setProperty ( this , Constants . Properties . PERMISSION_MODE , permissionMode . toString ( ) . toLowerCase ( Locale . ROOT ) ) ; }
selvasingh/azure-sdk-for-java | public String getToken ( ) { return super . getString ( Constants . Properties . TOKEN ) ; }
selvasingh/azure-sdk-for-java | public PartitionKey getResourcePartitionKey ( ) { PartitionKey key = null ; Object value = super . get ( Constants . Properties . RESOURCE_PARTITION_KEY ) ; if ( value != null ) { ArrayNode arrayValue = ( ArrayNode ) value ; key = new PartitionKey ( BridgeInternal . getValue ( arrayValue . get ( 0 ) ) ) ; } return key ; }
selvasingh/azure-sdk-for-java | public void setResourcePartitionKey ( PartitionKey partitionkey ) { BridgeInternal . setProperty ( this , Constants . Properties . RESOURCE_PARTITION_KEY , BridgeInternal . getPartitionKeyInternal ( partitionkey ) . toJson ( ) ) ; }
haakom/EnergiWeb-remake | public RadiusReader ( ) { this . counter = 0 ; }
haakom/EnergiWeb-remake | public RadiusData readData ( ) { RadiusData data = new RadiusData ( ) ; FileReader is = null ; try { is = new FileReader ( new File ( " / etc / freeradius / users " ) ) ; BufferedReader in = new BufferedReader ( is ) ; boolean fReadMore = true ; while ( fReadMore ) { java . util . List < String > lines = new java . util . ArrayList < String > ( ) ; while ( lines . size ( ) < 6 ) { String strLine = in . readLine ( ) ; if ( strLine == null ) { fReadMore = false ; break ; } if ( ! strLine . startsWith ( " # " ) ) lines . add ( strLine ) ; } if ( lines . size ( ) == 6 ) { parseSegment ( lines , data ) ; counter ++ ; } } } catch ( IOException ex ) { LogWriter . elog ( ex , " RadiusReader . readData : ▁ count = " + counter ) ; } finally { if ( is != null ) try { is . close ( ) ; } catch ( IOException e ) { } } return data ; }
haakom/EnergiWeb-remake | private void parseSegment ( java . util . List < String > lines , RadiusData data ) { TerminalLink term1 = createTerminalLink ( lines , 0 ) ; TerminalLink term2 = createTerminalLink ( lines , 3 ) ; if ( term1 == null || term2 == null ) { LogWriter . elog ( " RadiusReader : ▁ data ▁ missing ▁ at ▁ segment ▁ " + counter ) ; return ; } String simId = term1 . getSIMCardId ( ) ; if ( ! simId . equals ( term2 . getSIMCardId ( ) ) ) { LogWriter . elog ( " RadiusReader : ▁ error ▁ in ▁ segment ▁ " + counter ) ; return ; } data . addSegment ( new IOSegment ( simId , term1 , term2 ) ) ; }
haakom/EnergiWeb-remake | private TerminalLink createTerminalLink ( java . util . List < String > lines , int idx ) { String strLine1 = lines . get ( idx ) ; if ( strLine1 . indexOf ( " Calling - Station - Id " ) < 0 ) return null ; String [ ] strArray = strLine1 . split ( " , " ) ; if ( strArray == null || strArray . length != 4 ) return null ; String simCardId = null ; String phoneNr = null ; String ipAddr = null ; String nasIdent = null ; String setupStr = null ; String [ ] strArr = strArray [ 0 ] . split ( " ▁ " ) ; if ( strArr == null || strArr . length > 0 ) simCardId = strArr [ 0 ] . trim ( ) ; strArr = strArray [ 2 ] . split ( " = = " ) ; if ( strArr == null || strArr . length > 1 ) phoneNr = strArr [ 1 ] . replaceAll ( " \" " , " " ) ; strArr = strArray [ 3 ] . split ( " = = " ) ; if ( strArr == null || strArr . length > 1 ) nasIdent = strArr [ 1 ] . replaceAll ( " \" " , " " ) ; String strLine2 = lines . get ( idx + 1 ) ; strArr = strLine2 . split ( " = " ) ; if ( strArr == null || strArr . length > 1 ) ipAddr = strArr [ 1 ] . replaceAll ( " , " , " " ) ; String strLine3 = lines . get ( idx + 2 ) ; if ( strLine3 . length ( ) > 0 ) setupStr = strLine3 . trim ( ) ; if ( simCardId == null || phoneNr == null || ipAddr == null ) return null ; return new TerminalLink ( simCardId , phoneNr . trim ( ) , ipAddr . trim ( ) , nasIdent . trim ( ) , setupStr ) ; }
amit-jain/jackrabbit-oak | void sync ( @ NotNull ExternalUser externalUser ) throws Exception { Root systemRoot = getSystemRoot ( ) ; DynamicSyncContext syncContext = new DynamicSyncContext ( syncConfig , idp , getUserManager ( systemRoot ) , getValueFactory ( systemRoot ) ) ; syncContext . sync ( externalUser ) ; syncContext . close ( ) ; systemRoot . commit ( ) ; root . refresh ( ) ; }
amit-jain/jackrabbit-oak | @ NotNull Set < Principal > getExpectedGroupPrincipals ( @ NotNull String userId ) throws Exception { if ( syncConfig . user ( ) . getMembershipNestingDepth ( ) == 1 ) { Set < Principal > principals = ImmutableSet . copyOf ( Iterables . transform ( idp . getUser ( userId ) . getDeclaredGroups ( ) , ( Function < ExternalIdentityRef , Principal > ) input -> { try { return new PrincipalImpl ( idp . getIdentity ( input ) . getPrincipalName ( ) ) ; } catch ( ExternalIdentityException e ) { throw new RuntimeException ( e ) ; } } ) ) ; return principals ; } else { Set < Principal > set = new HashSet < > ( ) ; collectExpectedPrincipals ( set , idp . getUser ( userId ) . getDeclaredGroups ( ) , syncConfig . user ( ) . getMembershipNestingDepth ( ) ) ; return set ; } }
amit-jain/jackrabbit-oak | @ NotNull Set < Principal > getExpectedAllSearchResult ( @ NotNull String userId ) throws Exception { return getExpectedGroupPrincipals ( userId ) ; }
amit-jain/jackrabbit-oak | private void collectExpectedPrincipals ( Set < Principal > grPrincipals , @ NotNull Iterable < ExternalIdentityRef > declaredGroups , long depth ) throws Exception { if ( depth <= 0 ) { return ; } for ( ExternalIdentityRef ref : declaredGroups ) { ExternalIdentity ei = idp . getIdentity ( ref ) ; grPrincipals . add ( new PrincipalImpl ( ei . getPrincipalName ( ) ) ) ; collectExpectedPrincipals ( grPrincipals , ei . getDeclaredGroups ( ) , depth - 1 ) ; } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalLocalUser ( ) throws Exception { assertNull ( principalProvider . getPrincipal ( getTestUser ( ) . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalLocalGroup ( ) throws Exception { Group gr = createTestGroup ( ) ; assertNull ( principalProvider . getPrincipal ( gr . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalExternalUser ( ) throws Exception { UserManager userManager = getUserManager ( root ) ; User syncedUser = userManager . getAuthorizable ( USER_ID , User . class ) ; assertNull ( principalProvider . getPrincipal ( syncedUser . getPrincipal ( ) . getName ( ) ) ) ; syncedUser = userManager . getAuthorizable ( TestIdentityProvider . ID_SECOND_USER , User . class ) ; assertNull ( principalProvider . getPrincipal ( syncedUser . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalExternalGroup ( ) throws Exception { Group gr = getUserManager ( root ) . getAuthorizable ( " secondGroup " , Group . class ) ; assertNotNull ( gr ) ; assertNull ( principalProvider . getPrincipal ( gr . getPrincipal ( ) . getName ( ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalDynamicGroup ( ) throws Exception { for ( ExternalIdentityRef ref : idp . getUser ( USER_ID ) . getDeclaredGroups ( ) ) { String princName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; Principal principal = principalProvider . getPrincipal ( princName ) ; assertNotNull ( principal ) ; assertTrue ( principal instanceof GroupPrincipal ) ; } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalInheritedGroups ( ) throws Exception { ImmutableSet < ExternalIdentityRef > declared = ImmutableSet . < ExternalIdentityRef > copyOf ( idp . getUser ( USER_ID ) . getDeclaredGroups ( ) ) ; for ( ExternalIdentityRef ref : declared ) { for ( ExternalIdentityRef inheritedGroupRef : idp . getIdentity ( ref ) . getDeclaredGroups ( ) ) { if ( declared . contains ( inheritedGroupRef ) ) { continue ; } String inheritedPrincName = idp . getIdentity ( inheritedGroupRef ) . getPrincipalName ( ) ; assertNull ( principalProvider . getPrincipal ( inheritedPrincName ) ) ; } } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalUnderscoreSign ( ) throws Exception { ExternalUser externalUser = idp . getUser ( USER_ID ) ; for ( ExternalIdentityRef ref : externalUser . getDeclaredGroups ( ) ) { String pName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; for ( String n : new String [ ] { " _ " , " _ " + pName . substring ( 1 ) , pName . substring ( 0 , pName . length ( ) - 1 ) + " _ " } ) { assertNull ( principalProvider . getPrincipal ( n ) ) ; } } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalPercentSign ( ) throws Exception { ExternalUser externalUser = idp . getUser ( USER_ID ) ; for ( ExternalIdentityRef ref : externalUser . getDeclaredGroups ( ) ) { String pName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; for ( String n : new String [ ] { " % " , " % " + pName , pName + " % " , pName . charAt ( 0 ) + " % " } ) { assertNull ( principalProvider . getPrincipal ( n ) ) ; } } }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalGroupsWithQueryWildCard ( ) throws Exception { ExternalUser externalUser = idp . getUser ( TestIdentityProvider . ID_WILDCARD_USER ) ; sync ( externalUser ) ; for ( ExternalIdentityRef ref : externalUser . getDeclaredGroups ( ) ) { String pName = idp . getIdentity ( ref ) . getPrincipalName ( ) ; Principal p = principalProvider . getPrincipal ( pName ) ; assertNotNull ( p ) ; assertEquals ( pName , p . getName ( ) ) ; } }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipLocalPrincipal ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( getTestUser ( ) . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipLocalGroupPrincipal ( ) throws Exception { Group gr = createTestGroup ( ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( gr . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( gr . getPrincipal ( ) . getName ( ) ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipExternalUser ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( USER_ID ) ; assertNotNull ( user ) ; Set < Principal > expected = getExpectedGroupPrincipals ( USER_ID ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( user . getPrincipal ( ) ) ; assertEquals ( expected , principals ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipExternalUser2 ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( USER_ID ) ; assertNotNull ( user ) ; Set < Principal > expected = getExpectedGroupPrincipals ( USER_ID ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( user . getPrincipal ( ) . getName ( ) ) ) ; assertEquals ( expected , principals ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipDefaultSync ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( TestIdentityProvider . ID_SECOND_USER ) ; assertNotNull ( user ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( user . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipDefaultSync2 ( ) throws Exception { Authorizable user = getUserManager ( root ) . getAuthorizable ( TestIdentityProvider . ID_SECOND_USER ) ; assertNotNull ( user ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( user . getPrincipal ( ) . getName ( ) ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetGroupMembershipExternalGroup ( ) throws Exception { Authorizable group = getUserManager ( root ) . getAuthorizable ( " secondGroup " ) ; assertNotNull ( group ) ; Set < ? extends Principal > principals = principalProvider . getMembershipPrincipals ( group . getPrincipal ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; principals = principalProvider . getMembershipPrincipals ( new PrincipalImpl ( group . getPrincipal ( ) . getName ( ) ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsLocalUser ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getPrincipals ( getTestUser ( ) . getID ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsLocalGroup ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getPrincipals ( createTestGroup ( ) . getID ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsExternalUser ( ) throws Exception { Set < ? extends Principal > principals = principalProvider . getPrincipals ( USER_ID ) ; assertEquals ( getExpectedGroupPrincipals ( USER_ID ) , principals ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsExternalUser2 ( ) { Set < ? extends Principal > principals = principalProvider . getPrincipals ( TestIdentityProvider . ID_SECOND_USER ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsExternalGroup ( ) throws Exception { Authorizable authorizable = getUserManager ( root ) . getAuthorizable ( " secondGroup " ) ; assertNotNull ( authorizable ) ; Set < ? extends Principal > principals = principalProvider . getPrincipals ( authorizable . getID ( ) ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsNonExistingUser ( ) throws Exception { assertNull ( getUserManager ( root ) . getAuthorizable ( " nonExistingUser " ) ) ; Set < ? extends Principal > principals = principalProvider . getPrincipals ( " nonExistingUser " ) ; assertTrue ( principals . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsNonExistingUserTree ( ) throws Exception { Authorizable a = spy ( getUserManager ( root ) . getAuthorizable ( USER_ID ) ) ; when ( a . getPath ( ) ) . thenReturn ( " / path / to / non / existing / item " ) ; UserManager um = when ( mock ( UserManager . class ) . getAuthorizable ( USER_ID ) ) . thenReturn ( a ) . getMock ( ) ; UserConfiguration uc = when ( mock ( UserConfiguration . class ) . getUserManager ( root , getNamePathMapper ( ) ) ) . thenReturn ( um ) . getMock ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( root , uc , getNamePathMapper ( ) , ImmutableMap . of ( idp . getName ( ) , getAutoMembership ( ) ) ) ; assertTrue ( pp . getPrincipals ( USER_ID ) . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsForGroupTree ( ) throws Exception { Authorizable group = getUserManager ( root ) . createGroup ( " testGroup " ) ; Authorizable a = spy ( getUserManager ( root ) . getAuthorizable ( USER_ID ) ) ; when ( a . getPath ( ) ) . thenReturn ( group . getPath ( ) ) ; UserManager um = when ( mock ( UserManager . class ) . getAuthorizable ( USER_ID ) ) . thenReturn ( a ) . getMock ( ) ; UserConfiguration uc = when ( mock ( UserConfiguration . class ) . getUserManager ( root , getNamePathMapper ( ) ) ) . thenReturn ( um ) . getMock ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( root , uc , getNamePathMapper ( ) , ImmutableMap . of ( idp . getName ( ) , getAutoMembership ( ) ) ) ; assertTrue ( pp . getPrincipals ( USER_ID ) . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testGetPrincipalsMissingIdpName ( ) throws Exception { String userPath = getUserManager ( root ) . getAuthorizable ( USER_ID ) . getPath ( ) ; Tree t = root . getTree ( userPath ) ; t . removeProperty ( REP_EXTERNAL_ID ) ; String [ ] automembership = getAutoMembership ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( root , getUserConfiguration ( ) , getNamePathMapper ( ) , ImmutableMap . of ( idp . getName ( ) , automembership ) ) ; Set < ? extends Principal > principals = pp . getPrincipals ( USER_ID ) ; assertFalse ( principals . isEmpty ( ) ) ; assertFalse ( principals . removeAll ( ImmutableSet . copyOf ( automembership ) ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByHintTypeNotGroup ( ) { Iterator < ? extends Principal > iter = principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_NOT_GROUP ) ; assertSame ( Collections . emptyIterator ( ) , iter ) ; Iterator < ? extends Principal > iter2 = principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_NOT_GROUP , 0 , - 1 ) ; assertSame ( Collections . emptyIterator ( ) , iter2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByHintTypeGroup ( ) { Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " a " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_GROUP ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByHintTypeAll ( ) { Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " a " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsContainingUnderscore ( ) throws Exception { ExternalUser externalUser = idp . getUser ( TestIdentityProvider . ID_WILDCARD_USER ) ; sync ( externalUser ) ; Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " _ gr _ u _ " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " _ " , PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " _ " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsContainingPercentSign ( ) throws Exception { ExternalUser externalUser = idp . getUser ( TestIdentityProvider . ID_WILDCARD_USER ) ; sync ( externalUser ) ; Set < ? extends Principal > expected = ImmutableSet . of ( new PrincipalImpl ( " g % r % " ) ) ; Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " % " , PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( expected , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( " % " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; assertEquals ( expected , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByTypeNotGroup ( ) { Iterator < ? extends Principal > iter = principalProvider . findPrincipals ( PrincipalManager . SEARCH_TYPE_NOT_GROUP ) ; assertSame ( Collections . emptyIterator ( ) , iter ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByTypeGroup ( ) throws Exception { Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( PrincipalManager . SEARCH_TYPE_GROUP ) ) ; assertEquals ( getExpectedAllSearchResult ( USER_ID ) , res ) ; Set < ? extends Principal > res2 = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , - 1 ) ) ; assertEquals ( getExpectedAllSearchResult ( USER_ID ) , res2 ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsByTypeAll ( ) throws Exception { Set < ? extends Principal > res = ImmutableSet . copyOf ( principalProvider . findPrincipals ( PrincipalManager . SEARCH_TYPE_ALL ) ) ; assertEquals ( getExpectedAllSearchResult ( USER_ID ) , res ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsFiltersDuplicates ( ) throws Exception { ExternalGroup gr = idp . getGroup ( " a " ) ; ExternalUser otherUser = new TestUser ( " anotherUser " , ImmutableSet . of ( gr . getExternalId ( ) ) ) ; sync ( otherUser ) ; Set < Principal > expected = new HashSet < > ( ) ; expected . add ( new PrincipalImpl ( gr . getPrincipalName ( ) ) ) ; long depth = syncConfig . user ( ) . getMembershipNestingDepth ( ) ; if ( depth > 1 ) { collectExpectedPrincipals ( expected , gr . getDeclaredGroups ( ) , -- depth ) ; } Iterator < ? extends Principal > res = principalProvider . findPrincipals ( " a " , PrincipalManager . SEARCH_TYPE_ALL ) ; assertTrue ( res . hasNext ( ) ) ; assertEquals ( expected , ImmutableSet . copyOf ( res ) ) ; Iterator < ? extends Principal > res2 = principalProvider . findPrincipals ( " a " , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ; assertTrue ( res2 . hasNext ( ) ) ; assertEquals ( expected , ImmutableSet . copyOf ( res2 ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsSorted ( ) throws Exception { List < Principal > in = Arrays . asList ( new PrincipalImpl ( " p3" ) , new PrincipalImpl ( " p1" ) , new PrincipalImpl ( " p2" ) ) ; ExternalGroupPrincipalProvider p = new ExternalGroupPrincipalProvider ( root , getSecurityProvider ( ) . getConfiguration ( UserConfiguration . class ) , NamePathMapper . DEFAULT , ImmutableMap . of ( idp . getName ( ) , getAutoMembership ( ) ) ) { @ NotNull @ Override public Iterator < ? extends Principal > findPrincipals ( @ Nullable String nameHint , int searchType ) { return in . iterator ( ) ; } } ; List < Principal > out = ImmutableList . copyOf ( p . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_ALL , 0 , - 1 ) ) ; Collections . sort ( in , Comparator . comparing ( Principal :: getName ) ) ; assertEquals ( in , out ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffset ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; long offset = 2 ; long expectedSize = ( all . size ( ) <= offset ) ? 0 : all . size ( ) - offset ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , offset , - 1 ) ) ; assertEquals ( expectedSize , result . size ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffsetEqualsResultSize ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , all . size ( ) , - 1 ) ) ; assertTrue ( result . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffsetExceedsResultSize ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , all . size ( ) + 1 , - 1 ) ) ; assertTrue ( result . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithLimit ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , 1 ) ) ; assertEquals ( 1 , result . size ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithLimitExceedsResultSize ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , all . size ( ) + 1 ) ) ; assertEquals ( all , result ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithZeroLimit ( ) throws Exception { Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , 0 , 0 ) ) ; assertTrue ( result . isEmpty ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithOffsetAndLimit ( ) throws Exception { Set < Principal > all = getExpectedAllSearchResult ( USER_ID ) ; long offset = all . size ( ) - 1 ; long limit = all . size ( ) ; Set < ? extends Principal > result = ImmutableSet . copyOf ( principalProvider . findPrincipals ( null , false , PrincipalManager . SEARCH_TYPE_GROUP , offset , limit ) ) ; assertEquals ( 1 , result . size ( ) ) ; }
amit-jain/jackrabbit-oak | @ Test public void testFindPrincipalsWithParseException ( ) throws Exception { QueryEngine qe = mock ( QueryEngine . class ) ; when ( qe . executeQuery ( anyString ( ) , anyString ( ) , any ( Map . class ) , any ( Map . class ) ) ) . thenThrow ( new ParseException ( " fail " , 0 ) ) ; Root r = when ( mock ( Root . class ) . getQueryEngine ( ) ) . thenReturn ( qe ) . getMock ( ) ; ExternalGroupPrincipalProvider pp = new ExternalGroupPrincipalProvider ( r , getUserConfiguration ( ) , getNamePathMapper ( ) , Collections . emptyMap ( ) ) ; assertNull ( pp . getPrincipal ( " a " ) ) ; assertFalse ( pp . findPrincipals ( PrincipalManager . SEARCH_TYPE_GROUP ) . hasNext ( ) ) ; }
amit-jain/jackrabbit-oak | private TestUser ( @ NotNull String id , @ NotNull Iterable < ExternalIdentityRef > declaredGroups ) { super ( id ) ; this . declaredGroups = declaredGroups ; }
amit-jain/jackrabbit-oak | @ NotNull @ Override public Iterable < ExternalIdentityRef > getDeclaredGroups ( ) { return declaredGroups ; }
DieBauer/flink | @ Before public void setPartitioner ( ) { distributePartitioner = new RescalePartitioner < Tuple > ( ) ; }
DieBauer/flink | @ Test public void testSelectChannelsLength ( ) { sd . setInstance ( streamRecord ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 1 ) . length ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 2 ) . length ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 1024 ) . length ) ; }
DieBauer/flink | @ Test public void testSelectChannelsInterval ( ) { sd . setInstance ( streamRecord ) ; assertEquals ( 0 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 2 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 0 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; }
DieBauer/flink | @ Test public void testExecutionGraphGeneration ( ) throws Exception { final StreamExecutionEnvironment env = StreamExecutionEnvironment . getExecutionEnvironment ( ) ; env . setParallelism ( 4 ) ; DataStream < String > text = env . addSource ( new ParallelSourceFunction < String > ( ) { private static final long serialVersionUID = 7772338606389180774L ; @ Override public void run ( SourceContext < String > ctx ) throws Exception { } @ Override public void cancel ( ) { } } ) . setParallelism ( 2 ) ; DataStream < Tuple2 < String , Integer > > counts = text . rescale ( ) . flatMap ( new FlatMapFunction < String , Tuple2 < String , Integer > > ( ) { private static final long serialVersionUID = - 5255930322161596829L ; @ Override public void flatMap ( String value , Collector < Tuple2 < String , Integer > > out ) throws Exception { } } ) ; counts . rescale ( ) . print ( ) . setParallelism ( 2 ) ; JobGraph jobGraph = env . getStreamGraph ( ) . getJobGraph ( ) ; final JobID jobId = new JobID ( ) ; final String jobName = " Semi - Rebalance ▁ Test ▁ Job " ; final Configuration cfg = new Configuration ( ) ; List < JobVertex > jobVertices = jobGraph . getVerticesSortedTopologicallyFromSources ( ) ; JobVertex sourceVertex = jobVertices . get ( 0 ) ; JobVertex mapVertex = jobVertices . get ( 1 ) ; JobVertex sinkVertex = jobVertices . get ( 2 ) ; assertEquals ( 2 , sourceVertex . getParallelism ( ) ) ; assertEquals ( 4 , mapVertex . getParallelism ( ) ) ; assertEquals ( 2 , sinkVertex . getParallelism ( ) ) ; ExecutionGraph eg = new ExecutionGraph ( TestingUtils . defaultExecutor ( ) , TestingUtils . defaultExecutor ( ) , jobId , jobName , cfg , new SerializedValue < > ( new ExecutionConfig ( ) ) , AkkaUtils . getDefaultTimeout ( ) , new NoRestartStrategy ( ) , new ArrayList < BlobKey > ( ) , new ArrayList < URL > ( ) , new Scheduler ( TestingUtils . defaultExecutionContext ( ) ) , ExecutionGraph . class . getClassLoader ( ) ) ; try { eg . attachJobGraph ( jobVertices ) ; } catch ( JobException e ) { e . printStackTrace ( ) ; fail ( " Building ▁ ExecutionGraph ▁ failed : ▁ " + e . getMessage ( ) ) ; } ExecutionJobVertex execSourceVertex = eg . getJobVertex ( sourceVertex . getID ( ) ) ; ExecutionJobVertex execMapVertex = eg . getJobVertex ( mapVertex . getID ( ) ) ; ExecutionJobVertex execSinkVertex = eg . getJobVertex ( sinkVertex . getID ( ) ) ; assertEquals ( 0 , execSourceVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 1 , execMapVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 4 , execMapVertex . getParallelism ( ) ) ; ExecutionVertex [ ] mapTaskVertices = execMapVertex . getTaskVertices ( ) ; Map < Integer , Integer > mapInputPartitionCounts = new HashMap < > ( ) ; for ( ExecutionVertex mapTaskVertex : mapTaskVertices ) { assertEquals ( 1 , mapTaskVertex . getNumberOfInputs ( ) ) ; assertEquals ( 1 , mapTaskVertex . getInputEdges ( 0 ) . length ) ; ExecutionEdge inputEdge = mapTaskVertex . getInputEdges ( 0 ) [ 0 ] ; assertEquals ( sourceVertex . getID ( ) , inputEdge . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; int inputPartition = inputEdge . getSource ( ) . getPartitionNumber ( ) ; if ( ! mapInputPartitionCounts . containsKey ( inputPartition ) ) { mapInputPartitionCounts . put ( inputPartition , 1 ) ; } else { mapInputPartitionCounts . put ( inputPartition , mapInputPartitionCounts . get ( inputPartition ) + 1 ) ; } } assertEquals ( 2 , mapInputPartitionCounts . size ( ) ) ; for ( int count : mapInputPartitionCounts . values ( ) ) { assertEquals ( 2 , count ) ; } assertEquals ( 1 , execSinkVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 2 , execSinkVertex . getParallelism ( ) ) ; ExecutionVertex [ ] sinkTaskVertices = execSinkVertex . getTaskVertices ( ) ; Set < Integer > mapSubpartitions = new HashSet < > ( ) ; for ( ExecutionVertex sinkTaskVertex : sinkTaskVertices ) { assertEquals ( 1 , sinkTaskVertex . getNumberOfInputs ( ) ) ; assertEquals ( 2 , sinkTaskVertex . getInputEdges ( 0 ) . length ) ; ExecutionEdge inputEdge1 = sinkTaskVertex . getInputEdges ( 0 ) [ 0 ] ; ExecutionEdge inputEdge2 = sinkTaskVertex . getInputEdges ( 0 ) [ 1 ] ; assertEquals ( mapVertex . getID ( ) , inputEdge1 . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; assertEquals ( mapVertex . getID ( ) , inputEdge2 . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; int inputPartition1 = inputEdge1 . getSource ( ) . getPartitionNumber ( ) ; assertFalse ( mapSubpartitions . contains ( inputPartition1 ) ) ; mapSubpartitions . add ( inputPartition1 ) ; int inputPartition2 = inputEdge2 . getSource ( ) . getPartitionNumber ( ) ; assertFalse ( mapSubpartitions . contains ( inputPartition2 ) ) ; mapSubpartitions . add ( inputPartition2 ) ; } assertEquals ( 4 , mapSubpartitions . size ( ) ) ; }
guolf/pds | public void setMenuId ( Long menuId ) { this . menuId = menuId ; }
guolf/pds | public Long getMenuId ( ) { return menuId ; }
guolf/pds | public void setParentId ( Long parentId ) { this . parentId = parentId ; }
guolf/pds | public Long getParentId ( ) { return parentId ; }
guolf/pds | public void setName ( String name ) { this . name = name ; }
guolf/pds | public String getName ( ) { return name ; }
guolf/pds | public void setUrl ( String url ) { this . url = url ; }
guolf/pds | public String getUrl ( ) { return url ; }
guolf/pds | public String getPerms ( ) { return perms ; }
guolf/pds | public void setPerms ( String perms ) { this . perms = perms ; }
guolf/pds | public Integer getType ( ) { return type ; }
guolf/pds | public void setType ( Integer type ) { this . type = type ; }
guolf/pds | public void setIcon ( String icon ) { this . icon = icon ; }
guolf/pds | public String getIcon ( ) { return icon ; }
guolf/pds | public void setOrderNum ( Integer orderNum ) { this . orderNum = orderNum ; }
guolf/pds | public Integer getOrderNum ( ) { return orderNum ; }
guolf/pds | public List < ? > getList ( ) { return list ; }
guolf/pds | public void setList ( List < ? > list ) { this . list = list ; }
guolf/pds | public String getParentName ( ) { return parentName ; }
guolf/pds | public void setParentName ( String parentName ) { this . parentName = parentName ; }
guolf/pds | public Boolean getOpen ( ) { return true ; }
guolf/pds | public void setOpen ( Boolean open ) { this . open = open ; }
wuyinlei/MyHearts | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_category , container , false ) ; initView ( view ) ; mIndex = getArguments ( ) . getInt ( Contants . INDEX ) ; if ( mIndex == 0 ) { url = HttpUrlPaths . getDouyuLiveChannel ( limit , offset ) ; } else { url = HttpUrlPaths . getDouyuSubChannelBaseTag ( mIndex , limit , offset ) ; } requestData ( url ) ; return view ; }
wuyinlei/MyHearts | private void initView ( View view ) { this . mSwipeRefresh = ( SwipeRefreshLayout ) view . findViewById ( R . id . swipeRefresh ) ; mSwipeRefresh . setColorSchemeColors ( Color . YELLOW , Color . RED , Color . BLUE , Color . GREEN ) ; mSwipeRefresh . setOnRefreshListener ( this ) ; this . mRecyclerview = ( RecyclerView ) view . findViewById ( R . id . recycler_view ) ; mCategoryAdapter = new CategoryAdapter ( getContext ( ) ) ; final GridLayoutManager gridLayoutManager = new GridLayoutManager ( getContext ( ) , 2 ) ; gridLayoutManager . setSpanSizeLookup ( new GridLayoutManager . SpanSizeLookup ( ) { @ Override public int getSpanSize ( int position ) { return ( position == 0 || position == mDataEntities . size ( ) ) ? gridLayoutManager . getSpanCount ( ) : 1 ; } } ) ; mRecyclerview . setLayoutManager ( gridLayoutManager ) ; mRecyclerview . setAdapter ( mCategoryAdapter ) ; mCategoryAdapter . setOnItemClickListener ( ( view1 , position , dataEntity ) -> { if ( position % 2 == 0 ) { Intent intent = new Intent ( getActivity ( ) , VideoViewActivity . class ) ; intent . putExtra ( Contants . VIDEO_PATH , " http : // 125.39.142.86 / data2 / video09/2016/03/01/3871799-102-1615 . mp4" ) ; getActivity ( ) . startActivity ( intent ) ; } else { Intent intent = new Intent ( getActivity ( ) , VideoViewLiveActivity . class ) ; intent . putExtra ( Contants . VIDEO_PATH , " rtmp : // live . hkstv . hk . lxdns . com / live / hks " ) ; getActivity ( ) . startActivity ( intent ) ; } } ) ; mRecyclerview . addOnScrollListener ( new RecyclerView . OnScrollListener ( ) { @ Override public void onScrolled ( RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; } @ Override public void onScrollStateChanged ( RecyclerView recyclerView , int newState ) { super . onScrollStateChanged ( recyclerView , newState ) ; int lastVisiableItemPosition = gridLayoutManager . findLastVisibleItemPosition ( ) ; if ( lastVisiableItemPosition + 1 == mCategoryAdapter . getItemCount ( ) ) { if ( ! isLoading ) { isLoading = true ; mHandler . postDelayed ( ( ) -> { getMoreData ( ) ; isLoading = false ; mCategoryAdapter . notifyItemRemoved ( mCategoryAdapter . getItemCount ( ) ) ; } , 3000 ) ; } } } } ) ; }
wuyinlei/MyHearts | private void getMoreData ( ) { offset += limit ; limit += lordMoreNum ; if ( mIndex == 0 ) { url = HttpUrlPaths . getDouyuLiveChannel ( limit , offset ) ; } else { url = HttpUrlPaths . getDouyuSubChannelBaseTag ( mIndex , limit , offset ) ; } OkGo . get ( url ) . getCall ( StringConvert . create ( ) , RxAdapter . < String > create ( ) ) . doOnSubscribe ( ( ) -> { } ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( s -> { Type type = new TypeToken < RoomInfo > ( ) { } . getType ( ) ; RoomInfo roomInfo = new Gson ( ) . fromJson ( s , type ) ; if ( roomInfo . getData ( ) . size ( ) > 0 ) { mDataEntities . addAll ( roomInfo . getData ( ) ) ; mCategoryAdapter . setDataEntities ( mDataEntities ) ; mCategoryAdapter . notifyItemRemoved ( mCategoryAdapter . getItemCount ( ) ) ; } } , throwable -> { } ) ; }
wuyinlei/MyHearts | private void requestData ( String url ) { limit = lordMoreNum ; offset = 0 ; if ( mIndex == 0 ) { url = HttpUrlPaths . getDouyuLiveChannel ( limit , offset ) ; } else { url = HttpUrlPaths . getDouyuSubChannelBaseTag ( mIndex , limit , offset ) ; } OkGo . get ( url ) . getCall ( StringConvert . create ( ) , RxAdapter . < String > create ( ) ) . doOnSubscribe ( ( ) -> { } ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( s -> { Type type = new TypeToken < RoomInfo > ( ) { } . getType ( ) ; RoomInfo roomInfo = new Gson ( ) . fromJson ( s , type ) ; if ( roomInfo . getData ( ) . size ( ) > 0 ) { mDataEntities . addAll ( roomInfo . getData ( ) ) ; mCategoryAdapter . setDataEntities ( mDataEntities ) ; } } , throwable -> { } ) ; }
wuyinlei/MyHearts | @ Override public void onRefresh ( ) { new Handler ( ) . postDelayed ( ( ) -> { refreshData ( url ) ; mSwipeRefresh . setRefreshing ( false ) ; } , 3000 ) ; }
wuyinlei/MyHearts | private void refreshData ( String url ) { OkGo . get ( url ) . getCall ( StringConvert . create ( ) , RxAdapter . < String > create ( ) ) . doOnSubscribe ( ( ) -> { } ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( s -> { Type type = new TypeToken < RoomInfo > ( ) { } . getType ( ) ; RoomInfo roomInfo = new Gson ( ) . fromJson ( s , type ) ; if ( roomInfo . getData ( ) . size ( ) > 0 ) { mDataEntities . clear ( ) ; mDataEntities . addAll ( roomInfo . getData ( ) ) ; mCategoryAdapter . setDataEntities ( mDataEntities ) ; } } , throwable -> { } ) ; }
bbranan/fcrepo4 | @ Test public void testCreateVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; }
bbranan/fcrepo4 | @ Test public void testRemoveVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . createVersion ( session , " / " + pid , SECOND_LABEL ) ; session . commit ( ) ; assertEquals ( 3L , countVersions ( session , resource ) ) ; versionService . removeVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; }
bbranan/fcrepo4 | @ Test public void testRevertToVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; final String label = versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . createVersion ( session , " / " + pid , SECOND_LABEL ) ; session . commit ( ) ; assertEquals ( 3L , countVersions ( session , resource ) ) ; versionService . revertToVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( label , currentVersion ( session , resource ) ) ; }
bbranan/fcrepo4 | @ Test ( expected = RepositoryRuntimeException . class ) public void testRevertToInvalidVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . revertToVersion ( session , " / " + pid , " invalid - version - label " ) ; session . commit ( ) ; }
bbranan/fcrepo4 | @ Test ( expected = RepositoryRuntimeException . class ) public void testRemoveInvalidVersion ( ) throws RepositoryException { final FedoraSession session = repository . login ( ) ; final String pid = getRandomPid ( ) ; final FedoraResource resource = containerService . findOrCreate ( session , " / " + pid ) ; session . commit ( ) ; versionService . createVersion ( session , " / " + pid , LABEL ) ; session . commit ( ) ; assertEquals ( 2L , countVersions ( session , resource ) ) ; versionService . removeVersion ( session , " / " + pid , " invalid - version - label " ) ; session . commit ( ) ; }
paulstapleton/flowable-engine | @ Override protected String getEngineName ( ) { return this . getClass ( ) . getName ( ) ; }
paulstapleton/flowable-engine | @ Override protected void configureConfiguration ( CmmnEngineConfiguration cmmnEngineConfiguration ) { Map < Object , Object > beans = new HashMap < > ( ) ; cmmnEngineConfiguration . setBeans ( beans ) ; beans . put ( " taskListenerCreateBean " , new TestDelegateTaskListener ( ) ) ; beans . put ( " taskListenerCompleteBean " , new TestDelegateTaskListener ( ) ) ; beans . put ( " taskListenerAssignBean " , new TestDelegateTaskListener ( ) ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testCreateEvent ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; assertVariable ( caseInstance , " variableFromClassDelegate " , " Hello ▁ World ▁ from ▁ class ▁ delegate " ) ; assertVariable ( caseInstance , " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; assertVariable ( caseInstance , " expressionVariable " , " Hello ▁ World ▁ from ▁ expression " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testCompleteEvent ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; List < Task > tasks = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . list ( ) ; for ( Task task : tasks ) { if ( ! task . getName ( ) . equals ( " Keepalive " ) ) { cmmnTaskService . complete ( task . getId ( ) ) ; } } assertVariable ( caseInstance , " variableFromClassDelegate " , " Hello ▁ World ▁ from ▁ class ▁ delegate " ) ; assertVariable ( caseInstance , " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; assertVariable ( caseInstance , " expressionVariable " , " Hello ▁ World ▁ from ▁ expression " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testAssignEvent ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; List < Task > tasks = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . list ( ) ; for ( Task task : tasks ) { if ( ! task . getName ( ) . equals ( " Keepalive " ) ) { cmmnTaskService . setAssignee ( task . getId ( ) , " testAssignee " ) ; } } assertVariable ( caseInstance , " variableFromClassDelegate " , " Hello ▁ World ▁ from ▁ class ▁ delegate " ) ; assertVariable ( caseInstance , " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; assertVariable ( caseInstance , " expressionVariable " , " Hello ▁ World ▁ from ▁ expression " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment public void testAssignEventOriginalAssignee ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; Task task = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . singleResult ( ) ; cmmnTaskService . setAssignee ( task . getId ( ) , " testAssignee " ) ; assertVariable ( task , " taskId " , task . getId ( ) ) ; assertVariable ( task , " previousAssignee " , " defaultAssignee " ) ; assertVariable ( task , " currentAssignee " , " testAssignee " ) ; }
paulstapleton/flowable-engine | @ Test @ CmmnDeployment ( resources = " org / flowable / cmmn / test / listener / TaskListenerTest . testAssignEventOriginalAssignee . cmmn " ) public void testAssignEventOnCreateByHumanTaskActivityBehaviour ( ) { CaseInstance caseInstance = cmmnRuntimeService . createCaseInstanceBuilder ( ) . caseDefinitionKey ( " testTaskListeners " ) . start ( ) ; Task task = cmmnTaskService . createTaskQuery ( ) . caseInstanceId ( caseInstance . getId ( ) ) . singleResult ( ) ; assertVariable ( task , " taskId " , task . getId ( ) ) ; assertVariable ( task , " previousAssignee " , " defaultAssignee " ) ; assertVariable ( task , " currentAssignee " , " defaultAssignee " ) ; }
paulstapleton/flowable-engine | private void assertVariable ( CaseInstance caseInstance , String varName , String value ) { String variable = ( String ) cmmnRuntimeService . getVariable ( caseInstance . getId ( ) , varName ) ; assertThat ( variable ) . isEqualTo ( value ) ; }
paulstapleton/flowable-engine | private void assertVariable ( TaskInfo task , String varName , String value ) { String variable = ( String ) cmmnTaskService . getVariable ( task . getId ( ) , varName ) ; assertThat ( variable ) . isEqualTo ( value ) ; }
paulstapleton/flowable-engine | @ Override public void notify ( DelegateTask delegateTask ) { delegateTask . setVariable ( " variableFromDelegateExpression " , " Hello ▁ World ▁ from ▁ delegate ▁ expression " ) ; }
rmpestano/cukedoctor | public EnrichmentSteps ( ) throws IOException { }
rmpestano/cukedoctor | @ Before public void before ( ) throws IOException { metaCuke . setUp ( ) ; }
rmpestano/cukedoctor | @ After public void after ( ) throws IOException { metaCuke . tearDown ( ) ; }
rmpestano/cukedoctor | @ Given ( " ^ the ▁ feature : $ " ) public void the_feature ( String featureText ) throws Throwable { assertThat ( featureText ) . isNotNull ( ) ; metaCuke . addFeature ( featureText ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ docstring ▁ enriched ▁ json ▁ output ▁ activated ▁ with ▁ a ▁ step ▁ comment ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_docstring_enriched_json_output_activated_with_a_step_comment_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - step - comment . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ docstring ▁ with ▁ asciidoc ▁ content ▁ type ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_enriched_docstring_with_content_type_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - content - type . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ docstring ▁ with ▁ asciidoc ▁ feature ▁ tag ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_docstring_enriched_json_output_activiated_with_a_feature_tag_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - feature - tag . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ docstring ▁ with ▁ asciidoc ▁ scenario ▁ tag ▁ using ▁ cukedoctor ▁ converter $ " ) public void I_convert_docstring_enriched_json_output_activiated_with_a_scenario_tag_using_cukedoctor_converter ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / table - and - source - scenario - tag . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ enriched ▁ feature ▁ json ▁ output ▁ using ▁ cukedoctor $ " ) public void I_convert_enriched_feature_json_output_using_cukedoctor ( ) throws Throwable { getFeatureFixture ( " / json - output / enrichment / calc . json " ) ; }
rmpestano/cukedoctor | @ When ( " ^ I ▁ convert ▁ it $ " ) public void I_convert_it ( ) { metaCuke . runCucumber ( " com . care . dont " ) ; List < Feature > features = FeatureParser . parse ( metaCuke . getReport ( ) . getAbsolutePath ( ) ) ; documentation = new CukedoctorFeatureRenderer ( ( DocumentAttributes ) null ) . renderFeatures ( features , new CukedoctorDocumentBuilderImpl ( ) . createNestedBuilder ( ) ) ; }
rmpestano/cukedoctor | @ Then ( " ^ DocString ▁ asciidoc ▁ output ▁ must ▁ be ▁ rendered ▁ in ▁ my ▁ documentation $ " ) @ Then ( " ^ it ▁ should ▁ be ▁ rendered ▁ in ▁ AsciiDoc ▁ as $ " ) public void DocString_asciidoc_output_must_be_rendered_in_my_documentation ( String expected ) throws Throwable { assertThat ( documentation . replaceAll ( " \r " , " " ) ) . contains ( ( expected . replaceAll ( " \r " , " " ) ) ) ; }
rmpestano/cukedoctor | private void getFeatureFixture ( String fixturePath ) { URL featureFile = getClass ( ) . getResource ( fixturePath ) ; assertThat ( featureFile ) . isNotNull ( ) ; List < Feature > features = FeatureParser . parse ( featureFile . getPath ( ) ) ; assertThat ( features ) . isNotNull ( ) . hasSize ( 1 ) ; documentation = new CukedoctorFeatureRenderer ( ( DocumentAttributes ) null ) . renderFeatures ( features , new CukedoctorDocumentBuilderImpl ( ) . createNestedBuilder ( ) ) ; }
Medium/closure-templates | @ Inject public NoAutoescapeDirective ( ) { }
Medium/closure-templates | @ Override public String getName ( ) { return NAME ; }
Medium/closure-templates | @ Override public Set < Integer > getValidArgsSizes ( ) { return ImmutableSet . of ( 0 ) ; }
Medium/closure-templates | @ Override public boolean shouldCancelAutoescape ( ) { return true ; }
Medium/closure-templates | @ Override public SoyValue applyForJava ( SoyValue value , List < SoyValue > args ) { return Sanitizers . filterNoAutoescape ( value ) ; }
Medium/closure-templates | @ Override public SoyExpression applyForJbcSrc ( JbcSrcPluginContext context , SoyExpression value , List < SoyExpression > args ) { return SoyExpression . forSoyValue ( UnknownType . getInstance ( ) , JbcSrcMethods . FILTER_NO_AUTOESCAPE . invoke ( value . box ( ) ) ) ; }
Medium/closure-templates | @ Override public AppendableAndOptions applyForJbcSrcStreaming ( JbcSrcPluginContext context , Expression delegateAppendable , List < SoyExpression > args ) { return AppendableAndOptions . create ( JbcSrcMethods . FILTER_NO_AUTOESCAPE_STREAMING . invoke ( delegateAppendable ) ) ; }
Medium/closure-templates | @ Override public JsExpr applyForJsSrc ( JsExpr value , List < JsExpr > args ) { return new JsExpr ( " soy . $ $ filterNoAutoescape ( " + value . getText ( ) + " ) " , Integer . MAX_VALUE ) ; }
Medium/closure-templates | @ Override public ImmutableSet < String > getRequiredJsLibNames ( ) { return ImmutableSet . of ( " soy " ) ; }
MaedaSaneyuki/7segmentTimer | public void monodroidAddReference ( java . lang . Object obj ) { if ( refList == null ) refList = new java . util . ArrayList ( ) ; refList . add ( obj ) ; }
MaedaSaneyuki/7segmentTimer | public void monodroidClearReferences ( ) { if ( refList != null ) refList . clear ( ) ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchClearValuesRequest getBatchClearValuesRequest ( ) { return batchClearValuesRequest ; }
apache/camel | public void setBatchClearValuesRequest ( com . google . api . services . sheets . v4 . model . BatchClearValuesRequest batchClearValuesRequest ) { this . batchClearValuesRequest = batchClearValuesRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchGetValuesByDataFilterRequest getBatchGetValuesByDataFilterRequest ( ) { return batchGetValuesByDataFilterRequest ; }
apache/camel | public void setBatchGetValuesByDataFilterRequest ( com . google . api . services . sheets . v4 . model . BatchGetValuesByDataFilterRequest batchGetValuesByDataFilterRequest ) { this . batchGetValuesByDataFilterRequest = batchGetValuesByDataFilterRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchUpdateValuesByDataFilterRequest getBatchUpdateValuesByDataFilterRequest ( ) { return batchUpdateValuesByDataFilterRequest ; }
apache/camel | public void setBatchUpdateValuesByDataFilterRequest ( com . google . api . services . sheets . v4 . model . BatchUpdateValuesByDataFilterRequest batchUpdateValuesByDataFilterRequest ) { this . batchUpdateValuesByDataFilterRequest = batchUpdateValuesByDataFilterRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchUpdateValuesRequest getBatchUpdateValuesRequest ( ) { return batchUpdateValuesRequest ; }
apache/camel | public void setBatchUpdateValuesRequest ( com . google . api . services . sheets . v4 . model . BatchUpdateValuesRequest batchUpdateValuesRequest ) { this . batchUpdateValuesRequest = batchUpdateValuesRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . ClearValuesRequest getClearValuesRequest ( ) { return clearValuesRequest ; }
apache/camel | public void setClearValuesRequest ( com . google . api . services . sheets . v4 . model . ClearValuesRequest clearValuesRequest ) { this . clearValuesRequest = clearValuesRequest ; }
apache/camel | public com . google . api . services . sheets . v4 . model . BatchClearValuesByDataFilterRequest getContent ( ) { return content ; }
apache/camel | public void setContent ( com . google . api . services . sheets . v4 . model . BatchClearValuesByDataFilterRequest content ) { this . content = content ; }
apache/camel | public String getRange ( ) { return range ; }
apache/camel | public void setRange ( String range ) { this . range = range ; }
apache/camel | public String getSpreadsheetId ( ) { return spreadsheetId ; }
apache/camel | public void setSpreadsheetId ( String spreadsheetId ) { this . spreadsheetId = spreadsheetId ; }
apache/camel | public com . google . api . services . sheets . v4 . model . ValueRange getValues ( ) { return values ; }
apache/camel | public void setValues ( com . google . api . services . sheets . v4 . model . ValueRange values ) { this . values = values ; }
apache/jackrabbit-oak | @ Before public void setup ( ) throws Exception { container = azurite . getContainer ( AzureSegmentStoreService . DEFAULT_CONTAINER_NAME ) ; for ( String blob : BLOBS ) { container . getBlockBlobReference ( blob + " . txt " ) . uploadText ( blob ) ; } }
apache/jackrabbit-oak | @ Test public void connectWithSharedAccessSignatureURL_readOnly ( ) throws Exception { String sasToken = container . generateSharedAccessSignature ( policy ( READ_ONLY ) , null ) ; AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithSharedAccessSignature ( sasToken ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessNotGranted ( persistence ) ; assertReadAccessGranted ( persistence , BLOBS ) ; }
apache/jackrabbit-oak | @ Test public void connectWithSharedAccessSignatureURL_readWrite ( ) throws Exception { String sasToken = container . generateSharedAccessSignature ( policy ( READ_WRITE ) , null ) ; AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithSharedAccessSignature ( sasToken ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessGranted ( persistence ) ; assertReadAccessGranted ( persistence , concat ( BLOBS , " test " ) ) ; }
apache/jackrabbit-oak | @ Test public void connectWithSharedAccessSignatureURL_expired ( ) throws Exception { SharedAccessBlobPolicy expiredPolicy = policy ( READ_WRITE , yesterday ( ) ) ; String sasToken = container . generateSharedAccessSignature ( expiredPolicy , null ) ; AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithSharedAccessSignature ( sasToken ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessNotGranted ( persistence ) ; assertReadAccessNotGranted ( persistence ) ; }
apache/jackrabbit-oak | @ Test public void connectWithAccessKey ( ) throws Exception { AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithAccessKey ( AzuriteDockerRule . ACCOUNT_KEY ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessGranted ( persistence ) ; assertReadAccessGranted ( persistence , concat ( BLOBS , " test " ) ) ; }
apache/jackrabbit-oak | @ Test public void connectWithConnectionURL ( ) throws Exception { AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithConfigurationURL ( AzuriteDockerRule . ACCOUNT_KEY ) ) ; SegmentNodeStorePersistence persistence = context . getService ( SegmentNodeStorePersistence . class ) ; assertNotNull ( persistence ) ; assertWriteAccessGranted ( persistence ) ; assertReadAccessGranted ( persistence , concat ( BLOBS , " test " ) ) ; }
apache/jackrabbit-oak | @ Test public void deactivate ( ) throws Exception { AzureSegmentStoreService azureSegmentStoreService = new AzureSegmentStoreService ( ) ; azureSegmentStoreService . activate ( context . componentContext ( ) , getConfigurationWithAccessKey ( AzuriteDockerRule . ACCOUNT_KEY ) ) ; assertNotNull ( context . getService ( SegmentNodeStorePersistence . class ) ) ; azureSegmentStoreService . deactivate ( ) ; assertNull ( context . getService ( SegmentNodeStorePersistence . class ) ) ; }
crnk-project/crnk-framework | @ Test public void onSingleElementShouldReturnTheSameValue ( ) { String string = " hello ▁ world " ; List < String > values = Collections . singletonList ( string ) ; String result = StringUtils . join ( " , " , values ) ; assertThat ( result ) . isEqualTo ( string ) ; }
crnk-project/crnk-framework | @ Test public void onTwoElementsShouldReturnJoinedValues ( ) { List < String > values = Arrays . asList ( " hello " , " world " ) ; String result = StringUtils . join ( " ▁ " , values ) ; assertThat ( result ) . isEqualTo ( " hello ▁ world " ) ; }
crnk-project/crnk-framework | @ Test public void onIsBlankValues ( ) { assertTrue ( StringUtils . isBlank ( null ) ) ; assertTrue ( StringUtils . isBlank ( " " ) ) ; assertTrue ( StringUtils . isBlank ( " ▁ " ) ) ; assertFalse ( StringUtils . isBlank ( " crnk " ) ) ; assertFalse ( StringUtils . isBlank ( " ▁ ▁ crnk ▁ ▁ " ) ) ; }
crnk-project/crnk-framework | @ Test public void onJoinOfNulls ( ) { Assert . assertEquals ( " null , null " , StringUtils . join ( " , " , Arrays . asList ( null , null ) ) ) ; }
crnk-project/crnk-framework | @ Test public void checkDecapitalize ( ) { Assert . assertEquals ( " " , StringUtils . decapitalize ( " " ) ) ; Assert . assertEquals ( " test " , StringUtils . decapitalize ( " Test " ) ) ; Assert . assertEquals ( " someTest " , StringUtils . decapitalize ( " SomeTest " ) ) ; }
epanikas/q-link | public SampleDefImpl ( IPipelineContext ctxt ) { super ( ctxt ) ; doResult = getCtxt ( ) . getFactory ( ) . create ( DoResultAsSingleValue . class ) ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > first ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . first ) ; return doResult ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > last ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . last ) ; return doResult ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > middle ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . middle ) ; return doResult ; }
epanikas/q-link | @ Override public DoResultAsSingleValue < T , TPlugin > nth ( int nth ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . nth , nth ) ; return doResult ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > with ( SamplePredicate p ) { getCtxt ( ) . getPipelineDef ( ) . setSamplePredicate ( p ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > even ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . even ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > odd ( ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . odd ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > head ( int l ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . head , l ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
epanikas/q-link | @ Override public SampleEndDef < T , TPlugin > tail ( int l ) { getCtxt ( ) . getPipelineDef ( ) . setSampleType ( ESampleType . tail , l ) ; return new SampleEndDefImpl < T , TPlugin > ( getCtxt ( ) ) ; }
khiekmann/attila-load-test | @ Before public void before ( ) { givenThat ( mock . receivesAnyRequestThenReturn200TextplainContent ( ) ) ; }
khiekmann/attila-load-test | @ Test public void ok ( ) throws Exception { String actual = mock . readPage ( ) ; assertEquals ( responseContent , actual ) ; }
mendix/CommunityCommons | public StartRemoteApiServlet ( IContext context , java . lang . String password ) { super ( context ) ; this . password = password ; }
mendix/CommunityCommons | @ java . lang . Override public java . lang . Boolean executeAction ( ) throws Exception { Core . addRequestHandler ( " unittests / " , new RemoteApiServlet ( password ) ) ; return true ; }
mendix/CommunityCommons | @ java . lang . Override public java . lang . String toString ( ) { return " StartRemoteApiServlet " ; }
GunoH/intellij-community | protected void setUp ( ) throws Exception { System . out . println ( " foo " ) ; }
addthis/MetricCatcher | @ Before public void setUp ( ) throws Exception { }
addthis/MetricCatcher | @ After public void tearDown ( ) throws Exception { }
addthis/MetricCatcher | @ Test public void testFromName ( ) { MetricType res = MetricType . fromName ( " meter " ) ; assertEquals ( MetricType . METER , res ) ; }
addthis/MetricCatcher | @ Test public void testFromName_Invalid ( ) { MetricType res = MetricType . fromName ( " foo " ) ; assertEquals ( null , res ) ; }
addthis/MetricCatcher | @ Test public void testKlass ( ) { assertEquals ( Histogram . class , MetricType . HISTOGRAM_BIASED . getKlass ( ) ) ; }
GinaHsu/ud851-GinaExercises | public WaterReminderIntentService ( ) { super ( " WaterReminderIntentService " ) ; }
GinaHsu/ud851-GinaExercises | @ Override protected void onHandleIntent ( @ Nullable Intent intent ) { String action = intent . getAction ( ) ; ReminderTasks . executeTask ( this , action ) ; }
Log10Solutions/querydsl | private UserUtils ( ) { }
ebean-orm/avaje-ebeanorm-examples | @ Test public void simple ( ) { LoadExampleData . load ( ) ; Date oneWeekAgo = new Date ( System . currentTimeMillis ( ) ) ; ExpressionList < Order > recentNewOrders = new QOrder ( ) . orderDate . after ( oneWeekAgo ) . status . eq ( Order . Status . NEW ) . getExpressionList ( ) ; QCustomer cus = QCustomer . alias ( ) ; QContact con = QContact . alias ( ) ; List < Customer > customers = new QCustomer ( ) . select ( cus . name , cus . inactive ) . contacts . fetch ( con . email , con . firstName ) . contacts . notes . fetchAll ( ) . name . ilike ( " Rob " ) . orders . filterMany ( recentNewOrders ) . findList ( ) ; }
McJty/RFTools | public ModuleRenderInfo ( float factor , BlockPos pos , int hitx , int hity , @ Nullable TrueTypeFont font ) { this . factor = factor ; this . pos = pos ; this . hitx = hitx ; this . hity = hity ; this . font = font ; }
aws/aws-sdk-java | public Request < ListFunctionsRequest > marshall ( ListFunctionsRequest listFunctionsRequest ) { if ( listFunctionsRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } Request < ListFunctionsRequest > request = new DefaultRequest < ListFunctionsRequest > ( listFunctionsRequest , " AmazonCloudFront " ) ; request . setHttpMethod ( HttpMethodName . GET ) ; String uriResourcePath = " / 2020-05-31 / function " ; request . setResourcePath ( uriResourcePath ) ; if ( listFunctionsRequest . getMarker ( ) != null ) { request . addParameter ( " Marker " , StringUtils . fromString ( listFunctionsRequest . getMarker ( ) ) ) ; } if ( listFunctionsRequest . getMaxItems ( ) != null ) { request . addParameter ( " MaxItems " , StringUtils . fromString ( listFunctionsRequest . getMaxItems ( ) ) ) ; } if ( listFunctionsRequest . getStage ( ) != null ) { request . addParameter ( " Stage " , StringUtils . fromString ( listFunctionsRequest . getStage ( ) ) ) ; } return request ; }
far-edge/EdgeInfrastructure | public List < String > getDataKindReferenceID ( ) { if ( dataKindReferenceID == null ) { dataKindReferenceID = new ArrayList < String > ( ) ; } return dataKindReferenceID ; }
far-edge/EdgeInfrastructure | public void setDataKindReferenceID ( List < String > dataKindReferenceID ) { this . dataKindReferenceID = dataKindReferenceID ; }
MiniDigger/VoxelGamesLib | public StringScoreboardLine ( String value ) { this . value = value ; }
MiniDigger/VoxelGamesLib | @ Override public String getValue ( ) { return value ; }
MiniDigger/VoxelGamesLib | public void setValue ( String value ) { this . value = value ; }
edwinyxc/pond | for ( Tree < E > node : TinyTree . this . children ) { if ( node == null ) { continue ; } if ( STRING . notBlank ( node . name ( ) ) && node . name ( ) . equals ( name ) ) { return node ; } }
edwinyxc/pond | protected TinyTree ( ) { }
edwinyxc/pond | public TinyTree ( E root ) { this . elem = root ; this . parent = null ; name ( root . toString ( ) ) ; this . root = this ; }
edwinyxc/pond | private TinyTree ( Tree < E > tree ) { this ( tree . elem ( ) ) ; this . children . addAll ( tree . children ( ) ) ; }
edwinyxc/pond | @ Override public Tree < E > add ( Tree < E > t ) { t . addTo ( this ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > addTo ( Tree < E > t ) { root = t . root ( ) ; parent = t ; this . idxInParent = t . children ( ) . size ( ) ; t . children ( ) . add ( this ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > after ( Tree < E > t ) { siblings ( ) . add ( idxInParent + 1 , t ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > asNew ( ) { return new TinyTree < > ( this ) ; }
edwinyxc/pond | public Object attr ( String name ) { return this . attrs . get ( name ) ; }
edwinyxc/pond | public Map < String , Object > attrs ( ) { return this . attrs ; }
edwinyxc/pond | public Tree < E > attr ( String name , Object o ) { this . attrs . put ( name , o ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > before ( Tree < E > t ) { siblings ( ) . add ( idxInParent , t ) ; return this ; }
edwinyxc/pond | @ Override public Iterator < Tree < E > > bfs ( ) { return new BFS ( this ) ; }
edwinyxc/pond | @ Override public List < Tree < E > > children ( ) { return children ; }
edwinyxc/pond | @ Override public Iterator < Tree < E > > dfs ( ) { return new DFS ( this ) ; }
edwinyxc/pond | @ Override public E elem ( ) { return this . elem ; }
edwinyxc/pond | @ Override public Tree < E > elem ( E t ) { this . elem = t ; return this ; }
edwinyxc/pond | @ Override public Tree < E > find ( Function < Boolean , Tree < E > > findFunc ) { Iterator < Tree < E > > bfs = this . bfs ( ) ; while ( bfs . hasNext ( ) ) { final Tree < E > node = bfs . next ( ) ; if ( findFunc . apply ( node ) ) { return node ; } } return null ; }
edwinyxc/pond | @ Override public Tree < E > find ( String name ) { Iterator < Tree < E > > bfs = this . bfs ( ) ; while ( bfs . hasNext ( ) ) { final Tree < E > node = bfs . next ( ) ; if ( name . equals ( node . name ( ) ) ) { return node ; } } return null ; }
edwinyxc/pond | @ Override public Tree < E > first ( ) { return children . get ( 0 ) ; }
edwinyxc/pond | @ Override public boolean isFirst ( ) { List < ? > s = siblings ( ) ; S . _assert ( s != null && s . size ( ) > 0 , " bad ▁ logic " ) ; return this == s . get ( 0 ) ; }
edwinyxc/pond | @ Override public boolean isLast ( ) { List < ? > s = siblings ( ) ; S . _assert ( s != null && s . size ( ) > 0 , " bad ▁ logic " ) ; return this == s . get ( s . size ( ) - 1 ) ; }
edwinyxc/pond | @ Override public boolean isLeaf ( ) { return children . size ( ) == 0 ; }
edwinyxc/pond | @ Override public boolean isRoot ( ) { return parent == null ; }
edwinyxc/pond | @ Override public Tree < E > last ( ) { return children . get ( children . size ( ) - 1 ) ; }
edwinyxc/pond | private Matrix _lines ( ) { final Matrix view = MATRIX . console ( 255 ) ; view . addRow ( MATRIX . fromString ( this . name ( ) ) . row ( 0 ) ) ; S . _for ( children ( ) ) . each ( ( t ) -> { String prefix = " ┣ ━ ━ " ; if ( t . isLast ( ) ) { prefix = " ┗ ━ ━ " ; } view . addRows ( t . isLeaf ( ) ? MATRIX . fromString ( prefix , t . name ( ) ) : MATRIX . addHorizontal ( MATRIX . fromString ( prefix ) , ( ( TinyTree < E > ) t ) . _lines ( ) ) ) ; for ( int i = 1 ; i < view . rows ( ) ; i ++ ) { if ( view . get ( i , 0 ) == ' ┗ ' ) { break ; } else if ( view . get ( i , 0 ) == ' ┣ ' ) { } else { view . set ( i , 0 , ( int ) ' ┃ ' ) ; } } } ) ; return view ; }
edwinyxc/pond | @ Override public String name ( ) { return ( String ) this . attr ( " name " ) ; }
edwinyxc/pond | @ Override public Tree < E > name ( String name ) { return this . attr ( " name " , name ) ; }
edwinyxc/pond | @ Override public Tree < E > next ( ) { return siblings ( ) . get ( idxInParent + 1 ) ; }
edwinyxc/pond | @ Override public List < Tree < E > > nextAll ( ) { return S . array ( parent . children ( ) ) . slice ( idxInParent + 1 , parent . children ( ) . size ( ) ) . toList ( ) ; }
edwinyxc/pond | @ Override public Tree < E > parent ( ) { return parent ; }
edwinyxc/pond | @ Override public List < Tree < E > > parents ( ) { final List < Tree < E > > ret = new ArrayList < > ( ) ; Tree < E > node = this ; while ( node != null ) { ret . add ( node ) ; node = node . parent ( ) ; } return ret ; }
edwinyxc/pond | @ Override public String [ ] path ( ) { return S . _for ( parents ( ) ) . map ( a -> ( a . name ( ) ) ) . join ( ) ; }
edwinyxc/pond | @ Override public Tree < E > prev ( ) { return siblings ( ) . get ( idxInParent - 1 ) ; }
edwinyxc/pond | @ Override public List < Tree < E > > prevAll ( ) { return S . array ( parent . children ( ) ) . slice ( 0 , idxInParent ) . toList ( ) ; }
edwinyxc/pond | @ Override public void remove ( ) { siblings ( ) . remove ( this ) ; }
edwinyxc/pond | @ Override public Tree < E > remove ( Iterable < Tree < E > > t ) { for ( Tree < E > _t : t ) { children . remove ( _t ) ; } return this ; }
edwinyxc/pond | @ Override public Tree < E > remove ( Tree < E > t ) { children . remove ( t ) ; return this ; }
edwinyxc/pond | @ Override public Tree < E > root ( ) { return root ; }
edwinyxc/pond | @ Override public Tree < E > select ( String name ) { return selector . select ( name ) ; }
edwinyxc/pond | @ Override public Tree < E > select ( String [ ] name ) { Tree < E > cur = this ; int i = 0 ; while ( i < name . length ) { cur = cur . select ( name [ i ++ ] ) ; if ( cur == null ) { break ; } } if ( cur == this ) { return null ; } return cur ; }
edwinyxc/pond | @ Override public Selector < Tree < E > > selector ( ) { return selector ; }
edwinyxc/pond | @ Override public List < Tree < E > > siblings ( ) { if ( parent == null ) { return Collections . emptyList ( ) ; } return parent . children ( ) ; }
edwinyxc/pond | @ Override public String toString ( ) { long s = S . now ( ) ; String ret = " \n " + RichLayout . mkStr ( new Rect ( _lines ( ) ) ) ; long e = S . now ( ) ; return ret + " \n rendered ▁ in ▁ " + ( e - s ) + " ▁ ms " ; }
edwinyxc/pond | public BFS ( Tree < E > node ) { queue . offer ( node . children ( ) . iterator ( ) ) ; }
edwinyxc/pond | @ Override public boolean hasNext ( ) { if ( queue . isEmpty ( ) ) { return false ; } Iterator < Tree < E > > it = queue . peek ( ) ; if ( it . hasNext ( ) ) { return true ; } queue . poll ( ) ; return hasNext ( ) ; }
edwinyxc/pond | @ Override public Tree < E > next ( ) { if ( hasNext ( ) ) { Iterator < Tree < E > > it = queue . peek ( ) ; Tree < E > next = it . next ( ) ; if ( ! next . isLeaf ( ) ) { queue . offer ( next . children ( ) . iterator ( ) ) ; } return next ; } return null ; }
edwinyxc/pond | @ Override public void remove ( ) { throw new UnsupportedOperationException ( " remove ▁ not ▁ supported , ▁ yet . " ) ; }
edwinyxc/pond | public DFS ( Tree < E > node ) { S . _assert ( node , " node ▁ null " ) ; stack . push ( node . children ( ) . iterator ( ) ) ; }
edwinyxc/pond | @ Override public boolean hasNext ( ) { if ( stack . isEmpty ( ) ) { return false ; } Iterator < Tree < E > > it = stack . peek ( ) ; if ( it . hasNext ( ) ) { return true ; } stack . pop ( ) ; return hasNext ( ) ; }
edwinyxc/pond | @ Override public Tree < E > next ( ) { if ( hasNext ( ) ) { Iterator < Tree < E > > it = stack . peek ( ) ; Tree < E > next = it . next ( ) ; if ( ! next . isLeaf ( ) ) { stack . push ( next . children ( ) . iterator ( ) ) ; } return next ; } return null ; }
edwinyxc/pond | @ Override public void remove ( ) { throw new UnsupportedOperationException ( " remove ▁ not ▁ supported , ▁ yet . " ) ; }
opetrovski/development | @ Before public void setup ( ) throws Exception { initMocks ( ) ; orgTkey = Long . valueOf ( 1234L ) ; query = new OrganizationSettingQuery ( ds , orgTkey ) ; }
opetrovski/development | @ Test public void verifyQuery ( ) throws Exception { query . execute ( ) ; assertEquals ( 1 , createdStatement . getAllValues ( ) . size ( ) ) ; assertEquals ( " SELECT ▁ os . settingtype , ▁ os . settingvalue , ▁ ps . settingvalue ▁ FROM ▁ organizationsetting ▁ os ▁ LEFT ▁ OUTER ▁ JOIN ▁ platformsetting ▁ ps ▁ ON ▁ os . settingtype ▁ = ▁ ps . settingtype ▁ WHERE ▁ organization _ tkey ▁ = ▁ ? " , createdStatement . getValue ( ) ) ; }
opetrovski/development | @ Test public void verifyParam ( ) throws Exception { query . execute ( ) ; assertEquals ( 1 , passedParameter . getAllValues ( ) . size ( ) ) ; assertEquals ( orgTkey , passedParameter . getValue ( ) ) ; }
opetrovski/development | @ Test ( expected = NullPointerException . class ) public void verifyResultMapping_MissingMandatorySettings ( ) throws Exception { query . execute ( ) ; query . getProperties ( ) ; }
opetrovski/development | @ Test public void verifyResultMapping_MandatorySettings ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_ATTR_REFERRAL , " ignore " , " ignore " ) ; query . execute ( ) ; Properties properties = query . getProperties ( ) ; assertEquals ( " url " , properties . get ( Context . PROVIDER_URL ) ) ; assertEquals ( " com . sun . jndi . ldap . LdapCtxFactory " , properties . get ( Context . INITIAL_CONTEXT_FACTORY ) ) ; assertFalse ( properties . containsKey ( Context . SECURITY_PRINCIPAL ) ) ; assertEquals ( " ignore " , properties . get ( Context . REFERRAL ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_CheckProperties ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_PRINCIPAL , " principal " , " principal " ) ; addEntry ( SettingType . LDAP_CREDENTIALS , " credentials " , " credentials " ) ; addEntry ( SettingType . LDAP_ATTR_REFERRAL , " ignore " , " ignore " ) ; query . execute ( ) ; Properties properties = query . getProperties ( ) ; assertEquals ( " url " , properties . get ( Context . PROVIDER_URL ) ) ; assertEquals ( " com . sun . jndi . ldap . LdapCtxFactory " , properties . get ( Context . INITIAL_CONTEXT_FACTORY ) ) ; assertEquals ( " principal " , properties . get ( Context . SECURITY_PRINCIPAL ) ) ; assertEquals ( " credentials " , properties . get ( Context . SECURITY_CREDENTIALS ) ) ; assertEquals ( " ignore " , properties . get ( Context . REFERRAL ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_OrgSetting ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_BASE_DN , " orgBaseDN " , " platformBaseDN " ) ; query . execute ( ) ; assertEquals ( " orgBaseDN " , query . getBaseDN ( ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_LinkedSetting ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_ATTR_UID , " " , " platformUid " ) ; query . execute ( ) ; assertEquals ( " platformUid " , query . getAttrUid ( ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_UnsetBaseDN ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_ATTR_UID , " " , " platformUid " ) ; query . execute ( ) ; assertNull ( String . format ( " attribute ▁ for ▁ uid ▁ should ▁ be ▁ null ▁ but ▁ has ▁ value ▁ ' % s ' " , query . getBaseDN ( ) ) , query . getBaseDN ( ) ) ; }
opetrovski/development | @ Test public void verifyResultMapping_Evaluation_DefaultUid ( ) throws Exception { addEntry ( SettingType . LDAP_URL , " url " , " url " ) ; addEntry ( SettingType . LDAP_BASE_DN , " " , " platformBaseDN " ) ; query . execute ( ) ; assertEquals ( SettingType . LDAP_ATTR_UID . getDefaultValue ( ) , query . getAttrUid ( ) ) ; }
opetrovski/development | private void addEntry ( SettingType type , String orgValue , String platformValue ) { entries . add ( new ResultEntry ( type . name ( ) , orgValue , platformValue ) ) ; entryIterator = entries . iterator ( ) ; }
opetrovski/development | private void initMocks ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; ds = mock ( DataSource . class ) ; conn = mock ( Connection . class ) ; stmt = mock ( PreparedStatement . class ) ; rs = mock ( ResultSet . class ) ; doReturn ( conn ) . when ( ds ) . getConnection ( ) ; doReturn ( stmt ) . when ( conn ) . prepareStatement ( createdStatement . capture ( ) ) ; doReturn ( rs ) . when ( stmt ) . executeQuery ( ) ; doNothing ( ) . when ( stmt ) . setLong ( anyInt ( ) , passedParameter . capture ( ) ) ; doAnswer ( new Answer < Boolean > ( ) { public Boolean answer ( InvocationOnMock invocation ) throws Throwable { Boolean result = Boolean . valueOf ( entryIterator . hasNext ( ) ) ; if ( result ) { currentEntry = entryIterator . next ( ) ; } return result ; } } ) . when ( rs ) . next ( ) ; doAnswer ( new Answer < String > ( ) { public String answer ( InvocationOnMock invocation ) throws Throwable { Integer columnNo = ( Integer ) invocation . getArguments ( ) [ 0 ] ; switch ( columnNo . intValue ( ) ) { case 1 : return currentEntry . orgSettingType ; case 2 : return currentEntry . orgSettingValue ; case 3 : return currentEntry . platformSettingValue ; default : throw new RuntimeException ( " invalid ▁ column ▁ number " ) ; } } } ) . when ( rs ) . getString ( anyInt ( ) ) ; }
opetrovski/development | ResultEntry ( String orgSettingType , String orgSettingValue , String platformSettingValue ) { this . orgSettingType = orgSettingType ; this . orgSettingValue = orgSettingValue ; this . platformSettingValue = platformSettingValue ; }
GunoH/intellij-community | @ NotNull @ Override protected String buildErrorString ( Object ... infos ) { final PsiMethod method = ( PsiMethod ) infos [ 0 ] ; return InspectionGadgetsBundle . message ( " expected . exception . never . thrown . problem . descriptor " , method . getName ( ) ) ; }
GunoH/intellij-community | @ Override public BaseInspectionVisitor buildVisitor ( ) { return new ExpectedExceptionNeverThrownVisitor ( ) ; }
GunoH/intellij-community | @ Override public void visitMethod ( PsiMethod method ) { super . visitMethod ( method ) ; final PsiAnnotation annotation = AnnotationUtil . findAnnotation ( method , " org . junit . Test " ) ; if ( annotation == null ) { return ; } final PsiAnnotationParameterList parameterList = annotation . getParameterList ( ) ; final PsiNameValuePair [ ] attributes = parameterList . getAttributes ( ) ; PsiAnnotationMemberValue value = null ; for ( PsiNameValuePair attribute : attributes ) { if ( " expected " . equals ( attribute . getName ( ) ) ) { value = attribute . getValue ( ) ; break ; } } if ( ! ( value instanceof PsiClassObjectAccessExpression ) ) { return ; } final PsiCodeBlock body = method . getBody ( ) ; if ( body == null ) { return ; } final PsiClassObjectAccessExpression classObjectAccessExpression = ( PsiClassObjectAccessExpression ) value ; final PsiTypeElement operand = classObjectAccessExpression . getOperand ( ) ; final PsiType type = operand . getType ( ) ; final PsiClass aClass = PsiUtil . resolveClassInClassTypeOnly ( type ) ; if ( InheritanceUtil . isInheritor ( aClass , CommonClassNames . JAVA_LANG_RUNTIME_EXCEPTION ) || InheritanceUtil . isInheritor ( aClass , CommonClassNames . JAVA_LANG_ERROR ) ) { return ; } final List < PsiClassType > exceptionsThrown = ExceptionUtil . getThrownExceptions ( body ) ; for ( PsiClassType psiClassType : exceptionsThrown ) { if ( psiClassType . isAssignableFrom ( type ) ) { return ; } } registerError ( operand , method ) ; }
amikey/filter-nutch-plugin | public void setUp ( ) throws Exception { metadata . add ( Response . CONTENT_TYPE , " text / html " ) ; super . setUp ( ) ; }
amikey/filter-nutch-plugin | private Outlink [ ] generateOutlinks ( ) throws Exception { return generateOutlinks ( false ) ; }
amikey/filter-nutch-plugin | private Outlink [ ] generateOutlinks ( boolean parts ) throws Exception { Outlink [ ] outlinks = new Outlink [ 2 ] ; outlinks [ 0 ] = new Outlink ( " http : // www . test . com " , " test " ) ; outlinks [ 1 ] = new Outlink ( " http : // www . example . com " , " example " ) ; if ( parts ) { outlinks [ 0 ] = new Outlink ( outlinks [ 0 ] . getToUrl ( ) + " / index . php ? param = 1" , " test " ) ; outlinks [ 1 ] = new Outlink ( outlinks [ 1 ] . getToUrl ( ) + " / index . php ? param = 2" , " test " ) ; } return outlinks ; }
amikey/filter-nutch-plugin | public void testFilterOutlinks ( ) throws Exception { filter . setConf ( conf ) ; Outlink [ ] outlinks = generateOutlinks ( ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , new Inlinks ( ) ) ; assertEquals ( " Filter ▁ outlinks , ▁ allow ▁ only ▁ those ▁ from ▁ a ▁ different ▁ host " , outlinks [ 0 ] . getToUrl ( ) , doc . getFieldValue ( " outlinks " ) ) ; }
amikey/filter-nutch-plugin | public void testFilterInlinks ( ) throws Exception { filter . setConf ( conf ) ; Inlinks inlinks = new Inlinks ( ) ; inlinks . add ( new Inlink ( " http : // www . test . com " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . example . com " , " example " ) ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , new Outlink [ 0 ] , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , inlinks ) ; assertEquals ( " Filter ▁ inlinks , ▁ allow ▁ only ▁ those ▁ from ▁ a ▁ different ▁ host " , " http : // www . test . com " , doc . getFieldValue ( " inlinks " ) ) ; }
amikey/filter-nutch-plugin | public void testNoFilterOutlinks ( ) throws Exception { conf . set ( LinksIndexingFilter . LINKS_OUTLINKS_HOST , " false " ) ; filter . setConf ( conf ) ; Outlink [ ] outlinks = generateOutlinks ( ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , new Inlinks ( ) ) ; assertEquals ( " All ▁ outlinks ▁ must ▁ be ▁ indexed ▁ even ▁ those ▁ from ▁ the ▁ same ▁ host " , outlinks . length , doc . getField ( " outlinks " ) . getValues ( ) . size ( ) ) ; }
amikey/filter-nutch-plugin | public void testNoFilterInlinks ( ) throws Exception { conf . set ( LinksIndexingFilter . LINKS_INLINKS_HOST , " false " ) ; filter . setConf ( conf ) ; Inlinks inlinks = new Inlinks ( ) ; inlinks . add ( new Inlink ( " http : // www . test . com " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . example . com " , " example " ) ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , new Outlink [ 0 ] , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , inlinks ) ; assertEquals ( " All ▁ inlinks ▁ must ▁ be ▁ indexed ▁ even ▁ those ▁ from ▁ the ▁ same ▁ host " , inlinks . size ( ) , doc . getField ( " inlinks " ) . getValues ( ) . size ( ) ) ; }
amikey/filter-nutch-plugin | public void testIndexOnlyHostPart ( ) throws Exception { conf . set ( LinksIndexingFilter . LINKS_ONLY_HOSTS , " true " ) ; filter . setConf ( conf ) ; Outlink [ ] outlinks = generateOutlinks ( true ) ; Inlinks inlinks = new Inlinks ( ) ; inlinks . add ( new Inlink ( " http : // www . test . com / one - awesome - page " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . test . com / other - awesome - page " , " test " ) ) ; inlinks . add ( new Inlink ( " http : // www . example . com / my - first - awesome - example " , " example " ) ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , inlinks ) ; NutchField docOutlinks = doc . getField ( " outlinks " ) ; assertEquals ( " Only ▁ the ▁ host ▁ portion ▁ of ▁ the ▁ outlink ▁ URL ▁ must ▁ be ▁ indexed " , new URL ( " http : // www . test . com " ) . getHost ( ) , docOutlinks . getValues ( ) . get ( 0 ) ) ; assertEquals ( " The ▁ inlinks ▁ coming ▁ from ▁ the ▁ same ▁ host ▁ must ▁ count ▁ and ▁ only ▁ once " , 1 , doc . getField ( " inlinks " ) . getValues ( ) . size ( ) ) ; Iterator < Inlink > iterator = inlinks . iterator ( ) ; assertEquals ( " Only ▁ the ▁ host ▁ portion ▁ of ▁ the ▁ inlinks ▁ URL ▁ must ▁ be ▁ indexed " , new URL ( " http : // www . test . com " ) . getHost ( ) , doc . getFieldValue ( " inlinks " ) ) ; }
amikey/filter-nutch-plugin | public void testIndexHostsOnlyAndFilterOutlinks ( ) throws Exception { conf = NutchConfiguration . create ( ) ; conf . set ( LinksIndexingFilter . LINKS_ONLY_HOSTS , " true " ) ; conf . set ( LinksIndexingFilter . LINKS_OUTLINKS_HOST , " true " ) ; Outlink [ ] outlinks = generateOutlinks ( true ) ; filter . setConf ( conf ) ; NutchDocument doc = filter . filter ( new NutchDocument ( ) , new ParseImpl ( " text " , new ParseData ( new ParseStatus ( ) , " title " , outlinks , metadata ) ) , new Text ( " http : // www . example . com / " ) , new CrawlDatum ( ) , new Inlinks ( ) ) ; assertEquals ( " Index ▁ only ▁ the ▁ host ▁ portion ▁ of ▁ the ▁ outlinks ▁ after ▁ filtering ▁ the ▁ outlinks " , new URL ( " http : // www . test . com " ) . getHost ( ) , doc . getFieldValue ( " outlinks " ) ) ; }
Recombine/jailer | public AssociationRenderer ( boolean reversed ) { super ( Constants . EDGE_TYPE_LINE , reversed ? Constants . EDGE_ARROW_REVERSE : Constants . EDGE_ARROW_FORWARD ) ; this . reversed = reversed ; }
Recombine/jailer | public AssociationRenderer ( ) { full = true ; }
Recombine/jailer | @ Override protected Shape getRawShape ( VisualItem item ) { EdgeItem edge = ( EdgeItem ) item ; VisualItem item1 = edge . getSourceItem ( ) ; VisualItem item2 = edge . getTargetItem ( ) ; int type = m_edgeType ; boolean reversedCurve = false ; Association association = ( Association ) item . get ( " association " ) ; if ( association != null && association . source == association . destination ) { type = Constants . EDGE_TYPE_CURVE ; reversedCurve = association . reversed ; } getAlignedPoint ( m_tmpPoints [ 0 ] , item1 . getBounds ( ) , m_xAlign1 , m_yAlign1 ) ; getAlignedPoint ( m_tmpPoints [ 1 ] , item2 . getBounds ( ) , m_xAlign2 , m_yAlign2 ) ; m_curWidth = ( float ) ( m_width * getLineWidth ( item ) ) ; EdgeItem e = ( EdgeItem ) item ; boolean forward = ( m_edgeArrow == Constants . EDGE_ARROW_FORWARD ) ; Point2D start = null , end = null ; start = m_tmpPoints [ forward ? 0 : 1 ] ; end = m_tmpPoints [ forward ? 1 : 0 ] ; if ( ! full ) { double midX ; double midY ; Point2D sp = start , ep = end ; VisualItem dest = forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; int i = GraphicsLib . intersectLineRectangle ( start , end , dest . getBounds ( ) , m_isctPoints ) ; if ( i > 0 ) ep = m_isctPoints [ 0 ] ; VisualItem src = ! forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; i = GraphicsLib . intersectLineRectangle ( start , end , src . getBounds ( ) , m_isctPoints2 ) ; if ( i > 0 ) sp = m_isctPoints2 [ 0 ] ; midX = ( sp . getX ( ) + ep . getX ( ) ) / 2 ; midY = ( sp . getY ( ) + ep . getY ( ) ) / 2 ; m_tmpPoints [ reversed ? 1 : 0 ] . setLocation ( midX , midY ) ; } if ( e . isDirected ( ) && m_edgeArrow != Constants . EDGE_ARROW_NONE ) { if ( type == Constants . EDGE_TYPE_CURVE ) { AffineTransform t = new AffineTransform ( ) ; t . setToRotation ( Math . PI / 4 * ( reversedCurve ? 1 : - 1 ) ) ; Point2D p = new Point2D . Double ( ) , shift = new Point2D . Double ( ) ; double d = start . distance ( end ) / 5.0 ; p . setLocation ( ( end . getX ( ) - start . getX ( ) ) / d , ( end . getY ( ) - start . getY ( ) ) / d ) ; t . transform ( p , shift ) ; start . setLocation ( start . getX ( ) + shift . getX ( ) , start . getY ( ) + shift . getY ( ) ) ; end . setLocation ( end . getX ( ) + shift . getX ( ) , end . getY ( ) + shift . getY ( ) ) ; } VisualItem dest = forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; int i = GraphicsLib . intersectLineRectangle ( start , end , dest . getBounds ( ) , m_isctPoints ) ; if ( i > 0 ) end = m_isctPoints [ 0 ] ; AffineTransform at = getArrowTrans ( start , end , m_curWidth ) ; m_curArrow = at . createTransformedShape ( m_arrowHead ) ; if ( type == Constants . EDGE_TYPE_CURVE ) { if ( ! " XML " . equals ( association . getDataModel ( ) . getExportModus ( ) ) || ! isAggregation ( association ) ) { m_curArrow = null ; } } Point2D lineEnd = m_tmpPoints [ forward ? 1 : 0 ] ; lineEnd . setLocation ( 0 , type == Constants . EDGE_TYPE_CURVE ? 0 : - m_arrowHeight ) ; at . transform ( lineEnd , lineEnd ) ; } else { m_curArrow = null ; } Shape shape = null ; double n1x = m_tmpPoints [ 0 ] . getX ( ) ; double n1y = m_tmpPoints [ 0 ] . getY ( ) ; double n2x = m_tmpPoints [ 1 ] . getX ( ) ; double n2y = m_tmpPoints [ 1 ] . getY ( ) ; m_line . setLine ( n1x , n1y , n2x , n2y ) ; shape = m_line ; starBounds = null ; starPosition = null ; if ( ! forward && ( Cardinality . MANY_TO_MANY . equals ( association . getCardinality ( ) ) || Cardinality . MANY_TO_ONE . equals ( association . getCardinality ( ) ) ) || forward && ( Cardinality . MANY_TO_MANY . equals ( association . getCardinality ( ) ) || Cardinality . ONE_TO_MANY . equals ( association . getCardinality ( ) ) ) ) { starPosition = m_tmpPoints [ forward ? 1 : 0 ] ; start = starPosition ; end = m_tmpPoints [ forward ? 0 : 1 ] ; AffineTransform t = new AffineTransform ( ) ; t . setToRotation ( - Math . PI / 3 ) ; Point2D p = new Point2D . Double ( ) , shift = new Point2D . Double ( ) ; double d = m_tmpPoints [ 0 ] . distance ( m_tmpPoints [ 1 ] ) / 9.0 ; p . setLocation ( ( end . getX ( ) - start . getX ( ) ) / d , ( end . getY ( ) - start . getY ( ) ) / d ) ; t . transform ( p , shift ) ; starPosition . setLocation ( starPosition . getX ( ) + shift . getX ( ) , starPosition . getY ( ) + shift . getY ( ) ) ; starBounds = new Rectangle2D . Double ( starPosition . getX ( ) - STAR_SIZE * ( starWidth / 2 ) , starPosition . getY ( ) - STAR_SIZE * ( starHeight / 2 ) , starWidth * STAR_SIZE , starHeight * STAR_SIZE ) ; } return shape ; }
Recombine/jailer | protected AffineTransform getArrowTrans ( Point2D p1 , Point2D p2 , double width ) { m_arrowTrans . setToTranslation ( p2 . getX ( ) , p2 . getY ( ) ) ; m_arrowTrans . rotate ( - HALF_PI + Math . atan2 ( p2 . getY ( ) - p1 . getY ( ) , p2 . getX ( ) - p1 . getX ( ) ) ) ; if ( width > 1 ) { double scalar = width / 2 ; m_arrowTrans . scale ( scalar , scalar ) ; } return m_arrowTrans ; }
Recombine/jailer | public void render ( Graphics2D g , VisualItem item , boolean isSelected ) { Association association = ( Association ) item . get ( " association " ) ; item . setSize ( isSelected ? 3 : 1 ) ; int color ; if ( ! Boolean . TRUE . equals ( item . get ( " full " ) ) ) { if ( ! full ) { return ; } color = associationColor ( association ) ; } else { if ( full ) { return ; } color = reversed ? associationColor ( association . reversalAssociation ) : associationColor ( association ) ; } item . setFillColor ( color ) ; item . setStrokeColor ( color ) ; BasicStroke stroke = item . getStroke ( ) ; if ( stroke != null ) { if ( reversed ) { if ( association != null ) { association = association . reversalAssociation ; } } if ( association != null && association . isRestricted ( ) && ! association . isIgnored ( ) ) { item . setStroke ( new BasicStroke ( stroke . getLineWidth ( ) , stroke . getEndCap ( ) , stroke . getLineJoin ( ) , stroke . getMiterLimit ( ) , new float [ ] { 8f , 6f } , 1.0f ) ) ; } else { item . setStroke ( new BasicStroke ( stroke . getLineWidth ( ) , stroke . getEndCap ( ) , stroke . getLineJoin ( ) , stroke . getMiterLimit ( ) ) ) ; } } if ( " XML " . equals ( association . getDataModel ( ) . getExportModus ( ) ) ) { m_arrowHead = updateArrowHead ( m_arrowWidth , m_arrowHeight , association , isSelected ) ; arrowIsPotAggregation = true ; } else { if ( arrowIsPotAggregation ) { m_arrowHead = updateArrowHead ( m_arrowWidth , m_arrowHeight ) ; } arrowIsPotAggregation = false ; } starPosition = null ; render ( g , item ) ; if ( starPosition != null && starImage != null ) { double size = STAR_SIZE ; transform . setTransform ( size , 0 , 0 , size , starPosition . getX ( ) - size * ( starWidth / 2 ) , starPosition . getY ( ) - size * ( starHeight / 2 ) ) ; g . drawImage ( starImage , transform , null ) ; starPosition = null ; } }
Recombine/jailer | public void setBounds ( VisualItem item ) { super . setBounds ( item ) ; if ( starBounds != null ) { Rectangle2D bbox = ( Rectangle2D ) item . get ( VisualItem . BOUNDS ) ; Rectangle2D . union ( bbox , starBounds , bbox ) ; } }
Recombine/jailer | private int associationColor ( Association association ) { if ( association . isIgnored ( ) ) { return COLOR_IGNORED . getRGB ( ) ; } if ( association . isInsertDestinationBeforeSource ( ) ) { return COLOR_DEPENDENCY . getRGB ( ) ; } if ( association . isInsertSourceBeforeDestination ( ) ) { return COLOR_REVERSE_DEPENDENCY . getRGB ( ) ; } return COLOR_ASSOCIATION . getRGB ( ) ; }
Recombine/jailer | @ Override public boolean locatePoint ( Point2D p , VisualItem item ) { Shape s = getShape ( item ) ; if ( s == null ) { return false ; } else { double width = Math . max ( 14 , getLineWidth ( item ) ) ; double halfWidth = width / 2.0 ; return s . intersects ( p . getX ( ) - halfWidth , p . getY ( ) - halfWidth , width , width ) ; } }
Recombine/jailer | protected Polygon updateArrowHead ( int w , int h , Association association , boolean isSelected ) { if ( isAggregation ( association ) ) { if ( m_arrowHead == null ) { m_arrowHead = new Polygon ( ) ; } else { m_arrowHead . reset ( ) ; } double ws = 0.9 ; double hs = 2.0 / 3.0 ; if ( isSelected ) { ws /= 1.3 ; hs /= 1.3 ; } m_arrowHead . addPoint ( 0 , 0 ) ; m_arrowHead . addPoint ( ( int ) ( ws * - w ) , ( int ) ( hs * ( - h ) ) ) ; m_arrowHead . addPoint ( 0 , ( int ) ( hs * ( - 2 * h ) ) ) ; m_arrowHead . addPoint ( ( int ) ( ws * w ) , ( int ) ( hs * ( - h ) ) ) ; m_arrowHead . addPoint ( 0 , 0 ) ; return m_arrowHead ; } else { return updateArrowHead ( w , h ) ; } }
Recombine/jailer | private boolean isAggregation ( Association association ) { return association . reversalAssociation . getAggregationSchema ( ) != AggregationSchema . NONE ; }
Recombine/jailer | catch ( Exception e ) { e . printStackTrace ( ) ; }
apache/tomcat | public ProgressNotifier ( final ProgressListener pListener , final long pContentLength ) { listener = pListener ; contentLength = pContentLength ; }
apache/tomcat | void noteBytesRead ( final int pBytes ) { bytesRead += pBytes ; notifyListener ( ) ; }
apache/tomcat | public void noteItem ( ) { ++ items ; notifyListener ( ) ; }
apache/tomcat | private void notifyListener ( ) { if ( listener != null ) { listener . update ( bytesRead , contentLength , items ) ; } }
apache/tomcat | public MultipartStream ( final InputStream input , final byte [ ] boundary , final int bufSize , final ProgressNotifier pNotifier ) { if ( boundary == null ) { throw new IllegalArgumentException ( " boundary ▁ may ▁ not ▁ be ▁ null " ) ; } this . boundaryLength = boundary . length + BOUNDARY_PREFIX . length ; if ( bufSize < this . boundaryLength + 1 ) { throw new IllegalArgumentException ( " The ▁ buffer ▁ size ▁ specified ▁ for ▁ the ▁ MultipartStream ▁ is ▁ too ▁ small " ) ; } this . input = input ; this . bufSize = Math . max ( bufSize , boundaryLength * 2 ) ; this . buffer = new byte [ this . bufSize ] ; this . notifier = pNotifier ; this . boundary = new byte [ this . boundaryLength ] ; this . boundaryTable = new int [ this . boundaryLength + 1 ] ; this . keepRegion = this . boundary . length ; System . arraycopy ( BOUNDARY_PREFIX , 0 , this . boundary , 0 , BOUNDARY_PREFIX . length ) ; System . arraycopy ( boundary , 0 , this . boundary , BOUNDARY_PREFIX . length , boundary . length ) ; computeBoundaryTable ( ) ; head = 0 ; tail = 0 ; }
apache/tomcat | public MultipartStream ( final InputStream input , final byte [ ] boundary , final ProgressNotifier pNotifier ) { this ( input , boundary , DEFAULT_BUFSIZE , pNotifier ) ; }
apache/tomcat | public String getHeaderEncoding ( ) { return headerEncoding ; }
apache/tomcat | public void setHeaderEncoding ( final String encoding ) { headerEncoding = encoding ; }
apache/tomcat | public byte readByte ( ) throws IOException { if ( head == tail ) { head = 0 ; tail = input . read ( buffer , head , bufSize ) ; if ( tail == - 1 ) { throw new IOException ( " No ▁ more ▁ data ▁ is ▁ available " ) ; } if ( notifier != null ) { notifier . noteBytesRead ( tail ) ; } } return buffer [ head ++ ] ; }
apache/tomcat | if ( marker [ 0 ] == LF ) { return true ; }
apache/tomcat | if ( arrayequals ( marker , STREAM_TERMINATOR , 2 ) ) { nextChunk = false ; }
apache/tomcat | else if ( arrayequals ( marker , FIELD_SEPARATOR , 2 ) ) { nextChunk = true ; }
apache/tomcat | catch ( final FileUploadIOException e ) { throw e ; }
apache/tomcat | catch ( final IOException e ) { throw new MalformedStreamException ( " Stream ▁ ended ▁ unexpectedly " ) ; }
apache/tomcat | public void setBoundary ( final byte [ ] boundary ) throws IllegalBoundaryException { if ( boundary . length != boundaryLength - BOUNDARY_PREFIX . length ) { throw new IllegalBoundaryException ( " The ▁ length ▁ of ▁ a ▁ boundary ▁ token ▁ cannot ▁ be ▁ changed " ) ; } System . arraycopy ( boundary , 0 , this . boundary , BOUNDARY_PREFIX . length , boundary . length ) ; computeBoundaryTable ( ) ; }
apache/tomcat | private void computeBoundaryTable ( ) { int position = 2 ; int candidate = 0 ; boundaryTable [ 0 ] = - 1 ; boundaryTable [ 1 ] = 0 ; while ( position <= boundaryLength ) { if ( boundary [ position - 1 ] == boundary [ candidate ] ) { boundaryTable [ position ] = candidate + 1 ; candidate ++ ; position ++ ; } else if ( candidate > 0 ) { candidate = boundaryTable [ candidate ] ; } else { boundaryTable [ position ] = 0 ; position ++ ; } } }
apache/tomcat | while ( i < HEADER_SEPARATOR . length ) { try { b = readByte ( ) ; } catch ( final FileUploadIOException e ) { throw e ; } catch ( final IOException e ) { throw new MalformedStreamException ( " Stream ▁ ended ▁ unexpectedly " ) ; } if ( ++ size > HEADER_PART_SIZE_MAX ) { throw new MalformedStreamException ( String . format ( " Header ▁ section ▁ has ▁ more ▁ than ▁ % s ▁ bytes ▁ ( maybe ▁ it ▁ is ▁ not ▁ properly ▁ terminated ) " , Integer . valueOf ( HEADER_PART_SIZE_MAX ) ) ) ; } if ( b == HEADER_SEPARATOR [ i ] ) { i ++ ; } else { i = 0 ; } baos . write ( b ) ; }
apache/tomcat | if ( headerEncoding != null ) { try { headers = baos . toString ( headerEncoding ) ; } catch ( final UnsupportedEncodingException e ) { headers = baos . toString ( ) ; } }
apache/tomcat | public ItemInputStream newInputStream ( ) { return new ItemInputStream ( ) ; }
apache/tomcat | public boolean skipPreamble ( ) throws IOException { System . arraycopy ( boundary , 2 , boundary , 0 , boundary . length - 2 ) ; boundaryLength = boundary . length - 2 ; computeBoundaryTable ( ) ; try { discardBodyData ( ) ; return readBoundary ( ) ; } catch ( final MalformedStreamException e ) { return false ; } finally { System . arraycopy ( boundary , 0 , boundary , 2 , boundary . length - 2 ) ; boundaryLength = boundary . length ; boundary [ 0 ] = CR ; boundary [ 1 ] = LF ; computeBoundaryTable ( ) ; } }
apache/tomcat | protected int findByte ( final byte value , final int pos ) { for ( int i = pos ; i < tail ; i ++ ) { if ( buffer [ i ] == value ) { return i ; } } return - 1 ; }
apache/tomcat | protected int findSeparator ( ) { int bufferPos = this . head ; int tablePos = 0 ; while ( bufferPos < this . tail ) { while ( tablePos >= 0 && buffer [ bufferPos ] != boundary [ tablePos ] ) { tablePos = boundaryTable [ tablePos ] ; } bufferPos ++ ; tablePos ++ ; if ( tablePos == boundaryLength ) { return bufferPos - boundaryLength ; } } return - 1 ; }
apache/tomcat | public MalformedStreamException ( ) { }
apache/tomcat | public MalformedStreamException ( final String message ) { super ( message ) ; }
apache/tomcat | public IllegalBoundaryException ( ) { }
apache/tomcat | public IllegalBoundaryException ( final String message ) { super ( message ) ; }
apache/tomcat | ItemInputStream ( ) { findSeparator ( ) ; }
apache/tomcat | private void findSeparator ( ) { pos = MultipartStream . this . findSeparator ( ) ; if ( pos == - 1 ) { if ( tail - head > keepRegion ) { pad = keepRegion ; } else { pad = tail - head ; } } }
apache/tomcat | public long getBytesRead ( ) { return total ; }
apache/tomcat | @ Override public int available ( ) throws IOException { if ( pos == - 1 ) { return tail - head - pad ; } return pos - head ; }
apache/tomcat | @ Override public int read ( ) throws IOException { if ( closed ) { throw new FileItemStream . ItemSkippedException ( ) ; } if ( available ( ) == 0 && makeAvailable ( ) == 0 ) { return - 1 ; } ++ total ; final int b = buffer [ head ++ ] ; if ( b >= 0 ) { return b ; } return b + BYTE_POSITIVE_OFFSET ; }
apache/tomcat | @ Override public int read ( final byte [ ] b , final int off , final int len ) throws IOException { if ( closed ) { throw new FileItemStream . ItemSkippedException ( ) ; } if ( len == 0 ) { return 0 ; } int res = available ( ) ; if ( res == 0 ) { res = makeAvailable ( ) ; if ( res == 0 ) { return - 1 ; } } res = Math . min ( res , len ) ; System . arraycopy ( buffer , head , b , off , res ) ; head += res ; total += res ; return res ; }
apache/tomcat | @ Override public void close ( ) throws IOException { close ( false ) ; }
apache/tomcat | public void close ( final boolean pCloseUnderlying ) throws IOException { if ( closed ) { return ; } if ( pCloseUnderlying ) { closed = true ; input . close ( ) ; } else { for ( ; ; ) { int av = available ( ) ; if ( av == 0 ) { av = makeAvailable ( ) ; if ( av == 0 ) { break ; } } skip ( av ) ; } } closed = true ; }
apache/tomcat | @ Override public long skip ( final long bytes ) throws IOException { if ( closed ) { throw new FileItemStream . ItemSkippedException ( ) ; } int av = available ( ) ; if ( av == 0 ) { av = makeAvailable ( ) ; if ( av == 0 ) { return 0 ; } } final long res = Math . min ( av , bytes ) ; head += res ; return res ; }
apache/tomcat | private int makeAvailable ( ) throws IOException { if ( pos != - 1 ) { return 0 ; } total += tail - head - pad ; System . arraycopy ( buffer , tail - pad , buffer , 0 , pad ) ; head = 0 ; tail = pad ; for ( ; ; ) { final int bytesRead = input . read ( buffer , tail , bufSize - tail ) ; if ( bytesRead == - 1 ) { final String msg = " Stream ▁ ended ▁ unexpectedly " ; throw new MalformedStreamException ( msg ) ; } if ( notifier != null ) { notifier . noteBytesRead ( bytesRead ) ; } tail += bytesRead ; findSeparator ( ) ; final int av = available ( ) ; if ( av > 0 || pos != - 1 ) { return av ; } } }
apache/tomcat | @ Override public boolean isClosed ( ) { return closed ; }
anicloud/ani-cas | public CasAccountAttributeDao ( ) { }
anicloud/ani-cas | public CasAccountAttributeDao ( DataSource dataSource ) { this . dataSource = dataSource ; }
anicloud/ani-cas | public DataSource getDataSource ( ) { return dataSource ; }
anicloud/ani-cas | public void setDataSource ( DataSource dataSource ) { this . dataSource = dataSource ; }
anicloud/ani-cas | public String getEmailFieldName ( ) { return emailFieldName ; }
anicloud/ani-cas | public void setEmailFieldName ( String emailFieldName ) { this . emailFieldName = emailFieldName ; }
anicloud/ani-cas | public String getScreenFieldName ( ) { return screenFieldName ; }
anicloud/ani-cas | public void setScreenFieldName ( String screenFieldName ) { this . screenFieldName = screenFieldName ; }
anicloud/ani-cas | public String getAccountTableName ( ) { return accountTableName ; }
anicloud/ani-cas | public void setAccountTableName ( String accountTableName ) { this . accountTableName = accountTableName ; }
anicloud/ani-cas | public String getAccountPhoneTableName ( ) { return accountPhoneTableName ; }
anicloud/ani-cas | public void setAccountPhoneTableName ( String accountPhoneTableName ) { this . accountPhoneTableName = accountPhoneTableName ; }
anicloud/ani-cas | public String getPhoneFieldName ( ) { return phoneFieldName ; }
anicloud/ani-cas | public void setPhoneFieldName ( String phoneFieldName ) { this . phoneFieldName = phoneFieldName ; }
anicloud/ani-cas | @ Override public IPersonAttributes getPerson ( String uid ) { String sql = " " ; if ( uid . indexOf ( " @ " ) > 0 ) { sql = " ▁ select ▁ * ▁ from ▁ " + accountTableName + " ▁ where ▁ " + emailFieldName + " = ? " ; } else { sql = " ▁ select ▁ * ▁ from ▁ " + accountPhoneTableName + " ▁ where ▁ " + phoneFieldName + " = ? " ; } final Map < String , Object > values = new JdbcTemplate ( dataSource ) . queryForMap ( sql , uid ) ; Map < String , List < Object > > attributes = new HashMap < String , List < Object > > ( ) ; attributes . put ( " phoneNumber " , Collections . singletonList ( ( Object ) values . get ( " phoneNumber " ) ) ) ; attributes . put ( " email " , Collections . singletonList ( ( Object ) values . get ( " email " ) ) ) ; attributes . put ( " accountId " , Collections . singletonList ( ( Object ) values . get ( " accountId " ) ) ) ; attributes . put ( " id " , Collections . singletonList ( ( Object ) values . get ( " Id " ) ) ) ; return new AttributeNamedPersonImpl ( attributes ) ; }
rekhajoshm/pig | public MRCompiler ( PhysicalPlan plan ) throws MRCompilerException { this ( plan , null ) ; }
rekhajoshm/pig | public MRCompiler ( PhysicalPlan plan , PigContext pigContext ) throws MRCompilerException { super ( plan , new DepthFirstWalker < PhysicalOperator , PhysicalPlan > ( plan ) ) ; this . plan = plan ; this . pigContext = pigContext ; splitsSeen = new HashMap < OperatorKey , MapReduceOper > ( ) ; MRPlan = new MROperPlan ( ) ; nig = NodeIdGenerator . getGenerator ( ) ; r = new Random ( 1331 ) ; FileLocalizer . setR ( r ) ; udfFinder = new UDFFinder ( ) ; List < PhysicalOperator > roots = plan . getRoots ( ) ; if ( ( roots == null ) || ( roots . size ( ) <= 0 ) ) { int errCode = 2053 ; String msg = " Internal ▁ error . ▁ Did ▁ not ▁ find ▁ roots ▁ in ▁ the ▁ physical ▁ plan . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } scope = roots . get ( 0 ) . getOperatorKey ( ) . getScope ( ) ; messageCollector = new CompilationMessageCollector ( ) ; phyToMROpMap = new HashMap < PhysicalOperator , MapReduceOper > ( ) ; fileConcatenationThreshold = Integer . parseInt ( pigContext . getProperties ( ) . getProperty ( FILE_CONCATENATION_THRESHOLD , "100" ) ) ; optimisticFileConcatenation = pigContext . getProperties ( ) . getProperty ( OPTIMISTIC_FILE_CONCATENATION , " false " ) . equals ( " true " ) ; LOG . info ( " File ▁ concatenation ▁ threshold : ▁ " + fileConcatenationThreshold + " ▁ optimistic ? ▁ " + optimisticFileConcatenation ) ; }
rekhajoshm/pig | for ( MapReduceOper mrOp : MRPlan ) { mrOpList . add ( mrOp ) ; }
rekhajoshm/pig | for ( MapReduceOper mrOp : mrOpList ) { for ( PhysicalOperator scalar : mrOp . scalars ) { MapReduceOper mro = phyToMROpMap . get ( scalar ) ; if ( scalar instanceof POStore ) { FileSpec oldSpec = ( ( POStore ) scalar ) . getSFile ( ) ; MapReduceOper mro2 = seen . get ( oldSpec ) ; boolean hasSeen = false ; if ( mro2 != null ) { hasSeen = true ; mro = mro2 ; } if ( ! hasSeen && combinable && ( mro . reducePlan . isEmpty ( ) ? hasTooManyInputFiles ( mro , conf ) : ( mro . requestedParallelism >= fileConcatenationThreshold ) ) ) { PhysicalPlan pl = mro . reducePlan . isEmpty ( ) ? mro . mapPlan : mro . reducePlan ; FileSpec newSpec = getTempFileSpec ( ) ; new FindStoreNameVisitor ( pl , newSpec , oldSpec ) . visit ( ) ; POStore newSto = getStore ( ) ; newSto . setSFile ( oldSpec ) ; if ( MRPlan . getPredecessors ( mrOp ) != null && MRPlan . getPredecessors ( mrOp ) . contains ( mro ) ) MRPlan . disconnect ( mro , mrOp ) ; MapReduceOper catMROp = getConcatenateJob ( newSpec , mro , newSto ) ; MRPlan . connect ( catMROp , mrOp ) ; seen . put ( oldSpec , catMROp ) ; } else { if ( ! hasSeen ) seen . put ( oldSpec , mro ) ; } } } }
rekhajoshm/pig | public void randomizeFileLocalizer ( ) { FileLocalizer . setR ( new Random ( ) ) ; }
rekhajoshm/pig | public MROperPlan getMRPlan ( ) { return MRPlan ; }
rekhajoshm/pig | @ Override public PhysicalPlan getPlan ( ) { return plan ; }
rekhajoshm/pig | public CompilationMessageCollector getMessageCollector ( ) { return messageCollector ; }
rekhajoshm/pig | if ( ! pigContext . inIllustrator ) for ( PhysicalOperator op : leaves ) { if ( ! ( op instanceof POStore ) ) { int errCode = 2025 ; String msg = " Expected ▁ leaf ▁ of ▁ reduce ▁ plan ▁ to ▁ " + " always ▁ be ▁ POStore . ▁ Found ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } }
rekhajoshm/pig | if ( ! pigContext . inIllustrator ) { ops = new ArrayList < PhysicalOperator > ( stores . size ( ) + nativeMRs . size ( ) ) ; ops . addAll ( stores ) ; }
rekhajoshm/pig | for ( PhysicalOperator op : ops ) { compile ( op ) ; }
rekhajoshm/pig | for ( PhysicalOperator op : plan ) { if ( plan . getSoftLinkPredecessors ( op ) != null ) { for ( PhysicalOperator pred : plan . getSoftLinkPredecessors ( op ) ) { MapReduceOper from = phyToMROpMap . get ( pred ) ; MapReduceOper to = phyToMROpMap . get ( op ) ; if ( from == to ) continue ; if ( MRPlan . getPredecessors ( to ) == null || ! MRPlan . getPredecessors ( to ) . contains ( from ) ) { MRPlan . connect ( from , to ) ; } } } }
rekhajoshm/pig | if ( op instanceof PONative ) { }
rekhajoshm/pig | else if ( predecessors != null && predecessors . size ( ) > 0 ) { if ( op instanceof POLoad ) { if ( predecessors . size ( ) != 1 ) { int errCode = 2125 ; String msg = " Expected ▁ at ▁ most ▁ one ▁ predecessor ▁ of ▁ load . ▁ Got ▁ " + predecessors . size ( ) ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } PhysicalOperator p = predecessors . get ( 0 ) ; MapReduceOper oper = null ; if ( p instanceof POStore || p instanceof PONative ) { oper = phyToMROpMap . get ( p ) ; } else { int errCode = 2126 ; String msg = " Predecessor ▁ of ▁ load ▁ should ▁ be ▁ a ▁ store ▁ or ▁ mapreduce ▁ operator . ▁ Got ▁ " + p . getClass ( ) ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } curMROp = getMROp ( ) ; curMROp . mapPlan . add ( op ) ; MRPlan . add ( curMROp ) ; plan . disconnect ( op , p ) ; MRPlan . connect ( oper , curMROp ) ; phyToMROpMap . put ( op , curMROp ) ; return ; } Collections . sort ( predecessors ) ; compiledInputs = new MapReduceOper [ predecessors . size ( ) ] ; int i = - 1 ; for ( PhysicalOperator pred : predecessors ) { if ( pred instanceof POSplit && splitsSeen . containsKey ( pred . getOperatorKey ( ) ) ) { compiledInputs [ ++ i ] = startNew ( ( ( POSplit ) pred ) . getSplitStore ( ) , splitsSeen . get ( pred . getOperatorKey ( ) ) ) ; continue ; } compile ( pred ) ; compiledInputs [ ++ i ] = curMROp ; } }
rekhajoshm/pig | if ( op != null && op instanceof POLoad ) { if ( ( ( POLoad ) op ) . getLFile ( ) != null && ( ( POLoad ) op ) . getLFile ( ) . getFuncSpec ( ) != null ) curMROp . UDFs . add ( ( ( POLoad ) op ) . getLFile ( ) . getFuncSpec ( ) . toString ( ) ) ; }
rekhajoshm/pig | if ( op . getRequestedParallelism ( ) > curMROp . requestedParallelism ) { if ( ! curMROp . isSkewedJoin ( ) ) { curMROp . requestedParallelism = op . getRequestedParallelism ( ) ; } }
rekhajoshm/pig | private MapReduceOper getMROp ( ) { return new MapReduceOper ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; }
rekhajoshm/pig | private NativeMapReduceOper getNativeMROp ( String mrJar , String [ ] parameters ) { return new NativeMapReduceOper ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , mrJar , parameters ) ; }
rekhajoshm/pig | private POLoad getLoad ( ) { POLoad ld = new POLoad ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; ld . setPc ( pigContext ) ; ld . setIsTmpLoad ( true ) ; return ld ; }
rekhajoshm/pig | private POStore getStore ( ) { POStore st = new POStore ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; st . setIsTmpStore ( true ) ; return st ; }
rekhajoshm/pig | if ( compiledInputs . length == 1 ) { MapReduceOper mro = compiledInputs [ 0 ] ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( op ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( op ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } curMROp = mro ; }
rekhajoshm/pig | if ( compiledInputs . length == 1 ) { MapReduceOper mro = compiledInputs [ 0 ] ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( op ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { FileSpec fSpec = getTempFileSpec ( ) ; POStore st = getStore ( ) ; st . setSFile ( fSpec ) ; mro . reducePlan . addAsLeaf ( st ) ; mro . setReduceDone ( true ) ; mro = startNew ( fSpec , mro ) ; mro . mapPlan . addAsLeaf ( op ) ; compiledInputs [ 0 ] = mro ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } curMROp = mro ; }
rekhajoshm/pig | if ( compiledInputs . length == 1 ) { MapReduceOper mro = compiledInputs [ 0 ] ; if ( ! mro . isMapDone ( ) ) { mro . setMapDoneSingle ( true ) ; curMROp = mro ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { FileSpec fSpec = getTempFileSpec ( ) ; POStore st = getStore ( ) ; st . setSFile ( fSpec ) ; mro . reducePlan . addAsLeaf ( st ) ; mro . setReduceDone ( true ) ; curMROp = startNew ( fSpec , mro ) ; curMROp . setMapDone ( true ) ; } }
rekhajoshm/pig | for ( MapReduceOper mmro : mergedPlans ) { mmro . setReduceDone ( true ) ; FileSpec fileSpec = getTempFileSpec ( ) ; POLoad ld = getLoad ( ) ; ld . setLFile ( fileSpec ) ; POStore str = getStore ( ) ; str . setSFile ( fileSpec ) ; mmro . reducePlan . addAsLeaf ( str ) ; mro . mapPlan . add ( ld ) ; if ( leaf != null ) mro . mapPlan . connect ( ld , leaf ) ; MRPlan . connect ( mmro , mro ) ; }
rekhajoshm/pig | private MapReduceOper endSingleInputPlanWithStr ( FileSpec fSpec ) throws PlanException { if ( compiledInputs . length > 1 ) { int errCode = 2023 ; String msg = " Received ▁ a ▁ multi ▁ input ▁ plan ▁ when ▁ expecting ▁ only ▁ a ▁ single ▁ input ▁ one . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } MapReduceOper mro = compiledInputs [ 0 ] ; POStore str = getStore ( ) ; str . setSFile ( fSpec ) ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( str ) ; mro . setMapDoneSingle ( true ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( str ) ; mro . setReduceDone ( true ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } return mro ; }
rekhajoshm/pig | private MapReduceOper startNew ( FileSpec fSpec , MapReduceOper old ) throws PlanException { POLoad ld = getLoad ( ) ; ld . setLFile ( fSpec ) ; MapReduceOper ret = getMROp ( ) ; ret . mapPlan . add ( ld ) ; MRPlan . add ( ret ) ; MRPlan . connect ( old , ret ) ; return ret ; }
rekhajoshm/pig | private FileSpec getTempFileSpec ( ) throws IOException { return new FileSpec ( FileLocalizer . getTemporaryPath ( pigContext ) . toString ( ) , new FuncSpec ( Utils . getTmpFileCompressorName ( pigContext ) ) ) ; }
rekhajoshm/pig | private List < MapReduceOper > merge ( MapReduceOper [ ] compiledInputs ) throws PlanException { List < MapReduceOper > ret = new ArrayList < MapReduceOper > ( ) ; MapReduceOper mergedMap = getMROp ( ) ; ret . add ( mergedMap ) ; MRPlan . add ( mergedMap ) ; Set < MapReduceOper > toBeConnected = new HashSet < MapReduceOper > ( ) ; List < MapReduceOper > remLst = new ArrayList < MapReduceOper > ( ) ; List < PhysicalPlan > mpLst = new ArrayList < PhysicalPlan > ( ) ; for ( MapReduceOper mro : compiledInputs ) { if ( ! mro . isMapDone ( ) ) { remLst . add ( mro ) ; mpLst . add ( mro . mapPlan ) ; List < MapReduceOper > pmros = MRPlan . getPredecessors ( mro ) ; if ( pmros != null ) { for ( MapReduceOper pmro : pmros ) toBeConnected . add ( pmro ) ; } } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { ret . add ( mro ) ; } else { int errCode = 2027 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ for ▁ a ▁ merge . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } } merge ( ret . get ( 0 ) . mapPlan , mpLst ) ; Iterator < MapReduceOper > it = toBeConnected . iterator ( ) ; while ( it . hasNext ( ) ) MRPlan . connect ( it . next ( ) , mergedMap ) ; for ( MapReduceOper rmro : remLst ) { if ( rmro . requestedParallelism > mergedMap . requestedParallelism ) mergedMap . requestedParallelism = rmro . requestedParallelism ; for ( String udf : rmro . UDFs ) { if ( ! mergedMap . UDFs . contains ( udf ) ) mergedMap . UDFs . add ( udf ) ; } for ( PhysicalOperator physOp : rmro . scalars ) { if ( ! mergedMap . scalars . contains ( physOp ) ) { mergedMap . scalars . add ( physOp ) ; } } Set < PhysicalOperator > opsToChange = new HashSet < PhysicalOperator > ( ) ; for ( Map . Entry < PhysicalOperator , MapReduceOper > entry : phyToMROpMap . entrySet ( ) ) { if ( entry . getValue ( ) == rmro ) { opsToChange . add ( entry . getKey ( ) ) ; } } for ( PhysicalOperator op : opsToChange ) { phyToMROpMap . put ( op , mergedMap ) ; } MRPlan . remove ( rmro ) ; } return ret ; }
rekhajoshm/pig | private < O extends Operator , E extends OperatorPlan < O > > void merge ( E finPlan , List < E > plans ) throws PlanException { for ( E e : plans ) { finPlan . merge ( e ) ; } }
rekhajoshm/pig | private void processUDFs ( PhysicalPlan plan ) throws VisitorException { if ( plan != null ) { ScalarPhyFinder scalarPhyFinder = new ScalarPhyFinder ( plan ) ; scalarPhyFinder . visit ( ) ; curMROp . scalars . addAll ( scalarPhyFinder . getScalars ( ) ) ; udfFinder . setPlan ( plan ) ; udfFinder . visit ( ) ; curMROp . UDFs . addAll ( udfFinder . getUDFs ( ) ) ; } }
rekhajoshm/pig | @ Override public void visitSplit ( POSplit op ) throws VisitorException { try { FileSpec fSpec = op . getSplitStore ( ) ; MapReduceOper mro = endSingleInputPlanWithStr ( fSpec ) ; mro . setSplitter ( true ) ; splitsSeen . put ( op . getOperatorKey ( ) , mro ) ; curMROp = startNew ( fSpec , mro ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitLoad ( POLoad op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitNative ( PONative op ) throws VisitorException { try { MapReduceOper nativeMROper = getNativeMROp ( op . getNativeMRjar ( ) , op . getParams ( ) ) ; MRPlan . add ( nativeMROper ) ; MRPlan . connect ( curMROp , nativeMROper ) ; phyToMROpMap . put ( op , nativeMROper ) ; curMROp = nativeMROper ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitStore ( POStore op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; if ( op . getSFile ( ) != null && op . getSFile ( ) . getFuncSpec ( ) != null ) curMROp . UDFs . add ( op . getSFile ( ) . getFuncSpec ( ) . toString ( ) ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitFilter ( POFilter op ) throws VisitorException { try { nonBlocking ( op ) ; processUDFs ( op . getPlan ( ) ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitCross ( POCross op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitStream ( POStream op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitLimit ( POLimit op ) throws VisitorException { try { MapReduceOper mro = compiledInputs [ 0 ] ; mro . limit = op . getLimit ( ) ; if ( op . getLimitPlan ( ) != null ) { processUDFs ( op . getLimitPlan ( ) ) ; mro . limitPlan = op . getLimitPlan ( ) ; } if ( ! mro . isMapDone ( ) ) { if ( ! pigContext . inIllustrator ) { mro . mapPlan . addAsLeaf ( op ) ; mro . setMapDone ( true ) ; } if ( mro . reducePlan . isEmpty ( ) ) { MRUtil . simpleConnectMapToReduce ( mro , scope , nig ) ; mro . requestedParallelism = 1 ; if ( ! pigContext . inIllustrator ) { POLimit pLimit2 = new POLimit ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pLimit2 . setLimit ( op . getLimit ( ) ) ; pLimit2 . setLimitPlan ( op . getLimitPlan ( ) ) ; mro . reducePlan . addAsLeaf ( pLimit2 ) ; } else { mro . reducePlan . addAsLeaf ( op ) ; } } else { messageCollector . collect ( " Something ▁ in ▁ the ▁ reduce ▁ plan ▁ while ▁ map ▁ plan ▁ is ▁ not ▁ done . ▁ Something ▁ wrong ! " , MessageType . Warning , PigWarning . REDUCE_PLAN_NOT_EMPTY_WHILE_MAP_PLAN_UNDER_PROCESS ) ; } } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( op ) ; } else { messageCollector . collect ( " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling ! " , MessageType . Warning , PigWarning . UNREACHABLE_CODE_BOTH_MAP_AND_REDUCE_PLANS_PROCESSED ) ; } phyToMROpMap . put ( op , mro ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitLocalRearrange ( POLocalRearrange op ) throws VisitorException { try { addToMap ( op ) ; List < PhysicalPlan > plans = op . getPlans ( ) ; if ( plans != null ) for ( PhysicalPlan ep : plans ) processUDFs ( ep ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitCollectedGroup ( POCollectedGroup op ) throws VisitorException { if ( ! curMROp . mapDone ) { List < PhysicalOperator > roots = curMROp . mapPlan . getRoots ( ) ; if ( roots . size ( ) != 1 ) { int errCode = 2171 ; String errMsg = " Expected ▁ one ▁ but ▁ found ▁ more ▁ then ▁ one ▁ root ▁ physical ▁ operator ▁ in ▁ physical ▁ plan . " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } PhysicalOperator phyOp = roots . get ( 0 ) ; if ( ! ( phyOp instanceof POLoad ) ) { int errCode = 2172 ; String errMsg = " Expected ▁ physical ▁ operator ▁ at ▁ root ▁ to ▁ be ▁ POLoad . ▁ Found ▁ : ▁ " + phyOp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } LoadFunc loadFunc = ( ( POLoad ) phyOp ) . getLoadFunc ( ) ; try { if ( ! ( CollectableLoadFunc . class . isAssignableFrom ( loadFunc . getClass ( ) ) ) ) { int errCode = 2249 ; throw new MRCompilerException ( " While ▁ using ▁ ' collected ' ▁ on ▁ group ; ▁ data ▁ must ▁ be ▁ loaded ▁ via ▁ loader ▁ implementing ▁ CollectableLoadFunc . " , errCode ) ; } ( ( CollectableLoadFunc ) loadFunc ) . ensureAllKeyInstancesInSameSplit ( ) ; } catch ( MRCompilerException e ) { throw ( e ) ; } catch ( IOException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } try { nonBlocking ( op ) ; List < PhysicalPlan > plans = op . getPlans ( ) ; if ( plans != null ) for ( PhysicalPlan ep : plans ) processUDFs ( ep ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } } else if ( ! curMROp . reduceDone ) { int errCode = 2250 ; String msg = " Blocking ▁ operators ▁ are ▁ not ▁ allowed ▁ before ▁ Collected ▁ Group . ▁ Consider ▁ dropping ▁ using ▁ ' collected ' . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } }
rekhajoshm/pig | @ Override public void visitPOForEach ( POForEach op ) throws VisitorException { try { nonBlocking ( op ) ; List < PhysicalPlan > plans = op . getInputPlans ( ) ; if ( plans != null ) for ( PhysicalPlan plan : plans ) { processUDFs ( plan ) ; } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitGlobalRearrange ( POGlobalRearrange op ) throws VisitorException { try { blocking ( op ) ; curMROp . customPartitioner = op . getCustomPartitioner ( ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitPackage ( POPackage op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; if ( op . getPackageType ( ) == PackageType . JOIN ) { curMROp . markRegularJoin ( ) ; } else if ( op . getPackageType ( ) == PackageType . GROUP ) { if ( op . getNumInps ( ) == 1 ) { curMROp . markGroupBy ( ) ; } else if ( op . getNumInps ( ) > 1 ) { curMROp . markCogroup ( ) ; } } } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitUnion ( POUnion op ) throws VisitorException { try { nonBlocking ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitFRJoin ( POFRJoin op ) throws VisitorException { try { FileSpec [ ] replFiles = new FileSpec [ op . getInputs ( ) . size ( ) ] ; for ( int i = 0 ; i < replFiles . length ; i ++ ) { if ( i == op . getFragment ( ) ) continue ; replFiles [ i ] = getTempFileSpec ( ) ; } op . setReplFiles ( replFiles ) ; curMROp = phyToMROpMap . get ( op . getInputs ( ) . get ( op . getFragment ( ) ) ) ; for ( int i = 0 ; i < compiledInputs . length ; i ++ ) { MapReduceOper mro = compiledInputs [ i ] ; if ( curMROp . equals ( mro ) ) continue ; POStore str = getStore ( ) ; str . setSFile ( replFiles [ i ] ) ; Configuration conf = ConfigurationUtil . toConfiguration ( pigContext . getProperties ( ) ) ; boolean combinable = ! conf . getBoolean ( " pig . noSplitCombination " , false ) ; if ( ! mro . isMapDone ( ) ) { if ( combinable && hasTooManyInputFiles ( mro , conf ) ) { POStore tmpSto = getStore ( ) ; FileSpec fSpec = getTempFileSpec ( ) ; tmpSto . setSFile ( fSpec ) ; mro . mapPlan . addAsLeaf ( tmpSto ) ; mro . setMapDoneSingle ( true ) ; MapReduceOper catMROp = getConcatenateJob ( fSpec , mro , str ) ; MRPlan . connect ( catMROp , curMROp ) ; } else { mro . mapPlan . addAsLeaf ( str ) ; mro . setMapDoneSingle ( true ) ; MRPlan . connect ( mro , curMROp ) ; } } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { if ( combinable && ( mro . requestedParallelism >= fileConcatenationThreshold ) ) { POStore tmpSto = getStore ( ) ; FileSpec fSpec = getTempFileSpec ( ) ; tmpSto . setSFile ( fSpec ) ; mro . reducePlan . addAsLeaf ( tmpSto ) ; mro . setReduceDone ( true ) ; MapReduceOper catMROp = getConcatenateJob ( fSpec , mro , str ) ; MRPlan . connect ( catMROp , curMROp ) ; } else { mro . reducePlan . addAsLeaf ( str ) ; mro . setReduceDone ( true ) ; MRPlan . connect ( mro , curMROp ) ; } } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } } if ( ! curMROp . isMapDone ( ) ) { curMROp . mapPlan . addAsLeaf ( op ) ; } else if ( curMROp . isMapDone ( ) && ! curMROp . isReduceDone ( ) ) { curMROp . reducePlan . addAsLeaf ( op ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } List < List < PhysicalPlan > > joinPlans = op . getJoinPlans ( ) ; if ( joinPlans != null ) for ( List < PhysicalPlan > joinPlan : joinPlans ) { if ( joinPlan != null ) for ( PhysicalPlan plan : joinPlan ) { processUDFs ( plan ) ; } } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | private boolean hasTooManyInputFiles ( MapReduceOper mro , Configuration conf ) { if ( pigContext == null || pigContext . getExecType ( ) == ExecType . LOCAL ) { return false ; } if ( mro instanceof NativeMapReduceOper ) { return optimisticFileConcatenation ? false : true ; } PhysicalPlan mapPlan = mro . mapPlan ; List < PhysicalOperator > roots = mapPlan . getRoots ( ) ; if ( roots == null || roots . size ( ) == 0 ) return false ; int numFiles = 0 ; boolean ret = false ; try { for ( PhysicalOperator root : roots ) { POLoad ld = ( POLoad ) root ; String fileName = ld . getLFile ( ) . getFileName ( ) ; if ( UriUtil . isHDFSFile ( fileName ) ) { String [ ] locations = LoadFunc . getPathStrings ( fileName ) ; for ( String location : locations ) { if ( ! UriUtil . isHDFSFile ( location ) ) continue ; Path path = new Path ( location ) ; FileSystem fs = path . getFileSystem ( conf ) ; if ( fs . exists ( path ) ) { LoadFunc loader = ( LoadFunc ) PigContext . instantiateFuncFromSpec ( ld . getLFile ( ) . getFuncSpec ( ) ) ; Job job = new Job ( conf ) ; loader . setUDFContextSignature ( ld . getSignature ( ) ) ; loader . setLocation ( location , job ) ; InputFormat inf = loader . getInputFormat ( ) ; List < InputSplit > splits = inf . getSplits ( HadoopShims . cloneJobContext ( job ) ) ; List < List < InputSplit > > results = MapRedUtil . getCombinePigSplits ( splits , HadoopShims . getDefaultBlockSize ( fs , path ) , conf ) ; numFiles += results . size ( ) ; } else { List < MapReduceOper > preds = MRPlan . getPredecessors ( mro ) ; if ( preds != null && preds . size ( ) == 1 ) { MapReduceOper pred = preds . get ( 0 ) ; if ( ! pred . reducePlan . isEmpty ( ) ) { numFiles += pred . requestedParallelism ; } else { ret = hasTooManyInputFiles ( pred , conf ) ; break ; } } else if ( ! optimisticFileConcatenation ) { numFiles = fileConcatenationThreshold ; break ; } } } } } } catch ( IOException e ) { LOG . warn ( " failed ▁ to ▁ get ▁ number ▁ of ▁ input ▁ files " , e ) ; } catch ( InterruptedException e ) { LOG . warn ( " failed ▁ to ▁ get ▁ number ▁ of ▁ input ▁ files " , e ) ; } LOG . info ( " number ▁ of ▁ input ▁ files : ▁ " + numFiles ) ; return ret ? true : ( numFiles >= fileConcatenationThreshold ) ; }
rekhajoshm/pig | @ Override public void visitMergeCoGroup ( POMergeCogroup poCoGrp ) throws VisitorException { if ( compiledInputs . length < 2 ) { int errCode = 2251 ; String errMsg = " Merge ▁ Cogroup ▁ work ▁ on ▁ two ▁ or ▁ more ▁ relations . " + " To ▁ use ▁ map - side ▁ group - by ▁ on ▁ single ▁ relation , ▁ use ▁ ' collected ' ▁ qualifier . " ; throw new MRCompilerException ( errMsg , errCode ) ; } List < FuncSpec > funcSpecs = new ArrayList < FuncSpec > ( compiledInputs . length - 1 ) ; List < String > fileSpecs = new ArrayList < String > ( compiledInputs . length - 1 ) ; List < String > loaderSigns = new ArrayList < String > ( compiledInputs . length - 1 ) ; try { for ( int i = 0 ; i < compiledInputs . length ; i ++ ) { MapReduceOper mrOper = compiledInputs [ i ] ; PhysicalPlan mapPlan = mrOper . mapPlan ; if ( mapPlan . getRoots ( ) . size ( ) != 1 ) { int errCode = 2171 ; String errMsg = " Expected ▁ one ▁ but ▁ found ▁ more ▁ then ▁ one ▁ root ▁ physical ▁ operator ▁ in ▁ physical ▁ plan . " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } PhysicalOperator rootPOOp = mapPlan . getRoots ( ) . get ( 0 ) ; if ( ! ( rootPOOp instanceof POLoad ) ) { int errCode = 2172 ; String errMsg = " Expected ▁ physical ▁ operator ▁ at ▁ root ▁ to ▁ be ▁ POLoad . ▁ Found ▁ : ▁ " + rootPOOp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( errMsg , errCode ) ; } POLoad sideLoader = ( POLoad ) rootPOOp ; FileSpec loadFileSpec = sideLoader . getLFile ( ) ; FuncSpec funcSpec = loadFileSpec . getFuncSpec ( ) ; LoadFunc loadfunc = sideLoader . getLoadFunc ( ) ; if ( i == 0 ) { if ( ! ( CollectableLoadFunc . class . isAssignableFrom ( loadfunc . getClass ( ) ) ) ) { int errCode = 2252 ; throw new MRCompilerException ( " Base ▁ loader ▁ in ▁ Cogroup ▁ must ▁ implement ▁ CollectableLoadFunc . " , errCode ) ; } ( ( CollectableLoadFunc ) loadfunc ) . ensureAllKeyInstancesInSameSplit ( ) ; continue ; } if ( ! ( IndexableLoadFunc . class . isAssignableFrom ( loadfunc . getClass ( ) ) ) ) { int errCode = 2253 ; throw new MRCompilerException ( " Side ▁ loaders ▁ in ▁ cogroup ▁ must ▁ implement ▁ IndexableLoadFunc . " , errCode ) ; } funcSpecs . add ( funcSpec ) ; fileSpecs . add ( loadFileSpec . getFileName ( ) ) ; loaderSigns . add ( sideLoader . getSignature ( ) ) ; MRPlan . remove ( mrOper ) ; } poCoGrp . setSideLoadFuncs ( funcSpecs ) ; poCoGrp . setSideFileSpecs ( fileSpecs ) ; poCoGrp . setLoaderSignatures ( loaderSigns ) ; MapReduceOper baseMROp = phyToMROpMap . get ( poCoGrp . getInputs ( ) . get ( 0 ) ) ; if ( baseMROp . mapDone || ! baseMROp . reducePlan . isEmpty ( ) ) { int errCode = 2254 ; throw new MRCompilerException ( " Currently ▁ merged ▁ cogroup ▁ is ▁ not ▁ supported ▁ after ▁ blocking ▁ operators . " , errCode ) ; } MapReduceOper indexerMROp = getMROp ( ) ; FileSpec idxFileSpec = getIndexingJob ( indexerMROp , baseMROp , poCoGrp . getLRInnerPlansOf ( 0 ) ) ; poCoGrp . setIdxFuncSpec ( idxFileSpec . getFuncSpec ( ) ) ; poCoGrp . setIndexFileName ( idxFileSpec . getFileName ( ) ) ; baseMROp . mapPlan . addAsLeaf ( poCoGrp ) ; for ( FuncSpec funcSpec : funcSpecs ) baseMROp . UDFs . add ( funcSpec . toString ( ) ) ; MRPlan . add ( indexerMROp ) ; MRPlan . connect ( indexerMROp , baseMROp ) ; phyToMROpMap . put ( poCoGrp , baseMROp ) ; curMROp = baseMROp ; } catch ( ExecException e ) { throw new MRCompilerException ( e . getDetailedMessage ( ) , e . getErrorCode ( ) , e . getErrorSource ( ) , e ) ; } catch ( MRCompilerException mrce ) { throw ( mrce ) ; } catch ( CloneNotSupportedException e ) { throw new MRCompilerException ( e ) ; } catch ( PlanException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + poCoGrp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } catch ( IOException e ) { int errCode = 3000 ; String errMsg = " IOException ▁ caught ▁ while ▁ compiling ▁ POMergeCoGroup " ; throw new MRCompilerException ( errMsg , errCode , e ) ; } }
rekhajoshm/pig | if ( ! ( OrderedLoadFunc . class . isAssignableFrom ( loadFunc . getClass ( ) ) ) ) { int errCode = 1104 ; String errMsg = " Base ▁ relation ▁ of ▁ merge - coGroup ▁ must ▁ implement ▁ " + " OrderedLoadFunc ▁ interface . ▁ The ▁ specified ▁ loader ▁ " + funcSpec + " ▁ doesn ' t ▁ implement ▁ it " ; throw new MRCompilerException ( errMsg , errCode ) ; }
rekhajoshm/pig | if ( baseMapPlan . getSuccessors ( baseLoader ) == null || baseMapPlan . getSuccessors ( baseLoader ) . isEmpty ( ) ) { phyPlan = null ; }
rekhajoshm/pig | @ Override public void visitMergeJoin ( POMergeJoin joinOp ) throws VisitorException { try { if ( compiledInputs . length != 2 || joinOp . getInputs ( ) . size ( ) != 2 ) { int errCode = 1101 ; throw new MRCompilerException ( " Merge ▁ Join ▁ must ▁ have ▁ exactly ▁ two ▁ inputs . ▁ Found ▁ : ▁ " + compiledInputs . length , errCode ) ; } curMROp = phyToMROpMap . get ( joinOp . getInputs ( ) . get ( 0 ) ) ; MapReduceOper rightMROpr = null ; if ( curMROp . equals ( compiledInputs [ 0 ] ) ) rightMROpr = compiledInputs [ 1 ] ; else rightMROpr = compiledInputs [ 0 ] ; PhysicalPlan rightPipelinePlan ; if ( ! rightMROpr . mapDone ) { PhysicalPlan rightMapPlan = rightMROpr . mapPlan ; if ( rightMapPlan . getRoots ( ) . size ( ) != 1 ) { int errCode = 2171 ; String errMsg = " Expected ▁ one ▁ but ▁ found ▁ more ▁ then ▁ one ▁ root ▁ physical ▁ operator ▁ in ▁ physical ▁ plan . " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG ) ; } PhysicalOperator rightLoader = rightMapPlan . getRoots ( ) . get ( 0 ) ; if ( ! ( rightLoader instanceof POLoad ) ) { int errCode = 2172 ; String errMsg = " Expected ▁ physical ▁ operator ▁ at ▁ root ▁ to ▁ be ▁ POLoad . ▁ Found ▁ : ▁ " + rightLoader . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( errMsg , errCode ) ; } if ( rightMapPlan . getSuccessors ( rightLoader ) == null || rightMapPlan . getSuccessors ( rightLoader ) . isEmpty ( ) ) rightPipelinePlan = null ; else { rightPipelinePlan = rightMapPlan . clone ( ) ; PhysicalOperator root = rightPipelinePlan . getRoots ( ) . get ( 0 ) ; rightPipelinePlan . disconnect ( root , rightPipelinePlan . getSuccessors ( root ) . get ( 0 ) ) ; rightPipelinePlan . remove ( root ) ; rightMapPlan . trimBelow ( rightLoader ) ; } } else if ( ! rightMROpr . reduceDone ) { POStore rightStore = getStore ( ) ; FileSpec rightStrFile = getTempFileSpec ( ) ; rightStore . setSFile ( rightStrFile ) ; rightMROpr . reducePlan . addAsLeaf ( rightStore ) ; rightMROpr . setReduceDone ( true ) ; rightMROpr = startNew ( rightStrFile , rightMROpr ) ; rightPipelinePlan = null ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } joinOp . setupRightPipeline ( rightPipelinePlan ) ; rightMROpr . requestedParallelism = 1 ; POLoad rightLoader = ( POLoad ) rightMROpr . mapPlan . getRoots ( ) . get ( 0 ) ; joinOp . setSignature ( rightLoader . getSignature ( ) ) ; LoadFunc rightLoadFunc = rightLoader . getLoadFunc ( ) ; List < String > udfs = new ArrayList < String > ( ) ; if ( IndexableLoadFunc . class . isAssignableFrom ( rightLoadFunc . getClass ( ) ) ) { joinOp . setRightLoaderFuncSpec ( rightLoader . getLFile ( ) . getFuncSpec ( ) ) ; joinOp . setRightInputFileName ( rightLoader . getLFile ( ) . getFileName ( ) ) ; udfs . add ( rightLoader . getLFile ( ) . getFuncSpec ( ) . toString ( ) ) ; MRPlan . remove ( rightMROpr ) ; if ( rightMROpr == compiledInputs [ 0 ] ) { compiledInputs [ 0 ] = null ; } else if ( rightMROpr == compiledInputs [ 1 ] ) { compiledInputs [ 1 ] = null ; } rightMROpr = null ; int numInputs = mPlan . getPredecessors ( joinOp ) . size ( ) ; for ( int i = 0 ; i < numInputs ; i ++ ) { List < PhysicalPlan > keyPlans = joinOp . getInnerPlansOf ( i ) ; for ( PhysicalPlan keyPlan : keyPlans ) { for ( PhysicalOperator op : keyPlan ) { if ( ! ( op instanceof POProject ) ) { int errCode = 1106 ; String errMsg = " Merge ▁ join ▁ is ▁ possible ▁ only ▁ for ▁ simple ▁ column ▁ or ▁ ' * ' ▁ join ▁ keys ▁ when ▁ using ▁ " + rightLoader . getLFile ( ) . getFuncSpec ( ) + " ▁ as ▁ the ▁ loader " ; throw new MRCompilerException ( errMsg , errCode , PigException . INPUT ) ; } } } } } else { LoadFunc loadFunc = rightLoader . getLoadFunc ( ) ; if ( joinOp . getJoinType ( ) == LOJoin . JOINTYPE . MERGESPARSE ) { int errCode = 1104 ; String errMsg = " Right ▁ input ▁ of ▁ merge - join ▁ must ▁ implement ▁ IndexableLoadFunc . ▁ " + " The ▁ specified ▁ loader ▁ " + loadFunc + " ▁ doesn ' t ▁ implement ▁ it " ; throw new MRCompilerException ( errMsg , errCode ) ; } if ( ! ( OrderedLoadFunc . class . isAssignableFrom ( loadFunc . getClass ( ) ) ) ) { int errCode = 1104 ; String errMsg = " Right ▁ input ▁ of ▁ merge - join ▁ must ▁ implement ▁ " + " OrderedLoadFunc ▁ interface . ▁ The ▁ specified ▁ loader ▁ " + loadFunc + " ▁ doesn ' t ▁ implement ▁ it " ; throw new MRCompilerException ( errMsg , errCode ) ; } String [ ] indexerArgs = new String [ 6 ] ; List < PhysicalPlan > rightInpPlans = joinOp . getInnerPlansOf ( 1 ) ; FileSpec origRightLoaderFileSpec = rightLoader . getLFile ( ) ; indexerArgs [ 0 ] = origRightLoaderFileSpec . getFuncSpec ( ) . toString ( ) ; indexerArgs [ 1 ] = ObjectSerializer . serialize ( ( Serializable ) rightInpPlans ) ; indexerArgs [ 2 ] = ObjectSerializer . serialize ( rightPipelinePlan ) ; indexerArgs [ 3 ] = rightLoader . getSignature ( ) ; indexerArgs [ 4 ] = rightLoader . getOperatorKey ( ) . scope ; indexerArgs [ 5 ] = Boolean . toString ( true ) ; FileSpec lFile = new FileSpec ( rightLoader . getLFile ( ) . getFileName ( ) , new FuncSpec ( MergeJoinIndexer . class . getName ( ) , indexerArgs ) ) ; rightLoader . setLFile ( lFile ) ; MRUtil . simpleConnectMapToReduce ( rightMROpr , scope , nig ) ; rightMROpr . useTypedComparator ( true ) ; POStore st = getStore ( ) ; FileSpec strFile = getTempFileSpec ( ) ; st . setSFile ( strFile ) ; rightMROpr . reducePlan . addAsLeaf ( st ) ; rightMROpr . setReduceDone ( true ) ; String [ ] defaultIndexableLoaderArgs = new String [ 5 ] ; defaultIndexableLoaderArgs [ 0 ] = origRightLoaderFileSpec . getFuncSpec ( ) . toString ( ) ; defaultIndexableLoaderArgs [ 1 ] = strFile . getFileName ( ) ; defaultIndexableLoaderArgs [ 2 ] = strFile . getFuncSpec ( ) . toString ( ) ; defaultIndexableLoaderArgs [ 3 ] = joinOp . getOperatorKey ( ) . scope ; defaultIndexableLoaderArgs [ 4 ] = origRightLoaderFileSpec . getFileName ( ) ; joinOp . setRightLoaderFuncSpec ( ( new FuncSpec ( DefaultIndexableLoader . class . getName ( ) , defaultIndexableLoaderArgs ) ) ) ; joinOp . setRightInputFileName ( origRightLoaderFileSpec . getFileName ( ) ) ; joinOp . setIndexFile ( strFile . getFileName ( ) ) ; udfs . add ( origRightLoaderFileSpec . getFuncSpec ( ) . toString ( ) ) ; } if ( ! curMROp . mapDone ) curMROp . mapPlan . addAsLeaf ( joinOp ) ; else if ( ! curMROp . reduceDone ) { POStore leftStore = getStore ( ) ; FileSpec leftStrFile = getTempFileSpec ( ) ; leftStore . setSFile ( leftStrFile ) ; curMROp . reducePlan . addAsLeaf ( leftStore ) ; curMROp . setReduceDone ( true ) ; curMROp = startNew ( leftStrFile , curMROp ) ; curMROp . mapPlan . addAsLeaf ( joinOp ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } if ( rightMROpr != null ) { rightMROpr . markIndexer ( ) ; MRPlan . connect ( rightMROpr , curMROp ) ; } phyToMROpMap . put ( joinOp , curMROp ) ; curMROp . noCombineSmallSplits ( ) ; curMROp . UDFs . addAll ( udfs ) ; } catch ( PlanException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + joinOp . getClass ( ) . getCanonicalName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } catch ( IOException e ) { int errCode = 3000 ; String errMsg = " IOException ▁ caught ▁ while ▁ compiling ▁ POMergeJoin " ; throw new MRCompilerException ( errMsg , errCode , e ) ; } catch ( CloneNotSupportedException e ) { int errCode = 2127 ; String errMsg = " Cloning ▁ exception ▁ caught ▁ while ▁ compiling ▁ POMergeJoin " ; throw new MRCompilerException ( errMsg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitDistinct ( PODistinct op ) throws VisitorException { try { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prjStar = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prjStar . setResultType ( DataType . TUPLE ) ; prjStar . setStar ( true ) ; ep . add ( prjStar ) ; List < PhysicalPlan > eps = new ArrayList < PhysicalPlan > ( ) ; eps . add ( ep ) ; POLocalRearrange lr = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; lr . setIndex ( 0 ) ; lr . setKeyType ( DataType . TUPLE ) ; lr . setPlans ( eps ) ; lr . setResultType ( DataType . TUPLE ) ; lr . setDistinct ( true ) ; addToMap ( lr ) ; blocking ( op ) ; curMROp . customPartitioner = op . getCustomPartitioner ( ) ; POPackage pkg = new POPackage ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pkg . setKeyType ( DataType . TUPLE ) ; pkg . setDistinct ( true ) ; pkg . setNumInps ( 1 ) ; boolean [ ] inner = { false } ; pkg . setInner ( inner ) ; curMROp . reducePlan . add ( pkg ) ; List < PhysicalPlan > eps1 = new ArrayList < PhysicalPlan > ( ) ; List < Boolean > flat1 = new ArrayList < Boolean > ( ) ; PhysicalPlan ep1 = new PhysicalPlan ( ) ; POProject prj1 = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj1 . setResultType ( DataType . TUPLE ) ; prj1 . setStar ( false ) ; prj1 . setColumn ( 0 ) ; prj1 . setOverloaded ( false ) ; ep1 . add ( prj1 ) ; eps1 . add ( ep1 ) ; flat1 . add ( true ) ; POForEach nfe1 = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , op . getRequestedParallelism ( ) , eps1 , flat1 ) ; nfe1 . setResultType ( DataType . BAG ) ; curMROp . reducePlan . addAsLeaf ( nfe1 ) ; curMROp . setNeedsDistinctCombiner ( true ) ; phyToMROpMap . put ( op , curMROp ) ; curMROp . phyToMRMap . put ( op , nfe1 ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitSkewedJoin ( POSkewedJoin op ) throws VisitorException { try { if ( compiledInputs . length != 2 ) { int errCode = 2255 ; throw new VisitorException ( " POSkewedJoin ▁ operator ▁ has ▁ " + compiledInputs . length + " ▁ inputs . ▁ It ▁ should ▁ have ▁ 2 . " , errCode ) ; } FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper mro = compiledInputs [ 0 ] ; POStore str = getStore ( ) ; str . setSFile ( fSpec ) ; if ( ! mro . isMapDone ( ) ) { mro . mapPlan . addAsLeaf ( str ) ; mro . setMapDoneSingle ( true ) ; } else if ( mro . isMapDone ( ) && ! mro . isReduceDone ( ) ) { mro . reducePlan . addAsLeaf ( str ) ; mro . setReduceDone ( true ) ; } else { int errCode = 2022 ; String msg = " Both ▁ map ▁ and ▁ reduce ▁ phases ▁ have ▁ been ▁ done . ▁ This ▁ is ▁ unexpected ▁ while ▁ compiling . " ; throw new PlanException ( msg , errCode , PigException . BUG ) ; } FileSpec partitionFile = getTempFileSpec ( ) ; int rp = op . getRequestedParallelism ( ) ; Pair < MapReduceOper , Integer > sampleJobPair = getSkewedJoinSampleJob ( op , mro , fSpec , partitionFile , rp ) ; rp = sampleJobPair . second ; op . setRequestedParallelism ( rp ) ; MapReduceOper [ ] joinInputs = new MapReduceOper [ ] { startNew ( fSpec , sampleJobPair . first ) , compiledInputs [ 1 ] } ; MapReduceOper [ ] rearrangeOutputs = new MapReduceOper [ 2 ] ; compiledInputs = new MapReduceOper [ ] { joinInputs [ 0 ] } ; POLocalRearrange lr = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; try { lr . setIndex ( 0 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } List < PhysicalOperator > l = plan . getPredecessors ( op ) ; MultiMap < PhysicalOperator , PhysicalPlan > joinPlans = op . getJoinPlans ( ) ; List < PhysicalPlan > groups = joinPlans . get ( l . get ( 0 ) ) ; byte type = DataType . TUPLE ; if ( groups . size ( ) == 1 ) { type = groups . get ( 0 ) . getLeaves ( ) . get ( 0 ) . getResultType ( ) ; } lr . setKeyType ( type ) ; lr . setPlans ( groups ) ; lr . setResultType ( DataType . TUPLE ) ; lr . visit ( this ) ; if ( lr . getRequestedParallelism ( ) > curMROp . requestedParallelism ) curMROp . requestedParallelism = lr . getRequestedParallelism ( ) ; rearrangeOutputs [ 0 ] = curMROp ; compiledInputs = new MapReduceOper [ ] { joinInputs [ 1 ] } ; if ( compiledInputs [ 0 ] . isMapDone ( ) && ! compiledInputs [ 0 ] . isReduceDone ( ) ) { FileSpec f = getTempFileSpec ( ) ; POStore s = getStore ( ) ; s . setSFile ( f ) ; compiledInputs [ 0 ] . reducePlan . addAsLeaf ( s ) ; compiledInputs [ 0 ] . setReduceDone ( true ) ; compiledInputs [ 0 ] = startNew ( f , compiledInputs [ 0 ] ) ; } POPartitionRearrange pr = new POPartitionRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; pr . setPigContext ( pigContext ) ; lr = pr ; try { lr . setIndex ( 1 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } groups = joinPlans . get ( l . get ( 1 ) ) ; lr . setPlans ( groups ) ; lr . setKeyType ( type ) ; lr . setResultType ( DataType . BAG ) ; lr . visit ( this ) ; if ( lr . getRequestedParallelism ( ) > curMROp . requestedParallelism ) curMROp . requestedParallelism = lr . getRequestedParallelism ( ) ; rearrangeOutputs [ 1 ] = curMROp ; compiledInputs = rearrangeOutputs ; POGlobalRearrange gr = new POGlobalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; gr . setResultType ( DataType . TUPLE ) ; gr . visit ( this ) ; if ( gr . getRequestedParallelism ( ) > curMROp . requestedParallelism ) curMROp . requestedParallelism = gr . getRequestedParallelism ( ) ; compiledInputs = new MapReduceOper [ ] { curMROp } ; POPackage pkg = new POPackage ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , rp ) ; pkg . setKeyType ( type ) ; pkg . setResultType ( DataType . TUPLE ) ; pkg . setNumInps ( 2 ) ; boolean [ ] inner = op . getInnerFlags ( ) ; pkg . setInner ( inner ) ; pkg . visit ( this ) ; compiledInputs = new MapReduceOper [ ] { curMROp } ; List < PhysicalPlan > eps = new ArrayList < PhysicalPlan > ( ) ; List < Boolean > flat = new ArrayList < Boolean > ( ) ; PhysicalPlan ep ; for ( int i = 0 ; i < 2 ; i ++ ) { ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setColumn ( i + 1 ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . BAG ) ; ep . add ( prj ) ; eps . add ( ep ) ; if ( ! inner [ i ] ) { CompilerUtils . addEmptyBagOuterJoin ( ep , op . getSchema ( i ) ) ; } flat . add ( true ) ; } POForEach fe = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , eps , flat ) ; fe . setResultType ( DataType . TUPLE ) ; fe . visit ( this ) ; curMROp . setSkewedJoinPartitionFile ( partitionFile . getFileName ( ) ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( PlanException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } catch ( IOException e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitSort ( POSort op ) throws VisitorException { try { FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper mro = endSingleInputPlanWithStr ( fSpec ) ; FileSpec quantFile = getTempFileSpec ( ) ; int rp = op . getRequestedParallelism ( ) ; Pair < POProject , Byte > [ ] fields = getSortCols ( op . getSortPlans ( ) ) ; Pair < MapReduceOper , Integer > quantJobParallelismPair = getQuantileJob ( op , mro , fSpec , quantFile , rp ) ; curMROp = getSortJob ( op , quantJobParallelismPair . first , fSpec , quantFile , quantJobParallelismPair . second , fields ) ; if ( op . isUDFComparatorUsed ) { curMROp . UDFs . add ( op . getMSortFunc ( ) . getFuncSpec ( ) . toString ( ) ) ; curMROp . isUDFComparatorUsed = true ; } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitCounter ( POCounter op ) throws VisitorException { try { if ( op . isRowNumber ( ) ) { List < PhysicalOperator > mpLeaves = curMROp . mapPlan . getLeaves ( ) ; PhysicalOperator leaf = mpLeaves . get ( 0 ) ; if ( ! curMROp . isMapDone ( ) && ! curMROp . isRankOperation ( ) ) { curMROp . mapPlan . addAsLeaf ( op ) ; } else { FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper prevMROper = endSingleInputPlanWithStr ( fSpec ) ; MapReduceOper mrCounter = startNew ( fSpec , prevMROper ) ; mrCounter . mapPlan . addAsLeaf ( op ) ; curMROp = mrCounter ; } } else { curMROp . reducePlan . addAsLeaf ( op ) ; } phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | @ Override public void visitRank ( PORank op ) throws VisitorException { try { FileSpec fSpec = getTempFileSpec ( ) ; MapReduceOper prevMROper = endSingleInputPlanWithStr ( fSpec ) ; curMROp = startNew ( fSpec , prevMROper ) ; curMROp . mapPlan . addAsLeaf ( op ) ; phyToMROpMap . put ( op , curMROp ) ; } catch ( Exception e ) { int errCode = 2034 ; String msg = " Error ▁ compiling ▁ operator ▁ " + op . getClass ( ) . getSimpleName ( ) ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } }
rekhajoshm/pig | if ( plans != null ) { @ SuppressWarnings ( " unchecked " ) Pair < POProject , Byte > [ ] ret = new Pair [ plans . size ( ) ] ; int i = - 1 ; for ( PhysicalPlan plan : plans ) { PhysicalOperator op = plan . getLeaves ( ) . get ( 0 ) ; POProject proj ; if ( op instanceof POProject ) { if ( ( ( POProject ) op ) . isStar ( ) ) return null ; proj = ( POProject ) op ; } else { proj = null ; } byte type = op . getResultType ( ) ; ret [ ++ i ] = new Pair < POProject , Byte > ( proj , type ) ; } return ret ; }
rekhajoshm/pig | private MapReduceOper getSortJob ( POSort sort , MapReduceOper quantJob , FileSpec lFile , FileSpec quantFile , int rp , Pair < POProject , Byte > [ ] fields ) throws PlanException { MapReduceOper mro = startNew ( lFile , quantJob ) ; mro . setQuantFile ( quantFile . getFileName ( ) ) ; mro . setGlobalSort ( true ) ; mro . requestedParallelism = rp ; long limit = sort . getLimit ( ) ; mro . limit = limit ; List < PhysicalPlan > eps1 = new ArrayList < PhysicalPlan > ( ) ; byte keyType = DataType . UNKNOWN ; boolean [ ] sortOrder ; List < Boolean > sortOrderList = sort . getMAscCols ( ) ; if ( sortOrderList != null ) { sortOrder = new boolean [ sortOrderList . size ( ) ] ; for ( int i = 0 ; i < sortOrderList . size ( ) ; ++ i ) { sortOrder [ i ] = sortOrderList . get ( i ) ; } mro . setSortOrder ( sortOrder ) ; } if ( fields == null ) { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setStar ( true ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . TUPLE ) ; ep . add ( prj ) ; eps1 . add ( ep ) ; } else { eps1 . addAll ( sort . getSortPlans ( ) ) ; try { FindKeyTypeVisitor fktv = new FindKeyTypeVisitor ( sort . getSortPlans ( ) . get ( 0 ) ) ; fktv . visit ( ) ; keyType = fktv . keyType ; } catch ( VisitorException ve ) { int errCode = 2035 ; String msg = " Internal ▁ error . ▁ Could ▁ not ▁ compute ▁ key ▁ type ▁ of ▁ sort ▁ operator . " ; throw new PlanException ( msg , errCode , PigException . BUG , ve ) ; } } POLocalRearrange lr = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; try { lr . setIndex ( 0 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } lr . setKeyType ( ( fields == null || fields . length > 1 ) ? DataType . TUPLE : keyType ) ; lr . setPlans ( eps1 ) ; lr . setResultType ( DataType . TUPLE ) ; lr . addOriginalLocation ( sort . getAlias ( ) , sort . getOriginalLocations ( ) ) ; mro . mapPlan . addAsLeaf ( lr ) ; mro . setMapDone ( true ) ; if ( limit != - 1 ) { POPackageLite pkg_c = new POPackageLite ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pkg_c . setKeyType ( ( fields . length > 1 ) ? DataType . TUPLE : keyType ) ; pkg_c . setNumInps ( 1 ) ; mro . combinePlan . add ( pkg_c ) ; List < PhysicalPlan > eps_c1 = new ArrayList < PhysicalPlan > ( ) ; List < Boolean > flat_c1 = new ArrayList < Boolean > ( ) ; PhysicalPlan ep_c1 = new PhysicalPlan ( ) ; POProject prj_c1 = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj_c1 . setColumn ( 1 ) ; prj_c1 . setOverloaded ( false ) ; prj_c1 . setResultType ( DataType . BAG ) ; ep_c1 . add ( prj_c1 ) ; eps_c1 . add ( ep_c1 ) ; flat_c1 . add ( true ) ; POForEach fe_c1 = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , eps_c1 , flat_c1 ) ; fe_c1 . setResultType ( DataType . TUPLE ) ; mro . combinePlan . addAsLeaf ( fe_c1 ) ; POLimit pLimit = new POLimit ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pLimit . setLimit ( limit ) ; mro . combinePlan . addAsLeaf ( pLimit ) ; List < PhysicalPlan > eps_c2 = new ArrayList < PhysicalPlan > ( ) ; eps_c2 . addAll ( sort . getSortPlans ( ) ) ; POLocalRearrange lr_c2 = new POLocalRearrange ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; try { lr_c2 . setIndex ( 0 ) ; } catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; } lr_c2 . setKeyType ( ( fields . length > 1 ) ? DataType . TUPLE : keyType ) ; lr_c2 . setPlans ( eps_c2 ) ; lr_c2 . setResultType ( DataType . TUPLE ) ; mro . combinePlan . addAsLeaf ( lr_c2 ) ; } POPackageLite pkg = new POPackageLite ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pkg . setKeyType ( ( fields == null || fields . length > 1 ) ? DataType . TUPLE : keyType ) ; pkg . setNumInps ( 1 ) ; mro . reducePlan . add ( pkg ) ; PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setColumn ( 1 ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . BAG ) ; ep . add ( prj ) ; List < PhysicalPlan > eps2 = new ArrayList < PhysicalPlan > ( ) ; eps2 . add ( ep ) ; List < Boolean > flattened = new ArrayList < Boolean > ( ) ; flattened . add ( true ) ; POForEach nfe1 = new POForEach ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , eps2 , flattened ) ; mro . reducePlan . add ( nfe1 ) ; mro . reducePlan . connect ( pkg , nfe1 ) ; mro . phyToMRMap . put ( sort , nfe1 ) ; if ( limit != - 1 ) { POLimit pLimit2 = new POLimit ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; pLimit2 . setLimit ( limit ) ; mro . reducePlan . addAsLeaf ( pLimit2 ) ; mro . phyToMRMap . put ( sort , pLimit2 ) ; } return mro ; }
rekhajoshm/pig | if ( sort . isUDFComparatorUsed ) { String userComparatorFuncSpec = sort . getMSortFunc ( ) . getFuncSpec ( ) . toString ( ) ; ctorArgs = new String [ ascs . length + 1 ] ; ctorArgs [ 0 ] = USER_COMPARATOR_MARKER + userComparatorFuncSpec ; for ( int j = 0 ; j < ascs . length ; j ++ ) { ctorArgs [ j + 1 ] = ascs [ j ] ; } }
rekhajoshm/pig | i ++ ) { ascCol . add ( false ) ; }
rekhajoshm/pig | catch ( Exception e ) { throw new PlanException ( e ) ; }
rekhajoshm/pig | if ( sort . isUDFComparatorUsed ) { mro . UDFs . add ( sort . getMSortFunc ( ) . getFuncSpec ( ) . toString ( ) ) ; curMROp . isUDFComparatorUsed = true ; }
rekhajoshm/pig | if ( transformPlans == null ) { Pair < POProject , Byte > [ ] sortProjs = null ; try { sortProjs = getSortCols ( sort . getSortPlans ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( sortProjs == null ) { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setStar ( true ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . TUPLE ) ; ep . add ( prj ) ; eps1 . add ( ep ) ; flat1 . add ( false ) ; } else { for ( Pair < POProject , Byte > sortProj : sortProjs ) { if ( sortProj == null ) { int errCode = 2174 ; String msg = " Internal ▁ exception . ▁ Could ▁ not ▁ create ▁ a ▁ sampler ▁ job " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj ; try { prj = sortProj . first . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( " Error ▁ cloning ▁ project ▁ caught ▁ exception " + e ) ; } ep . add ( prj ) ; eps1 . add ( ep ) ; flat1 . add ( false ) ; } } }
rekhajoshm/pig | i ++ ) { eps1 . add ( transformPlans . get ( i ) ) ; flat1 . add ( true ) ; }
rekhajoshm/pig | catch ( ExecException e ) { int errCode = 2058 ; String msg = " Unable ▁ to ▁ set ▁ index ▁ on ▁ newly ▁ created ▁ POLocalRearrange . " ; throw new PlanException ( msg , errCode , PigException . BUG , e ) ; }
rekhajoshm/pig | if ( sortKeyPlans != null ) { for ( int i = 0 ; i < sortKeyPlans . size ( ) ; i ++ ) { nesSortPlanLst . add ( sortKeyPlans . get ( i ) ) ; } }
rekhajoshm/pig | catch ( Exception e ) { throw new RuntimeException ( e ) ; }
rekhajoshm/pig | if ( sortProjs == null ) { PhysicalPlan ep = new PhysicalPlan ( ) ; POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setStar ( true ) ; prj . setOverloaded ( false ) ; prj . setResultType ( DataType . TUPLE ) ; ep . add ( prj ) ; nesSortPlanLst . add ( ep ) ; }
rekhajoshm/pig | i ++ ) { POProject prj = new POProject ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) ) ; prj . setResultType ( sortProjs [ i ] . second ) ; if ( sortProjs [ i ] . first != null && sortProjs [ i ] . first . isProjectToEnd ( ) ) { if ( i != sortProjs . length - 1 ) { throw new AssertionError ( " Project - range ▁ to ▁ end ▁ ( x . . ) " + " ▁ is ▁ supported ▁ in ▁ order - by ▁ only ▁ as ▁ last ▁ sort ▁ column " ) ; } prj . setProjectToEnd ( i ) ; break ; } else { prj . setColumn ( i ) ; } prj . setOverloaded ( false ) ; PhysicalPlan ep = new PhysicalPlan ( ) ; ep . add ( prj ) ; nesSortPlanLst . add ( ep ) ; }
rekhajoshm/pig | LastInputStreamingOptimizer ( MROperPlan plan , String chunkSize ) { super ( plan , new DepthFirstWalker < MapReduceOper , MROperPlan > ( plan ) ) ; this . chunkSize = chunkSize ; }
rekhajoshm/pig | @ Override public void visitMROp ( MapReduceOper mr ) throws VisitorException { if ( mr . mapPlan . isEmpty ( ) ) return ; if ( mr . reducePlan . isEmpty ( ) ) return ; if ( ! mr . combinePlan . isEmpty ( ) ) { return ; } List < PhysicalOperator > mpLeaves = mr . mapPlan . getLeaves ( ) ; if ( mpLeaves . size ( ) != 1 ) { return ; } PhysicalOperator op = mpLeaves . get ( 0 ) ; if ( ! ( op instanceof POUnion ) ) { return ; } List < PhysicalOperator > mrRoots = mr . reducePlan . getRoots ( ) ; if ( mrRoots . size ( ) != 1 ) { return ; } op = mrRoots . get ( 0 ) ; if ( ! ( op instanceof POPackage ) ) { return ; } POPackage pack = ( POPackage ) op ; List < PhysicalOperator > sucs = mr . reducePlan . getSuccessors ( pack ) ; if ( sucs == null || sucs . size ( ) != 1 ) { return ; } op = sucs . get ( 0 ) ; boolean lastInputFlattened = true ; boolean allSimple = true ; if ( op instanceof POForEach ) { POForEach forEach = ( POForEach ) op ; List < PhysicalPlan > planList = forEach . getInputPlans ( ) ; List < Boolean > flatten = forEach . getToBeFlattened ( ) ; POProject projOfLastInput = null ; int i = 0 ; for ( PhysicalPlan p : planList ) { PhysicalOperator opProj = p . getRoots ( ) . get ( 0 ) ; if ( ! ( opProj instanceof POProject ) ) { allSimple = false ; break ; } POProject proj = ( POProject ) opProj ; if ( proj . isProjectToEnd ( ) || proj . getColumns ( ) . size ( ) != 1 ) { allSimple = false ; break ; } try { if ( proj . getColumn ( ) == pack . getNumInps ( ) ) { if ( projOfLastInput != null ) { allSimple = false ; break ; } projOfLastInput = proj ; if ( ! flatten . get ( i ) || proj . getResultType ( ) != DataType . BAG ) { lastInputFlattened = false ; break ; } } } catch ( ExecException e ) { int errCode = 2069 ; String msg = " Error ▁ during ▁ map ▁ reduce ▁ compilation . ▁ Problem ▁ in ▁ accessing ▁ column ▁ from ▁ project ▁ operator . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } PhysicalOperator succ = p . getSuccessors ( proj ) != null ? p . getSuccessors ( proj ) . get ( 0 ) : null ; while ( succ != null ) { if ( ! ( succ instanceof POProject ) ) { allSimple = false ; break ; } if ( proj == projOfLastInput && ( ( POProject ) succ ) . getResultType ( ) != DataType . BAG ) { allSimple = false ; break ; } succ = p . getSuccessors ( succ ) != null ? p . getSuccessors ( succ ) . get ( 0 ) : null ; } i ++ ; if ( allSimple == false ) break ; } if ( lastInputFlattened && allSimple && projOfLastInput != null ) { replaceWithPOJoinPackage ( mr . reducePlan , mr , pack , forEach , chunkSize ) ; } } }
rekhajoshm/pig | FindKeyTypeVisitor ( PhysicalPlan plan ) { super ( plan , new DepthFirstWalker < PhysicalOperator , PhysicalPlan > ( plan ) ) ; }
rekhajoshm/pig | @ Override public void visitProject ( POProject p ) throws VisitorException { keyType = p . getResultType ( ) ; }
rekhajoshm/pig | FindStoreNameVisitor ( PhysicalPlan plan , FileSpec newSpec , FileSpec oldSpec ) { super ( plan , new DepthFirstWalker < PhysicalOperator , PhysicalPlan > ( plan ) ) ; this . newSpec = newSpec ; this . oldSpec = oldSpec ; }
rekhajoshm/pig | @ Override public void visitStore ( POStore sto ) throws VisitorException { FileSpec spec = sto . getSFile ( ) ; if ( oldSpec . equals ( spec ) ) { sto . setSFile ( newSpec ) ; } }
18743206721/coolWeather | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . choose_area , container , false ) ; titleText = ( TextView ) view . findViewById ( R . id . title_text ) ; backButton = ( Button ) view . findViewById ( R . id . back_button ) ; listView = ( ListView ) view . findViewById ( R . id . list_view ) ; adapter = new ArrayAdapter < > ( getContext ( ) , android . R . layout . simple_list_item_1 , dataList ) ; listView . setAdapter ( adapter ) ; return view ; }
18743206721/coolWeather | @ Override public void onActivityCreated ( @ Nullable Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; listView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { @ Override public void onItemClick ( AdapterView < ? > parent , View view , int position , long id ) { if ( currentLevel == LEVEL_PROVINCE ) { selectedProvince = provinceList . get ( position ) ; queryCities ( ) ; } else if ( currentLevel == LEVEL_CITY ) { selectedCity = cityList . get ( position ) ; queryCounties ( ) ; } else if ( currentLevel == LEVEL_COUNTRY ) { String weatherId = countyList . get ( position ) . getWeatherId ( ) ; Intent intent = new Intent ( getActivity ( ) , WeatherActivity . class ) ; intent . putExtra ( " weather _ id " , weatherId ) ; startActivity ( intent ) ; getActivity ( ) . finish ( ) ; } } } ) ; backButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { if ( currentLevel == LEVEL_COUNTRY ) { queryCities ( ) ; } else if ( currentLevel == LEVEL_CITY ) { queryProvinces ( ) ; } } } ) ; queryProvinces ( ) ; }
18743206721/coolWeather | private void queryProvinces ( ) { titleText . setText ( " 中国 " ) ; backButton . setVisibility ( View . GONE ) ; provinceList = DataSupport . findAll ( Province . class ) ; if ( provinceList . size ( ) > 0 ) { dataList . clear ( ) ; for ( Province province : provinceList ) { dataList . add ( province . getProvinceName ( ) ) ; } adapter . notifyDataSetChanged ( ) ; listView . setSelection ( 0 ) ; currentLevel = LEVEL_PROVINCE ; } else { String address = Contus . PRIVICE_CITY ; queryFromServer ( address , " province " ) ; } }
18743206721/coolWeather | private void queryCities ( ) { titleText . setText ( selectedProvince . getProvinceName ( ) ) ; backButton . setVisibility ( View . VISIBLE ) ; cityList = DataSupport . where ( " provinceid ▁ = ▁ ? " , String . valueOf ( selectedProvince . getId ( ) ) ) . find ( City . class ) ; if ( cityList . size ( ) > 0 ) { dataList . clear ( ) ; for ( City city : cityList ) { dataList . add ( city . getCityname ( ) ) ; } adapter . notifyDataSetChanged ( ) ; listView . setSelection ( 0 ) ; currentLevel = LEVEL_CITY ; } else { int provinceCode = selectedProvince . getProvinceCode ( ) ; String address = Contus . PRIVICE_CITY + " / " + provinceCode ; queryFromServer ( address , " city " ) ; } }
18743206721/coolWeather | private void queryCounties ( ) { titleText . setText ( selectedCity . getCityname ( ) ) ; backButton . setVisibility ( View . VISIBLE ) ; countyList = DataSupport . where ( " cityid = ▁ ? ▁ " , String . valueOf ( selectedCity . getId ( ) ) ) . find ( County . class ) ; if ( countyList . size ( ) > 0 ) { dataList . clear ( ) ; for ( County county : countyList ) { dataList . add ( county . getCountyName ( ) ) ; } adapter . notifyDataSetChanged ( ) ; listView . setSelection ( 0 ) ; currentLevel = LEVEL_COUNTRY ; } else { int provinceCode = selectedProvince . getProvinceCode ( ) ; int cityCode = selectedCity . getCityCode ( ) ; String address = Contus . PRIVICE_CITY + " / " + provinceCode + " / " + cityCode ; Log . e ( " country _ ads " , " queryCounties : ▁ " + address ) ; queryFromServer ( address , " county " ) ; } }
18743206721/coolWeather | private void queryFromServer ( String address , final String type ) { showProgressDialog ( ) ; HttpUtils . sendOkHttpRequest ( address , new Callback ( ) { @ Override public void onFailure ( Call call , IOException e ) { getActivity ( ) . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { closeProgressDialog ( ) ; Toast . makeText ( getContext ( ) , " 加载失败 " , Toast . LENGTH_SHORT ) . show ( ) ; } } ) ; } @ Override public void onResponse ( Call call , Response response ) throws IOException { String responseText = response . body ( ) . string ( ) ; boolean result = false ; if ( " province " . equals ( type ) ) { result = Utility . handleProvinceResponse ( responseText ) ; } else if ( " city " . equals ( type ) ) { result = Utility . handleCityResponse ( responseText , selectedProvince . getId ( ) ) ; } else if ( " county " . equals ( type ) ) { result = Utility . handleCountryResponse ( responseText , selectedCity . getId ( ) ) ; } if ( result ) { getActivity ( ) . runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { closeProgressDialog ( ) ; if ( " province " . equals ( type ) ) { queryProvinces ( ) ; } else if ( " city " . equals ( type ) ) { queryCities ( ) ; } else if ( " county " . equals ( type ) ) { queryCounties ( ) ; } } } ) ; } } } ) ; }
18743206721/coolWeather | @ Override public void onDestroy ( ) { super . onDestroy ( ) ; closeProgressDialog ( ) ; }
18743206721/coolWeather | private void showProgressDialog ( ) { if ( progressDialog == null ) { progressDialog = new ProgressDialog ( getActivity ( ) ) ; progressDialog . setMessage ( " 正在加载 " ) ; progressDialog . setCanceledOnTouchOutside ( false ) ; } progressDialog . show ( ) ; }
18743206721/coolWeather | private void closeProgressDialog ( ) { if ( progressDialog != null ) { progressDialog . dismiss ( ) ; } }
andytaylor/activemq-artemis | @ Override protected SequentialFileFactory getFileFactory ( ) throws Exception { return new NIOSequentialFileFactory ( getTestDirfile ( ) , true , 1 ) ; }
andytaylor/activemq-artemis | @ Test public void testExportImport ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 , 2 ) ; journal . forceMoveNextFile ( ) ; delete ( 1 , 2 ) ; add ( 3 , 4 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 6 , 7 , 8 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 9 ) ; commit ( 5 ) ; journal . forceMoveNextFile ( ) ; deleteTx ( 10 , 6 , 7 , 8 , 9 ) ; commit ( 10 ) ; addTx ( 11 , 11 , 12 ) ; updateTx ( 11 , 11 , 12 ) ; commit ( 11 ) ; journal . forceMoveNextFile ( ) ; update ( 11 , 12 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
andytaylor/activemq-artemis | @ Test public void testExportImport3 ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 , 2 ) ; journal . forceMoveNextFile ( ) ; delete ( 1 , 2 ) ; add ( 3 , 4 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 6 , 7 , 8 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 9 ) ; commit ( 5 ) ; journal . forceMoveNextFile ( ) ; deleteTx ( 10 , 6 , 7 , 8 , 9 ) ; commit ( 10 ) ; addTx ( 11 , 12 , 13 ) ; EncodingSupport xid = new SimpleEncoding ( 10 , ( byte ) 0 ) ; prepare ( 11 , xid ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; commit ( 11 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
andytaylor/activemq-artemis | @ Test public void testExportImport2 ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
crate/crate | public RestoreOnlyRepository ( String indexName ) { this . indexName = indexName ; }
crate/crate | @ Override public RepositoryMetadata getMetadata ( ) { return null ; }
crate/crate | @ Override public void getSnapshotInfo ( SnapshotId snapshotId , ActionListener < SnapshotInfo > listener ) { listener . onResponse ( null ) ; }
crate/crate | @ Override public void getSnapshotGlobalMetadata ( SnapshotId snapshotId , ActionListener < Metadata > listener ) { }
crate/crate | @ Override public void getSnapshotIndexMetadata ( SnapshotId snapshotId , IndexId indexId , ActionListener < IndexMetadata > listener ) throws IOException { }
crate/crate | @ Override public void getSnapshotIndexMetadata ( SnapshotId snapshotId , Collection < IndexId > indexIds , ActionListener < Collection < IndexMetadata > > listener ) { }
crate/crate | @ Override public void getRepositoryData ( ActionListener < RepositoryData > listener ) { final IndexId indexId = new IndexId ( indexName , " blah " ) ; listener . onResponse ( new RepositoryData ( EMPTY_REPO_GEN , Map . of ( ) , Map . of ( ) , Map . of ( ) , Map . of ( indexId , Set . of ( ) ) , ShardGenerations . EMPTY ) ) ; }
crate/crate | @ Override public void finalizeSnapshot ( SnapshotId snapshotId , ShardGenerations shardGenerations , long startTime , String failure , int totalShards , List < SnapshotShardFailure > shardFailures , long repositoryStateId , boolean includeGlobalState , Metadata clusterMetadata , boolean writeShardGens , ActionListener < SnapshotInfo > listener ) { listener . onResponse ( null ) ; }
crate/crate | @ Override public void deleteSnapshot ( SnapshotId snapshotId , long repositoryStateId , boolean writeShardGens , ActionListener < Void > listener ) { }
crate/crate | @ Override public String startVerification ( ) { return null ; }
crate/crate | @ Override public void endVerification ( String verificationToken ) { }
crate/crate | @ Override public void verify ( String verificationToken , DiscoveryNode localNode ) { }
crate/crate | @ Override public boolean isReadOnly ( ) { return false ; }
crate/crate | @ Override public void snapshotShard ( Store store , MapperService mapperService , SnapshotId snapshotId , IndexId indexId , IndexCommit snapshotIndexCommit , IndexShardSnapshotStatus snapshotStatus , boolean writeShardGens , ActionListener < String > listener ) { }
crate/crate | @ Override public void restoreShard ( Store store , SnapshotId snapshotId , IndexId indexId , ShardId snapshotShardId , RecoveryState recoveryState , ActionListener < Void > listener ) { }
crate/crate | @ Override public Lifecycle . State lifecycleState ( ) { return null ; }
crate/crate | @ Override public void addLifecycleListener ( LifecycleListener listener ) { }
crate/crate | @ Override public void removeLifecycleListener ( LifecycleListener listener ) { }
crate/crate | @ Override public void start ( ) { }
crate/crate | @ Override public void stop ( ) { }
crate/crate | @ Override public void close ( ) { }
eayun/ovirt-engine | private EventNotificationEntity ( ApplicationMode applicationMode ) { this . availableInModes = applicationMode . getValue ( ) ; }
eayun/ovirt-engine | public int getValue ( ) { return this . ordinal ( ) ; }
eayun/ovirt-engine | public int getAvailableInModes ( ) { return availableInModes ; }
jprante/elasticsearch-client | GetMappingRequest ( ) { }
jprante/elasticsearch-client | public GetMappingRequest ( String ... indices ) { this . indices = indices ; }
jprante/elasticsearch-client | @ Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( mappingType == null ) { validationException = addValidationError ( " mapping ▁ type ▁ is ▁ missing " , validationException ) ; } return validationException ; }
jprante/elasticsearch-client | public GetMappingRequest indices ( String [ ] indices ) { this . indices = indices ; return this ; }
jprante/elasticsearch-client | public String [ ] indices ( ) { return indices ; }
jprante/elasticsearch-client | public String type ( ) { return mappingType ; }
jprante/elasticsearch-client | public GetMappingRequest type ( String mappingType ) { this . mappingType = mappingType ; return this ; }
jprante/elasticsearch-client | @ Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; indices = new String [ in . readVInt ( ) ] ; for ( int i = 0 ; i < indices . length ; i ++ ) { indices [ i ] = in . readString ( ) ; } if ( in . readBoolean ( ) ) { mappingType = in . readString ( ) ; } }
jprante/elasticsearch-client | @ Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; if ( indices == null ) { out . writeVInt ( 0 ) ; } else { out . writeVInt ( indices . length ) ; for ( String index : indices ) { out . writeString ( index ) ; } } if ( mappingType == null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeString ( mappingType ) ; } }
HappyRay/azkaban | public SlaAlertAction ( final String id , final SlaOption slaOption , final int execId ) { this . actionId = id ; this . slaOption = slaOption ; this . execId = execId ; this . alerters = ServiceProvider . SERVICE_PROVIDER . getInstance ( AlerterHolder . class ) ; this . executorLoader = ServiceProvider . SERVICE_PROVIDER . getInstance ( ExecutorLoader . class ) ; }
HappyRay/azkaban | @ Override public String getId ( ) { return this . actionId ; }
HappyRay/azkaban | @ Override public String getType ( ) { return type ; }
HappyRay/azkaban | @ Override public TriggerAction fromJson ( final Object obj ) throws Exception { return createFromJson ( obj ) ; }
HappyRay/azkaban | @ Override public Object toJson ( ) { final Map < String , Object > jsonObj = new HashMap < > ( ) ; jsonObj . put ( " actionId " , this . actionId ) ; jsonObj . put ( " type " , type ) ; jsonObj . put ( " slaAction " , this . slaOption . toObject ( ) ) ; jsonObj . put ( " execId " , String . valueOf ( this . execId ) ) ; return jsonObj ; }
HappyRay/azkaban | @ Override public void doAction ( ) throws Exception { logger . info ( " Alerting ▁ on ▁ sla ▁ failure . " ) ; if ( slaOption . hasAlert ( ) ) { final Alerter alerter = this . alerters . get ( SlaOption . ALERT_TYPE_EMAIL ) ; if ( alerter != null ) { try { final ExecutableFlow flow = this . executorLoader . fetchExecutableFlow ( this . execId ) ; alerter . alertOnSla ( this . slaOption , slaOption . createSlaMessage ( flow ) ) ; } catch ( final Exception e ) { e . printStackTrace ( ) ; logger . error ( " Failed ▁ to ▁ alert ▁ by ▁ " + SlaOption . ALERT_TYPE_EMAIL ) ; } } else { logger . error ( " Alerter ▁ type ▁ " + SlaOption . ALERT_TYPE_EMAIL + " ▁ doesn ' t ▁ exist . ▁ Failed ▁ to ▁ alert . " ) ; } } }
HappyRay/azkaban | @ Override public void setContext ( final Map < String , Object > context ) { }
HappyRay/azkaban | @ Override public String getDescription ( ) { return type + " ▁ for ▁ " + this . execId + " ▁ with ▁ " + this . slaOption . toString ( ) ; }
AWildridge/mint | public EventHandler ( Class clazz ) { this . clazz = clazz ; }
AWildridge/mint | public Class < ? extends T > getEventClass ( ) { return clazz ; }
gaston8181/uade-ventas | @ Transactional public void altaProducto ( ProductoForm producto ) { Producto p = new Producto ( producto ) ; productoDAO . altaProducto ( p ) ; }
gaston8181/uade-ventas | @ Transactional public void bajaProducto ( Long idBaja ) { Producto producto = new Producto ( idBaja ) ; productoDAO . bajaProducto ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public void modificarProducto ( ProductoForm form ) { Producto producto = new Producto ( form ) ; productoDAO . modificarProducto ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public void modificarStock ( ProductoForm form ) { Producto producto = productoDAO . loadProducto ( form . getId ( ) ) ; producto . agregarStock ( form . getAgregarStock ( ) ) ; productoDAO . modificarProducto ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public List < ProductoForm > consultarProductos ( ProductoForm form ) { List < Producto > productos = productoDAO . listarProductos ( form ) ; List < ProductoForm > productosForm = new ArrayList < ProductoForm > ( ) ; for ( Producto producto : productos ) { ProductoForm aux = crearView ( producto ) ; aux . setDescColor ( producto . getColor ( ) . getDescripcion ( ) ) ; aux . setDescMarca ( producto . getMarca ( ) . getDescripcion ( ) ) ; aux . setDescProducto ( producto . getTipoProducto ( ) . getDescripcion ( ) ) ; aux . setDescTalle ( producto . getTalle ( ) . getDescripcion ( ) ) ; productosForm . add ( aux ) ; } return productosForm ; }
gaston8181/uade-ventas | @ Override public List < ColorForm > getColores ( ) { return comboBusiness . getColores ( ) ; }
gaston8181/uade-ventas | @ Override public List < TalleForm > getTalles ( ) { return comboBusiness . getTalles ( ) ; }
gaston8181/uade-ventas | @ Override public List < TipoProductoForm > getTiposProd ( ) { return comboBusiness . getTiposProd ( ) ; }
gaston8181/uade-ventas | @ Override public List < ProveedorForm > getProveedores ( ) { return comboBusiness . getProveedores ( ) ; }
gaston8181/uade-ventas | @ Override public List < MarcaForm > getMarcas ( ) { return comboBusiness . getMarcas ( ) ; }
gaston8181/uade-ventas | @ Transactional public ProductoForm obtenerProducto ( Long id ) { Producto producto = productoDAO . loadProducto ( id ) ; return crearView ( producto ) ; }
gaston8181/uade-ventas | @ Transactional public List < ProductoForm > listarProductos ( ) { List < Producto > productos = productoDAO . listarProductos ( ) ; List < ProductoForm > productosForm = new ArrayList < ProductoForm > ( ) ; for ( Producto producto : productos ) { ProductoForm aux = crearView ( producto ) ; aux . setDescColor ( producto . getColor ( ) . getDescripcion ( ) ) ; aux . setDescMarca ( producto . getMarca ( ) . getDescripcion ( ) ) ; aux . setDescProducto ( producto . getTipoProducto ( ) . getDescripcion ( ) ) ; aux . setDescTalle ( producto . getTalle ( ) . getDescripcion ( ) ) ; productosForm . add ( aux ) ; } return productosForm ; }
gaston8181/uade-ventas | @ Override public boolean codigoBarrasExiste ( ProductoForm form ) { return productoDAO . codigoBarrasExiste ( form . getId ( ) ) ; }
gaston8181/uade-ventas | private ProductoForm crearView ( Producto producto ) { ProductoForm view = new ProductoForm ( ) ; view . setDatoAdicional ( producto . getDatoAdicional ( ) ) ; view . setId ( producto . getId ( ) ) ; view . setIdColor ( producto . getColor ( ) . getId ( ) ) ; view . setIdMarca ( producto . getMarca ( ) . getId ( ) ) ; view . setIdProveedor ( producto . getProveedor ( ) . getId ( ) ) ; view . setIdTalle ( producto . getTalle ( ) . getId ( ) ) ; view . setIdTipoProducto ( producto . getTipoProducto ( ) . getId ( ) ) ; view . setPrecioCompra ( producto . getPrecioCompra ( ) ) ; view . setPrecioVenta ( producto . getPrecioVenta ( ) ) ; view . setStock ( producto . getStock ( ) ) ; return view ; }
gaston8181/uade-ventas | public void setProductoDAO ( ProductoDAO productoDAO ) { this . productoDAO = productoDAO ; }
gaston8181/uade-ventas | public void setComboBusiness ( CombosBusiness comboBusiness ) { this . comboBusiness = comboBusiness ; }
googleapis/google-api-java-client-services | public GoogleCloudDocumentaiUiv1beta3CommonOperationMetadata getCommonMetadata ( ) { return commonMetadata ; }
googleapis/google-api-java-client-services | public GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata setCommonMetadata ( GoogleCloudDocumentaiUiv1beta3CommonOperationMetadata commonMetadata ) { this . commonMetadata = commonMetadata ; return this ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata set ( String fieldName , Object value ) { return ( GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata clone ( ) { return ( GoogleCloudDocumentaiUiv1beta3DeleteLabelerPoolOperationMetadata ) super . clone ( ) ; }
CSCSI/Triana | public HelpAction ( ToolSelectionHandler selhandler ) { this . selectionHandler = selhandler ; putValue ( SHORT_DESCRIPTION , Env . getString ( " Help " ) ) ; putValue ( ACTION_COMMAND_KEY , Env . getString ( " Help " ) ) ; putValue ( SMALL_ICON , GUIEnv . getIcon ( " help . png " ) ) ; putValue ( NAME , Env . getString ( " Help " ) ) ; putValue ( ACCELERATOR_KEY , KeyStroke . getKeyStroke ( " F1" ) ) ; }
CSCSI/Triana | public void actionPerformed ( ActionEvent e ) { Tool tool = null ; if ( selectionHandler . isSingleSelectedTool ( ) ) { tool = selectionHandler . getSelectedTool ( ) ; } if ( tool != null ) { showHelp ( tool ) ; } else { GUIEnv . getApplicationFrame ( ) . showHelp ( ) ; } }
CSCSI/Triana | public void showHelp ( Tool tool ) { String helpfile = ToolTableUtils . getUnitHelpFilePath ( tool ) ; GUIEnv . openURL ( helpfile ) ; }
EMResearch/EMB | public AutocompleteService ( UrlGenerator autoCompleteUrlFor , TimbuctooActions timbuctooActions ) { this . timbuctooActions = timbuctooActions ; this . autoCompleteUrlFor = autoCompleteUrlFor ; }
EMResearch/EMB | public JsonNode search ( String collectionName , Optional < String > query , Optional < String > keywordType ) throws InvalidCollectionException { final Collection collection = timbuctooActions . getCollectionMetadata ( collectionName ) ; int limit = query . isPresent ( ) ? 50 : 1000 ; String queryString = query . orElse ( null ) ; QuickSearch quickSearch = QuickSearch . fromQueryString ( queryString ) ; List < QuickSearchResult > results = timbuctooActions . doQuickSearch ( collection , quickSearch , keywordType . orElse ( null ) , limit ) ; return jsnA ( results . stream ( ) . map ( entity -> jsnO ( " value " , jsn ( entity . getIndexedValue ( ) ) , " key " , jsn ( autoCompleteUrlFor . apply ( collectionName , entity . getId ( ) , entity . getRev ( ) ) . toString ( ) ) ) ) ) ; }
EMResearch/EMB | public AutocompleteServiceFactory ( UrlGenerator autoCompleteUri ) { this . autoCompleteUri = autoCompleteUri ; }
EMResearch/EMB | public AutocompleteService create ( TimbuctooActions timbuctooActions ) { return new AutocompleteService ( autoCompleteUri , timbuctooActions ) ; }
marszczybrew/Diorite | @ Override public int compare ( final String s1 , final String s2 ) { return compareStatic ( s1 , s2 ) ; }
OpenBEL/rest-api | @ Get ( " json " ) public Representation _get ( ) { String function = getAttribute ( " function " ) ; FunctionEnum f = fromString ( function ) ; if ( f == null ) { setStatus ( Status . CLIENT_ERROR_NOT_FOUND ) ; return null ; } String name = f . getDisplayValue ( ) ; String abbrev = f . getAbbreviation ( ) ; Objects . Function objf = new Objects . Function ( name , abbrev ) ; objf . put ( " description " , description ( f ) ) ; String path = declaredPath ( Objects . Functions . class ) ; objf . addLink ( " self " , urlify ( path , function ) ) ; path = declaredPath ( Objects . Signatures . class ) ; objf . addLink ( " related " , urlify ( path , function ) ) ; FunctionsRoot . linkResource ( objf ) ; return objf . json ( ) ; }
maxcom/lorsource | @ Autowired public void setDateSource ( DataSource ds ) { jdbcTemplate = new JdbcTemplate ( ds ) ; }
maxcom/lorsource | @ Cacheable ( " Groups " ) public Group getGroup ( int id ) throws GroupNotFoundException { try { return jdbcTemplate . queryForObject ( " SELECT ▁ sections . moderate , ▁ vote , ▁ section , ▁ havelink , ▁ linktext , ▁ title , ▁ urlname , ▁ image , ▁ groups . restrict _ topics , ▁ restrict _ comments , stat3 , groups . id , ▁ groups . info , ▁ groups . longinfo , ▁ groups . resolvable ▁ FROM ▁ groups , ▁ sections ▁ WHERE ▁ groups . id = ? ▁ AND ▁ groups . section = sections . id " , ( resultSet , i ) -> Group . buildGroup ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException ex ) { throw new GroupNotFoundException ( " Группа ▁ " + id + " ▁ не ▁ существует " , ex ) ; } }
maxcom/lorsource | public List < Group > getGroups ( Section section ) { return jdbcTemplate . query ( " SELECT ▁ sections . moderate , ▁ vote , ▁ section , ▁ havelink , ▁ linktext , ▁ title , ▁ urlname , ▁ image , ▁ groups . restrict _ topics , ▁ restrict _ comments , ▁ stat3 , groups . id , groups . info , groups . longinfo , groups . resolvable ▁ FROM ▁ groups , ▁ sections ▁ WHERE ▁ sections . id = ? ▁ AND ▁ groups . section = sections . id ▁ ORDER ▁ BY ▁ id " , ( rs , rowNum ) -> Group . buildGroup ( rs ) , section . getId ( ) ) ; }
maxcom/lorsource | @ Nonnull public Group getGroup ( Section section , String name ) throws GroupNotFoundException { Optional < Group > group = getGroupOpt ( section , name , false ) ; if ( group . isEmpty ( ) ) { logger . info ( " Group ▁ ' { } ' ▁ not ▁ found ▁ in ▁ section ▁ { } " , name , section . getUrlName ( ) ) ; throw new GroupNotFoundException ( " group ▁ not ▁ found " ) ; } else { return group . get ( ) ; } }
maxcom/lorsource | public Optional < Group > getGroupOpt ( Section section , String name , Boolean allowNumber ) { try { if ( allowNumber && StringUtils . isNumeric ( name ) ) { int id = jdbcTemplate . queryForObject ( " SELECT ▁ id ▁ FROM ▁ groups ▁ WHERE ▁ section = ? ▁ AND ▁ id = ? " , Integer . class , section . getId ( ) , Integer . parseInt ( name ) ) ; return Optional . of ( getGroup ( id ) ) ; } else if ( StringUtils . isAsciiPrintable ( name ) ) { int id = jdbcTemplate . queryForObject ( " SELECT ▁ id ▁ FROM ▁ groups ▁ WHERE ▁ section = ? ▁ AND ▁ urlname = ? " , Integer . class , section . getId ( ) , name ) ; return Optional . of ( getGroup ( id ) ) ; } else { return Optional . empty ( ) ; } } catch ( EmptyResultDataAccessException ex ) { logger . debug ( " Group ▁ ' { } ' ▁ not ▁ found ▁ in ▁ section ▁ { } " , name , section . getUrlName ( ) ) ; return Optional . empty ( ) ; } }
maxcom/lorsource | @ CacheEvict ( value = " Groups " , key = " # group . id " ) public void setParams ( final Group group , final String title , final String info , final String longInfo , final boolean resolvable , final String urlName ) { jdbcTemplate . execute ( " UPDATE ▁ groups ▁ SET ▁ title = ? , ▁ info = ? , ▁ longinfo = ? , resolvable = ? , urlname = ? ▁ WHERE ▁ id = ? " , ( PreparedStatement pst ) -> { pst . setString ( 1 , title ) ; if ( ! info . isEmpty ( ) ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( ! longInfo . isEmpty ( ) ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; }
deroneriksson/incubator-systemml | @ Override public void selectPlans ( CPlanMemoTable memo , ArrayList < Hop > roots ) { Collection < PlanPartition > parts = PlanAnalyzer . analyzePlanPartitions ( memo , roots , true ) ; int sumMatPoints = 0 ; for ( PlanPartition part : parts ) { createAndAddMultiAggPlans ( memo , part . getPartition ( ) , part . getRoots ( ) ) ; selectPlans ( memo , part ) ; sumMatPoints += part . getMatPointsExt ( ) . length ; } createAndAddMultiAggPlans ( memo , roots ) ; for ( Entry < Long , List < MemoTableEntry > > e : getBestPlans ( ) . entrySet ( ) ) memo . setDistinct ( e . getKey ( ) , e . getValue ( ) ) ; if ( ConfigurationManager . isStatistics ( ) ) { if ( sumMatPoints >= 63 ) LOG . warn ( " Long ▁ overflow ▁ on ▁ maintaining ▁ codegen ▁ statistics ▁ " + " for ▁ a ▁ DAG ▁ with ▁ " + sumMatPoints + " ▁ interesting ▁ points . " ) ; Statistics . incrementCodegenEnumAll ( UtilFunctions . pow ( 2 , sumMatPoints ) ) ; } }
deroneriksson/incubator-systemml | private void selectPlans ( CPlanMemoTable memo , PlanPartition part ) { pruneInvalidAndSpecialCasePlans ( memo , part ) ; if ( part . getMatPointsExt ( ) == null || part . getMatPointsExt ( ) . length == 0 ) { for ( Long hopID : part . getRoots ( ) ) rSelectPlansFuseAll ( memo , memo . getHopRefs ( ) . get ( hopID ) , null , part . getPartition ( ) ) ; } else { HashMap < Long , Double > computeCosts = new HashMap < > ( ) ; for ( Long hopID : part . getPartition ( ) ) getComputeCosts ( memo . getHopRefs ( ) . get ( hopID ) , computeCosts ) ; StaticCosts costs = new StaticCosts ( computeCosts , sumComputeCost ( computeCosts ) , getReadCost ( part , memo ) , getWriteCost ( part . getRoots ( ) , memo ) , minOuterSparsity ( part , memo ) ) ; ReachabilityGraph rgraph = STRUCTURAL_PRUNING ? new ReachabilityGraph ( part , memo ) : null ; if ( STRUCTURAL_PRUNING ) { part . setMatPointsExt ( rgraph . getSortedSearchSpace ( ) ) ; for ( Long hopID : part . getPartition ( ) ) memo . pruneRedundant ( hopID , true , part . getMatPointsExt ( ) ) ; } boolean [ ] bestPlan = enumPlans ( memo , part , costs , rgraph , part . getMatPointsExt ( ) , 0 ) ; HashSet < Long > visited = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) rPruneSuboptimalPlans ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited , part , part . getMatPointsExt ( ) , bestPlan ) ; HashSet < Long > visited2 = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) rPruneInvalidPlans ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited2 , part , bestPlan ) ; for ( Long hopID : part . getRoots ( ) ) rSelectPlansFuseAll ( memo , memo . getHopRefs ( ) . get ( hopID ) , null , part . getPartition ( ) ) ; } }
deroneriksson/incubator-systemml | private boolean [ ] enumPlans ( CPlanMemoTable memo , PlanPartition part , StaticCosts costs , ReachabilityGraph rgraph , InterestingPoint [ ] matPoints , int off ) { final int Mlen = matPoints . length - off ; final long len = UtilFunctions . pow ( 2 , Mlen ) ; long numEvalPlans = 2 , numEvalPartPlans = 0 ; final boolean [ ] plan0 = createAssignment ( Mlen , off , 0 ) ; final boolean [ ] planN = createAssignment ( Mlen , off , len - 1 ) ; final double C0 = getPlanCost ( memo , part , matPoints , plan0 , costs . _computeCosts , Double . MAX_VALUE ) ; final double CN = getPlanCost ( memo , part , matPoints , planN , costs . _computeCosts , Double . MAX_VALUE ) ; boolean [ ] bestPlan = ( C0 <= CN ) ? plan0 : planN ; double bestC = Math . min ( C0 , CN ) ; final boolean evalRemain = ( Mlen < COST_MIN_EPS_NUM_POINTS || ! COST_PRUNING || bestC > ( 1 + COST_MIN_EPS ) * costs . getMinCosts ( ) ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum ▁ opening : ▁ " + Arrays . toString ( bestPlan ) + " ▁ - > ▁ " + bestC ) ; if ( ! evalRemain ) LOG . warn ( " Skip ▁ enum ▁ for ▁ | M | = " + Mlen + " , ▁ C = " + bestC + " , ▁ Cmin = " + costs . getMinCosts ( ) ) ; PartitionSignature pKey = null ; if ( probePlanCache ( matPoints ) ) { pKey = new PartitionSignature ( part , matPoints . length , costs , C0 , CN ) ; boolean [ ] plan = getPlan ( pKey ) ; if ( plan != null ) { Statistics . incrementCodegenEnumAllP ( ( rgraph != null || ! STRUCTURAL_PRUNING ) ? len : 0 ) ; return plan ; } } for ( long i = 1 ; i < len - 1 & evalRemain ; i ++ ) { boolean [ ] plan = createAssignment ( Mlen , off , i ) ; long pskip = 0 ; if ( STRUCTURAL_PRUNING && ( rgraph != null ) && rgraph . isCutSet ( plan ) ) { pskip = rgraph . getNumSkipPlans ( plan ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Structural ▁ pruning ▁ for ▁ cut ▁ set : ▁ " + rgraph . getCutSet ( plan ) ) ; SubProblem [ ] prob = rgraph . getSubproblems ( plan ) ; for ( int j = 0 ; j < prob . length ; j ++ ) { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Subproblem ▁ " + ( j + 1 ) + " / " + prob . length + " : ▁ " + prob [ j ] ) ; boolean [ ] bestTmp = enumPlans ( memo , part , costs , null , prob [ j ] . freeMat , prob [ j ] . offset ) ; LibSpoofPrimitives . vectWrite ( bestTmp , plan , prob [ j ] . freePos ) ; } } else if ( COST_PRUNING ) { double lbC = getLowerBoundCosts ( part , matPoints , memo , costs , plan ) ; if ( lbC >= bestC ) { long skip = getNumSkipPlans ( plan ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Skip ▁ " + skip + " ▁ plans ▁ ( by ▁ cost ) . " ) ; i += skip - 1 ; continue ; } } double pCBound = COST_PRUNING ? bestC : Double . MAX_VALUE ; double C = getPlanCost ( memo , part , matPoints , plan , costs . _computeCosts , pCBound ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ " + Arrays . toString ( plan ) + " ▁ - > ▁ " + C ) ; numEvalPartPlans += ( C == Double . POSITIVE_INFINITY ) ? 1 : 0 ; numEvalPlans ++ ; if ( bestPlan == null || C < bestC ) { bestC = C ; bestPlan = plan ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Found ▁ new ▁ best ▁ plan . " ) ; } i += pskip ; if ( pskip != 0 && LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Skip ▁ " + pskip + " ▁ plans ▁ ( by ▁ structure ) . " ) ; } if ( ConfigurationManager . isStatistics ( ) ) { Statistics . incrementCodegenEnumAllP ( ( rgraph != null || ! STRUCTURAL_PRUNING ) ? len : 0 ) ; Statistics . incrementCodegenEnumEval ( numEvalPlans ) ; Statistics . incrementCodegenEnumEvalP ( numEvalPartPlans ) ; } if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Optimal ▁ plan : ▁ " + Arrays . toString ( bestPlan ) ) ; if ( probePlanCache ( matPoints ) ) putPlan ( pKey , bestPlan ) ; return ( bestPlan == null ) ? new boolean [ Mlen ] : Arrays . copyOfRange ( bestPlan , off , bestPlan . length ) ; }
deroneriksson/incubator-systemml | private void createAndAddMultiAggPlans ( CPlanMemoTable memo , ArrayList < Hop > roots ) { HashSet < Long > fullAggs = new HashSet < > ( ) ; Hop . resetVisitStatus ( roots ) ; for ( Hop hop : roots ) rCollectFullAggregates ( hop , fullAggs ) ; Hop . resetVisitStatus ( roots ) ; fullAggs . removeIf ( p -> memo . contains ( p , TemplateType . MAGG ) ) ; if ( fullAggs . size ( ) <= 1 ) return ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Found ▁ across - partition ▁ ua ( RC ) ▁ aggregations : ▁ " + Arrays . toString ( fullAggs . toArray ( new Long [ 0 ] ) ) ) ; } List < AggregateInfo > aggInfos = new ArrayList < > ( ) ; for ( Long hopID : fullAggs ) { Hop aggHop = memo . getHopRefs ( ) . get ( hopID ) ; AggregateInfo tmp = new AggregateInfo ( aggHop ) ; for ( int i = 0 ; i < aggHop . getInput ( ) . size ( ) ; i ++ ) { Hop c = HopRewriteUtils . isMatrixMultiply ( aggHop ) && i == 0 ? aggHop . getInput ( ) . get ( 0 ) . getInput ( ) . get ( 0 ) : aggHop . getInput ( ) . get ( i ) ; rExtractAggregateInfo ( memo , c , tmp , TemplateType . CELL ) ; } if ( tmp . _fusedInputs . isEmpty ( ) ) { if ( HopRewriteUtils . isMatrixMultiply ( aggHop ) ) { tmp . addFusedInput ( aggHop . getInput ( ) . get ( 0 ) . getInput ( ) . get ( 0 ) . getHopID ( ) ) ; tmp . addFusedInput ( aggHop . getInput ( ) . get ( 1 ) . getHopID ( ) ) ; } else tmp . addFusedInput ( aggHop . getInput ( ) . get ( 0 ) . getHopID ( ) ) ; } aggInfos . add ( tmp ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Extracted ▁ across - partition ▁ ua ( RC ) ▁ aggregation ▁ info : ▁ " ) ; for ( AggregateInfo info : aggInfos ) LOG . trace ( info ) ; } aggInfos = aggInfos . stream ( ) . sorted ( Comparator . comparing ( a -> a . _inputAggs . size ( ) ) ) . collect ( Collectors . toList ( ) ) ; boolean converged = false ; while ( ! converged ) { AggregateInfo merged = null ; for ( int i = 0 ; i < aggInfos . size ( ) ; i ++ ) { AggregateInfo current = aggInfos . get ( i ) ; for ( int j = i + 1 ; j < aggInfos . size ( ) ; j ++ ) { AggregateInfo that = aggInfos . get ( j ) ; if ( current . isMergable ( that ) ) { merged = current . merge ( that ) ; aggInfos . remove ( j ) ; j -- ; } } } converged = ( merged == null ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Merged ▁ across - partition ▁ ua ( RC ) ▁ aggregation ▁ info : ▁ " ) ; for ( AggregateInfo info : aggInfos ) LOG . trace ( info ) ; } for ( AggregateInfo info : aggInfos ) { if ( info . _aggregates . size ( ) <= 1 ) continue ; Long [ ] aggs = info . _aggregates . keySet ( ) . toArray ( new Long [ 0 ] ) ; MemoTableEntry me = new MemoTableEntry ( TemplateType . MAGG , aggs [ 0 ] , aggs [ 1 ] , ( aggs . length > 2 ) ? aggs [ 2 ] : - 1 , aggs . length ) ; for ( int i = 0 ; i < aggs . length ; i ++ ) { memo . add ( memo . getHopRefs ( ) . get ( aggs [ i ] ) , me ) ; addBestPlan ( aggs [ i ] , me ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Added ▁ multiagg * ▁ plan : ▁ " + aggs [ i ] + " ▁ " + me ) ; } } }
deroneriksson/incubator-systemml | private double getPlanCost ( CPlanMemoTable memo , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan , HashMap < Long , Double > computeCosts , final double costBound ) { HashSet < VisitMarkCost > visited = new HashSet < > ( ) ; double costs = 0 ; int rem = part . getRoots ( ) . size ( ) ; for ( Long hopID : part . getRoots ( ) ) { costs += rGetPlanCosts ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; if ( costs >= costBound && -- rem > 0 ) return Double . POSITIVE_INFINITY ; } return costs ; }
deroneriksson/incubator-systemml | private double rGetPlanCosts ( CPlanMemoTable memo , final Hop current , HashSet < VisitMarkCost > visited , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan , HashMap < Long , Double > computeCosts , CostVector costsCurrent , TemplateType currentType , final double costBound ) { final long currentHopId = current . getHopID ( ) ; if ( ! visited . add ( new VisitMarkCost ( currentHopId , ( costsCurrent == null || currentType == TemplateType . MAGG ) ? - 1 : costsCurrent . ID ) ) ) return 0 ; MemoTableEntry best = null ; boolean opened = ( currentType == null ) ; if ( memo . contains ( currentHopId ) ) { if ( currentType == null ) { for ( MemoTableEntry me : memo . get ( currentHopId ) ) best = me . isValid ( ) && hasNoRefToMatPoint ( currentHopId , me , matPoints , plan ) && BasicPlanComparator . icompare ( me , best ) < 0 ? me : best ; opened = true ; } else { for ( MemoTableEntry me : memo . get ( currentHopId ) ) best = ( me . type == currentType || me . type == TemplateType . CELL ) && hasNoRefToMatPoint ( currentHopId , me , matPoints , plan ) && TypedPlanComparator . icompare ( me , best , currentType ) < 0 ? me : best ; } } CostVector costVect = ! opened ? costsCurrent : new CostVector ( getSize ( current ) ) ; double costs = 0 ; if ( opened && best != null && best . type == TemplateType . MAGG ) { if ( best . input1 == currentHopId ) for ( int i = 1 ; i < 3 ; i ++ ) { if ( ! best . isPlanRef ( i ) ) continue ; costs += rGetPlanCosts ( memo , memo . getHopRefs ( ) . get ( best . input ( i ) ) , visited , part , matPoints , plan , computeCosts , costVect , TemplateType . MAGG , costBound - costs ) ; if ( costs >= costBound ) return Double . POSITIVE_INFINITY ; } else return 0 ; } if ( computeCosts . containsKey ( currentHopId ) ) costVect . computeCosts += computeCosts . get ( currentHopId ) ; for ( int i = 0 ; i < current . getInput ( ) . size ( ) ; i ++ ) { Hop c = current . getInput ( ) . get ( i ) ; if ( best != null && best . isPlanRef ( i ) ) costs += rGetPlanCosts ( memo , c , visited , part , matPoints , plan , computeCosts , costVect , best . type , costBound - costs ) ; else if ( best != null && isImplicitlyFused ( current , i , best . type ) ) costVect . addInputSize ( c . getInput ( ) . get ( 0 ) . getHopID ( ) , getSize ( c ) ) ; else { if ( part . getPartition ( ) . contains ( c . getHopID ( ) ) ) costs += rGetPlanCosts ( memo , c , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; if ( costVect != null && c . getDataType ( ) . isMatrix ( ) ) costVect . addInputSize ( c . getHopID ( ) , getSize ( c ) ) ; } if ( costs >= costBound ) return Double . POSITIVE_INFINITY ; } if ( opened ) { double memInputs = sumInputMemoryEstimates ( memo , costVect ) ; double tmpCosts = costVect . outSize * 8 / WRITE_BANDWIDTH_MEM + Math . max ( memInputs / READ_BANDWIDTH_MEM , costVect . computeCosts / COMPUTE_BANDWIDTH ) ; if ( memInputs > OptimizerUtils . getLocalMemBudget ( ) ) tmpCosts += costVect . getSideInputSize ( ) * 8 / READ_BANDWIDTH_BROADCAST ; Hop driver = memo . getHopRefs ( ) . get ( costVect . getMaxInputSizeHopID ( ) ) ; if ( best != null && best . type == TemplateType . OUTER ) tmpCosts *= driver . dimsKnown ( true ) ? driver . getSparsity ( ) : SPARSE_SAFE_SPARSITY_EST ; else if ( memInputs <= OptimizerUtils . getLocalMemBudget ( ) && sumTmpInputOutputSize ( memo , costVect ) * 8 > LazyWriteBuffer . getWriteBufferLimit ( ) ) tmpCosts += costVect . outSize * 8 / WRITE_BANDWIDTH_IO ; costs += tmpCosts ; if ( LOG . isTraceEnabled ( ) ) { String type = ( best != null ) ? best . type . name ( ) : " HOP " ; LOG . trace ( " Cost ▁ vector ▁ ( " + type + " ▁ " + currentHopId + " ) : ▁ " + costVect + " ▁ - > ▁ " + tmpCosts ) ; } } else if ( part . getExtConsumed ( ) . contains ( current . getHopID ( ) ) ) { costs += rGetPlanCosts ( memo , current , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; } if ( costs < 0 || Double . isNaN ( costs ) || Double . isInfinite ( costs ) ) throw new RuntimeException ( " Wrong ▁ cost ▁ estimate : ▁ " + costs ) ; return costs ; }
deroneriksson/incubator-systemml | public CostVector ( double outputSize ) { ID = COST_ID . getNextID ( ) ; outSize = outputSize ; }
deroneriksson/incubator-systemml | public void addInputSize ( long hopID , double inputSize ) { inSizes . put ( hopID , inputSize ) ; }
deroneriksson/incubator-systemml | public double getInputSize ( ) { return inSizes . values ( ) . stream ( ) . mapToDouble ( d -> d . doubleValue ( ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | public double getSideInputSize ( ) { double max = getMaxInputSize ( ) ; return inSizes . values ( ) . stream ( ) . filter ( d -> d < max ) . mapToDouble ( d -> d . doubleValue ( ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | public double getMaxInputSize ( ) { return inSizes . values ( ) . stream ( ) . mapToDouble ( d -> d . doubleValue ( ) ) . max ( ) . orElse ( 0 ) ; }
deroneriksson/incubator-systemml | public long getMaxInputSizeHopID ( ) { long id = - 1 ; double max = 0 ; for ( Entry < Long , Double > e : inSizes . entrySet ( ) ) if ( max < e . getValue ( ) ) { id = e . getKey ( ) ; max = e . getValue ( ) ; } return id ; }
deroneriksson/incubator-systemml | @ Override public String toString ( ) { return " [ " + outSize + " , ▁ " + computeCosts + " , ▁ { " + Arrays . toString ( inSizes . keySet ( ) . toArray ( new Long [ 0 ] ) ) + " , ▁ " + Arrays . toString ( inSizes . values ( ) . toArray ( new Double [ 0 ] ) ) + " } ] " ; }
deroneriksson/incubator-systemml | public StaticCosts ( HashMap < Long , Double > allComputeCosts , double computeCost , double readCost , double writeCost , double minSparsity ) { _computeCosts = allComputeCosts ; _compute = computeCost ; _read = readCost ; _write = writeCost ; _minSparsity = minSparsity ; }
deroneriksson/incubator-systemml | public double getMinCosts ( ) { return Math . max ( _read , _compute ) + _write ; }
deroneriksson/incubator-systemml | public AggregateInfo ( Hop aggregate ) { _aggregates = new HashMap < > ( ) ; _aggregates . put ( aggregate . getHopID ( ) , aggregate ) ; }
deroneriksson/incubator-systemml | public void addInputAggregate ( long hopID ) { _inputAggs . add ( hopID ) ; }
deroneriksson/incubator-systemml | public void addFusedInput ( long hopID ) { _fusedInputs . add ( hopID ) ; }
deroneriksson/incubator-systemml | public boolean isMergable ( AggregateInfo that ) { boolean ret = _aggregates . size ( ) < 3 && _aggregates . size ( ) + that . _aggregates . size ( ) <= 3 ; for ( Long hopID : that . _aggregates . keySet ( ) ) ret &= ! _inputAggs . contains ( hopID ) ; for ( Long hopID : _aggregates . keySet ( ) ) ret &= ! that . _inputAggs . contains ( hopID ) ; ret &= ! CollectionUtils . intersection ( _fusedInputs , that . _fusedInputs ) . isEmpty ( ) ; Hop in1 = _aggregates . values ( ) . iterator ( ) . next ( ) ; Hop in2 = that . _aggregates . values ( ) . iterator ( ) . next ( ) ; return ret && HopRewriteUtils . isEqualSize ( in1 . getInput ( ) . get ( HopRewriteUtils . isMatrixMultiply ( in1 ) ? 1 : 0 ) , in2 . getInput ( ) . get ( HopRewriteUtils . isMatrixMultiply ( in2 ) ? 1 : 0 ) ) ; }
deroneriksson/incubator-systemml | public AggregateInfo merge ( AggregateInfo that ) { _aggregates . putAll ( that . _aggregates ) ; _inputAggs . addAll ( that . _inputAggs ) ; _fusedInputs . addAll ( that . _fusedInputs ) ; return this ; }
deroneriksson/incubator-systemml | @ Override public String toString ( ) { return " [ " + Arrays . toString ( _aggregates . keySet ( ) . toArray ( new Long [ 0 ] ) ) + " : ▁ " + " { " + Arrays . toString ( _inputAggs . toArray ( new Long [ 0 ] ) ) + " } , " + " { " + Arrays . toString ( _fusedInputs . toArray ( new Long [ 0 ] ) ) + " } ] " ; }
deroneriksson/incubator-systemml | public PartitionSignature ( PlanPartition part , int M , StaticCosts costs , double cP0 , double cPN ) { partNodes = part . getPartition ( ) . size ( ) ; inputNodes = part . getInputs ( ) . size ( ) ; rootNodes = part . getRoots ( ) . size ( ) ; matPoints = M ; cCompute = costs . _compute ; cRead = costs . _read ; cWrite = costs . _write ; cPlan0 = cP0 ; cPlanN = cPN ; }
deroneriksson/incubator-systemml | @ Override public int hashCode ( ) { return UtilFunctions . intHashCode ( Arrays . hashCode ( new int [ ] { partNodes , inputNodes , rootNodes , matPoints } ) , Arrays . hashCode ( new double [ ] { cCompute , cRead , cWrite , cPlan0 , cPlanN } ) ) ; }
deroneriksson/incubator-systemml | @ Override public boolean equals ( Object o ) { if ( ! ( o instanceof PartitionSignature ) ) return false ; PartitionSignature that = ( PartitionSignature ) o ; return partNodes == that . partNodes && inputNodes == that . inputNodes && rootNodes == that . rootNodes && matPoints == that . matPoints && cCompute == that . cCompute && cRead == that . cRead && cWrite == that . cWrite && cPlan0 == that . cPlan0 && cPlanN == that . cPlanN ; }
iavanish/CollegePal | public NewResource ( ) { }
iavanish/CollegePal | public void makeNotes ( ) { }
iavanish/CollegePal | public void takeSnapshot ( ) { }
iavanish/CollegePal | public void uploadResource ( ) { }
iavanish/CollegePal | public void makePublic ( ) { }
iavanish/CollegePal | public void makePrivate ( ) { }
iavanish/CollegePal | public void updateDetails ( ) { }
demonyan/douban-movie | public RecommendMovieAdapter ( RecyclerView view , Collection < SimpleSubjectBean > datas ) { super ( view , datas , R . layout . item_simple_movie_layout ) ; setOnItemClickListener ( ( View v , Object data , int position ) -> { if ( mCallback != null ) { SimpleSubjectBean bean = ( SimpleSubjectBean ) data ; String url = ImageUtil . getDisplayImage ( mContext , bean . images ) ; mCallback . onItemClick ( bean . id , url , true ) ; } } ) ; }
demonyan/douban-movie | public void setOnItemClickListener ( OnItemClickListener listener ) { mCallback = listener ; }
demonyan/douban-movie | public void update ( List < SimpleSubjectBean > data ) { super . update ( data ) ; }
demonyan/douban-movie | @ Override public void convert ( BaseRecyclerHolder holder , SimpleSubjectBean item , int position , boolean isScrolling ) { holder . setText ( R . id . tv_item_simple_movie_text , item . title ) ; holder . setImageFromEntity ( R . id . iv_item_simple_movie_image , item . images ) ; }
rokn/Count_Words_2015 | public DOMSource ( ) { }
rokn/Count_Words_2015 | public DOMSource ( Node n ) { setNode ( n ) ; }
rokn/Count_Words_2015 | public DOMSource ( Node node , String systemID ) { setNode ( node ) ; setSystemId ( systemID ) ; }
rokn/Count_Words_2015 | public void setNode ( Node node ) { this . node = node ; }
rokn/Count_Words_2015 | public Node getNode ( ) { return node ; }
rokn/Count_Words_2015 | public void setSystemId ( String systemID ) { this . systemID = systemID ; }
rokn/Count_Words_2015 | public String getSystemId ( ) { return this . systemID ; }
Lexine/rootbeer1 | public StringArrayTest1RunOnGpu ( String [ ] src , String [ ] dst , int i ) { m_source = src ; m_ret = dst ; m_index = i ; }
Lexine/rootbeer1 | public void gpuMethod ( ) { String str = " york " ; for ( int i = 0 ; i < m_source . length ; ++ i ) { str = m_source [ i ] + str ; } m_ret [ m_index ] = str ; }
Lexine/rootbeer1 | public String [ ] getResult ( ) { return m_ret ; }
oehme/analysing-gradle-performance | @ Test public void testProperty0 ( ) { String value = " value " ; objectUnderTest . setProperty0 ( value ) ; assertEquals ( value , objectUnderTest . getProperty0 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty1 ( ) { String value = " value " ; objectUnderTest . setProperty1 ( value ) ; assertEquals ( value , objectUnderTest . getProperty1 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty2 ( ) { String value = " value " ; objectUnderTest . setProperty2 ( value ) ; assertEquals ( value , objectUnderTest . getProperty2 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty3 ( ) { String value = " value " ; objectUnderTest . setProperty3 ( value ) ; assertEquals ( value , objectUnderTest . getProperty3 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty4 ( ) { String value = " value " ; objectUnderTest . setProperty4 ( value ) ; assertEquals ( value , objectUnderTest . getProperty4 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty5 ( ) { String value = " value " ; objectUnderTest . setProperty5 ( value ) ; assertEquals ( value , objectUnderTest . getProperty5 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty6 ( ) { String value = " value " ; objectUnderTest . setProperty6 ( value ) ; assertEquals ( value , objectUnderTest . getProperty6 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty7 ( ) { String value = " value " ; objectUnderTest . setProperty7 ( value ) ; assertEquals ( value , objectUnderTest . getProperty7 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty8 ( ) { String value = " value " ; objectUnderTest . setProperty8 ( value ) ; assertEquals ( value , objectUnderTest . getProperty8 ( ) ) ; }
oehme/analysing-gradle-performance | @ Test public void testProperty9 ( ) { String value = " value " ; objectUnderTest . setProperty9 ( value ) ; assertEquals ( value , objectUnderTest . getProperty9 ( ) ) ; }
congwiny/mysticker | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_sticker ) ; FrameLayout frameLayout = ( FrameLayout ) findViewById ( R . id . sticker_container ) ; mStickerContainer = new EditStickerContainer ( this ) ; frameLayout . addView ( mStickerContainer ) ; }
congwiny/mysticker | @ Override public void onBackPressed ( ) { super . onBackPressed ( ) ; Log . e ( TAG , " onBackPressed " ) ; }
congwiny/mysticker | @ Override public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK ) { if ( mStickerContainer . onBackPressed ( ) ) { return true ; } else { return super . onKeyDown ( keyCode , event ) ; } } return super . onKeyDown ( keyCode , event ) ; }
CyberdyneOfCerrado/Pechincha | public Lance ( ) { }
CyberdyneOfCerrado/Pechincha | public Lance ( int idleilao , int idusuario , float lance ) { this . idleilao = idleilao ; this . idusuario = idusuario ; this . lance = lance ; }
CyberdyneOfCerrado/Pechincha | public int getPk ( ) { return this . pk ; }
CyberdyneOfCerrado/Pechincha | public int getIdLeilao ( ) { return this . idleilao ; }
CyberdyneOfCerrado/Pechincha | public int getIdUsuario ( ) { return this . idusuario ; }
CyberdyneOfCerrado/Pechincha | public float getLance ( ) { return this . lance ; }
CyberdyneOfCerrado/Pechincha | public void setPk ( int pk ) { this . pk = pk ; }
CyberdyneOfCerrado/Pechincha | public void setIdLeilao ( int idleilao ) { this . idleilao = idleilao ; }
CyberdyneOfCerrado/Pechincha | public void setIdusuario ( int idusuario ) { this . idusuario = idusuario ; }
CyberdyneOfCerrado/Pechincha | public void setLance ( float lance ) { this . lance = lance ; }
pfrank13/spring-cloud-contract | public FraudCheck ( ) { }
pfrank13/spring-cloud-contract | public String getClientPesel ( ) { return clientPesel ; }
pfrank13/spring-cloud-contract | public void setClientPesel ( String clientPesel ) { this . clientPesel = clientPesel ; }
pfrank13/spring-cloud-contract | public BigDecimal getLoanAmount ( ) { return loanAmount ; }
pfrank13/spring-cloud-contract | public void setLoanAmount ( BigDecimal loanAmount ) { this . loanAmount = loanAmount ; }
MohammedHammam/camel | public char getFileSeparator ( ) { return File . separatorChar ; }
MohammedHammam/camel | public GenericFile < T > copyFrom ( GenericFile < T > source ) { GenericFile < T > result ; try { result = source . getClass ( ) . newInstance ( ) ; } catch ( Exception e ) { throw ObjectHelper . wrapRuntimeCamelException ( e ) ; } result . setCopyFromAbsoluteFilePath ( source . getAbsoluteFilePath ( ) ) ; result . setEndpointPath ( source . getEndpointPath ( ) ) ; result . setAbsolute ( source . isAbsolute ( ) ) ; result . setDirectory ( source . isDirectory ( ) ) ; result . setAbsoluteFilePath ( source . getAbsoluteFilePath ( ) ) ; result . setRelativeFilePath ( source . getRelativeFilePath ( ) ) ; result . setFileName ( source . getFileName ( ) ) ; result . setFileNameOnly ( source . getFileNameOnly ( ) ) ; result . setFileLength ( source . getFileLength ( ) ) ; result . setLastModified ( source . getLastModified ( ) ) ; result . setFile ( source . getFile ( ) ) ; result . setBody ( source . getBody ( ) ) ; result . setBinding ( source . getBinding ( ) ) ; result . setCharset ( source . getCharset ( ) ) ; copyFromPopulateAdditional ( source , result ) ; return result ; }
MohammedHammam/camel | public void copyFromPopulateAdditional ( GenericFile < T > source , GenericFile < T > result ) { }
MohammedHammam/camel | public void bindToExchange ( Exchange exchange ) { Map < String , Object > headers ; exchange . setProperty ( FileComponent . FILE_EXCHANGE_FILE , this ) ; GenericFileMessage < T > msg = new GenericFileMessage < T > ( this ) ; if ( exchange . hasOut ( ) ) { headers = exchange . getOut ( ) . hasHeaders ( ) ? exchange . getOut ( ) . getHeaders ( ) : null ; exchange . setOut ( msg ) ; } else { headers = exchange . getIn ( ) . hasHeaders ( ) ? exchange . getIn ( ) . getHeaders ( ) : null ; exchange . setIn ( msg ) ; } if ( headers != null ) { msg . setHeaders ( headers ) ; msg . removeHeaders ( " CamelFile * " ) ; } populateHeaders ( msg ) ; }
MohammedHammam/camel | public void populateHeaders ( GenericFileMessage < T > message ) { if ( message != null ) { message . setHeader ( Exchange . FILE_NAME_ONLY , getFileNameOnly ( ) ) ; message . setHeader ( Exchange . FILE_NAME , getFileName ( ) ) ; message . setHeader ( Exchange . FILE_NAME_CONSUMED , getFileName ( ) ) ; message . setHeader ( " CamelFileAbsolute " , isAbsolute ( ) ) ; message . setHeader ( " CamelFileAbsolutePath " , getAbsoluteFilePath ( ) ) ; if ( file instanceof File ) { File f = ( File ) file ; Path path = f . toPath ( ) ; try { message . setHeader ( Exchange . FILE_CONTENT_TYPE , Files . probeContentType ( path ) ) ; } catch ( Exception ex ) { } } if ( isAbsolute ( ) ) { message . setHeader ( Exchange . FILE_PATH , getAbsoluteFilePath ( ) ) ; } else { String path = normalizePathToProtocol ( getEndpointPath ( ) + File . separator + getRelativeFilePath ( ) ) ; message . setHeader ( Exchange . FILE_PATH , path ) ; } message . setHeader ( " CamelFileRelativePath " , getRelativeFilePath ( ) ) ; message . setHeader ( Exchange . FILE_PARENT , getParent ( ) ) ; if ( getFileLength ( ) >= 0 ) { message . setHeader ( Exchange . FILE_LENGTH , getFileLength ( ) ) ; } if ( getLastModified ( ) > 0 ) { message . setHeader ( Exchange . FILE_LAST_MODIFIED , getLastModified ( ) ) ; } } }
MohammedHammam/camel | protected boolean isAbsolute ( String name ) { return FileUtil . isAbsolute ( new File ( name ) ) ; }
MohammedHammam/camel | protected String normalizePath ( String name ) { return FileUtil . normalizePath ( name ) ; }
MohammedHammam/camel | public void changeFileName ( String newName ) { LOG . trace ( " Changing ▁ name ▁ to : ▁ { } " , newName ) ; String newFileName = FileUtil . normalizePath ( newName ) ; String newEndpointPath = FileUtil . normalizePath ( endpointPath ) ; LOG . trace ( " Normalized ▁ endpointPath : ▁ { } " , newEndpointPath ) ; LOG . trace ( " Normalized ▁ newFileName : ▁ ( ) " , newFileName ) ; File file = new File ( newFileName ) ; if ( ! absolute ) { if ( ObjectHelper . isNotEmpty ( newEndpointPath ) && newFileName . startsWith ( newEndpointPath ) ) { if ( newEndpointPath . endsWith ( " " + File . separatorChar ) ) { newFileName = ObjectHelper . after ( newFileName , newEndpointPath ) ; } else { newFileName = ObjectHelper . after ( newFileName , newEndpointPath + File . separatorChar ) ; } file = new File ( newFileName ) ; } } setFileNameOnly ( file . getName ( ) ) ; setFileName ( file . getName ( ) ) ; if ( file . getParent ( ) != null ) { setRelativeFilePath ( file . getParent ( ) + getFileSeparator ( ) + file . getName ( ) ) ; } else { setRelativeFilePath ( file . getName ( ) ) ; } if ( isAbsolute ( newFileName ) ) { setAbsolute ( true ) ; setAbsoluteFilePath ( newFileName ) ; } else { setAbsolute ( false ) ; String path = ObjectHelper . isEmpty ( endpointPath ) ? " " : endpointPath + getFileSeparator ( ) ; setAbsoluteFilePath ( path + getRelativeFilePath ( ) ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " FileNameOnly : ▁ { } " , getFileNameOnly ( ) ) ; LOG . trace ( " FileName : ▁ { } " , getFileName ( ) ) ; LOG . trace ( " Absolute : ▁ { } " , isAbsolute ( ) ) ; LOG . trace ( " Relative ▁ path : ▁ { } " , getRelativeFilePath ( ) ) ; LOG . trace ( " Absolute ▁ path : ▁ { } " , getAbsoluteFilePath ( ) ) ; LOG . trace ( " Name ▁ changed ▁ to : ▁ { } " , this ) ; } }
MohammedHammam/camel | public String getRelativeFilePath ( ) { return relativeFilePath ; }
MohammedHammam/camel | public void setRelativeFilePath ( String relativeFilePath ) { this . relativeFilePath = normalizePathToProtocol ( relativeFilePath ) ; }
MohammedHammam/camel | public String getFileName ( ) { return fileName ; }
MohammedHammam/camel | public void setFileName ( String fileName ) { this . fileName = normalizePathToProtocol ( fileName ) ; }
MohammedHammam/camel | public long getFileLength ( ) { return fileLength ; }
MohammedHammam/camel | public void setFileLength ( long fileLength ) { this . fileLength = fileLength ; }
MohammedHammam/camel | public long getLastModified ( ) { return lastModified ; }
MohammedHammam/camel | public void setLastModified ( long lastModified ) { this . lastModified = lastModified ; }
MohammedHammam/camel | public String getCharset ( ) { return charset ; }
MohammedHammam/camel | public void setCharset ( String charset ) { this . charset = charset ; }
MohammedHammam/camel | @ Override public T getFile ( ) { return file ; }
MohammedHammam/camel | public void setFile ( T file ) { this . file = file ; }
MohammedHammam/camel | public Object getBody ( ) { return getBinding ( ) . getBody ( this ) ; }
MohammedHammam/camel | public void setBody ( Object os ) { getBinding ( ) . setBody ( this , os ) ; }
MohammedHammam/camel | public String getParent ( ) { String parent ; if ( isAbsolute ( ) ) { String name = getAbsoluteFilePath ( ) ; File path = new File ( name ) ; parent = path . getParent ( ) ; } else { String name = getRelativeFilePath ( ) ; File path ; if ( name != null ) { path = new File ( endpointPath , name ) ; } else { path = new File ( endpointPath ) ; } parent = path . getParent ( ) ; } return normalizePathToProtocol ( parent ) ; }
MohammedHammam/camel | public GenericFileBinding < T > getBinding ( ) { if ( binding == null ) { binding = new GenericFileDefaultBinding < T > ( ) ; } return binding ; }
MohammedHammam/camel | public void setBinding ( GenericFileBinding < T > binding ) { this . binding = binding ; }
MohammedHammam/camel | public void setAbsoluteFilePath ( String absoluteFilePath ) { this . absoluteFilePath = normalizePathToProtocol ( absoluteFilePath ) ; }
MohammedHammam/camel | public String getAbsoluteFilePath ( ) { return absoluteFilePath ; }
MohammedHammam/camel | public boolean isAbsolute ( ) { return absolute ; }
MohammedHammam/camel | public void setAbsolute ( boolean absolute ) { this . absolute = absolute ; }
MohammedHammam/camel | public String getEndpointPath ( ) { return endpointPath ; }
MohammedHammam/camel | public void setEndpointPath ( String endpointPath ) { this . endpointPath = normalizePathToProtocol ( endpointPath ) ; }
MohammedHammam/camel | public String getFileNameOnly ( ) { return fileNameOnly ; }
MohammedHammam/camel | public void setFileNameOnly ( String fileNameOnly ) { this . fileNameOnly = fileNameOnly ; }
MohammedHammam/camel | public boolean isDirectory ( ) { return directory ; }
MohammedHammam/camel | public void setDirectory ( boolean directory ) { this . directory = directory ; }
MohammedHammam/camel | public String getCopyFromAbsoluteFilePath ( ) { return copyFromAbsoluteFilePath ; }
MohammedHammam/camel | public void setCopyFromAbsoluteFilePath ( String copyFromAbsoluteFilePath ) { this . copyFromAbsoluteFilePath = copyFromAbsoluteFilePath ; }
MohammedHammam/camel | protected String normalizePathToProtocol ( String path ) { if ( ObjectHelper . isEmpty ( path ) ) { return path ; } path = path . replace ( ' / ' , getFileSeparator ( ) ) ; path = path . replace ( ' \ \' , getFileSeparator ( ) ) ; return path ; }
MohammedHammam/camel | @ Override public String toString ( ) { return " GenericFile [ " + ( absolute ? absoluteFilePath : relativeFilePath ) + " ] " ; }
jamesweeYan/linkssq | public Funnel ( ) { }
jamesweeYan/linkssq | public int getId ( ) { return this . id ; }
jamesweeYan/linkssq | public void setId ( int id ) { this . id = id ; }
jamesweeYan/linkssq | public String getR01 ( ) { return this . r01 ; }
jamesweeYan/linkssq | public void setR01 ( String r01 ) { this . r01 = r01 ; }
jamesweeYan/linkssq | public String getR02 ( ) { return this . r02 ; }
jamesweeYan/linkssq | public void setR02 ( String r02 ) { this . r02 = r02 ; }
jamesweeYan/linkssq | public String getR03 ( ) { return this . r03 ; }
jamesweeYan/linkssq | public void setR03 ( String r03 ) { this . r03 = r03 ; }
jamesweeYan/linkssq | public String getR04 ( ) { return this . r04 ; }
jamesweeYan/linkssq | public void setR04 ( String r04 ) { this . r04 = r04 ; }
jamesweeYan/linkssq | public String getR05 ( ) { return this . r05 ; }
jamesweeYan/linkssq | public void setR05 ( String r05 ) { this . r05 = r05 ; }
jamesweeYan/linkssq | public String getR06 ( ) { return this . r06 ; }
jamesweeYan/linkssq | public void setR06 ( String r06 ) { this . r06 = r06 ; }
jamesweeYan/linkssq | public String getR07 ( ) { return this . r07 ; }
jamesweeYan/linkssq | public void setR07 ( String r07 ) { this . r07 = r07 ; }
jamesweeYan/linkssq | public String getR08 ( ) { return this . r08 ; }
jamesweeYan/linkssq | public void setR08 ( String r08 ) { this . r08 = r08 ; }
jamesweeYan/linkssq | public String getR09 ( ) { return this . r09 ; }
jamesweeYan/linkssq | public void setR09 ( String r09 ) { this . r09 = r09 ; }
jamesweeYan/linkssq | public String getR10 ( ) { return this . r10 ; }
jamesweeYan/linkssq | public void setR10 ( String r10 ) { this . r10 = r10 ; }
jamesweeYan/linkssq | public String getR11 ( ) { return this . r11 ; }
jamesweeYan/linkssq | public void setR11 ( String r11 ) { this . r11 = r11 ; }
jamesweeYan/linkssq | public String getR12 ( ) { return this . r12 ; }
jamesweeYan/linkssq | public void setR12 ( String r12 ) { this . r12 = r12 ; }
jamesweeYan/linkssq | public String getR13 ( ) { return this . r13 ; }
jamesweeYan/linkssq | public void setR13 ( String r13 ) { this . r13 = r13 ; }
jamesweeYan/linkssq | public String getR14 ( ) { return this . r14 ; }
jamesweeYan/linkssq | public void setR14 ( String r14 ) { this . r14 = r14 ; }
jamesweeYan/linkssq | public String getR15 ( ) { return this . r15 ; }
jamesweeYan/linkssq | public void setR15 ( String r15 ) { this . r15 = r15 ; }
jamesweeYan/linkssq | public String getR16 ( ) { return this . r16 ; }
jamesweeYan/linkssq | public void setR16 ( String r16 ) { this . r16 = r16 ; }
jamesweeYan/linkssq | public String getR17 ( ) { return this . r17 ; }
jamesweeYan/linkssq | public void setR17 ( String r17 ) { this . r17 = r17 ; }
jamesweeYan/linkssq | public String getR18 ( ) { return this . r18 ; }
jamesweeYan/linkssq | public void setR18 ( String r18 ) { this . r18 = r18 ; }
jamesweeYan/linkssq | public String getR19 ( ) { return this . r19 ; }
jamesweeYan/linkssq | public void setR19 ( String r19 ) { this . r19 = r19 ; }
jamesweeYan/linkssq | public String getR20 ( ) { return this . r20 ; }
jamesweeYan/linkssq | public void setR20 ( String r20 ) { this . r20 = r20 ; }
jamesweeYan/linkssq | public String getR21 ( ) { return this . r21 ; }
jamesweeYan/linkssq | public void setR21 ( String r21 ) { this . r21 = r21 ; }
jamesweeYan/linkssq | public String getR22 ( ) { return this . r22 ; }
jamesweeYan/linkssq | public void setR22 ( String r22 ) { this . r22 = r22 ; }
jamesweeYan/linkssq | public String getR23 ( ) { return this . r23 ; }
jamesweeYan/linkssq | public void setR23 ( String r23 ) { this . r23 = r23 ; }
jamesweeYan/linkssq | public String getR24 ( ) { return this . r24 ; }
jamesweeYan/linkssq | public void setR24 ( String r24 ) { this . r24 = r24 ; }
jamesweeYan/linkssq | public String getR25 ( ) { return this . r25 ; }
jamesweeYan/linkssq | public void setR25 ( String r25 ) { this . r25 = r25 ; }
jamesweeYan/linkssq | public String getR26 ( ) { return this . r26 ; }
jamesweeYan/linkssq | public void setR26 ( String r26 ) { this . r26 = r26 ; }
jamesweeYan/linkssq | public String getR27 ( ) { return this . r27 ; }
jamesweeYan/linkssq | public void setR27 ( String r27 ) { this . r27 = r27 ; }
jamesweeYan/linkssq | public String getR28 ( ) { return this . r28 ; }
jamesweeYan/linkssq | public void setR28 ( String r28 ) { this . r28 = r28 ; }
jamesweeYan/linkssq | public String getR29 ( ) { return this . r29 ; }
jamesweeYan/linkssq | public void setR29 ( String r29 ) { this . r29 = r29 ; }
jamesweeYan/linkssq | public String getR30 ( ) { return this . r30 ; }
jamesweeYan/linkssq | public void setR30 ( String r30 ) { this . r30 = r30 ; }
jamesweeYan/linkssq | public String getR31 ( ) { return this . r31 ; }
jamesweeYan/linkssq | public void setR31 ( String r31 ) { this . r31 = r31 ; }
jamesweeYan/linkssq | public String getR32 ( ) { return this . r32 ; }
jamesweeYan/linkssq | public void setR32 ( String r32 ) { this . r32 = r32 ; }
jamesweeYan/linkssq | public String getR33 ( ) { return this . r33 ; }
jamesweeYan/linkssq | public void setR33 ( String r33 ) { this . r33 = r33 ; }
l-dobrev/activemq-artemis | @ Override public Object createObject ( ) throws Exception { RemoveSubscriptionInfo info = new RemoveSubscriptionInfo ( ) ; populateObject ( info ) ; return info ; }
l-dobrev/activemq-artemis | @ Override protected void populateObject ( Object object ) throws Exception { super . populateObject ( object ) ; RemoveSubscriptionInfo info = ( RemoveSubscriptionInfo ) object ; info . setConnectionId ( createConnectionId ( " ConnectionId : 1" ) ) ; info . setSubscriptionName ( " SubcriptionName : 2" ) ; info . setClientId ( " ClientId : 3" ) ; }
yv84/yolo-avenger | public String getReturn ( ) { return _return ; }
yv84/yolo-avenger | public void setReturn ( String value ) { this . _return = value ; }
freeVM/freeVM | public MsgClassGenerator ( ) { super ( ) ; }
freeVM/freeVM | public void generate ( File dir , File props ) { File modProps ; if ( props == null ) { modProps = getResourceFromJar ( ENTRY_PATH , MODULES_PROPERTIES_NAME ) ; modProps . deleteOnExit ( ) ; } else { modProps = props ; } dstDir = ( dir != null ) ? dir : new File ( userDir ) ; Properties prs = null ; FileInputStream fis = null ; int fails = 0 ; try { fis = new FileInputStream ( modProps ) ; } catch ( FileNotFoundException e ) { logMessage ( " Generation ▁ error : ▁ Specified ▁ file ▁ " + modProps . getPath ( ) + " ▁ doesn ' t ▁ exist ! " ) ; return ; } prs = new Properties ( ) ; try { prs . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { logMessage ( " \n Generation ▁ error : " + e . getMessage ( ) ) ; } logMessage ( " \n Generation ▁ started : \n " ) ; logMessage ( " Modules ▁ generation ▁ status : ▁ " ) ; Enumeration en = prs . keys ( ) ; while ( en . hasMoreElements ( ) ) { String modName = prs . getProperty ( ( String ) en . nextElement ( ) ) . trim ( ) ; logMessage ( modName + " ▁ : ▁ " ) ; try { createSourceFromTemplate ( modName , MESSAGES_TEMPLATE_FILE , MSG_class_NAME ) ; createMsgsProperties ( modName ) ; } catch ( Exception e ) { logMessage ( " error : ▁ " + e . getMessage ( ) ) ; fails ++ ; continue ; } logMessage ( " completed " ) ; } if ( fails == 0 ) { logMessage ( " \n Generation ▁ successfully ▁ finished ! " ) ; } else { logMessage ( " \n Generation ▁ finished ▁ with ▁ " + fails + " ▁ fails ! " ) ; logMessage ( " See ▁ output ▁ information ▁ for ▁ details ! " ) ; } }
freeVM/freeVM | private void templateReplace ( File srcFile , File dstFile , String moduleName ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( srcFile ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( dstFile ) ) ; String s ; while ( ( s = br . readLine ( ) ) != null ) { if ( s . indexOf ( MODULE_PATTERN_NAME ) != - 1 ) { s = s . replaceAll ( MODULE_PATTERN_NAME , moduleName ) ; } bw . write ( s ) ; bw . newLine ( ) ; } bw . close ( ) ; br . close ( ) ; }
freeVM/freeVM | private void createSourceFromTemplate ( String moduleName , File srcFile , String templateName ) throws Exception { File dstFile = new File ( getDstDir ( moduleName ) , templateName + JAVA_EXT_NAME ) ; dstFile . createNewFile ( ) ; logMessage ( " \t " + dstFile . getAbsolutePath ( ) ) ; templateReplace ( srcFile , dstFile , getPackageFromModule ( moduleName ) ) ; }
freeVM/freeVM | private void createMsgsProperties ( String moduleName ) throws Exception { File dstFile = new File ( getDstDir ( moduleName ) , MSGS_PROPERTIES_NAME ) ; if ( dstFile . exists ( ) ) { return ; } FileInputStream fis = new FileInputStream ( MSGS_PROPERTIES_FILE ) ; FileOutputStream fos = new FileOutputStream ( dstFile ) ; byte [ ] data = new byte [ fis . available ( ) ] ; while ( fis . read ( data ) > 0 ) { fos . write ( data ) ; data = new byte [ fis . available ( ) ] ; } fis . close ( ) ; fos . close ( ) ; logMessage ( " \t " + dstFile . getAbsolutePath ( ) ) ; }
freeVM/freeVM | private File getDstDir ( String moduleName ) { File srcDir = new File ( dstDir , " modules / " + moduleName + " / src / main / java " ) ; if ( srcDir . exists ( ) && srcDir . isDirectory ( ) ) { String names [ ] = srcDir . list ( new FilenameCommonFilter ( ) ) ; if ( names . length > 0 ) { srcDir = new File ( srcDir , names [ 0 ] ) ; } } String path = " org / apache / harmony / " + getPackageFromModule ( moduleName ) + " / internal / nls " ; File dir = new File ( srcDir , path ) ; dir . mkdirs ( ) ; return dir ; }
freeVM/freeVM | private String getPackageFromModule ( String modName ) { String pkgName = modName ; return pkgName . replaceAll ( " [ _ , - ] " , " " ) ; }
freeVM/freeVM | public boolean accept ( File dir , String name ) { if ( name . equals ( " common " ) ) { File commonDir = new File ( dir , name ) ; return commonDir . isDirectory ( ) ; } return false ; }
BBK-PiJ-2015-74/Java-Exercises-week-6-onwards | public String getLastName ( ) { return lastName ; }
BBK-PiJ-2015-74/Java-Exercises-week-6-onwards | public void setLastName ( String lastName ) { this . lastName = lastName ; }
fogbeam/Heceta_solr | public SpellCheckResponse ( NamedList < NamedList < Object > > spellInfo ) { NamedList < Object > sugg = spellInfo . get ( " suggestions " ) ; if ( sugg == null ) { correctlySpelled = true ; return ; } for ( int i = 0 ; i < sugg . size ( ) ; i ++ ) { String n = sugg . getName ( i ) ; if ( " correctlySpelled " . equals ( n ) ) { correctlySpelled = ( Boolean ) sugg . getVal ( i ) ; } else if ( " collationInternalRank " . equals ( n ) ) { } else if ( " collation " . equals ( n ) ) { List < Object > collationInfo = sugg . getAll ( n ) ; collations = new ArrayList < Collation > ( collationInfo . size ( ) ) ; for ( Object o : collationInfo ) { if ( o instanceof String ) { collations . add ( new Collation ( ) . setCollationQueryString ( ( String ) o ) ) ; } else if ( o instanceof NamedList ) { @ SuppressWarnings ( " unchecked " ) NamedList < Object > expandedCollation = ( NamedList < Object > ) o ; String collationQuery = ( String ) expandedCollation . get ( " collationQuery " ) ; int hits = ( Integer ) expandedCollation . get ( " hits " ) ; @ SuppressWarnings ( " unchecked " ) NamedList < String > misspellingsAndCorrections = ( NamedList < String > ) expandedCollation . get ( " misspellingsAndCorrections " ) ; Collation collation = new Collation ( ) ; collation . setCollationQueryString ( collationQuery ) ; collation . setNumberOfHits ( hits ) ; for ( int ii = 0 ; ii < misspellingsAndCorrections . size ( ) ; ii ++ ) { String misspelling = misspellingsAndCorrections . getName ( ii ) ; String correction = misspellingsAndCorrections . getVal ( ii ) ; collation . addMisspellingsAndCorrection ( new Correction ( misspelling , correction ) ) ; } collations . add ( collation ) ; } else { throw new AssertionError ( " Should ▁ get ▁ Lists ▁ of ▁ Strings ▁ or ▁ List ▁ of ▁ NamedLists ▁ here . " ) ; } } } else { @ SuppressWarnings ( " unchecked " ) Suggestion s = new Suggestion ( n , ( NamedList < Object > ) sugg . getVal ( i ) ) ; suggestionMap . put ( n , s ) ; suggestions . add ( s ) ; } } }
fogbeam/Heceta_solr | public boolean isCorrectlySpelled ( ) { return correctlySpelled ; }
fogbeam/Heceta_solr | public List < Suggestion > getSuggestions ( ) { return suggestions ; }
fogbeam/Heceta_solr | public Map < String , Suggestion > getSuggestionMap ( ) { return suggestionMap ; }
fogbeam/Heceta_solr | public Suggestion getSuggestion ( String token ) { return suggestionMap . get ( token ) ; }
fogbeam/Heceta_solr | public String getFirstSuggestion ( String token ) { Suggestion s = suggestionMap . get ( token ) ; if ( s == null || s . getAlternatives ( ) . isEmpty ( ) ) return null ; return s . getAlternatives ( ) . get ( 0 ) ; }
fogbeam/Heceta_solr | public String getCollatedResult ( ) { return collations == null || collations . size ( ) == 0 ? null : collations . get ( 0 ) . collationQueryString ; }
fogbeam/Heceta_solr | public List < Collation > getCollatedResults ( ) { return collations ; }
fogbeam/Heceta_solr | public Suggestion ( String token , NamedList < Object > suggestion ) { this . token = token ; for ( int i = 0 ; i < suggestion . size ( ) ; i ++ ) { String n = suggestion . getName ( i ) ; if ( " numFound " . equals ( n ) ) { numFound = ( Integer ) suggestion . getVal ( i ) ; } else if ( " startOffset " . equals ( n ) ) { startOffset = ( Integer ) suggestion . getVal ( i ) ; } else if ( " endOffset " . equals ( n ) ) { endOffset = ( Integer ) suggestion . getVal ( i ) ; } else if ( " origFreq " . equals ( n ) ) { originalFrequency = ( Integer ) suggestion . getVal ( i ) ; } else if ( " suggestion " . equals ( n ) ) { @ SuppressWarnings ( " unchecked " ) List list = ( List ) suggestion . getVal ( i ) ; if ( list . size ( ) > 0 && list . get ( 0 ) instanceof NamedList ) { @ SuppressWarnings ( " unchecked " ) List < NamedList > extended = ( List < NamedList > ) list ; alternativeFrequencies = new ArrayList < Integer > ( ) ; for ( NamedList nl : extended ) { alternatives . add ( ( String ) nl . get ( " word " ) ) ; alternativeFrequencies . add ( ( Integer ) nl . get ( " freq " ) ) ; } } else { @ SuppressWarnings ( " unchecked " ) List < String > alts = ( List < String > ) list ; alternatives . addAll ( alts ) ; } } } }
fogbeam/Heceta_solr | public String getToken ( ) { return token ; }
fogbeam/Heceta_solr | public int getNumFound ( ) { return numFound ; }
fogbeam/Heceta_solr | public int getStartOffset ( ) { return startOffset ; }
fogbeam/Heceta_solr | public int getEndOffset ( ) { return endOffset ; }
fogbeam/Heceta_solr | public int getOriginalFrequency ( ) { return originalFrequency ; }
fogbeam/Heceta_solr | public List < String > getAlternatives ( ) { return alternatives ; }
fogbeam/Heceta_solr | public List < Integer > getAlternativeFrequencies ( ) { return alternativeFrequencies ; }
fogbeam/Heceta_solr | @ Deprecated public List < String > getSuggestions ( ) { return alternatives ; }
fogbeam/Heceta_solr | @ Deprecated public List < Integer > getSuggestionFrequencies ( ) { return alternativeFrequencies ; }
fogbeam/Heceta_solr | public long getNumberOfHits ( ) { return numberOfHits ; }
fogbeam/Heceta_solr | public void setNumberOfHits ( long numberOfHits ) { this . numberOfHits = numberOfHits ; }
fogbeam/Heceta_solr | public String getCollationQueryString ( ) { return collationQueryString ; }
fogbeam/Heceta_solr | public Collation setCollationQueryString ( String collationQueryString ) { this . collationQueryString = collationQueryString ; return this ; }
fogbeam/Heceta_solr | public List < Correction > getMisspellingsAndCorrections ( ) { return misspellingsAndCorrections ; }
fogbeam/Heceta_solr | public Collation addMisspellingsAndCorrection ( Correction correction ) { this . misspellingsAndCorrections . add ( correction ) ; return this ; }
fogbeam/Heceta_solr | public Correction ( String original , String correction ) { this . original = original ; this . correction = correction ; }
fogbeam/Heceta_solr | public String getOriginal ( ) { return original ; }
fogbeam/Heceta_solr | public void setOriginal ( String original ) { this . original = original ; }
fogbeam/Heceta_solr | public String getCorrection ( ) { return correction ; }
fogbeam/Heceta_solr | public void setCorrection ( String correction ) { this . correction = correction ; }
Susankha/developer-studio | private HTPackageImpl ( ) { super ( eNS_URI , HTFactory . eINSTANCE ) ; }
Susankha/developer-studio | public EClass getDocumentRoot ( ) { return documentRootEClass ; }
Susankha/developer-studio | public EAttribute getDocumentRoot_Mixed ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_XMLNSPrefixMap ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_XSISchemaLocation ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_BusinessAdministrators ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_ExcludedOwners ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getDocumentRoot_Group ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Groups ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_HumanInteractions ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Import ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 8 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_LogicalPeopleGroups ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 9 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Notification ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 10 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Notifications ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 11 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_OrganizationalEntity ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 12 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_PeopleAssignments ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 13 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_PotentialOwners ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 14 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Priority ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 15 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Recipients ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 16 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Task ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 17 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_TaskInitiator ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 18 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Tasks ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 19 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_TaskStakeholders ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 20 ) ; }
Susankha/developer-studio | public EAttribute getDocumentRoot_User ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 21 ) ; }
Susankha/developer-studio | public EReference getDocumentRoot_Users ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 22 ) ; }
Susankha/developer-studio | public EClass getTArgument ( ) { return tArgumentEClass ; }
Susankha/developer-studio | public EAttribute getTArgument_ExpressionLanguage ( ) { return ( EAttribute ) tArgumentEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTArgument_Name ( ) { return ( EAttribute ) tArgumentEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTBooleanExpr ( ) { return tBooleanExprEClass ; }
Susankha/developer-studio | public EClass getTDeadline ( ) { return tDeadlineEClass ; }
Susankha/developer-studio | public EReference getTDeadline_For ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTDeadline_Until ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTDeadline_Escalation ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTDeadlineExpr ( ) { return tDeadlineExprEClass ; }
Susankha/developer-studio | public EClass getTDeadlines ( ) { return tDeadlinesEClass ; }
Susankha/developer-studio | public EReference getTDeadlines_StartDeadline ( ) { return ( EReference ) tDeadlinesEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTDeadlines_CompletionDeadline ( ) { return ( EReference ) tDeadlinesEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTDelegation ( ) { return tDelegationEClass ; }
Susankha/developer-studio | public EReference getTDelegation_From ( ) { return ( EReference ) tDelegationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTDelegation_PotentialDelegatees ( ) { return ( EAttribute ) tDelegationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTDescription ( ) { return tDescriptionEClass ; }
Susankha/developer-studio | public EAttribute getTDescription_ContentType ( ) { return ( EAttribute ) tDescriptionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTDescription_Lang ( ) { return ( EAttribute ) tDescriptionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTDocumentation ( ) { return tDocumentationEClass ; }
Susankha/developer-studio | public EAttribute getTDocumentation_Mixed ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTDocumentation_Any ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTDocumentation_Lang ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTDurationExpr ( ) { return tDurationExprEClass ; }
Susankha/developer-studio | public EClass getTEscalation ( ) { return tEscalationEClass ; }
Susankha/developer-studio | public EReference getTEscalation_Condition ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTEscalation_ToParts ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTEscalation_Notification ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTEscalation_LocalNotification ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTEscalation_Reassignment ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getTEscalation_Name ( ) { return ( EAttribute ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EClass getTExpression ( ) { return tExpressionEClass ; }
Susankha/developer-studio | public EAttribute getTExpression_Mixed ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTExpression_Any ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTExpression_ExpressionLanguage ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTExpression_AnyAttribute ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTExtensibleElements ( ) { return tExtensibleElementsEClass ; }
Susankha/developer-studio | public EReference getTExtensibleElements_Documentation ( ) { return ( EReference ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleElements_Any ( ) { return ( EAttribute ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleElements_AnyAttribute ( ) { return ( EAttribute ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTExtensibleMixedContentElements ( ) { return tExtensibleMixedContentElementsEClass ; }
Susankha/developer-studio | public EAttribute getTExtensibleMixedContentElements_Mixed ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTExtensibleMixedContentElements_Documentation ( ) { return ( EReference ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleMixedContentElements_Any ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTExtensibleMixedContentElements_AnyAttribute ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTExtension ( ) { return tExtensionEClass ; }
Susankha/developer-studio | public EAttribute getTExtension_MustUnderstand ( ) { return ( EAttribute ) tExtensionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTExtension_Namespace ( ) { return ( EAttribute ) tExtensionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTExtensions ( ) { return tExtensionsEClass ; }
Susankha/developer-studio | public EReference getTExtensions_Extension ( ) { return ( EReference ) tExtensionsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTFrom ( ) { return tFromEClass ; }
Susankha/developer-studio | public EReference getTFrom_Argument ( ) { return ( EReference ) tFromEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTFrom_Literal ( ) { return ( EReference ) tFromEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTFrom_ExpressionLanguage ( ) { return ( EAttribute ) tFromEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTFrom_LogicalPeopleGroup ( ) { return ( EAttribute ) tFromEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTGenericHumanRole ( ) { return tGenericHumanRoleEClass ; }
Susankha/developer-studio | public EReference getTGenericHumanRole_From ( ) { return ( EReference ) tGenericHumanRoleEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTGrouplist ( ) { return tGrouplistEClass ; }
Susankha/developer-studio | public EAttribute getTGrouplist_Group ( ) { return ( EAttribute ) tGrouplistEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTHumanInteractions ( ) { return tHumanInteractionsEClass ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Extensions ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Import ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_LogicalPeopleGroups ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Tasks ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTHumanInteractions_Notifications ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getTHumanInteractions_ExpressionLanguage ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EAttribute getTHumanInteractions_QueryLanguage ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EAttribute getTHumanInteractions_TargetNamespace ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
Susankha/developer-studio | public EClass getTImport ( ) { return tImportEClass ; }
Susankha/developer-studio | public EAttribute getTImport_ImportType ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTImport_Location ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTImport_Namespace ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLiteral ( ) { return tLiteralEClass ; }
Susankha/developer-studio | public EAttribute getTLiteral_Mixed ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTLiteral_Any ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTLiteral_AnyAttribute ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLocalNotification ( ) { return tLocalNotificationEClass ; }
Susankha/developer-studio | public EReference getTLocalNotification_Priority ( ) { return ( EReference ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTLocalNotification_PeopleAssignments ( ) { return ( EReference ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTLocalNotification_Reference ( ) { return ( EAttribute ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLogicalPeopleGroup ( ) { return tLogicalPeopleGroupEClass ; }
Susankha/developer-studio | public EReference getTLogicalPeopleGroup_Parameter ( ) { return ( EReference ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTLogicalPeopleGroup_Name ( ) { return ( EAttribute ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTLogicalPeopleGroup_Reference ( ) { return ( EAttribute ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EClass getTLogicalPeopleGroups ( ) { return tLogicalPeopleGroupsEClass ; }
Susankha/developer-studio | public EReference getTLogicalPeopleGroups_LogicalPeopleGroup ( ) { return ( EReference ) tLogicalPeopleGroupsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTNotification ( ) { return tNotificationEClass ; }
Susankha/developer-studio | public EReference getTNotification_Interface ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTNotification_Priority ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTNotification_PeopleAssignments ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTNotification_PresentationElements ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTNotification_Renderings ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EAttribute getTNotification_Name ( ) { return ( EAttribute ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EClass getTNotificationInterface ( ) { return tNotificationInterfaceEClass ; }
Susankha/developer-studio | public EAttribute getTNotificationInterface_Operation ( ) { return ( EAttribute ) tNotificationInterfaceEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTNotificationInterface_PortType ( ) { return ( EAttribute ) tNotificationInterfaceEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTNotifications ( ) { return tNotificationsEClass ; }
Susankha/developer-studio | public EReference getTNotifications_Notification ( ) { return ( EReference ) tNotificationsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTOrganizationalEntity ( ) { return tOrganizationalEntityEClass ; }
Susankha/developer-studio | public EReference getTOrganizationalEntity_Users ( ) { return ( EReference ) tOrganizationalEntityEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTOrganizationalEntity_Groups ( ) { return ( EReference ) tOrganizationalEntityEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTParameter ( ) { return tParameterEClass ; }
Susankha/developer-studio | public EAttribute getTParameter_Name ( ) { return ( EAttribute ) tParameterEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTParameter_Type ( ) { return ( EAttribute ) tParameterEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTPeopleAssignments ( ) { return tPeopleAssignmentsEClass ; }
Susankha/developer-studio | public EAttribute getTPeopleAssignments_GenericHumanRole ( ) { return ( EAttribute ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_PotentialOwners ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_ExcludedOwners ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_TaskInitiator ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_TaskStakeholders ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_BusinessAdministrators ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EReference getTPeopleAssignments_Recipients ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EClass getTPresentationElements ( ) { return tPresentationElementsEClass ; }
Susankha/developer-studio | public EReference getTPresentationElements_Name ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTPresentationElements_PresentationParameters ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTPresentationElements_Subject ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTPresentationElements_Description ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTPresentationParameter ( ) { return tPresentationParameterEClass ; }
Susankha/developer-studio | public EClass getTPresentationParameters ( ) { return tPresentationParametersEClass ; }
Susankha/developer-studio | public EReference getTPresentationParameters_PresentationParameter ( ) { return ( EReference ) tPresentationParametersEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTPresentationParameters_ExpressionLanguage ( ) { return ( EAttribute ) tPresentationParametersEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTPriority ( ) { return tPriorityEClass ; }
Susankha/developer-studio | public EClass getTQuery ( ) { return tQueryEClass ; }
Susankha/developer-studio | public EAttribute getTQuery_Mixed ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_Any ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_Part ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_QueryLanguage ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EAttribute getTQuery_AnyAttribute ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EClass getTReassignment ( ) { return tReassignmentEClass ; }
Susankha/developer-studio | public EReference getTReassignment_PotentialOwners ( ) { return ( EReference ) tReassignmentEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTRendering ( ) { return tRenderingEClass ; }
Susankha/developer-studio | public EAttribute getTRendering_Type ( ) { return ( EAttribute ) tRenderingEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTRenderings ( ) { return tRenderingsEClass ; }
Susankha/developer-studio | public EReference getTRenderings_Rendering ( ) { return ( EReference ) tRenderingsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTTask ( ) { return tTaskEClass ; }
Susankha/developer-studio | public EReference getTTask_Interface ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EReference getTTask_Priority ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EReference getTTask_PeopleAssignments ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EReference getTTask_Delegation ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EReference getTTask_PresentationElements ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
Susankha/developer-studio | public EReference getTTask_Outcome ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
Susankha/developer-studio | public EReference getTTask_SearchBy ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
Susankha/developer-studio | public EReference getTTask_Renderings ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
Susankha/developer-studio | public EReference getTTask_Deadlines ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 8 ) ; }
Susankha/developer-studio | public EAttribute getTTask_Name ( ) { return ( EAttribute ) tTaskEClass . getEStructuralFeatures ( ) . get ( 9 ) ; }
Susankha/developer-studio | public EClass getTTaskInterface ( ) { return tTaskInterfaceEClass ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_Operation ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_PortType ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_ResponseOperation ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
Susankha/developer-studio | public EAttribute getTTaskInterface_ResponsePortType ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
Susankha/developer-studio | public EClass getTTasks ( ) { return tTasksEClass ; }
Susankha/developer-studio | public EReference getTTasks_Task ( ) { return ( EReference ) tTasksEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTText ( ) { return tTextEClass ; }
Susankha/developer-studio | public EAttribute getTText_Lang ( ) { return ( EAttribute ) tTextEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTToPart ( ) { return tToPartEClass ; }
Susankha/developer-studio | public EAttribute getTToPart_ExpressionLanguage ( ) { return ( EAttribute ) tToPartEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EAttribute getTToPart_Name ( ) { return ( EAttribute ) tToPartEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
Susankha/developer-studio | public EClass getTToParts ( ) { return tToPartsEClass ; }
Susankha/developer-studio | public EReference getTToParts_ToPart ( ) { return ( EReference ) tToPartsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EClass getTUserlist ( ) { return tUserlistEClass ; }
Susankha/developer-studio | public EAttribute getTUserlist_User ( ) { return ( EAttribute ) tUserlistEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
Susankha/developer-studio | public EEnum getTBoolean ( ) { return tBooleanEEnum ; }
Susankha/developer-studio | public EEnum getTPotentialDelegatees ( ) { return tPotentialDelegateesEEnum ; }
Susankha/developer-studio | public EDataType getTBooleanObject ( ) { return tBooleanObjectEDataType ; }
Susankha/developer-studio | public EDataType getTGroup ( ) { return tGroupEDataType ; }
Susankha/developer-studio | public EDataType getTPotentialDelegateesObject ( ) { return tPotentialDelegateesObjectEDataType ; }
Susankha/developer-studio | public EDataType getTUser ( ) { return tUserEDataType ; }
Susankha/developer-studio | public HTFactory getHTFactory ( ) { return ( HTFactory ) getEFactoryInstance ( ) ; }
Susankha/developer-studio | public void createPackageContents ( ) { if ( isCreated ) return ; isCreated = true ; documentRootEClass = createEClass ( DOCUMENT_ROOT ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__MIXED ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__XMLNS_PREFIX_MAP ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__XSI_SCHEMA_LOCATION ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__BUSINESS_ADMINISTRATORS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__EXCLUDED_OWNERS ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__GROUP ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__GROUPS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__HUMAN_INTERACTIONS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__IMPORT ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__LOGICAL_PEOPLE_GROUPS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__NOTIFICATION ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__NOTIFICATIONS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__ORGANIZATIONAL_ENTITY ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__PEOPLE_ASSIGNMENTS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__POTENTIAL_OWNERS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__PRIORITY ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__RECIPIENTS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK_INITIATOR ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASKS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK_STAKEHOLDERS ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__USER ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__USERS ) ; tArgumentEClass = createEClass ( TARGUMENT ) ; createEAttribute ( tArgumentEClass , TARGUMENT__EXPRESSION_LANGUAGE ) ; createEAttribute ( tArgumentEClass , TARGUMENT__NAME ) ; tBooleanExprEClass = createEClass ( TBOOLEAN_EXPR ) ; tDeadlineEClass = createEClass ( TDEADLINE ) ; createEReference ( tDeadlineEClass , TDEADLINE__FOR ) ; createEReference ( tDeadlineEClass , TDEADLINE__UNTIL ) ; createEReference ( tDeadlineEClass , TDEADLINE__ESCALATION ) ; tDeadlineExprEClass = createEClass ( TDEADLINE_EXPR ) ; tDeadlinesEClass = createEClass ( TDEADLINES ) ; createEReference ( tDeadlinesEClass , TDEADLINES__START_DEADLINE ) ; createEReference ( tDeadlinesEClass , TDEADLINES__COMPLETION_DEADLINE ) ; tDelegationEClass = createEClass ( TDELEGATION ) ; createEReference ( tDelegationEClass , TDELEGATION__FROM ) ; createEAttribute ( tDelegationEClass , TDELEGATION__POTENTIAL_DELEGATEES ) ; tDescriptionEClass = createEClass ( TDESCRIPTION ) ; createEAttribute ( tDescriptionEClass , TDESCRIPTION__CONTENT_TYPE ) ; createEAttribute ( tDescriptionEClass , TDESCRIPTION__LANG ) ; tDocumentationEClass = createEClass ( TDOCUMENTATION ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__MIXED ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__ANY ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__LANG ) ; tDurationExprEClass = createEClass ( TDURATION_EXPR ) ; tEscalationEClass = createEClass ( TESCALATION ) ; createEReference ( tEscalationEClass , TESCALATION__CONDITION ) ; createEReference ( tEscalationEClass , TESCALATION__TO_PARTS ) ; createEReference ( tEscalationEClass , TESCALATION__NOTIFICATION ) ; createEReference ( tEscalationEClass , TESCALATION__LOCAL_NOTIFICATION ) ; createEReference ( tEscalationEClass , TESCALATION__REASSIGNMENT ) ; createEAttribute ( tEscalationEClass , TESCALATION__NAME ) ; tExpressionEClass = createEClass ( TEXPRESSION ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__MIXED ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__ANY ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__EXPRESSION_LANGUAGE ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__ANY_ATTRIBUTE ) ; tExtensibleElementsEClass = createEClass ( TEXTENSIBLE_ELEMENTS ) ; createEReference ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__DOCUMENTATION ) ; createEAttribute ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__ANY ) ; createEAttribute ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__ANY_ATTRIBUTE ) ; tExtensibleMixedContentElementsEClass = createEClass ( TEXTENSIBLE_MIXED_CONTENT_ELEMENTS ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__MIXED ) ; createEReference ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__DOCUMENTATION ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__ANY ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__ANY_ATTRIBUTE ) ; tExtensionEClass = createEClass ( TEXTENSION ) ; createEAttribute ( tExtensionEClass , TEXTENSION__MUST_UNDERSTAND ) ; createEAttribute ( tExtensionEClass , TEXTENSION__NAMESPACE ) ; tExtensionsEClass = createEClass ( TEXTENSIONS ) ; createEReference ( tExtensionsEClass , TEXTENSIONS__EXTENSION ) ; tFromEClass = createEClass ( TFROM ) ; createEReference ( tFromEClass , TFROM__ARGUMENT ) ; createEReference ( tFromEClass , TFROM__LITERAL ) ; createEAttribute ( tFromEClass , TFROM__EXPRESSION_LANGUAGE ) ; createEAttribute ( tFromEClass , TFROM__LOGICAL_PEOPLE_GROUP ) ; tGenericHumanRoleEClass = createEClass ( TGENERIC_HUMAN_ROLE ) ; createEReference ( tGenericHumanRoleEClass , TGENERIC_HUMAN_ROLE__FROM ) ; tGrouplistEClass = createEClass ( TGROUPLIST ) ; createEAttribute ( tGrouplistEClass , TGROUPLIST__GROUP ) ; tHumanInteractionsEClass = createEClass ( THUMAN_INTERACTIONS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__EXTENSIONS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__IMPORT ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__LOGICAL_PEOPLE_GROUPS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__TASKS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__NOTIFICATIONS ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__EXPRESSION_LANGUAGE ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__QUERY_LANGUAGE ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__TARGET_NAMESPACE ) ; tImportEClass = createEClass ( TIMPORT ) ; createEAttribute ( tImportEClass , TIMPORT__IMPORT_TYPE ) ; createEAttribute ( tImportEClass , TIMPORT__LOCATION ) ; createEAttribute ( tImportEClass , TIMPORT__NAMESPACE ) ; tLiteralEClass = createEClass ( TLITERAL ) ; createEAttribute ( tLiteralEClass , TLITERAL__MIXED ) ; createEAttribute ( tLiteralEClass , TLITERAL__ANY ) ; createEAttribute ( tLiteralEClass , TLITERAL__ANY_ATTRIBUTE ) ; tLocalNotificationEClass = createEClass ( TLOCAL_NOTIFICATION ) ; createEReference ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__PRIORITY ) ; createEReference ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__PEOPLE_ASSIGNMENTS ) ; createEAttribute ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__REFERENCE ) ; tLogicalPeopleGroupEClass = createEClass ( TLOGICAL_PEOPLE_GROUP ) ; createEReference ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__PARAMETER ) ; createEAttribute ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__NAME ) ; createEAttribute ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__REFERENCE ) ; tLogicalPeopleGroupsEClass = createEClass ( TLOGICAL_PEOPLE_GROUPS ) ; createEReference ( tLogicalPeopleGroupsEClass , TLOGICAL_PEOPLE_GROUPS__LOGICAL_PEOPLE_GROUP ) ; tNotificationEClass = createEClass ( TNOTIFICATION ) ; createEReference ( tNotificationEClass , TNOTIFICATION__INTERFACE ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PRIORITY ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PEOPLE_ASSIGNMENTS ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PRESENTATION_ELEMENTS ) ; createEReference ( tNotificationEClass , TNOTIFICATION__RENDERINGS ) ; createEAttribute ( tNotificationEClass , TNOTIFICATION__NAME ) ; tNotificationInterfaceEClass = createEClass ( TNOTIFICATION_INTERFACE ) ; createEAttribute ( tNotificationInterfaceEClass , TNOTIFICATION_INTERFACE__OPERATION ) ; createEAttribute ( tNotificationInterfaceEClass , TNOTIFICATION_INTERFACE__PORT_TYPE ) ; tNotificationsEClass = createEClass ( TNOTIFICATIONS ) ; createEReference ( tNotificationsEClass , TNOTIFICATIONS__NOTIFICATION ) ; tOrganizationalEntityEClass = createEClass ( TORGANIZATIONAL_ENTITY ) ; createEReference ( tOrganizationalEntityEClass , TORGANIZATIONAL_ENTITY__USERS ) ; createEReference ( tOrganizationalEntityEClass , TORGANIZATIONAL_ENTITY__GROUPS ) ; tParameterEClass = createEClass ( TPARAMETER ) ; createEAttribute ( tParameterEClass , TPARAMETER__NAME ) ; createEAttribute ( tParameterEClass , TPARAMETER__TYPE ) ; tPeopleAssignmentsEClass = createEClass ( TPEOPLE_ASSIGNMENTS ) ; createEAttribute ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__GENERIC_HUMAN_ROLE ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__POTENTIAL_OWNERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__EXCLUDED_OWNERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__TASK_INITIATOR ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__TASK_STAKEHOLDERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__BUSINESS_ADMINISTRATORS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__RECIPIENTS ) ; tPresentationElementsEClass = createEClass ( TPRESENTATION_ELEMENTS ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__NAME ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__PRESENTATION_PARAMETERS ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__SUBJECT ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__DESCRIPTION ) ; tPresentationParameterEClass = createEClass ( TPRESENTATION_PARAMETER ) ; tPresentationParametersEClass = createEClass ( TPRESENTATION_PARAMETERS ) ; createEReference ( tPresentationParametersEClass , TPRESENTATION_PARAMETERS__PRESENTATION_PARAMETER ) ; createEAttribute ( tPresentationParametersEClass , TPRESENTATION_PARAMETERS__EXPRESSION_LANGUAGE ) ; tPriorityEClass = createEClass ( TPRIORITY ) ; tQueryEClass = createEClass ( TQUERY ) ; createEAttribute ( tQueryEClass , TQUERY__MIXED ) ; createEAttribute ( tQueryEClass , TQUERY__ANY ) ; createEAttribute ( tQueryEClass , TQUERY__PART ) ; createEAttribute ( tQueryEClass , TQUERY__QUERY_LANGUAGE ) ; createEAttribute ( tQueryEClass , TQUERY__ANY_ATTRIBUTE ) ; tReassignmentEClass = createEClass ( TREASSIGNMENT ) ; createEReference ( tReassignmentEClass , TREASSIGNMENT__POTENTIAL_OWNERS ) ; tRenderingEClass = createEClass ( TRENDERING ) ; createEAttribute ( tRenderingEClass , TRENDERING__TYPE ) ; tRenderingsEClass = createEClass ( TRENDERINGS ) ; createEReference ( tRenderingsEClass , TRENDERINGS__RENDERING ) ; tTaskEClass = createEClass ( TTASK ) ; createEReference ( tTaskEClass , TTASK__INTERFACE ) ; createEReference ( tTaskEClass , TTASK__PRIORITY ) ; createEReference ( tTaskEClass , TTASK__PEOPLE_ASSIGNMENTS ) ; createEReference ( tTaskEClass , TTASK__DELEGATION ) ; createEReference ( tTaskEClass , TTASK__PRESENTATION_ELEMENTS ) ; createEReference ( tTaskEClass , TTASK__OUTCOME ) ; createEReference ( tTaskEClass , TTASK__SEARCH_BY ) ; createEReference ( tTaskEClass , TTASK__RENDERINGS ) ; createEReference ( tTaskEClass , TTASK__DEADLINES ) ; createEAttribute ( tTaskEClass , TTASK__NAME ) ; tTaskInterfaceEClass = createEClass ( TTASK_INTERFACE ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__OPERATION ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__PORT_TYPE ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__RESPONSE_OPERATION ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__RESPONSE_PORT_TYPE ) ; tTasksEClass = createEClass ( TTASKS ) ; createEReference ( tTasksEClass , TTASKS__TASK ) ; tTextEClass = createEClass ( TTEXT ) ; createEAttribute ( tTextEClass , TTEXT__LANG ) ; tToPartEClass = createEClass ( TTO_PART ) ; createEAttribute ( tToPartEClass , TTO_PART__EXPRESSION_LANGUAGE ) ; createEAttribute ( tToPartEClass , TTO_PART__NAME ) ; tToPartsEClass = createEClass ( TTO_PARTS ) ; createEReference ( tToPartsEClass , TTO_PARTS__TO_PART ) ; tUserlistEClass = createEClass ( TUSERLIST ) ; createEAttribute ( tUserlistEClass , TUSERLIST__USER ) ; tBooleanEEnum = createEEnum ( TBOOLEAN ) ; tPotentialDelegateesEEnum = createEEnum ( TPOTENTIAL_DELEGATEES ) ; tBooleanObjectEDataType = createEDataType ( TBOOLEAN_OBJECT ) ; tGroupEDataType = createEDataType ( TGROUP ) ; tPotentialDelegateesObjectEDataType = createEDataType ( TPOTENTIAL_DELEGATEES_OBJECT ) ; tUserEDataType = createEDataType ( TUSER ) ; }
Susankha/developer-studio | public void initializePackageContents ( ) { if ( isInitialized ) return ; isInitialized = true ; setName ( eNAME ) ; setNsPrefix ( eNS_PREFIX ) ; setNsURI ( eNS_URI ) ; XMLTypePackage theXMLTypePackage = ( XMLTypePackage ) EPackage . Registry . INSTANCE . getEPackage ( XMLTypePackage . eNS_URI ) ; XMLNamespacePackage theXMLNamespacePackage = ( XMLNamespacePackage ) EPackage . Registry . INSTANCE . getEPackage ( XMLNamespacePackage . eNS_URI ) ; tArgumentEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tBooleanExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tDeadlineEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDeadlineExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tDeadlinesEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDelegationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDescriptionEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tDurationExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tEscalationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tExtensionEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tExtensionsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tFromEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tGenericHumanRoleEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tHumanInteractionsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tImportEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLocalNotificationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLogicalPeopleGroupEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLogicalPeopleGroupsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationInterfaceEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tParameterEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tPeopleAssignmentsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPresentationElementsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPresentationParameterEClass . getESuperTypes ( ) . add ( this . getTParameter ( ) ) ; tPresentationParametersEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPriorityEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tReassignmentEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tRenderingEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tRenderingsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTaskEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTaskInterfaceEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTasksEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTextEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tToPartEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tToPartsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; initEClass ( documentRootEClass , DocumentRoot . class , " DocumentRoot " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getDocumentRoot_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , null , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_XMLNSPrefixMap ( ) , ecorePackage . getEStringToStringMapEntry ( ) , null , " xMLNSPrefixMap " , null , 0 , - 1 , null , IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_XSISchemaLocation ( ) , ecorePackage . getEStringToStringMapEntry ( ) , null , " xSISchemaLocation " , null , 0 , - 1 , null , IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_BusinessAdministrators ( ) , this . getTGenericHumanRole ( ) , null , " businessAdministrators " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_ExcludedOwners ( ) , this . getTGenericHumanRole ( ) , null , " excludedOwners " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getDocumentRoot_Group ( ) , this . getTGroup ( ) , " group " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Groups ( ) , this . getTGrouplist ( ) , null , " groups " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_HumanInteractions ( ) , this . getTHumanInteractions ( ) , null , " humanInteractions " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Import ( ) , this . getTImport ( ) , null , " import " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_LogicalPeopleGroups ( ) , this . getTLogicalPeopleGroups ( ) , null , " logicalPeopleGroups " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Notifications ( ) , this . getTNotifications ( ) , null , " notifications " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_OrganizationalEntity ( ) , this . getTOrganizationalEntity ( ) , null , " organizationalEntity " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Recipients ( ) , this . getTGenericHumanRole ( ) , null , " recipients " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Task ( ) , this . getTTask ( ) , null , " task " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_TaskInitiator ( ) , this . getTGenericHumanRole ( ) , null , " taskInitiator " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Tasks ( ) , this . getTTasks ( ) , null , " tasks " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_TaskStakeholders ( ) , this . getTGenericHumanRole ( ) , null , " taskStakeholders " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getDocumentRoot_User ( ) , this . getTUser ( ) , " user " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Users ( ) , this . getTUserlist ( ) , null , " users " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEClass ( tArgumentEClass , TArgument . class , " TArgument " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTArgument_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TArgument . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTArgument_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 0 , 1 , TArgument . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tBooleanExprEClass , TBooleanExpr . class , " TBooleanExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tDeadlineEClass , TDeadline . class , " TDeadline " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDeadline_For ( ) , this . getTDurationExpr ( ) , null , " for " , null , 0 , 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadline_Until ( ) , this . getTDeadlineExpr ( ) , null , " until " , null , 0 , 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadline_Escalation ( ) , this . getTEscalation ( ) , null , " escalation " , null , 0 , - 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDeadlineExprEClass , TDeadlineExpr . class , " TDeadlineExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tDeadlinesEClass , TDeadlines . class , " TDeadlines " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDeadlines_StartDeadline ( ) , this . getTDeadline ( ) , null , " startDeadline " , null , 0 , - 1 , TDeadlines . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadlines_CompletionDeadline ( ) , this . getTDeadline ( ) , null , " completionDeadline " , null , 0 , - 1 , TDeadlines . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDelegationEClass , TDelegation . class , " TDelegation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDelegation_From ( ) , this . getTFrom ( ) , null , " from " , null , 0 , 1 , TDelegation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDelegation_PotentialDelegatees ( ) , this . getTPotentialDelegatees ( ) , " potentialDelegatees " , null , 1 , 1 , TDelegation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDescriptionEClass , TDescription . class , " TDescription " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTDescription_ContentType ( ) , theXMLTypePackage . getString ( ) , " contentType " , null , 0 , 1 , TDescription . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDescription_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TDescription . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDocumentationEClass , TDocumentation . class , " TDocumentation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTDocumentation_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TDocumentation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDocumentation_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TDocumentation . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDocumentation_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TDocumentation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDurationExprEClass , TDurationExpr . class , " TDurationExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tEscalationEClass , TEscalation . class , " TEscalation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTEscalation_Condition ( ) , this . getTBooleanExpr ( ) , null , " condition " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_ToParts ( ) , this . getTToParts ( ) , null , " toParts " , null , 0 , - 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_LocalNotification ( ) , this . getTLocalNotification ( ) , null , " localNotification " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_Reassignment ( ) , this . getTReassignment ( ) , null , " reassignment " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTEscalation_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExpressionEClass , TExpression . class , " TExpression " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExpression_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExpression . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensibleElementsEClass , TExtensibleElements . class , " TExtensibleElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTExtensibleElements_Documentation ( ) , this . getTDocumentation ( ) , null , " documentation " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleElements_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleElements_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensibleMixedContentElementsEClass , TExtensibleMixedContentElements . class , " TExtensibleMixedContentElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExtensibleMixedContentElements_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TExtensibleMixedContentElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTExtensibleMixedContentElements_Documentation ( ) , this . getTDocumentation ( ) , null , " documentation " , null , 0 , - 1 , TExtensibleMixedContentElements . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleMixedContentElements_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExtensibleMixedContentElements . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleMixedContentElements_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExtensibleMixedContentElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensionEClass , TExtension . class , " TExtension " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExtension_MustUnderstand ( ) , this . getTBoolean ( ) , " mustUnderstand " , null , 1 , 1 , TExtension . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtension_Namespace ( ) , theXMLTypePackage . getAnyURI ( ) , " namespace " , null , 1 , 1 , TExtension . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensionsEClass , TExtensions . class , " TExtensions " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTExtensions_Extension ( ) , this . getTExtension ( ) , null , " extension " , null , 1 , - 1 , TExtensions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tFromEClass , TFrom . class , " TFrom " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTFrom_Argument ( ) , this . getTArgument ( ) , null , " argument " , null , 0 , - 1 , TFrom . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTFrom_Literal ( ) , this . getTLiteral ( ) , null , " literal " , null , 0 , 1 , TFrom . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTFrom_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TFrom . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTFrom_LogicalPeopleGroup ( ) , theXMLTypePackage . getQName ( ) , " logicalPeopleGroup " , null , 0 , 1 , TFrom . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tGenericHumanRoleEClass , TGenericHumanRole . class , " TGenericHumanRole " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTGenericHumanRole_From ( ) , this . getTFrom ( ) , null , " from " , null , 1 , 1 , TGenericHumanRole . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tGrouplistEClass , TGrouplist . class , " TGrouplist " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTGrouplist_Group ( ) , this . getTGroup ( ) , " group " , null , 0 , - 1 , TGrouplist . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tHumanInteractionsEClass , THumanInteractions . class , " THumanInteractions " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTHumanInteractions_Extensions ( ) , this . getTExtensions ( ) , null , " extensions " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Import ( ) , this . getTImport ( ) , null , " import " , null , 0 , - 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_LogicalPeopleGroups ( ) , this . getTLogicalPeopleGroups ( ) , null , " logicalPeopleGroups " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Tasks ( ) , this . getTTasks ( ) , null , " tasks " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Notifications ( ) , this . getTNotifications ( ) , null , " notifications " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_QueryLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " queryLanguage " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_TargetNamespace ( ) , theXMLTypePackage . getAnyURI ( ) , " targetNamespace " , null , 1 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tImportEClass , TImport . class , " TImport " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTImport_ImportType ( ) , theXMLTypePackage . getAnyURI ( ) , " importType " , null , 1 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTImport_Location ( ) , theXMLTypePackage . getAnyURI ( ) , " location " , null , 0 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTImport_Namespace ( ) , theXMLTypePackage . getAnyURI ( ) , " namespace " , null , 0 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLiteralEClass , TLiteral . class , " TLiteral " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTLiteral_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TLiteral . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLiteral_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TLiteral . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLiteral_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TLiteral . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLocalNotificationEClass , TLocalNotification . class , " TLocalNotification " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLocalNotification_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTLocalNotification_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 0 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLocalNotification_Reference ( ) , theXMLTypePackage . getQName ( ) , " reference " , null , 1 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLogicalPeopleGroupEClass , TLogicalPeopleGroup . class , " TLogicalPeopleGroup " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLogicalPeopleGroup_Parameter ( ) , this . getTParameter ( ) , null , " parameter " , null , 0 , - 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLogicalPeopleGroup_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLogicalPeopleGroup_Reference ( ) , theXMLTypePackage . getNCName ( ) , " reference " , null , 0 , 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLogicalPeopleGroupsEClass , TLogicalPeopleGroups . class , " TLogicalPeopleGroups " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLogicalPeopleGroups_LogicalPeopleGroup ( ) , this . getTLogicalPeopleGroup ( ) , null , " logicalPeopleGroup " , null , 1 , - 1 , TLogicalPeopleGroups . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationEClass , TNotification . class , " TNotification " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTNotification_Interface ( ) , this . getTNotificationInterface ( ) , null , " interface " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_PresentationElements ( ) , this . getTPresentationElements ( ) , null , " presentationElements " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_Renderings ( ) , this . getTRenderings ( ) , null , " renderings " , null , 0 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTNotification_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationInterfaceEClass , TNotificationInterface . class , " TNotificationInterface " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTNotificationInterface_Operation ( ) , theXMLTypePackage . getNCName ( ) , " operation " , null , 1 , 1 , TNotificationInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTNotificationInterface_PortType ( ) , theXMLTypePackage . getQName ( ) , " portType " , null , 1 , 1 , TNotificationInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationsEClass , TNotifications . class , " TNotifications " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTNotifications_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 1 , - 1 , TNotifications . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tOrganizationalEntityEClass , TOrganizationalEntity . class , " TOrganizationalEntity " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTOrganizationalEntity_Users ( ) , this . getTUserlist ( ) , null , " users " , null , 0 , 1 , TOrganizationalEntity . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTOrganizationalEntity_Groups ( ) , this . getTGrouplist ( ) , null , " groups " , null , 0 , 1 , TOrganizationalEntity . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tParameterEClass , TParameter . class , " TParameter " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTParameter_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TParameter . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTParameter_Type ( ) , theXMLTypePackage . getQName ( ) , " type " , null , 1 , 1 , TParameter . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPeopleAssignmentsEClass , TPeopleAssignments . class , " TPeopleAssignments " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTPeopleAssignments_GenericHumanRole ( ) , ecorePackage . getEFeatureMapEntry ( ) , " genericHumanRole " , null , 0 , - 1 , TPeopleAssignments . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_ExcludedOwners ( ) , this . getTGenericHumanRole ( ) , null , " excludedOwners " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_TaskInitiator ( ) , this . getTGenericHumanRole ( ) , null , " taskInitiator " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_TaskStakeholders ( ) , this . getTGenericHumanRole ( ) , null , " taskStakeholders " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_BusinessAdministrators ( ) , this . getTGenericHumanRole ( ) , null , " businessAdministrators " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_Recipients ( ) , this . getTGenericHumanRole ( ) , null , " recipients " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEClass ( tPresentationElementsEClass , TPresentationElements . class , " TPresentationElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTPresentationElements_Name ( ) , this . getTText ( ) , null , " name " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_PresentationParameters ( ) , this . getTPresentationParameters ( ) , null , " presentationParameters " , null , 0 , 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_Subject ( ) , this . getTText ( ) , null , " subject " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_Description ( ) , this . getTDescription ( ) , null , " description " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPresentationParameterEClass , TPresentationParameter . class , " TPresentationParameter " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tPresentationParametersEClass , TPresentationParameters . class , " TPresentationParameters " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTPresentationParameters_PresentationParameter ( ) , this . getTPresentationParameter ( ) , null , " presentationParameter " , null , 1 , - 1 , TPresentationParameters . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTPresentationParameters_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TPresentationParameters . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPriorityEClass , TPriority . class , " TPriority " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tQueryEClass , TQuery . class , " TQuery " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTQuery_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TQuery . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_Part ( ) , theXMLTypePackage . getAnySimpleType ( ) , " part " , null , 0 , 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_QueryLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " queryLanguage " , null , 0 , 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tReassignmentEClass , TReassignment . class , " TReassignment " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTReassignment_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 1 , 1 , TReassignment . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tRenderingEClass , TRendering . class , " TRendering " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTRendering_Type ( ) , theXMLTypePackage . getQName ( ) , " type " , null , 1 , 1 , TRendering . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tRenderingsEClass , TRenderings . class , " TRenderings " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTRenderings_Rendering ( ) , this . getTRendering ( ) , null , " rendering " , null , 1 , - 1 , TRenderings . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTaskEClass , TTask . class , " TTask " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTTask_Interface ( ) , this . getTTaskInterface ( ) , null , " interface " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Delegation ( ) , this . getTDelegation ( ) , null , " delegation " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_PresentationElements ( ) , this . getTPresentationElements ( ) , null , " presentationElements " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Outcome ( ) , this . getTQuery ( ) , null , " outcome " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_SearchBy ( ) , this . getTExpression ( ) , null , " searchBy " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Renderings ( ) , this . getTRenderings ( ) , null , " renderings " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Deadlines ( ) , this . getTDeadlines ( ) , null , " deadlines " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTask_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTaskInterfaceEClass , TTaskInterface . class , " TTaskInterface " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTTaskInterface_Operation ( ) , theXMLTypePackage . getNCName ( ) , " operation " , null , 1 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_PortType ( ) , theXMLTypePackage . getQName ( ) , " portType " , null , 1 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_ResponseOperation ( ) , theXMLTypePackage . getNCName ( ) , " responseOperation " , null , 0 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_ResponsePortType ( ) , theXMLTypePackage . getQName ( ) , " responsePortType " , null , 0 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTasksEClass , TTasks . class , " TTasks " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTTasks_Task ( ) , this . getTTask ( ) , null , " task " , null , 1 , - 1 , TTasks . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTextEClass , TText . class , " TText " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTText_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TText . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tToPartEClass , TToPart . class , " TToPart " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTToPart_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TToPart . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTToPart_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TToPart . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tToPartsEClass , TToParts . class , " TToParts " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTToParts_ToPart ( ) , this . getTToPart ( ) , null , " toPart " , null , 1 , - 1 , TToParts . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tUserlistEClass , TUserlist . class , " TUserlist " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTUserlist_User ( ) , this . getTUser ( ) , " user " , null , 0 , - 1 , TUserlist . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEEnum ( tBooleanEEnum , TBoolean . class , " TBoolean " ) ; addEEnumLiteral ( tBooleanEEnum , TBoolean . YES ) ; addEEnumLiteral ( tBooleanEEnum , TBoolean . NO ) ; initEEnum ( tPotentialDelegateesEEnum , TPotentialDelegatees . class , " TPotentialDelegatees " ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . ANYBODY ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . NOBODY ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . POTENTIAL_OWNERS ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . OTHER ) ; initEDataType ( tBooleanObjectEDataType , TBoolean . class , " TBooleanObject " , IS_SERIALIZABLE , IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tGroupEDataType , String . class , " TGroup " , IS_SERIALIZABLE , ! IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tPotentialDelegateesObjectEDataType , TPotentialDelegatees . class , " TPotentialDelegateesObject " , IS_SERIALIZABLE , IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tUserEDataType , String . class , " TUser " , IS_SERIALIZABLE , ! IS_GENERATED_INSTANCE_CLASS ) ; createResource ( eNS_URI ) ; createExtendedMetaDataAnnotations ( ) ; }
Susankha/developer-studio | protected void createExtendedMetaDataAnnotations ( ) { String source = " http : // / org / eclipse / emf / ecore / util / ExtendedMetaData " ; addAnnotation ( documentRootEClass , source , new String [ ] { " name " , " " , " kind " , " mixed " } ) ; addAnnotation ( getDocumentRoot_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getDocumentRoot_XMLNSPrefixMap ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " xmlns : prefix " } ) ; addAnnotation ( getDocumentRoot_XSISchemaLocation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " xsi : schemaLocation " } ) ; addAnnotation ( getDocumentRoot_BusinessAdministrators ( ) , source , new String [ ] { " kind " , " element " , " name " , " businessAdministrators " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_ExcludedOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " excludedOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Group ( ) , source , new String [ ] { " kind " , " element " , " name " , " group " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Groups ( ) , source , new String [ ] { " kind " , " element " , " name " , " groups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_HumanInteractions ( ) , source , new String [ ] { " kind " , " element " , " name " , " humanInteractions " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Import ( ) , source , new String [ ] { " kind " , " element " , " name " , " import " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_LogicalPeopleGroups ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Notifications ( ) , source , new String [ ] { " kind " , " element " , " name " , " notifications " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_OrganizationalEntity ( ) , source , new String [ ] { " kind " , " element " , " name " , " organizationalEntity " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Recipients ( ) , source , new String [ ] { " kind " , " element " , " name " , " recipients " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Task ( ) , source , new String [ ] { " kind " , " element " , " name " , " task " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_TaskInitiator ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskInitiator " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Tasks ( ) , source , new String [ ] { " kind " , " element " , " name " , " tasks " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_TaskStakeholders ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskStakeholders " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_User ( ) , source , new String [ ] { " kind " , " element " , " name " , " user " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Users ( ) , source , new String [ ] { " kind " , " element " , " name " , " users " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tArgumentEClass , source , new String [ ] { " name " , " tArgument " , " kind " , " mixed " } ) ; addAnnotation ( getTArgument_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTArgument_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tBooleanEEnum , source , new String [ ] { " name " , " tBoolean " } ) ; addAnnotation ( tBooleanExprEClass , source , new String [ ] { " name " , " tBoolean - expr " , " kind " , " mixed " } ) ; addAnnotation ( tBooleanObjectEDataType , source , new String [ ] { " name " , " tBoolean : Object " , " baseType " , " tBoolean " } ) ; addAnnotation ( tDeadlineEClass , source , new String [ ] { " name " , " tDeadline " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDeadline_For ( ) , source , new String [ ] { " kind " , " element " , " name " , " for " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadline_Until ( ) , source , new String [ ] { " kind " , " element " , " name " , " until " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadline_Escalation ( ) , source , new String [ ] { " kind " , " element " , " name " , " escalation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tDeadlineExprEClass , source , new String [ ] { " name " , " tDeadline - expr " , " kind " , " mixed " } ) ; addAnnotation ( tDeadlinesEClass , source , new String [ ] { " name " , " tDeadlines " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDeadlines_StartDeadline ( ) , source , new String [ ] { " kind " , " element " , " name " , " startDeadline " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadlines_CompletionDeadline ( ) , source , new String [ ] { " kind " , " element " , " name " , " completionDeadline " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tDelegationEClass , source , new String [ ] { " name " , " tDelegation " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDelegation_From ( ) , source , new String [ ] { " kind " , " element " , " name " , " from " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDelegation_PotentialDelegatees ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " potentialDelegatees " } ) ; addAnnotation ( tDescriptionEClass , source , new String [ ] { " name " , " tDescription " , " kind " , " mixed " } ) ; addAnnotation ( getTDescription_ContentType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " contentType " } ) ; addAnnotation ( getTDescription_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tDocumentationEClass , source , new String [ ] { " name " , " tDocumentation " , " kind " , " mixed " } ) ; addAnnotation ( getTDocumentation_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTDocumentation_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTDocumentation_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tDurationExprEClass , source , new String [ ] { " name " , " tDuration - expr " , " kind " , " mixed " } ) ; addAnnotation ( tEscalationEClass , source , new String [ ] { " name " , " tEscalation " , " kind " , " elementOnly " } ) ; addAnnotation ( getTEscalation_Condition ( ) , source , new String [ ] { " kind " , " element " , " name " , " condition " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_ToParts ( ) , source , new String [ ] { " kind " , " element " , " name " , " toParts " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_LocalNotification ( ) , source , new String [ ] { " kind " , " element " , " name " , " localNotification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Reassignment ( ) , source , new String [ ] { " kind " , " element " , " name " , " reassignment " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tExpressionEClass , source , new String [ ] { " name " , " tExpression " , " kind " , " mixed " } ) ; addAnnotation ( getTExpression_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTExpression_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTExpression_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTExpression_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 3" , " processing " , " lax " } ) ; addAnnotation ( tExtensibleElementsEClass , source , new String [ ] { " name " , " tExtensibleElements " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtensibleElements_Documentation ( ) , source , new String [ ] { " kind " , " element " , " name " , " documentation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTExtensibleElements_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTExtensibleElements_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " lax " } ) ; addAnnotation ( tExtensibleMixedContentElementsEClass , source , new String [ ] { " name " , " tExtensibleMixedContentElements " , " kind " , " mixed " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Documentation ( ) , source , new String [ ] { " kind " , " element " , " name " , " documentation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " skip " } ) ; addAnnotation ( getTExtensibleMixedContentElements_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 3" , " processing " , " lax " } ) ; addAnnotation ( tExtensionEClass , source , new String [ ] { " name " , " tExtension " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtension_MustUnderstand ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " mustUnderstand " } ) ; addAnnotation ( getTExtension_Namespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " namespace " } ) ; addAnnotation ( tExtensionsEClass , source , new String [ ] { " name " , " tExtensions " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtensions_Extension ( ) , source , new String [ ] { " kind " , " element " , " name " , " extension " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tFromEClass , source , new String [ ] { " name " , " tFrom " , " kind " , " mixed " } ) ; addAnnotation ( getTFrom_Argument ( ) , source , new String [ ] { " kind " , " element " , " name " , " argument " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTFrom_Literal ( ) , source , new String [ ] { " kind " , " element " , " name " , " literal " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTFrom_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTFrom_LogicalPeopleGroup ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " logicalPeopleGroup " } ) ; addAnnotation ( tGenericHumanRoleEClass , source , new String [ ] { " name " , " tGenericHumanRole " , " kind " , " elementOnly " } ) ; addAnnotation ( getTGenericHumanRole_From ( ) , source , new String [ ] { " kind " , " element " , " name " , " from " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tGroupEDataType , source , new String [ ] { " name " , " tGroup " , " baseType " , " http : // www . eclipse . org / emf / 2003 / XMLType # string " } ) ; addAnnotation ( tGrouplistEClass , source , new String [ ] { " name " , " tGrouplist " , " kind " , " elementOnly " } ) ; addAnnotation ( getTGrouplist_Group ( ) , source , new String [ ] { " kind " , " element " , " name " , " group " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tHumanInteractionsEClass , source , new String [ ] { " name " , " tHumanInteractions " , " kind " , " elementOnly " } ) ; addAnnotation ( getTHumanInteractions_Extensions ( ) , source , new String [ ] { " kind " , " element " , " name " , " extensions " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Import ( ) , source , new String [ ] { " kind " , " element " , " name " , " import " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_LogicalPeopleGroups ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Tasks ( ) , source , new String [ ] { " kind " , " element " , " name " , " tasks " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Notifications ( ) , source , new String [ ] { " kind " , " element " , " name " , " notifications " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTHumanInteractions_QueryLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " queryLanguage " } ) ; addAnnotation ( getTHumanInteractions_TargetNamespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " targetNamespace " } ) ; addAnnotation ( tImportEClass , source , new String [ ] { " name " , " tImport " , " kind " , " elementOnly " } ) ; addAnnotation ( getTImport_ImportType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " importType " } ) ; addAnnotation ( getTImport_Location ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " location " } ) ; addAnnotation ( getTImport_Namespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " namespace " } ) ; addAnnotation ( tLiteralEClass , source , new String [ ] { " name " , " tLiteral " , " kind " , " mixed " } ) ; addAnnotation ( getTLiteral_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTLiteral_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # any " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTLiteral_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " lax " } ) ; addAnnotation ( tLocalNotificationEClass , source , new String [ ] { " name " , " tLocalNotification " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLocalNotification_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLocalNotification_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLocalNotification_Reference ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " reference " } ) ; addAnnotation ( tLogicalPeopleGroupEClass , source , new String [ ] { " name " , " tLogicalPeopleGroup " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLogicalPeopleGroup_Parameter ( ) , source , new String [ ] { " kind " , " element " , " name " , " parameter " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLogicalPeopleGroup_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( getTLogicalPeopleGroup_Reference ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " reference " } ) ; addAnnotation ( tLogicalPeopleGroupsEClass , source , new String [ ] { " name " , " tLogicalPeopleGroups " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLogicalPeopleGroups_LogicalPeopleGroup ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroup " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tNotificationEClass , source , new String [ ] { " name " , " tNotification " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotification_Interface ( ) , source , new String [ ] { " kind " , " element " , " name " , " interface " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_PresentationElements ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationElements " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Renderings ( ) , source , new String [ ] { " kind " , " element " , " name " , " renderings " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tNotificationInterfaceEClass , source , new String [ ] { " name " , " tNotificationInterface " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotificationInterface_Operation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " operation " } ) ; addAnnotation ( getTNotificationInterface_PortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " portType " } ) ; addAnnotation ( tNotificationsEClass , source , new String [ ] { " name " , " tNotifications " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotifications_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tOrganizationalEntityEClass , source , new String [ ] { " name " , " tOrganizationalEntity " , " kind " , " elementOnly " } ) ; addAnnotation ( getTOrganizationalEntity_Users ( ) , source , new String [ ] { " kind " , " element " , " name " , " users " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTOrganizationalEntity_Groups ( ) , source , new String [ ] { " kind " , " element " , " name " , " groups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tParameterEClass , source , new String [ ] { " name " , " tParameter " , " kind " , " mixed " } ) ; addAnnotation ( getTParameter_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( getTParameter_Type ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " type " } ) ; addAnnotation ( tPeopleAssignmentsEClass , source , new String [ ] { " name " , " tPeopleAssignments " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPeopleAssignments_GenericHumanRole ( ) , source , new String [ ] { " kind " , " group " , " name " , " GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_ExcludedOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " excludedOwners " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_TaskInitiator ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskInitiator " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_TaskStakeholders ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskStakeholders " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_BusinessAdministrators ( ) , source , new String [ ] { " kind " , " element " , " name " , " businessAdministrators " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_Recipients ( ) , source , new String [ ] { " kind " , " element " , " name " , " recipients " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( tPotentialDelegateesEEnum , source , new String [ ] { " name " , " tPotentialDelegatees " } ) ; addAnnotation ( tPotentialDelegateesObjectEDataType , source , new String [ ] { " name " , " tPotentialDelegatees : Object " , " baseType " , " tPotentialDelegatees " } ) ; addAnnotation ( tPresentationElementsEClass , source , new String [ ] { " name " , " tPresentationElements " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPresentationElements_Name ( ) , source , new String [ ] { " kind " , " element " , " name " , " name " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_PresentationParameters ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationParameters " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_Subject ( ) , source , new String [ ] { " kind " , " element " , " name " , " subject " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_Description ( ) , source , new String [ ] { " kind " , " element " , " name " , " description " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tPresentationParameterEClass , source , new String [ ] { " name " , " tPresentationParameter " , " kind " , " mixed " } ) ; addAnnotation ( tPresentationParametersEClass , source , new String [ ] { " name " , " tPresentationParameters " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPresentationParameters_PresentationParameter ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationParameter " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationParameters_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( tPriorityEClass , source , new String [ ] { " name " , " tPriority " , " kind " , " mixed " } ) ; addAnnotation ( tQueryEClass , source , new String [ ] { " name " , " tQuery " , " kind " , " mixed " } ) ; addAnnotation ( getTQuery_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTQuery_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTQuery_Part ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " part " } ) ; addAnnotation ( getTQuery_QueryLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " queryLanguage " } ) ; addAnnotation ( getTQuery_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 4" , " processing " , " lax " } ) ; addAnnotation ( tReassignmentEClass , source , new String [ ] { " name " , " tReassignment " , " kind " , " elementOnly " } ) ; addAnnotation ( getTReassignment_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tRenderingEClass , source , new String [ ] { " name " , " tRendering " , " kind " , " elementOnly " } ) ; addAnnotation ( getTRendering_Type ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " type " } ) ; addAnnotation ( tRenderingsEClass , source , new String [ ] { " name " , " tRenderings " , " kind " , " elementOnly " } ) ; addAnnotation ( getTRenderings_Rendering ( ) , source , new String [ ] { " kind " , " element " , " name " , " rendering " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tTaskEClass , source , new String [ ] { " name " , " tTask " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTask_Interface ( ) , source , new String [ ] { " kind " , " element " , " name " , " interface " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Delegation ( ) , source , new String [ ] { " kind " , " element " , " name " , " delegation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_PresentationElements ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationElements " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Outcome ( ) , source , new String [ ] { " kind " , " element " , " name " , " outcome " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_SearchBy ( ) , source , new String [ ] { " kind " , " element " , " name " , " searchBy " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Renderings ( ) , source , new String [ ] { " kind " , " element " , " name " , " renderings " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Deadlines ( ) , source , new String [ ] { " kind " , " element " , " name " , " deadlines " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tTaskInterfaceEClass , source , new String [ ] { " name " , " tTaskInterface " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTaskInterface_Operation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " operation " } ) ; addAnnotation ( getTTaskInterface_PortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " portType " } ) ; addAnnotation ( getTTaskInterface_ResponseOperation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " responseOperation " } ) ; addAnnotation ( getTTaskInterface_ResponsePortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " responsePortType " } ) ; addAnnotation ( tTasksEClass , source , new String [ ] { " name " , " tTasks " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTasks_Task ( ) , source , new String [ ] { " kind " , " element " , " name " , " task " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tTextEClass , source , new String [ ] { " name " , " tText " , " kind " , " mixed " } ) ; addAnnotation ( getTText_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tToPartEClass , source , new String [ ] { " name " , " tToPart " , " kind " , " mixed " } ) ; addAnnotation ( getTToPart_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTToPart_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tToPartsEClass , source , new String [ ] { " name " , " tToParts " , " kind " , " elementOnly " } ) ; addAnnotation ( getTToParts_ToPart ( ) , source , new String [ ] { " kind " , " element " , " name " , " toPart " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tUserEDataType , source , new String [ ] { " name " , " tUser " , " baseType " , " http : // www . eclipse . org / emf / 2003 / XMLType # string " } ) ; addAnnotation ( tUserlistEClass , source , new String [ ] { " name " , " tUserlist " , " kind " , " elementOnly " } ) ; addAnnotation ( getTUserlist_User ( ) , source , new String [ ] { " kind " , " element " , " name " , " user " , " namespace " , " # # targetNamespace " } ) ; }
scrutmydocs/scrutmydocs | public AbstractApiTest ( ) { hostname = System . getProperty ( " scrutmydocs . host " , BASE_URL_SERVER ) ; port = System . getProperty ( " scrutmydocs . port " , BASE_URL_PORT ) ; base_url = System . getProperty ( " scrutmydocs . url " , BASE_URL_SUFFIX ) ; }
scrutmydocs/scrutmydocs | @ Test public void asking_for_help ( ) throws Exception { logger . debug ( " Testing ▁ _ help ▁ entry ▁ point ▁ for ▁ { } ▁ api . " , getModuleApiUrl ( ) == null ? " / " : getModuleApiUrl ( ) ) ; RestResponseWelcome response = restTemplate . getForObject ( buildFullApiUrl ( " _ help " ) , RestResponseWelcome . class ) ; assertNotNull ( response ) ; assertTrue ( response . isOk ( ) ) ; assertNotNull ( response . getObject ( ) ) ; Welcome output = ( Welcome ) response . getObject ( ) ; assertNotNull ( output ) ; assertNotNull ( output . getApis ( ) ) ; assertTrue ( output . getApis ( ) . length > 0 ) ; logger . debug ( " { } ▁ _ help ▁ entry ▁ point ▁ provided ▁ { } ▁ hints . " , getModuleApiUrl ( ) == null ? " / " : getModuleApiUrl ( ) , output . getApis ( ) . length ) ; }
scrutmydocs/scrutmydocs | protected String buildFullApiUrl ( String append ) { StringBuffer sbf = new StringBuffer ( " http : // " ) ; sbf . append ( hostname ) ; sbf . append ( " : " ) ; sbf . append ( port ) ; sbf . append ( base_url ) ; if ( getModuleApiUrl ( ) != null ) sbf . append ( getModuleApiUrl ( ) ) ; if ( append != null ) sbf . append ( append ) ; return sbf . toString ( ) ; }
scrutmydocs/scrutmydocs | protected String buildFullApiUrl ( ) { return buildFullApiUrl ( null ) ; }
Cognifide/bobcat | @ Override public void setValue ( Object value ) { selectField . click ( ) ; List < WebElement > options = selectField . findElements ( By . cssSelector ( SELECT_OPTIONS_CSS ) ) ; options . stream ( ) . filter ( o -> value . toString ( ) . equals ( o . getText ( ) ) ) . findFirst ( ) . orElseThrow ( ( ) -> new NoSuchElementException ( String . format ( " Option ▁ with ▁ text ▁ % s ▁ not ▁ found " , value . toString ( ) ) ) ) . click ( ) ; }
Cognifide/bobcat | @ Override public String getLabel ( ) { return label . isEmpty ( ) ? " " : label . get ( 0 ) . getText ( ) ; }
Azure/azure-sdk-for-java | public DayOfWeek dayOfWeek ( ) { return this . dayOfWeek ; }
Azure/azure-sdk-for-java | public ScheduleEntry withDayOfWeek ( DayOfWeek dayOfWeek ) { this . dayOfWeek = dayOfWeek ; return this ; }
Azure/azure-sdk-for-java | public int startHourUtc ( ) { return this . startHourUtc ; }
Azure/azure-sdk-for-java | public ScheduleEntry withStartHourUtc ( int startHourUtc ) { this . startHourUtc = startHourUtc ; return this ; }
Azure/azure-sdk-for-java | public Duration maintenanceWindow ( ) { return this . maintenanceWindow ; }
Azure/azure-sdk-for-java | public ScheduleEntry withMaintenanceWindow ( Duration maintenanceWindow ) { this . maintenanceWindow = maintenanceWindow ; return this ; }
Azure/azure-sdk-for-java | public void validate ( ) { if ( dayOfWeek ( ) == null ) { throw LOGGER . logExceptionAsError ( new IllegalArgumentException ( " Missing ▁ required ▁ property ▁ dayOfWeek ▁ in ▁ model ▁ ScheduleEntry " ) ) ; } }
Azanor/thaumcraft-api | public ResearchEvent ( EntityPlayer player ) { this . player = player ; }
Azanor/thaumcraft-api | public EntityPlayer getPlayer ( ) { return player ; }
Azanor/thaumcraft-api | public Knowledge ( EntityPlayer player , EnumKnowledgeType type , ResearchCategory category , int amount ) { super ( player ) ; this . type = type ; this . category = category ; this . amount = amount ; }
Azanor/thaumcraft-api | public EnumKnowledgeType getType ( ) { return type ; }
Azanor/thaumcraft-api | public ResearchCategory getCategory ( ) { return category ; }
Azanor/thaumcraft-api | public int getAmount ( ) { return amount ; }
Azanor/thaumcraft-api | public Research ( EntityPlayer player , String researchKey ) { super ( player ) ; this . researchKey = researchKey ; }
Azanor/thaumcraft-api | public String getResearchKey ( ) { return researchKey ; }
Azanor/thaumcraft-api | @ Override public boolean isCancelable ( ) { return true ; }
shun634501730/java_source_cn | JSR_W ( ) { }
shun634501730/java_source_cn | public JSR_W ( InstructionHandle target ) { super ( com . sun . org . apache . bcel . internal . Constants . JSR_W , target ) ; length = 5 ; }
shun634501730/java_source_cn | public void dump ( DataOutputStream out ) throws IOException { index = getTargetOffset ( ) ; out . writeByte ( opcode ) ; out . writeInt ( index ) ; }
shun634501730/java_source_cn | protected void initFromFile ( ByteSequence bytes , boolean wide ) throws IOException { index = bytes . readInt ( ) ; length = 5 ; }
shun634501730/java_source_cn | public void accept ( Visitor v ) { v . visitStackProducer ( this ) ; v . visitBranchInstruction ( this ) ; v . visitJsrInstruction ( this ) ; v . visitJSR_W ( this ) ; }
dump247/aws-sdk-java | public UploadSigningCertificateRequest ( ) { }
dump247/aws-sdk-java | public UploadSigningCertificateRequest ( String certificateBody ) { setCertificateBody ( certificateBody ) ; }
dump247/aws-sdk-java | public void setUserName ( String userName ) { this . userName = userName ; }
dump247/aws-sdk-java | public String getUserName ( ) { return this . userName ; }
dump247/aws-sdk-java | public UploadSigningCertificateRequest withUserName ( String userName ) { setUserName ( userName ) ; return this ; }
dump247/aws-sdk-java | public void setCertificateBody ( String certificateBody ) { this . certificateBody = certificateBody ; }
dump247/aws-sdk-java | public String getCertificateBody ( ) { return this . certificateBody ; }
dump247/aws-sdk-java | public UploadSigningCertificateRequest withCertificateBody ( String certificateBody ) { setCertificateBody ( certificateBody ) ; return this ; }
dump247/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getUserName ( ) != null ) sb . append ( " UserName : ▁ " + getUserName ( ) + " , " ) ; if ( getCertificateBody ( ) != null ) sb . append ( " CertificateBody : ▁ " + getCertificateBody ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dump247/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof UploadSigningCertificateRequest == false ) return false ; UploadSigningCertificateRequest other = ( UploadSigningCertificateRequest ) obj ; if ( other . getUserName ( ) == null ^ this . getUserName ( ) == null ) return false ; if ( other . getUserName ( ) != null && other . getUserName ( ) . equals ( this . getUserName ( ) ) == false ) return false ; if ( other . getCertificateBody ( ) == null ^ this . getCertificateBody ( ) == null ) return false ; if ( other . getCertificateBody ( ) != null && other . getCertificateBody ( ) . equals ( this . getCertificateBody ( ) ) == false ) return false ; return true ; }
dump247/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getUserName ( ) == null ) ? 0 : getUserName ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getCertificateBody ( ) == null ) ? 0 : getCertificateBody ( ) . hashCode ( ) ) ; return hashCode ; }
dump247/aws-sdk-java | @ Override public UploadSigningCertificateRequest clone ( ) { return ( UploadSigningCertificateRequest ) super . clone ( ) ; }
is00hcw/parseq | public void reset ( ) { for ( ListLogger logger : _loggerMap . values ( ) ) { logger . reset ( ) ; } }
is00hcw/parseq | @ Override public ListLogger getLogger ( final String loggerName ) { ListLogger logger = _loggerMap . get ( loggerName ) ; if ( logger != null ) { return logger ; } final ListLogger newLogger = new ListLogger ( loggerName ) ; logger = _loggerMap . putIfAbsent ( loggerName , newLogger ) ; return logger == null ? newLogger : logger ; }
pippo1980/upns | public Configuration ( CTUApplicationContext applicationContext ) { super ( applicationContext ) ; }
pippo1980/upns | @ Override public String getName ( ) { return " classpath * : META - INF / sirius . upns . node . context . xml " ; }
statsbiblioteket/summa | ) public MUXFilterFeeder ( Configuration conf , PayloadQueue out ) { log . trace ( " Constructing ▁ MUXFilterFeeder " ) ; if ( out == null ) { throw new IllegalArgumentException ( " out ▁ queue ▁ must ▁ not ▁ be ▁ null " ) ; } this . out = out ; pusher = new PushFilter ( conf . getInt ( CONF_QUEUE_MAXPAYLOADS , DEFAULT_QUEUE_MAXPAYLOADS ) , conf . getInt ( CONF_QUEUE_MAXBYTES , DEFAULT_QUEUE_MAXBYTES ) ) ; if ( conf . valueExists ( CONF_QUEUE_OUT_LENGTH ) ) { log . warn ( String . format ( " The ▁ configuration ▁ contained ▁ the ▁ deprecated ▁ key ▁ % s . ▁ " + " Use ▁ % s ▁ instead " , CONF_QUEUE_OUT_LENGTH , MUXFilter . CONF_OUTQUEUE_MAXPAYLOADS ) ) ; } if ( conf . valueExists ( CONF_QUEUE_OUT_MAXBYTES ) ) { log . warn ( String . format ( " The ▁ configuration ▁ contained ▁ the ▁ deprecated ▁ key ▁ % s . ▁ Use ▁ % s ▁ instead " , CONF_QUEUE_OUT_MAXBYTES , MUXFilter . CONF_OUTQUEUE_MAXBYTES ) ) ; } filter = createFilter ( conf ) ; filter . setSource ( pusher ) ; filterName = conf . getString ( CONF_FILTER_NAME , " Feeder ( " + filter . getClass ( ) . getSimpleName ( ) + " ) " ) ; isFallback = conf . getBoolean ( CONF_FILTER_ISFALLBACK , isFallback ) ; List < String > baseList = conf . getStrings ( CONF_FILTER_BASES , ( List < String > ) null ) ; if ( baseList != null && ! ( baseList . size ( ) == 1 && " * " . equals ( baseList . get ( 0 ) ) ) ) { bases = new HashSet < > ( baseList ) ; } Thread t = new Thread ( this , filterName + " - " + this . hashCode ( ) + " ▁ daemon " ) ; t . setDaemon ( true ) ; t . start ( ) ; log . info ( " Constructed ▁ and ▁ activated ▁ " + this ) ; }
statsbiblioteket/summa | private ObjectFilter createFilter ( Configuration configuration ) { Class < ? extends ObjectFilter > filter = configuration . getClass ( CONF_FILTER_CLASS , ObjectFilter . class ) ; log . debug ( String . format ( " Got ▁ filter ▁ class ▁ % s . ▁ Commencing ▁ creation " , filter ) ) ; return Configuration . create ( filter , configuration ) ; }
statsbiblioteket/summa | public void queuePayload ( Payload payload ) { if ( log . isTraceEnabled ( ) ) { log . trace ( " Queueing ▁ " + payload + " ▁ in ▁ " + this ) ; } if ( ! accepts ( payload ) ) { throw new IllegalArgumentException ( String . format ( " % s ▁ does ▁ not ▁ accept ▁ % s " , this , payload ) ) ; } pusher . add ( payload ) ; }
statsbiblioteket/summa | public int getFreeSlots ( ) { return pusher . getFreeSlots ( ) ; }
statsbiblioteket/summa | public boolean accepts ( Payload payload ) { if ( bases == null ) { return true ; } if ( payload . getRecord ( ) == null ) { log . warn ( " A ▁ Payload ▁ without ▁ base ▁ was ▁ received ▁ in ▁ accepts ( " + payload + " ) ▁ in ▁ " + this ) ; return false ; } return bases . contains ( payload . getRecord ( ) . getBase ( ) ) ; }
statsbiblioteket/summa | public void signalEOF ( ) { log . debug ( " signalEOF ( ) ▁ entered ▁ for ▁ " + this ) ; pusher . signalEOF ( ) ; log . trace ( " signalEOF ( ) ▁ completed ▁ for ▁ " + this ) ; }
statsbiblioteket/summa | public boolean isFallback ( ) { return isFallback ; }
statsbiblioteket/summa | public boolean isEOFReached ( ) { return eofReached ; }
statsbiblioteket/summa | @ Override public String toString ( ) { return " MUXFilterFeeder ( " + filterName + " , ▁ " + filter + " , ▁ bases : ▁ " + ( bases == null ? " N / A " : Strings . join ( bases , " , ▁ " ) ) + " ) " ; }
statsbiblioteket/summa | @ Override public void run ( ) { try { while ( filter . hasNext ( ) ) { payloadCount ++ ; try { log . trace ( " Polling ▁ filter ▁ for ▁ next ▁ processes ▁ Payload " ) ; Payload next = filter . next ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " run ( ) ▁ got ▁ " + next ) ; } if ( next != null ) { try { log . trace ( " Offering ▁ payload ▁ to ▁ out ▁ queue ▁ in ▁ " + this ) ; out . put ( next ) ; log . trace ( " outQueue ▁ accepted ▁ Payload " ) ; } catch ( InterruptedException e ) { log . warn ( " Interrupted ▁ while ▁ trying ▁ to ▁ add ▁ " + next + " ▁ to ▁ outQueue ▁ in ▁ " + this + " . ▁ Retrying " ) ; } } } catch ( Exception e ) { log . warn ( String . format ( " Exception ▁ while ▁ calling ▁ next ▁ on ▁ filter ▁ ' % s ' ▁ in ▁ % s . ▁ Sleeping ▁ a ▁ bit , ▁ then ▁ retrying " , filter , this ) , e ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ex ) { log . warn ( " Interrupted ▁ while ▁ sleeping ▁ before ▁ next ▁ poll ▁ in ▁ " + this , ex ) ; } } } log . debug ( " Emptied ▁ " + filter + " ▁ after ▁ " + payloadCount + " ▁ Payloads " ) ; eofReached = true ; out . uninterruptablePut ( STOP ) ; } catch ( Exception e ) { log . error ( String . format ( " Got ▁ unexpected ▁ exception ▁ in ▁ run - method ▁ for ▁ ' % s ' " , this ) , e ) ; } }
statsbiblioteket/summa | public void close ( boolean success ) { filter . close ( success ) ; log . info ( " Closed ▁ feeder ▁ " + this ) ; }
michpetrov/hal.next | public UploadContentStep ( Resources resources ) { super ( resources . constants ( ) . uploadContent ( ) , resources . messages ( ) . noContent ( ) ) ; }
haikuowuya/android_system_code | public MatchingIterator ( int match , DTMAxisIterator source ) { _source = source ; _match = match ; }
haikuowuya/android_system_code | public void setRestartable ( boolean isRestartable ) { _isRestartable = isRestartable ; _source . setRestartable ( isRestartable ) ; }
haikuowuya/android_system_code | public DTMAxisIterator cloneIterator ( ) { try { final MatchingIterator clone = ( MatchingIterator ) super . clone ( ) ; clone . _source = _source . cloneIterator ( ) ; clone . _isRestartable = false ; return clone . reset ( ) ; } catch ( CloneNotSupportedException e ) { BasisLibrary . runTimeError ( BasisLibrary . ITERATOR_CLONE_ERR , e . toString ( ) ) ; return null ; } }
haikuowuya/android_system_code | public DTMAxisIterator setStartNode ( int node ) { if ( _isRestartable ) { _source . setStartNode ( node ) ; _position = 1 ; while ( ( node = _source . next ( ) ) != END && node != _match ) { _position ++ ; } } return this ; }
haikuowuya/android_system_code | public DTMAxisIterator reset ( ) { _source . reset ( ) ; return resetPosition ( ) ; }
haikuowuya/android_system_code | public int next ( ) { return _source . next ( ) ; }
haikuowuya/android_system_code | public int getLast ( ) { if ( _last == - 1 ) { _last = _source . getLast ( ) ; } return _last ; }
haikuowuya/android_system_code | public int getPosition ( ) { return _position ; }
haikuowuya/android_system_code | public void setMark ( ) { _source . setMark ( ) ; }
haikuowuya/android_system_code | public void gotoMark ( ) { _source . gotoMark ( ) ; }
navalev/azure-sdk-for-java | public String provisioningState ( ) { return this . provisioningState ; }
navalev/azure-sdk-for-java | public String availabilityGroupName ( ) { return this . availabilityGroupName ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withAvailabilityGroupName ( String availabilityGroupName ) { this . availabilityGroupName = availabilityGroupName ; return this ; }
navalev/azure-sdk-for-java | public List < LoadBalancerConfiguration > loadBalancerConfigurations ( ) { return this . loadBalancerConfigurations ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withLoadBalancerConfigurations ( List < LoadBalancerConfiguration > loadBalancerConfigurations ) { this . loadBalancerConfigurations = loadBalancerConfigurations ; return this ; }
navalev/azure-sdk-for-java | public Boolean createDefaultAvailabilityGroupIfNotExist ( ) { return this . createDefaultAvailabilityGroupIfNotExist ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withCreateDefaultAvailabilityGroupIfNotExist ( Boolean createDefaultAvailabilityGroupIfNotExist ) { this . createDefaultAvailabilityGroupIfNotExist = createDefaultAvailabilityGroupIfNotExist ; return this ; }
navalev/azure-sdk-for-java | public Integer port ( ) { return this . port ; }
navalev/azure-sdk-for-java | public AvailabilityGroupListenerInner withPort ( Integer port ) { this . port = port ; return this ; }
JavaSaBr/jME3-SpaceShift-Editor | synchronized ( Event . class ) { EVENT_TYPE = new EventType < > ( SceneEvent . EVENT_TYPE , AssetComponentLoadedEvent . class . getSimpleName ( ) ) ; }
JavaSaBr/jME3-SpaceShift-Editor | public AssetComponentLoadedEvent ( @ NotNull Path assetFolder ) { super ( EVENT_TYPE ) ; setAssetFolder ( assetFolder ) ; }
JavaSaBr/jME3-SpaceShift-Editor | public @ NotNull Path getAssetFolder ( ) { return notNull ( get ( ASSET ) ) ; }
JavaSaBr/jME3-SpaceShift-Editor | public void setAssetFolder ( @ NotNull Path assetFolder ) { set ( ASSET , assetFolder ) ; }
nicolaferraro/camel | default CordaComponentBuilder configuration ( org . apache . camel . component . corda . CordaConfiguration configuration ) { doSetProperty ( " configuration " , configuration ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder bridgeErrorHandler ( boolean bridgeErrorHandler ) { doSetProperty ( " bridgeErrorHandler " , bridgeErrorHandler ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder pageSpecification ( net . corda . core . node . services . vault . PageSpecification pageSpecification ) { doSetProperty ( " pageSpecification " , pageSpecification ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder processSnapshot ( boolean processSnapshot ) { doSetProperty ( " processSnapshot " , processSnapshot ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder sort ( net . corda . core . node . services . vault . Sort sort ) { doSetProperty ( " sort " , sort ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder contractStateClass ( java . lang . Class < net . corda . core . contracts . ContractState > contractStateClass ) { doSetProperty ( " contractStateClass " , contractStateClass ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder flowLogicArguments ( java . lang . Object [ ] flowLogicArguments ) { doSetProperty ( " flowLogicArguments " , flowLogicArguments ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder flowLogicClass ( java . lang . Class < net . corda . core . flows . FlowLogic < java . lang . Object > > flowLogicClass ) { doSetProperty ( " flowLogicClass " , flowLogicClass ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder queryCriteria ( net . corda . core . node . services . vault . QueryCriteria queryCriteria ) { doSetProperty ( " queryCriteria " , queryCriteria ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder lazyStartProducer ( boolean lazyStartProducer ) { doSetProperty ( " lazyStartProducer " , lazyStartProducer ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder operation ( java . lang . String operation ) { doSetProperty ( " operation " , operation ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder autowiredEnabled ( boolean autowiredEnabled ) { doSetProperty ( " autowiredEnabled " , autowiredEnabled ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder password ( java . lang . String password ) { doSetProperty ( " password " , password ) ; return this ; }
nicolaferraro/camel | default CordaComponentBuilder username ( java . lang . String username ) { doSetProperty ( " username " , username ) ; return this ; }
nicolaferraro/camel | @ Override protected CordaComponent buildConcreteComponent ( ) { return new CordaComponent ( ) ; }
nicolaferraro/camel | private org . apache . camel . component . corda . CordaConfiguration getOrCreateConfiguration ( org . apache . camel . component . corda . CordaComponent component ) { if ( component . getConfiguration ( ) == null ) { component . setConfiguration ( new org . apache . camel . component . corda . CordaConfiguration ( ) ) ; } return component . getConfiguration ( ) ; }
nicolaferraro/camel | @ Override protected boolean setPropertyOnComponent ( Component component , String name , Object value ) { switch ( name ) { case " configuration " : ( ( CordaComponent ) component ) . setConfiguration ( ( org . apache . camel . component . corda . CordaConfiguration ) value ) ; return true ; case " bridgeErrorHandler " : ( ( CordaComponent ) component ) . setBridgeErrorHandler ( ( boolean ) value ) ; return true ; case " pageSpecification " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setPageSpecification ( ( net . corda . core . node . services . vault . PageSpecification ) value ) ; return true ; case " processSnapshot " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setProcessSnapshot ( ( boolean ) value ) ; return true ; case " sort " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setSort ( ( net . corda . core . node . services . vault . Sort ) value ) ; return true ; case " contractStateClass " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setContractStateClass ( ( java . lang . Class ) value ) ; return true ; case " flowLogicArguments " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setFlowLogicArguments ( ( java . lang . Object [ ] ) value ) ; return true ; case " flowLogicClass " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setFlowLogicClass ( ( java . lang . Class ) value ) ; return true ; case " queryCriteria " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setQueryCriteria ( ( net . corda . core . node . services . vault . QueryCriteria ) value ) ; return true ; case " lazyStartProducer " : ( ( CordaComponent ) component ) . setLazyStartProducer ( ( boolean ) value ) ; return true ; case " operation " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setOperation ( ( java . lang . String ) value ) ; return true ; case " autowiredEnabled " : ( ( CordaComponent ) component ) . setAutowiredEnabled ( ( boolean ) value ) ; return true ; case " password " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setPassword ( ( java . lang . String ) value ) ; return true ; case " username " : getOrCreateConfiguration ( ( CordaComponent ) component ) . setUsername ( ( java . lang . String ) value ) ; return true ; default : return false ; } }
wichtounet/jtheque-utils | JAVA_IO_TMP_DIR ( " java . io . tmpdir " ) { @ Override public String get ( ) { String value = super . get ( ) ; if ( ! value . endsWith ( File . separator ) ) { value += File . separator ; } FileUtils . createIfNotExists ( new File ( value ) ) ; return value ; } }
wichtounet/jtheque-utils | , USER_DIR ( " user . dir " ) { @ Override public String get ( ) { String value = super . get ( ) ; if ( ! value . endsWith ( File . separator ) ) { value += File . separator ; } return value ; } }
wichtounet/jtheque-utils | SystemProperty ( String name ) { this . name = name ; }
wichtounet/jtheque-utils | public String get ( ) { return AccessController . doPrivileged ( new PrivilegedAction < String > ( ) { @ Override public String run ( ) { return System . getProperty ( getName ( ) ) ; } } ) ; }
wichtounet/jtheque-utils | public final void set ( final String value ) { AccessController . doPrivileged ( new PrivilegedAction < String > ( ) { @ Override public String run ( ) { return System . setProperty ( getName ( ) , value ) ; } } ) ; }
wichtounet/jtheque-utils | public final String getName ( ) { return name ; }
millmanorama/autopsy | GlobalEditListPanel ( ) { tableModel = new KeywordTableModel ( ) ; initComponents ( ) ; customizeComponents ( ) ; }
millmanorama/autopsy | private void customizeComponents ( ) { newKeywordsButton . setToolTipText ( ( NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . customizeComponents . addWordToolTip " ) ) ) ; deleteWordButton . setToolTipText ( NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . customizeComponents . removeSelectedMsg " ) ) ; keywordTable . getParent ( ) . setBackground ( keywordTable . getBackground ( ) ) ; final int width = jScrollPane1 . getPreferredSize ( ) . width ; keywordTable . setAutoResizeMode ( JTable . AUTO_RESIZE_NEXT_COLUMN ) ; TableColumn column ; for ( int i = 0 ; i < keywordTable . getColumnCount ( ) ; i ++ ) { column = keywordTable . getColumnModel ( ) . getColumn ( i ) ; if ( i == 0 ) { column . setPreferredWidth ( ( ( int ) ( width * 0.90 ) ) ) ; } else { column . setPreferredWidth ( ( ( int ) ( width * 0.10 ) ) ) ; } } keywordTable . setCellSelectionEnabled ( false ) ; keywordTable . setRowSelectionAllowed ( true ) ; final ListSelectionModel lsm = keywordTable . getSelectionModel ( ) ; lsm . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent e ) { boolean canDelete = ! ( lsm . isSelectionEmpty ( ) || currentKeywordList . isEditable ( ) || IngestManager . getInstance ( ) . isIngestRunning ( ) ) ; boolean canEdit = canDelete && ( lsm . getMaxSelectionIndex ( ) == lsm . getMinSelectionIndex ( ) ) ; deleteWordButton . setEnabled ( canDelete ) ; editWordButton . setEnabled ( canEdit ) ; } } ) ; setButtonStates ( ) ; IngestManager . getInstance ( ) . addIngestJobEventListener ( new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { Object source = evt . getSource ( ) ; if ( source instanceof String && ( ( String ) source ) . equals ( " LOCAL " ) ) { EventQueue . invokeLater ( ( ) -> { setButtonStates ( ) ; } ) ; } } } ) ; }
millmanorama/autopsy | void setButtonStates ( ) { boolean isIngestRunning = IngestManager . getInstance ( ) . isIngestRunning ( ) ; boolean isListSelected = currentKeywordList != null ; ingestWarningLabel . setVisible ( isIngestRunning ) ; boolean canEditList = isListSelected && ! isIngestRunning ; ingestMessagesCheckbox . setEnabled ( canEditList ) ; ingestMessagesCheckbox . setSelected ( currentKeywordList != null && currentKeywordList . getIngestMessages ( ) ) ; boolean canAddWord = canEditList && ! currentKeywordList . isEditable ( ) ; newKeywordsButton . setEnabled ( canAddWord ) ; if ( ( currentKeywordList == null ) || ( currentKeywordList . getKeywords ( ) . isEmpty ( ) ) ) { deleteWordButton . setEnabled ( false ) ; editWordButton . setEnabled ( false ) ; } }
millmanorama/autopsy | ) private boolean addKeywordsAction ( String existingKeywords , boolean isLiteral , boolean isWholeWord ) { String keywordsToRedisplay = existingKeywords ; AddKeywordsDialog dialog = new AddKeywordsDialog ( ) ; int goodCount = 0 ; int dupeCount = 0 ; int badCount = 1 ; if ( ! existingKeywords . isEmpty ( ) ) { dialog . setTitle ( NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . editKeyword . title " ) ) ; } while ( badCount > 0 ) { dialog . setInitialKeywordList ( keywordsToRedisplay , isLiteral , isWholeWord ) ; dialog . display ( ) ; goodCount = 0 ; dupeCount = 0 ; badCount = 0 ; keywordsToRedisplay = " " ; boolean displayedBoundaryWarning = false ; if ( ! dialog . getKeywords ( ) . isEmpty ( ) ) { for ( String newWord : dialog . getKeywords ( ) ) { if ( newWord . isEmpty ( ) ) { continue ; } final Keyword keyword = new Keyword ( newWord , ! dialog . isKeywordRegex ( ) , dialog . isKeywordExact ( ) , currentKeywordList . getName ( ) , newWord ) ; if ( currentKeywordList . hasKeyword ( keyword ) ) { dupeCount ++ ; continue ; } if ( ( ! displayedBoundaryWarning ) && dialog . isKeywordRegex ( ) ) { if ( newWord . startsWith ( " ^ " ) || ( newWord . endsWith ( " $ " ) && ! newWord . endsWith ( " \\ $ " ) ) ) { KeywordSearchUtil . displayDialog ( NbBundle . getMessage ( this . getClass ( ) , " GlobalEditListPanel . warning . title " ) , NbBundle . getMessage ( this . getClass ( ) , " GlobalEditListPanel . warning . text " ) , KeywordSearchUtil . DIALOG_MESSAGE_TYPE . WARN ) ; displayedBoundaryWarning = true ; } } boolean valid = true ; try { Pattern . compile ( newWord ) ; } catch ( PatternSyntaxException ex1 ) { valid = false ; } catch ( IllegalArgumentException ex2 ) { valid = false ; } if ( ! valid ) { keywordsToRedisplay += newWord + " \n " ; badCount ++ ; continue ; } tableModel . addKeyword ( keyword ) ; goodCount ++ ; } XmlKeywordSearchList . getCurrent ( ) . addList ( currentKeywordList ) ; firePropertyChange ( OptionsPanelController . PROP_CHANGED , null , null ) ; if ( ( badCount > 0 ) || ( dupeCount > 0 ) ) { String summary = " " ; KeywordSearchUtil . DIALOG_MESSAGE_TYPE level = KeywordSearchUtil . DIALOG_MESSAGE_TYPE . INFO ; if ( goodCount > 0 ) { if ( goodCount > 1 ) { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordsAddedPlural . text " , goodCount ) + " \n " ; } else { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordsAdded . text " , goodCount ) + " \n " ; } } if ( dupeCount > 0 ) { if ( dupeCount > 1 ) { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordDupesSkippedPlural . text " , dupeCount ) + " \n " ; } else { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordDupesSkipped . text " , dupeCount ) + " \n " ; } level = KeywordSearchUtil . DIALOG_MESSAGE_TYPE . WARN ; } if ( badCount > 0 ) { if ( badCount > 1 ) { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordErrorsPlural . text " , badCount ) + " \n " ; } else { summary += NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . keywordErrors . text " , badCount ) + " \n " ; } level = KeywordSearchUtil . DIALOG_MESSAGE_TYPE . ERROR ; } KeywordSearchUtil . displayDialog ( NbBundle . getMessage ( this . getClass ( ) , " GlobalEditListPanel . addKeywordResults . text " ) , summary , level ) ; } } } setFocusOnKeywordTextBox ( ) ; setButtonStates ( ) ; return ( goodCount >= 1 && dupeCount == 0 ) ; }
millmanorama/autopsy | private void deleteKeywordAction ( int [ ] selectedKeywords ) { tableModel . deleteSelected ( selectedKeywords ) ; XmlKeywordSearchList . getCurrent ( ) . addList ( currentKeywordList ) ; setButtonStates ( ) ; }
millmanorama/autopsy | private void initComponents ( ) { listEditorPanel = new javax . swing . JPanel ( ) ; jScrollPane1 = new javax . swing . JScrollPane ( ) ; keywordTable = new javax . swing . JTable ( ) ; ingestMessagesCheckbox = new javax . swing . JCheckBox ( ) ; keywordsLabel = new javax . swing . JLabel ( ) ; newKeywordsButton = new javax . swing . JButton ( ) ; deleteWordButton = new javax . swing . JButton ( ) ; editWordButton = new javax . swing . JButton ( ) ; ingestWarningLabel = new javax . swing . JLabel ( ) ; setMinimumSize ( new java . awt . Dimension ( 0 , 0 ) ) ; listEditorPanel . setMinimumSize ( new java . awt . Dimension ( 0 , 0 ) ) ; jScrollPane1 . setPreferredSize ( new java . awt . Dimension ( 340 , 300 ) ) ; keywordTable . setModel ( tableModel ) ; keywordTable . setAutoResizeMode ( javax . swing . JTable . AUTO_RESIZE_OFF ) ; keywordTable . setGridColor ( new java . awt . Color ( 153 , 153 , 153 ) ) ; keywordTable . setMaximumSize ( new java . awt . Dimension ( 30000 , 30000 ) ) ; keywordTable . getTableHeader ( ) . setReorderingAllowed ( false ) ; jScrollPane1 . setViewportView ( keywordTable ) ; ingestMessagesCheckbox . setSelected ( true ) ; ingestMessagesCheckbox . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . ingestMessagesCheckbox . text " ) ) ; ingestMessagesCheckbox . setToolTipText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . ingestMessagesCheckbox . toolTipText " ) ) ; ingestMessagesCheckbox . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ingestMessagesCheckboxActionPerformed ( evt ) ; } } ) ; keywordsLabel . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . keywordsLabel . text " ) ) ; newKeywordsButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / keywordsearch / add16 . png " ) ) ) ; newKeywordsButton . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . newKeywordsButton . text " ) ) ; newKeywordsButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { newKeywordsButtonActionPerformed ( evt ) ; } } ) ; deleteWordButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / keywordsearch / delete16 . png " ) ) ) ; deleteWordButton . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " KeywordSearchEditListPanel . deleteWordButton . text " ) ) ; deleteWordButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { deleteWordButtonActionPerformed ( evt ) ; } } ) ; editWordButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / keywordsearch / edit16 . png " ) ) ) ; editWordButton . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . editWordButton . text " ) ) ; editWordButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editWordButtonActionPerformed ( evt ) ; } } ) ; ingestWarningLabel . setFont ( ingestWarningLabel . getFont ( ) . deriveFont ( ingestWarningLabel . getFont ( ) . getStyle ( ) & ~ java . awt . Font . BOLD , 11 ) ) ; ingestWarningLabel . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( " / org / sleuthkit / autopsy / modules / hashdatabase / warning16 . png " ) ) ) ; ingestWarningLabel . setText ( org . openide . util . NbBundle . getMessage ( GlobalEditListPanel . class , " GlobalEditListPanel . ingestWarningLabel . text " ) ) ; javax . swing . GroupLayout listEditorPanelLayout = new javax . swing . GroupLayout ( listEditorPanel ) ; listEditorPanel . setLayout ( listEditorPanelLayout ) ; listEditorPanelLayout . setHorizontalGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addComponent ( keywordsLabel ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addGap ( 10 , 10 , 10 ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jScrollPane1 , javax . swing . GroupLayout . DEFAULT_SIZE , 566 , Short . MAX_VALUE ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addComponent ( newKeywordsButton ) . addGap ( 14 , 14 , 14 ) . addComponent ( editWordButton ) . addGap ( 14 , 14 , 14 ) . addComponent ( deleteWordButton ) . addGap ( 0 , 0 , Short . MAX_VALUE ) ) . addGroup ( listEditorPanelLayout . createSequentialGroup ( ) . addComponent ( ingestMessagesCheckbox ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addComponent ( ingestWarningLabel ) ) ) ) ) . addContainerGap ( ) ) ) ; listEditorPanelLayout . linkSize ( javax . swing . SwingConstants . HORIZONTAL , new java . awt . Component [ ] { deleteWordButton , editWordButton , newKeywordsButton } ) ; listEditorPanelLayout . setVerticalGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , listEditorPanelLayout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( keywordsLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( jScrollPane1 , javax . swing . GroupLayout . DEFAULT_SIZE , 256 , Short . MAX_VALUE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( deleteWordButton ) . addComponent ( newKeywordsButton ) . addComponent ( editWordButton ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addGroup ( listEditorPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( ingestMessagesCheckbox ) . addComponent ( ingestWarningLabel ) ) . addGap ( 9 , 9 , 9 ) ) ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( this ) ; this . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( listEditorPanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( listEditorPanel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) . addGap ( 5 , 5 , 5 ) ) ) ; }
millmanorama/autopsy | private void deleteWordButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( KeywordSearchUtil . displayConfirmDialog ( NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . removeKwMsg " ) , NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . deleteWordButtonActionPerformed . delConfirmMsg " ) , KeywordSearchUtil . DIALOG_MESSAGE_TYPE . WARN ) ) { deleteKeywordAction ( keywordTable . getSelectedRows ( ) ) ; firePropertyChange ( OptionsPanelController . PROP_CHANGED , null , null ) ; } }
millmanorama/autopsy | private void ingestMessagesCheckboxActionPerformed ( java . awt . event . ActionEvent evt ) { currentKeywordList . setIngestMessages ( ingestMessagesCheckbox . isSelected ( ) ) ; XmlKeywordSearchList updater = XmlKeywordSearchList . getCurrent ( ) ; updater . addList ( currentKeywordList ) ; firePropertyChange ( OptionsPanelController . PROP_CHANGED , null , null ) ; }
millmanorama/autopsy | private void newKeywordsButtonActionPerformed ( java . awt . event . ActionEvent evt ) { addKeywordsAction ( " " , true , true ) ; }
millmanorama/autopsy | private void editWordButtonActionPerformed ( java . awt . event . ActionEvent evt ) { int [ ] selectedKeywords = keywordTable . getSelectedRows ( ) ; if ( selectedKeywords . length == 1 ) { Keyword currentKeyword = currentKeywordList . getKeywords ( ) . get ( selectedKeywords [ 0 ] ) ; if ( addKeywordsAction ( currentKeyword . getSearchTerm ( ) , currentKeyword . searchTermIsLiteral ( ) , currentKeyword . searchTermIsWholeWord ( ) ) ) { deleteKeywordAction ( selectedKeywords ) ; } } }
millmanorama/autopsy | @ Override public void valueChanged ( ListSelectionEvent e ) { ListSelectionModel listSelectionModel = ( ListSelectionModel ) e . getSource ( ) ; currentKeywordList = null ; if ( ! listSelectionModel . isSelectionEmpty ( ) ) { XmlKeywordSearchList loader = XmlKeywordSearchList . getCurrent ( ) ; if ( listSelectionModel . getMinSelectionIndex ( ) == listSelectionModel . getMaxSelectionIndex ( ) ) { currentKeywordList = loader . getListsL ( false ) . get ( listSelectionModel . getMinSelectionIndex ( ) ) ; } } tableModel . resync ( ) ; setButtonStates ( ) ; }
millmanorama/autopsy | @ Override public void store ( ) { }
millmanorama/autopsy | @ Override public void load ( ) { }
millmanorama/autopsy | KeywordList getCurrentKeywordList ( ) { return currentKeywordList ; }
millmanorama/autopsy | void setCurrentKeywordList ( KeywordList list ) { currentKeywordList = list ; }
millmanorama/autopsy | @ Override public int getColumnCount ( ) { return 2 ; }
millmanorama/autopsy | @ Override public int getRowCount ( ) { return currentKeywordList == null ? 0 : currentKeywordList . getKeywords ( ) . size ( ) ; }
millmanorama/autopsy | @ Override public String getColumnName ( int column ) { String colName = null ; switch ( column ) { case 0 : colName = NbBundle . getMessage ( this . getClass ( ) , " KeywordSearchEditListPanel . kwColName " ) ; break ; case 1 : colName = NbBundle . getMessage ( this . getClass ( ) , " KeywordSearch . typeColLbl " ) ; break ; default : ; } return colName ; }
millmanorama/autopsy | @ Override public Object getValueAt ( int rowIndex , int columnIndex ) { Object ret = null ; if ( currentKeywordList == null ) { return " " ; } Keyword word = currentKeywordList . getKeywords ( ) . get ( rowIndex ) ; switch ( columnIndex ) { case 0 : ret = word . getSearchTerm ( ) ; break ; case 1 : ret = word . getSearchTermType ( ) ; break ; default : logger . log ( Level . SEVERE , " Invalid ▁ table ▁ column ▁ index : ▁ { 0 } " , columnIndex ) ; break ; } return ret ; }
millmanorama/autopsy | @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return false ; }
millmanorama/autopsy | @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { }
millmanorama/autopsy | @ Override public Class < ? > getColumnClass ( int c ) { return getValueAt ( 0 , c ) . getClass ( ) ; }
millmanorama/autopsy | void addKeyword ( Keyword keyword ) { if ( ! currentKeywordList . hasKeyword ( keyword ) ) { currentKeywordList . getKeywords ( ) . add ( keyword ) ; } fireTableDataChanged ( ) ; }
millmanorama/autopsy | void resync ( ) { fireTableDataChanged ( ) ; }
millmanorama/autopsy | void deleteSelected ( int [ ] selected ) { List < Keyword > words = currentKeywordList . getKeywords ( ) ; Arrays . sort ( selected ) ; for ( int arrayi = selected . length - 1 ; arrayi >= 0 ; arrayi -- ) { words . remove ( selected [ arrayi ] ) ; } resync ( ) ; }
millmanorama/autopsy | void setFocusOnKeywordTextBox ( ) { newKeywordsButton . requestFocus ( ) ; }
epam/NGB | public String getOriginalFilePath ( ) { return originalFilePath ; }
epam/NGB | public void setOriginalFilePath ( String originalFilePath ) { this . originalFilePath = originalFilePath ; }
epam/NGB | public String getSortedFilePath ( ) { return sortedFilePath ; }
epam/NGB | public void setSortedFilePath ( String sortedFilePath ) { this . sortedFilePath = sortedFilePath ; }
epam/NGB | public Integer getMaxMemory ( ) { return maxMemory ; }
epam/NGB | public void setMaxMemory ( Integer maxMemory ) { this . maxMemory = maxMemory ; }
semkagtn/last-fm | public IdsList getResponse ( ) { return response ; }
semkagtn/last-fm | @ Override public String toString ( ) { return JsonUtils . toJson ( this ) ; }
nabdulla/assignment1 | public Player ( String playerNo ) { this . setPlayerNo ( playerNo ) ; }
nabdulla/assignment1 | public String getPlayerNo ( ) { return playerNo ; }
nabdulla/assignment1 | public void setPlayerNo ( String playerNo ) { this . playerNo = playerNo ; }
Red5/red5-hls-plugin | private ThreadLocal < FileChannel > readChannelHolder = new ThreadLocal < FileChannel > ( ) { @ Override protected FileChannel initialValue ( ) { String fileName = String . format ( " % s % s _ % s . ts " , segmentDirectory , name , index ) ; log . debug ( " initialValue ▁ - ▁ read ▁ channel : ▁ { } " , fileName ) ; try { RandomAccessFile fileForReading = new RandomAccessFile ( fileName , " r " ) ; return fileForReading . getChannel ( ) ; } catch ( IOException e ) { log . warn ( " Exception ▁ in ▁ get ▁ channel " , e ) ; } return null ; } }
Red5/red5-hls-plugin | private ThreadLocal < Integer > readPositionHolder = new ThreadLocal < Integer > ( ) { @ Override protected Integer initialValue ( ) { log . debug ( " initialValue ▁ - ▁ buffer : ▁ { } " , buffer ) ; return 0 ; } }
Red5/red5-hls-plugin | public Segment ( String segmentDirectory , String name , int index , boolean memoryMapped ) { this . segmentDirectory = segmentDirectory ; this . name = name ; this . index = index ; if ( memoryMapped ) { log . debug ( " Using ▁ memory ▁ mapped ▁ files " ) ; buffer = IoBuffer . allocate ( CHUNK_SIZE * ( 1024 * 4 ) , false ) ; buffer . setAutoExpand ( true ) ; buffer . setAutoShrink ( true ) ; } else { log . debug ( " Using ▁ disk ▁ based ▁ files " ) ; try { file = new RandomAccessFile ( String . format ( " % s % s _ % s . ts " , segmentDirectory , name , index ) , " rwd " ) ; channel = file . getChannel ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } }
Red5/red5-hls-plugin | public String getSegmentDirectory ( ) { return segmentDirectory ; }
Red5/red5-hls-plugin | public String getName ( ) { return name ; }
Red5/red5-hls-plugin | public int getIndex ( ) { return index ; }
Red5/red5-hls-plugin | public long getCreated ( ) { return created ; }
Red5/red5-hls-plugin | public boolean isMemoryMapped ( ) { return channel == null ; }
Red5/red5-hls-plugin | public boolean isLast ( ) { return last ; }
Red5/red5-hls-plugin | public void setLast ( boolean last ) { this . last = last ; }
Red5/red5-hls-plugin | public boolean isPatWritten ( ) { return patWritten ; }
Red5/red5-hls-plugin | public void setPatWritten ( boolean patWritten ) { this . patWritten = patWritten ; }
Red5/red5-hls-plugin | public boolean isPmtWritten ( ) { return pmtWritten ; }
Red5/red5-hls-plugin | public void setPmtWritten ( boolean pmtWritten ) { this . pmtWritten = pmtWritten ; }
Red5/red5-hls-plugin | public boolean isSpWritten ( ) { return spWritten ; }
Red5/red5-hls-plugin | public void setSpWritten ( boolean spWritten ) { this . spWritten = spWritten ; }
Red5/red5-hls-plugin | public void setDuration ( double duration ) { this . duration = duration ; }
Red5/red5-hls-plugin | public double getDuration ( ) { return duration ; }
Red5/red5-hls-plugin | public ByteBuffer read ( ) { ByteBuffer buf = null ; if ( buffer != null ) { Integer readPos = readPositionHolder . get ( ) ; log . trace ( " Current ▁ buffer ▁ position : ▁ { } " , readPos ) ; int newPos = readPos + CHUNK_SIZE ; int currentPosition = buffer . position ( ) ; if ( newPos < currentPosition ) { byte [ ] chunk = new byte [ CHUNK_SIZE ] ; if ( lock . tryLock ( ) ) { try { currentPosition = buffer . position ( ) ; IoBuffer slice = buffer . getSlice ( readPos , CHUNK_SIZE ) ; buffer . position ( currentPosition ) ; slice . get ( chunk ) ; slice . free ( ) ; } finally { lock . unlock ( ) ; } buf = ByteBuffer . wrap ( chunk ) ; } readPositionHolder . set ( newPos ) ; } else { readPositionHolder . set ( readPos ) ; } } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { buf = ByteBuffer . allocate ( CHUNK_SIZE ) ; readChannel . read ( buf ) ; buf . flip ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . set ( readChannel ) ; } return buf ; }
Red5/red5-hls-plugin | public ByteBuffer read ( ByteBuffer buf ) { if ( buffer != null ) { Integer readPos = readPositionHolder . get ( ) ; log . trace ( " Current ▁ buffer ▁ read ▁ position : ▁ { } " , readPos ) ; int newPos = readPos + CHUNK_SIZE ; int currentPosition = buffer . position ( ) ; if ( newPos < currentPosition ) { byte [ ] chunk = new byte [ CHUNK_SIZE ] ; if ( lock . tryLock ( ) ) { try { currentPosition = buffer . position ( ) ; IoBuffer slice = buffer . getSlice ( readPos , CHUNK_SIZE ) ; buffer . position ( currentPosition ) ; slice . get ( chunk ) ; slice . free ( ) ; } finally { lock . unlock ( ) ; } buf . put ( chunk ) ; buf . flip ( ) ; } readPositionHolder . set ( newPos ) ; } else { readPositionHolder . set ( readPos ) ; buf . position ( CHUNK_SIZE - 1 ) ; } } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { readChannel . read ( buf ) ; buf . flip ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . set ( readChannel ) ; } return buf ; }
Red5/red5-hls-plugin | public boolean hasMoreData ( ) { boolean hasMore = false ; if ( buffer != null ) { Integer readPos = readPositionHolder . get ( ) ; hasMore = ( readPos + CHUNK_SIZE ) < buffer . position ( ) ; readPositionHolder . set ( readPos ) ; } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { hasMore = ( readChannel . size ( ) - readChannel . position ( ) ) >= CHUNK_SIZE ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . set ( readChannel ) ; } return hasMore ; }
Red5/red5-hls-plugin | public void cleanupThreadLocal ( ) { if ( buffer != null ) { readPositionHolder . remove ( ) ; } else { FileChannel readChannel = readChannelHolder . get ( ) ; try { readChannel . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } readChannelHolder . remove ( ) ; } }
Red5/red5-hls-plugin | public int write ( ByteBuffer data ) { log . debug ( " write " ) ; int written = 0 ; if ( ! closed ) { if ( buffer != null ) { log . trace ( " Current ▁ buffer ▁ size ▁ before ▁ write : ▁ { } " , buffer . capacity ( ) ) ; if ( lock . tryLock ( ) ) { try { buffer . put ( data ) ; chunksWritten ++ ; written = data . limit ( ) ; } catch ( BufferOverflowException bofe ) { log . warn ( " Error ▁ writing ▁ to ▁ the ▁ buffer " , bofe ) ; } finally { lock . unlock ( ) ; } } } else { if ( data != null ) { try { written = channel . write ( data ) ; channel . force ( true ) ; chunksWritten ++ ; } catch ( IOException e ) { log . warn ( " Exception ▁ writing ▁ channel " , e ) ; } } else { log . debug ( " Write ▁ data ▁ was ▁ null " ) ; } } } return written ; }
Red5/red5-hls-plugin | public boolean close ( ) { log . debug ( " Close ▁ - ▁ name : ▁ { } ▁ index : ▁ { } " , name , index ) ; closed = true ; log . debug ( " Chunks ▁ written : ▁ { } " , chunksWritten ) ; boolean result = false ; if ( buffer != null ) { buffer . clear ( ) ; result = true ; } else if ( channel != null && channel . isOpen ( ) ) { try { channel . close ( ) ; result = true ; } catch ( IOException e ) { log . warn ( " Exception ▁ closing ▁ channel " , e ) ; } } return result ; }
Red5/red5-hls-plugin | public void dispose ( ) { if ( buffer != null ) { buffer . free ( ) ; } else { File tsFile = new File ( String . format ( " % s % s _ % s . ts " , segmentDirectory , name , index ) ) ; if ( tsFile . exists ( ) ) { if ( ! tsFile . delete ( ) ) { tsFile . deleteOnExit ( ) ; } } tsFile = null ; } }
Red5/red5-hls-plugin | @ Override public String toString ( ) { return " Segment ▁ [ name = " + name + " , ▁ index = " + index + " , ▁ created = " + created + " ] " ; }
Red5/red5-hls-plugin | @ Override public int compareTo ( Segment otherSegment ) { int otherIndex = otherSegment . getIndex ( ) ; if ( index > otherIndex ) { return 1 ; } else if ( index < otherIndex ) { return - 1 ; } return 0 ; }
McLeodMoores/starling | public AbstractBloombergHTSTest ( ) { super ( ) ; }
McLeodMoores/starling | @ BeforeMethod ( alwaysRun = true ) protected void doSetUp ( ) { _htsMaster = new InMemoryHistoricalTimeSeriesMaster ( ) ; _historicalTimeSeriesProvider = new UnitTestHistoricalTimeSeriesProvider ( ) ; final BloombergIdentifierProvider idProvider = new BloombergIdentifierProvider ( new MockReferenceDataProvider ( ) ) ; _htsMasterUpdater = new BloombergHTSMasterUpdater ( _htsMaster , _historicalTimeSeriesProvider , idProvider ) ; _loader = new BloombergHistoricalTimeSeriesLoader ( _htsMaster , _historicalTimeSeriesProvider , idProvider ) ; }
McLeodMoores/starling | @ AfterMethod ( alwaysRun = true ) protected void doTearDown ( ) { _htsMaster = null ; }
McLeodMoores/starling | @ Override protected HistoricalTimeSeriesProviderGetResult doBulkGet ( final HistoricalTimeSeriesProviderGetRequest request ) { final Map < ExternalIdBundle , LocalDateDoubleTimeSeries > tsMap = Maps . newHashMap ( ) ; LocalDate start = request . getDateRange ( ) . getStartDateInclusive ( ) ; LocalDate end = request . getDateRange ( ) . getEndDateInclusive ( ) ; LOGGER . debug ( " producing ▁ TS ▁ for ▁ startDate = { } ▁ endDate = { } " , start , end ) ; for ( final ExternalIdBundle identifiers : request . getExternalIdBundles ( ) ) { final LocalDate cachedStart = MapUtils . putIfAbsentGet ( _startDateMap , identifiers , start ) ; if ( start . isBefore ( cachedStart ) ) { start = cachedStart ; } if ( end . equals ( LocalDate . MAX ) ) { end = previousWeekDay ( ) ; } final LocalDateDoubleTimeSeries timeSeries = makeRandomTimeSeries ( start , end ) ; tsMap . put ( identifiers , timeSeries ) ; } return new HistoricalTimeSeriesProviderGetResult ( tsMap ) ; }
McLeodMoores/starling | private LocalDateDoubleTimeSeries makeRandomTimeSeries ( final LocalDate start , final LocalDate end ) { final LocalDateDoubleTimeSeriesBuilder tsMap = ImmutableLocalDateDoubleTimeSeries . builder ( ) ; LocalDate current = start ; tsMap . put ( current , Math . random ( ) ) ; while ( current . isBefore ( end ) ) { current = current . plusDays ( 1 ) ; if ( isWeekday ( current ) ) { tsMap . put ( current , Math . random ( ) ) ; } } return tsMap . build ( ) ; }
McLeodMoores/starling | private boolean isWeekday ( final LocalDate day ) { return day . getDayOfWeek ( ) != DayOfWeek . SATURDAY && day . getDayOfWeek ( ) != DayOfWeek . SUNDAY ; }
McLeodMoores/starling | protected List < Pair < HistoricalTimeSeriesInfoDocument , HistoricalTimeSeries > > addTimeSeries ( ) { final List < Pair < HistoricalTimeSeriesInfoDocument , HistoricalTimeSeries > > result = Lists . newArrayList ( ) ; for ( int i = 0 ; i < TS_DATASET_SIZE ; i ++ ) { final LocalDate end = previousWeekDay ( ) . minusWeeks ( 1 ) ; final LocalDate start = end . minusWeeks ( 2 ) ; for ( final String dataSource : DATA_SOURCES ) { for ( final String dataProvider : DATA_PROVIDERS ) { for ( final String dataField : DATA_FIELDS ) { final ManageableHistoricalTimeSeriesInfo info = new ManageableHistoricalTimeSeriesInfo ( ) ; info . setName ( dataField + " ▁ " + dataSource ) ; info . setDataField ( dataField ) ; info . setDataProvider ( dataProvider ) ; info . setDataSource ( dataSource ) ; info . setObservationTime ( PROVIDER_TO_OBSERVATION_TIME . get ( dataProvider ) ) ; final ExternalId ticker = ExternalSchemes . bloombergTickerSecurityId ( " ticker " + i ) ; final ExternalId buid = ExternalSchemes . bloombergBuidSecurityId ( " buid " + i ) ; final ExternalIdBundleWithDates bundleWithDates = ExternalIdBundleWithDates . of ( ExternalIdWithDates . of ( ticker ) , ExternalIdWithDates . of ( buid ) ) ; info . setExternalIdBundle ( bundleWithDates ) ; final HistoricalTimeSeriesInfoDocument added = _htsMaster . add ( new HistoricalTimeSeriesInfoDocument ( info ) ) ; assertNotNull ( added ) ; assertNotNull ( added . getUniqueId ( ) ) ; final Map < ExternalIdBundle , LocalDateDoubleTimeSeries > resultMap = _historicalTimeSeriesProvider . getHistoricalTimeSeries ( Collections . singleton ( bundleWithDates . toBundle ( ) ) , BloombergConstants . BLOOMBERG_DATA_SOURCE_NAME , dataProvider , dataField , LocalDateRange . of ( start , end , true ) ) ; final LocalDateDoubleTimeSeries timeSeries = resultMap . get ( bundleWithDates . toBundle ( ) ) ; final UniqueId tsUid = _htsMaster . updateTimeSeriesDataPoints ( added . getInfo ( ) . getTimeSeriesObjectId ( ) , timeSeries ) ; final HistoricalTimeSeries hts = _htsMaster . getTimeSeries ( tsUid ) ; assertNotNull ( hts ) ; assertEquals ( timeSeries , hts . getTimeSeries ( ) ) ; result . add ( Pairs . of ( added , hts ) ) ; } } } } return result ; }
McLeodMoores/starling | protected BloombergHTSMasterUpdater getHtsMasterUpdater ( ) { return _htsMasterUpdater ; }
McLeodMoores/starling | protected BloombergHistoricalTimeSeriesLoader getLoader ( ) { return _loader ; }
McLeodMoores/starling | protected HistoricalTimeSeriesMaster getHtsMaster ( ) { return _htsMaster ; }
c3p0hz/microscope | public DateTimeBox ( ) { super ( new DateTimePicker ( ) , null , DATE_FORMAT ) ; ( ( DateTimePicker ) getDatePicker ( ) ) . setDateTimeBox ( this ) ; final TextBox textbox = getTextBox ( ) ; textbox . setVisibleLength ( 19 + 2 ) ; textbox . setMaxLength ( 19 ) ; }
c3p0hz/microscope | public DateTimePicker ( ) { }
c3p0hz/microscope | void setDateTimeBox ( final DateTimeBox box ) { this . box = box ; }
c3p0hz/microscope | private void setDate ( final Date d ) { refreshAll ( ) ; box . setValue ( d ) ; box . getTextBox ( ) . setFocus ( true ) ; }
c3p0hz/microscope | private PushButton newShiftDateButton ( final int seconds , final String label ) { final PushButton button = new PushButton ( label ) ; button . setStyleName ( seconds < 0 ? " datePickerPreviousButton " : " datePickerNextButton " ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { Date d = box . getValue ( ) ; if ( d == null ) { if ( seconds >= 0 ) { return ; } d = new Date ( ) ; } d . setTime ( d . getTime ( ) + seconds * 1000L ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
c3p0hz/microscope | private PushButton newSetHoursButton ( final int hours ) { final PushButton button = new PushButton ( Integer . toString ( hours ) ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { @ SuppressWarnings ( { " deprecation " } ) Date d = box . getValue ( ) ; if ( d == null ) { d = new Date ( ) ; d . setMinutes ( 0 ) ; } d . setHours ( hours ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
c3p0hz/microscope | private PushButton newSetMinutesButton ( final int minutes , final String label ) { final PushButton button = new PushButton ( label ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { @ SuppressWarnings ( { " deprecation " } ) Date d = box . getValue ( ) ; if ( d == null ) { d = new Date ( ) ; } d . setMinutes ( minutes ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
c3p0hz/microscope | private void setupAmUI ( ) { hours_minutes . setWidget ( 0 , 1 , newSetHoursButton ( 0 ) ) ; hours_minutes . setWidget ( 0 , 2 , newSetHoursButton ( 1 ) ) ; hours_minutes . setWidget ( 0 , 3 , newSetHoursButton ( 2 ) ) ; hours_minutes . setWidget ( 0 , 4 , newSetHoursButton ( 3 ) ) ; hours_minutes . setWidget ( 0 , 5 , newSetHoursButton ( 4 ) ) ; hours_minutes . setWidget ( 0 , 6 , newSetHoursButton ( 5 ) ) ; hours_minutes . setWidget ( 1 , 1 , newSetHoursButton ( 6 ) ) ; hours_minutes . setWidget ( 1 , 2 , newSetHoursButton ( 7 ) ) ; hours_minutes . setWidget ( 1 , 3 , newSetHoursButton ( 8 ) ) ; hours_minutes . setWidget ( 1 , 4 , newSetHoursButton ( 9 ) ) ; hours_minutes . setWidget ( 1 , 5 , newSetHoursButton ( 10 ) ) ; hours_minutes . setWidget ( 1 , 6 , newSetHoursButton ( 11 ) ) ; }
c3p0hz/microscope | private void setupPmUI ( ) { hours_minutes . setWidget ( 0 , 1 , newSetHoursButton ( 12 ) ) ; hours_minutes . setWidget ( 0 , 2 , newSetHoursButton ( 13 ) ) ; hours_minutes . setWidget ( 0 , 3 , newSetHoursButton ( 14 ) ) ; hours_minutes . setWidget ( 0 , 4 , newSetHoursButton ( 15 ) ) ; hours_minutes . setWidget ( 0 , 5 , newSetHoursButton ( 16 ) ) ; hours_minutes . setWidget ( 0 , 6 , newSetHoursButton ( 17 ) ) ; hours_minutes . setWidget ( 1 , 1 , newSetHoursButton ( 18 ) ) ; hours_minutes . setWidget ( 1 , 2 , newSetHoursButton ( 19 ) ) ; hours_minutes . setWidget ( 1 , 3 , newSetHoursButton ( 20 ) ) ; hours_minutes . setWidget ( 1 , 4 , newSetHoursButton ( 21 ) ) ; hours_minutes . setWidget ( 1 , 5 , newSetHoursButton ( 22 ) ) ; hours_minutes . setWidget ( 1 , 6 , newSetHoursButton ( 23 ) ) ; }
c3p0hz/microscope | @ Override protected void setup ( ) { final HorizontalPanel panel = new HorizontalPanel ( ) ; initWidget ( panel ) ; setStyleName ( panel . getElement ( ) , " gwt - DatePicker " ) ; { final VerticalPanel vbox = new VerticalPanel ( ) ; setStyleName ( " gwt - DatePicker " ) ; vbox . add ( super . getMonthSelector ( ) ) ; vbox . add ( super . getView ( ) ) ; panel . add ( vbox ) ; } { final VerticalPanel vbox = new VerticalPanel ( ) ; setStyleName ( vbox . getElement ( ) , " datePickerMonthSelector " ) ; final PushButton now = new PushButton ( " now " ) ; now . setStyleName ( " datePickerNextButton " ) ; now . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { box . setValue ( new Date ( ) ) ; } } ) ; { final Grid grid = new Grid ( 2 , 9 ) ; grid . setWidget ( 0 , 0 , newShiftDateButton ( - 3600 , "1h " ) ) ; grid . setWidget ( 0 , 1 , newShiftDateButton ( - 600 , "10m " ) ) ; grid . setWidget ( 0 , 2 , newShiftDateButton ( - 60 , "1m " ) ) ; grid . setWidget ( 0 , 3 , new InlineHTML ( " & lsaquo ; " ) ) ; grid . setWidget ( 0 , 4 , now ) ; grid . setWidget ( 0 , 5 , new InlineHTML ( " & rsaquo ; " ) ) ; grid . setWidget ( 0 , 6 , newShiftDateButton ( + 60 , "1m " ) ) ; grid . setWidget ( 0 , 7 , newShiftDateButton ( + 600 , "10m " ) ) ; grid . setWidget ( 0 , 8 , newShiftDateButton ( + 3600 , "1h " ) ) ; grid . setWidget ( 1 , 0 , newShiftDateButton ( - 86400 * 30 , "30d " ) ) ; grid . setWidget ( 1 , 1 , newShiftDateButton ( - 86400 * 7 , "1w " ) ) ; grid . setWidget ( 1 , 2 , newShiftDateButton ( - 86400 , "1d " ) ) ; grid . setWidget ( 1 , 3 , new InlineHTML ( " & laquo ; " ) ) ; grid . setWidget ( 1 , 4 , new InlineHTML ( " & nbsp ; " ) ) ; grid . setWidget ( 1 , 5 , new InlineHTML ( " & raquo ; " ) ) ; grid . setWidget ( 1 , 6 , newShiftDateButton ( + 86400 , "1d " ) ) ; grid . setWidget ( 1 , 7 , newShiftDateButton ( + 86400 * 7 , "1w " ) ) ; grid . setWidget ( 1 , 8 , newShiftDateButton ( + 86400 * 30 , "30d " ) ) ; final CellFormatter formatter = grid . getCellFormatter ( ) ; formatter . setWidth ( 0 , 4 , "100 % " ) ; formatter . setWidth ( 1 , 4 , "100 % " ) ; vbox . add ( grid ) ; } { hours_minutes = new Grid ( 4 , 8 ) ; setupAmUI ( ) ; hours_minutes . setWidget ( 0 , 0 , new InlineLabel ( " HH " ) ) ; final PushButton set_am = new PushButton ( " AM " ) ; set_am . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { setupAmUI ( ) ; } } ) ; hours_minutes . setWidget ( 0 , 7 , set_am ) ; final PushButton set_pm = new PushButton ( " PM " ) ; set_pm . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { setupPmUI ( ) ; } } ) ; hours_minutes . setWidget ( 1 , 7 , set_pm ) ; hours_minutes . setWidget ( 2 , 0 , new InlineLabel ( " MM " ) ) ; hours_minutes . setWidget ( 2 , 1 , newSetMinutesButton ( 0 , "00" ) ) ; hours_minutes . setWidget ( 2 , 2 , newSetMinutesButton ( 10 , "10" ) ) ; hours_minutes . setWidget ( 2 , 3 , newSetMinutesButton ( 20 , "20" ) ) ; hours_minutes . setWidget ( 2 , 4 , newSetMinutesButton ( 30 , "30" ) ) ; hours_minutes . setWidget ( 2 , 5 , newSetMinutesButton ( 40 , "40" ) ) ; hours_minutes . setWidget ( 2 , 6 , newSetMinutesButton ( 50 , "50" ) ) ; vbox . add ( hours_minutes ) ; } { final HorizontalPanel hbox = new HorizontalPanel ( ) ; hbox . add ( new InlineLabel ( " UNIX ▁ timestamp : " ) ) ; final ValidatedTextBox ts = new ValidatedTextBox ( ) ; ts . setValidationRegexp ( " ^ ( | [ 1-9 ] [ 0-9 ] { 0,9 } ) $ " ) ; ts . setVisibleLength ( 10 ) ; ts . setMaxLength ( 10 ) ; final EventsHandler handler = new EventsHandler ( ) { protected < H extends EventHandler > void onEvent ( final DomEvent < H > event ) { final Date d = new Date ( Integer . parseInt ( ts . getValue ( ) ) * 1000L ) ; box . setValue ( d , true ) ; } } ; ts . addBlurHandler ( handler ) ; ts . addKeyPressHandler ( handler ) ; hbox . add ( ts ) ; vbox . add ( hbox ) ; } vbox . setHeight ( "100 % " ) ; panel . add ( vbox ) ; panel . setCellHeight ( vbox , "100 % " ) ; } }
Kisamegr/Crawler | public Exctractor ( ) { try { Console . Log ( " - - - - - ▁ Started ▁ Extractor ▁ - - - - - " ) ; Console . Log ( " Extracting ▁ General ▁ User ▁ Info . . . " ) ; ExtractGeneralUserInfo ( ) ; Console . Log ( " Extracting ▁ Inspected ▁ User ▁ Info . . . " ) ; ExtractInspectedUserInfo ( ) ; Console . Log ( " Finding ▁ Inspected ▁ Users ▁ Duplicates . . . " ) ; FindDuplicates ( ) ; SaveInspectedUsersMongo ( ) ; } catch ( TwitterException e ) { Console . Log ( " Error ▁ @ Extractor " ) ; if ( e . isCausedByNetworkIssue ( ) ) { Console . WriteExceptionDump ( e , e . getErrorCode ( ) ) ; } } }
Kisamegr/Crawler | public void ExtractGeneralUserInfo ( ) throws TwitterException { DBCursor cursor = mongo . getStatusesCursor ( new BasicDBObject ( " trends " , 0 ) . append ( " index _ id " , 0 ) ) ; long currentTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < cursor . size ( ) ; i ++ ) { DBObject obj = cursor . next ( ) ; Status status = TwitterObjectFactory . createStatus ( obj . toString ( ) ) ; User user = status . getUser ( ) ; long age = currentTime - user . getCreatedAt ( ) . getTime ( ) ; int followers = user . getFollowersCount ( ) ; int friends = user . getFriendsCount ( ) ; mongo . addGeneralUserInfo ( user . getId ( ) , age , followers , friends ) ; } }
Kisamegr/Crawler | public void ExtractInspectedUserInfo ( ) throws TwitterException { HashMap < Long , HashMap < String , Integer > > sourcesCounter = new HashMap < > ( ) ; long currentTime = System . currentTimeMillis ( ) ; DBCursor cursor = mongo . getFollowedStatusesCursor ( ) ; for ( int i = 0 ; i < cursor . count ( ) ; i ++ ) { DBObject obj = cursor . next ( ) ; Status status = TwitterObjectFactory . createStatus ( obj . toString ( ) ) ; long id = status . getUser ( ) . getId ( ) ; InspectedUser user ; if ( ! userMap . containsKey ( id ) ) { user = new InspectedUser ( ) ; user . setId ( id ) ; userMap . put ( id , user ) ; } else user = userMap . get ( id ) ; user . setFollowers ( status . getUser ( ) . getFollowersCount ( ) ) ; user . setFriends ( status . getUser ( ) . getFriendsCount ( ) ) ; user . setAge ( currentTime - status . getUser ( ) . getCreatedAt ( ) . getTime ( ) ) ; if ( ! status . isRetweet ( ) ) user . addTweets ( ) ; else user . addRetweets ( ) ; if ( status . getInReplyToUserId ( ) != - 1 ) user . addReplies ( ) ; user . addUserMentions ( status . getUserMentionEntities ( ) . length ) ; user . addHashtags ( status . getHashtagEntities ( ) . length ) ; if ( status . getHashtagEntities ( ) . length > 0 ) user . addHashtaggedTweets ( ) ; if ( status . getURLEntities ( ) . length > 0 ) user . addUrlTweets ( ) ; String fullSource = status . getSource ( ) ; String source = fullSource . split ( " < | > " ) [ 2 ] ; if ( ! sourcesCounter . containsKey ( user . getId ( ) ) ) sourcesCounter . put ( user . getId ( ) , new HashMap < String , Integer > ( ) ) ; HashMap < String , Integer > userSourceMap = sourcesCounter . get ( user . getId ( ) ) ; if ( userSourceMap . containsKey ( source ) ) userSourceMap . put ( source , userSourceMap . get ( source ) + 1 ) ; else userSourceMap . put ( source , 1 ) ; } for ( Entry < Long , HashMap < String , Integer > > userSources : sourcesCounter . entrySet ( ) ) { String maxSource = null ; int max = - 1 ; for ( Entry < String , Integer > s : userSources . getValue ( ) . entrySet ( ) ) { if ( s . getValue ( ) > max ) { maxSource = s . getKey ( ) ; max = s . getValue ( ) ; } } userMap . get ( userSources . getKey ( ) ) . setMaxSource ( maxSource ) ; } Iterator < Entry < Long , InspectedUser > > it = userMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Entry < Long , InspectedUser > en = it . next ( ) ; if ( en . getValue ( ) . getTweets ( ) + en . getValue ( ) . getRetweets ( ) < 5 ) it . remove ( ) ; } }
Kisamegr/Crawler | public void FindDuplicates ( ) throws TwitterException { List < Number > userList = mongo . getInspectedUserIDs ( ) ; for ( Number userID : userList ) { InspectedUser user = userMap . get ( userID . longValue ( ) ) ; if ( user != null ) { DBCursor cursor = mongo . getFollowedStatusesCursor ( userID . longValue ( ) ) ; ArrayList < String > twitch = new ArrayList < > ( ) ; for ( int i = 0 ; i < cursor . size ( ) ; i ++ ) { DBObject obj = cursor . next ( ) ; Status status = TwitterObjectFactory . createStatus ( obj . toString ( ) ) ; if ( ! status . isRetweet ( ) && status . getInReplyToUserId ( ) == - 1 ) { StringBuilder tweet = new StringBuilder ( ) ; tweet . append ( status . getText ( ) ) ; for ( UserMentionEntity mention : status . getUserMentionEntities ( ) ) { int index_start = tweet . indexOf ( mention . getText ( ) ) ; if ( index_start != - 1 ) tweet . delete ( index_start , index_start + mention . getText ( ) . length ( ) ) ; } for ( URLEntity url : status . getURLEntities ( ) ) { int index_start = tweet . indexOf ( url . getText ( ) ) ; if ( index_start != - 1 ) tweet . delete ( index_start , index_start + url . getText ( ) . length ( ) ) ; } twitch . add ( tweet . toString ( ) ) ; } } int totalSimilar = 0 ; for ( int x = 0 ; x < twitch . size ( ) ; x ++ ) { for ( int y = x + 1 ; y < twitch . size ( ) ; y ++ ) { float percent = LevenshteinDistance ( twitch . get ( x ) , twitch . get ( y ) ) ; if ( percent < 0.1 ) totalSimilar ++ ; } } if ( twitch . size ( ) > 0 ) user . setDuplicateRatio ( ( double ) totalSimilar / twitch . size ( ) ) ; else user . setDuplicateRatio ( 0 ) ; } } }
Kisamegr/Crawler | public void SaveInspectedUsersMongo ( ) { for ( Entry < Long , InspectedUser > entry : userMap . entrySet ( ) ) { mongo . addInspectedUserInfo ( entry . getValue ( ) ) ; } }
Kisamegr/Crawler | public float LevenshteinDistance ( String s0 , String s1 ) { int len0 = s0 . length ( ) + 1 ; int len1 = s1 . length ( ) + 1 ; int [ ] cost = new int [ len0 ] ; int [ ] newcost = new int [ len0 ] ; for ( int i = 0 ; i < len0 ; i ++ ) cost [ i ] = i ; for ( int j = 1 ; j < len1 ; j ++ ) { newcost [ 0 ] = j ; for ( int i = 1 ; i < len0 ; i ++ ) { int match = ( s0 . charAt ( i - 1 ) == s1 . charAt ( j - 1 ) ) ? 0 : 1 ; int cost_replace = cost [ i - 1 ] + match ; int cost_insert = cost [ i ] + 1 ; int cost_delete = newcost [ i - 1 ] + 1 ; newcost [ i ] = Math . min ( Math . min ( cost_insert , cost_delete ) , cost_replace ) ; } int [ ] swap = cost ; cost = newcost ; newcost = swap ; } return ( float ) cost [ len0 - 1 ] / ( s0 . length ( ) + s1 . length ( ) ) ; }
steve1rm/busbymovies | public MovieDbHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; }
steve1rm/busbymovies | @ Override public void onCreate ( SQLiteDatabase db ) { final String CREATE_TABLE = " CREATE ▁ TABLE ▁ " + MovieContract . MovieEntry . TABLE_NAME + " ( ▁ " + MovieContract . MovieEntry . _ID + " ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , ▁ " + MovieContract . MovieEntry . MOVIE_ID + " ▁ INTEGER ▁ NOT ▁ NULL , ▁ " + MovieContract . MovieEntry . POSTER_PATH + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . OVERVIEW + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . RELEASE_DATE + " ▁ TEXT ▁ NOT ▁ NULL , ▁ " + MovieContract . MovieEntry . TITLE + " ▁ TEXT ▁ NOT ▁ NULL , ▁ " + MovieContract . MovieEntry . BACKDROP_PATH + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . VOTE_AVERAGE + " ▁ REAL , ▁ " + MovieContract . MovieEntry . VOTE_COUNT + " ▁ REAL , ▁ " + MovieContract . MovieEntry . TAGLINE + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . HOMEPATH + " ▁ TEXT , ▁ " + MovieContract . MovieEntry . RUNTIME + " ▁ INTEGER " + " ) ; " ; db . execSQL ( CREATE_TABLE ) ; }
steve1rm/busbymovies | @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { if ( newVersion > oldVersion ) { Timber . d ( " onUpgrade ▁ old ▁ version : ▁ % d ▁ new ▁ version ▁ % d " , oldVersion , newVersion ) ; final String DROP_TABLE = " DROP ▁ TABLE ▁ IF ▁ EXISTS ▁ " + MovieContract . MovieEntry . TABLE_NAME ; db . execSQL ( DROP_TABLE ) ; onCreate ( db ) ; } }
oivarc/j2ee-samples | public Page ( ) { super ( ) ; }
oivarc/j2ee-samples | public Page ( final List < T > someContent , final int someCount ) { this ( ) ; content = someContent ; count = someCount ; }
oivarc/j2ee-samples | public List < T > getContent ( ) { return content ; }
oivarc/j2ee-samples | public void setContent ( final List < T > someContent ) { content = someContent ; }
oivarc/j2ee-samples | public int getCount ( ) { return count ; }
oivarc/j2ee-samples | public void setCount ( final int someCount ) { count = someCount ; }
yeastrc/proxl-web-app | private DB_Insert_UnifiedRepPepIsotopeLabelLookupDAO ( ) { }
yeastrc/proxl-web-app | public void save ( UnifiedRepPepIsotopeLabelLookupDTO item , Connection conn ) throws Exception { PreparedStatement pstmt = null ; ResultSet rs = null ; final String sql = SAVE_SQL ; try { pstmt = conn . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; int counter = 0 ; counter ++ ; pstmt . setInt ( counter , item . getRpMatchedPeptideId ( ) ) ; counter ++ ; pstmt . setInt ( counter , item . getIsotopeLabelId ( ) ) ; pstmt . executeUpdate ( ) ; rs = pstmt . getGeneratedKeys ( ) ; if ( rs . next ( ) ) { item . setId ( rs . getInt ( 1 ) ) ; } else throw new Exception ( " Failed ▁ to ▁ insert ▁ UnifiedRepPepIsotopeLabelLookupDTO " ) ; } catch ( Exception e ) { String msg = " ERROR : ▁ sql : ▁ " + sql ; log . error ( msg , e ) ; throw e ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Throwable t ) { ; } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( Throwable t ) { ; } pstmt = null ; } } }
fSergio101/orchextra-android-sdk | public RegionMonitoringScannerImpl ( ContextProvider contextProvider , BeaconManager beaconManager , MonitoringListener monitoringListener , BeaconsController beaconsController , BeaconRegionAndroidMapper regionMapper ) { this . beaconManager = beaconManager ; this . beaconsController = beaconsController ; this . context = contextProvider . getApplicationContext ( ) ; this . monitoringListener = monitoringListener ; this . regionMapper = regionMapper ; this . beaconManager . setMonitorNotifier ( this ) ; }
fSergio101/orchextra-android-sdk | @ Override public void onBeaconServiceConnect ( ) { obtainRegionsToScan ( ) ; }
fSergio101/orchextra-android-sdk | @ Override public Context getApplicationContext ( ) { return context ; }
fSergio101/orchextra-android-sdk | @ Override public void unbindService ( ServiceConnection serviceConnection ) { context . unbindService ( serviceConnection ) ; }
fSergio101/orchextra-android-sdk | @ Override public boolean bindService ( Intent intent , ServiceConnection serviceConnection , int i ) { return context . bindService ( intent , serviceConnection , i ) ; }
fSergio101/orchextra-android-sdk | @ Override public void didEnterRegion ( Region region ) { OrchextraRegion orchextraRegion = regionMapper . externalClassToModel ( region ) ; beaconsController . onRegionEnter ( orchextraRegion ) ; monitoringListener . onRegionEnter ( region ) ; regionsInEnter . add ( region ) ; GGGLogImpl . log ( " ENTER ▁ BEACON ▁ REGION ▁ : ▁ " + region . getUniqueId ( ) ) ; }
fSergio101/orchextra-android-sdk | @ Override public void didExitRegion ( Region region ) { OrchextraRegion orchextraRegion = regionMapper . externalClassToModel ( region ) ; beaconsController . onRegionExit ( orchextraRegion ) ; monitoringListener . onRegionExit ( region ) ; regionsInEnter . remove ( region ) ; GGGLogImpl . log ( " EXIT ▁ BEACON ▁ REGION ▁ : ▁ " + region . getUniqueId ( ) ) ; }
fSergio101/orchextra-android-sdk | @ Override public void didDetermineStateForRegion ( int i , Region region ) { }
fSergio101/orchextra-android-sdk | @ Override public void initMonitoring ( ) { beaconManager . bind ( this ) ; }
fSergio101/orchextra-android-sdk | @ Override public void stopMonitoring ( ) { stopMonitoringRegions ( regionsToBeMonitored ) ; monitoring = false ; regionsInEnter . clear ( ) ; beaconManager . unbind ( this ) ; }
fSergio101/orchextra-android-sdk | private void obtainRegionsToScan ( ) { beaconsController . getAllRegionsFromDataBase ( this ) ; }
fSergio101/orchextra-android-sdk | @ Override public boolean isMonitoring ( ) { return monitoring ; }
fSergio101/orchextra-android-sdk | @ Override public void setRunningMode ( AppRunningModeType appRunningModeType ) { beaconManager . setBackgroundMode ( appRunningModeType == AppRunningModeType . BACKGROUND ) ; }
fSergio101/orchextra-android-sdk | @ Override public void updateRegions ( List deletedRegions , List newRegions ) { if ( ! deletedRegions . isEmpty ( ) ) { List < Region > deleted = regionMapper . modelListToExternalClassList ( deletedRegions ) ; stopMonitoringRegions ( deleted ) ; } if ( ! newRegions . isEmpty ( ) ) { List < Region > added = regionMapper . modelListToExternalClassList ( newRegions ) ; startMonitoringRegions ( added ) ; } }
fSergio101/orchextra-android-sdk | @ Override public void onRegionsReady ( List < OrchextraRegion > regions ) { List < Region > altRegions = regionMapper . modelListToExternalClassList ( regions ) ; this . regionsToBeMonitored . clear ( ) ; this . regionsToBeMonitored . addAll ( altRegions ) ; startMonitoringRegions ( altRegions ) ; }
fSergio101/orchextra-android-sdk | private void startMonitoringRegions ( List < Region > altRegions ) { try { for ( Region region : altRegions ) { beaconManager . startMonitoringBeaconsInRegion ( region ) ; GGGLogImpl . log ( " Start ▁ Beacons ▁ Monitoring ▁ for ▁ region ▁ " + region . getUniqueId ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } monitoring = true ; }
fSergio101/orchextra-android-sdk | private void stopMonitoringRegions ( List < Region > altRegions ) { try { for ( Region region : altRegions ) { beaconManager . stopMonitoringBeaconsInRegion ( region ) ; GGGLogImpl . log ( " Stop ▁ Beacons ▁ Monitoring ▁ for ▁ region ▁ " + region . getUniqueId ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } }
fSergio101/orchextra-android-sdk | public List < Region > obtainRegionsInRange ( ) { return regionsInEnter ; }
adrapereira/jena | @ Test public void setup_01 ( ) { assertTrue ( RDFLanguages . isRegistered ( THRIFT ) ) ; }
adrapereira/jena | @ Test public void setup_02 ( ) { Lang lang = RDFLanguages . filenameToLang ( " data . rt " ) ; assertEquals ( lang , THRIFT ) ; }
adrapereira/jena | @ Test public void setup_03 ( ) { assertTrue ( RDFParserRegistry . isQuads ( THRIFT ) ) ; assertTrue ( RDFParserRegistry . isTriples ( THRIFT ) ) ; assertNotNull ( RDFParserRegistry . getFactory ( THRIFT ) ) ; }
adrapereira/jena | @ Test public void setup_04 ( ) { assertTrue ( RDFWriterRegistry . contains ( THRIFT ) ) ; assertNotNull ( RDFWriterRegistry . getWriterDatasetFactory ( THRIFT ) ) ; assertTrue ( RDFWriterRegistry . contains ( RDFFormat . RDF_THRIFT ) ) ; assertNotNull ( RDFWriterRegistry . getWriterDatasetFactory ( RDFFormat . RDF_THRIFT ) ) ; assertTrue ( RDFWriterRegistry . contains ( RDFFormat . RDF_THRIFT_VALUES ) ) ; assertNotNull ( RDFWriterRegistry . getWriterDatasetFactory ( RDFFormat . RDF_THRIFT_VALUES ) ) ; }
emory-libraries-ecds/namedropper-oxygen | public SelectionActionGeoNames ( StandalonePluginWorkspace ws ) { super ( ws ) ; this . putValue ( Action . NAME , this . name ) ; this . putValue ( Action . ACCELERATOR_KEY , this . shortcut ) ; }
emory-libraries-ecds/namedropper-oxygen | public String getShortName ( ) { return this . shortName ; }
emory-libraries-ecds/namedropper-oxygen | public String processSelection ( String selection ) throws Exception { String result = selection ; if ( this . tagAllowedAtSelection ( DocumentType . NameType . GEOGRAPHIC ) == false ) { throw new Exception ( " Tag ▁ is ▁ not ▁ allowed ▁ in ▁ the ▁ current ▁ context " ) ; } result = this . queryGeoNames ( selection ) ; if ( result == null ) { result = selection ; } return result ; }
emory-libraries-ecds/namedropper-oxygen | public String queryGeoNames ( String text ) throws Exception { String result = null ; if ( this . docType == null ) { return result ; } String username = SelectionActionGeoNames . getGeoNamesUsername ( ) ; if ( username . isEmpty ( ) ) { throw new Exception ( " Please ▁ set ▁ a ▁ GeoNames . org ▁ username " ) ; } WebService . setUserName ( username ) ; ToponymSearchCriteria search = new ToponymSearchCriteria ( ) ; search . setQ ( text ) ; ToponymSearchResult searchResult = WebService . search ( search ) ; if ( searchResult . getTotalResultsCount ( ) == 0 ) { throw new Exception ( " No ▁ Results " ) ; } Toponym selection = this . getUserSelection ( searchResult . getToponyms ( ) ) ; if ( selection != null ) { result = this . docType . makeTag ( text , selection ) ; } return result ; }
emory-libraries-ecds/namedropper-oxygen | public Toponym getUserSelection ( List < Toponym > suggestions ) { Object [ ] choices = suggestions . toArray ( ) ; String [ ] labels = new String [ suggestions . size ( ) ] ; for ( int i = 0 ; i < suggestions . size ( ) ; i ++ ) { Toponym t = suggestions . get ( i ) ; labels [ i ] = t . getName ( ) ; if ( ! t . getCountryName ( ) . isEmpty ( ) ) { labels [ i ] += String . format ( " ▁ ( % s ) " , t . getCountryName ( ) ) ; } } Object choice = JOptionPane . showInputDialog ( null , " Names " , " Search ▁ Results " , JOptionPane . PLAIN_MESSAGE , null , labels , labels [ 0 ] ) ; if ( choice == null ) { return null ; } else { return suggestions . get ( Arrays . asList ( labels ) . indexOf ( choice ) ) ; } }
emory-libraries-ecds/namedropper-oxygen | public boolean hasUserOptions ( ) { return true ; }
emory-libraries-ecds/namedropper-oxygen | public Action getOptionsAction ( ) { final Action showOptions = new AbstractAction ( ) { public void actionPerformed ( ActionEvent selection ) { String dialogLabel = " GeoNames . org ▁ settings " ; JTextField username = new JTextField ( SelectionActionGeoNames . getGeoNamesUsername ( ) , 15 ) ; JPanel optionPanel = new JPanel ( ) ; java . awt . GridLayout layout = new java . awt . GridLayout ( 2 , 2 ) ; optionPanel . setLayout ( layout ) ; optionPanel . add ( new JLabel ( " GeoNames ▁ API ▁ Username : ▁ " ) ) ; optionPanel . add ( username ) ; int result = JOptionPane . showConfirmDialog ( ( java . awt . Frame ) workspace . getParentFrame ( ) , optionPanel , dialogLabel , JOptionPane . OK_CANCEL_OPTION ) ; if ( result == JOptionPane . OK_OPTION ) { SelectionActionGeoNames . setGeoNamesUsername ( username . getText ( ) ) ; } } } ; return showOptions ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test ( expected = NullPointerException . class ) public void initAutoCompleterWithNullPreferenceThrowsException ( ) { new BibtexKeyAutoCompleter ( null ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeWithoutAddingAnythingReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeAfterAddingNullReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; autoCompleter . addBibtexEntry ( null ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeAfterAddingEmptyEntryReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " testKey " ) ; Assert . assertEquals ( Arrays . asList ( " testKey " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeBeginnigOfKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Arrays . asList ( " testKey " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeLowercaseKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " testkey " ) ; Assert . assertEquals ( Arrays . asList ( " testKey " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeNullReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( null ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeEmptyStringReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeReturnsMultipleResults ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entryOne = new BibEntry ( ) ; entryOne . setCiteKey ( " testKeyOne " ) ; autoCompleter . addBibtexEntry ( entryOne ) ; BibEntry entryTwo = new BibEntry ( ) ; entryTwo . setCiteKey ( " testKeyTwo " ) ; autoCompleter . addBibtexEntry ( entryTwo ) ; List < String > result = autoCompleter . complete ( " testKey " ) ; Assert . assertEquals ( Arrays . asList ( " testKeyOne " , " testKeyTwo " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeShortKeyReturnsKey ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " key " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " k " ) ; Assert . assertEquals ( Arrays . asList ( " key " ) , result ) ; }
alanbrandini/DC-UFSCar-ES2-201701-Grupo01 | @ Test public void completeTooShortInputReturnsNothing ( ) { AutoCompletePreferences preferences = mock ( AutoCompletePreferences . class ) ; when ( preferences . getShortestLengthToComplete ( ) ) . thenReturn ( 100 ) ; BibtexKeyAutoCompleter autoCompleter = new BibtexKeyAutoCompleter ( preferences ) ; BibEntry entry = new BibEntry ( ) ; entry . setCiteKey ( " testKey " ) ; autoCompleter . addBibtexEntry ( entry ) ; List < String > result = autoCompleter . complete ( " test " ) ; Assert . assertEquals ( Collections . emptyList ( ) , result ) ; }
apache/incubator-asterixdb | public ActiveEvent ( JobId jobId , Kind eventKind , EntityId entityId , Object eventObject ) { this . jobId = jobId ; this . entityId = entityId ; this . eventKind = eventKind ; this . eventObject = eventObject ; }
apache/incubator-asterixdb | public JobId getJobId ( ) { return jobId ; }
apache/incubator-asterixdb | public EntityId getEntityId ( ) { return entityId ; }
apache/incubator-asterixdb | public Kind getEventKind ( ) { return eventKind ; }
apache/incubator-asterixdb | public Object getEventObject ( ) { return eventObject ; }
apache/incubator-asterixdb | @ Override public String toString ( ) { return " JobId : " + jobId + " , " + " EntityId : " + entityId + " , ▁ " + " Kind " + eventKind ; }
apache/incubator-asterixdb | @ Override public boolean equals ( Object o ) { if ( ! ( o instanceof ActiveEvent ) ) { return false ; } if ( this == o ) { return true ; } ActiveEvent other = ( ActiveEvent ) o ; return Objects . equals ( entityId , other . entityId ) && Objects . equals ( eventKind , other . eventKind ) && Objects . equals ( eventObject , other . eventObject ) ; }
apache/incubator-asterixdb | @ Override public int hashCode ( ) { return Objects . hash ( jobId , entityId , eventKind , eventObject ) ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof UpdateQueueNameResult == false ) return false ; UpdateQueueNameResult other = ( UpdateQueueNameResult ) obj ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; return hashCode ; }
aws/aws-sdk-java | @ Override public UpdateQueueNameResult clone ( ) { try { return ( UpdateQueueNameResult ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
georgewfraser/vscode-javac | public void test ( ) { print ( this :: ) }
georgewfraser/vscode-javac | private void print ( Supplier < String > message ) { System . out . println ( message . get ( ) ) ; }
georgewfraser/vscode-javac | private String testMethods ( ) { return " foo " ; }
MohammedHammam/camel | public WebsocketEndpoint ( WebsocketComponent component , String uri , String resourceUri , Map < String , Object > parameters ) { super ( uri , component ) ; this . resourceUri = resourceUri ; this . memoryStore = new MemoryWebsocketStore ( ) ; this . sync = new DefaultNodeSynchronization ( memoryStore ) ; this . component = component ; try { this . uri = new URI ( uri ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( e ) ; } }
MohammedHammam/camel | @ Override public WebsocketComponent getComponent ( ) { ObjectHelper . notNull ( component , " component " ) ; return ( WebsocketComponent ) super . getComponent ( ) ; }
MohammedHammam/camel | @ Override public Consumer createConsumer ( Processor processor ) throws Exception { ObjectHelper . notNull ( component , " component " ) ; WebsocketConsumer consumer = new WebsocketConsumer ( this , processor ) ; configureConsumer ( consumer ) ; return consumer ; }
MohammedHammam/camel | @ Override public Producer createProducer ( ) throws Exception { return new WebsocketProducer ( this , memoryStore ) ; }
MohammedHammam/camel | public void connect ( WebsocketConsumer consumer ) throws Exception { component . connect ( consumer ) ; component . addServlet ( sync , consumer , resourceUri ) ; }
MohammedHammam/camel | public void disconnect ( WebsocketConsumer consumer ) throws Exception { component . disconnect ( consumer ) ; }
MohammedHammam/camel | public void connect ( WebsocketProducer producer ) throws Exception { component . connect ( producer ) ; component . addServlet ( sync , producer , resourceUri ) ; }
MohammedHammam/camel | public void disconnect ( WebsocketProducer producer ) throws Exception { component . disconnect ( producer ) ; }
MohammedHammam/camel | @ Override public boolean isSingleton ( ) { return true ; }
MohammedHammam/camel | public URI getUri ( ) { return uri ; }
MohammedHammam/camel | public Integer getPort ( ) { return port ; }
MohammedHammam/camel | public String getHost ( ) { return host ; }
MohammedHammam/camel | public void setHost ( String host ) { this . host = host ; }
MohammedHammam/camel | public void setPort ( int port ) { this . port = port ; }
MohammedHammam/camel | public String getStaticResources ( ) { return staticResources ; }
MohammedHammam/camel | public void setStaticResources ( String staticResources ) { this . staticResources = staticResources ; }
MohammedHammam/camel | public Boolean getSendToAll ( ) { return sendToAll ; }
MohammedHammam/camel | public void setSendToAll ( Boolean sendToAll ) { this . sendToAll = sendToAll ; }
MohammedHammam/camel | public String getProtocol ( ) { return uri . getScheme ( ) ; }
MohammedHammam/camel | public String getPath ( ) { return uri . getPath ( ) ; }
MohammedHammam/camel | public void setSessionSupport ( boolean support ) { sessionSupport = support ; }
MohammedHammam/camel | public boolean isSessionSupport ( ) { return sessionSupport ; }
MohammedHammam/camel | public Integer getBufferSize ( ) { return bufferSize ; }
MohammedHammam/camel | public void setBufferSize ( Integer bufferSize ) { this . bufferSize = bufferSize ; }
MohammedHammam/camel | public Integer getMaxIdleTime ( ) { return maxIdleTime ; }
MohammedHammam/camel | public void setMaxIdleTime ( Integer maxIdleTime ) { this . maxIdleTime = maxIdleTime ; }
MohammedHammam/camel | public Integer getMaxTextMessageSize ( ) { return maxTextMessageSize ; }
MohammedHammam/camel | public void setMaxTextMessageSize ( Integer maxTextMessageSize ) { this . maxTextMessageSize = maxTextMessageSize ; }
MohammedHammam/camel | public Integer getMaxBinaryMessageSize ( ) { return maxBinaryMessageSize ; }
MohammedHammam/camel | public void setMaxBinaryMessageSize ( Integer maxBinaryMessageSize ) { this . maxBinaryMessageSize = maxBinaryMessageSize ; }
MohammedHammam/camel | public Integer getMinVersion ( ) { return minVersion ; }
MohammedHammam/camel | public void setMinVersion ( Integer minVersion ) { this . minVersion = minVersion ; }
MohammedHammam/camel | public List < Handler > getHandlers ( ) { return handlers ; }
MohammedHammam/camel | public void setHandlers ( List < Handler > handlers ) { this . handlers = handlers ; }
MohammedHammam/camel | public SSLContextParameters getSslContextParameters ( ) { return sslContextParameters ; }
MohammedHammam/camel | public void setSslContextParameters ( SSLContextParameters sslContextParameters ) { this . sslContextParameters = sslContextParameters ; }
MohammedHammam/camel | public boolean isEnableJmx ( ) { return this . enableJmx ; }
MohammedHammam/camel | public void setEnableJmx ( boolean enableJmx ) { this . enableJmx = enableJmx ; }
MohammedHammam/camel | public String getAllowedOrigins ( ) { return allowedOrigins ; }
MohammedHammam/camel | public void setAllowedOrigins ( String allowedOrigins ) { this . allowedOrigins = allowedOrigins ; }
MohammedHammam/camel | public boolean isCrossOriginFilterOn ( ) { return crossOriginFilterOn ; }
MohammedHammam/camel | public void setCrossOriginFilterOn ( boolean crossOriginFilterOn ) { this . crossOriginFilterOn = crossOriginFilterOn ; }
MohammedHammam/camel | public String getFilterPath ( ) { return filterPath ; }
MohammedHammam/camel | public void setFilterPath ( String filterPath ) { this . filterPath = filterPath ; }
MohammedHammam/camel | public String getResourceUri ( ) { return resourceUri ; }
MohammedHammam/camel | public void setResourceUri ( String resourceUri ) { this . resourceUri = resourceUri ; }
MohammedHammam/camel | @ Override protected void doStart ( ) throws Exception { ServiceHelper . startService ( memoryStore ) ; super . doStart ( ) ; }
MohammedHammam/camel | @ Override protected void doStop ( ) throws Exception { ServiceHelper . stopService ( memoryStore ) ; super . doStop ( ) ; }
Azure/azure-sdk-for-java | @ Generated SqlScriptAsyncClient ( SqlScriptsImpl serviceClient ) { this . serviceClient = serviceClient ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . COLLECTION ) public PagedFlux < SqlScriptResource > getSqlScriptsByWorkspace ( ) { return this . serviceClient . getSqlScriptsByWorkspaceAsync ( ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < SqlScriptResource > > createOrUpdateSqlScriptWithResponse ( String sqlScriptName , SqlScriptResource sqlScript , String ifMatch ) { return this . serviceClient . createOrUpdateSqlScriptWithResponseAsync ( sqlScriptName , sqlScript , ifMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > createOrUpdateSqlScript ( String sqlScriptName , SqlScriptResource sqlScript , String ifMatch ) { return this . serviceClient . createOrUpdateSqlScriptAsync ( sqlScriptName , sqlScript , ifMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > createOrUpdateSqlScript ( String sqlScriptName , SqlScriptResource sqlScript ) { return this . serviceClient . createOrUpdateSqlScriptAsync ( sqlScriptName , sqlScript ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < SqlScriptResource > > getSqlScriptWithResponse ( String sqlScriptName , String ifNoneMatch ) { return this . serviceClient . getSqlScriptWithResponseAsync ( sqlScriptName , ifNoneMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > getSqlScript ( String sqlScriptName , String ifNoneMatch ) { return this . serviceClient . getSqlScriptAsync ( sqlScriptName , ifNoneMatch ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < SqlScriptResource > getSqlScript ( String sqlScriptName ) { return this . serviceClient . getSqlScriptAsync ( sqlScriptName ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < Void > > deleteSqlScriptWithResponse ( String sqlScriptName ) { return this . serviceClient . deleteSqlScriptWithResponseAsync ( sqlScriptName ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Void > deleteSqlScript ( String sqlScriptName ) { return this . serviceClient . deleteSqlScriptAsync ( sqlScriptName ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Response < Void > > renameSqlScriptWithResponse ( String sqlScriptName , ArtifactRenameRequest request ) { return this . serviceClient . renameSqlScriptWithResponseAsync ( sqlScriptName , request ) ; }
Azure/azure-sdk-for-java | @ Generated @ ServiceMethod ( returns = ReturnType . SINGLE ) public Mono < Void > renameSqlScript ( String sqlScriptName , ArtifactRenameRequest request ) { return this . serviceClient . renameSqlScriptAsync ( sqlScriptName , request ) ; }
wolfdog007/aruzhev | public int [ ] mergingArray ( int [ ] firstArray , int [ ] secondArray ) { int [ ] resultArray = new int [ firstArray . length + secondArray . length ] ; for ( int i = 0 , j = 0 ; i + j < resultArray . length ; ) { resultArray [ i + j ] = firstArray [ i ] <= secondArray [ j ] ? firstArray [ i ++ ] : secondArray [ j ++ ] ; if ( i == firstArray . length ) { for ( ; j < secondArray . length ; j ++ ) { resultArray [ i + j ] = secondArray [ j ] ; } } if ( j == secondArray . length ) { for ( ; i < firstArray . length ; i ++ ) { resultArray [ i + j ] = firstArray [ i ] ; } } } return resultArray ; }
Legioth/vaadin | @ Override public void setup ( ) throws Exception { super . setup ( ) ; openTestURL ( ) ; TableElement table = $ ( TableElement . class ) . id ( " table " ) ; rowHeight = table . getCell ( 1 , 0 ) . getLocation ( ) . getY ( ) - table . getCell ( 0 , 0 ) . getLocation ( ) . getY ( ) ; wrapper = findElement ( By . className ( " v - table - body - wrapper " ) ) ; }
Legioth/vaadin | @ Test public void testScrollingThenUpdatingContents ( ) throws Exception { testBenchElement ( wrapper ) . scroll ( 44 * rowHeight ) ; waitForScrollToFinish ( ) ; Assert . assertTrue ( " Button ▁ widget ▁ was ▁ not ▁ found ▁ after ▁ scrolling ▁ for ▁ the ▁ first ▁ time " , ! findElements ( By . id ( "46" ) ) . isEmpty ( ) ) ; WebElement refreshButton = findElement ( By . id ( " refresh " ) ) ; refreshButton . click ( ) ; testBenchElement ( wrapper ) . scroll ( 44 * rowHeight ) ; waitForScrollToFinish ( ) ; Assert . assertTrue ( " Button ▁ widget ▁ was ▁ not ▁ found ▁ after ▁ refreshing ▁ container ▁ items . " , ! findElements ( By . id ( "46" ) ) . isEmpty ( ) ) ; }
Legioth/vaadin | private void waitForScrollToFinish ( ) { waitUntil ( new ExpectedCondition < Boolean > ( ) { @ Override public Boolean apply ( WebDriver input ) { List < WebElement > elements = findElements ( By . className ( " v - table - scrollposition " ) ) ; return elements . isEmpty ( ) || ! elements . get ( 0 ) . isDisplayed ( ) ; } @ Override public String toString ( ) { return " scroll ▁ position ▁ indicator ▁ to ▁ vanish " ; } } ) ; }
avafanasiev/groovy | @ Override protected void compile ( ) { GroovyClassLoader gcl = createClassLoader ( ) ; JavaStubCompilationUnit cu = new JavaStubCompilationUnit ( config , gcl , destdir ) ; int count = 0 ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File basedir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! basedir . exists ( ) ) { throw new BuildException ( " Source ▁ directory ▁ does ▁ not ▁ exist : ▁ " + basedir , getLocation ( ) ) ; } DirectoryScanner scanner = getDirectoryScanner ( basedir ) ; String [ ] includes = scanner . getIncludedFiles ( ) ; log . debug ( " Including ▁ files ▁ from : ▁ " + basedir ) ; for ( int j = 0 ; j < includes . length ; j ++ ) { log . debug ( " ▁ ▁ ▁ ▁ " + includes [ j ] ) ; File file = new File ( basedir , includes [ j ] ) ; cu . addSource ( file ) ; if ( ! includes [ j ] . endsWith ( " . java " ) ) { count ++ ; } } } if ( count > 0 ) { log . info ( " Generating ▁ " + count + " ▁ Java ▁ stub " + ( count > 1 ? " s " : " " ) + " ▁ to ▁ " + destdir ) ; cu . compile ( ) ; log . info ( " Generated ▁ " + cu . getStubCount ( ) + " ▁ Java ▁ stub ( s ) " ) ; } else { log . info ( " No ▁ sources ▁ found ▁ for ▁ stub ▁ generation " ) ; } }
PrinceOfAmber/OpenBlocks | public ItemOBGenericUnstackable ( ) { setMaxStackSize ( 1 ) ; setCreativeTab ( OpenBlocks . tabOpenBlocks ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | public EdgeExplorer ( int allowedEdges , EvaluationCtx ctx , URI startPolicy ) { this . node = ctx . getReductionGraph ( ) . getNode ( startPolicy ) ; this . ctx = ctx ; this . allowedEdges = allowedEdges ; AbstractPolicy parentPolicySet = ctx . getParentPolicySet ( ) ; if ( parentPolicySet != null ) { this . neighbors = getActiveChilds ( parentPolicySet . getChildren ( ) , ctx ) ; } else { this . neighbors = new ArrayList < AbstractPolicy > ( ) ; } this . neighborIter = this . neighbors . iterator ( ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | public boolean hasNext ( ) { return this . neighborIter . hasNext ( ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | public URI next ( ) { if ( ! this . neighborIter . hasNext ( ) ) { return null ; } AbstractPolicy neighbor = ( AbstractPolicy ) this . neighborIter . next ( ) ; Set < ReductionGraphEdge > fromEdges = this . ctx . getReductionGraph ( ) . getFromEdges ( this . node . getNodeId ( ) ) ; Iterator < ReductionGraphEdge > edgeIt = fromEdges . iterator ( ) ; while ( edgeIt . hasNext ( ) ) { ReductionGraphEdge edge = edgeIt . next ( ) ; if ( edge . getTo ( ) . equals ( neighbor . getId ( ) ) ) { if ( ( this . allowedEdges & edge . getType ( ) ) == edge . getType ( ) ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return neighbor . getId ( ) ; } else if ( edge . getType ( ) == ReductionGraphEdge . NOT_APPLICABLE ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return next ( ) ; } else if ( ( ( this . allowedEdges & ReductionGraphEdge . PP ) == ReductionGraphEdge . PP ) && edge . getType ( ) == ReductionGraphEdge . PI ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return next ( ) ; } else if ( ( ( this . allowedEdges & ReductionGraphEdge . DP ) == ReductionGraphEdge . DP ) && edge . getType ( ) == ReductionGraphEdge . DI ) { this . ctx . newEvent ( edge ) ; this . ctx . closeCurrentEvent ( ) ; return next ( ) ; } } } this . ctx . newEvent ( neighbor ) ; MatchResult matchResult = neighbor . match ( this . ctx ) ; switch ( matchResult . getResult ( ) ) { case MatchResult . NO_MATCH : this . ctx . closeCurrentEvent ( new Result ( Result . DECISION_NOT_APPLICABLE ) ) ; this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return next ( ) ; case MatchResult . INDETERMINATE : this . ctx . closeCurrentEvent ( new Result ( Result . DECISION_INDETERMINATE , this . ctx ) ) ; if ( this . ctx . getDecision ( ) == Result . DECISION_PERMIT ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . PI , matchResult . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . PI ) == ReductionGraphEdge . PI ) { return neighbor . getId ( ) ; } } else { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . DI , matchResult . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . DI ) == ReductionGraphEdge . DI ) { return neighbor . getId ( ) ; } } return next ( ) ; case MatchResult . MATCH : if ( neighbor instanceof PolicySet ) { this . ctx . saveParentPolicySet ( neighbor ) ; } else if ( neighbor instanceof PolicyReference ) { PolicyReference ref = ( PolicyReference ) neighbor ; if ( ref . getReferenceType ( ) == PolicyReference . POLICYSET_REFERENCE ) { this . ctx . saveParentPolicySet ( neighbor ) ; } } Result eval = neighbor . getCombiningAlg ( ) . combine ( this . ctx , neighbor . getCombiningParameters ( ) , neighbor . getChildElements ( ) ) ; if ( this . ctx . getDelegationDepth ( ) > neighbor . getMaxDelegationDepth ( ) ) { this . ctx . closeCurrentEvent ( " MaxDelegationDepth ▁ violated " ) ; this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return null ; } if ( this . ctx . supportsRevocation ( neighbor , this . node . getNodeId ( ) ) ) { Result nullResult = null ; this . ctx . closeCurrentEvent ( nullResult ) ; this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return null ; } this . ctx . closeCurrentEvent ( eval ) ; if ( neighbor instanceof PolicySet ) { this . ctx . popParentPolicySet ( ) ; this . ctx . popReductionGraph ( ) ; } else if ( neighbor instanceof PolicyReference ) { PolicyReference ref = ( PolicyReference ) neighbor ; if ( ref . getReferenceType ( ) == PolicyReference . POLICYSET_REFERENCE ) { this . ctx . popParentPolicySet ( ) ; this . ctx . popReductionGraph ( ) ; } } switch ( eval . getDecision ( ) ) { case Result . DECISION_PERMIT : if ( this . ctx . getDecision ( ) == Result . DECISION_PERMIT ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . PP ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . PP ) == ReductionGraphEdge . PP ) { return neighbor . getId ( ) ; } } else if ( this . ctx . getDecision ( ) == Result . DECISION_DENY ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . DP ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . DP ) == ReductionGraphEdge . DP ) { return neighbor . getId ( ) ; } } return next ( ) ; case Result . DECISION_INDETERMINATE : if ( this . ctx . getDecision ( ) == Result . DECISION_PERMIT ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . PI , eval . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . PI ) == ReductionGraphEdge . PI ) { return neighbor . getId ( ) ; } } else if ( this . ctx . getDecision ( ) == Result . DECISION_DENY ) { this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . DI , eval . getStatus ( ) ) ) ; if ( ( this . allowedEdges & ReductionGraphEdge . DI ) == ReductionGraphEdge . DI ) { return neighbor . getId ( ) ; } } return next ( ) ; default : this . ctx . getReductionGraph ( ) . setEdge ( new ReductionGraphEdge ( this . node . getNodeId ( ) , neighbor . getId ( ) , ReductionGraphEdge . NOT_APPLICABLE ) ) ; return next ( ) ; } } return next ( ) ; }
GenericBreakGlass/GenericBreakGlass-XACML | private List < AbstractPolicy > getActiveChilds ( List < PolicyTreeElement > allChilds , EvaluationCtx context ) { List < AbstractPolicy > activeChilds = new ArrayList < AbstractPolicy > ( ) ; Iterator < PolicyTreeElement > iter = allChilds . iterator ( ) ; while ( iter . hasNext ( ) ) { AbstractPolicy policy = ( AbstractPolicy ) iter . next ( ) ; URI elementId = null ; if ( policy instanceof PolicyReference ) { PolicyReference pr = ( PolicyReference ) policy ; elementId = pr . getReference ( ) ; } else { elementId = policy . getId ( ) ; } if ( ! context . getInactivePolicyIds ( ) . contains ( elementId ) ) { activeChilds . add ( policy ) ; } } return activeChilds ; }
xushaomin/apple-pay | public String getUserName ( ) { return userName ; }
xushaomin/apple-pay | public void setUserName ( String userName ) { this . userName = userName ; }
xushaomin/apple-pay | public BigDecimal getAvailableBalance ( ) { return this . balance . subtract ( unbalance ) ; }
xushaomin/apple-pay | public BigDecimal getAvailableSettAmount ( ) { BigDecimal subSettAmount = this . settAmount . subtract ( unbalance ) ; if ( getAvailableBalance ( ) . compareTo ( subSettAmount ) == - 1 ) { return getAvailableBalance ( ) ; } return subSettAmount ; }
xushaomin/apple-pay | public boolean availableBalanceIsEnough ( BigDecimal amount ) { return this . getAvailableBalance ( ) . compareTo ( amount ) >= 0 ; }
xushaomin/apple-pay | public String getAccountNo ( ) { return accountNo ; }
xushaomin/apple-pay | public void setAccountNo ( String accountNo ) { this . accountNo = accountNo == null ? null : accountNo . trim ( ) ; }
xushaomin/apple-pay | public BigDecimal getBalance ( ) { return balance ; }
xushaomin/apple-pay | public void setBalance ( BigDecimal balance ) { this . balance = balance ; }
xushaomin/apple-pay | public BigDecimal getUnbalance ( ) { return unbalance ; }
xushaomin/apple-pay | public void setUnbalance ( BigDecimal unbalance ) { this . unbalance = unbalance ; }
xushaomin/apple-pay | public BigDecimal getSecurityMoney ( ) { return securityMoney ; }
xushaomin/apple-pay | public void setSecurityMoney ( BigDecimal securityMoney ) { this . securityMoney = securityMoney ; }
xushaomin/apple-pay | public BigDecimal getTotalIncome ( ) { return totalIncome ; }
xushaomin/apple-pay | public void setTotalIncome ( BigDecimal totalIncome ) { this . totalIncome = totalIncome ; }
xushaomin/apple-pay | public BigDecimal getTotalExpend ( ) { return totalExpend ; }
xushaomin/apple-pay | public void setTotalExpend ( BigDecimal totalExpend ) { this . totalExpend = totalExpend ; }
xushaomin/apple-pay | public BigDecimal getTodayIncome ( ) { return todayIncome ; }
xushaomin/apple-pay | public void setTodayIncome ( BigDecimal todayIncome ) { this . todayIncome = todayIncome ; }
xushaomin/apple-pay | public BigDecimal getTodayExpend ( ) { return todayExpend ; }
xushaomin/apple-pay | public void setTodayExpend ( BigDecimal todayExpend ) { this . todayExpend = todayExpend ; }
xushaomin/apple-pay | public String getAccountType ( ) { return accountType ; }
xushaomin/apple-pay | public void setAccountType ( String accountType ) { this . accountType = accountType == null ? null : accountType . trim ( ) ; }
xushaomin/apple-pay | public BigDecimal getSettAmount ( ) { return settAmount ; }
xushaomin/apple-pay | public void setSettAmount ( BigDecimal settAmount ) { this . settAmount = settAmount ; }
xushaomin/apple-pay | public String getUserNo ( ) { return userNo ; }
xushaomin/apple-pay | public void setUserNo ( String userNo ) { this . userNo = userNo == null ? null : userNo . trim ( ) ; }
theonlyguills/doc-gym | @ Override public void init ( FilterConfig filterConfig ) throws ServletException { }
theonlyguills/doc-gym | if ( DOCFITNESS_CA . equals ( servletRequest . getServerName ( ) ) ) { HttpServletResponse response = ( HttpServletResponse ) servletResponse ; response . sendRedirect ( WWW_DOCFITNESS_CA ) ; return ; }
theonlyguills/doc-gym | @ Override public void destroy ( ) { }
leafclick/intellij-community | private Mixin ( @ NotNull PsiType type , @ Nullable ConditionInstruction condition , boolean negated ) { myType = type ; myCondition = condition ; myNegated = negated ; }
leafclick/intellij-community | private Mixin negate ( ) { return new Mixin ( myType , myCondition , ! myNegated ) ; }
leafclick/intellij-community | @ Override public String toString ( ) { return ( myNegated ? " ! " : " " ) + myType ; }
leafclick/intellij-community | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Mixin mixin = ( Mixin ) o ; if ( ! myType . equals ( mixin . myType ) ) return false ; if ( ! Objects . equals ( myCondition , mixin . myCondition ) ) return false ; return true ; }
leafclick/intellij-community | @ Override public int hashCode ( ) { int result = myType . hashCode ( ) ; result = 31 * result + ( myCondition != null ? myCondition . hashCode ( ) : 0 ) ; return result ; }
leafclick/intellij-community | private DFAType ( @ Nullable PsiType primary ) { this . primary = primary ; }
leafclick/intellij-community | public void addMixin ( @ Nullable PsiType mixin , @ Nullable ConditionInstruction instruction ) { if ( mixin == null ) { return ; } mixins . add ( new Mixin ( mixin , instruction , instruction != null && instruction . isNegated ( ) ) ) ; }
leafclick/intellij-community | @ Override public boolean equals ( Object obj ) { if ( obj == this ) return true ; if ( ! ( obj instanceof DFAType ) ) return false ; final DFAType other = ( DFAType ) obj ; if ( ! eq ( primary , other . primary ) ) return false ; if ( mixins . size ( ) != other . mixins . size ( ) ) return false ; for ( Mixin mixin1 : mixins ) { boolean contains = false ; for ( Mixin mixin2 : other . mixins ) { if ( mixin1 . equals ( mixin2 ) ) { contains = mixin1 . myNegated == mixin2 . myNegated ; break ; } } if ( ! contains ) return false ; } return true ; }
leafclick/intellij-community | @ Contract ( " - > ▁ new " ) @ NotNull public DFAType copy ( ) { final DFAType type = new DFAType ( primary ) ; type . mixins . addAll ( mixins ) ; return type ; }
leafclick/intellij-community | @ Contract ( " _ ▁ - > ▁ new " ) @ NotNull public DFAType negate ( @ NotNull NegatingGotoInstruction negation ) { DFAType result = copy ( ) ; final Set < ConditionInstruction > conditionsToNegate = negation . getCondition ( ) . getDependentConditions ( ) ; for ( ListIterator < Mixin > iterator = result . mixins . listIterator ( ) ; iterator . hasNext ( ) ; ) { Mixin mixin = iterator . next ( ) ; if ( conditionsToNegate . contains ( mixin . myCondition ) ) { iterator . set ( mixin . negate ( ) ) ; } } return result ; }
leafclick/intellij-community | @ Nullable public PsiType getResultType ( ) { if ( mixins . isEmpty ( ) ) return primary ; List < PsiType > types = new ArrayList < > ( ) ; if ( primary != null ) { types . add ( primary ) ; } for ( Mixin mixin : mixins ) { if ( mixin . myNegated ) { continue ; } if ( mixin . myType . equals ( PsiType . NULL ) ) { continue ; } types . add ( mixin . myType ) ; } if ( types . isEmpty ( ) ) return null ; return PsiIntersectionType . createIntersection ( types . toArray ( PsiType . createArray ( types . size ( ) ) ) ) ; }
leafclick/intellij-community | @ Override public String toString ( ) { return " { " + primary + " ▁ : ▁ " + mixins + " } " ; }
fraunhoferfokus/Fuzzino | public BadIpAddressesGenerator ( StringSpecification stringSpec , long seed ) { super ( stringSpec , seed ) ; this . owners . add ( this ) ; initHeuristics ( ) ; }
fraunhoferfokus/Fuzzino | public BadIpAddressesGenerator ( StringSpecification stringSpec , long seed , List < FuzzingHeuristic > owners ) { super ( stringSpec , seed , owners ) ; this . owners . add ( this ) ; initHeuristics ( ) ; }
fraunhoferfokus/Fuzzino | private void initHeuristics ( ) { SpecialBadIpAddressesGenerator specialBadIpAddressesGenerator = new SpecialBadIpAddressesGenerator ( stringSpec , seed , owners ) ; BadNumbersAsStringGenerator badNumbers = new BadNumbersAsStringGenerator ( stringSpec , seed , owners ) ; ConcreteValuesGenerator dot = new ConcreteValuesGenerator ( stringSpec , seed , owners , " . " ) ; Combinator badIpAddress = new Combinator ( stringSpec , seed , owners , badNumbers , dot , badNumbers , dot , badNumbers , dot , badNumbers ) ; heuristics . add ( specialBadIpAddressesGenerator ) ; heuristics . add ( badIpAddress ) ; }
fraunhoferfokus/Fuzzino | @ Override public boolean canCreateValuesFor ( StringSpecification stringSpec ) { boolean validType = stringSpec . getType ( ) == StringType . IP_ADDRESS ; return validType ; }
fraunhoferfokus/Fuzzino | @ Override public String getName ( ) { return " BadIpAddresses " ; }
Nekorp/Tikal-Technology | public GrupoRegistroAlmacen ( Long pedidoId , Long idProveedor , LineaDeProductos linea ) { registros = new LinkedList < > ( ) ; this . pedidoId = pedidoId ; this . idProveedor = idProveedor ; this . linea = linea ; }
Nekorp/Tikal-Technology | @ Override public Long getPedidoId ( ) { return pedidoId ; }
Nekorp/Tikal-Technology | @ Override public Long getId ( ) { return null ; }
Nekorp/Tikal-Technology | @ Override public Producto getProducto ( ) { return null ; }
Nekorp/Tikal-Technology | @ Override public Long getIdProveedor ( ) { return idProveedor ; }
Nekorp/Tikal-Technology | @ Override public Long getCantidad ( ) { long cantidad = 0 ; for ( RegistroAlmacen x : registros ) { cantidad = cantidad + x . getCantidad ( ) ; } return cantidad ; }
Nekorp/Tikal-Technology | public void updateFechaCreacion ( Date fecha ) { if ( fechaDeCreacion == null || fecha . before ( fechaDeCreacion ) ) { this . fechaDeCreacion = fecha ; } }
Nekorp/Tikal-Technology | public Date getFechaDeCreacion ( ) { return fechaDeCreacion ; }
Nekorp/Tikal-Technology | public LineaDeProductos getLinea ( ) { return linea ; }
Nekorp/Tikal-Technology | public RegistroAlmacen [ ] getRegistros ( ) { RegistroAlmacen [ ] response = new RegistroAlmacen [ registros . size ( ) ] ; registros . toArray ( response ) ; return response ; }
Nekorp/Tikal-Technology | public void addRegistro ( RegistroAlmacen pedimento ) { if ( ! pedimento . getIdProveedor ( ) . equals ( this . idProveedor ) ) { throw new IllegalArgumentException ( ) ; } this . registros . add ( pedimento ) ; }
Nekorp/Tikal-Technology | @ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final GrupoRegistroAlmacen other = ( GrupoRegistroAlmacen ) obj ; return Objects . equals ( this . pedidoId , other . pedidoId ) && Objects . equals ( this . linea . getId ( ) , other . linea . getId ( ) ) && Objects . equals ( this . linea . getCatalogoId ( ) , other . linea . getCatalogoId ( ) ) && Objects . equals ( this . idProveedor , other . idProveedor ) ; }
Nekorp/Tikal-Technology | @ Override public int hashCode ( ) { return Objects . hash ( this . pedidoId , this . linea . getId ( ) , this . linea . getCatalogoId ( ) , this . idProveedor ) ; }
Nekorp/Tikal-Technology | @ Override public Date getFechaRegistro ( ) { return null ; }
Nekorp/Tikal-Technology | @ Override public Long getReferenciaEnvio ( ) { return referenciaEnvio ; }
Nekorp/Tikal-Technology | public void setReferenciaEnvio ( Long referenciaEnvio ) { this . referenciaEnvio = referenciaEnvio ; }
gravitee-io/gravitee-gateway | @ Before public void setUp ( ) { initMocks ( this ) ; }
gravitee-io/gravitee-gateway | @ Test public void doNext_multiplePolicyOrder ( ) throws Exception { List < Policy > policies = policies2 ( ) ; PolicyChain requestChain = OrderedPolicyChain . create ( policies , mock ( ExecutionContext . class ) ) ; requestChain . handler ( result -> { } ) ; PolicyChain responseChain = ReversedPolicyChain . create ( policies , mock ( ExecutionContext . class ) ) ; responseChain . handler ( result -> { } ) ; InOrder requestOrder = inOrder ( policy , policy2 ) ; InOrder responseOrder = inOrder ( policy , policy2 ) ; requestChain . doNext ( null , null ) ; responseChain . doNext ( null , null ) ; requestOrder . verify ( policy ) . execute ( any ( ) , any ( ) ) ; requestOrder . verify ( policy2 ) . execute ( any ( ) , any ( ) ) ; responseOrder . verify ( policy2 ) . execute ( any ( ) , any ( ) ) ; responseOrder . verify ( policy ) . execute ( any ( ) , any ( ) ) ; }
gravitee-io/gravitee-gateway | private List < Policy > policies2 ( ) { List < Policy > policies = new ArrayList < > ( ) ; policies . add ( policy ) ; policies . add ( policy2 ) ; return policies ; }
BlazePowered/Blaze-Server | public void subscribe ( GlowPlayer player ) { for ( GlowObjective objective : objectives . values ( ) ) { player . getSession ( ) . send ( ScoreboardObjectiveMessage . create ( objective . getName ( ) , objective . getDisplayName ( ) ) ) ; } for ( DisplaySlot slot : DisplaySlot . values ( ) ) { GlowObjective objective = displaySlots . get ( slot ) ; String name = objective != null ? objective . getName ( ) : " " ; player . getSession ( ) . send ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , name ) ) ; } for ( Map . Entry < String , Set < GlowScore > > entry : scoreMap . entrySet ( ) ) { for ( GlowScore score : entry . getValue ( ) ) { player . getSession ( ) . send ( new ScoreboardScoreMessage ( entry . getKey ( ) , score . getObjective ( ) . getName ( ) , score . getScore ( ) ) ) ; } } for ( GlowTeam team : teams . values ( ) ) { player . getSession ( ) . send ( team . getCreateMessage ( ) ) ; } players . add ( player ) ; }
BlazePowered/Blaze-Server | public void unsubscribe ( GlowPlayer player ) { players . remove ( player ) ; for ( GlowTeam team : teams . values ( ) ) { player . getSession ( ) . send ( ScoreboardTeamMessage . remove ( team . getName ( ) ) ) ; } for ( DisplaySlot slot : DisplaySlot . values ( ) ) { player . getSession ( ) . send ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , " " ) ) ; } for ( GlowObjective objective : objectives . values ( ) ) { player . getSession ( ) . send ( ScoreboardObjectiveMessage . remove ( objective . getName ( ) ) ) ; } }
BlazePowered/Blaze-Server | void broadcast ( Message message ) { for ( GlowPlayer player : players ) { player . getSession ( ) . send ( message ) ; } }
BlazePowered/Blaze-Server | void setDisplaySlot ( DisplaySlot slot , GlowObjective objective ) { GlowObjective previous = displaySlots . put ( slot , objective ) ; if ( previous != null ) { previous . displaySlot = null ; } if ( objective != null ) { broadcast ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , objective . getName ( ) ) ) ; objective . displaySlot = slot ; } else { broadcast ( new ScoreboardDisplayMessage ( GlowDisplaySlot . getId ( slot ) , " " ) ) ; } }
BlazePowered/Blaze-Server | void removeObjective ( GlowObjective objective ) { if ( objective . displaySlot != null ) { setDisplaySlot ( objective . displaySlot , null ) ; } getForCriteria ( objective . getCriteria ( ) ) . remove ( objective ) ; objectives . remove ( objective . getName ( ) ) ; broadcast ( ScoreboardObjectiveMessage . remove ( objective . getName ( ) ) ) ; }
BlazePowered/Blaze-Server | void removeTeam ( GlowTeam team ) { for ( OfflinePlayer player : team . getPlayers ( ) ) { playerTeamMap . remove ( player ) ; } teams . remove ( team . getName ( ) ) ; broadcast ( ScoreboardTeamMessage . remove ( team . getName ( ) ) ) ; }
BlazePowered/Blaze-Server | Set < GlowObjective > getForCriteria ( String criteria ) { Set < GlowObjective > result = criteriaMap . get ( criteria ) ; if ( result == null ) { result = new HashSet < > ( ) ; criteriaMap . put ( criteria , result ) ; } return result ; }
BlazePowered/Blaze-Server | Set < GlowScore > getScoresForName ( String entry ) { Set < GlowScore > result = scoreMap . get ( entry ) ; if ( result == null ) { result = new HashSet < > ( ) ; scoreMap . put ( entry , result ) ; } return result ; }
BlazePowered/Blaze-Server | void setPlayerTeam ( OfflinePlayer player , GlowTeam team ) { GlowTeam previous = playerTeamMap . put ( player , team ) ; if ( previous != null && previous . hasPlayer ( player ) ) { previous . rawRemovePlayer ( player ) ; broadcast ( ScoreboardTeamMessage . removePlayers ( previous . getName ( ) , Arrays . asList ( player . getName ( ) ) ) ) ; } if ( team != null ) { broadcast ( ScoreboardTeamMessage . addPlayers ( team . getName ( ) , Arrays . asList ( player . getName ( ) ) ) ) ; } }
BlazePowered/Blaze-Server | public Objective registerNewObjective ( String name , String criteria ) throws IllegalArgumentException { Validate . notNull ( name , " Name ▁ cannot ▁ be ▁ null " ) ; Validate . notNull ( criteria , " Criteria ▁ cannot ▁ be ▁ null " ) ; Validate . isTrue ( ! objectives . containsKey ( name ) , " Objective ▁ \" " + name + " \" ▁ already ▁ exists " ) ; GlowObjective objective = new GlowObjective ( this , name , criteria ) ; objectives . put ( name , objective ) ; getForCriteria ( criteria ) . add ( objective ) ; broadcast ( ScoreboardObjectiveMessage . create ( name , objective . getDisplayName ( ) , RenderType . INTEGER ) ) ; return objective ; }
BlazePowered/Blaze-Server | public Objective getObjective ( String name ) throws IllegalArgumentException { return objectives . get ( name ) ; }
BlazePowered/Blaze-Server | public Set < Objective > getObjectivesByCriteria ( String criteria ) throws IllegalArgumentException { return ImmutableSet . < Objective > copyOf ( getForCriteria ( criteria ) ) ; }
BlazePowered/Blaze-Server | public Set < Objective > getObjectives ( ) { return ImmutableSet . < Objective > copyOf ( objectives . values ( ) ) ; }
BlazePowered/Blaze-Server | public Objective getObjective ( DisplaySlot slot ) throws IllegalArgumentException { Validate . notNull ( slot , " Slot ▁ cannot ▁ be ▁ null " ) ; return displaySlots . get ( slot ) ; }
BlazePowered/Blaze-Server | public void clearSlot ( DisplaySlot slot ) throws IllegalArgumentException { Validate . notNull ( slot , " Slot ▁ cannot ▁ be ▁ null " ) ; setDisplaySlot ( slot , null ) ; }
BlazePowered/Blaze-Server | public Team registerNewTeam ( String name ) throws IllegalArgumentException { Validate . notNull ( name , " Name ▁ cannot ▁ be ▁ null " ) ; Validate . isTrue ( ! teams . containsKey ( name ) , " Team ▁ \" " + name + " \" ▁ already ▁ exists " ) ; GlowTeam team = new GlowTeam ( this , name ) ; teams . put ( name , team ) ; broadcast ( team . getCreateMessage ( ) ) ; return team ; }
BlazePowered/Blaze-Server | public Team getPlayerTeam ( OfflinePlayer player ) throws IllegalArgumentException { Validate . notNull ( player , " Player ▁ cannot ▁ be ▁ null " ) ; return playerTeamMap . get ( player ) ; }
BlazePowered/Blaze-Server | @ Override public Team getEntryTeam ( String teamName ) throws IllegalArgumentException { return getTeam ( teamName ) ; }
BlazePowered/Blaze-Server | public Team getTeam ( String teamName ) throws IllegalArgumentException { Validate . notNull ( teamName , " Team ▁ name ▁ cannot ▁ be ▁ null " ) ; return teams . get ( teamName ) ; }
BlazePowered/Blaze-Server | public Set < Team > getTeams ( ) { return ImmutableSet . < Team > copyOf ( teams . values ( ) ) ; }
BlazePowered/Blaze-Server | public Set < String > getEntries ( ) { return ImmutableSet . copyOf ( scoreMap . keySet ( ) ) ; }
BlazePowered/Blaze-Server | public Set < Score > getScores ( String entry ) throws IllegalArgumentException { Validate . notNull ( entry , " Entry ▁ cannot ▁ be ▁ null " ) ; Set < GlowScore > scoreSet = scoreMap . get ( entry ) ; if ( scoreSet == null ) { return ImmutableSet . of ( ) ; } else { return ImmutableSet . < Score > copyOf ( scoreSet ) ; } }
BlazePowered/Blaze-Server | public void resetScores ( String entry ) throws IllegalArgumentException { Validate . notNull ( entry , " Entry ▁ cannot ▁ be ▁ null " ) ; for ( GlowObjective objective : objectives . values ( ) ) { broadcast ( ScoreboardScoreMessage . remove ( entry , objective . getName ( ) ) ) ; objective . deleteScore ( entry ) ; } scoreMap . remove ( entry ) ; }
BlazePowered/Blaze-Server | @ Deprecated public Set < OfflinePlayer > getPlayers ( ) { Set < OfflinePlayer > result = new HashSet < > ( ) ; for ( String name : getEntries ( ) ) { result . add ( Bukkit . getOfflinePlayer ( name ) ) ; } return Collections . unmodifiableSet ( result ) ; }
BlazePowered/Blaze-Server | @ Deprecated public Set < Score > getScores ( OfflinePlayer player ) throws IllegalArgumentException { Validate . notNull ( player , " Player ▁ cannot ▁ be ▁ null " ) ; return getScores ( player . getName ( ) ) ; }
BlazePowered/Blaze-Server | @ Deprecated public void resetScores ( OfflinePlayer player ) throws IllegalArgumentException { Validate . notNull ( player , " Player ▁ cannot ▁ be ▁ null " ) ; resetScores ( player . getName ( ) ) ; }
poornan/product-is | KeyValue ( String key , String value ) { this . key = key ; this . value = value ; }
poornan/product-is | public String getValue ( ) { return value ; }
poornan/product-is | public String getKey ( ) { return key ; }
eileenzhuang1/mozu-java | public Integer getId ( ) { return this . id ; }
eileenzhuang1/mozu-java | public void setId ( Integer id ) { this . id = id ; }
eileenzhuang1/mozu-java | public Boolean getIsDeleted ( ) { return this . isDeleted ; }
eileenzhuang1/mozu-java | public void setIsDeleted ( Boolean isDeleted ) { this . isDeleted = isDeleted ; }
eileenzhuang1/mozu-java | public String getName ( ) { return this . name ; }
eileenzhuang1/mozu-java | public void setName ( String name ) { this . name = name ; }
eileenzhuang1/mozu-java | public String getProductPublishingMode ( ) { return this . productPublishingMode ; }
eileenzhuang1/mozu-java | public void setProductPublishingMode ( String productPublishingMode ) { this . productPublishingMode = productPublishingMode ; }
bcvsolutions/CzechIdMng | @ Override public String getId ( ) { return id ; }
bcvsolutions/CzechIdMng | public void setId ( String id ) { this . id = id ; }
bcvsolutions/CzechIdMng | public Date getCreated ( ) { return created ; }
bcvsolutions/CzechIdMng | public void setCreated ( Date created ) { this . created = created ; }
bcvsolutions/CzechIdMng | public String getAssignee ( ) { return assignee ; }
bcvsolutions/CzechIdMng | public void setAssignee ( String assignee ) { this . assignee = assignee ; }
bcvsolutions/CzechIdMng | public WorkflowTaskDefinitionDto getDefinition ( ) { return definition ; }
bcvsolutions/CzechIdMng | public void setDefinition ( WorkflowTaskDefinitionDto definition ) { this . definition = definition ; }
bcvsolutions/CzechIdMng | public Map < String , Object > getVariables ( ) { if ( variables == null ) { variables = new HashMap < > ( ) ; } return variables ; }
bcvsolutions/CzechIdMng | public void setVariables ( Map < String , Object > variables ) { this . variables = variables ; }
bcvsolutions/CzechIdMng | public String getDescription ( ) { return description ; }
bcvsolutions/CzechIdMng | public void setDescription ( String description ) { this . description = description ; }
bcvsolutions/CzechIdMng | public List < DecisionFormTypeDto > getDecisions ( ) { if ( decisions == null ) { decisions = new ArrayList < > ( ) ; } return decisions ; }
bcvsolutions/CzechIdMng | public void setDecisions ( List < DecisionFormTypeDto > decisions ) { this . decisions = decisions ; }
bcvsolutions/CzechIdMng | public List < FormDataDto > getFormData ( ) { if ( formData == null ) { formData = new ArrayList < > ( ) ; } return formData ; }
bcvsolutions/CzechIdMng | public void setFormData ( List < FormDataDto > formData ) { this . formData = formData ; }
bcvsolutions/CzechIdMng | public String getName ( ) { return name ; }
bcvsolutions/CzechIdMng | public void setName ( String name ) { this . name = name ; }
bcvsolutions/CzechIdMng | public String getApplicant ( ) { return applicant ; }
bcvsolutions/CzechIdMng | public void setApplicant ( String applicant ) { this . applicant = applicant ; }
bcvsolutions/CzechIdMng | public String getApplicantFullName ( ) { return applicantFullName ; }
bcvsolutions/CzechIdMng | public void setApplicantFullName ( String applicantFullName ) { this . applicantFullName = applicantFullName ; }
bcvsolutions/CzechIdMng | public List < IdentityLinkDto > getIdentityLinks ( ) { if ( identityLinks == null ) { identityLinks = new ArrayList < > ( ) ; } return identityLinks ; }
bcvsolutions/CzechIdMng | public void setIdentityLinks ( List < IdentityLinkDto > identityLinks ) { this . identityLinks = identityLinks ; }
bcvsolutions/CzechIdMng | public String getProcessInstanceId ( ) { return processInstanceId ; }
bcvsolutions/CzechIdMng | public void setProcessInstanceId ( String processInstanceId ) { this . processInstanceId = processInstanceId ; }
bcvsolutions/CzechIdMng | public String getFormKey ( ) { return formKey ; }
bcvsolutions/CzechIdMng | public void setFormKey ( String formKey ) { this . formKey = formKey ; }
bcvsolutions/CzechIdMng | @ Override public void setId ( Serializable id ) { if ( id != null ) { Assert . isInstanceOf ( String . class , id , " WorkflowTaskInstanceDto ▁ supports ▁ only ▁ String ▁ identifier . " ) ; } this . id = ( String ) id ; }
bcvsolutions/CzechIdMng | public String getProcessDefinitionId ( ) { return processDefinitionId ; }
bcvsolutions/CzechIdMng | public void setProcessDefinitionId ( String processDefinitionId ) { this . processDefinitionId = processDefinitionId ; }
bcvsolutions/CzechIdMng | public String getProcessDefinitionKey ( ) { return processDefinitionKey ; }
bcvsolutions/CzechIdMng | public void setProcessDefinitionKey ( String processDefinitionKey ) { this . processDefinitionKey = processDefinitionKey ; }
bcvsolutions/CzechIdMng | public int getPriority ( ) { return priority ; }
bcvsolutions/CzechIdMng | public void setPriority ( int priority ) { this . priority = priority ; }
bcvsolutions/CzechIdMng | public Class < ? extends BaseDto > getType ( ) { return type ; }
bcvsolutions/CzechIdMng | public IdmDelegationDefinitionDto getDelegationDefinition ( ) { return delegationDefinition ; }
bcvsolutions/CzechIdMng | public void setDelegationDefinition ( IdmDelegationDefinitionDto delegationDefinition ) { this . delegationDefinition = delegationDefinition ; }
aws/aws-sdk-java | public void setRStudioServerProDomainSettingsForUpdate ( RStudioServerProDomainSettingsForUpdate rStudioServerProDomainSettingsForUpdate ) { this . rStudioServerProDomainSettingsForUpdate = rStudioServerProDomainSettingsForUpdate ; }
aws/aws-sdk-java | public RStudioServerProDomainSettingsForUpdate getRStudioServerProDomainSettingsForUpdate ( ) { return this . rStudioServerProDomainSettingsForUpdate ; }
aws/aws-sdk-java | public DomainSettingsForUpdate withRStudioServerProDomainSettingsForUpdate ( RStudioServerProDomainSettingsForUpdate rStudioServerProDomainSettingsForUpdate ) { setRStudioServerProDomainSettingsForUpdate ( rStudioServerProDomainSettingsForUpdate ) ; return this ; }
aws/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getRStudioServerProDomainSettingsForUpdate ( ) != null ) sb . append ( " RStudioServerProDomainSettingsForUpdate : ▁ " ) . append ( getRStudioServerProDomainSettingsForUpdate ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
aws/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DomainSettingsForUpdate == false ) return false ; DomainSettingsForUpdate other = ( DomainSettingsForUpdate ) obj ; if ( other . getRStudioServerProDomainSettingsForUpdate ( ) == null ^ this . getRStudioServerProDomainSettingsForUpdate ( ) == null ) return false ; if ( other . getRStudioServerProDomainSettingsForUpdate ( ) != null && other . getRStudioServerProDomainSettingsForUpdate ( ) . equals ( this . getRStudioServerProDomainSettingsForUpdate ( ) ) == false ) return false ; return true ; }
aws/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getRStudioServerProDomainSettingsForUpdate ( ) == null ) ? 0 : getRStudioServerProDomainSettingsForUpdate ( ) . hashCode ( ) ) ; return hashCode ; }
aws/aws-sdk-java | @ Override public DomainSettingsForUpdate clone ( ) { try { return ( DomainSettingsForUpdate ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
aws/aws-sdk-java | @ com . amazonaws . annotation . SdkInternalApi @ Override public void marshall ( ProtocolMarshaller protocolMarshaller ) { com . amazonaws . services . sagemaker . model . transform . DomainSettingsForUpdateMarshaller . getInstance ( ) . marshall ( this , protocolMarshaller ) ; }
fhg-fokus-nubomedia/nubomedia-paas | public ImageStreamMessageBuilder ( String name ) { this . name = name ; }
fhg-fokus-nubomedia/nubomedia-paas | public ImageStreamConfig buildMessage ( ) { ImageStreamConfig . ImageStreamStatus status = new ImageStreamConfig . ImageStreamStatus ( " " ) ; Metadata metadata = new Metadata ( name , " " , " " ) ; return new ImageStreamConfig ( metadata , new ImageStreamConfig . ImageStreamSpecification ( ) , status ) ; }
javar/sudoku-solver | int _ ( char [ ] a , int i ) { if ( i > 80 ) System . out . println ( a ) ; else { if ( a [ i ] > 48 ) return _ ( a , i + 1 ) ; char v [ ] = a . clone ( ) , k = 65535 ; while ( ++ k < 9 ) v [ a [ i / 9 * 9 + k ] ] = v [ a [ i % 9 + k * 9 ] ] = v [ a [ i - i % 3 - i / 9 % 3 * 9 + k + k / 3 * 6 ] ] = 1 ; for ( k = 58 ; ( a [ i ] = -- k ) > 48 ; ) if ( v [ k ] > 1 && _ ( a , i + 1 ) == 1 ) return 1 ; } return i / 81 ; }
GwonGisoo/ngrinder | ) public String getAll ( @ RequestParam ( value = " region " , required = false ) final String region , ModelMap model ) { List < AgentInfo > agents = agentManagerService . getAllVisible ( ) ; model . addAttribute ( " agents " , Collections2 . filter ( agents , new Predicate < AgentInfo > ( ) { @ Override public boolean apply ( AgentInfo agentInfo ) { final String eachAgentRegion = agentInfo . getRegion ( ) ; if ( StringUtils . equals ( region , " all " ) || StringUtils . isEmpty ( region ) ) { return true ; } return eachAgentRegion . startsWith ( region + " _ owned " ) || region . equals ( eachAgentRegion ) ; } } ) ) ; model . addAttribute ( " region " , region ) ; model . addAttribute ( " regions " , regionService . getAllVisibleRegionNames ( ) ) ; File agentPackage = null ; if ( isClustered ( ) ) { if ( StringUtils . isNotBlank ( region ) ) { final RegionInfo regionInfo = regionService . getOne ( region ) ; agentPackage = agentPackageService . createAgentPackage ( region , regionInfo . getIp ( ) , regionInfo . getControllerPort ( ) , null ) ; } } else { agentPackage = agentPackageService . createAgentPackage ( " " , " " , getConfig ( ) . getControllerPort ( ) , null ) ; } if ( agentPackage != null ) { model . addAttribute ( " downloadLink " , " / agent / download / " + agentPackage . getName ( ) ) ; } return " agent / list " ; }
GwonGisoo/ngrinder | " ) public String getOne ( @ PathVariable Long id , ModelMap model ) { model . addAttribute ( " agent " , agentManagerService . getOne ( id ) ) ; return " agent / detail " ; }
GwonGisoo/ngrinder | @ PreAuthorize ( " hasAnyRole ( ' A ' ) " ) @ RequestMapping ( value = " / api " , params = " action = cleanup " , method = RequestMethod . POST ) public HttpEntity < String > cleanUpAgentsInInactiveRegion ( ) { agentManagerService . cleanup ( ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | / state " ) public HttpEntity < String > getState ( @ PathVariable Long id , @ RequestParam String ip , @ RequestParam String name ) { agentManagerService . requestShareAgentSystemDataModel ( id ) ; return toJsonHttpEntity ( agentManagerService . getSystemDataModel ( ip , name ) ) ; }
GwonGisoo/ngrinder | , method = RequestMethod . GET ) public HttpEntity < String > getStates ( ) { List < AgentInfo > agents = agentManagerService . getAllVisible ( ) ; return toJsonHttpEntity ( getAgentStatus ( agents ) ) ; }
GwonGisoo/ngrinder | , method = RequestMethod . GET ) public HttpEntity < String > getAll ( ) { return toJsonHttpEntity ( agentManagerService . getAllVisible ( ) ) ; }
GwonGisoo/ngrinder | " , method = RequestMethod . GET ) public HttpEntity < String > getOne ( @ PathVariable ( " id " ) Long id ) { return toJsonHttpEntity ( agentManagerService . getOne ( id ) ) ; }
GwonGisoo/ngrinder | " , params = " action = approve " , method = RequestMethod . PUT ) public HttpEntity < String > approve ( @ PathVariable ( " id " ) Long id ) { agentManagerService . approve ( id , true ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | " , params = " action = disapprove " , method = RequestMethod . PUT ) public HttpEntity < String > disapprove ( @ PathVariable ( " id " ) Long id ) { agentManagerService . approve ( id , false ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | " , params = " action = stop " , method = RequestMethod . PUT ) public HttpEntity < String > stop ( @ PathVariable ( " id " ) Long id ) { agentManagerService . stopAgent ( id ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | @ RestAPI @ PreAuthorize ( " hasAnyRole ( ' A ' ) " ) @ RequestMapping ( value = " / api " , params = " action = stop " , method = RequestMethod . PUT ) public HttpEntity < String > stop ( @ RequestParam ( " ids " ) String ids ) { String [ ] split = StringUtils . split ( ids , " , " ) ; for ( String each : split ) { stop ( Long . parseLong ( each ) ) ; } return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | " , params = " action = update " , method = RequestMethod . PUT ) public HttpEntity < String > update ( @ PathVariable ( " id " ) Long id ) { agentManagerService . update ( id ) ; return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | @ RestAPI @ PreAuthorize ( " hasAnyRole ( ' A ' ) " ) @ RequestMapping ( value = " / api " , params = " action = update " , method = RequestMethod . PUT ) public HttpEntity < String > update ( @ RequestParam ( " ids " ) String ids ) { String [ ] split = StringUtils . split ( ids , " , " ) ; for ( String each : split ) { update ( Long . parseLong ( each ) ) ; } return successJsonHttpEntity ( ) ; }
GwonGisoo/ngrinder | private List < Map < String , Object > > getAgentStatus ( List < AgentInfo > agents ) { List < Map < String , Object > > statuses = newArrayList ( agents . size ( ) ) ; for ( AgentInfo each : agents ) { Map < String , Object > result = newHashMap ( ) ; result . put ( " id " , each . getId ( ) ) ; result . put ( " port " , each . getPort ( ) ) ; result . put ( " icon " , each . getState ( ) . getCategory ( ) . getIconName ( ) ) ; result . put ( " state " , each . getState ( ) ) ; statuses . add ( result ) ; } return statuses ; }
tdelev/MULLAN | public String globalInfo ( ) { return " Changes ▁ the ▁ order ▁ of ▁ the ▁ classes ▁ so ▁ that ▁ the ▁ class ▁ values ▁ are ▁ " + " no ▁ longer ▁ of ▁ in ▁ the ▁ order ▁ specified ▁ in ▁ the ▁ header . ▁ " + " The ▁ values ▁ will ▁ be ▁ in ▁ the ▁ order ▁ specified ▁ by ▁ the ▁ user ▁ " + " - - ▁ it ▁ could ▁ be ▁ either ▁ in ▁ ascending / descending ▁ order ▁ by ▁ the ▁ class ▁ " + " frequency ▁ or ▁ in ▁ random ▁ order . ▁ Note ▁ that ▁ this ▁ filter ▁ currently ▁ does ▁ not ▁ " + " change ▁ the ▁ header , ▁ only ▁ the ▁ class ▁ values ▁ of ▁ the ▁ instances , ▁ " + " so ▁ there ▁ is ▁ not ▁ much ▁ point ▁ in ▁ using ▁ it ▁ in ▁ conjunction ▁ with ▁ the ▁ " + " FilteredClassifier . ▁ The ▁ value ▁ can ▁ also ▁ be ▁ converted ▁ back ▁ using ▁ " + " ' originalValue ( double ▁ value ) ' ▁ procedure . " ; }
tdelev/MULLAN | public Enumeration listOptions ( ) { Vector newVector = new Vector ( 1 ) ; newVector . addElement ( new Option ( " \tSpecify ▁ the ▁ seed ▁ of ▁ randomization \n " + " \tused ▁ to ▁ randomize ▁ the ▁ class \n " + " \torder ▁ ( default : ▁ 1 ) " , " R " , 1 , " - R ▁ < seed > " ) ) ; newVector . addElement ( new Option ( " \tSpecify ▁ the ▁ class ▁ order ▁ to ▁ be \n " + " \tsorted , ▁ could ▁ be ▁ 0 : ▁ ascending \n " + " \t1 : ▁ descending ▁ and ▁ 2 : ▁ random . ( default : ▁ 0 ) " , " C " , 1 , " - C ▁ < order > " ) ) ; return newVector . elements ( ) ; }
tdelev/MULLAN | public void setOptions ( String [ ] options ) throws Exception { String seedString = Utils . getOption ( ' R ' , options ) ; if ( seedString . length ( ) != 0 ) m_Seed = Long . parseLong ( seedString ) ; else m_Seed = 1 ; String orderString = Utils . getOption ( ' C ' , options ) ; if ( orderString . length ( ) != 0 ) m_ClassOrder = Integer . parseInt ( orderString ) ; else m_ClassOrder = FREQ_ASCEND ; if ( getInputFormat ( ) != null ) setInputFormat ( getInputFormat ( ) ) ; m_Random = null ; }
tdelev/MULLAN | public String [ ] getOptions ( ) { String [ ] options = new String [ 4 ] ; int current = 0 ; options [ current ++ ] = " - R " ; options [ current ++ ] = " " + m_Seed ; options [ current ++ ] = " - C " ; options [ current ++ ] = " " + m_ClassOrder ; while ( current < options . length ) { options [ current ++ ] = " " ; } return options ; }
tdelev/MULLAN | public String seedTipText ( ) { return " Specify ▁ the ▁ seed ▁ of ▁ randomization ▁ of ▁ the ▁ class ▁ order " ; }
tdelev/MULLAN | public long getSeed ( ) { return m_Seed ; }
tdelev/MULLAN | public void setSeed ( long seed ) { m_Seed = seed ; m_Random = null ; }
tdelev/MULLAN | public String classOrderTipText ( ) { return " Specify ▁ the ▁ class ▁ order ▁ after ▁ the ▁ filtering " ; }
tdelev/MULLAN | public int getClassOrder ( ) { return m_ClassOrder ; }
tdelev/MULLAN | public void setClassOrder ( int order ) { m_ClassOrder = order ; }
tdelev/MULLAN | public Capabilities getCapabilities ( ) { Capabilities result = super . getCapabilities ( ) ; result . disableAll ( ) ; result . enableAllAttributes ( ) ; result . enable ( Capability . MISSING_VALUES ) ; result . enable ( Capability . NOMINAL_CLASS ) ; return result ; }
tdelev/MULLAN | public boolean setInputFormat ( Instances instanceInfo ) throws Exception { super . setInputFormat ( new Instances ( instanceInfo , 0 ) ) ; m_ClassAttribute = instanceInfo . classAttribute ( ) ; m_Random = new Random ( m_Seed ) ; m_Converter = null ; int numClasses = instanceInfo . numClasses ( ) ; m_ClassCounts = new double [ numClasses ] ; return false ; }
tdelev/MULLAN | public boolean input ( Instance instance ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( " No ▁ input ▁ instance ▁ format ▁ defined " ) ; } if ( m_NewBatch ) { resetQueue ( ) ; m_NewBatch = false ; } if ( m_Converter != null ) { Instance datum = ( Instance ) instance . copy ( ) ; if ( ! datum . isMissing ( m_ClassAttribute ) ) { datum . setClassValue ( ( double ) m_Converter [ ( int ) datum . classValue ( ) ] ) ; } push ( datum ) ; return true ; } if ( ! instance . isMissing ( m_ClassAttribute ) ) { m_ClassCounts [ ( int ) instance . classValue ( ) ] += instance . weight ( ) ; } bufferInput ( instance ) ; return false ; }
tdelev/MULLAN | public boolean batchFinished ( ) throws Exception { Instances data = getInputFormat ( ) ; if ( data == null ) throw new IllegalStateException ( " No ▁ input ▁ instance ▁ format ▁ defined " ) ; if ( m_Converter == null ) { int [ ] randomIndices = new int [ m_ClassCounts . length ] ; for ( int i = 0 ; i < randomIndices . length ; i ++ ) { randomIndices [ i ] = i ; } for ( int j = randomIndices . length - 1 ; j > 0 ; j -- ) { int toSwap = m_Random . nextInt ( j + 1 ) ; int tmpIndex = randomIndices [ j ] ; randomIndices [ j ] = randomIndices [ toSwap ] ; randomIndices [ toSwap ] = tmpIndex ; } double [ ] randomizedCounts = new double [ m_ClassCounts . length ] ; for ( int i = 0 ; i < randomizedCounts . length ; i ++ ) { randomizedCounts [ i ] = m_ClassCounts [ randomIndices [ i ] ] ; } if ( m_ClassOrder == RANDOM ) { m_Converter = randomIndices ; m_ClassCounts = randomizedCounts ; } else { int [ ] sorted = Utils . sort ( randomizedCounts ) ; m_Converter = new int [ sorted . length ] ; if ( m_ClassOrder == FREQ_ASCEND ) { for ( int i = 0 ; i < sorted . length ; i ++ ) { m_Converter [ i ] = randomIndices [ sorted [ i ] ] ; } } else if ( m_ClassOrder == FREQ_DESCEND ) { for ( int i = 0 ; i < sorted . length ; i ++ ) { m_Converter [ i ] = randomIndices [ sorted [ sorted . length - i - 1 ] ] ; } } else { throw new IllegalArgumentException ( " Class ▁ order ▁ not ▁ defined ! " ) ; } double [ ] tmp2 = new double [ m_ClassCounts . length ] ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) { tmp2 [ i ] = m_ClassCounts [ m_Converter [ i ] ] ; } m_ClassCounts = tmp2 ; } FastVector values = new FastVector ( data . classAttribute ( ) . numValues ( ) ) ; for ( int i = 0 ; i < data . numClasses ( ) ; i ++ ) { values . addElement ( data . classAttribute ( ) . value ( m_Converter [ i ] ) ) ; } FastVector newVec = new FastVector ( data . numAttributes ( ) ) ; for ( int i = 0 ; i < data . numAttributes ( ) ; i ++ ) { if ( i == data . classIndex ( ) ) { newVec . addElement ( new Attribute ( data . classAttribute ( ) . name ( ) , values , data . classAttribute ( ) . getMetadata ( ) ) ) ; } else { newVec . addElement ( data . attribute ( i ) ) ; } } Instances newInsts = new Instances ( data . relationName ( ) , newVec , 0 ) ; newInsts . setClassIndex ( data . classIndex ( ) ) ; setOutputFormat ( newInsts ) ; int [ ] temp = new int [ m_Converter . length ] ; for ( int i = 0 ; i < temp . length ; i ++ ) { temp [ m_Converter [ i ] ] = i ; } m_Converter = temp ; for ( int xyz = 0 ; xyz < data . numInstances ( ) ; xyz ++ ) { Instance datum = data . instance ( xyz ) ; if ( ! datum . isMissing ( datum . classIndex ( ) ) ) { datum . setClassValue ( ( double ) m_Converter [ ( int ) datum . classValue ( ) ] ) ; } push ( datum ) ; } } flushInput ( ) ; m_NewBatch = true ; return ( numPendingOutput ( ) != 0 ) ; }
tdelev/MULLAN | public double [ ] getClassCounts ( ) { if ( m_ClassAttribute . isNominal ( ) ) return m_ClassCounts ; else return null ; }
tdelev/MULLAN | public double [ ] distributionsByOriginalIndex ( double [ ] before ) { double [ ] after = new double [ m_Converter . length ] ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) after [ i ] = before [ m_Converter [ i ] ] ; return after ; }
tdelev/MULLAN | public double originalValue ( double value ) throws Exception { if ( m_Converter == null ) throw new IllegalStateException ( " Coverter ▁ table ▁ not ▁ defined ▁ yet ! " ) ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) if ( ( int ) value == m_Converter [ i ] ) return ( double ) i ; return - 1 ; }
tdelev/MULLAN | public String getRevision ( ) { return RevisionUtils . extract ( " $ Revision : ▁ 8034 ▁ $ " ) ; }
Alex-Diez/Java-TDD-Katas | Chars ( String source ) { this . source = source ; }
Alex-Diez/Java-TDD-Katas | char next ( ) { return source . charAt ( index ++ ) ; }
Alex-Diez/Java-TDD-Katas | char peek ( ) { return source . charAt ( index ) ; }
Alex-Diez/Java-TDD-Katas | int index ( ) { return index ; }
Alex-Diez/Java-TDD-Katas | String subString ( int start , int end ) { return source . substring ( start , end ) ; }
Alex-Diez/Java-TDD-Katas | boolean hasNext ( ) { return index < source . length ( ) ; }
y1011/cas-server | @ Override public ModelAndView resolveException ( final HttpServletRequest request , final HttpServletResponse response , final Object handler , final Exception exception ) { if ( ! ( exception instanceof FlowExecutionRepositoryException ) || exception instanceof BadlyFormattedFlowExecutionKeyException ) { logger . debug ( " Ignoring ▁ the ▁ received ▁ exception ▁ due ▁ to ▁ a ▁ type ▁ mismatch " , exception ) ; return null ; } final String urlToRedirectTo = request . getRequestURI ( ) + ( request . getQueryString ( ) != null ? ' ? ' + request . getQueryString ( ) : " " ) ; logger . debug ( " Error ▁ getting ▁ flow ▁ information ▁ for ▁ URL ▁ [ { } ] " , urlToRedirectTo , exception ) ; final Map < String , Object > model = new HashMap < > ( ) ; model . put ( this . modelKey , StringEscapeUtils . escapeHtml4 ( exception . getMessage ( ) ) ) ; return new ModelAndView ( new RedirectView ( urlToRedirectTo ) , model ) ; }
y1011/cas-server | public void setModelKey ( final String modelKey ) { this . modelKey = modelKey ; }
XillioQA/xill-platform-3.4 | @ Override public Connection createConnection ( String database , String user , String pass , Tuple < String , String > ... options ) throws SQLException { return connect ( createConnectionURL ( database , user , pass , options ) ) ; }
XillioQA/xill-platform-3.4 | @ Override protected String createConnectionURL ( String database , String user , String pass , Tuple < String , String > ... options ) { return createJDBCURL ( " mysql " , database , user , pass , " ? " , " & " , options ) ; }
XillioQA/xill-platform-3.4 | @ Override public void loadDriver ( ) throws ClassNotFoundException { Class . forName ( Database . MYSQL . getDriverClass ( ) ) ; }
apache/bookkeeper | @ Test ( timeout = 20000 ) public void testBasicOperations ( ) throws Exception { ConcurrentBaseConfiguration conf = new ConcurrentBaseConfiguration ( ) ; conf . setProperty ( " prop1" , "1" ) ; assertEquals ( 1 , conf . getInt ( " prop1" ) ) ; conf . setProperty ( " prop1" , "2" ) ; assertEquals ( 2 , conf . getInt ( " prop1" ) ) ; conf . clearProperty ( " prop1" ) ; assertEquals ( null , conf . getInteger ( " prop1" , null ) ) ; conf . setProperty ( " prop1" , "1" ) ; conf . setProperty ( " prop2" , "2" ) ; assertEquals ( 1 , conf . getInt ( " prop1" ) ) ; assertEquals ( 2 , conf . getInt ( " prop2" ) ) ; conf . clearProperty ( " prop1" ) ; assertEquals ( null , conf . getInteger ( " prop1" , null ) ) ; assertEquals ( 2 , conf . getInt ( " prop2" ) ) ; }
jentfoo/aws-sdk-java | public void marshall ( StartSchemaExtensionRequest startSchemaExtensionRequest , ProtocolMarshaller protocolMarshaller ) { if ( startSchemaExtensionRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { protocolMarshaller . marshall ( startSchemaExtensionRequest . getDirectoryId ( ) , DIRECTORYID_BINDING ) ; protocolMarshaller . marshall ( startSchemaExtensionRequest . getCreateSnapshotBeforeSchemaExtension ( ) , CREATESNAPSHOTBEFORESCHEMAEXTENSION_BINDING ) ; protocolMarshaller . marshall ( startSchemaExtensionRequest . getLdifContent ( ) , LDIFCONTENT_BINDING ) ; protocolMarshaller . marshall ( startSchemaExtensionRequest . getDescription ( ) , DESCRIPTION_BINDING ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final RyaStatement triple , final Optional < String > visibility ) { insert ( fluo , Collections . singleton ( triple ) , visibility ) ; }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final Collection < RyaStatement > triples , final Optional < String > visibility ) { checkNotNull ( fluo ) ; checkNotNull ( triples ) ; checkNotNull ( visibility ) ; try ( Transaction tx = fluo . newTransaction ( ) ) { for ( final RyaStatement triple : triples ) { try { tx . set ( spoFormat ( triple ) , FluoQueryColumns . TRIPLES , Bytes . of ( visibility . or ( " " ) ) ) ; } catch ( final TripleRowResolverException e ) { log . error ( " Could ▁ not ▁ convert ▁ a ▁ Triple ▁ into ▁ the ▁ SPO ▁ format : ▁ " + triple ) ; } } tx . commit ( ) ; } }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final RyaStatement triple ) { checkNotNull ( fluo ) ; checkNotNull ( triple ) ; insert ( fluo , Collections . singleton ( triple ) ) ; }
DLotts/incubator-rya | public void insert ( final FluoClient fluo , final Collection < RyaStatement > triples ) { checkNotNull ( fluo ) ; checkNotNull ( triples ) ; try ( Transaction tx = fluo . newTransaction ( ) ) { for ( final RyaStatement triple : triples ) { Optional < byte [ ] > visibility = Optional . fromNullable ( triple . getColumnVisibility ( ) ) ; try { tx . set ( spoFormat ( triple ) , FluoQueryColumns . TRIPLES , Bytes . of ( visibility . or ( new byte [ 0 ] ) ) ) ; } catch ( final TripleRowResolverException e ) { log . error ( " Could ▁ not ▁ convert ▁ a ▁ Triple ▁ into ▁ the ▁ SPO ▁ format : ▁ " + triple ) ; } } tx . commit ( ) ; } }
joewalnes/idea-community | public FindMethodUsagesDialog ( PsiElement element , Project project , FindUsagesOptions findUsagesOptions , boolean toShowInNewTab , boolean mustOpenInNewTab , boolean isSingleFile , FindUsagesHandler handler ) { super ( element , project , findUsagesOptions , toShowInNewTab , mustOpenInNewTab , isSingleFile , handler ) ; }
joewalnes/idea-community | @ Nullable public JComponent getPreferredFocusedControl ( ) { return myHasFindWhatPanel ? myCbUsages : null ; }
joewalnes/idea-community | public void calcFindUsagesOptions ( JavaMethodFindUsagesOptions options ) { super . calcFindUsagesOptions ( options ) ; options . isUsages = isSelected ( myCbUsages ) || ! myHasFindWhatPanel ; if ( isToChange ( myCbOverridingMethods ) ) { options . isOverridingMethods = isSelected ( myCbOverridingMethods ) ; } if ( isToChange ( myCbImplementingMethods ) ) { options . isImplementingMethods = isSelected ( myCbImplementingMethods ) ; } options . isCheckDeepInheritance = true ; }
joewalnes/idea-community | protected JPanel createFindWhatPanel ( ) { JPanel findWhatPanel = new JPanel ( ) ; findWhatPanel . setBorder ( IdeBorderFactory . createTitledBorder ( FindBundle . message ( " find . what . group " ) ) ) ; findWhatPanel . setLayout ( new BoxLayout ( findWhatPanel , BoxLayout . Y_AXIS ) ) ; myCbUsages = addCheckboxToPanel ( FindBundle . message ( " find . what . usages . checkbox " ) , getFindUsagesOptions ( ) . isUsages , findWhatPanel , true ) ; PsiMethod method = ( PsiMethod ) getPsiElement ( ) ; PsiClass aClass = method . getContainingClass ( ) ; if ( ! method . isConstructor ( ) && ! method . hasModifierProperty ( PsiModifier . STATIC ) && ! method . hasModifierProperty ( PsiModifier . FINAL ) && ! method . hasModifierProperty ( PsiModifier . PRIVATE ) && aClass != null && ! ( aClass instanceof PsiAnonymousClass ) && ! aClass . hasModifierProperty ( PsiModifier . FINAL ) ) { if ( method . hasModifierProperty ( PsiModifier . ABSTRACT ) ) { myCbImplementingMethods = addCheckboxToPanel ( FindBundle . message ( " find . what . implementing . methods . checkbox " ) , getFindUsagesOptions ( ) . isImplementingMethods , findWhatPanel , true ) ; } else { myCbOverridingMethods = addCheckboxToPanel ( FindBundle . message ( " find . what . overriding . methods . checkbox " ) , getFindUsagesOptions ( ) . isOverridingMethods , findWhatPanel , true ) ; } } else { myHasFindWhatPanel = false ; return null ; } myHasFindWhatPanel = true ; return findWhatPanel ; }
joewalnes/idea-community | protected void update ( ) { if ( ! myHasFindWhatPanel ) { setOKActionEnabled ( true ) ; } else { boolean hasSelected = isSelected ( myCbUsages ) || isSelected ( myCbImplementingMethods ) || isSelected ( myCbOverridingMethods ) ; setOKActionEnabled ( hasSelected ) ; } }
mikessh/mageri | private ResourceIOProvider ( ) { super ( " resources " ) ; }
mikessh/mageri | @ Override public InputStream getStream ( String path ) throws IOException { InputStream is = ResourceIOProvider . class . getClassLoader ( ) . getResourceAsStream ( path ) ; return path . endsWith ( " . gz " ) ? new GZIPInputStream ( is ) : is ; }
mauriciotogneri/shoppinglist | public Dialogs ( Context context ) { this . context = context ; }
mauriciotogneri/shoppinglist | public void options ( String title , List < String > list , OnOptionSelected callback ) { String [ ] options = new String [ list . size ( ) ] ; list . toArray ( options ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( title ( title ) ) ; builder . setItems ( options , ( dialog , which ) -> callback . onOptionSelected ( which ) ) ; builder . show ( ) ; }
mauriciotogneri/shoppinglist | public void confirmation ( String title , String message , OnConfirmationAccepted callback ) { AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( title ( title ) ) ; builder . setMessage ( message ) ; builder . setPositiveButton ( android . R . string . yes , ( dialog , whichButton ) -> callback . onConfirmationAccepted ( ) ) ; builder . setNegativeButton ( android . R . string . no , null ) ; builder . show ( ) ; }
mauriciotogneri/shoppinglist | public void input ( Context context , String title , String initialInput , OnInputConfirmed callback ) { View view = LayoutInflater . from ( context ) . inflate ( R . layout . view_dialog_input , null ) ; EditText nameField = view . findViewById ( R . id . input ) ; AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( title ( title ) ) ; builder . setView ( view ) ; builder . setPositiveButton ( R . string . button_accept , ( dialogInterface , i ) -> callback . onInputConfirmed ( nameField . getText ( ) . toString ( ) ) ) ; builder . setNegativeButton ( R . string . button_cancel , null ) ; AlertDialog dialog = builder . create ( ) ; Window window = dialog . getWindow ( ) ; if ( window != null ) { window . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_VISIBLE ) ; } dialog . show ( ) ; nameField . setText ( initialInput ) ; nameField . requestFocus ( ) ; nameField . selectAll ( ) ; dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setEnabled ( initialInput . length ( ) != 0 ) ; nameField . addTextChangedListener ( new TextWatcher ( ) { @ Override public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { } @ Override public void onTextChanged ( CharSequence s , int start , int before , int count ) { } @ Override public void afterTextChanged ( Editable text ) { dialog . getButton ( AlertDialog . BUTTON_POSITIVE ) . setEnabled ( text . length ( ) != 0 ) ; } } ) ; nameField . setOnEditorActionListener ( ( view1 , actionId , event ) -> { if ( actionId == EditorInfo . IME_ACTION_DONE ) { try { dialog . dismiss ( ) ; } catch ( Exception e ) { } callback . onInputConfirmed ( nameField . getText ( ) . toString ( ) ) ; } return false ; } ) ; }
mauriciotogneri/shoppinglist | private SpannableStringBuilder title ( String text ) { SpannableStringBuilder spannable = new SpannableStringBuilder ( text ) ; spannable . setSpan ( new ForegroundColorSpan ( ContextCompat . getColor ( context , R . color . primary ) ) , 0 , text . length ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; return spannable ; }
YoungDigitalPlanet/empiria.player | @ Test public void updateFontPropertiesAccordingToInlineFormatters ( ) { IInlineModule testModule = mock ( IInlineModule . class ) ; ModuleSocket socket = mock ( ModuleSocket . class ) ; Element element = mock ( Element . class ) ; Set < InlineFormattingContainerType > inlineStyles = new HashSet < InlineFormattingContainerType > ( ) ; inlineStyles . add ( InlineFormattingContainerType . BOLD ) ; when ( socket . getInlineFormattingTags ( testModule ) ) . thenReturn ( inlineStyles ) ; Font result = helper . initialize ( testModule , socket , element ) ; assertThat ( result . bold , is ( equalTo ( true ) ) ) ; }
YoungDigitalPlanet/empiria.player | @ Test public void updateFontPropertiesAccordingToStyles ( ) { DTOMathTextDefaultFontPropertiesProvider defaultFontPropertiesProvider = new DTOMathTextDefaultFontPropertiesProvider ( ) ; DTOMathTextFontProperties fontProperties = defaultFontPropertiesProvider . createDefaultProprerties ( ) ; HashMap < String , String > styles = new HashMap < String , String > ( ) ; styles . put ( " - empiria - math - font - size " , "26" ) ; helper . updateFontPropertiesAccordingToStyles ( styles , fontProperties ) ; assertThat ( fontProperties . getSize ( ) , is ( equalTo ( 26 ) ) ) ; }
PeterASteele/CodeForcesSolutions | public FastScanner ( Reader in ) { br = new BufferedReader ( in ) ; }
PeterASteele/CodeForcesSolutions | public FastScanner ( ) { this ( new InputStreamReader ( System . in ) ) ; }
PeterASteele/CodeForcesSolutions | String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; }
PeterASteele/CodeForcesSolutions | int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }
PeterASteele/CodeForcesSolutions | long nextLong ( ) { return Long . parseLong ( next ( ) ) ; }
PeterASteele/CodeForcesSolutions | double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; }
PeterASteele/CodeForcesSolutions | String readNextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; }
zreed/StarQuestCode | public BasicGeneratorGUI ( Player player , int id ) { super ( player , id ) ; }
zreed/StarQuestCode | @ Override public void open ( ) { Inventory gui = Bukkit . createInventory ( owner , 27 , ChatColor . BLUE + " SQTech ▁ - ▁ Basic ▁ Generator " ) ; Machine machine = ObjectUtils . getMachineFromMachineGUI ( this ) ; gui . setItem ( 8 , InventoryUtils . createSpecialItem ( Material . REDSTONE , ( short ) 0 , " Energy " , new String [ ] { EnergyUtils . formatEnergy ( machine . getEnergy ( ) ) + " / " + EnergyUtils . formatEnergy ( machine . getMachineType ( ) . getMaxEnergy ( ) ) , ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 26 , InventoryUtils . createSpecialItem ( Material . WOOD_DOOR , ( short ) 0 , " Back " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 17 , InventoryUtils . createSpecialItem ( Material . CHEST , ( short ) 0 , " Remaining ▁ fuel " , new String [ ] { " Fuel ▁ Type : ▁ None " , " Amount ▁ left : ▁ 0" , ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 0 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 2 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 9 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 11 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 18 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 19 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 20 , InventoryUtils . createSpecialItem ( Material . IRON_FENCE , ( short ) 0 , " ▁ " , new String [ ] { ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; gui . setItem ( 1 , InventoryUtils . createSpecialItem ( Material . PAPER , ( short ) 0 , " Info " , new String [ ] { " Fuel ▁ input " , ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " } ) ) ; owner . openInventory ( gui ) ; if ( SQTechBase . currentGui . containsKey ( owner ) ) { SQTechBase . currentGui . remove ( owner ) ; SQTechBase . currentGui . put ( owner , this ) ; } else { SQTechBase . currentGui . put ( owner , this ) ; } }
zreed/StarQuestCode | @ Override public void click ( final InventoryClickEvent event ) { if ( event . getClickedInventory ( ) != null ) { if ( event . getClickedInventory ( ) . getTitle ( ) . startsWith ( ChatColor . BLUE + " SQTech " ) ) { event . setCancelled ( true ) ; ItemStack clickedItem = event . getInventory ( ) . getItem ( event . getSlot ( ) ) ; boolean normalItem = true ; if ( clickedItem == null ) { normalItem = false ; } else { if ( clickedItem . hasItemMeta ( ) ) { if ( clickedItem . getItemMeta ( ) . hasLore ( ) ) { if ( clickedItem . getItemMeta ( ) . getLore ( ) . contains ( ChatColor . RED + " " + ChatColor . MAGIC + " Contraband " ) ) { normalItem = false ; } } } } if ( normalItem ) { event . setCancelled ( false ) ; } if ( event . getClickedInventory ( ) . getTitle ( ) . equals ( ChatColor . BLUE + " SQTech ▁ - ▁ Basic ▁ Generator " ) ) { if ( event . getSlot ( ) == 26 ) { GUIBlock guiBlock = ObjectUtils . getMachineFromMachineGUI ( this ) . getGUIBlock ( ) ; guiBlock . getGUI ( owner ) . open ( ) ; } else if ( event . getSlot ( ) == 10 ) { event . setCancelled ( false ) ; } } } else { if ( event . getAction ( ) . equals ( InventoryAction . MOVE_TO_OTHER_INVENTORY ) ) { event . setCancelled ( true ) ; } } } }
castagna/jax-rs-example | @ Before public void setUp ( ) throws Exception { resource = client . resource ( URL ) . path ( PATH ) ; model = ModelFactory . createDefaultModel ( ) ; model . add ( model . createResource ( " foo : bar " ) , RDFS . label , model . createLiteral ( " Bar " ) ) ; }
castagna/jax-rs-example | @ After public void tearDown ( ) throws Exception { if ( resource != null ) { resource = null ; } if ( model != null ) { model . close ( ) ; model = null ; } }
castagna/jax-rs-example | @ Test public void testSetUp ( ) { assertNotNull ( client ) ; assertNotNull ( resource ) ; assertNotNull ( model ) ; }
castagna/jax-rs-example | @ Test public void testPortIsOpen ( ) { try { new URL ( URL ) . openConnection ( ) . connect ( ) ; } catch ( MalformedURLException e ) { fail ( String . format ( " % s ▁ is ▁ not ▁ a ▁ valid ▁ URL . " , URL ) ) ; } catch ( IOException e ) { fail ( ) ; } }
castagna/jax-rs-example | @ Test public void testGetXML ( ) { testPostXML ( ) ; InputStream in = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( RDFMediaType . APPLICATION_TURTLE_CURRENT ) . get ( InputStream . class ) ; Model m = ModelFactory . createDefaultModel ( ) ; m . read ( in , " " , " TURTLE " ) ; assertTrue ( model . isIsomorphicWith ( m ) ) ; }
castagna/jax-rs-example | @ Test public void testGetTurtle ( ) { testPostTurtle ( ) ; InputStream in = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( RDFMediaType . APPLICATION_TURTLE_CURRENT ) . get ( InputStream . class ) ; Model m = ModelFactory . createDefaultModel ( ) ; m . read ( in , " " , " TURTLE " ) ; assertTrue ( model . isIsomorphicWith ( m ) ) ; }
castagna/jax-rs-example | @ Test public void testPut ( ) { assertEquals ( " Put ! " , resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . TEXT_PLAIN ) . put ( String . class ) ) ; }
castagna/jax-rs-example | @ Test public void testPostXML ( ) { StringWriter content = new StringWriter ( ) ; model . write ( content , " RDF / XML " ) ; resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . TEXT_PLAIN ) . entity ( content . toString ( ) , RDFMediaType . APPLICATION_RDFXML ) . post ( InputStream . class ) ; }
castagna/jax-rs-example | @ Test public void testPostTurtle ( ) { StringWriter content = new StringWriter ( ) ; model . write ( content , " TURTLE " ) ; resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . TEXT_PLAIN ) . entity ( content . toString ( ) , RDFMediaType . APPLICATION_TURTLE_CURRENT ) . post ( InputStream . class ) ; }
castagna/jax-rs-example | @ Test public void testDelete ( ) { try { Response response = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . WILDCARD_TYPE ) . delete ( Response . class ) ; assertEquals ( Response . Status . NOT_FOUND , response . getStatus ( ) ) ; } catch ( UniformInterfaceException e ) { } testPostTurtle ( ) ; try { Response response = resource . queryParam ( " graph " , GRAPH_URI ) . accept ( MediaType . WILDCARD_TYPE ) . delete ( Response . class ) ; assertEquals ( Response . Status . NO_CONTENT , response . getStatus ( ) ) ; } catch ( UniformInterfaceException e ) { } }
castagna/jax-rs-example | @ Test public void testApplicationWadl ( ) { resource = client . resource ( URL ) ; String wadl = resource . path ( " application . wadl " ) . accept ( MediaTypes . WADL ) . get ( String . class ) ; assertTrue ( wadl . length ( ) > 0 ) ; assertTrue ( wadl . contains ( " method ▁ name = \" GET \" " ) ) ; assertTrue ( wadl . contains ( " method ▁ name = \" PUT \" " ) ) ; assertTrue ( wadl . contains ( " method ▁ name = \" POST \" " ) ) ; assertTrue ( wadl . contains ( " method ▁ name = \" DELETE \" " ) ) ; }
Esri/geoportal-server | public ApplicationException ( ) { super ( ) ; }
Esri/geoportal-server | public ApplicationException ( String msg ) { super ( msg ) ; }
Esri/geoportal-server | public ApplicationException ( String msg , Throwable cause ) { super ( msg , cause ) ; }
Esri/geoportal-server | public ApplicationException ( Throwable cause ) { super ( cause ) ; }
b-slim/druid | @ Test public void testSanity ( ) throws Exception { URL segmentDesciptor = this . getClass ( ) . getClassLoader ( ) . getResource ( " test - segment / descriptor . json " ) ; DataSegment segment = HadoopDruidIndexerConfig . JSON_MAPPER . readValue ( segmentDesciptor , DataSegment . class ) . withLoadSpec ( ImmutableMap . < String , Object > of ( " type " , " local " , " path " , this . getClass ( ) . getClassLoader ( ) . getResource ( " test - segment / index . zip " ) . getPath ( ) ) ) ; InputSplit split = new DatasourceInputSplit ( Lists . newArrayList ( WindowedDataSegment . of ( segment ) ) , null ) ; Configuration config = new Configuration ( ) ; DatasourceInputFormat . addDataSource ( config , new DatasourceIngestionSpec ( segment . getDataSource ( ) , segment . getInterval ( ) , null , null , null , segment . getDimensions ( ) , segment . getMetrics ( ) , false , null ) , Collections . emptyList ( ) , 0 ) ; TaskAttemptContext context = EasyMock . createNiceMock ( TaskAttemptContext . class ) ; EasyMock . expect ( context . getConfiguration ( ) ) . andReturn ( config ) . anyTimes ( ) ; EasyMock . replay ( context ) ; DatasourceRecordReader rr = new DatasourceRecordReader ( ) ; rr . initialize ( split , context ) ; Assert . assertEquals ( 0 , rr . getProgress ( ) , 0.0001 ) ; List < InputRow > rows = Lists . newArrayList ( ) ; while ( rr . nextKeyValue ( ) ) { rows . add ( rr . getCurrentValue ( ) ) ; } verifyRows ( rows ) ; Assert . assertEquals ( 1 , rr . getProgress ( ) , 0.0001 ) ; rr . close ( ) ; }
b-slim/druid | private void verifyRows ( List < InputRow > actualRows ) { List < ImmutableMap < String , Object > > expectedRows = ImmutableList . of ( ImmutableMap . < String , Object > of ( " time " , DateTimes . of ( "2014-10-22T00:00:00.000Z " ) , " host " , ImmutableList . of ( " a . example . com " ) , " visited _ sum " , 100L , " unique _ hosts " , 1.0d ) , ImmutableMap . < String , Object > of ( " time " , DateTimes . of ( "2014-10-22T01:00:00.000Z " ) , " host " , ImmutableList . of ( " b . example . com " ) , " visited _ sum " , 150L , " unique _ hosts " , 1.0d ) , ImmutableMap . < String , Object > of ( " time " , DateTimes . of ( "2014-10-22T02:00:00.000Z " ) , " host " , ImmutableList . of ( " c . example . com " ) , " visited _ sum " , 200L , " unique _ hosts " , 1.0d ) ) ; Assert . assertEquals ( expectedRows . size ( ) , actualRows . size ( ) ) ; for ( int i = 0 ; i < expectedRows . size ( ) ; i ++ ) { Map < String , Object > expected = expectedRows . get ( i ) ; InputRow actual = actualRows . get ( i ) ; Assert . assertEquals ( ImmutableList . of ( " host " ) , actual . getDimensions ( ) ) ; Assert . assertEquals ( expected . get ( " time " ) , actual . getTimestamp ( ) ) ; Assert . assertEquals ( expected . get ( " host " ) , actual . getDimension ( " host " ) ) ; Assert . assertEquals ( expected . get ( " visited _ sum " ) , actual . getMetric ( " visited _ sum " ) ) ; Assert . assertEquals ( ( Double ) expected . get ( " unique _ hosts " ) , ( Double ) HyperUniquesAggregatorFactory . estimateCardinality ( actual . getRaw ( " unique _ hosts " ) , false ) , 0.001 ) ; } }
ApolloDev/apollo | public DiseaseOutcomeWithProbabilitySetter ( ) { }
ApolloDev/apollo | public DiseaseOutcomeWithProbabilitySetter ( ApolloTranslationEngine apolloTranslationEngine , String prefix , String section ) { super ( prefix , section , apolloTranslationEngine ) ; }
ApolloDev/apollo | private List < SetterReturnObject > setDiseaseOutcome ( DiseaseOutcomeEnum outcome ) throws ApolloSetterException { DiseaseOutcomeSetter setter = new DiseaseOutcomeSetter ( apolloTranslationEngine , type + " . " + DISEASE_OUTCOME_FIELD , section ) ; return setter . set ( outcome ) ; }
ApolloDev/apollo | private List < SetterReturnObject > setProbability ( ProbabilisticParameter value ) throws ApolloSetterException { ProbabilisticParameterSetter setter = new ProbabilisticParameterSetter ( apolloTranslationEngine , type + " . " + PROBABILITY_FIELD , section ) ; return setter . set ( value ) ; }
ApolloDev/apollo | @ Override public List < SetterReturnObject > set ( DiseaseOutcomeWithProbability t ) throws ApolloSetterException { List < SetterReturnObject > list = new ArrayList < SetterReturnObject > ( ) ; list . addAll ( setDiseaseOutcome ( t . getDiseaseOutcome ( ) ) ) ; list . addAll ( setProbability ( t . getProbability ( ) ) ) ; return list ; }
allotria/intellij-community | public FrameworkSupportConfigurableBase ( FrameworkSupportProviderBase frameworkSupportProvider , FrameworkSupportModel model ) { this ( frameworkSupportProvider , model , Collections . emptyList ( ) , null ) ; }
allotria/intellij-community | public FrameworkSupportConfigurableBase ( FrameworkSupportProviderBase frameworkSupportProvider , FrameworkSupportModel model , @ NotNull List < FrameworkVersion > versions , @ NlsContexts . Label @ Nullable String versionLabelText ) { myFrameworkSupportProvider = frameworkSupportProvider ; myFrameworkSupportModel = model ; myVersions = versions ; myDescriptionLabel . setText ( versionLabelText ) ; myVersionComboBox . setRenderer ( SimpleListCellRenderer . create ( " " , FrameworkVersion :: getVersionName ) ) ; updateAvailableVersions ( versions ) ; myVersionComboBox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { fireFrameworkVersionChanged ( ) ; } } ) ; }
allotria/intellij-community | protected void updateAvailableVersions ( List < ? extends FrameworkVersion > versions ) { if ( versions . size ( ) > 0 ) { String maxValue = " " ; ( ( DefaultComboBoxModel ) myVersionComboBox . getModel ( ) ) . removeAllElements ( ) ; FrameworkVersion defaultVersion = versions . get ( versions . size ( ) - 1 ) ; for ( FrameworkVersion version : versions ) { myVersionComboBox . addItem ( version ) ; FontMetrics fontMetrics = myVersionComboBox . getFontMetrics ( myVersionComboBox . getFont ( ) ) ; if ( fontMetrics . stringWidth ( version . getVersionName ( ) ) > fontMetrics . stringWidth ( maxValue ) ) { maxValue = version . getVersionName ( ) ; } if ( version . isDefault ( ) ) { defaultVersion = version ; } } myVersionComboBox . setSelectedItem ( defaultVersion ) ; myVersionComboBox . setPrototypeDisplayValue ( new FrameworkVersion ( maxValue + " _ " ) ) ; } final boolean hasMoreThanOneVersion = versions . size ( ) >= 2 ; myDescriptionLabel . setVisible ( hasMoreThanOneVersion ) ; myVersionComboBox . setVisible ( hasMoreThanOneVersion ) ; }
allotria/intellij-community | @ Override public JComponent getComponent ( ) { return myMainPanel ; }
allotria/intellij-community | protected void reloadVersions ( List < ? extends FrameworkVersion > frameworkVersions ) { myVersions . clear ( ) ; myVersions . addAll ( frameworkVersions ) ; }
allotria/intellij-community | @ Override @ NotNull public List < ? extends FrameworkVersion > getVersions ( ) { return myVersions ; }
allotria/intellij-community | public LibraryInfo @ NotNull [ ] getLibraries ( ) { return getSelectedVersion ( ) . getLibraries ( ) ; }
allotria/intellij-community | @ Override public void addSupport ( @ NotNull final Module module , @ NotNull final ModifiableRootModel rootModel , final @ Nullable Library library ) { myFrameworkSupportProvider . addSupport ( module , rootModel , getSelectedVersion ( ) , library ) ; }
allotria/intellij-community | @ Override public FrameworkVersion getSelectedVersion ( ) { return ( FrameworkVersion ) myVersionComboBox . getSelectedItem ( ) ; }
dickschoeller/gedbrowser | @ Override public final TrailerDocument findByFileAndString ( final String filename , final String string ) { final Query searchQuery = new Query ( Criteria . where ( " string " ) . is ( string ) . and ( " filename " ) . is ( filename ) ) ; final TrailerDocument trailerDocument = mongoTemplate . findOne ( searchQuery , TrailerDocumentMongo . class ) ; if ( trailerDocument == null ) { return null ; } final Trailer trailer = ( Trailer ) toObjConverter . createGedObject ( null , trailerDocument ) ; trailerDocument . setGedObject ( trailer ) ; return trailerDocument ; }
dickschoeller/gedbrowser | @ Override public final TrailerDocument findByRootAndString ( final RootDocument rootDocument , final String string ) { final TrailerDocument trailerDocument = findByFileAndString ( rootDocument . getFilename ( ) , string ) ; if ( trailerDocument == null ) { return null ; } final Trailer trailer = trailerDocument . getGedObject ( ) ; trailer . setParent ( rootDocument . getGedObject ( ) ) ; return trailerDocument ; }
dickschoeller/gedbrowser | @ Override public final Iterable < TrailerDocument > findAll ( final String filename ) { final Query searchQuery = new Query ( Criteria . where ( " filename " ) . is ( filename ) ) ; final List < TrailerDocumentMongo > trailerDocumentsMongo = mongoTemplate . find ( searchQuery , TrailerDocumentMongo . class ) ; if ( trailerDocumentsMongo == null ) { return null ; } final List < TrailerDocument > trailerDocuments = new ArrayList < > ( ) ; for ( final TrailerDocument trailerDocument : trailerDocumentsMongo ) { final Trailer trailer = ( Trailer ) toObjConverter . createGedObject ( null , trailerDocument ) ; trailerDocument . setGedObject ( trailer ) ; trailerDocuments . add ( trailerDocument ) ; } return trailerDocuments ; }
dickschoeller/gedbrowser | @ Override public final Iterable < TrailerDocument > findAll ( final RootDocument rootDocument ) { final Iterable < TrailerDocument > trailerDocuments = findAll ( rootDocument . getFilename ( ) ) ; if ( trailerDocuments == null ) { return null ; } for ( final TrailerDocument trailerDocument : trailerDocuments ) { final Trailer trailer = trailerDocument . getGedObject ( ) ; trailer . setParent ( rootDocument . getGedObject ( ) ) ; } return trailerDocuments ; }
dickschoeller/gedbrowser | @ Override public final long count ( final String filename ) { final Query searchQuery = new Query ( Criteria . where ( " filename " ) . is ( filename ) ) ; return mongoTemplate . count ( searchQuery , TrailerDocumentMongo . class ) ; }
dickschoeller/gedbrowser | @ Override public final long count ( final RootDocument rootDocument ) { return count ( rootDocument . getFilename ( ) ) ; }
dickschoeller/gedbrowser | @ Override public String lastId ( final RootDocument rootDocument ) { return " " ; }
dickschoeller/gedbrowser | @ Override public String newId ( final RootDocument rootDocument ) { return " " ; }
JSDemos/android-sdk-20 | protected Identity ( ) { }
JSDemos/android-sdk-20 | public Identity ( String name ) { this . name = name ; }
JSDemos/android-sdk-20 | public Identity ( String name , IdentityScope scope ) throws KeyManagementException { this ( name ) ; if ( scope != null ) { scope . addIdentity ( this ) ; this . scope = scope ; } }
JSDemos/android-sdk-20 | public void addCertificate ( Certificate certificate ) throws KeyManagementException { PublicKey certPK = certificate . getPublicKey ( ) ; if ( publicKey != null ) { if ( ! checkKeysEqual ( publicKey , certPK ) ) { throw new KeyManagementException ( " Cert ' s ▁ public ▁ key ▁ does ▁ not ▁ match ▁ Identity ' s ▁ public ▁ key " ) ; } } else { publicKey = certPK ; } if ( certificates == null ) { certificates = new Vector < Certificate > ( ) ; } certificates . add ( certificate ) ; }
JSDemos/android-sdk-20 | public void removeCertificate ( Certificate certificate ) throws KeyManagementException { if ( certificates != null ) { if ( ! certificates . contains ( certificate ) ) { throw new KeyManagementException ( " Certificate ▁ not ▁ found " ) ; } certificates . removeElement ( certificate ) ; } }
JSDemos/android-sdk-20 | public Certificate [ ] certificates ( ) { if ( certificates == null ) { return new Certificate [ 0 ] ; } Certificate [ ] ret = new Certificate [ certificates . size ( ) ] ; certificates . copyInto ( ret ) ; return ret ; }
JSDemos/android-sdk-20 | protected boolean identityEquals ( Identity identity ) { if ( ! name . equals ( identity . name ) ) { return false ; } if ( publicKey == null ) { return ( identity . publicKey == null ) ; } return checkKeysEqual ( publicKey , identity . publicKey ) ; }
JSDemos/android-sdk-20 | public String toString ( boolean detailed ) { String s = toString ( ) ; if ( detailed ) { s += " ▁ " + info ; } return s ; }
JSDemos/android-sdk-20 | public final IdentityScope getScope ( ) { return scope ; }
JSDemos/android-sdk-20 | public void setPublicKey ( PublicKey key ) throws KeyManagementException { if ( ( scope != null ) && ( key != null ) ) { Identity i = scope . getIdentity ( key ) ; if ( ( i != null ) && ( i != this ) ) { throw new KeyManagementException ( " key ▁ already ▁ used ▁ in ▁ scope " ) ; } } this . publicKey = key ; certificates = null ; }
JSDemos/android-sdk-20 | public PublicKey getPublicKey ( ) { return publicKey ; }
JSDemos/android-sdk-20 | public void setInfo ( String info ) { this . info = info ; }
JSDemos/android-sdk-20 | public String getInfo ( ) { return info ; }
JSDemos/android-sdk-20 | @ Override public final boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof Identity ) ) { return false ; } Identity i = ( Identity ) obj ; if ( Objects . equal ( name , i . name ) && ( Objects . equal ( scope , i . scope ) ) ) { return true ; } return identityEquals ( i ) ; }
JSDemos/android-sdk-20 | public final String getName ( ) { return name ; }
JSDemos/android-sdk-20 | @ Override public int hashCode ( ) { int hash = 0 ; if ( name != null ) { hash += name . hashCode ( ) ; } if ( scope != null ) { hash += scope . hashCode ( ) ; } return hash ; }
JSDemos/android-sdk-20 | @ Override public String toString ( ) { String s = ( this . name == null ? " " : this . name ) ; if ( scope != null ) { s += " ▁ [ " + scope . getName ( ) + " ] " ; } return s ; }
TomRoss/activemq-artemis | @ Override public SslContext getClientSslContext ( final SSLContextConfig config , final Map < String , Object > additionalOpts ) throws Exception { log . debugf ( " Creating ▁ Client ▁ OpenSSL ▁ Context ▁ with ▁ % s " , config ) ; return new SSLSupport ( config ) . setSslProvider ( TransportConstants . OPENSSL_PROVIDER ) . createNettyClientContext ( ) ; }
TomRoss/activemq-artemis | @ Override public SslContext getServerSslContext ( final SSLContextConfig config , final Map < String , Object > additionalOpts ) throws Exception { log . debugf ( " Creating ▁ Server ▁ OpenSSL ▁ Context ▁ with ▁ % s " , config ) ; return new SSLSupport ( config ) . setSslProvider ( TransportConstants . OPENSSL_PROVIDER ) . createNettyContext ( ) ; }
TomRoss/activemq-artemis | @ Override public int getPriority ( ) { return 5 ; }
eSDK/esdk_cloud_fm_r3_native_java | public String getName ( ) { return name ; }
eSDK/esdk_cloud_fm_r3_native_java | public void setName ( String name ) { this . name = name ; }
eSDK/esdk_cloud_fm_r3_native_java | public String getValue ( ) { return value ; }
eSDK/esdk_cloud_fm_r3_native_java | public void setValue ( String value ) { this . value = value ; }
brucevsked/vskeddemolist | " ) public String service1 ( @ PathVariable String username ) { return restTemplate . getForObject ( " http : // myprovider1 / service1 / " + username , String . class ) ; }
everttigchelaar/camel-svn | @ Test public void testMarshalDomainObject ( ) throws Exception { MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 1 ) ; PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; template . sendBody ( " direct : in " , order ) ; mock . assertIsSatisfied ( ) ; }
everttigchelaar/camel-svn | @ Test public void testMarshalDomainObjectTwice ( ) throws Exception { MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 2 ) ; PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; template . sendBody ( " direct : in " , order ) ; template . sendBody ( " direct : in " , order ) ; mock . assertIsSatisfied ( ) ; String body1 = mock . getExchanges ( ) . get ( 0 ) . getIn ( ) . getBody ( String . class ) ; String body2 = mock . getExchanges ( ) . get ( 1 ) . getIn ( ) . getBody ( String . class ) ; assertEquals ( " The ▁ body ▁ should ▁ marshalled ▁ to ▁ the ▁ same " , body1 , body2 ) ; }
everttigchelaar/camel-svn | @ Test public void testMarshalAndUnmarshal ( ) throws Exception { PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; MockEndpoint mock = getMockEndpoint ( " mock : reverse " ) ; mock . expectedMessageCount ( 1 ) ; mock . message ( 0 ) . body ( ) . isInstanceOf ( PurchaseOrder . class ) ; mock . message ( 0 ) . body ( ) . equals ( order ) ; Object result = ( Object ) template . requestBody ( " direct : marshal " , order ) ; String body = context . getTypeConverter ( ) . convertTo ( String . class , result ) ; template . sendBody ( " direct : reverse " , body ) ; mock . assertIsSatisfied ( ) ; }
everttigchelaar/camel-svn | protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : in " ) . marshal ( ) . xstream ( ) . to ( " mock : result " ) ; from ( " direct : marshal " ) . marshal ( ) . xstream ( " UTF - 8" ) ; from ( " direct : reverse " ) . unmarshal ( ) . xstream ( " UTF - 8" ) . to ( " mock : reverse " ) ; } } ; }
googleapis/google-api-java-client-services | public java . util . List < PivotGroup > getColumns ( ) { return columns ; }
googleapis/google-api-java-client-services | public PivotTable setColumns ( java . util . List < PivotGroup > columns ) { this . columns = columns ; return this ; }
googleapis/google-api-java-client-services | public java . util . Map < String , PivotFilterCriteria > getCriteria ( ) { return criteria ; }
googleapis/google-api-java-client-services | public PivotTable setCriteria ( java . util . Map < String , PivotFilterCriteria > criteria ) { this . criteria = criteria ; return this ; }
googleapis/google-api-java-client-services | public DataExecutionStatus getDataExecutionStatus ( ) { return dataExecutionStatus ; }
googleapis/google-api-java-client-services | public PivotTable setDataExecutionStatus ( DataExecutionStatus dataExecutionStatus ) { this . dataExecutionStatus = dataExecutionStatus ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getDataSourceId ( ) { return dataSourceId ; }
googleapis/google-api-java-client-services | public PivotTable setDataSourceId ( java . lang . String dataSourceId ) { this . dataSourceId = dataSourceId ; return this ; }
googleapis/google-api-java-client-services | public java . util . List < PivotFilterSpec > getFilterSpecs ( ) { return filterSpecs ; }
googleapis/google-api-java-client-services | public PivotTable setFilterSpecs ( java . util . List < PivotFilterSpec > filterSpecs ) { this . filterSpecs = filterSpecs ; return this ; }
googleapis/google-api-java-client-services | public java . util . List < PivotGroup > getRows ( ) { return rows ; }
googleapis/google-api-java-client-services | public PivotTable setRows ( java . util . List < PivotGroup > rows ) { this . rows = rows ; return this ; }
googleapis/google-api-java-client-services | public GridRange getSource ( ) { return source ; }
googleapis/google-api-java-client-services | public PivotTable setSource ( GridRange source ) { this . source = source ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getValueLayout ( ) { return valueLayout ; }
googleapis/google-api-java-client-services | public PivotTable setValueLayout ( java . lang . String valueLayout ) { this . valueLayout = valueLayout ; return this ; }
googleapis/google-api-java-client-services | public java . util . List < PivotValue > getValues ( ) { return values ; }
googleapis/google-api-java-client-services | public PivotTable setValues ( java . util . List < PivotValue > values ) { this . values = values ; return this ; }
googleapis/google-api-java-client-services | @ Override public PivotTable set ( String fieldName , Object value ) { return ( PivotTable ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public PivotTable clone ( ) { return ( PivotTable ) super . clone ( ) ; }
ucare-uchicago/hadoop | @ Before public void before ( ) { SubmarineLogs . verboseOff ( ) ; }
ucare-uchicago/hadoop | @ Test public void testPrintHelp ( ) { MockClientContext mockClientContext = new MockClientContext ( ) ; JobSubmitter mockJobSubmitter = mock ( JobSubmitter . class ) ; JobMonitor mockJobMonitor = mock ( JobMonitor . class ) ; RunJobCli runJobCli = new RunJobCli ( mockClientContext , mockJobSubmitter , mockJobMonitor ) ; runJobCli . printUsages ( ) ; }
ucare-uchicago/hadoop | @ Test public void testBasicRunJobForDistributedTraining ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; Assert . assertFalse ( SubmarineLogs . isVerbose ( ) ) ; runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - input _ path " , " hdfs : // input " , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "3" , " - - num _ ps " , "2" , " - - worker _ launch _ cmd " , " python ▁ run - job . py " , " - - worker _ resources " , " memory = 2048M , vcores = 2" , " - - ps _ resources " , " memory = 4G , vcores = 4" , " - - tensorboard " , " true " , " - - ps _ launch _ cmd " , " python ▁ run - ps . py " , " - - verbose " } ) ; RunJobParameters jobRunParameters = runJobCli . getRunJobParameters ( ) ; Assert . assertEquals ( jobRunParameters . getInputPath ( ) , " hdfs : // input " ) ; Assert . assertEquals ( jobRunParameters . getCheckpointPath ( ) , " hdfs : // output " ) ; Assert . assertEquals ( jobRunParameters . getNumPS ( ) , 2 ) ; Assert . assertEquals ( jobRunParameters . getPSLaunchCmd ( ) , " python ▁ run - ps . py " ) ; Assert . assertEquals ( Resources . createResource ( 4096 , 4 ) , jobRunParameters . getPsResource ( ) ) ; Assert . assertEquals ( jobRunParameters . getWorkerLaunchCmd ( ) , " python ▁ run - job . py " ) ; Assert . assertEquals ( Resources . createResource ( 2048 , 2 ) , jobRunParameters . getWorkerResource ( ) ) ; Assert . assertEquals ( jobRunParameters . getDockerImageName ( ) , " tf - docker : 1.1.0" ) ; Assert . assertTrue ( SubmarineLogs . isVerbose ( ) ) ; }
ucare-uchicago/hadoop | @ Test public void testBasicRunJobForSingleNodeTraining ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; Assert . assertFalse ( SubmarineLogs . isVerbose ( ) ) ; runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - input _ path " , " hdfs : // input " , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "1" , " - - worker _ launch _ cmd " , " python ▁ run - job . py " , " - - worker _ resources " , " memory = 4g , vcores = 2" , " - - tensorboard " , " true " , " - - verbose " , " - - wait _ job _ finish " } ) ; RunJobParameters jobRunParameters = runJobCli . getRunJobParameters ( ) ; Assert . assertEquals ( jobRunParameters . getInputPath ( ) , " hdfs : // input " ) ; Assert . assertEquals ( jobRunParameters . getCheckpointPath ( ) , " hdfs : // output " ) ; Assert . assertEquals ( jobRunParameters . getNumWorkers ( ) , 1 ) ; Assert . assertEquals ( jobRunParameters . getWorkerLaunchCmd ( ) , " python ▁ run - job . py " ) ; Assert . assertEquals ( Resources . createResource ( 4096 , 2 ) , jobRunParameters . getWorkerResource ( ) ) ; Assert . assertTrue ( SubmarineLogs . isVerbose ( ) ) ; Assert . assertTrue ( jobRunParameters . isWaitJobFinish ( ) ) ; }
ucare-uchicago/hadoop | @ Test public void testNoInputPathOptionSpecified ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; String expectedErrorMessage = " \" - - " + CliConstants . INPUT_PATH + " \" ▁ is ▁ absent " ; String actualMessage = " " ; try { runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "1" , " - - worker _ launch _ cmd " , " python ▁ run - job . py " , " - - worker _ resources " , " memory = 4g , vcores = 2" , " - - tensorboard " , " true " , " - - verbose " , " - - wait _ job _ finish " } ) ; } catch ( ParseException e ) { actualMessage = e . getMessage ( ) ; e . printStackTrace ( ) ; } Assert . assertEquals ( expectedErrorMessage , actualMessage ) ; }
ucare-uchicago/hadoop | @ Test public void testNoInputPathOptionButOnlyRunTensorboard ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; boolean success = true ; try { runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - num _ workers " , "0" , " - - tensorboard " , " - - verbose " , " - - tensorboard _ resources " , " memory = 2G , vcores = 2" , " - - tensorboard _ docker _ image " , " tb _ docker _ image : 001" } ) ; } catch ( ParseException e ) { success = false ; } Assert . assertTrue ( success ) ; }
ucare-uchicago/hadoop | @ Test public void testLaunchCommandPatternReplace ( ) throws Exception { RunJobCli runJobCli = new RunJobCli ( getMockClientContext ( ) ) ; Assert . assertFalse ( SubmarineLogs . isVerbose ( ) ) ; runJobCli . run ( new String [ ] { " - - name " , " my - job " , " - - docker _ image " , " tf - docker : 1.1.0" , " - - input _ path " , " hdfs : // input " , " - - checkpoint _ path " , " hdfs : // output " , " - - num _ workers " , "3" , " - - num _ ps " , "2" , " - - worker _ launch _ cmd " , " python ▁ run - job . py ▁ - - input = % input _ path % ▁ - - model _ dir = % checkpoint _ path % ▁ - - export _ dir = % saved _ model _ path % / savedmodel " , " - - worker _ resources " , " memory = 2048 , vcores = 2" , " - - ps _ resources " , " memory = 4096 , vcores = 4" , " - - tensorboard " , " true " , " - - ps _ launch _ cmd " , " python ▁ run - ps . py ▁ - - input = % input _ path % ▁ - - model _ dir = % checkpoint _ path % / model " , " - - verbose " } ) ; Assert . assertEquals ( " python ▁ run - job . py ▁ - - input = hdfs : // input ▁ - - model _ dir = hdfs : // output ▁ " + " - - export _ dir = hdfs : // output / savedmodel " , runJobCli . getRunJobParameters ( ) . getWorkerLaunchCmd ( ) ) ; Assert . assertEquals ( " python ▁ run - ps . py ▁ - - input = hdfs : // input ▁ - - model _ dir = hdfs : // output / model " , runJobCli . getRunJobParameters ( ) . getPSLaunchCmd ( ) ) ; }
ucare-uchicago/hadoop | @ Test public void testResourceUnitParsing ( ) throws Exception { Resource res = CliUtils . createResourceFromString ( " memory = 20g , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 * 1024 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20G , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 * 1024 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20M , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20m , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory - mb = 20 , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory - mb = 20m , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory - mb = 20G , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 20 * 1024 , 3 ) , res ) ; res = CliUtils . createResourceFromString ( " memory = 20 , vcores = 3" , ResourceUtils . getResourcesTypeInfo ( ) ) ; Assert . assertEquals ( Resources . createResource ( 0 , 3 ) , res ) ; List < ResourceTypeInfo > resTypes = new ArrayList < > ( ResourceUtils . getResourcesTypeInfo ( ) ) ; resTypes . add ( ResourceTypeInfo . newInstance ( ResourceInformation . GPU_URI , " " ) ) ; ResourceUtils . reinitializeResources ( resTypes ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , gpu = 0" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 0 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , gpu = 3" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 3 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 0 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , yarn . io / gpu = 0" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 0 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; res = CliUtils . createResourceFromString ( " memory = 2G , vcores = 3 , yarn . io / gpu = 3" , resTypes ) ; Assert . assertEquals ( 2 * 1024 , res . getMemorySize ( ) ) ; Assert . assertEquals ( 3 , res . getResourceValue ( ResourceInformation . GPU_URI ) ) ; }
mingxin6/incu | if ( user . getIsBusiness ( ) ) { request . setAttribute ( " type " , " B " ) ; }
mingxin6/incu | catch ( Exception e ) { e . printStackTrace ( ) ; }
mingxin6/incu | catch ( Exception e ) { }
kyunooh/goree-server | @ Before public void setUp ( ) { MockitoAnnotations . initMocks ( this ) ; mockMvc = MockMvcBuilders . standaloneSetup ( placeController ) . build ( ) ; }
kyunooh/goree-server | @ Test public void findPlaceById ( ) throws Exception { Place expected = new Place ( ) ; expected . setId ( 1L ) ; expected . setName ( " goodnews " ) ; expected . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; expected . setXCoordinate ( new BigDecimal ( "36.017194" ) ) ; expected . setYCoordinate ( new BigDecimal ( "128.6978236" ) ) ; when ( placeService . findPlaceById ( expected . getId ( ) ) ) . thenReturn ( expected ) ; mockMvc . perform ( get ( PlaceController . FIND_PLACE_BY_ID_URL , expected . getId ( ) ) . header ( HttpHeaderConstants . AUTH_TOKEN , settings . longLivedTokenForTest ( ) ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( jsonPath ( " $ . id " , is ( ( int ) expected . getId ( ) ) ) ) . andExpect ( jsonPath ( " $ . name " , is ( expected . getName ( ) ) ) ) . andExpect ( jsonPath ( " $ . address " , is ( expected . getAddress ( ) ) ) ) . andExpect ( jsonPath ( " $ . xCoordinate " , is ( expected . getXCoordinate ( ) . doubleValue ( ) ) ) ) . andExpect ( jsonPath ( " $ . yCoordinate " , is ( expected . getYCoordinate ( ) . doubleValue ( ) ) ) ) ; }
kyunooh/goree-server | @ Test public void createPlace ( ) throws Exception { Place newPlace = new Place ( ) ; newPlace . setName ( " goodnews " ) ; newPlace . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; newPlace . setXCoordinate ( new BigDecimal ( "36.017194" ) ) ; newPlace . setYCoordinate ( new BigDecimal ( "128.6978236" ) ) ; Place created = new Place ( ) ; PropertyUtils . copyProperties ( created , newPlace ) ; created . setId ( 1L ) ; when ( placeService . createPlace ( newPlace ) ) . thenReturn ( created ) ; mockMvc . perform ( post ( PlaceController . CREATE_PLACE_URL ) . header ( HttpHeaderConstants . AUTH_TOKEN , settings . longLivedTokenForTest ( ) ) . contentType ( MediaType . APPLICATION_JSON ) . content ( new ObjectMapper ( ) . writeValueAsString ( newPlace ) ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( jsonPath ( " $ . id " , is ( ( int ) created . getId ( ) ) ) ) . andExpect ( jsonPath ( " $ . name " , is ( created . getName ( ) ) ) ) . andExpect ( jsonPath ( " $ . address " , is ( created . getAddress ( ) ) ) ) . andExpect ( jsonPath ( " $ . xCoordinate " , is ( created . getXCoordinate ( ) . doubleValue ( ) ) ) ) . andExpect ( jsonPath ( " $ . yCoordinate " , is ( created . getYCoordinate ( ) . doubleValue ( ) ) ) ) ; }
kyunooh/goree-server | @ Test public void findPlaceByItself ( ) throws Exception { Place searchCondition = new Place ( ) ; searchCondition . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; Place expected = new Place ( ) ; expected . setName ( " goodnews " ) ; expected . setAddress ( " 서울시 ▁ 용산구 ▁ 청파동 ▁ 선린인고 ▁ 앞 " ) ; expected . setXCoordinate ( new BigDecimal ( "36.017194" ) ) ; expected . setYCoordinate ( new BigDecimal ( "128.6978236" ) ) ; when ( placeService . findPlaceByItself ( searchCondition ) ) . thenReturn ( expected ) ; mockMvc . perform ( get ( PlaceController . FIND_PLACE_BY_ITSELF ) . header ( HttpHeaderConstants . AUTH_TOKEN , settings . longLivedTokenForTest ( ) ) . contentType ( MediaType . APPLICATION_JSON ) . content ( new ObjectMapper ( ) . writeValueAsString ( searchCondition ) ) ) . andExpect ( status ( ) . isOk ( ) ) . andExpect ( jsonPath ( " $ . id " , is ( ( int ) expected . getId ( ) ) ) ) . andExpect ( jsonPath ( " $ . name " , is ( expected . getName ( ) ) ) ) . andExpect ( jsonPath ( " $ . address " , is ( expected . getAddress ( ) ) ) ) . andExpect ( jsonPath ( " $ . xCoordinate " , is ( expected . getXCoordinate ( ) . doubleValue ( ) ) ) ) . andExpect ( jsonPath ( " $ . yCoordinate " , is ( expected . getYCoordinate ( ) . doubleValue ( ) ) ) ) ; }
Gusbru/pets | public PetCursorAdapter ( Context context , Cursor c ) { super ( context , c , 0 ) ; }
Gusbru/pets | @ Override public View newView ( Context context , Cursor cursor , ViewGroup parent ) { return LayoutInflater . from ( context ) . inflate ( R . layout . item_pet , parent , false ) ; }
Gusbru/pets | @ Override public void bindView ( View view , Context context , Cursor cursor ) { TextView petName = ( TextView ) view . findViewById ( R . id . pet_name ) ; TextView petBreed = ( TextView ) view . findViewById ( R . id . pet_breed ) ; String name = cursor . getString ( cursor . getColumnIndexOrThrow ( PetEntry . COLUMN_NAME ) ) ; String breed = cursor . getString ( cursor . getColumnIndexOrThrow ( PetEntry . COLUMN_BREED ) ) ; petName . setText ( name ) ; petBreed . setText ( breed ) ; }
emag/wildfly-swarm | protected Main ( ) { }
emag/wildfly-swarm | catch ( Exception e ) { throw new RuntimeException ( " Failed ▁ to ▁ load ▁ version . properties " , e ) ; }
emag/wildfly-swarm | ExitException ( final int status , final boolean printHelp , final String message ) { super ( message ) ; this . printHelp = printHelp ; this . status = status ; }
adessaigne/camel | @ Test public void givenPulsarConsumerIsNullwhenICreateFactoryverifyIllegalArgumentExceptionIsThrown ( ) { assertThrows ( IllegalArgumentException . class , ( ) -> ConsumerCreationStrategyFactory . create ( null ) ) ; }
adessaigne/camel | @ Test public void givenPulsarConsumerAndRetryPolicyNonNullwhenICreateFactoryverifyIllegalArgumentExceptionIsNotThrown ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; assertNotNull ( factory ) ; }
adessaigne/camel | @ Test public void verifyFailOverStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . FAILOVER ) ; assertEquals ( FailoverConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifySharedStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . SHARED ) ; assertEquals ( SharedConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifyExclusiveStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . EXCLUSIVE ) ; assertEquals ( ExclusiveConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifyKeySharedStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( SubscriptionType . KEY_SHARED ) ; assertEquals ( KeySharedConsumerStrategy . class , strategy . getClass ( ) ) ; }
adessaigne/camel | @ Test public void verifyDefaultStrategyIsExclusiveStrategy ( ) { ConsumerCreationStrategyFactory factory = ConsumerCreationStrategyFactory . create ( mock ( PulsarConsumer . class ) ) ; ConsumerCreationStrategy strategy = factory . getStrategy ( null ) ; assertEquals ( ExclusiveConsumerStrategy . class , strategy . getClass ( ) ) ; }
comfreeze/android-tools | @ Override public int onStartCommand ( Intent intent , int flags , int startId ) { android . os . Process . setThreadPriority ( android . os . Process . THREAD_PRIORITY_BACKGROUND ) ; if ( persistent ) { return START_STICKY ; } else { return super . onStartCommand ( intent , flags , startId ) ; } }
comfreeze/android-tools | @ Override public void onCreate ( ) { super . onCreate ( ) ; initializeWorkQueue ( ) ; Log . w ( TAG , " Well , ▁ hello ▁ there . . . ▁ you ▁ come ▁ here ▁ often ? " ) ; }
comfreeze/android-tools | @ Override public void onDestroy ( ) { super . onDestroy ( ) ; Log . w ( TAG , " I ' M ▁ MELtInG . . . ▁ mel . . tin . . . g . . . " ) ; }
comfreeze/android-tools | protected void initializeWorkQueue ( ) { workQueue = new ConcurrentLinkedQueue < CFZWorkerItem > ( ) ; workerThread = new CFZWorkerThread ( workQueue , getThreadTag ( ) ) ; workerThread . start ( ) ; }
comfreeze/android-tools | protected void addRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void scheduleRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { if ( ! workQueue . contains ( work ) && ! work . equals ( workerThread . getActive ( ) ) ) { workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } } }
comfreeze/android-tools | protected void schedulePriorityRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { cancelActiveWorkItem ( work ) ; workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void replaceRunnable ( CFZWorkerItem work ) { synchronized ( workQueue ) { cancelPreviousWorkItem ( work ) ; workQueue . add ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void cancelPreviousWorkItem ( CFZWorkerItem work ) { synchronized ( workQueue ) { if ( workQueue . contains ( work ) ) workQueue . remove ( work ) ; workQueue . notifyAll ( ) ; } }
comfreeze/android-tools | protected void cancelActiveWorkItem ( CFZWorkerItem work ) { cancelPreviousWorkItem ( work ) ; if ( work . equals ( workerThread . active ) ) workerThread . interrupt ( ) ; }
comfreeze/android-tools | protected void showNotification ( CharSequence message ) { Log . d ( TAG , " Showing ▁ notification " ) ; }
comfreeze/android-tools | protected void registerClient ( Message message ) { Log . d ( TAG , " Registering ▁ client " ) ; if ( null != message . replyTo ) clients . add ( message . replyTo ) ; }
comfreeze/android-tools | protected void unregisterClient ( Message message ) { Log . d ( TAG , " Unregistering ▁ client " ) ; if ( null != message . replyTo ) clients . remove ( message . replyTo ) ; }
comfreeze/android-tools | protected void sendMessage ( Messenger client , Message msg ) { Log . d ( TAG , " Sending ▁ mesage " ) ; try { client . send ( msg ) ; } catch ( RemoteException e ) { Log . e ( TAG , " Exception " , e ) ; clients . remove ( client ) ; } }
comfreeze/android-tools | protected void sendMessage ( Message msg ) { for ( int i = clients . size ( ) - 1 ; i >= 0 ; i -- ) { sendMessage ( clients . get ( i ) , msg ) ; } }
comfreeze/android-tools | protected void sendMessage ( int code ) { sendMessage ( Message . obtain ( null , code ) ) ; }
comfreeze/android-tools | public CFZWorkerThread ( ConcurrentLinkedQueue < CFZWorkerItem > workQueue , String name ) { super ( name ) ; this . workQueue = workQueue ; }
comfreeze/android-tools | private CFZWorkerItem getWork ( ) { synchronized ( workQueue ) { try { while ( workQueue . isEmpty ( ) ) workQueue . wait ( ) ; return workQueue . remove ( ) ; } catch ( InterruptedException ie ) { throw new AssertionError ( ie ) ; } } }
comfreeze/android-tools | public Runnable getActive ( ) { return this . active ; }
comfreeze/android-tools | public void run ( ) { for ( ; ; ) { active = getWork ( ) ; active . run ( ) ; } }
comfreeze/android-tools | public CFZWorkerItem ( Intent intent , int what ) { this . intent = intent ; this . what = what ; }
comfreeze/android-tools | public void run ( ) { processItem ( intent , what ) ; }
comfreeze/android-tools | public boolean equals ( CFZWorkerItem item ) { if ( null != item && null != item . intent && ( null != item . intent . getAction ( ) && null != intent && item . intent . getAction ( ) . equals ( intent . getAction ( ) ) ) && item . what == what ) return true ; return false ; }
pevdh/telegram-bots-java-api | public ChatContextTelegramBot ( String botToken , AbstractChatContextFactory chatContextFactory ) { this ( botToken , chatContextFactory , true ) ; }
pevdh/telegram-bots-java-api | public ChatContextTelegramBot ( String botToken , AbstractChatContextFactory chatContextFactory , boolean sendAsync ) { super ( botToken ) ; this . chatContextFactory = chatContextFactory ; }
pevdh/telegram-bots-java-api | public void add ( ChatContext context ) { contextMap . put ( context . getChatId ( ) , context ) ; }
pevdh/telegram-bots-java-api | public void addAll ( List < ? extends ChatContext > contextList ) { for ( ChatContext chatContext : contextList ) add ( chatContext ) ; }
pevdh/telegram-bots-java-api | @ Override protected void onStart ( ) { for ( ChatContext chatContext : contextMap . values ( ) ) chatContext . onStart ( ) ; }
pevdh/telegram-bots-java-api | @ Override protected void onStop ( ) { for ( ChatContext chatContext : contextMap . values ( ) ) chatContext . onStop ( ) ; }
pevdh/telegram-bots-java-api | @ Override protected void onMessage ( Message message ) { int chatId = message . getChat ( ) . getId ( ) ; ChatContext chatContext ; synchronized ( contextMap ) { chatContext = contextMap . get ( chatId ) ; if ( chatContext == null ) chatContext = createNewChatContext ( chatId ) ; } chatContext . passMessage ( message ) ; }
pevdh/telegram-bots-java-api | private ChatContext createNewChatContext ( int chatId ) { ChatContext chatContext = chatContextFactory . createChatContext ( chatId , this ) ; contextMap . put ( chatId , chatContext ) ; return chatContext ; }
Esjob-Cloud-DevOps/elastic-job | @ Override public void execute ( final ShardingContext shardingContext ) { completed = true ; }
chunzj/closure-templates | private CssNode ( int id , String commandText , @ Nullable ExprRootNode componentNameExpr , String selectorText , SourceLocation sourceLocation ) { super ( id , sourceLocation , " css " , commandText ) ; this . componentNameExpr = componentNameExpr ; this . selectorText = selectorText ; if ( ! SELECTOR_TEXT_PATTERN . matcher ( selectorText ) . matches ( ) ) { maybeSetSyntaxVersionBound ( new SyntaxVersionBound ( SyntaxVersion . V2_1 , " Invalid ▁ ' css ' ▁ command ▁ text . " ) ) ; } }
chunzj/closure-templates | private CssNode ( CssNode orig , CopyState copyState ) { super ( orig , copyState ) ; this . componentNameExpr = ( orig . componentNameExpr != null ) ? orig . componentNameExpr . copy ( copyState ) : null ; this . selectorText = orig . selectorText ; }
chunzj/closure-templates | public CssNode ( CssNode orig , String newSelectorText , CopyState copyState ) { super ( orig , copyState ) ; this . componentNameExpr = ( orig . componentNameExpr != null ) ? orig . componentNameExpr . copy ( copyState ) : null ; this . selectorText = newSelectorText ; }
chunzj/closure-templates | @ Override public Kind getKind ( ) { return Kind . CSS_NODE ; }
chunzj/closure-templates | @ Nullable public ExprRootNode getComponentNameExpr ( ) { return componentNameExpr ; }
chunzj/closure-templates | public String getComponentNameText ( ) { return ( componentNameExpr != null ) ? componentNameExpr . toSourceString ( ) : null ; }
chunzj/closure-templates | public String getSelectorText ( ) { return selectorText ; }
chunzj/closure-templates | public String getRenamedSelectorText ( SoyCssRenamingMap cssRenamingMap ) { Pair < SoyCssRenamingMap , String > cache = renameCache ; if ( cache != null && cache . first == cssRenamingMap ) { return cache . second ; } if ( cssRenamingMap != null ) { String mappedText = cssRenamingMap . get ( selectorText ) ; if ( mappedText != null ) { renameCache = Pair . of ( cssRenamingMap , mappedText ) ; return mappedText ; } } return selectorText ; }
chunzj/closure-templates | @ Override public List < ExprUnion > getAllExprUnions ( ) { return ( componentNameExpr != null ) ? ImmutableList . of ( new ExprUnion ( componentNameExpr ) ) : Collections . < ExprUnion > emptyList ( ) ; }
chunzj/closure-templates | @ Override public BlockNode getParent ( ) { return ( BlockNode ) super . getParent ( ) ; }
chunzj/closure-templates | @ Override public CssNode copy ( CopyState copyState ) { return new CssNode ( this , copyState ) ; }
chunzj/closure-templates | public Builder ( int id , String commandText , SourceLocation sourceLocation ) { this . id = id ; this . commandText = commandText ; this . sourceLocation = sourceLocation ; }
chunzj/closure-templates | public CssNode build ( ErrorReporter errorReporter ) { int delimPos = commandText . lastIndexOf ( ' , ' ) ; ExprRootNode componentNameExpr = null ; String selectorText = commandText ; if ( delimPos != - 1 ) { String componentNameText = commandText . substring ( 0 , delimPos ) . trim ( ) ; componentNameExpr = new ExprRootNode ( new ExpressionParser ( componentNameText , sourceLocation , errorReporter ) . parseExpression ( ) ) ; selectorText = commandText . substring ( delimPos + 1 ) . trim ( ) ; } return new CssNode ( id , commandText , componentNameExpr , selectorText , sourceLocation ) ; }
aehlig/bazel | @ Override public List < BuildOptions > split ( BuildOptions buildOptions ) { AndroidConfiguration . Options androidOptions = buildOptions . get ( AndroidConfiguration . Options . class ) ; CppOptions cppOptions = buildOptions . get ( CppOptions . class ) ; Label androidCrosstoolTop = androidOptions . androidCrosstoolTop ; if ( androidOptions . fatApkCpus . isEmpty ( ) ) { if ( androidOptions . cpu . isEmpty ( ) || androidCrosstoolTop == null || androidCrosstoolTop . equals ( cppOptions . crosstoolTop ) ) { return ImmutableList . of ( buildOptions ) ; } else { BuildOptions splitOptions = buildOptions . clone ( ) ; splitOptions . get ( CoreOptions . class ) . cpu = androidOptions . cpu ; setCommonAndroidOptions ( androidOptions , splitOptions ) ; return ImmutableList . of ( splitOptions ) ; } } else { ImmutableList . Builder < BuildOptions > result = ImmutableList . builder ( ) ; for ( String cpu : ImmutableSortedSet . copyOf ( androidOptions . fatApkCpus ) ) { BuildOptions splitOptions = buildOptions . clone ( ) ; splitOptions . get ( AndroidConfiguration . Options . class ) . fatApkCpus = ImmutableList . of ( ) ; splitOptions . get ( AndroidConfiguration . Options . class ) . cpu = cpu ; splitOptions . get ( CoreOptions . class ) . cpu = cpu ; setCommonAndroidOptions ( androidOptions , splitOptions ) ; result . add ( splitOptions ) ; } return result . build ( ) ; } }
aehlig/bazel | private void setCommonAndroidOptions ( AndroidConfiguration . Options androidOptions , BuildOptions newOptions ) { newOptions . get ( CppOptions . class ) . cppCompiler = androidOptions . cppCompiler ; newOptions . get ( CppOptions . class ) . libcTopLabel = androidOptions . androidLibcTopLabel ; newOptions . get ( CppOptions . class ) . dynamicMode = androidOptions . dynamicMode ; setCrosstoolToAndroid ( newOptions ) ; newOptions . get ( PlatformOptions . class ) . platforms = ImmutableList . of ( ) ; }
aehlig/bazel | @ Override public boolean isImmutable ( ) { return true ; }
aehlig/bazel | @ Override public void repr ( SkylarkPrinter printer ) { printer . append ( " android _ common . multi _ cpu _ configuration " ) ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , final RuleDefinitionEnvironment env ) { return builder . add ( attr ( " manifest " , LABEL ) . allowedFileTypes ( FileType . of ( " . xml " ) ) ) . add ( attr ( " resource _ files " , LABEL_LIST ) . allowedFileTypes ( FileTypeSet . ANY_FILE ) ) . add ( attr ( " assets _ dir " , STRING ) ) . add ( attr ( " assets " , LABEL_LIST ) . allowedFileTypes ( FileTypeSet . ANY_FILE ) ) . add ( attr ( " inline _ constants " , BOOLEAN ) . undocumented ( " deprecated ▁ noop ▁ on ▁ library " ) . value ( false ) ) . add ( attr ( " custom _ package " , STRING ) ) . add ( attr ( " enable _ data _ binding " , Type . BOOLEAN ) ) . add ( attr ( DataBinding . DATABINDING_ANNOTATION_PROCESSOR_ATTR , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( env . getToolsLabel ( " // tools / android : databinding _ annotation _ processor " ) ) ) . add ( attr ( DataBinding . DATABINDING_EXEC_PROCESSOR_ATTR , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : databinding _ exec " ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( AndroidResourcesInfo . PROVIDER . getKey ( ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( AndroidNativeLibsInfo . PROVIDER . getKey ( ) ) ) . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ resource _ support " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( AndroidRuleClasses . AndroidBaseRule . class ) . build ( ) ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , RuleDefinitionEnvironment env ) { return builder . add ( attr ( " : android _ sdk " , LABEL ) . allowedRuleClasses ( " android _ sdk " ) . value ( getAndroidSdkLabel ( env . getToolsLabel ( AndroidRuleClasses . DEFAULT_SDK ) ) ) ) . add ( attr ( " plugins " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . allowedRuleClasses ( " java _ plugin " ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " : java _ plugins " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . allowedRuleClasses ( " java _ plugin " ) . silentRuleClassFilter ( ) . value ( JavaSemantics . JAVA_PLUGINS ) ) . add ( attr ( " javacopts " , STRING_LIST ) ) . add ( attr ( " $ idlclass " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : IdlClass " ) ) ) . add ( attr ( " $ desugar _ java8 _ extra _ bootclasspath " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( env . getToolsLabel ( " // tools / android : desugar _ java8 _ extra _ bootclasspath " ) ) ) . add ( attr ( " $ android _ resources _ busybox " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( DEFAULT_RESOURCES_BUSYBOX ) ) ) . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ base " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( BaseRuleClasses . RuleBase . class ) . build ( ) ; }
aehlig/bazel | public AndroidBinaryBaseRule ( AndroidNeverlinkAspect androidNeverlinkAspect , DexArchiveAspect dexArchiveAspect ) { this . androidNeverlinkAspect = androidNeverlinkAspect ; this . dexArchiveAspect = dexArchiveAspect ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , final RuleDefinitionEnvironment env ) { return builder . requiresConfigurationFragments ( AndroidConfiguration . class , JavaConfiguration . class , CppConfiguration . class ) . add ( attr ( " srcs " , LABEL_LIST ) . direct_compile_time_input ( ) . allowedFileTypes ( JavaSemantics . JAVA_SOURCE , JavaSemantics . SOURCE_JAR ) ) . override ( builder . copy ( " manifest " ) . mandatory ( ) ) . override ( builder . copy ( " deps " ) . cfg ( TransitionFactories . of ( ANDROID_SPLIT_TRANSITION ) ) . allowedRuleClasses ( ALLOWED_DEPENDENCIES ) . allowedFileTypes ( ) . mandatoryProviders ( CONTAINS_CC_INFO_PARAMS ) . mandatoryProviders ( JavaRuleClasses . CONTAINS_JAVA_PROVIDER ) . mandatoryProviders ( SkylarkProviderIdentifier . forKey ( AndroidResourcesInfo . PROVIDER . getKey ( ) ) , SkylarkProviderIdentifier . forKey ( AndroidAssetsInfo . PROVIDER . getKey ( ) ) ) . aspect ( androidNeverlinkAspect ) . aspect ( dexArchiveAspect , DexArchiveAspect . PARAM_EXTRACTOR ) ) . add ( attr ( " debug _ key " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . legacyAllowAnyFileType ( ) . value ( env . getToolsLabel ( " // tools / android : debug _ keystore " ) ) ) . add ( attr ( " nocompress _ extensions " , STRING_LIST ) ) . add ( attr ( " crunch _ png " , BOOLEAN ) . value ( true ) ) . add ( attr ( ResourceFilterFactory . RESOURCE_CONFIGURATION_FILTERS_NAME , STRING_LIST ) ) . add ( attr ( " shrink _ resources " , TRISTATE ) . value ( TriState . AUTO ) ) . add ( attr ( ResourceFilterFactory . DENSITIES_NAME , STRING_LIST ) ) . add ( attr ( " $ build _ incremental _ dexmanifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( BUILD_INCREMENTAL_DEXMANIFEST_LABEL ) ) ) . add ( attr ( " $ stubify _ manifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( STUBIFY_MANIFEST_LABEL ) ) ) . add ( attr ( " $ shuffle _ jars " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : shuffle _ jars " ) ) ) . add ( attr ( " $ dexbuilder " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexbuilder " ) ) ) . add ( attr ( " $ dexbuilder _ after _ proguard " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexbuilder _ after _ proguard " ) ) ) . add ( attr ( " $ dexsharder " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexsharder " ) ) ) . add ( attr ( " $ dexmerger " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexmerger " ) ) ) . add ( attr ( " $ merge _ dexzips " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : merge _ dexzips " ) ) ) . add ( attr ( " $ incremental _ install " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( INCREMENTAL_INSTALL_LABEL ) ) ) . add ( attr ( " $ build _ split _ manifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( BUILD_SPLIT_MANIFEST_LABEL ) ) ) . add ( attr ( " $ strip _ resources " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( STRIP_RESOURCES_LABEL ) ) ) . add ( attr ( " $ incremental _ stub _ application " , LABEL ) . value ( env . getToolsLabel ( DEFAULT_INCREMENTAL_STUB_APPLICATION ) ) . aspect ( dexArchiveAspect , DexArchiveAspect . ONLY_DESUGAR_JAVA8 ) ) . add ( attr ( " $ incremental _ split _ stub _ application " , LABEL ) . value ( env . getToolsLabel ( DEFAULT_INCREMENTAL_SPLIT_STUB_APPLICATION ) ) . aspect ( dexArchiveAspect , DexArchiveAspect . ONLY_DESUGAR_JAVA8 ) ) . add ( attr ( " $ desugar " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : desugar _ java8" ) ) ) . add ( attr ( " $ java8 _ legacy _ dex " , LABEL ) . value ( env . getToolsLabel ( " // tools / android : java8 _ legacy _ dex " ) ) ) . add ( attr ( " $ build _ java8 _ legacy _ dex " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : build _ java8 _ legacy _ dex " ) ) ) . add ( attr ( " $ desugared _ java8 _ legacy _ apis " , LABEL ) . value ( env . getToolsLabel ( " // tools / android : desugared _ java8 _ legacy _ apis " ) ) ) . add ( attr ( " dexopts " , STRING_LIST ) ) . add ( attr ( " dex _ shards " , INTEGER ) . value ( 1 ) ) . add ( attr ( " incremental _ dexing " , TRISTATE ) . nonconfigurable ( " AspectParameters ▁ don ' t ▁ support ▁ configurations . " ) ) . add ( attr ( " multidex " , STRING ) . allowedValues ( new AllowedValueSet ( MultidexMode . getValidValues ( ) ) ) . value ( MultidexMode . OFF . getAttributeValue ( ) ) ) . add ( attr ( " main _ dex _ list _ opts " , STRING_LIST ) ) . add ( attr ( " main _ dex _ list " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " main _ dex _ proguard _ specs " , LABEL_LIST ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ specs " , LABEL_LIST ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ generate _ mapping " , BOOLEAN ) . value ( false ) . nonconfigurable ( " value ▁ is ▁ referenced ▁ in ▁ an ▁ ImplicitOutputsFunction " ) ) . add ( attr ( " proguard _ apply _ mapping " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ apply _ dictionary " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " : extra _ proguard _ specs " , LABEL_LIST ) . value ( JavaSemantics . EXTRA_PROGUARD_SPECS ) ) . add ( attr ( " $ dex _ list _ obfuscator " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dex _ list _ obfuscator " ) ) ) . add ( attr ( " : bytecode _ optimizers " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . value ( JavaSemantics . BYTECODE_OPTIMIZERS ) ) . add ( attr ( " $ cc _ toolchain _ split " , LABEL ) . cfg ( TransitionFactories . of ( ANDROID_SPLIT_TRANSITION ) ) . value ( env . getToolsLabel ( " // tools / cpp : current _ cc _ toolchain " ) ) ) . add ( attr ( " manifest _ values " , STRING_DICT ) ) . add ( attr ( " aapt _ version " , STRING ) . allowedValues ( new AllowedValueSet ( AndroidAaptVersion . getAttributeValues ( ) ) ) . value ( AndroidAaptVersion . getRuleAttributeDefault ( ) ) ) . add ( attr ( AndroidFeatureFlagSetProvider . FEATURE_FLAG_ATTR , LABEL_KEYED_STRING_DICT ) . undocumented ( " the ▁ feature ▁ flag ▁ feature ▁ has ▁ not ▁ yet ▁ been ▁ launched " ) . allowedRuleClasses ( " config _ feature _ flag " ) . allowedFileTypes ( ) . nonconfigurable ( " defines ▁ an ▁ aspect ▁ of ▁ configuration " ) . mandatoryProviders ( ImmutableList . of ( ConfigFeatureFlagProvider . id ( ) ) ) ) . add ( AndroidFeatureFlagSetProvider . getWhitelistAttribute ( env ) ) . add ( attr ( " $ resource _ extractor " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : resource _ extractor " ) ) ) . add ( attr ( " instruments " , LABEL ) . allowedRuleClasses ( " android _ binary " ) . allowedFileTypes ( NO_FILE ) ) . add ( attr ( " $ instrumentation _ test _ check " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( new Attribute . ComputedDefault ( ) { @ Override public Object getDefault ( AttributeMap rule ) { return rule . isAttributeValueExplicitlySpecified ( " instruments " ) ? env . getToolsLabel ( " // tools / android : instrumentation _ test _ check " ) : null ; } } ) . exec ( ) ) . add ( attr ( " $ zip _ filter " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : zip _ filter " ) ) ) . add ( attr ( " application _ resources " , LABEL ) . mandatoryProviders ( AndroidApplicationResourceInfo . PROVIDER . id ( ) ) . allowedFileTypes ( NO_FILE ) . undocumented ( " Do ▁ not ▁ use ▁ this ▁ attribute . ▁ It ' s ▁ for ▁ the ▁ migration ▁ of ▁ " + " Android ▁ resource ▁ processing ▁ to ▁ Starlark ▁ only . " ) ) . removeAttribute ( " data " ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( ApkInfo . PROVIDER . getKey ( ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( JavaInfo . PROVIDER . getKey ( ) ) ) . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ binary _ base " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( AndroidResourceSupportRule . class ) . build ( ) ; }
aehlig/bazel | public String getAttributeValue ( ) { return toString ( ) . toLowerCase ( ) ; }
aehlig/bazel | public String getOutputDexFilename ( ) { return this == OFF ? " classes . dex " : " classes . dex . zip " ; }
aehlig/bazel | public AndroidToolsDefaultsJarRule ( Class < ? extends AndroidToolsDefaultsJar > factoryClass , Label ... compatibleWithAndroidEnvironments ) { this . factoryClass = factoryClass ; this . compatibleWithAndroidEnvironments = compatibleWithAndroidEnvironments ; }
aehlig/bazel | @ Override public RuleClass build ( RuleClass . Builder builder , RuleDefinitionEnvironment environment ) { builder . setUndocumented ( ) . add ( attr ( " : android _ sdk " , LABEL ) . allowedRuleClasses ( " android _ sdk " ) . value ( getAndroidSdkLabel ( environment . getToolsLabel ( DEFAULT_SDK ) ) ) ) ; if ( compatibleWithAndroidEnvironments . length > 0 ) { builder . compatibleWith ( compatibleWithAndroidEnvironments ) ; } return builder . build ( ) ; }
aehlig/bazel | @ Override public Metadata getMetadata ( ) { return Metadata . builder ( ) . name ( " android _ tools _ defaults _ jar " ) . ancestors ( BaseRuleClasses . BaseRule . class ) . factoryClass ( factoryClass ) . build ( ) ; }
