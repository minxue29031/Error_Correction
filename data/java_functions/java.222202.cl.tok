DongpoAlex/hhvss | public WritableSheet copySheetSettingToSheet ( WritableSheet sheet , SheetSettings setting ) { SheetSettings sheetSettings = sheet . getSettings ( ) ; sheetSettings . setBottomMargin ( setting . getBottomMargin ( ) ) ; sheetSettings . setCopies ( setting . getCopies ( ) ) ; sheetSettings . setDefaultColumnWidth ( setting . getDefaultColumnWidth ( ) ) ; sheetSettings . setDefaultRowHeight ( setting . getDefaultRowHeight ( ) ) ; sheetSettings . setDisplayZeroValues ( setting . getDisplayZeroValues ( ) ) ; sheetSettings . setFitHeight ( setting . getFitHeight ( ) ) ; sheetSettings . setFitToPages ( setting . getFitToPages ( ) ) ; sheetSettings . setFitWidth ( setting . getFitWidth ( ) ) ; HeaderFooter footer = setting . getFooter ( ) ; if ( footer != null ) { sheetSettings . setFooter ( footer ) ; } sheetSettings . setFooterMargin ( setting . getFooterMargin ( ) ) ; HeaderFooter header = setting . getHeader ( ) ; if ( header != null ) { sheetSettings . setHeader ( header ) ; } sheetSettings . setHeaderMargin ( setting . getHeaderMargin ( ) ) ; sheetSettings . setHidden ( setting . isHidden ( ) ) ; sheetSettings . setHorizontalCentre ( setting . isHorizontalCentre ( ) ) ; sheetSettings . setHorizontalFreeze ( setting . getHorizontalFreeze ( ) ) ; sheetSettings . setHorizontalPrintResolution ( setting . getHorizontalPrintResolution ( ) ) ; sheetSettings . setLeftMargin ( setting . getLeftMargin ( ) ) ; PageOrientation pageOrientation = setting . getOrientation ( ) ; if ( pageOrientation != null ) { sheetSettings . setOrientation ( pageOrientation ) ; } sheetSettings . setPageStart ( setting . getPageStart ( ) ) ; PaperSize paperSize = setting . getPaperSize ( ) ; if ( paperSize != null ) { sheetSettings . setPaperSize ( setting . getPaperSize ( ) ) ; } sheetSettings . setPassword ( setting . getPassword ( ) ) ; sheetSettings . setPasswordHash ( setting . getPasswordHash ( ) ) ; sheetSettings . setPrintGridLines ( setting . getPrintGridLines ( ) ) ; sheetSettings . setPrintHeaders ( setting . getPrintHeaders ( ) ) ; sheetSettings . setProtected ( setting . isProtected ( ) ) ; sheetSettings . setRightMargin ( setting . getRightMargin ( ) ) ; sheetSettings . setScaleFactor ( setting . getScaleFactor ( ) ) ; sheetSettings . setSelected ( setting . isSelected ( ) ) ; sheetSettings . setShowGridLines ( setting . getShowGridLines ( ) ) ; sheetSettings . setTopMargin ( setting . getTopMargin ( ) ) ; sheetSettings . setVerticalCentre ( setting . isVerticalCentre ( ) ) ; sheetSettings . setVerticalFreeze ( setting . getVerticalFreeze ( ) ) ; sheetSettings . setVerticalPrintResolution ( setting . getVerticalPrintResolution ( ) ) ; sheetSettings . setZoomFactor ( setting . getZoomFactor ( ) ) ; return sheet ; }
saki4510t/ExoPlayer | public MediaChunk ( DataSource dataSource , DataSpec dataSpec , Format trackFormat , int trackSelectionReason , Object trackSelectionData , long startTimeUs , long endTimeUs , long chunkIndex ) { super ( dataSource , dataSpec , C . DATA_TYPE_MEDIA , trackFormat , trackSelectionReason , trackSelectionData , startTimeUs , endTimeUs ) ; Assertions . checkNotNull ( trackFormat ) ; this . chunkIndex = chunkIndex ; }
saki4510t/ExoPlayer | public long getNextChunkIndex ( ) { return chunkIndex != C . INDEX_UNSET ? chunkIndex + 1 : C . INDEX_UNSET ; }
dkpro/dkpro-jwktl | @ Override protected void setUp ( ) throws Exception { nounTableHandler = new DEWordFormNounTableHandler ( ) ; genusHandler = new GenusHandler ( nounTableHandler ) ; }
dkpro/dkpro-jwktl | public void testCanHandle ( ) { assertFalse ( genusHandler . canHandle ( null , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Suneg " , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus " , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ " , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ 0" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 1" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 2" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 3" , null , null , null ) ) ; assertTrue ( genusHandler . canHandle ( " Genus ▁ 4" , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ 4.5" , null , null , null ) ) ; assertFalse ( genusHandler . canHandle ( " Genus ▁ 5" , null , null , null ) ) ; }
dkpro/dkpro-jwktl | public void testGenus ( ) { genusHandler . handle ( " Genus " , " m " , null , null ) ; assertEquals ( DEGenderText . M , nounTableHandler . getGenusByIndex ( 1 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 2 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus1 ( ) { genusHandler . handle ( " Genus ▁ 1" , " n " , null , null ) ; assertEquals ( DEGenderText . N , nounTableHandler . getGenusByIndex ( 1 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 2 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus2 ( ) { genusHandler . handle ( " Genus ▁ 2" , " pl " , null , null ) ; assertNull ( nounTableHandler . getGenusByIndex ( 1 ) ) ; assertEquals ( DEGenderText . PL , nounTableHandler . getGenusByIndex ( 2 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 3 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus3 ( ) { genusHandler . handle ( " Genus ▁ 3" , "0" , null , null ) ; assertNull ( nounTableHandler . getGenusByIndex ( 2 ) ) ; assertEquals ( DEGenderText . _0 , nounTableHandler . getGenusByIndex ( 3 ) ) ; assertNull ( nounTableHandler . getGenusByIndex ( 4 ) ) ; }
dkpro/dkpro-jwktl | public void testGenus4 ( ) { genusHandler . handle ( " Genus ▁ 4" , " x " , null , null ) ; assertNull ( nounTableHandler . getGenusByIndex ( 3 ) ) ; assertEquals ( DEGenderText . X , nounTableHandler . getGenusByIndex ( 4 ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | public DbContactEmailSensorDao ( DaoConfig config ) { super ( config ) ; }
Telecooperation/assistance-platform-client-sdk-android | public DbContactEmailSensorDao ( DaoConfig config , DaoSession daoSession ) { super ( config , daoSession ) ; this . daoSession = daoSession ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final void bindValues ( DatabaseStatement stmt , DbContactEmailSensor entity ) { stmt . clearBindings ( ) ; Long id = entity . getId ( ) ; if ( id != null ) { stmt . bindLong ( 1 , id ) ; } Long mailId = entity . getMailId ( ) ; if ( mailId != null ) { stmt . bindLong ( 2 , mailId ) ; } String address = entity . getAddress ( ) ; if ( address != null ) { stmt . bindString ( 3 , address ) ; } String type = entity . getType ( ) ; if ( type != null ) { stmt . bindString ( 4 , type ) ; } Boolean isNew = entity . getIsNew ( ) ; if ( isNew != null ) { stmt . bindLong ( 5 , isNew ? 1L : 0L ) ; } Boolean isUpdated = entity . getIsUpdated ( ) ; if ( isUpdated != null ) { stmt . bindLong ( 6 , isUpdated ? 1L : 0L ) ; } Boolean isDeleted = entity . getIsDeleted ( ) ; if ( isDeleted != null ) { stmt . bindLong ( 7 , isDeleted ? 1L : 0L ) ; } stmt . bindString ( 8 , entity . getCreated ( ) ) ; stmt . bindLong ( 9 , entity . getContactId ( ) ) ; stmt . bindLong ( 10 , entity . getDeviceId ( ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final void bindValues ( SQLiteStatement stmt , DbContactEmailSensor entity ) { stmt . clearBindings ( ) ; Long id = entity . getId ( ) ; if ( id != null ) { stmt . bindLong ( 1 , id ) ; } Long mailId = entity . getMailId ( ) ; if ( mailId != null ) { stmt . bindLong ( 2 , mailId ) ; } String address = entity . getAddress ( ) ; if ( address != null ) { stmt . bindString ( 3 , address ) ; } String type = entity . getType ( ) ; if ( type != null ) { stmt . bindString ( 4 , type ) ; } Boolean isNew = entity . getIsNew ( ) ; if ( isNew != null ) { stmt . bindLong ( 5 , isNew ? 1L : 0L ) ; } Boolean isUpdated = entity . getIsUpdated ( ) ; if ( isUpdated != null ) { stmt . bindLong ( 6 , isUpdated ? 1L : 0L ) ; } Boolean isDeleted = entity . getIsDeleted ( ) ; if ( isDeleted != null ) { stmt . bindLong ( 7 , isDeleted ? 1L : 0L ) ; } stmt . bindString ( 8 , entity . getCreated ( ) ) ; stmt . bindLong ( 9 , entity . getContactId ( ) ) ; stmt . bindLong ( 10 , entity . getDeviceId ( ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final void attachEntity ( DbContactEmailSensor entity ) { super . attachEntity ( entity ) ; entity . __setDaoSession ( daoSession ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public Long readKey ( Cursor cursor , int offset ) { return cursor . isNull ( offset + 0 ) ? null : cursor . getLong ( offset + 0 ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public DbContactEmailSensor readEntity ( Cursor cursor , int offset ) { DbContactEmailSensor entity = new DbContactEmailSensor ( cursor . isNull ( offset + 0 ) ? null : cursor . getLong ( offset + 0 ) , cursor . isNull ( offset + 1 ) ? null : cursor . getLong ( offset + 1 ) , cursor . isNull ( offset + 2 ) ? null : cursor . getString ( offset + 2 ) , cursor . isNull ( offset + 3 ) ? null : cursor . getString ( offset + 3 ) , cursor . isNull ( offset + 4 ) ? null : cursor . getShort ( offset + 4 ) != 0 , cursor . isNull ( offset + 5 ) ? null : cursor . getShort ( offset + 5 ) != 0 , cursor . isNull ( offset + 6 ) ? null : cursor . getShort ( offset + 6 ) != 0 , cursor . getString ( offset + 7 ) , cursor . getLong ( offset + 8 ) , cursor . getLong ( offset + 9 ) ) ; return entity ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public void readEntity ( Cursor cursor , DbContactEmailSensor entity , int offset ) { entity . setId ( cursor . isNull ( offset + 0 ) ? null : cursor . getLong ( offset + 0 ) ) ; entity . setMailId ( cursor . isNull ( offset + 1 ) ? null : cursor . getLong ( offset + 1 ) ) ; entity . setAddress ( cursor . isNull ( offset + 2 ) ? null : cursor . getString ( offset + 2 ) ) ; entity . setType ( cursor . isNull ( offset + 3 ) ? null : cursor . getString ( offset + 3 ) ) ; entity . setIsNew ( cursor . isNull ( offset + 4 ) ? null : cursor . getShort ( offset + 4 ) != 0 ) ; entity . setIsUpdated ( cursor . isNull ( offset + 5 ) ? null : cursor . getShort ( offset + 5 ) != 0 ) ; entity . setIsDeleted ( cursor . isNull ( offset + 6 ) ? null : cursor . getShort ( offset + 6 ) != 0 ) ; entity . setCreated ( cursor . getString ( offset + 7 ) ) ; entity . setContactId ( cursor . getLong ( offset + 8 ) ) ; entity . setDeviceId ( cursor . getLong ( offset + 9 ) ) ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final Long updateKeyAfterInsert ( DbContactEmailSensor entity , long rowId ) { entity . setId ( rowId ) ; return rowId ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override public Long getKey ( DbContactEmailSensor entity ) { if ( entity != null ) { return entity . getId ( ) ; } else { return null ; } }
Telecooperation/assistance-platform-client-sdk-android | @ Override public boolean hasKey ( DbContactEmailSensor entity ) { return entity . getId ( ) != null ; }
Telecooperation/assistance-platform-client-sdk-android | @ Override protected final boolean isEntityUpdateable ( ) { return true ; }
Telecooperation/assistance-platform-client-sdk-android | public List < DbContactEmailSensor > _queryDbContactSensor_DbContactEmailSensorList ( long contactId ) { synchronized ( this ) { if ( dbContactSensor_DbContactEmailSensorListQuery == null ) { QueryBuilder < DbContactEmailSensor > queryBuilder = queryBuilder ( ) ; queryBuilder . where ( Properties . ContactId . eq ( null ) ) ; dbContactSensor_DbContactEmailSensorListQuery = queryBuilder . build ( ) ; } } Query < DbContactEmailSensor > query = dbContactSensor_DbContactEmailSensorListQuery . forCurrentThread ( ) ; query . setParameter ( 0 , contactId ) ; return query . list ( ) ; }
Telecooperation/assistance-platform-client-sdk-android | protected String getSelectDeep ( ) { if ( selectDeep == null ) { StringBuilder builder = new StringBuilder ( " SELECT ▁ " ) ; SqlUtils . appendColumns ( builder , " T " , getAllColumns ( ) ) ; builder . append ( ' , ' ) ; SqlUtils . appendColumns ( builder , " T0" , daoSession . getDbContactSensorDao ( ) . getAllColumns ( ) ) ; builder . append ( ' , ' ) ; SqlUtils . appendColumns ( builder , " T1" , daoSession . getDbDeviceDao ( ) . getAllColumns ( ) ) ; builder . append ( " ▁ FROM ▁ contact _ email _ sensor ▁ T " ) ; builder . append ( " ▁ LEFT ▁ JOIN ▁ contact _ sensor ▁ T0 ▁ ON ▁ T . \" CONTACT _ ID \" = T0 . \" _ id \" " ) ; builder . append ( " ▁ LEFT ▁ JOIN ▁ device ▁ T1 ▁ ON ▁ T . \" DEVICE _ ID \" = T1 . \" _ id \" " ) ; builder . append ( ' ▁ ' ) ; selectDeep = builder . toString ( ) ; } return selectDeep ; }
Telecooperation/assistance-platform-client-sdk-android | protected DbContactEmailSensor loadCurrentDeep ( Cursor cursor , boolean lock ) { DbContactEmailSensor entity = loadCurrent ( cursor , 0 , lock ) ; int offset = getAllColumns ( ) . length ; DbContactSensor dbContactSensor = loadCurrentOther ( daoSession . getDbContactSensorDao ( ) , cursor , offset ) ; if ( dbContactSensor != null ) { entity . setDbContactSensor ( dbContactSensor ) ; } offset += daoSession . getDbContactSensorDao ( ) . getAllColumns ( ) . length ; DbDevice dbDevice = loadCurrentOther ( daoSession . getDbDeviceDao ( ) , cursor , offset ) ; if ( dbDevice != null ) { entity . setDbDevice ( dbDevice ) ; } return entity ; }
Telecooperation/assistance-platform-client-sdk-android | public DbContactEmailSensor loadDeep ( Long key ) { assertSinglePk ( ) ; if ( key == null ) { return null ; } StringBuilder builder = new StringBuilder ( getSelectDeep ( ) ) ; builder . append ( " WHERE ▁ " ) ; SqlUtils . appendColumnsEqValue ( builder , " T " , getPkColumns ( ) ) ; String sql = builder . toString ( ) ; String [ ] keyArray = new String [ ] { key . toString ( ) } ; Cursor cursor = db . rawQuery ( sql , keyArray ) ; try { boolean available = cursor . moveToFirst ( ) ; if ( ! available ) { return null ; } else if ( ! cursor . isLast ( ) ) { throw new IllegalStateException ( " Expected ▁ unique ▁ result , ▁ but ▁ count ▁ was ▁ " + cursor . getCount ( ) ) ; } return loadCurrentDeep ( cursor , true ) ; } finally { cursor . close ( ) ; } }
Telecooperation/assistance-platform-client-sdk-android | public List < DbContactEmailSensor > loadAllDeepFromCursor ( Cursor cursor ) { int count = cursor . getCount ( ) ; List < DbContactEmailSensor > list = new ArrayList < DbContactEmailSensor > ( count ) ; if ( cursor . moveToFirst ( ) ) { if ( identityScope != null ) { identityScope . lock ( ) ; identityScope . reserveRoom ( count ) ; } try { do { list . add ( loadCurrentDeep ( cursor , false ) ) ; } while ( cursor . moveToNext ( ) ) ; } finally { if ( identityScope != null ) { identityScope . unlock ( ) ; } } } return list ; }
Telecooperation/assistance-platform-client-sdk-android | protected List < DbContactEmailSensor > loadDeepAllAndCloseCursor ( Cursor cursor ) { try { return loadAllDeepFromCursor ( cursor ) ; } finally { cursor . close ( ) ; } }
Telecooperation/assistance-platform-client-sdk-android | public List < DbContactEmailSensor > queryDeep ( String where , String ... selectionArg ) { Cursor cursor = db . rawQuery ( getSelectDeep ( ) + where , selectionArg ) ; return loadDeepAllAndCloseCursor ( cursor ) ; }
Log10Solutions/querydsl | private Document createDocument ( ) { Document doc = new Document ( ) ; doc . add ( new Field ( " title " , new StringReader ( " Jurassic ▁ Park " ) ) ) ; doc . add ( new Field ( " author " , new StringReader ( " Michael ▁ Crichton " ) ) ) ; doc . add ( new Field ( " text " , new StringReader ( " It ' s ▁ a ▁ UNIX ▁ system ! ▁ I ▁ know ▁ this ! " ) ) ) ; doc . add ( new Field ( " rating " , new StringReader ( " Good " ) ) ) ; doc . add ( new Field ( " publisher " , " " , Store . YES , Index . ANALYZED ) ) ; doc . add ( new IntField ( " year " , 1990 , Store . YES ) ) ; doc . add ( new DoubleField ( " gross " , 900.0 , Store . YES ) ) ; doc . add ( new LongField ( " longField " , 1 , Store . YES ) ) ; doc . add ( new IntField ( " shortField " , 1 , Store . YES ) ) ; doc . add ( new IntField ( " byteField " , 1 , Store . YES ) ) ; doc . add ( new FloatField ( " floatField " , 1 , Store . YES ) ) ; return doc ; }
Log10Solutions/querydsl | @ Before public void setUp ( ) throws Exception { serializer = new LuceneSerializer ( true , true ) ; entityPath = new PathBuilder < Object > ( Object . class , " obj " ) ; title = entityPath . getString ( " title " ) ; author = entityPath . getString ( " author " ) ; text = entityPath . getString ( " text " ) ; publisher = entityPath . getString ( " publisher " ) ; year = entityPath . getNumber ( " year " , Integer . class ) ; rating = entityPath . getString ( " rating " ) ; gross = entityPath . getNumber ( " gross " , Double . class ) ; titles = entityPath . getCollection ( " title " , String . class , StringPath . class ) ; longField = entityPath . getNumber ( " longField " , Long . class ) ; shortField = entityPath . getNumber ( " shortField " , Short . class ) ; byteField = entityPath . getNumber ( " byteField " , Byte . class ) ; floatField = entityPath . getNumber ( " floatField " , Float . class ) ; idx = new RAMDirectory ( ) ; config = new IndexWriterConfig ( Version . LUCENE_42 , new StandardAnalyzer ( Version . LUCENE_42 ) ) . setOpenMode ( IndexWriterConfig . OpenMode . CREATE ) ; writer = new IndexWriter ( idx , config ) ; writer . addDocument ( createDocument ( ) ) ; writer . close ( ) ; IndexReader reader = IndexReader . open ( idx ) ; searcher = new IndexSearcher ( reader ) ; }
Log10Solutions/querydsl | @ After public void tearDown ( ) throws Exception { searcher . getIndexReader ( ) . close ( ) ; }
Log10Solutions/querydsl | private void testQuery ( Expression < ? > expr , int expectedHits ) throws Exception { Query query = serializer . toQuery ( expr , metadata ) ; TopDocs docs = searcher . search ( query , 100 ) ; assertEquals ( expectedHits , docs . totalHits ) ; }
Log10Solutions/querydsl | private void testQuery ( Expression < ? > expr , String expectedQuery , int expectedHits ) throws Exception { Query query = serializer . toQuery ( expr , metadata ) ; TopDocs docs = searcher . search ( query , 100 ) ; assertEquals ( expectedHits , docs . totalHits ) ; assertEquals ( expectedQuery , query . toString ( ) ) ; }
Log10Solutions/querydsl | @ Test public void QueryElement ( ) throws Exception { Query query1 = serializer . toQuery ( author . like ( " Michael " ) , metadata ) ; Query query2 = serializer . toQuery ( text . like ( " Text " ) , metadata ) ; BooleanExpression query = Expressions . anyOf ( new QueryElement ( query1 ) , new QueryElement ( query2 ) ) ; testQuery ( query , " author : michael ▁ text : text " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like ( ) throws Exception { testQuery ( author . like ( " * ichael * " ) , " author : * ichael * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Custom_Wildcard_Single_Character ( ) throws Exception { testQuery ( author . like ( " Mi ? hael " ) , " author : mi ? hael " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Custom_Wildcard_Multiple_Character ( ) throws Exception { testQuery ( text . like ( " * U * X * " ) , " text : * u * x * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Phrase ( ) throws Exception { testQuery ( title . like ( " * rassic ▁ Par * " ) , " + title : * * rassic * ▁ + title : * par * * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_or_like ( ) throws Exception { testQuery ( title . like ( " House " ) . or ( author . like ( " * ichae * " ) ) , " title : house ▁ author : * ichae * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_and_like ( ) throws Exception { testQuery ( title . like ( " * assic * " ) . and ( rating . like ( " G ? od " ) ) , " + title : * assic * ▁ + rating : g ? od " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq ( ) throws Exception { testQuery ( rating . eq ( " good " ) , " rating : good " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_with_deep_path ( ) throws Exception { StringPath deepPath = entityPath . get ( " property1" , Object . class ) . getString ( " property2" ) ; testQuery ( deepPath . eq ( " good " ) , " property1 . property2 : good " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void FuzzyLike ( ) throws Exception { testQuery ( LuceneExpressions . fuzzyLike ( rating , " Good " ) , " rating : Good ~ 2" , 1 ) ; }
Log10Solutions/querydsl | @ Test public void FuzzyLike_with_Similarity ( ) throws Exception { testQuery ( LuceneExpressions . fuzzyLike ( rating , " Good " , 2 ) , " rating : Good ~ 2" , 1 ) ; }
Log10Solutions/querydsl | @ Test public void FuzzyLike_with_Similarity_and_prefix ( ) throws Exception { testQuery ( LuceneExpressions . fuzzyLike ( rating , " Good " , 2 , 0 ) , " rating : Good ~ 2" , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_Numeric_Integer ( ) throws Exception { testQuery ( year . eq ( 1990 ) , " year : " + YEAR_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_Numeric_Double ( ) throws Exception { testQuery ( gross . eq ( 900.00 ) , " gross : " + GROSS_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_Numeric ( ) throws Exception { testQuery ( longField . eq ( 1L ) , " longField : " + LONG_PREFIX_CODED , 1 ) ; testQuery ( shortField . eq ( ( short ) 1 ) , " shortField : " + SHORT_PREFIX_CODED , 1 ) ; testQuery ( byteField . eq ( ( byte ) 1 ) , " byteField : " + BYTE_PREFIX_CODED , 1 ) ; testQuery ( floatField . eq ( ( float ) 1.0 ) , " floatField : " + FLOAT_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Equals_Ignores_Case ( ) throws Exception { testQuery ( title . eq ( " Jurassic " ) , " title : jurassic " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Title_Equals_Ignore_Case_Or_Year_Equals ( ) throws Exception { testQuery ( title . equalsIgnoreCase ( " House " ) . or ( year . eq ( 1990 ) ) , " title : house ▁ year : " + YEAR_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_and_eq ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) . and ( year . eq ( 1990 ) ) , " + title : \" jurassic ▁ park \" ▁ + year : " + YEAR_PREFIX_CODED , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Eq_and_Eq_and_eq ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) . and ( year . eq ( 1990 ) ) . and ( author . eq ( " Michael ▁ Crichton " ) ) , " + ( + title : \" jurassic ▁ park \" ▁ + year : " + YEAR_PREFIX_CODED + " ) ▁ + author : \" michael ▁ crichton \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Equals_Ignore_Case_And_Or ( ) throws Exception { testQuery ( title . equalsIgnoreCase ( " Jurassic ▁ Park " ) . and ( rating . equalsIgnoreCase ( " Bad " ) ) . or ( author . equalsIgnoreCase ( " Michael ▁ Crichton " ) ) , " ( + title : \" jurassic ▁ park \" ▁ + rating : bad ) ▁ author : \" michael ▁ crichton \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_or_Eq_and_Eq_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . eq ( " jeeves " ) . or ( rating . eq ( " superb " ) ) . and ( author . eq ( " michael ▁ crichton " ) ) , " + ( title : jeeves ▁ rating : superb ) ▁ + author : \" michael ▁ crichton \" " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_Phrase ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) , " title : \" jurassic ▁ park \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore ( " Not ▁ easily ▁ done ▁ in ▁ Lucene ! " ) public void Publisher_Equals_Empty_String ( ) throws Exception { testQuery ( publisher . eq ( " " ) , " publisher : " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_Phrase_Should_Not_Find_Results_But_LuceNe_Semantics_Differs_From_Querydsls ( ) throws Exception { testQuery ( text . eq ( " UNIX ▁ System " ) , " text : \" unix ▁ system \" " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_Phrase_Does_Not_Find_Results_Because_Word_In_Middle ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Amusement ▁ Park " ) , " title : \" jurassic ▁ amusement ▁ park \" " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Like_not_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . like ( " * H * e * " ) . not ( ) , " - title : * h * e * ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Title_Equals_Ignore_Case_Negation_Or_Rating_Equals_Ignore_Case ( ) throws Exception { testQuery ( title . equalsIgnoreCase ( " House " ) . not ( ) . or ( rating . equalsIgnoreCase ( " Good " ) ) , " - title : house ▁ rating : good " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_not_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . eq ( " Jurassic ▁ Park " ) . not ( ) , " - title : \" jurassic ▁ park \" ▁ + * : * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Title_Equals_Not_House ( ) throws Exception { testQuery ( title . eq ( " house " ) . not ( ) , " - title : house ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Eq_and_Eq_not_Does_Not_Find_Results_Because_Second_Expression_Finds_Nothing ( ) throws Exception { testQuery ( rating . eq ( " superb " ) . and ( title . eq ( " house " ) . not ( ) ) , " + rating : superb ▁ + ( - title : house ▁ + * : * ) " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Not_Equals_Finds_One ( ) throws Exception { testQuery ( title . ne ( " house " ) , " - title : house ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Not_Equals_Finds_None ( ) throws Exception { testQuery ( title . ne ( " Jurassic ▁ Park " ) , " - title : \" jurassic ▁ park \" ▁ + * : * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Nothing_Found_With_Not_Equals_Or_Equals ( ) throws Exception { testQuery ( title . ne ( " jurassic ▁ park " ) . or ( rating . eq ( " lousy " ) ) , " ( - title : \" jurassic ▁ park \" ▁ + * : * ) ▁ rating : lousy " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Ne_and_eq ( ) throws Exception { testQuery ( title . ne ( " house " ) . and ( rating . eq ( " good " ) ) , " + ( - title : house ▁ + * : * ) ▁ + rating : good " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void StartsWith ( ) throws Exception { testQuery ( title . startsWith ( " Jurassi " ) , " title : jurassi * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void StartsWith_Phrase ( ) throws Exception { testQuery ( title . startsWith ( " jurassic ▁ par " ) , " + title : jurassic * ▁ + title : * par * " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Starts_With_Ignore_Case_Phrase_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . startsWithIgnoreCase ( " urassic ▁ Par " ) , " + title : urassic * ▁ + title : * par * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void EndsWith ( ) throws Exception { testQuery ( title . endsWith ( " ark " ) , " title : * ark " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Ends_With_Ignore_Case_Phrase ( ) throws Exception { testQuery ( title . endsWithIgnoreCase ( " sic ▁ Park " ) , " + title : * sic * ▁ + title : * park " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Ends_With_Ignore_Case_Phrase_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . endsWithIgnoreCase ( " sic ▁ Par " ) , " + title : * sic * ▁ + title : * par " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Contains ( ) throws Exception { testQuery ( title . contains ( " rassi " ) , " title : * rassi * " , 1 ) ; }
Log10Solutions/querydsl | @ Test ( expected = UnsupportedOperationException . class ) public void Contains_Ignore_Case_Phrase ( ) throws Exception { testQuery ( title . containsIgnoreCase ( " rassi ▁ Pa " ) , " + title : * rassi * ▁ + title : * pa * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Contains_User_Inputted_Wildcards_Dont_Work ( ) throws Exception { testQuery ( title . contains ( " r * i " ) , " title : * r \\ * i * " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Between ( ) throws Exception { testQuery ( title . between ( " Indiana " , " Kundun " ) , " title : [ indiana ▁ TO ▁ kundun ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Numeric_Integer ( ) throws Exception { testQuery ( year . between ( 1980 , 2000 ) , " year : [1980 ▁ TO ▁ 2000 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Numeric_Double ( ) throws Exception { testQuery ( gross . between ( 10.00 , 19030.00 ) , " gross : [10.0 ▁ TO ▁ 19030.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Numeric ( ) throws Exception { testQuery ( longField . between ( 0L , 2L ) , " longField : [0 ▁ TO ▁ 2 ] " , 1 ) ; testQuery ( shortField . between ( ( short ) 0 , ( short ) 2 ) , " shortField : [0 ▁ TO ▁ 2 ] " , 1 ) ; testQuery ( byteField . between ( ( byte ) 0 , ( byte ) 2 ) , " byteField : [0 ▁ TO ▁ 2 ] " , 1 ) ; testQuery ( floatField . between ( ( float ) 0.0 , ( float ) 2.0 ) , " floatField : [0.0 ▁ TO ▁ 2.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Is_Inclusive_From_Start ( ) throws Exception { testQuery ( title . between ( " Jurassic " , " Kundun " ) , " title : [ jurassic ▁ TO ▁ kundun ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Is_Inclusive_To_End ( ) throws Exception { testQuery ( title . between ( " Indiana " , " Jurassic " ) , " title : [ indiana ▁ TO ▁ jurassic ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Does_Not_Find_Results ( ) throws Exception { testQuery ( title . between ( " Indiana " , " Jurassib " ) , " title : [ indiana ▁ TO ▁ jurassib ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void In ( ) throws Exception { testQuery ( title . in ( Arrays . asList ( " jurassic " , " park " ) ) , " title : jurassic ▁ title : park " , 1 ) ; testQuery ( title . in ( " jurassic " , " park " ) , " title : jurassic ▁ title : park " , 1 ) ; testQuery ( title . eq ( " jurassic " ) . or ( title . eq ( " park " ) ) , " title : jurassic ▁ title : park " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt ( ) throws Exception { testQuery ( rating . lt ( " Superb " ) , " rating : { * ▁ TO ▁ superb } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Integer ( ) throws Exception { testQuery ( year . lt ( 1991 ) , " year : { * ▁ TO ▁ 1991 } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Double ( ) throws Exception { testQuery ( gross . lt ( 10000.0 ) , " gross : { * ▁ TO ▁ 10000.0 } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( rating . lt ( " Good " ) , " rating : { * ▁ TO ▁ good } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Integer_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( year . lt ( 1990 ) , " year : { * ▁ TO ▁ 1990 } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Lt_Numeric_Double_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( gross . lt ( 900.0 ) , " gross : { * ▁ TO ▁ 900.0 } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Loe ( ) throws Exception { testQuery ( rating . loe ( " Superb " ) , " rating : [ * ▁ TO ▁ superb ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Integer ( ) throws Exception { testQuery ( year . loe ( 1991 ) , " year : [ * ▁ TO ▁ 1991 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Double ( ) throws Exception { testQuery ( gross . loe ( 903.0 ) , " gross : [ * ▁ TO ▁ 903.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Equal ( ) throws Exception { testQuery ( rating . loe ( " Good " ) , " rating : [ * ▁ TO ▁ good ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Integer_Equal ( ) throws Exception { testQuery ( year . loe ( 1990 ) , " year : [ * ▁ TO ▁ 1990 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Double_Equal ( ) throws Exception { testQuery ( gross . loe ( 900.0 ) , " gross : [ * ▁ TO ▁ 900.0 ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Not_Found ( ) throws Exception { testQuery ( rating . loe ( " Bad " ) , " rating : [ * ▁ TO ▁ bad ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Integer_Not_Found ( ) throws Exception { testQuery ( year . loe ( 1989 ) , " year : [ * ▁ TO ▁ 1989 ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Loe_Numeric_Double_Not_Found ( ) throws Exception { testQuery ( gross . loe ( 899.9 ) , " gross : [ * ▁ TO ▁ 899.9 ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Gt ( ) throws Exception { testQuery ( rating . gt ( " Bad " ) , " rating : { bad ▁ TO ▁ * } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Integer ( ) throws Exception { testQuery ( year . gt ( 1989 ) , " year : { 1989 ▁ TO ▁ * } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Double ( ) throws Exception { testQuery ( gross . gt ( 100.00 ) , " gross : { 100.0 ▁ TO ▁ * } " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( rating . gt ( " Good " ) , " rating : { good ▁ TO ▁ * } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Integer_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( year . gt ( 1990 ) , " year : { 1990 ▁ TO ▁ * } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Gt_Numeric_Double_Not_In_Range_Because_Equal ( ) throws Exception { testQuery ( gross . gt ( 900.00 ) , " gross : { 900.0 ▁ TO ▁ * } " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Goe ( ) throws Exception { testQuery ( rating . goe ( " Bad " ) , " rating : [ bad ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Integer ( ) throws Exception { testQuery ( year . goe ( 1989 ) , " year : [1989 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Double ( ) throws Exception { testQuery ( gross . goe ( 320.50 ) , " gross : [320.5 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Equal ( ) throws Exception { testQuery ( rating . goe ( " Good " ) , " rating : [ good ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Integer_Equal ( ) throws Exception { testQuery ( year . goe ( 1990 ) , " year : [1990 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Double_Equal ( ) throws Exception { testQuery ( gross . goe ( 900.00 ) , " gross : [900.0 ▁ TO ▁ * ] " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Not_Found ( ) throws Exception { testQuery ( rating . goe ( " Hood " ) , " rating : [ hood ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Integer_Not_Found ( ) throws Exception { testQuery ( year . goe ( 1991 ) , " year : [1991 ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Goe_Numeric_Double_Not_Found ( ) throws Exception { testQuery ( gross . goe ( 900.10 ) , " gross : [900.1 ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Equals_Empty_String ( ) throws Exception { testQuery ( title . eq ( " " ) , " title : " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Not_Equals_Empty_String ( ) throws Exception { testQuery ( title . ne ( " " ) , " - title : ▁ + * : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Contains_Empty_String ( ) throws Exception { testQuery ( title . contains ( " " ) , " title : * * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Like_Empty_String ( ) throws Exception { testQuery ( title . like ( " " ) , " title : " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void Starts_With_Empty_String ( ) throws Exception { testQuery ( title . startsWith ( " " ) , " title : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Ends_With_Empty_String ( ) throws Exception { testQuery ( title . endsWith ( " " ) , " title : * " , 1 ) ; }
Log10Solutions/querydsl | @ Test public void Between_Empty_Strings ( ) throws Exception { testQuery ( title . between ( " " , " " ) , " title : [ ▁ TO ▁ ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test public void BooleanBuilder ( ) throws Exception { testQuery ( new BooleanBuilder ( gross . goe ( 900.10 ) ) , " gross : [900.1 ▁ TO ▁ * ] " , 0 ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Fuzzy ( ) throws Exception { fail ( " Not ▁ yet ▁ implemented ! " ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Proximity ( ) throws Exception { fail ( " Not ▁ yet ▁ implemented ! " ) ; }
Log10Solutions/querydsl | @ Test @ Ignore public void Boost ( ) throws Exception { fail ( " Not ▁ yet ▁ implemented ! " ) ; }
Log10Solutions/querydsl | @ Test public void PathAny ( ) throws Exception { testQuery ( titles . any ( ) . eq ( " Jurassic " ) , " title : jurassic " , 1 ) ; }
Log10Solutions/querydsl | private boolean unsupportedOperation ( Predicate filter ) { if ( filter instanceof Operation < ? > ) { Operator op = ( ( Operation < ? > ) filter ) . getOperator ( ) ; if ( op == Ops . STARTS_WITH_IC || op == Ops . EQ_IGNORE_CASE || op == Ops . STARTS_WITH_IC || op == Ops . ENDS_WITH_IC || op == Ops . STRING_CONTAINS_IC ) { return true ; } } return false ; }
Log10Solutions/querydsl | @ Test public void various ( ) throws Exception { MatchingFiltersFactory filters = new MatchingFiltersFactory ( Module . LUCENE , Target . LUCENE ) ; for ( Predicate filter : filters . string ( title , StringConstant . create ( " jurassic ▁ park " ) ) ) { if ( unsupportedOperation ( filter ) ) { continue ; } testQuery ( filter , 1 ) ; } for ( Predicate filter : filters . string ( author , StringConstant . create ( " michael ▁ crichton " ) ) ) { if ( unsupportedOperation ( filter ) ) { continue ; } testQuery ( filter , 1 ) ; } for ( Predicate filter : filters . string ( title , StringConstant . create ( "1990" ) ) ) { if ( unsupportedOperation ( filter ) ) { continue ; } testQuery ( filter , 0 ) ; } }
BottleRocketStudios/Android-Vault | public ApplicationTest ( ) { super ( Application . class ) ; }
xabikip/CursoAndroid | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; inicializar ( ) ; }
xabikip/CursoAndroid | private void inicializar ( ) { bEmpezar = ( Button ) findViewById ( R . id . empezar ) ; bEmpezar . setOnClickListener ( this ) ; tvTurno = ( TextView ) findViewById ( R . id . turno ) ; resultA = ( TextView ) findViewById ( R . id . resultA ) ; resultB = ( TextView ) findViewById ( R . id . resultB ) ; resultados = ( TextView ) findViewById ( R . id . resultados ) ; b1 = ( Button ) findViewById ( R . id . b1 ) ; b1 . setOnClickListener ( this ) ; b2 = ( Button ) findViewById ( R . id . b2 ) ; b2 . setOnClickListener ( this ) ; b3 = ( Button ) findViewById ( R . id . b3 ) ; b3 . setOnClickListener ( this ) ; b4 = ( Button ) findViewById ( R . id . b4 ) ; b4 . setOnClickListener ( this ) ; b5 = ( Button ) findViewById ( R . id . b5 ) ; b5 . setOnClickListener ( this ) ; b6 = ( Button ) findViewById ( R . id . b6 ) ; b6 . setOnClickListener ( this ) ; b7 = ( Button ) findViewById ( R . id . b7 ) ; b7 . setOnClickListener ( this ) ; b8 = ( Button ) findViewById ( R . id . b8 ) ; b8 . setOnClickListener ( this ) ; b9 = ( Button ) findViewById ( R . id . b9 ) ; b9 . setOnClickListener ( this ) ; }
xabikip/CursoAndroid | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { getMenuInflater ( ) . inflate ( R . menu . main , menu ) ; return true ; }
xabikip/CursoAndroid | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . action_settings ) { return true ; } return super . onOptionsItemSelected ( item ) ; }
xabikip/CursoAndroid | @ Override public void onClick ( View v ) { if ( v . getId ( ) == R . id . empezar && bEmpezar . getText ( ) . toString ( ) . equals ( " Empezar " ) ) { this . a = 0 ; this . b = 0 ; habilitarBotones ( true ) ; bEmpezar . setText ( " Salir " ) ; this . judador = " x " ; tvTurno . setText ( " Turno ▁ del ▁ jugador : ▁ x " ) ; borrarCampos ( ) ; this . cont = 0 ; } else if ( v . getId ( ) == R . id . empezar && bEmpezar . getText ( ) . toString ( ) . equals ( " Salir " ) ) { borrarCampos ( ) ; bEmpezar . setText ( " Empezar " ) ; habilitarBotones ( false ) ; } else if ( v . getId ( ) == R . id . b1 ) { escribirJugada ( this . judador , b1 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b2 ) { escribirJugada ( this . judador , b2 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b3 ) { escribirJugada ( this . judador , b3 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b4 ) { escribirJugada ( this . judador , b4 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b5 ) { escribirJugada ( this . judador , b5 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b6 ) { escribirJugada ( this . judador , b6 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b7 ) { escribirJugada ( this . judador , b7 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b8 ) { escribirJugada ( this . judador , b8 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } else if ( v . getId ( ) == R . id . b9 ) { escribirJugada ( this . judador , b9 ) ; comprobarGanador ( ) ; cambiarJugador ( ) ; } }
xabikip/CursoAndroid | private void comprobarGanador ( ) { if ( b1 . getText ( ) . toString ( ) . equals ( this . judador ) && b2 . getText ( ) . toString ( ) . equals ( this . judador ) && b3 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b4 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b6 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b7 . getText ( ) . toString ( ) . equals ( this . judador ) && b8 . getText ( ) . toString ( ) . equals ( this . judador ) && b9 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b1 . getText ( ) . toString ( ) . equals ( this . judador ) && b4 . getText ( ) . toString ( ) . equals ( this . judador ) && b7 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b2 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b8 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b3 . getText ( ) . toString ( ) . equals ( this . judador ) && b6 . getText ( ) . toString ( ) . equals ( this . judador ) && b9 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b1 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b9 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( b3 . getText ( ) . toString ( ) . equals ( this . judador ) && b5 . getText ( ) . toString ( ) . equals ( this . judador ) && b7 . getText ( ) . toString ( ) . equals ( this . judador ) ) { ganado ( ) ; } else if ( this . cont == 9 ) { Toast toast = Toast . makeText ( this , " Habeis ▁ empatado " , Toast . LENGTH_SHORT ) ; toast . show ( ) ; habilitarBotones ( false ) ; bEmpezar . setText ( " Empezar " ) ; } }
xabikip/CursoAndroid | private void ganado ( ) { java . util . Date today = new java . util . Date ( ) ; this . hoy = today . toString ( ) ; DBHelper dbHelper = new DBHelper ( this , " TRESENRAYADB " , null , 1 ) ; SQLiteDatabase tresDBWrite = dbHelper . getWritableDatabase ( ) ; if ( tresDBWrite . isOpen ( ) ) { tresDBWrite . execSQL ( " INSERT ▁ INTO ▁ resultado ▁ ( FECHA , ▁ GANADOR ) ▁ VALUES ▁ ( ' " + this . hoy + " ' , ' " + this . judador + " ' ) " ) ; tresDBWrite . close ( ) ; } Toast toast = Toast . makeText ( this , " Has ▁ ganado ▁ " + this . judador , Toast . LENGTH_SHORT ) ; toast . show ( ) ; habilitarBotones ( false ) ; bEmpezar . setText ( " Empezar " ) ; String [ ] campos = new String [ ] { " FECHA " , " GANADOR " } ; SQLiteDatabase tresDBRead = dbHelper . getReadableDatabase ( ) ; if ( tresDBRead . isOpen ( ) ) { Cursor c = tresDBRead . query ( " RESULTADO " , campos , null , null , null , null , " _ ID " ) ; if ( c . moveToFirst ( ) ) { do { if ( c . getString ( c . getColumnIndex ( " GANADOR " ) ) . equals ( "0" ) ) { a ++ ; } else if ( c . getString ( c . getColumnIndex ( " GANADOR " ) ) . equals ( " x " ) ) { b ++ ; } } while ( c . moveToNext ( ) ) ; } tresDBRead . close ( ) ; } resultados . setText ( " RESULTADOS : " ) ; resultA . setText ( " Jugador ▁ 0 ▁ ganados = ▁ " + a ) ; resultB . setText ( " Jugador ▁ X ▁ ganados = ▁ " + b ) ; }
xabikip/CursoAndroid | private void cambiarJugador ( ) { if ( this . judador . toString ( ) . equals ( " x " ) ) { this . judador = "0" ; tvTurno . setText ( " Turno ▁ del ▁ jugador : ▁ 0" ) ; } else { this . judador = " x " ; tvTurno . setText ( " Turno ▁ del ▁ jugador : ▁ x " ) ; } }
xabikip/CursoAndroid | private void escribirJugada ( String jugador , Button boton ) { boton . setText ( jugador ) ; boton . setEnabled ( false ) ; this . cont ++ ; }
xabikip/CursoAndroid | private void borrarCampos ( ) { b1 . setText ( " " ) ; b2 . setText ( " " ) ; b3 . setText ( " " ) ; b4 . setText ( " " ) ; b5 . setText ( " " ) ; b6 . setText ( " " ) ; b7 . setText ( " " ) ; b8 . setText ( " " ) ; b9 . setText ( " " ) ; }
xabikip/CursoAndroid | void habilitarBotones ( boolean estado ) { b1 . setEnabled ( estado ) ; b2 . setEnabled ( estado ) ; b3 . setEnabled ( estado ) ; b4 . setEnabled ( estado ) ; b5 . setEnabled ( estado ) ; b6 . setEnabled ( estado ) ; b7 . setEnabled ( estado ) ; b8 . setEnabled ( estado ) ; b9 . setEnabled ( estado ) ; }
valegrajales/recommendation_systems_lab1 | @ Override public float predictRating ( int user , int item ) { return Float . NaN ; }
valegrajales/recommendation_systems_lab1 | public float predictRatingBPR ( int user , int item ) { int itemidx = data . itemIndices . get ( item ) ; Integer useridx = data . userIndices . get ( user ) ; if ( useridx != null ) { return ( float ) ( data . item_bias [ itemidx ] + data . rowScalarProduct ( useridx , itemidx ) ) ; } else { return Float . NaN ; } }
valegrajales/recommendation_systems_lab1 | public List < Integer > recommendByPrediction ( int user ) { List < Integer > result = new ArrayList < Integer > ( ) ; Set < Rating > ratings = getDataModel ( ) . getRatingsOfUser ( user ) ; if ( ratings == null || ratings . size ( ) == 0 ) { return Collections . emptyList ( ) ; } Map < Integer , Float > predictions = new HashMap < Integer , Float > ( ) ; float pred = Float . NaN ; for ( Integer item : dataModel . getItems ( ) ) { boolean userHasAlreadyRatedItem = false ; if ( getDataModel ( ) . originalTrainingPerUser . keySet ( ) . size ( ) > 0 ) { Set < Rating > originalRatings = getDataModel ( ) . originalTrainingPerUser . get ( user ) ; if ( originalRatings != null && Utilities101 . ratingExists ( user , item , originalRatings ) ) { userHasAlreadyRatedItem = true ; } } else { byte rating = dataModel . getRating ( user , item ) ; if ( rating != - 1 ) { userHasAlreadyRatedItem = true ; } } if ( ! userHasAlreadyRatedItem ) { pred = predictRatingBPR ( user , item ) ; if ( ! Float . isNaN ( pred ) ) { predictions . put ( item , pred ) ; } } } predictions = filterElementsByRelevanceThreshold ( predictions , user ) ; predictions = Utilities101 . sortByValueDescending ( predictions ) ; for ( Integer item : predictions . keySet ( ) ) { result . add ( item ) ; } return result ; }
valegrajales/recommendation_systems_lab1 | @ Override public List < Integer > recommendItems ( int user ) { return recommendByPrediction ( user ) ; }
valegrajales/recommendation_systems_lab1 | @ Override public void init ( ) { numItems = dataModel . getItems ( ) . size ( ) ; numUsers = dataModel . getUsers ( ) . size ( ) ; data . init ( dataModel , numUsers , numItems , numFeatures ) ; train ( ) ; System . out . println ( " BPR + + ▁ training ▁ DONE " ) ; Debug . log ( " BPRMF : init : ▁ Initial ▁ training ▁ done " ) ; }
valegrajales/recommendation_systems_lab1 | public void train ( ) { for ( int i = 0 ; i < initialSteps ; i ++ ) { if ( i % 10 == 0 ) System . out . println ( " Processed ▁ " + i + " ▁ of ▁ " + initialSteps + " ▁ BPR + + ▁ training ▁ steps . " ) ; iterate ( ) ; } }
valegrajales/recommendation_systems_lab1 | public void iterate ( ) { int num_pos_events = data . numPosentries ; int user_id , pos_item_id , neg_item_id , initial_item_id , xscale ; if ( UniformUserSampling ) { if ( SequentialLearning ) { if ( useIIMaps ) { for ( int f = 0 ; f < data . featureMatrixArray . length ; f ++ ) { SparseMatrix matrix = data . featureMatrixArray [ f ] ; for ( int entries = 0 ; entries < matrix . getNumberOfEntries ( ) ; entries ++ ) { auxiliaryStep ( matrix ) ; } } } if ( zalandoMode ) { SparseIntMatrix [ ] mcArray = initMCArray ( ) ; for ( int f = 0 ; f < mcArray . length ; f ++ ) { SparseIntMatrix matrix = mcArray [ f ] ; for ( int entries = 0 ; entries < matrix . getNumberOfEntries ( ) ; entries ++ ) { auxiliaryStep ( matrix ) ; } } } } for ( int i = 0 ; i < num_pos_events ; i ++ ) { if ( ! SequentialLearning ) { if ( useIIMaps ) { for ( int f = 0 ; f < data . featureMatrixArray . length ; f ++ ) { SparseMatrix matrix = data . featureMatrixArray [ f ] ; auxiliaryStep ( matrix ) ; } } if ( zalandoMode ) { SparseIntMatrix [ ] mcArray = initMCArray ( ) ; for ( int f = 0 ; f < mcArray . length ; f ++ ) { SparseIntMatrix matrix = mcArray [ f ] ; auxiliaryStep ( matrix ) ; } } } int [ ] triple = new int [ 4 ] ; xscale = 1 ; if ( tripleCriterion . equals ( " number " ) ) { triple [ 0 ] = sampleU ( data . numberMatrixP ) ; triple = sampleIJ ( triple , data . numberMatrixP , false ) ; } else if ( tripleCriterion . equals ( " time " ) ) { triple [ 0 ] = sampleU ( data . timeMatrixP ) ; triple = sampleIJ ( triple , data . timeMatrixP , false ) ; } else if ( tripleCriterion . equals ( " rating " ) ) { triple [ 0 ] = sampleU ( ) ; triple = sampleIJrating ( triple ) ; } else { triple [ 0 ] = sampleU ( ) ; triple = sampleIJ ( triple ) ; } user_id = triple [ 0 ] ; pos_item_id = triple [ 1 ] ; neg_item_id = triple [ 2 ] ; if ( useXscale ) xscale = triple [ 3 ] ; updateFactors ( user_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , learnRate , false ) ; } } else { if ( useIIMaps ) { for ( int f = 0 ; f < data . featureMatrixArray . length ; f ++ ) { for ( int k = 0 ; k < data . boolMatrix_numItems ; k ++ ) { for ( int l = 0 ; l < data . boolMatrix_numItems ; l ++ ) { initial_item_id = k ; pos_item_id = l ; neg_item_id = - 1 ; xscale = 1 ; if ( data . featureMatrixArray [ f ] . getBool ( initial_item_id , pos_item_id ) ) { int [ ] sampleTriple = null ; sampleTriple = sampleJ ( initial_item_id , pos_item_id , neg_item_id , data . featureMatrixArray [ f ] ) ; initial_item_id = sampleTriple [ 0 ] ; pos_item_id = sampleTriple [ 1 ] ; neg_item_id = sampleTriple [ 2 ] ; if ( useXscale ) xscale = sampleTriple [ 3 ] ; updateFactors ( initial_item_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , learnRate , true ) ; } } } } } for ( int k = 0 ; k < data . boolMatrix_numUsers ; k ++ ) { for ( int l = 0 ; l < data . boolMatrix_numItems ; l ++ ) { user_id = k ; pos_item_id = l ; neg_item_id = - 1 ; xscale = 1 ; if ( data . boolMatrix . getBool ( user_id , pos_item_id ) ) { int [ ] sampleTriple = null ; if ( tripleCriterion . equals ( " number " ) ) { sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , data . numberMatrixP , false ) ; } else if ( tripleCriterion . equals ( " time " ) ) { sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , data . timeMatrixP , false ) ; } else if ( tripleCriterion . equals ( " rating " ) ) { float useravg = data . dm . getUserAverageRating ( data . userMap . get ( user_id ) ) ; int rating = data . dm . getRating ( data . userMap . get ( user_id ) , data . itemMap . get ( pos_item_id ) ) ; if ( rating < useravg ) continue ; else sampleTriple = sampleJrating ( user_id , pos_item_id , neg_item_id ) ; } else { sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id ) ; } user_id = sampleTriple [ 0 ] ; pos_item_id = sampleTriple [ 1 ] ; neg_item_id = sampleTriple [ 2 ] ; if ( useXscale ) xscale = sampleTriple [ 3 ] ; updateFactors ( user_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , learnRate , false ) ; } if ( zalandoMode ) { SparseIntMatrix [ ] mcArray = initMCArray ( ) ; for ( int f = 0 ; f < mcArray . length ; f ++ ) { SparseIntMatrix matrix = mcArray [ f ] ; user_id = k ; pos_item_id = l ; neg_item_id = - 1 ; xscale = 1 ; if ( matrix . get ( user_id , pos_item_id ) > 0 ) { int [ ] sampleTriple = null ; if ( tripleCriterion . equals ( " unseen " ) ) sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , matrix , true ) ; else sampleTriple = sampleJ ( user_id , pos_item_id , neg_item_id , matrix , false ) ; user_id = sampleTriple [ 0 ] ; pos_item_id = sampleTriple [ 1 ] ; neg_item_id = sampleTriple [ 2 ] ; if ( useXscale ) xscale = sampleTriple [ 3 ] ; updateFactors ( user_id , pos_item_id , neg_item_id , true , true , updateJ , xscale , 0.05 , false ) ; } } } } } } }
valegrajales/recommendation_systems_lab1 | private SparseIntMatrix [ ] initMCArray ( ) { SparseIntMatrix [ ] mcArray = new SparseIntMatrix [ 6 ] ; if ( tripleCriterion . equals ( " unseen " ) ) { mcArray [ 0 ] = data . numberMatrixV ; mcArray [ 1 ] = data . numberMatrixC ; mcArray [ 2 ] = data . numberMatrixW ; mcArray [ 3 ] = data . numberMatrixVR ; mcArray [ 4 ] = data . numberMatrixDC ; mcArray [ 5 ] = data . numberMatrixDW ; } if ( tripleCriterion . equals ( " number " ) ) { mcArray [ 0 ] = data . numberMatrixV ; mcArray [ 1 ] = data . numberMatrixC ; mcArray [ 2 ] = data . numberMatrixW ; mcArray [ 3 ] = data . numberMatrixVR ; mcArray [ 4 ] = data . numberMatrixDC ; mcArray [ 5 ] = data . numberMatrixDW ; } if ( tripleCriterion . equals ( " time " ) ) { mcArray [ 0 ] = data . timeMatrixV ; mcArray [ 1 ] = data . timeMatrixC ; mcArray [ 2 ] = data . timeMatrixW ; mcArray [ 3 ] = data . timeMatrixVR ; mcArray [ 4 ] = data . timeMatrixDC ; mcArray [ 5 ] = data . timeMatrixDW ; } return mcArray ; }
valegrajales/recommendation_systems_lab1 | private void auxiliaryStep ( SparseMatrix matrix ) { int [ ] triple = new int [ 4 ] ; triple [ 0 ] = sampleK ( matrix ) ; triple = sampleIJ ( triple , matrix ) ; updateFactors ( triple [ 0 ] , triple [ 1 ] , triple [ 2 ] , true , true , updateJ , triple [ 3 ] , learnRate , true ) ; }
valegrajales/recommendation_systems_lab1 | private void auxiliaryStep ( SparseIntMatrix matrix ) { int [ ] triple = new int [ 4 ] ; triple [ 0 ] = sampleU ( matrix ) ; if ( tripleCriterion . equals ( " unseen " ) ) { triple = sampleIJ ( triple , matrix , true ) ; } else { triple = sampleIJ ( triple , matrix , false ) ; } int xscale = 1 ; if ( useXscale ) xscale = triple [ 3 ] ; updateFactors ( triple [ 0 ] , triple [ 1 ] , triple [ 2 ] , true , true , updateJ , xscale , learnRate , false ) ; }
valegrajales/recommendation_systems_lab1 | public void updateFactors ( int u , int i , int j , boolean update_u , boolean update_i , boolean update_j , int xscale , double newLearnrate , boolean item2item ) { double x_uij ; if ( ! item2item ) { x_uij = data . item_bias [ i ] - data . item_bias [ j ] + data . rowScalarProductWithRowDifference ( u , i , j ) ; } else { x_uij = data . item_bias [ i ] - data . item_bias [ j ] + data . rowScalarProductWithRowDifferenceItem ( u , i , j ) ; } x_uij *= xscale ; double one_over_one_plus_ex = 1 / ( 1 + Math . exp ( x_uij ) ) ; if ( update_i ) { double update = one_over_one_plus_ex - biasReg * data . item_bias [ i ] ; data . item_bias [ i ] += ( newLearnrate * update ) ; } if ( update_j ) { double update = - one_over_one_plus_ex - biasReg * data . item_bias [ j ] ; data . item_bias [ j ] += ( newLearnrate * update ) ; } for ( int f = 0 ; f < numFeatures ; f ++ ) { double w_uf ; if ( ! item2item ) { w_uf = data . latentUserVector [ u ] [ f ] ; } else { w_uf = data . latentItemVector [ u ] [ f ] ; } double h_if = data . latentItemVector [ i ] [ f ] ; double h_jf = data . latentItemVector [ j ] [ f ] ; if ( update_u ) { double update = ( h_if - h_jf ) * one_over_one_plus_ex - regU * w_uf ; if ( ! item2item ) { data . latentUserVector [ u ] [ f ] = ( w_uf + newLearnrate * update ) ; } else { data . latentItemVector [ u ] [ f ] = ( w_uf + newLearnrate * update ) ; } } if ( update_i ) { double update = w_uf * one_over_one_plus_ex - regI * h_if ; data . latentItemVector [ i ] [ f ] = ( float ) ( h_if + newLearnrate * update ) ; } if ( update_j ) { double update = - w_uf * one_over_one_plus_ex - regJ * h_jf ; data . latentItemVector [ j ] [ f ] = ( float ) ( h_jf + newLearnrate * update ) ; } } }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJ ( int u , int i , int j ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = u ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; boolean item_is_positive = data . boolMatrix . getBool ( u , i ) ; if ( item_is_positive == false ) System . err . println ( " This ▁ error ▁ should ▁ never ▁ happen ! " ) ; do sampleTriple [ 2 ] = random . nextInt ( numItems ) ; while ( data . boolMatrix . getBool ( u , sampleTriple [ 2 ] ) == item_is_positive ) ; sampleTriple [ 3 ] = 1 ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJrating ( int u , int i , int j ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = u ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; sampleTriple [ 3 ] = 1 ; int positive_rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( i ) ) ; List < Integer > user_items = data . userMatrix . get ( u ) ; float useravg = data . dm . getUserAverageRating ( data . userMap . get ( u ) ) ; boolean breaker ; do { sampleTriple [ 2 ] = random . nextInt ( numItems ) ; if ( user_items . contains ( sampleTriple [ 2 ] ) ) { int rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( sampleTriple [ 2 ] ) ) ; if ( rating < useravg ) { breaker = false ; sampleTriple [ 3 ] = Math . max ( 1 , positive_rating - rating ) ; } else breaker = true ; } else breaker = false ; } while ( breaker ) ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJ ( int u , int i , int j , SparseIntMatrix matrix , boolean justUnseen ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = u ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; int value_ui = matrix . get ( u , i ) ; do { sampleTriple [ 2 ] = random . nextInt ( numItems ) ; } while ( ( justUnseen ? 1 : value_ui ) <= matrix . get ( u , sampleTriple [ 2 ] ) ) ; sampleTriple [ 3 ] = justUnseen ? 1 : ( value_ui - matrix . get ( u , sampleTriple [ 2 ] ) ) ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleJ ( int k , int i , int j , SparseMatrix matrix ) { int [ ] sampleTriple = new int [ 4 ] ; sampleTriple [ 0 ] = k ; sampleTriple [ 1 ] = i ; sampleTriple [ 2 ] = j ; boolean breaker = false ; int xscale = 1 ; do { sampleTriple [ 2 ] = random . nextInt ( numItems ) ; if ( matrix . get ( k , sampleTriple [ 2 ] ) instanceof Byte ) { byte jValue = ( byte ) matrix . get ( k , sampleTriple [ 2 ] ) ; byte iValue = ( byte ) matrix . get ( k , sampleTriple [ 1 ] ) ; if ( iValue > jValue ) breaker = true ; } else if ( matrix . get ( k , sampleTriple [ 2 ] ) instanceof Integer ) { int jValue = ( int ) matrix . get ( k , sampleTriple [ 2 ] ) ; int iValue = ( int ) matrix . get ( k , sampleTriple [ 1 ] ) ; if ( iValue > jValue ) breaker = true ; xscale = iValue - jValue ; } else { System . err . println ( " WRONG ▁ TYPE ! ▁ 1" ) ; return null ; } } while ( ! breaker ) ; sampleTriple [ 3 ] = xscale ; return sampleTriple ; }
valegrajales/recommendation_systems_lab1 | public int sampleU ( ) { while ( true ) { int u = random . nextInt ( numUsers ) ; if ( ! data . userMatrix . containsKey ( u ) ) continue ; List < Integer > viewedItemsList = data . userMatrix . get ( u ) ; if ( viewedItemsList == null || viewedItemsList . size ( ) == 0 || viewedItemsList . size ( ) == numItems ) continue ; return u ; } }
valegrajales/recommendation_systems_lab1 | public int sampleU ( SparseIntMatrix matrix ) { while ( true ) { int i = random . nextInt ( matrix . getM ( ) ) ; if ( matrix . getRow ( i ) == null ) continue ; TIntIntMap ithRow = matrix . getRow ( i ) ; boolean oneIsNotZero = false ; boolean oneIsDifferent = false ; int temp = ithRow . get ( 0 ) ; for ( int j = 0 ; j < matrix . getN ( ) ; j ++ ) { int ij = ithRow . get ( j ) ; if ( ij != 0 ) { oneIsNotZero = true ; } if ( ij != temp ) { oneIsDifferent = true ; } temp = ij ; } if ( oneIsDifferent && oneIsNotZero ) return i ; continue ; } }
valegrajales/recommendation_systems_lab1 | public int sampleK ( SparseMatrix matrix ) { while ( true ) { int i = random . nextInt ( matrix . getM ( ) ) ; if ( matrix . getRow ( i ) == null ) continue ; Object ithRow = matrix . getRow ( i ) ; boolean breaker ; boolean oneIsNotZero = false ; boolean oneIsDifferent = false ; if ( ithRow instanceof TIntByteMap || ithRow instanceof TIntByteHashMap ) { TIntByteMap ithRowByte = ( TIntByteMap ) ithRow ; byte temp = ithRowByte . get ( 0 ) ; for ( int j = 0 ; j < matrix . getN ( ) ; j ++ ) { byte ij = ithRowByte . get ( j ) ; if ( ij != 0 ) { oneIsNotZero = true ; } if ( ij != temp ) { oneIsDifferent = true ; } temp = ij ; } } else if ( ithRow instanceof TIntIntMap || ithRow instanceof TIntIntHashMap ) { TIntIntMap ithRowInt = ( TIntIntMap ) ithRow ; int temp = ithRowInt . get ( 0 ) ; for ( int j = 0 ; j < matrix . getN ( ) ; j ++ ) { int ij = ithRowInt . get ( j ) ; if ( ij != 0 ) { oneIsNotZero = true ; } if ( ij != temp ) { oneIsDifferent = true ; } temp = ij ; } } else { System . err . println ( ithRow . getClass ( ) ) ; System . err . println ( " WRONG ▁ TYPE ! ▁ 2" ) ; return - 1 ; } if ( oneIsDifferent && oneIsNotZero ) return i ; continue ; } }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJ ( int [ ] triple ) { int u = triple [ 0 ] ; List < Integer > user_items = data . userMatrix . get ( u ) ; triple [ 1 ] = user_items . get ( ( random . nextInt ( user_items . size ( ) ) ) ) ; do triple [ 2 ] = random . nextInt ( numItems ) ; while ( user_items . contains ( triple [ 2 ] ) ) ; return triple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJrating ( int [ ] triple ) { int u = triple [ 0 ] ; int neg_rating ; float useravg = data . dm . getUserAverageRating ( data . userMap . get ( u ) ) ; int pos_rating ; triple [ 3 ] = 1 ; List < Integer > user_items = data . userMatrix . get ( u ) ; do { triple [ 1 ] = user_items . get ( ( random . nextInt ( user_items . size ( ) ) ) ) ; pos_rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( triple [ 1 ] ) ) ; if ( debug . contains ( " $ anyrated $ " ) ) { break ; } } while ( pos_rating < useravg ) ; boolean breaker ; int debugcount = 0 ; boolean debugswitch = false ; do { if ( debug . contains ( " $ force50percent $ " ) ) { debugswitch = random . nextBoolean ( ) ; } if ( debug . contains ( " $ force25percent $ " ) ) { if ( random . nextInt ( 4 ) == 0 ) debugswitch = true ; else debugswitch = false ; } if ( debug . contains ( " $ force75percent $ " ) ) { if ( random . nextInt ( 4 ) == 0 ) debugswitch = false ; else debugswitch = true ; } if ( ( debug . contains ( " $ forcerated $ " ) && debugcount < 5 ) || debugswitch ) { triple [ 2 ] = user_items . get ( ( random . nextInt ( user_items . size ( ) ) ) ) ; debugcount ++ ; } else { triple [ 2 ] = random . nextInt ( numItems ) ; } if ( user_items . contains ( triple [ 2 ] ) ) { neg_rating = data . dm . getRating ( data . userMap . get ( u ) , data . itemMap . get ( triple [ 2 ] ) ) ; if ( debug . contains ( " $ anyrated $ " ) || debug . contains ( " $ smallerthani $ " ) ) { if ( neg_rating < pos_rating ) { breaker = false ; triple [ 3 ] = Math . max ( 1 , pos_rating - neg_rating ) ; } else breaker = true ; } else { if ( neg_rating < useravg ) { breaker = false ; triple [ 3 ] = Math . max ( 1 , pos_rating - neg_rating ) ; } else breaker = true ; } } else breaker = false ; } while ( breaker ) ; return triple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJ ( int [ ] triple , SparseIntMatrix matrix , boolean justUnseen ) { int i = triple [ 0 ] ; int j1 ; int j2 ; TIntIntMap ithRow = matrix . getRow ( i ) ; do { j1 = random . nextInt ( matrix . getN ( ) ) ; } while ( ithRow . get ( j1 ) == 0 ) ; do { j2 = random . nextInt ( matrix . getN ( ) ) ; } while ( ( justUnseen ? 1 : ithRow . get ( j1 ) ) <= ithRow . get ( j2 ) ) ; triple [ 1 ] = j1 ; triple [ 2 ] = j2 ; if ( useXscale ) triple [ 3 ] = justUnseen ? 1 : ( ithRow . get ( j1 ) - ithRow . get ( j2 ) ) ; return triple ; }
valegrajales/recommendation_systems_lab1 | public int [ ] sampleIJ ( int [ ] triple , SparseMatrix matrix ) { int i = triple [ 0 ] ; int j1 ; int j2 ; int xscale = 1 ; Object ithRow = matrix . getRow ( i ) ; boolean breaker ; do { j1 = random . nextInt ( matrix . getN ( ) ) ; if ( ithRow instanceof TIntByteMap ) { breaker = ( ( ( TIntByteMap ) ithRow ) . get ( j1 ) == 0 ) ; } else if ( ithRow instanceof TIntIntMap ) { breaker = ( ( ( TIntIntMap ) ithRow ) . get ( j1 ) == 0 ) ; } else { System . err . println ( " WRONG ▁ TYPE ! ▁ 3" ) ; return null ; } } while ( breaker ) ; do { j2 = random . nextInt ( matrix . getN ( ) ) ; if ( ithRow instanceof TIntByteMap ) { breaker = ( ( ( TIntByteMap ) ithRow ) . get ( j2 ) != 0 ) ; } else if ( ithRow instanceof TIntIntMap ) { breaker = ( ( ( TIntIntMap ) ithRow ) . get ( j2 ) >= ( ( TIntIntMap ) ithRow ) . get ( j1 ) ) ; xscale = ( ( TIntIntMap ) ithRow ) . get ( j1 ) - ( ( TIntIntMap ) ithRow ) . get ( j2 ) ; } else { System . err . println ( " WRONG ▁ TYPE ! ▁ 4" ) ; return null ; } } while ( breaker ) ; triple [ 1 ] = j1 ; triple [ 2 ] = j2 ; triple [ 3 ] = xscale ; return triple ; }
valegrajales/recommendation_systems_lab1 | public void setNumFeatures ( String n ) { this . numFeatures = Integer . parseInt ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setRegI ( String n ) { this . regI = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setRegJ ( String n ) { this . regJ = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setRegU ( String n ) { this . regU = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setUpdateJ ( String n ) { this . updateJ = Boolean . parseBoolean ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setBiasReg ( String n ) { this . biasReg = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setLearnRate ( String n ) { this . learnRate = Double . parseDouble ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setInitialSteps ( String n ) { this . initialSteps = Integer . parseInt ( n ) ; }
valegrajales/recommendation_systems_lab1 | public void setUniformSampling ( String n ) { this . UniformUserSampling = Boolean . parseBoolean ( n ) ; }
valegrajales/recommendation_systems_lab1 | @ Override public int getDurationEstimate ( ) { return 3 ; }
valegrajales/recommendation_systems_lab1 | public void setUseRelevanceThreshold ( String u ) throws Exception { data . useRatingThreshold = Boolean . parseBoolean ( u ) ; }
valegrajales/recommendation_systems_lab1 | public void setTripleCriterion ( String u ) { this . tripleCriterion = u ; }
valegrajales/recommendation_systems_lab1 | public void setUseUIMaps ( String b ) { useUIMaps = Boolean . parseBoolean ( b ) ; data . useUIMaps = useUIMaps ; }
valegrajales/recommendation_systems_lab1 | public void setSelectIIMaps ( String b ) { if ( b != null && ! b . equals ( " " ) ) useIIMaps = true ; data . selectIIMaps = b ; data . useIIMaps = useIIMaps ; }
valegrajales/recommendation_systems_lab1 | public void setUseXscale ( String b ) { useXscale = Boolean . parseBoolean ( b ) ; }
valegrajales/recommendation_systems_lab1 | public void setSequentialLearning ( String b ) { SequentialLearning = Boolean . parseBoolean ( b ) ; }
valegrajales/recommendation_systems_lab1 | public void setZalandoMode ( String b ) { zalandoMode = Boolean . parseBoolean ( b ) ; data . zalandoMode = zalandoMode ; }
valegrajales/recommendation_systems_lab1 | public void setDebug ( String b ) { debug = b ; }
codeck/XChange | public KrakenUserTrade ( OrderType type , BigDecimal tradableAmount , CurrencyPair currencyPair , BigDecimal price , Date timestamp , String id , String orderId , BigDecimal feeAmount , String feeCurrency , BigDecimal cost ) { super ( type , tradableAmount , currencyPair , price , timestamp , id , orderId , feeAmount , feeCurrency ) ; this . cost = cost ; }
codeck/XChange | public BigDecimal getCost ( ) { return cost ; }
codeck/XChange | public Builder cost ( BigDecimal cost ) { this . cost = cost ; return this ; }
codeck/XChange | public KrakenUserTrade build ( ) { KrakenUserTrade trade = new KrakenUserTrade ( type , tradableAmount , currencyPair , price , timestamp , id , orderId , feeAmount , feeCurrency , cost ) ; return trade ; }
Hilco-Wijbenga/blueprint | @ Before public void setUp ( ) { value = " ▁ ▁ ▁ ▁ Hello ▁ ▁ ▁ \n ▁ ▁ World \n ▁ ▁ ▁ ▁ " ; comments = new Comments ( value ) ; commentsWithDifferentValue = new Comments ( " Hello \n World " ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_value_cannot_be_NULL ( ) { try { new Comments ( null ) ; fail ( " Expected ▁ a ▁ NullPointerException . " ) ; } catch ( final NullPointerException e ) { assertEquals ( " Missing ▁ ' value ' . " , e . getMessage ( ) ) ; } }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_with_an_empty_value_is_empty ( ) { final Comments emptyComments = new Comments ( " ▁ ▁ ▁ \t ▁ ▁ ▁ \n \r " ) ; assertEquals ( " " , emptyComments . value ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_lines_retain_their_indentation ( ) { final Iterator < String > lineIt = comments . iterator ( ) ; assertEquals ( " ▁ ▁ Hello " , lineIt . next ( ) ) ; assertEquals ( " World " , lineIt . next ( ) ) ; assertFalse ( lineIt . hasNext ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_hash_code_is_based_on_its_fields ( ) { assertEquals ( comments . hashCode ( ) , comments . hashCode ( ) ) ; assertEquals ( comments . hashCode ( ) , new Comments ( value ) . hashCode ( ) ) ; assertNotEquals ( comments . hashCode ( ) , new Comments ( " Hello \n world " ) . hashCode ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_MISSING_is_essentially_an_empty_instance ( ) { assertEquals ( " " , Comments . MISSING . value ( ) ) ; assertFalse ( Comments . MISSING . iterator ( ) . hasNext ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_order_is_based_on_its_value ( ) { final Comments commentsAbc = new Comments ( " abc " ) ; final Comments commentsXyz = new Comments ( " xyz " ) ; assertTrue ( commentsAbc . compareTo ( commentsXyz ) < 0 ) ; assertEquals ( 0 , commentsAbc . compareTo ( commentsAbc ) ) ; assertTrue ( commentsXyz . compareTo ( commentsAbc ) > 0 ) ; assertEquals ( 0 , commentsXyz . compareTo ( commentsXyz ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_a_Comments_equality_to_another_is_based_on_its_value ( ) { assertTrue ( comments . equals ( comments ) ) ; assertTrue ( comments . equals ( new Comments ( value ) ) ) ; assertTrue ( new Comments ( value ) . equals ( comments ) ) ; assertFalse ( comments . equals ( null ) ) ; assertFalse ( comments . equals ( new Object ( ) ) ) ; assertFalse ( comments . equals ( commentsWithDifferentValue ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_the_textual_representation_of_an_empty_Comments_is_correct ( ) { assertEquals ( " < comments > < / comments > " , Comments . MISSING . show ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void test_that_the_textual_representation_of_a_Comments_is_correct ( ) { assertEquals ( " < comments > \n ▁ ▁ ▁ ▁ ▁ ▁ Hello \n ▁ ▁ ▁ ▁ World \n < / comments > " , comments . show ( ) ) ; }
Hilco-Wijbenga/blueprint | @ Test public final void executeBridgeMethod ( ) throws Exception { final Method compareTo = Comments . class . getDeclaredMethod ( " compareTo " , Object . class ) ; compareTo . invoke ( comments , comments ) ; }
desruisseaux/sis | protected MetadataAdapter ( ) { }
desruisseaux/sis | @ Override public final BoundType unmarshal ( final ValueType value ) { return value ; }
FHannes/intellij-community | private MavenArtifactDownloader ( @ NotNull Project project , MavenProjectsTree projectsTree , Collection < MavenProject > mavenProjects , Collection < MavenArtifact > artifacts , MavenEmbedderWrapper embedder , MavenProgressIndicator p ) { myProject = project ; myProjectsTree = projectsTree ; myMavenProjects = mavenProjects ; myArtifacts = artifacts == null ? null : new THashSet < > ( artifacts ) ; myEmbedder = embedder ; myProgress = p ; }
FHannes/intellij-community | private DownloadResult download ( boolean downloadSources , boolean downloadDocs ) throws MavenProcessCanceledException { List < File > downloadedFiles = new ArrayList < > ( ) ; try { List < MavenExtraArtifactType > types = new ArrayList < > ( 2 ) ; if ( downloadSources ) types . add ( MavenExtraArtifactType . SOURCES ) ; if ( downloadDocs ) types . add ( MavenExtraArtifactType . DOCS ) ; String caption = downloadSources && downloadDocs ? ProjectBundle . message ( " maven . downloading " ) : ( downloadSources ? ProjectBundle . message ( " maven . downloading . sources " ) : ProjectBundle . message ( " maven . downloading . docs " ) ) ; myProgress . setText ( caption ) ; Map < MavenId , DownloadData > artifacts = collectArtifactsToDownload ( types ) ; return download ( artifacts , downloadedFiles ) ; } finally { boolean isAsync = ! ApplicationManager . getApplication ( ) . isUnitTestMode ( ) ; Set < File > filesToRefresh = new HashSet < > ( ) ; for ( File file : downloadedFiles ) { filesToRefresh . add ( file ) ; filesToRefresh . add ( file . getParentFile ( ) ) ; } LocalFileSystem . getInstance ( ) . refreshIoFiles ( filesToRefresh , isAsync , false , null ) ; } }
FHannes/intellij-community | private Map < MavenId , DownloadData > collectArtifactsToDownload ( List < MavenExtraArtifactType > types ) { Map < MavenId , DownloadData > result = new THashMap < > ( ) ; THashSet < String > dependencyTypesFromSettings = new THashSet < > ( ) ; AccessToken accessToken = ReadAction . start ( ) ; try { if ( myProject . isDisposed ( ) ) return result ; dependencyTypesFromSettings . addAll ( MavenProjectsManager . getInstance ( myProject ) . getImportingSettings ( ) . getDependencyTypesAsSet ( ) ) ; } finally { accessToken . finish ( ) ; } for ( MavenProject eachProject : myMavenProjects ) { List < MavenRemoteRepository > repositories = eachProject . getRemoteRepositories ( ) ; for ( MavenArtifact eachDependency : eachProject . getDependencies ( ) ) { if ( myArtifacts != null && ! myArtifacts . contains ( eachDependency ) ) continue ; if ( MavenConstants . SCOPE_SYSTEM . equalsIgnoreCase ( eachDependency . getScope ( ) ) ) continue ; if ( myProjectsTree . findProject ( eachDependency . getMavenId ( ) ) != null ) continue ; String dependencyType = eachDependency . getType ( ) ; if ( ! dependencyTypesFromSettings . contains ( dependencyType ) && ! eachProject . getDependencyTypesFromImporters ( SupportedRequestType . FOR_IMPORT ) . contains ( dependencyType ) ) { continue ; } MavenId id = eachDependency . getMavenId ( ) ; DownloadData data = result . get ( id ) ; if ( data == null ) { data = new DownloadData ( ) ; result . put ( id , data ) ; } data . repositories . addAll ( repositories ) ; for ( MavenExtraArtifactType eachType : types ) { Pair < String , String > classifierAndExtension = eachProject . getClassifierAndExtension ( eachDependency , eachType ) ; String classifier = eachDependency . getFullClassifier ( classifierAndExtension . first ) ; String extension = classifierAndExtension . second ; data . classifiersWithExtensions . add ( new DownloadElement ( classifier , extension , eachType ) ) ; } } } return result ; }
FHannes/intellij-community | private DownloadResult download ( final Map < MavenId , DownloadData > toDownload , final List < File > downloadedFiles ) throws MavenProcessCanceledException { List < Future > futures = new ArrayList < > ( ) ; final AtomicInteger downloaded = new AtomicInteger ( ) ; int total = 0 ; for ( DownloadData each : toDownload . values ( ) ) { total += each . classifiersWithExtensions . size ( ) ; } final DownloadResult result = new DownloadResult ( ) ; result . unresolvedSources . addAll ( toDownload . keySet ( ) ) ; result . unresolvedDocs . addAll ( toDownload . keySet ( ) ) ; try { for ( final Map . Entry < MavenId , DownloadData > eachEntry : toDownload . entrySet ( ) ) { myProgress . checkCanceled ( ) ; final DownloadData data = eachEntry . getValue ( ) ; final MavenId id = eachEntry . getKey ( ) ; for ( final DownloadElement eachElement : data . classifiersWithExtensions ) { final int finalTotal = total ; futures . add ( EXECUTOR . submit ( ( ) -> { try { if ( myProject . isDisposed ( ) ) return ; myProgress . checkCanceled ( ) ; myProgress . setFraction ( ( ( double ) downloaded . getAndIncrement ( ) ) / finalTotal ) ; MavenArtifact a = myEmbedder . resolve ( new MavenArtifactInfo ( id , eachElement . extension , eachElement . classifier ) , new ArrayList < > ( data . repositories ) ) ; File file = a . getFile ( ) ; if ( file . exists ( ) ) { synchronized ( downloadedFiles ) { downloadedFiles . add ( file ) ; switch ( eachElement . type ) { case SOURCES : result . resolvedSources . add ( id ) ; result . unresolvedSources . remove ( id ) ; break ; case DOCS : result . resolvedDocs . add ( id ) ; result . unresolvedDocs . remove ( id ) ; break ; } } } } catch ( MavenProcessCanceledException ignore ) { } } ) ) ; } } } finally { for ( Future each : futures ) { try { each . get ( ) ; } catch ( Exception e ) { MavenLog . LOG . error ( e ) ; } } } return result ; }
FHannes/intellij-community | public DownloadElement ( String classifier , String extension , MavenExtraArtifactType type ) { this . classifier = classifier ; this . extension = extension ; this . type = type ; }
FHannes/intellij-community | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; DownloadElement that = ( DownloadElement ) o ; if ( classifier != null ? ! classifier . equals ( that . classifier ) : that . classifier != null ) return false ; if ( extension != null ? ! extension . equals ( that . extension ) : that . extension != null ) return false ; if ( type != that . type ) return false ; return true ; }
FHannes/intellij-community | @ Override public int hashCode ( ) { int result = classifier != null ? classifier . hashCode ( ) : 0 ; result = 31 * result + ( extension != null ? extension . hashCode ( ) : 0 ) ; result = 31 * result + ( type != null ? type . hashCode ( ) : 0 ) ; return result ; }
fengshao0907/incubator-geode | public LocalDataSetIndexingDUnitTest ( String name ) { super ( name ) ; }
fengshao0907/incubator-geode | @ Override public void setUp ( ) throws Exception { super . setUp ( ) ; Host host = Host . getHost ( 0 ) ; dataStore1 = host . getVM ( 0 ) ; dataStore2 = host . getVM ( 1 ) ; }
fengshao0907/incubator-geode | public void testLocalDataSetIndexing ( ) { final CacheSerializableRunnable createPRs = new CacheSerializableRunnable ( " create ▁ prs ▁ " ) { public void run2 ( ) { AttributesFactory < Integer , RegionValue > factory = new AttributesFactory < Integer , RegionValue > ( ) ; factory . setPartitionAttributes ( new PartitionAttributesFactory < Integer , RegionValue > ( ) . setRedundantCopies ( 1 ) . setTotalNumBuckets ( 8 ) . create ( ) ) ; final PartitionedRegion pr1 = ( PartitionedRegion ) createRootRegion ( " pr1" , factory . create ( ) ) ; factory = new AttributesFactory < Integer , RegionValue > ( ) ; factory . setPartitionAttributes ( new PartitionAttributesFactory < Integer , RegionValue > ( ) . setRedundantCopies ( 1 ) . setTotalNumBuckets ( 8 ) . setColocatedWith ( pr1 . getName ( ) ) . create ( ) ) ; final PartitionedRegion pr2 = ( PartitionedRegion ) createRootRegion ( " pr2" , factory . create ( ) ) ; } } ; final CacheSerializableRunnable createIndexesOnPRs = new CacheSerializableRunnable ( " create ▁ prs ▁ " ) { public void run2 ( ) { try { QueryService qs = getCache ( ) . getQueryService ( ) ; qs . createIndex ( " valueIndex1" , IndexType . FUNCTIONAL , " e1 . value " , " / pr1 ▁ e1" ) ; qs . createIndex ( " valueIndex2" , IndexType . FUNCTIONAL , " e2 . value " , " / pr2 ▁ e2" ) ; } catch ( Exception e ) { fail ( " Test ▁ failed ▁ due ▁ to ▁ Exception ▁ in ▁ index ▁ creation ▁ " , e ) ; } } } ; final CacheSerializableRunnable execute = new CacheSerializableRunnable ( " execute ▁ function " ) { public void run2 ( ) { final PartitionedRegion pr1 = ( PartitionedRegion ) getRootRegion ( " pr1" ) ; final PartitionedRegion pr2 = ( PartitionedRegion ) getRootRegion ( " pr2" ) ; final Set < Integer > filter = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= 80 ; i ++ ) { pr1 . put ( i , new RegionValue ( i ) ) ; if ( i <= 20 ) { pr2 . put ( i , new RegionValue ( i ) ) ; if ( ( i % 5 ) == 0 ) { filter . add ( i ) ; } } } ArrayList < List > result = ( ArrayList < List > ) FunctionService . onRegion ( pr1 ) . withFilter ( filter ) . execute ( new FunctionAdapter ( ) { public void execute ( FunctionContext context ) { try { RegionFunctionContext rContext = ( RegionFunctionContext ) context ; Region pr1 = rContext . getDataSet ( ) ; LocalDataSet localCust = ( LocalDataSet ) PartitionRegionHelper . getLocalDataForContext ( rContext ) ; Map < String , Region < ? , ? > > colocatedRegions = PartitionRegionHelper . getColocatedRegions ( pr1 ) ; Map < String , Region < ? , ? > > localColocatedRegions = PartitionRegionHelper . getLocalColocatedRegions ( rContext ) ; Region pr2 = colocatedRegions . get ( " / pr2" ) ; LocalDataSet localOrd = ( LocalDataSet ) localColocatedRegions . get ( " / pr2" ) ; QueryObserverImpl observer = new QueryObserverImpl ( ) ; QueryObserverHolder . setInstance ( observer ) ; QueryService qs = pr1 . getCache ( ) . getQueryService ( ) ; DefaultQuery query = ( DefaultQuery ) qs . newQuery ( " select ▁ distinct ▁ e1 . value ▁ from ▁ / pr1 ▁ e1 , ▁ / pr2 ▁ ▁ e2 ▁ where ▁ e1 . value = e2 . value " ) ; GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " ▁ Num ▁ BUCKET ▁ SET : ▁ " + localCust . getBucketSet ( ) ) ; GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " VALUES ▁ FROM ▁ PR1 ▁ bucket : " ) ; for ( Integer bId : localCust . getBucketSet ( ) ) { BucketRegion br = ( ( PartitionedRegion ) pr1 ) . getDataStore ( ) . getLocalBucketById ( bId ) ; String val = " " ; for ( Object e : br . values ( ) ) { val += ( e + " , " ) ; } GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " : ▁ " + val ) ; } GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " VALUES ▁ FROM ▁ PR2 ▁ bucket : " ) ; for ( Integer bId : localCust . getBucketSet ( ) ) { BucketRegion br = ( ( PartitionedRegion ) pr2 ) . getDataStore ( ) . getLocalBucketById ( bId ) ; String val = " " ; for ( Object e : br . values ( ) ) { val += ( e + " , " ) ; } GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " : ▁ " + val ) ; } SelectResults r = ( SelectResults ) localCust . executeQuery ( query , null , localCust . getBucketSet ( ) ) ; GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " Result ▁ : " + r . asList ( ) ) ; Assert . assertTrue ( observer . isIndexesUsed ) ; pr1 . getCache ( ) . getLogger ( ) . fine ( " Index ▁ Used : ▁ " + observer . numIndexesUsed ( ) ) ; Assert . assertTrue ( 2 == observer . numIndexesUsed ( ) ) ; context . getResultSender ( ) . lastResult ( ( Serializable ) r . asList ( ) ) ; } catch ( Exception e ) { context . getResultSender ( ) . lastResult ( Boolean . TRUE ) ; } } @ Override public String getId ( ) { return " ok " ; } @ Override public boolean optimizeForWrite ( ) { return false ; } } ) . getResult ( ) ; int numResults = 0 ; for ( List oneNodeResult : result ) { GemFireCacheImpl . getInstance ( ) . getLogger ( ) . fine ( " Result ▁ : " + numResults + " ▁ oneNodeResult . size ( ) : ▁ " + oneNodeResult . size ( ) + " ▁ oneNodeResult ▁ : " + oneNodeResult ) ; numResults = + oneNodeResult . size ( ) ; } Assert . assertTrue ( 10 == numResults ) ; } } ; dataStore1 . invoke ( createPRs ) ; dataStore2 . invoke ( createPRs ) ; dataStore1 . invoke ( createIndexesOnPRs ) ; dataStore1 . invoke ( execute ) ; }
fengshao0907/incubator-geode | public void beforeIndexLookup ( Index index , int oper , Object key ) { indexName = index . getName ( ) ; indexesUsed . add ( index . getName ( ) ) ; }
fengshao0907/incubator-geode | public void afterIndexLookup ( Collection results ) { if ( results != null ) { isIndexesUsed = true ; } }
fengshao0907/incubator-geode | public int numIndexesUsed ( ) { return indexesUsed . size ( ) ; }
fengshao0907/incubator-geode | public RegionValue ( int value ) { this . value = value ; this . value2 = value ; }
fengshao0907/incubator-geode | public int compareTo ( RegionValue o ) { if ( this . value > o . value ) { return 1 ; } else if ( this . value < o . value ) { return - 1 ; } else { return 0 ; } }
fengshao0907/incubator-geode | public String toString ( ) { return " " + value ; }
cmunell/micro-util | public MethodClassificationFilterDatumIndicator ( ) { this ( null ) ; }
cmunell/micro-util | public MethodClassificationFilterDatumIndicator ( DatumContext < D , L > context ) { super ( context ) ; }
cmunell/micro-util | public MethodClassification < D , L > getInnerMethod ( ) { return this . method ; }
cmunell/micro-util | @ Override public String [ ] getParameterNames ( ) { if ( this . method != null ) { String [ ] parameterNames = Arrays . copyOf ( this . parameterNames , this . parameterNames . length + this . method . getParameterNames ( ) . length ) ; for ( int i = 0 ; i < this . method . getParameterNames ( ) . length ; i ++ ) parameterNames [ this . parameterNames . length + i ] = this . method . getParameterNames ( ) [ i ] ; return parameterNames ; } else return this . parameterNames ; }
cmunell/micro-util | @ Override public Obj getParameterValue ( String parameter ) { if ( parameter . equals ( " datumIndicator " ) ) return ( this . datumIndicator == null ) ? null : Obj . stringValue ( this . datumIndicator . toString ( ) ) ; else if ( parameter . equals ( " method " ) ) return ( this . method == null ) ? null : Obj . curlyBracedValue ( this . method . getReferenceName ( ) ) ; else if ( this . method != null ) return this . method . getParameterValue ( parameter ) ; else return null ; }
cmunell/micro-util | @ Override public boolean setParameterValue ( String parameter , Obj parameterValue ) { if ( parameter . equals ( " datumIndicator " ) ) { this . datumIndicator = ( parameterValue == null ) ? null : this . context . getDatumTools ( ) . getDatumIndicator ( this . context . getMatchValue ( parameterValue ) ) ; } else if ( parameter . equals ( " method " ) ) this . method = ( parameterValue == null ) ? null : this . context . getMatchClassifyMethod ( parameterValue ) ; else if ( this . method != null ) return this . method . setParameterValue ( parameter , parameterValue ) ; else return false ; return true ; }
cmunell/micro-util | @ Override public Map < D , L > classify ( DataSet < D , L > data ) { DataSet < D , L > filteredData = data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . classify ( filteredData ) ; }
cmunell/micro-util | @ Override public Map < D , Pair < L , Double > > classifyWithScore ( DataSet < D , L > data ) { DataSet < D , L > filteredData = data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . classifyWithScore ( filteredData ) ; }
cmunell/micro-util | @ Override public boolean init ( DataSet < D , L > testData ) { DataSet < D , L > filteredData = testData . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . init ( filteredData ) ; }
cmunell/micro-util | @ Override protected boolean fromParseInternal ( AssignmentList internalAssignments ) { return true ; }
cmunell/micro-util | @ Override protected AssignmentList toParseInternal ( ) { AssignmentList assignments = new AssignmentList ( ) ; if ( this . method != null ) assignments . add ( Assignment . assignmentTyped ( null , " classify _ method " , " method " , this . method . toParse ( true ) ) ) ; return assignments ; }
cmunell/micro-util | @ Override public String getGenericName ( ) { return " FilterDatumIndicator " ; }
cmunell/micro-util | @ Override public MethodClassification < D , L > clone ( String referenceName ) { MethodClassificationFilterDatumIndicator < D , L > clone = new MethodClassificationFilterDatumIndicator < D , L > ( this . context ) ; if ( ! clone . fromParse ( this . getModifiers ( ) , this . getReferenceName ( ) , toParse ( ) ) ) return null ; clone . method = this . method . clone ( ) ; clone . referenceName = referenceName ; return clone ; }
cmunell/micro-util | @ Override public MethodClassification < D , L > makeInstance ( DatumContext < D , L > context ) { return new MethodClassificationFilterDatumIndicator < D , L > ( context ) ; }
cmunell/micro-util | @ Override public boolean hasTrainable ( ) { return this . method . hasTrainable ( ) ; }
cmunell/micro-util | @ Override public Trainable < D , L > getTrainable ( ) { if ( this . method . hasTrainable ( ) ) return this ; else return null ; }
cmunell/micro-util | @ Override public boolean train ( ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . train ( ) ; }
cmunell/micro-util | @ Override public boolean setTrainData ( DataSet < D , L > data ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . setTrainData ( data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ) ; }
cmunell/micro-util | @ Override public boolean setDevData ( DataSet < D , L > data ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . setDevData ( data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ) ; }
cmunell/micro-util | @ Override public boolean iterateTraining ( Map < D , L > constrainedData ) { if ( ! hasTrainable ( ) ) return false ; return this . method . getTrainable ( ) . iterateTraining ( constrainedData ) ; }
cmunell/micro-util | @ Override public DataSet < D , L > getTrainData ( ) { return this . method . getTrainable ( ) . getTrainData ( ) ; }
cmunell/micro-util | @ Override public L classify ( D datum ) { if ( this . datumIndicator . indicator ( datum ) ) return this . method . classify ( datum ) ; else return null ; }
cmunell/micro-util | @ Override public Pair < L , Double > classifyWithScore ( D datum ) { if ( this . datumIndicator . indicator ( datum ) ) return this . method . classifyWithScore ( datum ) ; else return null ; }
cmunell/micro-util | @ Override public Map < D , Double > score ( DataSet < D , L > data , L label ) { DataSet < D , L > filteredData = data . filter ( this . datumIndicator , this . context . getMaxThreads ( ) ) ; return this . method . score ( filteredData , label ) ; }
cmunell/micro-util | @ Override public double score ( D datum , L label ) { if ( this . datumIndicator . indicator ( datum ) ) return this . method . score ( datum , label ) ; else return 0.0 ; }
webos21/xi | public Long ( long value ) { this . value = value ; }
webos21/xi | public Long ( String string ) throws NumberFormatException { this ( parseLong ( string ) ) ; }
webos21/xi | @ Override public byte byteValue ( ) { return ( byte ) value ; }
webos21/xi | public int compareTo ( Long object ) { long thisValue = this . value ; long thatValue = object . value ; return thisValue < thatValue ? - 1 : ( thisValue == thatValue ? 0 : 1 ) ; }
webos21/xi | @ Override public double doubleValue ( ) { return value ; }
webos21/xi | @ Override public boolean equals ( Object o ) { return o instanceof Long && ( ( Long ) o ) . value == value ; }
webos21/xi | @ Override public float floatValue ( ) { return value ; }
webos21/xi | @ Override public int hashCode ( ) { return ( int ) ( value ^ ( value >>> 32 ) ) ; }
webos21/xi | @ Override public int intValue ( ) { return ( int ) value ; }
webos21/xi | @ Override public long longValue ( ) { return value ; }
webos21/xi | @ Override public short shortValue ( ) { return ( short ) value ; }
webos21/xi | @ Override public String toString ( ) { return Long . toString ( value ) ; }
webos21/xi | i ++ ) { SMALL_VALUES [ i + 128 ] = new Long ( i ) ; }
apache/wicket | @ Test void testAdd ( ) { MockPageStore mockStore = new MockPageStore ( ) ; MockPageContext context = new MockPageContext ( ) ; RequestPageStore store = new RequestPageStore ( mockStore ) ; MockPage page1 = new MockPage ( 1 ) ; MockPage page2 = new MockPage ( 2 ) ; MockPage page3 = new MockPage ( 3 ) ; store . addPage ( context , page1 ) ; store . addPage ( context , page2 ) ; store . addPage ( context , page3 ) ; assertTrue ( mockStore . getPages ( ) . isEmpty ( ) , " no ▁ pages ▁ delegated ▁ before ▁ detach " ) ; store . detach ( context ) ; assertEquals ( 3 , mockStore . getPages ( ) . size ( ) , " pages ▁ delegated ▁ on ▁ detach " ) ; mockStore . getPages ( ) . clear ( ) ; assertNull ( store . getPage ( context , 1 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; assertNull ( store . getPage ( context , 2 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; assertNull ( store . getPage ( context , 3 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; }
apache/wicket | @ Test void testUntouch ( ) { MockPageStore mockStore = new MockPageStore ( ) ; MockPageContext context = new MockPageContext ( ) ; RequestPageStore store = new RequestPageStore ( mockStore ) ; MockPage page = new MockPage ( 1 ) ; store . addPage ( context , page ) ; store . revertPage ( context , page ) ; assertTrue ( mockStore . getPages ( ) . isEmpty ( ) , " no ▁ page ▁ delegated ▁ before ▁ detach " ) ; store . detach ( context ) ; assertEquals ( 0 , mockStore . getPages ( ) . size ( ) , " untouched ▁ page ▁ not ▁ delegated ▁ on ▁ detach " ) ; assertNull ( store . getPage ( context , 1 ) , " no ▁ page ▁ in ▁ request ▁ store " ) ; }
cuba-platform/cuba | @ AfterEach public void tearDown ( ) throws Exception { if ( userId != null ) cont . deleteRecord ( " SEC _ USER " , userId ) ; }
cuba-platform/cuba | @ Test public void testTransactions ( ) throws Exception { User user ; Group group ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; userId = user . getId ( ) ; user . setName ( " testUser " ) ; user . setLogin ( " testLogin " ) ; user . setGroup ( em . find ( Group . class , UUID . fromString ( "0fa2b1a5-1d68-4d69-9fbd - dff348347f93" ) ) ) ; em . persist ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . find ( User . class , userId ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; Query query = em . createQuery ( " select ▁ u ▁ from ▁ sec $ User ▁ u ▁ where ▁ u . id ▁ = ▁ ? 1" ) . setParameter ( 1 , userId ) ; user = ( User ) query . getFirstResult ( ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( group ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; user . setName ( " changed ▁ name " ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . merge ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
cuba-platform/cuba | @ Test public void testSerialization ( ) throws Exception { User user ; Group group ; user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; user = reserialize ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = new User ( ) ; userId = user . getId ( ) ; user . setName ( " testUser " ) ; user . setLogin ( " testLogin " ) ; user . setGroup ( em . find ( Group . class , UUID . fromString ( "0fa2b1a5-1d68-4d69-9fbd - dff348347f93" ) ) ) ; em . persist ( user ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . find ( User . class , userId ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( group ) ) ; user = reserialize ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } user . setName ( " changed ▁ name " ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . merge ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; user = reserialize ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
cuba-platform/cuba | @ Test public void testTransactionRollback_new ( ) throws Exception { User user = null ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; userId = user . getId ( ) ; cont . persistence ( ) . getEntityManager ( ) . persist ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; fail ( ) ; } catch ( Exception e ) { } finally { tx . end ( ) ; } assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
cuba-platform/cuba | @ Test public void testTransactionRollback_loaded ( ) { User user ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { user = cont . persistence ( ) . getEntityManager ( ) . find ( User . class , TestSupport . ADMIN_USER_ID ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
straniggtamas/swsv_lab1b | public Yytoken ( int type , Object value ) { this . type = type ; this . value = value ; }
straniggtamas/swsv_lab1b | public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; switch ( type ) { case TYPE_VALUE : sb . append ( " VALUE ( " ) . append ( value ) . append ( " ) " ) ; break ; case TYPE_LEFT_BRACE : sb . append ( " LEFT ▁ BRACE ( { ) " ) ; break ; case TYPE_RIGHT_BRACE : sb . append ( " RIGHT ▁ BRACE ( } ) " ) ; break ; case TYPE_LEFT_SQUARE : sb . append ( " LEFT ▁ SQUARE ( [ ) " ) ; break ; case TYPE_RIGHT_SQUARE : sb . append ( " RIGHT ▁ SQUARE ( ] ) " ) ; break ; case TYPE_COMMA : sb . append ( " COMMA ( , ) " ) ; break ; case TYPE_COLON : sb . append ( " COLON ( : ) " ) ; break ; case TYPE_EOF : sb . append ( " END ▁ OF ▁ FILE " ) ; break ; default : throw new IllegalStateException ( " Not ▁ a ▁ known ▁ type " ) ; } return sb . toString ( ) ; }
tita/tita | public ButtonEdit ( String id ) { super ( id ) ; }
GDG-Korea/holo_to_material | public Category ( Parcel in ) { category = in . readString ( ) ; Object [ ] objArrays = in . readArray ( Video . class . getClassLoader ( ) ) ; videos = new Video [ objArrays . length ] ; videos = Arrays . copyOf ( objArrays , objArrays . length , Video [ ] . class ) ; }
GDG-Korea/holo_to_material | @ Override public int describeContents ( ) { return 0 ; }
GDG-Korea/holo_to_material | @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeString ( category ) ; dest . writeArray ( videos ) ; }
GDG-Korea/holo_to_material | public void initVideos ( ) { for ( Video video : videos ) { video . setCateogry ( category ) ; video . description += " \n \n " + video . description . substring ( 30 ) + video . description . substring ( 50 ) ; } }
kingland/java-design-patterns | @ Test public void taskGeneratorTest ( ) { var msgQueue = new MessageQueue ( ) ; var taskRunnable = new TaskGenerator ( msgQueue , 1 ) ; var taskGenThr = new Thread ( taskRunnable ) ; taskGenThr . start ( ) ; var srvRunnable = new ServiceExecutor ( msgQueue ) ; var srvExeThr = new Thread ( srvRunnable ) ; srvExeThr . start ( ) ; }
andreagenso/java2scala | public ClientFactoryImpl ( ) { }
andreagenso/java2scala | public SaslClient createSaslClient ( String [ ] mechs , String authorizationId , String protocol , String serverName , Map < String , ? > props , CallbackHandler cbh ) throws SaslException { for ( int i = 0 ; i < mechs . length ; i ++ ) { if ( mechs [ i ] . equals ( myMechs [ EXTERNAL ] ) && PolicyUtils . checkPolicy ( mechPolicies [ EXTERNAL ] , props ) ) { return new ExternalClient ( authorizationId ) ; } else if ( mechs [ i ] . equals ( myMechs [ CRAMMD5 ] ) && PolicyUtils . checkPolicy ( mechPolicies [ CRAMMD5 ] , props ) ) { Object [ ] uinfo = getUserInfo ( " CRAM - MD5" , authorizationId , cbh ) ; return new CramMD5Client ( ( String ) uinfo [ 0 ] , ( byte [ ] ) uinfo [ 1 ] ) ; } else if ( mechs [ i ] . equals ( myMechs [ PLAIN ] ) && PolicyUtils . checkPolicy ( mechPolicies [ PLAIN ] , props ) ) { Object [ ] uinfo = getUserInfo ( " PLAIN " , authorizationId , cbh ) ; return new PlainClient ( authorizationId , ( String ) uinfo [ 0 ] , ( byte [ ] ) uinfo [ 1 ] ) ; } } return null ; }
andreagenso/java2scala | public String [ ] getMechanismNames ( Map < String , ? > props ) { return PolicyUtils . filterMechs ( myMechs , mechPolicies , props ) ; }
andreagenso/java2scala | private Object [ ] getUserInfo ( String prefix , String authorizationId , CallbackHandler cbh ) throws SaslException { if ( cbh == null ) { throw new SaslException ( " Callback ▁ handler ▁ to ▁ get ▁ username / password ▁ required " ) ; } try { String userPrompt = prefix + " ▁ authentication ▁ id : ▁ " ; String passwdPrompt = prefix + " ▁ password : ▁ " ; NameCallback ncb = authorizationId == null ? new NameCallback ( userPrompt ) : new NameCallback ( userPrompt , authorizationId ) ; PasswordCallback pcb = new PasswordCallback ( passwdPrompt , false ) ; cbh . handle ( new Callback [ ] { ncb , pcb } ) ; char [ ] pw = pcb . getPassword ( ) ; byte [ ] bytepw ; String authId ; if ( pw != null ) { bytepw = new String ( pw ) . getBytes ( " UTF8" ) ; pcb . clearPassword ( ) ; } else { bytepw = null ; } authId = ncb . getName ( ) ; return new Object [ ] { authId , bytepw } ; } catch ( IOException e ) { throw new SaslException ( " Cannot ▁ get ▁ password " , e ) ; } catch ( UnsupportedCallbackException e ) { throw new SaslException ( " Cannot ▁ get ▁ userid / password " , e ) ; } }
SomeFire/ignite | @ Override public void start ( ) throws IgniteCheckedException { if ( port <= 0 || port >= 0xffff ) throw new IpcEndpointBindException ( " Port ▁ value ▁ is ▁ illegal : ▁ " + port ) ; try { srvSock = new ServerSocket ( ) ; assert host != null ; srvSock . bind ( new InetSocketAddress ( U . resolveLocalHost ( host ) , port ) ) ; if ( log . isInfoEnabled ( ) ) log . info ( " IPC ▁ server ▁ loopback ▁ endpoint ▁ started ▁ [ port = " + port + ' ] ' ) ; } catch ( IOException e ) { if ( srvSock != null ) U . closeQuiet ( srvSock ) ; throw new IpcEndpointBindException ( " Failed ▁ to ▁ bind ▁ loopback ▁ IPC ▁ endpoint ▁ ( is ▁ port ▁ already ▁ in ▁ " + " use ? ) : ▁ " + port , e ) ; } }
SomeFire/ignite | @ Override public IpcEndpoint accept ( ) throws IgniteCheckedException { try { Socket sock = srvSock . accept ( ) ; return new IpcClientTcpEndpoint ( sock ) ; } catch ( IOException e ) { throw new IgniteCheckedException ( e ) ; } }
SomeFire/ignite | @ Override public void close ( ) { U . closeQuiet ( srvSock ) ; }
SomeFire/ignite | @ Override public int getPort ( ) { return port ; }
SomeFire/ignite | public void setPort ( int port ) { this . port = port ; }
SomeFire/ignite | @ Override public String getHost ( ) { return host ; }
SomeFire/ignite | public void setHost ( String host ) { this . host = host ; }
SomeFire/ignite | @ Override public boolean isManagement ( ) { return mgmt ; }
SomeFire/ignite | public void setManagement ( boolean mgmt ) { this . mgmt = mgmt ; }
SomeFire/ignite | @ Override public String toString ( ) { return S . toString ( IpcServerTcpEndpoint . class , this ) ; }
SomeFire/ignite | public void setupConfiguration ( Map < String , String > endpointCfg ) throws IgniteCheckedException { for ( Map . Entry < String , String > e : endpointCfg . entrySet ( ) ) { try { switch ( e . getKey ( ) ) { case " type " : break ; case " port " : setPort ( Integer . parseInt ( e . getValue ( ) ) ) ; break ; case " host " : setHost ( e . getValue ( ) ) ; break ; case " management " : setManagement ( Boolean . valueOf ( e . getValue ( ) ) ) ; break ; default : throw new IgniteCheckedException ( " Invalid ▁ property ▁ ' " + e . getKey ( ) + " ' ▁ of ▁ " + getClass ( ) . getSimpleName ( ) ) ; } } catch ( Throwable t ) { if ( t instanceof IgniteCheckedException || t instanceof Error ) throw t ; throw new IgniteCheckedException ( " Invalid ▁ value ▁ ' " + e . getValue ( ) + " ' ▁ of ▁ the ▁ property ▁ ' " + e . getKey ( ) + " ' ▁ in ▁ " + getClass ( ) . getSimpleName ( ) , t ) ; } } }
idea4bsd/idea4bsd | public VcsLogGraphTable ( @ NotNull VcsLogUiImpl ui , @ NotNull VcsLogData logData , @ NotNull VisiblePack initialDataPack ) { super ( new GraphTableModel ( initialDataPack , logData , ui ) ) ; getEmptyText ( ) . setText ( " Changes ▁ Log " ) ; myUi = ui ; myLogData = logData ; GraphCellPainter graphCellPainter = new SimpleGraphCellPainter ( new DefaultColorGenerator ( ) ) { @ Override protected int getRowHeight ( ) { return VcsLogGraphTable . this . getRowHeight ( ) ; } } ; myGraphCommitCellRenderer = new GraphCommitCellRenderer ( logData , graphCellPainter , this ) ; myStringCellRenderer = new StringCellRenderer ( ) ; myLogData . getProgress ( ) . addProgressIndicatorListener ( new MyProgressListener ( ) , ui ) ; setDefaultRenderer ( VirtualFile . class , new RootCellRenderer ( myUi ) ) ; setDefaultRenderer ( GraphCommitCell . class , myGraphCommitCellRenderer ) ; setDefaultRenderer ( String . class , myStringCellRenderer ) ; setShowHorizontalLines ( false ) ; setIntercellSpacing ( JBUI . emptySize ( ) ) ; setTableHeader ( new InvisibleResizableHeader ( ) ) ; myController = new GraphTableController ( this , ui , logData , graphCellPainter , myGraphCommitCellRenderer ) ; getSelectionModel ( ) . addListSelectionListener ( new MyListSelectionListener ( ) ) ; PopupHandler . installPopupHandler ( this , VcsLogActionPlaces . POPUP_ACTION_GROUP , VcsLogActionPlaces . VCS_LOG_TABLE_PLACE ) ; ScrollingUtil . installActions ( this , false ) ; initColumnSize ( ) ; addComponentListener ( new ComponentAdapter ( ) { @ Override public void componentResized ( ComponentEvent e ) { updateCommitColumnWidth ( ) ; } } ) ; }
idea4bsd/idea4bsd | public void updateDataPack ( @ NotNull VisiblePack visiblePack , boolean permGraphChanged ) { VcsLogGraphTable . Selection previousSelection = getSelection ( ) ; getModel ( ) . setVisiblePack ( visiblePack ) ; previousSelection . restore ( visiblePack . getVisibleGraph ( ) , true , permGraphChanged ) ; for ( VcsLogHighlighter highlighter : myHighlighters ) { highlighter . update ( visiblePack , permGraphChanged ) ; } setPaintBusy ( false ) ; initColumnSize ( ) ; }
idea4bsd/idea4bsd | boolean initColumnSize ( ) { if ( ! myColumnsSizeInitialized && getModel ( ) . getRowCount ( ) > 0 ) { myColumnsSizeInitialized = setColumnPreferredSize ( ) ; if ( myColumnsSizeInitialized ) { setAutoCreateColumnsFromModel ( false ) ; for ( int column = 0 ; column < getColumnCount ( ) ; column ++ ) { getColumnModel ( ) . getColumn ( column ) . setResizable ( column != GraphTableModel . ROOT_COLUMN ) ; } } return myColumnsSizeInitialized ; } return false ; }
idea4bsd/idea4bsd | private boolean setColumnPreferredSize ( ) { boolean sizeCalculated = false ; Font tableFont = UIManager . getFont ( " Table . font " ) ; for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { TableColumn column = getColumnModel ( ) . getColumn ( i ) ; if ( i == GraphTableModel . ROOT_COLUMN ) { setRootColumnSize ( column ) ; } else if ( i == GraphTableModel . AUTHOR_COLUMN ) { int maxRowsToCheck = Math . min ( MAX_ROWS_TO_CALC_WIDTH , getRowCount ( ) - MAX_ROWS_TO_CALC_OFFSET ) ; if ( maxRowsToCheck < 0 ) { maxRowsToCheck = getRowCount ( ) ; } int maxWidth = 0 ; for ( int row = 0 ; row < maxRowsToCheck ; row ++ ) { String value = getModel ( ) . getValueAt ( row , i ) . toString ( ) ; Font font = tableFont ; VcsLogHighlighter . TextStyle style = getStyle ( row , i , value , false , false ) . getTextStyle ( ) ; if ( BOLD . equals ( style ) ) { font = tableFont . deriveFont ( Font . BOLD ) ; } else if ( ITALIC . equals ( style ) ) { font = tableFont . deriveFont ( Font . ITALIC ) ; } maxWidth = Math . max ( getFontMetrics ( font ) . stringWidth ( value + " * " ) , maxWidth ) ; if ( ! value . isEmpty ( ) ) sizeCalculated = true ; } int min = Math . min ( maxWidth + myStringCellRenderer . getHorizontalTextPadding ( ) , JBUI . scale ( MAX_DEFAULT_AUTHOR_COLUMN_WIDTH ) ) ; column . setPreferredWidth ( min ) ; } else if ( i == GraphTableModel . DATE_COLUMN ) { int min = getFontMetrics ( tableFont . deriveFont ( Font . BOLD ) ) . stringWidth ( DateFormatUtil . formatDateTime ( new Date ( ) ) ) + myStringCellRenderer . getHorizontalTextPadding ( ) ; column . setPreferredWidth ( min ) ; } } updateCommitColumnWidth ( ) ; return sizeCalculated ; }
idea4bsd/idea4bsd | private void updateCommitColumnWidth ( ) { int size = getWidth ( ) ; for ( int i = 0 ; i < getColumnCount ( ) ; i ++ ) { if ( i == GraphTableModel . COMMIT_COLUMN ) continue ; TableColumn column = getColumnModel ( ) . getColumn ( i ) ; size -= column . getPreferredWidth ( ) ; } TableColumn commitColumn = getColumnModel ( ) . getColumn ( GraphTableModel . COMMIT_COLUMN ) ; commitColumn . setPreferredWidth ( size ) ; }
idea4bsd/idea4bsd | private void setRootColumnSize ( @ NotNull TableColumn column ) { int rootWidth ; if ( ! myUi . isMultipleRoots ( ) ) { rootWidth = 0 ; } else if ( ! myUi . isShowRootNames ( ) ) { rootWidth = JBUI . scale ( ROOT_INDICATOR_WIDTH ) ; } else { rootWidth = Math . min ( calculateMaxRootWidth ( ) , JBUI . scale ( ROOT_NAME_MAX_WIDTH ) ) ; } column . setMinWidth ( rootWidth ) ; column . setMaxWidth ( rootWidth ) ; column . setPreferredWidth ( rootWidth ) ; }
idea4bsd/idea4bsd | private int calculateMaxRootWidth ( ) { int width = 0 ; for ( VirtualFile file : myLogData . getRoots ( ) ) { Font tableFont = UIManager . getFont ( " Table . font " ) ; width = Math . max ( getFontMetrics ( tableFont ) . stringWidth ( file . getName ( ) + " ▁ ▁ " ) , width ) ; } return width ; }
idea4bsd/idea4bsd | @ Override public String getToolTipText ( @ NotNull MouseEvent event ) { int row = rowAtPoint ( event . getPoint ( ) ) ; int column = columnAtPoint ( event . getPoint ( ) ) ; if ( column < 0 || row < 0 ) { return null ; } if ( column == GraphTableModel . ROOT_COLUMN ) { Object at = getValueAt ( row , column ) ; if ( at instanceof VirtualFile ) { return " < html > < b > " + ( ( VirtualFile ) at ) . getPresentableUrl ( ) + " < / b > < br / > Click ▁ to ▁ " + ( myUi . isShowRootNames ( ) ? " collapse " : " expand " ) + " < / html > " ; } } return null ; }
idea4bsd/idea4bsd | public void jumpToRow ( int rowIndex ) { if ( rowIndex >= 0 && rowIndex <= getRowCount ( ) - 1 ) { scrollRectToVisible ( getCellRect ( rowIndex , 0 , false ) ) ; setRowSelectionInterval ( rowIndex , rowIndex ) ; scrollRectToVisible ( getCellRect ( rowIndex , 0 , false ) ) ; } }
idea4bsd/idea4bsd | @ Nullable @ Override public Object getData ( @ NonNls String dataId ) { if ( PlatformDataKeys . COPY_PROVIDER . is ( dataId ) ) { return this ; } return null ; }
idea4bsd/idea4bsd | @ Override public void performCopy ( @ NotNull DataContext dataContext ) { VcsLog log = VcsLogDataKeys . VCS_LOG . getData ( dataContext ) ; if ( log == null ) return ; List < VcsFullCommitDetails > details = VcsLogUtil . collectFirstPackOfLoadedSelectedDetails ( log ) ; if ( details . isEmpty ( ) ) return ; String text = StringUtil . join ( details , commit -> getPresentableText ( commit , true ) , " \n " ) ; CopyPasteManager . getInstance ( ) . setContents ( new StringSelection ( text ) ) ; }
idea4bsd/idea4bsd | @ Override public boolean isCopyEnabled ( @ NotNull DataContext dataContext ) { return getSelectedRowCount ( ) > 0 ; }
idea4bsd/idea4bsd | @ Override public boolean isCopyVisible ( @ NotNull DataContext dataContext ) { return true ; }
idea4bsd/idea4bsd | public void addHighlighter ( @ NotNull VcsLogHighlighter highlighter ) { myHighlighters . add ( highlighter ) ; }
idea4bsd/idea4bsd | public void removeHighlighter ( @ NotNull VcsLogHighlighter highlighter ) { myHighlighters . remove ( highlighter ) ; }
idea4bsd/idea4bsd | public void removeAllHighlighters ( ) { myHighlighters . clear ( ) ; }
idea4bsd/idea4bsd | public SimpleTextAttributes applyHighlighters ( @ NotNull Component rendererComponent , int row , int column , String text , boolean hasFocus , final boolean selected ) { VcsLogHighlighter . VcsCommitStyle style = getStyle ( row , column , text , hasFocus , selected ) ; assert style . getBackground ( ) != null && style . getForeground ( ) != null && style . getTextStyle ( ) != null ; rendererComponent . setBackground ( style . getBackground ( ) ) ; rendererComponent . setForeground ( style . getForeground ( ) ) ; switch ( style . getTextStyle ( ) ) { case BOLD : return SimpleTextAttributes . REGULAR_BOLD_ATTRIBUTES ; case ITALIC : return SimpleTextAttributes . REGULAR_ITALIC_ATTRIBUTES ; default : } return SimpleTextAttributes . REGULAR_ATTRIBUTES ; }
idea4bsd/idea4bsd | public VcsLogHighlighter . VcsCommitStyle getBaseStyle ( int row , int column , String text , boolean hasFocus , boolean selected ) { Component dummyRendererComponent = myDummyRenderer . getTableCellRendererComponent ( this , text , selected , hasFocus , row , column ) ; return VcsCommitStyleFactory . createStyle ( dummyRendererComponent . getForeground ( ) , dummyRendererComponent . getBackground ( ) , VcsLogHighlighter . TextStyle . NORMAL ) ; }
idea4bsd/idea4bsd | private VcsLogHighlighter . VcsCommitStyle getStyle ( int row , int column , String text , boolean hasFocus , boolean selected ) { VcsLogHighlighter . VcsCommitStyle baseStyle = getBaseStyle ( row , column , text , hasFocus , selected ) ; VisibleGraph < Integer > visibleGraph = getVisibleGraph ( ) ; if ( row < 0 || row >= visibleGraph . getVisibleCommitCount ( ) ) { LOG . error ( " Visible ▁ graph ▁ has ▁ " + visibleGraph . getVisibleCommitCount ( ) + " ▁ commits , ▁ yet ▁ we ▁ want ▁ row ▁ " + row ) ; return baseStyle ; } RowInfo < Integer > rowInfo = visibleGraph . getRowInfo ( row ) ; VcsLogHighlighter . VcsCommitStyle defaultStyle = VcsCommitStyleFactory . createStyle ( rowInfo . getRowType ( ) == RowType . UNMATCHED ? JBColor . GRAY : baseStyle . getForeground ( ) , baseStyle . getBackground ( ) , VcsLogHighlighter . TextStyle . NORMAL ) ; final VcsShortCommitDetails details = myLogData . getMiniDetailsGetter ( ) . getCommitDataIfAvailable ( rowInfo . getCommit ( ) ) ; if ( details == null || details instanceof LoadingDetails ) return defaultStyle ; List < VcsLogHighlighter . VcsCommitStyle > styles = ContainerUtil . map ( myHighlighters , highlighter -> highlighter . getStyle ( details , selected ) ) ; return VcsCommitStyleFactory . combine ( ContainerUtil . append ( styles , defaultStyle ) ) ; }
idea4bsd/idea4bsd | public void viewportSet ( JViewport viewport ) { viewport . addChangeListener ( e -> { AbstractTableModel model = getModel ( ) ; Couple < Integer > visibleRows = ScrollingUtil . getVisibleRows ( this ) ; model . fireTableChanged ( new TableModelEvent ( model , visibleRows . first - 1 , visibleRows . second , GraphTableModel . ROOT_COLUMN ) ) ; } ) ; }
idea4bsd/idea4bsd | public void rootColumnUpdated ( ) { setRootColumnSize ( getColumnModel ( ) . getColumn ( GraphTableModel . ROOT_COLUMN ) ) ; updateCommitColumnWidth ( ) ; }
idea4bsd/idea4bsd | @ Override public void setCursor ( Cursor cursor ) { super . setCursor ( cursor ) ; Component layeredPane = UIUtil . findParentByCondition ( this , component -> component instanceof LoadingDecorator . CursorAware ) ; if ( layeredPane != null ) { layeredPane . setCursor ( cursor ) ; } }
idea4bsd/idea4bsd | @ Override @ NotNull public GraphTableModel getModel ( ) { return ( GraphTableModel ) super . getModel ( ) ; }
idea4bsd/idea4bsd | @ NotNull public Selection getSelection ( ) { if ( mySelection == null ) mySelection = new Selection ( this ) ; return mySelection ; }
idea4bsd/idea4bsd | public void handleAnswer ( @ Nullable GraphAnswer < Integer > answer , boolean dataCouldChange ) { myController . handleGraphAnswer ( answer , dataCouldChange , null , null ) ; }
idea4bsd/idea4bsd | public Selection ( @ NotNull VcsLogGraphTable table ) { myTable = table ; List < Integer > selectedRows = ContainerUtil . sorted ( Ints . asList ( myTable . getSelectedRows ( ) ) ) ; Couple < Integer > visibleRows = ScrollingUtil . getVisibleRows ( myTable ) ; myIsOnTop = visibleRows . first - 1 == 0 ; VisibleGraph < Integer > graph = myTable . getVisibleGraph ( ) ; mySelectedCommits = new TIntHashSet ( ) ; Integer visibleSelectedCommit = null ; Integer delta = null ; for ( int row : selectedRows ) { if ( row < graph . getVisibleCommitCount ( ) ) { Integer commit = graph . getRowInfo ( row ) . getCommit ( ) ; mySelectedCommits . add ( commit ) ; if ( visibleRows . first - 1 <= row && row <= visibleRows . second && visibleSelectedCommit == null ) { visibleSelectedCommit = commit ; delta = myTable . getCellRect ( row , 0 , false ) . y - myTable . getVisibleRect ( ) . y ; } } } if ( visibleSelectedCommit == null && visibleRows . first - 1 >= 0 ) { visibleSelectedCommit = graph . getRowInfo ( visibleRows . first - 1 ) . getCommit ( ) ; delta = myTable . getCellRect ( visibleRows . first - 1 , 0 , false ) . y - myTable . getVisibleRect ( ) . y ; } myVisibleSelectedCommit = visibleSelectedCommit ; myDelta = delta ; }
idea4bsd/idea4bsd | public void restore ( @ NotNull VisibleGraph < Integer > newVisibleGraph , boolean scrollToSelection , boolean permGraphChanged ) { Pair < TIntHashSet , Integer > toSelectAndScroll = findRowsToSelectAndScroll ( myTable . getModel ( ) , newVisibleGraph ) ; if ( ! toSelectAndScroll . first . isEmpty ( ) ) { myTable . getSelectionModel ( ) . setValueIsAdjusting ( true ) ; toSelectAndScroll . first . forEach ( row -> { myTable . addRowSelectionInterval ( row , row ) ; return true ; } ) ; myTable . getSelectionModel ( ) . setValueIsAdjusting ( false ) ; } if ( scrollToSelection ) { if ( myIsOnTop && permGraphChanged ) { scrollToRow ( 0 , 0 ) ; } else if ( toSelectAndScroll . second != null ) { assert myDelta != null ; scrollToRow ( toSelectAndScroll . second , myDelta ) ; } } }
idea4bsd/idea4bsd | private void scrollToRow ( Integer row , Integer delta ) { Rectangle startRect = myTable . getCellRect ( row , 0 , true ) ; myTable . scrollRectToVisible ( new Rectangle ( startRect . x , Math . max ( startRect . y - delta , 0 ) , startRect . width , myTable . getVisibleRect ( ) . height ) ) ; }
idea4bsd/idea4bsd | @ NotNull private Pair < TIntHashSet , Integer > findRowsToSelectAndScroll ( @ NotNull GraphTableModel model , @ NotNull VisibleGraph < Integer > visibleGraph ) { TIntHashSet rowsToSelect = new TIntHashSet ( ) ; if ( model . getRowCount ( ) == 0 ) { return Pair . create ( rowsToSelect , null ) ; } Integer rowToScroll = null ; for ( int row = 0 ; row < visibleGraph . getVisibleCommitCount ( ) && ( rowsToSelect . size ( ) < mySelectedCommits . size ( ) || rowToScroll == null ) ; row ++ ) { int commit = visibleGraph . getRowInfo ( row ) . getCommit ( ) ; if ( mySelectedCommits . contains ( commit ) ) { rowsToSelect . add ( row ) ; } if ( myVisibleSelectedCommit != null && myVisibleSelectedCommit == commit ) { rowToScroll = row ; } } return Pair . create ( rowsToSelect , rowToScroll ) ; }
idea4bsd/idea4bsd | @ NotNull public VisibleGraph < Integer > getVisibleGraph ( ) { return getModel ( ) . getVisiblePack ( ) . getVisibleGraph ( ) ; }
idea4bsd/idea4bsd | @ Override public TableCellEditor getCellEditor ( ) { return myDummyEditor ; }
idea4bsd/idea4bsd | @ Override public int getRowHeight ( ) { return myGraphCommitCellRenderer . getPreferredHeight ( ) ; }
idea4bsd/idea4bsd | @ Override protected void paintFooter ( @ NotNull Graphics g , int x , int y , int width , int height ) { int lastRow = getRowCount ( ) - 1 ; if ( lastRow >= 0 ) { g . setColor ( getStyle ( lastRow , GraphTableModel . COMMIT_COLUMN , " " , hasFocus ( ) , false ) . getBackground ( ) ) ; g . fillRect ( x , y , width , height ) ; if ( myUi . isMultipleRoots ( ) ) { g . setColor ( getRootBackgroundColor ( getModel ( ) . getRoot ( lastRow ) , myUi . getColorManager ( ) ) ) ; int rootWidth = getColumnModel ( ) . getColumn ( GraphTableModel . ROOT_COLUMN ) . getWidth ( ) ; if ( ! myUi . isShowRootNames ( ) ) rootWidth -= JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) ; g . fillRect ( x , y , rootWidth , height ) ; } } else { g . setColor ( getBaseStyle ( lastRow , GraphTableModel . COMMIT_COLUMN , " " , hasFocus ( ) , false ) . getBackground ( ) ) ; g . fillRect ( x , y , width , height ) ; } }
idea4bsd/idea4bsd | boolean isResizingColumns ( ) { return getCursor ( ) == Cursor . getPredefinedCursor ( Cursor . E_RESIZE_CURSOR ) ; }
idea4bsd/idea4bsd | RootCellRenderer ( @ NotNull VcsLogUiImpl ui ) { super ( " " , CENTER ) ; myUi = ui ; }
idea4bsd/idea4bsd | @ Override protected void paintComponent ( Graphics g ) { setFont ( UIManager . getFont ( " Table . font " ) ) ; g . setColor ( myColor ) ; int width = getWidth ( ) ; if ( isNarrow ) { g . fillRect ( 0 , 0 , width - JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) , myUi . getTable ( ) . getRowHeight ( ) ) ; g . setColor ( myBorderColor ) ; g . fillRect ( width - JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) , 0 , JBUI . scale ( ROOT_INDICATOR_WHITE_WIDTH ) , myUi . getTable ( ) . getRowHeight ( ) ) ; } else { g . fillRect ( 0 , 0 , width , myUi . getTable ( ) . getRowHeight ( ) ) ; } super . paintComponent ( g ) ; }
idea4bsd/idea4bsd | @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { String text ; Color color ; if ( value instanceof VirtualFile ) { VirtualFile root = ( VirtualFile ) value ; int readableRow = ScrollingUtil . getReadableRow ( table , Math . round ( myUi . getTable ( ) . getRowHeight ( ) * 0.5f ) ) ; if ( row < readableRow ) { text = " " ; } else if ( row == 0 || ! value . equals ( table . getModel ( ) . getValueAt ( row - 1 , column ) ) || readableRow == row ) { text = root . getName ( ) ; } else { text = " " ; } color = getRootBackgroundColor ( root , myUi . getColorManager ( ) ) ; } else { text = null ; color = UIUtil . getTableBackground ( isSelected ) ; } myColor = color ; Color background = ( ( VcsLogGraphTable ) table ) . getStyle ( row , column , text , hasFocus , isSelected ) . getBackground ( ) ; assert background != null ; myBorderColor = background ; setForeground ( UIUtil . getTableForeground ( false ) ) ; if ( myUi . isShowRootNames ( ) ) { setText ( text ) ; isNarrow = false ; } else { setText ( " " ) ; isNarrow = true ; } return this ; }
idea4bsd/idea4bsd | @ Override public void setBackground ( Color bg ) { myBorderColor = bg ; }
idea4bsd/idea4bsd | @ Override protected void customizeCellRenderer ( JTable table , Object value , boolean selected , boolean hasFocus , int row , int column ) { if ( value == null ) { return ; } append ( value . toString ( ) , applyHighlighters ( this , row , column , value . toString ( ) , hasFocus , selected ) ) ; }
idea4bsd/idea4bsd | public int getHorizontalTextPadding ( ) { Insets borderInsets = getMyBorder ( ) . getBorderInsets ( this ) ; Insets ipad = getIpad ( ) ; return borderInsets . left + borderInsets . right + ipad . left + ipad . right ; }
idea4bsd/idea4bsd | @ Override public Component getTableCellEditorComponent ( JTable table , Object value , boolean isSelected , int row , int column ) { return null ; }
idea4bsd/idea4bsd | @ Override public Object getCellEditorValue ( ) { return null ; }
idea4bsd/idea4bsd | @ Override public boolean isCellEditable ( EventObject anEvent ) { return false ; }
idea4bsd/idea4bsd | @ Override public boolean shouldSelectCell ( EventObject anEvent ) { if ( ! ( anEvent instanceof MouseEvent ) ) return true ; return myController . findPrintElement ( ( MouseEvent ) anEvent ) == null ; }
idea4bsd/idea4bsd | @ Override public boolean stopCellEditing ( ) { return false ; }
idea4bsd/idea4bsd | @ Override public void cancelCellEditing ( ) { }
idea4bsd/idea4bsd | @ Override public void addCellEditorListener ( CellEditorListener l ) { }
idea4bsd/idea4bsd | @ Override public void removeCellEditorListener ( CellEditorListener l ) { }
idea4bsd/idea4bsd | public InvisibleResizableHeader ( ) { myHeaderUI = new MyBasicTableHeaderUI ( this ) ; setDefaultRenderer ( new EmptyTableCellRenderer ( ) ) ; setReorderingAllowed ( false ) ; }
idea4bsd/idea4bsd | @ Override public void setTable ( JTable table ) { JTable oldTable = getTable ( ) ; if ( oldTable != null ) { oldTable . removeMouseListener ( myHeaderUI ) ; oldTable . removeMouseMotionListener ( myHeaderUI ) ; } super . setTable ( table ) ; if ( table != null ) { table . addMouseListener ( myHeaderUI ) ; table . addMouseMotionListener ( myHeaderUI ) ; } }
idea4bsd/idea4bsd | @ Override public void setCursor ( @ Nullable Cursor cursor ) { JTable table = getTable ( ) ; if ( table != null ) { table . setCursor ( cursor ) ; myCursor = cursor ; } else { super . setCursor ( cursor ) ; } }
idea4bsd/idea4bsd | @ Override public Cursor getCursor ( ) { if ( myCursor == null ) { JTable table = getTable ( ) ; if ( table == null ) return super . getCursor ( ) ; return table . getCursor ( ) ; } return myCursor ; }
idea4bsd/idea4bsd | @ NotNull @ Override public Rectangle getHeaderRect ( int column ) { Rectangle headerRect = super . getHeaderRect ( column ) ; return new Rectangle ( headerRect . x , headerRect . y , headerRect . width , 1 ) ; }
idea4bsd/idea4bsd | @ NotNull @ Override public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . setMaximumSize ( new Dimension ( 0 , 0 ) ) ; return panel ; }
idea4bsd/idea4bsd | public MyBasicTableHeaderUI ( @ NotNull JTableHeader tableHeader ) { header = tableHeader ; mouseInputListener = createMouseInputListener ( ) ; }
idea4bsd/idea4bsd | @ NotNull private MouseEvent convertMouseEvent ( @ NotNull MouseEvent e ) { return new MouseEvent ( e . getComponent ( ) , e . getID ( ) , e . getWhen ( ) , e . getModifiers ( ) , e . getX ( ) , 0 , e . getXOnScreen ( ) , header . getY ( ) , e . getClickCount ( ) , e . isPopupTrigger ( ) , e . getButton ( ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseClicked ( @ NotNull MouseEvent e ) { }
idea4bsd/idea4bsd | @ Override public void mousePressed ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mousePressed ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseReleased ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mouseReleased ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseEntered ( @ NotNull MouseEvent e ) { }
idea4bsd/idea4bsd | @ Override public void mouseExited ( @ NotNull MouseEvent e ) { }
idea4bsd/idea4bsd | @ Override public void mouseDragged ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mouseDragged ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | @ Override public void mouseMoved ( @ NotNull MouseEvent e ) { if ( isOnBorder ( e ) ) return ; mouseInputListener . mouseMoved ( convertMouseEvent ( e ) ) ; }
idea4bsd/idea4bsd | public boolean isOnBorder ( @ NotNull MouseEvent e ) { return Math . abs ( header . getTable ( ) . getWidth ( ) - e . getPoint ( ) . x ) <= JBUI . scale ( 3 ) ; }
idea4bsd/idea4bsd | @ Override public void valueChanged ( ListSelectionEvent e ) { mySelection = null ; }
idea4bsd/idea4bsd | @ Override public void progressStarted ( ) { myText = getEmptyText ( ) . getText ( ) ; getEmptyText ( ) . setText ( " Loading ▁ History . . . " ) ; }
idea4bsd/idea4bsd | @ Override public void progressStopped ( ) { getEmptyText ( ) . setText ( myText ) ; }
uber/jaeger-client-java | @ Test public void testVersionGet ( ) { assertEquals ( " Version ▁ should ▁ be ▁ the ▁ same ▁ as ▁ the ▁ properties ▁ file " , JaegerTracer . getVersionFromProperties ( ) , Version . get ( ) ) ; assertNotEquals ( " The ▁ version ▁ from ▁ the ▁ tracer ▁ should ▁ not ▁ be ▁ the ▁ same ▁ string ▁ as ▁ Version . get ( ) " , new Configuration ( " testVersionGet " ) . getTracer ( ) . getVersion ( ) , Version . get ( ) ) ; }
CCI-MIT/XCoLab | public ProposalRatingWrapper ( org . xcolab . client . contest . pojo . wrapper . ProposalRatingWrapper proposalRating ) { this . proposalRating = proposalRating ; }
CCI-MIT/XCoLab | public ProposalRatingWrapper ( org . xcolab . client . contest . pojo . wrapper . ProposalRatingWrapper proposalRating , Long roundFactor ) { this . proposalRating = proposalRating ; this . roundFactor = roundFactor ; }
CCI-MIT/XCoLab | public ProposalRatingWrapper ( ) { }
CCI-MIT/XCoLab | public String getRatingValueName ( ) { IProposalRatingValue ratingValue = this . getRatingValue ( ) ; if ( ratingValue != null ) { return ratingValue . getName ( ) ; } else { return " " ; } }
CCI-MIT/XCoLab | public String getRatingTypeLabel ( ) { IProposalRatingType ratingType = this . getRatingType ( ) ; if ( ratingType != null ) { return ratingType . getLabel ( ) ; } else { return " " ; } }
CCI-MIT/XCoLab | public boolean getIsActive ( ) { IProposalRatingType ratingType = this . getRatingType ( ) ; if ( ratingType != null ) { return ratingType . isIsActive ( ) ; } else { return true ; } }
CCI-MIT/XCoLab | public Long getRatingTypeId ( ) { IProposalRatingType ratingType = this . getRatingType ( ) ; if ( ratingType != null ) { return ratingType . getId ( ) ; } else { return null ; } }
CCI-MIT/XCoLab | public IProposalRatingType getRatingType ( ) { IProposalRatingValue ratingValue = this . getRatingValue ( ) ; if ( ratingValue != null ) { if ( ratingType == null ) ratingType = StaticProposalContext . getProposalJudgeRatingClient ( ) . getProposalRatingType ( ratingValue . getRatingTypeId ( ) ) ; return ratingType ; } return null ; }
CCI-MIT/XCoLab | public IProposalRatingValue getRatingValue ( ) { if ( ratingValue == null ) if ( roundFactor == null ) { roundFactor = 1L ; } ratingValue = StaticProposalContext . getProposalJudgeRatingClient ( ) . getProposalRatingValue ( this . proposalRating . getRatingValueId ( ) / roundFactor ) ; return ratingValue ; }
CCI-MIT/XCoLab | public double getNotRoundedRatingValue ( ) { double ratingValueNotRounded = 0. ; try { if ( roundFactor == null ) { roundFactor = 1L ; } ratingValueNotRounded = ( double ) this . proposalRating . getRatingValueId ( ) / ( double ) roundFactor ; ratingValueNotRounded = ratingValueNotRounded / getRatingTypeId ( ) ; } catch ( Exception e ) { } return ratingValueNotRounded ; }
CCI-MIT/XCoLab | public String getNotRoundedRatingValueFormatted ( ) { DecimalFormat f = new DecimalFormat ( " # 0.0" ) ; return f . format ( getNotRoundedRatingValue ( ) ) ; }
CCI-MIT/XCoLab | public double getRatingValueInPercent ( ) { double ratingValueInPercent = 0 ; Double proposalRatingValue = getNotRoundedRatingValue ( ) ; if ( proposalRatingValue != null ) { ratingValueInPercent = proposalRatingValue / 5.0 * 100.0 ; } return ratingValueInPercent ; }
CCI-MIT/XCoLab | public org . xcolab . client . contest . pojo . wrapper . ProposalRatingWrapper unwrap ( ) { return proposalRating ; }
CCI-MIT/XCoLab | public void setRatingValueId ( Long id ) { this . proposalRating . setRatingValueId ( id ) ; }
apache/jena | protected Tuple5 ( X x1 , X x2 , X x3 , X x4 , X x5 ) { this . x1 = x1 ; this . x2 = x2 ; this . x3 = x3 ; this . x4 = x4 ; this . x5 = x5 ; }
apache/jena | @ Override public final X get ( int i ) { switch ( i ) { case 0 : return x1 ; case 1 : return x2 ; case 2 : return x3 ; case 3 : return x4 ; case 4 : return x5 ; } throw new IndexOutOfBoundsException ( ) ; }
apache/jena | @ Override public final int len ( ) { return 5 ; }
apache/jena | @ Override public < Y > Tuple < Y > map ( Function < X , Y > function ) { return new Tuple5 < > ( function . apply ( x1 ) , function . apply ( x2 ) , function . apply ( x3 ) , function . apply ( x4 ) , function . apply ( x5 ) ) ; }
apache/jena | @ Override public boolean contains ( X item ) { if ( Objects . equals ( x1 , item ) ) return true ; if ( Objects . equals ( x2 , item ) ) return true ; if ( Objects . equals ( x3 , item ) ) return true ; if ( Objects . equals ( x4 , item ) ) return true ; if ( Objects . equals ( x5 , item ) ) return true ; return false ; }
daiqiquan/framework-base | public boolean protect ( int socket ) { return NetworkUtils . protectFromVpn ( socket ) ; }
daiqiquan/framework-base | public boolean protect ( Socket socket ) { return protect ( socket . getFileDescriptor$ ( ) . getInt$ ( ) ) ; }
daiqiquan/framework-base | public boolean protect ( DatagramSocket socket ) { return protect ( socket . getFileDescriptor$ ( ) . getInt$ ( ) ) ; }
daiqiquan/framework-base | public boolean addAddress ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; try { return getService ( ) . addVpnAddress ( address . getHostAddress ( ) , prefixLength ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
daiqiquan/framework-base | public boolean removeAddress ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; try { return getService ( ) . removeVpnAddress ( address . getHostAddress ( ) , prefixLength ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
daiqiquan/framework-base | public boolean setUnderlyingNetworks ( Network [ ] networks ) { try { return getService ( ) . setUnderlyingNetworksForVpn ( networks ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
daiqiquan/framework-base | @ Override public IBinder onBind ( Intent intent ) { if ( intent != null && SERVICE_INTERFACE . equals ( intent . getAction ( ) ) ) { return new Callback ( ) ; } return null ; }
daiqiquan/framework-base | public void onRevoke ( ) { stopSelf ( ) ; }
daiqiquan/framework-base | @ Override protected boolean onTransact ( int code , Parcel data , Parcel reply , int flags ) { if ( code == IBinder . LAST_CALL_TRANSACTION ) { onRevoke ( ) ; return true ; } return false ; }
daiqiquan/framework-base | public Builder ( ) { mConfig . user = VpnService . this . getClass ( ) . getName ( ) ; }
daiqiquan/framework-base | public Builder setSession ( String session ) { mConfig . session = session ; return this ; }
daiqiquan/framework-base | public Builder setConfigureIntent ( PendingIntent intent ) { mConfig . configureIntent = intent ; return this ; }
daiqiquan/framework-base | public Builder setMtu ( int mtu ) { if ( mtu <= 0 ) { throw new IllegalArgumentException ( " Bad ▁ mtu " ) ; } mConfig . mtu = mtu ; return this ; }
daiqiquan/framework-base | public Builder addAddress ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; if ( address . isAnyLocalAddress ( ) ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } mAddresses . add ( new LinkAddress ( address , prefixLength ) ) ; mConfig . updateAllowedFamilies ( address ) ; return this ; }
daiqiquan/framework-base | public Builder addAddress ( String address , int prefixLength ) { return addAddress ( InetAddress . parseNumericAddress ( address ) , prefixLength ) ; }
daiqiquan/framework-base | public Builder addRoute ( InetAddress address , int prefixLength ) { check ( address , prefixLength ) ; int offset = prefixLength / 8 ; byte [ ] bytes = address . getAddress ( ) ; if ( offset < bytes . length ) { for ( bytes [ offset ] <<= prefixLength % 8 ; offset < bytes . length ; ++ offset ) { if ( bytes [ offset ] != 0 ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } } } mRoutes . add ( new RouteInfo ( new IpPrefix ( address , prefixLength ) , null ) ) ; mConfig . updateAllowedFamilies ( address ) ; return this ; }
daiqiquan/framework-base | public Builder addRoute ( String address , int prefixLength ) { return addRoute ( InetAddress . parseNumericAddress ( address ) , prefixLength ) ; }
daiqiquan/framework-base | public Builder addDnsServer ( InetAddress address ) { if ( address . isLoopbackAddress ( ) || address . isAnyLocalAddress ( ) ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } if ( mConfig . dnsServers == null ) { mConfig . dnsServers = new ArrayList < String > ( ) ; } mConfig . dnsServers . add ( address . getHostAddress ( ) ) ; return this ; }
daiqiquan/framework-base | public Builder addDnsServer ( String address ) { return addDnsServer ( InetAddress . parseNumericAddress ( address ) ) ; }
daiqiquan/framework-base | public Builder addSearchDomain ( String domain ) { if ( mConfig . searchDomains == null ) { mConfig . searchDomains = new ArrayList < String > ( ) ; } mConfig . searchDomains . add ( domain ) ; return this ; }
daiqiquan/framework-base | public Builder allowFamily ( int family ) { if ( family == AF_INET ) { mConfig . allowIPv4 = true ; } else if ( family == AF_INET6 ) { mConfig . allowIPv6 = true ; } else { throw new IllegalArgumentException ( family + " ▁ is ▁ neither ▁ " + AF_INET + " ▁ nor ▁ " + AF_INET6 ) ; } return this ; }
daiqiquan/framework-base | catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; }
daiqiquan/framework-base | if ( mConfig . disallowedApplications != null ) { throw new UnsupportedOperationException ( " addDisallowedApplication ▁ already ▁ called " ) ; }
daiqiquan/framework-base | if ( mConfig . allowedApplications == null ) { mConfig . allowedApplications = new ArrayList < String > ( ) ; }
daiqiquan/framework-base | if ( mConfig . allowedApplications != null ) { throw new UnsupportedOperationException ( " addAllowedApplication ▁ already ▁ called " ) ; }
daiqiquan/framework-base | if ( mConfig . disallowedApplications == null ) { mConfig . disallowedApplications = new ArrayList < String > ( ) ; }
daiqiquan/framework-base | public Builder allowBypass ( ) { mConfig . allowBypass = true ; return this ; }
daiqiquan/framework-base | public Builder setBlocking ( boolean blocking ) { mConfig . blocking = blocking ; return this ; }
daiqiquan/framework-base | public Builder setUnderlyingNetworks ( Network [ ] networks ) { mConfig . underlyingNetworks = networks != null ? networks . clone ( ) : null ; return this ; }
daiqiquan/framework-base | public ParcelFileDescriptor establish ( ) { mConfig . addresses = mAddresses ; mConfig . routes = mRoutes ; try { return getService ( ) . establishVpn ( mConfig ) ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }
selenareneephillips/brixen | @ Override public boolean getClickWithJavascript ( ) { return clickWithJavascript ; }
Syncleus/AetherMUD | public InventoryCommand ( GameManager gameManager ) { super ( gameManager , validTriggers , description , correctUsage ) ; }
Syncleus/AetherMUD | @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { this . execCommand ( ctx , e , ( ) -> { List < ItemInstance > inventory = player . getInventory ( ) ; if ( inventory == null ) { write ( " You ▁ aren ' t ▁ carrying ▁ anything . " ) ; return ; } StringBuilder inventoryString = new StringBuilder ( ) ; inventoryString . append ( " You ▁ are ▁ carrying : \r \n " ) ; inventoryString . append ( RESET ) ; String join = StringUtils . join ( player . getRolledUpIntentory ( ) . toArray ( ) , " \r \n " ) ; inventoryString . append ( join ) ; write ( inventoryString . toString ( ) ) ; } ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldSucceedWithName ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " fileHierarchy " ) ; thenAssertionIsSucceeded ( ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldFailWithDifferentName ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " fileHierarchy1" ) ; thenAssertionIsFailed ( ) . hasMessage ( String . format ( " \n Expecting : \n ▁ < % s > \n to ▁ have : \n ▁ < file ▁ name : ▁ fileHierarchy1 > " , preparePath ( ) ) ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldSucceedWithRegexInAssert ( ) { givenFileHierarchyAssert ( NameMatcherType . REGEX ) ; whenHasRootDirWithName ( " f . l [ eE ] Hierar . + " ) ; thenAssertionIsSucceeded ( ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldFailWithUnmatchingRegexInAssert ( ) { givenFileHierarchyAssert ( NameMatcherType . REGEX ) ; whenHasRootDirWithName ( " f . l [ eE ] Hirar . + " ) ; thenAssertionIsFailed ( ) . hasMessage ( String . format ( " \n Expecting : \n ▁ < % s > \n to ▁ have : \n ▁ < file ▁ name : ▁ f . l [ eE ] Hirar . + > " , preparePath ( ) ) ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldSucceedWithRegexInMethod ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " f . l [ eE ] Hierar . + " , NameMatcherType . REGEX ) ; thenAssertionIsSucceeded ( ) ; }
pkk82/file-hierarchy-assert | @ Test public void shouldFailWithUnmatchingRegexInMethod ( ) { givenFileHierarchyAssert ( ) ; whenHasRootDirWithName ( " f . l [ eE ] Hirar . + " , NameMatcherType . REGEX ) ; thenAssertionIsFailed ( ) . hasMessage ( String . format ( " \n Expecting : \n ▁ < % s > \n to ▁ have : \n ▁ < file ▁ name : ▁ f . l [ eE ] Hirar . + > " , preparePath ( ) ) ) ; }
pkk82/file-hierarchy-assert | private void whenHasRootDirWithName ( String rootDirName ) { try { fileHierarchyAssert . hasRootDirWithName ( rootDirName ) ; } catch ( AssertionError e ) { handleAssertionError ( e ) ; } }
pkk82/file-hierarchy-assert | private void whenHasRootDirWithName ( String rootDirName , NameMatcherType nameMatcherType ) { try { fileHierarchyAssert . hasRootDirWithName ( rootDirName , nameMatcherType ) ; } catch ( AssertionError e ) { handleAssertionError ( e ) ; } }
aaronwalker/camel | public ResourceBasedEndpoint ( ) { }
aaronwalker/camel | public ResourceBasedEndpoint ( String endpointUri , Component component , String resourceUri , Processor processor ) { super ( endpointUri , component , processor ) ; this . resourceUri = resourceUri ; if ( component instanceof ResourceBasedComponent ) { this . resourceLoader = ( ( ResourceBasedComponent ) component ) . getResourceLoader ( ) ; } }
aaronwalker/camel | protected ResourceBasedEndpoint ( String endpointUri , Processor processor , String resourceUri ) { super ( endpointUri , processor ) ; this . resourceUri = resourceUri ; }
aaronwalker/camel | public Resource getResource ( ) { if ( resource == null ) { log . debug ( " Loading ▁ resource : ▁ { } ▁ using : ▁ { } " , resourceUri , getResourceLoader ( ) ) ; resource = getResourceLoader ( ) . getResource ( resourceUri ) ; if ( resource == null ) { throw new IllegalArgumentException ( " Could ▁ not ▁ find ▁ resource ▁ for ▁ URI : ▁ " + resourceUri + " ▁ using : ▁ " + getResourceLoader ( ) ) ; } } return resource ; }
aaronwalker/camel | public InputStream getResourceAsInputStream ( ) throws IOException { if ( resource == null ) { resource = getResource ( ) ; } InputStream is = null ; if ( contentCache ) { synchronized ( resource ) { if ( buffer == null ) { log . debug ( " Reading ▁ resource : ▁ { } ▁ into ▁ the ▁ content ▁ cache " , resourceUri ) ; is = getResourceAsInputStreamWithoutCache ( ) ; buffer = IOConverter . toBytes ( is ) ; } } log . debug ( " Using ▁ resource : ▁ { } ▁ from ▁ the ▁ content ▁ cache " , resourceUri ) ; return new ByteArrayInputStream ( buffer ) ; } return getResourceAsInputStreamWithoutCache ( ) ; }
aaronwalker/camel | protected InputStream getResourceAsInputStreamWithoutCache ( ) throws IOException { InputStream result ; try { result = resource . getInputStream ( ) ; } catch ( IOException exception ) { result = getCamelContext ( ) . getClassResolver ( ) . loadResourceAsStream ( resourceUri ) ; if ( result == null ) { log . warn ( " Cannot ▁ get ▁ the ▁ resource : ▁ " + resourceUri + " from ▁ the ▁ camelContext ▁ ClassResolver " ) ; throw exception ; } } return result ; }
aaronwalker/camel | public boolean isContentCache ( ) { return contentCache ; }
aaronwalker/camel | public void setContentCache ( boolean contentCache ) { this . contentCache = contentCache ; }
aaronwalker/camel | public ResourceLoader getResourceLoader ( ) { if ( resourceLoader == null ) { resourceLoader = new CamelResourceLoader ( getCamelContext ( ) ) ; } return resourceLoader ; }
aaronwalker/camel | public void setResourceLoader ( ResourceLoader resourceLoader ) { this . resourceLoader = resourceLoader ; }
aaronwalker/camel | public String getResourceUri ( ) { return resourceUri ; }
aaronwalker/camel | public void setResourceUri ( String resourceUri ) { this . resourceUri = resourceUri ; }
StefanLiebenberg/throwable-interfaces | @ Test ( expected = CustomException . class ) public void testUnwrap ( ) throws CustomException { CustomException expected = new CustomException ( ) ; SuppressedException . unwrapSuppressedException ( ( ) -> { return castToDoubleFunctionWithThrowable ( ( v1 ) -> { throw expected ; } ) . applyAsDouble ( null ) ; } , CustomException . class ) ; }
apache/ant-ivy | @ Test public void testComparator ( ) { ArtifactInfo [ ] revs = toMockAI ( new String [ ] { "0.2.0 . a " , "0.2.0 . b " , "0.2.0 . final " , "1.0" , "1.0.0 . gamma " , "1.0.0 . rc1" , "1.0.0 . rc2" , "1.0.1" , "2" , "2.0.0 . b006" , "2.0.0 . b012" , "2.0.0 . xyz " } ) ; List < ArtifactInfo > shuffled = new ArrayList < > ( Arrays . asList ( revs ) ) ; Collections . shuffle ( shuffled ) ; Collections . sort ( shuffled , new OsgiLatestStrategy ( ) . new ArtifactInfoComparator ( ) ) ; assertEquals ( Arrays . asList ( revs ) , shuffled ) ; }
apache/ant-ivy | @ Test public void testSort ( ) { ArtifactInfo [ ] revs = toMockAI ( new String [ ] { "0.2.0 . a " , "0.2.0 . b " , "0.2.0 . final " , "1.0" , "1.0.0 . gamma " , "1.0.0 . rc1" , "1.0.0 . rc2" , "1.0.1" , "2" , "2.0.0 . b006" , "2.0.0 . b012" , "2.0.0 . xyz " } ) ; List < ArtifactInfo > shuffled = new ArrayList < > ( Arrays . asList ( revs ) ) ; ArtifactInfo [ ] shuffledRevs = shuffled . toArray ( new ArtifactInfo [ revs . length ] ) ; OsgiLatestStrategy latestRevisionStrategy = new OsgiLatestStrategy ( ) ; List < ArtifactInfo > sorted = latestRevisionStrategy . sort ( shuffledRevs ) ; assertEquals ( Arrays . asList ( revs ) , sorted ) ; }
apache/ant-ivy | @ Test public void testFindLatest ( ) { ArtifactInfo [ ] revs = toMockAI ( new String [ ] { "0.2.0 . a " , "0.2.0 . b " , "0.2.0 . rc1" , "0.2.0 . final " , "1.0.0 . dev1" , "1.0.0 . dev2" , "1.0.0 . alpha1" , "1.0.0 . alpha2" , "1.0.0 . beta1" , "1.0.0 . beta2" , "1.0.0 . gamma " , "1.0.0 . rc1" , "1.0.0 . rc2" , "1.0" , "1.0.1" , "2.0" } ) ; List < ArtifactInfo > shuffled = new ArrayList < > ( Arrays . asList ( revs ) ) ; Collections . shuffle ( shuffled ) ; ArtifactInfo [ ] shuffledRevs = shuffled . toArray ( new ArtifactInfo [ revs . length ] ) ; OsgiLatestStrategy latestRevisionStrategy = new OsgiLatestStrategy ( ) ; ArtifactInfo latest = latestRevisionStrategy . findLatest ( shuffledRevs , new Date ( ) ) ; assertNotNull ( latest ) ; assertEquals ( "2.0" , latest . getRevision ( ) ) ; }
apache/ant-ivy | public MockArtifactInfo ( String rev , long lastModified ) { this . rev = rev ; this . lastModified = lastModified ; }
apache/ant-ivy | public String getRevision ( ) { return rev ; }
apache/ant-ivy | public long getLastModified ( ) { return lastModified ; }
apache/ant-ivy | public String toString ( ) { return rev ; }
apache/ant-ivy | private ArtifactInfo [ ] toMockAI ( String [ ] revs ) { List < ArtifactInfo > artifactInfos = new ArrayList < > ( ) ; for ( String rev : revs ) { artifactInfos . add ( new MockArtifactInfo ( rev , 0 ) ) ; } return artifactInfos . toArray ( new ArtifactInfo [ artifactInfos . size ( ) ] ) ; }
dagnir/aws-sdk-java | public void setType ( String type ) { this . type = type ; }
dagnir/aws-sdk-java | public String getType ( ) { return this . type ; }
dagnir/aws-sdk-java | public BatchReadException withType ( String type ) { setType ( type ) ; return this ; }
dagnir/aws-sdk-java | public void setType ( BatchReadExceptionType type ) { this . type = type . toString ( ) ; }
dagnir/aws-sdk-java | public BatchReadException withType ( BatchReadExceptionType type ) { setType ( type ) ; return this ; }
dagnir/aws-sdk-java | public void setMessage ( String message ) { this . message = message ; }
dagnir/aws-sdk-java | public String getMessage ( ) { return this . message ; }
dagnir/aws-sdk-java | public BatchReadException withMessage ( String message ) { setMessage ( message ) ; return this ; }
dagnir/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getType ( ) != null ) sb . append ( " Type : ▁ " ) . append ( getType ( ) ) . append ( " , " ) ; if ( getMessage ( ) != null ) sb . append ( " Message : ▁ " ) . append ( getMessage ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
dagnir/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof BatchReadException == false ) return false ; BatchReadException other = ( BatchReadException ) obj ; if ( other . getType ( ) == null ^ this . getType ( ) == null ) return false ; if ( other . getType ( ) != null && other . getType ( ) . equals ( this . getType ( ) ) == false ) return false ; if ( other . getMessage ( ) == null ^ this . getMessage ( ) == null ) return false ; if ( other . getMessage ( ) != null && other . getMessage ( ) . equals ( this . getMessage ( ) ) == false ) return false ; return true ; }
dagnir/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getType ( ) == null ) ? 0 : getType ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMessage ( ) == null ) ? 0 : getMessage ( ) . hashCode ( ) ) ; return hashCode ; }
dagnir/aws-sdk-java | @ Override public BatchReadException clone ( ) { try { return ( BatchReadException ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
dagnir/aws-sdk-java | @ com . amazonaws . annotation . SdkInternalApi @ Override public void marshall ( ProtocolMarshaller protocolMarshaller ) { com . amazonaws . services . clouddirectory . model . transform . BatchReadExceptionMarshaller . getInstance ( ) . marshall ( this , protocolMarshaller ) ; }
1245816264/android-ndk | private int nextPOT ( int i ) { int pot = 1 ; while ( pot < i ) pot <<= 1 ; return pot ; }
1245816264/android-ndk | private Bitmap scaleBitmap ( Bitmap bitmapToScale , float newWidth , float newHeight ) { if ( bitmapToScale == null ) return null ; int width = bitmapToScale . getWidth ( ) ; int height = bitmapToScale . getHeight ( ) ; Matrix matrix = new Matrix ( ) ; matrix . postScale ( newWidth / width , newHeight / height ) ; return Bitmap . createBitmap ( bitmapToScale , 0 , 0 , bitmapToScale . getWidth ( ) , bitmapToScale . getHeight ( ) , matrix , true ) ; }
1245816264/android-ndk | public boolean loadTexture ( String path ) { Bitmap bitmap = null ; try { String str = path ; if ( ! path . startsWith ( " / " ) ) { str = " / " + path ; } File file = new File ( context . getExternalFilesDir ( null ) , str ) ; if ( file . canRead ( ) ) { bitmap = BitmapFactory . decodeStream ( new FileInputStream ( file ) ) ; } else { bitmap = BitmapFactory . decodeStream ( context . getResources ( ) . getAssets ( ) . open ( path ) ) ; } } catch ( Exception e ) { Log . w ( " NDKHelper " , " Coundn ' t ▁ load ▁ a ▁ file : " + path ) ; return false ; } if ( bitmap != null ) { GLUtils . texImage2D ( GL10 . GL_TEXTURE_2D , 0 , bitmap , 0 ) ; } return true ; }
1245816264/android-ndk | public Bitmap openBitmap ( String path , boolean iScalePOT ) { Bitmap bitmap = null ; try { bitmap = BitmapFactory . decodeStream ( context . getResources ( ) . getAssets ( ) . open ( path ) ) ; if ( iScalePOT ) { int originalWidth = getBitmapWidth ( bitmap ) ; int originalHeight = getBitmapHeight ( bitmap ) ; int width = nextPOT ( originalWidth ) ; int height = nextPOT ( originalHeight ) ; if ( originalWidth != width || originalHeight != height ) { bitmap = scaleBitmap ( bitmap , width , height ) ; } } } catch ( Exception e ) { Log . w ( " NDKHelper " , " Coundn ' t ▁ load ▁ a ▁ file : " + path ) ; } return bitmap ; }
1245816264/android-ndk | public int getBitmapWidth ( Bitmap bmp ) { return bmp . getWidth ( ) ; }
1245816264/android-ndk | public int getBitmapHeight ( Bitmap bmp ) { return bmp . getHeight ( ) ; }
1245816264/android-ndk | public void getBitmapPixels ( Bitmap bmp , int [ ] pixels ) { int w = bmp . getWidth ( ) ; int h = bmp . getHeight ( ) ; bmp . getPixels ( pixels , 0 , w , 0 , 0 , w , h ) ; }
1245816264/android-ndk | public void closeBitmap ( Bitmap bmp ) { bmp . recycle ( ) ; }
1245816264/android-ndk | @ TargetApi ( 17 ) public int getNativeAudioBufferSize ( ) { int SDK_INT = android . os . Build . VERSION . SDK_INT ; if ( SDK_INT >= 17 ) { AudioManager am = ( AudioManager ) context . getSystemService ( Context . AUDIO_SERVICE ) ; String framesPerBuffer = am . getProperty ( AudioManager . PROPERTY_OUTPUT_FRAMES_PER_BUFFER ) ; return Integer . parseInt ( framesPerBuffer ) ; } else { return 0 ; } }
1245816264/android-ndk | public int getNativeAudioSampleRate ( ) { return AudioTrack . getNativeOutputSampleRate ( AudioManager . STREAM_SYSTEM ) ; }
GunoH/intellij-community | @ Override @ NotNull protected String buildErrorString ( Object ... infos ) { return InspectionGadgetsBundle . message ( " instanceof . catch . parameter . problem . descriptor " ) ; }
GunoH/intellij-community | @ Override public BaseInspectionVisitor buildVisitor ( ) { return new InstanceofCatchParameterVisitor ( ) ; }
GunoH/intellij-community | @ Override public void visitInstanceOfExpression ( @ NotNull PsiInstanceOfExpression exp ) { super . visitInstanceOfExpression ( exp ) ; if ( ! ControlFlowUtils . isInCatchBlock ( exp ) ) { return ; } PsiTypeElement typeElement = exp . getCheckType ( ) ; if ( typeElement == null || ! InheritanceUtil . isInheritor ( typeElement . getType ( ) , CommonClassNames . JAVA_LANG_THROWABLE ) ) { return ; } final PsiExpression operand = PsiUtil . skipParenthesizedExprDown ( exp . getOperand ( ) ) ; if ( ! ( operand instanceof PsiReferenceExpression ) ) { return ; } final PsiReferenceExpression ref = ( PsiReferenceExpression ) operand ; final PsiElement referent = ref . resolve ( ) ; if ( ! ( referent instanceof PsiParameter ) ) { return ; } final PsiParameter parameter = ( PsiParameter ) referent ; if ( ! ( parameter . getDeclarationScope ( ) instanceof PsiCatchSection ) ) { return ; } registerError ( operand ) ; }
googleapis/google-api-java-client-services | public java . lang . String getDescription ( ) { return description ; }
googleapis/google-api-java-client-services | public GoogleCloudVideointelligenceV1p3beta1Entity setDescription ( java . lang . String description ) { this . description = description ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getEntityId ( ) { return entityId ; }
googleapis/google-api-java-client-services | public GoogleCloudVideointelligenceV1p3beta1Entity setEntityId ( java . lang . String entityId ) { this . entityId = entityId ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getLanguageCode ( ) { return languageCode ; }
googleapis/google-api-java-client-services | public GoogleCloudVideointelligenceV1p3beta1Entity setLanguageCode ( java . lang . String languageCode ) { this . languageCode = languageCode ; return this ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudVideointelligenceV1p3beta1Entity set ( String fieldName , Object value ) { return ( GoogleCloudVideointelligenceV1p3beta1Entity ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public GoogleCloudVideointelligenceV1p3beta1Entity clone ( ) { return ( GoogleCloudVideointelligenceV1p3beta1Entity ) super . clone ( ) ; }
mgraf1/gol | public GOLPannel ( int w , int h ) { width = w ; height = h ; d = new VDataArray ( width , height ) ; }
mgraf1/gol | public void runSim ( final int steps ) { final GOLPannel gp = this ; Thread r = new Thread ( ) { public void run ( ) { d . run ( steps , gp ) ; } } ; r . start ( ) ; try { r . join ( ) ; } catch ( InterruptedException e ) { System . exit ( 1 ) ; } System . exit ( 0 ) ; }
mgraf1/gol | public void drawBoard ( Graphics g ) { boolean [ ] [ ] grid = d . getGrid ( ) ; for ( int j = 0 ; j < height ; j ++ ) { for ( int i = 0 ; i < width ; i ++ ) { if ( grid [ j ] [ i ] ) { g . setColor ( Color . black ) ; g . drawRect ( i , j , 1 , 1 ) ; } else { g . setColor ( Color . white ) ; g . drawRect ( i , j , 1 , 1 ) ; } } } }
mgraf1/gol | public Dimension getPreferredSize ( ) { return new Dimension ( width , height ) ; }
mgraf1/gol | public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; drawBoard ( g ) ; }
mgraf1/gol | public void update ( Graphics g ) { drawBoard ( g ) ; }
seriousbusinessbe/XMLModifier | public DocumentException ( final String message ) { super ( message ) ; }
apache/incubator-taverna-common-activities | public InteractionActivity ( final CredentialManager credentialManager , final InteractionRecorder interactionRecorder , final InteractionUtils interactionUtils , final InteractionJetty interactionJetty , final InteractionPreference interactionPreference , final ResponseFeedListener responseFeedListener , final InteractionVelocity interactionVelocity ) { this . credentialManager = credentialManager ; this . interactionRecorder = interactionRecorder ; this . interactionUtils = interactionUtils ; this . interactionJetty = interactionJetty ; this . interactionPreference = interactionPreference ; this . responseFeedListener = responseFeedListener ; this . interactionVelocity = interactionVelocity ; this . json = null ; }
apache/incubator-taverna-common-activities | @ Override public void configure ( final JsonNode json ) throws ActivityConfigurationException { this . json = json ; }
apache/incubator-taverna-common-activities | @ Override public void executeAsynch ( final Map < String , T2Reference > inputs , final AsynchronousActivityCallback callback ) { final InteractionRequestor requestor = new InteractionCallbackRequestor ( this , callback , inputs ) ; callback . requestRun ( new InteractionActivityRunnable ( requestor , this . presentationTemplate , this . credentialManager , this . interactionRecorder , this . interactionUtils , this . interactionJetty , this . interactionPreference , this . responseFeedListener , this . interactionVelocity ) ) ; }
apache/incubator-taverna-common-activities | @ Override public JsonNode getConfiguration ( ) { return this . json ; }
apache/incubator-taverna-common-activities | public ActivityInputPort getInputPort ( final String name ) { for ( final ActivityInputPort port : this . getInputPorts ( ) ) { if ( port . getName ( ) . equals ( name ) ) { return port ; } } return null ; }
apache/incubator-taverna-common-activities | InteractionActivityType getInteractionActivityType ( ) { JsonNode subNode = json . get ( " interactivityActivityType " ) ; if ( subNode == null ) { return InteractionActivityType . LocallyPresentedHtml ; } String textValue = subNode . textValue ( ) ; if ( textValue == null ) { return InteractionActivityType . LocallyPresentedHtml ; } if ( " VelocityTemplate " . equals ( textValue ) ) { return InteractionActivityType . VelocityTemplate ; } return InteractionActivityType . LocallyPresentedHtml ; }
apache/incubator-taverna-common-activities | String getPresentationOrigin ( ) { JsonNode subNode = json . get ( " presentationOrigin " ) ; if ( subNode == null ) { return null ; } String textValue = subNode . textValue ( ) ; if ( textValue == null ) { return null ; } return textValue ; }
apache/incubator-taverna-common-activities | public boolean isProgressNotification ( ) { JsonNode subNode = json . get ( " progressNotification " ) ; if ( subNode == null ) { return false ; } return subNode . booleanValue ( ) ; }
triathematician/blaisemath | public NodeInGraph ( E node , @ Nullable Graph < E > graph ) { this . node = requireNonNull ( node ) ; this . graph = graph ; checkArgument ( graph == null || graph . nodes ( ) . contains ( node ) ) ; }
triathematician/blaisemath | public E getNode ( ) { return node ; }
triathematician/blaisemath | public @ Nullable Graph < E > getGraph ( ) { return graph ; }
StephanEwen/incubator-flink | @ Before public void before ( ) { this . streamSettings = EnvironmentSettings . inStreamingMode ( ) ; this . batchSettings = EnvironmentSettings . inBatchMode ( ) ; }
micmiu/bigdata-tutorial | private SimpleHiveConnManager ( ) { init ( ) ; }
micmiu/bigdata-tutorial | public void freeConnection ( String name , Connection con ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { pool . freeConnection ( con ) ; } }
micmiu/bigdata-tutorial | public Connection getConnection ( String name ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { return pool . getConnection ( ) ; } return null ; }
micmiu/bigdata-tutorial | public Connection getConnection ( String name , long time ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { return pool . getConnection ( time ) ; } return null ; }
micmiu/bigdata-tutorial | public synchronized void release ( ) { if ( -- clients != 0 ) { return ; } Enumeration allPools = pools . elements ( ) ; while ( allPools . hasMoreElements ( ) ) { ConnPool pool = ( ConnPool ) allPools . nextElement ( ) ; pool . release ( ) ; } Enumeration allDrivers = drivers . elements ( ) ; while ( allDrivers . hasMoreElements ( ) ) { Driver driver = ( Driver ) allDrivers . nextElement ( ) ; try { DriverManager . deregisterDriver ( driver ) ; log ( " 撤销JDBC驱动程序 ▁ " + driver . getClass ( ) . getName ( ) + " 的注册 " ) ; } catch ( SQLException e ) { log ( e , " 无法撤销下列JDBC驱动程序的注册 : ▁ " + driver . getClass ( ) . getName ( ) ) ; } } }
micmiu/bigdata-tutorial | private void createPools ( Properties props ) { Enumeration propNames = props . propertyNames ( ) ; while ( propNames . hasMoreElements ( ) ) { String name = ( String ) propNames . nextElement ( ) ; if ( name . endsWith ( " . url " ) ) { String poolName = name . substring ( 0 , name . lastIndexOf ( " . " ) ) ; String url = props . getProperty ( poolName + " . url " ) ; if ( url == null ) { log ( " 没有为连接池 " + poolName + " 指定URL " ) ; continue ; } String user = props . getProperty ( poolName + " . user " ) ; String password = props . getProperty ( poolName + " . password " ) ; String maxconn = props . getProperty ( poolName + " . maxconn " , "0" ) ; String minconn = props . getProperty ( poolName + " . minConns " , "0" ) ; String strloginterval = props . getProperty ( poolName + " . logInterval " , "0" ) ; int max ; int min ; long logInterval = Long . parseLong ( strloginterval ) ; try { max = Integer . valueOf ( maxconn ) . intValue ( ) ; } catch ( NumberFormatException e ) { log ( " 错误的最大连接数限制 : ▁ " + maxconn + " ▁ . 连接池 : ▁ " + poolName ) ; max = 0 ; } try { min = Integer . valueOf ( minconn ) . intValue ( ) ; } catch ( NumberFormatException e ) { log ( " 错误的最小连接数限制 : ▁ " + minconn + " ▁ . 连接池 : ▁ " + poolName ) ; min = 0 ; } ConnPool pool = new ConnPool ( poolName , url , user , password , max , min , logInterval ) ; pools . put ( poolName , pool ) ; log ( " 成功创建连接池 " + poolName ) ; } } }
micmiu/bigdata-tutorial | private void init ( ) { InputStream is = getClass ( ) . getResourceAsStream ( CONF_FILE_NAME ) ; Properties dbProps = new Properties ( ) ; try { dbProps . load ( is ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( " 不能读取属性文件 . ▁ " + " 请确保db . properties在CLASSPATH指定的路径中 " ) ; return ; } String logFile = dbProps . getProperty ( " logfile " , " DBConnectionManager . log " ) ; try { log = new PrintWriter ( new FileWriter ( logFile , true ) , true ) ; } catch ( IOException e ) { System . err . println ( " 无法打开日志文件 : ▁ " + logFile ) ; log = new PrintWriter ( System . err ) ; } loadDrivers ( dbProps ) ; createPools ( dbProps ) ; }
micmiu/bigdata-tutorial | private void loadDrivers ( Properties props ) { String driverClasses = props . getProperty ( " drivers " ) ; StringTokenizer st = new StringTokenizer ( driverClasses ) ; while ( st . hasMoreElements ( ) ) { String driverClassName = st . nextToken ( ) . trim ( ) ; try { Driver driver = ( Driver ) Class . forName ( driverClassName ) . newInstance ( ) ; DriverManager . registerDriver ( driver ) ; drivers . addElement ( driver ) ; log ( " 成功注册JDBC驱动程序 " + driverClassName ) ; } catch ( Exception e ) { log ( " 无法注册JDBC驱动程序 : ▁ " + driverClassName + " , ▁ 错误 : ▁ " + e ) ; } } }
micmiu/bigdata-tutorial | private void log ( String msg ) { log . println ( new Date ( ) + " : ▁ " + msg ) ; }
micmiu/bigdata-tutorial | private void log ( Throwable e , String msg ) { log . println ( new Date ( ) + " : ▁ " + msg ) ; e . printStackTrace ( log ) ; }
micmiu/bigdata-tutorial | public ConnPool ( String name , String URL , String user , String password , int maxConn , int minConn , long logInterval ) { this . name = name ; this . URL = URL ; this . user = user ; this . password = password ; this . maxConn = maxConn ; this . minConn = minConn ; this . logInterval = logInterval ; for ( int i = 0 ; i < minConn ; i ++ ) { Connection initConn = createNewConnection ( ) ; freeConnections . addElement ( initConn ) ; } logTimer = System . currentTimeMillis ( ) ; poolMonitor = new Thread ( new Runnable ( ) { public void run ( ) { monitor ( ) ; } } ) ; poolMonitor . start ( ) ; }
micmiu/bigdata-tutorial | private void monitor ( ) { while ( true ) { if ( ( System . currentTimeMillis ( ) - logTimer ) > logInterval ) { Enumeration checkconn = freeConnections . elements ( ) ; while ( checkconn . hasMoreElements ( ) ) { Connection con = ( Connection ) checkconn . nextElement ( ) ; try { if ( con == null || con . isClosed ( ) ) { freeConnections . removeElement ( con ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } else if ( freeConnections . size ( ) > minConn ) { con . close ( ) ; freeConnections . removeElement ( con ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } } catch ( SQLException e ) { System . out . println ( " momitor ▁ 出错 ！ " ) ; } } while ( freeConnections . size ( ) < minConn ) { Connection con = createNewConnection ( ) ; freeConnections . addElement ( con ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } logTimer = System . currentTimeMillis ( ) ; } try { Thread . sleep ( SLEEP_INTERVAL ) ; } catch ( InterruptedException e ) { System . out . println ( " 监控线程被打断 ! ! " ) ; } } }
micmiu/bigdata-tutorial | public synchronized void freeConnection ( Connection con ) { freeConnections . addElement ( con ) ; checkedOut -- ; log ( " 从连接池 " + name + " 被占用的链接数 " + checkedOut ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; notifyAll ( ) ; }
micmiu/bigdata-tutorial | public synchronized Connection getConnection ( ) { Connection con = null ; if ( freeConnections . size ( ) > 0 ) { con = ( Connection ) freeConnections . firstElement ( ) ; freeConnections . removeElementAt ( 0 ) ; try { if ( con . isClosed ( ) ) { log ( " 从连接池 " + name + " 删除一个无效连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; con = getConnection ( ) ; } } catch ( SQLException e ) { log ( " 从连接池 " + name + " 删除一个无效连接 " ) ; con = getConnection ( ) ; } } else if ( maxConn == 0 || checkedOut < maxConn ) { con = createNewConnection ( ) ; } if ( con != null ) { checkedOut ++ ; log ( " 从连接池 " + name + " 被占用的链接数 " + checkedOut ) ; } return con ; }
micmiu/bigdata-tutorial | public synchronized Connection getConnection ( long timeout ) { long startTime = new Date ( ) . getTime ( ) ; Connection con ; while ( ( con = getConnection ( ) ) == null ) { try { wait ( timeout ) ; } catch ( InterruptedException e ) { } if ( ( new Date ( ) . getTime ( ) - startTime ) >= timeout ) { return null ; } } return con ; }
micmiu/bigdata-tutorial | public synchronized void release ( ) { Enumeration allConnections = freeConnections . elements ( ) ; while ( allConnections . hasMoreElements ( ) ) { Connection con = ( Connection ) allConnections . nextElement ( ) ; try { con . close ( ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; } catch ( SQLException e ) { log ( e , " 无法关闭连接池 " + name + " 中的连接 " ) ; } } freeConnections . removeAllElements ( ) ; }
micmiu/bigdata-tutorial | private Connection createNewConnection ( ) { Connection con = null ; try { if ( user == null ) { con = DriverManager . getConnection ( URL ) ; } else { con = DriverManager . getConnection ( URL , user , password ) ; } log ( " 连接池 " + name + " 创建一个新的连接 " ) ; } catch ( SQLException e ) { log ( " 无法创建下列URL的连接 : ▁ " + URL + " \n \t " + e . getNextException ( ) ) ; return null ; } return con ; }
orange-buffalo/dozer | private ParentPrime ( ) { }
orange-buffalo/dozer | public ParentPrime ( Long id , String name ) { this . id = id ; this . name = name ; }
orange-buffalo/dozer | public Long getId ( ) { return id ; }
orange-buffalo/dozer | public void setId ( Long id ) { this . id = id ; }
orange-buffalo/dozer | public String getName ( ) { return name ; }
orange-buffalo/dozer | public void setName ( String name ) { this . name = name ; }
orange-buffalo/dozer | public List getChildrenList ( ) { return childrenList ; }
orange-buffalo/dozer | public void setChildrenList ( List childrenList ) { this . childrenList = childrenList ; }
orange-buffalo/dozer | public Set getChildrenSet ( ) { return childrenSet ; }
orange-buffalo/dozer | public void setChildrenSet ( Set childrenSet ) { this . childrenSet = childrenSet ; }
orange-buffalo/dozer | public Map getChildrenMap ( ) { return childrenMap ; }
orange-buffalo/dozer | public void setChildrenMap ( Map childrenMap ) { this . childrenMap = childrenMap ; }
orange-buffalo/dozer | @ Override public boolean equals ( Object o ) { if ( o instanceof ParentPrime ) { ParentPrime castObj = ( ParentPrime ) o ; return id . equals ( castObj . getId ( ) ) ; } return false ; }
orange-buffalo/dozer | @ Override public int hashCode ( ) { return id . hashCode ( ) ; }
Wolfgang-Winter/cibet | public PersistCallable ( EventMetadata md , EntityManager em , Object obj ) { metadata = md ; entityManager = em ; entity = obj ; }
Wolfgang-Winter/cibet | @ Override public Void call ( ) throws Exception { log . debug ( " start ▁ call ▁ for ▁ entity ▁ " + entity ) ; entityManager . persist ( entity ) ; log . debug ( entity ) ; if ( Thread . interrupted ( ) ) { log . debug ( " thread ▁ is ▁ interrupted " ) ; return null ; } entityManager . flush ( ) ; ( ( JpaResource ) metadata . getResource ( ) ) . setPrimaryKeyObject ( AnnotationUtil . primaryKeyAsObject ( entity ) ) ; metadata . getResource ( ) . setUnencodedTargetObject ( entity ) ; return null ; }
apache/tapestry4 | public Timestamp getLastAccess ( ) { return _user == null ? null : _user . getLastAccess ( ) ; }
apache/tapestry4 | public Person getUser ( ) { return _user ; }
apache/tapestry4 | public Integer getUserId ( ) { return _user == null ? null : _user . getId ( ) ; }
apache/tapestry4 | public void setUser ( Person user ) { _user = user ; }
apache/tapestry4 | public boolean isUserLoggedIn ( ) { return _user != null ; }
apache/tapestry4 | public boolean isUserLoggedOut ( ) { return _user == null ; }
apache/tapestry4 | public boolean isLoggedInUser ( Integer id ) { if ( _user == null ) return false ; return _user . getId ( ) . equals ( id ) ; }
apache/tapestry4 | public void clearCache ( ) { _user = null ; }
nmldiegues/jvm-stm | public ClosedChannelException ( ) { }
apache/axis1-java | public Detail ( ) { }
apache/axis1-java | public DetailEntry addDetailEntry ( Name name ) throws SOAPException { org . apache . axis . message . DetailEntry entry = new org . apache . axis . message . DetailEntry ( name ) ; addChildElement ( entry ) ; return entry ; }
apache/axis1-java | public Iterator getDetailEntries ( ) { return this . getChildElements ( ) ; }
Fabryprog/camel | public DummyConsumer ( Endpoint endpoint , Processor processor ) { super ( endpoint , processor ) ; }
Fabryprog/camel | @ Override public DummyEndpoint getEndpoint ( ) { return ( DummyEndpoint ) super . getEndpoint ( ) ; }
Fabryprog/camel | public boolean isFailOnRestart ( ) { return failOnRestart ; }
Fabryprog/camel | public void setFailOnRestart ( boolean failOnRestart ) { this . failOnRestart = failOnRestart ; }
Fabryprog/camel | @ Override protected void doStart ( ) throws Exception { int counter = getEndpoint ( ) . getComponent ( ) . increment ( ) ; if ( counter == 2 ) { throw new IOException ( " Forced ▁ error ▁ on ▁ restart " ) ; } super . doStart ( ) ; }
wso2/security-tools | public HTMLOutputGenerator ( JSONObject dataJSONObject , String hbsFileDirectory , String templateFileName ) { this . dataJSONObject = dataJSONObject ; this . hbsFileDirectory = hbsFileDirectory ; this . templateFileName = templateFileName ; }
wso2/security-tools | public String getHbsFileDirectory ( ) { return hbsFileDirectory ; }
wso2/security-tools | public JSONObject getDataJSONObject ( ) { return dataJSONObject ; }
wso2/security-tools | public String getTemplateFileName ( ) { return templateFileName ; }
wso2/security-tools | public void generate ( String outputFilePath ) throws FeedbackToolException { Template template ; Context context ; try { JsonNode jsonNode = new ObjectMapper ( ) . readTree ( this . getDataJSONObject ( ) . toJSONString ( ) ) ; Handlebars handlebars = new Handlebars ( ) ; handlebars . registerHelper ( " json " , Jackson2Helper . INSTANCE ) ; context = Context . newBuilder ( jsonNode ) . resolver ( JsonNodeValueResolver . INSTANCE , JavaBeanValueResolver . INSTANCE , FieldValueResolver . INSTANCE , MapValueResolver . INSTANCE , MethodValueResolver . INSTANCE ) . build ( ) ; TemplateLoader loader = new FileTemplateLoader ( this . getHbsFileDirectory ( ) , " . hbs " ) ; handlebars = new Handlebars ( loader ) ; template = handlebars . compile ( FilenameUtils . removeExtension ( this . getTemplateFileName ( ) ) ) ; String html = template . apply ( context ) ; FileHandler . writeToFile ( html , System . getProperty ( " java . io . tmpdir " ) + Constants . OUTPUT_HTML_FILE ) ; } catch ( FileNotFoundException e ) { throw new FeedbackToolException ( " FileNotFoundException ▁ was ▁ thrown ▁ while ▁ compiling ▁ the ▁ template ▁ file " , e ) ; } catch ( IOException e ) { throw new FeedbackToolException ( " IOException ▁ was ▁ thrown ▁ while ▁ compiling ▁ the ▁ template ▁ file " , e ) ; } }
abstractj/keycloak | public SAML11ResponseType ( String id , XMLGregorianCalendar issueInstant ) { super ( id , issueInstant ) ; }
abstractj/keycloak | public void add ( SAML11AssertionType assertion ) { this . assertions . add ( assertion ) ; }
abstractj/keycloak | public boolean remove ( SAML11AssertionType assertion ) { return this . assertions . remove ( assertion ) ; }
abstractj/keycloak | public List < SAML11AssertionType > get ( ) { return Collections . unmodifiableList ( assertions ) ; }
abstractj/keycloak | public SAML11StatusType getStatus ( ) { return status ; }
abstractj/keycloak | public void setStatus ( SAML11StatusType status ) { this . status = status ; }
jagarciavi/PhotoSpat | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_photo_spat ) ; webview = ( WebView ) findViewById ( R . id . webview ) ; final Activity activity = this ; webview . getSettings ( ) . setJavaScriptEnabled ( true ) ; webview . canGoBack ( ) ; webview . setWebViewClient ( new WebViewClient ( ) { public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ) ; return true ; } public void onLoadResource ( WebView view , String url ) { if ( progressDialog == null ) { progressDialog = new ProgressDialog ( activity ) ; progressDialog . setMessage ( getResources ( ) . getString ( R . string . loading ) ) ; progressDialog . show ( ) ; webview . setEnabled ( false ) ; } } public void onPageFinished ( WebView view , String url ) { Log . i ( TAG , " The ▁ app ▁ is ▁ in ▁ the ▁ onPageFinished ▁ method " ) ; String finalUrl = webview . getUrl ( ) . toString ( ) ; Log . i ( TAG , " finalurl ▁ string ▁ is ▁ " + finalUrl ) ; if ( finalUrl . equals ( " https : // instagram . com / accounts / login / " ) ) { if ( firstLoad == 1 ) { Log . i ( TAG , " The ▁ strings ▁ are ▁ equal , ▁ we ' ll ▁ set ▁ counter ▁ value ▁ to ▁ 4" ) ; counter = 4 ; } else { Log . i ( TAG , " It ' s ▁ not ▁ the ▁ load ▁ of ▁ the ▁ login ▁ page . . . " ) ; firstLoad = 1 ; } } if ( progressDialog . isShowing ( ) && counter == 4 ) { Log . i ( TAG , " On ▁ loop ▁ - > ▁ Dismiss ▁ progress ▁ dialog ▁ " ) ; progressDialog . dismiss ( ) ; webview . setEnabled ( true ) ; counter = 0 ; } Log . i ( TAG , " Counter ▁ value ▁ is ▁ " + counter ) ; counter ++ ; } public void onReceivedError ( WebView view , int errorCod , String description , String failingUrl ) { webview . setEnabled ( false ) ; setContentView ( R . layout . activity_photo_spat ) ; progressDialog . dismiss ( ) ; Log . i ( TAG , " Received ▁ error : ▁ " + errorCod + " ▁ " + description + " ▁ " + failingUrl ) ; new AlertDialog . Builder ( PhotoSpat . this ) . setTitle ( getResources ( ) . getString ( R . string . errorDialogTitle ) ) . setMessage ( getResources ( ) . getString ( R . string . errorDialogMessage ) ) . setNeutralButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { finish ( ) ; } } ) . show ( ) ; } } ) ; webview . loadUrl ( " https : // www . instagram . com / accounts / login " ) ; }
jagarciavi/PhotoSpat | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { return true ; }
jagarciavi/PhotoSpat | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . action_settings ) { return true ; } return super . onOptionsItemSelected ( item ) ; }
WANdisco/gerrit | public void setChangeAttribute ( ChangeAttribute changeAttr ) { this . changeAttr = changeAttr ; if ( changeAttr != null ) { projectName = changeAttr . project ; supported = true ; } }
WANdisco/gerrit | public void setProjectName ( String projectName ) { this . projectName = projectName ; this . supported = true ; }
WANdisco/gerrit | public void setBranchName ( Branch . NameKey branchName ) { this . branchName = branchName ; supported = true ; }
WANdisco/gerrit | public void setSupported ( boolean supported ) { this . supported = supported ; }
WANdisco/gerrit | public ChangeAttribute getChangeAttr ( ) { return changeAttr ; }
WANdisco/gerrit | public Branch . NameKey getBranchName ( ) { return branchName ; }
WANdisco/gerrit | public String getProjectName ( ) { return projectName ; }
WANdisco/gerrit | public boolean isSupported ( ) { return supported ; }
WANdisco/gerrit | @ Override public String toString ( ) { return String . format ( " ReplicatedChangeEventInfo { projectName = % s , ▁ branchName = % s , ▁ changeAttr = % s , ▁ supported = % s } " , projectName , branchName , changeAttr , supported ) ; }
avedensky/JavaRushTasks | public User ( int age , String name ) { this . age = age ; this . name = name ; }
avedensky/JavaRushTasks | @ Override protected User clone ( ) throws CloneNotSupportedException { return new User ( this . age , this . name ) ; }
avedensky/JavaRushTasks | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof User ) ) return false ; User user = ( User ) o ; if ( age != user . age ) return false ; return name . equals ( user . name ) ; }
avedensky/JavaRushTasks | @ Override public int hashCode ( ) { int result = age ; result = 31 * result + name . hashCode ( ) ; return result ; }
avedensky/JavaRushTasks | @ Override protected Solution clone ( ) throws CloneNotSupportedException { Solution solution = new Solution ( ) ; for ( Map . Entry < String , User > pair : this . users . entrySet ( ) ) { User user = pair . getValue ( ) . clone ( ) ; solution . users . put ( pair . getKey ( ) , user ) ; } return solution ; }
droolsjbpm/optaplanner | @ Override public Runnable accumulate ( InTuple input ) { KeyTuple key = toKey ( input ) ; ResultContainer1 container1 = containersMap1 . computeIfAbsent ( key , __ -> newFirstContainer ( ) ) ; ResultContainer2 container2 = containersMap2 . computeIfAbsent ( key , __ -> newSecondContainer ( ) ) ; Runnable undo1 = processFirst ( input , container1 ) ; Runnable undo2 = processSecond ( input , container2 ) ; addTuple ( key ) ; return ( ) -> { undo1 . run ( ) ; undo2 . run ( ) ; long currentCount = removeTuple ( key ) ; if ( currentCount == 0L ) { containersMap1 . remove ( key ) ; containersMap2 . remove ( key ) ; resultMap . remove ( key ) ; } } ; }
droolsjbpm/optaplanner | @ Override public Collection < OutTuple > finish ( ) { Set < KeyTuple > dirtyTupleSet = clearDirtyTupleSet ( ) ; if ( ! dirtyTupleSet . isEmpty ( ) ) { for ( KeyTuple tuple : dirtyTupleSet ) { resultMap . put ( tuple , toResult ( tuple , containersMap1 . get ( tuple ) , containersMap2 . get ( tuple ) ) ) ; } } return resultMap . values ( ) ; }
Weisses/Ebonheart-Mods | public TileEntityGemstoneWorkbench ( ) { this . inventory = new ItemStackHandler ( size ) ; }
Weisses/Ebonheart-Mods | @ Override public boolean hasCapability ( Capability < ? > capability , EnumFacing facing ) { if ( capability != CapabilityItemHandler . ITEM_HANDLER_CAPABILITY ) return false ; return super . hasCapability ( capability , facing ) ; }
Weisses/Ebonheart-Mods | @ Override public < T > T getCapability ( Capability < T > capability , EnumFacing facing ) { if ( capability == CapabilityItemHandler . ITEM_HANDLER_CAPABILITY ) return ( T ) this . inventory ; return super . getCapability ( capability , facing ) ; }
Weisses/Ebonheart-Mods | @ Override public NBTTagCompound writeToNBT ( NBTTagCompound compound ) { super . writeToNBT ( compound ) ; compound . setTag ( " Slots " , this . inventory . serializeNBT ( ) ) ; compound . setInteger ( " CutTime " , this . cutTime ) ; compound . setInteger ( " GemstoneMeta " , this . gemstoneMeta ) ; compound . setInteger ( " ProcChance " , this . procChance ) ; compound . setBoolean ( " IsOn " , this . isOn ) ; if ( this . hasCustomName ( ) ) { compound . setString ( " CustomName " , this . gemstoneWorkbenchCustomName ) ; } return compound ; }
Weisses/Ebonheart-Mods | @ Override public void readFromNBT ( NBTTagCompound compound ) { super . readFromNBT ( compound ) ; this . inventory . deserializeNBT ( compound . getCompoundTag ( " Slots " ) ) ; this . cutTime = compound . getInteger ( " CutTime " ) ; this . gemstoneMeta = compound . getInteger ( " GemstoneMeta " ) ; this . procChance = compound . getInteger ( " ProcChance " ) ; this . isOn = compound . getBoolean ( " IsOn " ) ; if ( compound . hasKey ( " CustomName " , 8 ) ) { this . gemstoneWorkbenchCustomName = compound . getString ( " CustomName " ) ; } }
Weisses/Ebonheart-Mods | @ Override @ Nullable public SPacketUpdateTileEntity getUpdatePacket ( ) { return new SPacketUpdateTileEntity ( this . pos , 3 , this . getUpdateTag ( ) ) ; }
Weisses/Ebonheart-Mods | @ Override public NBTTagCompound getUpdateTag ( ) { return this . writeToNBT ( new NBTTagCompound ( ) ) ; }
Weisses/Ebonheart-Mods | @ Override public void onDataPacket ( NetworkManager net , SPacketUpdateTileEntity pkt ) { super . onDataPacket ( net , pkt ) ; this . cutTime = pkt . getNbtCompound ( ) . getInteger ( " CutTime " ) ; this . handleUpdateTag ( pkt . getNbtCompound ( ) ) ; }
Weisses/Ebonheart-Mods | public String getName ( ) { return this . hasCustomName ( ) ? this . gemstoneWorkbenchCustomName : " gemstone _ workbench " ; }
Weisses/Ebonheart-Mods | public boolean hasCustomName ( ) { return this . gemstoneWorkbenchCustomName != null && ! this . gemstoneWorkbenchCustomName . isEmpty ( ) ; }
Weisses/Ebonheart-Mods | @ Override public void update ( ) { this . cuttingLogic ( ) ; }
Weisses/Ebonheart-Mods | private void cuttingLogic ( ) { boolean hasBeenCutting = cuttingSomething ( ) ; boolean changedCuttingState = false ; if ( ! this . world . isRemote ) { if ( this . isOn ) { if ( ! this . inventory . getStackInSlot ( 0 ) . isEmpty ( ) ) { this . totalCutTime = getMaxCutTime ( this . inventory . getStackInSlot ( 0 ) ) ; this . procChance = getGemProc ( this . inventory . getStackInSlot ( 0 ) ) ; this . procAmount = this . getMultiProcChance ( this . inventory . getStackInSlot ( 0 ) ) ; if ( ! cuttingSomething ( ) && canCut ( ) ) { if ( cuttingSomething ( ) ) { changedCuttingState = true ; } } if ( cuttingSomething ( ) && canCut ( ) ) { ++ this . cutTime ; this . syncCutTime ( ) ; if ( this . cutTime == this . totalCutTime ) { double procSuccessful = References . random . nextInt ( 100 ) ; this . cutTime = 0 ; this . totalCutTime = getMaxCutTime ( this . inventory . getStackInSlot ( 0 ) ) ; this . procAmount = this . getMultiProcChance ( this . inventory . getStackInSlot ( 0 ) ) ; if ( this . procChance >= procSuccessful ) { cutGem ( ) ; } else { this . inventory . getStackInSlot ( 0 ) . shrink ( 1 ) ; } changedCuttingState = true ; } } else { this . cutTime = 0 ; } } else { this . cutTime = 0 ; this . procChance = 0 ; } } else { this . cutTime = 0 ; if ( ! this . inventory . getStackInSlot ( 0 ) . isEmpty ( ) ) { this . procChance = getGemProc ( this . inventory . getStackInSlot ( 0 ) ) ; } else { this . procChance = 0 ; } } if ( ! canCut ( ) && this . cutTime > 0 ) { this . cutTime = 0 ; } if ( hasBeenCutting != cuttingSomething ( ) ) { changedCuttingState = true ; } } if ( changedCuttingState ) { this . markDirty ( ) ; } }
Weisses/Ebonheart-Mods | private boolean canCut ( ) { if ( ( ( ItemStack ) this . inventory . getStackInSlot ( 0 ) ) . isEmpty ( ) ) { return false ; } else { ItemStack itemstack1 = ( ItemStack ) this . inventory . getStackInSlot ( 1 ) ; if ( itemstack1 . isEmpty ( ) ) return true ; if ( ! itemstack1 . isItemEqual ( GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] ) ) return false ; int result = itemstack1 . getCount ( ) + GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] . getCount ( ) ; return result <= 64 && result <= itemstack1 . getMaxStackSize ( ) ; } }
Weisses/Ebonheart-Mods | public void cutGem ( ) { if ( this . canCut ( ) ) { ItemStack itemstackIn = ( ItemStack ) this . inventory . getStackInSlot ( 0 ) ; ItemStack itemstackOut = GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] ; ItemStack itemstack1 = ( ItemStack ) this . inventory . getStackInSlot ( 1 ) ; if ( itemstack1 . isEmpty ( ) ) { this . inventory . insertItem ( 1 , new ItemStack ( InitItemsVG . gemstone_item_basic_v1 , 1 + this . procAmount , this . gemstoneMeta ) , false ) ; } else if ( itemstack1 . isItemEqual ( GemCuttingRecipes . CUT_GEM_OUTPUT [ this . gemstoneMeta ] ) ) { if ( itemstack1 . getCount ( ) + this . procAmount > 64 ) { int reducedAmount = References . random . nextInt ( ( itemstack1 . getCount ( ) + this . procAmount ) - 64 ) ; if ( reducedAmount == 0 ) { reducedAmount = 1 ; } itemstack1 . grow ( reducedAmount ) ; } else { itemstack1 . grow ( 1 + this . procAmount ) ; } } if ( itemstack1 . getCount ( ) == 65 ) { itemstack1 . shrink ( 1 ) ; } if ( itemstack1 . getCount ( ) == 66 ) { itemstack1 . shrink ( 2 ) ; } itemstackIn . shrink ( 1 ) ; } }
Weisses/Ebonheart-Mods | public int getMaxCutTime ( ItemStack stack ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { return 200 ; } }
Weisses/Ebonheart-Mods | public int getGemProc ( ItemStack stack ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { Item item = stack . getItem ( ) ; if ( item == InitItemsVG . gemstone_item_unidentified ) return 500 ; if ( item instanceof ItemBlock && Block . getBlockFromItem ( item ) != Blocks . AIR ) { Block block = Block . getBlockFromItem ( item ) ; if ( block == Blocks . REDSTONE_ORE ) return 25 ; if ( block == Blocks . REDSTONE_BLOCK ) return 80 ; if ( block == Blocks . COAL_ORE ) return 30 ; if ( block == Blocks . COAL_BLOCK ) return 90 ; if ( block == Blocks . IRON_ORE ) return 75 ; if ( block == Blocks . IRON_BLOCK ) return 225 ; if ( block == Blocks . QUARTZ_ORE ) return 90 ; if ( block == Blocks . QUARTZ_BLOCK ) return 270 ; if ( block == Blocks . GOLD_ORE ) return 105 ; if ( block == Blocks . GOLD_BLOCK ) return 315 ; if ( block == Blocks . LAPIS_ORE ) return 115 ; if ( block == Blocks . LAPIS_BLOCK ) return 350 ; if ( block == Blocks . DIAMOND_ORE ) return 150 ; if ( block == Blocks . DIAMOND_BLOCK ) return 450 ; if ( block == Blocks . EMERALD_ORE ) return 165 ; if ( block == Blocks . EMERALD_BLOCK ) return 495 ; if ( block == Blocks . MYCELIUM ) return 10 ; if ( block == Blocks . COBBLESTONE ) return 15 ; if ( block == Blocks . LOG ) return 16 ; if ( block == Blocks . LOG2 ) return 16 ; if ( block == Blocks . NETHERRACK ) return 13 ; if ( block == Blocks . NETHER_BRICK ) return 50 ; if ( block == Blocks . RED_NETHER_BRICK ) return 60 ; if ( block == Blocks . OBSIDIAN ) return 45 ; if ( block == Blocks . GLOWSTONE ) return 95 ; if ( block == Blocks . SEA_LANTERN ) return 95 ; if ( block == Blocks . PRISMARINE ) return 100 ; if ( block == Blocks . END_STONE ) return 110 ; if ( block == Blocks . END_BRICKS ) return 110 ; if ( block == Blocks . END_ROD ) return 130 ; if ( block == Blocks . PURPUR_BLOCK ) return 150 ; if ( block == Blocks . PURPUR_PILLAR ) return 150 ; if ( block == Blocks . PURPUR_STAIRS ) return 150 ; if ( block == Blocks . PURPUR_SLAB ) return 75 ; if ( block == Blocks . ENCHANTING_TABLE ) return 280 ; if ( block == Blocks . ENDER_CHEST ) return 415 ; if ( block == Blocks . BEACON ) return 500 ; if ( block . getDefaultState ( ) . getMaterial ( ) == Material . GRASS || block . getDefaultState ( ) . getMaterial ( ) == Material . PLANTS || block . getDefaultState ( ) . getMaterial ( ) == Material . LEAVES || block . getDefaultState ( ) . getMaterial ( ) == Material . VINE || block . getDefaultState ( ) . getMaterial ( ) == Material . CACTUS || block . getDefaultState ( ) . getMaterial ( ) == Material . GOURD || block . getDefaultState ( ) . getMaterial ( ) == Material . CAKE ) { return 5 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . SNOW || block . getDefaultState ( ) . getMaterial ( ) == Material . CRAFTED_SNOW || block . getDefaultState ( ) . getMaterial ( ) == Material . ICE || block . getDefaultState ( ) . getMaterial ( ) == Material . PACKED_ICE ) { return 8 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . GROUND || block . getDefaultState ( ) . getMaterial ( ) == Material . SAND || block . getDefaultState ( ) . getMaterial ( ) == Material . WEB ) { return 10 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . WOOD ) { return 13 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . CLOTH || block . getDefaultState ( ) . getMaterial ( ) == Material . CARPET || block . getDefaultState ( ) . getMaterial ( ) == Material . SPONGE ) { return 15 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . CLAY || block . getDefaultState ( ) . getMaterial ( ) == Material . CORAL ) { return 18 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . GLASS ) { return 20 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . ROCK || block . getDefaultState ( ) . getMaterial ( ) == Material . PISTON ) { return 25 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . IRON || block . getDefaultState ( ) . getMaterial ( ) == Material . ANVIL || block . getDefaultState ( ) . getMaterial ( ) == Material . CIRCUITS || block . getDefaultState ( ) . getMaterial ( ) == Material . REDSTONE_LIGHT ) { return 40 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . TNT ) { return 50 ; } if ( block . getDefaultState ( ) . getMaterial ( ) == Material . DRAGON_EGG ) { return 100 ; } return 25 ; } if ( item instanceof ItemTool && " WOOD " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 15 ; if ( item instanceof ItemSword && " WOOD " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 15 ; if ( item instanceof ItemHoe && " WOOD " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 15 ; if ( item instanceof ItemTool && " STONE " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 28 ; if ( item instanceof ItemSword && " STONE " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 28 ; if ( item instanceof ItemHoe && " STONE " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 28 ; if ( item instanceof ItemTool && " IRON " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 38 ; if ( item instanceof ItemSword && " IRON " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 38 ; if ( item instanceof ItemHoe && " IRON " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 38 ; if ( item instanceof ItemTool && " GOLD " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 58 ; if ( item instanceof ItemSword && " GOLD " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 58 ; if ( item instanceof ItemHoe && " GOLD " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 58 ; if ( item instanceof ItemTool && " DIAMOND " . equals ( ( ( ItemTool ) item ) . getToolMaterialName ( ) ) ) return 85 ; if ( item instanceof ItemSword && " DIAMOND " . equals ( ( ( ItemSword ) item ) . getToolMaterialName ( ) ) ) return 85 ; if ( item instanceof ItemHoe && " DIAMOND " . equals ( ( ( ItemHoe ) item ) . getMaterialName ( ) ) ) return 85 ; if ( item instanceof ItemArmor && " leather " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 14 ; if ( item instanceof ItemArmor && " iron " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 40 ; if ( item instanceof ItemArmor && " gold " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 60 ; if ( item instanceof ItemArmor && " chainmail " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 75 ; if ( item instanceof ItemArmor && " diamond " . equals ( ( ( ItemArmor ) item ) . getArmorMaterial ( ) . getName ( ) ) ) return 90 ; if ( item == Items . IRON_HORSE_ARMOR ) return 40 ; if ( item == Items . GOLDEN_HORSE_ARMOR ) return 60 ; if ( item == Items . DIAMOND_HORSE_ARMOR ) return 90 ; if ( item instanceof ItemRecord ) return 90 ; if ( item == Items . REDSTONE ) return 8 ; if ( item == Items . DYE ) return 10 ; if ( item == Items . COAL ) return 10 ; if ( item == Items . IRON_INGOT ) return 25 ; if ( item == Items . QUARTZ ) return 30 ; if ( item == Items . GOLD_INGOT ) return 35 ; if ( item == Items . DIAMOND ) return 50 ; if ( item == Items . EMERALD ) return 55 ; if ( item == Items . PRISMARINE_SHARD ) return 75 ; if ( item == Items . PRISMARINE_CRYSTALS ) return 90 ; if ( item instanceof ItemSeeds ) return 3 ; if ( item == Items . GOLD_NUGGET ) return 4 ; if ( item == Items . GUNPOWDER ) return 10 ; if ( item == Items . BLAZE_ROD ) return 15 ; if ( item == Items . BREWING_STAND ) return 18 ; if ( item == Items . GLOWSTONE_DUST ) return 25 ; if ( item == Items . COMPASS ) return 40 ; if ( item == Items . CLOCK ) return 55 ; if ( item == Items . ENDER_PEARL ) return 30 ; if ( item == Items . FIRE_CHARGE ) return 40 ; if ( item == Items . SHEARS ) return 40 ; if ( item == Items . FIREWORK_CHARGE ) return 45 ; if ( item == Items . CAULDRON ) return 50 ; if ( item == Items . ENDER_EYE ) return 55 ; if ( item == Items . ENCHANTED_BOOK ) return 70 ; if ( item == Items . GOLDEN_APPLE ) return 75 ; if ( item == Items . BUCKET ) return 75 ; if ( item == Items . GHAST_TEAR ) return 80 ; if ( item == Items . CHORUS_FRUIT ) return 80 ; if ( item == Items . CHORUS_FRUIT_POPPED ) return 85 ; if ( item == Items . LAVA_BUCKET ) return 85 ; if ( item == Items . EXPERIENCE_BOTTLE ) return 100 ; if ( item == Items . TOTEM ) return 300 ; if ( item == Items . NETHER_STAR ) return 350 ; if ( item == Items . SHULKER_SHELL ) return 350 ; if ( item == Items . ELYTRA ) return 400 ; return 5 ; } }
Weisses/Ebonheart-Mods | public int getMultiProcChance ( ItemStack stack ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { if ( this . getGemProc ( stack ) >= 500 ) { return References . random . nextInt ( 5 ) ; } else if ( this . getGemProc ( stack ) >= 401 ) { return References . random . nextInt ( 4 ) ; } else if ( this . getGemProc ( stack ) >= 301 ) { return References . random . nextInt ( 3 ) ; } else if ( this . getGemProc ( stack ) >= 201 ) { return References . random . nextInt ( 2 ) ; } else if ( this . getGemProc ( stack ) >= 101 ) { return References . random . nextInt ( 1 ) ; } return 0 ; } }
Weisses/Ebonheart-Mods | @ SideOnly ( Side . CLIENT ) public boolean isWorkbenchOn ( ) { boolean isCutting = false ; if ( this . cutTime > 0 ) { isCutting = true ; } return isCutting ; }
Weisses/Ebonheart-Mods | public boolean cuttingSomething ( ) { return true ; }
Weisses/Ebonheart-Mods | public void syncCutTime ( ) { if ( this . cutTime == 1 || this . cutTime == 20 || this . cutTime == 40 || this . cutTime == 60 || this . cutTime == 80 || this . cutTime == 100 || this . cutTime == 120 || this . cutTime == 140 || this . cutTime == 160 || this . cutTime == 180 || this . cutTime == 200 ) { this . markUpdate ( ) ; } }
Weisses/Ebonheart-Mods | protected void markUpdate ( ) { world . notifyBlockUpdate ( this . getPos ( ) , this . getBlockType ( ) . getDefaultState ( ) , this . getBlockType ( ) . getDefaultState ( ) , 0 ) ; }
Weisses/Ebonheart-Mods | public int getField ( int id ) { switch ( id ) { case 0 : return this . cutTime ; case 1 : return this . totalCutTime ; case 2 : return this . procChance ; default : return 0 ; } }
Weisses/Ebonheart-Mods | public void setField ( int id , int value ) { switch ( id ) { case 0 : this . cutTime = value ; break ; case 1 : this . totalCutTime = value ; break ; case 2 : this . procChance = value ; break ; } }
Weisses/Ebonheart-Mods | public int getFieldCount ( ) { return 3 ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " samlIdPMetadataCouchDbInstance " ) @ RefreshScope @ Bean public CouchDbInstance samlIdPMetadataCouchDbInstance ( ) { return samlMetadataCouchDbFactory . getIfAvailable ( ) . getCouchDbInstance ( ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " samlIdPMetadataCouchDbConnector " ) @ RefreshScope @ Bean public CouchDbConnector samlIdPMetadataCouchDbConnector ( ) { return samlMetadataCouchDbFactory . getIfAvailable ( ) . getCouchDbConnector ( ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " samlIdPMetadataCouchDbRepository " ) @ Bean @ RefreshScope public SamlIdPMetadataCouchDbRepository samlIdPMetadataCouchDbRepository ( ) { val repository = new SamlIdPMetadataCouchDbRepository ( samlMetadataCouchDbFactory . getIfAvailable ( ) . getCouchDbConnector ( ) , casProperties . getAuthn ( ) . getSamlIdp ( ) . getMetadata ( ) . getCouchDb ( ) . isCreateIfNotExists ( ) ) ; repository . initStandardDesignDocument ( ) ; return repository ; }
philliprower/cas | @ Bean @ RefreshScope @ ConditionalOnMissingBean ( name = " couchDbSamlIdPMetadataCipherExecutor " ) public CipherExecutor couchDbSamlIdPMetadataCipherExecutor ( ) { val idp = casProperties . getAuthn ( ) . getSamlIdp ( ) ; val crypto = idp . getMetadata ( ) . getCouchDb ( ) . getCrypto ( ) ; if ( crypto . isEnabled ( ) ) { return new CouchDbSamlIdPMetadataCipherExecutor ( crypto . getEncryption ( ) . getKey ( ) , crypto . getSigning ( ) . getKey ( ) , crypto . getAlg ( ) , crypto . getSigning ( ) . getKeySize ( ) , crypto . getEncryption ( ) . getKeySize ( ) ) ; } LOGGER . info ( " CouchDb ▁ SAML ▁ IdP ▁ metadata ▁ encryption / signing ▁ is ▁ turned ▁ off ▁ and ▁ " + " MAY ▁ NOT ▁ be ▁ safe ▁ in ▁ a ▁ production ▁ environment . ▁ " + " Consider ▁ using ▁ other ▁ choices ▁ to ▁ handle ▁ encryption , ▁ signing ▁ and ▁ verification ▁ of ▁ metadata ▁ artifacts " ) ; return CipherExecutor . noOp ( ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " couchDbSamlIdPMetadataGenerator " ) @ Bean ( initMethod = " generate " ) public SamlIdPMetadataGenerator samlIdPMetadataGenerator ( ) { val idp = casProperties . getAuthn ( ) . getSamlIdp ( ) ; val context = SamlIdPMetadataGeneratorConfigurationContext . builder ( ) . samlIdPMetadataLocator ( samlIdPMetadataLocator ( ) ) . samlIdPCertificateAndKeyWriter ( samlSelfSignedCertificateWriter . getIfAvailable ( ) ) . entityId ( idp . getEntityId ( ) ) . resourceLoader ( resourceLoader ) . casServerPrefix ( casProperties . getServer ( ) . getPrefix ( ) ) . scope ( idp . getScope ( ) ) . metadataCipherExecutor ( couchDbSamlIdPMetadataCipherExecutor ( ) ) . build ( ) ; return new CouchDbSamlIdPMetadataGenerator ( context , samlIdPMetadataRepository . getIfAvailable ( ) ) ; }
philliprower/cas | @ ConditionalOnMissingBean ( name = " couchDbSamlIdPMetadataLocator " ) @ Bean @ SneakyThrows public SamlIdPMetadataLocator samlIdPMetadataLocator ( ) { return new CouchDbSamlIdPMetadataLocator ( couchDbSamlIdPMetadataCipherExecutor ( ) , samlIdPMetadataRepository . getIfAvailable ( ) ) ; }
bsspirit/kettle-4.4.0-stable | public DatabaseExplorerNode ( ) { this . children = new ArrayList < DatabaseExplorerNode > ( ) ; }
bsspirit/kettle-4.4.0-stable | public String getName ( ) { return this . name ; }
bsspirit/kettle-4.4.0-stable | public void setName ( String name ) { this . name = name ; }
bsspirit/kettle-4.4.0-stable | public String toString ( ) { return " Database ▁ Node : ▁ " + this . name ; }
bsspirit/kettle-4.4.0-stable | public String getImage ( ) { return this . image ; }
bsspirit/kettle-4.4.0-stable | public void setImage ( String aImage ) { this . image = aImage ; }
bsspirit/kettle-4.4.0-stable | public void setIsSchema ( boolean isSchema ) { this . isSchema = isSchema ; }
bsspirit/kettle-4.4.0-stable | public boolean isSchema ( ) { return isSchema ; }
bsspirit/kettle-4.4.0-stable | public boolean isTable ( ) { return this . isTable ; }
bsspirit/kettle-4.4.0-stable | public void setIsTable ( boolean aIsTable ) { this . isTable = aIsTable ; }
bsspirit/kettle-4.4.0-stable | public void setSchema ( String schema ) { this . schema = schema ; }
bsspirit/kettle-4.4.0-stable | public String getSchema ( ) { return schema ; }
bsspirit/kettle-4.4.0-stable | public String getLabel ( ) { if ( label != null ) { return label ; } else { return name ; } }
bsspirit/kettle-4.4.0-stable | public void setLabel ( String label ) { this . label = label ; }
TDbouk/Baking-App | @ Before public void registerIdlingResource ( ) { mIdlingResource = mActivityTestRule . getActivity ( ) . getIdlingResource ( ) ; Espresso . registerIdlingResources ( mIdlingResource ) ; }
TDbouk/Baking-App | @ Test public void clickOnStepItem_CheckDetailActivity ( ) { onView ( ViewMatchers . withId ( R . id . rv_recipes ) ) . perform ( RecyclerViewActions . actionOnItemAtPosition ( 1 , click ( ) ) ) ; onView ( withId ( R . id . fab_show_ingredients ) ) . check ( matches ( isDisplayed ( ) ) ) ; onView ( ViewMatchers . withId ( R . id . rv_steps ) ) . perform ( RecyclerViewActions . actionOnItemAtPosition ( 0 , click ( ) ) ) ; onView ( withId ( R . id . img_toolbar ) ) . check ( matches ( isDisplayed ( ) ) ) ; }
TDbouk/Baking-App | @ After public void unregisterIdlingResource ( ) { if ( mIdlingResource != null ) Espresso . unregisterIdlingResources ( mIdlingResource ) ; }
VHAINNOVATIONS/Telepathology | protected void setUp ( ) throws Exception { super . setUp ( ) ; this . factory = new CommandFactoryImpl ( ( CommandContext ) null ) ; }
VHAINNOVATIONS/Telepathology | protected CommandFactory getFactory ( ) { return factory ; }
VHAINNOVATIONS/Telepathology | protected void tearDown ( ) throws Exception { this . factory = null ; super . tearDown ( ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreateLogImageAccessEventCommand ( ) { ImageAccessLogEvent event = new ImageAccessLogEvent ( " ien " , null , " icn " , " site " , System . currentTimeMillis ( ) , " reason " , " reasonDescription " , ImageAccessLogEventType . IMAGE_ACCESS , "200" ) ; Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PostImageAccessEventCommand " , null , new Class < ? > [ ] { ImageAccessLogEvent . class } , new Object [ ] { event } ) ; assertExpectedType ( command , PostImageAccessEventCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreatePrefetchPatientIdentificationImageCommand ( ) { Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PrefetchPatientIdentificationImageCommand " , null , new Class < ? > [ ] { String . class , String . class } , new Object [ ] { " icn " , " site " } ) ; assertExpectedType ( command , PrefetchPatientIdentificationImageCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreatePrefetchPatientStudyListCommand ( ) throws URNFormatException { StudyFilter filter = new StudyFilter ( new Date ( 0L ) , new Date ( ) , URNFactory . create ( " urn : vastudy : 200-300-400" , StudyURN . class ) ) ; ImageFormatQualityList formatList = new ImageFormatQualityList ( ) ; Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PrefetchPatientStudyListCommand " , null , new Class < ? > [ ] { String . class , String . class , StudyFilter . class , ImageFormatQualityList . class } , new Object [ ] { " site " , " patient " , filter , formatList } ) ; assertExpectedType ( command , PrefetchPatientStudyListCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | public final void testCreateCommand ( ) throws URNFormatException { String siteNumber = "660" ; String patientIcn = "6553321" ; StudyFilter filter = new StudyFilter ( new Date ( 0L ) , new Date ( ) , URNFactory . create ( " urn : vastudy : 200-300-400" , StudyURN . class ) ) ; ImageFormatQualityList formatList = new ImageFormatQualityList ( ) ; Command < ? > command = getFactory ( ) . createCommand ( java . lang . Void . class , " PrefetchPatientStudyListCommand " , null , new Class < ? > [ ] { String . class , String . class , StudyFilter . class , ImageFormatQualityList . class } , new Object [ ] { siteNumber , patientIcn , filter , formatList } ) ; assertExpectedType ( command , PrefetchPatientStudyListCommandImpl . class ) ; }
VHAINNOVATIONS/Telepathology | private void assertExpectedType ( Object obj , Class < ? > expectedType ) { assertTrue ( " Command ▁ should ▁ be ▁ of ▁ type ▁ " + PostImageAccessEventCommandImpl . class . getName ( ) + " ▁ but ▁ is ▁ " + ( obj == null ? " null " : obj . getClass ( ) . getName ( ) ) , expectedType . isInstance ( obj ) ) ; }
juanchosaravia/TheReentrantBank | public UserAccountActionsThread ( String nombreUsuario , MiVariableRWL m ) { this . micuenta2 = m ; this . nombreUsuario = nombreUsuario ; }
juanchosaravia/TheReentrantBank | public void run ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { switch ( randomnumber ( ) ) { case 0 : micuenta2 . verSaldo ( nombreUsuario ) ; try { Thread . sleep ( tiempo_espera ) ; } catch ( Exception e ) { } ; break ; case 1 : micuenta2 . ingresarDinero ( nombreUsuario , 5 ) ; try { Thread . sleep ( tiempo_espera ) ; } catch ( Exception e ) { } ; break ; case 2 : micuenta2 . retirarDinero ( nombreUsuario , 2 ) ; try { Thread . sleep ( tiempo_espera ) ; } catch ( Exception e ) { } ; break ; } } System . out . println ( " Usuario : ▁ " + this . nombreUsuario + " ▁ ha ▁ finalizado ▁ la ▁ prueba . " ) ; }
juanchosaravia/TheReentrantBank | private int randomnumber ( ) { int numero = 0 ; Random r = new Random ( ) ; numero = r . nextInt ( 3 ) ; return numero ; }
dhutchis/accumulo | @ Override protected int defaultTimeoutSeconds ( ) { return 60 ; }
dhutchis/accumulo | @ Test public void test ( ) throws Exception { Connector c = getConnector ( ) ; String tableName = getUniqueNames ( 1 ) [ 0 ] ; c . tableOperations ( ) . create ( tableName ) ; IteratorSetting is = new IteratorSetting ( 30 , BadIterator . class ) ; c . tableOperations ( ) . attachIterator ( tableName , is , EnumSet . of ( IteratorScope . minc ) ) ; BatchWriter bw = c . createBatchWriter ( tableName , new BatchWriterConfig ( ) ) ; Mutation m = new Mutation ( new Text ( " r1" ) ) ; m . put ( new Text ( " acf " ) , new Text ( tableName ) , new Value ( "1" . getBytes ( UTF_8 ) ) ) ; bw . addMutation ( m ) ; bw . close ( ) ; c . tableOperations ( ) . flush ( tableName , null , null , false ) ; sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; FunctionalTestUtils . checkRFiles ( c , tableName , 1 , 1 , 0 , 0 ) ; Scanner scanner = c . createScanner ( tableName , Authorizations . EMPTY ) ; int count = Iterators . size ( scanner . iterator ( ) ) ; assertEquals ( " Did ▁ not ▁ see ▁ expected ▁ # ▁ entries ▁ " + count , 1 , count ) ; c . tableOperations ( ) . removeIterator ( tableName , BadIterator . class . getSimpleName ( ) , EnumSet . of ( IteratorScope . minc ) ) ; sleepUninterruptibly ( 5 , TimeUnit . SECONDS ) ; FunctionalTestUtils . checkRFiles ( c , tableName , 1 , 1 , 1 , 1 ) ; count = Iterators . size ( scanner . iterator ( ) ) ; if ( count != 1 ) throw new Exception ( " Did ▁ not ▁ see ▁ expected ▁ # ▁ entries ▁ " + count ) ; c . tableOperations ( ) . attachIterator ( tableName , is , EnumSet . of ( IteratorScope . minc ) ) ; bw = c . createBatchWriter ( tableName , new BatchWriterConfig ( ) ) ; m = new Mutation ( new Text ( " r2" ) ) ; m . put ( new Text ( " acf " ) , new Text ( tableName ) , new Value ( "1" . getBytes ( UTF_8 ) ) ) ; bw . addMutation ( m ) ; bw . close ( ) ; sleepUninterruptibly ( 500 , TimeUnit . MILLISECONDS ) ; c . tableOperations ( ) . flush ( tableName , null , null , false ) ; sleepUninterruptibly ( 1 , TimeUnit . SECONDS ) ; c . tableOperations ( ) . delete ( tableName ) ; }
betfair/cougar | @ Test public void doTest ( ) throws Exception { CougarManager cougarManager1 = CougarManager . getInstance ( ) ; HttpCallBean getNewHttpCallBean1 = cougarManager1 . getNewHttpCallBean ( "87.248.113.14" ) ; cougarManager1 = cougarManager1 ; getNewHttpCallBean1 . setOperationName ( " TestSimpleListGet " , " simpleListGet " ) ; getNewHttpCallBean1 . setServiceName ( " baseline " , " cougarBaseline " ) ; getNewHttpCallBean1 . setVersion ( " v2" ) ; Map map2 = new HashMap ( ) ; map2 . put ( " RESTJSON " , " { \" inputList \" : ▁ \n ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ [ ] \n } " ) ; getNewHttpCallBean1 . setPostQueryObjects ( map2 ) ; Timestamp getTimeAsTimeStamp7 = new Timestamp ( System . currentTimeMillis ( ) ) ; cougarManager1 . makeRestCougarHTTPCall ( getNewHttpCallBean1 , com . betfair . testing . utils . cougar . enums . CougarMessageProtocolRequestTypeEnum . RESTJSON , com . betfair . testing . utils . cougar . enums . CougarMessageContentTypeEnum . XML ) ; cougarManager1 . makeRestCougarHTTPCall ( getNewHttpCallBean1 , com . betfair . testing . utils . cougar . enums . CougarMessageProtocolRequestTypeEnum . RESTJSON , com . betfair . testing . utils . cougar . enums . CougarMessageContentTypeEnum . JSON ) ; XMLHelpers xMLHelpers4 = new XMLHelpers ( ) ; Document createAsDocument10 = xMLHelpers4 . getXMLObjectFromString ( " < TestSimpleListGetResponse > < / TestSimpleListGetResponse > " ) ; JSONHelpers jSONHelpers5 = new JSONHelpers ( ) ; JSONObject createAsJSONObject11 = jSONHelpers5 . createAsJSONObject ( new JSONObject ( " { \" response \" : ▁ [ ] } " ) ) ; HttpResponseBean response6 = getNewHttpCallBean1 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONXML ) ; AssertionUtils . multiAssertEquals ( createAsDocument10 , response6 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 200 , response6 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " OK " , response6 . getHttpStatusText ( ) ) ; HttpResponseBean response7 = getNewHttpCallBean1 . getResponseObjectsByEnum ( com . betfair . testing . utils . cougar . enums . CougarMessageProtocolResponseTypeEnum . RESTJSONJSON ) ; AssertionUtils . multiAssertEquals ( createAsJSONObject11 , response7 . getResponseObject ( ) ) ; AssertionUtils . multiAssertEquals ( ( int ) 200 , response7 . getHttpStatusCode ( ) ) ; AssertionUtils . multiAssertEquals ( " OK " , response7 . getHttpStatusText ( ) ) ; cougarManager1 . verifyRequestLogEntriesAfterDate ( getTimeAsTimeStamp7 , new RequestLogRequirement ( "2.8" , " testSimpleListGet " ) , new RequestLogRequirement ( "2.8" , " testSimpleListGet " ) ) ; }
yanzhijun/jclouds-aliyun | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; VolumeImpl that = VolumeImpl . class . cast ( o ) ; return equal ( this . id , that . id ) && equal ( this . getType ( ) , that . getType ( ) ) && equal ( this . size , that . size ) && equal ( this . device , that . device ) && equal ( this . bootDevice , that . bootDevice ) && equal ( this . durable , that . durable ) ; }
yanzhijun/jclouds-aliyun | @ Override public int hashCode ( ) { return Objects . hashCode ( id , size , device , bootDevice , durable ) ; }
yanzhijun/jclouds-aliyun | @ Override public String toString ( ) { return string ( ) . toString ( ) ; }
yanzhijun/jclouds-aliyun | protected ToStringHelper string ( ) { return Objects . toStringHelper ( " " ) . omitNullValues ( ) . add ( " id " , id ) . add ( " type " , getType ( ) ) . add ( " size " , size ) . add ( " device " , device ) . add ( " bootDevice " , bootDevice ) . add ( " durable " , durable ) ; }
yanzhijun/jclouds-aliyun | public VolumeImpl ( @ Nullable String id , Volume . Type type , @ Nullable Float size , @ Nullable String device , boolean bootDevice , boolean durable ) { this . id = id ; this . type = checkNotNull ( type , " type " ) ; this . size = size ; this . device = device ; this . bootDevice = bootDevice ; this . durable = durable ; }
yanzhijun/jclouds-aliyun | public VolumeImpl ( @ Nullable Float size , boolean bootDevice , boolean durable ) { this ( null , Volume . Type . LOCAL , size , null , bootDevice , durable ) ; }
yanzhijun/jclouds-aliyun | public VolumeImpl ( @ Nullable Float size , @ Nullable String device , boolean bootDevice , boolean durable ) { this ( null , Volume . Type . LOCAL , size , device , bootDevice , durable ) ; }
yanzhijun/jclouds-aliyun | @ Override public String getId ( ) { return id ; }
yanzhijun/jclouds-aliyun | @ Override public Volume . Type getType ( ) { return type ; }
yanzhijun/jclouds-aliyun | @ Override public Float getSize ( ) { return size ; }
yanzhijun/jclouds-aliyun | @ Override public String getDevice ( ) { return device ; }
yanzhijun/jclouds-aliyun | @ Override public boolean isDurable ( ) { return durable ; }
yanzhijun/jclouds-aliyun | @ Override public boolean isBootDevice ( ) { return bootDevice ; }
tzvetkoff/brkt-sdk-java | private Platform ( ) { }
dbrimley/hazelcast | @ Before public void init ( ) { factory = new TestHazelcastInstanceFactory ( 2 ) ; }
dbrimley/hazelcast | @ After public void tear ( ) { factory . shutdownAll ( ) ; }
dbrimley/hazelcast | @ Test public void testCloseableCacheLoader ( ) throws InterruptedException { CachingProvider provider = HazelcastServerCachingProvider . createCachingProvider ( factory . newHazelcastInstance ( ) ) ; CacheManager cacheManager = provider . getCacheManager ( ) ; CloseableCacheLoader loader = new CloseableCacheLoader ( ) ; Factory < CloseableCacheLoader > loaderFactory = FactoryBuilder . factoryOf ( loader ) ; CompleteConfiguration < Object , Object > configuration = new CacheConfig ( ) . setCacheLoaderFactory ( loaderFactory ) . setReadThrough ( true ) ; Cache < Object , Object > cache = cacheManager . createCache ( " test " , configuration ) ; cache . get ( " key " ) ; factory . newHazelcastInstance ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { cache . get ( i ) ; LockSupport . parkNanos ( 1000 ) ; } assertFalse ( " CacheLoader ▁ should ▁ not ▁ be ▁ closed ! " , loader . closed ) ; }
dbrimley/hazelcast | @ Override public Object load ( Object key ) throws CacheLoaderException { if ( closed ) { throw new IllegalStateException ( ) ; } return null ; }
dbrimley/hazelcast | @ Override public Map loadAll ( Iterable keys ) throws CacheLoaderException { if ( closed ) { throw new IllegalStateException ( ) ; } return null ; }
dbrimley/hazelcast | @ Override public void close ( ) throws IOException { closed = true ; }
dbrimley/hazelcast | @ Test public void testCloseableCacheWriter ( ) throws InterruptedException { CachingProvider provider = HazelcastServerCachingProvider . createCachingProvider ( factory . newHazelcastInstance ( ) ) ; CacheManager cacheManager = provider . getCacheManager ( ) ; CloseableCacheWriter writer = new CloseableCacheWriter ( ) ; Factory < CloseableCacheWriter > writerFactory = FactoryBuilder . factoryOf ( writer ) ; CompleteConfiguration < Object , Object > configuration = new CacheConfig ( ) . setCacheWriterFactory ( writerFactory ) . setWriteThrough ( true ) ; Cache < Object , Object > cache = cacheManager . createCache ( " test " , configuration ) ; cache . get ( " key " ) ; factory . newHazelcastInstance ( ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { cache . put ( i , i ) ; LockSupport . parkNanos ( 1000 ) ; } assertFalse ( " CacheWriter ▁ should ▁ not ▁ be ▁ closed ! " , writer . closed ) ; }
dbrimley/hazelcast | @ Override public void write ( Cache . Entry entry ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void delete ( Object key ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void deleteAll ( Collection keys ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void writeAll ( Collection collection ) throws CacheWriterException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void close ( ) throws IOException { closed = true ; }
dbrimley/hazelcast | @ Test public void testCloseableCacheListener ( ) { CachingProvider provider = HazelcastServerCachingProvider . createCachingProvider ( factory . newHazelcastInstance ( ) ) ; CacheManager cacheManager = provider . getCacheManager ( ) ; CloseableListener listener = new CloseableListener ( ) ; Factory < CloseableListener > listenerFactory = FactoryBuilder . factoryOf ( listener ) ; CompleteConfiguration < Object , Object > configuration = new CacheConfig ( ) . addCacheEntryListenerConfiguration ( new MutableCacheEntryListenerConfiguration ( listenerFactory , null , true , false ) ) ; Cache < Object , Object > cache = cacheManager . createCache ( " test " , configuration ) ; cache . close ( ) ; assertTrue ( " CloseableListener . close ( ) ▁ should ▁ be ▁ called ▁ when ▁ cache ▁ is ▁ closed ! " , listener . closed ) ; }
dbrimley/hazelcast | @ Override public void onCreated ( Iterable iterable ) throws CacheEntryListenerException { if ( closed ) { throw new IllegalStateException ( ) ; } }
dbrimley/hazelcast | @ Override public void close ( ) throws IOException { closed = true ; }
open-power/serverwiz | public String format ( LogRecord record ) { StringBuilder builder = new StringBuilder ( 1000 ) ; if ( record . getLevel ( ) == Level . CONFIG ) { builder . append ( df2 . format ( new Date ( record . getMillis ( ) ) ) ) . append ( " ▁ - ▁ " ) ; builder . append ( formatMessage ( record ) ) ; builder . append ( " \n " ) ; } else { builder . append ( df . format ( new Date ( record . getMillis ( ) ) ) ) . append ( " ▁ - ▁ " ) ; builder . append ( " [ " ) . append ( record . getLevel ( ) ) . append ( " ] ▁ - ▁ " ) ; builder . append ( formatMessage ( record ) ) ; builder . append ( " \n " ) ; } return builder . toString ( ) ; }
open-power/serverwiz | public String getHead ( Handler h ) { return super . getHead ( h ) ; }
open-power/serverwiz | public String getTail ( Handler h ) { return super . getTail ( h ) ; }
NuwanSameera/syncope | public DefaultModalCloseButton ( ) { super ( new ResourceModel ( " cancel " , " Cancel " ) ) ; add ( new AttributeAppender ( " class " , " ▁ pull - left " ) ) ; setOutputMarkupId ( true ) ; }
NuwanSameera/syncope | @ Override public String getAjaxIndicatorMarkupId ( ) { return StringUtils . EMPTY ; }
dbrimley/hazelcast | @ Before public void setup ( ) { HazelcastInstance [ ] cluster = createHazelcastInstanceFactory ( 2 ) . newInstances ( ) ; local = cluster [ 0 ] ; remote = cluster [ 1 ] ; operationService = ( OperationServiceImpl ) getOperationService ( local ) ; clusterService = getClusterService ( local ) ; operationRunner = new OperationRunnerImpl ( operationService , getPartitionId ( local ) , 0 , newSwCounter ( ) ) ; responseHandler = mock ( OperationResponseHandler . class ) ; }
dbrimley/hazelcast | @ Test public void runTask ( ) { final AtomicLong counter = new AtomicLong ( ) ; operationRunner . run ( new Runnable ( ) { @ Override public void run ( ) { counter . incrementAndGet ( ) ; } } ) ; assertEquals ( 1 , counter . get ( ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation ( ) { final AtomicLong counter = new AtomicLong ( ) ; final Object response = " someresponse " ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } @ Override public Object getResponse ( ) { return response ; } } ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 1 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( op , response ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenGeneric ( ) { final AtomicLong counter = new AtomicLong ( ) ; final Object response = " someresponse " ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } @ Override public Object getResponse ( ) { return response ; } } ; op . setPartitionId ( - 1 ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 1 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( op , response ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenWrongPartition_thenTaskNotExecuted ( ) { final AtomicLong counter = new AtomicLong ( ) ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } } ; op . setPartitionId ( operationRunner . getPartitionId ( ) + 1 ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 0 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( same ( op ) , any ( IllegalStateException . class ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenRunThrowsException ( ) { Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { throw new ExpectedRuntimeException ( ) ; } } ; op . setOperationResponseHandler ( responseHandler ) ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; operationRunner . run ( op ) ; verify ( responseHandler ) . sendResponse ( same ( op ) , any ( ExpectedRuntimeException . class ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenWaitingNeeded ( ) { final AtomicLong counter = new AtomicLong ( ) ; DummyWaitingOperation op = new DummyWaitingOperation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } } ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; operationRunner . run ( op ) ; assertEquals ( 0 , counter . get ( ) ) ; verify ( responseHandler , never ( ) ) . sendResponse ( same ( op ) , any ( ) ) ; }
dbrimley/hazelcast | @ Test public void runOperation_whenTimeout_thenOperationNotExecuted ( ) { final AtomicLong counter = new AtomicLong ( ) ; Operation op = new Operation ( ) { @ Override public void run ( ) throws Exception { counter . incrementAndGet ( ) ; } } ; setCallId ( op , 10 ) ; setCallTimeout ( op , clusterService . getClusterClock ( ) . getClusterTime ( ) - 1 ) ; op . setPartitionId ( operationRunner . getPartitionId ( ) ) ; op . setOperationResponseHandler ( responseHandler ) ; operationRunner . run ( op ) ; assertEquals ( 0 , counter . get ( ) ) ; verify ( responseHandler ) . sendResponse ( same ( op ) , any ( CallTimeoutResponse . class ) ) ; }
dbrimley/hazelcast | @ Test public void runPacket ( ) throws Exception { Operation op = new DummyOperation ( ) ; setCallId ( op , 1000 * 1000 ) ; Packet packet = toPacket ( local , remote , op ) ; operationRunner . run ( packet ) ; }
dbrimley/hazelcast | @ Test ( expected = HazelcastSerializationException . class ) public void runPacket_whenBroken ( ) throws Exception { Operation op = new DummyOperation ( ) ; setCallId ( op , 1000 * 1000 ) ; Packet packet = toPacket ( local , remote , op ) ; byte [ ] bytes = packet . toByteArray ( ) ; for ( int k = 0 ; k < bytes . length ; k ++ ) { bytes [ k ] ++ ; } operationRunner . run ( packet ) ; }
dbrimley/hazelcast | WaitNotifyKey waitNotifyKey = new WaitNotifyKey ( ) { @ Override public String getServiceName ( ) { return " someservice " ; } @ Override public String getObjectName ( ) { return " someobject " ; } }
dbrimley/hazelcast | @ Override public WaitNotifyKey getWaitKey ( ) { return waitNotifyKey ; }
dbrimley/hazelcast | @ Override public boolean shouldWait ( ) { return true ; }
dbrimley/hazelcast | @ Override public void onWaitExpire ( ) { }
BezrukovM/veraPDF-pdfbox | AnnotFlag ( COSDictionary annotDictionary ) { this . annotDictionary = annotDictionary ; }
BezrukovM/veraPDF-pdfbox | @ Override String getFlagType ( ) { return " Annot ▁ flag " ; }
BezrukovM/veraPDF-pdfbox | @ Override String getFlagValue ( ) { return " Flag ▁ vlaue : ▁ " + annotDictionary . getInt ( COSName . F ) ; }
BezrukovM/veraPDF-pdfbox | @ Override Object [ ] [ ] getFlagBits ( ) { PDAnnotation annotation = new PDAnnotation ( annotDictionary ) { } ; return new Object [ ] [ ] { new Object [ ] { 1 , " Invisible " , annotation . isInvisible ( ) } , new Object [ ] { 2 , " Hidden " , annotation . isHidden ( ) } , new Object [ ] { 3 , " Print " , annotation . isPrinted ( ) } , new Object [ ] { 4 , " NoZoom " , annotation . isNoZoom ( ) } , new Object [ ] { 5 , " NoRotate " , annotation . isNoRotate ( ) } , new Object [ ] { 6 , " NoView " , annotation . isNoView ( ) } , new Object [ ] { 7 , " ReadOnly " , annotation . isReadOnly ( ) } , new Object [ ] { 8 , " Locked " , annotation . isLocked ( ) } , new Object [ ] { 9 , " ToggleNoView " , annotation . isToggleNoView ( ) } , new Object [ ] { 10 , " LockedContents " , annotation . isLocked ( ) } } ; }
corbel-platform/corbel | protected ApiEntity ( ) { }
corbel-platform/corbel | protected ApiEntity ( String id ) { this . id = hasText ( id ) ? id : null ; }
corbel-platform/corbel | public String getId ( ) { return id ; }
corbel-platform/corbel | public String getEtag ( ) { return etag ; }
globalbus/blueprint-gradle-plugin | @ Override public void initContext ( ContextEnricher contextEnricher ) { final Map < String , String > customParameters = contextEnricher . getBlueprintConfiguration ( ) . getCustomParameters ( ) ; for ( final String param : customParameters . keySet ( ) ) { if ( param . startsWith ( " example . " ) ) { final String key = param . split ( " \\ . " ) [ 1 ] ; contextEnricher . addBlueprintContentWriter ( " enrichContextWithExample - " + key , xmlStreamWriter -> { xmlStreamWriter . writeEmptyElement ( " example " ) ; xmlStreamWriter . writeDefaultNamespace ( " http : // exampleNamespace " ) ; xmlStreamWriter . writeAttribute ( " id " , key ) ; xmlStreamWriter . writeAttribute ( " value " , customParameters . get ( param ) ) ; } ) ; } } }
matgr1/ai-playground | protected NeatGeneticAlgorithm ( RandomGenerator random , NeatCrossoverSettings crossoverSettings , NeatMutationSettings mutationSettings , SpeciationStrategy speciationStrategy ) { super ( random ) ; if ( null == crossoverSettings ) { throw new IllegalArgumentException ( " crossoverSettings ▁ not ▁ provided " ) ; } if ( null == mutationSettings ) { throw new IllegalArgumentException ( " mutationSettings ▁ not ▁ provided " ) ; } if ( null == speciationStrategy ) { throw new IllegalArgumentException ( " speciationStrategy ▁ not ▁ provided " ) ; } this . crossoverSettings = crossoverSettings ; this . mutationSettings = mutationSettings ; this . speciationStrategy = speciationStrategy ; }
matgr1/ai-playground | public PopulationT createRandomPopulation ( EvolutionContext context , int populationSize , int inputCount , int outputCount ) { return createRandomPopulation ( getNeatEvolutionContext ( context ) , populationSize , inputCount , outputCount ) ; }
matgr1/ai-playground | private PopulationT createRandomPopulation ( NeatEvolutionContext context , int populationSize , int inputCount , int outputCount ) { List < SpeciesMemberT > genomes = new ArrayList < > ( ) ; for ( int i = 0 ; i < populationSize ; i ++ ) { NeatGenomeT genome = createRandomGenome ( random , inputCount , outputCount ) ; for ( CyclicNeuron outputNode : genome . neuralNet . neurons . values ( NeuronType . Output ) ) { addRandomConnection ( context , genome , genome . neuralNet . biasNeuron ( ) , outputNode ) ; for ( CyclicNeuron inputNode : genome . neuralNet . neurons . values ( NeuronType . Input ) ) { addRandomConnection ( context , genome , inputNode , outputNode ) ; } } SpeciesMemberT member = createSpeciesMember ( null , genome ) ; genomes . add ( member ) ; } return createNewPopulation ( context , genomes ) ; }
matgr1/ai-playground | private void addRandomConnection ( NeatEvolutionContext context , NeatGenomeT genome , CyclicNeuron source , CyclicNeuron target ) { NeatMutationFunctions . addConnection ( genome , source . id , target . id , mutationSettings . getConnectionWeightsMutationSettings ( ) . getRandomValueInRange ( random ) , context . innovationMap ) ; }
matgr1/ai-playground | @ Override public final NeatEvolutionContext createEvolutionContext ( EvolutionParameters evolutionParameters , SelectionStrategy selectionStrategy ) { return new NeatEvolutionContext ( evolutionParameters , selectionStrategy ) ; }
matgr1/ai-playground | protected NeatEvolutionContext getNeatEvolutionContext ( EvolutionContext context ) { @ SuppressWarnings ( " unchecked " ) NeatEvolutionContext neatContext = ( NeatEvolutionContext ) context ; return neatContext ; }
matgr1/ai-playground | @ Override protected List < SpeciesT > speciate ( EvolutionContext context , List < SpeciesMemberT > members , PopulationT previousPopulation ) { return speciate ( members , previousPopulation ) ; }
matgr1/ai-playground | private List < SpeciesT > speciate ( List < SpeciesMemberT > members , PopulationT previousPopulation ) { return speciationStrategy . speciate ( members , previousPopulation , this :: createSpecies ) ; }
matgr1/ai-playground | @ Override protected List < SpeciesMemberT > createOffspringAsexual ( EvolutionContext context , FitnessItem < SpeciesMemberT > parent , long currentGeneration , int count ) { return createOffspringAsexual ( getNeatEvolutionContext ( context ) , parent , currentGeneration , count ) ; }
matgr1/ai-playground | private List < SpeciesMemberT > createOffspringAsexual ( NeatEvolutionContext context , FitnessItem < SpeciesMemberT > parent , long currentGeneration , int count ) { List < SpeciesMemberT > children = new ArrayList < > ( ) ; for ( int childCount = 0 ; childCount < count ; childCount ++ ) { NeatGenomeT childGenome = Genome . cloneGenome ( parent . item . genome ( ) , true ) ; NeatMutationFunctions . mutate ( random , mutationSettings , childGenome , currentGeneration , context . innovationMap ) ; SpeciesMemberT child = createSpeciesMember ( parent . item , childGenome ) ; children . add ( child ) ; } return children ; }
matgr1/ai-playground | @ Override protected List < SpeciesMemberT > createOffspringSexual ( EvolutionContext context , FitnessItem < SpeciesMemberT > parentA , FitnessItem < SpeciesMemberT > parentB , long currentGeneration , int count ) { return createOffspringSexual ( getNeatEvolutionContext ( context ) , parentA , parentB , currentGeneration , count ) ; }
matgr1/ai-playground | private List < SpeciesMemberT > createOffspringSexual ( NeatEvolutionContext context , FitnessItem < SpeciesMemberT > parentA , FitnessItem < SpeciesMemberT > parentB , long currentGeneration , int count ) { int parentAInputCount = parentA . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Input ) ; int parentAOutputCount = parentA . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Output ) ; int parentBInputCount = parentB . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Input ) ; int parentBOutputCount = parentB . item . genome ( ) . neuralNet . neurons . count ( NeuronType . Output ) ; if ( parentAInputCount != parentBInputCount ) { throw new IllegalArgumentException ( " Input ▁ count ▁ mismatch " ) ; } if ( parentAOutputCount != parentBOutputCount ) { throw new IllegalArgumentException ( " Output ▁ count ▁ mismatch " ) ; } FitnessItem < NeatGenomeT > parentAItem = createGenomeItem ( parentA ) ; FitnessItem < NeatGenomeT > parentBItem = createGenomeItem ( parentB ) ; GenomeParents < NeatGenomeT > parents = new GenomeParents < > ( parentAItem , parentBItem ) ; List < SpeciesMemberT > children = new ArrayList < > ( ) ; for ( int childCount = 0 ; childCount < count ; childCount ++ ) { NeatGenomeT childGenome = NeatCrossoverFunctions . crossover ( random , crossoverSettings , parents , this :: createNewGenomeFromTemplate ) ; if ( RandomFunctions . testProbability ( random , mutationSettings . getSexualMutationProbability ( ) ) ) { NeatMutationFunctions . mutate ( random , mutationSettings , childGenome , currentGeneration , context . innovationMap ) ; } GenomeParents < SpeciesMemberT > memberParents = new GenomeParents < > ( parentA , parentB ) ; SortedGenomeParents < SpeciesMemberT > sortedMemberParents = memberParents . getSorted ( random ) ; SpeciesMemberT child = createSpeciesMember ( sortedMemberParents . fittest . item , childGenome ) ; children . add ( child ) ; } return children ; }
matgr1/ai-playground | private FitnessItem < NeatGenomeT > createGenomeItem ( FitnessItem < SpeciesMemberT > member ) { return new FitnessItem < > ( member . item . genome ( ) , member . fitness ) ; }
matgr1/ai-playground | public NeatEvolutionContext ( EvolutionParameters evolutionParameters , SelectionStrategy selectionStrategy ) { super ( evolutionParameters , selectionStrategy ) ; innovationMap = new HashMap < > ( ) ; }
facebook/fresco | public TooManyBitmapsException ( ) { super ( ) ; }
facebook/fresco | public TooManyBitmapsException ( String detailMessage ) { super ( detailMessage ) ; }
tausifmuzaffar/bisApp | CodePushUpdateState ( int value ) { this . value = value ; }
tausifmuzaffar/bisApp | public int getValue ( ) { return this . value ; }
psaradhi/fabric-java-sdk | public FileKeyValStore ( String file ) { this . file = file ; }
psaradhi/fabric-java-sdk | public String getValue ( String name ) { Properties properties = loadProperties ( ) ; return ( String ) properties . getProperty ( name ) ; }
psaradhi/fabric-java-sdk | private Properties loadProperties ( ) { Properties properties = new Properties ( ) ; try ( InputStream input = new FileInputStream ( file ) ; ) { properties . load ( input ) ; input . close ( ) ; } catch ( FileNotFoundException e ) { logger . warn ( String . format ( " Could ▁ not ▁ find ▁ the ▁ file ▁ \" % s \" " , file ) ) ; } catch ( IOException e ) { logger . warn ( String . format ( " Could ▁ not ▁ load ▁ keyvalue ▁ store ▁ from ▁ file ▁ \" % s \" , ▁ reason : % s " , file , e . getMessage ( ) ) ) ; } return properties ; }
psaradhi/fabric-java-sdk | public void setValue ( String name , String value ) { Properties properties = loadProperties ( ) ; try ( OutputStream output = new FileOutputStream ( file ) ; ) { properties . setProperty ( name , value ) ; properties . store ( output , " " ) ; output . close ( ) ; } catch ( IOException e ) { logger . warn ( String . format ( " Could ▁ not ▁ save ▁ the ▁ keyvalue ▁ store , ▁ reason : % s " , e . getMessage ( ) ) ) ; } }
multi-os-engine/moe-core | @ Generated private ACAccountCredentialRenewResult ( ) { }
TACTfactory/harmony-core | protected void routerDebug ( ) { }
TACTfactory/harmony-core | public void generateManifest ( ) { }
TACTfactory/harmony-core | @ Override public final void summary ( ) { LinkedHashMap < String , String > commands = new LinkedHashMap < String , String > ( ) ; commands . put ( ROUTER_DEBUG , " List ▁ all ▁ URI " ) ; commands . put ( ROUTER_GENERATE_MANIFEST , " Generate ▁ Manifest " ) ; ConsoleUtils . displaySummary ( BUNDLE , commands ) ; }
TACTfactory/harmony-core | @ Override public final void execute ( final String action , final String [ ] args , final String option ) { }
TACTfactory/harmony-core | @ Override public final boolean isAvailableCommand ( final String command ) { return false ; }
star3136/DemoCollection | public void registerDataObseraver ( ExpandableConnectorAdapter . ConnectorDataObserver dataObserver ) { mObservable . registerObserver ( dataObserver ) ; }
star3136/DemoCollection | public void unregisterDataObserver ( ExpandableConnectorAdapter . ConnectorDataObserver dataObserver ) { mObservable . unregisterObserver ( dataObserver ) ; }
star3136/DemoCollection | public final void notifyDataSetChanged ( ) { mObservable . notifyChanged ( ) ; }
star3136/DemoCollection | @ Override public void notifyGroupInserted ( int groupPosition ) { mObservable . notifyGroupRangeInserted ( groupPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildInserted ( int groupPosition , int childPosition ) { mObservable . notifyChildRangeInserted ( groupPosition , childPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeInserted ( int groupPosition , int childPosition , int itemCount ) { mObservable . notifyChildRangeInserted ( groupPosition , childPosition , itemCount ) ; }
star3136/DemoCollection | @ Override public void notifyChildChanged ( int groupPosition , int childPosition ) { mObservable . notifyChildRangeChanged ( groupPosition , childPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildChanged ( int groupPosition , int childPosition , Object payload ) { mObservable . notifyChildRangeChanged ( groupPosition , childPosition , 1 , payload ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRangeChanged ( int positionStart , int itemCount ) { mObservable . notifyGroupRangeChanged ( positionStart , itemCount , null ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRangeChanged ( int positionStart , int itemCount , Object payload ) { mObservable . notifyGroupRangeChanged ( positionStart , itemCount , payload ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeChanged ( int groupPosition , int positionStart , int itemCount ) { mObservable . notifyChildRangeChanged ( groupPosition , positionStart , itemCount ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeChanged ( int groupPosition , int positionStart , int itemCount , Object payload ) { mObservable . notifyChildRangeChanged ( groupPosition , positionStart , itemCount , payload ) ; }
star3136/DemoCollection | @ Override public void notifyGroupMoved ( int fromPosition , int toPosition ) { mObservable . notifyGroupMoved ( fromPosition , toPosition ) ; }
star3136/DemoCollection | @ Override public void notifyChildMoved ( int groupPosition , int fromPosition , int toPosition ) { mObservable . notifyChildMoved ( groupPosition , fromPosition , toPosition ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRemoved ( int groupPosition ) { mObservable . notifyGroupRangeRemoved ( groupPosition , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyChildRemoved ( int groupPosition , int position ) { mObservable . notifyChildRangeRemoved ( groupPosition , position , 1 ) ; }
star3136/DemoCollection | @ Override public void notifyGroupRangeRemoved ( int positionStart , int itemCount ) { mObservable . notifyGroupRangeRemoved ( positionStart , itemCount ) ; }
star3136/DemoCollection | @ Override public void notifyChildRangeRemoved ( int groupPosition , int positionStart , int itemCount ) { mObservable . notifyChildRangeRemoved ( groupPosition , positionStart , itemCount ) ; }
star3136/DemoCollection | @ Override public long getChildId ( int groupPosition , int childPosition ) { return getChild ( groupPosition , childPosition ) . hashCode ( ) ; }
star3136/DemoCollection | @ Override public long getGroupId ( int groupPosition ) { return getGroup ( groupPosition ) . hashCode ( ) ; }
shin285/KOMORAN | @ Before public void init ( ) { }
shin285/KOMORAN | @ Test public void NothingYet_Test ( ) { }
Xylus/pinpoint | public Observable < String > hello ( final String name ) { return Observable . create ( new Observable . OnSubscribe < String > ( ) { @ Override public void call ( Subscriber < ? super String > subscriber ) { if ( ! subscriber . isUnsubscribed ( ) ) { String message = helloRepository . hello ( name ) ; subscriber . onNext ( message ) ; subscriber . onCompleted ( ) ; } } } ) . subscribeOn ( Schedulers . io ( ) ) ; }
Xylus/pinpoint | public Observable < String > hello ( final String name , final Exception exception ) { return Observable . create ( new Observable . OnSubscribe < String > ( ) { @ Override public void call ( Subscriber < ? super String > subscriber ) { try { if ( ! subscriber . isUnsubscribed ( ) ) { String message = helloRepository . hello ( name , exception ) ; subscriber . onNext ( message ) ; subscriber . onCompleted ( ) ; } } catch ( Exception e ) { subscriber . onError ( e ) ; } } } ) . subscribeOn ( Schedulers . io ( ) ) ; }
Xylus/pinpoint | public Observable < String > hello ( final String name , final long delayMs ) { return Observable . create ( new Observable . OnSubscribe < String > ( ) { @ Override public void call ( Subscriber < ? super String > subscriber ) { try { if ( ! subscriber . isUnsubscribed ( ) ) { String message = helloRepository . hello ( name , delayMs ) ; subscriber . onNext ( message ) ; subscriber . onCompleted ( ) ; } } catch ( Exception e ) { subscriber . onError ( e ) ; } } } ) . subscribeOn ( Schedulers . io ( ) ) ; }
freeVM/freeVM | public void test_missingFormatWidthException ( ) { try { new MissingFormatWidthException ( null ) ; fail ( " should ▁ throw ▁ NullPointerExcepiton " ) ; } catch ( NullPointerException e ) { } }
freeVM/freeVM | public void test_getFormatSpecifier ( ) { String s = " MYTESTSTRING " ; MissingFormatWidthException missingFormatWidthException = new MissingFormatWidthException ( s ) ; assertEquals ( s , missingFormatWidthException . getFormatSpecifier ( ) ) ; }
freeVM/freeVM | public void test_getMessage ( ) { String s = " MYTESTSTRING " ; MissingFormatWidthException missingFormatWidthException = new MissingFormatWidthException ( s ) ; assertTrue ( null != missingFormatWidthException . getMessage ( ) ) ; }
freeVM/freeVM | public void testSerializationSelf ( ) throws Exception { SerializationTest . verifySelf ( new MissingFormatWidthException ( " MYTESTSTRING " ) , exComparator ) ; }
freeVM/freeVM | public void testSerializationCompatibility ( ) throws Exception { SerializationTest . verifyGolden ( this , new MissingFormatWidthException ( " MYTESTSTRING " ) , exComparator ) ; }
Muni10/flyway | public AndroidScanner ( ClassLoader classLoader ) { this . classLoader = classLoader ; context = ContextHolder . getContext ( ) ; if ( context == null ) { throw new FlywayException ( " Unable ▁ to ▁ scan ▁ for ▁ Migrations ! ▁ Context ▁ not ▁ set . ▁ " + " Within ▁ an ▁ activity ▁ you ▁ can ▁ fix ▁ this ▁ with ▁ org . flywaydb . core . api . android . ContextHolder . setContext ( this ) ; " ) ; } }
Muni10/flyway | public LoadableResource [ ] scanForResources ( Location location , String prefix , String suffix ) throws Exception { List < LoadableResource > resources = new ArrayList < LoadableResource > ( ) ; String path = location . getPath ( ) ; for ( String asset : context . getAssets ( ) . list ( path ) ) { if ( asset . startsWith ( prefix ) && asset . endsWith ( suffix ) && ( asset . length ( ) > ( prefix + suffix ) . length ( ) ) ) { resources . add ( new AndroidResource ( context . getAssets ( ) , path , asset ) ) ; } else { LOG . debug ( " Filtering ▁ out ▁ asset : ▁ " + asset ) ; } } return resources . toArray ( new LoadableResource [ resources . size ( ) ] ) ; }
Muni10/flyway | public Class < ? > [ ] scanForClasses ( Location location , Class < ? > implementedInterface ) throws Exception { String pkg = location . getPath ( ) . replace ( " / " , " . " ) ; List < Class > classes = new ArrayList < Class > ( ) ; DexFile dex = new DexFile ( context . getApplicationInfo ( ) . sourceDir ) ; Enumeration < String > entries = dex . entries ( ) ; while ( entries . hasMoreElements ( ) ) { String className = entries . nextElement ( ) ; if ( className . startsWith ( pkg ) ) { Class < ? > clazz = classLoader . loadClass ( className ) ; if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) ) { LOG . debug ( " Skipping ▁ abstract ▁ class : ▁ " + className ) ; continue ; } if ( ! implementedInterface . isAssignableFrom ( clazz ) ) { continue ; } ClassUtils . instantiate ( className , classLoader ) ; classes . add ( clazz ) ; LOG . debug ( " Found ▁ class : ▁ " + className ) ; } } return classes . toArray ( new Class < ? > [ classes . size ( ) ] ) ; }
xiangzhuyuan/spring-security-oauth | @ Before public void init ( ) { template = new OAuth2RestTemplate ( resource , new DefaultOAuth2ClientContext ( ) ) ; }
xiangzhuyuan/spring-security-oauth | @ Test public void testForRedirectWithNoToken ( ) throws Exception { try { template . getForObject ( http . getUrl ( " / " ) , String . class ) ; fail ( " Expected ▁ UserRedirectRequiredException " ) ; } catch ( UserRedirectRequiredException e ) { String message = e . getMessage ( ) ; assertTrue ( " Wrong ▁ message : ▁ " + message , message . contains ( " A ▁ redirect ▁ is ▁ required ▁ to ▁ get ▁ the ▁ users ▁ approval " ) ) ; } }
syntelos/gwtcc | public BindingProperty createBinding ( String name ) { BindingProperty prop = create ( name , BindingProperty . class ) ; bindingProps . add ( prop ) ; return prop ; }
syntelos/gwtcc | public ConfigurationProperty createConfiguration ( String name , boolean allowMultipleValues ) { ConfigurationProperty prop = create ( name , allowMultipleValues , ConfigurationProperty . class ) ; configProps . add ( prop ) ; return prop ; }
syntelos/gwtcc | public Property find ( String name ) { return map . get ( name ) ; }
syntelos/gwtcc | public SortedSet < BindingProperty > getBindingProperties ( ) { return bindingProps ; }
syntelos/gwtcc | public SortedSet < ConfigurationProperty > getConfigurationProperties ( ) { return configProps ; }
syntelos/gwtcc | public Iterator < Property > iterator ( ) { return map . values ( ) . iterator ( ) ; }
syntelos/gwtcc | private < T extends Property > T create ( String name , boolean flag , boolean useFlagArgument , Class < T > clazz ) { if ( clazz == null ) { throw new NullPointerException ( " clazz " ) ; } else if ( name == null ) { throw new NullPointerException ( " name " ) ; } Property property = find ( name ) ; if ( property != null ) { try { return clazz . cast ( property ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( " Cannot ▁ create ▁ property ▁ " + name + " ▁ because ▁ one ▁ of ▁ another ▁ type ▁ ( " + property . getClass ( ) . getSimpleName ( ) + " ) ▁ already ▁ exists . " ) ; } } Exception ex = null ; try { T newInstance ; if ( useFlagArgument ) { newInstance = clazz . getConstructor ( String . class , boolean . class ) . newInstance ( name , flag ) ; } else { newInstance = clazz . getConstructor ( String . class ) . newInstance ( name ) ; } map . put ( name , newInstance ) ; return newInstance ; } catch ( NoSuchMethodException e ) { ex = e ; } catch ( InstantiationException e ) { ex = e ; } catch ( IllegalAccessException e ) { ex = e ; } catch ( InvocationTargetException e ) { ex = e ; } throw new RuntimeException ( " Unable ▁ to ▁ create ▁ Property ▁ instance " , ex ) ; }
syntelos/gwtcc | private < T extends Property > T create ( String name , boolean flag , Class < T > clazz ) { return create ( name , flag , true , clazz ) ; }
syntelos/gwtcc | private < T extends Property > T create ( String name , Class < T > clazz ) { return create ( name , false , false , clazz ) ; }
jenkinsci/gmaven | public void testRender ( ) throws Exception { chew ( " interfaces . groovy . txt " ) ; }
kangaroo-server/kangaroo | @ Before public void bootstrap ( ) { getSession ( ) . beginTransaction ( ) ; this . client = mock ( Client . class ) ; this . webTarget = mock ( WebTarget . class ) ; this . builder = mock ( Builder . class ) ; this . getResponse = mock ( Response . class ) ; doReturn ( webTarget ) . when ( client ) . target ( anyString ( ) ) ; doReturn ( builder ) . when ( webTarget ) . request ( ) ; doReturn ( builder ) . when ( builder ) . header ( any ( ) , any ( ) ) ; doReturn ( getResponse ) . when ( builder ) . get ( ) ; doReturn ( Status . OK ) . when ( getResponse ) . getStatusInfo ( ) ; this . githubAuth = new GithubAuthenticator ( ) ; this . githubAuth . setClient ( client ) ; this . githubAuth . setSession ( getSession ( ) ) ; }
kangaroo-server/kangaroo | @ After public void cleanup ( ) { Transaction t = getSession ( ) . getTransaction ( ) ; if ( t . isActive ( ) ) { t . commit ( ) ; } }
kangaroo-server/kangaroo | @ Test public void testStaticAccessors ( ) { assertEquals ( " https : // github . com / login / oauth / authorize " , githubAuth . getAuthEndpoint ( ) ) ; assertEquals ( " https : // github . com / login / oauth / access _ token " , githubAuth . getTokenEndpoint ( ) ) ; assertEquals ( " read : user , user : email " , githubAuth . getScopes ( ) ) ; }
kangaroo-server/kangaroo | @ Test public void testLoadUser ( ) { OAuth2IdPToken result = new OAuth2IdPToken ( ) ; result . setAccessToken ( " github _ access _ token " ) ; GithubUserEntity user = new GithubUserEntity ( ) ; user . setId ( RandomUtils . nextInt ( ) ) ; user . setName ( " test ▁ name " ) ; doReturn ( user ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; OAuth2User returnedUser = githubAuth . loadUserIdentity ( result ) ; assertEquals ( returnedUser . getId ( ) , user . getId ( ) . toString ( ) ) ; assertEquals ( " test ▁ name " , returnedUser . getClaims ( ) . get ( " name " ) ) ; }
kangaroo-server/kangaroo | @ Test ( expected = ThirdPartyErrorException . class ) public void testLoadUserWithRemoteError ( ) { OAuth2IdPToken result = new OAuth2IdPToken ( ) ; result . setAccessToken ( " github _ access _ token " ) ; Map < String , String > response = new HashMap < > ( ) ; response . put ( " error " , " test " ) ; response . put ( " error _ description " , " description " ) ; doReturn ( Status . BAD_REQUEST ) . when ( getResponse ) . getStatusInfo ( ) ; doReturn ( response ) . when ( getResponse ) . readEntity ( GithubAuthenticator . MAP_TYPE ) ; githubAuth . loadUserIdentity ( result ) ; }
kangaroo-server/kangaroo | @ Test ( expected = ThirdPartyErrorException . class ) public void testLoadUserUnparseable ( ) { OAuth2IdPToken result = new OAuth2IdPToken ( ) ; result . setAccessToken ( " github _ access _ token " ) ; doThrow ( ProcessingException . class ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; githubAuth . loadUserIdentity ( result ) ; }
kangaroo-server/kangaroo | @ Test ( expected = ThirdPartyErrorException . class ) public void testLoadUserNoResponse ( ) { OAuth2IdPToken idPToken = new OAuth2IdPToken ( ) ; idPToken . setAccessToken ( " github _ access _ token " ) ; GithubUserEntity result = new GithubUserEntity ( ) ; doReturn ( result ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; githubAuth . loadUserIdentity ( idPToken ) ; }
kangaroo-server/kangaroo | @ Test ( expected = Exception . class ) public void testLoadUserErrorOnClose ( ) { OAuth2IdPToken idPToken = new OAuth2IdPToken ( ) ; idPToken . setAccessToken ( " github _ access _ token " ) ; GithubUserEntity testUser = new GithubUserEntity ( ) ; testUser . setId ( RandomUtils . nextInt ( ) ) ; testUser . setName ( " Some ▁ Random ▁ Name " ) ; testUser . setEmail ( " lol @ example . com " ) ; doReturn ( testUser ) . when ( getResponse ) . readEntity ( GithubUserEntity . class ) ; doThrow ( Exception . class ) . when ( getResponse ) . close ( ) ; MultivaluedStringMap params = new MultivaluedStringMap ( ) ; params . putSingle ( " code " , " valid _ code " ) ; githubAuth . loadUserIdentity ( idPToken ) ; }
denkers/jdamvc-framework | public Command ( String commandName , String [ ] paramTypes , String className , String methodName , String commandDescription ) { this . commandName = commandName ; this . paramTypes = paramTypes ; this . className = className ; this . methodName = methodName ; this . commandDescription = commandDescription ; }
denkers/jdamvc-framework | public Object call ( String [ ] params , Object instance ) { try { if ( params . length > paramTypes . length || params . length < paramTypes . length ) throw new NoSuchMethodException ( ) ; Class < ? > viewClass = Class . forName ( className ) ; Method listenMethod ; if ( instance == null ) instance = viewClass . newInstance ( ) ; if ( params . length > 0 ) { listenMethod = viewClass . getMethod ( methodName , Class . forName ( paramTypes [ 0 ] ) ) ; return listenMethod . invoke ( instance , ( Object [ ] ) params ) ; } else { listenMethod = viewClass . getDeclaredMethod ( methodName , new Class [ ] { } ) ; return listenMethod . invoke ( instance ) ; } } catch ( ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e ) { ExceptionOutput . output ( e . getMessage ( ) , ExceptionOutput . OutputType . DEBUG ) ; return null ; } }
denkers/jdamvc-framework | public String getCommandName ( ) { return commandName ; }
denkers/jdamvc-framework | public String getCommandDescription ( ) { return commandDescription ; }
denkers/jdamvc-framework | public String [ ] getParamTypes ( ) { return paramTypes ; }
denkers/jdamvc-framework | public String getClassName ( ) { return className ; }
denkers/jdamvc-framework | public String getMethodName ( ) { return methodName ; }
denkers/jdamvc-framework | public void setCommandName ( String commandName ) { this . commandName = commandName ; }
denkers/jdamvc-framework | public void setCommandDescription ( String commandDescription ) { this . commandDescription = commandDescription ; }
denkers/jdamvc-framework | public void setParamTypes ( String [ ] paramTypes ) { this . paramTypes = paramTypes ; }
denkers/jdamvc-framework | public void setClassName ( String className ) { this . className = className ; }
denkers/jdamvc-framework | public void setMethodName ( String methodName ) { this . methodName = methodName ; }
denkers/jdamvc-framework | @ Override public String toString ( ) { String output = MessageFormat . format ( " Command : ▁ { 0 } \n Command ▁ class : ▁ { 1 } \n Command ▁ method : ▁ { 2 } \n Method ▁ param ▁ count : ▁ { 3 } \n " , commandName , className , methodName , paramTypes [ 0 ] ) ; return output ; }
jpalves/ojAlgo | SuperimposedStore ( final MatrixStore < N > base , final int row , final int column , final MatrixStore < N > diff ) { super ( ( int ) base . countRows ( ) , ( int ) base . countColumns ( ) , base ) ; myRowFirst = row ; myColFirst = column ; final int tmpDiffRowDim = ( int ) diff . countRows ( ) ; final int tmpDiffColDim = ( int ) diff . countColumns ( ) ; myRowLimit = row + tmpDiffRowDim ; myColLimit = column + tmpDiffColDim ; myDiff = diff ; }
jpalves/ojAlgo | private SuperimposedStore ( final int rowsCount , final int columnsCount , final MatrixStore < N > base ) { this ( base , 0 , 0 , ( MatrixStore < N > ) null ) ; ProgrammingError . throwForIllegalInvocation ( ) ; }
jpalves/ojAlgo | SuperimposedStore ( final MatrixStore < N > base , final MatrixStore < N > diff ) { this ( base , 0 , 0 , diff ) ; }
jpalves/ojAlgo | public double doubleValue ( final long row , final long column ) { double retVal = this . getBase ( ) . doubleValue ( row , column ) ; if ( this . isCovered ( ( int ) row , ( int ) column ) ) { retVal += myDiff . doubleValue ( row - myRowFirst , column - myColFirst ) ; } return retVal ; }
jpalves/ojAlgo | public N get ( final long row , final long column ) { N retVal = this . getBase ( ) . get ( row , column ) ; if ( this . isCovered ( ( int ) row , ( int ) column ) ) { retVal = myDiff . toScalar ( ( int ) row - myRowFirst , ( int ) column - myColFirst ) . add ( retVal ) . getNumber ( ) ; } return retVal ; }
jpalves/ojAlgo | public Scalar < N > toScalar ( final long row , final long column ) { Scalar < N > retVal = this . getBase ( ) . toScalar ( row , column ) ; if ( this . isCovered ( ( int ) row , ( int ) column ) ) { retVal = retVal . add ( myDiff . get ( row - myRowFirst , column - myColFirst ) ) ; } return retVal ; }
jpalves/ojAlgo | private final boolean isCovered ( final int row , final int column ) { return ( myRowFirst <= row ) && ( myColFirst <= column ) && ( row < myRowLimit ) && ( column < myColLimit ) ; }
jisqyv/appinventor-sources | private TypeUtil ( ) { }
Reimerei/flatbuffers | public Stat __init ( int _i , ByteBuffer _bb ) { bb_pos = _i ; bb = _bb ; return this ; }
Reimerei/flatbuffers | public String id ( ) { int o = __offset ( 4 ) ; return o != 0 ? __string ( o + bb_pos ) : null ; }
Reimerei/flatbuffers | public ByteBuffer idAsByteBuffer ( ) { return __vector_as_bytebuffer ( 4 , 1 ) ; }
Reimerei/flatbuffers | public long val ( ) { int o = __offset ( 6 ) ; return o != 0 ? bb . getLong ( o + bb_pos ) : 0 ; }
Reimerei/flatbuffers | public boolean mutateVal ( long val ) { int o = __offset ( 6 ) ; if ( o != 0 ) { bb . putLong ( o + bb_pos , val ) ; return true ; } else { return false ; } }
Reimerei/flatbuffers | public int count ( ) { int o = __offset ( 8 ) ; return o != 0 ? bb . getShort ( o + bb_pos ) & 0xFFFF : 0 ; }
Reimerei/flatbuffers | public boolean mutateCount ( int count ) { int o = __offset ( 8 ) ; if ( o != 0 ) { bb . putShort ( o + bb_pos , ( short ) count ) ; return true ; } else { return false ; } }
yuananf/presto | @ BeforeMethod public void setupDatabase ( ) { TypeRegistry typeRegistry = new TypeRegistry ( ) ; dbi = new DBI ( " jdbc : h2 : mem : test " + System . nanoTime ( ) ) ; dbi . registerMapper ( new TableColumn . Mapper ( typeRegistry ) ) ; dbi . registerMapper ( new Distribution . Mapper ( typeRegistry ) ) ; dummyHandle = dbi . open ( ) ; createTablesWithRetry ( dbi ) ; RaptorConnectorId connectorId = new RaptorConnectorId ( " raptor " ) ; NodeManager nodeManager = new TestingNodeManager ( ) ; NodeSupplier nodeSupplier = nodeManager :: getWorkerNodes ; shardManager = createShardManager ( dbi , nodeSupplier , systemTicker ( ) ) ; metadata = new RaptorMetadata ( connectorId . toString ( ) , dbi , shardManager ) ; }
yuananf/presto | @ AfterMethod ( alwaysRun = true ) public void cleanupDatabase ( ) { dummyHandle . close ( ) ; }
yuananf/presto | @ Test public void testRenameColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle columnHandle = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . renameColumn ( SESSION , raptorTableHandle , columnHandle , " orderkey _ renamed " ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey _ renamed " ) ) ; }
yuananf/presto | @ Test public void testAddColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; metadata . addColumn ( SESSION , raptorTableHandle , new ColumnMetadata ( " new _ col " , BIGINT ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , raptorTableHandle ) . get ( " new _ col " ) ) ; }
yuananf/presto | @ Test public void testDropColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle lastColumn = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . dropColumn ( SESSION , raptorTableHandle , lastColumn ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; }
yuananf/presto | @ Test public void testAddColumnAfterDropColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle column = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . dropColumn ( SESSION , raptorTableHandle , column ) ; metadata . addColumn ( SESSION , raptorTableHandle , new ColumnMetadata ( " new _ col " , BIGINT ) ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , raptorTableHandle ) . get ( " new _ col " ) ) ; }
yuananf/presto | @ Test public void testDropColumnDisallowed ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; Map < String , Object > properties = ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , ORDERING_PROPERTY , ImmutableList . of ( " totalprice " ) , TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ; ConnectorTableMetadata ordersTable = buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " totalprice " , DOUBLE ) . column ( " orderdate " , DATE ) . column ( " highestid " , BIGINT ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle ordersTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( ordersTableHandle , RaptorTableHandle . class ) ; RaptorTableHandle ordersRaptorTableHandle = ( RaptorTableHandle ) ordersTableHandle ; assertEquals ( ordersRaptorTableHandle . getTableId ( ) , 1 ) ; assertInstanceOf ( ordersRaptorTableHandle , RaptorTableHandle . class ) ; ColumnHandle bucketColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " orderkey " ) ; assertThrows ( " Cannot ▁ drop ▁ bucket ▁ columns " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , bucketColumn ) ) ; ColumnHandle sortColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " totalprice " ) ; assertThrows ( " Cannot ▁ drop ▁ sort ▁ columns " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , sortColumn ) ) ; ColumnHandle temporalColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " orderdate " ) ; assertThrows ( " Cannot ▁ drop ▁ the ▁ temporal ▁ column " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , temporalColumn ) ) ; ColumnHandle highestColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " highestid " ) ; assertThrows ( " Cannot ▁ drop ▁ the ▁ column ▁ which ▁ has ▁ the ▁ largest ▁ column ▁ ID ▁ in ▁ the ▁ table " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , highestColumn ) ) ; }
yuananf/presto | @ Test public void testRenameTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; SchemaTableName renamedTable = new SchemaTableName ( raptorTableHandle . getSchemaName ( ) , " orders _ renamed " ) ; metadata . renameTable ( SESSION , raptorTableHandle , renamedTable ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableHandle renamedTableHandle = metadata . getTableHandle ( SESSION , renamedTable ) ; assertNotNull ( renamedTableHandle ) ; assertEquals ( ( ( RaptorTableHandle ) renamedTableHandle ) . getTableName ( ) , renamedTable . getTableName ( ) ) ; }
yuananf/presto | @ Test public void testCreateTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; assertEquals ( ( ( RaptorTableHandle ) tableHandle ) . getTableId ( ) , 1 ) ; ConnectorTableMetadata table = metadata . getTableMetadata ( SESSION , tableHandle ) ; assertTableEqual ( table , getOrdersTable ( ) ) ; ColumnHandle columnHandle = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; assertInstanceOf ( columnHandle , RaptorColumnHandle . class ) ; assertEquals ( ( ( RaptorColumnHandle ) columnHandle ) . getColumnId ( ) , 1 ) ; ColumnMetadata columnMetadata = metadata . getColumnMetadata ( SESSION , tableHandle , columnHandle ) ; assertNotNull ( columnMetadata ) ; assertEquals ( columnMetadata . getName ( ) , " orderkey " ) ; assertEquals ( columnMetadata . getType ( ) , BIGINT ) ; }
yuananf/presto | @ Test public void testTableProperties ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) , TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , true ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , Long . valueOf ( 4 ) ) ; assertFalse ( metadataDao . getTableInformation ( tableId ) . isOrganized ( ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testTablePropertiesWithOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) , ORGANIZED_PROPERTY , true ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertTrue ( metadataDao . getTableInformation ( tableId ) . isOrganized ( ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testCreateBucketedTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " custkey " , " orderkey " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 1 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; metadata . createTable ( SESSION , ordersTable , false ) ; tableId = ( ( RaptorTableHandle ) metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) . getTableId ( ) ; assertEquals ( tableId , 2 ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 2 ) ) ; }
yuananf/presto | @ Test public void testCreateBucketedTableAsSelect ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 32 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " , " custkey " ) ) ) ; ConnectorNewTableLayout layout = metadata . getNewTableLayout ( SESSION , ordersTable ) . get ( ) ; assertEquals ( layout . getPartitionColumns ( ) , ImmutableList . of ( " orderkey " , " custkey " ) ) ; assertInstanceOf ( layout . getPartitioning ( ) , RaptorPartitioningHandle . class ) ; RaptorPartitioningHandle partitioning = ( RaptorPartitioningHandle ) layout . getPartitioning ( ) ; assertEquals ( partitioning . getDistributionId ( ) , 1 ) ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , ordersTable , Optional . of ( layout ) ) ; metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . of ( 1 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 32 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testCreateBucketedTableExistingDistribution ( ) { MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata table = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , DISTRIBUTION_NAME_PROPERTY , " orders " ) ) ; metadata . createTable ( SESSION , table , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; long tableId = raptorTableHandle . getTableId ( ) ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_LINEITEMS ) ) ; table = getLineItemsTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , DISTRIBUTION_NAME_PROPERTY , " orders " ) ) ; metadata . createTable ( SESSION , table , false ) ; tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_LINEITEMS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; raptorTableHandle = ( RaptorTableHandle ) tableHandle ; tableId = raptorTableHandle . getTableId ( ) ; assertEquals ( tableId , 2 ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_LINEITEMS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Ordering ▁ column ▁ does ▁ not ▁ exist : ▁ orderdatefoo " ) public void testInvalidOrderingColumns ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdatefoo " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; fail ( " Expected ▁ createTable ▁ to ▁ fail " ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Temporal ▁ column ▁ does ▁ not ▁ exist : ▁ foo " ) public void testInvalidTemporalColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " foo " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; fail ( " Expected ▁ createTable ▁ to ▁ fail " ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Temporal ▁ column ▁ must ▁ be ▁ of ▁ type ▁ timestamp ▁ or ▁ date : ▁ orderkey " ) public void testInvalidTemporalColumnType ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderkey " ) ) , false ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Table ▁ with ▁ temporal ▁ columns ▁ cannot ▁ be ▁ organized " ) public void testInvalidTemporalOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderdate " , ORGANIZED_PROPERTY , true ) ) , false ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Table ▁ organization ▁ requires ▁ an ▁ ordering " ) public void testInvalidOrderingOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( ORGANIZED_PROPERTY , true ) ) , false ) ; }
yuananf/presto | @ Test public void testSortOrderProperty ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , null ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testTemporalColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertEquals ( sortColumns . size ( ) , 0 ) ; assertEquals ( sortColumns , ImmutableList . of ( ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , Long . valueOf ( 4 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
yuananf/presto | @ Test public void testListTables ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; List < SchemaTableName > tables = metadata . listTables ( SESSION , null ) ; assertEquals ( tables , ImmutableList . of ( DEFAULT_TEST_ORDERS ) ) ; }
yuananf/presto | @ Test public void testListTableColumns ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; Map < SchemaTableName , List < ColumnMetadata > > columns = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( ) ) ; assertEquals ( columns , ImmutableMap . of ( DEFAULT_TEST_ORDERS , getOrdersTable ( ) . getColumns ( ) ) ) ; }
yuananf/presto | @ Test public void testListTableColumnsFiltering ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; Map < SchemaTableName , List < ColumnMetadata > > filterCatalog = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( ) ) ; Map < SchemaTableName , List < ColumnMetadata > > filterSchema = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( " test " ) ) ; Map < SchemaTableName , List < ColumnMetadata > > filterTable = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( " test " , " orders " ) ) ; assertEquals ( filterCatalog , filterSchema ) ; assertEquals ( filterCatalog , filterTable ) ; }
yuananf/presto | @ Test public void testTableIdentity ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle connectorTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; TableIdentity tableIdentity = metadata . getTableIdentity ( connectorTableHandle ) ; byte [ ] bytes = tableIdentity . serialize ( ) ; assertEquals ( tableIdentity , metadata . deserializeTableIdentity ( bytes ) ) ; byte version = 1 ; long tableId = 12345678L ; ByteArrayDataOutput dataOutput = newDataOutput ( ) ; dataOutput . writeByte ( version ) ; dataOutput . writeLong ( tableId ) ; byte [ ] testBytes = dataOutput . toByteArray ( ) ; TableIdentity testTableIdentity = metadata . deserializeTableIdentity ( testBytes ) ; assertEquals ( testTableIdentity , new RaptorTableIdentity ( tableId ) ) ; }
yuananf/presto | @ Test public void testColumnIdentity ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle connectorTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; Map < String , ColumnHandle > columnHandles = metadata . getColumnHandles ( SESSION , connectorTableHandle ) ; ColumnIdentity orderKeyColumnIdentity = metadata . getColumnIdentity ( columnHandles . get ( " orderkey " ) ) ; byte [ ] bytes = orderKeyColumnIdentity . serialize ( ) ; assertEquals ( orderKeyColumnIdentity , metadata . deserializeColumnIdentity ( bytes ) ) ; byte version = 1 ; long columnId = 123456789012L ; ByteArrayDataOutput dataOutput = newDataOutput ( ) ; dataOutput . writeByte ( version ) ; dataOutput . writeLong ( columnId ) ; byte [ ] testBytes = dataOutput . toByteArray ( ) ; ColumnIdentity testColumnIdentity = metadata . deserializeColumnIdentity ( testBytes ) ; assertEquals ( testColumnIdentity , new RaptorColumnIdentity ( columnId ) ) ; }
yuananf/presto | @ Test public void testViews ( ) { SchemaTableName test1 = new SchemaTableName ( " test " , " test _ view1" ) ; SchemaTableName test2 = new SchemaTableName ( " test " , " test _ view2" ) ; metadata . createView ( SESSION , test1 , " test1" , false ) ; metadata . createView ( SESSION , test2 , " test2" , false ) ; List < SchemaTableName > list = metadata . listViews ( SESSION , " test " ) ; assertEqualsIgnoreOrder ( list , ImmutableList . of ( test1 , test2 ) ) ; Map < SchemaTableName , ConnectorViewDefinition > views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertEquals ( views . keySet ( ) , ImmutableSet . of ( test1 , test2 ) ) ; assertEquals ( views . get ( test1 ) . getViewData ( ) , " test1" ) ; assertEquals ( views . get ( test2 ) . getViewData ( ) , " test2" ) ; metadata . dropView ( SESSION , test1 ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertEquals ( views . keySet ( ) , ImmutableSet . of ( test2 ) ) ; metadata . dropView ( SESSION , test2 ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertTrue ( views . isEmpty ( ) ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( ) ) ; assertTrue ( views . isEmpty ( ) ) ; }
yuananf/presto | @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " View ▁ already ▁ exists : ▁ test \\ . test _ view " ) public void testCreateViewWithoutReplace ( ) { SchemaTableName test = new SchemaTableName ( " test " , " test _ view " ) ; try { metadata . createView ( SESSION , test , " test " , false ) ; } catch ( Exception e ) { fail ( " should ▁ have ▁ succeeded " ) ; } metadata . createView ( SESSION , test , " test " , false ) ; }
yuananf/presto | @ Test public void testCreateViewWithReplace ( ) { SchemaTableName test = new SchemaTableName ( " test " , " test _ view " ) ; metadata . createView ( SESSION , test , " aaa " , true ) ; metadata . createView ( SESSION , test , " bbb " , true ) ; assertEquals ( metadata . getViews ( SESSION , test . toSchemaTablePrefix ( ) ) . get ( test ) . getViewData ( ) , " bbb " ) ; }
yuananf/presto | @ Test public void testTransactionSelect ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; assertFalse ( ( ( RaptorTableHandle ) tableHandle ) . getTransactionId ( ) . isPresent ( ) ) ; }
yuananf/presto | @ Test public void testTransactionTableWrite ( ) { long transactionId = 1 ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , getOrdersTable ( ) , Optional . empty ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
yuananf/presto | @ Test public void testTransactionInsert ( ) { long transactionId = 1 ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; ConnectorInsertTableHandle insertHandle = metadata . beginInsert ( SESSION , tableHandle ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishInsert ( SESSION , insertHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
yuananf/presto | @ Test public void testTransactionDelete ( ) { long transactionId = 1 ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; tableHandle = metadata . beginDelete ( SESSION , tableHandle ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; assertEquals ( raptorTableHandle . getTransactionId ( ) , OptionalLong . of ( transactionId ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . rollback ( ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertFalse ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; tableHandle = metadata . beginDelete ( SESSION , tableHandle ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishDelete ( SESSION , tableHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
yuananf/presto | @ Test public void testTransactionAbort ( ) { long transactionId = 1 ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , getOrdersTable ( ) , Optional . empty ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; shardManager . rollbackTransaction ( transactionId ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertFalse ( transactionSuccessful ( transactionId ) ) ; try { metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; fail ( " expected ▁ exception " ) ; } catch ( PrestoException e ) { assertEquals ( e . getErrorCode ( ) , TRANSACTION_CONFLICT . toErrorCode ( ) ) ; } }
yuananf/presto | private boolean transactionExists ( long transactionId ) { try ( Handle handle = dbi . open ( ) ) { return handle . createQuery ( " SELECT ▁ count ( * ) ▁ FROM ▁ transactions ▁ WHERE ▁ transaction _ id ▁ = ▁ ? " ) . bind ( 0 , transactionId ) . map ( BooleanMapper . FIRST ) . first ( ) ; } }
yuananf/presto | private Boolean transactionSuccessful ( long transactionId ) { try ( Handle handle = dbi . open ( ) ) { return ( Boolean ) handle . createQuery ( " SELECT ▁ successful ▁ FROM ▁ transactions ▁ WHERE ▁ transaction _ id ▁ = ▁ ? " ) . bind ( 0 , transactionId ) . first ( ) . get ( " successful " ) ; } }
yuananf/presto | private Long getTableDistributionId ( long tableId ) { try ( Handle handle = dbi . open ( ) ) { return handle . createQuery ( " SELECT ▁ distribution _ id ▁ FROM ▁ tables ▁ WHERE ▁ table _ id ▁ = ▁ ? " ) . bind ( 0 , tableId ) . map ( LongMapper . FIRST ) . first ( ) ; } }
scaffeinate/crack-the-code | public DetectCycleDirectedGraph ( ) { graph = new DirectedGraph < String > ( ) ; whiteSet = new HashSet < Vertex < String > > ( ) ; greySet = new HashSet < Vertex < String > > ( ) ; blackSet = new HashSet < Vertex < String > > ( ) ; }
scaffeinate/crack-the-code | public void constructGraph ( String [ ] input ) { GraphUtil . constructGraph ( graph , input ) ; vertices = graph . verticesSet ( ) ; }
scaffeinate/crack-the-code | public boolean detectCycle ( ) { whiteSet . addAll ( vertices ) ; for ( Vertex < String > vertex : vertices ) { if ( whiteSet . contains ( vertex ) ) { if ( detectCycleDFS ( vertex ) ) { return true ; } } } return false ; }
scaffeinate/crack-the-code | private boolean detectCycleDFS ( Vertex < String > vertex ) { if ( vertex == null ) { return false ; } whiteSet . remove ( vertex ) ; greySet . add ( vertex ) ; List < Vertex < String > > neighbours = graph . neighboursOf ( vertex ) ; for ( Vertex < String > neighbour : neighbours ) { if ( whiteSet . contains ( neighbour ) ) { if ( detectCycleDFS ( neighbour ) ) { return true ; } } else if ( greySet . contains ( neighbour ) ) { return true ; } } greySet . remove ( vertex ) ; blackSet . add ( vertex ) ; return false ; }
aozkesek/selenium-json-suite-runner | public FindElementCommandDriver ( ) { super ( LoggerFactory . getLogger ( FindElementCommandDriver . class ) ) ; }
aozkesek/selenium-json-suite-runner | @ Override public void execute ( CommandModel commandModel , SuiteDriver suiteDriver ) throws RuntimeException { WebElement webElement = findElement ( commandModel . getArgs ( ) . get ( 0 ) , suiteDriver ) ; commandModel . setValue ( webElement ) ; }
vjanmey/EpicMudfia | @ Override public String name ( ) { return " RandomAreaTemplates " ; }
vjanmey/EpicMudfia | @ Override public boolean isAdminMacro ( ) { return true ; }
vjanmey/EpicMudfia | @ Override public String runMacro ( HTTPRequest httpReq , String parm ) { final java . util . Map < String , String > parms = parseParms ( parm ) ; final MOB M = Authenticate . getAuthenticatedMob ( httpReq ) ; if ( M == null ) return " [ authentication ▁ error ] " ; try { final String last = httpReq . getUrlParameter ( " RTEMPLATE " ) ; if ( parms . containsKey ( " NEXT " ) ) { if ( parms . containsKey ( " RESET " ) ) { if ( last != null ) httpReq . removeUrlParameter ( " RTEMPLATE " ) ; return " " ; } if ( last == null ) return " ▁ @ break @ " ; List < String > fileList = ( List < String > ) httpReq . getRequestObjects ( ) . get ( " RANDOMAREATEMPLATESLIST " ) ; if ( fileList == null ) { fileList = new ArrayList < String > ( ) ; final List < String > templateDirs = new LinkedList < String > ( ) ; templateDirs . add ( " " ) ; while ( templateDirs . size ( ) > 0 ) { final String templateDirPath = templateDirs . remove ( 0 ) ; final CMFile templateDir = new CMFile ( Resources . buildResourcePath ( " randareas / " + templateDirPath ) , M ) ; for ( final CMFile file : templateDir . listFiles ( ) ) { if ( file . isDirectory ( ) && file . canRead ( ) ) templateDirs . add ( templateDirPath + file . getName ( ) + " / " ) ; else fileList . add ( templateDirPath + file . getName ( ) ) ; } } httpReq . getRequestObjects ( ) . put ( " RANDOMAREATEMPLATESLIST " , fileList ) ; } String lastID = " " ; for ( final String RC : fileList ) { if ( ( last . length ( ) > 0 ) && ( last . equals ( lastID ) ) && ( ! RC . equals ( lastID ) ) ) { httpReq . addFakeUrlParameter ( " RTEMPLATE " , RC ) ; return " " ; } lastID = RC ; } httpReq . addFakeUrlParameter ( " RTEMPLATE " , " " ) ; if ( parms . containsKey ( " EMPTYOK " ) ) return " < ! - - EMPTY - - > " ; return " ▁ @ break @ " ; } } catch ( final Exception e ) { return " [ an ▁ error ▁ occurred ▁ performing ▁ the ▁ last ▁ operation ] " ; } return " " ; }
PenguinSquad/Harvest-Festival | public PurchasableDestroy ( long cost , Building building ) { super ( cost , null ) ; this . building = building ; this . cost = cost ; this . resource = ( ( cost >= 0 ) ? " buy : " : " sell : " ) + building . getResource ( ) . toString ( ) . replace ( " : " , " _ " ) ; }
PenguinSquad/Harvest-Festival | @ Override public ItemStack getDisplayStack ( ) { return building . getSpawner ( ) ; }
PenguinSquad/Harvest-Festival | @ Override protected ItemStack getPurchasedStack ( ) { return building . getSpawner ( ) ; }
PenguinSquad/Harvest-Festival | @ Override public boolean canDo ( @ Nonnull World world , @ Nonnull EntityPlayer player , int amount ) { return amount == 1 && TownHelper . getClosestTownToEntity ( player , false ) . hasBuilding ( building ) ; }
PenguinSquad/Harvest-Festival | @ Override @ SuppressWarnings ( " unchecked " ) public boolean canList ( @ Nonnull World world , @ Nonnull EntityPlayer player ) { return TownHelper . getClosestTownToEntity ( player , false ) . hasBuilding ( building ) ; }
PenguinSquad/Harvest-Festival | @ Override public void onPurchased ( EntityPlayer player ) { TownData town = TownHelper . getClosestTownToEntity ( player , false ) ; TownBuilding theBuilding = town . getBuilding ( building ) ; HFTemplate template = BuildingRegistry . INSTANCE . getTemplateForBuilding ( building ) ; if ( template != null && theBuilding != null ) { template . removeBlocks ( player . world , theBuilding . pos , theBuilding . rotation , Blocks . AIR . getDefaultState ( ) , true ) ; if ( theBuilding . building == HFBuildings . FESTIVAL_GROUNDS ) { BuildingFestival . getFestivalTemplateFromFestival ( town . getFestival ( ) ) . removeBlocks ( player . world , theBuilding . pos , theBuilding . rotation , Blocks . AIR . getDefaultState ( ) , true ) ; } TownHelper . < TownDataServer > getClosestTownToEntity ( player , false ) . removeBuilding ( theBuilding ) ; } }
PenguinSquad/Harvest-Festival | @ Override public String getDisplayName ( ) { return TextHelper . formatHF ( " structures . demolish " , building . getLocalisedName ( ) ) ; }
PenguinSquad/Harvest-Festival | @ SideOnly ( Side . CLIENT ) @ Override public void addTooltip ( List < String > list ) { list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning1" ) ) ; list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning2" ) ) ; list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning3" ) ) ; }
signed/intellij-community | @ NotNull @ Override public String getProtocol ( ) { return PROTOCOL ; }
signed/intellij-community | @ Nullable @ Override protected String normalize ( @ NotNull String path ) { int p = path . indexOf ( SEPARATOR ) ; return p > 0 ? FileUtil . normalize ( path . substring ( 0 , p ) ) + path . substring ( p ) : super . normalize ( path ) ; }
signed/intellij-community | @ NotNull @ Override protected String extractLocalPath ( @ NotNull String rootPath ) { return StringUtil . trimEnd ( rootPath , SEPARATOR ) ; }
signed/intellij-community | @ NotNull @ Override protected String composeRootPath ( @ NotNull String localPath ) { return localPath + SEPARATOR ; }
signed/intellij-community | @ NotNull @ Override protected String extractRootPath ( @ NotNull String entryPath ) { int separatorIndex = entryPath . indexOf ( SEPARATOR ) ; assert separatorIndex >= 0 : " Path ▁ passed ▁ to ▁ JrtFileSystem ▁ must ▁ have ▁ a ▁ separator ▁ ' ! / ' : ▁ " + entryPath ; return entryPath . substring ( 0 , separatorIndex + SEPARATOR . length ( ) ) ; }
signed/intellij-community | @ NotNull @ Override protected ArchiveHandler getHandler ( @ NotNull VirtualFile entryFile ) { checkSubscription ( ) ; String homePath = extractLocalPath ( extractRootPath ( entryFile . getPath ( ) ) ) ; ArchiveHandler handler = myHandlers . get ( homePath ) ; if ( handler == null ) { handler = new JrtHandler ( homePath ) ; myHandlers . put ( homePath , handler ) ; ApplicationManager . getApplication ( ) . invokeLater ( ( ) -> LocalFileSystem . getInstance ( ) . refreshAndFindFileByPath ( homePath + " / release " ) , ModalityState . defaultModalityState ( ) ) ; } return handler ; }
signed/intellij-community | private void checkSubscription ( ) { if ( mySubscribed . getAndSet ( true ) ) return ; Application app = ApplicationManager . getApplication ( ) ; app . getMessageBus ( ) . connect ( app ) . subscribe ( VirtualFileManager . VFS_CHANGES , new BulkFileListener ( ) { @ Override public void after ( @ NotNull List < ? extends VFileEvent > events ) { Set < VirtualFile > toRefresh = null ; for ( VFileEvent event : events ) { if ( event . getFileSystem ( ) instanceof LocalFileSystem && event instanceof VFileContentChangeEvent ) { VirtualFile file = event . getFile ( ) ; if ( file != null && " release " . equals ( file . getName ( ) ) ) { String homePath = file . getParent ( ) . getPath ( ) ; ArchiveHandler handler = myHandlers . remove ( homePath ) ; if ( handler != null ) { handler . dispose ( ) ; VirtualFile root = findFileByPath ( composeRootPath ( homePath ) ) ; if ( root != null ) { ( ( NewVirtualFile ) root ) . markDirtyRecursively ( ) ; if ( toRefresh == null ) toRefresh = ContainerUtil . newHashSet ( ) ; toRefresh . add ( root ) ; } } } } } if ( toRefresh != null ) { boolean async = ! ApplicationManager . getApplication ( ) . isUnitTestMode ( ) ; RefreshQueue . getInstance ( ) . refresh ( async , true , null , toRefresh ) ; } } } ) ; }
signed/intellij-community | @ Override public VirtualFile findFileByPath ( @ NotNull String path ) { return VfsImplUtil . findFileByPath ( this , path ) ; }
signed/intellij-community | @ Override public VirtualFile findFileByPathIfCached ( @ NotNull String path ) { return VfsImplUtil . findFileByPathIfCached ( this , path ) ; }
signed/intellij-community | @ Override public VirtualFile refreshAndFindFileByPath ( @ NotNull String path ) { return VfsImplUtil . refreshAndFindFileByPath ( this , path ) ; }
signed/intellij-community | @ Override public void refresh ( boolean asynchronous ) { VfsImplUtil . refresh ( this , asynchronous ) ; }
signed/intellij-community | @ Override protected boolean isCorrectFileType ( @ NotNull VirtualFile local ) { return isModularJdk ( FileUtil . toSystemDependentName ( local . getPath ( ) ) ) ; }
PhilDatoon/CertIV_IntroOOP | Student ( ) { this . studentNum = 12345 ; for ( int x = 0 ; x < course . length ; x ++ ) { this . course [ x ] = new CollegeCourse ( ) ; } }
PhilDatoon/CertIV_IntroOOP | public int getStudentNum ( ) { return this . studentNum ; }
PhilDatoon/CertIV_IntroOOP | public void setStudentNum ( int num ) { this . studentNum = num ; }
PhilDatoon/CertIV_IntroOOP | public CollegeCourse getCourse ( int index ) { return this . course [ index ] ; }
PhilDatoon/CertIV_IntroOOP | public void setCourseID ( String id , int index ) { this . course [ index ] . setCourseID ( id ) ; }
PhilDatoon/CertIV_IntroOOP | public void setCreditHour ( int hour , int index ) { this . course [ index ] . setCreditHour ( hour ) ; }
PhilDatoon/CertIV_IntroOOP | public void setGrade ( String grade , int index ) { this . course [ index ] . setGrade ( grade ) ; }
yurloc/drools | public ZipKieModule ( ReleaseId releaseId , KieModuleModel kieProject , File file ) { super ( releaseId , kieProject ) ; this . file = file ; this . zipEntries = IoUtils . buildZipFileMapEntries ( file ) ; }
yurloc/drools | @ Override public File getFile ( ) { return this . file ; }
yurloc/drools | @ Override public boolean isAvailable ( String name ) { return this . zipEntries . containsKey ( name ) ; }
yurloc/drools | @ Override public byte [ ] getBytes ( String name ) { try { return readBytesFromZipEntry ( file , zipEntries . get ( name ) ) ; } catch ( IOException e ) { throw new RuntimeException ( " Unable ▁ to ▁ get ▁ ZipFile ▁ bytes ▁ for ▁ : ▁ ▁ " + name + " ▁ : ▁ " + file , e ) ; } }
yurloc/drools | @ Override public Collection < String > getFileNames ( ) { return this . zipEntries . keySet ( ) ; }
yurloc/drools | @ Override public byte [ ] getBytes ( ) { throw new UnsupportedOperationException ( ) ; }
yurloc/drools | public String toString ( ) { return " ZipKieModule [ ▁ ReleaseId = " + getReleaseId ( ) + " file = " + file + " ] " ; }
anchela/jackrabbit-oak | @ Before public void prepare ( ) { context . registerInjectActivateService ( new MountInfoProviderService ( ) , " mountedPaths " , new String [ ] { " / foo / bar " } ) ; observer = context . registerInjectActivateService ( new NonDefaultMountWriteReportingObserver ( ) , " ignoredClassNameFragments " , " MarkerToBeIgnored " ) ; reporter = new SpyChangeReporter ( ) ; observer . setReporter ( reporter ) ; }
anchela/jackrabbit-oak | @ Test public void pathAddedUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Added | / foo / bar " , " Added | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void subPathAddedUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; reporter . changes . clear ( ) ; NodeBuilder builder2 = nodeStore . getRoot ( ) . builder ( ) ; builder2 . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder2 , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Changed | / foo / bar " , " Added | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void propertyChangedUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; reporter . changes . clear ( ) ; NodeBuilder builder2 = nodeStore . getRoot ( ) . builder ( ) ; builder2 . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) . setProperty ( " prop " , " val " ) ; nodeStore . merge ( builder2 , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Changed | / foo / bar " , " Changed | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void subPathAddedUnderDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void subPathUnderNonDefaultMountButWithExpectedComponent ( ) throws Exception { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) ; MarkerToBeIgnored . call ( ( ) -> nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void commitWithMixedDefaultAndNonDefaultMounts ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) ; builder . child ( " outside " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Added | / foo / bar " ) ) ) ; }
anchela/jackrabbit-oak | @ Test public void commitWithDeletedNodeUnderNonDefaultMount ( ) throws CommitFailedException { MemoryNodeStore nodeStore = new MemoryNodeStore ( ) ; nodeStore . addObserver ( observer ) ; NodeBuilder builder = nodeStore . getRoot ( ) . builder ( ) ; builder . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) ; nodeStore . merge ( builder , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; reporter . changes . clear ( ) ; NodeBuilder builder2 = nodeStore . getRoot ( ) . builder ( ) ; builder2 . child ( " foo " ) . child ( " bar " ) . child ( " baz " ) . remove ( ) ; nodeStore . merge ( builder2 , EmptyHook . INSTANCE , CommitInfo . EMPTY ) ; assertThat ( reporter . changes , equalTo ( Arrays . asList ( " Changed | / foo / bar " , " Deleted | / foo / bar / baz " ) ) ) ; }
anchela/jackrabbit-oak | @ Override void reportChanges ( Map < String , String > changes , RuntimeException ignored ) { changes . forEach ( ( path , type ) -> this . changes . add ( type + " | " + path ) ) ; }
Kwangseob/graphhopper | @ Before public void setUp ( ) { instance = new SRTMProvider ( ) ; }
Kwangseob/graphhopper | @ After public void tearDown ( ) { instance . release ( ) ; }
Kwangseob/graphhopper | @ Test public void testGetFileString ( ) { assertEquals ( " Eurasia / N49E011" , instance . getFileString ( 49 , 11 ) ) ; assertEquals ( " Eurasia / N52W002" , instance . getFileString ( 52.268157 , - 1.230469 ) ) ; assertEquals ( " Africa / S06E034" , instance . getFileString ( - 5.965754 , 34.804687 ) ) ; assertEquals ( " Australia / S29E131" , instance . getFileString ( - 28.304381 , 131.484375 ) ) ; assertEquals ( " South _ America / S09W045" , instance . getFileString ( - 9 , - 45 ) ) ; assertEquals ( " South _ America / S10W046" , instance . getFileString ( - 9.1 , - 45.1 ) ) ; assertEquals ( " South _ America / S10W045" , instance . getFileString ( - 9.6 , - 45 ) ) ; assertEquals ( " South _ America / S28W071" , instance . getFileString ( - 28 , - 71 ) ) ; assertEquals ( " South _ America / S29W072" , instance . getFileString ( - 28.88316 , - 71.070557 ) ) ; }
Kwangseob/graphhopper | @ Test public void testGetHeight ( ) throws IOException { instance . setCacheDir ( new File ( " . / files / " ) ) ; assertEquals ( 466 , instance . getEle ( 49.968651 , 11.574869 ) , 1e-1 ) ; assertEquals ( 330 , instance . getEle ( 49.958233 , 11.558647 ) , 1e-1 ) ; assertEquals ( 1678 , instance . getEle ( - 28.88316 , - 71.070557 ) , 1e-1 ) ; assertEquals ( 0 , instance . getEle ( - 28.671311 , - 71.38916 ) , 1e-1 ) ; assertEquals ( 0 , instance . getEle ( 55.4711873 , 19.2501641 ) , 1e-1 ) ; assertEquals ( 161 , instance . getEle ( 55.8943144 , - 3 ) , 1e-1 ) ; }
Kwangseob/graphhopper | @ Test public void testGetHeightMMap ( ) throws IOException { instance . setCacheDir ( new File ( " . / files / " ) ) ; instance . setDAType ( DAType . MMAP ) ; assertEquals ( 161 , instance . getEle ( 55.8943144 , - 3 ) , 1e-1 ) ; }
spotify/styx | RuntimeIOException ( IOException cause ) { super ( cause ) ; this . cause = Objects . requireNonNull ( cause ) ; }
spotify/styx | @ Override public synchronized IOException getCause ( ) { return cause ; }
Groostav/CMPT880-term-project | public WMFFont ( Font font , int charset ) { this . font = font ; this . charset = charset ; }
Groostav/CMPT880-term-project | public WMFFont ( Font font , int charset , int underline , int strikeOut , int italic , int weight , int orient , int escape ) { this . font = font ; this . charset = charset ; this . underline = underline ; this . strikeOut = strikeOut ; this . italic = italic ; this . weight = weight ; this . orientation = orient ; this . escape = escape ; }
DavidWhitlock/PortlandStateJava | void assertEquals ( Person p1 , Person p2 ) { if ( p1 == null ) { assertNull ( p2 ) ; return ; } else if ( p2 == null ) { assertNull ( p1 ) ; return ; } assertNotNull ( p1 ) ; assertNotNull ( p2 ) ; Assertions . assertEquals ( p1 . getId ( ) , p2 . getId ( ) ) ; Assertions . assertEquals ( p1 . getGender ( ) , p2 . getGender ( ) ) ; Assertions . assertEquals ( p1 . getFirstName ( ) , p2 . getFirstName ( ) ) ; Assertions . assertEquals ( p1 . getMiddleName ( ) , p2 . getMiddleName ( ) ) ; Assertions . assertEquals ( p1 . getLastName ( ) , p2 . getLastName ( ) ) ; assertEquals ( p1 . getMother ( ) , p2 . getMother ( ) ) ; assertEquals ( p1 . getFather ( ) , p2 . getFather ( ) ) ; assertEquals ( p1 . getDateOfBirth ( ) , p2 . getDateOfBirth ( ) ) ; assertEquals ( p1 . getDateOfDeath ( ) , p2 . getDateOfDeath ( ) ) ; Assertions . assertEquals ( p1 . getMarriages ( ) . size ( ) , p2 . getMarriages ( ) . size ( ) ) ; Iterator < Marriage > iter1 = p1 . getMarriages ( ) . iterator ( ) ; Iterator < Marriage > iter2 = p2 . getMarriages ( ) . iterator ( ) ; while ( iter1 . hasNext ( ) && iter2 . hasNext ( ) ) { assertEquals ( iter1 . next ( ) , iter2 . next ( ) ) ; } }
DavidWhitlock/PortlandStateJava | void assertEquals ( Date d1 , Date d2 ) { if ( d1 == null ) { assertNull ( d2 ) ; return ; } else if ( d2 == null ) { assertNull ( d1 ) ; return ; } Calendar c1 = Calendar . getInstance ( ) ; c1 . setTime ( d1 ) ; Calendar c2 = Calendar . getInstance ( ) ; c2 . setTime ( d2 ) ; Assertions . assertEquals ( c1 . get ( Calendar . DAY_OF_YEAR ) , c2 . get ( Calendar . DAY_OF_YEAR ) ) ; Assertions . assertEquals ( c1 . get ( Calendar . YEAR ) , c2 . get ( Calendar . YEAR ) ) ; }
DavidWhitlock/PortlandStateJava | void assertEquals ( Marriage m1 , Marriage m2 ) { if ( m1 == null ) { assertNotNull ( m2 ) ; return ; } else if ( m2 == null ) { assertNull ( m1 ) ; return ; } Assertions . assertEquals ( m1 . getHusband ( ) . getId ( ) , m2 . getHusband ( ) . getId ( ) ) ; Assertions . assertEquals ( m1 . getWife ( ) . getId ( ) , m2 . getWife ( ) . getId ( ) ) ; assertEquals ( m1 . getDate ( ) , m2 . getDate ( ) ) ; Assertions . assertEquals ( m1 . getLocation ( ) , m2 . getLocation ( ) ) ; }
DavidWhitlock/PortlandStateJava | void assertEquals ( FamilyTree tree1 , FamilyTree tree2 ) { Assertions . assertEquals ( tree1 . getPeople ( ) . size ( ) , tree2 . getPeople ( ) . size ( ) ) ; for ( Person person : tree1 . getPeople ( ) ) { Person p2 = tree2 . getPerson ( person . getId ( ) ) ; assertNotNull ( p2 ) ; assertEquals ( person , p2 ) ; } }
DavidWhitlock/PortlandStateJava | void assertContains ( String container , String containee ) { assertTrue ( container . indexOf ( containee ) != - 1 ) ; }
DavidWhitlock/PortlandStateJava | void assertContains ( String message , String container , String containee ) { assertTrue ( container . indexOf ( containee ) != - 1 , message ) ; }
xvik/dropwizard-guicey | @ Override public void setConfiguration ( final C configuration ) { this . configuration = configuration ; }
xvik/dropwizard-guicey | @ Override public void setBootstrap ( final Bootstrap < C > bootstrap ) { this . bootstrap = bootstrap ; }
xvik/dropwizard-guicey | @ Override public void setEnvironment ( final Environment environment ) { this . environment = environment ; }
xvik/dropwizard-guicey | @ Override public void setOptions ( final Options options ) { this . options = options ; }
xvik/dropwizard-guicey | @ Override public void setConfigurationTree ( final ConfigurationTree configurationTree ) { this . configurationTree = configurationTree ; }
xvik/dropwizard-guicey | protected Bootstrap < C > bootstrap ( ) { return bootstrap ; }
xvik/dropwizard-guicey | protected C configuration ( ) { return configuration ; }
xvik/dropwizard-guicey | protected < T > T configuration ( final String yamlPath ) { return configurationTree ( ) . valueByPath ( yamlPath ) ; }
xvik/dropwizard-guicey | protected < T , K extends T > K configuration ( final Class < T > type ) { return configurationTree ( ) . valueByUniqueDeclaredType ( type ) ; }
xvik/dropwizard-guicey | protected < T > List < ? extends T > configurations ( final Class < T > type ) { return configurationTree ( ) . valuesByType ( type ) ; }
xvik/dropwizard-guicey | protected ConfigurationTree configurationTree ( ) { return configurationTree ; }
xvik/dropwizard-guicey | protected Environment environment ( ) { return environment ; }
xvik/dropwizard-guicey | protected String appPackage ( ) { return bootstrap ( ) . getApplication ( ) . getClass ( ) . getPackage ( ) . getName ( ) ; }
xvik/dropwizard-guicey | protected Options options ( ) { return options ; }
xvik/dropwizard-guicey | public void shareState ( final Class < ? > key , final Object value ) { SharedConfigurationState . getOrFail ( environment ( ) , STATE_NOT_FOUND ) . put ( key , value ) ; }
xvik/dropwizard-guicey | public < T > T sharedState ( final Class < ? > key , final Supplier < T > defaultValue ) { return SharedConfigurationState . getOrFail ( environment ( ) , STATE_NOT_FOUND ) . get ( key , defaultValue ) ; }
xvik/dropwizard-guicey | protected < T > Optional < T > sharedState ( final Class < ? > key ) { return SharedConfigurationState . lookup ( environment ( ) , key ) ; }
xvik/dropwizard-guicey | protected < T > T sharedStateOrFail ( final Class < ? > key , final String message , final Object ... args ) { return SharedConfigurationState . lookupOrFail ( environment ( ) , key , message , args ) ; }
selvasingh/azure-sdk-for-java | public void createEventData ( ) { TelemetryEvent telemetry = new TelemetryEvent ( " temperature " , "37" ) ; byte [ ] serializedTelemetryData = telemetry . toString ( ) . getBytes ( UTF_8 ) ; EventData eventData = new EventData ( serializedTelemetryData ) ; eventData . getProperties ( ) . put ( " eventType " , TelemetryEvent . class . getName ( ) ) ; }
selvasingh/azure-sdk-for-java | public void sharingConnection ( ) { EventHubClientBuilder builder = new EventHubClientBuilder ( ) . connectionString ( " event - hubs - instance - connection - string " ) . shareConnection ( ) ; EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; EventHubConsumerAsyncClient consumer = builder . consumerGroup ( " my - consumer - group " ) . buildAsyncConsumerClient ( ) ; }
selvasingh/azure-sdk-for-java | public void instantiateConsumerAsyncClient ( ) { EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; " + " SharedAccessKey = { key } ; EntityPath = { eh - name } " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; consumer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void receive ( ) { String partitionId = "0" ; EventPosition startingPosition = EventPosition . latest ( ) ; Disposable subscription = consumer . receiveFromPartition ( partitionId , startingPosition ) . subscribe ( partitionEvent -> { PartitionContext partitionContext = partitionEvent . getPartitionContext ( ) ; EventData event = partitionEvent . getData ( ) ; System . out . printf ( " Received ▁ event ▁ from ▁ partition ▁ ' % s ' % n " , partitionContext . getPartitionId ( ) ) ; System . out . printf ( " Contents ▁ of ▁ event ▁ as ▁ string : ▁ ' % s ' % n " , event . getBodyAsString ( ) ) ; } , error -> System . err . print ( error . toString ( ) ) ) ; subscription . dispose ( ) ; }
selvasingh/azure-sdk-for-java | public void receiveBackpressure ( ) { String partitionId = "0" ; EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " fake - string " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; consumer . receiveFromPartition ( partitionId , EventPosition . latest ( ) ) . subscribe ( new BaseSubscriber < PartitionEvent > ( ) { private static final int NUMBER_OF_EVENTS = 5 ; private final AtomicInteger currentNumberOfEvents = new AtomicInteger ( ) ; @ Override protected void hookOnSubscribe ( Subscription subscription ) { request ( NUMBER_OF_EVENTS ) ; } @ Override protected void hookOnNext ( PartitionEvent value ) { if ( currentNumberOfEvents . incrementAndGet ( ) % 5 == 0 ) { request ( NUMBER_OF_EVENTS ) ; } } } ) ; }
selvasingh/azure-sdk-for-java | public void receiveAll ( ) { EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " fake - string " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; consumer . receive ( true ) . subscribe ( partitionEvent -> { PartitionContext context = partitionEvent . getPartitionContext ( ) ; EventData event = partitionEvent . getData ( ) ; System . out . printf ( " Event ▁ % s ▁ is ▁ from ▁ partition ▁ % s % n . " , event . getSequenceNumber ( ) , context . getPartitionId ( ) ) ; } ) ; }
selvasingh/azure-sdk-for-java | public void receiveLastEnqueuedInformation ( ) { EventHubConsumerAsyncClient consumer = new EventHubClientBuilder ( ) . connectionString ( " event - hub - instance - connection - string " ) . consumerGroup ( " consumer - group - name " ) . buildAsyncConsumerClient ( ) ; ReceiveOptions receiveOptions = new ReceiveOptions ( ) . setTrackLastEnqueuedEventProperties ( true ) ; consumer . receiveFromPartition ( "0" , EventPosition . earliest ( ) , receiveOptions ) . subscribe ( partitionEvent -> { LastEnqueuedEventProperties properties = partitionEvent . getLastEnqueuedEventProperties ( ) ; System . out . printf ( " Information ▁ received ▁ at ▁ % s . ▁ Last ▁ enqueued ▁ sequence ▁ number : ▁ % s % n " , properties . getRetrievalTime ( ) , properties . getSequenceNumber ( ) ) ; } ) ; }
selvasingh/azure-sdk-for-java | public void instantiateConsumerClient ( ) { EventHubConsumerClient consumer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { eh - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } ; Entity - Path = { hub - name } " ) . consumerGroup ( " $ DEFAULT " ) . buildConsumerClient ( ) ; consumer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void receiveFromSinglePartition ( ) { EventHubConsumerClient consumer = new EventHubClientBuilder ( ) . connectionString ( " event - hub - instance - connection - string " ) . consumerGroup ( " consumer - group - name " ) . buildConsumerClient ( ) ; Instant twelveHoursAgo = Instant . now ( ) . minus ( Duration . ofHours ( 12 ) ) ; EventPosition startingPosition = EventPosition . fromEnqueuedTime ( twelveHoursAgo ) ; String partitionId = "0" ; IterableStream < PartitionEvent > events = consumer . receiveFromPartition ( partitionId , 100 , startingPosition , Duration . ofSeconds ( 30 ) ) ; Long lastSequenceNumber = - 1L ; for ( PartitionEvent partitionEvent : events ) { System . out . print ( " Event ▁ received : ▁ " + partitionEvent . getData ( ) . getSequenceNumber ( ) ) ; lastSequenceNumber = partitionEvent . getData ( ) . getSequenceNumber ( ) ; } if ( lastSequenceNumber != - 1L ) { EventPosition nextPosition = EventPosition . fromSequenceNumber ( lastSequenceNumber , false ) ; IterableStream < PartitionEvent > nextEvents = consumer . receiveFromPartition ( partitionId , 100 , nextPosition , Duration . ofSeconds ( 30 ) ) ; } }
selvasingh/azure-sdk-for-java | public void instantiateProducerAsyncClient ( ) { EventHubProducerAsyncClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildAsyncProducerClient ( ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchAutomaticRoutingAsync ( ) { EventHubProducerAsyncClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildAsyncProducerClient ( ) ; producer . createBatch ( ) . flatMap ( batch -> { batch . tryAdd ( new EventData ( " test - event - 1" ) ) ; batch . tryAdd ( new EventData ( " test - event - 2" ) ) ; return producer . send ( batch ) ; } ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ batch : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionIdAsync ( ) { EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionId ( " foo " ) ; producer . createBatch ( options ) . flatMap ( batch -> { batch . tryAdd ( new EventData ( " test - event - 1" ) ) ; batch . tryAdd ( new EventData ( " test - event - 2" ) ) ; return producer . send ( batch ) ; } ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ batch : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionKeyAsync ( ) { EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionKey ( " bread " ) ; producer . createBatch ( options ) . flatMap ( batch -> { batch . tryAdd ( new EventData ( " sourdough " ) ) ; batch . tryAdd ( new EventData ( " rye " ) ) ; return producer . send ( batch ) ; } ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ batch : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; }
selvasingh/azure-sdk-for-java | public void batchSizeLimitedAsync ( ) { final EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; final EventData firstEvent = new EventData ( "92" . getBytes ( UTF_8 ) ) ; firstEvent . getProperties ( ) . put ( " telemetry " , " latency " ) ; final EventData secondEvent = new EventData ( "98" . getBytes ( UTF_8 ) ) ; secondEvent . getProperties ( ) . put ( " telemetry " , " cpu - temperature " ) ; final Flux < EventData > telemetryEvents = Flux . just ( firstEvent , secondEvent ) ; final CreateBatchOptions options = new CreateBatchOptions ( ) . setMaximumSizeInBytes ( 256 ) ; final AtomicReference < EventDataBatch > currentBatch = new AtomicReference < > ( producer . createBatch ( options ) . block ( ) ) ; telemetryEvents . flatMap ( event -> { final EventDataBatch batch = currentBatch . get ( ) ; if ( batch . tryAdd ( event ) ) { return Mono . empty ( ) ; } return Mono . when ( producer . send ( batch ) , producer . createBatch ( options ) . map ( newBatch -> { currentBatch . set ( newBatch ) ; if ( ! newBatch . tryAdd ( event ) ) { throw Exceptions . propagate ( new IllegalArgumentException ( " Event ▁ was ▁ too ▁ large ▁ to ▁ fit ▁ in ▁ an ▁ empty ▁ batch . ▁ Max ▁ size : ▁ " + newBatch . getMaxSizeInBytes ( ) ) ) ; } return newBatch ; } ) ) ; } ) . then ( ) . doFinally ( signal -> { final EventDataBatch batch = currentBatch . getAndSet ( null ) ; if ( batch != null && batch . getCount ( ) > 0 ) { producer . send ( batch ) . block ( ) ; } } ) ; }
selvasingh/azure-sdk-for-java | public void sendIterableSampleAsync ( ) { final EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " maple " ) , new EventData ( " aspen " ) , new EventData ( " oak " ) ) ; producer . send ( events ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ events : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; }
selvasingh/azure-sdk-for-java | public void sendIterableWithPartitionKeySampleAsync ( ) { final EventHubProducerAsyncClient producer = builder . buildAsyncProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " Melbourne " ) , new EventData ( " London " ) , new EventData ( " New ▁ York " ) ) ; SendOptions sendOptions = new SendOptions ( ) . setPartitionKey ( " cities " ) ; producer . send ( events , sendOptions ) . subscribe ( unused -> { } , error -> System . err . println ( " Error ▁ occurred ▁ while ▁ sending ▁ events : " + error ) , ( ) -> System . out . println ( " Send ▁ complete . " ) ) ; }
selvasingh/azure-sdk-for-java | public void instantiateProducerClient ( ) { EventHubProducerClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildProducerClient ( ) ; producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchAutomaticRouting ( ) { EventHubProducerClient producer = new EventHubClientBuilder ( ) . connectionString ( " Endpoint = { fully - qualified - namespace } ; SharedAccessKeyName = { policy - name } ; SharedAccessKey = { key } " , " event - hub - name " ) . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " test - event - 1" ) , new EventData ( " test - event - 2" ) ) ; EventDataBatch batch = producer . createBatch ( ) ; for ( EventData event : events ) { if ( batch . tryAdd ( event ) ) { continue ; } producer . send ( batch ) ; batch = producer . createBatch ( ) ; if ( ! batch . tryAdd ( event ) ) { throw new IllegalArgumentException ( " Event ▁ is ▁ too ▁ large ▁ for ▁ an ▁ empty ▁ batch . " ) ; } } producer . close ( ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionId ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionId ( " foo " ) ; EventDataBatch batch = producer . createBatch ( options ) ; batch . tryAdd ( new EventData ( " data - to - partition - foo " ) ) ; producer . send ( batch ) ; }
selvasingh/azure-sdk-for-java | public void batchPartitionKey ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " sourdough " ) , new EventData ( " rye " ) , new EventData ( " wheat " ) ) ; CreateBatchOptions options = new CreateBatchOptions ( ) . setPartitionKey ( " bread " ) ; EventDataBatch batch = producer . createBatch ( options ) ; events . forEach ( event -> batch . tryAdd ( event ) ) ; producer . send ( batch ) ; }
selvasingh/azure-sdk-for-java | public void batchSizeLimited ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; final EventData firstEvent = new EventData ( "92" . getBytes ( UTF_8 ) ) ; firstEvent . getProperties ( ) . put ( " telemetry " , " latency " ) ; final EventData secondEvent = new EventData ( "98" . getBytes ( UTF_8 ) ) ; secondEvent . getProperties ( ) . put ( " telemetry " , " cpu - temperature " ) ; final EventData thirdEvent = new EventData ( "120" . getBytes ( UTF_8 ) ) ; thirdEvent . getProperties ( ) . put ( " telemetry " , " fps " ) ; final List < EventData > telemetryEvents = Arrays . asList ( firstEvent , secondEvent , thirdEvent ) ; final CreateBatchOptions options = new CreateBatchOptions ( ) . setMaximumSizeInBytes ( 256 ) ; EventDataBatch currentBatch = producer . createBatch ( options ) ; for ( EventData event : telemetryEvents ) { if ( ! currentBatch . tryAdd ( event ) ) { producer . send ( currentBatch ) ; currentBatch = producer . createBatch ( options ) ; if ( ! currentBatch . tryAdd ( event ) ) { throw new IllegalArgumentException ( " Event ▁ is ▁ too ▁ large ▁ for ▁ an ▁ empty ▁ batch . " ) ; } } } }
selvasingh/azure-sdk-for-java | public void sendIterableSample ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " maple " ) , new EventData ( " aspen " ) , new EventData ( " oak " ) ) ; producer . send ( events ) ; }
selvasingh/azure-sdk-for-java | public void sendIterableWithPartitionKeySample ( ) { final EventHubProducerClient producer = builder . buildProducerClient ( ) ; List < EventData > events = Arrays . asList ( new EventData ( " Melbourne " ) , new EventData ( " London " ) , new EventData ( " New ▁ York " ) ) ; SendOptions sendOptions = new SendOptions ( ) . setPartitionKey ( " cities " ) ; producer . send ( events , sendOptions ) ; }
selvasingh/azure-sdk-for-java | public EventProcessorClient createEventProcessor ( ) { String connectionString = " Endpoint = { endpoint } ; SharedAccessKeyName = { sharedAccessKeyName } ; " + " SharedAccessKey = { sharedAccessKey } ; EntityPath = { eventHubName } " ; EventProcessorClient eventProcessorClient = new EventProcessorClientBuilder ( ) . consumerGroup ( " consumer - group " ) . checkpointStore ( new SampleCheckpointStore ( ) ) . processEvent ( eventContext -> { System . out . println ( " Partition ▁ id ▁ = ▁ " + eventContext . getPartitionContext ( ) . getPartitionId ( ) + " and ▁ sequence ▁ number ▁ of ▁ event ▁ = ▁ " + eventContext . getEventData ( ) . getSequenceNumber ( ) ) ; } ) . processError ( errorContext -> { System . out . printf ( " Error ▁ occurred ▁ in ▁ partition ▁ processor ▁ for ▁ partition ▁ { } , ▁ { } " , errorContext . getPartitionContext ( ) . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; } ) . connectionString ( connectionString ) . buildEventProcessorClient ( ) ; return eventProcessorClient ; }
selvasingh/azure-sdk-for-java | public void receiveBatchSample ( ) { String connectionString = " Endpoint = { endpoint } ; SharedAccessKeyName = { sharedAccessKeyName } ; " + " SharedAccessKey = { sharedAccessKey } ; EntityPath = { eventHubName } " ; EventProcessorClient eventProcessorClient = new EventProcessorClientBuilder ( ) . consumerGroup ( " consumer - group " ) . checkpointStore ( new SampleCheckpointStore ( ) ) . processEventBatch ( eventBatchContext -> { eventBatchContext . getEvents ( ) . forEach ( eventData -> { System . out . println ( " Partition ▁ id ▁ = ▁ " + eventBatchContext . getPartitionContext ( ) . getPartitionId ( ) + " and ▁ sequence ▁ number ▁ of ▁ event ▁ = ▁ " + eventData . getSequenceNumber ( ) ) ; } ) ; } , 50 , Duration . ofSeconds ( 30 ) ) . processError ( errorContext -> { System . out . printf ( " Error ▁ occurred ▁ in ▁ partition ▁ processor ▁ for ▁ partition ▁ { } , ▁ { } " , errorContext . getPartitionContext ( ) . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; } ) . connectionString ( connectionString ) . buildEventProcessorClient ( ) ; }
selvasingh/azure-sdk-for-java | public void startStopSample ( ) { String connectionString = " Endpoint = { endpoint } ; SharedAccessKeyName = { sharedAccessKeyName } ; " + " SharedAccessKey = { sharedAccessKey } ; EntityPath = { eventHubName } " ; EventProcessorClient eventProcessorClient = new EventProcessorClientBuilder ( ) . connectionString ( connectionString ) . processEvent ( eventContext -> { System . out . println ( " Partition ▁ id ▁ = ▁ " + eventContext . getPartitionContext ( ) . getPartitionId ( ) + " ▁ and ▁ " + " sequence ▁ number ▁ of ▁ event ▁ = ▁ " + eventContext . getEventData ( ) . getSequenceNumber ( ) ) ; } ) . processError ( errorContext -> { System . out . printf ( " Error ▁ occurred ▁ in ▁ partition ▁ processor ▁ for ▁ partition ▁ { } , ▁ { } " , errorContext . getPartitionContext ( ) . getPartitionId ( ) , errorContext . getThrowable ( ) ) ; } ) . consumerGroup ( " consumer - group " ) . buildEventProcessorClient ( ) ; eventProcessorClient . start ( ) ; eventProcessorClient . stop ( ) ; }
selvasingh/azure-sdk-for-java | private TelemetryEvent ( String name , String value ) { this . name = name ; this . value = value ; }
selvasingh/azure-sdk-for-java | @ Override public String toString ( ) { return String . format ( " [ name ] = % s ; [ value ] = % s " , name , value ) ; }
worldcoinproject/worldcoin-wallet-java | public WorldcoinWalletCheckpointManager ( NetworkParameters params , InputStream inputStream ) throws IOException { super ( params , inputStream ) ; }
worldcoinproject/worldcoin-wallet-java | public StoredBlock getCheckpointBeforeOrAtHeight ( int height ) { Map . Entry < Long , StoredBlock > highestCheckpointBeforeHeight = null ; for ( Map . Entry < Long , StoredBlock > loop : checkpoints . entrySet ( ) ) { if ( loop . getValue ( ) . getHeight ( ) < height ) { if ( highestCheckpointBeforeHeight == null ) { highestCheckpointBeforeHeight = loop ; } else { if ( highestCheckpointBeforeHeight . getValue ( ) . getHeight ( ) < loop . getValue ( ) . getHeight ( ) ) { highestCheckpointBeforeHeight = loop ; } } } } if ( highestCheckpointBeforeHeight == null ) { try { return new StoredBlock ( params . getGenesisBlock ( ) , params . getGenesisBlock ( ) . getWork ( ) , 0 ) ; } catch ( VerificationException e ) { e . printStackTrace ( ) ; } } return highestCheckpointBeforeHeight . getValue ( ) ; }
111t8e/h2o-2 | for ( Sys s : Sys . values ( ) ) { String str = System . getProperty ( " log . " + s ) ; if ( str == null ) continue ; if ( str . equals ( " false " ) ) unsetFlag ( s ) ; else setFlag ( s ) ; }
111t8e/h2o-2 | private void init ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages , Object message , Timer t ) { this . kind = kind ; this . ouch = ouch ; this . messages = messages ; this . message = message ; this . sys = sys ; this . when = t ; this . printMe = true ; }
111t8e/h2o-2 | public String toString ( ) { StringBuilder buf = longHeader ( new StringBuilder ( 120 ) ) ; int headroom = buf . length ( ) ; buf . append ( body ( headroom ) ) ; return buf . toString ( ) ; }
111t8e/h2o-2 | public String toShortString ( ) { StringBuilder buf = shortHeader ( new StringBuilder ( 120 ) ) ; int headroom = buf . length ( ) ; buf . append ( body ( headroom ) ) ; return buf . toString ( ) ; }
111t8e/h2o-2 | private String body ( int headroom ) { StringBuilder buf = new StringBuilder ( 120 ) ; if ( messages != null ) for ( Object m : messages ) buf . append ( m . toString ( ) ) ; else if ( message != null ) buf . append ( message . toString ( ) ) ; if ( buf . indexOf ( " \n " ) != - 1 ) { String s = buf . toString ( ) ; String [ ] lines = s . split ( " \n " ) ; if ( lines . length > 0 ) { StringBuilder buf2 = new StringBuilder ( 2 * buf . length ( ) ) ; buf2 . append ( lines [ 0 ] ) ; for ( int i = 1 ; i < lines . length ; i ++ ) { buf2 . append ( NL ) . append ( " + " ) ; for ( int j = 1 ; j < headroom ; j ++ ) buf2 . append ( " ▁ " ) ; buf2 . append ( lines [ i ] ) ; } buf = buf2 ; } } if ( ouch != null ) { buf . append ( NL ) ; Writer wr = new StringWriter ( ) ; PrintWriter pwr = new PrintWriter ( wr ) ; ouch . printStackTrace ( pwr ) ; String mess = wr . toString ( ) ; String [ ] lines = mess . split ( " \n " ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { buf . append ( " + " ) ; for ( int j = 1 ; j < headroom ; j ++ ) buf . append ( " ▁ " ) ; buf . append ( lines [ i ] ) ; if ( i != lines . length - 1 ) buf . append ( NL ) ; } } return buf . toString ( ) ; }
111t8e/h2o-2 | private StringBuilder longHeader ( StringBuilder buf ) { String headers = _longHeaders ; if ( headers == null ) { String host = H2O . SELF_ADDRESS != null ? H2O . SELF_ADDRESS . getHostAddress ( ) : " " ; headers = fixedLength ( host + " : " + H2O . API_PORT + " ▁ " , 22 ) + fixedLength ( PID + " ▁ " , 6 ) ; if ( H2O . SELF_ADDRESS != null ) _longHeaders = headers ; } buf . append ( when . startAsString ( ) ) . append ( " ▁ " ) . append ( headers ) ; if ( thread == null ) thread = fixedLength ( Thread . currentThread ( ) . getName ( ) + " ▁ " , 10 ) ; buf . append ( thread ) ; buf . append ( kind . toString ( ) ) . append ( " ▁ " ) . append ( sys . toString ( ) ) . append ( " : ▁ " ) ; return buf ; }
111t8e/h2o-2 | private StringBuilder shortHeader ( StringBuilder buf ) { buf . append ( when . startAsShortString ( ) ) . append ( " ▁ " ) ; if ( H2O . DEBUG ) { String host = H2O . SELF_ADDRESS != null ? H2O . SELF_ADDRESS . getHostAddress ( ) : " " ; buf . append ( fixedLength ( host + " : " + H2O . API_PORT + " ▁ " , 18 ) ) ; } if ( thread == null ) thread = fixedLength ( Thread . currentThread ( ) . getName ( ) + " ▁ " , 8 ) ; buf . append ( thread ) ; if ( ! H2O . DEBUG ) buf . append ( kind . toString ( ) ) . append ( " ▁ " ) . append ( sys . toString ( ) ) . append ( " : ▁ " ) ; return buf ; }
111t8e/h2o-2 | Wrapper ( PrintStream parent ) { super ( parent ) ; this . parent = parent ; }
111t8e/h2o-2 | @ Override public PrintStream printf ( String format , Object ... args ) { super . print ( log ( null , false , format , args ) ) ; return this ; }
111t8e/h2o-2 | @ Override public PrintStream printf ( Locale l , String format , Object ... args ) { super . print ( log ( l , false , format , args ) ) ; return this ; }
111t8e/h2o-2 | @ Override public void println ( String x ) { super . print ( log ( null , true , " % s " , x ) ) ; }
111t8e/h2o-2 | void printlnParent ( String s ) { super . println ( s ) ; }
111t8e/h2o-2 | LogStr ( LogStr l , String date , H2ONode h2o , long pid , String thr , Kind kind , Sys sys , String msg ) { _dates = l == null ? new String [ MAX ] : l . _dates ; _h2os = l == null ? new H2ONode [ MAX ] : l . _h2os ; _pids = l == null ? new long [ MAX ] : l . _pids ; _thrs = l == null ? new String [ MAX ] : l . _thrs ; _kinds = l == null ? new byte [ MAX ] : l . _kinds ; _syss = l == null ? new byte [ MAX ] : l . _syss ; _msgs = l == null ? new String [ MAX ] : l . _msgs ; _idx = l == null ? 0 : ( l . _idx + 1 ) & ( MAX - 1 ) ; _dates [ _idx ] = date ; _h2os [ _idx ] = h2o ; _pids [ _idx ] = pid ; _thrs [ _idx ] = thr ; _kinds [ _idx ] = ( byte ) kind . ordinal ( ) ; _syss [ _idx ] = ( byte ) sys . ordinal ( ) ; _msgs [ _idx ] = msg ; }
guard163/cassandra | private ListType ( AbstractType < T > elements , boolean isMultiCell ) { super ( ComparisonType . CUSTOM , Kind . LIST ) ; this . elements = elements ; this . serializer = ListSerializer . getInstance ( elements . getSerializer ( ) ) ; this . isMultiCell = isMultiCell ; }
guard163/cassandra | public AbstractType < T > getElementsType ( ) { return elements ; }
guard163/cassandra | public AbstractType < UUID > nameComparator ( ) { return TimeUUIDType . instance ; }
guard163/cassandra | public AbstractType < T > valueComparator ( ) { return elements ; }
guard163/cassandra | public ListSerializer < T > getSerializer ( ) { return serializer ; }
guard163/cassandra | @ Override public AbstractType < ? > freeze ( ) { if ( isMultiCell ) return getInstance ( this . elements , false ) ; else return this ; }
guard163/cassandra | @ Override public boolean isMultiCell ( ) { return isMultiCell ; }
guard163/cassandra | @ Override public boolean isCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isCompatibleWith ( ( ( ListType ) previous ) . elements ) ; }
guard163/cassandra | @ Override public boolean isValueCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isValueCompatibleWithInternal ( ( ( ListType ) previous ) . elements ) ; }
guard163/cassandra | @ Override public int compareCustom ( ByteBuffer o1 , ByteBuffer o2 ) { return compareListOrSet ( elements , o1 , o2 ) ; }
guard163/cassandra | @ Override public String toString ( boolean ignoreFreezing ) { boolean includeFrozenType = ! ignoreFreezing && ! isMultiCell ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( includeFrozenType ) sb . append ( FrozenType . class . getName ( ) ) . append ( " ( " ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( TypeParser . stringifyTypeParameters ( Collections . < AbstractType < ? > > singletonList ( elements ) , ignoreFreezing || ! isMultiCell ) ) ; if ( includeFrozenType ) sb . append ( " ) " ) ; return sb . toString ( ) ; }
guard163/cassandra | public List < ByteBuffer > serializedValues ( Iterator < Cell > cells ) { assert isMultiCell ; List < ByteBuffer > bbs = new ArrayList < ByteBuffer > ( ) ; while ( cells . hasNext ( ) ) bbs . add ( cells . next ( ) . value ( ) ) ; return bbs ; }
guard163/cassandra | @ Override public Term fromJSONObject ( Object parsed ) throws MarshalException { if ( parsed instanceof String ) parsed = Json . decodeJson ( ( String ) parsed ) ; if ( ! ( parsed instanceof List ) ) throw new MarshalException ( String . format ( " Expected ▁ a ▁ list , ▁ but ▁ got ▁ a ▁ % s : ▁ % s " , parsed . getClass ( ) . getSimpleName ( ) , parsed ) ) ; List list = ( List ) parsed ; List < Term > terms = new ArrayList < > ( list . size ( ) ) ; for ( Object element : list ) { if ( element == null ) throw new MarshalException ( " Invalid ▁ null ▁ element ▁ in ▁ list " ) ; terms . add ( elements . fromJSONObject ( element ) ) ; } return new Lists . DelayedValue ( terms ) ; }
guard163/cassandra | @ Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { return setOrListToJsonString ( buffer , elements , protocolVersion ) ; }
PlanetWaves/clockworkengine | public void initialize ( Class clazz ) { }
0x90sled/droidtowers | public ExceptionHandlerConstantVisitor ( ConstantVisitor constantVisitor ) { this . constantVisitor = constantVisitor ; }
0x90sled/droidtowers | public void visitExceptionInfo ( Clazz clazz , Method method , CodeAttribute codeAttribute , ExceptionInfo exceptionInfo ) { int catchType = exceptionInfo . u2catchType ; if ( catchType != 0 ) { clazz . constantPoolEntryAccept ( catchType , constantVisitor ) ; } }
cgfalcon/myprolang | @ Before public void setUp ( ) throws Exception { lexer = new CalcLexer ( "1 + 2" ) ; }
cgfalcon/myprolang | @ Test public void testGetTokenSimple ( ) throws Exception { lexer . setLine ( "1 + 2" ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "1" , TokenType . NUM ) , token ) ; Token tokenOp = lexer . nextToken ( ) ; assertEquals ( 1 , tokenOp . getPos ( ) ) ; assertEquals ( 1 , tokenOp . getLine ( ) ) ; assertEquals ( TokenType . OP_ADD_TOKEN , tokenOp . getKind ( ) ) ; Token tokenOperand2 = lexer . nextToken ( ) ; assertEquals ( new Token ( 2 , 1 , "2" , TokenType . NUM ) , tokenOperand2 ) ; Token tokenEndLine = lexer . nextToken ( ) ; assertEquals ( 2 , tokenEndLine . getPos ( ) ) ; assertEquals ( 1 , tokenEndLine . getLine ( ) ) ; assertEquals ( TokenType . EOF , tokenEndLine . getKind ( ) ) ; }
cgfalcon/myprolang | @ Test public void tesLexerComplex1 ( ) throws Exception { String line = "34 \n " ; lexer . setLine ( line ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "34" , TokenType . NUM ) , token ) ; String line2 = "34.9384 ▁ 0.4 \n " ; lexer . setLine ( line2 ) ; Token token2 = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "34.9384" , TokenType . NUM ) , token2 ) ; Token token3 = lexer . nextToken ( ) ; assertEquals ( new Token ( 8 , 1 , "0.4" , TokenType . NUM ) , token3 ) ; }
cgfalcon/myprolang | @ Test public void testAdd ( ) throws Exception { String line = "45.3 ▁ + ▁ 0.23 \n " ; lexer . setLine ( line ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , "45.3" , TokenType . NUM ) , token ) ; Token tokenAdd = lexer . nextToken ( ) ; assertEquals ( 5 , tokenAdd . getPos ( ) ) ; assertEquals ( TokenType . OP_ADD_TOKEN , tokenAdd . getKind ( ) ) ; Token tokenOperand = lexer . nextToken ( ) ; assertEquals ( new Token ( 7 , 1 , "0.23" , TokenType . NUM ) , tokenOperand ) ; }
cgfalcon/myprolang | @ Test public void testID ( ) { String line = " dbd " ; lexer . setLine ( line ) ; Token token = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , " dbd " , TokenType . ID ) , token ) ; }
cgfalcon/myprolang | @ Test public void testAssign ( ) { String line = " x ▁ = ▁ 10" ; lexer . setLine ( line ) ; Token tokenX = lexer . nextToken ( ) ; assertEquals ( new Token ( 0 , 1 , " x " , TokenType . ID ) , tokenX ) ; Token tokenEqual = lexer . nextToken ( ) ; assertEquals ( new Token ( 2 , 1 , " = " , TokenType . EQUAL ) , tokenEqual ) ; Token tokenNum = lexer . nextToken ( ) ; assertEquals ( new Token ( 4 , 1 , "10" , TokenType . NUM ) , tokenNum ) ; }
JEBailey/sling | while ( nodeTypeIterator . hasNext ( ) ) { NodeType nodeType = nodeTypeIterator . nextNodeType ( ) ; if ( nodeType . getName ( ) != null ) { JSONNodeType jsonNodeType = new JSONNodeType ( nodeType ) ; nodeTypes . put ( nodeType . getName ( ) , jsonNodeType . getJson ( ) ) ; } }
JEBailey/sling | catch ( RepositoryException e ) { log . error ( " Could ▁ not ▁ generate ▁ the ▁ node ▁ types . " , e ) ; response . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; }
JEBailey/sling | catch ( JSONException e ) { log . error ( " Could ▁ not ▁ generate ▁ the ▁ node ▁ types . " , e ) ; response . setStatus ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; }
shs96c/buck | @ VisibleForTesting AndroidLibrary ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , JarBuildStepsFactory jarBuildStepsFactory , SourcePathRuleFinder ruleFinder , Optional < SourcePath > proguardConfig , SortedSet < BuildRule > fullJarDeclaredDeps , ImmutableSortedSet < BuildRule > fullJarExportedDeps , ImmutableSortedSet < BuildRule > fullJarProvidedDeps , ImmutableSortedSet < BuildRule > fullJarExportedProvidedDeps , @ Nullable BuildTarget abiJar , @ Nullable BuildTarget sourceOnlyAbiJar , Optional < String > mavenCoords , Optional < SourcePath > manifestFile , ImmutableSortedSet < BuildTarget > tests , boolean requiredForSourceOnlyAbi , UnusedDependenciesAction unusedDependenciesAction , Optional < UnusedDependenciesFinderFactory > unusedDependenciesFinderFactory , @ Nullable CalculateSourceAbi sourceAbi ) { super ( buildTarget , projectFilesystem , jarBuildStepsFactory , ruleFinder , proguardConfig , fullJarDeclaredDeps , fullJarExportedDeps , fullJarProvidedDeps , fullJarExportedProvidedDeps , abiJar , sourceOnlyAbiJar , mavenCoords , tests , requiredForSourceOnlyAbi , unusedDependenciesAction , unusedDependenciesFinderFactory , sourceAbi ) ; this . manifestFile = manifestFile ; }
shs96c/buck | public Optional < SourcePath > getManifestFile ( ) { return manifestFile ; }
shs96c/buck | @ Override public void addToCollector ( AndroidPackageableCollector collector ) { super . addToCollector ( collector ) ; if ( manifestFile . isPresent ( ) ) { collector . addManifestPiece ( this . getBuildTarget ( ) , manifestFile . get ( ) ) ; } }
shs96c/buck | protected Builder ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , ToolchainProvider toolchainProvider , BuildRuleParams params , ActionGraphBuilder graphBuilder , CellPathResolver cellPathResolver , JavaBuckConfig javaBuckConfig , JavacFactory javacFactory , JavacOptions javacOptions , CoreArg args , ConfiguredCompilerFactory compilerFactory ) { this . graphBuilder = graphBuilder ; DefaultJavaLibraryRules . Builder delegateBuilder = new DefaultJavaLibraryRules . Builder ( buildTarget , projectFilesystem , toolchainProvider , params , graphBuilder , cellPathResolver , compilerFactory , javaBuckConfig , args ) ; delegateBuilder . setConstructor ( new DefaultJavaLibraryRules . DefaultJavaLibraryConstructor ( ) { @ Override public DefaultJavaLibrary newInstance ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , JarBuildStepsFactory jarBuildStepsFactory , SourcePathRuleFinder ruleFinder , Optional < SourcePath > proguardConfig , SortedSet < BuildRule > firstOrderPackageableDeps , ImmutableSortedSet < BuildRule > fullJarExportedDeps , ImmutableSortedSet < BuildRule > fullJarProvidedDeps , ImmutableSortedSet < BuildRule > fullJarExportedProvidedDeps , @ Nullable BuildTarget abiJar , @ Nullable BuildTarget sourceOnlyAbiJar , Optional < String > mavenCoords , ImmutableSortedSet < BuildTarget > tests , boolean requiredForSourceOnlyAbi , UnusedDependenciesAction unusedDependenciesAction , Optional < UnusedDependenciesFinderFactory > unusedDependenciesFinderFactory , @ Nullable CalculateSourceAbi sourceAbi ) { return new AndroidLibrary ( buildTarget , projectFilesystem , jarBuildStepsFactory , ruleFinder , proguardConfig , firstOrderPackageableDeps , fullJarExportedDeps , fullJarProvidedDeps , fullJarExportedProvidedDeps , abiJar , sourceOnlyAbiJar , mavenCoords , args . getManifest ( ) , tests , requiredForSourceOnlyAbi , unusedDependenciesAction , unusedDependenciesFinderFactory , sourceAbi ) ; } } ) ; delegateBuilder . setJavacOptions ( javacOptions ) ; delegateBuilder . setTests ( args . getTests ( ) ) ; JavaLibraryDeps deps = Preconditions . checkNotNull ( delegateBuilder . getDeps ( ) ) ; BuildTarget libraryTarget = JavaAbis . isLibraryTarget ( buildTarget ) ? buildTarget : JavaAbis . getLibraryTarget ( buildTarget ) ; graphEnhancer = new AndroidLibraryGraphEnhancer ( libraryTarget , projectFilesystem , ImmutableSortedSet . copyOf ( Iterables . concat ( deps . getDeps ( ) , deps . getProvidedDeps ( ) ) ) , javacFactory . create ( new SourcePathRuleFinder ( graphBuilder ) , args ) , javacOptions , DependencyMode . FIRST_ORDER , false , args . getResourceUnionPackage ( ) , args . getFinalRName ( ) , false , args . isSkipNonUnionRDotJava ( ) ) ; getDummyRDotJava ( ) . ifPresent ( dummyRDotJava -> { delegateBuilder . setDeps ( new JavaLibraryDeps . Builder ( graphBuilder ) . from ( JavaLibraryDeps . newInstance ( args , graphBuilder , compilerFactory ) ) . addDepTargets ( dummyRDotJava . getBuildTarget ( ) ) . build ( ) ) ; } ) ; delegate = delegateBuilder . build ( ) ; }
shs96c/buck | public AndroidLibrary build ( ) { return ( AndroidLibrary ) delegate . buildLibrary ( ) ; }
shs96c/buck | public BuildRule buildAbi ( ) { return delegate . buildAbi ( ) ; }
shs96c/buck | public DummyRDotJava buildDummyRDotJava ( ) { return graphEnhancer . getBuildableForAndroidResources ( graphBuilder , true ) . get ( ) ; }
shs96c/buck | public Optional < DummyRDotJava > getDummyRDotJava ( ) { return graphEnhancer . getBuildableForAndroidResources ( graphBuilder , false ) ; }
codepitbull/wicket-buch | public HomePage ( final PageParameters parameters ) { add ( new Label ( " testText " , new AbstractReadOnlyModel < String > ( ) { @ Override public String getObject ( ) { return testService . getName ( ) ; } } ) ) ; }
google/guava | @ Override protected void setUp ( ) throws Exception { SettableFuture < ? > unused = SettableFuture . create ( ) ; final String concurrentPackage = SettableFuture . class . getPackage ( ) . getName ( ) ; classReloader = new URLClassLoader ( ClassPathUtil . getClassPathUrls ( ) ) { @ GuardedBy ( " loadedClasses " ) final Map < String , Class < ? > > loadedClasses = new HashMap < > ( ) ; @ Override public Class < ? > loadClass ( String name ) throws ClassNotFoundException { if ( name . startsWith ( concurrentPackage ) && ! ListenableFuture . class . getName ( ) . equals ( name ) ) { synchronized ( loadedClasses ) { Class < ? > toReturn = loadedClasses . get ( name ) ; if ( toReturn == null ) { toReturn = super . findClass ( name ) ; loadedClasses . put ( name , toReturn ) ; } return toReturn ; } } return super . loadClass ( name ) ; } } ; oldClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Thread . currentThread ( ) . setContextClassLoader ( classReloader ) ; oldSecurityManager = System . getSecurityManager ( ) ; final PropertyPermission readSystemProperty = new PropertyPermission ( " guava . concurrent . generate _ cancellation _ cause " , " read " ) ; SecurityManager disallowPropertySecurityManager = new SecurityManager ( ) { @ Override public void checkPermission ( Permission p ) { if ( readSystemProperty . equals ( p ) ) { throw new SecurityException ( " Disallowed : ▁ " + p ) ; } } } ; System . setSecurityManager ( disallowPropertySecurityManager ) ; settableFutureClass = classReloader . loadClass ( SettableFuture . class . getName ( ) ) ; }
google/guava | @ Override protected void tearDown ( ) throws Exception { System . setSecurityManager ( oldSecurityManager ) ; classReloader . close ( ) ; Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; }
google/guava | public void testAbstractFutureInitializationWithInnocuousThread_doesNotThrow ( ) throws Exception { CountDownLatch latch = new CountDownLatch ( 1 ) ; ForkJoinPool . commonPool ( ) . execute ( ( ) -> { try { settableFutureClass . getMethod ( " create " ) . invoke ( null ) ; latch . countDown ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; assertTrue ( latch . await ( 2 , TimeUnit . SECONDS ) ) ; }
Gigaspaces/xap-openspaces | @ Override public void calculateNewStatistics ( InternalProcessingUnitStatistics processingUnitStatistics , Collection < ProcessingUnitStatisticsId > statisticsIds ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( " calculateNewStatistics ( processingUnitStatistics = " + processingUnitStatistics + " ▁ , ▁ statisticsIds = " + statisticsIds ) ; } Map < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > instancesStatisticsPerErasedStatisticsId = eraseInstancesStatistics ( statisticsIds ) ; Set < ProcessingUnitStatisticsId > erasedStatisticsIds = instancesStatisticsPerErasedStatisticsId . keySet ( ) ; Map < ProcessingUnitStatisticsId , StatisticsObjectList > valuesPerErasedStatisticsId = getValues ( processingUnitStatistics , erasedStatisticsIds ) ; for ( Map . Entry < ProcessingUnitStatisticsId , StatisticsObjectList > pair : valuesPerErasedStatisticsId . entrySet ( ) ) { ProcessingUnitStatisticsId erasedStatisticsId = pair . getKey ( ) ; StatisticsObjectList values = pair . getValue ( ) ; for ( InstancesStatisticsConfig instancesStatistics : instancesStatisticsPerErasedStatisticsId . get ( erasedStatisticsId ) ) { if ( instancesStatistics instanceof StatisticsObjectListFunction ) { StatisticsObjectListFunction statisticsFunc = ( StatisticsObjectListFunction ) instancesStatistics ; Object value = statisticsFunc . calc ( values ) ; ProcessingUnitStatisticsId statisticsId = unerase ( erasedStatisticsId , instancesStatistics ) ; processingUnitStatistics . addStatistics ( statisticsId , value ) ; } } } }
Gigaspaces/xap-openspaces | private Map < ProcessingUnitStatisticsId , StatisticsObjectList > getValues ( InternalProcessingUnitStatistics processingUnitStatistics , Set < ProcessingUnitStatisticsId > erasedStatisticsIds ) { Map < ProcessingUnitStatisticsId , StatisticsObjectList > values = new HashMap < ProcessingUnitStatisticsId , StatisticsObjectList > ( ) ; for ( Entry < ProcessingUnitStatisticsId , Object > pair : processingUnitStatistics . getStatistics ( ) . entrySet ( ) ) { ProcessingUnitStatisticsId statisticsId = pair . getKey ( ) ; if ( statisticsId . getInstancesStatistics ( ) instanceof EachSingleInstanceStatisticsConfig ) { throw new IllegalArgumentException ( " Unsupported ▁ statisticsId . ▁ Use ▁ " + SingleInstanceStatisticsConfig . class + " ▁ instead ▁ of ▁ " + EachSingleInstanceStatisticsConfig . class ) ; } if ( statisticsId . getInstancesStatistics ( ) instanceof SingleInstanceStatisticsConfig ) { ProcessingUnitStatisticsId erasedStatisticsId = erase ( statisticsId ) ; if ( erasedStatisticsIds . contains ( erasedStatisticsId ) ) { if ( ! values . containsKey ( erasedStatisticsId ) ) { values . put ( erasedStatisticsId , new StatisticsObjectList ( ) ) ; } Object value = pair . getValue ( ) ; long timeStamp = processingUnitStatistics . getAdminTimestamp ( ) ; values . get ( erasedStatisticsId ) . add ( value , timeStamp ) ; } } } return values ; }
Gigaspaces/xap-openspaces | private Map < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > eraseInstancesStatistics ( Iterable < ProcessingUnitStatisticsId > statisticsIds ) { Map < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > groupBy = new HashMap < ProcessingUnitStatisticsId , Set < InstancesStatisticsConfig > > ( ) ; for ( ProcessingUnitStatisticsId statisticsId : statisticsIds ) { InstancesStatisticsConfig instancesStatistics = statisticsId . getInstancesStatistics ( ) ; ProcessingUnitStatisticsId key = erase ( statisticsId ) ; if ( ! groupBy . containsKey ( key ) ) { groupBy . put ( key , new HashSet < InstancesStatisticsConfig > ( ) ) ; } groupBy . get ( key ) . add ( instancesStatistics ) ; } return groupBy ; }
Gigaspaces/xap-openspaces | private ProcessingUnitStatisticsId erase ( ProcessingUnitStatisticsId statisticsId ) { statisticsId . validate ( ) ; ProcessingUnitStatisticsId erased = statisticsId . shallowClone ( ) ; erased . setInstancesStatistics ( null ) ; return erased ; }
Gigaspaces/xap-openspaces | private ProcessingUnitStatisticsId unerase ( ProcessingUnitStatisticsId erasedStatisticsId , InstancesStatisticsConfig instancesStatistics ) { ProcessingUnitStatisticsId unerased ; if ( erasedStatisticsId . getInstancesStatistics ( ) != null ) { unerased = erasedStatisticsId ; } else { unerased = erasedStatisticsId . shallowClone ( ) ; unerased . setInstancesStatistics ( instancesStatistics ) ; } unerased . validate ( ) ; return unerased ; }
ydengGitHub/usermodule | @ Bean public RememberMeServices rememberMeServices ( ) { TokenBasedRememberMeServices rememberMeServices = new TokenBasedRememberMeServices ( rememberMeKey , userService ) ; return rememberMeServices ; }
ydengGitHub/usermodule | @ Bean public PasswordEncoder passwordEncoder ( ) { logger . info ( " Creating ▁ password ▁ encoder ▁ bean " ) ; return new BCryptPasswordEncoder ( ) ; }
ydengGitHub/usermodule | @ Override protected void configure ( HttpSecurity http ) throws Exception { http . authorizeRequests ( ) . antMatchers ( " / " , " / home " , " / error " , " / signup " , " / forgot - password " , " / reset - password /* " , " / public /* * " , " / users /* * " ) . permitAll ( ) . anyRequest ( ) . authenticated ( ) ; http . formLogin ( ) . loginPage ( " / login " ) . permitAll ( ) . and ( ) . rememberMe ( ) . key ( rememberMeKey ) . rememberMeServices ( rememberMeServices ( ) ) . and ( ) . logout ( ) . permitAll ( ) ; }
ydengGitHub/usermodule | @ Autowired @ Override protected void configure ( AuthenticationManagerBuilder authManagerBuilder ) throws Exception { authManagerBuilder . userDetailsService ( userService ) . passwordEncoder ( passwordEncoder ( ) ) ; }
loxal/FreeEthereum | public ShhEnvelopeMessage ( final byte [ ] encoded ) { super ( encoded ) ; parse ( ) ; }
loxal/FreeEthereum | public ShhEnvelopeMessage ( final WhisperMessage ... msg ) { Collections . addAll ( messages , msg ) ; parsed = true ; }
loxal/FreeEthereum | public ShhEnvelopeMessage ( final Collection < WhisperMessage > msg ) { messages . addAll ( msg ) ; parsed = true ; }
loxal/FreeEthereum | @ Override public ShhMessageCodes getCommand ( ) { return MESSAGE ; }
loxal/FreeEthereum | public void addMessage ( final WhisperMessage msg ) { messages . add ( msg ) ; }
loxal/FreeEthereum | private void parse ( ) { if ( ! parsed ) { final RLPList paramsList = ( RLPList ) RLP . decode2 ( encoded ) . get ( 0 ) ; for ( final RLPElement aParamsList : paramsList ) { messages . add ( new WhisperMessage ( aParamsList . getRLPData ( ) ) ) ; } this . parsed = true ; } }
loxal/FreeEthereum | @ Override public byte [ ] getEncoded ( ) { if ( encoded == null ) { final byte [ ] [ ] encodedMessages = new byte [ messages . size ( ) ] [ ] ; for ( int i = 0 ; i < encodedMessages . length ; i ++ ) { encodedMessages [ i ] = messages . get ( i ) . getEncoded ( ) ; } encoded = RLP . encodeList ( encodedMessages ) ; } return encoded ; }
loxal/FreeEthereum | public List < WhisperMessage > getMessages ( ) { return messages ; }
loxal/FreeEthereum | @ Override public Class < ? > getAnswerMessage ( ) { return null ; }
loxal/FreeEthereum | @ Override public String toString ( ) { return " [ ENVELOPE ▁ " + messages . toString ( ) + " ] " ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerNonArgumentConstructor ( ) { processEngineConfiguration . setHistoryEventHandler ( new CompositeDbHistoryEventHandler ( ) ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 0 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerNonArgumentConstructorAddNullEvent ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( ) ; try { compositeDbHistoryEventHandler . add ( null ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerNonArgumentConstructorAddNotNullEvent ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( ) ; compositeDbHistoryEventHandler . add ( new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 2 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerNonArgumentConstructorAddTwoNotNullEvents ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( ) ; compositeDbHistoryEventHandler . add ( new CustomDbHistoryEventHandler ( ) ) ; compositeDbHistoryEventHandler . add ( new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 4 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNullVarargs ( ) { HistoryEventHandler historyEventHandler = null ; try { new CompositeDbHistoryEventHandler ( historyEventHandler ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNullTwoVarargs ( ) { try { new CompositeDbHistoryEventHandler ( null , null ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotNullVarargsOneEvent ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 2 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotNullVarargsTwoEvents ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( new CustomDbHistoryEventHandler ( ) , new CustomDbHistoryEventHandler ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 4 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithEmptyList ( ) { CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( new ArrayList < HistoryEventHandler > ( ) ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 0 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
xasx/camunda-bpm-platform | public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotEmptyListNullTwoEvents ( ) { List < HistoryEventHandler > historyEventHandlers = new ArrayList < HistoryEventHandler > ( ) ; historyEventHandlers . add ( null ) ; historyEventHandlers . add ( null ) ; try { new CompositeDbHistoryEventHandler ( historyEventHandlers ) ; fail ( " NullValueException ▁ expected " ) ; } catch ( NullValueException e ) { assertTextPresent ( " History ▁ event ▁ handler ▁ is ▁ null " , e . getMessage ( ) ) ; } }
xasx/camunda-bpm-platform | ) public void testCompositeDbHistoryEventHandlerArgumentConstructorWithNotEmptyListNotNullTwoEvents ( ) { List < HistoryEventHandler > historyEventHandlers = new ArrayList < HistoryEventHandler > ( ) ; historyEventHandlers . add ( new CustomDbHistoryEventHandler ( ) ) ; historyEventHandlers . add ( new CustomDbHistoryEventHandler ( ) ) ; CompositeDbHistoryEventHandler compositeDbHistoryEventHandler = new CompositeDbHistoryEventHandler ( historyEventHandlers ) ; processEngineConfiguration . setHistoryEventHandler ( compositeDbHistoryEventHandler ) ; startProcessAndCompleteUserTask ( ) ; assertEquals ( 4 , countCustomHistoryEventHandler ) ; assertEquals ( 2 , historyService . createHistoricDetailQuery ( ) . count ( ) ) ; }
blacroix/droidcon_android_tests | public Messenger ( Context context ) { this . context = context ; }
blacroix/droidcon_android_tests | void showMessage ( String message ) { Toast . makeText ( context , message , Toast . LENGTH_SHORT ) . show ( ) ; }
blacroix/droidcon_android_tests | public void showMessage ( int messageId ) { Toast . makeText ( context , messageId , Toast . LENGTH_SHORT ) . show ( ) ; }
sovaj/sovaj.basics | @ Override public Calendar unmarshal ( String value ) { if ( value == null || value . length ( ) < 1 ) { return null ; } return DatatypeConverter . parseDateTime ( value ) ; }
sovaj/sovaj.basics | @ Override public String marshal ( Calendar value ) { if ( value == null ) { return null ; } return DatatypeConverter . printDateTime ( value ) ; }
nemoNoboru/SecretHitler | public PersonajeLiberal ( ) { }
nemoNoboru/SecretHitler | public String getPersonaje ( ) { return " Liberal " ; }
ChallenHB/drools | public Float getDistance2 ( ) { return this . distance2 ; }
ChallenHB/drools | public void setDistance2 ( final Float distance2 ) { this . distance2 = distance2 ; }
ChallenHB/drools | public Float getTime2 ( ) { return this . time2 ; }
ChallenHB/drools | public void setTime2 ( final Float time2 ) { this . time2 = time2 ; }
ChallenHB/drools | public Float getBearing ( ) { return this . bearing ; }
ChallenHB/drools | public void setBearing ( final Float bearing ) { this . bearing = bearing ; }
ChallenHB/drools | public Float getDistance ( ) { return this . distance ; }
ChallenHB/drools | public void setDistance ( final Float distance ) { this . distance = distance ; }
ChallenHB/drools | public String getLabel ( ) { return this . label ; }
ChallenHB/drools | public void setLabel ( final String label ) { this . label = label ; }
ChallenHB/drools | public String getLabel2 ( ) { return this . label2 ; }
ChallenHB/drools | public void setLabel2 ( final String label2 ) { this . label2 = label2 ; }
ChallenHB/drools | public Float getTime ( ) { return this . time ; }
ChallenHB/drools | public void setTime ( final Float time ) { this . time = time ; }
ChallenHB/drools | public Float getBearing2 ( ) { return this . bearing2 ; }
ChallenHB/drools | public void setBearing2 ( final Float bearing2 ) { this . bearing2 = bearing2 ; }
ChallenHB/drools | public String toString ( ) { return " Approach < ▁ label : ▁ " + this . label + " ▁ label2 : ▁ " + this . label2 + " ▁ time : ▁ " + this . time + " ▁ time2 : ▁ " + this . time2 + " ▁ distance : ▁ " + this . distance + " ▁ distance2 : ▁ " + this . distance2 + " ▁ bearing : ▁ " + this . bearing + " ▁ bearing2 : ▁ " + this . bearing2 + " ▁ > " ; }
westbury/dwg-lib | public Expander ( byte [ ] compressedData , int uncompressedSize ) { this . compressedData = compressedData ; result = expand ( uncompressedSize ) ; }
westbury/dwg-lib | private byte [ ] expand ( int uncompressedSize ) { byte [ ] outputBytes = new byte [ uncompressedSize ] ; int initialLitCount = getLitLength ( ) ; for ( int i = 0 ; i < initialLitCount ; i ++ ) { outputBytes [ outputPosition ++ ] = compressedData [ inputPosition ++ ] ; } int opcode1 ; while ( ( opcode1 = getUnsignedByte ( ) ) != 0x11 ) { if ( opcode1 < 0x10 ) { throw new RuntimeException ( " bad ▁ data ? ? ? " ) ; } int compressedBytes ; int compOffset ; int litCount ; if ( opcode1 == 0x10 ) { compressedBytes = getLongCompressionOffset ( ) + 9 ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset + 0x3FFF ; litCount = twoByteOffset . litCount ; } else if ( opcode1 <= 0x1F ) { assert opcode1 >= 0x12 && opcode1 <= 0x1F ; compressedBytes = ( opcode1 & 0x0F ) + 2 ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset + 0x3FFF ; litCount = twoByteOffset . litCount ; } else if ( opcode1 == 0x20 ) { compressedBytes = getLongCompressionOffset ( ) + 0x21 ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset ; litCount = twoByteOffset . litCount ; } else if ( opcode1 <= 0x3F ) { assert opcode1 >= 0x21 && opcode1 <= 0x3F ; compressedBytes = opcode1 - 0x1E ; TwoByteOffset twoByteOffset = getTwoByteOffset ( ) ; compOffset = twoByteOffset . reducedCompOffset ; litCount = twoByteOffset . litCount ; } else { assert opcode1 >= 0x40 ; compressedBytes = ( ( opcode1 & 0xF0 ) >> 4 ) - 1 ; int opcode2 = getUnsignedByte ( ) ; compOffset = ( opcode2 << 2 ) | ( ( opcode1 & 0x0C ) >> 2 ) ; litCount = opcode1 & 0x03 ; if ( litCount == 0 ) { litCount = getLitLength ( ) ; } } int duplicateFromPosition = outputPosition - compOffset - 1 ; for ( int i = 0 ; i < compressedBytes ; i ++ ) { outputBytes [ outputPosition ++ ] = outputBytes [ duplicateFromPosition ++ ] ; } for ( int i = 0 ; i < litCount ; i ++ ) { outputBytes [ outputPosition ++ ] = compressedData [ inputPosition ++ ] ; } } return outputBytes ; }
westbury/dwg-lib | private int getLitLength ( ) { int opcode = peekUnsignedByte ( ) ; if ( opcode > 0x0F ) { return 0 ; } getUnsignedByte ( ) ; int runningTotal = 0 ; if ( opcode == 0x00 ) { runningTotal += 0x0F ; while ( ( opcode = getUnsignedByte ( ) ) == 0x00 ) { runningTotal += 0xFF ; } } return runningTotal + opcode + 3 ; }
westbury/dwg-lib | private int getLongCompressionOffset ( ) { int runningTotal = 0 ; int opcode ; while ( ( opcode = getUnsignedByte ( ) ) == 0x00 ) { runningTotal += 0xFF ; } return runningTotal + opcode ; }
westbury/dwg-lib | private TwoByteOffset getTwoByteOffset ( ) { int firstByte = getUnsignedByte ( ) ; int secondByte = getUnsignedByte ( ) ; int reducedCompOffset = ( firstByte >> 2 ) | ( secondByte << 6 ) ; int litCount = ( firstByte & 0x03 ) ; if ( litCount == 0 ) { litCount = getLitLength ( ) ; } return new TwoByteOffset ( reducedCompOffset , litCount ) ; }
westbury/dwg-lib | private int getUnsignedByte ( ) { return ( compressedData [ inputPosition ++ ] ) & 0xff ; }
westbury/dwg-lib | private int peekUnsignedByte ( ) { return ( compressedData [ inputPosition ] ) & 0xff ; }
westbury/dwg-lib | public TwoByteOffset ( int reducedCompOffset , int litCount ) { this . reducedCompOffset = reducedCompOffset ; this . litCount = litCount ; }
elect86/NvGlSamples | private NvGLSLProgram ( int program , boolean strict ) { this . programName = program ; this . strict = strict ; }
elect86/NvGlSamples | public int getAttribLocation ( GL4 gl4 , String attribute ) { return getAttribLocation ( gl4 , attribute , false ) ; }
elect86/NvGlSamples | public int getAttribLocation ( GL4 gl4 , String attribute , boolean isOptional ) { int result = gl4 . glGetAttribLocation ( programName , attribute ) ; if ( result == - 1 ) { if ( ( logAllMissing || strict ) && ! isOptional ) { System . err . println ( " could ▁ not ▁ find ▁ attribute ▁ " + attribute + " ▁ in ▁ program ▁ " + programName ) ; } } return result ; }
elect86/NvGlSamples | public void enable ( GL4 gl4 ) { gl4 . glUseProgram ( programName ) ; }
elect86/NvGlSamples | public void disable ( GL4 gl4 ) { gl4 . glUseProgram ( 0 ) ; }
elect86/NvGlSamples | public int getUniformLocation ( GL4 gl4 , String uniform ) { return getUniformLocation ( gl4 , uniform , false ) ; }
elect86/NvGlSamples | public int getUniformLocation ( GL4 gl4 , String uniform , boolean isOptional ) { int result = gl4 . glGetUniformLocation ( programName , uniform ) ; if ( result == - 1 ) { if ( ( logAllMissing || strict ) && ! isOptional ) { System . err . println ( " could ▁ not ▁ find ▁ uniform ▁ " + uniform + " ▁ in ▁ program ▁ " + programName ) ; } } return result ; }
eBay/myriad | public DeleteClusterResponse ( ) { }
cybera/OpenConext-dashboard | public Policy ( ) { }
cybera/OpenConext-dashboard | private Policy ( PolicyBuilder builder ) { this . id = builder . id ; this . created = builder . created ; this . userDisplayName = builder . userDisplayName ; this . actionsAllowed = builder . actionsAllowed ; this . revisionNbr = builder . revisionNbr ; this . numberOfRevisions = builder . numberOfRevisions ; this . serviceProviderName = builder . serviceProviderName ; this . name = builder . policy . name ; this . description = builder . policy . description ; this . serviceProviderId = builder . policy . serviceProviderId ; this . identityProviderIds = builder . policy . identityProviderIds ; this . identityProviderNames = builder . policy . identityProviderNames ; this . attributes = builder . policy . attributes ; this . denyAdvice = builder . policy . denyAdvice ; this . denyAdviceNl = builder . policy . denyAdviceNl ; this . denyRule = builder . policy . denyRule ; this . allAttributesMustMatch = builder . policy . allAttributesMustMatch ; this . authenticatingAuthorityName = builder . policy . authenticatingAuthorityName ; this . isActivatedSr = builder . policy . isActivatedSr ; this . active = builder . policy . active ; this . type = builder . policy . type ; }
cybera/OpenConext-dashboard | public Policy ( String name , String description ) { this . name = name ; this . description = description ; }
cybera/OpenConext-dashboard | public Long getId ( ) { return id ; }
cybera/OpenConext-dashboard | public String getName ( ) { return name ; }
cybera/OpenConext-dashboard | public String getDescription ( ) { return description ; }
cybera/OpenConext-dashboard | public String getServiceProviderName ( ) { return serviceProviderName ; }
cybera/OpenConext-dashboard | public String getServiceProviderNameNl ( ) { return serviceProviderNameNl ; }
cybera/OpenConext-dashboard | public int getNumberOfRevisions ( ) { return numberOfRevisions ; }
cybera/OpenConext-dashboard | public List < String > getIdentityProviderIds ( ) { return identityProviderIds ; }
cybera/OpenConext-dashboard | public List < String > getIdentityProviderNames ( ) { return identityProviderNames ; }
cybera/OpenConext-dashboard | public List < String > getIdentityProviderNamesNl ( ) { return identityProviderNamesNl ; }
cybera/OpenConext-dashboard | public boolean isActionsAllowed ( ) { return actionsAllowed ; }
cybera/OpenConext-dashboard | public List < Attribute > getAttributes ( ) { return attributes ; }
cybera/OpenConext-dashboard | public String getCreated ( ) { return created ; }
cybera/OpenConext-dashboard | public String getDenyAdvice ( ) { return denyAdvice ; }
cybera/OpenConext-dashboard | public String getDenyAdviceNl ( ) { return denyAdviceNl ; }
cybera/OpenConext-dashboard | public boolean isDenyRule ( ) { return denyRule ; }
cybera/OpenConext-dashboard | public boolean isAllAttributesMustMatch ( ) { return allAttributesMustMatch ; }
cybera/OpenConext-dashboard | public String getServiceProviderId ( ) { return serviceProviderId ; }
cybera/OpenConext-dashboard | public String getUserDisplayName ( ) { return userDisplayName ; }
cybera/OpenConext-dashboard | public int getRevisionNbr ( ) { return revisionNbr ; }
cybera/OpenConext-dashboard | public boolean isActivatedSr ( ) { return isActivatedSr ; }
cybera/OpenConext-dashboard | public boolean isActive ( ) { return active ; }
cybera/OpenConext-dashboard | public String getAuthenticatingAuthorityName ( ) { return authenticatingAuthorityName ; }
cybera/OpenConext-dashboard | public String getType ( ) { return type ; }
cybera/OpenConext-dashboard | public String toString ( ) { return MoreObjects . toStringHelper ( Policy . class ) . add ( " name " , name ) . add ( " serviceProviderId " , serviceProviderId ) . add ( " identityProviderIds " , identityProviderIds ) . add ( " denyRule " , denyRule ) . add ( " denyAdvice " , denyAdvice ) . add ( " denyAdviceNl " , denyAdviceNl ) . add ( " attributes " , attributes ) . add ( " created " , created ) . add ( " description " , description ) . add ( " type " , type ) . add ( " serviceProviderName " , serviceProviderName ) . toString ( ) ; }
cybera/OpenConext-dashboard | public Attribute ( ) { }
cybera/OpenConext-dashboard | public Attribute ( String name , String value ) { this . name = name ; this . value = value ; }
cybera/OpenConext-dashboard | public String getName ( ) { return name ; }
cybera/OpenConext-dashboard | public String getValue ( ) { return value ; }
cybera/OpenConext-dashboard | @ Override public String toString ( ) { return MoreObjects . toStringHelper ( Attribute . class ) . add ( " name " , name ) . add ( " value " , value ) . toString ( ) ; }
cybera/OpenConext-dashboard | private PolicyBuilder ( Policy policy ) { this . policy = policy ; }
cybera/OpenConext-dashboard | public PolicyBuilder withId ( Long id ) { this . id = id ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withCreated ( String created ) { this . created = created ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withUserDisplayName ( String userDisplayName ) { this . userDisplayName = userDisplayName ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withActionsAllowed ( boolean actionsAllowed ) { this . actionsAllowed = actionsAllowed ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withRevisionNbr ( int revisionNbr ) { this . revisionNbr = revisionNbr ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withNumberOfRevisions ( int numberOfRevisions ) { this . numberOfRevisions = numberOfRevisions ; return this ; }
cybera/OpenConext-dashboard | public PolicyBuilder withServiceProviderName ( String serviceProviderName ) { this . serviceProviderName = serviceProviderName ; return this ; }
cybera/OpenConext-dashboard | public Policy build ( ) { return new Policy ( this ) ; }
Lanceolata/code-problems | public int numJewelsInStones ( String J , String S ) { Map < Character , Integer > map = new HashMap < Character , Integer > ( ) ; char [ ] arr = S . toCharArray ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { map . put ( arr [ i ] , map . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; } arr = J . toCharArray ( ) ; int res = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { res += map . getOrDefault ( arr [ i ] , 0 ) ; } return res ; }
GunoH/intellij-community | BindToNewBeanStep ( @ NotNull final WizardData data ) { myData = data ; myTableModel = new MyTableModel ( ) ; myTable . setModel ( myTableModel ) ; myTable . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; myScrollPane . getViewport ( ) . setBackground ( myTable . getBackground ( ) ) ; myTable . setSurrendersFocusOnKeystroke ( true ) ; { final TableColumn column = myTable . getColumnModel ( ) . getColumn ( 0 ) ; column . setCellRenderer ( new FormPropertyTableCellRenderer ( myData . myProject ) ) ; } { final TableColumn column = myTable . getColumnModel ( ) . getColumn ( 1 ) ; column . setCellRenderer ( new BeanPropertyTableCellRenderer ( ) ) ; column . setCellEditor ( new BeanPropertyTableCellEditor ( ) ) ; final DefaultCellEditor editor = ( DefaultCellEditor ) myTable . getDefaultEditor ( Object . class ) ; editor . setClickCountToStart ( 1 ) ; } myChkGetData . setSelected ( true ) ; myChkGetData . setEnabled ( false ) ; myChkSetData . setSelected ( true ) ; myChkSetData . setEnabled ( false ) ; myChkIsModified . setSelected ( myData . myGenerateIsModified ) ; }
GunoH/intellij-community | @ Override public JComponent getComponent ( ) { return myPanel ; }
GunoH/intellij-community | @ Override public void _init ( ) { LOG . assertTrue ( myData . myBindToNewBean ) ; myTableModel . fireTableDataChanged ( ) ; }
GunoH/intellij-community | @ Override public void _commit ( boolean finishChosen ) throws CommitStepException { final TableCellEditor cellEditor = myTable . getCellEditor ( ) ; if ( cellEditor != null ) { cellEditor . stopCellEditing ( ) ; } final PsiNameHelper nameHelper = PsiNameHelper . getInstance ( myData . myProject ) ; for ( int i = 0 ; i < myData . myBindings . length ; i ++ ) { final FormProperty2BeanProperty binding = myData . myBindings [ i ] ; if ( binding . myBeanProperty == null ) { continue ; } if ( ! nameHelper . isIdentifier ( binding . myBeanProperty . myName ) ) { throw new CommitStepException ( UIDesignerBundle . message ( " error . X . is . not . a . valid . property . name " , binding . myBeanProperty . myName ) ) ; } } myData . myGenerateIsModified = myChkIsModified . isSelected ( ) ; }
GunoH/intellij-community | MyTableModel ( ) { myColumnNames = new String [ ] { UIDesignerBundle . message ( " column . form . field " ) , UIDesignerBundle . message ( " column . bean . property " ) } ; myColumnClasses = new Class [ ] { Object . class , Object . class } ; }
GunoH/intellij-community | @ Override public int getColumnCount ( ) { return myColumnNames . length ; }
GunoH/intellij-community | @ Override public String getColumnName ( final int column ) { return myColumnNames [ column ] ; }
GunoH/intellij-community | @ Override public Class getColumnClass ( final int column ) { return myColumnClasses [ column ] ; }
GunoH/intellij-community | @ Override public int getRowCount ( ) { return myData . myBindings . length ; }
GunoH/intellij-community | @ Override public boolean isCellEditable ( final int row , final int column ) { return column == 1 ; }
GunoH/intellij-community | @ Override public Object getValueAt ( final int row , final int column ) { final FormProperty2BeanProperty binding = myData . myBindings [ row ] ; if ( column == 0 ) { return binding . myFormProperty ; } else if ( column == 1 ) { return binding . myBeanProperty ; } else { throw new IllegalArgumentException ( " unknown ▁ column : ▁ " + column ) ; } }
GunoH/intellij-community | @ Override public void setValueAt ( final Object value , final int row , final int column ) { final FormProperty2BeanProperty binding = myData . myBindings [ row ] ; if ( column == 1 ) { binding . myBeanProperty = ( BeanProperty ) value ; } else { throw new IllegalArgumentException ( " unknown ▁ column : ▁ " + column ) ; } }
nmaguirre/riocuartobandasderock | @ Test public void nameTest ( ) { Song song = new Song ( ) ; song . setName ( " thebeatles " ) ; assertEquals ( " thebeatles " , song . getName ( ) ) ; }
nmaguirre/riocuartobandasderock | @ Test public void durationTest ( ) { Song song = new Song ( ) ; song . setDuration ( 3 ) ; assertEquals ( 3 , song . getDuration ( ) ) ; }
nmaguirre/riocuartobandasderock | @ Test public void constructorTest ( ) { Song song = new Song ( " pinguinos ▁ en ▁ la ▁ cama " , 300 ) ; boolean res = ( song . getName ( ) == " pinguinos ▁ en ▁ la ▁ cama " ) && ( song . getDuration ( ) == 300 ) ; assertTrue ( res ) ; }
nmaguirre/riocuartobandasderock | @ Test public void getDurationInStringTest ( ) { Song song = new Song ( ) ; int a = 129 ; song . setDuration ( a ) ; assertEquals ( "2:9" , song . getDurationAsString ( ) ) ; }
BriData/DBus | public List < Integer > getScope ( ) { return scope ; }
BriData/DBus | public void setScope ( List < Integer > scope ) { this . scope = scope ; }
BriData/DBus | public Boolean getEq ( ) { return isEq ; }
BriData/DBus | public void setEq ( Boolean eq ) { isEq = eq ; }
BriData/DBus | public void setStart ( String start ) { this . start = start ; }
BriData/DBus | public void setEnd ( String end ) { this . end = end ; }
BriData/DBus | public String getStart ( ) { return start ; }
BriData/DBus | public String getEnd ( ) { return end ; }
BriData/DBus | public String getStartType ( ) { return startType ; }
BriData/DBus | public void setStartType ( String startType ) { this . startType = startType ; }
BriData/DBus | public String getEndType ( ) { return endType ; }
BriData/DBus | public void setEndType ( String endType ) { this . endType = endType ; }
BriData/DBus | public String getParamter ( ) { return paramter ; }
BriData/DBus | public void setParamter ( String paramter ) { this . paramter = paramter ; }
BriData/DBus | public String getOperate ( ) { return operate ; }
BriData/DBus | public void setOperate ( String operate ) { this . operate = operate ; }
BriData/DBus | public String getRuleType ( ) { return ruleType ; }
BriData/DBus | public void setRuleType ( String ruleType ) { this . ruleType = ruleType ; }
BriData/DBus | public String getFilterKey ( ) { return filterKey ; }
BriData/DBus | public void setFilterKey ( String filterKey ) { this . filterKey = filterKey ; }
WhatAKitty/spark-project | ConfigurationWrapper ( String configurationName ) { Class < ? > clazz = null ; try { clazz = ClassUtils . forName ( configurationName , getClass ( ) . getClassLoader ( ) ) ; } catch ( ClassNotFoundException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( String . format ( " Target ▁ configuration ▁ named ▁ % s ▁ is ▁ not ▁ found . " , configurationName ) , e ) ; } } if ( ! clazz . isAnnotationPresent ( Configuration . class ) ) { throw new RuntimeException ( String . format ( " Target ▁ class ▁ % s ▁ is ▁ not ▁ configurable . " , configurationName ) ) ; } this . configurationAnnotation = clazz . getAnnotation ( Configuration . class ) ; Constructor < ? > [ ] constructors = clazz . getDeclaredConstructors ( ) ; if ( constructors . length > 1 ) { throw new RuntimeException ( " Target ▁ configuration ▁ can ' t ▁ be ▁ instantiated : ▁ There ▁ are ▁ too ▁ many ▁ constructor , ▁ please ▁ reduce ▁ constructor ' s ▁ count . ▁ Only ▁ one ▁ constructor ▁ can ▁ be ▁ instantiated . " ) ; } for ( Constructor < ? > constructor : constructors ) { if ( constructor . isAnnotationPresent ( ConfigurationProperties . class ) ) { ConfigurationProperties configurationProperties = constructor . getAnnotation ( ConfigurationProperties . class ) ; int propertyLength = 0 ; String [ ] propertiesLocations = configurationProperties . propertiesLocation ( ) ; Parameter [ ] parameters = constructor . getParameters ( ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { Parameter parameter = parameters [ i ] ; if ( parameter . getType ( ) . equals ( Properties . class ) ) { propertyLength ++ ; } } if ( propertiesLocations . length != propertyLength ) { throw new RuntimeException ( String . format ( " Target ▁ configuration ▁ % s ▁ can ▁ not ▁ be ▁ instantiated : ▁ Properties ' ▁ size ▁ is ▁ not ▁ equal ▁ to ▁ configuration ▁ locations ' ▁ size . " , configurationName ) ) ; } Object [ ] parameterValues = new Object [ parameters . length ] ; for ( int i = 0 ; i < parameters . length ; i ++ ) { String propertiesLocation = propertiesLocations [ i ] ; Parameter parameter = parameters [ i ] ; Object parameterValue ; if ( parameter . getType ( ) . equals ( Properties . class ) ) { parameterValue = loadProperties ( clazz , propertiesLocation ) ; } else { parameterValue = null ; } parameterValues [ i ] = parameterValue ; } try { this . configuration = constructor . newInstance ( parameterValues ) ; } catch ( InstantiationException | IllegalAccessException | InvocationTargetException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( String . format ( " Target ▁ configuration ▁ % s ▁ can ▁ not ▁ be ▁ instantiated . " , configurationName ) , e ) ; } } } else { this . configuration = Reflect . on ( clazz ) . create ( ) ; } } }
WhatAKitty/spark-project | private Properties loadProperties ( Class < ? > clazz , String propertiesLocation ) { URL propertiesUrl = null ; try { propertiesUrl = ResourceUtils . getURL ( propertiesLocation ) ; } catch ( FileNotFoundException e ) { if ( logger . isErrorEnabled ( ) ) { logger . error ( String . format ( " The ▁ % s ▁ configuration ▁ file ▁ properties ▁ % s ▁ is ▁ not ▁ exists . ▁ " , clazz . getName ( ) , propertiesLocation ) , e ) ; } throw new RuntimeException ( e ) ; } return PropertiesLoaderUtils . loadProperties ( propertiesUrl ) ; }
WhatAKitty/spark-project | final String getName ( ) { return this . configuration . getClass ( ) . getName ( ) ; }
WhatAKitty/spark-project | final < T > T getConfiguration ( ) { return ( T ) this . configuration ; }
WhatAKitty/spark-project | final Configuration getConfigurationAnnotation ( ) { return this . configurationAnnotation ; }
WhatAKitty/spark-project | final Properties getProperties ( String propertiesName ) { return configurationProperties . get ( propertiesName ) ; }
WhatAKitty/spark-project | final boolean withMissing ( ) { return configurationAnnotation . withMissing ( ) ; }
google/differential-privacy | @ Before public void setUp ( ) { when ( noise . addNoise ( anyDouble ( ) , anyInt ( ) , anyDouble ( ) , anyDouble ( ) , anyDouble ( ) ) ) . thenAnswer ( invocation -> invocation . getArguments ( ) [ 0 ] ) ; when ( noise . getMechanismType ( ) ) . thenReturn ( GAUSSIAN ) ; sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . maxContributionsPerPartition ( 1 ) . lower ( - Double . MAX_VALUE ) . upper ( Double . MAX_VALUE ) . build ( ) ; }
google/differential-privacy | @ Test public void addEntry ( ) { sum . addEntry ( 1.0 ) ; sum . addEntry ( 2.0 ) ; sum . addEntry ( 3.0 ) ; sum . addEntry ( 4.0 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 10.0 ) ; }
google/differential-privacy | @ Test public void addEntries ( ) { sum . addEntries ( Arrays . asList ( 1.0 , 2.0 , 3.0 , 4.0 ) ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 10.0 ) ; }
google/differential-privacy | @ Test public void addEntry_Nan_ignored ( ) { sum . addEntry ( NaN ) ; sum . addEntry ( 2 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 2.0 ) ; }
google/differential-privacy | @ Test public void addEntry_calledAfterComputeResult_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntry ( 0.0 ) ) ; }
google/differential-privacy | @ Test public void addEntry_calledAfterSerialize_throwsException ( ) { sum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntry ( 0.0 ) ) ; }
google/differential-privacy | @ Test public void addEntries_calledAfterComputeResult_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntries ( Arrays . asList ( 0.0 ) ) ) ; }
google/differential-privacy | @ Test public void addEntries_calledAfterSerialize_throwsException ( ) { sum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . addEntries ( Arrays . asList ( 0.0 ) ) ) ; }
google/differential-privacy | @ Test public void computeResult_multipleCalls_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . computeResult ( ) ) ; }
google/differential-privacy | @ Test public void computeResult_calledAfterSerialize_throwsException ( ) { sum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . computeResult ( ) ) ; }
google/differential-privacy | @ Test public void addEntry_clampsInput ( ) { sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . lower ( 0 ) . upper ( 1 ) . build ( ) ; sum . addEntry ( - 1.0 ) ; sum . addEntry ( 1.0 ) ; sum . addEntry ( 10.0 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 2 ) ; }
google/differential-privacy | @ Test public void computeResult_callsNoiseCorrectly ( ) { double value = 0.5 ; int l0Sensitivity = 1 ; sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( l0Sensitivity ) . maxContributionsPerPartition ( 5 ) . lower ( 0 ) . upper ( 100 ) . build ( ) ; sum . addEntry ( value ) ; sum . computeResult ( ) ; verify ( noise ) . addNoise ( eq ( value ) , eq ( l0Sensitivity ) , eq ( 500.0 ) , eq ( EPSILON ) , eq ( DELTA ) ) ; }
google/differential-privacy | @ Test public void computeResult_addsNoise ( ) { when ( noise . addNoise ( anyDouble ( ) , anyInt ( ) , anyDouble ( ) , anyDouble ( ) , anyDouble ( ) ) ) . thenAnswer ( invocation -> ( double ) invocation . getArguments ( ) [ 0 ] + 100.0 ) ; sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . lower ( 0 ) . upper ( 1000 ) . build ( ) ; sum . addEntry ( 10 ) ; assertThat ( sum . computeResult ( ) ) . isEqualTo ( 110 ) ; }
google/differential-privacy | @ Test public void lowerBoundMinInteger_doesntOverflow ( ) { sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . maxContributionsPerPartition ( 1 ) . lower ( Integer . MIN_VALUE ) . upper ( 0 ) . build ( ) ; sum . computeResult ( ) ; verify ( noise ) . addNoise ( anyDouble ( ) , anyInt ( ) , eq ( - ( double ) Integer . MIN_VALUE ) , anyDouble ( ) , anyDouble ( ) ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesPartialSumCorrectly ( ) { sum . addEntry ( 10.0 ) ; sum . addEntry ( 10.0 ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( 20.0 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesZeroSumCorrectly ( ) { BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( 0.0 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMaxDoubleSumCorrectly ( ) { sum . addEntry ( Double . MAX_VALUE ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( Double . MAX_VALUE ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMinDoubleSumCorrectly ( ) { sum . addEntry ( Double . MIN_VALUE ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( Double . MIN_VALUE ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesNegativeSumCorrectly ( ) { sum . addEntry ( - 5.0 ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( - 5 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesPositiveSumCorrectly ( ) { sum . addEntry ( 5 ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getPartialSum ( ) . getFloatValue ( ) ) . isEqualTo ( 5.0 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_calledAfterComputeResult_throwsException ( ) { sum . computeResult ( ) ; assertThrows ( IllegalStateException . class , ( ) -> sum . getSerializableSummary ( ) ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_multipleCalls_returnsSameSummary ( ) { sum = BoundedSum . builder ( ) . epsilon ( EPSILON ) . noise ( new LaplaceNoise ( ) ) . maxPartitionsContributed ( 1 ) . lower ( 0.0 ) . upper ( 1.0 ) . build ( ) ; sum . addEntry ( 0.5 ) ; byte [ ] summary1 = sum . getSerializableSummary ( ) ; byte [ ] summary2 = sum . getSerializableSummary ( ) ; assertThat ( summary1 ) . isEqualTo ( summary2 ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesEpsilonCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . epsilon ( EPSILON ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getEpsilon ( ) ) . isEqualTo ( EPSILON ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesDeltaCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . delta ( DELTA ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getDelta ( ) ) . isEqualTo ( DELTA ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesGaussianNoiseCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . noise ( new GaussianNoise ( ) ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMechanismType ( ) ) . isEqualTo ( GAUSSIAN ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesLaplaceNoiseCorrectly ( ) { sum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMechanismType ( ) ) . isEqualTo ( LAPLACE ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMaxPartitionsContributedCorrectly ( ) { int maxPartitionsContributed = 150 ; sum = getBoundedSumBuilderWithFields ( ) . maxPartitionsContributed ( maxPartitionsContributed ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMaxPartitionsContributed ( ) ) . isEqualTo ( maxPartitionsContributed ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesMaxContributionsPerPartitionCorrectly ( ) { int maxContributionsPerPartition = 150 ; sum = getBoundedSumBuilderWithFields ( ) . maxContributionsPerPartition ( maxContributionsPerPartition ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getMaxContributionsPerPartition ( ) ) . isEqualTo ( maxContributionsPerPartition ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesLowerCorrectly ( ) { double lower = - 0.1 ; sum = getBoundedSumBuilderWithFields ( ) . lower ( lower ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getLower ( ) ) . isEqualTo ( lower ) ; }
google/differential-privacy | @ Test public void getSerializableSummary_copiesUpperCorrectly ( ) { double upper = 0.1 ; sum = getBoundedSumBuilderWithFields ( ) . upper ( upper ) . build ( ) ; BoundedSumSummary summary = getSummary ( sum ) ; assertThat ( summary . getUpper ( ) ) . isEqualTo ( upper ) ; }
google/differential-privacy | @ Test public void mergeWith_basicExample_sumsValues ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . addEntry ( 1 ) ; sourceSum . addEntry ( 1 ) ; targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ; assertThat ( targetSum . computeResult ( ) ) . isEqualTo ( 2 ) ; }
google/differential-privacy | @ Test public void mergeWith_calledTwice_sumsValues ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum1 = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum2 = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . addEntry ( 1 ) ; sourceSum1 . addEntry ( 2 ) ; sourceSum2 . addEntry ( 3 ) ; targetSum . mergeWith ( sourceSum1 . getSerializableSummary ( ) ) ; targetSum . mergeWith ( sourceSum2 . getSerializableSummary ( ) ) ; assertThat ( targetSum . computeResult ( ) ) . isEqualTo ( 6 ) ; }
google/differential-privacy | @ Test public void mergeWith_epsilonMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . epsilon ( EPSILON ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . epsilon ( 2 * EPSILON ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_nullDelta_mergesWithoutException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ; }
google/differential-privacy | @ Test public void mergeWith_deltaMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . delta ( DELTA ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . delta ( 2 * DELTA ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_noiseMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . noise ( new LaplaceNoise ( ) ) . delta ( null ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . noise ( new GaussianNoise ( ) ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_maxPartitionsContributedMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . maxPartitionsContributed ( 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . maxPartitionsContributed ( 2 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_maxContributionsPerPartitionMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . maxContributionsPerPartition ( 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . maxContributionsPerPartition ( 2 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_lowerBoundsMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . lower ( - 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . lower ( - 100 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_upperBoundsMismatch_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . upper ( 1 ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . upper ( 100 ) . build ( ) ; assertThrows ( IllegalArgumentException . class , ( ) -> targetSum . mergeWith ( sourceSum . getSerializableSummary ( ) ) ) ; }
google/differential-privacy | @ Test public void mergeWith_calledAfterComputeResult_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . computeResult ( ) ; byte [ ] summary = sourceSum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> targetSum . mergeWith ( summary ) ) ; }
google/differential-privacy | @ Test public void mergeWith_calledAfterSerialization_throwsException ( ) { BoundedSum targetSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; BoundedSum sourceSum = getBoundedSumBuilderWithFields ( ) . build ( ) ; targetSum . getSerializableSummary ( ) ; byte [ ] summary = sourceSum . getSerializableSummary ( ) ; assertThrows ( IllegalStateException . class , ( ) -> targetSum . mergeWith ( summary ) ) ; }
google/differential-privacy | private BoundedSum . Params . Builder getBoundedSumBuilderWithFields ( ) { return BoundedSum . builder ( ) . epsilon ( EPSILON ) . delta ( DELTA ) . noise ( noise ) . maxPartitionsContributed ( 1 ) . maxContributionsPerPartition ( 10 ) . lower ( - 10 ) . upper ( 10 ) ; }
dbs-leipzig/gradoop | @ Override public CCSSubgraph map ( CCSSubgraphEmbeddings subgraphEmbeddings ) throws Exception { reuseTuple . setCategory ( subgraphEmbeddings . getCategory ( ) ) ; reuseTuple . setCanonicalLabel ( subgraphEmbeddings . getCanonicalLabel ( ) ) ; reuseTuple . setEmbedding ( subgraphEmbeddings . getEmbeddings ( ) . iterator ( ) . next ( ) ) ; return reuseTuple ; }
JasmeenKaur19/jenkins-client | @ Test public void shouldAddStringParamToAnExistingJob ( ) throws IOException { JenkinsServer js = new JenkinsServer ( URI . create ( " http : // ci . soebes . de : 8080 / " ) ) ; MavenJobWithDetails mavenJob = js . getMavenJob ( " SupoSE " ) ; BuildWithDetails details = mavenJob . getLastSuccessfulBuild ( ) . details ( ) ; System . out . println ( " Build ▁ Number : ▁ " + details . getNumber ( ) ) ; TestReport testReport = mavenJob . getLastSuccessfulBuild ( ) . getTestReport ( ) ; System . out . println ( " - - - - - - ▁ Tests " ) ; System . out . println ( " ▁ ▁ ▁ ▁ urlName : ▁ " + testReport . getUrlName ( ) ) ; System . out . println ( " ▁ ▁ failCount : ▁ " + testReport . getFailCount ( ) ) ; System . out . println ( " ▁ ▁ skipCount : ▁ " + testReport . getSkipCount ( ) ) ; System . out . println ( " ▁ totalCount : ▁ " + testReport . getTotalCount ( ) ) ; List < TestChildReport > childReports = testReport . getChildReports ( ) ; for ( TestChildReport testChildReport : childReports ) { TestChild child = testChildReport . getChild ( ) ; System . out . println ( " ▁ Child ▁ number : ▁ " + child . getNumber ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ ▁ ▁ url : ▁ " + child . getUrl ( ) ) ; TestResult testResult = testChildReport . getResult ( ) ; System . out . println ( " ▁ Child ▁ ▁ ▁ duration : ▁ " + testResult . getDuration ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ failCount : ▁ " + testResult . getFailCount ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ passCount : ▁ " + testResult . getPassCount ( ) ) ; System . out . println ( " ▁ Child ▁ ▁ skipCount : ▁ " + testResult . getSkipCount ( ) ) ; List < TestSuites > suites = testResult . getSuites ( ) ; for ( TestSuites testSuite : suites ) { System . out . println ( " ▁ ▁ ▁ TestSuite ▁ ▁ duration : " + testSuite . getDuration ( ) ) ; System . out . println ( " ▁ ▁ ▁ TestSuite ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ id : " + testSuite . getId ( ) ) ; System . out . println ( " ▁ ▁ ▁ TestSuite ▁ ▁ ▁ ▁ ▁ ▁ name : " + testSuite . getName ( ) ) ; System . out . println ( " ▁ ▁ ▁ TestSuite ▁ timestamp : " + testSuite . getTimestamp ( ) ) ; List < TestCase > testCases = testSuite . getCases ( ) ; double sumTestCases = 0.0 ; for ( TestCase testCase : testCases ) { System . out . println ( " ▁ ▁ ▁ ▁ ▁ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ age : ▁ " + testCase . getAge ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ classname : ▁ " + testCase . getClassName ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ duration : ▁ " + testCase . getDuration ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ failedSince : ▁ " + testCase . getFailedSince ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ name : ▁ " + testCase . getName ( ) ) ; System . out . println ( " ▁ ▁ ▁ ▁ ▁ TestCase : ▁ ▁ ▁ ▁ ▁ ▁ status : ▁ " + testCase . getStatus ( ) ) ; sumTestCases += testCase . getDuration ( ) ; } System . out . println ( " - - - - > ▁ SUM : ▁ " + sumTestCases ) ; } } }
ControlSystemStudio/diirt | public final PVDirector < ? > getDirector ( ) { return director ; }
ControlSystemStudio/diirt | public final < T > DesiredRateExpression < T > channel ( String channelName , Class clazz ) { return new LastOfChannelExpression < > ( channelName , clazz ) ; }
ControlSystemStudio/diirt | void setDirector ( PVDirector < ? > director ) { this . director = director ; }
CandleCandle/camel | @ Override public boolean isUseRouteBuilder ( ) { return false ; }
CandleCandle/camel | @ Test public void testHttpsHandshakeError ( ) throws Exception { if ( isJavaVendor ( " ibm " ) ) { return ; } getMockEndpoint ( " mock : target " ) . expectedMessageCount ( 0 ) ; context . addRoutes ( new RouteBuilder ( ) { public void configure ( ) { from ( " netty - http : https : // localhost : { { port } } ? ssl = true & needClientAuth = true & keyStoreFormat = JKS " + " & passphrase = storepassword & keyStoreResource = jsse / server - keystore . jks & trustStoreResource = jsse / server - truststore . jks " ) . to ( " mock : target " ) ; } } ) ; context . start ( ) ; DefaultExchange exchange = new DefaultExchange ( context ) ; Exchange response = template . send ( " netty - http : https : // localhost : { { port } } ? requestTimeout = 10000 & throwExceptionOnFailure = false " + " & ssl = true & keyStoreFormat = JKS & passphrase = storepassword & keyStoreResource = jsse / client - keystore . jks & trustStoreResource = jsse / server - truststore . jks " , exchange ) ; Exception ex = response . getException ( ) ; assertTrue ( " should ▁ have ▁ failed " , response . isFailed ( ) ) ; assertEquals ( " exception ▁ expected " , javax . net . ssl . SSLHandshakeException . class , ex . getClass ( ) ) ; assertMockEndpointsSatisfied ( ) ; }
damorim/compilers-cin | i ++ ) { tokenNames [ i ] = VOCABULARY . getLiteralName ( i ) ; if ( tokenNames [ i ] == null ) { tokenNames [ i ] = VOCABULARY . getSymbolicName ( i ) ; } if ( tokenNames [ i ] == null ) { tokenNames [ i ] = " < INVALID > " ; } }
damorim/compilers-cin | @ Override @ Deprecated public String [ ] getTokenNames ( ) { return tokenNames ; }
damorim/compilers-cin | @ Override public Vocabulary getVocabulary ( ) { return VOCABULARY ; }
damorim/compilers-cin | public TestLexer ( CharStream input ) { super ( input ) ; _interp = new LexerATNSimulator ( this , _ATN , _decisionToDFA , _sharedContextCache ) ; }
damorim/compilers-cin | @ Override public String getGrammarFileName ( ) { return " Test . g4" ; }
damorim/compilers-cin | @ Override public String [ ] getRuleNames ( ) { return ruleNames ; }
damorim/compilers-cin | @ Override public String getSerializedATN ( ) { return _serializedATN ; }
damorim/compilers-cin | @ Override public String [ ] getModeNames ( ) { return modeNames ; }
damorim/compilers-cin | @ Override public ATN getATN ( ) { return _ATN ; }
damorim/compilers-cin | i ++ ) { _decisionToDFA [ i ] = new DFA ( _ATN . getDecisionState ( i ) , i ) ; }
prabodhprakash/problemsolving | private void printLCS ( ) { int i = 0 , j = 0 ; StringBuffer sb = new StringBuffer ( ) ; while ( i < sizeA && j < sizeB ) { if ( string1 [ i ] . equalsIgnoreCase ( string2 [ j ] ) ) { sb . append ( string1 [ i ] + " ▁ " ) ; i ++ ; j ++ ; } else if ( max [ i + 1 ] [ j ] >= max [ i ] [ j + 1 ] ) { i ++ ; } else { j ++ ; } } System . out . println ( sb . toString ( ) ) ; }
prabodhprakash/problemsolving | private void readInput ( ) { Scanner in = new Scanner ( System . in ) ; String [ ] sizes = in . nextLine ( ) . split ( " ▁ " ) ; sizeA = Integer . parseInt ( sizes [ 0 ] ) ; sizeB = Integer . parseInt ( sizes [ 1 ] ) ; max = new int [ sizeA + 1 ] [ sizeB + 1 ] ; string1 = in . nextLine ( ) . split ( " ▁ " ) ; string2 = in . nextLine ( ) . split ( " ▁ " ) ; in . close ( ) ; }
prabodhprakash/problemsolving | private int calculateLCS ( int i , int j ) { if ( i >= sizeA || j >= sizeB ) { return 0 ; } if ( max [ i ] [ j ] > 0 ) { return max [ i ] [ j ] ; } String a = string1 [ i ] ; String b = string2 [ j ] ; if ( i < sizeA && j < sizeB && a . equalsIgnoreCase ( b ) ) { max [ i ] [ j ] = 1 + calculateLCS ( i + 1 , j + 1 ) ; } else { max [ i ] [ j ] = Math . max ( calculateLCS ( i + 1 , j ) , calculateLCS ( i , j + 1 ) ) ; } return max [ i ] [ j ] ; }
plum-umd/pasket | public void paintIcon ( Component c , Graphics g , int x , int y ) { Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . setColor ( Color . WHITE ) ; g2d . fillRect ( x + 1 , y + 1 , width - 2 , height - 2 ) ; g2d . setColor ( Color . BLACK ) ; g2d . drawRect ( x + 1 , y + 1 , width - 2 , height - 2 ) ; g2d . setColor ( Color . RED ) ; g2d . setStroke ( stroke ) ; g2d . drawLine ( x + 10 , y + 10 , x + width - 10 , y + height - 10 ) ; g2d . drawLine ( x + 10 , y + height - 10 , x + width - 10 , y + 10 ) ; g2d . dispose ( ) ; }
plum-umd/pasket | public int getIconWidth ( ) { return width ; }
plum-umd/pasket | public int getIconHeight ( ) { return height ; }
AdrianCozma/gateway | @ Override public String getSchemeName ( ) { return SCHEME_NAME ; }
AdrianCozma/gateway | @ Override protected int getSchemePort ( ) { return SCHEME_PORT ; }
AdrianCozma/gateway | @ Override protected String getTransportName ( ) { return TRANSPORT_NAME ; }
AdrianCozma/gateway | @ Override protected ResourceFactory getTransportFactory ( ) { return TRANSPORT_FACTORY ; }
AdrianCozma/gateway | @ Override protected String getProtocolName ( ) { return PROTOCOL_NAME ; }
AdrianCozma/gateway | @ Override protected void parseNamedOptions0 ( String location , ResourceOptions options , Map < String , Object > optionsByName ) { Boolean keepAlive = ( Boolean ) optionsByName . remove ( KEEP_ALIVE . name ( ) ) ; if ( keepAlive != null ) { options . setOption ( KEEP_ALIVE , keepAlive ) ; } Object maxRedirects = optionsByName . remove ( MAXIMUM_REDIRECTS . name ( ) ) ; if ( maxRedirects != null ) { options . setOption ( MAXIMUM_REDIRECTS , maxRedirects instanceof String ? Integer . parseInt ( ( String ) maxRedirects ) : ( Integer ) maxRedirects ) ; } Integer keepAliveTimeout = ( Integer ) optionsByName . remove ( KEEP_ALIVE_TIMEOUT . name ( ) ) ; if ( keepAliveTimeout != null ) { options . setOption ( KEEP_ALIVE_TIMEOUT , keepAliveTimeout ) ; } Integer keepAliveConnections = ( Integer ) optionsByName . remove ( KEEP_ALIVE_CONNECTIONS . name ( ) ) ; if ( keepAliveConnections != null ) { options . setOption ( KEEP_ALIVE_CONNECTIONS , keepAliveConnections ) ; } String [ ] requiredRoles = ( String [ ] ) optionsByName . remove ( REQUIRED_ROLES . name ( ) ) ; if ( requiredRoles != null ) { options . setOption ( REQUIRED_ROLES , requiredRoles ) ; } String authenticationConnect = ( String ) optionsByName . remove ( AUTHENTICATION_CONNECT . name ( ) ) ; if ( authenticationConnect != null ) { options . setOption ( AUTHENTICATION_CONNECT , authenticationConnect ) ; } String authenticationIdentifier = ( String ) optionsByName . remove ( AUTHENTICATION_IDENTIFIER . name ( ) ) ; if ( authenticationIdentifier != null ) { options . setOption ( AUTHENTICATION_IDENTIFIER , authenticationIdentifier ) ; } String encryptionKeyAlias = ( String ) optionsByName . remove ( ENCRYPTION_KEY_ALIAS . name ( ) ) ; if ( encryptionKeyAlias != null ) { options . setOption ( ENCRYPTION_KEY_ALIAS , encryptionKeyAlias ) ; } String serviceDomain = ( String ) optionsByName . remove ( SERVICE_DOMAIN . name ( ) ) ; if ( serviceDomain != null ) { options . setOption ( SERVICE_DOMAIN , serviceDomain ) ; } Set < HttpInjectableHeader > injectableHeaders = ( Set < HttpInjectableHeader > ) optionsByName . remove ( INJECTABLE_HEADERS . name ( ) ) ; if ( injectableHeaders != null ) { options . setOption ( INJECTABLE_HEADERS , injectableHeaders ) ; } Map < String , ? extends CrossSiteConstraintContext > acceptConstraints = ( Map < String , ? extends CrossSiteConstraintContext > ) optionsByName . remove ( ORIGIN_SECURITY . name ( ) ) ; if ( acceptConstraints != null ) { options . setOption ( ORIGIN_SECURITY , new HttpOriginSecurity ( acceptConstraints ) ) ; } File tempDirectory = ( File ) optionsByName . remove ( TEMP_DIRECTORY . name ( ) ) ; if ( tempDirectory != null ) { options . setOption ( TEMP_DIRECTORY , tempDirectory ) ; } List < Map < String , Map < String , CrossSiteConstraintContext > > > authorityToSetOfAcceptConstraintsByURI = ( List < Map < String , Map < String , CrossSiteConstraintContext > > > ) optionsByName . remove ( GATEWAY_ORIGIN_SECURITY . name ( ) ) ; if ( authorityToSetOfAcceptConstraintsByURI != null ) { options . setOption ( GATEWAY_ORIGIN_SECURITY , new GatewayHttpOriginSecurity ( authorityToSetOfAcceptConstraintsByURI ) ) ; } Collection < String > balanceOrigin = ( Collection < String > ) optionsByName . remove ( BALANCE_ORIGINS . name ( ) ) ; if ( balanceOrigin != null ) { options . setOption ( BALANCE_ORIGINS , balanceOrigin ) ; } Boolean serverHeaderEnabled = ( Boolean ) optionsByName . remove ( SERVER_HEADER_ENABLED . name ( ) ) ; if ( serverHeaderEnabled != null ) { options . setOption ( SERVER_HEADER_ENABLED , serverHeaderEnabled ) ; } Boolean dateHeaderEnabled = ( Boolean ) optionsByName . remove ( DATE_HEADER_ENABLED . name ( ) ) ; if ( serverHeaderEnabled != null ) { options . setOption ( DATE_HEADER_ENABLED , dateHeaderEnabled ) ; } Boolean userAgentHeaderEnabled = ( Boolean ) optionsByName . remove ( USER_AGENT_HEADER_ENABLED . name ( ) ) ; if ( userAgentHeaderEnabled != null ) { options . setOption ( USER_AGENT_HEADER_ENABLED , userAgentHeaderEnabled ) ; } Boolean hostHeaderEnabled = ( Boolean ) optionsByName . remove ( HOST_HEADER_ENABLED . name ( ) ) ; if ( hostHeaderEnabled != null ) { options . setOption ( HOST_HEADER_ENABLED , hostHeaderEnabled ) ; } Object maxAuthenticationAttempts = optionsByName . remove ( MAX_AUTHENTICATION_ATTEMPTS . name ( ) ) ; if ( maxAuthenticationAttempts != null ) { if ( maxAuthenticationAttempts instanceof String ) { maxAuthenticationAttempts = Integer . parseInt ( ( String ) maxAuthenticationAttempts ) ; } options . setOption ( MAX_AUTHENTICATION_ATTEMPTS , ( Integer ) maxAuthenticationAttempts ) ; } HttpRealmInfo [ ] realms = ( HttpRealmInfo [ ] ) optionsByName . remove ( REALMS . name ( ) ) ; if ( realms != null ) { options . setOption ( REALMS , realms ) ; } IdentityResolver httpIdentityResolver = ( IdentityResolver ) optionsByName . remove ( IDENTITY_RESOLVER . name ( ) ) ; if ( httpIdentityResolver != null ) { options . setOption ( IDENTITY_RESOLVER , httpIdentityResolver ) ; } else { Collection < Class < ? extends Principal > > userPrincipalClasses = getUserPrincipalClasses ( ( HttpRealmInfo [ ] ) optionsByName . remove ( REALMS . name ( ) ) ) ; if ( userPrincipalClasses != null && ! userPrincipalClasses . isEmpty ( ) ) { httpIdentityResolver = new HttpIdentityResolver ( userPrincipalClasses ) ; options . setOption ( IDENTITY_RESOLVER , httpIdentityResolver ) ; } } }
AdrianCozma/gateway | private Collection < Class < ? extends Principal > > getUserPrincipalClasses ( HttpRealmInfo [ ] realms ) { if ( realms != null && realms . length > 0 ) { if ( realms . length == 1 ) { return realms [ 0 ] . getUserPrincipleClasses ( ) ; } else { return Arrays . stream ( realms ) . map ( r -> r . getUserPrincipleClasses ( ) ) . filter ( upc -> upc != null ) . flatMap ( upc -> upc . stream ( ) ) . collect ( Collectors . toList ( ) ) ; } } else { return Collections . emptySet ( ) ; } }
AdrianCozma/gateway | @ Override protected void setAlternateOption ( final String location , ResourceOptions options , Map < String , Object > optionsByName ) { String key = options . getOption ( HttpResourceAddress . NEXT_PROTOCOL ) ; String scheme = URIUtils . getScheme ( location ) ; final boolean secureScheme = " https " . equals ( scheme ) || scheme . contains ( " + ssl " ) ; if ( key != null && secureScheme ) { key = key + " ▁ secure " ; } List < ResourceFactory > resourceFactories = RESOURCE_FACTORIES_BY_KEY . get ( key ) ; if ( resourceFactories != null && ! resourceFactories . isEmpty ( ) && getResourceAddressFactory ( ) != null ) { HttpResourceAddress alternateAddress = null ; for ( ResourceFactory resourceFactory : resourceFactories ) { alternateAddress = newResourceAddressWithAlternate ( resourceFactory . createURI ( location ) , getNewOptionsByName ( options , optionsByName ) , alternateAddress ) ; } options . setOption ( ResourceAddress . ALTERNATE , alternateAddress ) ; } }
AdrianCozma/gateway | @ Override protected HttpResourceAddress newResourceAddress0 ( String original , String location ) { String host = URIUtils . getHost ( location ) ; int port = URIUtils . getPort ( location ) ; String path = URIUtils . getPath ( location ) ; if ( host == null ) { throw new IllegalArgumentException ( format ( " Missing ▁ host ▁ in ▁ URI : ▁ % s " , location ) ) ; } if ( port == - 1 ) { throw new IllegalArgumentException ( format ( " Missing ▁ port ▁ in ▁ URI : ▁ % s " , location ) ) ; } if ( path == null || path . length ( ) == 0 ) { throw new IllegalArgumentException ( format ( " Missing ▁ path ▁ in ▁ URI : ▁ % s " , location ) ) ; } URI uriLocation = URI . create ( location ) ; return new HttpResourceAddress ( this , original , uriLocation ) ; }
AdrianCozma/gateway | @ Override protected void setOptions ( HttpResourceAddress address , ResourceOptions options , Object qualifier ) { super . setOptions ( address , options , qualifier ) ; address . setOption0 ( KEEP_ALIVE , options . getOption ( KEEP_ALIVE ) ) ; address . setOption0 ( MAXIMUM_REDIRECTS , options . getOption ( MAXIMUM_REDIRECTS ) ) ; address . setOption0 ( KEEP_ALIVE_TIMEOUT , options . getOption ( KEEP_ALIVE_TIMEOUT ) ) ; address . setOption0 ( KEEP_ALIVE_CONNECTIONS , options . getOption ( KEEP_ALIVE_CONNECTIONS ) ) ; address . setOption0 ( REQUIRED_ROLES , options . getOption ( REQUIRED_ROLES ) ) ; address . setOption0 ( INJECTABLE_HEADERS , options . getOption ( INJECTABLE_HEADERS ) ) ; address . setOption0 ( ORIGIN_SECURITY , options . getOption ( ORIGIN_SECURITY ) ) ; address . setOption0 ( TEMP_DIRECTORY , options . getOption ( TEMP_DIRECTORY ) ) ; address . setOption0 ( GATEWAY_ORIGIN_SECURITY , options . getOption ( GATEWAY_ORIGIN_SECURITY ) ) ; address . setOption0 ( BALANCE_ORIGINS , options . getOption ( BALANCE_ORIGINS ) ) ; address . setOption0 ( AUTHENTICATION_CONNECT , options . getOption ( AUTHENTICATION_CONNECT ) ) ; address . setOption0 ( AUTHENTICATION_IDENTIFIER , options . getOption ( AUTHENTICATION_IDENTIFIER ) ) ; address . setOption0 ( ENCRYPTION_KEY_ALIAS , options . getOption ( ENCRYPTION_KEY_ALIAS ) ) ; address . setOption0 ( SERVICE_DOMAIN , options . getOption ( SERVICE_DOMAIN ) ) ; address . setOption0 ( SERVER_HEADER_ENABLED , options . getOption ( SERVER_HEADER_ENABLED ) ) ; address . setOption0 ( USER_AGENT_HEADER_ENABLED , options . getOption ( USER_AGENT_HEADER_ENABLED ) ) ; address . setOption0 ( HOST_HEADER_ENABLED , options . getOption ( HOST_HEADER_ENABLED ) ) ; address . setOption0 ( DATE_HEADER_ENABLED , options . getOption ( DATE_HEADER_ENABLED ) ) ; address . setOption0 ( MAX_AUTHENTICATION_ATTEMPTS , options . getOption ( MAX_AUTHENTICATION_ATTEMPTS ) ) ; address . setOption0 ( REALMS , options . getOption ( REALMS ) ) ; if ( address . getOption ( IDENTITY_RESOLVER ) == null ) { Collection < Class < ? extends Principal > > realmUserPrincipalClasses = getUserPrincipalClasses ( address . getOption ( REALMS ) ) ; if ( realmUserPrincipalClasses != null && ! realmUserPrincipalClasses . isEmpty ( ) ) { IdentityResolver httpIdentityResolver = new HttpIdentityResolver ( realmUserPrincipalClasses ) ; address . setIdentityResolver ( IDENTITY_RESOLVER , httpIdentityResolver ) ; } } }
aws/aws-sdk-java | public ListTagsForResourceResult unmarshall ( JsonUnmarshallerContext context ) throws Exception { ListTagsForResourceResult listTagsForResourceResult = new ListTagsForResourceResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; String currentParentElement = context . getCurrentParentElement ( ) ; int targetDepth = originalDepth + 1 ; JsonToken token = context . getCurrentToken ( ) ; if ( token == null ) token = context . nextToken ( ) ; if ( token == VALUE_NULL ) { return listTagsForResourceResult ; } while ( true ) { if ( token == null ) break ; if ( token == FIELD_NAME || token == START_OBJECT ) { if ( context . testExpression ( " Tags " , targetDepth ) ) { context . nextToken ( ) ; listTagsForResourceResult . setTags ( new ListUnmarshaller < Tag > ( TagJsonUnmarshaller . getInstance ( ) ) . unmarshall ( context ) ) ; } } else if ( token == END_ARRAY || token == END_OBJECT ) { if ( context . getLastParsedParentElement ( ) == null || context . getLastParsedParentElement ( ) . equals ( currentParentElement ) ) { if ( context . getCurrentDepth ( ) <= originalDepth ) break ; } } token = context . nextToken ( ) ; } return listTagsForResourceResult ; }
donovanmuller/spring-cloud-dataflow | TaskNode ( String name , String taskDSL , List < LabelledTaskNode > sequences , boolean inAppMode ) { super ( ( sequences . size ( ) == 0 ) ? 0 : sequences . get ( 0 ) . getStartPos ( ) , ( sequences . size ( ) == 0 ) ? 0 : sequences . get ( sequences . size ( ) - 1 ) . getEndPos ( ) ) ; this . name = name ; this . taskDSL = taskDSL ; this . sequences = sequences ; }
donovanmuller/spring-cloud-dataflow | @ Override public String stringify ( boolean includePositionInfo ) { StringBuilder s = new StringBuilder ( ) ; for ( int i = 0 ; i < sequences . size ( ) ; i ++ ) { if ( i > 0 ) { s . append ( " \n " ) ; } s . append ( sequences . get ( i ) . stringify ( includePositionInfo ) ) ; } return s . toString ( ) ; }
donovanmuller/spring-cloud-dataflow | public List < TaskApp > getTaskApps ( ) { if ( taskApps == null ) { TaskAppsCollector collector = new TaskAppsCollector ( ) ; accept ( collector ) ; taskApps = collector . getTaskApps ( ) ; } return taskApps ; }
donovanmuller/spring-cloud-dataflow | public void accept ( TaskVisitor visitor ) { Assert . notNull ( visitor , " visitor ▁ expected ▁ to ▁ be ▁ non - null " ) ; visitor . startVisit ( this . name , this . taskDSL ) ; int sequenceNumber = 0 ; for ( LabelledTaskNode ctn : sequences ) { if ( visitor . preVisitSequence ( ctn , sequenceNumber ) ) { ctn . accept ( visitor ) ; visitor . postVisitSequence ( ctn , sequenceNumber ) ; } sequenceNumber ++ ; } visitor . endVisit ( ) ; }
donovanmuller/spring-cloud-dataflow | public Graph toGraph ( ) { GraphGeneratorVisitor ggv = new GraphGeneratorVisitor ( ) ; this . accept ( ggv ) ; return ggv . getGraph ( ) ; }
donovanmuller/spring-cloud-dataflow | public List < TaskValidationProblem > validate ( ) { TaskValidatorVisitor validator = new TaskValidatorVisitor ( ) ; this . accept ( validator ) ; return validator . getProblems ( ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void startVisit ( String taskName , String taskDSL ) { this . taskName = taskName ; }
donovanmuller/spring-cloud-dataflow | @ Override public void visit ( TaskAppNode taskApp ) { taskApps . add ( new TaskApp ( taskName , taskApp ) ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void visit ( TransitionNode transition ) { if ( transition . isTargetApp ( ) ) { taskApps . add ( new TaskApp ( taskName , transition . getTargetApp ( ) ) ) ; } }
donovanmuller/spring-cloud-dataflow | public List < TaskApp > getTaskApps ( ) { return taskApps ; }
donovanmuller/spring-cloud-dataflow | public String getName ( ) { return this . name ; }
donovanmuller/spring-cloud-dataflow | public String getTaskText ( ) { return this . taskDSL ; }
donovanmuller/spring-cloud-dataflow | public LabelledTaskNode getStart ( ) { if ( sequences . size ( ) == 0 ) { return null ; } else { return sequences . get ( 0 ) ; } }
donovanmuller/spring-cloud-dataflow | public List < LabelledTaskNode > getSequences ( ) { return Collections . unmodifiableList ( sequences ) ; }
donovanmuller/spring-cloud-dataflow | public LabelledTaskNode getSequenceWithLabel ( String label ) { Assert . hasText ( label , " label ▁ is ▁ required " ) ; for ( LabelledTaskNode ctn : sequences ) { if ( ctn . hasLabel ( ) && ctn . getLabelString ( ) . equals ( label ) ) { return ctn ; } } return null ; }
donovanmuller/spring-cloud-dataflow | public String toDSL ( ) { return stringify ( false ) ; }
donovanmuller/spring-cloud-dataflow | public String toExecutableDSL ( ) { ExecutableDSLVisitor v = new ExecutableDSLVisitor ( ) ; accept ( v ) ; return v . getDSL ( ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void startVisit ( String taskName , String taskDSL ) { this . taskName = taskName ; }
donovanmuller/spring-cloud-dataflow | @ Override public boolean preVisit ( FlowNode flow ) { if ( ! state . isEmpty ( ) && state . peek ( ) == IN_SPLIT ) { dsl . append ( " ▁ | | ▁ " ) ; } state . push ( START_OF_FLOW ) ; return true ; }
donovanmuller/spring-cloud-dataflow | @ Override public void postVisit ( FlowNode flow ) { state . pop ( ) ; if ( ! state . isEmpty ( ) && state . peek ( ) == START_OF_SPLIT ) { state . pop ( ) ; state . push ( IN_SPLIT ) ; } }
donovanmuller/spring-cloud-dataflow | @ Override public boolean preVisit ( SplitNode split ) { if ( state . peek ( ) == START_OF_FLOW ) { state . pop ( ) ; state . push ( IN_FLOW ) ; } else if ( state . peek ( ) == IN_FLOW ) { dsl . append ( " ▁ & & ▁ " ) ; } state . push ( START_OF_SPLIT ) ; dsl . append ( " < " ) ; return true ; }
donovanmuller/spring-cloud-dataflow | @ Override public void postVisit ( SplitNode split ) { dsl . append ( " > " ) ; state . pop ( ) ; }
donovanmuller/spring-cloud-dataflow | @ Override public void visit ( TaskAppNode taskApp ) { int currentState = state . peek ( ) ; if ( currentState == START_OF_FLOW ) { state . pop ( ) ; state . push ( IN_FLOW ) ; } else if ( currentState == IN_FLOW ) { dsl . append ( " ▁ & & ▁ " ) ; } else { throw new IllegalStateException ( " " + state . peek ( ) ) ; } dsl . append ( toExecutableDSLTaskName ( taskApp ) ) ; List < TransitionNode > transitions = taskApp . getTransitions ( ) ; for ( TransitionNode transition : transitions ) { dsl . append ( " ▁ " ) ; dsl . append ( transition . getStatusToCheckInDSLForm ( ) ) ; dsl . append ( " - > " ) ; if ( transition . isTargetApp ( ) ) { dsl . append ( toExecutableDSLTaskName ( transition . getTargetApp ( ) ) ) ; } else { dsl . append ( " : " ) . append ( transition . getTargetLabel ( ) ) ; } } }
donovanmuller/spring-cloud-dataflow | private String toExecutableDSLTaskName ( TaskAppNode taskApp ) { StringBuilder taskDefName = new StringBuilder ( ) ; taskDefName . append ( getTaskPrefix ( taskName ) ) ; if ( taskApp . hasLabel ( ) ) { taskDefName . append ( taskApp . getLabelString ( ) ) ; } else { taskDefName . append ( taskApp . getName ( ) ) ; } return taskDefName . toString ( ) ; }
donovanmuller/spring-cloud-dataflow | public String getDSL ( ) { return dsl . toString ( ) ; }
donovanmuller/spring-cloud-dataflow | public boolean isComposed ( ) { boolean isOneTask = ( sequences . size ( ) == 1 && sequences . get ( 0 ) . isFlow ( ) && ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesLength ( ) == 1 && ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesElement ( 0 ) . isTaskApp ( ) ) ; if ( ! isOneTask ) { return true ; } TaskAppNode singleNode = ( TaskAppNode ) ( ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesElement ( 0 ) ) ; return singleNode . hasTransitions ( ) ; }
donovanmuller/spring-cloud-dataflow | public TaskAppNode getTaskApp ( ) { return ( isComposed ( ) ? null : ( TaskAppNode ) ( ( ( FlowNode ) sequences . get ( 0 ) ) . getSeriesElement ( 0 ) ) ) ; }
donovanmuller/spring-cloud-dataflow | public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; s . append ( " TaskNode ▁ for ▁ " ) . append ( taskDSL . replaceAll ( " \n " , " ; " ) ) ; s . append ( " \n " ) . append ( sequences ) ; return s . toString ( ) ; }
tilioteo/hypothesis | public Interval ( T min , T max ) { this . min = min ; this . max = max ; }
tilioteo/hypothesis | public boolean contains ( T value ) { if ( value != null ) { return value . compareTo ( min ) >= 0 && value . compareTo ( max ) <= 0 ; } return false ; }
tilioteo/hypothesis | public boolean containsExclusive ( T value ) { if ( value != null ) { return value . compareTo ( min ) > 0 && value . compareTo ( max ) < 0 ; } return false ; }
tilioteo/hypothesis | public boolean containsExclusiveRight ( T value ) { if ( value != null ) { return value . compareTo ( min ) >= 0 && value . compareTo ( max ) < 0 ; } return false ; }
tilioteo/hypothesis | public boolean containsExclusiveLeft ( T value ) { if ( value != null ) { return value . compareTo ( min ) > 0 && value . compareTo ( max ) <= 0 ; } return false ; }
ufoscout/jpattern | @ Override protected void setUp ( ) throws Exception { super . setUp ( ) ; }
ufoscout/jpattern | @ Override protected void tearDown ( ) throws Exception { super . tearDown ( ) ; }
ufoscout/jpattern | public void testString ( ) { assertTrue ( mc . estimate ( new String ( " Hello ▁ World ! " ) ) >= 64 ) ; }
ufoscout/jpattern | public void testIntegerToString ( ) { for ( int i = 0 ; i < 1 ; i ++ ) { assertEquals ( 42 , mc . estimate ( " " + i ) ) ; } }
ufoscout/jpattern | Entry ( int h , Object k , Object v , Entry n ) { value = v ; next = n ; key = k ; hash = h ; }
ufoscout/jpattern | @ Override public Object getKey ( ) { return key ; }
ufoscout/jpattern | @ Override public Object getValue ( ) { return value ; }
ufoscout/jpattern | @ Override public Object setValue ( Object value ) { return value ; }
ufoscout/jpattern | public void testHashMap ( ) { assertTrue ( mc . estimate ( new HashMap < Object , Object > ( ) ) >= 120 ) ; Byte [ ] all = new Byte [ 256 ] ; for ( int i = - 128 ; i < 128 ; i ++ ) { all [ i + 128 ] = new Byte ( ( byte ) i ) ; } assertTrue ( mc . estimate ( all ) >= 5136 ) ; HashMap < Object , Object > hm = new HashMap < Object , Object > ( ) ; for ( int i = - 128 ; i < 128 ; i ++ ) { hm . put ( " " + i , new Byte ( ( byte ) i ) ) ; } assertEquals ( 23940 , mc . estimate ( hm ) ) ; }
ufoscout/jpattern | public void testVector ( ) { assertEquals ( 80 , mc . estimate ( new Vector < Object > ( 10 ) ) ) ; }
ufoscout/jpattern | public void testObject ( ) { assertEquals ( 8 , mc . estimate ( new Object ( ) ) ) ; }
ufoscout/jpattern | public void testInteger ( ) { assertEquals ( 16 , mc . estimate ( new Integer ( 1 ) ) ) ; }
ufoscout/jpattern | public void testCharArray ( ) { assertEquals ( 40 , mc . estimate ( " Hello ▁ World ! " . toCharArray ( ) ) ) ; }
ufoscout/jpattern | public void testByte ( ) { assertEquals ( 16 , mc . estimate ( new Byte ( ( byte ) 10 ) ) ) ; }
ufoscout/jpattern | public void testThreeBytes ( ) { assertEquals ( 16 , mc . estimate ( new ThreeBytes ( ) ) ) ; }
ufoscout/jpattern | public void testSixtyFourBooleans ( ) { assertEquals ( 72 , mc . estimate ( new SixtyFourBooleans ( ) ) ) ; }
ufoscout/jpattern | public void testThousandBooleansObjects ( ) { Boolean [ ] booleans = new Boolean [ 1000 ] ; for ( int i = 0 ; i < booleans . length ; i ++ ) booleans [ i ] = new Boolean ( true ) ; assertEquals ( 20016 , mc . estimate ( booleans ) ) ; }
ufoscout/jpattern | public void testThousandBytes ( ) { assertEquals ( 1016 , mc . estimate ( new byte [ 1000 ] ) ) ; }
ufoscout/jpattern | public void testEmptyArrayList ( ) { assertEquals ( 80 , mc . estimate ( new ArrayList < Object > ( ) ) ) ; }
ufoscout/jpattern | public void testFullArrayList ( ) { ArrayList < Object > arrayList = new ArrayList < Object > ( 10000 ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { arrayList . add ( new Object ( ) ) ; } assertEquals ( 120040 , mc . estimate ( arrayList ) ) ; }
ufoscout/jpattern | public void testFullLinkedList ( ) { LinkedList < Object > linkedList = new LinkedList < Object > ( ) ; for ( int i = 0 ; i < 10000 ; i ++ ) { linkedList . add ( new Object ( ) ) ; } assertEquals ( 320048 , mc . estimate ( linkedList ) ) ; }
ufoscout/jpattern | public void testComplexClass ( ) { assertEquals ( 48 , mc . estimate ( new ComplexClass ( ) ) ) ; }
ufoscout/jpattern | public void testBooleanArray ( ) { assertEquals ( 27 , mc . estimate ( new boolean [ 11 ] ) ) ; }
ufoscout/jpattern | public void testShortArray ( ) { assertEquals ( 38 , mc . estimate ( new short [ 11 ] ) ) ; }
ufoscout/jpattern | public void testIntArray ( ) { assertEquals ( 60 , mc . estimate ( new int [ 11 ] ) ) ; }
ufoscout/jpattern | public void testFloatArray ( ) { assertEquals ( 60 , mc . estimate ( new float [ 11 ] ) ) ; }
ufoscout/jpattern | public void testLongArray ( ) { assertEquals ( 104 , mc . estimate ( new long [ 11 ] ) ) ; }
ufoscout/jpattern | public void testDoubleArray ( ) { assertEquals ( 104 , mc . estimate ( new double [ 11 ] ) ) ; }
eljefe6a/incubator-beam | ShardFn ( int numShards , RecordIdMethod recordIdMethod ) { this . numShards = numShards ; this . recordIdMethod = recordIdMethod ; }
eljefe6a/incubator-beam | @ ProcessElement public void processElement ( ProcessContext c ) throws Exception { elementCounter . inc ( ) ; PubsubMessage message = c . element ( ) ; byte [ ] elementBytes = message . getPayload ( ) ; Map < String , String > attributes = message . getAttributeMap ( ) ; long timestampMsSinceEpoch = c . timestamp ( ) . getMillis ( ) ; @ Nullable String recordId = null ; switch ( recordIdMethod ) { case NONE : break ; case DETERMINISTIC : recordId = Hashing . murmur3_128 ( ) . hashBytes ( elementBytes ) . toString ( ) ; break ; case RANDOM : recordId = UUID . randomUUID ( ) . toString ( ) ; break ; } c . output ( KV . of ( ThreadLocalRandom . current ( ) . nextInt ( numShards ) , new OutgoingMessage ( elementBytes , attributes , timestampMsSinceEpoch , recordId ) ) ) ; }
eljefe6a/incubator-beam | @ Override public void populateDisplayData ( Builder builder ) { super . populateDisplayData ( builder ) ; builder . add ( DisplayData . item ( " numShards " , numShards ) ) ; }
eljefe6a/incubator-beam | WriterFn ( PubsubClientFactory pubsubFactory , ValueProvider < TopicPath > topic , String timestampAttribute , String idAttribute , int publishBatchSize , int publishBatchBytes ) { this . pubsubFactory = pubsubFactory ; this . topic = topic ; this . timestampAttribute = timestampAttribute ; this . idAttribute = idAttribute ; this . publishBatchSize = publishBatchSize ; this . publishBatchBytes = publishBatchBytes ; }
eljefe6a/incubator-beam | private void publishBatch ( List < OutgoingMessage > messages , int bytes ) throws IOException { int n = pubsubClient . publish ( topic . get ( ) , messages ) ; checkState ( n == messages . size ( ) , " Attempted ▁ to ▁ publish ▁ % s ▁ messages ▁ but ▁ % s ▁ were ▁ successful " , messages . size ( ) , n ) ; batchCounter . inc ( ) ; elementCounter . inc ( messages . size ( ) ) ; byteCounter . inc ( bytes ) ; }
eljefe6a/incubator-beam | @ StartBundle public void startBundle ( StartBundleContext c ) throws Exception { checkState ( pubsubClient == null , " startBundle ▁ invoked ▁ without ▁ prior ▁ finishBundle " ) ; pubsubClient = pubsubFactory . newClient ( timestampAttribute , idAttribute , c . getPipelineOptions ( ) . as ( PubsubOptions . class ) ) ; }
eljefe6a/incubator-beam | @ ProcessElement public void processElement ( ProcessContext c ) throws Exception { List < OutgoingMessage > pubsubMessages = new ArrayList < > ( publishBatchSize ) ; int bytes = 0 ; for ( OutgoingMessage message : c . element ( ) . getValue ( ) ) { if ( ! pubsubMessages . isEmpty ( ) && bytes + message . elementBytes . length > publishBatchBytes ) { publishBatch ( pubsubMessages , bytes ) ; pubsubMessages . clear ( ) ; bytes = 0 ; } pubsubMessages . add ( message ) ; bytes += message . elementBytes . length ; } if ( ! pubsubMessages . isEmpty ( ) ) { publishBatch ( pubsubMessages , bytes ) ; } }
eljefe6a/incubator-beam | @ FinishBundle public void finishBundle ( ) throws Exception { pubsubClient . close ( ) ; pubsubClient = null ; }
eljefe6a/incubator-beam | @ Override public void populateDisplayData ( Builder builder ) { super . populateDisplayData ( builder ) ; builder . add ( DisplayData . item ( " topic " , topic ) ) ; builder . add ( DisplayData . item ( " transport " , pubsubFactory . getKind ( ) ) ) ; builder . addIfNotNull ( DisplayData . item ( " timestampAttribute " , timestampAttribute ) ) ; builder . addIfNotNull ( DisplayData . item ( " idAttribute " , idAttribute ) ) ; }
eljefe6a/incubator-beam | @ VisibleForTesting PubsubUnboundedSink ( PubsubClientFactory pubsubFactory , ValueProvider < TopicPath > topic , String timestampAttribute , String idAttribute , int numShards , int publishBatchSize , int publishBatchBytes , Duration maxLatency , RecordIdMethod recordIdMethod ) { this . pubsubFactory = pubsubFactory ; this . topic = topic ; this . timestampAttribute = timestampAttribute ; this . idAttribute = idAttribute ; this . numShards = numShards ; this . publishBatchSize = publishBatchSize ; this . publishBatchBytes = publishBatchBytes ; this . maxLatency = maxLatency ; this . recordIdMethod = idAttribute == null ? RecordIdMethod . NONE : recordIdMethod ; }
eljefe6a/incubator-beam | public PubsubUnboundedSink ( PubsubClientFactory pubsubFactory , ValueProvider < TopicPath > topic , String timestampAttribute , String idAttribute , int numShards ) { this ( pubsubFactory , topic , timestampAttribute , idAttribute , numShards , DEFAULT_PUBLISH_BATCH_SIZE , DEFAULT_PUBLISH_BATCH_BYTES , DEFAULT_MAX_LATENCY , RecordIdMethod . RANDOM ) ; }
eljefe6a/incubator-beam | public TopicPath getTopic ( ) { return topic . get ( ) ; }
eljefe6a/incubator-beam | public ValueProvider < TopicPath > getTopicProvider ( ) { return topic ; }
eljefe6a/incubator-beam | @ Nullable public String getTimestampAttribute ( ) { return timestampAttribute ; }
eljefe6a/incubator-beam | @ Nullable public String getIdAttribute ( ) { return idAttribute ; }
eljefe6a/incubator-beam | @ Override public PDone expand ( PCollection < PubsubMessage > input ) { input . apply ( " PubsubUnboundedSink . Window " , Window . < PubsubMessage > into ( new GlobalWindows ( ) ) . triggering ( Repeatedly . forever ( AfterFirst . of ( AfterPane . elementCountAtLeast ( publishBatchSize ) , AfterProcessingTime . pastFirstElementInPane ( ) . plusDelayOf ( maxLatency ) ) ) ) . discardingFiredPanes ( ) ) . apply ( " PubsubUnboundedSink . Shard " , ParDo . of ( new ShardFn ( numShards , recordIdMethod ) ) ) . setCoder ( KvCoder . of ( VarIntCoder . of ( ) , CODER ) ) . apply ( GroupByKey . < Integer , OutgoingMessage > create ( ) ) . apply ( " PubsubUnboundedSink . Writer " , ParDo . of ( new WriterFn ( pubsubFactory , topic , timestampAttribute , idAttribute , publishBatchSize , publishBatchBytes ) ) ) ; return PDone . in ( input . getPipeline ( ) ) ; }
Aliaksandr-Kastenka/pentaho-kettle | public IfNullDialog ( Shell parent , Object in , TransMeta tr , String sname ) { super ( parent , ( BaseStepMeta ) in , tr , sname ) ; input = ( IfNullMeta ) in ; }
Aliaksandr-Kastenka/pentaho-kettle | public String open ( ) { Shell parent = getParent ( ) ; Display display = parent . getDisplay ( ) ; shell = new Shell ( parent , SWT . DIALOG_TRIM | SWT . RESIZE | SWT . MIN | SWT . MAX ) ; props . setLook ( shell ) ; setShellImage ( shell , input ) ; lsMod = new ModifyListener ( ) { public void modifyText ( ModifyEvent e ) { input . setChanged ( ) ; } } ; changed = input . hasChanged ( ) ; oldlsMod = lsMod ; FormLayout formLayout = new FormLayout ( ) ; formLayout . marginWidth = Const . FORM_MARGIN ; formLayout . marginHeight = Const . FORM_MARGIN ; middle = props . getMiddlePct ( ) ; margin = Const . MARGIN ; FieldsRows = input . getFieldName ( ) . length ; shell . setLayout ( formLayout ) ; shell . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Shell . Title " ) ) ; wlStepname = new Label ( shell , SWT . RIGHT ) ; wlStepname . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Stepname . Label " ) ) ; props . setLook ( wlStepname ) ; fdlStepname = new FormData ( ) ; fdlStepname . left = new FormAttachment ( 0 , 0 ) ; fdlStepname . right = new FormAttachment ( middle , - margin ) ; fdlStepname . top = new FormAttachment ( 0 , margin ) ; wlStepname . setLayoutData ( fdlStepname ) ; wStepname = new Text ( shell , SWT . SINGLE | SWT . LEFT | SWT . BORDER ) ; wStepname . setText ( stepname ) ; props . setLook ( wStepname ) ; wStepname . addModifyListener ( lsMod ) ; fdStepname = new FormData ( ) ; fdStepname . left = new FormAttachment ( middle , 0 ) ; fdStepname . top = new FormAttachment ( 0 , margin ) ; fdStepname . right = new FormAttachment ( 100 , 0 ) ; wStepname . setLayoutData ( fdStepname ) ; wAllFields = new Group ( shell , SWT . SHADOW_NONE ) ; props . setLook ( wAllFields ) ; wAllFields . setText ( BaseMessages . getString ( PKG , " IfNullDialog . AllFields . Label " ) ) ; FormLayout AllFieldsgroupLayout = new FormLayout ( ) ; AllFieldsgroupLayout . marginWidth = 10 ; AllFieldsgroupLayout . marginHeight = 10 ; wAllFields . setLayout ( AllFieldsgroupLayout ) ; wlReplaceByValue = new Label ( wAllFields , SWT . RIGHT ) ; wlReplaceByValue . setText ( BaseMessages . getString ( PKG , " IfNullDialog . ReplaceByValue . Label " ) ) ; props . setLook ( wlReplaceByValue ) ; fdlReplaceByValue = new FormData ( ) ; fdlReplaceByValue . left = new FormAttachment ( 0 , 0 ) ; fdlReplaceByValue . right = new FormAttachment ( middle , - margin ) ; fdlReplaceByValue . top = new FormAttachment ( wStepname , margin * 2 ) ; wlReplaceByValue . setLayoutData ( fdlReplaceByValue ) ; wReplaceByValue = new TextVar ( transMeta , wAllFields , SWT . SINGLE | SWT . LEFT | SWT . BORDER ) ; wReplaceByValue . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . ReplaceByValue . Tooltip " ) ) ; props . setLook ( wReplaceByValue ) ; fdReplaceByValue = new FormData ( ) ; fdReplaceByValue . left = new FormAttachment ( middle , 0 ) ; fdReplaceByValue . top = new FormAttachment ( wStepname , 2 * margin ) ; fdReplaceByValue . right = new FormAttachment ( 100 , 0 ) ; wReplaceByValue . setLayoutData ( fdReplaceByValue ) ; wlSetEmptyStringAll = new Label ( wAllFields , SWT . RIGHT ) ; wlSetEmptyStringAll . setText ( BaseMessages . getString ( PKG , " IfNullDialog . SetEmptyStringAll . Label " ) ) ; props . setLook ( wlSetEmptyStringAll ) ; fdlSetEmptyStringAll = new FormData ( ) ; fdlSetEmptyStringAll . left = new FormAttachment ( 0 , 0 ) ; fdlSetEmptyStringAll . top = new FormAttachment ( wReplaceByValue , margin ) ; fdlSetEmptyStringAll . right = new FormAttachment ( middle , - margin ) ; wlSetEmptyStringAll . setLayoutData ( fdlSetEmptyStringAll ) ; wSetEmptyStringAll = new Button ( wAllFields , SWT . CHECK ) ; wSetEmptyStringAll . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . SetEmptyStringAll . Tooltip " ) ) ; props . setLook ( wSetEmptyStringAll ) ; fdSetEmptyStringAll = new FormData ( ) ; fdSetEmptyStringAll . left = new FormAttachment ( middle , 0 ) ; fdSetEmptyStringAll . top = new FormAttachment ( wReplaceByValue , margin ) ; fdSetEmptyStringAll . right = new FormAttachment ( 100 , 0 ) ; wSetEmptyStringAll . setLayoutData ( fdSetEmptyStringAll ) ; wSetEmptyStringAll . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { input . setChanged ( ) ; enableSetEmptyStringAll ( ) ; } } ) ; wlMask = new Label ( wAllFields , SWT . RIGHT ) ; wlMask . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Mask . Label " ) ) ; props . setLook ( wlMask ) ; fdlMask = new FormData ( ) ; fdlMask . left = new FormAttachment ( 0 , 0 ) ; fdlMask . top = new FormAttachment ( wSetEmptyStringAll , margin ) ; fdlMask . right = new FormAttachment ( middle , - margin ) ; wlMask . setLayoutData ( fdlMask ) ; wMask = new CCombo ( wAllFields , SWT . BORDER | SWT . READ_ONLY ) ; wMask . setEditable ( true ) ; wMask . setItems ( Const . getDateFormats ( ) ) ; props . setLook ( wMask ) ; wMask . addModifyListener ( lsMod ) ; fdMask = new FormData ( ) ; fdMask . left = new FormAttachment ( middle , 0 ) ; fdMask . top = new FormAttachment ( wSetEmptyStringAll , margin ) ; fdMask . right = new FormAttachment ( 100 , 0 ) ; wMask . setLayoutData ( fdMask ) ; fdAllFields = new FormData ( ) ; fdAllFields . left = new FormAttachment ( 0 , margin ) ; fdAllFields . top = new FormAttachment ( wStepname , margin ) ; fdAllFields . right = new FormAttachment ( 100 , - margin ) ; wAllFields . setLayoutData ( fdAllFields ) ; wlSelectFields = new Label ( shell , SWT . RIGHT ) ; wlSelectFields . setText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectFields . Label " ) ) ; props . setLook ( wlSelectFields ) ; fdlSelectFields = new FormData ( ) ; fdlSelectFields . left = new FormAttachment ( 0 , 0 ) ; fdlSelectFields . top = new FormAttachment ( wAllFields , margin ) ; fdlSelectFields . right = new FormAttachment ( middle , - margin ) ; wlSelectFields . setLayoutData ( fdlSelectFields ) ; wSelectFields = new Button ( shell , SWT . CHECK ) ; wSelectFields . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectFields . Tooltip " ) ) ; props . setLook ( wSelectFields ) ; fdSelectFields = new FormData ( ) ; fdSelectFields . left = new FormAttachment ( middle , 0 ) ; fdSelectFields . top = new FormAttachment ( wAllFields , margin ) ; fdSelectFields . right = new FormAttachment ( 100 , 0 ) ; wSelectFields . setLayoutData ( fdSelectFields ) ; wlSelectValuesType = new Label ( shell , SWT . RIGHT ) ; wlSelectValuesType . setText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectValuesType . Label " ) ) ; props . setLook ( wlSelectValuesType ) ; fdlSelectValuesType = new FormData ( ) ; fdlSelectValuesType . left = new FormAttachment ( 0 , 0 ) ; fdlSelectValuesType . top = new FormAttachment ( wSelectFields , margin ) ; fdlSelectValuesType . right = new FormAttachment ( middle , - margin ) ; wlSelectValuesType . setLayoutData ( fdlSelectValuesType ) ; wSelectValuesType = new Button ( shell , SWT . CHECK ) ; wSelectValuesType . setToolTipText ( BaseMessages . getString ( PKG , " IfNullDialog . SelectValuesType . Tooltip " ) ) ; props . setLook ( wSelectValuesType ) ; fdSelectValuesType = new FormData ( ) ; fdSelectValuesType . left = new FormAttachment ( middle , 0 ) ; fdSelectValuesType . top = new FormAttachment ( wSelectFields , margin ) ; fdSelectValuesType . right = new FormAttachment ( 100 , 0 ) ; wSelectValuesType . setLayoutData ( fdSelectValuesType ) ; wlValueTypes = new Label ( shell , SWT . NONE ) ; wlValueTypes . setText ( BaseMessages . getString ( PKG , " IfNullDialog . ValueTypes . Label " ) ) ; props . setLook ( wlValueTypes ) ; fdlValueTypes = new FormData ( ) ; fdlValueTypes . left = new FormAttachment ( 0 , 0 ) ; fdlValueTypes . top = new FormAttachment ( wSelectValuesType , margin ) ; wlValueTypes . setLayoutData ( fdlValueTypes ) ; int ValueTypesRows = input . getFieldName ( ) . length ; int FieldsCols = 4 ; ColumnInfo [ ] colval = new ColumnInfo [ FieldsCols ] ; colval [ 0 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . ValueType . Column " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , ValueMetaInterface . typeCodes ) ; colval [ 1 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . Column " ) , ColumnInfo . COLUMN_TYPE_TEXT , false ) ; colval [ 2 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . ConversionMask " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , Const . getDateFormats ( ) ) ; colval [ 3 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . SetEmptyString " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , new String [ ] { BaseMessages . getString ( PKG , " System . Combo . Yes " ) , BaseMessages . getString ( PKG , " System . Combo . No " ) } ) ; colval [ 1 ] . setUsingVariables ( true ) ; wValueTypes = new TableView ( transMeta , shell , SWT . BORDER | SWT . FULL_SELECTION | SWT . MULTI , colval , ValueTypesRows , oldlsMod , props ) ; fdValueTypes = new FormData ( ) ; fdValueTypes . left = new FormAttachment ( 0 , 0 ) ; fdValueTypes . top = new FormAttachment ( wlValueTypes , margin ) ; fdValueTypes . right = new FormAttachment ( 100 , 0 ) ; fdValueTypes . bottom = new FormAttachment ( wlValueTypes , 190 ) ; wValueTypes . setLayoutData ( fdValueTypes ) ; getFirstData ( ) ; wOK = new Button ( shell , SWT . PUSH ) ; wOK . setText ( BaseMessages . getString ( PKG , " System . Button . OK " ) ) ; wGet = new Button ( shell , SWT . PUSH ) ; wGet . setText ( BaseMessages . getString ( PKG , " System . Button . GetFields " ) ) ; wCancel = new Button ( shell , SWT . PUSH ) ; wCancel . setText ( BaseMessages . getString ( PKG , " System . Button . Cancel " ) ) ; setButtonPositions ( new Button [ ] { wOK , wGet , wCancel } , margin , null ) ; addFields ( ) ; wSelectValuesType . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { activeSelectValuesType ( ) ; input . setChanged ( ) ; } } ) ; wSelectFields . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { activeSelectFields ( ) ; input . setChanged ( ) ; } } ) ; lsCancel = new Listener ( ) { public void handleEvent ( Event e ) { cancel ( ) ; } } ; lsGet = new Listener ( ) { public void handleEvent ( Event e ) { get ( ) ; } } ; lsOK = new Listener ( ) { public void handleEvent ( Event e ) { ok ( ) ; } } ; wCancel . addListener ( SWT . Selection , lsCancel ) ; wOK . addListener ( SWT . Selection , lsOK ) ; wGet . addListener ( SWT . Selection , lsGet ) ; lsDef = new SelectionAdapter ( ) { public void widgetDefaultSelected ( SelectionEvent e ) { ok ( ) ; } } ; wStepname . addSelectionListener ( lsDef ) ; shell . addShellListener ( new ShellAdapter ( ) { public void shellClosed ( ShellEvent e ) { cancel ( ) ; } } ) ; setSize ( ) ; getData ( ) ; enableSetEmptyStringAll ( ) ; activeSelectFields ( ) ; activeSelectValuesType ( ) ; input . setChanged ( changed ) ; shell . open ( ) ; while ( ! shell . isDisposed ( ) ) { if ( ! display . readAndDispatch ( ) ) { display . sleep ( ) ; } } return stepname ; }
Aliaksandr-Kastenka/pentaho-kettle | private void addFields ( ) { int FieldsCols = 4 ; ColumnInfo [ ] colinf = new ColumnInfo [ FieldsCols ] ; wlFields = new Label ( shell , SWT . NONE ) ; wlFields . setText ( BaseMessages . getString ( PKG , " IfNullDialog . Fields . Label " ) ) ; props . setLook ( wlFields ) ; fdlFields = new FormData ( ) ; fdlFields . left = new FormAttachment ( 0 , 0 ) ; fdlFields . top = new FormAttachment ( wValueTypes , margin ) ; wlFields . setLayoutData ( fdlFields ) ; colinf [ 0 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Fieldname . Column " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , new String [ ] { } , false ) ; colinf [ 1 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . Column " ) , ColumnInfo . COLUMN_TYPE_TEXT , false ) ; colinf [ 2 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . ConversionMask " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , Const . getDateFormats ( ) ) ; colinf [ 1 ] . setUsingVariables ( true ) ; colinf [ 3 ] = new ColumnInfo ( BaseMessages . getString ( PKG , " IfNullDialog . Value . SetEmptyString " ) , ColumnInfo . COLUMN_TYPE_CCOMBO , new String [ ] { BaseMessages . getString ( PKG , " System . Combo . Yes " ) , BaseMessages . getString ( PKG , " System . Combo . No " ) } ) ; wFields = new TableView ( transMeta , shell , SWT . BORDER | SWT . FULL_SELECTION | SWT . MULTI , colinf , FieldsRows , oldlsMod , props ) ; fdFields = new FormData ( ) ; fdFields . left = new FormAttachment ( 0 , 0 ) ; fdFields . top = new FormAttachment ( wlFields , margin ) ; fdFields . right = new FormAttachment ( 100 , 0 ) ; fdFields . bottom = new FormAttachment ( wOK , - 2 * margin ) ; wFields . setLayoutData ( fdFields ) ; setComboValues ( ) ; fieldColumns . add ( colinf [ 0 ] ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void activeSelectFields ( ) { if ( wSelectFields . getSelection ( ) ) { wSelectValuesType . setSelection ( false ) ; wlValueTypes . setEnabled ( false ) ; wValueTypes . setEnabled ( false ) ; } activeFields ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void activeSelectValuesType ( ) { if ( wSelectValuesType . getSelection ( ) ) { wSelectFields . setSelection ( false ) ; wFields . setEnabled ( false ) ; wlFields . setEnabled ( false ) ; } activeFields ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void activeFields ( ) { wlFields . setEnabled ( wSelectFields . getSelection ( ) ) ; wFields . setEnabled ( wSelectFields . getSelection ( ) ) ; wGet . setEnabled ( wSelectFields . getSelection ( ) ) ; wlValueTypes . setEnabled ( wSelectValuesType . getSelection ( ) ) ; wValueTypes . setEnabled ( wSelectValuesType . getSelection ( ) ) ; wlReplaceByValue . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wReplaceByValue . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wlMask . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wMask . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wlSetEmptyStringAll . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; wSetEmptyStringAll . setEnabled ( ! wSelectFields . getSelection ( ) && ! wSelectValuesType . getSelection ( ) ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void get ( ) { try { RowMetaInterface r = transMeta . getPrevStepFields ( stepname ) ; if ( r != null ) { TableItemInsertListener insertListener = new TableItemInsertListener ( ) { public boolean tableItemInserted ( TableItem tableItem , ValueMetaInterface v ) { return true ; } } ; BaseStepDialog . getFieldsFromPrevious ( r , wFields , 1 , new int [ ] { 1 } , new int [ ] { } , - 1 , - 1 , insertListener ) ; } } catch ( KettleException ke ) { new ErrorDialog ( shell , BaseMessages . getString ( PKG , " System . Dialog . GetFieldsFailed . Title " ) , BaseMessages . getString ( PKG , " System . Dialog . GetFieldsFailed . Message " ) , ke ) ; } }
Aliaksandr-Kastenka/pentaho-kettle | private void setComboValues ( ) { Runnable fieldLoader = new Runnable ( ) { public void run ( ) { try { prevFields = transMeta . getPrevStepFields ( stepname ) ; } catch ( KettleException e ) { String msg = BaseMessages . getString ( PKG , " IfNullDialog . DoMapping . UnableToFindInput " ) ; logError ( msg ) ; } String [ ] prevStepFieldNames = prevFields . getFieldNames ( ) ; if ( prevStepFieldNames != null ) { Arrays . sort ( prevStepFieldNames ) ; for ( int i = 0 ; i < fieldColumns . size ( ) ; i ++ ) { ColumnInfo colInfo = fieldColumns . get ( i ) ; if ( colInfo != null ) { colInfo . setComboValues ( prevStepFieldNames ) ; } } } } } ; new Thread ( fieldLoader ) . start ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | public void getFirstData ( ) { wSelectFields . setSelection ( input . isSelectFields ( ) ) ; wSelectValuesType . setSelection ( input . isSelectValuesType ( ) ) ; }
Aliaksandr-Kastenka/pentaho-kettle | public void getData ( ) { if ( input . getReplaceAllByValue ( ) != null ) { wReplaceByValue . setText ( input . getReplaceAllByValue ( ) ) ; } if ( input . getReplaceAllMask ( ) != null ) { wMask . setText ( input . getReplaceAllMask ( ) ) ; } wSetEmptyStringAll . setSelection ( input . isSetEmptyStringAll ( ) ) ; wSelectFields . setSelection ( input . isSelectFields ( ) ) ; wSelectValuesType . setSelection ( input . isSelectValuesType ( ) ) ; Table table = wValueTypes . table ; if ( input . getTypeName ( ) . length > 0 ) { table . removeAll ( ) ; } for ( int i = 0 ; i < input . getTypeName ( ) . length ; i ++ ) { TableItem ti = new TableItem ( table , SWT . NONE ) ; ti . setText ( 0 , " " + ( i + 1 ) ) ; if ( input . getTypeName ( ) [ i ] != null ) { ti . setText ( 1 , input . getTypeName ( ) [ i ] ) ; } if ( input . getTypeReplaceValue ( ) [ i ] != null ) { ti . setText ( 2 , input . getTypeReplaceValue ( ) [ i ] ) ; } if ( input . getTypeReplaceMask ( ) [ i ] != null ) { ti . setText ( 3 , input . getTypeReplaceMask ( ) [ i ] ) ; } ti . setText ( 4 , input . isSetTypeEmptyString ( ) [ i ] ? BaseMessages . getString ( PKG , " System . Combo . Yes " ) : BaseMessages . getString ( PKG , " System . Combo . No " ) ) ; } wValueTypes . setRowNums ( ) ; wValueTypes . removeEmptyRows ( ) ; wValueTypes . optWidth ( true ) ; table = wFields . table ; if ( input . getFieldName ( ) . length > 0 ) { table . removeAll ( ) ; } for ( int i = 0 ; i < input . getFieldName ( ) . length ; i ++ ) { TableItem ti = new TableItem ( table , SWT . NONE ) ; ti . setText ( 0 , " " + ( i + 1 ) ) ; if ( input . getFieldName ( ) [ i ] != null ) { ti . setText ( 1 , input . getFieldName ( ) [ i ] ) ; } if ( input . getReplaceValue ( ) [ i ] != null ) { ti . setText ( 2 , input . getReplaceValue ( ) [ i ] ) ; } if ( input . getReplaceMask ( ) [ i ] != null ) { ti . setText ( 3 , input . getReplaceMask ( ) [ i ] ) ; } ti . setText ( 4 , input . isSetEmptyString ( ) [ i ] ? BaseMessages . getString ( PKG , " System . Combo . Yes " ) : BaseMessages . getString ( PKG , " System . Combo . No " ) ) ; } wFields . setRowNums ( ) ; wValueTypes . removeEmptyRows ( ) ; wFields . optWidth ( true ) ; wStepname . selectAll ( ) ; wStepname . setFocus ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void cancel ( ) { stepname = null ; input . setChanged ( changed ) ; dispose ( ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void enableSetEmptyStringAll ( ) { wMask . setText ( " " ) ; }
Aliaksandr-Kastenka/pentaho-kettle | private void ok ( ) { if ( Const . isEmpty ( wStepname . getText ( ) ) ) { return ; } stepname = wStepname . getText ( ) ; input . setEmptyStringAll ( wSetEmptyStringAll . getSelection ( ) ) ; if ( wSetEmptyStringAll . getSelection ( ) ) { input . setReplaceAllByValue ( " " ) ; input . setReplaceAllMask ( " " ) ; } else { input . setReplaceAllByValue ( wReplaceByValue . getText ( ) ) ; input . setReplaceAllMask ( wMask . getText ( ) ) ; } input . setSelectFields ( wSelectFields . getSelection ( ) ) ; input . setSelectValuesType ( wSelectValuesType . getSelection ( ) ) ; int nrtypes = wValueTypes . nrNonEmpty ( ) ; int nrfields = wFields . nrNonEmpty ( ) ; input . allocate ( nrtypes , nrfields ) ; for ( int i = 0 ; i < nrtypes ; i ++ ) { TableItem ti = wValueTypes . getNonEmpty ( i ) ; input . getTypeName ( ) [ i ] = ti . getText ( 1 ) ; input . isSetTypeEmptyString ( ) [ i ] = BaseMessages . getString ( PKG , " System . Combo . Yes " ) . equalsIgnoreCase ( ti . getText ( 4 ) ) ; if ( input . isSetTypeEmptyString ( ) [ i ] ) { input . getTypeReplaceValue ( ) [ i ] = " " ; input . getTypeReplaceMask ( ) [ i ] = " " ; } else { input . getTypeReplaceValue ( ) [ i ] = ti . getText ( 2 ) ; input . getTypeReplaceMask ( ) [ i ] = ti . getText ( 3 ) ; } } for ( int i = 0 ; i < nrfields ; i ++ ) { TableItem ti = wFields . getNonEmpty ( i ) ; input . getFieldName ( ) [ i ] = ti . getText ( 1 ) ; input . isSetEmptyString ( ) [ i ] = BaseMessages . getString ( PKG , " System . Combo . Yes " ) . equalsIgnoreCase ( ti . getText ( 4 ) ) ; if ( input . isSetEmptyString ( ) [ i ] ) { input . getReplaceValue ( ) [ i ] = " " ; input . getReplaceMask ( ) [ i ] = " " ; } else { input . getReplaceValue ( ) [ i ] = ti . getText ( 2 ) ; input . getReplaceMask ( ) [ i ] = ti . getText ( 3 ) ; } } dispose ( ) ; }
loafer/spring4-tutorials | public ResponseResult ( boolean success ) { this . success = success ; }
loafer/spring4-tutorials | public ResponseResult ( boolean success , String url , Object message ) { this . success = success ; this . url = url ; this . message = message ; }
loafer/spring4-tutorials | public boolean isSuccess ( ) { return success ; }
loafer/spring4-tutorials | public String getUrl ( ) { return url ; }
loafer/spring4-tutorials | public Object getMessage ( ) { return message ; }
llenterak/eulers | private int sumDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += factorials [ n % 10 ] ; n = n / 10 ; } return sum ; }
llenterak/eulers | private long getDigitFactorials ( int limit ) { long res = 0l ; for ( int i = 3 ; i < limit ; i ++ ) { if ( sumDigits ( i ) == i ) res += i ; } return res ; }
llenterak/eulers | @ Override public String getResult ( ) { return String . format ( " % d " , getDigitFactorials ( 1000000 ) ) ; }
user404d/CS6601-Project | public OrOperation ( ) { super ( NAME ) ; }
user404d/CS6601-Project | public Circuit create_circuit ( State [ ] operands ) throws Exception { if ( operands . length == 1 ) { return new OR_L_1 ( operands [ 0 ] . getWidth ( ) ) ; } else { return new OR_2L_L ( operands [ 0 ] . getWidth ( ) ) ; } }
user404d/CS6601-Project | public int circuit_id ( State [ ] operands ) { int id = operands [ 0 ] . getWidth ( ) ; if ( operands . length == 1 ) return - id ; else return id ; }
user404d/CS6601-Project | public State execute ( State [ ] inputs , Circuit or ) throws Exception { if ( inputs . length == 1 ) { return or . startExecuting ( inputs [ 0 ] ) ; } else { return binaryOperation ( or , inputs ) ; } }
user404d/CS6601-Project | public int validate ( Variable [ ] operands ) throws CircuitDescriptionException { if ( operands . length == 1 ) { int o = operands [ 0 ] . validate ( ) ; if ( o < 2 ) { throw createException ( " Unary ▁ or ▁ operation ▁ requires ▁ at ▁ least ▁ two ▁ bits " ) ; } return 1 ; } else { binaryOperation ( operands ) ; return operands [ 0 ] . validate ( ) ; } }
n4cer/estockkarte | public Result index ( ) { List < Colony > colonies = Colony . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . order ( ) . asc ( " id " ) . findList ( ) ; return ok ( index . render ( colonies ) ) ; }
n4cer/estockkarte | public Result add ( ) { List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; return ok ( add . render ( formFactory . form ( Colony . class ) , hives , QueenColor . getColors ( ) , races , stands ) ) ; }
n4cer/estockkarte | public Result create ( ) { Form < Colony > form = formFactory . form ( Colony . class ) . bindFromRequest ( ) ; List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; if ( form . hasErrors ( ) ) { return badRequest ( add . render ( form , hives , QueenColor . getColors ( ) , races , stands ) ) ; } Colony colony = form . get ( ) ; colony . user = Util . getUser ( ) ; colony . shortUrl = Util . rndUrl ( 10 ) ; colony . save ( ) ; return redirect ( routes . Colonies . index ( ) ) ; }
n4cer/estockkarte | public Result edit ( Long id ) { Colony colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; return ok ( edit . render ( colony , formFactory . form ( Colony . class ) . fill ( colony ) , hives , QueenColor . getColors ( ) , races , stands ) ) ; }
n4cer/estockkarte | public Result update ( Long id ) { Colony old_colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( old_colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } Form < Colony > form = formFactory . form ( Colony . class ) . bindFromRequest ( ) ; List < Hive > hives = Hive . find . all ( ) ; List < Race > races = Race . find . all ( ) ; List < Stand > stands = Stand . find . query ( ) . where ( ) . eq ( " user " , Util . getUser ( ) ) . findList ( ) ; if ( form . hasErrors ( ) ) { return badRequest ( edit . render ( old_colony , form , hives , QueenColor . getColors ( ) , races , stands ) ) ; } Colony colony = form . get ( ) ; colony . id = old_colony . id ; colony . user = Util . getUser ( ) ; colony . update ( ) ; return redirect ( routes . Colonies . index ( ) ) ; }
n4cer/estockkarte | public Result delete ( Long id ) { Colony colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } colony . delete ( ) ; return redirect ( routes . Colonies . index ( ) ) ; }
n4cer/estockkarte | public Result showQRCode ( String shortUrl ) { File qrcode = QRCode . from ( " https : // www . estockkarte . de / d / " + shortUrl ) . file ( ) ; return ok ( qrcode ) . as ( " image / png " ) ; }
n4cer/estockkarte | public Result inscription ( Long id ) { Colony colony = Colony . find . byId ( id ) ; User user = Util . getUser ( ) ; if ( ! user . equals ( colony . user ) ) { return badRequest ( " Zugriff ▁ nicht ▁ erlaubt ! " ) ; } return ok ( inscription . render ( colony ) ) ; }
MikePfaff/acs-aem-commons | @ Before public void setupSession ( ) { when ( workflowSession . getSession ( ) ) . thenReturn ( session ) ; when ( jcrFactory . getResourceResolver ( session ) ) . thenReturn ( resourceResolver ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_null_rendition_arg_is_noop ( ) throws Exception { WorkItem workItem = mock ( WorkItem . class ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; process . execute ( workItem , workflowSession , metaData ) ; verifyZeroInteractions ( harness ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_blank_rendition_arg_is_noop ( ) throws Exception { WorkItem workItem = mock ( WorkItem . class ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; metaData . put ( " PROCESS _ ARGS " , " " ) ; process . execute ( workItem , workflowSession , metaData ) ; verifyZeroInteractions ( harness ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_rendition_arg_getting_no_rendition_is_noop ( ) throws Exception { String path = " / content / dam / some / path . ext " ; WorkItem workItem = mock ( WorkItem . class ) ; WorkflowData data = mock ( WorkflowData . class ) ; when ( workItem . getWorkflowData ( ) ) . thenReturn ( data ) ; when ( data . getPayloadType ( ) ) . thenReturn ( AbstractAssetWorkflowProcess . TYPE_JCR_PATH ) ; when ( data . getPayload ( ) ) . thenReturn ( path ) ; Resource resource = mock ( Resource . class ) ; Asset asset = mock ( Asset . class ) ; when ( resource . adaptTo ( Asset . class ) ) . thenReturn ( asset ) ; when ( resource . getResourceType ( ) ) . thenReturn ( DamConstants . NT_DAM_ASSET ) ; when ( resourceResolver . getResource ( path ) ) . thenReturn ( resource ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; metaData . put ( " PROCESS _ ARGS " , " renditionName : test " ) ; process . execute ( workItem , workflowSession , metaData ) ; verifyZeroInteractions ( harness ) ; }
MikePfaff/acs-aem-commons | @ Test public void test_with_rendition_arg_getting_real_rendition ( ) throws Exception { String path = " / content / dam / some / path . ext " ; WorkItem workItem = mock ( WorkItem . class ) ; WorkflowData data = mock ( WorkflowData . class ) ; when ( workItem . getWorkflowData ( ) ) . thenReturn ( data ) ; when ( data . getPayloadType ( ) ) . thenReturn ( AbstractAssetWorkflowProcess . TYPE_JCR_PATH ) ; when ( data . getPayload ( ) ) . thenReturn ( path ) ; Resource resource = mock ( Resource . class ) ; Asset asset = mock ( Asset . class ) ; Rendition rendition = mock ( Rendition . class ) ; when ( resource . adaptTo ( Asset . class ) ) . thenReturn ( asset ) ; when ( resource . getResourceType ( ) ) . thenReturn ( DamConstants . NT_DAM_ASSET ) ; when ( resourceResolver . getResource ( path ) ) . thenReturn ( resource ) ; when ( asset . getRendition ( isA ( RenditionPicker . class ) ) ) . thenReturn ( rendition ) ; when ( rendition . getStream ( ) ) . then ( new Answer < InputStream > ( ) { @ Override public InputStream answer ( InvocationOnMock invocation ) throws Throwable { return getClass ( ) . getResourceAsStream ( " / img / test . png " ) ; } } ) ; when ( harness . processLayer ( any ( Layer . class ) , eq ( rendition ) , eq ( workflowSession ) , any ( String [ ] . class ) ) ) . thenAnswer ( new Answer < Layer > ( ) { @ Override public Layer answer ( InvocationOnMock invocation ) throws Throwable { return ( Layer ) invocation . getArguments ( ) [ 0 ] ; } } ) ; MetaDataMap metaData = new SimpleMetaDataMap ( ) ; metaData . put ( " PROCESS _ ARGS " , " renditionName : test " ) ; process . execute ( workItem , workflowSession , metaData ) ; verify ( harness , times ( 1 ) ) . processLayer ( any ( Layer . class ) , eq ( rendition ) , eq ( workflowSession ) , any ( String [ ] . class ) ) ; verify ( harness , times ( 1 ) ) . saveImage ( eq ( asset ) , eq ( rendition ) , any ( Layer . class ) , eq ( " image / png " ) , eq ( 0.6 ) ) ; }
branches-cc/camel-cookbook-examples | @ Override public RouteBuilder createRouteBuilder ( ) { return new AggregateCompletionTimeoutRouteBuilder ( ) ; }
branches-cc/camel-cookbook-examples | @ Test public void testAggregation ( ) throws InterruptedException { MockEndpoint mockOut = getMockEndpoint ( " mock : out " ) ; mockOut . setExpectedMessageCount ( 2 ) ; template . sendBodyAndHeader ( " direct : in " , " One " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Two " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Three " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Four " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Five " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Six " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Seven " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Eight " , " group " , " even " ) ; template . sendBodyAndHeader ( " direct : in " , " Nine " , " group " , " odd " ) ; template . sendBodyAndHeader ( " direct : in " , " Ten " , " group " , " even " ) ; assertMockEndpointsSatisfied ( ) ; List < Exchange > receivedExchanges = mockOut . getReceivedExchanges ( ) ; Set < String > odd = receivedExchanges . get ( 0 ) . getIn ( ) . getBody ( Set . class ) ; assertTrue ( odd . containsAll ( Arrays . asList ( " One " , " Three " , " Five " , " Seven " , " Nine " ) ) ) ; Set < String > even = receivedExchanges . get ( 1 ) . getIn ( ) . getBody ( Set . class ) ; assertTrue ( even . containsAll ( Arrays . asList ( " Two " , " Four " , " Six " , " Eight " , " Ten " ) ) ) ; }
OpenNTF/Nagios4DominoIntegration | if ( isAccessAllowed ( req . getRemoteAddr ( ) , NotesIniFactory . getNagiosCaller ( ) ) ) { strResult = ActionRegistry . getInstance ( ) . getServletAction ( strAction ) . buildResponse ( req . getParameterMap ( ) , sesServer ) ; }
OpenNTF/Nagios4DominoIntegration | catch ( Exception e ) { ErrorPageBuilder . getInstance ( ) . processError ( resp , e . getMessage ( ) , e ) ; }
OpenNTF/Nagios4DominoIntegration | if ( sesServer != null ) { sesServer . recycle ( ) ; }
OpenNTF/Nagios4DominoIntegration | catch ( Exception e ) { e . printStackTrace ( ) ; }
OpenNTF/Nagios4DominoIntegration | private boolean isAccessAllowed ( String strCallerIP , String strNotesINIIP ) { try { InetAddress inCurrent = InetAddress . getByName ( strCallerIP ) ; if ( inCurrent . isAnyLocalAddress ( ) || inCurrent . isLoopbackAddress ( ) ) { return true ; } if ( NetworkInterface . getByInetAddress ( inCurrent ) != null ) { return true ; } if ( strNotesINIIP != null && ! " " . equals ( strNotesINIIP ) ) { List < String > lstAddr = Arrays . asList ( strNotesINIIP . split ( " ; " ) ) ; for ( String strAdrCheck : lstAddr ) { if ( strAdrCheck . equals ( strCallerIP ) ) { return true ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; }
FHannes/intellij-community | public KeyAwareInspectionViewAction ( String name ) { super ( name ) ; }
FHannes/intellij-community | @ Override protected boolean isEnabled ( @ NotNull InspectionResultsView view , AnActionEvent e ) { final InspectionToolWrapper wrapper = view . getTree ( ) . getSelectedToolWrapper ( true ) ; return wrapper != null && HighlightDisplayKey . find ( wrapper . getShortName ( ) ) != null ; }
FHannes/intellij-community | @ Override public void actionPerformed ( AnActionEvent e ) { final InspectionResultsView view = getView ( e ) ; final HighlightDisplayKey key = HighlightDisplayKey . find ( view . getTree ( ) . getSelectedToolWrapper ( true ) . getShortName ( ) ) ; actionPerformed ( view , key ) ; }
FHannes/intellij-community | public DisableInspection ( ) { super ( DisableInspectionToolAction . NAME ) ; }
FHannes/intellij-community | @ Override protected boolean isEnabled ( @ NotNull InspectionResultsView view , AnActionEvent e ) { final boolean enabled = super . isEnabled ( view , e ) ; if ( ! enabled ) return false ; final HighlightDisplayKey key = HighlightDisplayKey . find ( view . getTree ( ) . getSelectedToolWrapper ( true ) . getShortName ( ) ) ; final InspectionProfile profile = InspectionProjectProfileManager . getInstance ( view . getProject ( ) ) . getCurrentProfile ( ) ; return profile . isToolEnabled ( key ) ; }
FHannes/intellij-community | @ Override protected void actionPerformed ( @ NotNull InspectionResultsView view , @ NotNull HighlightDisplayKey key ) { if ( view . isSingleInspectionRun ( ) ) { view . getCurrentProfile ( ) . modifyProfile ( it -> it . setToolEnabled ( key . toString ( ) , false ) ) ; view . updateCurrentProfile ( ) ; } else { final RefEntity [ ] selectedElements = view . getTree ( ) . getSelectedElements ( ) ; final Set < PsiElement > files = new HashSet < > ( ) ; for ( RefEntity selectedElement : selectedElements ) { if ( selectedElement instanceof RefElement ) { files . add ( ( ( RefElement ) selectedElement ) . getElement ( ) ) ; } } InspectionProfileModifiableModelKt . modifyAndCommitProjectProfile ( view . getProject ( ) , it -> { for ( PsiElement element : files ) { it . disableTool ( key . toString ( ) , element ) ; } } ) ; } }
FHannes/intellij-community | public RunInspectionOn ( ) { super ( InspectionsBundle . message ( " run . inspection . on . file . intention . text " ) ) ; }
FHannes/intellij-community | @ Override protected boolean isEnabled ( @ NotNull InspectionResultsView view , AnActionEvent e ) { return super . isEnabled ( view , e ) && getPsiElement ( view ) != null ; }
FHannes/intellij-community | @ Override protected void actionPerformed ( @ NotNull InspectionResultsView view , @ NotNull HighlightDisplayKey key ) { Set < PsiFile > files = new THashSet < > ( ) ; for ( RefEntity entity : view . getTree ( ) . getSelectedElements ( ) ) { if ( entity instanceof RefElement && entity . isValid ( ) ) { final PsiElement element = ( ( RefElement ) entity ) . getElement ( ) ; final PsiFile file = element . getContainingFile ( ) ; files . add ( file ) ; } } boolean useModule = true ; Module module = null ; for ( PsiFile file : files ) { final Module currentFileModule = ModuleUtilCore . findModuleForPsiElement ( file ) ; if ( currentFileModule != null ) { if ( module == null ) { module = currentFileModule ; } else if ( currentFileModule != module ) { useModule = false ; break ; } } else { useModule = false ; break ; } } final PsiElement context ; final AnalysisScope scope ; switch ( files . size ( ) ) { case 0 : context = null ; scope = view . getScope ( ) ; break ; case 1 : final PsiFile theFile = ContainerUtil . getFirstItem ( files ) ; LOG . assertTrue ( theFile != null ) ; context = theFile ; scope = new AnalysisScope ( theFile ) ; break ; default : context = null ; scope = new AnalysisScope ( view . getProject ( ) , files . stream ( ) . map ( PsiFile :: getVirtualFile ) . collect ( Collectors . toList ( ) ) ) ; } RunInspectionIntention . selectScopeAndRunInspection ( key . toString ( ) , scope , useModule ? module : null , context , view . getProject ( ) ) ; }
fvasquezjatar/fermat-unused | public AssetIssuerIdentityDatabaseFactory ( PluginDatabaseSystem pluginDatabaseSystem ) { this . pluginDatabaseSystem = pluginDatabaseSystem ; }
fvasquezjatar/fermat-unused | public Database createDatabase ( UUID pluginId ) throws CantCreateDatabaseException { Database database ; try { database = this . pluginDatabaseSystem . createDatabase ( pluginId , AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_DB_NAME ) ; DatabaseTableFactory table ; DatabaseFactory databaseFactory = database . getDatabaseFactory ( ) ; table = databaseFactory . newTableFactory ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_TABLE_NAME ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_PUBLIC_KEY_COLUMN_NAME , DatabaseDataType . STRING , 130 , true ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_PRIVATE_KEY_COLUMN_NAME , DatabaseDataType . STRING , 130 , false ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_ALIAS_COLUMN_NAME , DatabaseDataType . STRING , 36 , false ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_STATUS_COLUMN_NAME , DatabaseDataType . STRING , 130 , false ) ; table . addColumn ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_DEVICE_USER_PUBLIC_KEY_COLUMN_NAME , DatabaseDataType . STRING , 130 , false ) ; table . addIndex ( AssetIssuerIdentityDatabaseConstants . ASSET_ISSUER_IDENTITY_FIRST_KEY_COLUMN ) ; databaseFactory . createTable ( table ) ; } catch ( CantCreateDatabaseException cantCreateDatabaseException ) { String message = CantCreateDatabaseException . DEFAULT_MESSAGE ; FermatException cause = cantCreateDatabaseException . getCause ( ) ; String context = " Asset ▁ Issuer ▁ Identity ▁ DataBase _ Factory : ▁ " + cantCreateDatabaseException . getContext ( ) ; String possibleReason = " The ▁ exception ▁ is ▁ thrown ▁ the ▁ Create ▁ Database ▁ Asset ▁ Issuer ▁ Identity ▁ ' this . platformDatabaseSystem . createDatabase ( \" AssetIssuerIdentity \" ) ' " + cantCreateDatabaseException . getPossibleReason ( ) ; throw new CantCreateDatabaseException ( message , cause , context , possibleReason ) ; } catch ( CantCreateTableException cantCreateTableException ) { String message = CantCreateTableException . DEFAULT_MESSAGE ; FermatException cause = cantCreateTableException . getCause ( ) ; String context = " Create ▁ Table ▁ Asset ▁ Issuer ▁ Identity " + cantCreateTableException . getContext ( ) ; String possibleReason = " The ▁ exception ▁ is ▁ generated ▁ when ▁ creating ▁ the ▁ table ▁ Asset ▁ Issuer ▁ Identity ▁ - ▁ DatabaseFactory . createTable ( table ) ▁ " + cantCreateTableException . getPossibleReason ( ) ; throw new CantCreateDatabaseException ( message , cause , context , possibleReason ) ; } catch ( Exception exception ) { throw new CantCreateDatabaseException ( CantCreateDatabaseException . DEFAULT_MESSAGE , FermatException . wrapException ( exception ) , null , null ) ; } return database ; }
fvasquezjatar/fermat-unused | @ Override public void setPluginDatabaseSystem ( PluginDatabaseSystem pluginDatabaseSystem ) { this . pluginDatabaseSystem = pluginDatabaseSystem ; }
fvasquezjatar/fermat-unused | @ Override public void setErrorManager ( ErrorManager errorManager ) { this . errorManager = errorManager ; }
0359xiaodong/blink | public Group ( ) { }
0359xiaodong/blink | public Group ( Long id ) { this . id = id ; }
0359xiaodong/blink | public Group ( String name , Integer state , Long id , String attributableType ) { this . name = name ; this . state = state ; this . id = id ; this . attributableType = attributableType ; }
0359xiaodong/blink | public void __setDaoSession ( DaoSession daoSession ) { this . daoSession = daoSession ; myDao = daoSession != null ? daoSession . getGroupDao ( ) : null ; }
0359xiaodong/blink | public String getName ( ) { return name ; }
0359xiaodong/blink | public void setName ( String name ) { this . name = name ; }
0359xiaodong/blink | public Integer getState ( ) { return state ; }
0359xiaodong/blink | public void setState ( Integer state ) { this . state = state ; }
0359xiaodong/blink | public Long getId ( ) { return id ; }
0359xiaodong/blink | public void setId ( Long id ) { this . id = id ; }
0359xiaodong/blink | public String getAttributableType ( ) { return attributableType ; }
0359xiaodong/blink | public void setAttributableType ( String attributableType ) { this . attributableType = attributableType ; }
0359xiaodong/blink | public List < GroupDevice > getGroupDeviceList ( ) { if ( groupDeviceList == null ) { if ( daoSession == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } GroupDeviceDao targetDao = daoSession . getGroupDeviceDao ( ) ; List < GroupDevice > groupDeviceListNew = targetDao . _queryGroup_GroupDeviceList ( id ) ; synchronized ( this ) { if ( groupDeviceList == null ) { groupDeviceList = groupDeviceListNew ; } } } return groupDeviceList ; }
0359xiaodong/blink | public synchronized void resetGroupDeviceList ( ) { groupDeviceList = null ; }
0359xiaodong/blink | public List < Attribute > getAttributes ( ) { if ( attributes == null ) { if ( daoSession == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } AttributeDao targetDao = daoSession . getAttributeDao ( ) ; List < Attribute > attributesNew = targetDao . _queryGroup_Attributes ( id , attributableType ) ; synchronized ( this ) { if ( attributes == null ) { attributes = attributesNew ; } } } return attributes ; }
0359xiaodong/blink | public synchronized void resetAttributes ( ) { attributes = null ; }
0359xiaodong/blink | public void delete ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } myDao . delete ( this ) ; }
0359xiaodong/blink | public void update ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } myDao . update ( this ) ; }
0359xiaodong/blink | public void refresh ( ) { if ( myDao == null ) { throw new DaoException ( " Entity ▁ is ▁ detached ▁ from ▁ DAO ▁ context " ) ; } myDao . refresh ( this ) ; }
0359xiaodong/blink | public void flushAttributes ( ) { AttributeDao attributeDao = BlinkApp . getDaoSession ( ) . getAttributeDao ( ) ; for ( Attribute attribute : getAttributes ( ) ) { attribute . setAttributableId ( id ) ; attribute . setAttributableType ( ATTRIBUTABLE_TYPE ) ; attributeDao . insertOrIgnore ( attribute ) ; } }
0359xiaodong/blink | public void flushGroupDevices ( ) { GroupDeviceDao groupDeviceDao = BlinkApp . getDaoSession ( ) . getGroupDeviceDao ( ) ; List < GroupDevice > groupDevices = groupDeviceDao . queryBuilder ( ) . where ( GroupDeviceDao . Properties . GroupId . eq ( getId ( ) ) ) . list ( ) ; Set < Long > deviceSet = new HashSet < > ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { deviceSet . add ( groupDevice . getDeviceId ( ) ) ; } Log . d ( TAG , " flushGroupDevices : ▁ " + groupDevices . size ( ) ) ; Log . d ( TAG , " flushGroupDevices : ▁ " + getGroupDeviceList ( ) . size ( ) ) ; for ( GroupDevice groupDevice : groupDevices ) { if ( ! deviceSet . remove ( groupDevice . getDeviceId ( ) ) ) { Log . d ( TAG , " delete : ▁ " + groupDevice . getDeviceId ( ) ) ; groupDevice . delete ( ) ; } } for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { if ( deviceSet . contains ( groupDevice . getDeviceId ( ) ) ) { Log . d ( TAG , " adding : ▁ " + groupDevice . getDeviceId ( ) ) ; groupDeviceDao . insertOrReplace ( groupDevice ) ; } } }
0359xiaodong/blink | public void deleteWithReferences ( ) { BlinkApp . getDaoSession ( ) . runInTx ( new Runnable ( ) { @ Override public void run ( ) { for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { groupDevice . delete ( ) ; } for ( Attribute attribute : getAttributes ( ) ) { attribute . delete ( ) ; } delete ( ) ; } } ) ; Event . broadcast ( Group . KEY ) ; }
0359xiaodong/blink | public List < Device > getDevices ( ) { List < Device > devices = new ArrayList < > ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { devices . add ( groupDevice . getDevice ( ) ) ; } return devices ; }
0359xiaodong/blink | public void setLevel ( final int level ) { BlinkApp . getDaoSession ( ) . runInTx ( new Runnable ( ) { @ Override public void run ( ) { Attribute attribute = getAttributes ( ) . get ( 1 ) ; String newValue = String . valueOf ( level ) ; attribute . setValueLocal ( newValue ) ; attribute . update ( ) ; state = BlinkApp . STATE_UPDATED ; update ( ) ; Long attributeTypeId = attribute . getAttributeTypeId ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { groupDevice . getDevice ( ) . setAttribute ( attributeTypeId , newValue ) ; } } } ) ; }
0359xiaodong/blink | public void setOn ( final boolean on ) { BlinkApp . getDaoSession ( ) . runInTx ( new Runnable ( ) { @ Override public void run ( ) { Attribute attribute = getAttributes ( ) . get ( 0 ) ; String newValue = on ? Attribute . ON : Attribute . OFF ; attribute . setValueLocal ( newValue ) ; attribute . update ( ) ; state = BlinkApp . STATE_UPDATED ; update ( ) ; Long attributeTypeId = attribute . getAttributeTypeId ( ) ; for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { groupDevice . getDevice ( ) . setAttribute ( attributeTypeId , newValue ) ; } } } ) ; }
0359xiaodong/blink | public boolean isOn ( ) { if ( getAttributes ( ) . size ( ) < 1 ) { return false ; } return getAttributes ( ) . get ( 0 ) . getBool ( ) ; }
0359xiaodong/blink | public int getLevel ( ) { if ( getAttributes ( ) . size ( ) < 2 ) { return 0 ; } return getAttributes ( ) . get ( 1 ) . getInt ( ) ; }
0359xiaodong/blink | public String toNfc ( ) { List < NfcCommand > commands = new ArrayList < > ( ) ; List < NfcCommand . Update > updates = new ArrayList < > ( ) ; NfcCommand command = new NfcCommand ( ) ; command . g = getId ( ) ; command . u = updates ; commands . add ( command ) ; for ( Attribute attribute : getAttributes ( ) ) { NfcCommand . Update update = new NfcCommand . Update ( ) ; update . i = attribute . getAttributeTypeId ( ) ; update . v = attribute . getValue ( ) ; updates . add ( update ) ; } return BlinkApi . getGson ( ) . toJson ( commands ) ; }
0359xiaodong/blink | public void setNominal ( ) { switch ( state ) { case BlinkApp . STATE_UPDATED : for ( Attribute attribute : getAttributes ( ) ) { attribute . onSync ( ) ; } state = BlinkApp . STATE_NOMINAL ; update ( ) ; break ; case BlinkApp . STATE_REMOVED : deleteWithReferences ( ) ; break ; case BlinkApp . STATE_ADDED : state = BlinkApp . STATE_NOMINAL ; update ( ) ; break ; case BlinkApp . STATE_NAME_SET : state = BlinkApp . STATE_NOMINAL ; update ( ) ; break ; } }
0359xiaodong/blink | public void onEdit ( final String newName , final long [ ] ids ) { Log . d ( TAG , " onEdit : ▁ " + newName + " ▁ " + ids . length ) ; daoSession . runInTx ( new Runnable ( ) { @ Override public void run ( ) { if ( ! getName ( ) . equals ( newName ) ) { setName ( newName ) ; setState ( BlinkApp . STATE_NAME_SET ) ; update ( ) ; } setDeviceIds ( ids ) ; Syncro . getInstance ( ) . syncDevices ( ) ; } } ) ; }
0359xiaodong/blink | private void setDeviceIds ( long [ ] deviceIds ) { Set < Long > deviceSet = new HashSet < > ( ) ; for ( long deviceId : deviceIds ) { deviceSet . add ( deviceId ) ; } for ( GroupDevice groupDevice : getGroupDeviceList ( ) ) { if ( ! deviceSet . remove ( groupDevice . getDeviceId ( ) ) ) { groupDevice . setState ( BlinkApp . STATE_REMOVED ) ; groupDevice . update ( ) ; } } for ( Long deviceId : deviceSet ) { addDevice ( deviceId ) ; } resetGroupDeviceList ( ) ; Event . broadcast ( Group . KEY ) ; }
0359xiaodong/blink | private void addDevice ( long deviceId ) { GroupDevice groupDevice = new GroupDevice ( ) ; groupDevice . setDeviceId ( deviceId ) ; groupDevice . setGroupId ( getId ( ) ) ; groupDevice . setState ( BlinkApp . STATE_ADDED ) ; daoSession . getGroupDeviceDao ( ) . insertOrReplace ( groupDevice ) ; }
VaybhavSharma/commons | @ Test public void testEmptyMergedHistogram ( ) { ApproximateHistogram empty [ ] = new ApproximateHistogram [ 0 ] ; Histogram mergedHistogram = ApproximateHistogram . merge ( empty ) ; assertEquals ( 0L , mergedHistogram . getQuantile ( 0.5 ) ) ; }
VaybhavSharma/commons | @ Test public void testMergedSimilarHistogram ( ) { int n = 10 ; ApproximateHistogram histograms [ ] = new ApproximateHistogram [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ApproximateHistogram h = new ApproximateHistogram ( ) ; h . add ( i ) ; histograms [ i ] = h ; } Histogram mergedHistogram = ApproximateHistogram . merge ( histograms ) ; assertEquals ( 0L , mergedHistogram . getQuantile ( 0.0 ) ) ; assertEquals ( 1L , mergedHistogram . getQuantile ( 0.1 ) ) ; assertEquals ( 5L , mergedHistogram . getQuantile ( 0.5 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.9 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.99 ) ) ; }
VaybhavSharma/commons | @ Test public void testMergedDifferentHistogram ( ) { int n = 10 ; ApproximateHistogram histograms [ ] = new ApproximateHistogram [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ApproximateHistogram h = new ApproximateHistogram ( Amount . of ( 2L + 4 * i , Data . KB ) ) ; h . add ( i ) ; histograms [ i ] = h ; } Histogram mergedHistogram = ApproximateHistogram . merge ( histograms ) ; assertEquals ( 0L , mergedHistogram . getQuantile ( 0.0 ) ) ; assertEquals ( 1L , mergedHistogram . getQuantile ( 0.1 ) ) ; assertEquals ( 5L , mergedHistogram . getQuantile ( 0.5 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.9 ) ) ; assertEquals ( 9L , mergedHistogram . getQuantile ( 0.99 ) ) ; }
VaybhavSharma/commons | @ Test public void testMergedBigHistogram ( ) { int n = 10 ; int m = 5000 ; ApproximateHistogram histograms [ ] = new ApproximateHistogram [ n ] ; int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ApproximateHistogram h = new ApproximateHistogram ( ) ; while ( x < m * ( i + 1 ) ) { h . add ( x ) ; x += 1 ; } histograms [ i ] = h ; } long sum = m * n ; double maxError = ApproximateHistogram . DEFAULT_PRECISION . getEpsilon ( ) * ApproximateHistogram . DEFAULT_PRECISION . getN ( ) ; Histogram mergedHistogram = ApproximateHistogram . merge ( histograms ) ; for ( int i = 1 ; i < 10 ; i ++ ) { double q = i / 10.0 ; double expected = q * sum ; assertEquals ( expected , mergedHistogram . getQuantile ( q ) , maxError ) ; } }
vvakame/JsonPullParser | OnJsonObjectAddListener listener = new OnJsonObjectAddListener ( ) { @ Override public void onAdd ( Object obj ) { if ( obj instanceof Tweet ) { s += " t " ; } else if ( obj instanceof User ) { s += " u " ; } else if ( obj instanceof Place ) { s += " p " ; } else if ( obj instanceof NestParentData ) { s += " Np " ; } else if ( obj instanceof NestDepth1Data ) { s += " N1" ; } else if ( obj instanceof NestDepth2Data ) { s += " N2" ; } else { s += " o " ; } } }
vvakame/JsonPullParser | i ++ ) { expected += " uot " ; }
vvakame/JsonPullParser | InputStream getStream ( String str ) { return new ByteArrayInputStream ( str . getBytes ( ) ) ; }
vvakame/JsonPullParser | @ Before public void setup ( ) { s = " " ; }
bunjlabs/jed2d | protected Vector4b ( Vector4b v ) { this . x1 = v . x1 ; this . x2 = v . x2 ; this . x3 = v . x3 ; this . x4 = v . x4 ; }
bunjlabs/jed2d | protected Vector4b ( boolean v ) { this . x1 = v ; this . x2 = v ; this . x3 = v ; this . x4 = v ; }
bunjlabs/jed2d | protected Vector4b ( boolean x1 , boolean x2 , boolean x3 , boolean x4 ) { this . x1 = x1 ; this . x2 = x2 ; this . x3 = x3 ; this . x4 = x4 ; }
bunjlabs/jed2d | protected Vector4b ( ) { this . x1 = this . x2 = this . x3 = this . x4 = false ; }
bunjlabs/jed2d | public Vector4i toInteger ( ) { return new Vector4i ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | public Vector4l toLong ( ) { return new Vector4l ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | public Vector4f toFloat ( ) { return new Vector4f ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | public Vector4d toDouble ( ) { return new Vector4d ( x1 ? 1 : 0 , x2 ? 1 : 0 , x3 ? 1 : 0 , x4 ? 1 : 0 ) ; }
bunjlabs/jed2d | @ Override public String toString ( ) { return " Vector4b { " + " x1 = " + x1 + " , ▁ x2 = " + x2 + " , ▁ x3 = " + x3 + " , ▁ x4 = " + x4 + ' } ' ; }
bunjlabs/jed2d | @ Override public int hashCode ( ) { int hash = 5 ; hash = 47 * hash + ( this . x1 ? 1 : 0 ) ; hash = 47 * hash + ( this . x2 ? 1 : 0 ) ; hash = 47 * hash + ( this . x3 ? 1 : 0 ) ; hash = 47 * hash + ( this . x4 ? 1 : 0 ) ; return hash ; }
bunjlabs/jed2d | @ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Vector4b other = ( Vector4b ) obj ; if ( this . x1 != other . x1 ) { return false ; } if ( this . x2 != other . x2 ) { return false ; } if ( this . x3 != other . x3 ) { return false ; } if ( this . x4 != other . x4 ) { return false ; } return true ; }
LCA311/leoapp-sources | public ResultDialog ( @ NonNull Context context , int id , String to ) { super ( context ) ; this . id = id ; this . to = to ; }
LCA311/leoapp-sources | @ Override public void onCreate ( Bundle b ) { super . onCreate ( b ) ; setContentView ( R . layout . dialog_survey_result ) ; b1 = findViewById ( R . id . buttonOK ) ; t1 = findViewById ( R . id . question ) ; t2 = findViewById ( R . id . votes ) ; load = findViewById ( R . id . progressBarLoading ) ; ProgressBar p1 = findViewById ( R . id . progressBar1 ) ; ProgressBar p2 = findViewById ( R . id . progressBar2 ) ; ProgressBar p3 = findViewById ( R . id . progressBar3 ) ; ProgressBar p4 = findViewById ( R . id . progressBar4 ) ; ProgressBar p5 = findViewById ( R . id . progressBar5 ) ; progressBars = new ProgressBar [ ] { p1 , p2 , p3 , p4 , p5 } ; TextView op1 = findViewById ( R . id . answer1 ) ; TextView op2 = findViewById ( R . id . answer2 ) ; TextView op3 = findViewById ( R . id . answer3 ) ; TextView op4 = findViewById ( R . id . answer4 ) ; TextView op5 = findViewById ( R . id . answer5 ) ; answers = new TextView [ ] { op1 , op2 , op3 , op4 , op5 } ; TextView pe1 = findViewById ( R . id . percent1 ) ; TextView pe2 = findViewById ( R . id . percent2 ) ; TextView pe3 = findViewById ( R . id . percent3 ) ; TextView pe4 = findViewById ( R . id . percent4 ) ; TextView pe5 = findViewById ( R . id . percent5 ) ; percentages = new TextView [ ] { pe1 , pe2 , pe3 , pe4 , pe5 } ; for ( TextView cur : answers ) cur . setVisibility ( View . GONE ) ; for ( ProgressBar cur : progressBars ) cur . setVisibility ( View . GONE ) ; t1 . setVisibility ( View . INVISIBLE ) ; t2 . setVisibility ( View . INVISIBLE ) ; b1 . setOnClickListener ( v -> { dismiss ( ) ; stopLoading ( ) ; } ) ; asyncTask = new SyncResultTask ( ) ; asyncTask . addListener ( this ) . execute ( id , to ) ; }
LCA311/leoapp-sources | private void animateChanges ( int amount , HashMap < String , Integer > answerMap , int target , int votes ) { Map . Entry < String , Integer > [ ] entries = answerMap . entrySet ( ) . toArray ( new Map . Entry [ 0 ] ) ; for ( int i = 0 ; i < amount ; i ++ ) { answers [ i ] . setText ( entries [ i ] . getKey ( ) ) ; answers [ i ] . setVisibility ( View . VISIBLE ) ; progressBars [ i ] . setVisibility ( View . VISIBLE ) ; if ( votes == 0 ) continue ; ObjectAnimator animation = ObjectAnimator . ofInt ( progressBars [ i ] , " progress " , entries [ i ] . getValue ( ) * 100 / votes ) ; animation . setDuration ( 1250 ) ; animation . setInterpolator ( new DecelerateInterpolator ( ) ) ; animation . start ( ) ; percentages [ i ] . setText ( String . valueOf ( entries [ i ] . getValue ( ) ) ) ; } RelativeLayout . LayoutParams params = ( RelativeLayout . LayoutParams ) b1 . getLayoutParams ( ) ; params . addRule ( RelativeLayout . BELOW , answers [ amount - 1 ] . getId ( ) ) ; b1 . setLayoutParams ( params ) ; for ( int i = amount ; i < answers . length ; i ++ ) { answers [ i ] . setVisibility ( GONE ) ; } double percentage = ( double ) votes * 100d / ( double ) target ; DecimalFormat df = new DecimalFormat ( " # # # #0.00" ) ; t2 . setText ( Utils . getContext ( ) . getString ( R . string . statistics_result , votes , target , df . format ( percentage ) ) ) ; }
LCA311/leoapp-sources | private void stopLoading ( ) { asyncTask . cancel ( true ) ; }
LCA311/leoapp-sources | @ Override @ SuppressWarnings ( " unchecked " ) public void taskFinished ( Object ... params ) { ResponseCode responseCode = ( ResponseCode ) params [ 0 ] ; int amountAnswers = ( int ) params [ 1 ] ; LinkedHashMap < String , Integer > answerResults = ( LinkedHashMap < String , Integer > ) params [ 2 ] ; int target = ( int ) params [ 3 ] ; int sumVotes = ( int ) params [ 4 ] ; String title = ( String ) params [ 5 ] ; load . setVisibility ( View . GONE ) ; switch ( responseCode ) { case NO_CONNECTION : findViewById ( R . id . imageViewError ) . setVisibility ( View . VISIBLE ) ; final Snackbar snack = Snackbar . make ( findViewById ( R . id . snackbar ) , Utils . getString ( R . string . snackbar_no_connection_info ) , Snackbar . LENGTH_LONG ) ; snack . setActionTextColor ( ContextCompat . getColor ( getContext ( ) , R . color . colorPrimary ) ) ; snack . setAction ( getContext ( ) . getString ( R . string . confirm ) , v -> snack . dismiss ( ) ) ; snack . show ( ) ; break ; case NOT_SENT : case SERVER_FAILED : findViewById ( R . id . imageViewError ) . setVisibility ( View . VISIBLE ) ; final Snackbar snackbar = Snackbar . make ( findViewById ( R . id . snackbar ) , Utils . getString ( R . string . error_later ) , Snackbar . LENGTH_SHORT ) ; snackbar . setActionTextColor ( ContextCompat . getColor ( getContext ( ) , R . color . colorPrimary ) ) ; snackbar . setAction ( getContext ( ) . getString ( R . string . confirm ) , v -> snackbar . dismiss ( ) ) ; snackbar . show ( ) ; break ; case SUCCESS : t1 . setText ( title ) ; t1 . setVisibility ( View . VISIBLE ) ; t2 . setVisibility ( View . VISIBLE ) ; animateChanges ( amountAnswers , answerResults , target , sumVotes ) ; break ; } }
cezarykluczynski/stapi | public AstronomicalObject ( AstronomicalObjectPortType astronomicalObjectPortType , ApiKeySupplier apiKeySupplier ) { this . astronomicalObjectPortType = astronomicalObjectPortType ; this . apiKeySupplier = apiKeySupplier ; }
cezarykluczynski/stapi | public AstronomicalObjectFullResponse get ( AstronomicalObjectFullRequest request ) { apiKeySupplier . supply ( request ) ; return astronomicalObjectPortType . getAstronomicalObjectFull ( request ) ; }
cezarykluczynski/stapi | public AstronomicalObjectBaseResponse search ( AstronomicalObjectBaseRequest request ) { apiKeySupplier . supply ( request ) ; return astronomicalObjectPortType . getAstronomicalObjectBase ( request ) ; }
rodhilton/rallydroid | public Activity ( JSONObject object ) { super ( object ) ; }
rodhilton/rallydroid | public String getText ( ) { return getString ( " Text " ) ; }
rodhilton/rallydroid | public String getUserName ( ) { return getString ( " UserName " ) ; }
rodhilton/rallydroid | public String getArtifact ( ) { return getString ( " Artifact " ) ; }
rodhilton/rallydroid | public String toString ( ) { StringBuffer ret = new StringBuffer ( getCreationDate ( ) ) ; ret . append ( " ▁ : ▁ " + getUserName ( ) ) ; ret . append ( " ▁ : ▁ " + getArtifact ( ) ) ; ret . append ( " ▁ ( " + getText ( ) + " ) " ) ; return ret . toString ( ) ; }
rodhilton/rallydroid | public String getCreationDate ( ) { return getString ( " CreationDate " ) ; }
mzubairahmed/externalapi | public ProductColorJsonModel ( ) { }
mzubairahmed/externalapi | public ProductColorJsonModel ( String code , String description , String displayName , List < CodeValueGroupJsonModel > codeValueGroups ) { this . code = code ; this . description = description ; this . displayName = displayName ; this . codeValueGroups = codeValueGroups ; }
mzubairahmed/externalapi | public String getCode ( ) { return code ; }
mzubairahmed/externalapi | public void setCode ( String code ) { this . code = code ; }
mzubairahmed/externalapi | public String getDescription ( ) { return description ; }
mzubairahmed/externalapi | public void setDescription ( String description ) { this . description = description ; }
mzubairahmed/externalapi | public String getDisplayName ( ) { return displayName ; }
mzubairahmed/externalapi | public void setDisplayName ( String displayName ) { this . displayName = displayName ; }
mzubairahmed/externalapi | public List < CodeValueGroupJsonModel > getCodeValueGroups ( ) { return codeValueGroups ; }
mzubairahmed/externalapi | public void setCodeValueGroups ( List < CodeValueGroupJsonModel > codeValueGroups ) { this . codeValueGroups = codeValueGroups ; }
mzubairahmed/externalapi | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( code == null ) ? 0 : code . hashCode ( ) ) ; result = prime * result + ( ( codeValueGroups == null ) ? 0 : codeValueGroups . hashCode ( ) ) ; result = prime * result + ( ( description == null ) ? 0 : description . hashCode ( ) ) ; result = prime * result + ( ( displayName == null ) ? 0 : displayName . hashCode ( ) ) ; return result ; }
mzubairahmed/externalapi | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ProductColorJsonModel other = ( ProductColorJsonModel ) obj ; if ( code == null ) { if ( other . code != null ) return false ; } else if ( ! code . equals ( other . code ) ) return false ; if ( codeValueGroups == null ) { if ( other . codeValueGroups != null ) return false ; } else if ( ! codeValueGroups . equals ( other . codeValueGroups ) ) return false ; if ( description == null ) { if ( other . description != null ) return false ; } else if ( ! description . equals ( other . description ) ) return false ; if ( displayName == null ) { if ( other . displayName != null ) return false ; } else if ( ! displayName . equals ( other . displayName ) ) return false ; return true ; }
mzubairahmed/externalapi | @ Override public String toString ( ) { return " ProductColorJsonModel ▁ [ code = " + code + " , ▁ description = " + description + " , ▁ displayName = " + displayName + " , ▁ codeValueGroups = " + codeValueGroups + " ] " ; }
jk1/intellij-community | public RemoveBuildFileAction ( AntExplorer antExplorer ) { super ( AntBundle . message ( " remove . build . file . action . name " ) ) ; myAntExplorer = antExplorer ; }
jk1/intellij-community | public void actionPerformed ( AnActionEvent e ) { myAntExplorer . removeSelectedBuildFiles ( ) ; }
JMedinilla/Netbour | @ OnItemClick ( R . id . fragListMeeting_list ) public void itemClick ( View view , int position ) { TextView txv = ( TextView ) view . findViewById ( R . id . adapterMeeting_txtDescription ) ; PoMeeting meeting = adpMeeting . getItem ( position ) ; if ( txv != null && meeting != null ) { String txt = txv . getText ( ) . toString ( ) ; if ( txv . getMaxLines ( ) == 2 ) { openText ( txv , txt ) ; } else { closeText ( txv ) ; } } }
JMedinilla/Netbour | @ Override public void onAttach ( Context context ) { super . onAttach ( context ) ; callbackBack = ( FrgBack ) context ; callSnack = ( FrgLists ) context ; callback = ( ListMeeting ) context ; }
JMedinilla/Netbour | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setRetainInstance ( true ) ; setHasOptionsMenu ( true ) ; loadingDialogCreate ( ) ; Bundle bundle = getArguments ( ) ; if ( bundle != null ) { userEmail = bundle . getString ( " userEmail " ) ; String code = bundle . getString ( " comcode " ) ; userCategory = bundle . getInt ( " userCategory " ) ; ArrayList < String > arrayList = bundle . getStringArrayList ( " adminEmails " ) ; List < PoMeeting > list = new ArrayList < > ( ) ; adpMeeting = new AdpMeeting ( getActivity ( ) , list , this , this ) ; presenterMeeting = new PresenterMeetingImpl ( null , this ) ; presenterMeeting . instanceFirebase ( code ) ; if ( arrayList != null ) { to = arrayList . toArray ( new String [ arrayList . size ( ) ] ) ; } } }
JMedinilla/Netbour | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . fragment_list_meeting , container , false ) ; ButterKnife . bind ( this , view ) ; return view ; }
JMedinilla/Netbour | @ Override public void onViewCreated ( View view , @ Nullable Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; meetingList . setAdapter ( adpMeeting ) ; meetingList . setDivider ( null ) ; }
JMedinilla/Netbour | @ Override public void onStart ( ) { super . onStart ( ) ; loadingDialogShow ( ) ; if ( callbackBack != null ) { callbackBack . backFromForm ( ) ; } if ( presenterMeeting != null ) { presenterMeeting . attachFirebase ( ) ; } }
JMedinilla/Netbour | @ Override public void onStop ( ) { super . onStop ( ) ; if ( presenterMeeting != null ) { presenterMeeting . dettachFirebase ( ) ; } loadingDialogHide ( ) ; }
JMedinilla/Netbour | @ Override public void onDetach ( ) { super . onDetach ( ) ; callback = null ; callSnack = null ; callbackBack = null ; }
JMedinilla/Netbour | @ Override public void deleteElement ( PoMeeting meeting , int position ) { if ( meeting != null ) { if ( userEmail . equals ( meeting . getAuthorEmail ( ) ) || userCategory == PoUser . GROUP_ADMIN ) { showDeleteDialog ( meeting , position ) ; } else { if ( callSnack != null ) { callSnack . sendSnack ( getString ( R . string . no_permission ) ) ; } } } }
JMedinilla/Netbour | @ Override public void deletedMeeting ( PoMeeting item ) { callback . deletedMeeting ( item ) ; }
JMedinilla/Netbour | @ Override public void editElement ( PoMeeting meeting ) { if ( meeting != null ) { if ( userEmail . equals ( meeting . getAuthorEmail ( ) ) || userCategory == PoUser . GROUP_ADMIN ) { if ( callback != null ) { callback . sendMeeting ( meeting ) ; } } else { if ( callSnack != null ) { callSnack . sendSnack ( getString ( R . string . no_permission ) ) ; } } } }
JMedinilla/Netbour | @ Override public void reportElement ( ) { sendEmail ( ) ; }
JMedinilla/Netbour | @ Override public void returnList ( List < PoMeeting > list ) { meetingList . setVisibility ( View . VISIBLE ) ; meetingEmpty . setVisibility ( View . GONE ) ; loadingDialogHide ( ) ; updateList ( list ) ; }
JMedinilla/Netbour | @ Override public void returnListEmpty ( ) { meetingList . setVisibility ( View . GONE ) ; meetingEmpty . setVisibility ( View . VISIBLE ) ; List < PoMeeting > list = new ArrayList < > ( ) ; loadingDialogHide ( ) ; updateList ( list ) ; }
JMedinilla/Netbour | private void closeText ( TextView txv ) { txv . setMaxLines ( 2 ) ; txv . setEllipsize ( TextUtils . TruncateAt . END ) ; }
JMedinilla/Netbour | private void deleteResponse ( int position ) { if ( presenterMeeting != null ) { presenterMeeting . deleteMeeting ( adpMeeting . getItem ( position ) ) ; } }
JMedinilla/Netbour | private void loadingDialogCreate ( ) { AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; LayoutInflater inflater = getActivity ( ) . getLayoutInflater ( ) ; View view = inflater . inflate ( R . layout . loading_dialog , null ) ; builder . setView ( view ) ; builder . setCancelable ( false ) ; loading = builder . create ( ) ; loading . setCancelable ( false ) ; loading . setCanceledOnTouchOutside ( false ) ; if ( loading . getWindow ( ) != null ) { loading . getWindow ( ) . setBackgroundDrawable ( new ColorDrawable ( Color . TRANSPARENT ) ) ; } }
JMedinilla/Netbour | public void loadingDialogHide ( ) { if ( loading != null ) { loading . dismiss ( ) ; } }
JMedinilla/Netbour | public void loadingDialogShow ( ) { if ( loading != null ) { loading . show ( ) ; } }
JMedinilla/Netbour | private void openText ( TextView txv , String txt ) { txv . setMaxLines ( Integer . MAX_VALUE ) ; txv . setEllipsize ( null ) ; txv . setText ( txt ) ; }
JMedinilla/Netbour | private void sendEmail ( ) { if ( to != null ) { if ( to . length > 0 ) { EmailIntentBuilder . from ( getActivity ( ) ) . to ( Arrays . asList ( to ) ) . subject ( getActivity ( ) . getString ( R . string . report_meeting ) ) . start ( ) ; } else { Toast . makeText ( getActivity ( ) , R . string . no_email_admin , Toast . LENGTH_SHORT ) . show ( ) ; } } else { Toast . makeText ( getActivity ( ) , R . string . no_email_admin , Toast . LENGTH_SHORT ) . show ( ) ; } }
JMedinilla/Netbour | private void showDeleteDialog ( PoMeeting meeting , final int position ) { AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; builder . setTitle ( R . string . dialog_title_delete ) ; builder . setMessage ( getString ( R . string . dialog_message_delete ) + " ▁ " + meeting . getDate ( ) + getString ( R . string . dialog_message_delete_two ) ) ; builder . setPositiveButton ( android . R . string . yes , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { deleteResponse ( position ) ; } } ) ; builder . setNegativeButton ( android . R . string . no , null ) ; AlertDialog dialog = builder . create ( ) ; dialog . show ( ) ; }
JMedinilla/Netbour | private void updateList ( List < PoMeeting > list ) { adpMeeting . clear ( ) ; adpMeeting . addAll ( list ) ; }
TonyTangAndroid/storio | PreparedGetMandatoryResult ( @ NonNull StorIOSQLite storIOSQLite , @ NonNull Query query ) { super ( storIOSQLite , query ) ; }
TonyTangAndroid/storio | PreparedGetMandatoryResult ( @ NonNull StorIOSQLite storIOSQLite , @ NonNull RawQuery rawQuery ) { super ( storIOSQLite , rawQuery ) ; }
TonyTangAndroid/storio | @ WorkerThread @ NonNull public final Result executeAsBlocking ( ) { return super . executeAsBlocking ( ) ; }
data-integrations/pivot | public AggregateResult ( Schema inputSchema , Map < String , AggregateFunction > functions ) { this . inputSchema = inputSchema ; this . functions = functions ; missingColumnsModel = new HashMap < > ( ) ; }
data-integrations/pivot | public Schema getInputSchema ( ) { return inputSchema ; }
data-integrations/pivot | public Map < String , AggregateFunction > getFunctions ( ) { return functions ; }
data-integrations/pivot | public HashMap < String , Set < Object > > getMissingColumnsModel ( ) { return missingColumnsModel ; }
data-integrations/pivot | public void mergeMissingColumnDataModels ( AggregateResult otherResult ) { missingColumnsModel . putAll ( otherResult . getMissingColumnsModel ( ) ) ; }
Thanu/stratos | public StratosManagerTopologyEventReceiver ( ) { }
GunoH/intellij-community | @ Override protected boolean isEnabled ( @ NotNull XDebugSession session , DataContext dataContext ) { Promise < String > textPromise = getTextToEvaluate ( dataContext , session ) ; if ( textPromise . getState ( ) == Promise . State . PENDING ) { return true ; } else if ( textPromise . getState ( ) == Promise . State . REJECTED ) { return false ; } try { return textPromise . blockingGet ( 0 ) != null ; } catch ( TimeoutException | ExecutionException e ) { return false ; } }
GunoH/intellij-community | @ Override protected void perform ( @ NotNull XDebugSession session , DataContext dataContext ) { getTextToEvaluate ( dataContext , session ) . onSuccess ( text -> { if ( text == null ) return ; UIUtil . invokeLaterIfNeeded ( ( ) -> { XDebugSessionTab tab = ( ( XDebugSessionImpl ) session ) . getSessionTab ( ) ; if ( tab != null ) { ( ( XWatchesViewImpl ) tab . getWatchesView ( ) ) . addWatchExpression ( XExpressionImpl . fromText ( text ) , - 1 , true , true ) ; } } ) ; } ) ; }
DavideD/hibernate-validator | public PropertyDescriptorImpl ( Type returnType , String propertyName , Set < ConstraintDescriptorImpl < ? > > constraints , boolean cascaded , boolean defaultGroupSequenceRedefined , List < Class < ? > > defaultGroupSequence , Set < GroupConversionDescriptor > groupConversions ) { super ( returnType , constraints , defaultGroupSequenceRedefined , defaultGroupSequence ) ; this . property = propertyName ; this . cascaded = cascaded ; this . groupConversions = Collections . unmodifiableSet ( groupConversions ) ; }
DavideD/hibernate-validator | @ Override public boolean isCascaded ( ) { return cascaded ; }
DavideD/hibernate-validator | @ Override public Set < GroupConversionDescriptor > getGroupConversions ( ) { return groupConversions ; }
DavideD/hibernate-validator | @ Override public String getPropertyName ( ) { return property ; }
DavideD/hibernate-validator | @ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " PropertyDescriptorImpl " ) ; sb . append ( " { property = " ) . append ( property ) ; sb . append ( " , ▁ cascaded = ' " ) . append ( cascaded ) . append ( ' \' ' ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; }
sawano/java-commons | public ValidationException ( ) { }
sawano/java-commons | public ValidationException ( final String message ) { super ( message ) ; }
sawano/java-commons | public ValidationException ( final String message , final Throwable cause ) { super ( message , cause ) ; }
sawano/java-commons | public ValidationException ( final Throwable cause ) { super ( cause ) ; }
numixproject/com.numix.calculator | public TinyDB ( Context appContext ) { preferences = PreferenceManager . getDefaultSharedPreferences ( appContext ) ; }
numixproject/com.numix.calculator | public Bitmap getImage ( String path ) { Bitmap bitmapFromPath = null ; try { bitmapFromPath = BitmapFactory . decodeFile ( path ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return bitmapFromPath ; }
numixproject/com.numix.calculator | public String getSavedImagePath ( ) { return lastImagePath ; }
numixproject/com.numix.calculator | public boolean putImage ( String theFolder , String theImageName , Bitmap theBitmap ) { if ( theFolder == null || theImageName == null || theBitmap == null ) return false ; this . DEFAULT_APP_IMAGEDATA_DIRECTORY = theFolder ; String mFullPath = setupFullPath ( theImageName ) ; if ( ! mFullPath . equals ( " " ) ) { lastImagePath = mFullPath ; return saveBitmap ( mFullPath , theBitmap ) ; } return false ; }
numixproject/com.numix.calculator | public boolean putImageWithFullPath ( String fullPath , Bitmap theBitmap ) { return ! ( fullPath == null || theBitmap == null ) && saveBitmap ( fullPath , theBitmap ) ; }
numixproject/com.numix.calculator | private String setupFullPath ( String imageName ) { File mFolder = new File ( Environment . getExternalStorageDirectory ( ) , DEFAULT_APP_IMAGEDATA_DIRECTORY ) ; if ( isExternalStorageReadable ( ) && isExternalStorageWritable ( ) && ! mFolder . exists ( ) ) { if ( ! mFolder . mkdirs ( ) ) { Log . e ( " ERROR " , " Failed ▁ to ▁ setup ▁ folder " ) ; return " " ; } } return mFolder . getPath ( ) + ' / ' + imageName ; }
numixproject/com.numix.calculator | private boolean saveBitmap ( String fullPath , Bitmap bitmap ) { if ( fullPath == null || bitmap == null ) return false ; boolean fileCreated = false ; boolean bitmapCompressed = false ; boolean streamClosed = false ; File imageFile = new File ( fullPath ) ; if ( imageFile . exists ( ) ) if ( ! imageFile . delete ( ) ) return false ; try { fileCreated = imageFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } FileOutputStream out = null ; try { out = new FileOutputStream ( imageFile ) ; bitmapCompressed = bitmap . compress ( CompressFormat . PNG , 100 , out ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; bitmapCompressed = false ; } finally { if ( out != null ) { try { out . flush ( ) ; out . close ( ) ; streamClosed = true ; } catch ( IOException e ) { e . printStackTrace ( ) ; streamClosed = false ; } } } return ( fileCreated && bitmapCompressed && streamClosed ) ; }
numixproject/com.numix.calculator | public int getInt ( String key , int defaultValue ) { return preferences . getInt ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public ArrayList < Integer > getListInt ( String key ) { String [ ] myList = TextUtils . split ( preferences . getString ( key , " " ) , " ‚ ‗ ‚ " ) ; ArrayList < String > arrayToList = new ArrayList < String > ( Arrays . asList ( myList ) ) ; ArrayList < Integer > newList = new ArrayList < Integer > ( ) ; for ( String item : arrayToList ) newList . add ( Integer . parseInt ( item ) ) ; return newList ; }
numixproject/com.numix.calculator | public long getLong ( String key , long defaultValue ) { return preferences . getLong ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public float getFloat ( String key , float defaultValue ) { return preferences . getFloat ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public double getDouble ( String key , double defaultValue ) { String number = getString ( key ) ; try { return Double . parseDouble ( number ) ; } catch ( NumberFormatException e ) { return defaultValue ; } }
numixproject/com.numix.calculator | public ArrayList < Double > getListDouble ( String key ) { String [ ] myList = TextUtils . split ( preferences . getString ( key , " " ) , " â € šâ € — â € š " ) ; ArrayList < String > arrayToList = new ArrayList < String > ( Arrays . asList ( myList ) ) ; ArrayList < Double > newList = new ArrayList < Double > ( ) ; for ( String item : arrayToList ) newList . add ( Double . parseDouble ( item ) ) ; return newList ; }
numixproject/com.numix.calculator | public String getString ( String key ) { return preferences . getString ( key , " " ) ; }
numixproject/com.numix.calculator | public ArrayList < String > getListString ( String key ) { return new ArrayList < String > ( Arrays . asList ( TextUtils . split ( preferences . getString ( key , " " ) , " ‚ ‗ ‚ " ) ) ) ; }
numixproject/com.numix.calculator | public boolean getBoolean ( String key , boolean defaultValue ) { return preferences . getBoolean ( key , defaultValue ) ; }
numixproject/com.numix.calculator | public ArrayList < Boolean > getListBoolean ( String key ) { ArrayList < String > myList = getListString ( key ) ; ArrayList < Boolean > newList = new ArrayList < Boolean > ( ) ; for ( String item : myList ) { if ( item . equals ( " true " ) ) { newList . add ( true ) ; } else { newList . add ( false ) ; } } return newList ; }
numixproject/com.numix.calculator | public void putInt ( String key , int value ) { preferences . edit ( ) . putInt ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putListInt ( String key , ArrayList < Integer > intList ) { Integer [ ] myIntList = intList . toArray ( new Integer [ intList . size ( ) ] ) ; preferences . edit ( ) . putString ( key , TextUtils . join ( " ‚ ‗ ‚ " , myIntList ) ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putLong ( String key , long value ) { preferences . edit ( ) . putLong ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putFloat ( String key , float value ) { preferences . edit ( ) . putFloat ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putDouble ( String key , double value ) { putString ( key , String . valueOf ( value ) ) ; }
numixproject/com.numix.calculator | public void putListDouble ( String key , ArrayList < Double > doubleList ) { Double [ ] myDoubleList = doubleList . toArray ( new Double [ doubleList . size ( ) ] ) ; preferences . edit ( ) . putString ( key , TextUtils . join ( " â € šâ € — â € š " , myDoubleList ) ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putString ( String key , String value ) { preferences . edit ( ) . putString ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putListString ( String key , ArrayList < String > stringList ) { String [ ] myStringList = stringList . toArray ( new String [ stringList . size ( ) ] ) ; preferences . edit ( ) . putString ( key , TextUtils . join ( " ‚ ‗ ‚ " , myStringList ) ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putBoolean ( String key , boolean value ) { preferences . edit ( ) . putBoolean ( key , value ) . apply ( ) ; }
numixproject/com.numix.calculator | public void putListBoolean ( String key , ArrayList < Boolean > boolList ) { ArrayList < String > newList = new ArrayList < String > ( ) ; for ( Boolean item : boolList ) { if ( item ) { newList . add ( " true " ) ; } else { newList . add ( " false " ) ; } } putListString ( key , newList ) ; }
numixproject/com.numix.calculator | public void remove ( String key ) { preferences . edit ( ) . remove ( key ) . apply ( ) ; }
numixproject/com.numix.calculator | public boolean deleteImage ( String path ) { return new File ( path ) . delete ( ) ; }
numixproject/com.numix.calculator | public void clear ( ) { preferences . edit ( ) . clear ( ) . apply ( ) ; }
numixproject/com.numix.calculator | public Map < String , ? > getAll ( ) { return preferences . getAll ( ) ; }
numixproject/com.numix.calculator | public void registerOnSharedPreferenceChangeListener ( SharedPreferences . OnSharedPreferenceChangeListener listener ) { preferences . registerOnSharedPreferenceChangeListener ( listener ) ; }
numixproject/com.numix.calculator | public void unregisterOnSharedPreferenceChangeListener ( SharedPreferences . OnSharedPreferenceChangeListener listener ) { preferences . unregisterOnSharedPreferenceChangeListener ( listener ) ; }
Khushmeet/LeaveApp-VIT | public Default_Detail_View_Fragment ( ) { }
Khushmeet/LeaveApp-VIT | @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View rootView = inflater . inflate ( R . layout . default_detail_view , container , false ) ; return rootView ; }
nkolban/jpigpio | MyListener ( int userGpio , int edge ) { super ( userGpio , edge ) ; }
nkolban/jpigpio | @ Override public void alert ( int gpio , int level , long tick ) { this . count ++ ; System . out . println ( " MyListener ▁ # " + count + " ▁ GPIO = " + gpio ) ; }
nkolban/jpigpio | public void run ( ) { String host = " pigpiod - host " ; int gpio1 = 23 ; int gpio2 = 24 ; int gpio3 = 25 ; long startTime = System . currentTimeMillis ( ) ; try { JPigpio pigpio = new PigpioSocket ( host , 8888 ) ; pigpio . gpioInitialize ( ) ; pigpio . addCallback ( new MyListener ( gpio1 , JPigpio . PI_RISING_EDGE ) ) ; System . out . println ( " Listening ▁ for ▁ changes ▁ on ▁ GPIO ▁ " + gpio1 ) ; pigpio . addCallback ( new MyListener ( gpio2 , JPigpio . PI_FALLING_EDGE ) ) ; System . out . println ( " Listening ▁ for ▁ changes ▁ on ▁ GPIO ▁ " + gpio2 ) ; pigpio . gpioSetAlertFunc ( gpio3 , ( int gpio , int level , long tick ) -> { System . out . println ( " ALERT ▁ Received : ▁ ▁ gpio = " + gpio + " ▁ ▁ level = " + Integer . toBinaryString ( level ) + " ▁ ▁ tick = " + tick ) ; } ) ; System . out . println ( " Waiting ▁ 20s ▁ for ▁ incoming ▁ notifications " ) ; while ( System . currentTimeMillis ( ) - startTime < 20000 ) { Thread . sleep ( 100 ) ; } System . out . println ( " Finished . " ) ; pigpio . gpioTerminate ( ) ; } catch ( PigpioException | InterruptedException e ) { e . printStackTrace ( ) ; } }
ChallenHB/droolsjbpm-tools | public BPMNWorkItemNodeFigure ( ) { setSize ( 80 , 48 ) ; }
ChallenHB/droolsjbpm-tools | protected void customizeFigure ( ) { rectangle = new RoundedRectangle ( ) ; rectangle . setCornerDimensions ( new Dimension ( 25 , 25 ) ) ; add ( rectangle , 0 ) ; rectangle . setBounds ( getBounds ( ) ) ; setSelected ( false ) ; }
ChallenHB/droolsjbpm-tools | public void setBounds ( Rectangle rectangle ) { super . setBounds ( rectangle ) ; this . rectangle . setBounds ( rectangle ) ; }
ChallenHB/droolsjbpm-tools | public void setSelected ( boolean b ) { super . setSelected ( b ) ; rectangle . setLineWidth ( b ? 3 : 1 ) ; repaint ( ) ; }
o3project/openflowj-otn | private OFInstructionIdGotoTableVer14 ( ) { }
o3project/openflowj-otn | @ Override public OFInstructionType getType ( ) { return OFInstructionType . GOTO_TABLE ; }
o3project/openflowj-otn | @ Override public OFVersion getVersion ( ) { return OFVersion . OF_14 ; }
o3project/openflowj-otn | public OFInstructionIdGotoTable . Builder createBuilder ( ) { throw new UnsupportedOperationException ( " OFInstructionIdGotoTableVer14 ▁ has ▁ no ▁ mutable ▁ properties ▁ - - ▁ builder ▁ unneeded " ) ; }
o3project/openflowj-otn | @ Override public OFInstructionIdGotoTable readFrom ( ChannelBuffer bb ) throws OFParseError { int start = bb . readerIndex ( ) ; short type = bb . readShort ( ) ; if ( type != ( short ) 0x1 ) throw new OFParseError ( " Wrong ▁ type : ▁ Expected = OFInstructionType . GOTO _ TABLE ( 1 ) , ▁ got = " + type ) ; int length = U16 . f ( bb . readShort ( ) ) ; if ( length != 4 ) throw new OFParseError ( " Wrong ▁ length : ▁ Expected = 4(4 ) , ▁ got = " + length ) ; if ( bb . readableBytes ( ) + ( bb . readerIndex ( ) - start ) < length ) { bb . readerIndex ( start ) ; return null ; } if ( logger . isTraceEnabled ( ) ) logger . trace ( " readFrom ▁ - ▁ length = { } " , length ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( " readFrom ▁ - ▁ returning ▁ shared ▁ instance = { } " , INSTANCE ) ; return INSTANCE ; }
o3project/openflowj-otn | public void putTo ( PrimitiveSink sink ) { FUNNEL . funnel ( this , sink ) ; }
o3project/openflowj-otn | @ Override public void funnel ( OFInstructionIdGotoTableVer14 message , PrimitiveSink sink ) { sink . putShort ( ( short ) 0x1 ) ; sink . putShort ( ( short ) 0x4 ) ; }
o3project/openflowj-otn | public void writeTo ( ChannelBuffer bb ) { WRITER . write ( bb , this ) ; }
o3project/openflowj-otn | @ Override public void write ( ChannelBuffer bb , OFInstructionIdGotoTableVer14 message ) { bb . writeShort ( ( short ) 0x1 ) ; bb . writeShort ( ( short ) 0x4 ) ; }
o3project/openflowj-otn | @ Override public String toString ( ) { StringBuilder b = new StringBuilder ( " OFInstructionIdGotoTableVer14 ( " ) ; b . append ( " ) " ) ; return b . toString ( ) ; }
o3project/openflowj-otn | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; return true ; }
o3project/openflowj-otn | @ Override public int hashCode ( ) { int result = 1 ; return result ; }
detnavillus/modular-informatic-designs | public void setGeoFormat ( String geoFormat ) { this . geoFormat = geoFormat ; }
detnavillus/modular-informatic-designs | public void setLatitudeProperty ( String latitudeProperty ) { this . latitudeProperty = latitudeProperty ; }
detnavillus/modular-informatic-designs | public void setLongitudeProperty ( String longitudeProperty ) { this . longitudeProperty = longitudeProperty ; }
detnavillus/modular-informatic-designs | public void setGeoLocationProperty ( String geoLocationProperty ) { this . geoLocationProperty = geoLocationProperty ; }
detnavillus/modular-informatic-designs | @ Override public IProperty transform ( IProperty input ) throws PropertyTransformException { LOG . info ( " transform ▁ ▁ val : ▁ " + input . getValue ( ) + " ▁ class : ▁ " + input . getClass ( ) . getName ( ) ) ; try { if ( input instanceof DataObject ) { if ( latitudeProperty == null || longitudeProperty == null || geoLocationProperty == null ) { throw new PropertyTransformException ( " Cannot ▁ transform ▁ DataObject ▁ - ▁ need ▁ lat , lon ▁ and ▁ geoloc ▁ properties ▁ defined ! " ) ; } DataObject dobj = ( DataObject ) input ; IProperty latProp = dobj . getProperty ( latitudeProperty ) ; IProperty lonProp = dobj . getProperty ( longitudeProperty ) ; if ( latProp instanceof IQuantity && lonProp instanceof IQuantity ) { GeographicLocation geoLoc = new GeographicLocation ( ( IQuantity ) latProp , ( IQuantity ) lonProp ) ; geoLoc . setName ( geoLocationProperty ) ; dobj . setProperty ( geoLoc ) ; } else { throw new PropertyTransformException ( " latitude ▁ and ▁ longitude ▁ must ▁ be ▁ quantities ! " ) ; } } else { GeographicLocation geoProp = new GeographicLocation ( ) ; geoProp . setValue ( input . getValue ( ) , geoFormat ) ; geoProp . setName ( input . getName ( ) ) ; return geoProp ; } } catch ( PropertyValidationException pve ) { throw new PropertyTransformException ( pve . getMessage ( ) ) ; } return input ; }
detnavillus/modular-informatic-designs | @ Override public IPropertyHolder transformPropertyHolder ( IPropertyHolder input ) throws PropertyTransformException { if ( latitudeProperty != null && longitudeProperty != null ) { IProperty latProp = input . getProperty ( latitudeProperty ) ; IProperty lonProp = input . getProperty ( longitudeProperty ) ; if ( latProp instanceof IQuantity && lonProp instanceof IQuantity ) { GeographicLocation geoLoc = new GeographicLocation ( ( IQuantity ) latProp , ( IQuantity ) lonProp ) ; geoLoc . setName ( geoLocationProperty ) ; input . setProperty ( geoLoc ) ; } else { throw new PropertyTransformException ( " latitude ▁ and ▁ longitude ▁ must ▁ be ▁ quantities ! " ) ; } } return input ; }
detnavillus/modular-informatic-designs | @ Override public void startTransform ( IProperty input , IPropertyTransformListener transformListener ) throws PropertyTransformException { }
hsaputra/cdap | public DefaultDataWriter ( WorkerContext context , DatasetContext dsContext ) { this . context = context ; this . dsContext = dsContext ; }
hsaputra/cdap | @ Override public < T extends Dataset > T getDataset ( final String name ) throws DatasetInstantiationException { try { return LogContext . runWithoutLogging ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { return dsContext . getDataset ( name ) ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , DatasetInstantiationException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public < T extends Dataset > T getDataset ( final String name , final Map < String , String > arguments ) throws DatasetInstantiationException { try { return LogContext . runWithoutLogging ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { return dsContext . getDataset ( name , arguments ) ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , DatasetInstantiationException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final String data ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final String data , final Map < String , String > headers ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data , headers ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final ByteBuffer data ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void write ( final String stream , final StreamEventData data ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . write ( stream , data ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public void writeFile ( final String stream , final File file , final String contentType ) throws IOException { try { LogContext . runWithoutLogging ( new Callable < Void > ( ) { @ Override public Void call ( ) throws Exception { context . writeFile ( stream , file , contentType ) ; return null ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
hsaputra/cdap | @ Override public StreamBatchWriter createBatchWriter ( final String stream , final String contentType ) throws IOException { try { return LogContext . runWithoutLogging ( new Callable < StreamBatchWriter > ( ) { @ Override public StreamBatchWriter call ( ) throws Exception { return context . createBatchWriter ( stream , contentType ) ; } } ) ; } catch ( Exception e ) { Throwables . propagateIfInstanceOf ( e , IOException . class ) ; throw Throwables . propagate ( e ) ; } }
rajeevanv89/developer-studio | public EnrichMediatorOutputConnectorItemSemanticEditPolicy ( ) { super ( EsbElementTypes . EnrichMediatorOutputConnector_3037 ) ; }
rajeevanv89/developer-studio | protected Command getDestroyElementCommand ( DestroyElementRequest req ) { View view = ( View ) getHost ( ) . getModel ( ) ; CompositeTransactionalCommand cmd = new CompositeTransactionalCommand ( getEditingDomain ( ) , null ) ; cmd . setTransactionNestingEnabled ( false ) ; for ( Iterator < ? > it = view . getSourceEdges ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Edge outgoingLink = ( Edge ) it . next ( ) ; if ( EsbVisualIDRegistry . getVisualID ( outgoingLink ) == EsbLinkEditPart . VISUAL_ID ) { DestroyElementRequest r = new DestroyElementRequest ( outgoingLink . getElement ( ) , false ) ; cmd . add ( new DestroyElementCommand ( r ) ) ; cmd . add ( new DeleteCommand ( getEditingDomain ( ) , outgoingLink ) ) ; continue ; } } EAnnotation annotation = view . getEAnnotation ( " Shortcut " ) ; if ( annotation == null ) { addDestroyShortcutsCommand ( cmd , view ) ; cmd . add ( new DestroyElementCommand ( req ) ) ; } else { cmd . add ( new DeleteCommand ( getEditingDomain ( ) , view ) ) ; } return getGEFWrapper ( cmd . reduce ( ) ) ; }
rajeevanv89/developer-studio | protected Command getCreateRelationshipCommand ( CreateRelationshipRequest req ) { Command command = req . getTarget ( ) == null ? getStartCreateRelationshipCommand ( req ) : getCompleteCreateRelationshipCommand ( req ) ; return command != null ? command : super . getCreateRelationshipCommand ( req ) ; }
rajeevanv89/developer-studio | protected Command getStartCreateRelationshipCommand ( CreateRelationshipRequest req ) { if ( EsbElementTypes . EsbLink_4001 == req . getElementType ( ) ) { return getGEFWrapper ( new EsbLinkCreateCommand ( req , req . getSource ( ) , req . getTarget ( ) ) ) ; } return null ; }
rajeevanv89/developer-studio | protected Command getCompleteCreateRelationshipCommand ( CreateRelationshipRequest req ) { if ( EsbElementTypes . EsbLink_4001 == req . getElementType ( ) ) { return null ; } return null ; }
rajeevanv89/developer-studio | protected Command getReorientRelationshipCommand ( ReorientRelationshipRequest req ) { switch ( getVisualID ( req ) ) { case EsbLinkEditPart . VISUAL_ID : return getGEFWrapper ( new EsbLinkReorientCommand ( req ) ) ; } return super . getReorientRelationshipCommand ( req ) ; }
gems-uff/oceano | public void setup ( ) { mapAttributeIndices = new HashMap < String , Integer > ( ) ; int indice = 1 ; attributeNames = new String [ QMOOD . QMOOD_QUALITY_ATTRIBUTES . length + 1 ] ; for ( String qaName : QMOOD . QMOOD_QUALITY_ATTRIBUTES ) { attributeNames [ indice ] = qaName ; mapAttributeIndices . put ( qaName , indice ++ ) ; } }
gems-uff/oceano | private void updateAttributeIndiceMap ( DataMiningResult currentDataMiningResult ) { mapAttributeIndices = new HashMap < String , Integer > ( ) ; int indice = 1 ; List < String > attributes = getAttributes ( currentDataMiningResult ) ; Collections . sort ( attributes ) ; for ( String attributeName : attributes ) { mapAttributeIndices . put ( attributeName , indice ++ ) ; } attributeNames = new String [ mapAttributeIndices . keySet ( ) . size ( ) + 1 ] ; for ( String attributeName : mapAttributeIndices . keySet ( ) ) { MetricManager mm = ( MetricManager ) MetricManagerFactory . getInstance ( ) . getMetricByName ( attributeName ) ; System . out . println ( " mapAttributeIndices . get ( attributeName ) ▁ = ▁ " + mapAttributeIndices . get ( attributeName ) ) ; System . out . println ( " mm . getMetric ( ) . getAcronym ( ) ▁ = ▁ " + mm . getMetric ( ) . getAcronym ( ) ) ; attributeNames [ mapAttributeIndices . get ( attributeName ) ] = mm . getMetric ( ) . getAcronym ( ) ; } TABLE_SIZE = attributeNames . length ; }
gems-uff/oceano | public synchronized Behavior [ ] [ ] buildTable ( DataMiningResult currentDataMiningResult ) { updateAttributeIndiceMap ( currentDataMiningResult ) ; Behavior [ ] [ ] behaviorTable = createDefaultTable ( currentDataMiningResult ) ; final String ruleMetricName = currentDataMiningResult . getRuleMetricName ( ) ; for ( DataMiningPattern dataMiningPattern : currentDataMiningResult . getDataMiningPatterns ( ) ) { if ( dataMiningPattern . getSize ( ) != 2 ) { continue ; } final String pattern = dataMiningPattern . getPattern ( ) ; if ( pattern . contains ( " project - revision " ) || pattern . contains ( " rdate " ) || pattern . contains ( " rcommiter " ) || pattern . contains ( " # files " ) || pattern . contains ( " rday " ) || pattern . contains ( " rhour " ) || pattern . contains ( " rcompile " ) ) { continue ; } final String precedentAttribute = DataMiningPattern . getAttribute ( dataMiningPattern . getPrecedent ( ) ) ; final String consequentAttribute = DataMiningPattern . getAttribute ( dataMiningPattern . getConsequent ( ) ) ; final Integer precedentIndice = mapAttributeIndices . get ( precedentAttribute ) ; final Integer consequentIndice = mapAttributeIndices . get ( consequentAttribute ) ; if ( precedentIndice == null || consequentIndice == null ) { continue ; } final Behavior behavior = behaviorTable [ precedentIndice ] [ consequentIndice ] ; behavior . getRules ( ) . add ( dataMiningPattern ) ; behavior . setValue ( verifyBehaviors ( behavior . getRules ( ) ) ) ; final Double highestValue = behavior . getHighestConfidence ( ) ; final Double actualValue = getRuleMetric ( ruleMetricName , dataMiningPattern ) ; if ( highestValue == null || actualValue > highestValue ) { behavior . setHighestConfidence ( actualValue ) ; } } return behaviorTable ; }
gems-uff/oceano | private Behavior [ ] [ ] createDefaultTable ( DataMiningResult dataMiningResult ) { Behavior [ ] [ ] behaviorTable = new Behavior [ TABLE_SIZE ] [ TABLE_SIZE ] ; for ( int i = 0 ; i < behaviorTable . length ; i ++ ) { for ( int j = 0 ; j < behaviorTable [ i ] . length ; j ++ ) { if ( j == 0 && i == 0 ) { behaviorTable [ i ] [ j ] = new Behavior ( dataMiningResult ) ; } else if ( j == 0 ) { behaviorTable [ i ] [ j ] = new Behavior ( attributeNames [ i ] , dataMiningResult ) ; } else if ( i == 0 ) { behaviorTable [ i ] [ j ] = new Behavior ( attributeNames [ j ] , dataMiningResult ) ; } else { behaviorTable [ i ] [ j ] = new Behavior ( dataMiningResult ) ; } } } return behaviorTable ; }
gems-uff/oceano | private String verifyBehavior ( String oneValue , String otherValue ) { if ( oneValue . equals ( otherValue ) ) { return SYMBOL_PROPORTIONAL_BEHAVIOR ; } else { return SYMBOL_OPOSITE_BEHAVIOR ; } }
gems-uff/oceano | private String verifyBehaviors ( List < DataMiningPattern > rules ) { boolean proportionalBehavior = false ; boolean opositeBehavior = false ; for ( DataMiningPattern rule : rules ) { String behavior = verifyBehavior ( DataMiningPattern . getValue ( rule . getPrecedent ( ) ) , DataMiningPattern . getValue ( rule . getConsequent ( ) ) ) ; if ( behavior . equals ( SYMBOL_PROPORTIONAL_BEHAVIOR ) ) { proportionalBehavior = true ; } else if ( behavior . equals ( SYMBOL_OPOSITE_BEHAVIOR ) ) { opositeBehavior = true ; } } if ( opositeBehavior && proportionalBehavior ) { return SYMBOL_CONFLICTANT_BEHAVIOR ; } else if ( opositeBehavior ) { return SYMBOL_OPOSITE_BEHAVIOR ; } else { return SYMBOL_PROPORTIONAL_BEHAVIOR ; } }
gems-uff/oceano | private Double getRuleMetric ( String ruleMetricName , DataMiningPattern dataMiningPattern ) { if ( ruleMetricName . equals ( " Confidence " ) ) { return dataMiningPattern . getConfidence ( ) ; } if ( ruleMetricName . equals ( " Lift " ) ) { return dataMiningPattern . getLift ( ) ; } if ( ruleMetricName . equals ( " Leverage " ) ) { return dataMiningPattern . getLeverage ( ) ; } if ( ruleMetricName . equals ( " Conviction " ) ) { return dataMiningPattern . getConviction ( ) ; } return null ; }
gems-uff/oceano | private List < String > getAttributes ( DataMiningResult dataMiningResult ) { List < String > returningAttributes = new LinkedList < String > ( ) ; final String arff = dataMiningResult . getArff ( ) ; for ( String line : arff . substring ( 0 , arff . indexOf ( " @ DATA " ) ) . split ( " \n " ) ) { if ( line . startsWith ( " @ ATTRIBUTE " ) ) { if ( line . contains ( " project - revision " ) || line . contains ( " rdate " ) || line . contains ( " rcommiter " ) || line . contains ( " # files " ) || line . contains ( " rday " ) || line . contains ( " rhour " ) || line . contains ( " rRound " ) || line . contains ( " rcompile " ) ) { continue ; } String attributeName ; if ( line . contains ( " \" " ) ) { attributeName = line . substring ( line . indexOf ( " \" " ) + 1 ) ; attributeName = attributeName . substring ( 0 , attributeName . indexOf ( " \" " ) ) ; } else { attributeName = line . split ( " ▁ " ) [ 1 ] ; } attributeName = attributeName . substring ( " dAvg - " . length ( ) ) ; returningAttributes . add ( attributeName ) ; } } return returningAttributes ; }
FelixGV/azkaban2 | protected AbstractJob ( String id , Logger log ) { _id = id ; _log = log ; _progress = 0.0 ; }
FelixGV/azkaban2 | public String getId ( ) { return _id ; }
FelixGV/azkaban2 | public double getProgress ( ) throws Exception { return _progress ; }
FelixGV/azkaban2 | public void setProgress ( double progress ) { this . _progress = progress ; }
FelixGV/azkaban2 | public void cancel ( ) throws Exception { throw new RuntimeException ( " Job ▁ " + _id + " ▁ does ▁ not ▁ support ▁ cancellation ! " ) ; }
FelixGV/azkaban2 | public Logger getLog ( ) { return this . _log ; }
FelixGV/azkaban2 | public void debug ( String message ) { this . _log . debug ( message ) ; }
FelixGV/azkaban2 | public void debug ( String message , Throwable t ) { this . _log . debug ( message , t ) ; }
FelixGV/azkaban2 | public void info ( String message ) { this . _log . info ( message ) ; }
FelixGV/azkaban2 | public void info ( String message , Throwable t ) { this . _log . info ( message , t ) ; }
FelixGV/azkaban2 | public void warn ( String message ) { this . _log . warn ( message ) ; }
FelixGV/azkaban2 | public void warn ( String message , Throwable t ) { this . _log . warn ( message , t ) ; }
FelixGV/azkaban2 | public void error ( String message ) { this . _log . error ( message ) ; }
FelixGV/azkaban2 | public void error ( String message , Throwable t ) { this . _log . error ( message , t ) ; }
FelixGV/azkaban2 | public Props getJobGeneratedProperties ( ) { return new Props ( ) ; }
FelixGV/azkaban2 | public boolean isCanceled ( ) { return false ; }
goodwinnk/intellij-community | public LiveTemplateBuilder ( ) { this ( false , Registry . intValue ( " emmet . segments . limit " ) ) ; }
goodwinnk/intellij-community | public LiveTemplateBuilder ( boolean addEndVariableAtTheEndOfTemplate , int segmentLimit ) { mySegmentLimit = segmentLimit ; myAddEndVariableAtTheEndOfTemplate = addEndVariableAtTheEndOfTemplate ; }
goodwinnk/intellij-community | public void setIsToReformat ( boolean isToReformat ) { myIsToReformat = isToReformat ; }
goodwinnk/intellij-community | public CharSequence getText ( ) { return myText ; }
goodwinnk/intellij-community | private VarOccurence ( String name , int offset ) { myName = name ; myOffset = offset ; }
goodwinnk/intellij-community | public boolean findVarOccurence ( String name ) { for ( VarOccurence occurence : myVariableOccurrences ) { if ( occurence . myName . equals ( name ) ) { return true ; } } return false ; }
goodwinnk/intellij-community | @ NotNull public TemplateImpl buildTemplate ( ) { List < Variable > variables = getListWithLimit ( myVariables ) ; if ( ! findVarOccurence ( TemplateImpl . END ) ) { if ( myLastEndVarName == null ) { for ( Variable variable : variables ) { if ( isEndVariable ( variable . getName ( ) ) ) { myLastEndVarName = variable . getName ( ) ; break ; } } } if ( myLastEndVarName != null ) { int endOffset = - 1 ; if ( myAddEndVariableAtTheEndOfTemplate ) { endOffset = myText . length ( ) ; } else { Iterator < VarOccurence > it = myVariableOccurrences . iterator ( ) ; while ( it . hasNext ( ) ) { VarOccurence occurence = it . next ( ) ; if ( occurence . myName . equals ( myLastEndVarName ) ) { endOffset = occurence . myOffset ; break ; } } if ( endOffset >= 0 ) { for ( Iterator < Variable > it1 = variables . iterator ( ) ; it1 . hasNext ( ) ; ) { Variable variable = it1 . next ( ) ; if ( myLastEndVarName . equals ( variable . getName ( ) ) && variable . isAlwaysStopAt ( ) ) { it . remove ( ) ; it1 . remove ( ) ; } } } } if ( endOffset >= 0 ) { myVariableOccurrences . add ( new VarOccurence ( TemplateImpl . END , endOffset ) ) ; } } } TemplateImpl template = new TemplateImpl ( " " , " " ) ; for ( Variable variable : variables ) { template . addVariable ( variable . getName ( ) , variable . getExpressionString ( ) , variable . getDefaultValueString ( ) , variable . isAlwaysStopAt ( ) ) ; } List < VarOccurence > variableOccurrences = getListWithLimit ( myVariableOccurrences ) ; Collections . sort ( variableOccurrences , Comparator . comparingInt ( o -> o . myOffset ) ) ; int last = 0 ; for ( VarOccurence occurence : variableOccurrences ) { template . addTextSegment ( myText . substring ( last , occurence . myOffset ) ) ; template . addVariableSegment ( occurence . myName ) ; last = occurence . myOffset ; } template . addTextSegment ( myText . substring ( last ) ) ; template . setToReformat ( myIsToReformat ) ; return template ; }
goodwinnk/intellij-community | private < T > List < T > getListWithLimit ( List < T > list ) { if ( ApplicationManager . getApplication ( ) . isUnitTestMode ( ) ) { return list ; } if ( mySegmentLimit == 0 ) { return Collections . emptyList ( ) ; } if ( mySegmentLimit > 0 && list . size ( ) > mySegmentLimit ) { warnTooManySegments ( list . size ( ) ) ; return list . subList ( 0 , Math . min ( list . size ( ) , mySegmentLimit ) ) ; } return list ; }
goodwinnk/intellij-community | public void insertText ( int offset , String text , boolean disableEndVariable ) { if ( disableEndVariable ) { String varName = null ; for ( VarOccurence occurence : myVariableOccurrences ) { if ( ! isEndVariable ( occurence . myName ) ) { continue ; } if ( occurence . myOffset == offset ) { varName = occurence . myName ; break ; } } if ( varName != null ) { for ( Variable variable : myVariables ) { if ( varName . equals ( variable . getName ( ) ) ) { variable . setAlwaysStopAt ( false ) ; variable . setDefaultValueString ( " \" \" " ) ; break ; } } } } int delta = text . length ( ) ; for ( VarOccurence occurence : myVariableOccurrences ) { if ( occurence . myOffset > offset || ! disableEndVariable && occurence . myOffset == offset ) { occurence . myOffset += delta ; } } myText . insert ( offset , text ) ; updateMarkers ( offset , text ) ; }
goodwinnk/intellij-community | public int length ( ) { return myText . length ( ) ; }
goodwinnk/intellij-community | private void updateMarkers ( int offset , String text ) { for ( Marker marker : myMarkers ) { if ( offset < marker . getStartOffset ( ) ) { marker . myStartOffset += text . length ( ) ; } else if ( offset <= marker . getEndOffset ( ) ) { marker . myEndOffset += text . length ( ) ; } } }
goodwinnk/intellij-community | private String generateUniqueVarName ( Set < String > existingNames , boolean end ) { String prefix = end ? END_PREFIX : " VAR " ; int i = 0 ; while ( myVarNames . contains ( prefix + i ) || existingNames . contains ( prefix + i ) ) { i ++ ; } return prefix + i ; }
goodwinnk/intellij-community | public int insertTemplate ( int offset , TemplateImpl template , Map < String , String > predefinedVarValues ) { myIsToReformat = myText . length ( ) > 0 || template . isToReformat ( ) ; removeEndVarAtOffset ( offset ) ; String text = template . getTemplateText ( ) ; insertText ( offset , text , false ) ; Set < String > oldVarNames = new HashSet < > ( ) ; for ( int i = 0 ; i < template . getVariableCount ( ) ; i ++ ) { String varName = template . getVariableNameAt ( i ) ; oldVarNames . add ( varName ) ; } Map < String , String > newVarNames = new HashMap < > ( ) ; for ( int i = 0 ; i < template . getVariableCount ( ) ; i ++ ) { String varName = template . getVariableNameAt ( i ) ; if ( ! TemplateImpl . INTERNAL_VARS_SET . contains ( varName ) ) { if ( predefinedVarValues != null && predefinedVarValues . containsKey ( varName ) ) { continue ; } String newVarName ; if ( myVarNames . contains ( varName ) ) { oldVarNames . remove ( varName ) ; newVarName = generateUniqueVarName ( oldVarNames , isEndVariable ( varName ) ) ; newVarNames . put ( varName , newVarName ) ; if ( varName . equals ( myLastEndVarName ) ) { myLastEndVarName = newVarName ; } } else { newVarName = varName ; } Variable var = new Variable ( newVarName , template . getExpressionStringAt ( i ) , template . getDefaultValueStringAt ( i ) , template . isAlwaysStopAt ( i ) ) ; if ( mySegmentLimit >= 0 && myVariables . size ( ) >= mySegmentLimit ) { if ( mySegmentLimit > 0 ) { warnTooManySegments ( myVariables . size ( ) ) ; } break ; } myVariables . add ( var ) ; myVarNames . add ( newVarName ) ; } } int end = - 1 ; for ( int i = 0 ; i < template . getSegmentsCount ( ) ; i ++ ) { String segmentName = template . getSegmentName ( i ) ; int localOffset = template . getSegmentOffset ( i ) ; if ( TemplateImpl . END . equals ( segmentName ) ) { end = offset + localOffset ; } else { if ( predefinedVarValues != null && predefinedVarValues . containsKey ( segmentName ) ) { String value = predefinedVarValues . get ( segmentName ) ; insertText ( offset + localOffset , value , false ) ; offset += value . length ( ) ; continue ; } if ( newVarNames . containsKey ( segmentName ) ) { segmentName = newVarNames . get ( segmentName ) ; } myVariableOccurrences . add ( new VarOccurence ( segmentName , offset + localOffset ) ) ; } } int endOffset = end >= 0 ? end : offset + text . length ( ) ; if ( endOffset > 0 && endOffset != offset + text . length ( ) && endOffset < myText . length ( ) && ! hasVarAtOffset ( endOffset ) ) { myLastEndVarName = generateUniqueVarName ( myVarNames , true ) ; myVariables . add ( new Variable ( myLastEndVarName , " " , " " , true ) ) ; myVarNames . add ( myLastEndVarName ) ; myVariableOccurrences . add ( new VarOccurence ( myLastEndVarName , endOffset ) ) ; } return endOffset ; }
goodwinnk/intellij-community | private void warnTooManySegments ( int size ) { LOGGER . warn ( " Too ▁ many ▁ ( " + size + " ▁ with ▁ the ▁ limit ▁ of ▁ " + mySegmentLimit + " ) ▁ segments ▁ were ▁ requested " + " ▁ for ▁ the ▁ template ▁ with ▁ the ▁ text : ▁ " + myText ) ; }
goodwinnk/intellij-community | private void removeEndVarAtOffset ( int offset ) { for ( Iterator < VarOccurence > it = myVariableOccurrences . iterator ( ) ; it . hasNext ( ) ; ) { VarOccurence occurence = it . next ( ) ; if ( ! isEndVariable ( occurence . myName ) ) { continue ; } if ( occurence . myOffset == offset ) { it . remove ( ) ; myVariables . removeIf ( variable -> occurence . myName . equals ( variable . getName ( ) ) ) ; } } }
goodwinnk/intellij-community | private boolean hasVarAtOffset ( int offset ) { boolean flag = false ; for ( VarOccurence occurence : myVariableOccurrences ) { if ( occurence . myOffset == offset ) { flag = true ; } } return flag ; }
goodwinnk/intellij-community | public Marker createMarker ( int offset ) { Marker marker = new Marker ( offset , offset ) ; myMarkers . add ( marker ) ; return marker ; }
goodwinnk/intellij-community | private Marker ( int startOffset , int endOffset ) { myStartOffset = startOffset ; myEndOffset = endOffset ; }
goodwinnk/intellij-community | public int getStartOffset ( ) { return myStartOffset ; }
goodwinnk/intellij-community | public int getEndOffset ( ) { return myEndOffset ; }
Niranjan-K/carbon-kernel | @ Override public void loadSecrets ( SecretRepositoryConfiguration secretRepositoryConfiguration ) throws SecureVaultException { logger . debug ( " Loading ▁ secrets ▁ to ▁ SecretRepository " ) ; Path secretPropertiesFilePath = Paths . get ( SecureVaultUtils . getSecretPropertiesFileLocation ( secretRepositoryConfiguration ) ) ; String resolvedFileContent = SecureVaultUtils . resolveFileToString ( secretPropertiesFilePath . toFile ( ) ) ; Properties secretsProperties = new Properties ( ) ; try { secretsProperties . load ( new StringReader ( resolvedFileContent ) ) ; } catch ( IOException e ) { throw new SecureVaultException ( " Failed ▁ to ▁ load ▁ secrets . properties ▁ file " ) ; } for ( Map . Entry < Object , Object > entry : secretsProperties . entrySet ( ) ) { String key = entry . getKey ( ) . toString ( ) . trim ( ) ; String value = entry . getValue ( ) . toString ( ) . trim ( ) ; char [ ] decryptedPassword ; String [ ] tokens = value . split ( SecureVaultConstants . SPACE ) ; if ( tokens . length != 2 ) { logger . error ( " Secret ▁ properties ▁ file ▁ contains ▁ an ▁ invalid ▁ entry ▁ at ▁ key ▁ : ▁ { } " , key ) ; continue ; } String updatedTokenValue = SecureVaultUtils . substituteVariables ( tokens [ 1 ] ) ; if ( SecureVaultConstants . CIPHER_TEXT . equals ( tokens [ 0 ] ) ) { byte [ ] base64Decoded = SecureVaultUtils . base64Decode ( SecureVaultUtils . toBytes ( updatedTokenValue ) ) ; decryptedPassword = SecureVaultUtils . toChars ( decrypt ( base64Decoded ) ) ; } else if ( SecureVaultConstants . PLAIN_TEXT . equals ( tokens [ 0 ] ) ) { decryptedPassword = updatedTokenValue . toCharArray ( ) ; } else { logger . error ( " Unknown ▁ prefix ▁ in ▁ secrets ▁ file " ) ; continue ; } secrets . put ( key , decryptedPassword ) ; } logger . debug ( " Secret ▁ repository ▁ loaded ▁ with ▁ ' { } ' ▁ secrets " , secrets . size ( ) ) ; }
Niranjan-K/carbon-kernel | @ Override public void persistSecrets ( SecretRepositoryConfiguration secretRepositoryConfiguration ) throws SecureVaultException { logger . debug ( " Persisting ▁ secrets ▁ to ▁ SecretRepository " ) ; Path secretPropertiesFilePath = Paths . get ( SecureVaultUtils . getSecretPropertiesFileLocation ( secretRepositoryConfiguration ) ) ; Properties secretsProperties = SecureVaultUtils . loadSecretFile ( secretPropertiesFilePath ) ; int count = 0 ; for ( Map . Entry < Object , Object > entry : secretsProperties . entrySet ( ) ) { String key = entry . getKey ( ) . toString ( ) . trim ( ) ; String value = entry . getValue ( ) . toString ( ) . trim ( ) ; byte [ ] encryptedPassword ; String [ ] tokens = value . split ( SecureVaultConstants . SPACE ) ; if ( tokens . length != 2 ) { logger . error ( " Secret ▁ properties ▁ file ▁ contains ▁ an ▁ invalid ▁ entry ▁ at ▁ key ▁ : ▁ { } " , key ) ; continue ; } if ( SecureVaultConstants . PLAIN_TEXT . equals ( tokens [ 0 ] ) ) { encryptedPassword = SecureVaultUtils . base64Encode ( encrypt ( SecureVaultUtils . toBytes ( tokens [ 1 ] . trim ( ) ) ) ) ; secretsProperties . setProperty ( key , SecureVaultConstants . CIPHER_TEXT + " ▁ " + new String ( SecureVaultUtils . toChars ( encryptedPassword ) ) ) ; count ++ ; } } SecureVaultUtils . updateSecretFile ( secretPropertiesFilePath , secretsProperties ) ; logger . debug ( " Secrets ▁ file ▁ updated ▁ with ▁ ' { } ' ▁ new ▁ encrypted ▁ secrets " , count ) ; }
Niranjan-K/carbon-kernel | @ Override public char [ ] resolve ( String alias ) { char [ ] secret = secrets . get ( alias ) ; if ( secret != null && secret . length != 0 ) { return secret ; } return new char [ 0 ] ; }
jSquirrel/nutforms | @ Before public void setUp ( ) throws Exception { KieServices kieServices = KieServices . Factory . get ( ) ; KieContainer kieContainer = kieServices . getKieClasspathContainer ( ) ; kieSession = kieContainer . newStatelessKieSession ( " accountsession " ) ; kieSession . setGlobal ( " status " , " verified " ) ; }
jSquirrel/nutforms | @ Test public void inspectUserEntityRules ( ) { Collection < KiePackage > kiePackages = kieSession . getKieBase ( ) . getKiePackages ( ) ; for ( KiePackage kiePackage : kiePackages ) { if ( kiePackage . getRules ( ) . size ( ) > 0 ) { System . out . println ( kiePackage . getRules ( ) . size ( ) + " ▁ rule ( s ) ▁ found ▁ in ▁ package ▁ " + kiePackage . getName ( ) + " : " ) ; for ( Rule rule : kiePackage . getRules ( ) ) { inspectRule ( ( RuleImpl ) rule ) ; System . out . println ( ) ; } } } }
jSquirrel/nutforms | @ Test public void testInspectRule ( ) { Inspector inspector = new Inspector ( ) ; Map < String , Set < cz . cvut . fel . nutforms . rules . metamodel . Rule > > rules = inspector . inspectBase ( kieSession . getKieBase ( ) ) ; }
jSquirrel/nutforms | private void inspectRule ( RuleImpl rule ) { System . out . println ( " \tName : ▁ " ) ; System . out . println ( " \t\t " + rule . getName ( ) ) ; System . out . println ( " \tDeclarations : ▁ " ) ; for ( String s : rule . getDeclarations ( ) . keySet ( ) ) { System . out . println ( " \t\t " + s + " ▁ [ " + rule . getDeclaration ( s ) . getBoxedTypeName ( ) + " ] " ) ; } System . out . println ( " \tConstraints : ▁ " ) ; for ( RuleConditionElement ruleConditionElement : rule . getLhs ( ) . getChildren ( ) ) { for ( Constraint constraint : ( ( Pattern ) ruleConditionElement ) . getConstraints ( ) ) { System . out . println ( " \t\t " + " Object ▁ type : ▁ " + ( ( Pattern ) ruleConditionElement ) . getObjectType ( ) ) ; System . out . println ( " \t\t " + ( ( MvelConstraint ) constraint ) . getExpression ( ) ) ; } } if ( rule . getConsequence ( ) != null ) { System . out . println ( " \tConsequence : ▁ " ) ; try { Field unit = rule . getConsequence ( ) . getClass ( ) . getDeclaredField ( " unit " ) ; unit . setAccessible ( true ) ; System . out . println ( " \t\t " + ( ( MVELCompilationUnit ) unit . get ( rule . getConsequence ( ) ) ) . getExpression ( ) ) ; } catch ( NoSuchFieldException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } }
SpongePowered/SpongeAPI | default BlockEntity rotate ( final Supplier < ? extends Rotation > rotation ) { return this . rotate ( rotation . get ( ) ) ; }
SpongePowered/SpongeAPI | default BlockEntity mirror ( final Supplier < ? extends Mirror > mirror ) { return this . mirror ( mirror . get ( ) ) ; }
CMPUT301F17T13/cat-is-a-dog | public HabitEventRepository ( String userId ) { mHabitEventsRef = FirebaseDatabase . getInstance ( ) . getReference ( " events / " + userId ) ; this . userId = userId ; mGeoFireRef = FirebaseDatabase . getInstance ( ) . getReference ( " events _ geofire / " ) ; geoFire = new GeoFire ( mGeoFireRef ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void add ( HabitEvent habitEvent ) { HabitEventDataModel eventModel = new HabitEventDataModel ( habitEvent ) ; DatabaseReference newEvent = mHabitEventsRef . push ( ) ; eventModel . setKey ( newEvent . getKey ( ) ) ; newEvent . setValue ( eventModel , - 1 * habitEvent . getEventDate ( ) . getMillis ( ) , null ) ; geoFire . setLocation ( userId + ' @ ' + newEvent . getKey ( ) , new GeoLocation ( habitEvent . getLatitude ( ) , habitEvent . getLongitude ( ) ) ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void update ( String key , HabitEvent habitEvent ) { HabitEventDataModel eventModel = new HabitEventDataModel ( habitEvent ) ; mHabitEventsRef . child ( key ) . getRef ( ) . setValue ( eventModel , null ) ; geoFire . setLocation ( userId + ' @ ' + habitEvent . getKey ( ) , new GeoLocation ( habitEvent . getLatitude ( ) , habitEvent . getLongitude ( ) ) ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void delete ( String key ) { mHabitEventsRef . child ( key ) . getRef ( ) . removeValue ( null ) ; geoFire . removeLocation ( userId + ' @ ' + key ) ; }
CMPUT301F17T13/cat-is-a-dog | @ Override public void get ( String key , final OnResultListener < HabitEvent > resultListener ) { mHabitEventsRef . child ( key ) . addListenerForSingleValueEvent ( new ValueEventListener ( ) { @ Override public void onDataChange ( DataSnapshot dataSnapshot ) { HabitEventDataModel model = dataSnapshot . getValue ( HabitEventDataModel . class ) ; if ( model != null ) { resultListener . onResult ( model . getHabitEvent ( ) ) ; } else { resultListener . onResult ( null ) ; } } @ Override public void onCancelled ( DatabaseError databaseError ) { } } ) ; }
changshan/graphdb-benchmarks | public LouvainMethod ( GraphDatabase < ? , ? , ? , ? > graphDatabase , int cacheSize , boolean isRandomized ) throws ExecutionException { this . graphDatabase = graphDatabase ; this . isRandomized = isRandomized ; initialize ( ) ; cache = new Cache ( graphDatabase , cacheSize ) ; }
changshan/graphdb-benchmarks | private void initialize ( ) { this . N = this . graphDatabase . getNodeCount ( ) ; this . graphWeightSum = this . graphDatabase . getGraphWeightSum ( ) / 2 ; this . communityWeights = new ArrayList < Double > ( this . N ) ; for ( int i = 0 ; i < this . N ; i ++ ) { this . communityWeights . add ( 0.0 ) ; } this . graphDatabase . initCommunityProperty ( ) ; }
changshan/graphdb-benchmarks | public void computeModularity ( ) throws ExecutionException { Random rand = new Random ( ) ; boolean someChange = true ; while ( someChange ) { someChange = false ; boolean localChange = true ; while ( localChange ) { localChange = false ; int start = 0 ; if ( this . isRandomized ) { start = Math . abs ( rand . nextInt ( ) ) % this . N ; } int step = 0 ; for ( int i = start ; step < this . N ; i = ( i + 1 ) % this . N ) { step ++ ; int bestCommunity = updateBestCommunity ( i ) ; if ( ( this . cache . getCommunity ( i ) != bestCommunity ) && ( this . communityUpdate ) ) { this . cache . moveNodeCommunity ( i , bestCommunity ) ; this . graphDatabase . moveNode ( i , bestCommunity ) ; double bestCommunityWeight = this . communityWeights . get ( bestCommunity ) ; bestCommunityWeight += cache . getNodeCommunityWeight ( i ) ; this . communityWeights . set ( bestCommunity , bestCommunityWeight ) ; localChange = true ; } this . communityUpdate = false ; } someChange = localChange || someChange ; } if ( someChange ) { zoomOut ( ) ; } } }
changshan/graphdb-benchmarks | private int updateBestCommunity ( int node ) throws ExecutionException { int bestCommunity = 0 ; double best = 0 ; Set < Integer > communities = this . cache . getCommunitiesConnectedToNodeCommunities ( node ) ; for ( int community : communities ) { double qValue = q ( node , community ) ; if ( qValue > best ) { best = qValue ; bestCommunity = community ; this . communityUpdate = true ; } } return bestCommunity ; }
changshan/graphdb-benchmarks | private double q ( int nodeCommunity , int community ) throws ExecutionException { double edgesInCommunity = this . cache . getEdgesInsideCommunity ( nodeCommunity , community ) ; double communityWeight = this . communityWeights . get ( community ) ; double nodeWeight = this . cache . getNodeCommunityWeight ( nodeCommunity ) ; double qValue = this . resolution * edgesInCommunity - ( nodeWeight * communityWeight ) / ( 2.0 * this . graphWeightSum ) ; int actualNodeCom = this . cache . getCommunity ( nodeCommunity ) ; int communitySize = this . cache . getCommunitySize ( community ) ; if ( ( actualNodeCom == community ) && ( communitySize > 1 ) ) { qValue = this . resolution * edgesInCommunity - ( nodeWeight * ( communityWeight - nodeWeight ) ) / ( 2.0 * this . graphWeightSum ) ; } if ( ( actualNodeCom == community ) && ( communitySize == 1 ) ) { qValue = 0. ; } return qValue ; }
changshan/graphdb-benchmarks | public void zoomOut ( ) { this . N = this . graphDatabase . reInitializeCommunities ( ) ; this . cache . reInitializeCommunities ( ) ; this . communityWeights = new ArrayList < Double > ( this . N ) ; for ( int i = 0 ; i < this . N ; i ++ ) { this . communityWeights . add ( graphDatabase . getCommunityWeight ( i ) ) ; } }
changshan/graphdb-benchmarks | public int getN ( ) { return this . N ; }
nabilzhang/enunciate | public RootElementDeclaration ( TypeElement delegate , TypeDefinition typeDefinition , EnunciateJaxbContext context ) { super ( delegate , context . getContext ( ) . getProcessingEnvironment ( ) ) ; this . rootElement = getAnnotation ( XmlRootElement . class ) ; this . typeDefinition = typeDefinition ; this . schema = new Schema ( this . env . getElementUtils ( ) . getPackageOf ( delegate ) , env ) ; this . facets . addAll ( Facet . gatherFacets ( delegate , context . getContext ( ) ) ) ; this . facets . addAll ( this . schema . getFacets ( ) ) ; }
nabilzhang/enunciate | public TypeDefinition getTypeDefinition ( ) { return this . typeDefinition ; }
nabilzhang/enunciate | public String getName ( ) { String name = Introspector . decapitalize ( getSimpleName ( ) . toString ( ) ) ; if ( ( rootElement != null ) && ( ! " # # default " . equals ( rootElement . name ( ) ) ) ) { name = rootElement . name ( ) ; } return name ; }
nabilzhang/enunciate | public String getNamespace ( ) { String namespace = getPackage ( ) . getNamespace ( ) ; if ( ( rootElement != null ) && ( ! " # # default " . equals ( rootElement . namespace ( ) ) ) ) { namespace = rootElement . namespace ( ) ; } return namespace ; }
nabilzhang/enunciate | public QName getQname ( ) { return new QName ( getNamespace ( ) , getName ( ) ) ; }
nabilzhang/enunciate | public String getClientSimpleName ( ) { String clientSimpleName = getSimpleName ( ) . toString ( ) ; ClientName clientName = getAnnotation ( ClientName . class ) ; if ( clientName != null ) { clientSimpleName = clientName . value ( ) ; } return clientSimpleName ; }
nabilzhang/enunciate | public Schema getSchema ( ) { return schema ; }
nabilzhang/enunciate | @ Override public Schema getPackage ( ) { return getSchema ( ) ; }
nabilzhang/enunciate | public Set < Facet > getFacets ( ) { return facets ; }
kaen/Terasology | @ Before public void setUp ( ) { bindsSubsystem = new BindsSubsystem ( ) ; bindsConfiguration = new BindsConfigAdapter ( new BindsConfig ( ) ) ; context = new ContextImpl ( ) ; context . put ( BindsConfiguration . class , bindsConfiguration ) ; bindsSubsystem . preInitialise ( context ) ; setUpMockModuleEnvironment ( ) ; }
kaen/Terasology | private void setUpMockModuleEnvironment ( ) { ModuleManager moduleManager = mock ( ModuleManager . class ) ; ModuleRegistry moduleRegistry = new TableModuleRegistry ( ) ; Module module = mock ( Module . class ) ; when ( module . isCodeModule ( ) ) . thenReturn ( true ) ; when ( module . getId ( ) ) . thenReturn ( new Name ( TEST_MODULE ) ) ; when ( module . getVersion ( ) ) . thenReturn ( new Version ( 0 , 0 , 1 , true ) ) ; when ( module . getMetadata ( ) ) . thenReturn ( new ModuleMetadata ( ) ) ; moduleRegistry . add ( module ) ; when ( moduleManager . getRegistry ( ) ) . thenReturn ( moduleRegistry ) ; ModuleEnvironment environment = mock ( ModuleEnvironment . class ) ; when ( moduleManager . loadEnvironment ( any ( ) , anyBoolean ( ) ) ) . thenReturn ( environment ) ; when ( moduleManager . getEnvironment ( ) ) . thenReturn ( environment ) ; registerBindButtonClasses = new ArrayList < > ( ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindButton . class ) ) ) . thenReturn ( registerBindButtonClasses ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindButton . class ) , any ( ) ) ) . thenReturn ( registerBindButtonClasses ) ; registerRealBindAxisClasses = new ArrayList < > ( ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindAxis . class ) ) ) . thenReturn ( registerRealBindAxisClasses ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindAxis . class ) , any ( ) ) ) . thenReturn ( registerRealBindAxisClasses ) ; when ( environment . getModuleProviding ( any ( ) ) ) . thenReturn ( new Name ( TEST_MODULE ) ) ; context . put ( ModuleManager . class , moduleManager ) ; }
kaen/Terasology | @ Test public void testSelfRegisterOnContext ( ) { assertThat ( context . get ( BindsManager . class ) , is ( bindsSubsystem ) ) ; }
kaen/Terasology | @ Test public void testUpdateBinds ( ) { registerBindButtonClasses . add ( TestEventButton . class ) ; bindsSubsystem . updateConfigWithDefaultBinds ( ) ; List < Input > defaultBinds = bindsSubsystem . getDefaultBindsConfig ( ) . getBinds ( new SimpleUri ( TEST_MODULE , " testEvent " ) ) ; assertThat ( defaultBinds . size ( ) , is ( 1 ) ) ; assertThat ( defaultBinds . get ( 0 ) . getType ( ) , is ( InputType . KEY ) ) ; assertThat ( defaultBinds . get ( 0 ) . getId ( ) , is ( KeyId . T ) ) ; assertThat ( defaultBinds . get ( 0 ) . getName ( ) , is ( Key . T . getName ( ) ) ) ; assertThat ( defaultBinds . get ( 0 ) . getDisplayName ( ) , is ( Key . T . getDisplayName ( ) ) ) ; List < Input > binds = bindsSubsystem . getBindsConfig ( ) . getBinds ( new SimpleUri ( TEST_MODULE , " testEvent " ) ) ; assertThat ( binds . size ( ) , is ( 1 ) ) ; assertThat ( binds . get ( 0 ) . getType ( ) , is ( InputType . KEY ) ) ; assertThat ( binds . get ( 0 ) . getId ( ) , is ( KeyId . T ) ) ; assertThat ( binds . get ( 0 ) . getName ( ) , is ( Key . T . getName ( ) ) ) ; assertThat ( binds . get ( 0 ) . getDisplayName ( ) , is ( Key . T . getDisplayName ( ) ) ) ; }
kaen/Terasology | @ Test public void test ( ) { ModuleEnvironment environment = mock ( ModuleEnvironment . class ) ; when ( environment . getTypesAnnotatedWith ( eq ( RegisterBindButton . class ) , any ( ) ) ) . thenReturn ( registerBindButtonClasses ) ; registerBindButtonClasses . add ( TestEventButton . class ) ; }
kaen/Terasology | @ Test public void testRegisterBinds ( ) { registerBindButtonClasses . add ( TestEventButton . class ) ; bindsSubsystem . updateConfigWithDefaultBinds ( ) ; bindsSubsystem . registerBinds ( ) ; BindableButton button = bindsSubsystem . getKeyBinds ( ) . get ( KeyId . T ) ; assertThat ( button , is ( not ( nullValue ( ) ) ) ) ; assertThat ( button . getId ( ) , is ( new SimpleUri ( TEST_MODULE , " testEvent " ) ) ) ; assertThat ( button . getDisplayName ( ) , is ( " $ { engine - tests : menu # theTestEvent } " ) ) ; }
wso2/security-tools | public Class ( String className ) { this . className = className ; this . methods = new ArrayList < Method > ( ) ; }
wso2/security-tools | public String getClassName ( ) { return className ; }
wso2/security-tools | public void setClassName ( String className ) { this . className = className ; }
wso2/security-tools | public ArrayList < Method > getMethods ( ) { return methods ; }
wso2/security-tools | public void setMethods ( ArrayList < Method > methods ) { this . methods = methods ; }
lnquy/TodoTask | if ( username != null && SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { UserDetails userDetails = this . userDetailsService . loadUserByUsername ( username ) ; if ( jwtTokenUtil . validateToken ( authToken , userDetails ) ) { UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken ( userDetails , null , userDetails . getAuthorities ( ) ) ; authentication . setDetails ( new WebAuthenticationDetailsSource ( ) . buildDetails ( httpRequest ) ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; } }
jexp/idea2 | public ThreadState ( final String name , final String state ) { myName = name ; myState = state . trim ( ) ; }
jexp/idea2 | public String getName ( ) { return myName ; }
jexp/idea2 | public String getState ( ) { return myState ; }
jexp/idea2 | public String getStackTrace ( ) { return myStackTrace ; }
jexp/idea2 | public void setStackTrace ( final String stackTrace , boolean isEmpty ) { myStackTrace = stackTrace ; myEmptyStackTrace = isEmpty ; }
jexp/idea2 | public Collection < ThreadState > getAwaitingThreads ( ) { return Collections . unmodifiableSet ( myThreadsWaitingForMyLock ) ; }
jexp/idea2 | public String toString ( ) { return myName ; }
jexp/idea2 | public void setJavaThreadState ( final String javaThreadState ) { myJavaThreadState = javaThreadState ; }
jexp/idea2 | public void setThreadStateDetail ( @ NonNls final String threadStateDetail ) { myThreadStateDetail = threadStateDetail ; }
jexp/idea2 | public String getJavaThreadState ( ) { return myJavaThreadState ; }
jexp/idea2 | public String getThreadStateDetail ( ) { if ( myOperation != null ) { return myOperation . toString ( ) ; } return myThreadStateDetail ; }
jexp/idea2 | public boolean isEmptyStackTrace ( ) { return myEmptyStackTrace ; }
jexp/idea2 | public String getExtraState ( ) { return myExtraState ; }
jexp/idea2 | public void setExtraState ( final String extraState ) { myExtraState = extraState ; }
jexp/idea2 | public boolean isSleeping ( ) { return " sleeping " . equals ( getThreadStateDetail ( ) ) || ( ( " parking " . equals ( getThreadStateDetail ( ) ) || " waiting ▁ on ▁ condition " . equals ( myState ) ) && isThreadPoolExecutor ( ) ) ; }
jexp/idea2 | private boolean isThreadPoolExecutor ( ) { return myStackTrace . contains ( " java . util . concurrent . ScheduledThreadPoolExecutor $ DelayedWorkQueue . take " ) || myStackTrace . contains ( " java . util . concurrent . ThreadPoolExecutor . getTask " ) ; }
jexp/idea2 | public boolean isAwaitedBy ( ThreadState thread ) { return myThreadsWaitingForMyLock . contains ( thread ) ; }
jexp/idea2 | public void addWaitingThread ( ThreadState thread ) { myThreadsWaitingForMyLock . add ( thread ) ; }
jexp/idea2 | public boolean isDeadlocked ( ) { return ! myDeadlockedThreads . isEmpty ( ) ; }
jexp/idea2 | public void addDeadlockedThread ( ThreadState thread ) { myDeadlockedThreads . add ( thread ) ; }
jexp/idea2 | @ Nullable public ThreadOperation getOperation ( ) { return myOperation ; }
jexp/idea2 | public void setOperation ( @ Nullable final ThreadOperation operation ) { myOperation = operation ; }
jexp/idea2 | public boolean isWaiting ( ) { return " on ▁ object ▁ monitor " . equals ( myThreadStateDetail ) || myState . startsWith ( " waiting " ) || ( " parking " . equals ( myThreadStateDetail ) && ! isSleeping ( ) ) ; }
jexp/idea2 | public boolean isEDT ( ) { final String name = getName ( ) ; return isEDT ( name ) ; }
emboss/krypt-core-java | public PemInputStream ( InputStream in ) { super ( in ) ; b64Buffer = new Base64Buffer ( in ) ; }
emboss/krypt-core-java | public void continueStream ( ) { b64Buffer . continueStream ( ) ; }
emboss/krypt-core-java | public String getCurrentName ( ) { return b64Buffer . getName ( ) ; }
emboss/krypt-core-java | @ Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( len <= 0 ) throw new IllegalArgumentException ( " Negative ▁ or ▁ zero ▁ length " ) ; return b64Buffer . read ( b , off , len ) ; }
emboss/krypt-core-java | @ Override public int read ( ) throws IOException { int r = read ( singleByte ) ; while ( r == 0 ) { r = read ( singleByte ) ; } if ( r == - 1 ) return r ; return ( singleByte [ 0 ] & 0xff ) ; }
emboss/krypt-core-java | @ Override public boolean markSupported ( ) { return false ; }
emboss/krypt-core-java | @ Override public long skip ( long n ) throws IOException { throw new UnsupportedOperationException ( " Not ▁ implemented ▁ yet " ) ; }
emboss/krypt-core-java | public PemLineMatcher ( String line , final String beginOrEnd ) { this . pattern = Pattern . compile ( " ^ - - - - - " + beginOrEnd + " ▁ ( \\ w ( \\ w | \\ s ) * ) - - - - - $ " ) ; this . line = line ; }
emboss/krypt-core-java | public boolean match ( ) throws IOException { Matcher m = pattern . matcher ( line ) ; if ( m . matches ( ) ) { name = m . group ( 1 ) ; if ( name == null ) return false ; return true ; } return false ; }
emboss/krypt-core-java | public String getName ( ) { return name ; }
emboss/krypt-core-java | public PemHeaderMatcher ( String line ) { super ( line , " BEGIN " ) ; }
emboss/krypt-core-java | public PemFooterMatcher ( String line , String name ) { super ( line , " END " ) ; this . name = name ; }
emboss/krypt-core-java | @ Override public boolean match ( ) throws IOException { boolean match = super . match ( ) ; if ( match && name . equals ( getName ( ) ) ) return true ; else return false ; }
emboss/krypt-core-java | public Base64Buffer ( InputStream in ) { try { this . in = new BufferedReader ( new InputStreamReader ( in , " US - ASCII " ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } }
emboss/krypt-core-java | public void continueStream ( ) { this . buffer = null ; this . name = null ; this . bufpos = 0 ; this . state = State . HEADER ; this . eof = false ; }
emboss/krypt-core-java | private int decodeLine ( String line , OutputStream out ) throws IOException { try { byte [ ] bytes = line . getBytes ( " US - ASCII " ) ; Base64 . decodeTo ( bytes , 0 , bytes . length , out ) ; return bytes . length ; } catch ( UnsupportedEncodingException ex ) { throw new RuntimeException ( ex ) ; } }
emboss/krypt-core-java | private void fill ( ) throws IOException { int total = 0 ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( THRESHOLD ) ; String line = in . readLine ( ) ; while ( ! state . equals ( State . DONE ) && total < THRESHOLD && line != null ) { if ( line . equals ( " " ) ) { line = in . readLine ( ) ; continue ; } switch ( state ) { case HEADER : if ( line . charAt ( 0 ) == ' - ' ) { PemHeaderMatcher matcher = new PemHeaderMatcher ( line ) ; if ( matcher . match ( ) ) { state = State . CONTENT ; name = matcher . getName ( ) ; } } line = in . readLine ( ) ; break ; case CONTENT : if ( line . charAt ( 0 ) == ' - ' ) { state = State . FOOTER ; } else { total += decodeLine ( line , baos ) ; if ( total < THRESHOLD ) line = in . readLine ( ) ; } break ; case FOOTER : if ( line . charAt ( 0 ) == ' - ' ) { PemFooterMatcher matcher = new PemFooterMatcher ( line , name ) ; if ( matcher . match ( ) ) { state = State . DONE ; } else { line = in . readLine ( ) ; } } else { line = in . readLine ( ) ; } break ; default : break ; } } if ( state . equals ( State . DONE ) || line == null ) eof = true ; if ( line == null && ! state . equals ( State . DONE ) ) { switch ( state ) { case HEADER : break ; case CONTENT : throw new MalformedPemException ( " PEM ▁ data ▁ ended ▁ prematurely " ) ; default : throw new MalformedPemException ( " Could ▁ not ▁ find ▁ matching ▁ footer " ) ; } } buffer = baos . toByteArray ( ) ; bufpos = 0 ; }
emboss/krypt-core-java | private int consumeBytes ( byte [ ] b , int off , int len ) { if ( bufpos == buffer . length ) return 0 ; int available = buffer . length - bufpos ; int toRead = len < available ? len : available ; System . arraycopy ( buffer , bufpos , b , off , toRead ) ; bufpos += toRead ; return toRead ; }
emboss/krypt-core-java | public int read ( byte [ ] b , int off , int len ) throws IOException { int total = 0 ; if ( buffer == null ) { fill ( ) ; } while ( total != len && ! ( bufpos == buffer . length && eof ) ) { if ( bufpos == buffer . length ) fill ( ) ; total += consumeBytes ( b , off + total , len - total ) ; } if ( total == 0 && eof ) return - 1 ; return total ; }
emboss/krypt-core-java | public String getName ( ) { return name ; }
emboss/krypt-core-java | public MalformedPemException ( Throwable cause ) { super ( cause ) ; }
emboss/krypt-core-java | public MalformedPemException ( String message , Throwable cause ) { super ( message , cause ) ; }
emboss/krypt-core-java | public MalformedPemException ( String message ) { super ( message ) ; }
lsimons/phloc-schematron-standalone | public ComparatorThreadID ( ) { super ( ) ; }
lsimons/phloc-schematron-standalone | public ComparatorThreadID ( @ Nonnull final ESortOrder eSortOrder ) { super ( eSortOrder ) ; }
lsimons/phloc-schematron-standalone | @ Override protected long asLong ( @ Nullable final Thread aThread ) { return aThread == null ? CGlobal . ILLEGAL_ULONG : aThread . getId ( ) ; }
open-o/nfvo | @ Test public void testOperateFail ( ) throws ServiceException { execTestCase ( new File ( POST_PATH ) ) ; execTestCase ( new File ( PUT_PATH ) ) ; execTestCase ( new File ( DEL_PATH ) ) ; }
google/or-tools | public VarArraySolutionPrinter ( IntVar [ ] variables ) { variableArray = variables ; }
google/or-tools | @ Override public void onSolutionCallback ( ) { System . out . printf ( " Solution ▁ # % d : ▁ time ▁ = ▁ % .02f ▁ s % n " , solutionCount , wallTime ( ) ) ; for ( IntVar v : variableArray ) { System . out . printf ( " ▁ ▁ % s ▁ = ▁ % d % n " , v . getName ( ) , value ( v ) ) ; } solutionCount ++ ; }
google/or-tools | public int getSolutionCount ( ) { return solutionCount ; }
bollsal/pikicast-java-study | Knight ( Color color ) { super ( color ) ; }
bollsal/pikicast-java-study | @ Override public String getName ( ) { if ( isWhite ( ) ) { return WHITE_NAME ; } else { return BLACK_NAME ; } }
Estructuras-ITESM/Anpharos | public void settings ( ) { size ( multiplier * 600 , multiplier * 600 ) ; }
Estructuras-ITESM/Anpharos | public void setup ( ) { city = " " ; destCity = " " ; cp5 = new ControlP5 ( this ) ; dfs = cp5 . addButton ( " DFS " ) . setPosition ( 2 * width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; bfs = cp5 . addButton ( " BFS " ) . setPosition ( 3 * width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; input = cp5 . addTextfield ( " input " ) . setPosition ( 0 , 00 ) . setSize ( 100 * multiplier , 20 * multiplier ) ; destination = cp5 . addTextfield ( " destination " ) . setPosition ( 0 , 40 ) . setSize ( 100 * multiplier , 20 * multiplier ) ; spainGraph = new SpainGraph ( this , multiplier ) ; sphero = new Sphero ( this , multiplier , spainGraph . getGuiNodes ( ) ) ; dijkstra = cp5 . addButton ( " Dijkstra " ) . setPosition ( width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; }
Estructuras-ITESM/Anpharos | public void controlEvent ( ControlEvent theEvent ) { System . out . println ( theEvent . getController ( ) . getName ( ) ) ; if ( city != " " ) { switch ( theEvent . getName ( ) ) { case " Dijkstra " : if ( destCity != " " ) { Dijkstra tmp = new Dijkstra ( spainGraph . getGraph ( ) ) ; tmp . setSource ( city ) ; trace = tmp . trace ( destCity ) ; sphero . putTo ( trace ) ; } break ; case " DFS " : trace = DFS . trace ( spainGraph . getGraph ( ) , city ) ; sphero . putTo ( trace ) ; break ; case " BFS " : trace = BFS . trace ( spainGraph . getGraph ( ) , city ) ; sphero . putTo ( trace ) ; break ; } } }
Estructuras-ITESM/Anpharos | public void Dijkstra ( ) { System . out . println ( " Dijkstra ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } if ( spainGraph . contains ( destination . getText ( ) ) ) { destCity = destination . getText ( ) ; } }
Estructuras-ITESM/Anpharos | public void DFS ( ) { System . out . println ( " DFS ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } }
Estructuras-ITESM/Anpharos | public void BFS ( ) { System . out . println ( " BFS ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } }
Estructuras-ITESM/Anpharos | public void draw ( ) { background ( 255 ) ; spainGraph . draw ( ) ; sphero . draw ( ) ; }
neckhyg/dataChart | @ RequestMapping ( " / list " ) @ RequiresPermissions ( " czitattendance : list " ) public R list ( @ RequestParam Map < String , Object > params ) { Query query = new Query ( params ) ; List < CzitAttendanceEntity > czitAttendanceList = czitAttendanceService . queryList ( query ) ; int total = czitAttendanceService . queryTotal ( query ) ; PageUtils pageUtil = new PageUtils ( czitAttendanceList , total , query . getLimit ( ) , query . getPage ( ) ) ; return R . ok ( ) . put ( " page " , pageUtil ) ; }
neckhyg/dataChart | @ RequestMapping ( " / list2" ) public R list2 ( @ RequestParam Map < String , Object > params ) { List < CzitAttendanceEntity > czitAttendanceList = czitAttendanceService . queryList ( params ) ; return R . ok ( ) . put ( " data " , czitAttendanceList ) ; }
neckhyg/dataChart | " ) @ RequiresPermissions ( " czitattendance : info " ) public R info ( @ PathVariable ( " id " ) Integer id ) { CzitAttendanceEntity czitAttendance = czitAttendanceService . queryObject ( id ) ; return R . ok ( ) . put ( " czitAttendance " , czitAttendance ) ; }
neckhyg/dataChart | @ RequestMapping ( " / save " ) @ RequiresPermissions ( " czitattendance : save " ) public R save ( @ RequestBody CzitAttendanceEntity czitAttendance ) { czitAttendanceService . save ( czitAttendance ) ; return R . ok ( ) ; }
neckhyg/dataChart | @ RequestMapping ( " / update " ) @ RequiresPermissions ( " czitattendance : update " ) public R update ( @ RequestBody CzitAttendanceEntity czitAttendance ) { czitAttendanceService . update ( czitAttendance ) ; return R . ok ( ) ; }
neckhyg/dataChart | @ RequestMapping ( " / delete " ) @ RequiresPermissions ( " czitattendance : delete " ) public R delete ( @ RequestBody Integer [ ] ids ) { czitAttendanceService . deleteBatch ( ids ) ; return R . ok ( ) ; }
saandrews/pulsar | private final TypeReference < Map < String , Map < BookieSocketAddress , BookieInfo > > > typeRef = new TypeReference < Map < String , Map < BookieSocketAddress , BookieInfo > > > ( ) { }
saandrews/pulsar | public ZkIsolatedBookieEnsemblePlacementPolicy ( ) { super ( ) ; }
saandrews/pulsar | @ Override public RackawareEnsemblePlacementPolicyImpl initialize ( ClientConfiguration conf , Optional < DNSToSwitchMapping > optionalDnsResolver , HashedWheelTimer timer , FeatureProvider featureProvider , StatsLogger statsLogger ) { if ( conf . getProperty ( ISOLATION_BOOKIE_GROUPS ) != null ) { String isolationGroupsString = ( String ) conf . getProperty ( ISOLATION_BOOKIE_GROUPS ) ; if ( ! isolationGroupsString . isEmpty ( ) ) { for ( String isolationGroup : isolationGroupsString . split ( " , " ) ) { isolationGroups . add ( isolationGroup ) ; } bookieMappingCache = getAndSetZkCache ( conf ) ; } } return super . initialize ( conf , optionalDnsResolver , timer , featureProvider , statsLogger ) ; }
saandrews/pulsar | private ZooKeeperCache getAndSetZkCache ( Configuration conf ) { ZooKeeperCache zkCache = null ; if ( conf . getProperty ( ZooKeeperCache . ZK_CACHE_INSTANCE ) != null ) { zkCache = ( ZooKeeperCache ) conf . getProperty ( ZooKeeperCache . ZK_CACHE_INSTANCE ) ; } else { int zkTimeout ; String zkServers ; if ( conf instanceof ClientConfiguration ) { zkTimeout = ( ( ClientConfiguration ) conf ) . getZkTimeout ( ) ; zkServers = ( ( ClientConfiguration ) conf ) . getZkServers ( ) ; try { ZooKeeper zkClient = ZooKeeperClient . newBuilder ( ) . connectString ( zkServers ) . sessionTimeoutMs ( zkTimeout ) . build ( ) ; zkCache = new ZooKeeperCache ( zkClient ) { } ; conf . addProperty ( ZooKeeperCache . ZK_CACHE_INSTANCE , zkCache ) ; } catch ( Exception e ) { LOG . error ( " Error ▁ creating ▁ zookeeper ▁ client " , e ) ; } } else { LOG . error ( " No ▁ zk ▁ configurations ▁ available " ) ; } } return zkCache ; }
saandrews/pulsar | @ Override public ArrayList < BookieSocketAddress > newEnsemble ( int ensembleSize , int writeQuorumSize , int ackQuorumSize , Map < String , byte [ ] > customMetadata , Set < BookieSocketAddress > excludeBookies ) throws BKNotEnoughBookiesException { Set < BookieSocketAddress > blacklistedBookies = getBlacklistedBookies ( ) ; if ( excludeBookies == null ) { excludeBookies = new HashSet < BookieSocketAddress > ( ) ; } excludeBookies . addAll ( blacklistedBookies ) ; return super . newEnsemble ( ensembleSize , writeQuorumSize , ackQuorumSize , customMetadata , excludeBookies ) ; }
saandrews/pulsar | @ Override public BookieSocketAddress replaceBookie ( int ensembleSize , int writeQuorumSize , int ackQuorumSize , Map < String , byte [ ] > customMetadata , Set < BookieSocketAddress > currentEnsemble , BookieSocketAddress bookieToReplace , Set < BookieSocketAddress > excludeBookies ) throws BKNotEnoughBookiesException { Set < BookieSocketAddress > blacklistedBookies = getBlacklistedBookies ( ) ; if ( excludeBookies == null ) { excludeBookies = new HashSet < BookieSocketAddress > ( ) ; } excludeBookies . addAll ( blacklistedBookies ) ; return super . replaceBookie ( ensembleSize , writeQuorumSize , ackQuorumSize , customMetadata , currentEnsemble , bookieToReplace , excludeBookies ) ; }
saandrews/pulsar | private Set < BookieSocketAddress > getBlacklistedBookies ( ) { Set < BookieSocketAddress > blacklistedBookies = new HashSet < BookieSocketAddress > ( ) ; try { if ( bookieMappingCache != null ) { Map < String , Map < BookieSocketAddress , BookieInfo > > allGroupsBookieMapping = bookieMappingCache . getData ( ZkBookieRackAffinityMapping . BOOKIE_INFO_ROOT_PATH , this ) . orElseThrow ( ( ) -> new KeeperException . NoNodeException ( ZkBookieRackAffinityMapping . BOOKIE_INFO_ROOT_PATH ) ) ; for ( String group : allGroupsBookieMapping . keySet ( ) ) { if ( ! isolationGroups . contains ( group ) ) { for ( BookieSocketAddress bookieAddress : allGroupsBookieMapping . get ( group ) . keySet ( ) ) { blacklistedBookies . add ( bookieAddress ) ; } } } } } catch ( Exception e ) { LOG . warn ( " Error ▁ getting ▁ bookie ▁ isolation ▁ info ▁ from ▁ zk : ▁ { } " , e . getMessage ( ) ) ; } return blacklistedBookies ; }
saandrews/pulsar | @ Override public Map < String , Map < BookieSocketAddress , BookieInfo > > deserialize ( String key , byte [ ] content ) throws Exception { LOG . info ( " Reloading ▁ the ▁ bookie ▁ isolation ▁ groups ▁ mapping ▁ cache . " ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Loading ▁ the ▁ bookie ▁ mappings ▁ with ▁ bookie ▁ info ▁ data : ▁ { } " , new String ( content ) ) ; } return jsonMapper . readValue ( content , typeRef ) ; }
thedevgeek/ANDROID-APPs | public DatabaseOpenHelper ( Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; }
thedevgeek/ANDROID-APPs | @ Override public void onCreate ( SQLiteDatabase db ) { Twitter . Status . class . getMethods ( ) ; String sql = String . format ( " CREATE ▁ table ▁ % s ▁ ( " + " % s ▁ integer ▁ NOT ▁ NULL ▁ primary ▁ key , " + " % s ▁ timestamp , ▁ % s ▁ TEXT , ▁ % s ▁ TEXT ) " , TABLE , C_ID , C_CREATED_AT , C_TEXT , C_USER ) ; Log . d ( TAG , " Created ▁ SQLite ▁ database : ▁ " + sql ) ; db . execSQL ( sql ) ; }
thedevgeek/ANDROID-APPs | @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( " DROP ▁ TABLE ▁ IF ▁ EXISTS ▁ " + TABLE + " ; " ) ; this . onCreate ( db ) ; }
NguyenAnhDuc/fpt-qa | public String getId ( ) { return id ; }
NguyenAnhDuc/fpt-qa | public void setId ( String id ) { this . id = id ; }
NguyenAnhDuc/fpt-qa | public String getName ( ) { return name ; }
NguyenAnhDuc/fpt-qa | public void setName ( String name ) { this . name = name ; }
omindra/schema_org_java_api | public Number getNumberOfRooms ( ) { return numberOfRooms ; }
omindra/schema_org_java_api | public void setNumberOfRooms ( Number numberOfRooms ) { this . numberOfRooms = numberOfRooms ; }
omindra/schema_org_java_api | public QuantitativeValue getOccupancy ( ) { return occupancy ; }
omindra/schema_org_java_api | public void setOccupancy ( QuantitativeValue occupancy ) { this . occupancy = occupancy ; }
LanternPowered/LanternServer | LanternBlockType ( ResourceKey key , Iterable < BlockTrait < ? > > blockTraits , TranslationProvider translationProvider , MutableBehaviorPipeline < Behavior > behaviorPipeline , @ Nullable BlockEntityProvider tileEntityProvider ) { super ( key ) ; this . translationProvider = translationProvider ; this . behaviorPipeline = behaviorPipeline ; this . tileEntityProvider = tileEntityProvider ; this . tickRandomly = ! behaviorPipeline . pipeline ( RandomTickBehavior . class ) . getBehaviors ( ) . isEmpty ( ) ; this . blockStateBase = new LanternBlockStateMap ( this , blockTraits ) ; this . defaultBlockState = this . blockStateBase . getBaseState ( ) ; this . isAir = key . getValue ( ) . contains ( " air " ) ; }
LanternPowered/LanternServer | void setItemType ( ItemType itemType ) { this . itemType = itemType ; }
LanternPowered/LanternServer | void setDefaultBlockState ( BlockState blockState ) { this . defaultBlockState = blockState ; }
LanternPowered/LanternServer | public Optional < BlockEntityProvider > getBlockEntityProvider ( ) { return Optional . ofNullable ( this . tileEntityProvider ) ; }
LanternPowered/LanternServer | public MutableBehaviorPipeline < Behavior > getPipeline ( ) { return this . behaviorPipeline ; }
LanternPowered/LanternServer | public LanternBlockStateMap getBlockStateBase ( ) { return this . blockStateBase ; }
LanternPowered/LanternServer | @ Override public Translation getTranslation ( ) { return this . translationProvider . get ( getDefaultState ( ) , null , null ) ; }
LanternPowered/LanternServer | public Translation getTranslation ( BlockState blockState ) { return this . translationProvider . get ( blockState , null , null ) ; }
LanternPowered/LanternServer | public BlockState getStateFromItemStack ( ItemStack itemStack ) { return this . getDefaultState ( ) ; }
LanternPowered/LanternServer | public PropertyProviderCollection getPropertyProviderCollection ( ) { return this . propertyProviderCollection ; }
LanternPowered/LanternServer | @ Override public Optional < ItemType > getItem ( ) { return Optional . ofNullable ( this . itemType ) ; }
LanternPowered/LanternServer | @ Override public String getName ( ) { return super . getName ( ) ; }
LanternPowered/LanternServer | @ Override public BlockState getDefaultState ( ) { return this . defaultBlockState ; }
LanternPowered/LanternServer | @ Override public Collection < BlockState > getAllBlockStates ( ) { return this . blockStateBase . getBlockStates ( ) ; }
LanternPowered/LanternServer | @ Override public boolean getTickRandomly ( ) { return this . tickRandomly ; }
LanternPowered/LanternServer | @ Override public void setTickRandomly ( boolean tickRandomly ) { this . tickRandomly = tickRandomly ; }
LanternPowered/LanternServer | @ Override public Collection < BlockTrait < ? > > getTraits ( ) { return getDefaultState ( ) . getTraits ( ) ; }
LanternPowered/LanternServer | @ Override public Optional < BlockTrait < ? > > getTrait ( String blockTrait ) { return getDefaultState ( ) . getTrait ( blockTrait ) ; }
LanternPowered/LanternServer | @ Override public BlockSoundGroup getSoundGroup ( ) { return this . blockSoundGroup ; }
LanternPowered/LanternServer | void setSoundGroup ( BlockSoundGroup blockSoundGroup ) { this . blockSoundGroup = blockSoundGroup ; }
LanternPowered/LanternServer | void setPropertyProviderCollection ( PropertyProviderCollection propertyProviderCollection ) { this . propertyProviderCollection = propertyProviderCollection ; }
LanternPowered/LanternServer | @ Nullable public BlockObjectProvider < AABB > getSelectionBoxProvider ( ) { return this . selectionBoxProvider ; }
LanternPowered/LanternServer | void setSelectionBoxProvider ( @ Nullable BlockObjectProvider < AABB > selectionBoxProvider ) { this . selectionBoxProvider = selectionBoxProvider ; }
LanternPowered/LanternServer | @ Nullable public BlockObjectProvider < Collection < AABB > > getCollisionBoxesProvider ( ) { return this . collisionBoxesProvider ; }
LanternPowered/LanternServer | void setCollisionBoxesProvider ( @ Nullable BlockObjectProvider < Collection < AABB > > boundingBoxProvider ) { this . collisionBoxesProvider = boundingBoxProvider ; }
LanternPowered/LanternServer | public boolean isAir ( ) { return this . isAir ; }
cjm0000000/mmt | @ Test public void testUser ( ) { User user = addUser ( ) ; assertNotEquals ( 0 , user . getUser_id ( ) ) ; Role role = addRole ( ) ; assertNotEquals ( 0 , role . getRole_id ( ) ) ; Customer cust = addCustomer ( ) ; assertNotEquals ( 0 , cust . getCust_id ( ) ) ; userMapper . addUserRole ( user . getUser_id ( ) , role . getRole_id ( ) , cust . getCust_id ( ) ) ; User u3 = userMapper . checkLogin ( user . getUsername ( ) , user . getPassword ( ) ) ; assertNotNull ( u3 ) ; assertEquals ( role . getRole_name ( ) , u3 . getRole_name ( ) ) ; assertEquals ( cust . getCust_name ( ) , u3 . getCust_name ( ) ) ; Role r2 = addRole ( ) ; Customer c2 = addCustomer ( ) ; userMapper . updateUserRole ( user . getUser_id ( ) , r2 . getRole_id ( ) , c2 . getCust_id ( ) ) ; User u4 = userMapper . getUserById ( user . getUser_id ( ) ) ; assertEquals ( r2 . getRole_name ( ) , u4 . getRole_name ( ) ) ; assertEquals ( c2 . getCust_name ( ) , u4 . getCust_name ( ) ) ; }
cjm0000000/mmt | @ Test public void getUserIdByName ( ) { User u1 = addUser ( ) ; assertNotNull ( u1 ) ; int user_id = userMapper . getUserIdByName ( u1 . getUsername ( ) ) ; assertEquals ( user_id , u1 . getUser_id ( ) ) ; }
cjm0000000/mmt | @ Test public void getUserById ( ) { User u1 = addUser ( ) ; assertNotNull ( u1 ) ; User u2 = userMapper . getUserById ( u1 . getUser_id ( ) ) ; assertNotNull ( u2 ) ; }
cjm0000000/mmt | @ Test public void deleteUser ( ) { User u1 = addUser ( ) ; User u2 = addUser ( ) ; User u3 = addUser ( ) ; String [ ] users = { String . valueOf ( u1 . getUser_id ( ) ) , String . valueOf ( u2 . getUser_id ( ) ) , String . valueOf ( u3 . getUser_id ( ) ) } ; userMapper . deleteUser ( users ) ; }
cjm0000000/mmt | @ Test public void getUserList ( ) { List < User > list = userMapper . getUserList ( 0 , 0 , null ) ; int cnt = userMapper . getUserCnt ( null ) ; assertEquals ( cnt , list . size ( ) ) ; }
cjm0000000/mmt | private User addUser ( ) { User user = new User ( ) ; user . setBz ( " 备注 " ) ; user . setIslock ( Status . UNAVAILABLE ) ; user . setPassword ( " password " ) ; user . setRole_id ( 10 ) ; user . setIdcard ( "330111190012123333" ) ; user . setMphone ( "18805718888" ) ; user . setStatus ( Status . AVAILABLE ) ; user . setUsername ( new Object ( ) . toString ( ) ) ; user . setXm ( " xm " ) ; userMapper . addUser ( user ) ; return user ; }
cjm0000000/mmt | private Role addRole ( ) { Role role = new Role ( ) ; role . setReloadable ( Status . AVAILABLE ) ; role . setRole_desc ( " role _ desc " ) ; role . setRole_name ( " ROLE _ NAME " ) ; role . setSort ( 1 ) ; role . setStatus ( Status . AVAILABLE ) ; roleMapper . addRole ( role ) ; return role ; }
cjm0000000/mmt | private Customer addCustomer ( ) { Customer cust = new Customer ( ) ; cust . setCust_name ( " LEMON ▁ TEST ▁ CUSTOMER " ) ; cust . setMemo ( " MEMO . . . " ) ; cust . setStatus ( Status . AVAILABLE ) ; customerMapper . addCustomer ( cust ) ; return cust ; }
CodeArcsInc/candlestack | private SQSCloudWatchMetric ( CloudWatchStatistic statistic , String serviceName , String commandName , String scriptFileName , String notes ) { this . statistic = statistic ; this . serviceName = serviceName ; this . commandName = commandName ; this . scriptFileName = scriptFileName ; this . notes = notes ; try { logsHost = GlobalAWSProperties . getLogsHost ( ) ; logsAuthToken = GlobalAWSProperties . getLogsAuthToken ( ) ; } catch ( CandlestackPropertiesException ignore ) { } }
CodeArcsInc/candlestack | @ Override public CloudWatchStatistic getStatistic ( ) { return statistic ; }
CodeArcsInc/candlestack | @ Override public String getServiceName ( ) { return serviceName ; }
CodeArcsInc/candlestack | @ Override public String getCommandName ( ) { return commandName ; }
CodeArcsInc/candlestack | @ Override public String getScriptFileName ( ) { return scriptFileName ; }
CodeArcsInc/candlestack | @ Override public Service getService ( String queueName , Set < String > contactGroups ) throws CandlestackPropertiesException { long warning = GlobalAWSProperties . getSQSCloudWatchMetricWarningLevel ( queueName , this ) ; long critical = GlobalAWSProperties . getSQSCloudWatchMetricCriticalLevel ( queueName , this ) ; String command = commandName + " ! " + MetricsReaderWriter . sanitizeString ( queueName ) + " ! " + warning + " ! " + critical ; String notificationPeriod = GlobalAWSProperties . getSQSServiceNotificationPeriod ( queueName ) ; return new Service ( serviceName , queueName , command , notes , notificationPeriod , contactGroups ) ; }
CodeArcsInc/candlestack | @ Override public Command getMonitorCommand ( String relativePathToMonitorResource ) { return new Command ( commandName , relativePathToMonitorResource + scriptFileName + " ▁ " + logsHost + " ▁ " + logsAuthToken + " ▁ $ ARG1 $ ▁ $ ARG2 $ ▁ $ ARG3 $ " ) ; }
CodeArcsInc/candlestack | @ Override public String getNamespace ( ) { return NAMESPACE ; }
CodeArcsInc/candlestack | @ Override public String getName ( ) { return name ( ) ; }
code2358/jcdk-wrapper | @ Before public void init ( ) throws IOException { configurationFile = Files . createTempFile ( " " , " " ) ; jcdk2Installation = new Jcdk2Installation ( JCDK2_PATH ) ; jcdk3Installation = new Jcdk3Installation ( JCDK3_PATH ) ; jcdkInstallation = jcdk3Installation ; jcdkWrongPath = Files . createTempDirectory ( " " ) ; jcdkInstallationWrongPath = new Jcdk3Installation ( jcdkWrongPath ) ; jcdkWrapper = new JcdkWrapperImpl ( jcdkInstallation , configurationFile ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdk2Success ( ) throws Exception { String command = JcdkWrapperImpl . generateCommand ( jcdk2Installation , configurationFile ) ; assertThat ( command , equalTo ( String . format ( " java ▁ - cp ▁ % s ▁ " + " - Djc . home = % s ▁ % s ▁ - config ▁ % s " , jcdk2Installation . getConverterClasspath ( ) , jcdk2Installation . getBasePath ( ) , jcdk2Installation . getConverterClass ( ) , configurationFile ) ) ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdk3Success ( ) throws Exception { String command = JcdkWrapperImpl . generateCommand ( jcdk3Installation , configurationFile ) ; assertThat ( command , equalTo ( String . format ( " java ▁ - cp ▁ % s ▁ " + " - Djc . home = % s ▁ % s ▁ - config ▁ % s " , jcdk3Installation . getConverterClasspath ( ) , jcdk3Installation . getBasePath ( ) , jcdk3Installation . getConverterClass ( ) , configurationFile ) ) ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdkWithoutConfigurationFailure ( ) throws Exception { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Provided ▁ configuration ▁ path ▁ is ▁ not ▁ valid : ▁ " + configurationFile ) ; Files . delete ( configurationFile ) ; JcdkWrapperImpl . generateCommand ( jcdkInstallation , configurationFile ) ; }
code2358/jcdk-wrapper | @ Test public void generateCommandJcdkWithWrongJcdkPathFailure ( ) throws Exception { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Provided ▁ JCDK ▁ path ▁ is ▁ not ▁ valid : ▁ " + jcdkWrongPath ) ; JcdkWrapperImpl . generateCommand ( jcdkInstallationWrongPath , configurationFile ) ; }
code2358/jcdk-wrapper | @ Test public void convertCannotFindClassFailure ( ) throws Exception { exception . expect ( ConvertionException . class ) ; exception . expectMessage ( " Error ▁ during ▁ execution ▁ of ▁ JCDK ▁ converter ▁ ( see ▁ output ▁ for ▁ details ) . " ) ; jcdkWrapper . convert ( ) ; }
code2358/jcdk-wrapper | @ Test public void checkoutAfterConvertFailureSuccess ( ) throws Exception { try { jcdkWrapper . convert ( ) ; } catch ( ConvertionException e ) { } assertThat ( jcdkWrapper . getJcdkOutput ( ) , startsWith ( " Error : ▁ Could ▁ not ▁ find ▁ or ▁ load ▁ main ▁ class ▁ " ) ) ; }
code2358/jcdk-wrapper | @ Test public void emptyOutputSuccess ( ) throws Exception { assertThat ( jcdkWrapper . getJcdkOutput ( ) , nullValue ( ) ) ; }
WilliamRen/gretty | public Greeting ( String content ) { this . content = content ; }
WilliamRen/gretty | public String getContent ( ) { return content ; }
alexTrifonov/atrifonov | public AutoModel ( ) { }
alexTrifonov/atrifonov | public AutoModel ( String model , MakeCar makeCar ) { this . model = model ; this . makeCar = makeCar ; }
alexTrifonov/atrifonov | public int getId ( ) { return id ; }
alexTrifonov/atrifonov | public String getModel ( ) { return model ; }
alexTrifonov/atrifonov | public void setId ( int id ) { this . id = id ; }
alexTrifonov/atrifonov | public void setModel ( String model ) { this . model = model ; }
alexTrifonov/atrifonov | public MakeCar getMakeCar ( ) { return makeCar ; }
alexTrifonov/atrifonov | public void setMakeCar ( MakeCar makeCar ) { this . makeCar = makeCar ; }
alexTrifonov/atrifonov | @ Override public String toString ( ) { return model ; }
alexTrifonov/atrifonov | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; AutoModel autoModel = ( AutoModel ) o ; if ( id != autoModel . id ) return false ; if ( model != null ? ! model . equals ( autoModel . model ) : autoModel . model != null ) return false ; return makeCar != null ? makeCar . equals ( autoModel . makeCar ) : autoModel . makeCar == null ; }
alexTrifonov/atrifonov | @ Override public int hashCode ( ) { int result = id ; result = 31 * result + ( model != null ? model . hashCode ( ) : 0 ) ; result = 31 * result + ( makeCar != null ? makeCar . hashCode ( ) : 0 ) ; return result ; }
PrakashGoulla/selendroid | public FingerView ( Context context , AttributeSet attrs ) { super ( context , attrs ) ; paint = new Paint ( ) ; paint . setColor ( Color . WHITE ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeWidth ( 12 ) ; pointerPathMap = new HashMap < Integer , Path > ( ) ; }
PrakashGoulla/selendroid | @ Override public boolean onTouchEvent ( MotionEvent event ) { int idx = event . getActionIndex ( ) ; int id = event . getPointerId ( idx ) ; switch ( event . getActionMasked ( ) ) { case MotionEvent . ACTION_DOWN : case MotionEvent . ACTION_POINTER_DOWN : Path pth = new Path ( ) ; pth . moveTo ( event . getX ( idx ) , event . getY ( idx ) ) ; pointerPathMap . put ( id , pth ) ; break ; case MotionEvent . ACTION_MOVE : for ( Map . Entry < Integer , Path > entry : pointerPathMap . entrySet ( ) ) { idx = event . findPointerIndex ( entry . getKey ( ) ) ; entry . getValue ( ) . lineTo ( event . getX ( idx ) , event . getY ( idx ) ) ; } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_POINTER_UP : pointerPathMap . remove ( id ) ; break ; } invalidate ( ) ; return true ; }
PrakashGoulla/selendroid | @ Override protected void onDraw ( Canvas canvas ) { for ( Path p : pointerPathMap . values ( ) ) { canvas . drawPath ( p , paint ) ; } }
Stargator/testdrivenexamples | public List < Segment > parseSegments ( String template ) { List < Segment > segments = new ArrayList < > ( ) ; collectSegments ( segments , template ) ; return segments ; }
Stargator/testdrivenexamples | private void collectSegments ( List < Segment > segments , String template ) { Pattern pattern = Pattern . compile ( " \\ $ \\ { [ ^ } ] * \\ }
Stargator/testdrivenexamples | while ( matcher . find ( ) ) { String strToEval = template . substring ( matcher . start ( ) , matcher . end ( ) ) ; if ( isVariable ( strToEval ) ) { segments . add ( new Variable ( strToEval ) ) ; } else { segments . add ( new PlainText ( strToEval ) ) ; } }
Stargator/testdrivenexamples | private void addEmptyStringIfTemplateWasEmpty ( List < Segment > segments ) { if ( segments . isEmpty ( ) ) { segments . add ( new PlainText ( " " ) ) ; } }
Stargator/testdrivenexamples | private boolean isVariable ( String segment ) { return segment . startsWith ( varStarting ) && segment . endsWith ( varEnding ) ; }
hizel/lorsource | @ RequestMapping ( value = " / commit . jsp " , method = RequestMethod . GET ) public ModelAndView showCommitForm ( HttpServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ ModelAttribute ( " form " ) EditTopicRequest form ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; if ( message . isCommited ( ) ) { throw new UserErrorException ( " Сообщение ▁ уже ▁ подтверждено " ) ; } PreparedTopic preparedMessage = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; if ( ! preparedMessage . getSection ( ) . isPremoderated ( ) ) { throw new UserErrorException ( " Раздел ▁ не ▁ премодерируемый " ) ; } ModelAndView mv = prepareModel ( preparedMessage , form , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) ) ; mv . getModel ( ) . put ( " commit " , true ) ; return mv ; }
hizel/lorsource | @ RequestMapping ( value = " / edit . jsp " , method = RequestMethod . GET ) public ModelAndView showEditForm ( ServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ ModelAttribute ( " form " ) EditTopicRequest form ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; User user = tmpl . getCurrentUser ( ) ; PreparedTopic preparedMessage = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; if ( ! permissionService . isEditable ( preparedMessage , user ) && ! permissionService . isTagsEditable ( preparedMessage , user ) ) { throw new AccessViolationException ( " это ▁ сообщение ▁ нельзя ▁ править " ) ; } return prepareModel ( preparedMessage , form , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) ) ; }
hizel/lorsource | private ModelAndView prepareModel ( PreparedTopic preparedTopic , EditTopicRequest form , User currentUser , Profile profile ) throws PollNotFoundException { Map < String , Object > params = new HashMap < > ( ) ; final Topic message = preparedTopic . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedTopic ) ; Group group = preparedTopic . getGroup ( ) ; params . put ( " group " , group ) ; params . put ( " groups " , groupDao . getGroups ( preparedTopic . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; TopicMenu topicMenu = prepareService . getTopicMenu ( preparedTopic , currentUser , profile , true ) ; params . put ( " topicMenu " , topicMenu ) ; List < EditHistoryRecord > editInfoList = editHistoryService . getEditInfo ( message . getId ( ) , EditHistoryObjectTypeEnum . TOPIC ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; ImmutableSet < User > editors = editHistoryService . getEditorUsers ( message , editInfoList ) ; form . setEditorBonus ( editors . stream ( ) . collect ( Collectors . toMap ( User :: getId , u -> 0 ) ) ) ; params . put ( " editors " , editors ) ; } params . put ( " commit " , false ) ; if ( group . isLinksAllowed ( ) ) { form . setLinktext ( message . getLinktext ( ) ) ; form . setUrl ( message . getUrl ( ) ) ; } form . setTitle ( StringEscapeUtils . unescapeHtml4 ( message . getTitle ( ) ) ) ; form . setMsg ( msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ) ; if ( message . getSectionId ( ) == Section . SECTION_NEWS ) { form . setMinor ( message . isMinor ( ) ) ; } if ( ! preparedTopic . getTags ( ) . isEmpty ( ) ) { form . setTags ( TagRef . names ( preparedTopic . getTags ( ) ) ) ; } if ( preparedTopic . getSection ( ) . isPollPostAllowed ( ) ) { Poll poll = pollDao . getPollByTopicId ( message . getId ( ) ) ; form . setPoll ( PollVariant . toMap ( poll . getVariants ( ) ) ) ; form . setMultiselect ( poll . isMultiSelect ( ) ) ; } params . put ( " imagepost " , permissionService . isImagePostingAllowed ( preparedTopic . getSection ( ) , currentUser ) ) ; return new ModelAndView ( " edit " , params ) ; }
hizel/lorsource | @ ModelAttribute ( " ipBlockInfo " ) private IPBlockInfo loadIPBlock ( HttpServletRequest request ) { return ipBlockDao . getBlockInfo ( request . getRemoteAddr ( ) ) ; }
hizel/lorsource | @ RequestMapping ( value = " / edit . jsp " , method = RequestMethod . POST ) public ModelAndView edit ( HttpServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @ RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId , @ Valid @ ModelAttribute ( " form " ) EditTopicRequest form , Errors errors , @ ModelAttribute ( " ipBlockInfo " ) IPBlockInfo ipBlockInfo ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; final Topic message = messageDao . getById ( msgid ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; Group group = preparedTopic . getGroup ( ) ; User user = tmpl . getCurrentUser ( ) ; IPBlockDao . checkBlockIP ( ipBlockInfo , errors , user ) ; boolean tagsEditable = permissionService . isTagsEditable ( preparedTopic , user ) ; boolean editable = permissionService . isEditable ( preparedTopic , user ) ; if ( ! editable && ! tagsEditable ) { throw new AccessViolationException ( " это ▁ сообщение ▁ нельзя ▁ править " ) ; } params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedTopic ) ; params . put ( " group " , group ) ; params . put ( " topicMenu " , prepareService . getTopicMenu ( preparedTopic , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , true ) ) ; params . put ( " groups " , groupDao . getGroups ( preparedTopic . getSection ( ) ) ) ; if ( editable ) { String title = request . getParameter ( " title " ) ; if ( title == null || title . trim ( ) . isEmpty ( ) ) { throw new BadInputException ( " заголовок ▁ сообщения ▁ не ▁ может ▁ быть ▁ пустым " ) ; } } boolean preview = request . getParameter ( " preview " ) != null ; if ( preview ) { params . put ( " info " , " Предпросмотр " ) ; } boolean publish = request . getParameter ( " publish " ) != null ; List < EditHistoryRecord > editInfoList = editHistoryService . getEditInfo ( message . getId ( ) , EditHistoryObjectTypeEnum . TOPIC ) ; if ( ! editInfoList . isEmpty ( ) ) { EditHistoryRecord editHistoryRecord = editInfoList . get ( 0 ) ; params . put ( " editInfo " , editHistoryRecord ) ; if ( lastEdit == null || editHistoryRecord . getEditdate ( ) . getTime ( ) != lastEdit ) { errors . reject ( null , " Сообщение ▁ было ▁ отредактировано ▁ независимо " ) ; } } boolean commit = request . getParameter ( " commit " ) != null ; if ( commit ) { user . checkCommit ( ) ; if ( message . isCommited ( ) ) { throw new BadInputException ( " сообщение ▁ уже ▁ подтверждено " ) ; } } params . put ( " commit " , ! message . isCommited ( ) && preparedTopic . getSection ( ) . isPremoderated ( ) && user . isModerator ( ) ) ; Topic newMsg = new Topic ( group , message , form , publish ) ; boolean modified = false ; if ( ! message . getTitle ( ) . equals ( newMsg . getTitle ( ) ) ) { modified = true ; } if ( form . getMsg ( ) != null ) { String oldText = msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ; if ( ! oldText . equals ( form . getMsg ( ) ) ) { modified = true ; } } if ( message . getLinktext ( ) == null ) { if ( newMsg . getLinktext ( ) != null ) { modified = true ; } } else if ( ! message . getLinktext ( ) . equals ( newMsg . getLinktext ( ) ) ) { modified = true ; } if ( group . isLinksAllowed ( ) ) { if ( message . getUrl ( ) == null ) { if ( newMsg . getUrl ( ) != null ) { modified = true ; } } else if ( ! message . getUrl ( ) . equals ( newMsg . getUrl ( ) ) ) { modified = true ; } } UploadedImagePreview imagePreview = null ; if ( permissionService . isImagePostingAllowed ( preparedTopic . getSection ( ) , user ) ) { if ( permissionService . isTopicPostingAllowed ( group , user ) ) { File image = imageService . processUploadImage ( request ) ; imagePreview = imageService . processUpload ( user , request . getSession ( ) , image , errors ) ; if ( imagePreview != null ) { modified = true ; } } } if ( ! editable && modified ) { throw new AccessViolationException ( " нельзя ▁ править ▁ это ▁ сообщение , ▁ только ▁ теги " ) ; } if ( form . getMinor ( ) != null && ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " вы ▁ не ▁ можете ▁ менять ▁ статус ▁ новости " ) ; } List < String > newTags = null ; if ( form . getTags ( ) != null ) { newTags = TagName . parseAndSanitizeTags ( form . getTags ( ) ) ; } if ( changeGroupId != null ) { if ( message . getGroupId ( ) != changeGroupId ) { Group changeGroup = groupDao . getGroup ( changeGroupId ) ; int section = message . getSectionId ( ) ; if ( changeGroup . getSectionId ( ) != section ) { throw new AccessViolationException ( " Can ' t ▁ move ▁ topics ▁ between ▁ sections " ) ; } } } Poll newPoll = null ; if ( preparedTopic . getSection ( ) . isPollPostAllowed ( ) && form . getPoll ( ) != null && tmpl . isModeratorSession ( ) ) { newPoll = buildNewPoll ( message , form ) ; } String newText ; if ( form . getMsg ( ) != null ) { newText = form . getMsg ( ) ; } else { newText = msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ; } if ( form . getEditorBonus ( ) != null ) { ImmutableSet < Integer > editors = editHistoryService . getEditors ( message , editInfoList ) ; form . getEditorBonus ( ) . keySet ( ) . stream ( ) . filter ( userid -> ! editors . contains ( userid ) ) . forEach ( userid -> errors . reject ( " editorBonus " , " некорректный ▁ корректор ? ! " ) ) ; } if ( ! preview && ! errors . hasErrors ( ) && ipBlockInfo . isCaptchaRequired ( ) ) { captcha . checkCaptcha ( request , errors ) ; } if ( ! preview && ! errors . hasErrors ( ) ) { boolean changed = topicService . updateAndCommit ( newMsg , message , user , newTags , newText , commit , changeGroupId , form . getBonus ( ) , newPoll != null ? newPoll . getVariants ( ) : null , form . isMultiselect ( ) , form . getEditorBonus ( ) , imagePreview ) ; if ( changed || commit || publish ) { if ( ! newMsg . isDraft ( ) ) { searchQueueSender . updateMessage ( newMsg . getId ( ) , true ) ; } if ( ! publish || ! preparedTopic . getSection ( ) . isPremoderated ( ) ) { return new ModelAndView ( new RedirectView ( TopicLinkBuilder . baseLink ( message ) . forceLastmod ( ) . build ( ) ) ) ; } else { params . put ( " moderated " , true ) ; params . put ( " url " , TopicLinkBuilder . baseLink ( message ) . forceLastmod ( ) . build ( ) ) ; return new ModelAndView ( " add - done - moderated " , params ) ; } } else { errors . reject ( null , " Нет ▁ изменений " ) ; } } params . put ( " newMsg " , newMsg ) ; Image imageObject = null ; if ( imagePreview != null ) { imageObject = new Image ( 0 , 0 , " gallery / preview / " + imagePreview . mainFile ( ) . getName ( ) ) ; } params . put ( " newPreparedMessage " , prepareService . prepareTopicPreview ( newMsg , newTags != null ? TagService . namesToRefs ( newTags ) : null , newPoll , request . isSecure ( ) , newText , imageObject ) ) ; return new ModelAndView ( " edit " , params ) ; }
hizel/lorsource | private Poll buildNewPoll ( Topic message , EditTopicRequest form ) throws PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( message . getId ( ) ) ; List < PollVariant > newVariants = new ArrayList < > ( ) ; for ( PollVariant v : poll . getVariants ( ) ) { String label = form . getPoll ( ) . get ( v . getId ( ) ) ; if ( ! Strings . isNullOrEmpty ( label ) ) { newVariants . add ( new PollVariant ( v . getId ( ) , label ) ) ; } } for ( String label : form . getNewPoll ( ) ) { if ( ! Strings . isNullOrEmpty ( label ) ) { newVariants . add ( new PollVariant ( 0 , label ) ) ; } } return poll . createNew ( newVariants ) ; }
hizel/lorsource | @ InitBinder ( " form " ) public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( editTopicRequestValidator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; }
elimu-ai/webapp | @ RequestMapping ( method = RequestMethod . GET ) public String handleGetRequest ( HttpServletRequest request ) { logger . info ( " handleGetRequest " ) ; JSONArray videosJsonArray = new JSONArray ( ) ; for ( Video video : videoDao . readAllOrdered ( ) ) { VideoGson videoGson = JpaToGsonConverter . getVideoGson ( video ) ; String json = new Gson ( ) . toJson ( videoGson ) ; videosJsonArray . put ( new JSONObject ( json ) ) ; } String jsonResponse = videosJsonArray . toString ( ) ; logger . info ( " jsonResponse : ▁ " + jsonResponse ) ; return jsonResponse ; }
guonl/DesignPattern | public String getServiceId ( ) { return serviceId ; }
guonl/DesignPattern | public void setServiceId ( String serviceId ) { this . serviceId = serviceId ; }
guonl/DesignPattern | public String getRequestType ( ) { return requestType ; }
guonl/DesignPattern | public void setRequestType ( String requestType ) { this . requestType = requestType ; }
guonl/DesignPattern | public Map < String , Object > getAttributes ( ) { return attributes ; }
guonl/DesignPattern | public void setAttributes ( Map < String , Object > attributes ) { this . attributes = attributes ; }
anishek/hive | KEY ( String s ) { this . keyName = s ; }
anishek/hive | @ Override public String toString ( ) { return keyName ; }
anishek/hive | public ReplicationSpec ( ASTNode node ) { if ( node != null ) { if ( isApplicable ( node ) ) { init ( node ) ; return ; } else { for ( int i = 1 ; i < node . getChildCount ( ) ; ++ i ) { ASTNode child = ( ASTNode ) node . getChild ( i ) ; if ( isApplicable ( child ) ) { init ( child ) ; return ; } } } } }
anishek/hive | public ReplicationSpec ( ) { this ( ( ASTNode ) null ) ; }
anishek/hive | public ReplicationSpec ( String fromId , String toId ) { this ( true , false , fromId , toId , false , false ) ; }
anishek/hive | public ReplicationSpec ( boolean isInReplicationScope , boolean isMetadataOnly , String eventReplicationState , String currentReplicationState , boolean isNoop , boolean isReplace ) { this . isInReplicationScope = isInReplicationScope ; this . isMetadataOnly = isMetadataOnly ; this . eventId = eventReplicationState ; this . currStateId = currentReplicationState ; this . isNoop = isNoop ; this . isReplace = isReplace ; this . specType = Type . DEFAULT ; }
anishek/hive | public ReplicationSpec ( Function < String , String > keyFetcher ) { String scope = keyFetcher . apply ( ReplicationSpec . KEY . REPL_SCOPE . toString ( ) ) ; this . isInReplicationScope = false ; this . isMetadataOnly = false ; this . specType = Type . DEFAULT ; if ( scope != null ) { if ( scope . equalsIgnoreCase ( " metadata " ) ) { this . isMetadataOnly = true ; this . isInReplicationScope = true ; } else if ( scope . equalsIgnoreCase ( " all " ) ) { this . isInReplicationScope = true ; } } this . eventId = keyFetcher . apply ( ReplicationSpec . KEY . EVENT_ID . toString ( ) ) ; this . currStateId = keyFetcher . apply ( ReplicationSpec . KEY . CURR_STATE_ID . toString ( ) ) ; this . isNoop = Boolean . parseBoolean ( keyFetcher . apply ( ReplicationSpec . KEY . NOOP . toString ( ) ) ) ; this . isReplace = Boolean . parseBoolean ( keyFetcher . apply ( ReplicationSpec . KEY . IS_REPLACE . toString ( ) ) ) ; this . validWriteIdList = keyFetcher . apply ( ReplicationSpec . KEY . VALID_WRITEID_LIST . toString ( ) ) ; this . validTxnList = keyFetcher . apply ( KEY . VALID_TXN_LIST . toString ( ) ) ; }
anishek/hive | public boolean allowReplacement ( String currReplState , String replacementReplState ) { if ( ( currReplState == null ) || ( currReplState . isEmpty ( ) ) ) { return true ; } if ( ( replacementReplState == null ) || ( replacementReplState . isEmpty ( ) ) ) { return false ; } long currReplStateLong = Long . parseLong ( currReplState . replaceAll ( " \\ D " , " " ) ) ; long replacementReplStateLong = Long . parseLong ( replacementReplState . replaceAll ( " \\ D " , " " ) ) ; if ( specType == Type . IMPORT ) { return ( currReplStateLong <= replacementReplStateLong ) ; } else { return ( currReplStateLong < replacementReplStateLong ) ; } }
anishek/hive | public boolean allowReplacementInto ( Map < String , String > params ) { return allowReplacement ( getLastReplicatedStateFromParameters ( params ) , getCurrentReplicationState ( ) ) ; }
anishek/hive | public boolean allowEventReplacementInto ( Map < String , String > params ) { return allowReplacement ( getLastReplicatedStateFromParameters ( params ) , getReplicationState ( ) ) ; }
anishek/hive | public Predicate < Partition > allowEventReplacementInto ( ) { return new Predicate < Partition > ( ) { @ Override public boolean apply ( @ Nullable Partition partition ) { if ( partition == null ) { return false ; } return ( allowEventReplacementInto ( partition . getParameters ( ) ) ) ; } } ; }
anishek/hive | private void init ( ASTNode node ) { isInReplicationScope = true ; eventId = PlanUtils . stripQuotes ( node . getChild ( 0 ) . getText ( ) ) ; if ( ( node . getChildCount ( ) > 1 ) && node . getChild ( 1 ) . getText ( ) . toLowerCase ( ) . equals ( " metadata " ) ) { isMetadataOnly = true ; try { if ( Long . parseLong ( eventId ) >= 0 ) { currStateId = eventId ; } } catch ( Exception ex ) { } } }
anishek/hive | public Type getReplSpecType ( ) { return this . specType ; }
anishek/hive | public void setReplSpecType ( Type specType ) { this . specType = specType ; }
anishek/hive | public boolean isInReplicationScope ( ) { return isInReplicationScope ; }
anishek/hive | public boolean isMetadataOnly ( ) { return isMetadataOnly ; }
anishek/hive | public void setIsMetadataOnly ( boolean isMetadataOnly ) { this . isMetadataOnly = isMetadataOnly ; }
anishek/hive | public boolean isMetadataOnlyForExternalTables ( ) { return isMetadataOnlyForExternalTables ; }
anishek/hive | public void setMetadataOnlyForExternalTables ( boolean metadataOnlyForExternalTables ) { isMetadataOnlyForExternalTables = metadataOnlyForExternalTables ; }
anishek/hive | public boolean isReplace ( ) { return isReplace ; }
anishek/hive | public void setIsReplace ( boolean isReplace ) { this . isReplace = isReplace ; }
anishek/hive | public String getReplicationState ( ) { return eventId ; }
anishek/hive | public String getCurrentReplicationState ( ) { return currStateId ; }
anishek/hive | public void setCurrentReplicationState ( String currStateId ) { this . currStateId = currStateId ; }
anishek/hive | public boolean isNoop ( ) { return isNoop ; }
anishek/hive | public void setNoop ( boolean isNoop ) { this . isNoop = isNoop ; }
anishek/hive | public String getValidWriteIdList ( ) { return validWriteIdList ; }
anishek/hive | public void setValidWriteIdList ( String validWriteIdList ) { this . validWriteIdList = validWriteIdList ; }
anishek/hive | public String getValidTxnList ( ) { return validTxnList ; }
anishek/hive | public void setValidTxnList ( String validTxnList ) { this . validTxnList = validTxnList ; }
anishek/hive | public boolean isTransactionalTableDump ( ) { return ( validWriteIdList != null ) ; }
anishek/hive | public String get ( KEY key ) { switch ( key ) { case REPL_SCOPE : switch ( getScope ( ) ) { case MD_ONLY : return " metadata " ; case REPL : return " all " ; case NO_REPL : return " none " ; } case EVENT_ID : return getReplicationState ( ) ; case CURR_STATE_ID : return getCurrentReplicationState ( ) ; case NOOP : return String . valueOf ( isNoop ( ) ) ; case IS_REPLACE : return String . valueOf ( isReplace ( ) ) ; case VALID_WRITEID_LIST : return getValidWriteIdList ( ) ; case VALID_TXN_LIST : return getValidTxnList ( ) ; } return null ; }
anishek/hive | public SCOPE getScope ( ) { if ( isInReplicationScope ( ) ) { if ( isMetadataOnly ( ) ) { return SCOPE . MD_ONLY ; } else { return SCOPE . REPL ; } } else { return SCOPE . NO_REPL ; } }
anishek/hive | public boolean isMigratingToTxnTable ( ) { return isMigratingToTxnTable ; }
anishek/hive | public void setMigratingToTxnTable ( ) { isMigratingToTxnTable = true ; }
anishek/hive | public boolean isMigratingToExternalTable ( ) { return isMigratingToExternalTable ; }
anishek/hive | public void setMigratingToExternalTable ( ) { isMigratingToExternalTable = true ; }
anishek/hive | public boolean needDupCopyCheck ( ) { return needDupCopyCheck ; }
anishek/hive | public void setNeedDupCopyCheck ( boolean isFirstIncPending ) { this . needDupCopyCheck = isFirstIncPending ; }
anishek/hive | public boolean isRepl ( ) { return isRepl ; }
anishek/hive | public void setRepl ( boolean repl ) { isRepl = repl ; }
aaneja/Twitter | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; binding = DataBindingUtil . setContentView ( this , R . layout . activity_compose_tweet ) ; }
aaneja/Twitter | public void onCancelClick ( View view ) { setResult ( RESULT_CANCELED ) ; finish ( ) ; }
aaneja/Twitter | public void onPublishTweetClick ( View view ) { final String tweetText = binding . etTweetText . getText ( ) . toString ( ) ; twitterClient . postTweet ( tweetText , new JsonHttpResponseHandler ( ) { @ Override public void onSuccess ( int statusCode , Header [ ] headers , JSONObject response ) { final Tweet postedTweet = new Tweet ( response ) ; Log . d ( " POSTTWEET " , " New ▁ tweet ▁ id : " + postedTweet . getId ( ) ) ; Intent data = new Intent ( ) ; data . putExtra ( NEW_TWEET , Parcels . wrap ( postedTweet ) ) ; setResult ( RESULT_OK , data ) ; finish ( ) ; } @ Override public void onFailure ( int statusCode , Header [ ] headers , Throwable throwable , JSONObject errorResponse ) { Toast . makeText ( ComposeTweetActivity . this , String . format ( " Error ▁ posting ▁ tweet ▁ : ▁ StatusCode ▁ : ▁ % d , ▁ ExceptionText : ▁ % s " , statusCode , throwable . getMessage ( ) ) , Toast . LENGTH_LONG ) ; super . onFailure ( statusCode , headers , throwable , errorResponse ) ; } } ) ; }
dcoraboeuf/ontrack | @ When ( " I ▁ create ▁ a ▁ $ name ▁ project ▁ with ▁ description ▁ \" $ description \" " ) public void create_project ( String name , String description ) { generalSteps . open_home_page ( ) ; projectSteps . create_project ( name , description ) ; }
dcoraboeuf/ontrack | @ When ( " I ▁ close ▁ the ▁ project ▁ page " ) public void project_page_close ( ) { projectSteps . project_page_close ( ) ; }
dcoraboeuf/ontrack | @ Then ( " I ▁ am ▁ on ▁ the ▁ $ name ▁ project ▁ page " ) public void project_page_check ( String name ) { projectSteps . project_page_check ( name ) ; }
jaltekruse/parquet-mr | public MessageType ( String name , Type ... fields ) { super ( Repetition . REPEATED , name , fields ) ; }
jaltekruse/parquet-mr | public MessageType ( String name , List < Type > fields ) { super ( Repetition . REPEATED , name , fields ) ; }
jaltekruse/parquet-mr | @ Override public void accept ( TypeVisitor visitor ) { visitor . visit ( this ) ; }
jaltekruse/parquet-mr | @ Override public void writeToStringBuilder ( StringBuilder sb , String indent ) { sb . append ( " message ▁ " ) . append ( getName ( ) ) . append ( getOriginalType ( ) == null ? " " : " ▁ ( " + getOriginalType ( ) + " ) " ) . append ( " ▁ { \n " ) ; membersDisplayString ( sb , " ▁ ▁ " ) ; sb . append ( " } \n " ) ; }
jaltekruse/parquet-mr | public int getMaxRepetitionLevel ( String ... path ) { return getMaxRepetitionLevel ( path , 0 ) - 1 ; }
jaltekruse/parquet-mr | public int getMaxDefinitionLevel ( String ... path ) { return getMaxDefinitionLevel ( path , 0 ) - 1 ; }
jaltekruse/parquet-mr | public Type getType ( String ... path ) { return getType ( path , 0 ) ; }
jaltekruse/parquet-mr | public ColumnDescriptor getColumnDescription ( String [ ] path ) { int maxRep = getMaxRepetitionLevel ( path ) ; int maxDef = getMaxDefinitionLevel ( path ) ; PrimitiveTypeName type = getType ( path ) . asPrimitiveType ( ) . getPrimitiveTypeName ( ) ; return new ColumnDescriptor ( path , type , maxRep , maxDef ) ; }
jaltekruse/parquet-mr | public List < String [ ] > getPaths ( ) { return this . getPaths ( 0 ) ; }
jaltekruse/parquet-mr | public List < ColumnDescriptor > getColumns ( ) { List < String [ ] > paths = this . getPaths ( 0 ) ; List < ColumnDescriptor > columns = new ArrayList < ColumnDescriptor > ( paths . size ( ) ) ; for ( String [ ] path : paths ) { columns . add ( new ColumnDescriptor ( path , getType ( path ) . asPrimitiveType ( ) . getPrimitiveTypeName ( ) , getMaxRepetitionLevel ( path ) , getMaxDefinitionLevel ( path ) ) ) ; } return columns ; }
jaltekruse/parquet-mr | @ Override public void checkContains ( Type subType ) { if ( ! ( subType instanceof MessageType ) ) { throw new InvalidRecordException ( subType + " ▁ found : ▁ expected ▁ " + this ) ; } super . checkContains ( subType ) ; }
jaltekruse/parquet-mr | public < T > T convertWith ( TypeConverter < T > converter ) { final ArrayList < GroupType > path = new ArrayList < GroupType > ( ) ; path . add ( this ) ; return converter . convertMessageType ( this , convertChildren ( path , converter ) ) ; }
jaltekruse/parquet-mr | public boolean containsPath ( String [ ] path ) { return containsPath ( path , 0 ) ; }
moghaddam/cas | public ISOStandardDateFormat ( ) { super ( DATE_FORMAT , TimeZone . getDefault ( ) , Locale . getDefault ( ) ) ; }
moghaddam/cas | public String getCurrentDateAndTime ( ) { return format ( new Date ( ) ) ; }
moghaddam/cas | public String format ( final DateTime dt ) { return format ( dt . toDate ( ) ) ; }
liufeiit/itmarry | public ApkCacheHelper ( Context paramContext ) { context = paramContext ; init ( paramContext ) ; }
liufeiit/itmarry | private void init ( Context paramContext ) { if ( init ) { return ; } init = true ; dbHelper = new DbHelper ( this . context ) ; apkCacheRepo = new HashMap < String , ApkCache > ( ) ; Cursor localCursor = dbHelper . getApkCacheCursor ( ) ; if ( localCursor != null ) { localCursor . moveToFirst ( ) ; } while ( true ) { if ( localCursor . isAfterLast ( ) ) { localCursor . close ( ) ; return ; } ApkCache localApkCache = new ApkCache ( ) ; localApkCache . appName = localCursor . getString ( localCursor . getColumnIndex ( " appName " ) ) ; localApkCache . pkgName = localCursor . getString ( localCursor . getColumnIndex ( " pkg " ) ) ; byte [ ] arrayOfByte = localCursor . getBlob ( localCursor . getColumnIndex ( " icon " ) ) ; if ( arrayOfByte != null ) { localApkCache . icon = new BitmapDrawable ( paramContext . getResources ( ) , BitmapFactory . decodeByteArray ( arrayOfByte , 0 , arrayOfByte . length ) ) ; } apkCacheRepo . put ( localApkCache . pkgName , localApkCache ) ; localCursor . moveToNext ( ) ; } }
liufeiit/itmarry | public ApkCache load ( String paramString ) { init ( context ) ; ApkCache localApkCache = apkCacheRepo . get ( paramString ) ; return localApkCache ; }
liufeiit/itmarry | public boolean save ( String packageName , Drawable paramDrawable , String apkInfoName ) { init ( context ) ; ApkCache localApkCache = new ApkCache ( ) ; localApkCache . appName = apkInfoName ; localApkCache . pkgName = packageName ; localApkCache . icon = paramDrawable ; if ( dbHelper . saveApkCache ( localApkCache ) != - 1L ) { apkCacheRepo . put ( packageName , localApkCache ) ; return true ; } return false ; }
pepstock-org/Charba | ArrayImageList ( ArrayImage array ) { if ( array == null ) { this . array = new ArrayImage ( ) ; } else { this . array = array ; } }
pepstock-org/Charba | public ArrayImageList ( ) { this ( null ) ; }
pepstock-org/Charba | @ Override ArrayImage getArray ( ) { return array ; }
pepstock-org/Charba | public void addAll ( Img ... values ) { if ( values != null && values . length > 0 ) { for ( Img val : values ) { add ( val ) ; } } }
pepstock-org/Charba | @ Override public boolean add ( Img element ) { if ( element != null ) { array . push ( element ) ; return true ; } return false ; }
pepstock-org/Charba | @ Override public boolean addAll ( Collection < ? extends Img > collection ) { boolean modified = collection != null && ! collection . isEmpty ( ) ; if ( modified ) { Iterator < ? extends Img > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { modified = modified && add ( iter . next ( ) ) ; } } return modified ; }
pepstock-org/Charba | @ Override public boolean retainAll ( Collection < ? > collection ) { boolean modified = collection != null && ! collection . isEmpty ( ) ; if ( modified ) { List < Img > contained = new ArrayList < > ( ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { Img value = get ( i ) ; if ( ! collection . contains ( value ) ) { contained . add ( value ) ; } } if ( ! contained . isEmpty ( ) ) { for ( Img toRemove : contained ) { modified = modified && remove ( toRemove ) ; } } } return modified ; }
pepstock-org/Charba | @ Override public void clear ( ) { array . clear ( ) ; }
pepstock-org/Charba | @ Override public Img get ( int index ) { if ( checkRange ( index ) ) { return array . get ( index ) ; } return null ; }
pepstock-org/Charba | @ Override public Img set ( int index , Img element ) { if ( element != null && checkRange ( index ) ) { Img old = array . get ( index ) ; array . set ( index , element ) ; return old ; } return null ; }
pepstock-org/Charba | @ Override public void add ( int index , Img element ) { if ( element != null ) { array . insertAt ( index , element ) ; } }
pepstock-org/Charba | @ Override public Img remove ( int index ) { if ( checkRange ( index ) ) { return array . remove ( index ) ; } return Undefined . IMAGE_ELEMENT ; }
pepstock-org/Charba | @ Override public int indexOf ( Object object ) { if ( object instanceof Img ) { Img value = ( Img ) object ; return array . indexOf ( value ) ; } return AbstractArrayList . NOT_FOUND ; }
pepstock-org/Charba | @ Override public int lastIndexOf ( Object object ) { if ( object instanceof Img ) { Img value = ( Img ) object ; return array . lastIndexOf ( value ) ; } return AbstractArrayList . NOT_FOUND ; }
pepstock-org/Charba | @ Override public Object [ ] toArray ( ) { Object [ ] toArray = new Object [ array . length ( ) ] ; for ( int i = 0 ; i < array . length ( ) ; i ++ ) { toArray [ i ] = array . get ( i ) ; } return toArray ; }
rkistner/binarization | public int findThreshold ( int [ ] h ) { int n = h . length ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total += h [ i ] ; } double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = ( double ) h [ i ] / total ; } double max = Double . MIN_VALUE ; int best = 0 ; for ( int T = 1 ; T < n ; T ++ ) { double sum1a = 0 ; double sum1b = 0 ; for ( int i = 0 ; i < T ; i ++ ) { if ( p [ i ] > 0 ) { sum1a += p [ i ] ; sum1b += p [ i ] * Math . log ( p [ i ] ) ; } } double sum2a = 0 ; double sum2b = 0 ; for ( int i = T ; i < n ; i ++ ) { if ( p [ i ] > 0 ) { sum2a += p [ i ] ; sum2b += p [ i ] * Math . log ( p [ i ] ) ; } } double theTotal = Math . log ( sum1a ) + Math . log ( sum2a ) - sum1b / sum1a - sum2b / sum2a ; if ( theTotal > max ) { max = theTotal ; best = T ; } } return best ; }
rkistner/binarization | public String toString ( ) { return " Kapur " ; }
nikgoodley-ibboost/jsparklines | public XYDataPoint ( double x , double y ) { this . x = x ; this . y = y ; }
nikgoodley-ibboost/jsparklines | public XYDataPoint ( double x , double y , boolean compareBasedOnFirstDataPoint ) { this . x = x ; this . y = y ; this . compareBasedOnFirstDataPoint = compareBasedOnFirstDataPoint ; }
nikgoodley-ibboost/jsparklines | public double getX ( ) { return x ; }
nikgoodley-ibboost/jsparklines | public void setX ( double x ) { this . x = x ; }
nikgoodley-ibboost/jsparklines | public double getY ( ) { return y ; }
nikgoodley-ibboost/jsparklines | public void setY ( double y ) { this . y = y ; }
nikgoodley-ibboost/jsparklines | public String toString ( ) { return " " + Util . roundDouble ( x , 2 ) ; }
nikgoodley-ibboost/jsparklines | public int compareTo ( XYDataPoint o ) { if ( compareBasedOnFirstDataPoint ) { return Double . compare ( this . x , o . x ) ; } else { return Double . compare ( this . x + this . y , o . x + o . y ) ; } }
gemmellr/qpid-proton-j | @ Test public void testCompareToWithSameObject ( ) { TaskImpl task = new TaskImpl ( 1000 , 1 ) ; Assert . assertEquals ( 0 , task . compareTo ( task ) ) ; }
gemmellr/qpid-proton-j | @ Test public void testCompareToWithDifferentDeadlines ( ) { TaskImpl task1 = new TaskImpl ( 1000 , 1 ) ; TaskImpl task2 = new TaskImpl ( 2000 , 2 ) ; Assert . assertTrue ( task1 . compareTo ( task2 ) < 0 ) ; Assert . assertTrue ( task2 . compareTo ( task1 ) > 0 ) ; }
gemmellr/qpid-proton-j | @ Test public void testCompareToWithSameDeadlines ( ) { int deadline = 1000 ; TaskImpl task1 = new TaskImpl ( deadline , 1 ) ; TaskImpl task2 = new TaskImpl ( deadline , 2 ) ; Assert . assertTrue ( " Expected ▁ task1 ▁ to ▁ order ▁ ' less ' ▁ due ▁ to ▁ being ▁ created ▁ first " , task1 . compareTo ( task2 ) < 0 ) ; Assert . assertTrue ( " Expected ▁ task2 ▁ to ▁ order ▁ ' greater ' ▁ due ▁ to ▁ being ▁ created ▁ second " , task1 . compareTo ( task2 ) < 0 ) ; Assert . assertTrue ( task2 . compareTo ( task1 ) > 0 ) ; }
weiwenqiang/GitHub | public CupcakeDetector ( Context context ) { final ViewConfiguration configuration = ViewConfiguration . get ( context ) ; mMinimumVelocity = configuration . getScaledMinimumFlingVelocity ( ) ; mTouchSlop = configuration . getScaledTouchSlop ( ) ; }
weiwenqiang/GitHub | float getActiveX ( MotionEvent ev ) { return ev . getX ( ) ; }
weiwenqiang/GitHub | float getActiveY ( MotionEvent ev ) { return ev . getY ( ) ; }
weiwenqiang/GitHub | public boolean isScaling ( ) { return false ; }
weiwenqiang/GitHub | @ Override public boolean onTouchEvent ( MotionEvent ev ) { switch ( ev . getAction ( ) ) { case MotionEvent . ACTION_DOWN : { mVelocityTracker = VelocityTracker . obtain ( ) ; mVelocityTracker . addMovement ( ev ) ; mLastTouchX = getActiveX ( ev ) ; mLastTouchY = getActiveY ( ev ) ; mIsDragging = false ; break ; } case MotionEvent . ACTION_MOVE : { final float x = getActiveX ( ev ) ; final float y = getActiveY ( ev ) ; final float dx = x - mLastTouchX , dy = y - mLastTouchY ; if ( ! mIsDragging ) { mIsDragging = ( float ) Math . sqrt ( ( dx * dx ) + ( dy * dy ) ) >= mTouchSlop ; } if ( mIsDragging ) { mListener . onDrag ( dx , dy ) ; mLastTouchX = x ; mLastTouchY = y ; if ( null != mVelocityTracker ) { mVelocityTracker . addMovement ( ev ) ; } } break ; } case MotionEvent . ACTION_CANCEL : { if ( null != mVelocityTracker ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } break ; } case MotionEvent . ACTION_UP : { if ( mIsDragging ) { if ( null != mVelocityTracker ) { mLastTouchX = getActiveX ( ev ) ; mLastTouchY = getActiveY ( ev ) ; mVelocityTracker . addMovement ( ev ) ; mVelocityTracker . computeCurrentVelocity ( 1000 ) ; final float vX = mVelocityTracker . getXVelocity ( ) , vY = mVelocityTracker . getYVelocity ( ) ; if ( Math . max ( Math . abs ( vX ) , Math . abs ( vY ) ) >= mMinimumVelocity ) { mListener . onFling ( mLastTouchX , mLastTouchY , - vX , - vY ) ; } } } if ( null != mVelocityTracker ) { mVelocityTracker . recycle ( ) ; mVelocityTracker = null ; } break ; } } return true ; }
weiwenqiang/GitHub | public EclairDetector ( Context context ) { super ( context ) ; }
weiwenqiang/GitHub | @ Override float getActiveX ( MotionEvent ev ) { try { return ev . getX ( mActivePointerIndex ) ; } catch ( Exception e ) { return ev . getX ( ) ; } }
weiwenqiang/GitHub | @ Override float getActiveY ( MotionEvent ev ) { try { return ev . getY ( mActivePointerIndex ) ; } catch ( Exception e ) { return ev . getY ( ) ; } }
weiwenqiang/GitHub | @ Override public boolean onTouchEvent ( MotionEvent ev ) { final int action = ev . getAction ( ) ; switch ( action & MotionEvent . ACTION_MASK ) { case MotionEvent . ACTION_DOWN : mActivePointerId = ev . getPointerId ( 0 ) ; break ; case MotionEvent . ACTION_CANCEL : case MotionEvent . ACTION_UP : mActivePointerId = INVALID_POINTER_ID ; break ; case MotionEvent . ACTION_POINTER_UP : final int pointerIndex = ( ev . getAction ( ) & MotionEvent . ACTION_POINTER_INDEX_MASK ) >> MotionEvent . ACTION_POINTER_INDEX_SHIFT ; final int pointerId = ev . getPointerId ( pointerIndex ) ; if ( pointerId == mActivePointerId ) { final int newPointerIndex = pointerIndex == 0 ? 1 : 0 ; mActivePointerId = ev . getPointerId ( newPointerIndex ) ; mLastTouchX = ev . getX ( newPointerIndex ) ; mLastTouchY = ev . getY ( newPointerIndex ) ; } break ; } mActivePointerIndex = ev . findPointerIndex ( mActivePointerId != INVALID_POINTER_ID ? mActivePointerId : 0 ) ; return super . onTouchEvent ( ev ) ; }
weiwenqiang/GitHub | private final OnScaleGestureListener mScaleListener = new OnScaleGestureListener ( ) { @ Override public boolean onScale ( ScaleGestureDetector detector ) { mListener . onScale ( detector . getScaleFactor ( ) , detector . getFocusX ( ) , detector . getFocusY ( ) ) ; return true ; } @ Override public boolean onScaleBegin ( ScaleGestureDetector detector ) { return true ; } @ Override public void onScaleEnd ( ScaleGestureDetector detector ) { } }
weiwenqiang/GitHub | public FroyoDetector ( Context context ) { super ( context ) ; mDetector = new ScaleGestureDetector ( context , mScaleListener ) ; }
weiwenqiang/GitHub | @ Override public boolean isScaling ( ) { return mDetector . isInProgress ( ) ; }
weiwenqiang/GitHub | @ Override public boolean onTouchEvent ( MotionEvent ev ) { mDetector . onTouchEvent ( ev ) ; return super . onTouchEvent ( ev ) ; }
derekhiggins/ovirt-engine | public AuditLogableBase ( ) { }
derekhiggins/ovirt-engine | public AuditLogableBase ( final NGuid vdsId ) { mVdsId = vdsId ; }
derekhiggins/ovirt-engine | public AuditLogableBase ( final NGuid vdsId , final Guid vmId ) { this ( vdsId ) ; mVmId = vmId ; }
derekhiggins/ovirt-engine | public NGuid getUserId ( ) { if ( mUserId . equals ( Guid . Empty ) && getCurrentUser ( ) != null ) { mUserId = getCurrentUser ( ) . getUserId ( ) ; } return mUserId ; }
derekhiggins/ovirt-engine | public void setUserId ( final NGuid value ) { mUserId = value . getValue ( ) ; }
derekhiggins/ovirt-engine | public String getUserName ( ) { if ( StringUtils . isEmpty ( mUserName ) && getCurrentUser ( ) != null ) { mUserName = getCurrentUser ( ) . getUserName ( ) ; } return mUserName ; }
derekhiggins/ovirt-engine | public void setUserName ( final String value ) { mUserName = value ; }
derekhiggins/ovirt-engine | public IVdcUser getCurrentUser ( ) { return mVdcUser ; }
derekhiggins/ovirt-engine | public void setCurrentUser ( final IVdcUser value ) { mVdcUser = value ; }
derekhiggins/ovirt-engine | public Guid getVmTemplateId ( ) { return getVmTemplateIdRef ( ) != null ? getVmTemplateIdRef ( ) . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public void setVmTemplateId ( final Guid value ) { mVmTemplateId = value ; }
derekhiggins/ovirt-engine | public NGuid getVmTemplateIdRef ( ) { if ( mVmTemplateId == null && getVmTemplate ( ) != null ) { mVmTemplateId = getVmTemplate ( ) . getId ( ) ; } return mVmTemplateId ; }
derekhiggins/ovirt-engine | public String getVmTemplateName ( ) { if ( mVmTemplateName == null && getVmTemplate ( ) != null ) { mVmTemplateName = getVmTemplate ( ) . getname ( ) ; } return mVmTemplateName ; }
derekhiggins/ovirt-engine | protected void setVmTemplateName ( final String value ) { mVmTemplateName = value ; }
derekhiggins/ovirt-engine | public Guid getVmId ( ) { return getVmIdRef ( ) != null ? getVmIdRef ( ) . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public void setVmId ( final Guid value ) { mVmId = value ; }
derekhiggins/ovirt-engine | public String getSnapshotName ( ) { return privateSnapshotName ; }
derekhiggins/ovirt-engine | public void setSnapshotName ( final String value ) { privateSnapshotName = value ; }
derekhiggins/ovirt-engine | public NGuid getVmIdRef ( ) { if ( mVmId == null && getVm ( ) != null ) { mVmId = getVm ( ) . getId ( ) ; } return mVmId ; }
derekhiggins/ovirt-engine | public String getVmName ( ) { if ( mVmName == null && getVm ( ) != null ) { mVmName = getVm ( ) . getvm_name ( ) ; } return mVmName ; }
derekhiggins/ovirt-engine | protected void setVmName ( final String value ) { mVmName = value ; }
derekhiggins/ovirt-engine | public NGuid getVdsIdRef ( ) { if ( mVdsId == null && getVds ( ) != null ) { mVdsId = getVds ( ) . getId ( ) ; } return mVdsId ; }
derekhiggins/ovirt-engine | protected void setVdsIdRef ( final NGuid value ) { mVdsId = value ; }
derekhiggins/ovirt-engine | public Guid getVdsId ( ) { return mVdsId != null ? mVdsId . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public void setVdsId ( final Guid value ) { mVdsId = value ; }
derekhiggins/ovirt-engine | public String getVdsName ( ) { if ( mVdsName == null && getVds ( ) != null ) { mVdsName = getVds ( ) . getvds_name ( ) ; } return mVdsName ; }
derekhiggins/ovirt-engine | protected void setVdsName ( final String value ) { mVdsName = value ; }
derekhiggins/ovirt-engine | public Guid getQuotaId ( ) { return getQuotaIdRef ( ) != null ? getQuotaIdRef ( ) . getValue ( ) : Guid . Empty ; }
derekhiggins/ovirt-engine | public Guid getQuotaIdRef ( ) { if ( quotaId == null && getQuota ( ) != null ) { quotaId = getQuota ( ) . getId ( ) ; } return quotaId ; }
derekhiggins/ovirt-engine | public void setQuotaId ( final Guid value ) { quotaId = value ; }
derekhiggins/ovirt-engine | public String getQuotaName ( ) { if ( quotaName == null && getQuota ( ) != null ) { quotaName = getQuota ( ) . getQuotaName ( ) ; } return quotaName ; }
derekhiggins/ovirt-engine | protected void setQuotaName ( final String value ) { quotaName = value ; }
derekhiggins/ovirt-engine | public storage_domains getStorageDomain ( ) { if ( _storageDomain == null && getStorageDomainId ( ) != null ) { if ( _storagePoolId != null && getStoragePool ( ) != null ) { _storageDomain = getStorageDomainDAO ( ) . getForStoragePool ( getStorageDomainId ( ) . getValue ( ) , getStoragePool ( ) . getId ( ) ) ; } if ( _storageDomain == null ) { final List < storage_domains > storageDomainList = getStorageDomainDAO ( ) . getAllForStorageDomain ( getStorageDomainId ( ) . getValue ( ) ) ; if ( storageDomainList . size ( ) != 0 ) { _storageDomain = storageDomainList . get ( 0 ) ; for ( final storage_domains storageDomainFromList : storageDomainList ) { if ( storageDomainFromList . getstatus ( ) != null && storageDomainFromList . getstatus ( ) == StorageDomainStatus . Active ) { _storageDomain = storageDomainFromList ; break ; } } } } } return _storageDomain ; }
derekhiggins/ovirt-engine | public void setStorageDomain ( final storage_domains value ) { _storageDomain = value ; }
derekhiggins/ovirt-engine | public NGuid getStorageDomainId ( ) { if ( _storageDomain != null ) { return _storageDomain . getId ( ) ; } return _storageDomainId ; }
derekhiggins/ovirt-engine | public void setStorageDomainId ( final NGuid value ) { _storageDomainId = value ; }
derekhiggins/ovirt-engine | public String getStorageDomainName ( ) { if ( getStorageDomain ( ) != null ) { return getStorageDomain ( ) . getstorage_name ( ) ; } return " " ; }
derekhiggins/ovirt-engine | public storage_pool getStoragePool ( ) { if ( _storagePool == null && getStoragePoolId ( ) != null && ! Guid . Empty . equals ( getStoragePoolId ( ) ) ) { _storagePool = getStoragePoolDAO ( ) . get ( getStoragePoolId ( ) . getValue ( ) ) ; } return _storagePool ; }
derekhiggins/ovirt-engine | public void setStoragePool ( final storage_pool value ) { _storagePool = value ; }
derekhiggins/ovirt-engine | public NGuid getStoragePoolId ( ) { if ( _storagePoolId == null ) { if ( _storagePool != null ) { _storagePoolId = _storagePool . getId ( ) ; } else if ( getStorageDomain ( ) != null ) { _storagePoolId = getStorageDomain ( ) . getstorage_pool_id ( ) ; } } return _storagePoolId ; }
derekhiggins/ovirt-engine | public void setStoragePoolId ( final NGuid value ) { _storagePoolId = value ; }
derekhiggins/ovirt-engine | public String getStoragePoolName ( ) { if ( getStoragePool ( ) != null ) { return getStoragePool ( ) . getname ( ) ; } return " " ; }
derekhiggins/ovirt-engine | public AuditLogType getAuditLogTypeValue ( ) { return AuditLogType . UNASSIGNED ; }
derekhiggins/ovirt-engine | protected Quota getQuota ( ) { if ( quota == null && quotaId != null ) { try { quota = getQuotaDAO ( ) . getById ( getQuotaId ( ) ) ; } catch ( final RuntimeException e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ quota ▁ { 0 } \n { 1 } " , quotaId , e . getMessage ( ) ) ; } } return quota ; }
derekhiggins/ovirt-engine | protected void setQuota ( final Quota value ) { quota = value ; quotaName = null ; }
derekhiggins/ovirt-engine | protected VDS getVds ( ) { if ( mVds == null && ( mVdsId != null || ( getVm ( ) != null && getVm ( ) . getrun_on_vds ( ) != null ) ) ) { if ( mVdsId == null ) { mVdsId = new Guid ( getVm ( ) . getrun_on_vds ( ) . toString ( ) ) ; } try { mVds = getVdsDAO ( ) . get ( getVdsId ( ) ) ; } catch ( final RuntimeException e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ vds ▁ { 0 } \n { 1 } " , mVdsId , e . getMessage ( ) ) ; } } return mVds ; }
derekhiggins/ovirt-engine | protected void setVds ( final VDS value ) { mVds = value ; mVdsName = null ; }
derekhiggins/ovirt-engine | public VM getVm ( ) { if ( mVm == null && mVmId != null && ! mVmId . equals ( Guid . Empty ) ) { try { mVm = getVmDAO ( ) . get ( mVmId . getValue ( ) ) ; if ( mVm != null ) { mVm . setInterfaces ( getVmNetworkInterfaceDAO ( ) . getAllForVm ( mVmId . getValue ( ) ) ) ; } } catch ( final Exception e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ vm ▁ { 0 } " , mVmId ) ; log . debug ( e ) ; } } return mVm ; }
derekhiggins/ovirt-engine | protected void setVm ( final VM value ) { mVm = value ; }
derekhiggins/ovirt-engine | public VmTemplate getVmTemplate ( ) { if ( mVmTemplate == null && ( mVmTemplateId != null || getVm ( ) != null ) ) { mVmTemplate = getVmTemplateDAO ( ) . get ( mVmTemplateId != null ? getVmTemplateId ( ) : getVm ( ) . getvmt_guid ( ) ) ; } return mVmTemplate ; }
derekhiggins/ovirt-engine | protected void setVmTemplate ( final VmTemplate value ) { mVmTemplate = value ; }
derekhiggins/ovirt-engine | public Guid getVdsGroupId ( ) { if ( mVdsGroupId != null ) { return mVdsGroupId ; } else if ( getVdsGroup ( ) != null ) { mVdsGroupId = getVdsGroup ( ) . getId ( ) ; return mVdsGroupId ; } else { return Guid . Empty ; } }
derekhiggins/ovirt-engine | public void setVdsGroupId ( final Guid value ) { mVdsGroupId = value ; }
derekhiggins/ovirt-engine | protected VDSGroup getVdsGroup ( ) { if ( mVdsGroup == null ) { if ( mVdsGroupId != null ) { mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } else if ( getVds ( ) != null ) { mVdsGroupId = getVds ( ) . getvds_group_id ( ) ; mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } else if ( getVm ( ) != null ) { mVdsGroupId = getVm ( ) . getvds_group_id ( ) ; mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } } return mVdsGroup ; }
derekhiggins/ovirt-engine | protected void setVdsGroup ( final VDSGroup value ) { mVdsGroup = value ; }
derekhiggins/ovirt-engine | public String getVdsGroupName ( ) { if ( getVdsGroup ( ) != null ) { return getVdsGroup ( ) . getname ( ) ; } return " " ; }
derekhiggins/ovirt-engine | protected void log ( ) { final Transaction transaction = TransactionSupport . suspend ( ) ; try { try { AuditLogDirector . log ( this ) ; } catch ( final RuntimeException ex ) { log . errorFormat ( " Error ▁ during ▁ log ▁ command : ▁ { 0 } . ▁ Exception ▁ { 1 } " , getClass ( ) . getName ( ) , ex ) ; } } finally { TransactionSupport . resume ( transaction ) ; } }
derekhiggins/ovirt-engine | public void DefaultLog ( ) { }
derekhiggins/ovirt-engine | public void AddCustomValue ( final String name , final String value ) { customValues . put ( name . toLowerCase ( ) , value ) ; }
derekhiggins/ovirt-engine | public void AddCustomValue ( CustomAuditLogKeys key , final String value ) { AddCustomValue ( key . name ( ) , value ) ; }
derekhiggins/ovirt-engine | public void AppendCustomValue ( final String name , final String value , final String separator ) { final String key = name . toLowerCase ( ) ; String newValue = value ; if ( customValues . containsKey ( key ) ) { newValue = String . format ( " % 1 $ s % 2 $ s % 3 $ s " , customValues . get ( key ) , separator , value ) ; } customValues . put ( name . toLowerCase ( ) , newValue ) ; }
derekhiggins/ovirt-engine | public Map < String , String > getCustomValues ( ) { return customValues ; }
derekhiggins/ovirt-engine | @ Override protected String getKey ( ) { return getAuditLogTypeValue ( ) . toString ( ) ; }
derekhiggins/ovirt-engine | public String GetCustomValue ( final String name ) { if ( customValues . containsKey ( name ) ) { return customValues . get ( name ) ; } return " " ; }
derekhiggins/ovirt-engine | public void setCorrelationId ( String correlationId ) { this . correlationId = correlationId ; }
derekhiggins/ovirt-engine | public String getCorrelationId ( ) { return correlationId ; }
derekhiggins/ovirt-engine | public void setJobId ( NGuid jobId ) { this . jobId = jobId ; }
derekhiggins/ovirt-engine | public NGuid getJobId ( ) { return jobId ; }
derekhiggins/ovirt-engine | public boolean isInternalExecution ( ) { return isInternalExecution ; }
derekhiggins/ovirt-engine | public void setInternalExecution ( boolean isInternalExecution ) { this . isInternalExecution = isInternalExecution ; }
derekhiggins/ovirt-engine | public NGuid getGlusterVolumeId ( ) { return glusterVolumeId ; }
derekhiggins/ovirt-engine | public void setGlusterVolumeId ( NGuid value ) { glusterVolumeId = value ; }
derekhiggins/ovirt-engine | public String getGlusterVolumeName ( ) { if ( glusterVolumeName == null && getGlusterVolume ( ) != null ) { glusterVolumeName = getGlusterVolume ( ) . getName ( ) ; } return glusterVolumeName ; }
derekhiggins/ovirt-engine | public void setGlusterVolumeName ( String value ) { glusterVolumeName = value ; }
derekhiggins/ovirt-engine | protected GlusterVolumeEntity getGlusterVolume ( ) { if ( glusterVolume == null && glusterVolumeId != null ) { glusterVolume = getGlusterVolumeDao ( ) . getById ( glusterVolumeId . getValue ( ) ) ; } return glusterVolume ; }
derekhiggins/ovirt-engine | public GlusterVolumeDao getGlusterVolumeDao ( ) { return getDbFacade ( ) . getGlusterVolumeDao ( ) ; }
derekhiggins/ovirt-engine | public StorageDomainDAO getStorageDomainDAO ( ) { return getDbFacade ( ) . getStorageDomainDAO ( ) ; }
derekhiggins/ovirt-engine | public StoragePoolDAO getStoragePoolDAO ( ) { return getDbFacade ( ) . getStoragePoolDAO ( ) ; }
derekhiggins/ovirt-engine | public VdsDAO getVdsDAO ( ) { return getDbFacade ( ) . getVdsDAO ( ) ; }
derekhiggins/ovirt-engine | public QuotaDAO getQuotaDAO ( ) { return getDbFacade ( ) . getQuotaDAO ( ) ; }
derekhiggins/ovirt-engine | public VmTemplateDAO getVmTemplateDAO ( ) { return getDbFacade ( ) . getVmTemplateDAO ( ) ; }
derekhiggins/ovirt-engine | protected VmDAO getVmDAO ( ) { return getDbFacade ( ) . getVmDAO ( ) ; }
derekhiggins/ovirt-engine | public VmStaticDAO getVmStaticDAO ( ) { return getDbFacade ( ) . getVmStaticDAO ( ) ; }
derekhiggins/ovirt-engine | protected VmStatisticsDAO getVmStatisticsDAO ( ) { return getDbFacade ( ) . getVmStatisticsDAO ( ) ; }
derekhiggins/ovirt-engine | public VdsGroupDAO getVdsGroupDAO ( ) { return getDbFacade ( ) . getVdsGroupDAO ( ) ; }
derekhiggins/ovirt-engine | public RoleDAO getRoleDao ( ) { return getDbFacade ( ) . getRoleDAO ( ) ; }
derekhiggins/ovirt-engine | public RoleGroupMapDAO getRoleGroupMapDAO ( ) { return getDbFacade ( ) . getRoleGroupMapDAO ( ) ; }
derekhiggins/ovirt-engine | public PermissionDAO getPermissionDAO ( ) { return getDbFacade ( ) . getPermissionDAO ( ) ; }
derekhiggins/ovirt-engine | public DbUserDAO getDbUserDAO ( ) { return getDbFacade ( ) . getDbUserDAO ( ) ; }
derekhiggins/ovirt-engine | public AdGroupDAO getAdGroupDAO ( ) { return getDbFacade ( ) . getAdGroupDAO ( ) ; }
derekhiggins/ovirt-engine | protected VmNetworkInterfaceDAO getVmNetworkInterfaceDAO ( ) { return getDbFacade ( ) . getVmNetworkInterfaceDAO ( ) ; }
derekhiggins/ovirt-engine | protected NetworkClusterDAO getNetworkClusterDAO ( ) { return getDbFacade ( ) . getNetworkClusterDAO ( ) ; }
derekhiggins/ovirt-engine | protected NetworkDAO getNetworkDAO ( ) { return getDbFacade ( ) . getNetworkDAO ( ) ; }
derekhiggins/ovirt-engine | protected DbFacade getDbFacade ( ) { return DbFacade . getInstance ( ) ; }
melthaw/spring-backend-boilerplate | @ Override public void onApplicationEvent ( ApplicationFailedEvent event ) { if ( StringUtils . isEmpty ( webhookConfigurationProperties . getUrl ( ) ) ) { return ; } webhookClient . sendMessage ( webhookConfigurationProperties . getUrl ( ) , String . format ( " % s ▁ startup ▁ failed . ▁ The ▁ cause ▁ is ▁ % s " , getAppName ( ) , event . getException ( ) . getMessage ( ) ) , event . getException ( ) . getMessage ( ) ) ; }
markharwood/elasticsearch | public Version getVersion ( ) { return this . version ; }
markharwood/elasticsearch | public StreamOutput setVersion ( Version version ) { this . version = version ; return this ; }
markharwood/elasticsearch | public long position ( ) throws IOException { throw new UnsupportedOperationException ( ) ; }
markharwood/elasticsearch | public void seek ( long position ) throws IOException { throw new UnsupportedOperationException ( ) ; }
markharwood/elasticsearch | public void writeBytes ( byte [ ] b ) throws IOException { writeBytes ( b , 0 , b . length ) ; }
markharwood/elasticsearch | public void writeBytes ( byte [ ] b , int length ) throws IOException { writeBytes ( b , 0 , length ) ; }
markharwood/elasticsearch | public void writeByteArray ( byte [ ] b ) throws IOException { writeVInt ( b . length ) ; writeBytes ( b , 0 , b . length ) ; }
markharwood/elasticsearch | public void writeBytesReference ( @ Nullable BytesReference bytes ) throws IOException { if ( bytes == null ) { writeVInt ( 0 ) ; return ; } writeVInt ( bytes . length ( ) ) ; bytes . writeTo ( this ) ; }
markharwood/elasticsearch | public void writeBytesRef ( BytesRef bytes ) throws IOException { if ( bytes == null ) { writeVInt ( 0 ) ; return ; } writeVInt ( bytes . length ) ; write ( bytes . bytes , bytes . offset , bytes . length ) ; }
markharwood/elasticsearch | public final void writeShort ( short v ) throws IOException { writeByte ( ( byte ) ( v >> 8 ) ) ; writeByte ( ( byte ) v ) ; }
markharwood/elasticsearch | public void writeInt ( int i ) throws IOException { writeByte ( ( byte ) ( i >> 24 ) ) ; writeByte ( ( byte ) ( i >> 16 ) ) ; writeByte ( ( byte ) ( i >> 8 ) ) ; writeByte ( ( byte ) i ) ; }
markharwood/elasticsearch | public void writeVInt ( int i ) throws IOException { while ( ( i & ~ 0x7F ) != 0 ) { writeByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i >>>= 7 ; } writeByte ( ( byte ) i ) ; }
markharwood/elasticsearch | public void writeLong ( long i ) throws IOException { writeInt ( ( int ) ( i >> 32 ) ) ; writeInt ( ( int ) i ) ; }
markharwood/elasticsearch | public void writeVLong ( long i ) throws IOException { assert i >= 0 ; while ( ( i & ~ 0x7F ) != 0 ) { writeByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; i >>>= 7 ; } writeByte ( ( byte ) i ) ; }
markharwood/elasticsearch | public void writeZLong ( long i ) throws IOException { long value = BitUtil . zigZagEncode ( i ) ; while ( ( value & 0xFFFFFFFFFFFFFF80L ) != 0L ) { writeByte ( ( byte ) ( ( value & 0x7F ) | 0x80 ) ) ; value >>>= 7 ; } writeByte ( ( byte ) ( value & 0x7F ) ) ; }
markharwood/elasticsearch | public void writeOptionalString ( @ Nullable String str ) throws IOException { if ( str == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeString ( str ) ; } }
markharwood/elasticsearch | public void writeOptionalVInt ( @ Nullable Integer integer ) throws IOException { if ( integer == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeVInt ( integer ) ; } }
markharwood/elasticsearch | public void writeOptionalText ( @ Nullable Text text ) throws IOException { if ( text == null ) { writeInt ( - 1 ) ; } else { writeText ( text ) ; } }
markharwood/elasticsearch | public void writeText ( Text text ) throws IOException { if ( ! text . hasBytes ( ) ) { final String string = text . string ( ) ; spare . copyChars ( string ) ; writeInt ( spare . length ( ) ) ; write ( spare . bytes ( ) , 0 , spare . length ( ) ) ; } else { BytesReference bytes = text . bytes ( ) ; writeInt ( bytes . length ( ) ) ; bytes . writeTo ( this ) ; } }
markharwood/elasticsearch | public void writeString ( String str ) throws IOException { int charCount = str . length ( ) ; writeVInt ( charCount ) ; int c ; for ( int i = 0 ; i < charCount ; i ++ ) { c = str . charAt ( i ) ; if ( c <= 0x007F ) { writeByte ( ( byte ) c ) ; } else if ( c > 0x07FF ) { writeByte ( ( byte ) ( 0xE0 | c >> 12 & 0x0F ) ) ; writeByte ( ( byte ) ( 0x80 | c >> 6 & 0x3F ) ) ; writeByte ( ( byte ) ( 0x80 | c >> 0 & 0x3F ) ) ; } else { writeByte ( ( byte ) ( 0xC0 | c >> 6 & 0x1F ) ) ; writeByte ( ( byte ) ( 0x80 | c >> 0 & 0x3F ) ) ; } } }
markharwood/elasticsearch | public void writeFloat ( float v ) throws IOException { writeInt ( Float . floatToIntBits ( v ) ) ; }
markharwood/elasticsearch | public void writeDouble ( double v ) throws IOException { writeLong ( Double . doubleToLongBits ( v ) ) ; }
markharwood/elasticsearch | public void writeBoolean ( boolean b ) throws IOException { writeByte ( b ? ONE : ZERO ) ; }
markharwood/elasticsearch | public void writeOptionalBoolean ( @ Nullable Boolean b ) throws IOException { if ( b == null ) { writeByte ( TWO ) ; } else { writeByte ( b ? ONE : ZERO ) ; } }
markharwood/elasticsearch | @ Override public void write ( int b ) throws IOException { writeByte ( ( byte ) b ) ; }
markharwood/elasticsearch | @ Override public void write ( byte [ ] b , int off , int len ) throws IOException { writeBytes ( b , off , len ) ; }
markharwood/elasticsearch | public void writeStringArray ( String [ ] array ) throws IOException { writeVInt ( array . length ) ; for ( String s : array ) { writeString ( s ) ; } }
markharwood/elasticsearch | public void writeStringArrayNullable ( @ Nullable String [ ] array ) throws IOException { if ( array == null ) { writeVInt ( 0 ) ; } else { writeVInt ( array . length ) ; for ( String s : array ) { writeString ( s ) ; } } }
markharwood/elasticsearch | public void writeOptionalStringArray ( @ Nullable String [ ] array ) throws IOException { if ( array == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; writeStringArray ( array ) ; } }
markharwood/elasticsearch | public void writeMap ( @ Nullable Map < String , Object > map ) throws IOException { writeGenericValue ( map ) ; }
markharwood/elasticsearch | public void writeGenericValue ( @ Nullable Object value ) throws IOException { if ( value == null ) { writeByte ( ( byte ) - 1 ) ; return ; } Class type = value . getClass ( ) ; if ( type == String . class ) { writeByte ( ( byte ) 0 ) ; writeString ( ( String ) value ) ; } else if ( type == Integer . class ) { writeByte ( ( byte ) 1 ) ; writeInt ( ( Integer ) value ) ; } else if ( type == Long . class ) { writeByte ( ( byte ) 2 ) ; writeLong ( ( Long ) value ) ; } else if ( type == Float . class ) { writeByte ( ( byte ) 3 ) ; writeFloat ( ( Float ) value ) ; } else if ( type == Double . class ) { writeByte ( ( byte ) 4 ) ; writeDouble ( ( Double ) value ) ; } else if ( type == Boolean . class ) { writeByte ( ( byte ) 5 ) ; writeBoolean ( ( Boolean ) value ) ; } else if ( type == byte [ ] . class ) { writeByte ( ( byte ) 6 ) ; writeVInt ( ( ( byte [ ] ) value ) . length ) ; writeBytes ( ( ( byte [ ] ) value ) ) ; } else if ( value instanceof List ) { writeByte ( ( byte ) 7 ) ; List list = ( List ) value ; writeVInt ( list . size ( ) ) ; for ( Object o : list ) { writeGenericValue ( o ) ; } } else if ( value instanceof Object [ ] ) { writeByte ( ( byte ) 8 ) ; Object [ ] list = ( Object [ ] ) value ; writeVInt ( list . length ) ; for ( Object o : list ) { writeGenericValue ( o ) ; } } else if ( value instanceof Map ) { if ( value instanceof LinkedHashMap ) { writeByte ( ( byte ) 9 ) ; } else { writeByte ( ( byte ) 10 ) ; } @ SuppressWarnings ( " unchecked " ) Map < String , Object > map = ( Map < String , Object > ) value ; writeVInt ( map . size ( ) ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { writeString ( entry . getKey ( ) ) ; writeGenericValue ( entry . getValue ( ) ) ; } } else if ( type == Byte . class ) { writeByte ( ( byte ) 11 ) ; writeByte ( ( Byte ) value ) ; } else if ( type == Date . class ) { writeByte ( ( byte ) 12 ) ; writeLong ( ( ( Date ) value ) . getTime ( ) ) ; } else if ( value instanceof ReadableInstant ) { writeByte ( ( byte ) 13 ) ; writeString ( ( ( ReadableInstant ) value ) . getZone ( ) . getID ( ) ) ; writeLong ( ( ( ReadableInstant ) value ) . getMillis ( ) ) ; } else if ( value instanceof BytesReference ) { writeByte ( ( byte ) 14 ) ; writeBytesReference ( ( BytesReference ) value ) ; } else if ( value instanceof Text ) { writeByte ( ( byte ) 15 ) ; writeText ( ( Text ) value ) ; } else if ( type == Short . class ) { writeByte ( ( byte ) 16 ) ; writeShort ( ( Short ) value ) ; } else if ( type == int [ ] . class ) { writeByte ( ( byte ) 17 ) ; writeIntArray ( ( int [ ] ) value ) ; } else if ( type == long [ ] . class ) { writeByte ( ( byte ) 18 ) ; writeLongArray ( ( long [ ] ) value ) ; } else if ( type == float [ ] . class ) { writeByte ( ( byte ) 19 ) ; writeFloatArray ( ( float [ ] ) value ) ; } else if ( type == double [ ] . class ) { writeByte ( ( byte ) 20 ) ; writeDoubleArray ( ( double [ ] ) value ) ; } else if ( value instanceof BytesRef ) { writeByte ( ( byte ) 21 ) ; writeBytesRef ( ( BytesRef ) value ) ; } else if ( type == GeoPoint . class ) { writeByte ( ( byte ) 22 ) ; writeGeoPoint ( ( GeoPoint ) value ) ; } else { throw new IOException ( " Can ' t ▁ write ▁ type ▁ [ " + type + " ] " ) ; } }
markharwood/elasticsearch | public void writeIntArray ( int [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( int value : values ) { writeInt ( value ) ; } }
markharwood/elasticsearch | public void writeVIntArray ( int [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( int value : values ) { writeVInt ( value ) ; } }
markharwood/elasticsearch | public void writeLongArray ( long [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( long value : values ) { writeLong ( value ) ; } }
markharwood/elasticsearch | public void writeVLongArray ( long [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( long value : values ) { writeVLong ( value ) ; } }
markharwood/elasticsearch | public void writeFloatArray ( float [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( float value : values ) { writeFloat ( value ) ; } }
markharwood/elasticsearch | public void writeDoubleArray ( double [ ] values ) throws IOException { writeVInt ( values . length ) ; for ( double value : values ) { writeDouble ( value ) ; } }
markharwood/elasticsearch | public void writeOptionalStreamable ( @ Nullable Streamable streamable ) throws IOException { if ( streamable != null ) { writeBoolean ( true ) ; streamable . writeTo ( this ) ; } else { writeBoolean ( false ) ; } }
markharwood/elasticsearch | public void writeThrowable ( Throwable throwable ) throws IOException { if ( throwable == null ) { writeBoolean ( false ) ; } else { writeBoolean ( true ) ; boolean writeCause = true ; boolean writeMessage = true ; if ( throwable instanceof CorruptIndexException ) { writeVInt ( 1 ) ; writeOptionalString ( ( ( CorruptIndexException ) throwable ) . getOriginalMessage ( ) ) ; writeOptionalString ( ( ( CorruptIndexException ) throwable ) . getResourceDescription ( ) ) ; writeMessage = false ; } else if ( throwable instanceof IndexFormatTooNewException ) { writeVInt ( 2 ) ; writeOptionalString ( ( ( IndexFormatTooNewException ) throwable ) . getResourceDescription ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getVersion ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getMinVersion ( ) ) ; writeInt ( ( ( IndexFormatTooNewException ) throwable ) . getMaxVersion ( ) ) ; writeMessage = false ; writeCause = false ; } else if ( throwable instanceof IndexFormatTooOldException ) { writeVInt ( 3 ) ; IndexFormatTooOldException t = ( IndexFormatTooOldException ) throwable ; writeOptionalString ( t . getResourceDescription ( ) ) ; if ( t . getVersion ( ) == null ) { writeBoolean ( false ) ; writeOptionalString ( t . getReason ( ) ) ; } else { writeBoolean ( true ) ; writeInt ( t . getVersion ( ) ) ; writeInt ( t . getMinVersion ( ) ) ; writeInt ( t . getMaxVersion ( ) ) ; } writeMessage = false ; writeCause = false ; } else if ( throwable instanceof NullPointerException ) { writeVInt ( 4 ) ; writeCause = false ; } else if ( throwable instanceof NumberFormatException ) { writeVInt ( 5 ) ; writeCause = false ; } else if ( throwable instanceof IllegalArgumentException ) { writeVInt ( 6 ) ; } else if ( throwable instanceof AlreadyClosedException ) { writeVInt ( 7 ) ; } else if ( throwable instanceof EOFException ) { writeVInt ( 8 ) ; writeCause = false ; } else if ( throwable instanceof SecurityException ) { writeVInt ( 9 ) ; } else if ( throwable instanceof StringIndexOutOfBoundsException ) { writeVInt ( 10 ) ; writeCause = false ; } else if ( throwable instanceof ArrayIndexOutOfBoundsException ) { writeVInt ( 11 ) ; writeCause = false ; } else if ( throwable instanceof AssertionError ) { writeVInt ( 12 ) ; } else if ( throwable instanceof FileNotFoundException ) { writeVInt ( 13 ) ; writeCause = false ; } else if ( throwable instanceof FileSystemException ) { writeVInt ( 14 ) ; if ( throwable instanceof NoSuchFileException ) { writeVInt ( 0 ) ; } else if ( throwable instanceof NotDirectoryException ) { writeVInt ( 1 ) ; } else if ( throwable instanceof DirectoryNotEmptyException ) { writeVInt ( 2 ) ; } else if ( throwable instanceof AtomicMoveNotSupportedException ) { writeVInt ( 3 ) ; } else if ( throwable instanceof FileAlreadyExistsException ) { writeVInt ( 4 ) ; } else if ( throwable instanceof AccessDeniedException ) { writeVInt ( 5 ) ; } else if ( throwable instanceof FileSystemLoopException ) { writeVInt ( 6 ) ; } else { writeVInt ( 7 ) ; } writeOptionalString ( ( ( FileSystemException ) throwable ) . getFile ( ) ) ; writeOptionalString ( ( ( FileSystemException ) throwable ) . getOtherFile ( ) ) ; writeOptionalString ( ( ( FileSystemException ) throwable ) . getReason ( ) ) ; writeCause = false ; } else if ( throwable instanceof OutOfMemoryError ) { writeVInt ( 15 ) ; writeCause = false ; } else if ( throwable instanceof IllegalStateException ) { writeVInt ( 16 ) ; } else if ( throwable instanceof LockObtainFailedException ) { writeVInt ( 17 ) ; } else if ( throwable instanceof InterruptedException ) { writeVInt ( 18 ) ; writeCause = false ; } else if ( throwable instanceof IOException ) { writeVInt ( 19 ) ; } else { ElasticsearchException ex ; if ( throwable instanceof ElasticsearchException && ElasticsearchException . isRegistered ( throwable . getClass ( ) ) ) { ex = ( ElasticsearchException ) throwable ; } else { ex = new NotSerializableExceptionWrapper ( throwable ) ; } writeVInt ( 0 ) ; writeVInt ( ElasticsearchException . getId ( ex . getClass ( ) ) ) ; ex . writeTo ( this ) ; return ; } if ( writeMessage ) { writeOptionalString ( throwable . getMessage ( ) ) ; } if ( writeCause ) { writeThrowable ( throwable . getCause ( ) ) ; } ElasticsearchException . writeStackTraces ( throwable , this ) ; } }
markharwood/elasticsearch | void writeNamedWriteable ( NamedWriteable namedWriteable ) throws IOException { writeString ( namedWriteable . getWriteableName ( ) ) ; namedWriteable . writeTo ( this ) ; }
markharwood/elasticsearch | public void writeQuery ( QueryBuilder queryBuilder ) throws IOException { writeNamedWriteable ( queryBuilder ) ; }
markharwood/elasticsearch | public void writeShape ( ShapeBuilder shapeBuilder ) throws IOException { writeNamedWriteable ( shapeBuilder ) ; }
markharwood/elasticsearch | public void writeScoreFunction ( ScoreFunctionBuilder < ? > scoreFunctionBuilder ) throws IOException { writeNamedWriteable ( scoreFunctionBuilder ) ; }
markharwood/elasticsearch | public void writeTaskStatus ( Task . Status status ) throws IOException { writeNamedWriteable ( status ) ; }
markharwood/elasticsearch | public void writeGeoPoint ( GeoPoint geoPoint ) throws IOException { writeDouble ( geoPoint . lat ( ) ) ; writeDouble ( geoPoint . lon ( ) ) ; }
markharwood/elasticsearch | public < T extends Writeable < T > > void writeList ( List < T > list ) throws IOException { writeVInt ( list . size ( ) ) ; for ( T obj : list ) { obj . writeTo ( this ) ; } }
markharwood/elasticsearch | public void writeRescorer ( RescoreBuilder < ? > rescorer ) throws IOException { writeNamedWriteable ( rescorer ) ; }
selvasingh/azure-sdk-for-java | public String body ( ) { return this . body ; }
selvasingh/azure-sdk-for-java | public ApplicationGatewayProbeHealthResponseMatch withBody ( String body ) { this . body = body ; return this ; }
selvasingh/azure-sdk-for-java | public List < String > statusCodes ( ) { return this . statusCodes ; }
selvasingh/azure-sdk-for-java | public ApplicationGatewayProbeHealthResponseMatch withStatusCodes ( List < String > statusCodes ) { this . statusCodes = statusCodes ; return this ; }
OnePaaS/aws-sdk-java | public void setLogStreamName ( String logStreamName ) { this . logStreamName = logStreamName ; }
OnePaaS/aws-sdk-java | public String getLogStreamName ( ) { return this . logStreamName ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withLogStreamName ( String logStreamName ) { setLogStreamName ( logStreamName ) ; return this ; }
OnePaaS/aws-sdk-java | public void setTimestamp ( Long timestamp ) { this . timestamp = timestamp ; }
OnePaaS/aws-sdk-java | public Long getTimestamp ( ) { return this . timestamp ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withTimestamp ( Long timestamp ) { setTimestamp ( timestamp ) ; return this ; }
OnePaaS/aws-sdk-java | public void setMessage ( String message ) { this . message = message ; }
OnePaaS/aws-sdk-java | public String getMessage ( ) { return this . message ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withMessage ( String message ) { setMessage ( message ) ; return this ; }
OnePaaS/aws-sdk-java | public void setIngestionTime ( Long ingestionTime ) { this . ingestionTime = ingestionTime ; }
OnePaaS/aws-sdk-java | public Long getIngestionTime ( ) { return this . ingestionTime ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withIngestionTime ( Long ingestionTime ) { setIngestionTime ( ingestionTime ) ; return this ; }
OnePaaS/aws-sdk-java | public void setEventId ( String eventId ) { this . eventId = eventId ; }
OnePaaS/aws-sdk-java | public String getEventId ( ) { return this . eventId ; }
OnePaaS/aws-sdk-java | public FilteredLogEvent withEventId ( String eventId ) { setEventId ( eventId ) ; return this ; }
OnePaaS/aws-sdk-java | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " { " ) ; if ( getLogStreamName ( ) != null ) sb . append ( " LogStreamName : ▁ " + getLogStreamName ( ) + " , " ) ; if ( getTimestamp ( ) != null ) sb . append ( " Timestamp : ▁ " + getTimestamp ( ) + " , " ) ; if ( getMessage ( ) != null ) sb . append ( " Message : ▁ " + getMessage ( ) + " , " ) ; if ( getIngestionTime ( ) != null ) sb . append ( " IngestionTime : ▁ " + getIngestionTime ( ) + " , " ) ; if ( getEventId ( ) != null ) sb . append ( " EventId : ▁ " + getEventId ( ) ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
OnePaaS/aws-sdk-java | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof FilteredLogEvent == false ) return false ; FilteredLogEvent other = ( FilteredLogEvent ) obj ; if ( other . getLogStreamName ( ) == null ^ this . getLogStreamName ( ) == null ) return false ; if ( other . getLogStreamName ( ) != null && other . getLogStreamName ( ) . equals ( this . getLogStreamName ( ) ) == false ) return false ; if ( other . getTimestamp ( ) == null ^ this . getTimestamp ( ) == null ) return false ; if ( other . getTimestamp ( ) != null && other . getTimestamp ( ) . equals ( this . getTimestamp ( ) ) == false ) return false ; if ( other . getMessage ( ) == null ^ this . getMessage ( ) == null ) return false ; if ( other . getMessage ( ) != null && other . getMessage ( ) . equals ( this . getMessage ( ) ) == false ) return false ; if ( other . getIngestionTime ( ) == null ^ this . getIngestionTime ( ) == null ) return false ; if ( other . getIngestionTime ( ) != null && other . getIngestionTime ( ) . equals ( this . getIngestionTime ( ) ) == false ) return false ; if ( other . getEventId ( ) == null ^ this . getEventId ( ) == null ) return false ; if ( other . getEventId ( ) != null && other . getEventId ( ) . equals ( this . getEventId ( ) ) == false ) return false ; return true ; }
OnePaaS/aws-sdk-java | @ Override public int hashCode ( ) { final int prime = 31 ; int hashCode = 1 ; hashCode = prime * hashCode + ( ( getLogStreamName ( ) == null ) ? 0 : getLogStreamName ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getTimestamp ( ) == null ) ? 0 : getTimestamp ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getMessage ( ) == null ) ? 0 : getMessage ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getIngestionTime ( ) == null ) ? 0 : getIngestionTime ( ) . hashCode ( ) ) ; hashCode = prime * hashCode + ( ( getEventId ( ) == null ) ? 0 : getEventId ( ) . hashCode ( ) ) ; return hashCode ; }
OnePaaS/aws-sdk-java | @ Override public FilteredLogEvent clone ( ) { try { return ( FilteredLogEvent ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( " Got ▁ a ▁ CloneNotSupportedException ▁ from ▁ Object . clone ( ) ▁ " + " even ▁ though ▁ we ' re ▁ Cloneable ! " , e ) ; } }
Runpop/MVPDemo | @ Test public void addition_isCorrect ( ) throws Exception { assertEquals ( 4 , 2 + 2 ) ; }
PG85/OpenTerrainGenerator | public BiomeLayerData ( BiomeLayerData data ) { this . biomeColorMap = new HashMap < > ( ) ; for ( Entry < Integer , Integer > entry : data . biomeColorMap . entrySet ( ) ) { this . biomeColorMap . put ( entry . getKey ( ) . intValue ( ) , entry . getValue ( ) . intValue ( ) ) ; } this . imageXOffset = data . imageXOffset ; this . imageZOffset = data . imageZOffset ; this . imageMode = data . imageMode ; this . configImageFillBiome = data . configImageFillBiome ; this . imageFillBiome = data . imageFillBiome ; this . presetDir = data . presetDir ; this . imageFile = data . imageFile ; this . imageOrientation = data . imageOrientation ; this . biomeMode = data . biomeMode ; this . generationDepth = data . generationDepth ; this . landSize = data . landSize ; this . landFuzzy = data . landFuzzy ; this . landRarity = data . landRarity ; this . oceanBiomeSize = data . oceanBiomeSize ; this . frozenOceanTemperature = data . frozenOceanTemperature ; this . biomeRarityScale = data . biomeRarityScale ; this . randomRivers = data . randomRivers ; this . riverDepth = data . riverDepth ; this . riverSize = data . riverSize ; this . riversEnabled = data . riversEnabled ; this . oceanBiomeData = data . oceanBiomeData . clone ( ) ; this . biomeDepths . addAll ( data . biomeDepths ) ; this . cumulativeGroupRarities = data . cumulativeGroupRarities . clone ( ) ; this . groupMaxRarityPerDepth = data . groupMaxRarityPerDepth . clone ( ) ; this . oldMaxRarities = data . oldMaxRarities ; this . oldGroupRarity = data . oldGroupRarity ; this . oldLandRarity = data . oldLandRarity ; this . forceLandAtSpawn = data . forceLandAtSpawn ; for ( Entry < Integer , List < NewBiomeGroup > > entry : data . groups . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { List < NewBiomeGroup > clonedList = new ArrayList < > ( ) ; for ( NewBiomeGroup group : entry . getValue ( ) ) { NewBiomeGroup clonedGroup = group . clone ( ) ; this . groupRegistry . put ( clonedGroup . id , clonedGroup ) ; clonedList . add ( clonedGroup ) ; } this . groups . put ( entry . getKey ( ) . intValue ( ) , clonedList ) ; } else { this . groups . put ( entry . getKey ( ) . intValue ( ) , null ) ; } } for ( Entry < Integer , List < BiomeData > > entry : data . isleBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { List < BiomeData > clonedList = new ArrayList < > ( ) ; for ( BiomeData biome : entry . getValue ( ) ) { clonedList . add ( biome . clone ( ) ) ; } this . isleBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , clonedList ) ; } else { this . isleBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , null ) ; } } for ( Entry < Integer , List < BiomeData > > entry : data . borderBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { List < BiomeData > clonedList = new ArrayList < > ( ) ; for ( BiomeData biome : entry . getValue ( ) ) { clonedList . add ( biome . clone ( ) ) ; } this . borderBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , clonedList ) ; } else { this . borderBiomesAtDepth . put ( entry . getKey ( ) . intValue ( ) , null ) ; } } this . riverBiomes = data . riverBiomes . clone ( ) ; this . oceanTemperatures = new int [ 4 ] ; System . arraycopy ( data . oceanTemperatures , 0 , this . oceanTemperatures , 0 , 4 ) ; }
PG85/OpenTerrainGenerator | public BiomeLayerData ( Path presetDir , IWorldConfig worldConfig , IBiomeConfig oceanBiomeConfig , int [ ] oceanTemperatures ) { this . imageXOffset = worldConfig . getImageXOffset ( ) ; this . imageZOffset = worldConfig . getImageZOffset ( ) ; this . imageMode = worldConfig . getImageMode ( ) ; this . configImageFillBiome = worldConfig . getImageFillBiome ( ) ; this . presetDir = presetDir ; this . imageFile = worldConfig . getImageFile ( ) ; this . imageOrientation = worldConfig . getImageOrientation ( ) ; this . biomeMode = worldConfig . getBiomeMode ( ) ; this . generationDepth = worldConfig . getGenerationDepth ( ) ; this . landSize = worldConfig . getLandSize ( ) ; this . landFuzzy = worldConfig . getLandFuzzy ( ) ; this . landRarity = worldConfig . getLandRarity ( ) ; this . oceanBiomeSize = worldConfig . getOceanBiomeSize ( ) ; this . oceanTemperatures = oceanTemperatures ; this . cumulativeGroupRarities = new int [ this . generationDepth + 1 ] ; this . groupMaxRarityPerDepth = new int [ this . generationDepth + 1 ] ; this . oldMaxRarities = new int [ this . generationDepth + 1 ] ; this . oldGroupRarity = worldConfig . getOldGroupRarity ( ) ; this . oldLandRarity = worldConfig . getOldLandRarity ( ) ; this . forceLandAtSpawn = worldConfig . getForceLandAtSpawn ( ) ; if ( oceanBiomeConfig == null ) { this . oceanBiomeData = new BiomeData ( 0 , 0 , 0 , 0 , ImmutableList . of ( ) , ImmutableList . of ( ) , ImmutableList . of ( ) , ImmutableList . of ( ) ) ; } else { this . oceanBiomeData = new BiomeData ( 0 , oceanBiomeConfig . getBiomeRarity ( ) , oceanBiomeConfig . getBiomeSize ( ) , oceanBiomeConfig . getBiomeTemperature ( ) , oceanBiomeConfig . getIsleInBiomes ( ) , oceanBiomeConfig . getBorderInBiomes ( ) , oceanBiomeConfig . getOnlyBorderNearBiomes ( ) , oceanBiomeConfig . getNotBorderNearBiomes ( ) ) ; } this . frozenOceanTemperature = worldConfig . getFrozenOceanTemperature ( ) ; this . biomeRarityScale = worldConfig . getBiomeRarityScale ( ) ; this . randomRivers = worldConfig . getIsRandomRivers ( ) ; this . riverDepth = worldConfig . getRiverRarity ( ) ; this . riverSize = worldConfig . getRiverSize ( ) ; this . riversEnabled = worldConfig . getRiversEnabled ( ) ; }
PG85/OpenTerrainGenerator | public void init ( Set < Integer > biomeDepths , Map < Integer , List < NewBiomeGroup > > groupDepth , Map < Integer , List < BiomeData > > isleBiomesAtDepth , Map < Integer , List < BiomeData > > borderBiomesAtDepth , Map < String , List < Integer > > biomeIdsByName , HashMap < Integer , Integer > biomeColorMap , IBiome [ ] biomes ) { this . biomeDepths . addAll ( biomeDepths ) ; this . groups . putAll ( groupDepth ) ; this . isleBiomesAtDepth . putAll ( isleBiomesAtDepth ) ; this . borderBiomesAtDepth . putAll ( borderBiomesAtDepth ) ; for ( Entry < Integer , List < NewBiomeGroup > > entry : this . groups . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { int cumulativeRarity = 0 ; for ( NewBiomeGroup group : entry . getValue ( ) ) { group . init ( biomeIdsByName ) ; cumulativeRarity += group . rarity ; oldMaxRarities [ entry . getKey ( ) ] ++ ; } this . cumulativeGroupRarities [ entry . getKey ( ) ] = cumulativeRarity ; } } for ( int depth = 0 ; depth < this . cumulativeGroupRarities . length ; depth ++ ) { for ( int j = depth ; j < this . cumulativeGroupRarities . length ; j ++ ) { this . groupMaxRarityPerDepth [ depth ] += this . cumulativeGroupRarities [ j ] ; } } for ( int i = 0 ; i < oldMaxRarities . length ; i ++ ) { oldMaxRarities [ i ] *= 100 ; } for ( Entry < Integer , List < BiomeData > > entry : this . isleBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { for ( BiomeData biome : entry . getValue ( ) ) { biome . init ( biomeIdsByName ) ; } } } for ( Entry < Integer , List < BiomeData > > entry : this . borderBiomesAtDepth . entrySet ( ) ) { if ( entry . getValue ( ) != null ) { for ( BiomeData biome : entry . getValue ( ) ) { biome . init ( biomeIdsByName ) ; } } } this . biomeColorMap = biomeColorMap ; this . riverBiomes = new int [ biomes . length ] ; for ( int i = 0 ; i < biomes . length ; i ++ ) { List < Integer > ids = biomeIdsByName . getOrDefault ( biomes [ i ] . getBiomeConfig ( ) . getRiverBiome ( ) , null ) ; this . riverBiomes [ i ] = ids == null ? - 1 : ids . get ( 0 ) ; } }
spring-projects/spring-framework | @ Override protected ClientHttpRequestFactory createRequestFactory ( ) { return new BufferingClientHttpRequestFactory ( new HttpComponentsClientHttpRequestFactory ( ) ) ; }
spring-projects/spring-framework | @ Test void repeatableRead ( ) throws Exception { ClientHttpRequest request = factory . createRequest ( new URI ( baseUrl + " / echo " ) , HttpMethod . PUT ) ; assertThat ( request . getMethod ( ) ) . as ( " Invalid ▁ HTTP ▁ method " ) . isEqualTo ( HttpMethod . PUT ) ; String headerName = " MyHeader " ; String headerValue1 = " value1" ; request . getHeaders ( ) . add ( headerName , headerValue1 ) ; String headerValue2 = " value2" ; request . getHeaders ( ) . add ( headerName , headerValue2 ) ; byte [ ] body = " Hello ▁ World " . getBytes ( " UTF - 8" ) ; request . getHeaders ( ) . setContentLength ( body . length ) ; FileCopyUtils . copy ( body , request . getBody ( ) ) ; try ( ClientHttpResponse response = request . execute ( ) ) { assertThat ( response . getStatusCode ( ) ) . as ( " Invalid ▁ status ▁ code " ) . isEqualTo ( HttpStatus . OK ) ; assertThat ( response . getStatusCode ( ) ) . as ( " Invalid ▁ status ▁ code " ) . isEqualTo ( HttpStatus . OK ) ; assertThat ( response . getHeaders ( ) . containsKey ( headerName ) ) . as ( " Header ▁ not ▁ found " ) . isTrue ( ) ; assertThat ( response . getHeaders ( ) . containsKey ( headerName ) ) . as ( " Header ▁ not ▁ found " ) . isTrue ( ) ; assertThat ( response . getHeaders ( ) . get ( headerName ) ) . as ( " Header ▁ value ▁ not ▁ found " ) . isEqualTo ( Arrays . asList ( headerValue1 , headerValue2 ) ) ; assertThat ( response . getHeaders ( ) . get ( headerName ) ) . as ( " Header ▁ value ▁ not ▁ found " ) . isEqualTo ( Arrays . asList ( headerValue1 , headerValue2 ) ) ; byte [ ] result = FileCopyUtils . copyToByteArray ( response . getBody ( ) ) ; assertThat ( Arrays . equals ( body , result ) ) . as ( " Invalid ▁ body " ) . isTrue ( ) ; FileCopyUtils . copyToByteArray ( response . getBody ( ) ) ; assertThat ( Arrays . equals ( body , result ) ) . as ( " Invalid ▁ body " ) . isTrue ( ) ; } }
DebalinaDey/AuraDevelopDeb | @ AuraEnabled public String getThirdThing ( ) { return thirdThing ; }
DebalinaDey/AuraDevelopDeb | public void setThirdThing ( String thirdThing ) { this . thirdThing = thirdThing ; }
DebalinaDey/AuraDevelopDeb | @ AuraEnabled public String getReadOnlyThing ( ) { return " readonlyFromTestController2" ; }
johanwermensjoe/project-bacon | public MaterialModel ( ) { super ( new String [ ] { " Name " , " Amount " , " Manufacture " , " Manufacture ▁ Cost / unit ▁ ( ISK ) " , " Price / unit ▁ ( ISK ) " , " Total ▁ Cost ▁ ( ISK ) " } , new int [ ] { LEFT , RIGHT , CENTER , RIGHT , RIGHT , RIGHT } , new int [ ] { 2 } ) ; }
johanwermensjoe/project-bacon | @ Override public Class < ? > getColumnClass ( int columnIndex ) { switch ( columnIndex ) { case 0 : return String . class ; case 2 : return Boolean . class ; case 1 : case 3 : case 4 : case 5 : return Double . class ; default : return Object . class ; } }
johanwermensjoe/project-bacon | @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return getColumnClass ( columnIndex ) == Boolean . class && dataList . get ( rowIndex ) . canBeManufactured ( ) ; }
johanwermensjoe/project-bacon | @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { if ( getColumnClass ( columnIndex ) == Boolean . class ) { dataList . get ( rowIndex ) . setProduced ( ( Boolean ) aValue ) ; fireTableCellUpdated ( rowIndex , columnIndex ) ; } }
johanwermensjoe/project-bacon | @ Override public Object getValueAt ( int row , int col ) { Material m = dataList . get ( row ) ; switch ( col ) { case 0 : return m . getItem ( ) . getName ( ) ; case 1 : return m . getAmount ( ) ; case 2 : return m . canBeManufactured ( ) ? m . isProduced ( ) : null ; case 3 : return m . getManufactureQuote ( ) == null ? null : m . getManufactureQuote ( ) . getManuCost ( ) ; case 4 : return m . getPrice ( ) ; case 5 : return m . isProduced ( ) ? m . getManufactureQuote ( ) . getManuCost ( ) * m . getAmount ( ) : m . getPrice ( ) * m . getAmount ( ) ; default : return null ; } }
Ladicek/creaper | public RemoveModule ( String moduleName ) { this ( moduleName , AddModule . DEFAULT_SLOT ) ; }
Ladicek/creaper | public RemoveModule ( String moduleName , String slot ) { if ( moduleName == null ) { throw new IllegalArgumentException ( " moduleName ▁ cannot ▁ be ▁ null " ) ; } if ( slot == null ) { throw new IllegalArgumentException ( " slot ▁ cannot ▁ be ▁ null " ) ; } this . moduleName = moduleName ; this . slot = slot ; }
Ladicek/creaper | @ Override public void apply ( OnlineCommandContext ctx ) throws Exception { if ( ctx . options . isDomain ) { throw new CommandFailedException ( " RemoveModule ▁ command ▁ isn ' t ▁ supported ▁ in ▁ domain ▁ mode " ) ; } ctx . client . executeCli ( " module ▁ remove ▁ - - name = " + moduleName + " ▁ - - slot = " + slot ) ; }
Ladicek/creaper | @ Override public String toString ( ) { return " RemoveModule ▁ " + moduleName ; }
syg5201314/demoCollection | @ Override protected void onCreate ( Bundle arg0 ) { super . onCreate ( arg0 ) ; setContentView ( R . layout . eleme_content_layout ) ; mRecyclerView = ( RecyclerView ) findViewById ( R . id . recyclerView ) ; mViewPager = ( ViewPager ) findViewById ( R . id . viewpager ) ; mHeaderView = ( ElemeHeaderView ) findViewById ( R . id . zoomHeader ) ; mViewPager . setAdapter ( new Adapter ( ) ) ; mViewPager . setOffscreenPageLimit ( 4 ) ; CtrlLinearLayoutManager layoutManager = new CtrlLinearLayoutManager ( this ) ; layoutManager . setScrollEnabled ( false ) ; mRecyclerView . setLayoutManager ( layoutManager ) ; mRecyclerView . setAdapter ( new ListAdapter ( ) ) ; mRecyclerView . setAlpha ( 0 ) ; mBottomView = ( RelativeLayout ) findViewById ( R . id . rv_bottom ) ; }
syg5201314/demoCollection | @ Override public void onWindowFocusChanged ( boolean hasFocus ) { super . onWindowFocusChanged ( hasFocus ) ; int size = mViewPager . getChildCount ( ) ; if ( isFirst ) { for ( int i = 0 ; i < size ; i ++ ) { View v = mViewPager . getChildAt ( i ) . findViewById ( R . id . ll_bottom ) ; v . setY ( mViewPager . getChildAt ( i ) . findViewById ( R . id . imageView ) . getHeight ( ) ) ; v . setX ( MarginConfig . MARGIN_LEFT_RIGHT ) ; mHeaderView . setY ( mHeaderView . getY ( ) - 1 ) ; isFirst = false ; } } bottomY = ( int ) mBottomView . getY ( ) ; mBottomView . setTranslationY ( mBottomView . getY ( ) + mBottomView . getHeight ( ) ) ; mHeaderView . setBottomView ( mBottomView , bottomY ) ; }
syg5201314/demoCollection | @ Override public Object instantiateItem ( ViewGroup container , int position ) { views . get ( position ) . findViewById ( R . id . imageView ) . setBackgroundResource ( imgs [ position ] ) ; container . addView ( views . get ( position ) ) ; return views . get ( position ) ; }
syg5201314/demoCollection | public Adapter ( ) { views = new ArrayList < > ( ) ; views . add ( View . inflate ( ElemeDetailContentActivity . this , R . layout . item_img , null ) ) ; views . get ( 0 ) . findViewById ( R . id . btn_buy ) . setOnClickListener ( v -> Toast . makeText ( ElemeDetailContentActivity . this , " buy " , Toast . LENGTH_SHORT ) . show ( ) ) ; views . add ( View . inflate ( ElemeDetailContentActivity . this , R . layout . item_img , null ) ) ; views . add ( View . inflate ( ElemeDetailContentActivity . this , R . layout . item_img , null ) ) ; }
syg5201314/demoCollection | @ Override public int getCount ( ) { return views . size ( ) ; }
syg5201314/demoCollection | @ Override public boolean isViewFromObject ( View view , Object object ) { return view == object ; }
syg5201314/demoCollection | @ Override public void onBackPressed ( ) { if ( mHeaderView . isExpand ( ) ) { mHeaderView . restore ( mHeaderView . getY ( ) ) ; } else { finish ( ) ; } }
pupnewfster/Necessities | public boolean commandUse ( CommandSender sender , String [ ] args ) { Variables var = Necessities . getVar ( ) ; if ( sender instanceof Player ) { sender . sendMessage ( var . getEr ( ) + " Error : ▁ " + var . getErMsg ( ) + " You ▁ cannot ▁ use ▁ this ▁ command , ▁ it ▁ is ▁ console ▁ specific . " ) ; } else { Console console = Necessities . getConsole ( ) ; sender . sendMessage ( var . getMessages ( ) + ( console . chatToggled ( ) ? " Toggled ▁ back ▁ to ▁ command ▁ mode . " : " Toggled ▁ to ▁ chat ▁ mode . " ) ) ; console . chatToggle ( ) ; } return true ; }
pupnewfster/Necessities | public boolean isPaintballEnabled ( ) { return true ; }
mmnaseri/cs-review | @ Test public void testFindingItemsAtTheBeginning ( ) throws Exception { assertThat ( getFinder ( ) . find ( 1 , 1 , 2 , 3 , 4 , 5 ) , is ( 0 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemsAtTheEnd ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , 1 , 2 , 3 , 4 , 5 ) , is ( 4 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemInArrayOfSmallSize ( ) throws Exception { assertThat ( getFinder ( ) . find ( 2 , 1 , 2 ) , is ( 1 ) ) ; assertThat ( getFinder ( ) . find ( 3 , 3 , 4 ) , is ( 0 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingFromAnEmptyList ( ) throws Exception { assertThat ( getFinder ( ) . find ( 0 ) , is ( - 1 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemInTheMiddle ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , 1 , 3 , 5 , 7 , 9 ) , is ( 2 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemThatIsNotThere ( ) throws Exception { assertThat ( getFinder ( ) . find ( - 1 , 1 , 2 , 3 , 4 ) , is ( - 1 ) ) ; }
mmnaseri/cs-review | @ Test public void testFindingItemWhenListContainsInfinity ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , Integer . MIN_VALUE , 1 , 2 , 3 , 5 , Integer . MAX_VALUE ) , is ( 4 ) ) ; }
bclozel/spring-boot | @ Before public void setup ( ) { this . mockMvc = MockMvcBuilders . webAppContextSetup ( this . wac ) . build ( ) ; }
bclozel/spring-boot | @ Test public void testDirectAccessForMachineClient ( ) throws Exception { MvcResult response = this . mockMvc . perform ( get ( " / error " ) ) . andExpect ( status ( ) . is5xxServerError ( ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( "999" ) ; }
bclozel/spring-boot | @ Test public void testErrorWithResponseStatus ( ) throws Exception { MvcResult result = this . mockMvc . perform ( get ( " / bang " ) ) . andExpect ( status ( ) . isNotFound ( ) ) . andReturn ( ) ; MvcResult response = this . mockMvc . perform ( new ErrorDispatcher ( result , " / error " ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( " Expected ! " ) ; }
bclozel/spring-boot | @ Test public void testBindingExceptionForMachineClient ( ) throws Exception { MvcResult result = this . mockMvc . perform ( get ( " / bind " ) ) . andExpect ( status ( ) . is4xxClientError ( ) ) . andReturn ( ) ; MvcResult response = this . mockMvc . perform ( new ErrorDispatcher ( result , " / error " ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( " Error ▁ count : ▁ 1" ) ; }
bclozel/spring-boot | @ Test public void testDirectAccessForBrowserClient ( ) throws Exception { MvcResult response = this . mockMvc . perform ( get ( " / error " ) . accept ( MediaType . TEXT_HTML ) ) . andExpect ( status ( ) . is5xxServerError ( ) ) . andReturn ( ) ; String content = response . getResponse ( ) . getContentAsString ( ) ; assertThat ( content ) . contains ( " ERROR _ BEAN " ) ; }
bclozel/spring-boot | @ Bean public View error ( ) { return new AbstractView ( ) { @ Override protected void renderMergedOutputModel ( Map < String , Object > model , HttpServletRequest request , HttpServletResponse response ) throws Exception { response . getWriter ( ) . write ( " ERROR _ BEAN " ) ; } } ; }
bclozel/spring-boot | public String getFoo ( ) { return " foo " ; }
bclozel/spring-boot | @ RequestMapping ( " / " ) public String home ( ) { throw new IllegalStateException ( " Expected ! " ) ; }
bclozel/spring-boot | @ RequestMapping ( " / bang " ) public String bang ( ) { throw new NotFoundException ( " Expected ! " ) ; }
bclozel/spring-boot | @ RequestMapping ( " / bind " ) public String bind ( ) throws Exception { BindException error = new BindException ( this , " test " ) ; error . rejectValue ( " foo " , " bar . error " ) ; throw error ; }
bclozel/spring-boot | NotFoundException ( String string ) { super ( string ) ; }
bclozel/spring-boot | ErrorDispatcher ( MvcResult result , String path ) { this . result = result ; this . path = path ; }
bclozel/spring-boot | @ Override public MockHttpServletRequest buildRequest ( ServletContext servletContext ) { MockHttpServletRequest request = this . result . getRequest ( ) ; request . setDispatcherType ( DispatcherType . ERROR ) ; request . setRequestURI ( this . path ) ; return request ; }
udayinfy/ECommerce-Java | public FulfillmentClient ( ) { super ( ) ; }
udayinfy/ECommerce-Java | private void recieveMessages ( ) { CreateQueueResult queue = super . getQueue ( ) ; ReceiveMessageResult result = client . receiveMessage ( new ReceiveMessageRequest ( queue . getQueueUrl ( ) ) ) ; List < Message > messages = result . getMessages ( ) ; while ( true ) { for ( Message message : messages ) { processMessage ( message ) ; } try { Thread . sleep ( 1 * 1000 ) ; } catch ( InterruptedException ie ) { } } }
udayinfy/ECommerce-Java | private void processMessage ( Message message ) { client . deleteMessage ( new DeleteMessageRequest ( getQueue ( ) . getQueueUrl ( ) , message . getReceiptHandle ( ) ) ) ; logger . info ( " Message ▁ Deleted : " + message . getReceiptHandle ( ) ) ; }
medlinker/android-photo-picker | private final PhotoGridAdapter . ICallback < BasePhotoFileEntity > mCallback = new PhotoGridAdapter . ICallback < BasePhotoFileEntity > ( ) { @ Override public void onClickCamera ( View itemView ) { showToast ( " onClickCamera " ) ; try { startActivityForResult ( mPickerHelper . makeTakePhotoIntent ( ) , PhotoPickerHelper . REQUEST_TAKE_PHOTO ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } @ Override public void onClickItemView ( View itemView , int position , BasePhotoFileEntity item ) { showToast ( " onClickItemView : ▁ position ▁ = ▁ " + position ) ; List < BasePhotoFileEntity > selectItems = mGridAdapter . getSelectHelper ( ) . getSelectedItems ( ) ; ArrayList < BasePhotoFileEntity > photoes = new ArrayList < > ( mGridAdapter . getAdapterManager ( ) . getItems ( ) ) ; if ( mGridAdapter . isShowCamera ( ) ) { photoes . remove ( 0 ) ; position -= 1 ; } Bundle b = new Bundle ( ) ; b . putInt ( PhotoPickerHelper . KEY_SELECT_INDEX , position ) ; b . putParcelableArrayList ( PhotoPickerHelper . KEY_PHOTOES , photoes ) ; if ( selectItems != null ) { b . putParcelableArrayList ( PhotoPickerHelper . KEY_PHOTOES_SELECTED , new ArrayList < > ( mGridAdapter . getSelectHelper ( ) . getSelectedItems ( ) ) ) ; } getIntentExecutor ( ) . launchActivityForResult ( PhotoPagerActivity . class , PhotoPickerHelper . REQUEST_CODE_SEE_BIG_PIC , b ) ; } @ Override public void onClickSelectIcon ( View itemView , int position , BasePhotoFileEntity item , List < BasePhotoFileEntity > selectItems ) { int size = selectItems != null ? selectItems . size ( ) : 0 ; tv_done_notice . setText ( getString ( R . string . template_done , size ) ) ; showToast ( " onClickSelectIcon : ▁ position ▁ = ▁ " + position + " ▁ , size ▁ = ▁ " + size ) ; } @ Override public boolean shouldIgnoreClickEventOfSelectIcon ( int position , BasePhotoFileEntity item , List < BasePhotoFileEntity > selectItems ) { if ( selectItems != null && selectItems . size ( ) == 9 ) { showToast ( R . string . only_permit_9_image ) ; return true ; } return false ; } }
medlinker/android-photo-picker | @ Override protected int getlayoutId ( ) { return R . layout . ac_photo_picker ; }
medlinker/android-photo-picker | @ Override protected void onSaveInstanceState ( Bundle outState ) { outState . putString ( " image " , mPickerHelper . getCurrentPhotoPath ( ) ) ; super . onSaveInstanceState ( outState ) ; showToast ( " onSaveInstanceState " + mPickerHelper . getCurrentPhotoPath ( ) ) ; }
medlinker/android-photo-picker | @ Override protected void onRestoreInstanceState ( Bundle savedInstanceState ) { super . onRestoreInstanceState ( savedInstanceState ) ; mPickerHelper . setPhotoPath ( savedInstanceState . getString ( " image " , null ) ) ; Logger . i ( " - - ▁ onRestoreInstanceState ▁ - - " , " ▁ path ▁ = ▁ " + mPickerHelper . getCurrentPhotoPath ( ) ) ; }
medlinker/android-photo-picker | @ Override protected void initView ( ) { setCommonBackListener ( iv_Back ) ; GridLayoutManager layoutManager = new GridLayoutManager ( this , 3 , GridLayoutManager . VERTICAL , false ) ; rv_photos . setLayoutManager ( layoutManager ) ; rv_photos . addItemDecoration ( new SpacesItemDecoration ( ( int ) getResources ( ) . getDimension ( R . dimen . photo_width ) ) ) ; PhotoPickerFactory . setImageLoader ( new DraweeImageLoader ( 0 ) ) ; PhotoPickerFactory . setPhotoFileEntityFactory ( new PhotoPickerFactory . IPhotoFileEntityFactory < BasePhotoFileEntity > ( ) { @ Override public BasePhotoFileEntity create ( int id , String path ) { return new BasePhotoFileEntity ( id , path ) ; } } ) ; mPickerHelper = PhotoPickerFactory . createPhotoPickerHelper ( this ) ; }
medlinker/android-photo-picker | @ Override protected void initData ( Bundle savedInstanceState ) { if ( savedInstanceState != null ) { mPickerHelper . setPhotoPath ( savedInstanceState . getString ( " image " , null ) ) ; } if ( ContextCompat . checkSelfPermission ( this , android . Manifest . permission . WRITE_EXTERNAL_STORAGE ) != PackageManager . PERMISSION_GRANTED ) { ActivityCompat . requestPermissions ( this , new String [ ] { Manifest . permission . WRITE_EXTERNAL_STORAGE } , 100 ) ; } else { mPickerHelper . scanPhotoes ( this ) ; } }
medlinker/android-photo-picker | @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode != RESULT_OK ) return ; switch ( requestCode ) { case PhotoPickerHelper . REQUEST_CODE_SEE_BIG_PIC : finishSelect ( ) ; break ; case PhotoPickerHelper . REQUEST_TAKE_PHOTO : mPickerHelper . scanFileToDatabase ( ) ; if ( mPhotoDirs == null ) { mPickerHelper . scanPhotoes ( this ) ; return ; } String path = mPickerHelper . getCurrentPhotoPath ( ) ; BasePhotoFileEntity entity = ( BasePhotoFileEntity ) PhotoPickerFactory . getPhotoFileEntityFactory ( ) . create ( path . hashCode ( ) , path ) ; final PhotoDirectory < BasePhotoFileEntity > dirs = mPhotoDirs . get ( PhotoPickerHelper . INDEX_ALL_PHOTOS ) ; dirs . getPhotos ( ) . add ( 0 , entity ) ; dirs . setPath ( path ) ; mGridAdapter . clearAllSelected ( ) ; mGridAdapter . getAdapterManager ( ) . getItems ( ) . add ( 0 , entity ) ; break ; } }
medlinker/android-photo-picker | private void finishSelect ( ) { Intent sIntent = new Intent ( ) ; List < BasePhotoFileEntity > selectedPhotos = mGridAdapter . getSelectHelper ( ) . getSelectedItems ( ) ; sIntent . putParcelableArrayListExtra ( PhotoPickerHelper . KEY_PHOTOES_SELECTED , ( ArrayList < ? extends Parcelable > ) selectedPhotos ) ; setResult ( RESULT_OK , sIntent ) ; finish ( ) ; }
medlinker/android-photo-picker | @ Override public void onResultCallback ( List < PhotoDirectory < BasePhotoFileEntity > > directories ) { this . mPhotoDirs = directories ; final List < BasePhotoFileEntity > photos = directories . get ( 0 ) . getPhotos ( ) ; if ( mGridAdapter == null ) { if ( photos . size ( ) == 0 ) { showToast ( " no ▁ photoes " ) ; } mGridAdapter = new PhotoGridAdapter < BasePhotoFileEntity > ( R . layout . item_photo , photos , ISelectable . SELECT_MODE_MULTI ) { @ Override protected void applySelectState ( ImageView selectIcon , boolean selected ) { selectIcon . setImageResource ( selected ? R . mipmap . pic_check_select : R . mipmap . pic_check_normal ) ; } @ Override protected boolean bindCameraItemSuccess ( Context context , int position , ViewHelper helper ) { return false ; } @ Override protected int getCameraItemLayoutId ( ) { return R . layout . item_photo_camera ; } } ; mGridAdapter . setCallback ( mCallback ) ; rv_photos . setAdapter ( mGridAdapter ) ; } else { mGridAdapter . getAdapterManager ( ) . replaceAllItems ( photos ) ; } }
medlinker/android-photo-picker | @ Override public void onRequestPermissionsResult ( int requestCode , String [ ] permissions , int [ ] grantResults ) { super . onRequestPermissionsResult ( requestCode , permissions , grantResults ) ; if ( grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ) { mPickerHelper . scanPhotoes ( this ) ; } else { showToast ( " permission ▁ denied ▁ ！ " ) ; } }
medlinker/android-photo-picker | public SpacesItemDecoration ( int space ) { this . space = space ; }
medlinker/android-photo-picker | public void getItemOffsets ( Rect outRect , View view , RecyclerView parent , RecyclerView . State state ) { if ( ( parent . getChildLayoutPosition ( view ) + 1 ) % 3 == 0 ) { outRect . right = space ; } else { outRect . right = space ; } outRect . bottom = space ; }
nafae/developer | public Integer getTotalResultSetSize ( ) { return totalResultSetSize ; }
nafae/developer | public void setTotalResultSetSize ( Integer value ) { this . totalResultSetSize = value ; }
nafae/developer | public Integer getStartIndex ( ) { return startIndex ; }
nafae/developer | public void setStartIndex ( Integer value ) { this . startIndex = value ; }
nafae/developer | public List < ActivityGroup > getResults ( ) { if ( results == null ) { results = new ArrayList < ActivityGroup > ( ) ; } return this . results ; }
FilteredPush/geo_ref_qc | @ Test public void test ( ) { List < GeolocationResult > results = service . queryGeoLocateMulti ( " USA " , " Arizona " , " " , "1 ▁ mi . ▁ S ▁ of ▁ Portal " , "31.899097" , " - 109.14083" ) ; assertTrue ( results . size ( ) > 0 ) ; }
FingolfinTEK/camel | public Update ( ) { }
FingolfinTEK/camel | public Long getUpdateId ( ) { return updateId ; }
FingolfinTEK/camel | public void setUpdateId ( Long updateId ) { this . updateId = updateId ; }
FingolfinTEK/camel | public IncomingMessage getMessage ( ) { return message ; }
FingolfinTEK/camel | public void setMessage ( IncomingMessage message ) { this . message = message ; }
FingolfinTEK/camel | @ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( " Update { " ) ; sb . append ( " updateId = " ) . append ( updateId ) ; sb . append ( " , ▁ message = " ) . append ( message ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; }
masaki-yamakawa/geode | public void setLocalAddr ( InternalDistributedMember localAddr ) { this . localAddr = localAddr ; conduit . setMemberId ( localAddr ) ; if ( disconnected ) { disconnected = false ; disconnectCompleted = false ; } }
masaki-yamakawa/geode | public CancelCriterion getCancelCriterion ( ) { return conduit . getCancelCriterion ( ) ; }
masaki-yamakawa/geode | public DirectChannel ( Membership < InternalDistributedMember > mgr , MessageListener < InternalDistributedMember > listener , ClusterDistributionManager dm ) throws ConnectionException { this . receiver = listener ; this . dm = dm ; this . stats = dm . getStats ( ) ; this . bufferPool = new BufferPool ( stats ) ; DistributionConfig dc = dm . getConfig ( ) ; this . address = initAddress ( dc ) ; boolean isBindAddress = dc . getBindAddress ( ) != null ; try { int port = Integer . getInteger ( " tcpServerPort " , 0 ) . intValue ( ) ; if ( port == 0 ) { port = dc . getTcpPort ( ) ; } Properties props = System . getProperties ( ) ; if ( props . getProperty ( " p2p . shareSockets " ) == null ) { props . setProperty ( " p2p . shareSockets " , String . valueOf ( dc . getConserveSockets ( ) ) ) ; } if ( dc . getSocketBufferSize ( ) != DistributionConfig . DEFAULT_SOCKET_BUFFER_SIZE ) { props . setProperty ( " p2p . tcpBufferSize " , String . valueOf ( dc . getSocketBufferSize ( ) ) ) ; } if ( props . getProperty ( " p2p . idleConnectionTimeout " ) == null ) { props . setProperty ( " p2p . idleConnectionTimeout " , String . valueOf ( dc . getSocketLeaseTime ( ) ) ) ; } int [ ] range = dc . getMembershipPortRange ( ) ; props . setProperty ( " membership _ port _ range _ start " , " " + range [ 0 ] ) ; props . setProperty ( " membership _ port _ range _ end " , " " + range [ 1 ] ) ; this . conduit = new TCPConduit ( mgr , port , address , isBindAddress , this , bufferPool , props ) ; disconnected = false ; disconnectCompleted = false ; logger . info ( " GemFire ▁ P2P ▁ Listener ▁ started ▁ on ▁ { } " , conduit . getSocketId ( ) ) ; } catch ( ConnectionException ce ) { logger . fatal ( String . format ( " Unable ▁ to ▁ initialize ▁ direct ▁ channel ▁ because : ▁ % s " , new Object [ ] { ce . getMessage ( ) } ) , ce ) ; throw ce ; } }
masaki-yamakawa/geode | boolean threadOwnsResources ( ) { if ( dm != null ) { return dm . getSystem ( ) . threadOwnsResources ( ) && ! AlertingAction . isThreadAlerting ( ) ; } return false ; }
masaki-yamakawa/geode | public BufferPool getBufferPool ( ) { return bufferPool ; }
masaki-yamakawa/geode | if ( msg instanceof DirectReplyMessage ) { directMsg = ( DirectReplyMessage ) msg ; }
masaki-yamakawa/geode | if ( directMsg != null || msg . getProcessorId ( ) > 0 ) { ackTimeout = ( int ) ( ackWaitThreshold * 1000 ) ; if ( msg . isSevereAlertCompatible ( ) || ReplyProcessor21 . isSevereAlertProcessingForced ( ) ) { ackSDTimeout = ( int ) ( ackSAThreshold * 1000 ) ; if ( ReplyProcessor21 . getShortSevereAlertProcessing ( ) ) { ackSDTimeout = ( int ) ( ReplyProcessor21 . PR_SEVERE_ALERT_RATIO * ackSDTimeout ) ; } } }
masaki-yamakawa/geode | if ( directMsg != null && directMsg . supportsDirectAck ( ) && threadOwnsResources ( ) ) { directReply = true ; }
masaki-yamakawa/geode | if ( ! directReply && directMsg != null ) { directMsg . registerProcessor ( ) ; }
masaki-yamakawa/geode | if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Sending ▁ ( { } ) ▁ to ▁ { } ▁ peers ▁ ( { } ) ▁ via ▁ tcp / ip " , msg , p_destinations . length , Arrays . toString ( p_destinations ) ) ; }
masaki-yamakawa/geode | if ( retryInfo != null ) { List retryMembers = retryInfo . getMembers ( ) ; InternalDistributedMember [ ] retryDest = new InternalDistributedMember [ retryMembers . size ( ) ] ; retryDest = ( InternalDistributedMember [ ] ) retryMembers . toArray ( retryDest ) ; destinations = retryDest ; retryInfo = null ; retry = true ; }
masaki-yamakawa/geode | if ( directReply && msg . getProcessorId ( ) > 0 ) { directReply = false ; }
masaki-yamakawa/geode | if ( ce != null ) { if ( failedCe != null ) { failedCe . getMembers ( ) . addAll ( ce . getMembers ( ) ) ; failedCe . getCauses ( ) . addAll ( ce . getCauses ( ) ) ; } else { failedCe = ce ; } ce = null ; }
masaki-yamakawa/geode | if ( cons . isEmpty ( ) ) { if ( failedCe != null ) { throw failedCe ; } return bytesWritten ; }
masaki-yamakawa/geode | if ( logger . isDebugEnabled ( ) ) { logger . debug ( " { } ▁ on ▁ these ▁ { } ▁ connections : ▁ { } " , ( retry ? " Retrying ▁ send " : " Sending " ) , cons . size ( ) , cons ) ; }
masaki-yamakawa/geode | if ( ackTimeout > 0 ) { startTime = System . currentTimeMillis ( ) ; }
masaki-yamakawa/geode | if ( bytesWritten == 0 ) { bytesWritten = result ; }
masaki-yamakawa/geode | catch ( NotSerializableException e ) { throw e ; }
masaki-yamakawa/geode | catch ( IOException ex ) { throw new InternalGemFireException ( " Unknown ▁ error ▁ serializing ▁ message " , ex ) ; }
masaki-yamakawa/geode | catch ( IOException e ) { throw new InternalGemFireException ( " Unknown ▁ error ▁ serializing ▁ message " , e ) ; }
masaki-yamakawa/geode | if ( ce != null ) { retryInfo = ce ; ce = null ; }
masaki-yamakawa/geode | if ( directReply && ! sentCons . isEmpty ( ) ) { long readAckStart = 0 ; if ( stats != null ) { readAckStart = stats . startReplyWait ( ) ; } try { ce = readAcks ( sentCons , startTime , ackTimeout , ackSDTimeout , ce , directMsg . getDirectReplyProcessor ( ) ) ; } finally { if ( stats != null ) { stats . endReplyWait ( readAckStart , startTime ) ; } } }
masaki-yamakawa/geode | if ( ce != null ) { if ( retryInfo != null ) { retryInfo . getMembers ( ) . addAll ( ce . getMembers ( ) ) ; retryInfo . getCauses ( ) . addAll ( ce . getCauses ( ) ) ; } else { retryInfo = ce ; } ce = null ; }
masaki-yamakawa/geode | if ( retryInfo != null ) { this . conduit . getCancelCriterion ( ) . checkCancelInProgress ( null ) ; }
masaki-yamakawa/geode | if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; }
masaki-yamakawa/geode | ) { Connection con = ( Connection ) it . next ( ) ; con . setInUse ( false , 0 , 0 , 0 , null ) ; }
masaki-yamakawa/geode | if ( failedCe != null ) { throw failedCe ; }
masaki-yamakawa/geode | private ConnectExceptions readAcks ( List sentCons , long startTime , long ackTimeout , long ackSDTimeout , ConnectExceptions cumulativeExceptions , DirectReplyProcessor processor ) { ConnectExceptions ce = cumulativeExceptions ; for ( Iterator it = sentCons . iterator ( ) ; it . hasNext ( ) ; ) { Connection con = ( Connection ) it . next ( ) ; if ( con . isSharedResource ( ) ) { continue ; } try { try { con . readAck ( processor ) ; } catch ( SocketTimeoutException ex ) { handleAckTimeout ( ackTimeout , ackSDTimeout , con , processor ) ; } } catch ( ConnectionException conEx ) { if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( con . getRemoteAddress ( ) , conEx ) ; } } return ce ; }
masaki-yamakawa/geode | private ConnectExceptions getConnections ( Membership mgr , DistributionMessage msg , InternalDistributedMember [ ] destinations , boolean preserveOrder , boolean retry , long ackTimeout , long ackSDTimeout , List cons ) { ConnectExceptions ce = null ; for ( int i = 0 ; i < destinations . length ; i ++ ) { InternalDistributedMember destination = destinations [ i ] ; if ( destination == null ) { continue ; } if ( localAddr . equals ( destination ) ) { continue ; } if ( ! mgr . memberExists ( destination ) || mgr . shutdownInProgress ( ) || mgr . isShunned ( destination ) ) { if ( logger . isTraceEnabled ( LogMarker . DM_VERBOSE ) ) { logger . trace ( LogMarker . DM_VERBOSE , " Not ▁ a ▁ member : ▁ { } " , destination ) ; } if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( destination , new ShunnedMemberException ( String . format ( " Member ▁ is ▁ being ▁ shunned : ▁ % s " , destination ) ) ) ; } else { try { long startTime = 0 ; if ( ackTimeout > 0 ) { startTime = System . currentTimeMillis ( ) ; } Connection con = conduit . getConnection ( destination , preserveOrder , retry , startTime , ackTimeout , ackSDTimeout ) ; con . setInUse ( true , startTime , 0 , 0 , null ) ; cons . add ( con ) ; if ( con . isSharedResource ( ) && msg instanceof DirectReplyMessage ) { DirectReplyMessage directMessage = ( DirectReplyMessage ) msg ; directMessage . registerProcessor ( ) ; } } catch ( IOException ex ) { if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( destination , ex ) ; } } } return ce ; }
masaki-yamakawa/geode | if ( disconnected ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ channel ▁ is ▁ disconnected : ▁ { } " , msg ) ; } return 0 ; }
masaki-yamakawa/geode | if ( destinations == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ null ▁ set ▁ passed ▁ in : ▁ { } " , msg ) ; } return 0 ; }
masaki-yamakawa/geode | if ( destinations . length == 0 ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ empty ▁ destinations ▁ passed ▁ in ▁ { } " , msg ) ; } return 0 ; }
masaki-yamakawa/geode | if ( destinations . length == 1 ) { return sendToOne ( mgr , destinations , msg , ackWaitThreshold , ackSAThreshold ) ; }
masaki-yamakawa/geode | public DMStats getDMStats ( ) { return stats ; }
masaki-yamakawa/geode | public DistributionConfig getDMConfig ( ) { if ( dm != null ) { return dm . getConfig ( ) ; } else { return null ; } }
masaki-yamakawa/geode | public DistributionManager getDM ( ) { return dm ; }
masaki-yamakawa/geode | private void handleAckTimeout ( long ackTimeout , long ackSATimeout , Connection c , DirectReplyProcessor processor ) throws ConnectionException { Set activeMembers = dm . getDistributionManagerIds ( ) ; dm . getStats ( ) . incReplyTimeouts ( ) ; { String msg = " % s ▁ seconds ▁ have ▁ elapsed ▁ while ▁ waiting ▁ for ▁ reply ▁ from ▁ % s ▁ on ▁ % s ▁ whose ▁ current ▁ membership ▁ list ▁ is : ▁ [ % s ] " ; final Object [ ] msgArgs = new Object [ ] { Long . valueOf ( ackTimeout / 1000 ) , c . getRemoteAddress ( ) , dm . getId ( ) , activeMembers } ; logger . warn ( String . format ( msg , msgArgs ) ) ; msgArgs [ 3 ] = " ( omitted ) " ; Breadcrumbs . setProblem ( msg , msgArgs ) ; if ( ReplyProcessor21 . THROW_EXCEPTION_ON_TIMEOUT ) { TimeoutException cause = new TimeoutException ( " Timed ▁ out ▁ waiting ▁ for ▁ ACKS . " ) ; throw new InternalGemFireException ( String . format ( msg , msgArgs ) , cause ) ; } } if ( activeMembers . contains ( c . getRemoteAddress ( ) ) ) { if ( ackSATimeout > 0 ) { try { c . readAck ( processor ) ; return ; } catch ( SocketTimeoutException e ) { Object [ ] args = new Object [ ] { Long . valueOf ( ( ackSATimeout + ackTimeout ) / 1000 ) , c . getRemoteAddress ( ) , dm . getId ( ) , activeMembers } ; logger . fatal ( " { } ▁ seconds ▁ have ▁ elapsed ▁ while ▁ waiting ▁ for ▁ reply ▁ from ▁ { } ▁ on ▁ { } ▁ whose ▁ currentFull ▁ membership ▁ list ▁ is : ▁ [ { } ] " , args ) ; } } try { c . readAck ( processor ) ; } catch ( SocketTimeoutException ex ) { logger . error ( String . format ( " Unexpected ▁ timeout ▁ while ▁ waiting ▁ for ▁ ack ▁ from ▁ % s " , c . getRemoteAddress ( ) ) , ex ) ; } } else { logger . warn ( " View ▁ no ▁ longer ▁ has ▁ { } ▁ as ▁ an ▁ active ▁ member , ▁ so ▁ we ▁ will ▁ no ▁ longer ▁ wait ▁ for ▁ it . " , c . getRemoteAddress ( ) ) ; processor . memberDeparted ( getDM ( ) , c . getRemoteAddress ( ) , true ) ; } }
masaki-yamakawa/geode | public void receive ( DistributionMessage msg , int bytesRead ) throws MemberShunnedException { if ( disconnected ) { return ; } try { receiver . messageReceived ( msg ) ; } catch ( MemberShunnedException e ) { throw e ; } catch ( CancelException e ) { } catch ( Exception ex ) { if ( ! conduit . getCancelCriterion ( ) . isCancelInProgress ( ) ) { logger . fatal ( " While ▁ pulling ▁ a ▁ message " , ex ) ; } } }
masaki-yamakawa/geode | public void emergencyClose ( ) { this . conduit . emergencyClose ( ) ; }
masaki-yamakawa/geode | public synchronized void disconnect ( Exception cause ) { this . disconnected = true ; this . disconnectCompleted = false ; this . conduit . stop ( cause ) ; this . disconnectCompleted = true ; }
masaki-yamakawa/geode | public boolean isOpen ( ) { return ! disconnectCompleted ; }
masaki-yamakawa/geode | protected MessageListener getReceiver ( ) { return receiver ; }
masaki-yamakawa/geode | public int getPort ( ) { return this . conduit . getPort ( ) ; }
masaki-yamakawa/geode | public TCPConduit getConduit ( ) { return this . conduit ; }
masaki-yamakawa/geode | private InetAddress initAddress ( DistributionConfig dc ) { String bindAddress = dc . getBindAddress ( ) ; try { if ( bindAddress != null && bindAddress . length ( ) > 0 ) { return InetAddress . getByName ( bindAddress ) ; } else { return LocalHostUtil . getLocalHost ( ) ; } } catch ( java . net . UnknownHostException unhe ) { throw new RuntimeException ( unhe ) ; } }
masaki-yamakawa/geode | public void closeEndpoint ( InternalDistributedMember member , String reason , boolean notifyDisconnect ) { TCPConduit tc = this . conduit ; if ( tc != null ) { tc . removeEndpoint ( member , reason , notifyDisconnect ) ; } }
masaki-yamakawa/geode | public void getChannelStates ( DistributedMember member , Map result ) { TCPConduit tc = this . conduit ; if ( tc != null ) { tc . getThreadOwnedOrderedConnectionState ( member , result ) ; } }
masaki-yamakawa/geode | public void waitForChannelState ( DistributedMember member , Map channelState ) throws InterruptedException { if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } TCPConduit tc = this . conduit ; if ( tc != null ) { tc . waitForThreadOwnedOrderedConnectionState ( member , channelState ) ; } }
masaki-yamakawa/geode | public boolean hasReceiversFor ( DistributedMember mbr ) { return this . conduit . hasReceiversFor ( mbr ) ; }
glaucio-melo-movile/activemq-artemis | @ Before public void startBroker ( ) throws Exception { broker = createBroker ( ) ; TransportConnector connector = broker . addConnector ( " tcp : // 0.0.0.0:0" ) ; broker . deleteAllMessages ( ) ; broker . start ( ) ; broker . waitUntilStarted ( ) ; PolicyEntry policy = new PolicyEntry ( ) ; policy . setMaxBrowsePageSize ( browserLimit ) ; broker . setDestinationPolicy ( new PolicyMap ( ) ) ; broker . getDestinationPolicy ( ) . setDefaultEntry ( policy ) ; connectUri = connector . getConnectUri ( ) ; factory = new ActiveMQConnectionFactory ( connectUri ) ; }
glaucio-melo-movile/activemq-artemis | public BrokerService createBroker ( ) throws IOException { return new BrokerService ( ) ; }
glaucio-melo-movile/activemq-artemis | @ After public void stopBroker ( ) throws Exception { broker . stop ( ) ; broker . waitUntilStopped ( ) ; }
glaucio-melo-movile/activemq-artemis | @ Test public void testBrowsingLimited ( ) throws Exception { int messageToSend = 470 ; ActiveMQQueue queue = new ActiveMQQueue ( " TEST " ) ; Connection connection = factory . createConnection ( ) ; connection . start ( ) ; Session session = connection . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; MessageProducer producer = session . createProducer ( queue ) ; String data = " " ; for ( int i = 0 ; i < 1024 * 2 ; i ++ ) { data += " x " ; } for ( int i = 0 ; i < messageToSend ; i ++ ) { producer . send ( session . createTextMessage ( data ) ) ; } QueueBrowser browser = session . createBrowser ( queue ) ; Enumeration < ? > enumeration = browser . getEnumeration ( ) ; int received = 0 ; while ( enumeration . hasMoreElements ( ) ) { Message m = ( Message ) enumeration . nextElement ( ) ; received ++ ; LOG . info ( " Browsed ▁ message ▁ " + received + " : ▁ " + m . getJMSMessageID ( ) ) ; } browser . close ( ) ; assertEquals ( browserLimit , received ) ; }
longkerdandy/chii2mqtt | public PubRelMessage ( ) { }
longkerdandy/chii2mqtt | public PubRelMessage ( boolean dupFlag , int messageID ) { this . messageType = MessageType . PUBREL ; this . qosLevel = QoSLevel . LEAST_ONCE ; this . dupFlag = dupFlag ; this . messageID = messageID ; this . remainingLength = calculateRemainingLength ( ) ; }
longkerdandy/chii2mqtt | @ Override protected int calculateRemainingLength ( ) { return 2 ; }
longkerdandy/chii2mqtt | @ Override public void validate ( ) { if ( messageID < 0 ) { throw new IllegalStateException ( " Negative ▁ Message ▁ ID . " ) ; } }
longkerdandy/chii2mqtt | public int getMessageID ( ) { return messageID ; }
longkerdandy/chii2mqtt | public void setMessageID ( int messageID ) { this . messageID = messageID ; }
kaiyuntao/tao | public long getId ( ) { return id ; }
kaiyuntao/tao | public void setId ( long id ) { this . id = id ; }
kaiyuntao/tao | public long getUserId ( ) { return userId ; }
kaiyuntao/tao | public void setUserId ( long userId ) { this . userId = userId ; }
kaiyuntao/tao | public int getType ( ) { return type ; }
kaiyuntao/tao | public void setType ( int type ) { this . type = type ; }
kaiyuntao/tao | public String getAccount ( ) { return account ; }
kaiyuntao/tao | public void setAccount ( String account ) { this . account = account ; }
kaiyuntao/tao | public String getBank ( ) { return bank ; }
kaiyuntao/tao | public void setBank ( String bank ) { this . bank = bank ; }
kaiyuntao/tao | public String getName ( ) { return name ; }
kaiyuntao/tao | public void setName ( String name ) { this . name = name ; }
zhangleidaniejian/bluemmSite | public MallVirtualProduct get ( String id ) { return super . get ( id ) ; }
zhangleidaniejian/bluemmSite | public List < MallVirtualProduct > findList ( MallVirtualProduct mallVirtualProduct ) { return super . findList ( mallVirtualProduct ) ; }
zhangleidaniejian/bluemmSite | public Page < MallVirtualProduct > findPage ( Page < MallVirtualProduct > page , MallVirtualProduct mallVirtualProduct ) { return super . findPage ( page , mallVirtualProduct ) ; }
zhangleidaniejian/bluemmSite | @ Transactional ( readOnly = false ) public void save ( MallVirtualProduct mallVirtualProduct ) { super . save ( mallVirtualProduct ) ; }
zhangleidaniejian/bluemmSite | @ Transactional ( readOnly = false ) public void delete ( MallVirtualProduct mallVirtualProduct ) { super . delete ( mallVirtualProduct ) ; }
tudelft-atlarge/granula | public ExtractionRule ( int level ) { super ( level ) ; }
jstourac/undertow | public NonStandardResponseWrapper ( ServletResponse response ) { this . response = checkNotNullParam ( " response " , response ) ; }
jstourac/undertow | public ServletResponse getResponse ( ) { return this . response ; }
jstourac/undertow | public void setResponse ( ServletResponse response ) { this . response = checkNotNullParam ( " response " , response ) ; }
jstourac/undertow | public void setCharacterEncoding ( String charset ) { this . response . setCharacterEncoding ( charset ) ; }
jstourac/undertow | public String getCharacterEncoding ( ) { return this . response . getCharacterEncoding ( ) ; }
jstourac/undertow | public ServletOutputStream getOutputStream ( ) throws IOException { return this . response . getOutputStream ( ) ; }
jstourac/undertow | public PrintWriter getWriter ( ) throws IOException { return this . response . getWriter ( ) ; }
jstourac/undertow | public void setContentLength ( int len ) { this . response . setContentLength ( len ) ; }
jstourac/undertow | public void setContentLengthLong ( long len ) { this . response . setContentLengthLong ( len ) ; }
jstourac/undertow | public void setContentType ( String type ) { this . response . setContentType ( type ) ; }
jstourac/undertow | public String getContentType ( ) { return this . response . getContentType ( ) ; }
jstourac/undertow | public void setBufferSize ( int size ) { this . response . setBufferSize ( size ) ; }
jstourac/undertow | public int getBufferSize ( ) { return this . response . getBufferSize ( ) ; }
jstourac/undertow | public void flushBuffer ( ) throws IOException { this . response . flushBuffer ( ) ; }
jstourac/undertow | public boolean isCommitted ( ) { return this . response . isCommitted ( ) ; }
jstourac/undertow | public void reset ( ) { this . response . reset ( ) ; }
jstourac/undertow | public void resetBuffer ( ) { this . response . resetBuffer ( ) ; }
jstourac/undertow | public void setLocale ( Locale loc ) { this . response . setLocale ( loc ) ; }
jstourac/undertow | public Locale getLocale ( ) { return this . response . getLocale ( ) ; }
jstourac/undertow | public boolean isWrapperFor ( ServletResponse wrapped ) { if ( response == wrapped ) { return true ; } else if ( response instanceof ServletResponseWrapper ) { return ( ( ServletResponseWrapper ) response ) . isWrapperFor ( wrapped ) ; } else { return false ; } }
jstourac/undertow | public boolean isWrapperFor ( Class < ? > wrappedType ) { if ( ! ServletResponse . class . isAssignableFrom ( wrappedType ) ) { throw new IllegalArgumentException ( " Given ▁ class ▁ " + wrappedType . getName ( ) + " ▁ not ▁ a ▁ subinterface ▁ of ▁ " + ServletResponse . class . getName ( ) ) ; } if ( wrappedType . isAssignableFrom ( response . getClass ( ) ) ) { return true ; } else if ( response instanceof ServletResponseWrapper ) { return ( ( ServletResponseWrapper ) response ) . isWrapperFor ( wrappedType ) ; } else { return false ; } }
jstourac/undertow | private HttpServletResponse _getHttpServletResponse ( ) { return ( HttpServletResponse ) response ; }
jstourac/undertow | @ Override public void addCookie ( Cookie cookie ) { this . _getHttpServletResponse ( ) . addCookie ( cookie ) ; }
jstourac/undertow | @ Override public boolean containsHeader ( String name ) { return this . _getHttpServletResponse ( ) . containsHeader ( name ) ; }
jstourac/undertow | @ Override public String encodeURL ( String url ) { return this . _getHttpServletResponse ( ) . encodeURL ( url ) ; }
jstourac/undertow | @ Override public String encodeRedirectURL ( String url ) { return this . _getHttpServletResponse ( ) . encodeRedirectURL ( url ) ; }
jstourac/undertow | @ Override public String encodeUrl ( String url ) { return this . _getHttpServletResponse ( ) . encodeUrl ( url ) ; }
jstourac/undertow | @ Override public String encodeRedirectUrl ( String url ) { return this . _getHttpServletResponse ( ) . encodeRedirectUrl ( url ) ; }
jstourac/undertow | @ Override public void sendError ( int sc , String msg ) throws IOException { this . _getHttpServletResponse ( ) . sendError ( sc , msg ) ; }
jstourac/undertow | @ Override public void sendError ( int sc ) throws IOException { this . _getHttpServletResponse ( ) . sendError ( sc ) ; }
jstourac/undertow | @ Override public void sendRedirect ( String location ) throws IOException { this . _getHttpServletResponse ( ) . sendRedirect ( location ) ; }
jstourac/undertow | @ Override public void setDateHeader ( String name , long date ) { this . _getHttpServletResponse ( ) . setDateHeader ( name , date ) ; }
jstourac/undertow | @ Override public void addDateHeader ( String name , long date ) { this . _getHttpServletResponse ( ) . addDateHeader ( name , date ) ; }
jstourac/undertow | @ Override public void setHeader ( String name , String value ) { this . _getHttpServletResponse ( ) . setHeader ( name , value ) ; }
jstourac/undertow | @ Override public void addHeader ( String name , String value ) { this . _getHttpServletResponse ( ) . addHeader ( name , value ) ; }
jstourac/undertow | @ Override public void setIntHeader ( String name , int value ) { this . _getHttpServletResponse ( ) . setIntHeader ( name , value ) ; }
jstourac/undertow | @ Override public void addIntHeader ( String name , int value ) { this . _getHttpServletResponse ( ) . addIntHeader ( name , value ) ; }
jstourac/undertow | @ Override public void setStatus ( int sc ) { this . _getHttpServletResponse ( ) . setStatus ( sc ) ; }
jstourac/undertow | @ Override public void setStatus ( int sc , String sm ) { this . _getHttpServletResponse ( ) . setStatus ( sc , sm ) ; }
jstourac/undertow | @ Override public int getStatus ( ) { return _getHttpServletResponse ( ) . getStatus ( ) ; }
jstourac/undertow | @ Override public String getHeader ( String name ) { return _getHttpServletResponse ( ) . getHeader ( name ) ; }
jstourac/undertow | @ Override public Collection < String > getHeaders ( String name ) { return _getHttpServletResponse ( ) . getHeaders ( name ) ; }
jstourac/undertow | @ Override public Collection < String > getHeaderNames ( ) { return _getHttpServletResponse ( ) . getHeaderNames ( ) ; }
eldemcan/markettsp | @ RequestMapping ( value = " / test " , method = RequestMethod . GET ) @ ResponseBody public String testMethod ( ) { return " Test ▁ OK " ; }
eldemcan/markettsp | @ RequestMapping ( value = " / poolrecent " , method = RequestMethod . GET ) @ ResponseBody public TradeMessageData poolRecentMessage ( ) { return consumerFacade . getRecentMessageData ( ) ; }
eldemcan/markettsp | @ RequestMapping ( value = " / poolall " , method = RequestMethod . GET ) @ ResponseBody public DeferredResult < List < TradeMessageData > > poolAllMessages ( ) { DeferredResult < List < TradeMessageData > > results = new DeferredResult < List < TradeMessageData > > ( ) ; results . setResult ( consumerFacade . findAllMessages ( ) ) ; return results ; }
eldemcan/markettsp | " ) @ ResponseBody public DeferredResult < List < TradeMessageData > > poolMessagesCountry ( @ PathVariable String country ) { DeferredResult < List < TradeMessageData > > results = new DeferredResult < List < TradeMessageData > > ( ) ; results . setResult ( consumerFacade . findTradeMessagesByCountryCode ( country ) ) ; return results ; }
jelsas/JavaItertools | public CountingIterator ( ) { this ( 0 ) ; }
jelsas/JavaItertools | public CountingIterator ( int start ) { count = start ; }
jelsas/JavaItertools | public boolean hasNext ( ) { return true ; }
jelsas/JavaItertools | public Integer next ( ) { return new Integer ( count ++ ) ; }
jelsas/JavaItertools | public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
jelsas/JavaItertools | public int nextInt ( ) { return count ++ ; }
milindaperera/product-ei | if ( createConsumer ) { if ( ExchangeType . QUEUE == this . consumerConfig . getExchangeType ( ) ) { this . createQueueConnection ( ) ; } else if ( ExchangeType . TOPIC == this . consumerConfig . getExchangeType ( ) ) { this . createTopicConnection ( ) ; } }
milindaperera/product-ei | if ( TopicSession . SESSION_TRANSACTED == this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) { topicSession = topicConnection . createTopicSession ( true , this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) ; }
milindaperera/product-ei | if ( this . consumerConfig . isDurable ( ) ) { if ( null != this . consumerConfig . getSelectors ( ) ) { receiver = topicSession . createDurableSubscriber ( topic , this . consumerConfig . getSubscriptionID ( ) , this . consumerConfig . getSelectors ( ) , false ) ; } else { receiver = topicSession . createDurableSubscriber ( topic , this . consumerConfig . getSubscriptionID ( ) ) ; } }
milindaperera/product-ei | if ( null != this . consumerConfig . getSelectors ( ) ) { receiver = topicSession . createSubscriber ( topic , this . consumerConfig . getSelectors ( ) , false ) ; }
milindaperera/product-ei | if ( QueueSession . SESSION_TRANSACTED == this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) { queueSession = queueConnection . createQueueSession ( true , this . consumerConfig . getAcknowledgeMode ( ) . getType ( ) ) ; }
milindaperera/product-ei | if ( null != this . consumerConfig . getSelectors ( ) ) { receiver = queueSession . createReceiver ( queue , this . consumerConfig . getSelectors ( ) ) ; }
milindaperera/product-ei | if ( null != connection && null != session && null != receiver ) { log . info ( " Starting ▁ Consumer " ) ; if ( this . consumerConfig . isAsync ( ) ) { receiver . setMessageListener ( this ) ; } else { Thread consumerThread = new Thread ( this ) ; consumerThread . start ( ) ; } }
milindaperera/product-ei | @ Override public void stopClient ( ) { Thread stopThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( null != connection && null != session && null != receiver ) { try { log . info ( " Closing ▁ Consumer " ) ; if ( ExchangeType . TOPIC == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { TopicSubscriber topicSubscriber = ( TopicSubscriber ) receiver ; topicSubscriber . close ( ) ; } if ( null != session ) { TopicSession topicSession = ( TopicSession ) session ; topicSession . close ( ) ; } if ( null != connection ) { TopicConnection topicConnection = ( TopicConnection ) connection ; topicConnection . close ( ) ; } } else if ( ExchangeType . QUEUE == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { QueueReceiver queueReceiver = ( QueueReceiver ) receiver ; queueReceiver . close ( ) ; } if ( null != session ) { QueueSession queueSession = ( QueueSession ) session ; queueSession . close ( ) ; } if ( null != connection ) { QueueConnection queueConnection = ( QueueConnection ) connection ; queueConnection . stop ( ) ; queueConnection . close ( ) ; } } receiver = null ; session = null ; connection = null ; log . info ( " Consumer ▁ Closed " ) ; } catch ( JMSException e ) { log . error ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; throw new RuntimeException ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; } } } } ) ; stopThread . start ( ) ; try { stopThread . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Error ▁ waiting ▁ for ▁ subscriber ▁ to ▁ stop " , e ) ; } }
milindaperera/product-ei | public void stopClientSync ( ) { if ( null != connection && null != session && null != receiver ) { try { log . info ( " Closing ▁ Consumer " ) ; if ( ExchangeType . TOPIC == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { TopicSubscriber topicSubscriber = ( TopicSubscriber ) receiver ; topicSubscriber . close ( ) ; } if ( null != session ) { TopicSession topicSession = ( TopicSession ) session ; topicSession . close ( ) ; } if ( null != connection ) { TopicConnection topicConnection = ( TopicConnection ) connection ; topicConnection . close ( ) ; } } else if ( ExchangeType . QUEUE == consumerConfig . getExchangeType ( ) ) { if ( null != receiver ) { QueueReceiver queueReceiver = ( QueueReceiver ) receiver ; queueReceiver . close ( ) ; } if ( null != session ) { QueueSession queueSession = ( QueueSession ) session ; queueSession . close ( ) ; } if ( null != connection ) { QueueConnection queueConnection = ( QueueConnection ) connection ; queueConnection . stop ( ) ; queueConnection . close ( ) ; } } receiver = null ; session = null ; connection = null ; log . info ( " Consumer ▁ Closed " ) ; } catch ( JMSException e ) { log . error ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; throw new RuntimeException ( " Error ▁ in ▁ stopping ▁ client . " , e ) ; } } }
milindaperera/product-ei | public void unSubscribe ( final boolean stopClient ) throws JMSException { Thread unsubscribeThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { if ( null != connection && null != session && null != receiver ) { try { log . info ( " Un - subscribing ▁ Subscriber " ) ; session . unsubscribe ( consumerConfig . getSubscriptionID ( ) ) ; log . info ( " Subscriber ▁ Un - Subscribed " ) ; if ( stopClient ) { stopClient ( ) ; } } catch ( JMSException e ) { log . error ( " Error ▁ in ▁ removing ▁ subscription ( un - subscribing ) . " , e ) ; throw new RuntimeException ( " JMSException ▁ : ▁ Error ▁ in ▁ removing ▁ subscription ( un - subscribing ) . " , e ) ; } } else { AndesClientException andesClientException = new AndesClientException ( " The ▁ connection , ▁ session ▁ and ▁ message ▁ receiver ▁ is ▁ not ▁ assigned . " ) ; log . error ( " The ▁ connection , ▁ session ▁ and ▁ message ▁ receiver ▁ is ▁ not ▁ assigned . " , andesClientException ) ; throw new RuntimeException ( " The ▁ connection , ▁ session ▁ and ▁ message ▁ receiver ▁ is ▁ not ▁ assigned . " , andesClientException ) ; } } } ) ; unsubscribeThread . start ( ) ; try { unsubscribeThread . join ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Error ▁ waiting ▁ for ▁ consumer ▁ to ▁ unsubscribe " , e ) ; } }
milindaperera/product-ei | @ Override public void run ( ) { try { boolean interrupted = false ; while ( true ) { Message message = this . receiver . receive ( ) ; if ( null == message ) { interrupted = true ; break ; } else if ( processReceivedMessage ( message ) ) { break ; } } if ( ! interrupted ) { stopClientSync ( ) ; } } catch ( JMSException e ) { log . error ( " Error ▁ while ▁ receiving ▁ messages ▁ " , e ) ; throw new RuntimeException ( " JMSException ▁ : ▁ Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; } catch ( IOException e ) { log . error ( " Error ▁ while ▁ writing ▁ message ▁ to ▁ file " , e ) ; throw new RuntimeException ( " IOException ▁ : ▁ Error ▁ while ▁ writing ▁ message ▁ to ▁ file \" " , e ) ; } }
milindaperera/product-ei | @ Override public void onMessage ( Message message ) { try { boolean success = this . processReceivedMessage ( message ) ; if ( success ) { stopClient ( ) ; } } catch ( JMSException e ) { log . error ( " Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; throw new RuntimeException ( " Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; } catch ( IOException e ) { log . error ( " Error ▁ while ▁ writing ▁ message ▁ to ▁ file " , e ) ; throw new RuntimeException ( " Error ▁ while ▁ listening ▁ to ▁ messages " , e ) ; } }
milindaperera/product-ei | if ( null != message ) { long threadID = Thread . currentThread ( ) . getId ( ) ; long currentTimeStamp = System . currentTimeMillis ( ) ; this . totalLatency = this . totalLatency + ( currentTimeStamp - message . getJMSTimestamp ( ) ) ; if ( 0 == this . firstMessageConsumedTimestamp ) { this . firstMessageConsumedTimestamp = currentTimeStamp ; } this . lastMessageConsumedTimestamp = currentTimeStamp ; this . receivedMessageCount . incrementAndGet ( ) ; JMSDeliveryStatus deliveryStatus ; if ( message . getJMSRedelivered ( ) ) { deliveryStatus = JMSDeliveryStatus . REDELIVERED ; } else { deliveryStatus = JMSDeliveryStatus . ORIGINAL ; } if ( 0 == this . receivedMessageCount . get ( ) % this . consumerConfig . getPrintsPerMessageCount ( ) ) { log . info ( " [ RECEIVE ] ▁ ThreadID : " + threadID + " ▁ Destination ( " + this . consumerConfig . getExchangeType ( ) . getType ( ) + " ) : " + this . consumerConfig . getDestinationName ( ) + " ▁ ReceivedMessageCount : " + this . receivedMessageCount + " ▁ MessageToReceive : " + this . consumerConfig . getMaximumMessagesToReceived ( ) + " ▁ Original / Redelivered : " + deliveryStatus . getStatus ( ) ) ; } if ( null != this . consumerConfig . getFilePathToWriteStatistics ( ) ) { String statisticsString = Long . toString ( currentTimeStamp ) + " , " + Double . toString ( this . getConsumerTPS ( ) ) + " , " + Double . toString ( this . getAverageLatency ( ) ) ; AndesClientUtils . writeStatisticsToFile ( statisticsString , this . consumerConfig . getFilePathToWriteStatistics ( ) ) ; } if ( message instanceof TextMessage ) { TextMessage textMessage = ( TextMessage ) message ; if ( null != this . consumerConfig . getFilePathToWriteReceivedMessages ( ) ) { AndesClientUtils . writeReceivedMessagesToFile ( textMessage . getText ( ) , this . consumerConfig . getFilePathToWriteReceivedMessages ( ) ) ; } else { this . consumerConfig . addReceivedMessage ( textMessage . getText ( ) ) ; } } if ( 0 == this . receivedMessageCount . get ( ) % this . consumerConfig . getAcknowledgeAfterEachMessageCount ( ) ) { if ( Session . CLIENT_ACKNOWLEDGE == session . getAcknowledgeMode ( ) ) { message . acknowledge ( ) ; log . info ( " Acknowledging ▁ message ▁ : ▁ " + message . getJMSMessageID ( ) ) ; } } if ( 0 == this . receivedMessageCount . get ( ) % consumerConfig . getCommitAfterEachMessageCount ( ) ) { session . commit ( ) ; log . info ( " Committed ▁ session " ) ; } else if ( 0 == this . receivedMessageCount . get ( ) % consumerConfig . getRollbackAfterEachMessageCount ( ) ) { session . rollback ( ) ; log . info ( " Roll - backed ▁ session " ) ; } else if ( 0 == this . receivedMessageCount . get ( ) % consumerConfig . getRecoverAfterEachMessageCount ( ) ) { log . info ( " Recovering ▁ session " ) ; session . recover ( ) ; } if ( this . receivedMessageCount . get ( ) >= consumerConfig . getUnSubscribeAfterEachMessageCount ( ) ) { unSubscribe ( true ) ; AndesClientUtils . sleepForInterval ( 1000L ) ; return true ; } else if ( this . receivedMessageCount . get ( ) >= consumerConfig . getMaximumMessagesToReceived ( ) ) { return true ; } if ( 0 < consumerConfig . getRunningDelay ( ) ) { try { Thread . sleep ( consumerConfig . getRunningDelay ( ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } }
milindaperera/product-ei | public AtomicLong getReceivedMessageCount ( ) { return this . receivedMessageCount ; }
milindaperera/product-ei | public double getConsumerTPS ( ) { if ( 0 == this . lastMessageConsumedTimestamp - this . firstMessageConsumedTimestamp ) { return this . receivedMessageCount . doubleValue ( ) / ( 1D / 1000 ) ; } else { return this . receivedMessageCount . doubleValue ( ) / ( ( ( double ) ( this . lastMessageConsumedTimestamp - this . firstMessageConsumedTimestamp ) ) / 1000D ) ; } }
milindaperera/product-ei | public double getAverageLatency ( ) { if ( 0 == this . receivedMessageCount . doubleValue ( ) ) { log . warn ( " No ▁ messages ▁ were ▁ received ▁ to ▁ calculate ▁ average ▁ latency . " ) ; return 0D ; } else { return ( ( ( double ) this . totalLatency ) / 1000D ) / this . receivedMessageCount . doubleValue ( ) ; } }
milindaperera/product-ei | @ Override public AndesJMSConsumerClientConfiguration getConfig ( ) { return this . consumerConfig ; }
milindaperera/product-ei | public Connection getConnection ( ) { return this . connection ; }
milindaperera/product-ei | public void setConnection ( Connection connection ) { this . connection = connection ; }
milindaperera/product-ei | public Session getSession ( ) { return this . session ; }
milindaperera/product-ei | public void setSession ( Session session ) { this . session = session ; }
milindaperera/product-ei | public MessageConsumer getReceiver ( ) { return this . receiver ; }
milindaperera/product-ei | public void setReceiver ( MessageConsumer receiver ) { this . receiver = receiver ; }
VHAINNOVATIONS/Telepathology | private ImageExchangeApplicationContext ( ) { super ( effectiveApplicationContext ) ; }
RedHotChiliBots/FRC4453 | public OI ( ) { System . out . println ( " OI ▁ starting . . . " ) ; drive1Controller = new Joystick ( RobotMap . FIRST_CONTROLLER ) ; }
RedHotChiliBots/FRC4453 | public Joystick getDrive1Controller ( ) { return drive1Controller ; }
RedHotChiliBots/FRC4453 | public double getLeftYDriveStick ( ) { double leftY = drive1Controller . getRawAxis ( RobotMap . Y_AXIS ) ; return ( Math . abs ( leftY ) < 0.15 ? 0.0 : - leftY ) ; }
RedHotChiliBots/FRC4453 | public double getLeftXDriveStick ( ) { double leftX = drive1Controller . getRawAxis ( RobotMap . X_AXIS ) ; return ( Math . abs ( leftX ) < 0.15 ? 0.0 : - leftX ) ; }
RedHotChiliBots/FRC4453 | public double getThrottleDrive ( ) { double leftZ = drive1Controller . getRawAxis ( RobotMap . THROTTLE_AXIS ) ; return 0.35 * - leftZ + 0.65 ; }
james345221/coolweather | public int getId ( ) { return id ; }
james345221/coolweather | public void setId ( int id ) { this . id = id ; }
james345221/coolweather | public String getCityName ( ) { return cityName ; }
james345221/coolweather | public void setCityName ( String cityName ) { this . cityName = cityName ; }
james345221/coolweather | public int getCityCode ( ) { return cityCode ; }
james345221/coolweather | public void setCityCode ( int cityCode ) { this . cityCode = cityCode ; }
james345221/coolweather | public int getProvinceId ( ) { return provinceId ; }
james345221/coolweather | public void setProvinceId ( int provinceId ) { this . provinceId = provinceId ; }
Svish/hyperic-sonicmq-plugin | public DomainOptions ( Properties properties ) { validate ( properties , Options . Domain . Name , Options . Domain . Location , Options . Domain . Username , Options . Domain . Password ) ; domain = properties . getProperty ( Options . Domain . Name ) ; location = properties . getProperty ( Options . Domain . Location ) ; username = properties . getProperty ( Options . Domain . Username ) ; password = properties . getProperty ( Options . Domain . Password ) ; id = properties . getProperty ( Options . Component . Id , domain + " . DIRECTORY ▁ SERVICE : ID = DIRECTORY ▁ SERVICE " ) ; }
ivelin1936/Studing-SoftUni- | @ Autowired public OfferServiceImpl ( OfferRepository offerRepository , ModelMapper modelMapper , Validator validator ) { this . offerRepository = offerRepository ; this . modelMapper = modelMapper ; this . validator = validator ; }
ivelin1936/Studing-SoftUni- | @ Override public void register ( OfferServiceModel serviceModel ) { if ( validator . validate ( serviceModel ) . size ( ) != DEFAULT_CONSTRAINT_VIOLATION_SIZE ) { throw new IllegalArgumentException ( DEFAULT_INVALID_MODEL_MESSAGE ) ; } Offer offerEntity = this . modelMapper . map ( serviceModel , Offer . class ) ; this . offerRepository . saveAndFlush ( offerEntity ) ; }
ivelin1936/Studing-SoftUni- | @ Override public List < OfferServiceModel > findAll ( ) { return this . offerRepository . findAll ( ) . stream ( ) . map ( entity -> this . modelMapper . map ( entity , OfferServiceModel . class ) ) . collect ( Collectors . toList ( ) ) ; }
ivelin1936/Studing-SoftUni- | @ Override public void findOffer ( OfferFindServiceModel model ) { if ( this . validator . validate ( model ) . size ( ) != DEFAULT_CONSTRAINT_VIOLATION_SIZE ) { throw new IllegalArgumentException ( DEFAULT_INVALID_MODEL_MESSAGE ) ; } Offer offer = this . offerRepository . findAll ( ) . stream ( ) . filter ( o -> o . getApartmentType ( ) . toLowerCase ( ) . equals ( model . getApartmentType ( ) . toLowerCase ( ) ) && this . isFamilyBudgetEnough ( model . getFamilyBudget ( ) , o ) ) . findFirst ( ) . orElse ( null ) ; if ( offer == null ) { throw new IllegalArgumentException ( DEFAULT_NOT_FOUND_OFFER_MESSAGE ) ; } this . offerRepository . delete ( offer ) ; }
ivelin1936/Studing-SoftUni- | private boolean isFamilyBudgetEnough ( BigDecimal familyBudget , Offer offer ) { BigDecimal finalPrice = offer . getApartmentRent ( ) . add ( offer . getAgencyCommission ( ) . divide ( new BigDecimal ( 100 ) ) . multiply ( offer . getApartmentRent ( ) ) ) ; return familyBudget . compareTo ( finalPrice ) >= 0 ; }
mocircle/cidrawing | @ Override public void applyMatrixForData ( Matrix matrix ) { super . applyMatrixForData ( matrix ) ; boundingPath . transform ( matrix ) ; }
mocircle/cidrawing | @ Override public void updateBoundingBox ( ) { if ( boundingPath != null ) { RectF box = new RectF ( ) ; boundingPath . computeBounds ( box , true ) ; setBoundingBox ( box ) ; } }
mocircle/cidrawing | @ Override public RectF getOuterBoundingBox ( ) { if ( boundingPath != null ) { Path path = new Path ( boundingPath ) ; path . transform ( getDisplayMatrix ( ) ) ; RectF box = new RectF ( ) ; path . computeBounds ( box , true ) ; return box ; } return new RectF ( ) ; }
mocircle/cidrawing | @ Override public Path getTouchableArea ( ) { if ( boundingPath != null ) { return boundingPath ; } else { return new Path ( ) ; } }
mocircle/cidrawing | @ Override protected void cloneTo ( BaseElement element ) { super . cloneTo ( element ) ; if ( element instanceof BoundsElement ) { BoundsElement obj = ( BoundsElement ) element ; if ( originalBoundingBox != null ) { obj . originalBoundingBox = new RectF ( originalBoundingBox ) ; } if ( boundingPath != null ) { obj . boundingPath = new Path ( boundingPath ) ; } } }
mocircle/cidrawing | protected void updateBoundingBoxWithDataMatrix ( ) { boundingPath . transform ( getDataMatrix ( ) ) ; updateBoundingBox ( ) ; }
shigengyu/Hyperion | public ListHashMap < K , V > addAll ( Iterable < V > values , Function < V , K > keySelector ) { for ( V value : values ) { K key = keySelector . apply ( value ) ; addItem ( key , value ) ; } return this ; }
shigengyu/Hyperion | public ListHashMap < K , V > addItem ( K key , V value ) { if ( ! map . containsKey ( key ) ) { map . put ( key , new ArrayList < V > ( ) ) ; } map . get ( key ) . add ( value ) ; return this ; }
shigengyu/Hyperion | public boolean containsItems ( String key , V item ) { return map . containsKey ( key ) && map . get ( key ) . contains ( item ) ; }
shigengyu/Hyperion | public boolean containsKey ( String key ) { return map . containsKey ( key ) ; }
shigengyu/Hyperion | public List < V > get ( K key ) { List < V > mutable = getMutable ( key ) ; if ( mutable == null ) { return null ; } return ImmutableList . copyOf ( mutable ) ; }
shigengyu/Hyperion | public List < V > getMutable ( K key ) { return map . get ( key ) ; }
shigengyu/Hyperion | @ Override public Iterator < Entry < K , List < V > > > iterator ( ) { return map . entrySet ( ) . iterator ( ) ; }
shigengyu/Hyperion | public List < V > remove ( String key ) { return map . remove ( key ) ; }
shigengyu/Hyperion | public boolean removeItem ( String key , V value ) { if ( ! map . containsKey ( key ) ) { return false ; } return map . get ( key ) . remove ( value ) ; }
shigengyu/Hyperion | public int size ( ) { return map . size ( ) ; }
shigengyu/Hyperion | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int count = 0 ; for ( Entry < K , List < V > > entry : map . entrySet ( ) ) { sb . append ( entry . getKey ( ) + " ▁ ( " + entry . getKey ( ) . hashCode ( ) + " ) ▁ = ▁ " + entry . getValue ( ) + SystemUtils . LINE_SEPARATOR ) ; ++ count ; if ( count == 10 ) { sb . append ( " . . . " ) ; return sb . toString ( ) ; } } return sb . toString ( ) ; }
SweeneyLiu/TravelWeather | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_about ) ; ButterKnife . bind ( this ) ; setSupportActionBar ( toolbar ) ; if ( getSupportActionBar ( ) != null ) { getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; getSupportActionBar ( ) . setTitle ( R . string . about ) ; } version . setText ( " V ▁ " + getVersionName ( ) ) ; }
SweeneyLiu/TravelWeather | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : finish ( ) ; break ; default : } return super . onOptionsItemSelected ( item ) ; }
SweeneyLiu/TravelWeather | ) public void onClick ( View view ) { switch ( view . getId ( ) ) { case R . id . suggestion : Intent intent = new Intent ( AboutActivity . this , ContactActivity . class ) ; startActivity ( intent ) ; break ; case R . id . new_version : break ; case R . id . favourable_comment : openApplicationMarket ( ) ; break ; } }
SweeneyLiu/TravelWeather | @ Override protected void onResume ( ) { super . onResume ( ) ; }
SweeneyLiu/TravelWeather | @ Override protected void onStop ( ) { super . onStop ( ) ; }
SweeneyLiu/TravelWeather | private void openApplicationMarket ( ) { try { String str = " market : // details ? id = " + getPackageName ( ) ; Intent localIntent = new Intent ( Intent . ACTION_VIEW ) ; localIntent . setData ( Uri . parse ( str ) ) ; startActivity ( localIntent ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; Toast . makeText ( getApplicationContext ( ) , " 打开应用商店失败 " , Toast . LENGTH_SHORT ) . show ( ) ; String url = " http : // app . mi . com / detail / 163525 ? ref = search " ; openLinkBySystem ( url ) ; } }
SweeneyLiu/TravelWeather | private void openLinkBySystem ( String url ) { Intent intent = new Intent ( Intent . ACTION_VIEW ) ; intent . setData ( Uri . parse ( url ) ) ; startActivity ( intent ) ; }
SweeneyLiu/TravelWeather | private String getVersionName ( ) { PackageManager packageManager = getPackageManager ( ) ; PackageInfo packInfo = null ; String version = " " ; try { packInfo = packageManager . getPackageInfo ( getPackageName ( ) , 0 ) ; version = packInfo . versionName ; } catch ( PackageManager . NameNotFoundException e ) { e . printStackTrace ( ) ; } return version ; }
AndiDog/zap-extensions | public WebSocketProxyListenerBreak ( ExtensionWebSocket extension , BreakpointMessageHandler messageHandler ) { this . extension = extension ; this . wsBrkMessageHandler = messageHandler ; }
AndiDog/zap-extensions | @ Override public int getObservingOrder ( ) { return WEBSOCKET_OBSERVING_ORDER ; }
AndiDog/zap-extensions | @ Override public boolean onMessageFrame ( int channelId , WebSocketMessage wsMessage ) { boolean continueNotifying = false ; WebSocketMessageDTO message = wsMessage . getDTO ( ) ; if ( ! extension . isSafe ( message ) ) { return true ; } if ( ! wsMessage . isFinished ( ) ) { boolean isRequest = ( wsMessage . getDirection ( ) . equals ( Direction . OUTGOING ) ) ; if ( wsBrkMessageHandler . isBreakpoint ( message , isRequest , false ) ) { continueNotifying = false ; } else { continueNotifying = true ; } return continueNotifying ; } if ( message . isOutgoing ) { if ( wsBrkMessageHandler . handleMessageReceivedFromClient ( message , false ) ) { setPayload ( wsMessage , message . payload ) ; continueNotifying = true ; } } else { if ( wsBrkMessageHandler . handleMessageReceivedFromServer ( message , false ) ) { setPayload ( wsMessage , message . payload ) ; continueNotifying = true ; } } return continueNotifying ; }
AndiDog/zap-extensions | @ Override public void onStateChange ( State state , WebSocketProxy proxy ) { }
AndiDog/zap-extensions | private void setPayload ( WebSocketMessage message , Object payload ) { try { if ( payload instanceof String ) { message . setReadablePayload ( ( String ) payload ) ; } else if ( payload instanceof byte [ ] ) { message . setPayload ( ( byte [ ] ) payload ) ; } } catch ( WebSocketException e ) { logger . error ( e ) ; } }
ChengCorp/robolectric | @ Test public void shouldUseApplicationLabelFromManifestAsTitleForActivity ( ) throws Exception { activity = Robolectric . setupActivity ( LabelTestActivity1 . class ) ; assertThat ( activity . getTitle ( ) ) . isNotNull ( ) ; assertThat ( activity . getTitle ( ) . toString ( ) ) . isEqualTo ( activity . getString ( R . string . app_name ) ) ; }
ChengCorp/robolectric | @ Test public void shouldUseActivityLabelFromManifestAsTitleForActivity ( ) throws Exception { activity = Robolectric . setupActivity ( LabelTestActivity2 . class ) ; assertThat ( activity . getTitle ( ) ) . isNotNull ( ) ; assertThat ( activity . getTitle ( ) . toString ( ) ) . isEqualTo ( activity . getString ( R . string . activity_name ) ) ; }
ChengCorp/robolectric | @ Test public void shouldUseActivityLabelFromManifestAsTitleForActivityWithShortName ( ) throws Exception { activity = Robolectric . setupActivity ( LabelTestActivity3 . class ) ; assertThat ( activity . getTitle ( ) ) . isNotNull ( ) ; assertThat ( activity . getTitle ( ) . toString ( ) ) . isEqualTo ( activity . getString ( R . string . activity_name ) ) ; }
ChengCorp/robolectric | @ Test public void shouldNotComplainIfActivityIsDestroyedWhileAnotherActivityHasRegisteredBroadcastReceivers ( ) throws Exception { ActivityController < DialogCreatingActivity > controller = Robolectric . buildActivity ( DialogCreatingActivity . class ) ; activity = controller . get ( ) ; DialogLifeCycleActivity activity2 = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; activity2 . registerReceiver ( new AppWidgetProvider ( ) , new IntentFilter ( ) ) ; controller . destroy ( ) ; }
ChengCorp/robolectric | @ Test public void shouldNotRegisterNullBroadcastReceiver ( ) { ActivityController < DialogCreatingActivity > controller = Robolectric . buildActivity ( DialogCreatingActivity . class ) ; activity = controller . get ( ) ; activity . registerReceiver ( null , new IntentFilter ( ) ) ; controller . destroy ( ) ; }
ChengCorp/robolectric | @ Test @ Config ( minSdk = JELLY_BEAN_MR1 ) public void shouldReportDestroyedStatus ( ) { ActivityController < DialogCreatingActivity > controller = Robolectric . buildActivity ( DialogCreatingActivity . class ) ; activity = controller . get ( ) ; controller . destroy ( ) ; assertThat ( activity . isDestroyed ( ) ) . isTrue ( ) ; }
ChengCorp/robolectric | @ Test public void startActivity_shouldDelegateToStartActivityForResult ( ) { final List < String > transcript = new ArrayList < > ( ) ; Activity activity = new Activity ( ) { @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { transcript . add ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ " + requestCode + " , ▁ resultCode ▁ " + resultCode + " , ▁ intent ▁ data ▁ " + data . getData ( ) ) ; } } ; activity . startActivity ( new Intent ( ) . setType ( " image /* " ) ) ; shadowOf ( activity ) . receiveResult ( new Intent ( ) . setType ( " image /* " ) , Activity . RESULT_OK , new Intent ( ) . setData ( Uri . parse ( " content : foo " ) ) ) ; assertThat ( transcript ) . containsExactly ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ - 1 , ▁ resultCode ▁ - 1 , ▁ intent ▁ data ▁ content : foo " ) ; }
ChengCorp/robolectric | @ Test public void startActivities_shouldStartAllActivities ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final Intent view = new Intent ( Intent . ACTION_VIEW ) ; final Intent pick = new Intent ( Intent . ACTION_PICK ) ; activity . startActivities ( new Intent [ ] { view , pick } ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( pick ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( view ) ; }
ChengCorp/robolectric | @ Test public void startActivities_withBundle_shouldStartAllActivities ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final Intent view = new Intent ( Intent . ACTION_VIEW ) ; final Intent pick = new Intent ( Intent . ACTION_PICK ) ; activity . startActivities ( new Intent [ ] { view , pick } , new Bundle ( ) ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( pick ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivity ( ) ) . isEqualTo ( view ) ; }
ChengCorp/robolectric | @ Test public void startActivityForResultAndReceiveResult_shouldSendResponsesBackToActivity ( ) throws Exception { final List < String > transcript = new ArrayList < > ( ) ; Activity activity = new Activity ( ) { @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { transcript . add ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ " + requestCode + " , ▁ resultCode ▁ " + resultCode + " , ▁ intent ▁ data ▁ " + data . getData ( ) ) ; } } ; activity . startActivityForResult ( new Intent ( ) . setType ( " audio /* " ) , 123 ) ; activity . startActivityForResult ( new Intent ( ) . setType ( " image /* " ) , 456 ) ; shadowOf ( activity ) . receiveResult ( new Intent ( ) . setType ( " image /* " ) , Activity . RESULT_OK , new Intent ( ) . setData ( Uri . parse ( " content : foo " ) ) ) ; assertThat ( transcript ) . containsExactly ( " onActivityResult ▁ called ▁ with ▁ requestCode ▁ 456 , ▁ resultCode ▁ - 1 , ▁ intent ▁ data ▁ content : foo " ) ; }
ChengCorp/robolectric | @ Test public void startActivityForResultAndReceiveResult_whenNoIntentMatches_shouldThrowException ( ) throws Exception { Activity activity = new Activity ( ) { @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { throw new IllegalStateException ( " should ▁ not ▁ be ▁ called " ) ; } } ; activity . startActivityForResult ( new Intent ( ) . setType ( " audio /* " ) , 123 ) ; activity . startActivityForResult ( new Intent ( ) . setType ( " image /* " ) , 456 ) ; Intent requestIntent = new Intent ( ) . setType ( " video /* " ) ; try { shadowOf ( activity ) . receiveResult ( requestIntent , Activity . RESULT_OK , new Intent ( ) . setData ( Uri . parse ( " content : foo " ) ) ) ; fail ( ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) ) . startsWith ( " No ▁ intent ▁ matches ▁ " + requestIntent ) ; } }
ChengCorp/robolectric | @ Test public void shouldSupportStartActivityForResult ( ) throws Exception { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; Intent intent = new Intent ( ) . setClass ( activity , DialogLifeCycleActivity . class ) ; assertThat ( shadowActivity . getNextStartedActivity ( ) ) . isNull ( ) ; activity . startActivityForResult ( intent , 142 ) ; Intent startedIntent = shadowActivity . getNextStartedActivity ( ) ; assertThat ( startedIntent ) . isNotNull ( ) ; assertThat ( startedIntent ) . isSameAs ( intent ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportGetStartedActivitiesForResult ( ) throws Exception { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; Intent intent = new Intent ( ) . setClass ( activity , DialogLifeCycleActivity . class ) ; activity . startActivityForResult ( intent , 142 ) ; ShadowActivity . IntentForResult intentForResult = shadowActivity . getNextStartedActivityForResult ( ) ; assertThat ( intentForResult ) . isNotNull ( ) ; assertThat ( shadowActivity . getNextStartedActivityForResult ( ) ) . isNull ( ) ; assertThat ( intentForResult . intent ) . isNotNull ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 142 ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportPeekStartedActivitiesForResult ( ) throws Exception { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; Intent intent = new Intent ( ) . setClass ( activity , DialogLifeCycleActivity . class ) ; activity . startActivityForResult ( intent , 142 ) ; ShadowActivity . IntentForResult intentForResult = shadowActivity . peekNextStartedActivityForResult ( ) ; assertThat ( intentForResult ) . isNotNull ( ) ; assertThat ( shadowActivity . peekNextStartedActivityForResult ( ) ) . isSameAs ( intentForResult ) ; assertThat ( intentForResult . intent ) . isNotNull ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 142 ) ; }
ChengCorp/robolectric | @ Test public void onContentChangedShouldBeCalledAfterContentViewIsSet ( ) throws RuntimeException { final List < String > transcript = new ArrayList < > ( ) ; ActivityWithContentChangedTranscript customActivity = Robolectric . setupActivity ( ActivityWithContentChangedTranscript . class ) ; customActivity . setTranscript ( transcript ) ; customActivity . setContentView ( R . layout . main ) ; assertThat ( transcript ) . containsExactly ( " onContentChanged ▁ was ▁ called ; ▁ title ▁ is ▁ \" Main ▁ Layout \" " ) ; }
ChengCorp/robolectric | @ Test public void shouldRetrievePackageNameFromTheManifest ( ) throws Exception { assertThat ( Robolectric . setupActivity ( Activity . class ) . getPackageName ( ) ) . isEqualTo ( RuntimeEnvironment . application . getPackageName ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldRunUiTasksImmediatelyByDefault ( ) throws Exception { TestRunnable runnable = new TestRunnable ( ) ; activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; activity . runOnUiThread ( runnable ) ; assertTrue ( runnable . wasRun ) ; }
ChengCorp/robolectric | @ Test public void shouldQueueUiTasksWhenUiThreadIsPaused ( ) throws Exception { ShadowLooper . pauseMainLooper ( ) ; activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; TestRunnable runnable = new TestRunnable ( ) ; activity . runOnUiThread ( runnable ) ; assertFalse ( runnable . wasRun ) ; ShadowLooper . unPauseMainLooper ( ) ; assertTrue ( runnable . wasRun ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldCreatePrepareAndShowDialog ( ) { final DialogLifeCycleActivity activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final AtomicBoolean dialogWasShown = new AtomicBoolean ( false ) ; new Dialog ( activity ) { { activity . dialog = this ; } @ Override public void show ( ) { dialogWasShown . set ( true ) ; } } ; activity . showDialog ( 1 ) ; assertTrue ( activity . createdDialog ) ; assertTrue ( activity . preparedDialog ) ; assertTrue ( dialogWasShown . get ( ) ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldCreatePrepareAndShowDialogWithBundle ( ) { final DialogLifeCycleActivity activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; final AtomicBoolean dialogWasShown = new AtomicBoolean ( false ) ; new Dialog ( activity ) { { activity . dialog = this ; } @ Override public void show ( ) { dialogWasShown . set ( true ) ; } } ; activity . showDialog ( 1 , new Bundle ( ) ) ; assertTrue ( activity . createdDialog ) ; assertTrue ( activity . preparedDialogWithBundle ) ; assertTrue ( dialogWasShown . get ( ) ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldReturnFalseIfDialogDoesNotExist ( ) { final DialogLifeCycleActivity activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; boolean dialogCreated = activity . showDialog ( 97 , new Bundle ( ) ) ; assertThat ( dialogCreated ) . isFalse ( ) ; assertThat ( activity . createdDialog ) . isTrue ( ) ; assertThat ( activity . preparedDialogWithBundle ) . isFalse ( ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldReuseDialogs ( ) { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; Dialog firstDialog = ShadowDialog . getLatestDialog ( ) ; activity . showDialog ( 1 ) ; Dialog secondDialog = ShadowDialog . getLatestDialog ( ) ; assertSame ( " dialogs ▁ should ▁ be ▁ the ▁ same ▁ instance " , firstDialog , secondDialog ) ; }
ChengCorp/robolectric | @ Test public void showDialog_shouldShowDialog ( ) throws Exception { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; Dialog dialog = ShadowDialog . getLatestDialog ( ) ; assertTrue ( dialog . isShowing ( ) ) ; }
ChengCorp/robolectric | @ Test public void dismissDialog_shouldDismissPreviouslyShownDialog ( ) throws Exception { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; activity . dismissDialog ( 1 ) ; Dialog dialog = ShadowDialog . getLatestDialog ( ) ; assertFalse ( dialog . isShowing ( ) ) ; }
ChengCorp/robolectric | @ Test ( expected = IllegalArgumentException . class ) public void dismissDialog_shouldThrowExceptionIfDialogWasNotPreviouslyShown ( ) throws Exception { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . dismissDialog ( 1 ) ; }
ChengCorp/robolectric | @ Test public void removeDialog_shouldCreateDialogAgain ( ) { final DialogCreatingActivity activity = Robolectric . setupActivity ( DialogCreatingActivity . class ) ; activity . showDialog ( 1 ) ; Dialog firstDialog = ShadowDialog . getLatestDialog ( ) ; activity . removeDialog ( 1 ) ; assertNull ( shadowOf ( activity ) . getDialogById ( 1 ) ) ; activity . showDialog ( 1 ) ; Dialog secondDialog = ShadowDialog . getLatestDialog ( ) ; assertNotSame ( " dialogs ▁ should ▁ not ▁ be ▁ the ▁ same ▁ instance " , firstDialog , secondDialog ) ; }
ChengCorp/robolectric | @ Test public void shouldCallOnCreateDialogFromShowDialog ( ) { ActivityWithOnCreateDialog activity = Robolectric . setupActivity ( ActivityWithOnCreateDialog . class ) ; activity . showDialog ( 123 ) ; assertTrue ( activity . onCreateDialogWasCalled ) ; assertThat ( ShadowDialog . getLatestDialog ( ) ) . isNotNull ( ) ; }
ChengCorp/robolectric | @ Test public void shouldCallFinishInOnBackPressed ( ) { Activity activity = new Activity ( ) ; activity . onBackPressed ( ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; assertTrue ( shadowActivity . isFinishing ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportCurrentFocus ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; ShadowActivity shadow = shadowOf ( activity ) ; assertNull ( shadow . getCurrentFocus ( ) ) ; View view = new View ( activity ) ; shadow . setCurrentFocus ( view ) ; assertEquals ( view , shadow . getCurrentFocus ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldSetOrientation ( ) { activity = Robolectric . setupActivity ( DialogLifeCycleActivity . class ) ; activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; assertThat ( activity . getRequestedOrientation ( ) ) . isEqualTo ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; }
ChengCorp/robolectric | @ Test public void setDefaultKeyMode_shouldSetKeyMode ( ) { int [ ] modes = { Activity . DEFAULT_KEYS_DISABLE , Activity . DEFAULT_KEYS_SHORTCUT , Activity . DEFAULT_KEYS_DIALER , Activity . DEFAULT_KEYS_SEARCH_LOCAL , Activity . DEFAULT_KEYS_SEARCH_GLOBAL } ; Activity activity = new Activity ( ) ; ShadowActivity shadow = shadowOf ( activity ) ; for ( int mode : modes ) { activity . setDefaultKeyMode ( mode ) ; assertThat ( shadow . getDefaultKeymode ( ) ) . as ( " Unexpected ▁ key ▁ mode " ) . isEqualTo ( mode ) ; } }
ChengCorp/robolectric | @ Test public void shouldPopulateWindowDecorViewWithMergeLayoutContents ( ) throws Exception { Activity activity = Robolectric . buildActivity ( Activity . class ) . create ( ) . get ( ) ; activity . setContentView ( R . layout . toplevel_merge ) ; View contentView = activity . findViewById ( android . R . id . content ) ; assertThat ( ( ( ViewGroup ) contentView ) . getChildCount ( ) ) . isEqualTo ( 2 ) ; }
ChengCorp/robolectric | @ Test public void setContentView_shouldReplaceOldContentView ( ) throws Exception { View view1 = new View ( application ) ; view1 . setId ( R . id . burritos ) ; View view2 = new View ( application ) ; view2 . setId ( R . id . button ) ; Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; activity . setContentView ( view1 ) ; assertSame ( view1 , activity . findViewById ( R . id . burritos ) ) ; activity . setContentView ( view2 ) ; assertNull ( activity . findViewById ( R . id . burritos ) ) ; assertSame ( view2 , activity . findViewById ( R . id . button ) ) ; }
ChengCorp/robolectric | @ Test public void onKeyUp_callsOnBackPressedWhichFinishesTheActivity ( ) throws Exception { OnBackPressedActivity activity = buildActivity ( OnBackPressedActivity . class ) . setup ( ) . get ( ) ; boolean downConsumed = activity . dispatchKeyEvent ( new KeyEvent ( KeyEvent . ACTION_DOWN , KeyEvent . KEYCODE_BACK ) ) ; boolean upConsumed = activity . dispatchKeyEvent ( new KeyEvent ( KeyEvent . ACTION_UP , KeyEvent . KEYCODE_BACK ) ) ; assertTrue ( downConsumed ) ; assertTrue ( upConsumed ) ; assertTrue ( activity . onBackPressedCalled ) ; assertTrue ( activity . isFinishing ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldGiveSharedPreferences ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; SharedPreferences preferences = activity . getPreferences ( Context . MODE_PRIVATE ) ; assertNotNull ( preferences ) ; preferences . edit ( ) . putString ( " foo " , " bar " ) . commit ( ) ; assertThat ( activity . getPreferences ( Context . MODE_PRIVATE ) . getString ( " foo " , null ) ) . isEqualTo ( " bar " ) ; }
ChengCorp/robolectric | @ Test public void shouldFindContentViewContainerWithChild ( ) throws Exception { Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; View contentView = new View ( activity ) ; activity . setContentView ( contentView ) ; FrameLayout contentViewContainer = ( FrameLayout ) activity . findViewById ( android . R . id . content ) ; assertThat ( contentViewContainer . getChildAt ( 0 ) ) . isSameAs ( contentView ) ; }
ChengCorp/robolectric | @ Test public void shouldFindContentViewContainerWithoutChild ( ) throws Exception { Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; FrameLayout contentViewContainer = ( FrameLayout ) activity . findViewById ( android . R . id . content ) ; assertThat ( contentViewContainer . getId ( ) ) . isEqualTo ( android . R . id . content ) ; }
ChengCorp/robolectric | @ Test public void recreateGoesThroughFullLifeCycle ( ) throws Exception { TestActivity activity = buildActivity ( TestActivity . class ) . get ( ) ; activity . recreate ( ) ; assertThat ( activity . transcript ) . containsExactly ( " onSaveInstanceState " , " onPause " , " onStop " , " onRetainNonConfigurationInstance " , " onDestroy " , " onCreate " , " onStart " , " onRestoreInstanceState " , " onResume " ) ; Integer storedValue = ( Integer ) activity . getLastNonConfigurationInstance ( ) ; assertEquals ( 5 , storedValue . intValue ( ) ) ; }
ChengCorp/robolectric | @ Test public void startAndStopManagingCursorTracksCursors ( ) throws Exception { TestActivity activity = new TestActivity ( ) ; ShadowActivity shadow = shadowOf ( activity ) ; assertThat ( shadow . getManagedCursors ( ) ) . isNotNull ( ) ; assertThat ( shadow . getManagedCursors ( ) . size ( ) ) . isEqualTo ( 0 ) ; Cursor c = Shadow . newInstanceOf ( SQLiteCursor . class ) ; activity . startManagingCursor ( c ) ; assertThat ( shadow . getManagedCursors ( ) ) . isNotNull ( ) ; assertThat ( shadow . getManagedCursors ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertThat ( shadow . getManagedCursors ( ) . get ( 0 ) ) . isSameAs ( c ) ; activity . stopManagingCursor ( c ) ; assertThat ( shadow . getManagedCursors ( ) ) . isNotNull ( ) ; assertThat ( shadow . getManagedCursors ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
ChengCorp/robolectric | @ Test public void setVolumeControlStream_setsTheSpecifiedStreamType ( ) { TestActivity activity = new TestActivity ( ) ; activity . setVolumeControlStream ( AudioManager . STREAM_ALARM ) ; assertThat ( activity . getVolumeControlStream ( ) ) . isEqualTo ( AudioManager . STREAM_ALARM ) ; }
ChengCorp/robolectric | @ Test public void decorViewSizeEqualToDisplaySize ( ) { Activity activity = buildActivity ( Activity . class ) . create ( ) . visible ( ) . get ( ) ; View decorView = activity . getWindow ( ) . getDecorView ( ) ; assertThat ( decorView ) . isNotEqualTo ( null ) ; ViewRootImpl root = decorView . getViewRootImpl ( ) ; assertThat ( root ) . isNotEqualTo ( null ) ; assertThat ( decorView . getWidth ( ) ) . isNotEqualTo ( 0 ) ; assertThat ( decorView . getHeight ( ) ) . isNotEqualTo ( 0 ) ; Display display = Shadow . newInstanceOf ( Display . class ) ; ShadowDisplay shadowDisplay = Shadows . shadowOf ( display ) ; assertThat ( decorView . getWidth ( ) ) . isEqualTo ( shadowDisplay . getWidth ( ) ) ; assertThat ( decorView . getHeight ( ) ) . isEqualTo ( shadowDisplay . getHeight ( ) ) ; }
ChengCorp/robolectric | @ Test @ Config ( minSdk = M ) public void requestsPermissions ( ) { TestActivity activity = new TestActivity ( ) ; activity . requestPermissions ( new String [ 0 ] , - 1 ) ; }
ChengCorp/robolectric | @ Override public void onSaveInstanceState ( Bundle outState ) { isRecreating = true ; transcript . add ( " onSaveInstanceState " ) ; outState . putString ( " TestActivityKey " , " TestActivityValue " ) ; super . onSaveInstanceState ( outState ) ; }
ChengCorp/robolectric | @ Override public void onRestoreInstanceState ( Bundle savedInstanceState ) { transcript . add ( " onRestoreInstanceState " ) ; assertTrue ( savedInstanceState . containsKey ( " TestActivityKey " ) ) ; assertEquals ( " TestActivityValue " , savedInstanceState . getString ( " TestActivityKey " ) ) ; super . onRestoreInstanceState ( savedInstanceState ) ; }
ChengCorp/robolectric | @ Override public Object onRetainNonConfigurationInstance ( ) { transcript . add ( " onRetainNonConfigurationInstance " ) ; return new Integer ( 5 ) ; }
ChengCorp/robolectric | @ Override public void onPause ( ) { transcript . add ( " onPause " ) ; super . onPause ( ) ; }
ChengCorp/robolectric | @ Override public void onDestroy ( ) { transcript . add ( " onDestroy " ) ; super . onDestroy ( ) ; }
ChengCorp/robolectric | @ Override public void onCreate ( Bundle savedInstanceState ) { transcript . add ( " onCreate " ) ; if ( isRecreating ) { assertTrue ( savedInstanceState . containsKey ( " TestActivityKey " ) ) ; assertEquals ( " TestActivityValue " , savedInstanceState . getString ( " TestActivityKey " ) ) ; } super . onCreate ( savedInstanceState ) ; }
ChengCorp/robolectric | @ Override public void onStart ( ) { transcript . add ( " onStart " ) ; super . onStart ( ) ; }
ChengCorp/robolectric | @ Override public void onPostCreate ( Bundle savedInstanceState ) { transcript . add ( " onPostCreate " ) ; super . onPostCreate ( savedInstanceState ) ; }
ChengCorp/robolectric | @ Override public void onStop ( ) { transcript . add ( " onStop " ) ; super . onStop ( ) ; }
ChengCorp/robolectric | @ Override public void onRestart ( ) { transcript . add ( " onRestart " ) ; super . onRestart ( ) ; }
ChengCorp/robolectric | @ Override public void onResume ( ) { transcript . add ( " onResume " ) ; super . onResume ( ) ; }
ChengCorp/robolectric | @ Test public void getAndSetParentActivity_shouldWorkForTestingPurposes ( ) throws Exception { Activity parentActivity = new Activity ( ) { } ; Activity activity = new Activity ( ) { } ; shadowOf ( activity ) . setParent ( parentActivity ) ; assertSame ( parentActivity , activity . getParent ( ) ) ; }
ChengCorp/robolectric | @ Test public void getAndSetRequestedOrientation_shouldRemember ( ) throws Exception { Activity activity = new Activity ( ) { } ; activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; assertEquals ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT , activity . getRequestedOrientation ( ) ) ; }
ChengCorp/robolectric | @ Test public void getAndSetRequestedOrientation_shouldDelegateToParentIfPresent ( ) throws Exception { Activity parentActivity = new Activity ( ) { } ; Activity activity = new Activity ( ) { } ; shadowOf ( activity ) . setParent ( parentActivity ) ; parentActivity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT ) ; assertEquals ( ActivityInfo . SCREEN_ORIENTATION_PORTRAIT , activity . getRequestedOrientation ( ) ) ; activity . setRequestedOrientation ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_LANDSCAPE ) ; assertEquals ( ActivityInfo . SCREEN_ORIENTATION_REVERSE_LANDSCAPE , parentActivity . getRequestedOrientation ( ) ) ; }
ChengCorp/robolectric | @ Test public void shouldSupportIsTaskRoot ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; assertTrue ( activity . isTaskRoot ( ) ) ; shadowOf ( activity ) . setIsTaskRoot ( false ) ; assertFalse ( activity . isTaskRoot ( ) ) ; }
ChengCorp/robolectric | @ Test public void getPendingTransitionEnterAnimationResourceId_should ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; activity . overridePendingTransition ( 15 , 2 ) ; assertThat ( shadowOf ( activity ) . getPendingTransitionEnterAnimationResourceId ( ) ) . isEqualTo ( 15 ) ; }
ChengCorp/robolectric | @ Test public void getPendingTransitionExitAnimationResourceId_should ( ) throws Exception { Activity activity = Robolectric . setupActivity ( Activity . class ) ; activity . overridePendingTransition ( 15 , 2 ) ; assertThat ( shadowOf ( activity ) . getPendingTransitionExitAnimationResourceId ( ) ) . isEqualTo ( 2 ) ; }
ChengCorp/robolectric | @ Test public void shouldGetAttributeFromThemeSetOnActivity ( ) throws Exception { ShadowThemeTest . TestActivity activity = setupActivity ( ShadowThemeTest . TestActivityWithAnotherTheme . class ) ; TypedArray a = activity . obtainStyledAttributes ( R . styleable . AnotherTheme ) ; assertThat ( a . hasValue ( R . styleable . AnotherTheme_animalStyle ) ) . isTrue ( ) ; }
ChengCorp/robolectric | @ Test public void getActionBar_shouldWorkIfActivityHasAnAppropriateTheme ( ) throws Exception { ActionBarThemedActivity myActivity = Robolectric . buildActivity ( ActionBarThemedActivity . class ) . create ( ) . get ( ) ; ActionBar actionBar = myActivity . getActionBar ( ) ; assertThat ( actionBar ) . isNotNull ( ) ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setTheme ( android . R . style . Theme_Holo_Light ) ; setContentView ( new LinearLayout ( this ) ) ; }
ChengCorp/robolectric | @ Test public void canGetOptionsMenu ( ) throws Exception { Activity activity = buildActivity ( OptionsMenuActivity . class ) . create ( ) . visible ( ) . get ( ) ; Menu optionsMenu = shadowOf ( activity ) . getOptionsMenu ( ) ; assertThat ( optionsMenu ) . isNotNull ( ) ; assertThat ( optionsMenu . getItem ( 0 ) . getTitle ( ) ) . isEqualTo ( " Algebraic ! " ) ; }
ChengCorp/robolectric | @ Test public void canGetOptionsMenuWithActionMenu ( ) throws Exception { ActionMenuActivity activity = buildActivity ( ActionMenuActivity . class ) . create ( ) . visible ( ) . get ( ) ; SearchView searchView = activity . mSearchView ; searchView . setIconifiedByDefault ( false ) ; }
ChengCorp/robolectric | @ Test public void canStartActivityFromFragment ( ) { final Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; activity . startActivityFromFragment ( new Fragment ( ) , intent , 4 ) ; ShadowActivity . IntentForResult intentForResult = shadowOf ( activity ) . getNextStartedActivityForResult ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 4 ) ; }
ChengCorp/robolectric | @ Test public void canStartActivityFromFragment_withBundle ( ) { final Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; Bundle options = new Bundle ( ) ; Intent intent = new Intent ( Intent . ACTION_VIEW ) ; activity . startActivityFromFragment ( new Fragment ( ) , intent , 5 , options ) ; ShadowActivity . IntentForResult intentForResult = shadowOf ( activity ) . getNextStartedActivityForResult ( ) ; assertThat ( intentForResult . intent ) . isSameAs ( intent ) ; assertThat ( intentForResult . options ) . isSameAs ( options ) ; assertThat ( intentForResult . requestCode ) . isEqualTo ( 5 ) ; }
ChengCorp/robolectric | @ Test public void shouldUseAnimationOverride ( ) { Activity activity = buildActivity ( Activity . class ) . create ( ) . get ( ) ; Intent intent = new Intent ( activity , OptionsMenuActivity . class ) ; Bundle animationBundle = ActivityOptions . makeCustomAnimation ( activity , R . anim . test_anim_1 , R . anim . test_anim_1 ) . toBundle ( ) ; activity . startActivity ( intent , animationBundle ) ; assertThat ( shadowOf ( activity ) . getNextStartedActivityForResult ( ) . options ) . isSameAs ( animationBundle ) ; }
ChengCorp/robolectric | @ Test public void shouldCallActivityLifecycleCallbacks ( ) { final List < String > transcript = new ArrayList < > ( ) ; final ActivityController < Activity > controller = buildActivity ( Activity . class ) ; RuntimeEnvironment . application . registerActivityLifecycleCallbacks ( new ActivityLifecycleCallbacks ( transcript ) ) ; controller . create ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityCreated " ) ; transcript . clear ( ) ; controller . start ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityStarted " ) ; transcript . clear ( ) ; controller . resume ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityResumed " ) ; transcript . clear ( ) ; controller . saveInstanceState ( new Bundle ( ) ) ; assertThat ( transcript ) . containsExactly ( " onActivitySaveInstanceState " ) ; transcript . clear ( ) ; controller . pause ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityPaused " ) ; transcript . clear ( ) ; controller . stop ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityStopped " ) ; transcript . clear ( ) ; controller . destroy ( ) ; assertThat ( transcript ) . containsExactly ( " onActivityDestroyed " ) ; }
ChengCorp/robolectric | @ Test public void getParentActivityIntent ( ) { Activity activity = setupActivity ( ChildActivity . class ) ; assertThat ( activity . getParentActivityIntent ( ) . getComponent ( ) . getClassName ( ) ) . isEqualTo ( ParentActivity . class . getName ( ) ) ; }
ChengCorp/robolectric | @ Test public void getCallingActivity_defaultsToNull ( ) { Activity activity = Robolectric . setupActivity ( Activity . class ) ; assertNull ( activity . getCallingActivity ( ) ) ; }
ChengCorp/robolectric | @ Test public void getCallingActivity_returnsSetValue ( ) { Activity activity = Robolectric . setupActivity ( Activity . class ) ; ComponentName componentName = new ComponentName ( " com . example . package " , " SomeActivity " ) ; ShadowActivity shadowActivity = shadowOf ( activity ) ; shadowActivity . setCallingActivity ( componentName ) ; assertEquals ( componentName , activity . getCallingActivity ( ) ) ; }
ChengCorp/robolectric | public AndroidManifest newConfigWith ( String contents ) throws IOException { return newConfigWith ( " org . robolectric " , contents ) ; }
ChengCorp/robolectric | private AndroidManifest newConfigWith ( String packageName , String contents ) throws IOException { String fileContents = " < ? xml ▁ version = \" 1.0 \" ▁ encoding = \" utf - 8 \" ? > \n " + " < manifest ▁ xmlns : android = \" http : // schemas . android . com / apk / res / android \" \n " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ package = \" " + packageName + " \" > \n " + " ▁ ▁ ▁ ▁ " + contents + " \n " + " < / manifest > \n " ; File f = temporaryFolder . newFile ( " whatever . xml " ) ; Files . write ( fileContents , f , Charsets . UTF_8 ) ; return new AndroidManifest ( Fs . newFile ( f ) , null , null ) ; }
ChengCorp/robolectric | @ Override protected Dialog onCreateDialog ( int id ) { return new Dialog ( this ) ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow ( ) . requestFeature ( Window . FEATURE_ACTION_BAR ) ; setContentView ( new FrameLayout ( this ) ) ; }
ChengCorp/robolectric | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; menu . add ( " Algebraic ! " ) ; return true ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getWindow ( ) . requestFeature ( Window . FEATURE_ACTION_BAR ) ; setContentView ( new FrameLayout ( this ) ) ; }
ChengCorp/robolectric | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . action_menu , menu ) ; MenuItem searchMenuItem = menu . findItem ( R . id . action_search ) ; mSearchView = ( SearchView ) searchMenuItem . getActionView ( ) ; return true ; }
ChengCorp/robolectric | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( new FrameLayout ( this ) ) ; }
ChengCorp/robolectric | @ Override protected void onDestroy ( ) { super . onDestroy ( ) ; }
ChengCorp/robolectric | @ Override protected Dialog onCreateDialog ( int id ) { createdDialog = true ; return dialog ; }
ChengCorp/robolectric | @ Override protected void onPrepareDialog ( int id , Dialog dialog ) { preparedDialog = true ; }
ChengCorp/robolectric | @ Override protected void onPrepareDialog ( int id , Dialog dialog , Bundle bundle ) { preparedDialogWithBundle = true ; }
ChengCorp/robolectric | @ Override protected Dialog onCreateDialog ( int id ) { onCreateDialogWasCalled = true ; return new Dialog ( this ) ; }
ChengCorp/robolectric | @ Override public void onContentChanged ( ) { transcript . add ( " onContentChanged ▁ was ▁ called ; ▁ title ▁ is ▁ \" " + shadowOf ( ( View ) findViewById ( R . id . title ) ) . innerText ( ) + " \" " ) ; }
ChengCorp/robolectric | private void setTranscript ( List < String > transcript ) { this . transcript = transcript ; }
ChengCorp/robolectric | @ Override public void onBackPressed ( ) { onBackPressedCalled = true ; super . onBackPressed ( ) ; }
ChengCorp/robolectric | public ActivityLifecycleCallbacks ( List < String > transcript ) { this . transcript = transcript ; }
ChengCorp/robolectric | @ Override public void onActivityCreated ( Activity activity , Bundle bundle ) { transcript . add ( " onActivityCreated " ) ; }
ChengCorp/robolectric | @ Override public void onActivityStarted ( Activity activity ) { transcript . add ( " onActivityStarted " ) ; }
ChengCorp/robolectric | @ Override public void onActivityResumed ( Activity activity ) { transcript . add ( " onActivityResumed " ) ; }
ChengCorp/robolectric | @ Override public void onActivityPaused ( Activity activity ) { transcript . add ( " onActivityPaused " ) ; }
ChengCorp/robolectric | @ Override public void onActivityStopped ( Activity activity ) { transcript . add ( " onActivityStopped " ) ; }
ChengCorp/robolectric | @ Override public void onActivitySaveInstanceState ( Activity activity , Bundle bundle ) { transcript . add ( " onActivitySaveInstanceState " ) ; }
ChengCorp/robolectric | @ Override public void onActivityDestroyed ( Activity activity ) { transcript . add ( " onActivityDestroyed " ) ; }
MX-Futhark/hook-any-text | public void addAttempt ( DebuggableDecodingAttempt attempt ) { attempts . add ( attempt ) ; }
MX-Futhark/hook-any-text | @ Override public DebuggableLineList getDecorableList ( ) { for ( DebuggableDecodingAttempt attempt : attempts ) { if ( attempt . isValidEncoding ( ) ) { return attempt . getAttempt ( ) ; } } return null ; }
MX-Futhark/hook-any-text | @ Override public String toString ( long debuggingFlags , int converterStrictness ) { StringBuilder sb = new StringBuilder ( ) ; if ( ( debuggingFlags & DebuggingFlags . LINE_LIST_ENCODING_REJECTED ) > 0 ) { sb . append ( " Lines ▁ with ▁ detected ▁ encoding : ▁ \n " ) ; } for ( DebuggableDecodingAttempt attempt : attempts ) { if ( attempt . isValidEncoding ( ) ) { sb . append ( attempt . toString ( debuggingFlags , converterStrictness ) ) ; break ; } } if ( ( debuggingFlags & DebuggingFlags . LINE_LIST_ENCODING_REJECTED ) > 0 ) { sb . append ( " \n Failed ▁ attempts ▁ at ▁ decoding : ▁ \n " ) ; for ( DebuggableDecodingAttempt attempt : attempts ) { if ( ! attempt . isValidEncoding ( ) ) { sb . append ( attempt . toString ( debuggingFlags , converterStrictness ) ) ; sb . append ( " \n " ) ; } } } return sb . toString ( ) . trim ( ) ; }
darciopacifico/omr | public MDBVO ( ) { }
darciopacifico/omr | public String getDesc ( ) { return Desc ; }
darciopacifico/omr | public long getDtExec ( ) { return dtExec ; }
darciopacifico/omr | public long getDtSolic ( ) { return dtSolic ; }
darciopacifico/omr | public String getId ( ) { return Id ; }
darciopacifico/omr | public String getMensagem ( ) { return mensagem ; }
darciopacifico/omr | public String getStatus ( ) { return status ; }
darciopacifico/omr | public String getTipo ( ) { return tipo ; }
darciopacifico/omr | public String getUsuarioId ( ) { return usuarioId ; }
darciopacifico/omr | public void setDesc ( String desc ) { Desc = desc ; }
darciopacifico/omr | public void setDtExec ( long dtExec ) { this . dtExec = dtExec ; }
darciopacifico/omr | public void setDtSolic ( long dtSolic ) { this . dtSolic = dtSolic ; }
darciopacifico/omr | public void setId ( String id ) { Id = id ; }
darciopacifico/omr | public void setMensagem ( String mensagem ) { this . mensagem = mensagem ; }
darciopacifico/omr | public void setStatus ( String status ) { this . status = status ; }
darciopacifico/omr | public void setTipo ( String tipo ) { this . tipo = tipo ; }
darciopacifico/omr | public void setUsuarioId ( String usuarioId ) { this . usuarioId = usuarioId ; }
bubbledoodle/Algorithms_Training | public int reverse ( int x ) { int res = 0 ; while ( x != 0 ) { int tail = x % 10 ; int temp = res * 10 + tail ; if ( ( temp - tail ) / 10 != res ) return 0 ; res = temp ; x = x / 10 ; } return res ; }
prabushi/devstudio-tooling-esb | public IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl ( IPropertiesEditionComponent editionComponent ) { super ( editionComponent ) ; }
prabushi/devstudio-tooling-esb | public Composite createFigure ( final Composite parent ) { view = new Composite ( parent , SWT . NONE ) ; GridLayout layout = new GridLayout ( ) ; layout . numColumns = 3 ; view . setLayout ( layout ) ; createControls ( view ) ; return view ; }
prabushi/devstudio-tooling-esb | public void createControls ( Composite view ) { CompositionSequence iterateMediatorTargetOutputConnectorStep = new BindingCompositionSequence ( propertiesEditionComponent ) ; iterateMediatorTargetOutputConnectorStep . addStep ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . class ) . addStep ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) ; composer = new PartComposer ( iterateMediatorTargetOutputConnectorStep ) { @ Override public Composite addToPart ( Composite parent , Object key ) { if ( key == EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . class ) { return createPropertiesGroup ( parent ) ; } if ( key == EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) { return createCommentMediatorsAdvancedTableComposition ( parent ) ; } return parent ; } } ; composer . compose ( view ) ; }
prabushi/devstudio-tooling-esb | protected Composite createPropertiesGroup ( Composite parent ) { Group propertiesGroup = new Group ( parent , SWT . NONE ) ; propertiesGroup . setText ( EsbMessages . IterateMediatorTargetOutputConnectorPropertiesEditionPart_PropertiesGroupLabel ) ; GridData propertiesGroupData = new GridData ( GridData . FILL_HORIZONTAL ) ; propertiesGroupData . horizontalSpan = 3 ; propertiesGroup . setLayoutData ( propertiesGroupData ) ; GridLayout propertiesGroupLayout = new GridLayout ( ) ; propertiesGroupLayout . numColumns = 3 ; propertiesGroup . setLayout ( propertiesGroupLayout ) ; return propertiesGroup ; }
prabushi/devstudio-tooling-esb | protected Composite createCommentMediatorsAdvancedTableComposition ( Composite parent ) { this . commentMediators = new ReferencesTable ( getDescription ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , EsbMessages . IterateMediatorTargetOutputConnectorPropertiesEditionPart_CommentMediatorsLabel ) , new ReferencesTableListener ( ) { public void handleAdd ( ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . ADD , null , null ) ) ; commentMediators . refresh ( ) ; } public void handleEdit ( EObject element ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . EDIT , null , element ) ) ; commentMediators . refresh ( ) ; } public void handleMove ( EObject element , int oldIndex , int newIndex ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . MOVE , element , newIndex ) ) ; commentMediators . refresh ( ) ; } public void handleRemove ( EObject element ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . COMMIT , PropertiesEditionEvent . REMOVE , null , element ) ) ; commentMediators . refresh ( ) ; } public void navigateTo ( EObject element ) { } } ) ; for ( ViewerFilter filter : this . commentMediatorsFilters ) { this . commentMediators . addFilter ( filter ) ; } this . commentMediators . setHelpText ( propertiesEditionComponent . getHelpContent ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , EsbViewsRepository . SWT_KIND ) ) ; this . commentMediators . createControls ( parent ) ; this . commentMediators . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { if ( e . item != null && e . item . getData ( ) instanceof EObject ) { propertiesEditionComponent . firePropertiesChanged ( new PropertiesEditionEvent ( IterateMediatorTargetOutputConnectorPropertiesEditionPartImpl . this , EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators , PropertiesEditionEvent . CHANGE , PropertiesEditionEvent . SELECTION_CHANGED , null , e . item . getData ( ) ) ) ; } } } ) ; GridData commentMediatorsData = new GridData ( GridData . FILL_HORIZONTAL ) ; commentMediatorsData . horizontalSpan = 3 ; this . commentMediators . setLayoutData ( commentMediatorsData ) ; this . commentMediators . setLowerBound ( 0 ) ; this . commentMediators . setUpperBound ( - 1 ) ; commentMediators . setID ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) ; commentMediators . setEEFType ( " eef : : AdvancedTableComposition " ) ; return parent ; }
prabushi/devstudio-tooling-esb | public void firePropertiesChanged ( IPropertiesEditionEvent event ) { }
prabushi/devstudio-tooling-esb | public void initCommentMediators ( ReferencesTableSettings settings ) { if ( current . eResource ( ) != null && current . eResource ( ) . getResourceSet ( ) != null ) this . resourceSet = current . eResource ( ) . getResourceSet ( ) ; ReferencesTableContentProvider contentProvider = new ReferencesTableContentProvider ( ) ; commentMediators . setContentProvider ( contentProvider ) ; commentMediators . setInput ( settings ) ; boolean eefElementEditorReadOnlyState = isReadOnly ( EsbViewsRepository . IterateMediatorTargetOutputConnector . Properties . commentMediators ) ; if ( eefElementEditorReadOnlyState && commentMediators . isEnabled ( ) ) { commentMediators . setEnabled ( false ) ; commentMediators . setToolTipText ( EsbMessages . IterateMediatorTargetOutputConnector_ReadOnly ) ; } else if ( ! eefElementEditorReadOnlyState && ! commentMediators . isEnabled ( ) ) { commentMediators . setEnabled ( true ) ; } }
prabushi/devstudio-tooling-esb | public void updateCommentMediators ( ) { commentMediators . refresh ( ) ; }
prabushi/devstudio-tooling-esb | public void addFilterToCommentMediators ( ViewerFilter filter ) { commentMediatorsFilters . add ( filter ) ; if ( this . commentMediators != null ) { this . commentMediators . addFilter ( filter ) ; } }
prabushi/devstudio-tooling-esb | public void addBusinessFilterToCommentMediators ( ViewerFilter filter ) { commentMediatorsBusinessFilters . add ( filter ) ; }
prabushi/devstudio-tooling-esb | public boolean isContainedInCommentMediatorsTable ( EObject element ) { return ( ( ReferencesTableSettings ) commentMediators . getInput ( ) ) . contains ( element ) ; }
prabushi/devstudio-tooling-esb | public String getTitle ( ) { return EsbMessages . IterateMediatorTargetOutputConnector_Part_Title ; }
ThiagoGarciaAlves/elasticsearch | DummyQuery ( int id ) { this . id = id ; }
ThiagoGarciaAlves/elasticsearch | @ Override public boolean equals ( Object obj ) { return sameClassAs ( obj ) && id == ( ( DummyQuery ) obj ) . id ; }
ThiagoGarciaAlves/elasticsearch | @ Override public int hashCode ( ) { return 31 * classHash ( ) + id ; }
ThiagoGarciaAlves/elasticsearch | @ Override public String toString ( String field ) { return " dummy " ; }
ThiagoGarciaAlves/elasticsearch | @ Override public Weight createWeight ( IndexSearcher searcher , boolean needsScores , float boost ) throws IOException { return new ConstantScoreWeight ( this , boost ) { @ Override public Scorer scorer ( LeafReaderContext context ) throws IOException { return new ConstantScoreScorer ( this , score ( ) , DocIdSetIterator . all ( context . reader ( ) . maxDoc ( ) ) ) ; } @ Override public boolean isCacheable ( LeafReaderContext ctx ) { return true ; } } ; }
ThiagoGarciaAlves/elasticsearch | public void testBasics ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriter w = new IndexWriter ( dir , newIndexWriterConfig ( ) ) ; w . addDocument ( new Document ( ) ) ; DirectoryReader r = DirectoryReader . open ( w ) ; w . close ( ) ; ShardId shard = new ShardId ( " index " , " _ na _ " , 0 ) ; r = ElasticsearchDirectoryReader . wrap ( r , shard ) ; IndexSearcher s = new IndexSearcher ( r ) ; s . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s . setQueryCache ( cache ) ; QueryCacheStats stats = cache . getStats ( shard ) ; assertEquals ( 0L , stats . getCacheSize ( ) ) ; assertEquals ( 0L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 0L , stats . getMissCount ( ) ) ; assertEquals ( 1 , s . count ( new DummyQuery ( 0 ) ) ) ; stats = cache . getStats ( shard ) ; assertEquals ( 1L , stats . getCacheSize ( ) ) ; assertEquals ( 1L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 1L , stats . getMissCount ( ) ) ; for ( int i = 1 ; i < 20 ; ++ i ) { assertEquals ( 1 , s . count ( new DummyQuery ( i ) ) ) ; } stats = cache . getStats ( shard ) ; assertEquals ( 10L , stats . getCacheSize ( ) ) ; assertEquals ( 20L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 20L , stats . getMissCount ( ) ) ; s . count ( new DummyQuery ( 10 ) ) ; stats = cache . getStats ( shard ) ; assertEquals ( 10L , stats . getCacheSize ( ) ) ; assertEquals ( 20L , stats . getCacheCount ( ) ) ; assertEquals ( 1L , stats . getHitCount ( ) ) ; assertEquals ( 20L , stats . getMissCount ( ) ) ; IOUtils . close ( r , dir ) ; stats = cache . getStats ( shard ) ; assertEquals ( 0L , stats . getCacheSize ( ) ) ; assertEquals ( 20L , stats . getCacheCount ( ) ) ; assertEquals ( 1L , stats . getHitCount ( ) ) ; assertEquals ( 20L , stats . getMissCount ( ) ) ; cache . onClose ( shard ) ; stats = cache . getStats ( shard ) ; assertEquals ( 0L , stats . getCacheSize ( ) ) ; assertEquals ( 0L , stats . getCacheCount ( ) ) ; assertEquals ( 0L , stats . getHitCount ( ) ) ; assertEquals ( 0L , stats . getMissCount ( ) ) ; cache . close ( ) ; }
ThiagoGarciaAlves/elasticsearch | public void testTwoShards ( ) throws IOException { Directory dir1 = newDirectory ( ) ; IndexWriter w1 = new IndexWriter ( dir1 , newIndexWriterConfig ( ) ) ; w1 . addDocument ( new Document ( ) ) ; DirectoryReader r1 = DirectoryReader . open ( w1 ) ; w1 . close ( ) ; ShardId shard1 = new ShardId ( " index " , " _ na _ " , 0 ) ; r1 = ElasticsearchDirectoryReader . wrap ( r1 , shard1 ) ; IndexSearcher s1 = new IndexSearcher ( r1 ) ; s1 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Directory dir2 = newDirectory ( ) ; IndexWriter w2 = new IndexWriter ( dir2 , newIndexWriterConfig ( ) ) ; w2 . addDocument ( new Document ( ) ) ; DirectoryReader r2 = DirectoryReader . open ( w2 ) ; w2 . close ( ) ; ShardId shard2 = new ShardId ( " index " , " _ na _ " , 1 ) ; r2 = ElasticsearchDirectoryReader . wrap ( r2 , shard2 ) ; IndexSearcher s2 = new IndexSearcher ( r2 ) ; s2 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s1 . setQueryCache ( cache ) ; s2 . setQueryCache ( cache ) ; assertEquals ( 1 , s1 . count ( new DummyQuery ( 0 ) ) ) ; QueryCacheStats stats1 = cache . getStats ( shard1 ) ; assertEquals ( 1L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; QueryCacheStats stats2 = cache . getStats ( shard2 ) ; assertEquals ( 0L , stats2 . getCacheSize ( ) ) ; assertEquals ( 0L , stats2 . getCacheCount ( ) ) ; assertEquals ( 0L , stats2 . getHitCount ( ) ) ; assertEquals ( 0L , stats2 . getMissCount ( ) ) ; assertEquals ( 1 , s2 . count ( new DummyQuery ( 0 ) ) ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 1L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 1L , stats2 . getCacheSize ( ) ) ; assertEquals ( 1L , stats2 . getCacheCount ( ) ) ; assertEquals ( 0L , stats2 . getHitCount ( ) ) ; assertEquals ( 1L , stats2 . getMissCount ( ) ) ; for ( int i = 0 ; i < 20 ; ++ i ) { assertEquals ( 1 , s2 . count ( new DummyQuery ( i ) ) ) ; } stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 10L , stats2 . getCacheSize ( ) ) ; assertEquals ( 20L , stats2 . getCacheCount ( ) ) ; assertEquals ( 1L , stats2 . getHitCount ( ) ) ; assertEquals ( 20L , stats2 . getMissCount ( ) ) ; IOUtils . close ( r1 , dir1 ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 1L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 10L , stats2 . getCacheSize ( ) ) ; assertEquals ( 20L , stats2 . getCacheCount ( ) ) ; assertEquals ( 1L , stats2 . getHitCount ( ) ) ; assertEquals ( 20L , stats2 . getMissCount ( ) ) ; cache . onClose ( shard1 ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 0L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 0L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 10L , stats2 . getCacheSize ( ) ) ; assertEquals ( 20L , stats2 . getCacheCount ( ) ) ; assertEquals ( 1L , stats2 . getHitCount ( ) ) ; assertEquals ( 20L , stats2 . getMissCount ( ) ) ; IOUtils . close ( r2 , dir2 ) ; cache . onClose ( shard2 ) ; stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 0L , stats1 . getCacheCount ( ) ) ; assertEquals ( 0L , stats1 . getHitCount ( ) ) ; assertEquals ( 0L , stats1 . getMissCount ( ) ) ; stats2 = cache . getStats ( shard2 ) ; assertEquals ( 0L , stats2 . getCacheSize ( ) ) ; assertEquals ( 0L , stats2 . getCacheCount ( ) ) ; assertEquals ( 0L , stats2 . getHitCount ( ) ) ; assertEquals ( 0L , stats2 . getMissCount ( ) ) ; cache . close ( ) ; }
ThiagoGarciaAlves/elasticsearch | public void testStatsOnEviction ( ) throws IOException { Directory dir1 = newDirectory ( ) ; IndexWriter w1 = new IndexWriter ( dir1 , newIndexWriterConfig ( ) ) ; w1 . addDocument ( new Document ( ) ) ; DirectoryReader r1 = DirectoryReader . open ( w1 ) ; w1 . close ( ) ; ShardId shard1 = new ShardId ( " index " , " _ na _ " , 0 ) ; r1 = ElasticsearchDirectoryReader . wrap ( r1 , shard1 ) ; IndexSearcher s1 = new IndexSearcher ( r1 ) ; s1 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Directory dir2 = newDirectory ( ) ; IndexWriter w2 = new IndexWriter ( dir2 , newIndexWriterConfig ( ) ) ; w2 . addDocument ( new Document ( ) ) ; DirectoryReader r2 = DirectoryReader . open ( w2 ) ; w2 . close ( ) ; ShardId shard2 = new ShardId ( " index " , " _ na _ " , 1 ) ; r2 = ElasticsearchDirectoryReader . wrap ( r2 , shard2 ) ; IndexSearcher s2 = new IndexSearcher ( r2 ) ; s2 . setQueryCachingPolicy ( QueryCachingPolicy . ALWAYS_CACHE ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s1 . setQueryCache ( cache ) ; s2 . setQueryCache ( cache ) ; assertEquals ( 1 , s1 . count ( new DummyQuery ( 0 ) ) ) ; for ( int i = 1 ; i <= 20 ; ++ i ) { assertEquals ( 1 , s2 . count ( new DummyQuery ( i ) ) ) ; } QueryCacheStats stats1 = cache . getStats ( shard1 ) ; assertEquals ( 0L , stats1 . getCacheSize ( ) ) ; assertEquals ( 1L , stats1 . getCacheCount ( ) ) ; IOUtils . close ( r1 , dir1 ) ; cache . onClose ( shard1 ) ; IOUtils . close ( r2 , dir2 ) ; cache . onClose ( shard2 ) ; cache . close ( ) ; }
ThiagoGarciaAlves/elasticsearch | DummyWeight ( Weight weight ) { super ( weight . getQuery ( ) ) ; this . weight = weight ; }
ThiagoGarciaAlves/elasticsearch | @ Override public void extractTerms ( Set < Term > terms ) { weight . extractTerms ( terms ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public Explanation explain ( LeafReaderContext context , int doc ) throws IOException { return weight . explain ( context , doc ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public Scorer scorer ( LeafReaderContext context ) throws IOException { scorerCalled = true ; return weight . scorer ( context ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public ScorerSupplier scorerSupplier ( LeafReaderContext context ) throws IOException { scorerSupplierCalled = true ; return weight . scorerSupplier ( context ) ; }
ThiagoGarciaAlves/elasticsearch | @ Override public boolean isCacheable ( LeafReaderContext ctx ) { return true ; }
ThiagoGarciaAlves/elasticsearch | public void testDelegatesScorerSupplier ( ) throws Exception { Directory dir = newDirectory ( ) ; IndexWriter w = new IndexWriter ( dir , newIndexWriterConfig ( ) ) ; w . addDocument ( new Document ( ) ) ; DirectoryReader r = DirectoryReader . open ( w ) ; w . close ( ) ; ShardId shard = new ShardId ( " index " , " _ na _ " , 0 ) ; r = ElasticsearchDirectoryReader . wrap ( r , shard ) ; IndexSearcher s = new IndexSearcher ( r ) ; s . setQueryCachingPolicy ( new QueryCachingPolicy ( ) { @ Override public boolean shouldCache ( Query query ) throws IOException { return false ; } @ Override public void onUse ( Query query ) { } } ) ; Settings settings = Settings . builder ( ) . put ( IndicesQueryCache . INDICES_CACHE_QUERY_COUNT_SETTING . getKey ( ) , 10 ) . put ( IndicesQueryCache . INDICES_QUERIES_CACHE_ALL_SEGMENTS_SETTING . getKey ( ) , true ) . build ( ) ; IndicesQueryCache cache = new IndicesQueryCache ( settings ) ; s . setQueryCache ( cache ) ; Query query = new MatchAllDocsQuery ( ) ; final DummyWeight weight = new DummyWeight ( s . createNormalizedWeight ( query , false ) ) ; final Weight cached = cache . doCache ( weight , s . getQueryCachingPolicy ( ) ) ; assertNotSame ( weight , cached ) ; assertFalse ( weight . scorerCalled ) ; assertFalse ( weight . scorerSupplierCalled ) ; cached . scorerSupplier ( s . getIndexReader ( ) . leaves ( ) . get ( 0 ) ) ; assertFalse ( weight . scorerCalled ) ; assertTrue ( weight . scorerSupplierCalled ) ; IOUtils . close ( r , dir ) ; cache . onClose ( shard ) ; cache . close ( ) ; }
Ossit/SenseBack | private SensorDbHelper ( Context context ) { super ( context , SensorDbContract . DATABASE_NAME , null , DATABASE_VERSION ) ; }
Ossit/SenseBack | @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_DATA_TABLE ) ; db . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_NAME_TABLE ) ; initializeSensorTable ( db ) ; }
Ossit/SenseBack | public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { db . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_DATA_TABLE ) ; db . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_NAME_TABLE ) ; onCreate ( db ) ; }
Ossit/SenseBack | public void insertSensorData ( long timeStampMillis , int sensorId , int value ) { ContentValues values = new ContentValues ( ) ; values . put ( SensorDbContract . SensorDataTable . COLUMN_NAME_TIME , timeStampMillis ) ; values . put ( SensorDbContract . SensorDataTable . COLUMN_NAME_SENSOR_ID , sensorId ) ; values . put ( SensorDbContract . SensorDataTable . COLUMN_NAME_VALUE , value ) ; this . getWritableDatabase ( ) . insert ( SensorDbContract . SensorDataTable . TABLE_NAME , null , values ) ; }
Ossit/SenseBack | public void insertSensor ( int sensorId , String sensorName ) { ContentValues values = new ContentValues ( ) ; values . put ( SensorDbContract . SensorNameTable . COLUMN_NAME_SENSOR_ID , sensorId ) ; values . put ( SensorDbContract . SensorNameTable . COLUMN_NAME_SENSOR_NAME , sensorName ) ; this . getWritableDatabase ( ) . insert ( SensorDbContract . SensorNameTable . TABLE_NAME , null , values ) ; }
Ossit/SenseBack | public void dropSensorDataTable ( ) { this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_DATA_TABLE ) ; this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_DATA_TABLE ) ; }
Ossit/SenseBack | public void dropSensorNameTable ( ) { this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_DELETE_SENSOR_NAME_TABLE ) ; this . getWritableDatabase ( ) . execSQL ( SensorDbCommands . SQL_CREATE_SENSOR_NAME_TABLE ) ; }
Ossit/SenseBack | private void initializeSensorTable ( SQLiteDatabase db ) { insertSensor ( 34 , " Sensor34" ) ; insertSensor ( 56 , " Sensor56" ) ; }
TexasDigitalLibrary/duracloud | @ Before public void setUp ( ) throws Exception { targetProvider = new MockStorageProvider ( ) ; directProvider = new MockStorageProvider ( ) ; dispatchProvider = new StatelessStorageProviderImpl ( ) ; broker = new BrokeredStorageProvider ( dispatchProvider , targetProvider , StorageProviderType . UNKNOWN , "0" ) ; content = new ByteArrayInputStream ( " " . getBytes ( ) ) ; }
TexasDigitalLibrary/duracloud | @ After public void tearDown ( ) throws Exception { broker = null ; dispatchProvider = null ; targetProvider = null ; directProvider = null ; content . close ( ) ; content = null ; }
TexasDigitalLibrary/duracloud | @ Test public void testAddContent ( ) throws StorageException { directProvider . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; broker . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; verifySpaceId ( ) ; verifyContentId ( ) ; verifyContentMimeType ( ) ; verifyContentSize ( ) ; verifyContent ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void testCreateSpace ( ) throws StorageException { directProvider . createSpace ( spaceId ) ; broker . createSpace ( spaceId ) ; verifySpaceId ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void testDeleteContent ( ) throws StorageException { directProvider . deleteContent ( spaceId , contentId ) ; broker . deleteContent ( spaceId , contentId ) ; verifySpaceId ( ) ; verifyContentId ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void deleteSpace ( ) throws StorageException { directProvider . deleteSpace ( spaceId ) ; broker . deleteSpace ( spaceId ) ; verifySpaceId ( ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getContent ( ) throws StorageException { directProvider . setContent ( content ) ; targetProvider . setContent ( content ) ; InputStream content0 = directProvider . getContent ( spaceId , contentId ) . getContentStream ( ) ; InputStream content1 = broker . getContent ( spaceId , contentId ) . getContentStream ( ) ; verify ( content0 , content1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getContentProperties ( ) throws StorageException { directProvider . setContentProperties ( spaceId , contentId , contentProperties ) ; broker . setContentProperties ( spaceId , contentId , contentProperties ) ; Map < String , String > meta0 = directProvider . getContentProperties ( spaceId , contentId ) ; Map < String , String > meta1 = broker . getContentProperties ( spaceId , contentId ) ; verify ( meta0 , meta1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaceContents ( ) throws StorageException { directProvider . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; broker . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; Iterator < String > spaceContents0 = directProvider . getSpaceContents ( spaceId , null ) ; Iterator < String > spaceContents1 = broker . getSpaceContents ( spaceId , null ) ; verifyIteratorContents ( spaceContents0 , spaceContents1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaceContentsChunked ( ) throws StorageException { directProvider . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; broker . addContent ( spaceId , contentId , contentMimeType , userProperties , contentSize , null , content ) ; List < String > spaceContents0 = directProvider . getSpaceContentsChunked ( spaceId , null , 0 , null ) ; List < String > spaceContents1 = broker . getSpaceContentsChunked ( spaceId , null , 0 , null ) ; verifyIteratorContents ( spaceContents0 . iterator ( ) , spaceContents1 . iterator ( ) ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaceProperties ( ) throws StorageException { Map < String , String > meta0 = directProvider . getSpaceProperties ( spaceId ) ; Map < String , String > meta1 = broker . getSpaceProperties ( spaceId ) ; verify ( meta0 , meta1 ) ; }
TexasDigitalLibrary/duracloud | @ Test public void getSpaces ( ) throws StorageException { directProvider . createSpace ( spaceId ) ; broker . createSpace ( spaceId ) ; Iterator < String > spaces0 = directProvider . getSpaces ( ) ; Iterator < String > spaces1 = broker . getSpaces ( ) ; verifyIteratorContents ( spaces0 , spaces1 ) ; }
TexasDigitalLibrary/duracloud | private void verifySpaceId ( ) { Assert . assertNotNull ( directProvider . getSpaceId ( ) ) ; Assert . assertEquals ( directProvider . getSpaceId ( ) , targetProvider . getSpaceId ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContentId ( ) { Assert . assertNotNull ( directProvider . getContentId ( ) ) ; Assert . assertEquals ( directProvider . getContentId ( ) , targetProvider . getContentId ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContentMimeType ( ) { Assert . assertNotNull ( directProvider . getContentMimeType ( ) ) ; Assert . assertEquals ( directProvider . getContentMimeType ( ) , targetProvider . getContentMimeType ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContentSize ( ) { Assert . assertNotNull ( directProvider . getContentSize ( ) ) ; Assert . assertEquals ( directProvider . getContentSize ( ) , targetProvider . getContentSize ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyContent ( ) { Assert . assertNotNull ( directProvider . getContent ( ) ) ; Assert . assertEquals ( directProvider . getContent ( ) , targetProvider . getContent ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifySpaceProperties ( ) { Assert . assertNotNull ( directProvider . getSpaceProperties ( ) ) ; Assert . assertEquals ( directProvider . getSpaceProperties ( ) , targetProvider . getSpaceProperties ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verifyIteratorContents ( Iterator < String > iter0 , Iterator < String > iter1 ) { Assert . assertNotNull ( iter0 ) ; Assert . assertNotNull ( iter1 ) ; while ( iter0 . hasNext ( ) ) { Assert . assertEquals ( iter0 . next ( ) , iter1 . next ( ) ) ; } Assert . assertFalse ( iter1 . hasNext ( ) ) ; }
TexasDigitalLibrary/duracloud | private void verify ( Object obj0 , Object obj1 ) { Assert . assertNotNull ( obj0 ) ; Assert . assertEquals ( obj0 , obj1 ) ; }
Alluxio/alluxio | protected KodoUnderFileSystem ( AlluxioURI uri , KodoClient kodoclient , UnderFileSystemConfiguration conf ) { super ( uri , conf ) ; mKodoClinet = kodoclient ; }
Alluxio/alluxio | @ Override public String getUnderFSType ( ) { return " kodo " ; }
Alluxio/alluxio | @ Override public void setOwner ( String path , String user , String group ) { }
Alluxio/alluxio | @ Override public void setMode ( String path , short mode ) throws IOException { }
Alluxio/alluxio | @ Override protected boolean copyObject ( String src , String dst ) { try { mKodoClinet . copyObject ( src , dst ) ; return true ; } catch ( QiniuException e ) { LOG . error ( " copy ▁ Object ▁ failed ▁ { } ▁ to ▁ { } ▁ , ▁ Msg : { } " , src , dst , e ) ; } return false ; }
Alluxio/alluxio | @ Override public boolean createEmptyObject ( String key ) { try { mKodoClinet . createEmptyObject ( key ) ; return true ; } catch ( QiniuException e ) { LOG . error ( " create ▁ empty ▁ object ▁ failed ▁ key : { } ▁ , ▁ Msg : { } " , key , e ) ; } return false ; }
Alluxio/alluxio | @ Override protected OutputStream createObject ( String key ) throws IOException { return new KodoOutputStream ( key , mKodoClinet , mUfsConf . getList ( PropertyKey . TMP_DIRS ) ) ; }
Alluxio/alluxio | @ Override protected boolean deleteObject ( String key ) { try { mKodoClinet . deleteObject ( key ) ; return true ; } catch ( QiniuException e ) { LOG . error ( " delete ▁ object ▁ failed ▁ key : { } , ▁ Msg : { } " , key , e ) ; } return false ; }
Alluxio/alluxio | @ Override protected String getFolderSuffix ( ) { return FOLDER_SUFFIX ; }
Alluxio/alluxio | @ Nullable @ Override protected ObjectListingChunk getObjectListingChunk ( String key , boolean recursive ) throws IOException { String delimiter = recursive ? " " : PATH_SEPARATOR ; key = PathUtils . normalizePath ( key , PATH_SEPARATOR ) ; key = key . equals ( PATH_SEPARATOR ) ? " " : key ; FileListing result = getObjectListingChunk ( key , getListingChunkLength ( mUfsConf ) , delimiter ) ; if ( result != null ) { return new KodoObjectListingChunk ( result , getListingChunkLength ( mUfsConf ) , delimiter , key ) ; } return null ; }
Alluxio/alluxio | private FileListing getObjectListingChunk ( String prefix , int limit , String delimiter ) { try { return mKodoClinet . listFiles ( prefix , null , limit , delimiter ) ; } catch ( QiniuException e ) { LOG . error ( " list ▁ objects ▁ failed : " , e ) ; return null ; } }
Alluxio/alluxio | @ Nullable @ Override protected ObjectStatus getObjectStatus ( String key ) { try { FileInfo fileInfo = mKodoClinet . getFileInfo ( key ) ; if ( fileInfo == null ) { return null ; } return new ObjectStatus ( key , fileInfo . hash , fileInfo . fsize , fileInfo . putTime / 10000 ) ; } catch ( QiniuException e ) { return null ; } }
Alluxio/alluxio | @ Override protected ObjectPermissions getPermissions ( ) { return new ObjectPermissions ( " " , " " , Constants . DEFAULT_FILE_SYSTEM_MODE ) ; }
Alluxio/alluxio | @ Override protected InputStream openObject ( String key , OpenOptions options , RetryPolicy retryPolicy ) { try { return new KodoInputStream ( key , mKodoClinet , options . getOffset ( ) , retryPolicy , mUfsConf . getBytes ( PropertyKey . UNDERFS_OBJECT_STORE_MULTI_RANGE_CHUNK_SIZE ) ) ; } catch ( QiniuException e ) { LOG . error ( " Failed ▁ to ▁ open ▁ Object ▁ { } , ▁ Msg : ▁ { } " , key , e ) ; } return null ; }
Alluxio/alluxio | @ Override protected String getRootKey ( ) { return Constants . HEADER_KODO + mKodoClinet . getBucketName ( ) ; }
Alluxio/alluxio | KodoObjectListingChunk ( FileListing result , int limit , String delimiter , String prefix ) throws IOException { mLimit = limit ; mDelimiter = delimiter ; mResult = result ; mPrefix = prefix ; }
Alluxio/alluxio | @ Override public ObjectStatus [ ] getObjectStatuses ( ) { FileInfo [ ] fileInfos = mResult . items ; ObjectStatus [ ] ret = new ObjectStatus [ fileInfos . length ] ; int i = 0 ; for ( FileInfo fileInfo : fileInfos ) { if ( fileInfo . key != null ) { ret [ i ++ ] = new ObjectStatus ( fileInfo . key , fileInfo . hash , fileInfo . fsize , fileInfo . putTime / 10000 ) ; } } return ret ; }
Alluxio/alluxio | @ Override public String [ ] getCommonPrefixes ( ) { if ( mResult . commonPrefixes == null ) { return new String [ ] { } ; } return mResult . commonPrefixes ; }
Alluxio/alluxio | @ Nullable @ Override public ObjectListingChunk getNextChunk ( ) throws IOException { if ( ! mResult . isEOF ( ) ) { FileListing nextResult = mKodoClinet . listFiles ( mPrefix , mResult . marker , mLimit , mDelimiter ) ; return new KodoObjectListingChunk ( nextResult , mLimit , mDelimiter , mPrefix ) ; } return null ; }
DarwinSPL/DarwinSPL | public HymappingKeyword ( String value , eu . hyvar . feature . mapping . resource . hymapping . grammar . HymappingCardinality cardinality ) { super ( cardinality , null ) ; this . value = value ; }
DarwinSPL/DarwinSPL | public String getValue ( ) { return value ; }
DarwinSPL/DarwinSPL | public String toString ( ) { return " \" " + value + " \" " ; }
459below/jitsi | public StatusSelectorMenu ( ) { super ( ) ; }
459below/jitsi | public StatusSelectorMenu ( String text , Icon defaultIcon , ProtocolProviderService protocolProvider ) { super ( text , defaultIcon ) ; this . protocolProvider = protocolProvider ; this . presence = protocolProvider . getOperationSet ( OperationSetPresence . class ) ; this . onlineStatus = AccountStatusUtils . getOnlineStatus ( protocolProvider ) ; this . offlineStatus = AccountStatusUtils . getOfflineStatus ( protocolProvider ) ; loadSkin ( ) ; }
459below/jitsi | public int getAccountIndex ( ) { return - 1 ; }
459below/jitsi | public void setAccountIndex ( int index ) { }
459below/jitsi | @ Override public void paintComponent ( Graphics g ) { AntialiasingManager . activateAntialiasing ( g ) ; super . paintComponent ( g ) ; if ( isConnecting ) g . drawImage ( getConnectingIcon ( ) , 0 , 3 , this ) ; }
459below/jitsi | private Image getConnectingIcon ( ) { if ( connectingIcon == null ) { connectingIcon = GuiActivator . getResources ( ) . getImage ( " service . gui . icons . CONNECTING " ) . getImage ( ) ; } return connectingIcon ; }
459below/jitsi | private void clearConnectingIcon ( ) { if ( connectingIcon != null ) { connectingIcon . flush ( ) ; connectingIcon = null ; } }
459below/jitsi | public void startConnecting ( ) { setConnecting ( true ) ; }
459below/jitsi | public void stopConnecting ( ) { clearConnectingIcon ( ) ; setConnecting ( false ) ; }
459below/jitsi | private void setConnecting ( boolean isConnecting ) { this . isConnecting = isConnecting ; this . repaint ( ) ; }
459below/jitsi | @ Override public boolean imageUpdate ( Image img , int infoflags , int x , int y , int w , int h ) { repaint ( ) ; return true ; }
459below/jitsi | public ProtocolProviderService getProtocolProvider ( ) { return protocolProvider ; }
459below/jitsi | public PresenceStatus getOfflineStatus ( ) { return offlineStatus ; }
459below/jitsi | public PresenceStatus getOnlineStatus ( ) { return onlineStatus ; }
459below/jitsi | public void loadSkin ( ) { clearConnectingIcon ( ) ; }
459below/jitsi | public void dispose ( ) { protocolProvider = null ; clearConnectingIcon ( ) ; offlineStatus = null ; onlineStatus = null ; }
459below/jitsi | public JMenuItem getEntryComponent ( ) { return this ; }
gurbuzali/hazelcast-jet | CsvFileFormat ( ) { }
gurbuzali/hazelcast-jet | @ Nonnull public CsvFileFormat < T > withClass ( @ Nullable Class < T > clazz ) { this . clazz = clazz ; return this ; }
gurbuzali/hazelcast-jet | @ Nullable public Class < T > clazz ( ) { return clazz ; }
gurbuzali/hazelcast-jet | @ Nonnull @ Override public String format ( ) { return FORMAT_CSV ; }
onders86/camel | protected AbstractBraintreeTestSupport ( ) { this . gateway = null ; }
onders86/camel | @ Override protected CamelContext createCamelContext ( ) throws Exception { final CamelContext context = super . createCamelContext ( ) ; final BraintreeComponent component = new BraintreeComponent ( context ) ; component . setConfiguration ( buildBraintreeConfiguration ( ) ) ; context . addComponent ( " braintree " , component ) ; return context ; }
onders86/camel | protected void addOptionIfMissing ( Map < String , Object > options , String name , String envName ) { if ( ! options . containsKey ( name ) ) { String value = System . getenv ( envName ) ; if ( ObjectHelper . isNotEmpty ( value ) ) { options . put ( name , value ) ; } } }
onders86/camel | protected BraintreeConfiguration buildBraintreeConfiguration ( ) throws Exception { final Properties properties = new Properties ( ) ; try { properties . load ( getClass ( ) . getResourceAsStream ( TEST_OPTIONS_PROPERTIES ) ) ; } catch ( Exception e ) { throw new IOException ( String . format ( " % s ▁ could ▁ not ▁ be ▁ loaded : ▁ % s " , TEST_OPTIONS_PROPERTIES , e . getMessage ( ) ) , e ) ; } Map < String , Object > options = new HashMap < > ( ) ; for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { options . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } AuthenticationType configurationType = getAuthenticationType ( ) ; LOG . info ( String . format ( " Test ▁ using ▁ % s ▁ configuration ▁ profile " , configurationType ) ) ; switch ( configurationType ) { case PUBLIC_PRIVATE_KEYS : addOptionIfMissing ( options , " environment " , " CAMEL _ BRAINTREE _ ENVIRONMENT " ) ; addOptionIfMissing ( options , " merchantId " , " CAMEL _ BRAINTREE _ MERCHANT _ ID " ) ; addOptionIfMissing ( options , " publicKey " , " CAMEL _ BRAINTREE _ PUBLIC _ KEY " ) ; addOptionIfMissing ( options , " privateKey " , " CAMEL _ BRAINTREE _ PRIVATE _ KEY " ) ; options . remove ( " accessToken " ) ; options . remove ( " clientId " ) ; break ; case ACCESS_TOKEN : addOptionIfMissing ( options , " accessToken " , " CAMEL _ BRAINTREE _ ACCESS _ TOKEN " ) ; options . remove ( " environment " ) ; options . remove ( " merchantId " ) ; options . remove ( " publicKey " ) ; options . remove ( " privateKey " ) ; break ; default : throw new IllegalArgumentException ( " Unsupported ▁ configuration ▁ type " ) ; } final BraintreeConfiguration configuration = new BraintreeConfiguration ( ) ; configuration . setHttpLogLevel ( BraintreeLogHandler . DEFAULT_LOGGER_VERSION ) ; configuration . setHttpLogName ( BraintreeLogHandler . DEFAULT_LOGGER_NAME ) ; IntrospectionSupport . setProperties ( configuration , options ) ; return configuration ; }
onders86/camel | protected AuthenticationType getAuthenticationType ( ) { if ( authenticationType == null ) { authenticationType = parseAuthenticationType ( ) ; } return authenticationType ; }
onders86/camel | protected boolean checkAuthenticationType ( AuthenticationType authenticationType ) { return getAuthenticationType ( ) . equals ( authenticationType ) ; }
onders86/camel | private AuthenticationType parseAuthenticationType ( ) { String authenticationTypeString = System . getProperty ( " braintreeAuthenticationType " ) ; if ( authenticationTypeString != null ) { AuthenticationType authenticationType = AuthenticationType . valueOf ( authenticationTypeString ) ; if ( authenticationType != null ) { return authenticationType ; } } return AuthenticationType . PUBLIC_PRIVATE_KEYS ; }
onders86/camel | @ Override public boolean isCreateCamelContextPerClass ( ) { return false ; }
onders86/camel | protected < T > T requestBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers ) throws CamelExecutionException { return ( T ) template ( ) . requestBodyAndHeaders ( endpointUri , body , headers ) ; }
onders86/camel | protected < T > T requestBodyAndHeaders ( String endpointUri , Object body , Map < String , Object > headers , Class < T > type ) throws CamelExecutionException { return template ( ) . requestBodyAndHeaders ( endpointUri , body , headers , type ) ; }
onders86/camel | protected < T > T requestBody ( String endpoint , Object body ) throws CamelExecutionException { return ( T ) template ( ) . requestBody ( endpoint , body ) ; }
onders86/camel | protected < T > T requestBody ( String endpoint , Object body , Class < T > type ) throws CamelExecutionException { return template ( ) . requestBody ( endpoint , body , type ) ; }
onders86/camel | protected final BraintreeComponent getBraintreeComponent ( ) { return ( BraintreeComponent ) context ( ) . getComponent ( " braintree " ) ; }
onders86/camel | protected final synchronized BraintreeGateway getGateway ( ) { if ( gateway == null ) { gateway = getBraintreeComponent ( ) . getConfiguration ( ) . newBraintreeGateway ( ) ; } return gateway ; }
onders86/camel | public BraintreeHeaderBuilder ( ) { headers = new HashMap < > ( ) ; }
onders86/camel | public BraintreeHeaderBuilder add ( String key , Object value ) { if ( key . startsWith ( BraintreeConstants . PROPERTY_PREFIX ) ) { headers . put ( key , value ) ; } else { headers . put ( BraintreeConstants . PROPERTY_PREFIX + key , value ) ; } return this ; }
onders86/camel | public Map < String , Object > build ( ) { return Collections . unmodifiableMap ( headers ) ; }
Ironc2/barbapapa | @ Override protected void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . command_layout ) ; beer = Database . getBeerForCommand ( ) ; TextView beerText = ( TextView ) findViewById ( R . id . beerText ) ; beerText . setText ( beer . name ) ; ImageView beerImage = ( ImageView ) findViewById ( R . id . beerPhoto ) ; beerImage . setImageResource ( beer . imageID ) ; TextView type = ( TextView ) findViewById ( R . id . typeText ) ; type . setText ( beer . type ) ; TextView color = ( TextView ) findViewById ( R . id . colorText ) ; color . setText ( " Couleur ▁ : ▁ " + beer . color ) ; TextView abv = ( TextView ) findViewById ( R . id . ABVText ) ; abv . setText ( beer . getABV ( ) ) ; TextView bottle = ( TextView ) findViewById ( R . id . bottleText ) ; bottle . setText ( beer . getBottleDesc ( ) ) ; TextView description = ( TextView ) findViewById ( R . id . description ) ; description . setText ( beer . description ) ; ImageButton cancel = ( ImageButton ) findViewById ( R . id . cancelButton ) ; cancel . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { returnToMainActivity ( ) ; } } ) ; number = ( TextView ) findViewById ( R . id . number ) ; number . setText ( String . valueOf ( beerNumber ) ) ; ImageButton minus = ( ImageButton ) findViewById ( R . id . minus ) ; minus . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( beerNumber > 1 ) { beerNumber -- ; number . setText ( String . valueOf ( beerNumber ) ) ; } } } ) ; ImageButton plus = ( ImageButton ) findViewById ( R . id . plus ) ; plus . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( beerNumber < 10 ) { beerNumber ++ ; number . setText ( String . valueOf ( beerNumber ) ) ; } } } ) ; final Button commanderButton = ( Button ) findViewById ( R . id . commanderButton ) ; final Button retourButton = ( Button ) findViewById ( R . id . retourButton ) ; if ( beer . checked ) { commanderButton . setText ( " Checked " ) ; retourButton . setText ( " Annuler " ) ; } else { commanderButton . setText ( " Check - in " ) ; retourButton . setText ( " Retour " ) ; } commanderButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( ! beer . checked ) { beer . checked = true ; Utils . goToActivity ( CommandActivity . this , MainActivity . class ) ; } } } ) ; retourButton . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View view ) { if ( beer . checked ) { beer . checked = false ; } Utils . goToActivity ( CommandActivity . this , MainActivity . class ) ; } } ) ; }
Ironc2/barbapapa | public void returnToMainActivity ( ) { Intent intent = new Intent ( this , MainActivity . class ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TOP ) ; startActivity ( intent ) ; }
SP96/SpringProject | public Address ( ) { }
SP96/SpringProject | public String getStreet ( ) { return street ; }
SP96/SpringProject | public void setStreet ( String street ) { this . street = street ; }
SP96/SpringProject | public String getPostcode ( ) { return postcode ; }
SP96/SpringProject | public void setPostcode ( String postcode ) { this . postcode = postcode ; }
SP96/SpringProject | public Address ( String street , String postcode ) { this . street = street ; this . postcode = postcode ; }
SP96/SpringProject | public void init ( ) { System . out . println ( " init ▁ called , ▁ Bean ▁ created : ▁ " + this ) ; }
SP96/SpringProject | public void destroy ( ) { }
SP96/SpringProject | @ Override public String toString ( ) { return " Address ▁ [ street = ▁ " + street + " , ▁ postcode = ▁ " + postcode + " ] " ; }
afinka77/ignite | public VisorCachePartitions ( ) { primary = new ArrayList < > ( ) ; backup = new ArrayList < > ( ) ; }
afinka77/ignite | public void addPrimary ( int part , int heap , long offheap , long swap ) { primary . add ( new VisorCachePartition ( part , heap , offheap , swap ) ) ; }
afinka77/ignite | public void addBackup ( int part , int heap , long offheap , long swap ) { backup . add ( new VisorCachePartition ( part , heap , offheap , swap ) ) ; }
afinka77/ignite | public List < VisorCachePartition > primary ( ) { return primary ; }
afinka77/ignite | public List < VisorCachePartition > backup ( ) { return backup ; }
afinka77/ignite | @ Override public String toString ( ) { return S . toString ( VisorCachePartitions . class , this ) ; }
jmarkos/protostream | @ Override public String getTypeName ( ) { return " sample _ bank _ account . Account . Limits " ; }
jmarkos/protostream | @ Override public Class < ? extends Account . Limits > getJavaClass ( ) { return Account . Limits . class ; }
jmarkos/protostream | @ Override public Account . Limits readFrom ( ProtoStreamReader reader ) throws IOException { double maxDailyLimit = reader . readDouble ( " maxDailyLimit " ) ; double maxTransactionLimit = reader . readDouble ( " maxTransactionLimit " ) ; Account . Limits account = new Account . Limits ( ) ; account . setMaxDailyLimit ( maxDailyLimit ) ; account . setMaxTransactionLimit ( maxTransactionLimit ) ; return account ; }
jmarkos/protostream | @ Override public void writeTo ( ProtoStreamWriter writer , Account . Limits limits ) throws IOException { writer . writeDouble ( " maxDailyLimit " , limits . getMaxDailyLimit ( ) ) ; writer . writeDouble ( " maxTransactionLimit " , limits . getMaxTransactionLimit ( ) ) ; }
osinstom/onos | private CriterionTranslatorHelper ( ) { }
Mozu/mozu-java | public ChannelResource ( ApiContext apiContext ) { _apiContext = apiContext ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . ChannelCollection getChannels ( ) throws Exception { return getChannels ( null , null , null , null , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . ChannelCollection getChannels ( Integer startIndex , Integer pageSize , String sortBy , String filter , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . ChannelCollection > client = com . mozu . api . clients . commerce . ChannelClient . getChannelsClient ( startIndex , pageSize , sortBy , filter , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel getChannel ( String code ) throws Exception { return getChannel ( code , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel getChannel ( String code , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . Channel > client = com . mozu . api . clients . commerce . ChannelClient . getChannelClient ( code , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel createChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel ) throws Exception { return createChannel ( channel , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel createChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . Channel > client = com . mozu . api . clients . commerce . ChannelClient . createChannelClient ( channel , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel updateChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel , String code ) throws Exception { return updateChannel ( channel , code , null ) ; }
Mozu/mozu-java | public com . mozu . api . contracts . commerceruntime . channels . Channel updateChannel ( com . mozu . api . contracts . commerceruntime . channels . Channel channel , String code , String responseFields ) throws Exception { MozuClient < com . mozu . api . contracts . commerceruntime . channels . Channel > client = com . mozu . api . clients . commerce . ChannelClient . updateChannelClient ( channel , code , responseFields ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; return client . getResult ( ) ; }
Mozu/mozu-java | public void deleteChannel ( String code ) throws Exception { MozuClient client = com . mozu . api . clients . commerce . ChannelClient . deleteChannelClient ( code ) ; client . setContext ( _apiContext ) ; client . executeRequest ( ) ; client . cleanupHttpConnection ( ) ; }
simplaapliko/Trips | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; ButterKnife . bind ( this ) ; ActionBar actionBar = getSupportActionBar ( ) ; if ( actionBar != null ) { actionBar . setDisplayHomeAsUpEnabled ( true ) ; actionBar . setHomeButtonEnabled ( true ) ; } mPagerAdapter = new PlacePagerAdapter ( getSupportFragmentManager ( ) , this ) ; activityComponent ( ) . inject ( this ) ; initializeWidgets ( ) ; initializeActivity ( savedInstanceState ) ; initializeInjector ( ) ; }
simplaapliko/Trips | @ Override protected void onSaveInstanceState ( Bundle savedInstanceState ) { if ( savedInstanceState != null ) { savedInstanceState . putLong ( TRIP_ID_KEY , mTripId ) ; } super . onSaveInstanceState ( savedInstanceState ) ; }
simplaapliko/Trips | @ Override protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; if ( resultCode != RESULT_OK ) { return ; } switch ( requestCode ) { case CREATE_PLACE : onCreatePlaceResultReceived ( ) ; break ; case EDIT_PLACE : onEditPlaceResultReceived ( ) ; break ; } }
simplaapliko/Trips | @ Override public PlaceListComponent getComponent ( ) { return mPlaceListComponent ; }
simplaapliko/Trips | @ OnClick ( R . id . add_fab ) public void onAddFabClick ( ) { mNavigator . navigateToAddPlace ( this , mTripId ) ; }
simplaapliko/Trips | @ Override protected int getContentView ( ) { return R . layout . activity_trip ; }
simplaapliko/Trips | private void initializeActivity ( Bundle savedInstanceState ) { if ( savedInstanceState == null ) { mTripId = getIntent ( ) . getLongExtra ( TRIP_ID_KEY , - 1L ) ; } else { mTripId = savedInstanceState . getInt ( TRIP_ID_KEY ) ; } }
simplaapliko/Trips | private void initializeInjector ( ) { mPlaceListComponent = super . getAppComponent ( ) . plusPlaceListComponent ( new PlaceListModule ( mTripId ) ) ; }
simplaapliko/Trips | private void initializeWidgets ( ) { mViewPager . setAdapter ( mPagerAdapter ) ; mViewPager . addOnPageChangeListener ( new ViewPager . SimpleOnPageChangeListener ( ) { @ Override public void onPageSelected ( int position ) { mPagerAdapter . onPageSelected ( position ) ; } } ) ; mTabLayout . setupWithViewPager ( mViewPager ) ; }
simplaapliko/Trips | private void onCreatePlaceResultReceived ( ) { mPagerAdapter . notifyDataSetChanged ( ) ; }
simplaapliko/Trips | private void onEditPlaceResultReceived ( ) { mPagerAdapter . notifyDataSetChanged ( ) ; }
Ckathode/archimedes-ships | public MobileChunkServer ( World world , EntityShip entityship ) { super ( world , entityship ) ; sendQueue = new HashSet < ChunkPosition > ( ) ; }
Ckathode/archimedes-ships | public Collection < ChunkPosition > getSendQueue ( ) { return sendQueue ; }
Ckathode/archimedes-ships | @ Override public boolean setBlockIDWithMetadata ( int x , int y , int z , Block block , int meta ) { if ( super . setBlockIDWithMetadata ( x , y , z , block , meta ) ) { sendQueue . add ( new ChunkPosition ( x , y , z ) ) ; return true ; } return false ; }
Ckathode/archimedes-ships | @ Override public boolean setBlockMetadata ( int x , int y , int z , int meta ) { if ( super . setBlockMetadata ( x , y , z , meta ) ) { sendQueue . add ( new ChunkPosition ( x , y , z ) ) ; return true ; } return false ; }
Ckathode/archimedes-ships | @ Override protected void onSetBlockAsFilledAir ( int x , int y , int z ) { }
cbeams-archive/spring-framework-2.5.x | public void setFooService ( FooService fooService ) { this . fooService = fooService ; }
cbeams-archive/spring-framework-2.5.x | public void setServiceInvocationCounter ( ServiceInvocationCounter serviceInvocationCounter ) { this . serviceInvocationCounter = serviceInvocationCounter ; }
cbeams-archive/spring-framework-2.5.x | public void testFooService ( ) throws Exception { String value = fooService . foo ( 1 ) ; assertEquals ( " bar " , value ) ; assertEquals ( 1 , serviceInvocationCounter . getCount ( ) ) ; fooService . foo ( 1 ) ; assertEquals ( 2 , serviceInvocationCounter . getCount ( ) ) ; }
cbeams-archive/spring-framework-2.5.x | @ Override protected String [ ] getConfigLocations ( ) { return new String [ ] { " org / springframework / context / annotation / simpleConfigTests . xml " } ; }
michel-kraemer/vertx-lang-typescript | public DiskCache ( File cacheDir ) { this . cacheDir = cacheDir ; }
michel-kraemer/vertx-lang-typescript | private File getFileOnDisk ( Source source ) { return new File ( cacheDir , source . getDigest ( ) ) ; }
michel-kraemer/vertx-lang-typescript | @ Override public String get ( Source src ) { String result = memoryCache . get ( src ) ; if ( result == null ) { File f = getFileOnDisk ( src ) ; if ( f . exists ( ) ) { Source rs ; try { rs = Source . fromFile ( f , StandardCharsets . UTF_8 ) ; result = rs . toString ( ) ; memoryCache . put ( src , result ) ; } catch ( IOException e ) { } } } return result ; }
michel-kraemer/vertx-lang-typescript | @ Override public void put ( Source src , String value ) { memoryCache . put ( src , value ) ; if ( ! cacheDir . exists ( ) ) { cacheDir . mkdirs ( ) ; } File f = getFileOnDisk ( src ) ; try ( Writer w = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( f ) ) ) ) { w . write ( value ) ; w . flush ( ) ; } catch ( IOException e ) { } }
aperepel/netty | public RtspResponseDecoder ( ) { super ( ) ; }
aperepel/netty | public RtspResponseDecoder ( int maxInitialLineLength , int maxHeaderSize , int maxContentLength ) { super ( maxInitialLineLength , maxHeaderSize , maxContentLength ) ; }
aperepel/netty | @ Override protected HttpMessage createMessage ( String [ ] initialLine ) throws Exception { return new DefaultHttpResponse ( RtspVersions . valueOf ( initialLine [ 0 ] ) , new HttpResponseStatus ( Integer . valueOf ( initialLine [ 1 ] ) , initialLine [ 2 ] ) ) ; }
aperepel/netty | @ Override protected boolean isDecodingRequest ( ) { return false ; }
SirDap/itranslator99-to-unicode-epub-converter | if ( deleteOutputFile ) { actualOutputFile . deleteOnExit ( ) ; }
bsenduran/wso2-commons-vfs | public FileContentInfo create ( FileContent fileContent ) throws FileSystemException { WebdavFileObject file = ( WebdavFileObject ) ( FileObjectUtils . getAbstractFileObject ( fileContent . getFile ( ) ) ) ; String contentType = null ; String contentEncoding = null ; DavPropertyNameSet nameSet = new DavPropertyNameSet ( ) ; nameSet . add ( DavPropertyName . GETCONTENTTYPE ) ; DavPropertySet propertySet = file . getProperties ( ( URLFileName ) file . getName ( ) , nameSet , true ) ; DavProperty property = propertySet . get ( DavPropertyName . GETCONTENTTYPE ) ; if ( property != null ) { contentType = ( String ) property . getValue ( ) ; } property = propertySet . get ( WebdavFileObject . RESPONSE_CHARSET ) ; if ( property != null ) { contentEncoding = ( String ) property . getValue ( ) ; } return new DefaultFileContentInfo ( contentType , contentEncoding ) ; }
BladeRunnerJS/closure-compiler | private Base64 ( ) { }
BladeRunnerJS/closure-compiler | i ++ ) { BASE64_DECODE_MAP [ BASE64_MAP . charAt ( i ) ] = i ; }
alect/Puzzledice | public DatabaseModel ( ) { _items = new HashMap < String , DatabaseItem > ( ) ; _properties = new HashMap < String , DatabaseProperty > ( ) ; }
alect/Puzzledice | public boolean addItemToDatabase ( DatabaseItem item ) { if ( _items . containsKey ( item . getName ( ) ) ) { return false ; } for ( String propertyName : _properties . keySet ( ) ) { if ( ! item . hasProperty ( propertyName ) ) item . addProperty ( propertyName , null ) ; } _items . put ( item . getName ( ) , item ) ; WindowMain . addItemToListView ( item ) ; WindowMain . addItemToTableView ( item ) ; return true ; }
alect/Puzzledice | public void removeItemFromDatabase ( DatabaseItem item ) { if ( ! _items . containsKey ( item . getName ( ) ) ) return ; _items . remove ( item . getName ( ) ) ; WindowMain . removeItemFromListView ( item ) ; WindowMain . removeItemFromTableView ( item ) ; }
alect/Puzzledice | public boolean addPropertyToDatabase ( DatabaseProperty property ) { if ( _properties . containsKey ( property . getName ( ) ) ) return false ; _properties . put ( property . getName ( ) , property ) ; for ( DatabaseItem item : _items . values ( ) ) { item . addProperty ( property . getName ( ) , null ) ; } WindowMain . addPropertyToTableView ( property ) ; WindowMain . updateGUI ( ) ; return true ; }
alect/Puzzledice | public void removePropertyFromDatabase ( DatabaseProperty property ) { if ( ! _properties . containsKey ( property . getName ( ) ) ) return ; _properties . remove ( property . getName ( ) ) ; for ( DatabaseItem item : _items . values ( ) ) { item . removeProperty ( property . getName ( ) ) ; } WindowMain . removePropertyFromTableView ( property ) ; WindowMain . updateGUI ( ) ; }
alect/Puzzledice | public DatabaseProperty createInstance ( String propertyName ) { if ( ! _properties . containsKey ( propertyName ) ) return null ; return _properties . get ( propertyName ) . initializeInstance ( ) ; }
alect/Puzzledice | public boolean isPropertyNameInDatabase ( String propertyName ) { return _properties . containsKey ( propertyName ) ; }
alect/Puzzledice | public DatabaseItem [ ] getItemList ( ) { DatabaseItem [ ] items = new DatabaseItem [ _items . values ( ) . size ( ) ] ; return _items . values ( ) . toArray ( items ) ; }
alect/Puzzledice | public DatabaseProperty [ ] getPropertyList ( ) { DatabaseProperty [ ] properties = new DatabaseProperty [ _properties . values ( ) . size ( ) ] ; return _properties . values ( ) . toArray ( properties ) ; }
alect/Puzzledice | public DatabaseProperty getPropertyValue ( String propertyName ) { return _properties . get ( propertyName ) ; }
alect/Puzzledice | public String xmlDigest ( ) { String xml = " < Database > \n < Properties > \n " ; for ( DatabaseProperty property : _properties . values ( ) ) { xml += property . toXML ( ) + " \n " ; } xml += " < / Properties > \n < Items > \n " ; for ( DatabaseItem item : _items . values ( ) ) { xml += item . toXML ( ) + " \n " ; } xml += " < / Items > \n < / Database > " ; return xml ; }
YoungDigitalPlanet/empiria.player | @ Before public void init ( ) { when ( flowData . getCurrentPageIndex ( ) ) . thenReturn ( 0 ) ; when ( itemDataSourceCollectionManager . getItemIdentifier ( 0 ) ) . thenReturn ( identifier ) ; }
YoungDigitalPlanet/empiria.player | @ Test public void shouldReturnStyleWrappedWithOptional ( ) { String style = " style " ; Optional < String > optionalStyle = Optional . of ( style ) ; when ( itemStylesContainer . getStyle ( identifier ) ) . thenReturn ( optionalStyle ) ; Optional < String > result = testObj . getCurrentItemStyle ( ) ; assertThat ( result . isPresent ( ) ) . isTrue ( ) ; assertThat ( result . get ( ) ) . isEqualTo ( style ) ; }
YoungDigitalPlanet/empiria.player | @ Test public void shouldReturnEmptyOptional_whenStyleForPageDoesNotExist ( ) { Optional < String > optionalStyle = Optional . absent ( ) ; when ( itemStylesContainer . getStyle ( identifier ) ) . thenReturn ( optionalStyle ) ; Optional < String > result = testObj . getCurrentItemStyle ( ) ; assertThat ( result . isPresent ( ) ) . isFalse ( ) ; }
snowdream/android-sharesdk | public DemoPage ( final SlidingMenu menu ) { super ( menu ) ; View pageView = getPage ( ) ; llTitle = ( TitleLayout ) pageView . findViewById ( R . id . llTitle ) ; llTitle . getBtnBack ( ) . setOnClickListener ( this ) ; llTitle . getTvTitle ( ) . setText ( R . string . sm_item_demo ) ; pageView . findViewById ( R . id . btnShareAllGui ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnShareAll ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnFlSw ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnFlTc ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnGetToken ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnVisitWc ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnGetInfor ) . setOnClickListener ( this ) ; pageView . findViewById ( R . id . btnGetUserInfor ) . setOnClickListener ( this ) ; new Thread ( ) { public void run ( ) { Platform [ ] list = ShareSDK . getPlatformList ( menu . getContext ( ) ) ; if ( list != null ) { Message msg = new Message ( ) ; msg . obj = list ; UIHandler . sendMessage ( msg , new Callback ( ) { public boolean handleMessage ( Message msg ) { afterPlatformsGot ( ( Platform [ ] ) msg . obj ) ; return false ; } } ) ; } } } . start ( ) ; }
snowdream/android-sharesdk | private void afterPlatformsGot ( Platform [ ] platforms ) { View pageView = getPage ( ) ; LinearLayout llList = ( LinearLayout ) pageView . findViewById ( R . id . llList ) ; LinearLayout line = ( LinearLayout ) View . inflate ( menu . getContext ( ) , R . layout . demo_page_item , null ) ; llList . addView ( line ) ; int lineCount = 0 ; for ( Platform platform : platforms ) { String name = platform . getName ( ) ; if ( ShareCore . isUseClientToShare ( platform . getContext ( ) , name ) ) { continue ; } if ( lineCount >= 2 ) { line = ( LinearLayout ) View . inflate ( menu . getContext ( ) , R . layout . demo_page_item , null ) ; llList . addView ( line ) ; lineCount = 0 ; } int res = lineCount == 0 ? R . id . btnLeft : R . id . btnRight ; Button btn = ( Button ) line . findViewById ( res ) ; btn . setSingleLine ( ) ; int platNameRes = cn . sharesdk . framework . utils . R . getStringRes ( menu . getContext ( ) , name ) ; String platName = menu . getContext ( ) . getString ( platNameRes ) ; String text = menu . getContext ( ) . getString ( R . string . share_to_format , platName ) ; btn . setText ( text ) ; btn . setTag ( platform ) ; btn . setVisibility ( View . VISIBLE ) ; btn . setOnClickListener ( this ) ; lineCount ++ ; } }
snowdream/android-sharesdk | protected View initPage ( ) { return LayoutInflater . from ( menu . getContext ( ) ) . inflate ( R . layout . page_demo , null ) ; }
snowdream/android-sharesdk | private void showShare ( boolean silent , String platform ) { final OnekeyShare oks = new OnekeyShare ( ) ; oks . setNotification ( R . drawable . ic_launcher , menu . getContext ( ) . getString ( R . string . app_name ) ) ; oks . setAddress ( "12345678901" ) ; oks . setTitle ( menu . getContext ( ) . getString ( R . string . evenote_title ) ) ; oks . setTitleUrl ( " http : // sharesdk . cn " ) ; oks . setText ( menu . getContext ( ) . getString ( R . string . share_content ) ) ; oks . setImagePath ( MainActivity . TEST_IMAGE ) ; oks . setImageUrl ( " http : // img . appgo . cn / imgs / sharesdk / content / 2013/07/25/1374723172663 . jpg " ) ; oks . setUrl ( " http : // www . sharesdk . cn " ) ; oks . setFilePath ( MainActivity . TEST_IMAGE ) ; oks . setComment ( menu . getContext ( ) . getString ( R . string . share ) ) ; oks . setSite ( menu . getContext ( ) . getString ( R . string . app_name ) ) ; oks . setSiteUrl ( " http : // sharesdk . cn " ) ; oks . setVenueName ( " ShareSDK " ) ; oks . setVenueDescription ( " This ▁ is ▁ a ▁ beautiful ▁ place ! " ) ; oks . setLatitude ( 23.056081f ) ; oks . setLongitude ( 113.385708f ) ; oks . setSilent ( silent ) ; if ( platform != null ) { oks . setPlatform ( platform ) ; } oks . setShareContentCustomizeCallback ( new ShareContentCustomizeDemo ( ) ) ; oks . show ( menu . getContext ( ) ) ; }
snowdream/android-sharesdk | public void onClick ( View v ) { if ( v . equals ( llTitle . getBtnBack ( ) ) ) { if ( menu . isMenuShown ( ) ) { menu . hideMenu ( ) ; } else { menu . showMenu ( ) ; } return ; } final int id = v . getId ( ) ; if ( id == R . id . btnShareAllGui ) { showShare ( false , null ) ; } else if ( id == R . id . btnShareAll ) { showShare ( true , null ) ; } else if ( id == R . id . btnFlSw ) { Platform plat = ShareSDK . getPlatform ( menu . getContext ( ) , " SinaWeibo " ) ; plat . setPlatformActionListener ( this ) ; plat . followFriend ( MainAdapter . SDK_SINAWEIBO_UID ) ; } else if ( id == R . id . btnFlTc ) { Platform plat = ShareSDK . getPlatform ( menu . getContext ( ) , " TencentWeibo " ) ; plat . setPlatformActionListener ( this ) ; plat . followFriend ( MainAdapter . SDK_TENCENTWEIBO_UID ) ; } else if ( id == R . id . btnGetToken ) { GetTokenPage page = new GetTokenPage ( ) ; page . show ( menu . getContext ( ) , null ) ; } else if ( id == R . id . btnVisitWc ) { String packageName = " com . tencent . mm " ; PackageInfo pi = null ; try { pi = menu . getContext ( ) . getPackageManager ( ) . getPackageInfo ( packageName , 0 ) ; } catch ( Throwable t ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_is_not_installed_correctly , Toast . LENGTH_SHORT ) . show ( ) ; t . printStackTrace ( ) ; } if ( pi == null ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_is_not_installed_correctly , Toast . LENGTH_SHORT ) . show ( ) ; } Intent i = new Intent ( Intent . ACTION_VIEW ) ; i . setData ( Uri . parse ( MainAdapter . WECHAT_ADDR ) ) ; i . setPackage ( " com . tencent . mm " ) ; ResolveInfo ri = menu . getContext ( ) . getPackageManager ( ) . resolveActivity ( i , 0 ) ; if ( ri == null ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_is_not_installed_correctly , Toast . LENGTH_SHORT ) . show ( ) ; } try { menu . getContext ( ) . startActivity ( i ) ; } catch ( Throwable t ) { Toast . makeText ( menu . getContext ( ) , R . string . wechat_client_not_support_following_operation , Toast . LENGTH_SHORT ) . show ( ) ; t . printStackTrace ( ) ; } } else if ( id == R . id . btnGetInfor ) { GetInforPage page = new GetInforPage ( ) ; page . setType ( 0 ) ; page . show ( menu . getContext ( ) , null ) ; } else if ( id == R . id . btnGetUserInfor ) { Intent i = new Intent ( menu . getContext ( ) , GetInforPage . class ) ; i . putExtra ( " type " , 1 ) ; menu . getContext ( ) . startActivity ( i ) ; } else { Object tag = v . getTag ( ) ; if ( tag != null ) { showShare ( false , ( ( Platform ) tag ) . getName ( ) ) ; } } }
snowdream/android-sharesdk | public void onComplete ( Platform plat , int action , HashMap < String , Object > res ) { Message msg = new Message ( ) ; msg . arg1 = 1 ; msg . arg2 = action ; msg . obj = plat ; UIHandler . sendMessage ( msg , this ) ; }
snowdream/android-sharesdk | public void onCancel ( Platform palt , int action ) { Message msg = new Message ( ) ; msg . arg1 = 3 ; msg . arg2 = action ; msg . obj = palt ; UIHandler . sendMessage ( msg , this ) ; }
snowdream/android-sharesdk | public void onError ( Platform palt , int action , Throwable t ) { t . printStackTrace ( ) ; Message msg = new Message ( ) ; msg . arg1 = 2 ; msg . arg2 = action ; msg . obj = palt ; UIHandler . sendMessage ( msg , this ) ; }
snowdream/android-sharesdk | public boolean handleMessage ( Message msg ) { Platform plat = ( Platform ) msg . obj ; String text = MainActivity . actionToString ( msg . arg2 ) ; switch ( msg . arg1 ) { case 1 : { text = plat . getName ( ) + " ▁ completed ▁ at ▁ " + text ; } break ; case 2 : { text = plat . getName ( ) + " ▁ caught ▁ error ▁ at ▁ " + text ; } break ; case 3 : { text = plat . getName ( ) + " ▁ canceled ▁ at ▁ " + text ; } break ; } Toast . makeText ( menu . getContext ( ) , text , Toast . LENGTH_SHORT ) . show ( ) ; return false ; }
LearnLib/automatalib | @ Test public void testNormalDomain ( ) { final Set < List < Integer > > combinations = Streams . stream ( CollectionsUtil . cartesianProduct ( DOMAIN1 , DOMAIN2 , DOMAIN3 ) ) . map ( ArrayList :: new ) . collect ( Collectors . toSet ( ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 1 , 3 , 4 ) ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 1 , 3 , 5 ) ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 2 , 3 , 4 ) ) ) ; Assert . assertTrue ( combinations . remove ( Arrays . asList ( 2 , 3 , 5 ) ) ) ; Assert . assertTrue ( combinations . isEmpty ( ) ) ; }
LearnLib/automatalib | @ Test public void testEmptyDomain ( ) { final Iterable < List < Integer > > iter = CollectionsUtil . cartesianProduct ( DOMAIN1 , Collections . emptyList ( ) , DOMAIN3 ) ; Assert . assertTrue ( Iterables . isEmpty ( iter ) ) ; Assert . assertThrows ( NoSuchElementException . class , ( ) -> iter . iterator ( ) . next ( ) ) ; }
LearnLib/automatalib | @ Test public void testEmptyDimension ( ) { final Iterable < List < Integer > > iter = CollectionsUtil . cartesianProduct ( ) ; Assert . assertEquals ( Iterables . size ( iter ) , 1 ) ; Assert . assertTrue ( Iterables . all ( iter , List :: isEmpty ) ) ; }
GunoH/intellij-community | public MavenImportDependency ( @ NotNull T artifact , @ NotNull DependencyScope scope ) { this . artifact = artifact ; this . scope = scope ; }
GunoH/intellij-community | public @ NotNull T getArtifact ( ) { return artifact ; }
GunoH/intellij-community | public @ NotNull DependencyScope getScope ( ) { return scope ; }
GunoH/intellij-community | @ Override public String toString ( ) { return artifact . toString ( ) ; }
dagnir/aws-sdk-java | public void marshall ( StartLambdaFunctionFailedEventAttributes startLambdaFunctionFailedEventAttributes , ProtocolMarshaller protocolMarshaller ) { if ( startLambdaFunctionFailedEventAttributes == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { protocolMarshaller . marshall ( startLambdaFunctionFailedEventAttributes . getScheduledEventId ( ) , SCHEDULEDEVENTID_BINDING ) ; protocolMarshaller . marshall ( startLambdaFunctionFailedEventAttributes . getCause ( ) , CAUSE_BINDING ) ; protocolMarshaller . marshall ( startLambdaFunctionFailedEventAttributes . getMessage ( ) , MESSAGE_BINDING ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
AlanJinTS/zstack | public NetworkServiceType ( String typeName ) { this . typeName = typeName ; types . put ( typeName , this ) ; }
AlanJinTS/zstack | @ Override public String toString ( ) { return typeName ; }
AlanJinTS/zstack | @ Override public boolean equals ( Object t ) { if ( t == null || ! ( t instanceof NetworkServiceType ) ) { return false ; } NetworkServiceType type = ( NetworkServiceType ) t ; return type . toString ( ) . equals ( typeName ) ; }
AlanJinTS/zstack | @ Override public int hashCode ( ) { return typeName . hashCode ( ) ; }
ZhernakovMikhail/fax4j | private ProcessExecutorHelper ( ) { super ( ) ; }
ZhernakovMikhail/fax4j | public ProcessOutput ( String outputText , String errorText , int exitCode ) { super ( ) ; this . OUTPUT_TEXT = outputText ; this . ERROR_TEXT = errorText ; this . EXIT_CODE = exitCode ; }
ZhernakovMikhail/fax4j | public String getOutputText ( ) { return this . OUTPUT_TEXT ; }
ZhernakovMikhail/fax4j | public String getErrorText ( ) { return this . ERROR_TEXT ; }
ZhernakovMikhail/fax4j | public int getExitCode ( ) { return this . EXIT_CODE ; }
AdamPD/drill | public DrillServiceInstance ( ) { }
AdamPD/drill | public String getId ( ) { return id ; }
AdamPD/drill | public DrillServiceInstance setId ( String id ) { this . id = id ; return this ; }
AdamPD/drill | public long getRegistrationTimeUTC ( ) { return registrationTimeUTC ; }
AdamPD/drill | public DrillServiceInstance setRegistrationTimeUTC ( long registrationTimeUTC ) { this . registrationTimeUTC = registrationTimeUTC ; return this ; }
AdamPD/drill | public DrillbitEndpoint getEndpoint ( ) { return endpoint ; }
AdamPD/drill | public DrillServiceInstance setEndpoint ( DrillbitEndpoint endpoint ) { this . endpoint = endpoint ; return this ; }
AdamPD/drill | public void readExternal ( ObjectInput in ) throws IOException { GraphIOUtil . mergeDelimitedFrom ( in , this , this ) ; }
AdamPD/drill | public void writeExternal ( ObjectOutput out ) throws IOException { GraphIOUtil . writeDelimitedTo ( out , this , this ) ; }
AdamPD/drill | public Schema < DrillServiceInstance > cachedSchema ( ) { return DEFAULT_INSTANCE ; }
AdamPD/drill | public DrillServiceInstance newMessage ( ) { return new DrillServiceInstance ( ) ; }
AdamPD/drill | public Class < DrillServiceInstance > typeClass ( ) { return DrillServiceInstance . class ; }
AdamPD/drill | public String messageName ( ) { return DrillServiceInstance . class . getSimpleName ( ) ; }
AdamPD/drill | public String messageFullName ( ) { return DrillServiceInstance . class . getName ( ) ; }
AdamPD/drill | public boolean isInitialized ( DrillServiceInstance message ) { return true ; }
AdamPD/drill | public void mergeFrom ( Input input , DrillServiceInstance message ) throws IOException { for ( int number = input . readFieldNumber ( this ) ; ; number = input . readFieldNumber ( this ) ) { switch ( number ) { case 0 : return ; case 1 : message . id = input . readString ( ) ; break ; case 2 : message . registrationTimeUTC = input . readInt64 ( ) ; break ; case 3 : message . endpoint = input . mergeObject ( message . endpoint , DrillbitEndpoint . getSchema ( ) ) ; break ; default : input . handleUnknownField ( number , this ) ; } } }
AdamPD/drill | public void writeTo ( Output output , DrillServiceInstance message ) throws IOException { if ( message . id != null ) output . writeString ( 1 , message . id , false ) ; if ( message . registrationTimeUTC != 0 ) output . writeInt64 ( 2 , message . registrationTimeUTC , false ) ; if ( message . endpoint != null ) output . writeObject ( 3 , message . endpoint , DrillbitEndpoint . getSchema ( ) , false ) ; }
AdamPD/drill | public String getFieldName ( int number ) { switch ( number ) { case 1 : return " id " ; case 2 : return " registrationTimeUTC " ; case 3 : return " endpoint " ; default : return null ; } }
AdamPD/drill | public int getFieldNumber ( String name ) { final Integer number = __fieldMap . get ( name ) ; return number == null ? 0 : number . intValue ( ) ; }
googlesamples/android-testdpc | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mDevicePolicyManager = ( DevicePolicyManager ) getActivity ( ) . getSystemService ( Context . DEVICE_POLICY_SERVICE ) ; }
googlesamples/android-testdpc | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { final ViewGroup rootView = ( ViewGroup ) inflater . inflate ( R . layout . transfer_ownership_dialog , null ) ; final ListView listView = rootView . findViewById ( R . id . list ) ; final EditText componentName = rootView . findViewById ( R . id . component_name ) ; final EditText result = rootView . findViewById ( R . id . result ) ; final Button transferButton = rootView . findViewById ( R . id . transfer_btn ) ; final Intent intent = new Intent ( DeviceAdminReceiver . ACTION_DEVICE_ADMIN_ENABLED ) ; final List < String > items = new ArrayList < > ( ) ; final PackageManager packageManager = getActivity ( ) . getPackageManager ( ) ; final List < ResolveInfo > resolveInfos = packageManager . queryBroadcastReceivers ( intent , 0 ) ; for ( ResolveInfo resolveInfo : resolveInfos ) { ActivityInfo activityInfo = resolveInfo . activityInfo ; if ( activityInfo == null ) { continue ; } items . add ( activityInfo . packageName + " / " + activityInfo . name ) ; } final ListAdapter adapter = new ArrayAdapter < > ( getActivity ( ) , android . R . layout . simple_list_item_1 , items ) ; listView . setAdapter ( adapter ) ; listView . setOnItemClickListener ( ( adapterView , view1 , i , __ ) -> componentName . setText ( adapterView . getItemAtPosition ( i ) . toString ( ) ) ) ; transferButton . setOnClickListener ( view -> { ComponentName target = ComponentName . unflattenFromString ( componentName . getText ( ) . toString ( ) ) ; if ( target != null ) { result . setText ( performTransfer ( target ) ) ; } else { result . setText ( R . string . transfer_ownership_invalid_target_format ) ; } } ) ; return rootView ; }
googlesamples/android-testdpc | private String performTransfer ( ComponentName target ) { ComponentName source = com . afwsamples . testdpc . DeviceAdminReceiver . getComponentName ( getActivity ( ) ) ; Log . i ( getClass ( ) . getName ( ) , " Transferring ▁ ownership ▁ from ▁ " + source + " ▁ to ▁ target ▁ " + target ) ; try { PersistableBundle persistableBundle = new PersistableBundle ( ) ; persistableBundle . putString ( " random _ key " , " random _ value " ) ; mDevicePolicyManager . transferOwnership ( source , target , persistableBundle ) ; return " Success ! " ; } catch ( Exception e ) { Throwable cause = e . getCause ( ) ; if ( cause instanceof InvocationTargetException ) { return getStackTrace ( ( ( InvocationTargetException ) cause ) . getTargetException ( ) ) ; } return getStackTrace ( cause ) ; } }
googlesamples/android-testdpc | private String getStackTrace ( Throwable throwable ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( stringWriter ) ; throwable . printStackTrace ( printWriter ) ; return stringWriter . toString ( ) ; }
dylanscott/proxie | DispatcherAdapter ( Supplier < ? > supplier ) { this . supplier = supplier ; }
dylanscott/proxie | @ Override public Object loadObject ( ) throws Exception { return supplier . get ( ) ; }
ladygagapowerbot/bachelor-thesis-implementation | public RippleGimpyRenderer ( double d1 , double d2 , ColorRangeContainer colorRange1 , ColorRangeContainer colorRange2 ) { super ( d1 , d2 , colorRange1 , colorRange2 ) ; }
ladygagapowerbot/bachelor-thesis-implementation | @ Override public void gimp ( BufferedImage image ) { RippleFilter filter = new RippleFilter ( ) ; filter . setWaveType ( RippleFilter . SINGLEFRAME ) ; filter . setXAmplitude ( d1 ) ; filter . setYAmplitude ( d2 ) ; filter . setXWavelength ( ( 5.77 ) * d1 ) ; filter . setYWavelength ( ( 2.94 ) * d2 ) ; filter . setEdgeAction ( TransformFilter . RANDOMPIXELORDER ) ; ImageUtil . applyFilter ( image , filter ) ; }
jrbeaumont/workcraft | @ Test public void testMirrorSignalTransformationCommand ( ) throws DeserialisationException { final Framework framework = Framework . getInstance ( ) ; final ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; for ( String testStgWork : TEST_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; Stg stg = WorkspaceUtils . getAs ( we , Stg . class ) ; Set < String > srcInputs = stg . getSignalNames ( Type . INPUT , null ) ; Set < String > srcOutputs = stg . getSignalNames ( Type . OUTPUT , null ) ; Set < String > srcInternals = stg . getSignalNames ( Type . INTERNAL , null ) ; MirrorSignalTransformationCommand command = new MirrorSignalTransformationCommand ( ) ; command . execute ( we ) ; Set < String > dstInputs = stg . getSignalNames ( Type . INPUT , null ) ; Set < String > dstOutputs = stg . getSignalNames ( Type . OUTPUT , null ) ; Set < String > dstInternals = stg . getSignalNames ( Type . INTERNAL , null ) ; Assert . assertEquals ( srcInputs , dstOutputs ) ; Assert . assertEquals ( srcOutputs , dstInputs ) ; Assert . assertEquals ( srcInternals , dstInternals ) ; framework . closeWork ( we ) ; } }
jrbeaumont/workcraft | @ Test public void testMirrorTransitionTransformationCommand ( ) throws DeserialisationException { final Framework framework = Framework . getInstance ( ) ; final ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; for ( String testStgWork : TEST_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; Stg stg = WorkspaceUtils . getAs ( we , Stg . class ) ; int srcMinusCount = 0 ; int srcPlusCount = 0 ; int srcToggleCount = 0 ; for ( SignalTransition srcTransition : stg . getSignalTransitions ( ) ) { switch ( srcTransition . getDirection ( ) ) { case MINUS : srcMinusCount ++ ; break ; case PLUS : srcPlusCount ++ ; break ; case TOGGLE : srcToggleCount ++ ; break ; } } MirrorTransitionTransformationCommand command = new MirrorTransitionTransformationCommand ( ) ; command . execute ( we ) ; int dstMinusCount = 0 ; int dstPlusCount = 0 ; int dstToggleCount = 0 ; for ( SignalTransition dstTransition : stg . getSignalTransitions ( ) ) { switch ( dstTransition . getDirection ( ) ) { case MINUS : dstMinusCount ++ ; break ; case PLUS : dstPlusCount ++ ; break ; case TOGGLE : dstToggleCount ++ ; break ; } } Assert . assertEquals ( srcMinusCount , dstPlusCount ) ; Assert . assertEquals ( srcPlusCount , dstMinusCount ) ; Assert . assertEquals ( srcToggleCount , dstToggleCount ) ; framework . closeWork ( we ) ; } }
jrbeaumont/workcraft | @ Test public void testPlaceTransformationCommands ( ) throws DeserialisationException { final Framework framework = Framework . getInstance ( ) ; final ClassLoader classLoader = ClassLoader . getSystemClassLoader ( ) ; for ( String testStgWork : TEST_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; VisualStg stg = WorkspaceUtils . getAs ( we , VisualStg . class ) ; int srcPlaces = stg . getVisualPlaces ( ) . size ( ) ; int srcImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int srcSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int srcDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; ExplicitPlaceTransformationCommand command1 = new ExplicitPlaceTransformationCommand ( ) ; command1 . execute ( we ) ; int expPlaces = stg . getVisualPlaces ( ) . size ( ) ; int expImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int expSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int expDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; Assert . assertEquals ( srcPlaces + srcImplicitPlaceArcs , expPlaces + expImplicitPlaceArcs ) ; Assert . assertEquals ( srcSignalTransitions , expSignalTransitions ) ; Assert . assertEquals ( srcDummyTransitions , expDummyTransitions ) ; ImplicitPlaceTransformationCommand command2 = new ImplicitPlaceTransformationCommand ( ) ; command2 . execute ( we ) ; int impPlaces = stg . getVisualPlaces ( ) . size ( ) ; int impImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int impSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int impDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; Assert . assertEquals ( srcPlaces + srcImplicitPlaceArcs , impPlaces + impImplicitPlaceArcs ) ; Assert . assertEquals ( srcSignalTransitions , impSignalTransitions ) ; Assert . assertEquals ( srcDummyTransitions , impDummyTransitions ) ; framework . closeWork ( we ) ; } }
jrbeaumont/workcraft | for ( String testStgWork : COMPRESSED_HANDSHAKE_STG_WORKS ) { URL url = classLoader . getResource ( testStgWork ) ; WorkspaceEntry we = framework . loadWork ( url . getFile ( ) ) ; VisualStg stg = WorkspaceUtils . getAs ( we , VisualStg . class ) ; int srcPlaces = stg . getVisualPlaces ( ) . size ( ) ; int srcImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int srcSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int srcDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; int srcConnections = stg . getVisualConnections ( ) . size ( ) ; stg . selectAll ( ) ; ExpandHandshakeReqAckTransformationCommand command = new ExpandHandshakeReqAckTransformationCommand ( ) ; command . execute ( we ) ; int dstPlaces = stg . getVisualPlaces ( ) . size ( ) ; int dstImplicitPlaceArcs = stg . getVisualImplicitPlaceArcs ( ) . size ( ) ; int dstSignalTransitions = stg . getVisualSignalTransitions ( ) . size ( ) ; int dstDummyTransitions = stg . getVisualDummyTransitions ( ) . size ( ) ; int dstConnections = stg . getVisualConnections ( ) . size ( ) ; Assert . assertEquals ( srcPlaces , dstPlaces ) ; Assert . assertEquals ( srcSignalTransitions * 2 , dstSignalTransitions ) ; Assert . assertEquals ( srcDummyTransitions , dstDummyTransitions ) ; Assert . assertEquals ( srcImplicitPlaceArcs + srcSignalTransitions , dstImplicitPlaceArcs ) ; Assert . assertEquals ( srcConnections + srcSignalTransitions , dstConnections ) ; framework . closeWork ( we ) ; }
acmi/L2unreal | @ Override protected int getOpcode ( ) { return OPCODE ; }
acmi/L2unreal | @ Override public String toString ( ) { return " Let ( " + left + " , ▁ " + right + ' ) ' ; }
acmi/L2unreal | @ Override public String toString ( UnrealRuntimeContext context ) { return left . toString ( context ) + " ▁ = ▁ " + right . toString ( context ) ; }
mogoweb/webkit_for_android5.1 | public WebResourceResponse ( String mimeType , String encoding , InputStream data ) { mMimeType = mimeType ; mEncoding = encoding ; mInputStream = data ; }
mogoweb/webkit_for_android5.1 | public WebResourceResponse ( String mimeType , String encoding , int statusCode , String reasonPhrase , Map < String , String > responseHeaders , InputStream data ) { this ( mimeType , encoding , data ) ; setStatusCodeAndReasonPhrase ( statusCode , reasonPhrase ) ; setResponseHeaders ( responseHeaders ) ; }
mogoweb/webkit_for_android5.1 | public void setMimeType ( String mimeType ) { mMimeType = mimeType ; }
mogoweb/webkit_for_android5.1 | public String getMimeType ( ) { return mMimeType ; }
mogoweb/webkit_for_android5.1 | public void setEncoding ( String encoding ) { mEncoding = encoding ; }
mogoweb/webkit_for_android5.1 | public String getEncoding ( ) { return mEncoding ; }
mogoweb/webkit_for_android5.1 | public void setStatusCodeAndReasonPhrase ( int statusCode , String reasonPhrase ) { if ( statusCode < 100 ) throw new IllegalArgumentException ( " statusCode ▁ can ' t ▁ be ▁ less ▁ than ▁ 100 . " ) ; if ( statusCode > 599 ) throw new IllegalArgumentException ( " statusCode ▁ can ' t ▁ be ▁ greater ▁ than ▁ 599 . " ) ; if ( statusCode > 299 && statusCode < 400 ) throw new IllegalArgumentException ( " statusCode ▁ can ' t ▁ be ▁ in ▁ the ▁ [ 300 , ▁ 399 ] ▁ range . " ) ; if ( reasonPhrase == null ) throw new IllegalArgumentException ( " reasonPhrase ▁ can ' t ▁ be ▁ null . " ) ; if ( reasonPhrase . trim ( ) . isEmpty ( ) ) throw new IllegalArgumentException ( " reasonPhrase ▁ can ' t ▁ be ▁ empty . " ) ; for ( int i = 0 ; i < reasonPhrase . length ( ) ; i ++ ) { int c = reasonPhrase . charAt ( i ) ; if ( c > 0x7F ) { throw new IllegalArgumentException ( " reasonPhrase ▁ can ' t ▁ contain ▁ non - ASCII ▁ characters . " ) ; } } mStatusCode = statusCode ; mReasonPhrase = reasonPhrase ; }
mogoweb/webkit_for_android5.1 | public int getStatusCode ( ) { return mStatusCode ; }
mogoweb/webkit_for_android5.1 | public String getReasonPhrase ( ) { return mReasonPhrase ; }
mogoweb/webkit_for_android5.1 | public void setResponseHeaders ( Map < String , String > headers ) { mResponseHeaders = headers ; }
mogoweb/webkit_for_android5.1 | public Map < String , String > getResponseHeaders ( ) { return mResponseHeaders ; }
mogoweb/webkit_for_android5.1 | public void setData ( InputStream data ) { mInputStream = data ; }
mogoweb/webkit_for_android5.1 | public InputStream getData ( ) { return mInputStream ; }
apache/skywalking | @ Override public void reportInstanceProperties ( final InstanceProperties request , final StreamObserver < Commands > responseObserver ) { delegate . reportInstanceProperties ( request , responseObserver ) ; }
apache/skywalking | @ Override public void keepAlive ( final InstancePingPkg request , final StreamObserver < Commands > responseObserver ) { delegate . keepAlive ( request , responseObserver ) ; }
droolsjbpm/droolsjbpm-integration | @ Before public void prepareSession ( ) { kieSession = kieContainer . newKieSession ( ) ; results = new ArrayList < > ( ) ; kieSession . setGlobal ( " results " , results ) ; }
droolsjbpm/droolsjbpm-integration | @ After public void disposeSession ( ) { if ( kieSession != null ) { kieSession . dispose ( ) ; } results = null ; }
droolsjbpm/droolsjbpm-integration | @ Test public void testLoadingKJarAndFiringRules ( ) { final String dogName = " Azor " ; final Person person = new Person ( " Bruno " , 17 ) ; person . addPet ( new Dog ( dogName , 2 ) ) ; kieSession . insert ( person ) ; kieSession . fireAllRules ( ) ; assertThat ( results ) . containsExactlyInAnyOrder ( dogName ) ; }
droolsjbpm/droolsjbpm-integration | @ Test public void testOOPathReactivityWithInstrumentedModel ( ) { final Person person = new Person ( " Bruno " , 17 ) ; FactHandle fh = kieSession . insert ( person ) ; kieSession . fireAllRules ( ) ; assertThat ( results ) . isEmpty ( ) ; person . setAge ( 18 ) ; kieSession . update ( fh , person ) ; kieSession . fireAllRules ( ) ; assertThat ( results ) . containsExactlyInAnyOrder ( " Lassie " , " The ▁ Cat " ) ; }
yafengguo/Apache-beam | BoundedReadEvaluatorFactory ( EvaluationContext evaluationContext ) { this ( evaluationContext , REQUIRED_DYNAMIC_SPLIT_ORIGINAL_SIZE ) ; }
yafengguo/Apache-beam | @ VisibleForTesting BoundedReadEvaluatorFactory ( EvaluationContext evaluationContext , long minimumDynamicSplitSize ) { this . evaluationContext = evaluationContext ; this . minimumDynamicSplitSize = minimumDynamicSplitSize ; }
yafengguo/Apache-beam | ) @ Override @ Nullable public < InputT > TransformEvaluator < InputT > forApplication ( AppliedPTransform < ? , ? , ? > application , CommittedBundle < ? > inputBundle ) throws IOException { return createEvaluator ( ( AppliedPTransform ) application ) ; }
yafengguo/Apache-beam | private < OutputT > TransformEvaluator < ? > createEvaluator ( final AppliedPTransform < ? , PCollection < OutputT > , ? > transform ) { return new BoundedReadEvaluator < > ( transform , evaluationContext , minimumDynamicSplitSize , executor ) ; }
yafengguo/Apache-beam | @ Override public void cleanup ( ) { }
yafengguo/Apache-beam | public BoundedReadEvaluator ( AppliedPTransform < ? , PCollection < OutputT > , ? > transform , EvaluationContext evaluationContext , long minimumDynamicSplitSize , ExecutorService executor ) { this . transform = transform ; this . evaluationContext = evaluationContext ; resultBuilder = StepTransformResult . withoutHold ( transform ) ; this . minimumDynamicSplitSize = minimumDynamicSplitSize ; this . produceSplitExecutor = executor ; }
yafengguo/Apache-beam | @ Override public void processElement ( WindowedValue < BoundedSourceShard < OutputT > > element ) throws Exception { BoundedSource < OutputT > source = element . getValue ( ) . getSource ( ) ; try ( final BoundedReader < OutputT > reader = source . createReader ( evaluationContext . getPipelineOptions ( ) ) ) { boolean contentsRemaining = reader . start ( ) ; Future < BoundedSource < OutputT > > residualFuture = startDynamicSplitThread ( source , reader ) ; UncommittedBundle < OutputT > output = evaluationContext . createBundle ( transform . getOutput ( ) ) ; while ( contentsRemaining ) { output . add ( WindowedValue . timestampedValueInGlobalWindow ( reader . getCurrent ( ) , reader . getCurrentTimestamp ( ) ) ) ; contentsRemaining = reader . advance ( ) ; } resultBuilder . addOutput ( output ) ; try { BoundedSource < OutputT > residual = residualFuture . get ( ) ; if ( residual != null ) { resultBuilder . addUnprocessedElements ( element . withValue ( BoundedSourceShard . of ( residual ) ) ) ; } } catch ( ExecutionException exex ) { throw UserCodeException . wrap ( exex . getCause ( ) ) ; } } }
yafengguo/Apache-beam | private Future < BoundedSource < OutputT > > startDynamicSplitThread ( BoundedSource < OutputT > source , BoundedReader < OutputT > reader ) throws Exception { if ( source . getEstimatedSizeBytes ( evaluationContext . getPipelineOptions ( ) ) > minimumDynamicSplitSize ) { return produceSplitExecutor . submit ( new GenerateSplitAtHalfwayPoint < > ( reader ) ) ; } else { SettableFuture < BoundedSource < OutputT > > emptyFuture = SettableFuture . create ( ) ; emptyFuture . set ( null ) ; return emptyFuture ; } }
yafengguo/Apache-beam | @ Override public TransformResult finishBundle ( ) { return resultBuilder . build ( ) ; }
yafengguo/Apache-beam | InputProvider ( EvaluationContext evaluationContext ) { this . evaluationContext = evaluationContext ; }
yafengguo/Apache-beam | @ Override public Collection < CommittedBundle < BoundedSourceShard < T > > > getInitialInputs ( AppliedPTransform < PBegin , PCollection < T > , Read . Bounded < T > > transform , int targetParallelism ) throws Exception { BoundedSource < T > source = transform . getTransform ( ) . getSource ( ) ; PipelineOptions options = evaluationContext . getPipelineOptions ( ) ; long estimatedBytes = source . getEstimatedSizeBytes ( options ) ; long bytesPerBundle = estimatedBytes / targetParallelism ; List < ? extends BoundedSource < T > > bundles = source . splitIntoBundles ( bytesPerBundle , options ) ; ImmutableList . Builder < CommittedBundle < BoundedSourceShard < T > > > shards = ImmutableList . builder ( ) ; for ( BoundedSource < T > bundle : bundles ) { CommittedBundle < BoundedSourceShard < T > > inputShard = evaluationContext . < BoundedSourceShard < T > > createRootBundle ( ) . add ( WindowedValue . valueInGlobalWindow ( BoundedSourceShard . of ( bundle ) ) ) . commit ( BoundedWindow . TIMESTAMP_MAX_VALUE ) ; shards . add ( inputShard ) ; } return shards . build ( ) ; }
yafengguo/Apache-beam | private GenerateSplitAtHalfwayPoint ( BoundedReader < T > reader ) { this . reader = reader ; }
yafengguo/Apache-beam | @ Override public BoundedSource < T > call ( ) throws Exception { Double currentlyConsumed = reader . getFractionConsumed ( ) ; if ( currentlyConsumed == null || currentlyConsumed == 1.0 ) { return null ; } double halfwayBetweenCurrentAndCompletion = 0.5 + ( currentlyConsumed / 2 ) ; return reader . splitAtFraction ( halfwayBetweenCurrentAndCompletion ) ; }
FedericoPecora/meta-csp-framework | public MultiConstraint ( ) { this . constraints = null ; }
FedericoPecora/meta-csp-framework | public Constraint [ ] getInternalConstraints ( ) { if ( constraints == null ) constraints = this . createInternalConstraints ( this . scope ) ; return constraints ; }
FedericoPecora/meta-csp-framework | public void setPropagateLater ( ) { propagateImmediately = false ; }
FedericoPecora/meta-csp-framework | public void setPropagateImmediately ( ) { propagateImmediately = true ; }
FedericoPecora/meta-csp-framework | public boolean propagateImmediately ( ) { return propagateImmediately ; }
FedericoPecora/meta-csp-framework | @ Override public String getDescription ( ) { String ret = this . getClass ( ) . getSimpleName ( ) + " : ▁ [ " ; if ( this . getInternalConstraints ( ) != null ) { for ( int i = 0 ; i < this . getInternalConstraints ( ) . length ; i ++ ) { ret += this . getInternalConstraints ( ) [ i ] . getClass ( ) . getSimpleName ( ) ; if ( i != this . getInternalConstraints ( ) . length - 1 ) ret += " , " ; } } return ret + " ] " ; }
pac4j/pac4j | protected LdaptiveAuthenticatorBuilder ( ) { }
elminsterjimmy/java | public SequentialPuzzleSolver ( Puzzle < P , M > puzzle ) { super ( ) ; this . puzzle = puzzle ; }
elminsterjimmy/java | public List < M > solve ( ) { P pos = puzzle . initialPosition ( ) ; return search ( new Node < P , M > ( pos , null , null ) ) ; }
elminsterjimmy/java | private List < M > search ( Node < P , M > node ) { if ( ! seen . contains ( node . pos ) ) { seen . add ( node . pos ) ; if ( puzzle . isGoal ( node . pos ) ) { return node . asMoveList ( ) ; } for ( M move : puzzle . legalMoves ( node . pos ) ) { P pos = puzzle . move ( node . pos , move ) ; Node < P , M > child = new Node < P , M > ( pos , move , node ) ; List < M > result = search ( child ) ; if ( null != result ) { return result ; } } } return null ; }
elminsterjimmy/java | public Node ( P pos , M move , Node < P , M > prev ) { super ( ) ; this . pos = pos ; this . move = move ; this . prev = prev ; }
elminsterjimmy/java | List < M > asMoveList ( ) { List < M > solution = new LinkedList < M > ( ) ; for ( Node < P , M > n = this ; n . move != null ; n = n . prev ) { solution . add ( 0 , n . move ) ; } return solution ; }
gajen0981/FHIR-Server | @ Test public void testExtensionType ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . setPetName ( new StringDt ( " Fido " ) ) ; patient . getImportantDates ( ) . add ( new DateTimeDt ( "2010-01-02" ) ) ; patient . getImportantDates ( ) . add ( new DateTimeDt ( "2014-01-26T11:11:11" ) ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newXmlParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , containsString ( " < modifierExtension ▁ url = \" http : // example . com / dontuse # importantDates \" > < valueDateTime ▁ value = \" 2010-01-02 \" / > < / modifierExtension > " ) ) ; }
gajen0981/FHIR-Server | @ Test public void testEmptyExtensionType ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newXmlParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , not ( containsString ( " xtension " ) ) ) ; }
gajen0981/FHIR-Server | @ Test public void testEmptyExtensionTypeJson ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newJsonParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , not ( containsString ( " xtension " ) ) ) ; }
Nimco/sling | private Session getSession ( ) throws RepositoryException { return repository . loginAdministrative ( null ) ; }
Nimco/sling | private void ungetSession ( final Session session ) { if ( session != null ) { try { session . logout ( ) ; } catch ( Throwable t ) { log . error ( " Unable ▁ to ▁ log ▁ out ▁ of ▁ session : ▁ " + t . getMessage ( ) , t ) ; } } }
Nimco/sling | @ Override protected void activate ( ComponentContext componentContext ) { super . activate ( componentContext ) ; Dictionary < ? , ? > props = componentContext . getProperties ( ) ; Object propValue = props . get ( PROP_SELF_REGISTRATION_ENABLED ) ; if ( propValue instanceof Boolean ) { selfRegistrationEnabled = ( Boolean ) propValue ; } else if ( propValue instanceof String ) { selfRegistrationEnabled = Boolean . parseBoolean ( ( String ) propValue ) ; } else { selfRegistrationEnabled = DEFAULT_SELF_REGISTRATION_ENABLED ; } this . userAdminGroupName = OsgiUtil . toString ( props . get ( PAR_USER_ADMIN_GROUP_NAME ) , DEFAULT_USER_ADMIN_GROUP_NAME ) ; log . info ( " User ▁ Admin ▁ Group ▁ Name ▁ { } " , this . userAdminGroupName ) ; }
Nimco/sling | @ Override protected void deactivate ( ComponentContext context ) { super . deactivate ( context ) ; }
Nimco/sling | @ Override protected void handleOperation ( SlingHttpServletRequest request , AbstractPostResponse response , List < Modification > changes ) throws RepositoryException { Session session = request . getResourceResolver ( ) . adaptTo ( Session . class ) ; String principalName = request . getParameter ( SlingPostConstants . RP_NODE_NAME ) ; User user = createUser ( session , principalName , request . getParameter ( " pwd " ) , request . getParameter ( " pwdConfirm " ) , request . getRequestParameterMap ( ) , changes ) ; String userPath = null ; if ( user == null ) { if ( changes . size ( ) > 0 ) { Modification modification = changes . get ( 0 ) ; if ( modification . getType ( ) == ModificationType . CREATE ) { userPath = modification . getSource ( ) ; } } } else { userPath = AuthorizableResourceProvider . SYSTEM_USER_MANAGER_USER_PREFIX + user . getID ( ) ; } if ( userPath != null ) { response . setPath ( userPath ) ; response . setLocation ( externalizePath ( request , userPath ) ) ; } response . setParentLocation ( externalizePath ( request , AuthorizableResourceProvider . SYSTEM_USER_MANAGER_USER_PATH ) ) ; }
Nimco/sling | public User createUser ( Session jcrSession , String name , String password , String passwordConfirm , Map < String , ? > properties , List < Modification > changes ) throws RepositoryException { if ( jcrSession == null ) { throw new RepositoryException ( " JCR ▁ Session ▁ not ▁ found " ) ; } boolean administrator = false ; try { UserManager um = AccessControlUtil . getUserManager ( jcrSession ) ; User currentUser = ( User ) um . getAuthorizable ( jcrSession . getUserID ( ) ) ; administrator = currentUser . isAdmin ( ) ; if ( ! administrator ) { Authorizable userAdmin = um . getAuthorizable ( this . userAdminGroupName ) ; if ( userAdmin instanceof Group ) { boolean isMember = ( ( Group ) userAdmin ) . isMember ( currentUser ) ; if ( isMember ) { administrator = true ; } } } } catch ( Exception ex ) { log . warn ( " Failed ▁ to ▁ determine ▁ if ▁ the ▁ user ▁ is ▁ an ▁ admin , ▁ assuming ▁ not . ▁ Cause : ▁ " + ex . getMessage ( ) ) ; administrator = false ; } if ( ! administrator && ! selfRegistrationEnabled ) { throw new RepositoryException ( " Sorry , ▁ registration ▁ of ▁ new ▁ users ▁ is ▁ not ▁ currently ▁ enabled . ▁ ▁ Please ▁ try ▁ again ▁ later . " ) ; } if ( name == null || name . length ( ) == 0 ) { throw new RepositoryException ( " User ▁ name ▁ was ▁ not ▁ submitted " ) ; } if ( password == null ) { throw new RepositoryException ( " Password ▁ was ▁ not ▁ submitted " ) ; } if ( ! password . equals ( passwordConfirm ) ) { throw new RepositoryException ( " Password ▁ value ▁ does ▁ not ▁ match ▁ the ▁ confirmation ▁ password " ) ; } User user = null ; Session selfRegSession = jcrSession ; boolean useAdminSession = ! administrator && selfRegistrationEnabled ; try { if ( useAdminSession ) { selfRegSession = getSession ( ) ; } UserManager userManager = AccessControlUtil . getUserManager ( selfRegSession ) ; Authorizable authorizable = userManager . getAuthorizable ( name ) ; if ( authorizable != null ) { throw new RepositoryException ( " A ▁ principal ▁ already ▁ exists ▁ with ▁ the ▁ requested ▁ name : ▁ " + name ) ; } else { user = userManager . createUser ( name , password ) ; String userPath = AuthorizableResourceProvider . SYSTEM_USER_MANAGER_USER_PREFIX + user . getID ( ) ; Map < String , RequestProperty > reqProperties = collectContent ( properties , userPath ) ; changes . add ( Modification . onCreated ( userPath ) ) ; writeContent ( selfRegSession , user , reqProperties , changes ) ; if ( selfRegSession . hasPendingChanges ( ) ) { selfRegSession . save ( ) ; } if ( useAdminSession ) { UserManager userManager2 = AccessControlUtil . getUserManager ( jcrSession ) ; Authorizable authorizable2 = userManager2 . getAuthorizable ( user . getID ( ) ) ; if ( authorizable2 instanceof User ) { user = ( User ) authorizable2 ; } else { user = null ; } } } } finally { if ( useAdminSession ) { ungetSession ( selfRegSession ) ; } } return user ; }
kouddy/SoftwareTestingTool | public String run ( String executableLine , OutputType t ) throws Exception { Process proc ; Runtime rt = Runtime . getRuntime ( ) ; String result ; proc = rt . exec ( executableLine . toString ( ) ) ; ThreadedOutputStream out = new ThreadedOutputStream ( proc . getInputStream ( ) ) ; out . start ( ) ; ThreadedOutputStream err = new ThreadedOutputStream ( proc . getErrorStream ( ) ) ; err . start ( ) ; int exitValue = proc . waitFor ( ) ; out . join ( ) ; err . join ( ) ; proc . destroy ( ) ; result = ( OutputType . STDOUT == t ) ? out . getString ( ) : err . getString ( ) ; err = null ; out = null ; return result ; }
ineiros/jbake | public JadeTemplateEngine ( final CompositeConfiguration config , final ContentStore db , final File destination , final File templatesPath ) { super ( config , db , destination , templatesPath ) ; TemplateLoader loader = new FileTemplateLoader ( templatesPath . getAbsolutePath ( ) + File . separatorChar , config . getString ( Keys . TEMPLATE_ENCODING ) ) ; jadeConfiguration . setTemplateLoader ( loader ) ; jadeConfiguration . setMode ( Jade4J . Mode . XHTML ) ; jadeConfiguration . setPrettyPrint ( true ) ; jadeConfiguration . setFilter ( FILTER_CDATA , new CDATAFilter ( ) ) ; jadeConfiguration . setFilter ( FILTER_SCRIPT , new JsFilter ( ) ) ; jadeConfiguration . setFilter ( FILTER_STYLE , new CssFilter ( ) ) ; jadeConfiguration . getSharedVariables ( ) . put ( " formatter " , new FormatHelper ( ) ) ; }
ineiros/jbake | @ Override public void renderDocument ( Map < String , Object > model , String templateName , Writer writer ) throws RenderingException { try { JadeTemplate template = jadeConfiguration . getTemplate ( templateName ) ; renderTemplate ( template , model , writer ) ; } catch ( IOException e ) { throw new RenderingException ( e ) ; } }
ineiros/jbake | public void renderTemplate ( JadeTemplate template , Map < String , Object > model , Writer writer ) throws JadeCompilerException { JadeModel jadeModel = wrap ( jadeConfiguration . getSharedVariables ( ) ) ; jadeModel . putAll ( model ) ; template . process ( jadeModel , writer ) ; }
ineiros/jbake | private JadeModel wrap ( final Map < String , Object > model ) { return new JadeModel ( model ) { @ Override public Object get ( final Object property ) { String key = property . toString ( ) ; try { return extractors . extractAndTransform ( db , key , model , new TemplateEngineAdapter . NoopAdapter ( ) ) ; } catch ( NoModelExtractorException e ) { } return super . get ( property ) ; } } ; }
ineiros/jbake | public String format ( Date date , String pattern ) { if ( date != null && pattern != null ) { SimpleDateFormat df = formatters . get ( pattern ) ; if ( df == null ) { df = new SimpleDateFormat ( pattern ) ; formatters . put ( pattern , df ) ; } return df . format ( date ) ; } else { return " " ; } }
ineiros/jbake | public String escape ( String s ) { return StringEscapeUtils . escapeHtml ( s ) ; }
kaaaaang/ews-java-api | protected SubscribeToPushNotificationsRequest ( ExchangeService service ) throws Exception { super ( service ) ; }
kaaaaang/ews-java-api | @ Override protected void validate ( ) throws Exception { super . validate ( ) ; EwsUtilities . validateParam ( this . getUrl ( ) , " Url " ) ; if ( ( this . getFrequency ( ) < 1 ) || ( this . getFrequency ( ) > 1440 ) ) { throw new ArgumentException ( String . format ( Strings . InvalidFrequencyValue , this . getFrequency ( ) ) ) ; } }
kaaaaang/ews-java-api | @ Override protected String getSubscriptionXmlElementName ( ) { return XmlElementNames . PushSubscriptionRequest ; }
kaaaaang/ews-java-api | @ Override protected SubscribeResponse < PushSubscription > createServiceResponse ( ExchangeService service , int responseIndex ) throws Exception { return new SubscribeResponse < PushSubscription > ( new PushSubscription ( service ) ) ; }
kaaaaang/ews-java-api | @ Override protected ExchangeVersion getMinimumRequiredServerVersion ( ) { return ExchangeVersion . Exchange2007_SP1 ; }
kaaaaang/ews-java-api | public int getFrequency ( ) { return this . frequency ; }
kaaaaang/ews-java-api | public void setFrequency ( int frequency ) { this . frequency = frequency ; }
kaaaaang/ews-java-api | public URI getUrl ( ) { return this . url ; }
kaaaaang/ews-java-api | public void setUrl ( URI url ) { this . url = url ; }
GunoH/intellij-community | @ NotNull @ Override protected String getActionName ( ) { return SvnBundle . message ( " action . Subversion . Unlock . description " ) ; }
GunoH/intellij-community | @ Override protected boolean isEnabled ( @ NotNull SvnVcs vcs , @ NotNull VirtualFile file ) { return ! file . isDirectory ( ) && SvnStatusUtil . isExplicitlyLocked ( vcs , file ) ; }
GunoH/intellij-community | @ Override protected void perform ( @ NotNull SvnVcs vcs , @ NotNull VirtualFile file , @ NotNull DataContext context ) throws VcsException { batchPerform ( vcs , ar ( file ) , context ) ; }
GunoH/intellij-community | @ Override protected void batchPerform ( @ NotNull SvnVcs vcs , VirtualFile @ NotNull [ ] files , @ NotNull DataContext context ) throws VcsException { SvnUtil . doUnlockFiles ( vcs . getProject ( ) , vcs , toIoFiles ( files ) ) ; }
GunoH/intellij-community | @ Override protected boolean isBatchAction ( ) { return true ; }
googleapis/google-api-java-client-services | public CloudSqlConnectionProfile getCloudsql ( ) { return cloudsql ; }
googleapis/google-api-java-client-services | public ConnectionProfile setCloudsql ( CloudSqlConnectionProfile cloudsql ) { this . cloudsql = cloudsql ; return this ; }
googleapis/google-api-java-client-services | public String getCreateTime ( ) { return createTime ; }
googleapis/google-api-java-client-services | public ConnectionProfile setCreateTime ( String createTime ) { this . createTime = createTime ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getDisplayName ( ) { return displayName ; }
googleapis/google-api-java-client-services | public ConnectionProfile setDisplayName ( java . lang . String displayName ) { this . displayName = displayName ; return this ; }
googleapis/google-api-java-client-services | public Status getError ( ) { return error ; }
googleapis/google-api-java-client-services | public ConnectionProfile setError ( Status error ) { this . error = error ; return this ; }
googleapis/google-api-java-client-services | public java . util . Map < String , java . lang . String > getLabels ( ) { return labels ; }
googleapis/google-api-java-client-services | public ConnectionProfile setLabels ( java . util . Map < String , java . lang . String > labels ) { this . labels = labels ; return this ; }
googleapis/google-api-java-client-services | public MySqlConnectionProfile getMysql ( ) { return mysql ; }
googleapis/google-api-java-client-services | public ConnectionProfile setMysql ( MySqlConnectionProfile mysql ) { this . mysql = mysql ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getName ( ) { return name ; }
googleapis/google-api-java-client-services | public ConnectionProfile setName ( java . lang . String name ) { this . name = name ; return this ; }
googleapis/google-api-java-client-services | public PostgreSqlConnectionProfile getPostgresql ( ) { return postgresql ; }
googleapis/google-api-java-client-services | public ConnectionProfile setPostgresql ( PostgreSqlConnectionProfile postgresql ) { this . postgresql = postgresql ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getProvider ( ) { return provider ; }
googleapis/google-api-java-client-services | public ConnectionProfile setProvider ( java . lang . String provider ) { this . provider = provider ; return this ; }
googleapis/google-api-java-client-services | public java . lang . String getState ( ) { return state ; }
googleapis/google-api-java-client-services | public ConnectionProfile setState ( java . lang . String state ) { this . state = state ; return this ; }
googleapis/google-api-java-client-services | public String getUpdateTime ( ) { return updateTime ; }
googleapis/google-api-java-client-services | public ConnectionProfile setUpdateTime ( String updateTime ) { this . updateTime = updateTime ; return this ; }
googleapis/google-api-java-client-services | @ Override public ConnectionProfile set ( String fieldName , Object value ) { return ( ConnectionProfile ) super . set ( fieldName , value ) ; }
googleapis/google-api-java-client-services | @ Override public ConnectionProfile clone ( ) { return ( ConnectionProfile ) super . clone ( ) ; }
ys305751572/shouye | @ Override public void queryBefore ( AopContext ac ) { setParma ( " userId " , ac ) ; String keyWord = this . getRecord ( ) . getStr ( " keyWord " ) ; StringBuffer whereBuffer = new StringBuffer ( ) ; whereBuffer . append ( " ▁ and ▁ ( " ) . append ( " ▁ province _ city ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ school ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ career ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ domain ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ professional ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ product _ service _ name ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ organization ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zy ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zl ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ sc ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zy2 ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ industry _ ranking ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ qualification ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ key _ word ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' " ) ; ac . setCondition ( whereBuffer . toString ( ) ) ; super . queryBefore ( ac ) ; }
3dcitydb/importer-exporter | public ExportCounter ( SchemaMapping schemaMapping ) { this . schemaMapping = schemaMapping ; objectCounter = new HashMap < > ( ) ; geometryCounter = new HashMap < > ( ) ; counterWalker = new CounterWalker ( ) ; }
3dcitydb/importer-exporter | public void updateExportCounter ( AbstractGML object ) { object . accept ( counterWalker ) ; }
3dcitydb/importer-exporter | private void updateObjectCounter ( int objectClassId ) { Long counter = objectCounter . get ( objectClassId ) ; if ( counter == null ) objectCounter . put ( objectClassId , 1L ) ; else objectCounter . put ( objectClassId , counter + 1 ) ; }
3dcitydb/importer-exporter | private void updateGeometryCounter ( GMLClass type ) { Long counter = geometryCounter . get ( type ) ; if ( counter == null ) geometryCounter . put ( type , 1L ) ; else geometryCounter . put ( type , counter + 1 ) ; }
3dcitydb/importer-exporter | public Map < Integer , Long > getAndResetObjectCounter ( ) { Map < Integer , Long > tmp = new HashMap < > ( objectCounter ) ; objectCounter . clear ( ) ; return tmp ; }
3dcitydb/importer-exporter | public Map < GMLClass , Long > getAndResetGeometryCounter ( ) { Map < GMLClass , Long > tmp = new HashMap < > ( geometryCounter ) ; geometryCounter . clear ( ) ; return tmp ; }
3dcitydb/importer-exporter | public void visit ( AbstractGML object ) { AbstractObjectType < ? > type = schemaMapping . getAbstractObjectType ( Util . getObjectClassId ( object . getClass ( ) ) ) ; if ( type != null ) updateObjectCounter ( type . getObjectClassId ( ) ) ; else if ( object instanceof ImplicitGeometry ) updateObjectCounter ( MappingConstants . IMPLICIT_GEOMETRY_OBJECTclass_ID ) ; }
3dcitydb/importer-exporter | public void visit ( AbstractSurfaceData surfaceData ) { }
3dcitydb/importer-exporter | public void visit ( Address address ) { }
3dcitydb/importer-exporter | public void visit ( AbstractGeometry geometry ) { updateGeometryCounter ( geometry . getGMLClass ( ) ) ; }
google/intellij-protocol-buffer-editor | public PbTextFileImpl ( @ NotNull FileViewProvider viewProvider , @ NotNull Language language ) { super ( viewProvider , language ) ; }
google/intellij-protocol-buffer-editor | @ NotNull @ Override public FileType getFileType ( ) { return PbTextFileType . INSTANCE ; }
google/intellij-protocol-buffer-editor | @ Override public PbTextRootMessage getRootMessage ( ) { return this ; }
google/intellij-protocol-buffer-editor | @ Override @ Nullable public SchemaInfo getSchemaInfo ( ) { return CachedValuesManager . getCachedValue ( this , ( ) -> CachedValueProvider . Result . create ( SchemaProvider . forFile ( this ) , PsiModificationTracker . MODIFICATION_COUNT ) ) ; }
google/intellij-protocol-buffer-editor | @ Override public String toString ( ) { return " Protocol ▁ Buffer ▁ Text ▁ File " ; }
liyanippon/working | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_main ) ; init ( ) ; }
liyanippon/working | private void init ( ) { gesture = ( Button ) findViewById ( R . id . gesture ) ; gesture . setOnClickListener ( this ) ; }
liyanippon/working | @ Override public void onClick ( View view ) { switch ( view . getId ( ) ) { case R . id . gesture : Log . d ( " MainActivity " , " gesture " ) ; in = new Intent ( MainActivity . this , GestureLockActivity . class ) ; startActivity ( in ) ; break ; } }
hakanmhmd/algorithms-and-data-structures | public Client ( ) { shapes = new ArrayList < Shape > ( ) ; }
hakanmhmd/algorithms-and-data-structures | public void readShapes ( String [ ] shapes ) { for ( String shape : shapes ) { this . shapes . add ( Shape . create ( shape ) ) ; } }
hakanmhmd/algorithms-and-data-structures | public void drawShapes ( ) { for ( Shape shape : shapes ) { shape . draw ( ) ; } }
Xylus/pinpoint | public ByteArrayHeaderReader ( byte [ ] bytes ) { this ( checkBytes ( bytes ) , 0 , bytes . length ) ; }
Xylus/pinpoint | public ByteArrayHeaderReader ( byte [ ] bytes , final int startOffset , final int length ) { checkBytes ( bytes ) ; this . buffer = new OffsetFixedBuffer ( bytes , startOffset , length ) ; }
Xylus/pinpoint | public Header readHeader ( ) { final byte signature = buffer . readByte ( ) ; if ( signature != Header . SIGNATURE ) { throw new InvalidHeaderException ( " invalid ▁ signature ▁ : " + signature ) ; } final byte version = buffer . readByte ( ) ; final short type = buffer . readShort ( ) ; if ( version == HeaderV1 . VERSION ) { return new HeaderV1 ( signature , version , type ) ; } if ( version == HeaderV2 . VERSION ) { return new HeaderV2 ( signature , version , type ) ; } throw new InvalidHeaderException ( String . format ( " invalid ▁ Header ▁ : ▁ signature ( 0x % 02X ) , ▁ version ( 0x % 02X ) " , signature , version ) ) ; }
Xylus/pinpoint | public HeaderEntity readHeaderEntity ( Header header ) { final byte version = header . getVersion ( ) ; if ( version == HeaderV1 . VERSION ) { return HeaderEntity . EMPTY_HEADER_ENTITY ; } if ( version == HeaderV2 . VERSION ) { return readHeaderEntity ( ) ; } throw new InvalidHeaderException ( " invalid ▁ Header ▁ : ▁ " + header ) ; }
Xylus/pinpoint | private HeaderEntity readHeaderEntity ( ) { final short headerEntitySize = buffer . readShort ( ) ; if ( headerEntitySize < 0 || headerEntitySize > HeaderV2 . HEADER_ENTITY_COUNT_MAX_SIZE ) { throw new InvalidHeaderException ( " header ▁ entity ▁ count ▁ size ▁ is ▁ invalid . ▁ size ▁ : ▁ " + headerEntitySize ) ; } if ( headerEntitySize == 0 ) { return HeaderEntity . EMPTY_HEADER_ENTITY ; } final Map < String , String > headerEntity = new HashMap < String , String > ( headerEntitySize ) ; for ( int i = 0 ; i < headerEntitySize ; i ++ ) { final String key = readString ( ) ; final String value = readString ( ) ; headerEntity . put ( key , value ) ; } return new HeaderEntity ( headerEntity ) ; }
Xylus/pinpoint | private String readString ( ) { final short stringLength = buffer . readShort ( ) ; if ( ! validCheck ( stringLength ) ) { throw new InvalidHeaderException ( " string ▁ length ▁ is ▁ invalid ▁ in ▁ header ▁ data . ▁ length ▁ : ▁ " + stringLength ) ; } buffer . setOffset ( buffer . getOffset ( ) - 2 ) ; return buffer . read2PrefixedString ( ) ; }
Xylus/pinpoint | private boolean validCheck ( short length ) { if ( length > HeaderV2 . HEADER_ENTITY_STRING_MAX_LANGTH || length == 0 ) { return false ; } return true ; }
Xylus/pinpoint | @ Override public int getOffset ( ) { return this . buffer . getOffset ( ) ; }
Xylus/pinpoint | @ Override public int getRemaining ( ) { return this . buffer . remaining ( ) ; }
0x1mason/selendroid | public ShellCommandException ( String message ) { super ( message ) ; }
0x1mason/selendroid | public ShellCommandException ( Throwable t ) { super ( t ) ; }
0x1mason/selendroid | public ShellCommandException ( String message , Throwable t ) { super ( message , t ) ; }
mzhu22/SimpleLogo | public TurtleStatsWindow ( double x , double y , double width , double height , TurtleCollection turtles ) { super ( x , y , width , height , " \t " + GUI_NAMES . getString ( " Stats " ) + " \n " ) ; myTurtleCollection = turtles ; }
mzhu22/SimpleLogo | @ Override public void updatePane ( ) { finalOutput = initialString ; myTurtleCollection . setActiveTurtles ( ) ; for ( Turtle myTurtle : myTurtleCollection ) { Map < String , String > turtleInfo = new TreeMap < String , String > ( ) ; turtleInfo . put ( GUI_NAMES . getString ( " X " ) + " : " , ( ( Long ) Math . round ( ( myTurtle . getX ( ) - CANVAS_WIDTH / 2 ) ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " Y " ) + " : " , ( ( Long ) Math . round ( - 1 * ( myTurtle . getY ( ) - CANVAS_HEIGHT / 2 ) ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " Heading " ) + " : " , ( ( Long ) Math . round ( myTurtle . getDirection ( ) ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " Showing " ) + " : " , ( ( Boolean ) myTurtle . isShowing ( ) ) . toString ( ) ) ; turtleInfo . put ( GUI_NAMES . getString ( " PenDown " ) + " : " , ( ( Boolean ) myTurtle . getPen ( ) . isPenDown ( ) ) . toString ( ) ) ; for ( String s : turtleInfo . keySet ( ) ) { finalOutput += s + " \t " + turtleInfo . get ( s ) + " \n " ; } finalOutput += " \n " ; } super . updatePane ( ) ; }
brightchen/pcap4j | while ( true ) { try { Packet packet = handle . getNextPacketEx ( ) ; Short id = packet . get ( IpV4Packet . class ) . getHeader ( ) . getIdentification ( ) ; if ( ipV4Packets . containsKey ( id ) ) { ipV4Packets . get ( id ) . add ( packet . get ( IpV4Packet . class ) ) ; } else { List < IpV4Packet > list = new ArrayList < IpV4Packet > ( ) ; list . add ( packet . get ( IpV4Packet . class ) ) ; ipV4Packets . put ( id , list ) ; originalPackets . put ( id , packet ) ; } } catch ( TimeoutException e ) { continue ; } catch ( EOFException e ) { break ; } }
brightchen/pcap4j | for ( Short id : ipV4Packets . keySet ( ) ) { List < IpV4Packet > list = ipV4Packets . get ( id ) ; final IpV4Packet defragmentedIpV4Packet = IpV4Helper . defragment ( list ) ; Packet . Builder builder = originalPackets . get ( id ) . getBuilder ( ) ; builder . getOuterOf ( IpV4Packet . Builder . class ) . payloadBuilder ( new SimpleBuilder ( defragmentedIpV4Packet ) ) ; System . out . println ( builder . build ( ) ) ; }
camelgroup/back2home_cliente | public TipoMascota ( ) { }
camelgroup/back2home_cliente | public Integer getPktipoMascota ( ) { return pktipoMascota ; }
camelgroup/back2home_cliente | public void setPktipoMascota ( Integer pktipoMascota ) { this . pktipoMascota = pktipoMascota ; }
camelgroup/back2home_cliente | public String getNombre ( ) { return nombre ; }
camelgroup/back2home_cliente | public void setNombre ( String nombre ) { this . nombre = nombre ; }
GitLqr/MaterialDesignDemo | @ Override protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_recycler_view ) ; mRv = ( RecyclerView ) findViewById ( R . id . rv ) ; initData ( ) ; initView ( ) ; setRecyclerView ( ) ; }
GitLqr/MaterialDesignDemo | private void initView ( ) { MyDecorationThree decorationThree = new MyDecorationThree ( this , mData ) ; mRv . addItemDecoration ( decorationThree ) ; }
GitLqr/MaterialDesignDemo | private void initData ( ) { mData = Arrays . asList ( Cheeses . NAMES ) ; Collections . sort ( mData , new Comparator < String > ( ) { @ Override public int compare ( String o1 , String o2 ) { return PinyinUtils . getPinyin ( o1 ) . compareTo ( PinyinUtils . getPinyin ( o2 ) ) ; } } ) ; }
GitLqr/MaterialDesignDemo | private void setRecyclerView ( ) { mMyAdapter = new MyAdapter ( mData ) ; mRv . setLayoutManager ( new LinearLayoutManager ( this ) ) ; mRv . setAdapter ( mMyAdapter ) ; }
JoelMarcey/buck | public Groovyc ( Supplier < ? extends SourcePath > path , boolean external ) { this . path = path ; this . external = external ; }
JoelMarcey/buck | public Groovyc ( SourcePath path , boolean external ) { this ( ( ) -> Objects . requireNonNull ( path ) , external ) ; }
JoelMarcey/buck | @ Override public ImmutableList < String > getCommandPrefix ( SourcePathResolverAdapter resolver ) { AbsPath toolPath = resolver . getAbsolutePath ( path . get ( ) ) ; if ( ! external ) { toolPath = toolPath . resolve ( BIN_GROOVYC ) ; } return ImmutableList . of ( toolPath . toString ( ) ) ; }
JoelMarcey/buck | @ Override public ImmutableMap < String , String > getEnvironment ( SourcePathResolverAdapter resolver ) { return ImmutableMap . of ( ) ; }
freeVM/freeVM | public boolean isCellEditable ( final EventObject e ) { return true ; }
freeVM/freeVM | public boolean shouldSelectCell ( final EventObject event ) { return true ; }
freeVM/freeVM | public boolean stopCellEditing ( ) { fireEditingStopped ( ) ; return true ; }
freeVM/freeVM | public void cancelCellEditing ( ) { fireEditingCanceled ( ) ; }
freeVM/freeVM | public void addCellEditorListener ( final CellEditorListener l ) { listenerList . add ( CellEditorListener . class , l ) ; }
freeVM/freeVM | public void removeCellEditorListener ( final CellEditorListener l ) { listenerList . remove ( CellEditorListener . class , l ) ; }
freeVM/freeVM | public CellEditorListener [ ] getCellEditorListeners ( ) { return listenerList . getListeners ( CellEditorListener . class ) ; }
freeVM/freeVM | protected void fireEditingStopped ( ) { CellEditorListener [ ] listeners = getCellEditorListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { listeners [ i ] . editingStopped ( getChangeEvent ( ) ) ; } }
freeVM/freeVM | protected void fireEditingCanceled ( ) { CellEditorListener [ ] listeners = getCellEditorListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { listeners [ i ] . editingCanceled ( getChangeEvent ( ) ) ; } }
freeVM/freeVM | private ChangeEvent getChangeEvent ( ) { if ( changeEvent == null ) { changeEvent = new ChangeEvent ( this ) ; } return changeEvent ; }
Scottmitch/netty | private Http2TestUtil ( ) { }
Scottmitch/netty | FrameAdapter ( Http2FrameListener listener , CountDownLatch latch ) { this ( null , listener , latch ) ; }
Scottmitch/netty | FrameAdapter ( Http2Connection connection , Http2FrameListener listener , CountDownLatch latch ) { this ( connection , new DefaultHttp2FrameReader ( false ) , listener , latch ) ; }
Scottmitch/netty | FrameAdapter ( Http2Connection connection , DefaultHttp2FrameReader reader , Http2FrameListener listener , CountDownLatch latch ) { this . connection = connection ; this . listener = listener ; this . reader = reader ; this . latch = latch ; }
Scottmitch/netty | private Http2Stream getOrCreateStream ( int streamId , boolean halfClosed ) throws Http2Exception { return getOrCreateStream ( connection , streamId , halfClosed ) ; }
Scottmitch/netty | private void closeStream ( Http2Stream stream ) { closeStream ( stream , false ) ; }
Scottmitch/netty | protected void closeStream ( Http2Stream stream , boolean dataRead ) { if ( stream != null ) { stream . close ( ) ; } }
Scottmitch/netty | @ Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { reader . readFrame ( ctx , in , new Http2FrameListener ( ) { @ Override public int onDataRead ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , endOfStream ) ; int processed = listener . onDataRead ( ctx , streamId , data , padding , endOfStream ) ; if ( endOfStream ) { closeStream ( stream , true ) ; } latch . countDown ( ) ; return processed ; } @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , endStream ) ; listener . onHeadersRead ( ctx , streamId , headers , padding , endStream ) ; if ( endStream ) { closeStream ( stream ) ; } latch . countDown ( ) ; } @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endStream ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , endStream ) ; if ( stream != null ) { stream . setPriority ( streamDependency , weight , exclusive ) ; } listener . onHeadersRead ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endStream ) ; if ( endStream ) { closeStream ( stream ) ; } latch . countDown ( ) ; } @ Override public void onPriorityRead ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , false ) ; if ( stream != null ) { stream . setPriority ( streamDependency , weight , exclusive ) ; } listener . onPriorityRead ( ctx , streamId , streamDependency , weight , exclusive ) ; latch . countDown ( ) ; } @ Override public void onRstStreamRead ( ChannelHandlerContext ctx , int streamId , long errorCode ) throws Http2Exception { Http2Stream stream = getOrCreateStream ( streamId , false ) ; listener . onRstStreamRead ( ctx , streamId , errorCode ) ; closeStream ( stream ) ; latch . countDown ( ) ; } @ Override public void onSettingsAckRead ( ChannelHandlerContext ctx ) throws Http2Exception { listener . onSettingsAckRead ( ctx ) ; latch . countDown ( ) ; } @ Override public void onSettingsRead ( ChannelHandlerContext ctx , Http2Settings settings ) throws Http2Exception { listener . onSettingsRead ( ctx , settings ) ; latch . countDown ( ) ; } @ Override public void onPingRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingRead ( ctx , data ) ; latch . countDown ( ) ; } @ Override public void onPingAckRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingAckRead ( ctx , data ) ; latch . countDown ( ) ; } @ Override public void onPushPromiseRead ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding ) throws Http2Exception { getOrCreateStream ( promisedStreamId , false ) ; listener . onPushPromiseRead ( ctx , streamId , promisedStreamId , headers , padding ) ; latch . countDown ( ) ; } @ Override public void onGoAwayRead ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData ) throws Http2Exception { listener . onGoAwayRead ( ctx , lastStreamId , errorCode , debugData ) ; latch . countDown ( ) ; } @ Override public void onWindowUpdateRead ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement ) throws Http2Exception { getOrCreateStream ( streamId , false ) ; listener . onWindowUpdateRead ( ctx , streamId , windowSizeIncrement ) ; latch . countDown ( ) ; } @ Override public void onUnknownFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload ) throws Http2Exception { listener . onUnknownFrame ( ctx , frameType , streamId , flags , payload ) ; latch . countDown ( ) ; } } ) ; }
Scottmitch/netty | FrameCountDown ( Http2FrameListener listener , CountDownLatch settingsAckLatch , CountDownLatch messageLatch ) { this ( listener , settingsAckLatch , messageLatch , null , null ) ; }
Scottmitch/netty | FrameCountDown ( Http2FrameListener listener , CountDownLatch settingsAckLatch , CountDownLatch messageLatch , CountDownLatch dataLatch , CountDownLatch trailersLatch ) { this ( listener , settingsAckLatch , messageLatch , dataLatch , trailersLatch , messageLatch ) ; }
Scottmitch/netty | FrameCountDown ( Http2FrameListener listener , CountDownLatch settingsAckLatch , CountDownLatch messageLatch , CountDownLatch dataLatch , CountDownLatch trailersLatch , CountDownLatch goAwayLatch ) { this . listener = listener ; this . messageLatch = messageLatch ; this . settingsAckLatch = settingsAckLatch ; this . dataLatch = dataLatch ; this . trailersLatch = trailersLatch ; this . goAwayLatch = goAwayLatch ; }
Scottmitch/netty | @ Override public int onDataRead ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { int numBytes = data . readableBytes ( ) ; int processed = listener . onDataRead ( ctx , streamId , data , padding , endOfStream ) ; messageLatch . countDown ( ) ; if ( dataLatch != null ) { for ( int i = 0 ; i < numBytes ; ++ i ) { dataLatch . countDown ( ) ; } } return processed ; }
Scottmitch/netty | @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream ) throws Http2Exception { listener . onHeadersRead ( ctx , streamId , headers , padding , endStream ) ; messageLatch . countDown ( ) ; if ( trailersLatch != null && endStream ) { trailersLatch . countDown ( ) ; } }
Scottmitch/netty | @ Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endStream ) throws Http2Exception { listener . onHeadersRead ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endStream ) ; messageLatch . countDown ( ) ; if ( trailersLatch != null && endStream ) { trailersLatch . countDown ( ) ; } }
Scottmitch/netty | @ Override public void onPriorityRead ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive ) throws Http2Exception { listener . onPriorityRead ( ctx , streamId , streamDependency , weight , exclusive ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onRstStreamRead ( ChannelHandlerContext ctx , int streamId , long errorCode ) throws Http2Exception { listener . onRstStreamRead ( ctx , streamId , errorCode ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onSettingsAckRead ( ChannelHandlerContext ctx ) throws Http2Exception { listener . onSettingsAckRead ( ctx ) ; settingsAckLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onSettingsRead ( ChannelHandlerContext ctx , Http2Settings settings ) throws Http2Exception { listener . onSettingsRead ( ctx , settings ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onPingRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingRead ( ctx , data ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onPingAckRead ( ChannelHandlerContext ctx , ByteBuf data ) throws Http2Exception { listener . onPingAckRead ( ctx , data ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onPushPromiseRead ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding ) throws Http2Exception { listener . onPushPromiseRead ( ctx , streamId , promisedStreamId , headers , padding ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onGoAwayRead ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData ) throws Http2Exception { listener . onGoAwayRead ( ctx , lastStreamId , errorCode , debugData ) ; goAwayLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onWindowUpdateRead ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement ) throws Http2Exception { listener . onWindowUpdateRead ( ctx , streamId , windowSizeIncrement ) ; messageLatch . countDown ( ) ; }
Scottmitch/netty | @ Override public void onUnknownFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload ) throws Http2Exception { listener . onUnknownFrame ( ctx , frameType , streamId , flags , payload ) ; messageLatch . countDown ( ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsTextGridFile ( ) { FormattedFile ff = new FormattedFile ( " blah . TextGrid " ) ; assertEquals ( FormattedFile . Format . TEXTGRID , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsBURNCFile ( ) { FormattedFile ff = new FormattedFile ( " blah . ala " ) ; assertEquals ( FormattedFile . Format . BURNC , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsBuckeyeFile ( ) { FormattedFile ff = new FormattedFile ( " s1234b . words " ) ; assertEquals ( FormattedFile . Format . BUCKEYE , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsSimpleWordFile ( ) { FormattedFile ff = new FormattedFile ( " file . words " ) ; assertEquals ( FormattedFile . Format . SIMPLE_WORD , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructsSwitchboardFile ( ) { FormattedFile ff = new FormattedFile ( " file . terminals . xml " ) ; assertEquals ( FormattedFile . Format . SWB_NXT , ff . getFormat ( ) ) ; }
AndrewRosenberg/AuToBI | @ Test public void testConstructorAndGetter ( ) { FormattedFile ff = new FormattedFile ( " test / file . name " , FormattedFile . Format . SWB_NXT ) ; assertEquals ( " test / file . name " , ff . getFilename ( ) ) ; assertEquals ( FormattedFile . Format . SWB_NXT , ff . getFormat ( ) ) ; }
hidekatsu-izuno/xmlic | DefaultNumberExpr ( Double number ) { this . number = number ; }
hidekatsu-izuno/xmlic | public Number getNumber ( ) { return this . number ; }
hidekatsu-izuno/xmlic | public String toString ( ) { return " [ ( DefaultNumberExpr ) : ▁ " + getNumber ( ) + " ] " ; }
hidekatsu-izuno/xmlic | public String getText ( ) { return getNumber ( ) . toString ( ) ; }
hidekatsu-izuno/xmlic | public Object evaluate ( Context context ) { return getNumber ( ) ; }
datalayer/zeppelin | public Mathjax ( Properties property ) { super ( property ) ; }
datalayer/zeppelin | @ Override public void open ( ) { }
datalayer/zeppelin | @ Override public void close ( ) { }
datalayer/zeppelin | @ Override public InterpreterResult interpret ( String text , InterpreterContext interpreterContext ) { return new InterpreterResult ( Code . SUCCESS , " % mathjax ▁ " + text ) ; }
datalayer/zeppelin | @ Override public void cancel ( InterpreterContext context ) { }
datalayer/zeppelin | @ Override public FormType getFormType ( ) { return FormType . SIMPLE ; }
datalayer/zeppelin | @ Override public int getProgress ( InterpreterContext context ) { return 0 ; }
datalayer/zeppelin | @ Override public Scheduler getScheduler ( ) { return SchedulerFactory . singleton ( ) . createOrGetParallelScheduler ( Mathjax . class . getName ( ) + this . hashCode ( ) , 5 ) ; }
datalayer/zeppelin | @ Override public List < InterpreterCompletion > completion ( String buf , int cursor , InterpreterContext interpreterContext ) { return null ; }
NatashaWso2/carbon-business-process | public void execute ( ) { HumanTaskServerConfiguration serverConfiguration = HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getServerConfig ( ) ; final SimpleQueryCriteria queryCriteria = createQueryCriteria ( serverConfiguration ) ; log . info ( " Running ▁ the ▁ task ▁ cleanup ▁ service . . . . . " ) ; try { HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getTaskEngine ( ) . getScheduler ( ) . execTransaction ( new Callable < Object > ( ) { public Object call ( ) throws Exception { HumanTaskDAOConnection daoConnection = HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getDaoConnectionFactory ( ) . getConnection ( ) ; daoConnection . removeTasks ( queryCriteria ) ; return null ; } } ) ; } catch ( Exception ex ) { String errMsg = " Task ▁ Cleanup ▁ operation ▁ failed ! ▁ : " ; log . error ( errMsg , ex ) ; throw new HumanTaskRuntimeException ( errMsg , ex ) ; } }
NatashaWso2/carbon-business-process | private SimpleQueryCriteria createQueryCriteria ( HumanTaskServerConfiguration serverConfiguration ) { SimpleQueryCriteria queryCriteria = new SimpleQueryCriteria ( ) ; queryCriteria . setSimpleQueryType ( SimpleQueryCriteria . QueryType . REMOVE_TASKS ) ; queryCriteria . setStatuses ( serverConfiguration . getRemovableTaskStatuses ( ) ) ; return queryCriteria ; }
CodeSmell/camel | public AmazonIdentityManagement getIamClient ( ) { return iamClient ; }
CodeSmell/camel | public void setIamClient ( AmazonIdentityManagement iamClient ) { this . iamClient = iamClient ; }
CodeSmell/camel | public String getAccessKey ( ) { return accessKey ; }
CodeSmell/camel | public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; }
CodeSmell/camel | public String getSecretKey ( ) { return secretKey ; }
CodeSmell/camel | public void setSecretKey ( String secretKey ) { this . secretKey = secretKey ; }
CodeSmell/camel | public IAMOperations getOperation ( ) { return operation ; }
CodeSmell/camel | public void setOperation ( IAMOperations operation ) { this . operation = operation ; }
CodeSmell/camel | public Protocol getProxyProtocol ( ) { return proxyProtocol ; }
CodeSmell/camel | public void setProxyProtocol ( Protocol proxyProtocol ) { this . proxyProtocol = proxyProtocol ; }
CodeSmell/camel | public String getProxyHost ( ) { return proxyHost ; }
CodeSmell/camel | public void setProxyHost ( String proxyHost ) { this . proxyHost = proxyHost ; }
CodeSmell/camel | public Integer getProxyPort ( ) { return proxyPort ; }
CodeSmell/camel | public void setProxyPort ( Integer proxyPort ) { this . proxyPort = proxyPort ; }
CodeSmell/camel | public String getRegion ( ) { return region ; }
CodeSmell/camel | public void setRegion ( String region ) { this . region = region ; }
CodeSmell/camel | public IAMConfiguration copy ( ) { try { return ( IAMConfiguration ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } }
ypresto/miniguava | ImmutableMapKeySet ( ImmutableMap < K , V > map ) { this . map = map ; }
ypresto/miniguava | @ Override public int size ( ) { return map . size ( ) ; }
ypresto/miniguava | @ Override public UnmodifiableIterator < K > iterator ( ) { return map . keyIterator ( ) ; }
ypresto/miniguava | @ Override public boolean contains ( @ Nullable Object object ) { return map . containsKey ( object ) ; }
ypresto/miniguava | @ Override K get ( int index ) { return map . entrySet ( ) . asList ( ) . get ( index ) . getKey ( ) ; }
ypresto/miniguava | @ Override boolean isPartialView ( ) { return true ; }
ypresto/miniguava | @ Override Object writeReplace ( ) { return new KeySetSerializedForm < K > ( map ) ; }
ypresto/miniguava | KeySetSerializedForm ( ImmutableMap < K , ? > map ) { this . map = map ; }
ypresto/miniguava | Object readResolve ( ) { return map . keySet ( ) ; }
beijunyi/ParallelGit | @ Before public void setupTargetSystem ( ) throws IOException { targetRepo = new TestRepository ( ) ; targetGfs = Gfs . newFileSystem ( targetRepo ) ; }
beijunyi/ParallelGit | @ After public void closeTargetSystem ( ) throws IOException { targetGfs . close ( ) ; targetRepo . close ( ) ; }
beijunyi/ParallelGit | @ Test public void moveFileToAnotherSystem_theTargetFileShouldExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source . txt " ) ; GitPath target = targetGfs . getPath ( " / target . txt " ) ; Files . move ( source , target ) ; assertTrue ( Files . exists ( target ) ) ; }
beijunyi/ParallelGit | @ Test public void moveFile_theSourceFileShouldNotExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source . txt " ) ; GitPath target = targetGfs . getPath ( " / target . txt " ) ; Files . move ( source , target ) ; assertFalse ( Files . exists ( source ) ) ; }
beijunyi/ParallelGit | @ Test public void moveFileToAnotherSystem_theTargetFileShouldHaveTheSameData ( ) throws IOException { initRepository ( ) ; byte [ ] expected = someBytes ( ) ; writeToCache ( " / source . txt " , expected ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source . txt " ) ; GitPath target = targetGfs . getPath ( " / target . txt " ) ; Files . move ( source , target ) ; assertArrayEquals ( expected , Files . readAllBytes ( target ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theTargetDirectoryShouldExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source / file . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertTrue ( Files . exists ( target ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theSourceDirectoryShouldNotExist ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source / file . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertFalse ( Files . exists ( source ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theTargetDirectoryShouldHaveTheSameChildren ( ) throws IOException { initRepository ( ) ; writeToCache ( " / source / file1 . txt " ) ; writeToCache ( " / source / file2 . txt " ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertTrue ( Files . exists ( target . resolve ( " file1 . txt " ) ) ) ; assertTrue ( Files . exists ( target . resolve ( " file2 . txt " ) ) ) ; }
beijunyi/ParallelGit | @ Test public void moveDirectoryToAnotherSystem_theChildrenInTheTargetDirectoryShouldHaveTheSameData ( ) throws IOException { initRepository ( ) ; byte [ ] expectedData1 = someBytes ( ) ; writeToCache ( " / source / file1 . txt " , expectedData1 ) ; byte [ ] expectedData2 = someBytes ( ) ; writeToCache ( " / source / file2 . txt " , expectedData2 ) ; commitToMaster ( ) ; initGitFileSystem ( ) ; GitPath source = gfs . getPath ( " / source " ) ; GitPath target = targetGfs . getPath ( " / target " ) ; Files . move ( source , target ) ; assertArrayEquals ( expectedData1 , Files . readAllBytes ( target . resolve ( " file1 . txt " ) ) ) ; assertArrayEquals ( expectedData2 , Files . readAllBytes ( target . resolve ( " file2 . txt " ) ) ) ; }
apache/directory-kerby | public DesCbcMd5Enc ( ) { super ( new Md5Provider ( ) ) ; }
apache/directory-kerby | public EncryptionType eType ( ) { return EncryptionType . DES_CBC_MD5 ; }
apache/directory-kerby | public CheckSumType checksumType ( ) { return CheckSumType . RSA_MD5_DES ; }
servioticy/servioticy-datamodel | public String getCurrentValue ( ) { return currentValue ; }
servioticy/servioticy-datamodel | public void setCurrentValue ( String currentValue ) { this . currentValue = currentValue ; }
servioticy/servioticy-datamodel | public String getUnit ( ) { return unit ; }
servioticy/servioticy-datamodel | public void setUnit ( String unit ) { this . unit = unit ; }
servioticy/servioticy-datamodel | public String getType ( ) { return type ; }
servioticy/servioticy-datamodel | public void setType ( String type ) { this . type = type ; }
hovsepm/azure-sdk-for-java | @ Ignore ( " Depends ▁ on ▁ the ▁ existing ▁ SQL ▁ server " ) @ Test public void canListRecommendedElasticPools ( ) throws Exception { SqlServer sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( " ans " , " ans - secondary " ) ; sqlServer . databases ( ) . list ( ) . get ( 0 ) . listServiceTierAdvisors ( ) . values ( ) . iterator ( ) . next ( ) . serviceLevelObjectiveUsageMetrics ( ) ; Map < String , RecommendedElasticPool > recommendedElasticPools = sqlServer . listRecommendedElasticPools ( ) ; Assert . assertNotNull ( recommendedElasticPools ) ; Assert . assertNotNull ( sqlServer . databases ( ) . list ( ) . get ( 0 ) . getUpgradeHint ( ) ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlServer ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; validateSqlServer ( sqlServer ) ; List < ServiceObjective > serviceObjectives = sqlServer . listServiceObjectives ( ) ; Assert . assertNotEquals ( serviceObjectives . size ( ) , 0 ) ; Assert . assertNotNull ( serviceObjectives . get ( 0 ) . refresh ( ) ) ; Assert . assertNotNull ( sqlServer . getServiceObjective ( " d1737d22 - a8ea - 4de7-9bd0-33395d2a7419" ) ) ; sqlServer . update ( ) . withAdministratorPassword ( " P @ ssword ~ 2" ) . apply ( ) ; List < SqlServer > sqlServers = sqlServerManager . sqlServers ( ) . listByResourceGroup ( RG_NAME ) ; boolean found = false ; for ( SqlServer server : sqlServers ) { if ( server . name ( ) . equals ( SQL_SERVER_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; Assert . assertNotNull ( sqlServer ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canUseCoolShortcutsForResourceCreation ( ) throws Exception { String database2Name = " database2" ; String database1InEPName = " database1InEP " ; String database2InEPName = " database2InEP " ; String elasticPool2Name = " elasticPool2" ; String elasticPool3Name = " elasticPool3" ; String elasticPool1Name = SQL_ELASTIC_POOL_NAME ; SqlServer sqlServer = sqlServerManager . sqlServers ( ) . define ( SQL_SERVER_NAME ) . withRegion ( Region . US_CENTRAL ) . withNewResourceGroup ( RG_NAME ) . withAdministratorLogin ( " userName " ) . withAdministratorPassword ( " Password ~ 1" ) . withNewDatabase ( SQL_DATABASE_NAME ) . withNewDatabase ( database2Name ) . withNewElasticPool ( elasticPool1Name , ElasticPoolEditions . STANDARD ) . withNewElasticPool ( elasticPool2Name , ElasticPoolEditions . PREMIUM , database1InEPName , database2InEPName ) . withNewElasticPool ( elasticPool3Name , ElasticPoolEditions . STANDARD ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS , SQL_FIREWALLRULE_NAME ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS ) . withNewFirewallRule ( START_IPADDRESS ) . create ( ) ; validateMultiCreation ( database2Name , database1InEPName , database2InEPName , elasticPool1Name , elasticPool2Name , elasticPool3Name , sqlServer , false ) ; elasticPool1Name = SQL_ELASTIC_POOL_NAME + " ▁ U " ; database2Name = " database2U " ; database1InEPName = " database1InEPU " ; database2InEPName = " database2InEPU " ; elasticPool2Name = " elasticPool2U " ; elasticPool3Name = " elasticPool3U " ; sqlServer = sqlServer . update ( ) . withNewDatabase ( SQL_DATABASE_NAME ) . withNewDatabase ( database2Name ) . withNewElasticPool ( elasticPool1Name , ElasticPoolEditions . STANDARD ) . withNewElasticPool ( elasticPool2Name , ElasticPoolEditions . PREMIUM , database1InEPName , database2InEPName ) . withNewElasticPool ( elasticPool3Name , ElasticPoolEditions . STANDARD ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS , SQL_FIREWALLRULE_NAME ) . withNewFirewallRule ( START_IPADDRESS , END_IPADDRESS ) . withNewFirewallRule ( START_IPADDRESS ) . apply ( ) ; validateMultiCreation ( database2Name , database1InEPName , database2InEPName , elasticPool1Name , elasticPool2Name , elasticPool3Name , sqlServer , true ) ; sqlServer . refresh ( ) ; Assert . assertEquals ( sqlServer . elasticPools ( ) . list ( ) . size ( ) , 0 ) ; List < SqlServer > sqlServers = sqlServerManager . sqlServers ( ) . listByResourceGroup ( RG_NAME ) ; boolean found = false ; for ( SqlServer server : sqlServers ) { if ( server . name ( ) . equals ( SQL_SERVER_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; Assert . assertNotNull ( sqlServer ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlDatabase ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; Observable < Indexable > resourceStream = sqlServer . databases ( ) . define ( SQL_DATABASE_NAME ) . createAsync ( ) ; SqlDatabase sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlDatabase ( sqlDatabase , SQL_DATABASE_NAME ) ; Assert . assertTrue ( sqlServer . databases ( ) . list ( ) . size ( ) > 0 ) ; TransparentDataEncryption transparentDataEncryption = sqlDatabase . getTransparentDataEncryption ( ) ; Assert . assertNotNull ( transparentDataEncryption . status ( ) ) ; List < TransparentDataEncryptionActivity > transparentDataEncryptionActivities = transparentDataEncryption . listActivities ( ) ; Assert . assertNotNull ( transparentDataEncryptionActivities ) ; transparentDataEncryption = transparentDataEncryption . updateStatus ( TransparentDataEncryptionStates . ENABLED ) ; Assert . assertNotNull ( transparentDataEncryption ) ; Assert . assertEquals ( transparentDataEncryption . status ( ) , TransparentDataEncryptionStates . ENABLED ) ; transparentDataEncryptionActivities = transparentDataEncryption . listActivities ( ) ; Assert . assertNotNull ( transparentDataEncryptionActivities ) ; TestUtilities . sleep ( 10000 , isRecordMode ( ) ) ; transparentDataEncryption = sqlDatabase . getTransparentDataEncryption ( ) . updateStatus ( TransparentDataEncryptionStates . DISABLED ) ; Assert . assertNotNull ( transparentDataEncryption ) ; Assert . assertEquals ( transparentDataEncryption . status ( ) , TransparentDataEncryptionStates . DISABLED ) ; Assert . assertEquals ( transparentDataEncryption . sqlServerName ( ) , SQL_SERVER_NAME ) ; Assert . assertEquals ( transparentDataEncryption . databaseName ( ) , SQL_DATABASE_NAME ) ; Assert . assertNotNull ( transparentDataEncryption . name ( ) ) ; Assert . assertNotNull ( transparentDataEncryption . id ( ) ) ; Assert . assertNotNull ( sqlDatabase . getUpgradeHint ( ) ) ; Map < String , ServiceTierAdvisor > serviceTierAdvisors = sqlDatabase . listServiceTierAdvisors ( ) ; Assert . assertNotNull ( serviceTierAdvisors ) ; Assert . assertNotNull ( serviceTierAdvisors . values ( ) . iterator ( ) . next ( ) . serviceLevelObjectiveUsageMetrics ( ) ) ; Assert . assertNotEquals ( serviceTierAdvisors . size ( ) , 0 ) ; Assert . assertNotNull ( serviceTierAdvisors . values ( ) . iterator ( ) . next ( ) . refresh ( ) ) ; Assert . assertNotNull ( serviceTierAdvisors . values ( ) . iterator ( ) . next ( ) . serviceLevelObjectiveUsageMetrics ( ) ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; Creatable < SqlElasticPool > sqlElasticPoolCreatable = sqlServer . elasticPools ( ) . define ( SQL_ELASTIC_POOL_NAME ) . withEdition ( ElasticPoolEditions . STANDARD ) ; String anotherDatabaseName = " anotherDatabase " ; SqlDatabase anotherDatabase = sqlServer . databases ( ) . define ( anotherDatabaseName ) . withNewElasticPool ( sqlElasticPoolCreatable ) . withSourceDatabase ( sqlDatabase . id ( ) ) . withMode ( CreateMode . COPY ) . create ( ) ; validateSqlDatabaseWithElasticPool ( anotherDatabase , anotherDatabaseName ) ; sqlServer . databases ( ) . delete ( anotherDatabase . name ( ) ) ; validateSqlDatabase ( sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) , SQL_DATABASE_NAME ) ; validateListSqlDatabase ( sqlServer . databases ( ) . list ( ) ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; validateSqlDatabaseNotFound ( SQL_DATABASE_NAME ) ; resourceStream = sqlServer . databases ( ) . define ( " newDatabase " ) . withEdition ( DatabaseEditions . STANDARD ) . withCollation ( COLLATION ) . createAsync ( ) ; sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; sqlServer . databases ( ) . delete ( sqlDatabase . name ( ) ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canManageReplicationLinks ( ) throws Exception { String anotherSqlServerName = SQL_SERVER_NAME + " another " ; SqlServer sqlServer1 = createSqlServer ( ) ; SqlServer sqlServer2 = createSqlServer ( anotherSqlServerName ) ; Observable < Indexable > resourceStream = sqlServer1 . databases ( ) . define ( SQL_DATABASE_NAME ) . withEdition ( DatabaseEditions . STANDARD ) . withCollation ( COLLATION ) . createAsync ( ) ; SqlDatabase databaseInServer1 = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlDatabase ( databaseInServer1 , SQL_DATABASE_NAME ) ; SqlDatabase databaseInServer2 = sqlServer2 . databases ( ) . define ( SQL_DATABASE_NAME ) . withSourceDatabase ( databaseInServer1 . id ( ) ) . withMode ( CreateMode . ONLINE_SECONDARY ) . create ( ) ; TestUtilities . sleep ( 2000 , isRecordMode ( ) ) ; List < ReplicationLink > replicationLinksInDb1 = new ArrayList < > ( databaseInServer1 . listReplicationLinks ( ) . values ( ) ) ; Assert . assertEquals ( replicationLinksInDb1 . size ( ) , 1 ) ; Assert . assertEquals ( replicationLinksInDb1 . get ( 0 ) . partnerDatabase ( ) , databaseInServer2 . name ( ) ) ; Assert . assertEquals ( replicationLinksInDb1 . get ( 0 ) . partnerServer ( ) , databaseInServer2 . sqlServerName ( ) ) ; List < ReplicationLink > replicationLinksInDb2 = new ArrayList < > ( databaseInServer2 . listReplicationLinks ( ) . values ( ) ) ; Assert . assertEquals ( replicationLinksInDb2 . size ( ) , 1 ) ; Assert . assertEquals ( replicationLinksInDb2 . get ( 0 ) . partnerDatabase ( ) , databaseInServer1 . name ( ) ) ; Assert . assertEquals ( replicationLinksInDb2 . get ( 0 ) . partnerServer ( ) , databaseInServer1 . sqlServerName ( ) ) ; Assert . assertNotNull ( replicationLinksInDb1 . get ( 0 ) . refresh ( ) ) ; replicationLinksInDb2 . get ( 0 ) . failover ( ) ; replicationLinksInDb2 . get ( 0 ) . refresh ( ) ; TestUtilities . sleep ( 30000 , isRecordMode ( ) ) ; replicationLinksInDb1 . get ( 0 ) . forceFailoverAllowDataLoss ( ) ; replicationLinksInDb1 . get ( 0 ) . refresh ( ) ; TestUtilities . sleep ( 30000 , isRecordMode ( ) ) ; replicationLinksInDb2 . get ( 0 ) . delete ( ) ; Assert . assertEquals ( databaseInServer2 . listReplicationLinks ( ) . size ( ) , 0 ) ; sqlServer1 . databases ( ) . delete ( databaseInServer1 . name ( ) ) ; sqlServer2 . databases ( ) . delete ( databaseInServer2 . name ( ) ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer2 . resourceGroupName ( ) , sqlServer2 . name ( ) ) ; validateSqlServerNotFound ( sqlServer2 ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer1 . resourceGroupName ( ) , sqlServer1 . name ( ) ) ; validateSqlServerNotFound ( sqlServer1 ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canDoOperationsOnDataWarehouse ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; validateSqlServer ( sqlServer ) ; Assert . assertNotNull ( sqlServer . listUsages ( ) ) ; Observable < Indexable > resourceStream = sqlServer . databases ( ) . define ( SQL_DATABASE_NAME ) . withEdition ( DatabaseEditions . DATA_WAREHOUSE ) . withCollation ( COLLATION ) . createAsync ( ) ; SqlDatabase sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; Assert . assertNotNull ( sqlDatabase ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertNotNull ( sqlDatabase ) ; Assert . assertTrue ( sqlDatabase . isDataWarehouse ( ) ) ; SqlWarehouse dataWarehouse = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) . asWarehouse ( ) ; Assert . assertNotNull ( dataWarehouse ) ; Assert . assertEquals ( dataWarehouse . name ( ) , SQL_DATABASE_NAME ) ; Assert . assertEquals ( dataWarehouse . edition ( ) , DatabaseEditions . DATA_WAREHOUSE ) ; Assert . assertNotNull ( dataWarehouse . listRestorePoints ( ) ) ; Assert . assertNotNull ( dataWarehouse . listUsages ( ) ) ; dataWarehouse . pauseDataWarehouse ( ) ; dataWarehouse . resumeDataWarehouse ( ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlDatabaseWithElasticPool ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; Creatable < SqlElasticPool > sqlElasticPoolCreatable = sqlServer . elasticPools ( ) . define ( SQL_ELASTIC_POOL_NAME ) . withEdition ( ElasticPoolEditions . STANDARD ) ; Observable < Indexable > resourceStream = sqlServer . databases ( ) . define ( SQL_DATABASE_NAME ) . withNewElasticPool ( sqlElasticPoolCreatable ) . withCollation ( COLLATION ) . createAsync ( ) ; SqlDatabase sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlDatabase ( sqlDatabase , SQL_DATABASE_NAME ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; SqlElasticPool elasticPool = sqlServer . elasticPools ( ) . get ( SQL_ELASTIC_POOL_NAME ) ; validateSqlElasticPool ( elasticPool ) ; validateSqlDatabaseWithElasticPool ( sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) , SQL_DATABASE_NAME ) ; validateListSqlDatabase ( sqlServer . databases ( ) . list ( ) ) ; sqlDatabase . update ( ) . withoutElasticPool ( ) . withEdition ( DatabaseEditions . STANDARD ) . withServiceObjective ( ServiceObjectiveName . S3 ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertNull ( sqlDatabase . elasticPoolName ( ) ) ; sqlDatabase . update ( ) . withEdition ( DatabaseEditions . PREMIUM ) . withServiceObjective ( ServiceObjectiveName . P1 ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . edition ( ) , DatabaseEditions . PREMIUM ) ; Assert . assertEquals ( sqlDatabase . serviceLevelObjective ( ) , ServiceObjectiveName . P1 ) ; sqlDatabase . update ( ) . withServiceObjective ( ServiceObjectiveName . P2 ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . serviceLevelObjective ( ) , ServiceObjectiveName . P2 ) ; Assert . assertEquals ( sqlDatabase . requestedServiceObjectiveName ( ) , ServiceObjectiveName . P2 ) ; sqlDatabase . update ( ) . withMaxSizeBytes ( 268435456000L ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . maxSizeBytes ( ) , 268435456000L ) ; sqlDatabase . update ( ) . withExistingElasticPool ( SQL_ELASTIC_POOL_NAME ) . apply ( ) ; sqlDatabase = sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( sqlDatabase . elasticPoolName ( ) , SQL_ELASTIC_POOL_NAME ) ; Assert . assertNotNull ( elasticPool . listActivities ( ) ) ; Assert . assertNotNull ( elasticPool . listDatabaseActivities ( ) ) ; List < SqlDatabase > databasesInElasticPool = elasticPool . listDatabases ( ) ; Assert . assertNotNull ( databasesInElasticPool ) ; Assert . assertEquals ( databasesInElasticPool . size ( ) , 1 ) ; SqlDatabase databaseInElasticPool = elasticPool . getDatabase ( SQL_DATABASE_NAME ) ; validateSqlDatabase ( databaseInElasticPool , SQL_DATABASE_NAME ) ; databaseInElasticPool . refresh ( ) ; try { elasticPool . getDatabase ( " does _ not _ exist " ) ; Assert . assertNotNull ( null ) ; } catch ( Exception ex ) { } sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; validateSqlDatabaseNotFound ( SQL_DATABASE_NAME ) ; SqlElasticPool sqlElasticPool = sqlServer . elasticPools ( ) . get ( SQL_ELASTIC_POOL_NAME ) ; resourceStream = sqlServer . databases ( ) . define ( " newDatabase " ) . withExistingElasticPool ( sqlElasticPool ) . withCollation ( COLLATION ) . createAsync ( ) ; sqlDatabase = Utils . < SqlDatabase > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; sqlServer . databases ( ) . delete ( sqlDatabase . name ( ) ) ; validateSqlDatabaseNotFound ( " newDatabase " ) ; sqlServer . elasticPools ( ) . delete ( SQL_ELASTIC_POOL_NAME ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlElasticPool ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; Observable < Indexable > resourceStream = sqlServer . elasticPools ( ) . define ( SQL_ELASTIC_POOL_NAME ) . withEdition ( ElasticPoolEditions . STANDARD ) . createAsync ( ) ; SqlElasticPool sqlElasticPool = Utils . < SqlElasticPool > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlElasticPool ( sqlElasticPool ) ; Assert . assertEquals ( sqlElasticPool . listDatabases ( ) . size ( ) , 0 ) ; sqlElasticPool = sqlElasticPool . update ( ) . withDtu ( 100 ) . withDatabaseDtuMax ( 20 ) . withDatabaseDtuMin ( 10 ) . withStorageCapacity ( 102400 ) . withNewDatabase ( SQL_DATABASE_NAME ) . apply ( ) ; validateSqlElasticPool ( sqlElasticPool ) ; Assert . assertEquals ( sqlElasticPool . listDatabases ( ) . size ( ) , 1 ) ; validateSqlElasticPool ( sqlServer . elasticPools ( ) . get ( SQL_ELASTIC_POOL_NAME ) ) ; validateListSqlElasticPool ( sqlServer . elasticPools ( ) . list ( ) ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; sqlServer . elasticPools ( ) . delete ( SQL_ELASTIC_POOL_NAME ) ; validateSqlElasticPoolNotFound ( sqlServer , SQL_ELASTIC_POOL_NAME ) ; resourceStream = sqlServer . elasticPools ( ) . define ( " newElasticPool " ) . withEdition ( ElasticPoolEditions . STANDARD ) . createAsync ( ) ; sqlElasticPool = Utils . < SqlElasticPool > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; sqlServer . elasticPools ( ) . delete ( sqlElasticPool . name ( ) ) ; validateSqlElasticPoolNotFound ( sqlServer , " newElasticPool " ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
hovsepm/azure-sdk-for-java | @ Test public void canCRUDSqlFirewallRule ( ) throws Exception { SqlServer sqlServer = createSqlServer ( ) ; sqlServer = sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ; validateSqlServer ( sqlServer ) ; Observable < Indexable > resourceStream = sqlServer . firewallRules ( ) . define ( SQL_FIREWALLRULE_NAME ) . withIPAddressRange ( START_IPADDRESS , END_IPADDRESS ) . createAsync ( ) ; SqlFirewallRule sqlFirewallRule = Utils . < SqlFirewallRule > rootResource ( resourceStream ) . toBlocking ( ) . first ( ) ; validateSqlFirewallRule ( sqlFirewallRule , SQL_FIREWALLRULE_NAME ) ; validateSqlFirewallRule ( sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) , SQL_FIREWALLRULE_NAME ) ; String secondFirewallRuleName = " secondFireWallRule " ; SqlFirewallRule secondFirewallRule = sqlServer . firewallRules ( ) . define ( secondFirewallRuleName ) . withIPAddress ( START_IPADDRESS ) . create ( ) ; Assert . assertNotNull ( secondFirewallRule ) ; secondFirewallRule = sqlServer . firewallRules ( ) . get ( secondFirewallRuleName ) ; Assert . assertNotNull ( secondFirewallRule ) ; Assert . assertEquals ( START_IPADDRESS , secondFirewallRule . endIPAddress ( ) ) ; secondFirewallRule = secondFirewallRule . update ( ) . withEndIPAddress ( END_IPADDRESS ) . apply ( ) ; validateSqlFirewallRule ( secondFirewallRule , secondFirewallRuleName ) ; sqlServer . firewallRules ( ) . delete ( secondFirewallRuleName ) ; Assert . assertNull ( sqlServer . firewallRules ( ) . get ( secondFirewallRuleName ) ) ; sqlFirewallRule = sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) ; validateSqlFirewallRule ( sqlFirewallRule , SQL_FIREWALLRULE_NAME ) ; sqlFirewallRule . update ( ) . withEndIPAddress ( START_IPADDRESS ) . apply ( ) ; sqlFirewallRule = sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) ; Assert . assertEquals ( sqlFirewallRule . endIPAddress ( ) , START_IPADDRESS ) ; validateListSqlFirewallRule ( sqlServer . firewallRules ( ) . list ( ) ) ; sqlServer . firewallRules ( ) . delete ( sqlFirewallRule . name ( ) ) ; validateSqlFirewallRuleNotFound ( ) ; sqlServerManager . sqlServers ( ) . deleteByResourceGroup ( sqlServer . resourceGroupName ( ) , sqlServer . name ( ) ) ; validateSqlServerNotFound ( sqlServer ) ; }
OyabunAB/criters | public FooPropertyFilter ( final Integer value ) { this . value = value ; }
OyabunAB/criters | @ Parameter ( restriction = Restriction . EQUALS , name = " value " ) public Integer getValue ( ) { return value ; }
OyabunAB/criters | public void setValue ( Integer value ) { this . value = value ; }
hazendaz/assertj-core | protected AbstractBooleanArrayAssert ( boolean [ ] actual , Class < ? > selfType ) { super ( actual , selfType ) ; }
hazendaz/assertj-core | @ Override public void isNullOrEmpty ( ) { arrays . assertNullOrEmpty ( info , actual ) ; }
hazendaz/assertj-core | @ Override public void isEmpty ( ) { arrays . assertEmpty ( info , actual ) ; }
hazendaz/assertj-core | @ Override public SELF isNotEmpty ( ) { arrays . assertNotEmpty ( info , actual ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSize ( int expected ) { arrays . assertHasSize ( info , actual , expected ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeGreaterThan ( int boundary ) { arrays . assertHasSizeGreaterThan ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeGreaterThanOrEqualTo ( int boundary ) { arrays . assertHasSizeGreaterThanOrEqualTo ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeLessThan ( int boundary ) { arrays . assertHasSizeLessThan ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeLessThanOrEqualTo ( int boundary ) { arrays . assertHasSizeLessThanOrEqualTo ( info , actual , boundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSizeBetween ( int lowerBoundary , int higherBoundary ) { arrays . assertHasSizeBetween ( info , actual , lowerBoundary , higherBoundary ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF hasSameSizeAs ( Iterable < ? > other ) { arrays . assertHasSameSizeAs ( info , actual , other ) ; return myself ; }
hazendaz/assertj-core | public SELF contains ( boolean ... values ) { arrays . assertContains ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF contains ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContains ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnly ( boolean ... values ) { arrays . assertContainsOnly ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnly ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsOnly ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnlyOnce ( boolean ... values ) { arrays . assertContainsOnlyOnce ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsOnlyOnce ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsOnlyOnce ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSequence ( boolean ... sequence ) { arrays . assertContainsSequence ( info , actual , sequence ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSequence ( Boolean [ ] sequence ) { requireNonNullParameter ( sequence , " sequence " ) ; arrays . assertContainsSequence ( info , actual , toPrimitiveBooleanArray ( sequence ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSubsequence ( boolean ... subsequence ) { arrays . assertContainsSubsequence ( info , actual , subsequence ) ; return myself ; }
hazendaz/assertj-core | public SELF containsSubsequence ( Boolean [ ] subsequence ) { requireNonNullParameter ( subsequence , " subsequence " ) ; arrays . assertContainsSubsequence ( info , actual , toPrimitiveBooleanArray ( subsequence ) ) ; return myself ; }
hazendaz/assertj-core | public SELF contains ( boolean value , Index index ) { arrays . assertContains ( info , actual , value , index ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotContain ( boolean ... values ) { arrays . assertDoesNotContain ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotContain ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertDoesNotContain ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotContain ( boolean value , Index index ) { arrays . assertDoesNotContain ( info , actual , value , index ) ; return myself ; }
hazendaz/assertj-core | public SELF doesNotHaveDuplicates ( ) { arrays . assertDoesNotHaveDuplicates ( info , actual ) ; return myself ; }
hazendaz/assertj-core | public SELF startsWith ( boolean ... sequence ) { arrays . assertStartsWith ( info , actual , sequence ) ; return myself ; }
hazendaz/assertj-core | public SELF startsWith ( Boolean [ ] sequence ) { requireNonNullParameter ( sequence , " sequence " ) ; arrays . assertStartsWith ( info , actual , toPrimitiveBooleanArray ( sequence ) ) ; return myself ; }
hazendaz/assertj-core | public SELF endsWith ( boolean ... sequence ) { arrays . assertEndsWith ( info , actual , sequence ) ; return myself ; }
hazendaz/assertj-core | public SELF endsWith ( Boolean [ ] sequence ) { requireNonNullParameter ( sequence , " sequence " ) ; arrays . assertEndsWith ( info , actual , toPrimitiveBooleanArray ( sequence ) ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF isSorted ( ) { arrays . assertIsSorted ( info , actual ) ; return myself ; }
hazendaz/assertj-core | @ Override public SELF isSortedAccordingTo ( Comparator < ? super Boolean > comparator ) { arrays . assertIsSortedAccordingToComparator ( info , actual , comparator ) ; return myself ; }
hazendaz/assertj-core | @ Override @ Deprecated public final SELF usingElementComparator ( Comparator < ? super Boolean > customComparator ) { throw new UnsupportedOperationException ( " custom ▁ element ▁ Comparator ▁ is ▁ not ▁ supported ▁ for ▁ Boolean ▁ array ▁ comparison " ) ; }
hazendaz/assertj-core | @ Override @ Deprecated public final SELF usingDefaultElementComparator ( ) { throw new UnsupportedOperationException ( " custom ▁ element ▁ Comparator ▁ is ▁ not ▁ supported ▁ for ▁ Boolean ▁ array ▁ comparison " ) ; }
hazendaz/assertj-core | public SELF containsExactly ( boolean ... values ) { arrays . assertContainsExactly ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsExactly ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsExactly ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsExactlyInAnyOrder ( boolean ... values ) { arrays . assertContainsExactlyInAnyOrder ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsExactlyInAnyOrder ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsExactlyInAnyOrder ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
hazendaz/assertj-core | public SELF containsAnyOf ( boolean ... values ) { arrays . assertContainsAnyOf ( info , actual , values ) ; return myself ; }
hazendaz/assertj-core | public SELF containsAnyOf ( Boolean [ ] values ) { requireNonNullParameter ( values , " values " ) ; arrays . assertContainsAnyOf ( info , actual , toPrimitiveBooleanArray ( values ) ) ; return myself ; }
caldofran/PFM-LoadSensing | public BalloonOverlayView ( Context context , int balloonBottomOffset ) { super ( context ) ; setPadding ( 10 , 0 , 10 , balloonBottomOffset ) ; layout = new LinearLayout ( context ) ; layout . setVisibility ( VISIBLE ) ; LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; View v = inflater . inflate ( R . layout . balloon_overlay , layout ) ; title = ( TextView ) v . findViewById ( R . id . balloon_item_title ) ; snippet = ( TextView ) v . findViewById ( R . id . balloon_item_snippet ) ; ImageView close = ( ImageView ) v . findViewById ( R . id . close_img_button ) ; close . setOnClickListener ( new OnClickListener ( ) { public void onClick ( View v ) { layout . setVisibility ( GONE ) ; } } ) ; FrameLayout . LayoutParams params = new FrameLayout . LayoutParams ( LayoutParams . WRAP_CONTENT , LayoutParams . WRAP_CONTENT ) ; params . gravity = Gravity . NO_GRAVITY ; addView ( layout , params ) ; }
caldofran/PFM-LoadSensing | public void setData ( Item item ) { layout . setVisibility ( VISIBLE ) ; if ( item . getTitle ( ) != null ) { title . setVisibility ( VISIBLE ) ; title . setText ( item . getTitle ( ) ) ; } else { title . setVisibility ( GONE ) ; } if ( item . getSnippet ( ) != null ) { snippet . setVisibility ( VISIBLE ) ; snippet . setText ( item . getSnippet ( ) ) ; } else { snippet . setVisibility ( GONE ) ; } }
danathughes/javaEvolutionaryAlgorithm | public Fitness ( double value ) { fitness = value ; }
danathughes/javaEvolutionaryAlgorithm | public double value ( ) { return fitness ; }
danathughes/javaEvolutionaryAlgorithm | public int compareTo ( Fitness other ) { int results = 0 ; if ( this . value ( ) > other . value ( ) ) { results = 1 ; } if ( other . value ( ) > this . value ( ) ) { results = - 1 ; } return results ; }
TatsianaKasiankova/pentaho-kettle | @ Test public void testNegatedTrueFuncEvaluatesAsFalse ( ) throws Exception { String left = " test _ filed " ; String right = " test _ value " ; int func = Condition . func_TRUE ; boolean negate = true ; Condition condition = new Condition ( negate , left , func , right , null ) ; assertFalse ( condition . evaluate ( new RowMeta ( ) , new Object [ ] { " test " } ) ) ; }
TatsianaKasiankova/pentaho-kettle | @ Test public void testPdi13227 ( ) throws Exception { RowMetaInterface rowMeta1 = new RowMeta ( ) ; rowMeta1 . addValueMeta ( new ValueMetaNumber ( " name1" ) ) ; rowMeta1 . addValueMeta ( new ValueMetaNumber ( " name2" ) ) ; rowMeta1 . addValueMeta ( new ValueMetaNumber ( " name3" ) ) ; RowMetaInterface rowMeta2 = new RowMeta ( ) ; rowMeta2 . addValueMeta ( new ValueMetaNumber ( " name2" ) ) ; rowMeta2 . addValueMeta ( new ValueMetaNumber ( " name1" ) ) ; rowMeta2 . addValueMeta ( new ValueMetaNumber ( " name3" ) ) ; String left = " name1" ; String right = " name3" ; Condition condition = new Condition ( left , Condition . func_EQUAL , right , null ) ; assertTrue ( condition . evaluate ( rowMeta1 , new Object [ ] { 1.0 , 2.0 , 1.0 } ) ) ; assertTrue ( condition . evaluate ( rowMeta2 , new Object [ ] { 2.0 , 1.0 , 1.0 } ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromMessageCopiesBody ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; byte [ ] testBody = httpsMsg . getBody ( ) ; byte [ ] expectedBody = body ; assertThat ( testBody , is ( expectedBody ) ) ; expectedBody [ 0 ] = 0x34 ; assertThat ( testBody , is ( not ( expectedBody ) ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromMessageSavesBase64Encoded ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; boolean testBase64Encoded = httpsMsg . isBase64Encoded ( ) ; boolean expectedBase64Encoded = base64Encoded ; assertThat ( testBase64Encoded , is ( expectedBase64Encoded ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromMessageSavesPropertiesWithPrefix ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; final String expectedPrefix = " iothub - app - " ; final String expectedPropertyName = expectedPrefix + propertyName ; final String expectedPropertyValue = propertyValue ; new Verifications ( ) { { new IotHubMessageProperty ( expectedPropertyName , expectedPropertyValue ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseCopiesBody ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; byte [ ] testBody = httpsMsg . getBody ( ) ; byte [ ] expectedBody = body ; assertThat ( testBody , is ( expectedBody ) ) ; expectedBody [ 0 ] = 0x34 ; assertThat ( testBody , is ( not ( expectedBody ) ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseDoesNotBase64EncodeBody ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; boolean testBase64Encoded = httpsMsg . isBase64Encoded ( ) ; boolean expectedBase64Encoded = false ; assertThat ( testBase64Encoded , is ( expectedBase64Encoded ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseDoesNotIncludeNonAppProperties ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; IotHubMessageProperty [ ] testProperties = httpsMsg . getProperties ( ) ; IotHubMessageProperty [ ] expectedProperties = { } ; assertThat ( testProperties , is ( expectedProperties ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void parseHttpsMessageFromResponseIncludesAppProperties ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; IotHubMessageProperty . isValidAppProperty ( propertyName , propertyValue ) ; result = true ; } } ; HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; new Verifications ( ) { { new IotHubMessageProperty ( propertyName , propertyValue ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void toMessageCopiesBody ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty , @ Mocked final IotHubMessage mockMsg ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; IotHubMessageProperty . isValidAppProperty ( propertyName , propertyValue ) ; result = true ; new IotHubMessageProperty ( propertyName , propertyValue ) ; result = mockProperty ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; new IotHubMessage ( body ) ; result = mockMsg ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; httpsMsg . toMessage ( ) ; final byte [ ] expectedBody = body ; new Verifications ( ) { { new IotHubMessage ( expectedBody ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void toMessageRemovesPrefixFromProperties ( @ Mocked final HttpsResponse mockResponse , @ Mocked final IotHubMessageProperty mockProperty , @ Mocked final IotHubMessage mockMsg ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final Map < String , String > headerFields = new HashMap < > ( ) ; final String propertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; headerFields . put ( propertyName , propertyValue ) ; new NonStrictExpectations ( ) { { mockResponse . getBody ( ) ; result = body ; mockResponse . getHeaderFields ( ) ; result = headerFields ; IotHubMessageProperty . isValidAppProperty ( propertyName , propertyValue ) ; result = true ; new IotHubMessageProperty ( propertyName , propertyValue ) ; result = mockProperty ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; new IotHubMessage ( body ) ; result = mockMsg ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockResponse ) ; httpsMsg . toMessage ( ) ; final String expectedPropertyName = " test - property - name " ; final String expectedPropertyValue = propertyValue ; new Verifications ( ) { { mockMsg . setProperty ( expectedPropertyName , expectedPropertyValue ) ; } } ; }
fsautomata/azure-iot-sdks | @ Test public void getBodyReturnsCopyOfBody ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; byte [ ] testBody = httpsMsg . getBody ( ) ; byte [ ] expectedBody = body ; assertThat ( testBody , is ( expectedBody ) ) ; testBody [ 0 ] = 0x34 ; testBody = httpsMsg . getBody ( ) ; assertThat ( testBody , is ( expectedBody ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void getBodyAsStringsReturnsUtf8Body ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; String testBody = httpsMsg . getBodyAsString ( ) ; String expectedBody = " abc " ; assertThat ( testBody , is ( expectedBody ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void getContentTypeReturnsCorrectContentType ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; String testContentType = httpsMsg . getContentType ( ) ; String expectedContentType = " binary / octet - stream " ; assertThat ( testContentType , is ( expectedContentType ) ) ; }
fsautomata/azure-iot-sdks | @ Test public void getPropertiesReturnsCopyOfProperties ( @ Mocked final IotHubServiceboundMessage mockMsg , @ Mocked final IotHubMessageProperty mockProperty ) { final byte [ ] body = { 0x61 , 0x62 , 0x63 } ; final boolean base64Encoded = false ; final IotHubMessageProperty [ ] properties = { mockProperty } ; final String propertyName = " test - property - name " ; final String httpsPropertyName = " iothub - app - test - property - name " ; final String propertyValue = " test - property - value " ; new NonStrictExpectations ( ) { { mockMsg . getBody ( ) ; result = body ; mockMsg . isBase64Encoded ( ) ; result = base64Encoded ; mockMsg . getProperties ( ) ; result = properties ; mockProperty . getName ( ) ; result = propertyName ; result = httpsPropertyName ; mockProperty . getValue ( ) ; result = propertyValue ; } } ; HttpsSingleMessage httpsMsg = HttpsSingleMessage . parseHttpsMessage ( mockMsg ) ; IotHubMessageProperty [ ] testProperties = httpsMsg . getProperties ( ) ; final IotHubMessageProperty [ ] expectedProperties = properties ; assertThat ( testProperties . length , is ( expectedProperties . length ) ) ; final String expectedPropertyName = httpsPropertyName ; final String expectedPropertyValue = propertyValue ; new Verifications ( ) { { new IotHubMessageProperty ( expectedPropertyName , expectedPropertyValue ) ; times = 2 ; } } ; }
cs383-final/skynet | @ Before public void setUp ( ) throws Exception { baseTime = new DateTime ( 2011 , 2 , 1 , 0 , 0 , 0 , 0 , DateTimeZone . UTC ) . toInstant ( ) ; broker = new PowerTacBroker ( ) ; ApplicationContext ctx = mock ( ApplicationContext . class ) ; SpringApplicationContext sac = new SpringApplicationContext ( ) ; sac . setApplicationContext ( ctx ) ; MessageDispatcher messageDispatcher = new MessageDispatcher ( ) ; ReflectionTestUtils . setField ( broker , " router " , messageDispatcher ) ; customerRepo = new CustomerRepo ( ) ; ReflectionTestUtils . setField ( broker , " customerRepo " , customerRepo ) ; brokerRepo = new BrokerRepo ( ) ; ReflectionTestUtils . setField ( broker , " brokerRepo " , brokerRepo ) ; ReflectionTestUtils . setField ( broker , " username " , " Sample " ) ; broker . init ( ) ; }
cs383-final/skynet | @ Test public void testSampleBroker ( ) { assertFalse ( broker . getBroker ( ) . isEnabled ( ) ) ; }
cs383-final/skynet | @ Test public void testIsEnabled ( ) { assertFalse ( broker . getBroker ( ) . isEnabled ( ) ) ; broker . getBroker ( ) . receiveMessage ( new BrokerAccept ( 3 ) ) ; assertTrue ( broker . getBroker ( ) . isEnabled ( ) ) ; assertEquals ( " correct ▁ prefix " , 3 , IdGenerator . getPrefix ( ) ) ; }
cs383-final/skynet | @ Test public void testReceiveCompetition ( ) { assertEquals ( " initially , ▁ no ▁ competing ▁ brokers " , 1 , broker . getBrokerList ( ) . size ( ) ) ; Competition comp = Competition . newInstance ( " Test " ) . withSimulationBaseTime ( baseTime ) . addBroker ( " Sam " ) . addBroker ( " Sally " ) . addCustomer ( new CustomerInfo ( " Podunk " , 3 ) ) . addCustomer ( new CustomerInfo ( " Midvale " , 1000 ) ) . addCustomer ( new CustomerInfo ( " Metro " , 100000 ) ) ; broker . getBroker ( ) . receiveMessage ( comp ) ; assertEquals ( " still ▁ no ▁ competing ▁ brokers " , 1 , broker . getBrokerList ( ) . size ( ) ) ; broker . getBroker ( ) . receiveMessage ( new BrokerAccept ( 3 ) ) ; broker . getBroker ( ) . receiveMessage ( comp ) ; assertEquals ( "2 ▁ competing ▁ brokers " , 3 , broker . getBrokerList ( ) . size ( ) ) ; assertEquals ( "3 ▁ customers " , 3 , customerRepo . size ( ) ) ; }
8106yogi/music-synthesizer-for-android | public void testBasic ( ) { SynthesizerInput frequency = new SynthesizerInput ( 0.0 , 0.0 , 1.0 ) ; SynthesisTime time = new SynthesisTime ( ) ; time . setSampleRate ( 8 ) ; Sawtooth sawtooth = new Sawtooth ( frequency ) ; assertEquals ( - 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 2.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 3.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 4.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 3.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 2.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 0.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; }
8106yogi/music-synthesizer-for-android | public void testFrequencyChange ( ) { SynthesizerInput frequency = new SynthesizerInput ( 0.0 , 0.0 , 1.0 ) ; SynthesisTime time = new SynthesisTime ( ) ; time . setSampleRate ( 8 ) ; Sawtooth sawtooth = new Sawtooth ( frequency ) ; assertEquals ( - 1.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 2.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; frequency . setValue ( - 1.0 ) ; assertEquals ( - 3.0 / 4.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 8.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 7.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 6.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 5.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 4.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 3.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 2.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 1.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( 0.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; time . advance ( ) ; assertEquals ( - 1.0 / 8.0 , sawtooth . getValue ( time ) , TOLERANCE ) ; }
alecharp/plugin-dependency-analyzer | @ GetMapping public String ping ( ) { return " pong " ; }
AngusZhu/spring-boot | @ Before public void setup ( ) throws Exception { this . sampleJarFile = createSampleJarFile ( ) ; URL url = this . sampleJarFile . toURI ( ) . toURL ( ) ; ClassLoader classLoader = getClass ( ) . getClassLoader ( ) ; URL [ ] urls = new URL [ ] { url } ; this . parentClassLoader = new URLClassLoader ( urls , classLoader ) ; this . updatedFiles = new ClassLoaderFiles ( ) ; this . reloadClassLoader = new RestartClassLoader ( this . parentClassLoader , urls , this . updatedFiles ) ; }
AngusZhu/spring-boot | private File createSampleJarFile ( ) throws IOException { File file = this . temp . newFile ( " sample . jar " ) ; JarOutputStream jarOutputStream = new JarOutputStream ( new FileOutputStream ( file ) ) ; jarOutputStream . putNextEntry ( new ZipEntry ( PACKAGE_PATH + " / Sample . class " ) ) ; StreamUtils . copy ( getClass ( ) . getResourceAsStream ( " Sample . class " ) , jarOutputStream ) ; jarOutputStream . closeEntry ( ) ; jarOutputStream . putNextEntry ( new ZipEntry ( PACKAGE_PATH + " / Sample . txt " ) ) ; StreamUtils . copy ( " fromchild " , UTF_8 , jarOutputStream ) ; jarOutputStream . closeEntry ( ) ; jarOutputStream . close ( ) ; return file ; }
AngusZhu/spring-boot | @ Test public void parentMustNotBeNull ( ) throws Exception { this . thrown . expect ( IllegalArgumentException . class ) ; this . thrown . expectMessage ( " Parent ▁ must ▁ not ▁ be ▁ null " ) ; new RestartClassLoader ( null , new URL [ ] { } ) ; }
AngusZhu/spring-boot | @ Test public void updatedFilesMustNotBeNull ( ) throws Exception { this . thrown . expect ( IllegalArgumentException . class ) ; this . thrown . expectMessage ( " UpdatedFiles ▁ must ▁ not ▁ be ▁ null " ) ; new RestartClassLoader ( this . parentClassLoader , new URL [ ] { } , null ) ; }
AngusZhu/spring-boot | @ Test public void getResourceFromReloadableUrl ( ) throws Exception { String content = readString ( this . reloadClassLoader . getResourceAsStream ( PACKAGE_PATH + " / Sample . txt " ) ) ; assertThat ( content , startsWith ( " fromchild " ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourceFromParent ( ) throws Exception { String content = readString ( this . reloadClassLoader . getResourceAsStream ( PACKAGE_PATH + " / Parent . txt " ) ) ; assertThat ( content , startsWith ( " fromparent " ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourcesFiltersDuplicates ( ) throws Exception { List < URL > resources = toList ( this . reloadClassLoader . getResources ( PACKAGE_PATH + " / Sample . txt " ) ) ; assertThat ( resources . size ( ) , equalTo ( 1 ) ) ; }
AngusZhu/spring-boot | @ Test public void loadClassFromReloadableUrl ( ) throws Exception { Class < ? > loaded = this . reloadClassLoader . loadClass ( PACKAGE + " . Sample " ) ; assertThat ( loaded . getClassLoader ( ) , equalTo ( ( ClassLoader ) this . reloadClassLoader ) ) ; }
AngusZhu/spring-boot | @ Test public void loadClassFromParent ( ) throws Exception { Class < ? > loaded = this . reloadClassLoader . loadClass ( PACKAGE + " . SampleParent " ) ; assertThat ( loaded . getClassLoader ( ) , equalTo ( getClass ( ) . getClassLoader ( ) ) ) ; }
AngusZhu/spring-boot | @ Test public void getDeletedResource ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; assertThat ( this . reloadClassLoader . getResource ( name ) , equalTo ( null ) ) ; }
AngusZhu/spring-boot | @ Test public void getDeletedResourceAsStream ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; assertThat ( this . reloadClassLoader . getResourceAsStream ( name ) , equalTo ( null ) ) ; }
AngusZhu/spring-boot | @ Test public void getUpdatedResource ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; byte [ ] bytes = " abc " . getBytes ( ) ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . MODIFIED , bytes ) ) ; URL resource = this . reloadClassLoader . getResource ( name ) ; assertThat ( FileCopyUtils . copyToByteArray ( resource . openStream ( ) ) , equalTo ( bytes ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourcesWithDeleted ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; List < URL > resources = toList ( this . reloadClassLoader . getResources ( name ) ) ; assertThat ( resources . size ( ) , equalTo ( 0 ) ) ; }
AngusZhu/spring-boot | @ Test public void getResourcesWithUpdated ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . txt " ; byte [ ] bytes = " abc " . getBytes ( ) ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . MODIFIED , bytes ) ) ; List < URL > resources = toList ( this . reloadClassLoader . getResources ( name ) ) ; assertThat ( FileCopyUtils . copyToByteArray ( resources . get ( 0 ) . openStream ( ) ) , equalTo ( bytes ) ) ; }
AngusZhu/spring-boot | @ Test public void getDeletedClass ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . class " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . DELETED , null ) ) ; this . thrown . expect ( ClassNotFoundException . class ) ; this . reloadClassLoader . loadClass ( PACKAGE + " . Sample " ) ; }
AngusZhu/spring-boot | @ Test public void getUpdatedClass ( ) throws Exception { String name = PACKAGE_PATH + " / Sample . class " ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . MODIFIED , new byte [ 10 ] ) ) ; this . thrown . expect ( ClassFormatError . class ) ; this . reloadClassLoader . loadClass ( PACKAGE + " . Sample " ) ; }
AngusZhu/spring-boot | @ Test public void getAddedClass ( ) throws Exception { String name = PACKAGE_PATH + " / SampleParent . class " ; byte [ ] bytes = FileCopyUtils . copyToByteArray ( getClass ( ) . getResourceAsStream ( " SampleParent . class " ) ) ; this . updatedFiles . addFile ( name , new ClassLoaderFile ( Kind . ADDED , bytes ) ) ; Class < ? > loaded = this . reloadClassLoader . loadClass ( PACKAGE + " . SampleParent " ) ; assertThat ( loaded . getClassLoader ( ) , equalTo ( ( ClassLoader ) this . reloadClassLoader ) ) ; }
AngusZhu/spring-boot | private String readString ( InputStream in ) throws IOException { return new String ( FileCopyUtils . copyToByteArray ( in ) ) ; }
AngusZhu/spring-boot | private < T > List < T > toList ( Enumeration < T > enumeration ) { List < T > list = new ArrayList < T > ( ) ; if ( enumeration != null ) { while ( enumeration . hasMoreElements ( ) ) { list . add ( enumeration . nextElement ( ) ) ; } } return list ; }
leafclick/intellij-community | @ Override protected final void customizeCellRenderer ( @ NotNull JList < ? extends T > list , T value , int index , boolean selected , boolean hasFocus ) { doCustomize ( list , value , index , selected , hasFocus ) ; }
leafclick/intellij-community | public void append ( @ NotNull SimpleColoredText text ) { text . appendToComponent ( this ) ; }
saddi909/LementProAndroidApp | public Checkpoints ( ) { dateClosed = " " ; description = " " ; duration = 0 ; id = " " ; isClosed = false ; isExpired = false ; name = " " ; startDateTime = " " ; authorAvatarFileld = " " ; authorId = " " ; authorisInVacation = false ; authorText = " " ; authorFromAvatarFileld = " " ; authorFromId = " " ; authorFromisInVacation = false ; authorFromText = " " ; }
incodehq/ecpcrm | @ Programmatic public List < Center > listAll ( ) { return repositoryService . allInstances ( Center . class ) ; }
incodehq/ecpcrm | @ Programmatic public Center findByExactName ( final String name ) { return repositoryService . uniqueMatch ( new QueryDefault < > ( Center . class , " findByExactName " , " name " , name ) ) ; }
incodehq/ecpcrm | @ Programmatic public List < Center > findByNameContains ( final String name ) { return repositoryService . allMatches ( new QueryDefault < > ( Center . class , " findByNameContains " , " name " , name ) ) ; }
incodehq/ecpcrm | @ Programmatic public List < Center > findByMailchimpListId ( final String mailchimpListId ) { QCenter center = QCenter . candidate ( ) ; return isisJdoSupport . executeQuery ( Center . class , center . mailchimpListId . eq ( mailchimpListId ) ) ; }
incodehq/ecpcrm | @ Programmatic public Center findByCode ( final String code ) { return repositoryService . uniqueMatch ( new QueryDefault < > ( Center . class , " findByCode " , " code " , code ) ) ; }
incodehq/ecpcrm | @ Programmatic private Center newCenter ( final String code , final String name , final String id , final String mailchimpListId , final String contactEmail ) { Center center = repositoryService . instantiate ( Center . class ) ; center . setCode ( code ) ; center . setId ( id ) ; center . setName ( name ) ; center . setNumerator ( numeratorRepository . findOrCreate ( name , " % d " , Long . parseLong ( "2" + code + "000000000" ) ) ) ; center . setAtPath ( " / FRA / " + code ) ; center . setMailchimpListId ( mailchimpListId ) ; center . setContactEmail ( contactEmail ) ; repositoryService . persist ( center ) ; return center ; }
incodehq/ecpcrm | @ Programmatic public Center findOrCreate ( final String code , final String name , final String id , final String mailchimpListId , final String contactEmail ) { Center center = findByCode ( code ) ; center = center != null ? center : findByExactName ( name ) ; center = center != null ? center : newCenter ( code , name , id , mailchimpListId , contactEmail ) ; return center ; }
anilgursel/squbs | catch ( Exception e ) { binding = null ; }
anilgursel/squbs | if ( " helloHttps " . equals ( svcName ) ) { return Optional . of ( HttpEndpoint . create ( " https : // localhost : " + port , sslContext ( " exampletrust . jks " , " changeit " ) , Optional . empty ( ) ) ) ; }
anilgursel/squbs | public ClientFlowHttpsEndpointTest ( ) { clientFlow = ClientFlow . create ( " helloHttps " , system , mat ) ; }
anilgursel/squbs | CompletionStage < Try < HttpResponse > > doRequest ( HttpRequest request ) { return Source . single ( Pair . create ( request , 42 ) ) . via ( clientFlow ) . runWith ( Sink . head ( ) , mat ) . thenApply ( Pair :: first ) ; }
anilgursel/squbs | @ Test public void testClientCallHelloService ( ) throws Exception { CompletionStage < Try < HttpResponse > > cs = doRequest ( HttpRequest . create ( " / hello " ) ) ; HttpResponse response = cs . toCompletableFuture ( ) . get ( ) . get ( ) ; assertEquals ( StatusCodes . OK , response . status ( ) ) ; String content = response . entity ( ) . toStrict ( Timeouts . awaitMax ( ) . toMillis ( ) , mat ) . toCompletableFuture ( ) . get ( ) . getData ( ) . utf8String ( ) ; assertEquals ( " Hello ▁ World ! " , content ) ; }
anilgursel/squbs | @ Test ( expected = HttpClientEndpointNotExistException . class ) public void endPointNotExist ( ) throws Exception { ClientFlow . < Integer > create ( " cannotResolve " , system , mat ) ; }
minwoo-jung/pinpoint | @ Before public void before ( ) { when ( mockApplicationIndexDao . selectAgentIds ( APPLICATION_NAME ) ) . thenReturn ( Arrays . asList ( AGENT_ID_1 , AGENT_ID_2 , AGENT_ID_3 ) ) ; }
minwoo-jung/pinpoint | private long createEventTimestamp ( ) { return RandomUtils . nextLong ( START_TIME_MILLIS , CURRENT_TIME_MILLIS ) ; }
minwoo-jung/pinpoint | @ Test public void checkTest1 ( ) { Rule rule = new Rule ( APPLICATION_NAME , SERVICE_TYPE , CheckerCategory . ERROR_COUNT . getName ( ) , 50 , " testGroup " , false , false , " " ) ; Application application = new Application ( APPLICATION_NAME , ServiceType . STAND_ALONE ) ; Range range = Range . newUncheckedRange ( START_TIME_MILLIS , CURRENT_TIME_MILLIS ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_1 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_1 , createEventTimestamp ( ) , AgentEventType . AGENT_CLOSED_BY_SERVER ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_2 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_2 , createEventTimestamp ( ) , AgentEventType . AGENT_DEADLOCK_DETECTED ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_3 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_3 , createEventTimestamp ( ) , AgentEventType . AGENT_PING ) ) ) ; AgentEventDataCollector dataCollector = new AgentEventDataCollector ( DataCollectorFactory . DataCollectorCategory . AGENT_EVENT , application , mockAgentEventDao , mockApplicationIndexDao , CURRENT_TIME_MILLIS , INTERVAL_MILLIS ) ; DeadlockChecker checker = new DeadlockChecker ( dataCollector , rule ) ; checker . check ( ) ; Assert . assertTrue ( checker . isDetected ( ) ) ; String emailMessage = checker . getEmailMessage ( ) ; Assert . assertTrue ( StringUtils . hasLength ( emailMessage ) ) ; List < String > smsMessage = checker . getSmsMessage ( ) ; Assert . assertTrue ( smsMessage . size ( ) == 1 ) ; }
minwoo-jung/pinpoint | @ Test public void checkTest2 ( ) { Rule rule = new Rule ( APPLICATION_NAME , SERVICE_TYPE , CheckerCategory . ERROR_COUNT . getName ( ) , 50 , " testGroup " , false , false , " " ) ; Application application = new Application ( APPLICATION_NAME , ServiceType . STAND_ALONE ) ; Range range = Range . newUncheckedRange ( START_TIME_MILLIS , CURRENT_TIME_MILLIS ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_1 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_1 , createEventTimestamp ( ) , AgentEventType . AGENT_CLOSED_BY_SERVER ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_2 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_2 , createEventTimestamp ( ) , AgentEventType . AGENT_SHUTDOWN ) ) ) ; when ( mockAgentEventDao . getAgentEvents ( AGENT_ID_3 , range , Collections . emptySet ( ) ) ) . thenReturn ( Arrays . asList ( createAgentEvent ( AGENT_ID_3 , createEventTimestamp ( ) , AgentEventType . AGENT_PING ) ) ) ; AgentEventDataCollector dataCollector = new AgentEventDataCollector ( DataCollectorFactory . DataCollectorCategory . AGENT_EVENT , application , mockAgentEventDao , mockApplicationIndexDao , CURRENT_TIME_MILLIS , INTERVAL_MILLIS ) ; DeadlockChecker checker = new DeadlockChecker ( dataCollector , rule ) ; checker . check ( ) ; Assert . assertFalse ( checker . isDetected ( ) ) ; String emailMessage = checker . getEmailMessage ( ) ; Assert . assertTrue ( StringUtils . isEmpty ( emailMessage ) ) ; List < String > smsMessage = checker . getSmsMessage ( ) ; Assert . assertTrue ( smsMessage . isEmpty ( ) ) ; }
minwoo-jung/pinpoint | private AgentEventBo createAgentEvent ( String agentId , long eventTimestamp , AgentEventType agentEventType ) { return new AgentEventBo ( agentId , START_TIME_MILLIS , eventTimestamp , agentEventType ) ; }
mnipper/AndroidSurvey | public SendResponsesTask ( Context context ) { mContext = context ; }
mnipper/AndroidSurvey | @ Override protected Void doInBackground ( Void ... params ) { if ( NetworkNotificationUtils . checkForNetworkErrors ( mContext ) ) { ActiveRecordCloudSync . syncSendTables ( mContext ) ; } return null ; }
intrack/BoofCV-master | public ShowLensDistortion ( Class < T > imageType ) { this . imageType = imageType ; input = new MultiSpectral < T > ( imageType , 1 , 1 , 3 ) ; output = new MultiSpectral < T > ( imageType , 1 , 1 , 3 ) ; addToToolbar ( createRadialSelect ( ) ) ; setMainGUI ( gui ) ; }
intrack/BoofCV-master | private JPanel createRadialSelect ( ) { JPanel ret = new JPanel ( ) ; ret . setLayout ( new BoxLayout ( ret , BoxLayout . X_AXIS ) ) ; radialOrder1 = new JSpinner ( new SpinnerNumberModel ( radial1 , - 1.0 , 2.0 , 0.05 ) ) ; radialOrder1 . addChangeListener ( this ) ; int h = radialOrder1 . getPreferredSize ( ) . height ; radialOrder1 . setPreferredSize ( new Dimension ( 50 , h ) ) ; radialOrder1 . setMaximumSize ( radialOrder1 . getPreferredSize ( ) ) ; radialOrder2 = new JSpinner ( new SpinnerNumberModel ( radial2 , - 1.0 , 2.0 , 0.05 ) ) ; radialOrder2 . addChangeListener ( this ) ; radialOrder2 . setPreferredSize ( new Dimension ( 50 , h ) ) ; radialOrder2 . setMaximumSize ( radialOrder1 . getPreferredSize ( ) ) ; ret . add ( Box . createRigidArea ( new Dimension ( 10 , 1 ) ) ) ; ret . add ( new JLabel ( " Radial ▁ 1 : " ) ) ; ret . add ( radialOrder1 ) ; ret . add ( Box . createRigidArea ( new Dimension ( 10 , 1 ) ) ) ; ret . add ( new JLabel ( " Radial ▁ 2 : " ) ) ; ret . add ( radialOrder2 ) ; ret . addPropertyChangeListener ( new PropertyChangeListener ( ) { @ Override public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . equals ( " enabled " ) ) { JPanel src = ( JPanel ) evt . getSource ( ) ; boolean value = ( Boolean ) evt . getNewValue ( ) ; for ( int i = 0 ; i < src . getComponentCount ( ) ; i ++ ) { src . getComponent ( i ) . setEnabled ( value ) ; } } } } ) ; return ret ; }
intrack/BoofCV-master | public void process ( final BufferedImage image ) { input . reshape ( image . getWidth ( ) , image . getHeight ( ) ) ; output . reshape ( image . getWidth ( ) , image . getHeight ( ) ) ; ConvertBufferedImage . convertFromMulti ( image , input , imageType ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { setInputImage ( image ) ; outputImage = new BufferedImage ( input . width , input . height , BufferedImage . TYPE_INT_BGR ) ; renderedImage = new BufferedImage ( input . width , input . height , BufferedImage . TYPE_INT_BGR ) ; gui . setBufferedImage ( outputImage ) ; gui . setPreferredSize ( new Dimension ( input . width , input . height ) ) ; gui . repaint ( ) ; processedImage = true ; doRefreshAll ( ) ; } } ) ; }
intrack/BoofCV-master | @ Override public void loadConfigurationFile ( String fileName ) { }
intrack/BoofCV-master | @ Override public boolean getHasProcessedImage ( ) { return processedImage ; }
intrack/BoofCV-master | @ Override public void refreshAll ( Object [ ] cookies ) { performUpdate ( ) ; }
intrack/BoofCV-master | private synchronized void performUpdate ( ) { if ( input == null || output == null ) return ; progress = 0 ; ProgressMonitorThread thread = new MyMonitorThread ( this ) ; thread . start ( ) ; PointTransform_F32 ptran = new AddRadialPtoP_F32 ( input . width * 0.8 , input . width * 0.8 , 0 , input . width / 2 , input . height / 2 , radial1 , radial2 ) ; PixelTransform_F32 tran = new PointToPixelTransform_F32 ( ptran ) ; for ( int i = 0 ; i < input . getNumBands ( ) ; i ++ , progress ++ ) { T bandIn = input . getBand ( i ) ; T bandOut = output . getBand ( i ) ; DistortImageOps . distortSingle ( bandIn , bandOut , tran , false , TypeInterpolate . BILINEAR ) ; } thread . stopThread ( ) ; ConvertBufferedImage . convertTo ( output , renderedImage ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { outputImage . createGraphics ( ) . drawImage ( renderedImage , 0 , 0 , null ) ; gui . repaint ( ) ; } } ) ; }
intrack/BoofCV-master | @ Override public void changeInput ( String name , int index ) { BufferedImage image = media . openImage ( inputRefs . get ( index ) . getPath ( ) ) ; if ( image != null ) { process ( image ) ; } }
intrack/BoofCV-master | @ Override public synchronized void stateChanged ( ChangeEvent e ) { if ( e . getSource ( ) == radialOrder1 ) radial1 = ( ( Number ) radialOrder1 . getValue ( ) ) . doubleValue ( ) ; if ( e . getSource ( ) == radialOrder2 ) radial2 = ( ( Number ) radialOrder2 . getValue ( ) ) . doubleValue ( ) ; performUpdate ( ) ; }
intrack/BoofCV-master | protected MyMonitorThread ( Component comp ) { super ( new ProgressMonitor ( comp , " Applying ▁ Distortion " , " " , 0 , input . getNumBands ( ) ) ) ; }
intrack/BoofCV-master | @ Override public void doRun ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { monitor . setProgress ( progress ) ; } } ) ; }
pvillard31/nifi | @ Override public Set < Relationship > getRelationships ( ) { return RELATIONSHIPS ; }
pvillard31/nifi | @ Override public void onTrigger ( final ProcessContext context , final ProcessSession session ) throws ProcessException { FlowFile flowFile = session . get ( ) ; if ( flowFile == null ) { return ; } FlowFile extracted = session . create ( flowFile ) ; boolean error = false ; try ( InputStream is = session . read ( flowFile ) ; Reader tikaReader = new Tika ( ) . parse ( is ) ; OutputStream os = session . write ( extracted ) ; OutputStreamWriter writer = new OutputStreamWriter ( os ) ) { IOUtils . copy ( tikaReader , writer ) ; } catch ( final Throwable t ) { error = true ; getLogger ( ) . error ( " Extraction ▁ Failed ▁ { } " , flowFile , t ) ; session . remove ( extracted ) ; session . transfer ( flowFile , REL_FAILURE ) ; } finally { if ( ! error ) { final Map < String , String > attributes = new HashMap < > ( ) ; attributes . put ( CoreAttributes . MIME_TYPE . key ( ) , TEXT_PLAIN ) ; extracted = session . putAllAttributes ( extracted , attributes ) ; session . transfer ( extracted , REL_EXTRACTED ) ; session . transfer ( flowFile , REL_ORIGINAL ) ; } } }
blacklocus/jres | public < T extends Facet > T get ( String facetName , Class < T > klass ) { return ObjectMappers . fromJson ( get ( facetName ) , klass ) ; }
cf0566/FireEyes | @ Override protected void getIntentData ( Bundle savedInstanceState ) { Intent intent = getIntent ( ) ; taskId = intent . getStringExtra ( " taskId " ) ; areaData = intent . getParcelableExtra ( " checkAreaData " ) ; }
cf0566/FireEyes | @ Override protected void loadXml ( ) { setContentView ( R . layout . activity_add_area_check ) ; }
cf0566/FireEyes | @ Override protected void initView ( ) { ivBack = ( ImageView ) findViewById ( R . id . activity_add_area_check_back ) ; tvSave = ( TextView ) findViewById ( R . id . activity_add_area_check_save ) ; etName = ( EditText ) findViewById ( R . id . area_name_et_activity_add_area_check ) ; elv = ( ExpandableListView ) findViewById ( R . id . activity_add_area_check_lv ) ; progressDialog = ProgressDialogHandle . getProgressDialog ( this , null ) ; }
cf0566/FireEyes | @ Override protected void registerListener ( ) { ivBack . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { onBackPressed ( ) ; } } ) ; tvSave . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { saveCheckArea ( ) ; } } ) ; elv . setOnChildClickListener ( new OnChildClickListener ( ) { @ Override public boolean onChildClick ( ExpandableListView parent , View v , int groupPosition , int childPosition , long id ) { CheckBox cBox = ( CheckBox ) v . findViewById ( R . id . item_add_book_check_listview_item_cbox ) ; if ( ! cBox . isChecked ( ) ) { cBox . setChecked ( true ) ; selInfoIds . add ( solutions . get ( groupPosition ) . children . get ( childPosition ) . sub_id ) ; } else { cBox . setChecked ( false ) ; selInfoIds . remove ( solutions . get ( groupPosition ) . children . get ( childPosition ) . sub_id ) ; } return false ; } } ) ; }
cf0566/FireEyes | @ Override protected void initData ( ) { SharedPreferences sharedPref = PreferenceManager . getDefaultSharedPreferences ( this ) ; token = sharedPref . getString ( " token " , null ) ; solutions = areaData . list ; initAdapter ( ) ; }
cf0566/FireEyes | private void initAdapter ( ) { groupTitles = new ArrayList < String > ( ) ; childItems = new ArrayList < ArrayList < ChildItem > > ( ) ; for ( Solution solu : solutions ) { groupTitles . add ( solu . solution ) ; ArrayList < ChildItem > subItems = new ArrayList < ChildItem > ( ) ; for ( SolutionChildItem item : solu . children ) { subItems . add ( new ChildItem ( item . sub_id , item . sub_name ) ) ; } childItems . add ( subItems ) ; } infoAdapter = new AddBookCheckListViewAdapter ( this ) ; infoAdapter . setDatas ( groupTitles , childItems , selInfoIds ) ; elv . setAdapter ( infoAdapter ) ; for ( int i = 0 ; i < groupTitles . size ( ) ; i ++ ) elv . expandGroup ( i ) ; }
cf0566/FireEyes | private void saveCheckArea ( ) { areaName = etName . getText ( ) . toString ( ) ; if ( areaName . isEmpty ( ) ) { showShortToast ( " 名称不能为空 " ) ; etName . requestFocus ( ) ; return ; } if ( taskId == null ) return ; RequestParams params = new RequestParams ( ) ; params . addBodyParameter ( " token " , token ) ; params . addBodyParameter ( " task _ id " , taskId ) ; params . addBodyParameter ( " name " , areaName ) ; params . addBodyParameter ( " type " , Constants . checkTypeArea ) ; String sels = " " ; if ( selInfoIds . size ( ) > 0 ) { for ( int i = 0 ; i < selInfoIds . size ( ) - 1 ; i ++ ) { sels += selInfoIds . get ( i ) + " , " ; } sels += selInfoIds . get ( selInfoIds . size ( ) - 1 ) ; } params . addBodyParameter ( " ids " , sels ) ; HttpUtils http = new HttpUtils ( ) ; String url = Constants . postUrl + Constants . path_saveCheckUnit ; http . send ( HttpMethod . POST , url , params , new RequestCallBack < String > ( ) { @ Override public void onStart ( ) { if ( progressDialog != null ) progressDialog . show ( ) ; } @ Override public void onFailure ( HttpException arg0 , String arg1 ) { if ( progressDialog != null ) progressDialog . dismiss ( ) ; showShortToast ( " 提交失败 ， 请检查网络连接 " ) ; } @ Override public void onSuccess ( ResponseInfo < String > arg0 ) { if ( progressDialog != null ) progressDialog . dismiss ( ) ; showShortToast ( " 操作成功 " ) ; intent = new Intent ( ) ; intent . putExtra ( " areaName " , areaName ) ; setResult ( RESULT_OK , intent ) ; onBackPressed ( ) ; } } ) ; }
apereo/cas | @ Override public SamlAttributeQueryTicket create ( final String id , final SAMLObject samlObject , final String relyingParty , final TicketGrantingTicket ticketGrantingTicket ) { return FunctionUtils . doUnchecked ( ( ) -> { try ( val w = SamlUtils . transformSamlObject ( this . configBean , samlObject ) ) { val codeId = createTicketIdFor ( id , relyingParty ) ; val service = webApplicationServiceFactory . createService ( relyingParty ) ; service . getAttributes ( ) . put ( TicketGrantingTicket . class . getSimpleName ( ) , CollectionUtils . wrapList ( ticketGrantingTicket . getId ( ) ) ) ; service . getAttributes ( ) . put ( RegisteredService . class . getSimpleName ( ) , CollectionUtils . wrapList ( relyingParty ) ) ; service . getAttributes ( ) . put ( " owner " , CollectionUtils . wrapList ( getTicketType ( ) . getName ( ) ) ) ; return new SamlAttributeQueryTicketImpl ( codeId , service , expirationPolicy . buildTicketExpirationPolicy ( ) , relyingParty , w . toString ( ) , Objects . requireNonNull ( ticketGrantingTicket ) . getAuthentication ( ) ) ; } } ) ; }
apereo/cas | @ Override public Class < ? extends Ticket > getTicketType ( ) { return SamlAttributeQueryTicket . class ; }
ivakegg/accumulo | public SummingCombinerTest ( IteratorTestInput input , IteratorTestOutput expectedOutput , IteratorTestCase testCase ) { super ( input , expectedOutput , testCase ) ; }
Tonius/E-Mobile | public InventoryCellphone ( ItemStack cellphone ) { if ( cellphone == null || ! ( cellphone . getItem ( ) instanceof ItemCellphone ) ) { throw new IllegalArgumentException ( " Invalid ▁ ItemStack ▁ when ▁ creating ▁ a ▁ " + this . getClass ( ) . getSimpleName ( ) + " ▁ instance " ) ; } this . cellphone = cellphone ; this . readFromNBT ( StackUtils . getNBT ( cellphone ) ) ; }
Tonius/E-Mobile | public ItemStack getCellphone ( ) { this . markDirty ( ) ; return this . cellphone ; }
Tonius/E-Mobile | public int getStoredPearls ( ) { ItemStack pearls = this . getStackInSlot ( 0 ) ; return pearls != null ? pearls . stackSize : 0 ; }
Tonius/E-Mobile | public boolean useFuel ( ) { if ( this . getStoredPearls ( ) <= 0 ) { return false ; } this . getStackInSlot ( 0 ) ; this . decrStackSize ( 0 , 1 ) ; this . markDirty ( ) ; return true ; }
Tonius/E-Mobile | public void readFromNBT ( NBTTagCompound tagCompound ) { NBTTagList tagList = tagCompound . getTagList ( " Inventory " , 10 ) ; for ( int i = 0 ; i < tagList . tagCount ( ) ; i ++ ) { NBTTagCompound tag = tagList . getCompoundTagAt ( i ) ; byte slot = tag . getByte ( " Slot " ) ; if ( slot >= 0 && slot < this . inv . length ) { this . inv [ slot ] = ItemStack . loadItemStackFromNBT ( tag ) ; } } }
Tonius/E-Mobile | public void writeToNBT ( NBTTagCompound tagCompound ) { NBTTagList itemList = new NBTTagList ( ) ; for ( int i = 0 ; i < this . inv . length ; i ++ ) { ItemStack stack = this . inv [ i ] ; if ( stack != null ) { NBTTagCompound tag = new NBTTagCompound ( ) ; tag . setByte ( " Slot " , ( byte ) i ) ; stack . writeToNBT ( tag ) ; itemList . appendTag ( tag ) ; } } tagCompound . setTag ( " Inventory " , itemList ) ; }
Tonius/E-Mobile | @ Override public int getSizeInventory ( ) { return this . inv . length ; }
Tonius/E-Mobile | @ Override public ItemStack getStackInSlot ( int slot ) { return this . inv [ slot ] ; }
Tonius/E-Mobile | @ Override public ItemStack decrStackSize ( int slot , int amount ) { ItemStack itemStack = this . getStackInSlot ( slot ) ; if ( itemStack != null ) { if ( itemStack . stackSize <= amount ) { this . setInventorySlotContents ( slot , null ) ; } else { itemStack = itemStack . splitStack ( amount ) ; if ( itemStack . stackSize == 0 ) { this . setInventorySlotContents ( slot , null ) ; } } } return itemStack ; }
Tonius/E-Mobile | @ Override public ItemStack getStackInSlotOnClosing ( int slot ) { ItemStack itemStack = this . getStackInSlot ( slot ) ; if ( itemStack != null ) { this . setInventorySlotContents ( slot , null ) ; } return itemStack ; }
Tonius/E-Mobile | @ Override public void setInventorySlotContents ( int slot , ItemStack itemStack ) { this . inv [ slot ] = itemStack ; if ( itemStack != null && itemStack . stackSize > this . getInventoryStackLimit ( ) ) { itemStack . stackSize = this . getInventoryStackLimit ( ) ; } }
Tonius/E-Mobile | @ Override public String getInventoryName ( ) { return this . cellphone . getDisplayName ( ) ; }
Tonius/E-Mobile | @ Override public boolean hasCustomInventoryName ( ) { return true ; }
Tonius/E-Mobile | @ Override public int getInventoryStackLimit ( ) { return 64 ; }
Tonius/E-Mobile | @ Override public void markDirty ( ) { NBTTagCompound tagCompound = StackUtils . getNBT ( this . cellphone ) ; this . writeToNBT ( tagCompound ) ; this . cellphone . setTagCompound ( tagCompound ) ; }
Tonius/E-Mobile | @ Override public boolean isUseableByPlayer ( EntityPlayer player ) { return true ; }
Tonius/E-Mobile | @ Override public void openInventory ( ) { }
Tonius/E-Mobile | @ Override public void closeInventory ( ) { }
Tonius/E-Mobile | @ Override public boolean isItemValidForSlot ( int slot , ItemStack item ) { return item != null && item . getItem ( ) instanceof ItemEnderPearl ; }
shaunmahony/seqcode | public GeneDomainData ( Gene g , int win ) { super ( g ) ; gene = g ; window = new Region ( gene . getGenome ( ) , gene . getChrom ( ) , gene . getStart ( ) - win , gene . getEnd ( ) + win ) ; windowData = new RegionDomainData ( window ) ; exons = new Vector < Region > ( ) ; exonData = new Vector < RegionDomainData > ( ) ; if ( g instanceof ExonicGene ) { ExonicGene eg = ( ExonicGene ) g ; Iterator < Region > exitr = eg . getExons ( ) ; while ( exitr . hasNext ( ) ) { Region ex = exitr . next ( ) ; exons . add ( ex ) ; exonData . add ( new RegionDomainData ( ex ) ) ; } } }
shaunmahony/seqcode | public void addDomain ( Region dom ) { super . addDomain ( dom ) ; windowData . addDomain ( dom ) ; for ( RegionDomainData rdd : exonData ) { rdd . addDomain ( dom ) ; } }
shaunmahony/seqcode | public RegionDomainData getWindowData ( ) { return windowData ; }
shaunmahony/seqcode | public RegionDomainData getExonData ( int i ) { return exonData . get ( i ) ; }
shaunmahony/seqcode | public int getNumExons ( ) { return exons . size ( ) ; }
shaunmahony/seqcode | public Region getExon ( int i ) { return exons . get ( i ) ; }
shaunmahony/seqcode | public Region getWindow ( ) { return window ; }
shaunmahony/seqcode | public Gene getGene ( ) { return gene ; }
shaunmahony/seqcode | public boolean isTSSCovered ( ) { Point tss = new Point ( gene . getGenome ( ) , gene . getChrom ( ) , gene . getTSS ( ) ) ; for ( Region unc : uncoveredRegions ) { if ( unc . contains ( tss ) ) { return false ; } } return true ; }
shaunmahony/seqcode | public void printData ( ) { double cover = ( double ) getCoveredBP ( ) / ( double ) getBP ( ) ; double wincover = ( double ) windowData . getCoveredBP ( ) / ( double ) windowData . getBP ( ) ; System . out . println ( " Gene : ▁ " + gene . getID ( ) ) ; System . out . println ( " \tLocation : ▁ " + gene . getLocationString ( ) ) ; System . out . println ( " \t # ▁ Domains : ▁ " + getNumDomains ( ) ) ; for ( Region dom : domains ) { System . out . println ( " \t\t " + dom . getLocationString ( ) ) ; } System . out . println ( " \t % ▁ Coverage : ▁ " + nf . format ( cover ) ) ; System . out . println ( " \t % ▁ Window ▁ Coverage : ▁ " + nf . format ( wincover ) ) ; if ( exons . size ( ) >= 1 ) { System . out . println ( " \t # ▁ Exons : ▁ " + getNumExons ( ) ) ; double ex_cover = ( double ) ( exonData . get ( 0 ) . getCoveredBP ( ) ) / ( double ) ( exonData . get ( 0 ) . getBP ( ) ) ; System . out . println ( " \t % ▁ 1st ▁ Exon ▁ Coverage : ▁ " + nf . format ( ex_cover ) ) ; } System . out . println ( ) ; }
mingjian2049/zstack | public RequestInfo ( HttpServletRequest req ) { session = req . getSession ( ) ; remoteHost = req . getRemoteHost ( ) ; for ( Enumeration e = req . getHeaderNames ( ) ; e . hasMoreElements ( ) ; ) { String name = e . nextElement ( ) . toString ( ) ; headers . add ( name , req . getHeader ( name ) ) ; } try { requestUrl = URLDecoder . decode ( req . getRequestURI ( ) , " UTF - 8" ) ; } catch ( UnsupportedEncodingException e ) { throw new CloudRuntimeException ( e ) ; } }
mingjian2049/zstack | @ Override public boolean handleEvent ( Event e ) { if ( e instanceof APIEvent ) { RequestData d = asyncStore . complete ( ( APIEvent ) e ) ; if ( d != null && d . webHook != null ) { try { callWebHook ( d ) ; } catch ( Throwable t ) { throw new CloudRuntimeException ( t ) ; } } } return false ; }
mingjian2049/zstack | public WebHookRetryException ( ) { }
mingjian2049/zstack | public WebHookRetryException ( String message ) { super ( message ) ; }
mingjian2049/zstack | public WebHookRetryException ( String message , Throwable cause ) { super ( message , cause ) ; }
mingjian2049/zstack | public WebHookRetryException ( Throwable cause ) { super ( cause ) ; }
mingjian2049/zstack | public WebHookRetryException ( String message , Throwable cause , boolean enableSuppression , boolean writableStackTrace ) { super ( message , cause , enableSuppression , writableStackTrace ) ; }
mingjian2049/zstack | if ( evt . isSuccess ( ) ) { RestResponseWrapper w = responseAnnotationByClass . get ( evt . getClass ( ) ) ; if ( w == null ) { throw new CloudRuntimeException ( String . format ( " cannot ▁ find ▁ RestResponseWrapper ▁ for ▁ the ▁ class [ % s ] " , evt . getClass ( ) ) ) ; } writeResponse ( response , w , ret . getResult ( ) ) ; }
mingjian2049/zstack | new Retry < Void > ( ) { String __name__ = String . format ( " call - webhook - % s " , d . webHook ) ; @ Override @ RetryCondition ( onExceptions = { WebHookRetryException . class } , times = 15 , interval = 2 ) protected Void call ( ) { try { if ( requestLogger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( String . format ( " Call ▁ Web - Hook [ % s ] ▁ ( to ▁ % s % s ) " , d . webHook , d . requestInfo . remoteHost , d . requestInfo . requestUrl ) ) ; sb . append ( String . format ( " ▁ Body : ▁ % s " , body ) ) ; requestLogger . trace ( sb . toString ( ) ) ; } Response r = http . newCall ( request ) . execute ( ) ; if ( r . code ( ) < 200 || r . code ( ) >= 300 ) { throw new WebHookRetryException ( String . format ( " failed ▁ to ▁ post ▁ to ▁ the ▁ webhook [ % s ] , ▁ % s " , d . webHook , r . toString ( ) ) ) ; } } catch ( IOException e ) { throw new WebHookRetryException ( e ) ; } return null ; } }
mingjian2049/zstack | @ Override public String toString ( ) { return String . format ( " % s - % s " , requestAnnotation . method ( ) , " null " . equals ( requestAnnotation . path ( ) ) ? apiClass . getName ( ) : path ) ; }
mingjian2049/zstack | Api ( Class clz , RestRequest at ) { apiClass = clz ; requestAnnotation = at ; apiResponseClass = at . responseClass ( ) ; path = String . format ( " % s % s " , RestConstants . API_VERSION , at . path ( ) ) ; if ( at . mappingFields ( ) . length > 0 ) { requestMappingFields = new HashMap < > ( ) ; for ( String mf : at . mappingFields ( ) ) { String [ ] kv = mf . split ( " = " ) ; if ( kv . length != 2 ) { throw new CloudRuntimeException ( String . format ( " bad ▁ requestMappingField [ % s ] ▁ of ▁ % s " , mf , apiClass ) ) ; } requestMappingFields . put ( kv [ 0 ] . trim ( ) , kv [ 1 ] . trim ( ) ) ; } } responseAnnotation = ( RestResponse ) apiResponseClass . getAnnotation ( RestResponse . class ) ; DebugUtils . Assert ( responseAnnotation != null , String . format ( " % s ▁ must ▁ be ▁ annotated ▁ with ▁ @ RestResponse " , apiResponseClass ) ) ; Collections . addAll ( optionalPaths , at . optionalPaths ( ) ) ; optionalPaths = optionalPaths . stream ( ) . map ( p -> String . format ( " % s % s " , RestConstants . API_VERSION , p ) ) . collect ( Collectors . toList ( ) ) ; if ( at . isAction ( ) ) { actionName = StringUtils . removeStart ( apiClass . getSimpleName ( ) , " API " ) ; actionName = StringUtils . removeEnd ( actionName , " Msg " ) ; actionName = StringUtils . uncapitalize ( actionName ) ; } if ( ! at . isAction ( ) && requestAnnotation . parameterName ( ) . isEmpty ( ) && requestAnnotation . method ( ) == HttpMethod . PUT ) { throw new CloudRuntimeException ( String . format ( " Invalid ▁ @ RestRequest ▁ of ▁ % s , ▁ either ▁ isAction ▁ must ▁ be ▁ set ▁ to ▁ true ▁ or " + " ▁ parameterName ▁ is ▁ set ▁ to ▁ a ▁ non - empty ▁ string " , apiClass . getName ( ) ) ) ; } List < Field > fs = FieldUtils . getAllFields ( apiClass ) ; fs = fs . stream ( ) . filter ( f -> ! f . isAnnotationPresent ( APINoSee . class ) && ! Modifier . isStatic ( f . getModifiers ( ) ) ) . collect ( Collectors . toList ( ) ) ; for ( Field f : fs ) { allApiClassFields . put ( f . getName ( ) , f ) ; if ( requestAnnotation . method ( ) == HttpMethod . GET ) { if ( APIQueryMessage . class . isAssignableFrom ( apiClass ) ) { continue ; } if ( Collection . class . isAssignableFrom ( f . getType ( ) ) ) { Class gtype = FieldUtils . getGenericType ( f ) ; if ( gtype == null ) { throw new CloudRuntimeException ( String . format ( " % s . % s ▁ is ▁ of ▁ collection ▁ type ▁ but ▁ doesn ' t ▁ not ▁ have " + " ▁ a ▁ generic ▁ type " , apiClass , f . getName ( ) ) ) ; } if ( ! gtype . getName ( ) . startsWith ( " java . " ) ) { throw new CloudRuntimeException ( String . format ( " % s . % s ▁ is ▁ of ▁ collection ▁ type ▁ with ▁ a ▁ generic ▁ type " + " [ % s ] ▁ not ▁ belonging ▁ to ▁ JDK " , apiClass , f . getName ( ) , gtype ) ) ; } } else if ( Map . class . isAssignableFrom ( f . getType ( ) ) ) { throw new CloudRuntimeException ( String . format ( " % s . % s ▁ is ▁ of ▁ map ▁ type , ▁ however , ▁ the ▁ GET ▁ method ▁ doesn ' t " + " ▁ support ▁ query ▁ parameters ▁ of ▁ map ▁ type " , apiClass , f . getName ( ) ) ) ; } } } }
mingjian2049/zstack | String getMappingField ( String key ) { if ( requestMappingFields == null ) { return null ; } return requestMappingFields . get ( key ) ; }
mingjian2049/zstack | private void mapQueryParameterToApiFieldValue ( String name , String [ ] vals , Map < String , Object > params ) throws RestException { String [ ] pairs = name . split ( " \\ . " ) ; String fname = pairs [ 0 ] ; String key = pairs [ 1 ] ; Field f = allApiClassFields . get ( fname ) ; if ( f == null ) { logger . warn ( String . format ( " unknown ▁ map ▁ query ▁ parameter [ % s ] , ▁ ignore " , name ) ) ; return ; } MapField at = f . getAnnotation ( MapField . class ) ; DebugUtils . Assert ( at != null , String . format ( " % s : : % s ▁ must ▁ be ▁ annotated ▁ by ▁ @ MapField " , apiClass , fname ) ) ; Map m = ( Map ) params . get ( fname ) ; if ( m == null ) { m = new HashMap ( ) ; params . put ( fname , m ) ; } if ( m . containsKey ( key ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " duplicate ▁ map ▁ query ▁ parameter [ % s ] , ▁ there ▁ has ▁ been ▁ a ▁ parameter ▁ with ▁ the ▁ same ▁ map ▁ key " , name ) ) ; } if ( Collection . class . isAssignableFrom ( at . valueType ( ) ) ) { m . put ( key , asList ( vals ) ) ; } else { if ( vals . length > 1 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter [ % s ] , ▁ only ▁ one ▁ value ▁ is ▁ allowed ▁ for ▁ the ▁ parameter ▁ but " + " ▁ multiple ▁ values ▁ found " , name ) ) ; } m . put ( key , vals [ 0 ] ) ; } }
mingjian2049/zstack | Object queryParameterToApiFieldValue ( String name , String [ ] vals ) throws RestException { Field f = allApiClassFields . get ( name ) ; if ( f == null ) { return null ; } if ( Collection . class . isAssignableFrom ( f . getType ( ) ) ) { Class gtype = FieldUtils . getGenericType ( f ) ; List lst = new ArrayList ( ) ; for ( String v : vals ) { lst . add ( TypeUtils . stringToValue ( v , gtype ) ) ; } return lst ; } else { if ( vals . length > 1 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter [ % s ] , ▁ only ▁ one ▁ value ▁ is ▁ allowed ▁ for ▁ the ▁ parameter ▁ but " + " ▁ multiple ▁ values ▁ found " , name ) ) ; } return TypeUtils . stringToValue ( vals [ 0 ] , f . getType ( ) ) ; } }
mingjian2049/zstack | public RestException ( int statusCode , String error ) { this . statusCode = statusCode ; this . error = error ; }
mingjian2049/zstack | public RestResponseWrapper ( RestResponse annotation , Class apiResponseClass ) { this . annotation = annotation ; this . apiResponseClass = apiResponseClass ; if ( annotation . fieldsTo ( ) . length > 0 ) { responseMappingFields = new HashMap < > ( ) ; if ( annotation . fieldsTo ( ) . length == 1 && " all " . equals ( annotation . fieldsTo ( ) [ 0 ] ) ) { List < Field > apiFields = FieldUtils . getAllFields ( apiResponseClass ) ; apiFields = apiFields . stream ( ) . filter ( f -> ! f . isAnnotationPresent ( APINoSee . class ) && ! Modifier . isStatic ( f . getModifiers ( ) ) ) . collect ( Collectors . toList ( ) ) ; for ( Field f : apiFields ) { responseMappingFields . put ( f . getName ( ) , f . getName ( ) ) ; } } else { for ( String mf : annotation . fieldsTo ( ) ) { String [ ] kv = mf . split ( " = " ) ; if ( kv . length == 2 ) { responseMappingFields . put ( kv [ 0 ] . trim ( ) , kv [ 1 ] . trim ( ) ) ; } else if ( kv . length == 1 ) { responseMappingFields . put ( kv [ 0 ] . trim ( ) , kv [ 0 ] . trim ( ) ) ; } else { throw new CloudRuntimeException ( String . format ( " bad ▁ mappingFields [ % s ] ▁ of ▁ % s " , mf , apiResponseClass ) ) ; } } } } }
mingjian2049/zstack | private HttpEntity < String > toHttpEntity ( HttpServletRequest req ) { try { String body = IOUtils . toString ( req . getReader ( ) ) ; req . getReader ( ) . close ( ) ; HttpHeaders header = new HttpHeaders ( ) ; for ( Enumeration e = req . getHeaderNames ( ) ; e . hasMoreElements ( ) ; ) { String name = e . nextElement ( ) . toString ( ) ; header . add ( name , req . getHeader ( name ) ) ; } return new HttpEntity < > ( body , header ) ; } catch ( Exception e ) { logger . warn ( e . getMessage ( ) , e ) ; throw new CloudRuntimeException ( e ) ; } }
mingjian2049/zstack | private void sendResponse ( int statusCode , String body , HttpServletResponse rsp ) throws IOException { if ( requestLogger . isTraceEnabled ( ) ) { RequestInfo info = requestInfo . get ( ) ; StringBuilder sb = new StringBuilder ( String . format ( " [ ID : ▁ % s ] ▁ Response ▁ to ▁ % s ▁ ( % s ) , " , info . session . getId ( ) , info . remoteHost , info . requestUrl ) ) ; sb . append ( String . format ( " ▁ Status ▁ Code : ▁ % s , " , statusCode ) ) ; sb . append ( String . format ( " ▁ Body : ▁ % s " , body == null || body . isEmpty ( ) ? null : body ) ) ; requestLogger . trace ( sb . toString ( ) ) ; } rsp . setStatus ( statusCode ) ; rsp . getWriter ( ) . write ( body == null ? " " : body ) ; }
mingjian2049/zstack | private String getDecodedUrl ( HttpServletRequest req ) { try { if ( req . getContextPath ( ) == null ) { return URLDecoder . decode ( req . getRequestURI ( ) , " UTF - 8" ) ; } else { return URLDecoder . decode ( StringUtils . removeStart ( req . getRequestURI ( ) , req . getContextPath ( ) ) , " UTF - 8" ) ; } } catch ( UnsupportedEncodingException e ) { throw new CloudRuntimeException ( e ) ; } }
mingjian2049/zstack | if ( requestLogger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( String . format ( " [ ID : ▁ % s , ▁ Method : ▁ % s ] ▁ Request ▁ from ▁ % s ▁ ( to ▁ % s ) , ▁ " , req . getSession ( ) . getId ( ) , req . getMethod ( ) , req . getRemoteHost ( ) , URLDecoder . decode ( req . getRequestURI ( ) , " UTF - 8" ) ) ) ; sb . append ( String . format ( " ▁ Headers : ▁ % s , " , JSONObjectUtil . toJsonString ( entity . getHeaders ( ) ) ) ) ; if ( req . getQueryString ( ) != null && ! req . getQueryString ( ) . isEmpty ( ) ) { sb . append ( String . format ( " ▁ Query : ▁ % s , " , URLDecoder . decode ( req . getQueryString ( ) , " UTF - 8" ) ) ) ; } sb . append ( String . format ( " ▁ Body : ▁ % s " , entity . getBody ( ) . isEmpty ( ) ? null : entity . getBody ( ) ) ) ; requestLogger . trace ( sb . toString ( ) ) ; }
mingjian2049/zstack | if ( matcher . match ( ASYNC_JOB_PATH_PATTERN , path ) ) { handleJobQuery ( req , rsp ) ; return ; }
mingjian2049/zstack | if ( api == null ) { for ( String p : apis . keySet ( ) ) { if ( matcher . match ( p , path ) ) { api = apis . get ( p ) ; break ; } } }
mingjian2049/zstack | if ( api == null ) { sendResponse ( HttpStatus . NOT_FOUND . value ( ) , String . format ( " no ▁ api ▁ mapping ▁ to ▁ % s " , path ) , rsp ) ; return ; }
mingjian2049/zstack | if ( api instanceof Api ) { handleUniqueApi ( ( Api ) api , entity , req , rsp ) ; }
mingjian2049/zstack | catch ( RestException e ) { sendResponse ( e . statusCode , e . error , rsp ) ; }
mingjian2049/zstack | catch ( Throwable e ) { logger . warn ( String . format ( " failed ▁ to ▁ handle ▁ API ▁ to ▁ % s " , path ) , e ) ; sendResponse ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , e . getMessage ( ) , rsp ) ; }
mingjian2049/zstack | if ( ! req . getMethod ( ) . equals ( HttpMethod . GET . name ( ) ) ) { sendResponse ( HttpStatus . METHOD_NOT_ALLOWED . value ( ) , " only ▁ GET ▁ method ▁ is ▁ allowed ▁ for ▁ querying ▁ job ▁ status " , rsp ) ; return ; }
mingjian2049/zstack | if ( ret . getState ( ) == AsyncRestState . expired ) { sendResponse ( HttpStatus . NOT_FOUND . value ( ) , " the ▁ job ▁ has ▁ been ▁ expired " , rsp ) ; return ; }
mingjian2049/zstack | if ( ret . getState ( ) == AsyncRestState . processing ) { sendResponse ( HttpStatus . ACCEPTED . value ( ) , response , rsp ) ; return ; }
mingjian2049/zstack | if ( evt . isSuccess ( ) ) { RestResponseWrapper w = responseAnnotationByClass . get ( evt . getClass ( ) ) ; if ( w == null ) { throw new CloudRuntimeException ( String . format ( " cannot ▁ find ▁ RestResponseWrapper ▁ for ▁ the ▁ class [ % s ] " , evt . getClass ( ) ) ) ; } writeResponse ( response , w , ret . getResult ( ) ) ; sendResponse ( HttpStatus . OK . value ( ) , response , rsp ) ; }
mingjian2049/zstack | private void sendResponse ( int statusCode , ApiResponse response , HttpServletResponse rsp ) throws IOException { sendResponse ( statusCode , response . isEmpty ( ) ? " " : JSONObjectUtil . toJsonString ( response ) , rsp ) ; }
mingjian2049/zstack | if ( " POST " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> a . requestAnnotation . method ( ) . name ( ) . equals ( " POST " ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , String . format ( " No ▁ creational ▁ API ▁ found " + " ▁ for ▁ the ▁ path [ % s ] " , req . getRequestURI ( ) ) ) ; } api = o . get ( ) ; }
mingjian2049/zstack | else if ( " PUT " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> m . containsKey ( a . actionName ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " the ▁ body ▁ doesn ' t ▁ contain ▁ action ▁ mapping " + " ▁ to ▁ the ▁ URL [ % s ] " , getDecodedUrl ( req ) ) ) ; } api = o . get ( ) ; parameterName = api . actionName ; }
mingjian2049/zstack | else if ( " GET " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> a . requestAnnotation . method ( ) . name ( ) . equals ( " GET " ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , String . format ( " No ▁ query ▁ API ▁ found " + " ▁ for ▁ the ▁ path [ % s ] " , req . getRequestURI ( ) ) ) ; } api = o . get ( ) ; }
mingjian2049/zstack | else if ( " DELETE " . equals ( req . getMethod ( ) ) ) { Optional < Api > o = apis . stream ( ) . filter ( a -> a . requestAnnotation . method ( ) . name ( ) . equals ( " DELETE " ) ) . findAny ( ) ; if ( ! o . isPresent ( ) ) { throw new RestException ( HttpStatus . INTERNAL_SERVER_ERROR . value ( ) , String . format ( " No ▁ delete ▁ API ▁ found " + " ▁ for ▁ the ▁ path [ % s ] " , req . getRequestURI ( ) ) ) ; } api = o . get ( ) ; }
mingjian2049/zstack | if ( body == null ) { body = new HashMap ( ) ; }
mingjian2049/zstack | if ( ! api . apiClass . isAnnotationPresent ( SuppressCredentialCheck . class ) ) { String auth = entity . getHeaders ( ) . getFirst ( " Authorization " ) ; if ( auth == null ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , " missing ▁ header ▁ ' Authorization ' " ) ; } auth = auth . trim ( ) ; if ( ! auth . startsWith ( RestConstants . HEADER_OAUTH ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Authorization ▁ type ▁ must ▁ be ▁ ' % s ' " , RestConstants . HEADER_OAUTH ) ) ; } sessionId = auth . replaceFirst ( " OAuth " , " " ) . trim ( ) ; }
mingjian2049/zstack | if ( APIQueryMessage . class . isAssignableFrom ( api . apiClass ) ) { handleQueryApi ( api , sessionId , req , rsp ) ; return ; }
mingjian2049/zstack | if ( req . getMethod ( ) . equals ( HttpMethod . GET . toString ( ) ) || req . getMethod ( ) . equals ( HttpMethod . DELETE . toString ( ) ) ) { Map < String , Object > m = new HashMap < > ( ) ; Map < String , String [ ] > queryParameters = req . getParameterMap ( ) ; for ( Map . Entry < String , String [ ] > e : queryParameters . entrySet ( ) ) { String k = e . getKey ( ) ; String [ ] vals = e . getValue ( ) ; if ( k . contains ( " . " ) ) { api . mapQueryParameterToApiFieldValue ( k , vals , m ) ; } else { Object val = api . queryParameterToApiFieldValue ( k , vals ) ; if ( val == null ) { logger . warn ( String . format ( " unknown ▁ query ▁ parameter [ % s ] , ▁ ignored " , k ) ) ; continue ; } m . put ( k , val ) ; } } parameter = m ; }
mingjian2049/zstack | if ( parameter == null ) { msg = ( APIMessage ) api . apiClass . newInstance ( ) ; }
mingjian2049/zstack | if ( requestInfo . get ( ) . headers . containsKey ( RestConstants . HEADER_JOB_UUID ) ) { String jobUuid = requestInfo . get ( ) . headers . get ( RestConstants . HEADER_JOB_UUID ) . get ( 0 ) ; if ( jobUuid . length ( ) != 32 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ header [ % s ] , ▁ it " + " ▁ must ▁ be ▁ a ▁ UUID ▁ with ▁ ' - ' ▁ stripped " , RestConstants . HEADER_JOB_UUID ) ) ; } msg . setId ( jobUuid ) ; }
mingjian2049/zstack | if ( sessionId != null ) { SessionInventory session = new SessionInventory ( ) ; session . setUuid ( sessionId ) ; msg . setSession ( session ) ; }
mingjian2049/zstack | if ( ! req . getMethod ( ) . equals ( HttpMethod . GET . toString ( ) ) && ! req . getMethod ( ) . equals ( HttpMethod . DELETE . toString ( ) ) ) { Object systemTags = body . get ( " systemTags " ) ; if ( systemTags != null ) { msg . setSystemTags ( ( List < String > ) systemTags ) ; } Object userTags = body . get ( " userTags " ) ; if ( userTags != null ) { msg . setUserTags ( ( List < String > ) userTags ) ; } }
mingjian2049/zstack | for ( Map . Entry < String , String > e : vars . entrySet ( ) ) { String key = e . getKey ( ) ; String mappingKey = api . getMappingField ( key ) ; PropertyUtils . setProperty ( msg , mappingKey == null ? key : mappingKey , e . getValue ( ) ) ; }
mingjian2049/zstack | if ( uuid != null ) { QueryCondition qc = new QueryCondition ( ) ; qc . setName ( " uuid " ) ; qc . setOp ( " = " ) ; qc . setValue ( uuid ) ; msg . getConditions ( ) . add ( qc ) ; sendMessage ( msg , api , rsp ) ; return ; }
mingjian2049/zstack | for ( Map . Entry < String , String [ ] > e : vars . entrySet ( ) ) { String varname = e . getKey ( ) . trim ( ) ; String varvalue = e . getValue ( ) [ 0 ] . trim ( ) ; if ( " limit " . equals ( varname ) ) { try { msg . setLimit ( Integer . valueOf ( varvalue ) ) ; } catch ( NumberFormatException ex ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , " Invalid ▁ query ▁ parameter . ▁ ' limit ' ▁ must ▁ be ▁ an ▁ integer " ) ; } } else if ( " start " . equals ( varname ) ) { try { msg . setStart ( Integer . valueOf ( varvalue ) ) ; } catch ( NumberFormatException ex ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , " Invalid ▁ query ▁ parameter . ▁ ' start ' ▁ must ▁ be ▁ an ▁ integer " ) ; } } else if ( " count " . equals ( varname ) ) { msg . setCount ( Boolean . valueOf ( varvalue ) ) ; } else if ( " groupBy " . equals ( varname ) ) { msg . setGroupBy ( varvalue ) ; } else if ( " replyWithCount " . equals ( varname ) ) { msg . setReplyWithCount ( Boolean . valueOf ( varvalue ) ) ; } else if ( " sort " . equals ( varname ) ) { if ( varvalue . startsWith ( " + " ) ) { msg . setSortDirection ( " asc " ) ; varvalue = StringUtils . stripStart ( varvalue , " + " ) ; } else if ( varvalue . startsWith ( " - " ) ) { msg . setSortDirection ( " desc " ) ; varvalue = StringUtils . stripStart ( varvalue , " - " ) ; } else { msg . setSortDirection ( " asc " ) ; } msg . setSortBy ( varvalue ) ; } else if ( " q " . startsWith ( varname ) ) { String [ ] conds = e . getValue ( ) ; for ( String cond : conds ) { String OP = null ; String delimiter = null ; for ( String op : QUERY_OP_MAPPING . keySet ( ) ) { if ( cond . contains ( op ) ) { OP = QUERY_OP_MAPPING . get ( op ) ; delimiter = op ; break ; } } if ( OP == null ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter . " + " ▁ The ▁ ' % s ' ▁ in ▁ the ▁ parameter [ q ] ▁ doesn ' t ▁ contain ▁ any ▁ query ▁ operator . ▁ Valid ▁ query ▁ operators ▁ are " + " ▁ % s " , cond , asList ( QUERY_OP_MAPPING . keySet ( ) ) ) ) ; } QueryCondition qc = new QueryCondition ( ) ; String [ ] ks = StringUtils . splitByWholeSeparator ( cond , delimiter , 2 ) ; if ( OP . equals ( QueryOp . IS_NULL . toString ( ) ) || OP . equals ( QueryOp . NOT_NULL . toString ( ) ) ) { String cname = ks [ 0 ] . trim ( ) ; qc . setName ( cname ) ; qc . setOp ( OP ) ; } else { if ( ks . length != 2 ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter . " + " ▁ The ▁ ' % s ' ▁ in ▁ parameter [ q ] ▁ is ▁ not ▁ a ▁ key - value ▁ pair ▁ split ▁ by ▁ % s " , cond , OP ) ) ; } String cname = ks [ 0 ] . trim ( ) ; String cvalue = ks [ 1 ] ; qc . setName ( cname ) ; qc . setOp ( OP ) ; qc . setValue ( cvalue ) ; } msg . getConditions ( ) . add ( qc ) ; } } else if ( " fields " . equals ( varname ) ) { List < String > fs = new ArrayList < > ( ) ; for ( String f : varvalue . split ( " , " ) ) { fs . add ( f . trim ( ) ) ; } if ( fs . isEmpty ( ) ) { throw new RestException ( HttpStatus . BAD_REQUEST . value ( ) , String . format ( " Invalid ▁ query ▁ parameter . ▁ ' fields ' " + " ▁ contains ▁ zero ▁ field " ) ) ; } msg . setFields ( fs ) ; } }
mingjian2049/zstack | if ( msg . getConditions ( ) == null ) { msg . setConditions ( new ArrayList < > ( ) ) ; }
mingjian2049/zstack | if ( ! w . annotation . allTo ( ) . equals ( " " ) ) { response . put ( w . annotation . allTo ( ) , PropertyUtils . getProperty ( replyOrEvent , w . annotation . allTo ( ) ) ) ; }
mingjian2049/zstack | for ( Map . Entry < String , String > e : w . responseMappingFields . entrySet ( ) ) { response . put ( e . getKey ( ) , PropertyUtils . getProperty ( replyOrEvent , e . getValue ( ) ) ) ; }
mingjian2049/zstack | if ( APIQueryReply . class . isAssignableFrom ( w . apiResponseClass ) ) { Object total = PropertyUtils . getProperty ( replyOrEvent , " total " ) ; if ( total != null ) { response . put ( " total " , total ) ; } }
mingjian2049/zstack | if ( requestInfo . get ( ) . headers . containsKey ( RestConstants . HEADER_JSON_SCHEMA ) || APIQueryReply . class . isAssignableFrom ( w . apiResponseClass ) ) { response . setSchema ( new JsonSchemaBuilder ( response ) . build ( ) ) ; }
mingjian2049/zstack | if ( ! reply . isSuccess ( ) ) { response . setError ( reply . getError ( ) ) ; sendResponse ( HttpStatus . SERVICE_UNAVAILABLE . value ( ) , JSONObjectUtil . toJsonString ( response ) , rsp ) ; return ; }
mingjian2049/zstack | if ( msg instanceof APISyncCallMessage ) { MessageReply reply = bus . call ( msg ) ; sendReplyResponse ( reply , api , rsp ) ; }
mingjian2049/zstack | if ( webHook != null && ! webHook . isEmpty ( ) ) { d . webHook = webHook . get ( 0 ) ; }
mingjian2049/zstack | @ Override public boolean start ( ) { build ( ) ; return true ; }
mingjian2049/zstack | private String substituteUrl ( String url , Map < String , String > tokens ) { Pattern pattern = Pattern . compile ( " \\ { ( . + ? ) \\ } " ) ; Matcher matcher = pattern . matcher ( url ) ; StringBuffer buffer = new StringBuffer ( ) ; while ( matcher . find ( ) ) { String varName = matcher . group ( 1 ) ; Object replacement = tokens . get ( varName ) ; if ( replacement == null ) { throw new CloudRuntimeException ( String . format ( " cannot ▁ find ▁ value ▁ for ▁ URL ▁ variable [ % s ] " , varName ) ) ; } matcher . appendReplacement ( buffer , " " ) ; buffer . append ( replacement . toString ( ) ) ; } matcher . appendTail ( buffer ) ; return buffer . toString ( ) ; }
mingjian2049/zstack | private List < String > getVarNamesFromUrl ( String url ) { Pattern pattern = Pattern . compile ( " \\ { ( . + ? ) \\ } " ) ; Matcher matcher = pattern . matcher ( url ) ; List < String > urlVars = new ArrayList < > ( ) ; while ( matcher . find ( ) ) { urlVars . add ( matcher . group ( 1 ) ) ; } return urlVars ; }
mingjian2049/zstack | private String normalizePath ( String p ) { List < String > varNames = getVarNamesFromUrl ( p ) ; if ( varNames . isEmpty ( ) ) { return p ; } Map < String , String > m = new HashMap < > ( ) ; for ( int i = 0 ; i < varNames . size ( ) ; i ++ ) { m . put ( varNames . get ( i ) , String . format ( " { % s } " , i ) ) ; } return substituteUrl ( p , m ) ; }
mingjian2049/zstack | private void build ( ) { Reflections reflections = Platform . getReflections ( ) ; Set < Class < ? > > classes = reflections . getTypesAnnotatedWith ( RestRequest . class ) . stream ( ) . filter ( it -> it . isAnnotationPresent ( RestRequest . class ) ) . collect ( Collectors . toSet ( ) ) ; for ( Class clz : classes ) { RestRequest at = ( RestRequest ) clz . getAnnotation ( RestRequest . class ) ; Api api = new Api ( clz , at ) ; List < String > paths = new ArrayList < > ( ) ; if ( ! " null " . equals ( api . path ) ) { paths . add ( api . path ) ; } paths . addAll ( api . optionalPaths ) ; for ( String path : paths ) { String normalizedPath = normalizePath ( path ) ; api = new Api ( clz , at ) ; api . path = path ; if ( ! apis . containsKey ( normalizedPath ) ) { apis . put ( normalizedPath , api ) ; } else { Object c = apis . get ( normalizedPath ) ; List lst ; if ( c instanceof Api ) { lst = new ArrayList ( ) ; lst . add ( c ) ; apis . put ( normalizedPath , lst ) ; } else { lst = ( List ) c ; } lst . add ( api ) ; } } responseAnnotationByClass . put ( api . apiResponseClass , new RestResponseWrapper ( api . responseAnnotation , api . apiResponseClass ) ) ; } for ( Object o : apis . values ( ) ) { if ( ! ( o instanceof List ) ) { continue ; } List < Api > as = ( List < Api > ) o ; List < Api > nonActions = as . stream ( ) . filter ( a -> ! a . requestAnnotation . isAction ( ) ) . collect ( Collectors . toList ( ) ) ; Map < String , Api > set = new HashMap < > ( ) ; for ( Api a : nonActions ) { Api old = set . get ( a . toString ( ) ) ; if ( old != null ) { throw new CloudRuntimeException ( String . format ( " duplicate ▁ rest ▁ API [ % s , ▁ % s ] , ▁ they ▁ both ▁ have ▁ the ▁ same " + " ▁ HTTP ▁ methods ▁ and ▁ paths , ▁ and ▁ both ▁ are ▁ not ▁ actions . ▁ % s " , a . apiClass , old . apiClass , a . toString ( ) ) ) ; } set . put ( a . toString ( ) , a ) ; } List < Api > actions = as . stream ( ) . filter ( a -> a . requestAnnotation . isAction ( ) ) . collect ( Collectors . toList ( ) ) ; set = new HashMap < > ( ) ; for ( Api a : actions ) { Api old = set . get ( a . actionName ) ; if ( old != null ) { throw new CloudRuntimeException ( String . format ( " duplicate ▁ rest ▁ API [ % s , ▁ % s ] , ▁ they ▁ are ▁ both ▁ actions ▁ with ▁ the " + " ▁ same ▁ action ▁ name [ % s ] " , a . apiClass , old . apiClass , a . actionName ) ) ; } set . put ( a . actionName , a ) ; } } }
mingjian2049/zstack | @ Override public boolean stop ( ) { return true ; }
camunda/camunda-bpm-camel | @ Test public void getSignalProcessProducerFromUri ( ) throws Exception { CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; assertThat ( producer ) . isInstanceOf ( MessageProducer . class ) ; }
camunda/camunda-bpm-camel | @ Test public void messageIsDeliveredCalled ( ) throws Exception { ProcessInstance processInstance = mock ( ProcessInstance . class ) ; when ( processInstance . getProcessInstanceId ( ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( processInstance . getProcessDefinitionId ( ) ) . thenReturn ( " theProcessDefinitionId " ) ; when ( runtimeService . startProcessInstanceByKey ( eq ( " aProcessDefinitionKey " ) , anyMap ( ) ) ) . thenReturn ( processInstance ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; assertThat ( producer ) . isInstanceOf ( MessageProducer . class ) ; }
camunda/camunda-bpm-camel | @ Test public void signalCalled ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; ExecutionQuery query = mock ( ExecutionQuery . class ) ; Execution execution = mock ( Execution . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_PROCESS_INSTANCE_ID ) , eq ( String . class ) ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( runtimeService . createExecutionQuery ( ) ) . thenReturn ( query ) ; when ( query . processInstanceId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . activityId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . singleResult ( ) ) . thenReturn ( execution ) ; when ( execution . getId ( ) ) . thenReturn ( "1234" ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; verify ( runtimeService ) . signal ( anyString ( ) , anyMap ( ) ) ; }
camunda/camunda-bpm-camel | @ Test public void signalTransformBusinesskey ( ) throws Exception { Exchange exchange = mock ( ExtendedExchange . class ) ; Message message = mock ( Message . class ) ; ExecutionQuery query = mock ( ExecutionQuery . class ) ; Execution execution = mock ( Execution . class ) ; ProcessInstanceQuery piQuery = mock ( ProcessInstanceQuery . class ) ; ProcessInstance processInstance = mock ( ProcessInstance . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; when ( runtimeService . createProcessInstanceQuery ( ) ) . thenReturn ( piQuery ) ; when ( runtimeService . createExecutionQuery ( ) ) . thenReturn ( query ) ; when ( piQuery . processInstanceBusinessKey ( anyString ( ) ) ) . thenReturn ( piQuery ) ; when ( piQuery . singleResult ( ) ) . thenReturn ( processInstance ) ; when ( processInstance . getId ( ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( query . processInstanceId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . activityId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . singleResult ( ) ) . thenReturn ( execution ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + ACTIVITY_ID_PARAMETER + " = " + " anActivityId " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; verify ( piQuery ) . processInstanceBusinessKey ( " theBusinessKey " ) ; verify ( query ) . processInstanceId ( " theProcessInstanceId " ) ; }
camunda/camunda-bpm-camel | @ Test public void messageProcessInstanceId ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; ExecutionQuery query = mock ( ExecutionQuery . class ) ; Execution execution = mock ( Execution . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_PROCESS_INSTANCE_ID ) , eq ( String . class ) ) ) . thenReturn ( " theProcessInstanceId " ) ; when ( runtimeService . createExecutionQuery ( ) ) . thenReturn ( query ) ; when ( query . processInstanceId ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . messageEventSubscriptionName ( anyString ( ) ) ) . thenReturn ( query ) ; when ( query . singleResult ( ) ) . thenReturn ( execution ) ; when ( execution . getId ( ) ) . thenReturn ( " theExecutionId " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; verify ( query ) . processInstanceId ( " theProcessInstanceId " ) ; verify ( query ) . messageEventSubscriptionName ( " aMessageName " ) ; verify ( runtimeService ) . messageEventReceived ( eq ( " aMessageName " ) , eq ( " theExecutionId " ) , anyMap ( ) ) ; }
camunda/camunda-bpm-camel | @ Test public void messageBusinessKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , eq ( " theBusinessKey " ) , correlationCaptor . capture ( ) , anyMap ( ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
camunda/camunda-bpm-camel | @ Test public void messageBusinessKeyCorrelationKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; final String BODY = " body " ; when ( message . getBody ( ) ) . thenReturn ( BODY ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theCorrelationKey " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " + " & " + CORRELATION_KEY_NAME_PARAMETER + " = " + " aCorrelationKeyName " + " & " + COPY_MESSAGE_BODY_AS_PROCESS_VARIABLE_PARAMETER + " = test " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; ArgumentCaptor < Map < String , Object > > variablesCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , eq ( " theBusinessKey " ) , correlationCaptor . capture ( ) , variablesCaptor . capture ( ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( correlationCaptor . getValue ( ) . keySet ( ) . contains ( " aCorrelationKeyName " ) ) ; assertTrue ( correlationCaptor . getValue ( ) . values ( ) . contains ( " theCorrelationKey " ) ) ; assertThat ( variablesCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( variablesCaptor . getValue ( ) . containsKey ( " test " ) ) ; assertTrue ( variablesCaptor . getValue ( ) . containsValue ( BODY ) ) ; }
camunda/camunda-bpm-camel | @ Test public void messageBusinessKeyCorrelationKeyType ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_BUSINESS_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theBusinessKey " ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY ) , eq ( java . lang . Integer . class ) ) ) . thenReturn ( 15 ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY_TYPE ) , eq ( String . class ) ) ) . thenReturn ( " java . lang . Integer " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " + " & " + CORRELATION_KEY_NAME_PARAMETER + " = " + " aCorrelationKeyName " + " & " + EXCHANGE_HEADER_CORRELATION_KEY_TYPE + " = java . lang . Integer " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , eq ( " theBusinessKey " ) , correlationCaptor . capture ( ) , anyMap ( ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( correlationCaptor . getValue ( ) . keySet ( ) . contains ( " aCorrelationKeyName " ) ) ; assertTrue ( correlationCaptor . getValue ( ) . values ( ) . contains ( 15 ) ) ; }
camunda/camunda-bpm-camel | @ Test public void messageNoKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , correlationCaptor . capture ( ) , anyMapOf ( String . class , Object . class ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 0 ) ; }
camunda/camunda-bpm-camel | @ Test public void messageCorrelationKey ( ) throws Exception { Exchange exchange = mock ( Exchange . class ) ; Message message = mock ( Message . class ) ; when ( exchange . getIn ( ) ) . thenReturn ( message ) ; when ( exchange . getProperty ( eq ( EXCHANGE_HEADER_CORRELATION_KEY ) , eq ( String . class ) ) ) . thenReturn ( " theCorrelationKey " ) ; CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message ? " + MESSAGE_NAME_PARAMETER + " = " + " aMessageName " + " & " + CORRELATION_KEY_NAME_PARAMETER + " = " + " aCorrelationKeyName " ) ) ; Producer producer = endpoint . createProducer ( ) ; producer . process ( exchange ) ; @ SuppressWarnings ( " rawtypes " ) Class < Map < String , Object > > mapClass = ( Class < Map < String , Object > > ) ( Class ) Map . class ; ArgumentCaptor < Map < String , Object > > correlationCaptor = ArgumentCaptor . forClass ( mapClass ) ; verify ( runtimeService ) . correlateMessage ( eq ( " aMessageName " ) , correlationCaptor . capture ( ) , anyMapOf ( String . class , Object . class ) ) ; assertThat ( correlationCaptor . getValue ( ) . size ( ) ) . isEqualTo ( 1 ) ; assertTrue ( correlationCaptor . getValue ( ) . keySet ( ) . contains ( " aCorrelationKeyName " ) ) ; assertTrue ( correlationCaptor . getValue ( ) . values ( ) . contains ( " theCorrelationKey " ) ) ; }
camunda/camunda-bpm-camel | @ Test ( expected = IllegalArgumentException . class ) public void shouldFailWithoutMessageActivityId ( ) throws Exception { CamundaBpmEndpoint endpoint = ( CamundaBpmEndpoint ) camelContext . getEndpoint ( camundaBpmUri ( " message " ) ) ; endpoint . createProducer ( ) ; }
PG85/OpenTerrainGenerator | public PlottedChunksRegion ( ) { }
PG85/OpenTerrainGenerator | PlottedChunksRegion ( boolean [ ] [ ] plottedChunks ) { this . plottedChunks = plottedChunks ; }
PG85/OpenTerrainGenerator | boolean requiresSave ( ) { return this . requiresSave ; }
PG85/OpenTerrainGenerator | void markSaved ( ) { this . requiresSave = false ; }
PG85/OpenTerrainGenerator | public boolean getChunk ( int internalX , int internalZ ) { return this . plottedChunks [ internalX ] [ internalZ ] ; }
PG85/OpenTerrainGenerator | public void setChunk ( int internalX , int internalZ ) { this . plottedChunks [ internalX ] [ internalZ ] = true ; this . requiresSave = true ; }
PG85/OpenTerrainGenerator | public boolean [ ] [ ] getArray ( ) { return this . plottedChunks ; }
imikemo/robot-plugin | public RobotSuiteResult ( String name ) { this . name = name ; this . parent = null ; }
imikemo/robot-plugin | public RobotSuiteResult ( RobotTestObject parent , Element suite , File baseDirectory ) throws DocumentException { this . name = suite . attributeValue ( " name " ) ; this . parent = parent ; this . baseDirectory = baseDirectory ; if ( suite . attributeValue ( " src " ) != null ) { parseExternalFile ( suite ) ; } else { parseChildren ( suite ) ; } }
imikemo/robot-plugin | private void parseExternalFile ( Element suite ) throws DocumentException { File externalFile = new File ( baseDirectory , suite . attributeValue ( " src " ) ) ; SAXReader reader = new SAXReader ( ) ; Document splittedOutput = reader . read ( externalFile ) ; Element rootElement = splittedOutput . getRootElement ( ) . element ( " suite " ) ; parseChildren ( rootElement ) ; }
imikemo/robot-plugin | private void parseChildren ( Element suite ) throws DocumentException { for ( Element nestedSuite : ( List < Element > ) suite . elements ( " suite " ) ) { RobotSuiteResult suiteResult = new RobotSuiteResult ( this , nestedSuite , baseDirectory ) ; addChild ( suiteResult ) ; } for ( Element testCase : ( List < Element > ) suite . elements ( " test " ) ) { RobotCaseResult caseResult = new RobotCaseResult ( this , testCase ) ; addCaseResult ( caseResult ) ; } }
imikemo/robot-plugin | public void addChild ( RobotSuiteResult child ) { if ( children == null ) children = new HashMap < String , RobotSuiteResult > ( ) ; children . put ( child . getSafeName ( ) , child ) ; }
imikemo/robot-plugin | public Collection < RobotSuiteResult > getChildSuites ( ) { return children == null ? new ArrayList < RobotSuiteResult > ( ) : children . values ( ) ; }
imikemo/robot-plugin | public RobotTestObject getParent ( ) { return parent ; }
imikemo/robot-plugin | public String getName ( ) { return name ; }
imikemo/robot-plugin | public Collection < RobotCaseResult > getCaseResults ( ) { return caseResults == null ? new ArrayList < RobotCaseResult > ( ) : caseResults . values ( ) ; }
imikemo/robot-plugin | public int getFailed ( ) { return failed ; }
imikemo/robot-plugin | public int getPassed ( ) { return passed ; }
imikemo/robot-plugin | public int getTotal ( ) { return passed + failed ; }
imikemo/robot-plugin | public long getDuration ( ) { return duration ; }
imikemo/robot-plugin | public int getCriticalPassed ( ) { return criticalPassed ; }
imikemo/robot-plugin | public int getCriticalFailed ( ) { return criticalFailed ; }
imikemo/robot-plugin | public int getCriticalTotal ( ) { return criticalPassed + criticalFailed ; }
imikemo/robot-plugin | public void addCaseResult ( RobotCaseResult caseResult ) { if ( caseResults == null ) caseResults = new HashMap < String , RobotCaseResult > ( ) ; caseResults . put ( caseResult . getSafeName ( ) , caseResult ) ; }
imikemo/robot-plugin | public String getDisplayName ( ) { return getName ( ) ; }
imikemo/robot-plugin | public String getSearchUrl ( ) { return getDisplayName ( ) ; }
imikemo/robot-plugin | public RobotSuiteResult getSuite ( String name ) { if ( children == null ) return null ; return children . get ( name ) ; }
imikemo/robot-plugin | public RobotCaseResult getCase ( String name ) { if ( caseResults == null ) return null ; return caseResults . get ( name ) ; }
imikemo/robot-plugin | public RobotSuiteResult getPreviousResult ( ) { if ( parent == null ) return null ; RobotTestObject prevParent = parent . getPreviousResult ( ) ; if ( prevParent instanceof RobotSuiteResult ) return ( ( RobotSuiteResult ) prevParent ) . getSuite ( getSafeName ( ) ) ; else if ( prevParent instanceof RobotResult ) { return ( ( RobotResult ) prevParent ) . getSuite ( getSafeName ( ) ) ; } return null ; }
imikemo/robot-plugin | public Object getDynamic ( String token , StaplerRequest req , StaplerRequest rsp ) { if ( ( token ) == null ) return this ; if ( getCase ( token ) != null ) return getCase ( token ) ; return getSuite ( token ) ; }
imikemo/robot-plugin | public List < RobotSuiteResult > getAllChildSuites ( ) { List < RobotSuiteResult > allChildSuites = new ArrayList < RobotSuiteResult > ( ) ; if ( children != null ) { for ( RobotSuiteResult suite : children . values ( ) ) { allChildSuites . add ( suite ) ; List < RobotSuiteResult > childSuites = suite . getAllChildSuites ( ) ; allChildSuites . addAll ( childSuites ) ; } } return allChildSuites ; }
imikemo/robot-plugin | public List < RobotCaseResult > getAllFailedCases ( ) { List < RobotCaseResult > failedCases = new ArrayList < RobotCaseResult > ( ) ; if ( caseResults != null ) { for ( RobotCaseResult caseResult : caseResults . values ( ) ) { if ( ! caseResult . isPassed ( ) ) failedCases . add ( caseResult ) ; } } if ( children != null ) { for ( RobotSuiteResult suite : children . values ( ) ) { failedCases . addAll ( suite . getAllFailedCases ( ) ) ; } } return failedCases ; }
imikemo/robot-plugin | public void tally ( RobotBuildAction parentAction ) { setParentAction ( parentAction ) ; failed = 0 ; passed = 0 ; criticalPassed = 0 ; criticalFailed = 0 ; duration = 0 ; if ( caseResults != null ) { for ( RobotCaseResult caseResult : getCaseResults ( ) ) { if ( caseResult . isPassed ( ) ) { if ( caseResult . isCritical ( ) ) criticalPassed ++ ; passed ++ ; } else { if ( caseResult . isCritical ( ) ) criticalFailed ++ ; failed ++ ; } duration += caseResult . getDuration ( ) ; caseResult . setParentAction ( parentAction ) ; } } if ( children != null ) { for ( RobotSuiteResult suite : getChildSuites ( ) ) { suite . tally ( parentAction ) ; failed += suite . getFailed ( ) ; passed += suite . getPassed ( ) ; criticalFailed += suite . getCriticalFailed ( ) ; criticalPassed += suite . getCriticalPassed ( ) ; duration += suite . getDuration ( ) ; } } }
imikemo/robot-plugin | public RobotTestObject findObjectById ( String id ) { if ( id . indexOf ( " / " ) >= 0 ) { String suiteName = id . substring ( 0 , id . indexOf ( " / " ) ) ; String childId = id . substring ( id . indexOf ( " / " ) + 1 , id . length ( ) ) ; RobotSuiteResult suite = children . get ( suiteName ) ; return suite . findObjectById ( childId ) ; } else if ( getSuite ( id ) != null ) { return getSuite ( id ) ; } else return getCase ( id ) ; }
imikemo/robot-plugin | public void doGraph ( StaplerRequest req , StaplerResponse rsp ) throws IOException { if ( ! isNeedToGenerate ( req , rsp ) ) return ; Graph g = new RobotGraph ( getOwner ( ) , RobotGraphHelper . createDataSetForSuite ( this ) , Messages . robot_trendgraph_testcases ( ) , Messages . robot_trendgraph_builds ( ) , 500 , 200 , false , Color . green , Color . red ) ; g . doPng ( req , rsp ) ; }
imikemo/robot-plugin | public void doDurationGraph ( StaplerRequest req , StaplerResponse rsp ) throws IOException { if ( ! isNeedToGenerate ( req , rsp ) ) return ; Graph g = new RobotGraph ( getOwner ( ) , RobotGraphHelper . createDurationDataSetForSuite ( this ) , " Duration ▁ ( ms ) " , Messages . robot_trendgraph_builds ( ) , 500 , 200 , false , Color . cyan ) ; g . doPng ( req , rsp ) ; }
imikemo/robot-plugin | public void addChildren ( Collection < RobotSuiteResult > childSuites ) { for ( RobotSuiteResult child : childSuites ) { if ( children . get ( child . getSafeName ( ) ) == null ) children . put ( child . getSafeName ( ) , child ) ; } }
imikemo/robot-plugin | public void addCaseResults ( Collection < RobotCaseResult > newCaseResults ) { for ( RobotCaseResult caseResult : newCaseResults ) { if ( caseResults . get ( caseResult . getSafeName ( ) ) == null ) { caseResults . put ( caseResult . getSafeName ( ) , caseResult ) ; } } }
djechelon/spring-security | @ BeforeEach public void setup ( ) throws Exception { String keyData = " - - - - - BEGIN ▁ PRIVATE ▁ KEY - - - - - \n " + " MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBANG7v8QjQGU3MwQE \n " + " VUBxvH6Uuiy / MhZT7TV0ZNjyAF2ExA1gpn3aUxx6jYK5UnrpxRRE / KbeLucYbOhK \n " + " cDECt77Rggz5TStrOta0BQTvfluRyoQtmQ5Nkt6Vqg7O2ZapFt7k64Sal7AftzH6 \n " + " Q2BxWN1y04bLdDrH4jipqRj / 2qEFAgMBAAECgYEAj4ExY1jjdN3iEDuOwXuRB + Nn \n " + " x7pC4TgntE2huzdKvLJdGvIouTArce8A6JM5NlTBvm69mMepvAHgcsiMH1zGr5J5 \n " + " wJz23mGOyhM1veON41 / DJTVG + cxq4soUZhdYy3bpOuXGMAaJ8QLMbQQoivllNihd \n " + " vwH0rNSK8LTYWWPZYIECQQDxct + TFX1VsQ1eo41K0T4fu2rWUaxlvjUGhK6HxTmY \n " + "8OMJptunGRJL1CUjIb45Uz7SP8TPz5FwhXWsLfS182kRAkEA3l + Qd9C9gdpUh1uX \n " + " oPSNIxn5hFUrSTW1EwP9QH9vhwb5Vr8Jrd5ei678WYDLjUcx648RjkjhU9jSMzIx \n " + " EGvYtQJBAMm / i9NR7IVyyNIgZUpz5q4LI21rl1r4gUQuD8vA36zM81i4ROeuCly0 \n " + " KkfdxR4PUfnKcQCX11YnHjk9uTFj75ECQEFY / gBnxDjzqyF35hAzrYIiMPQVfznt \n " + " YX / sDTE2AdVBVGaMj1Cb51bPHnNC6Q5kXKQnj / YrLqRQND09Q7ParX0CQQC5NxZr \n " + "9jKqhHj8yQD6PlXTsY4Occ7DH6 / IoDenfdEVD5qlet0zmd50HatN2Jiqm5ubN7CM \n " + " INrtuLp4YHbgk1mi \n " + " - - - - - END ▁ PRIVATE ▁ KEY - - - - - " ; this . key = RsaKeyConverters . pkcs8 ( ) . convert ( new ByteArrayInputStream ( keyData . getBytes ( StandardCharsets . UTF_8 ) ) ) ; final CertificateFactory factory = CertificateFactory . getInstance ( " X . 509" ) ; String certificateData = " - - - - - BEGIN ▁ CERTIFICATE - - - - - \n " + " MIICgTCCAeoCCQCuVzyqFgMSyDANBgkqhkiG9w0BAQsFADCBhDELMAkGA1UEBhMC \n " + " VVMxEzARBgNVBAgMCldhc2hpbmd0b24xEjAQBgNVBAcMCVZhbmNvdXZlcjEdMBsG \n " + " A1UECgwUU3ByaW5nIFNlY3VyaXR5IFNBTUwxCzAJBgNVBAsMAnNwMSAwHgYDVQQD \n " + " DBdzcC5zcHJpbmcuc2VjdXJpdHkuc2FtbDAeFw0xODA1MTQxNDMwNDRaFw0yODA1 \n " + " MTExNDMwNDRaMIGEMQswCQYDVQQGEwJVUzETMBEGA1UECAwKV2FzaGluZ3RvbjES \n " + " MBAGA1UEBwwJVmFuY291dmVyMR0wGwYDVQQKDBRTcHJpbmcgU2VjdXJpdHkgU0FN \n " + " TDELMAkGA1UECwwCc3AxIDAeBgNVBAMMF3NwLnNwcmluZy5zZWN1cml0eS5zYW1s \n " + " MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDRu7 / EI0BlNzMEBFVAcbx + lLos \n " + " vzIWU + 01dGTY8gBdhMQNYKZ92lMceo2CuVJ66cUURPym3i7nGGzoSnAxAre + 0YIM \n " + " + U0razrWtAUE735bkcqELZkOTZLelaoOztmWqRbe5OuEmpewH7cx + kNgcVjdctOG \n " + " y3Q6x + I4qakY / 9qhBQIDAQABMA0GCSqGSIb3DQEBCwUAA4GBAAeViTvHOyQopWEi \n " + " XOfI2Z9eukwrSknDwq / zscR0YxwwqDBMt / QdAODfSwAfnciiYLkmEjlozWRtOeN + \n " + " qK7UFgP1bRl5qksrYX5S0z2iGJh0GvonLUt3e20Ssfl5tTEDDnAEUMLfBkyaxEHD \n " + " RZ / nbTJ7VTeZOSyRoVn5XHhpuJ0B \n " + " - - - - - END ▁ CERTIFICATE - - - - - " ; this . certificate = ( X509Certificate ) factory . generateCertificate ( new ByteArrayInputStream ( certificateData . getBytes ( StandardCharsets . UTF_8 ) ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithCredentialsThenItSucceeds ( ) { new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . SIGNING ) ; new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . SIGNING , Saml2X509CredentialType . DECRYPTION ) ; new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . DECRYPTION ) ; Saml2X509Credential . signing ( this . key , this . certificate ) ; Saml2X509Credential . decryption ( this . key , this . certificate ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithCredentialsThenItSucceeds ( ) { new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . VERIFICATION ) ; new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . VERIFICATION , Saml2X509CredentialType . ENCRYPTION ) ; new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . ENCRYPTION ) ; Saml2X509Credential . verification ( this . certificate ) ; Saml2X509Credential . encryption ( this . certificate ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithoutCredentialsThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( null , ( X509Certificate ) null , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithoutPrivateKeyThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( null , this . certificate , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . key , null , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( null , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithEncryptionUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . ENCRYPTION ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenRelyingPartyWithVerificationUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . key , this . certificate , Saml2X509CredentialType . VERIFICATION ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithSigningUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . SIGNING ) ) ; }
djechelon/spring-security | @ Test public void constructorWhenAssertingPartyWithDecryptionUsageThenItFails ( ) { assertThatIllegalStateException ( ) . isThrownBy ( ( ) -> new Saml2X509Credential ( this . certificate , Saml2X509CredentialType . DECRYPTION ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForSigningWithoutCredentialsThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . signing ( null , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForSigningWithoutPrivateKeyThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . signing ( null , this . certificate ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForSigningWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . signing ( this . key , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForDecryptionWithoutCredentialsThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . decryption ( null , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForDecryptionWithoutPrivateKeyThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . decryption ( null , this . certificate ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenRelyingPartyForDecryptionWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . decryption ( this . key , null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenAssertingPartyForVerificationWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . verification ( null ) ) ; }
djechelon/spring-security | @ Test public void factoryWhenAssertingPartyForEncryptionWithoutCertificateThenItFails ( ) { assertThatIllegalArgumentException ( ) . isThrownBy ( ( ) -> Saml2X509Credential . encryption ( null ) ) ; }
Gitpiece/ssm | @ Override public boolean checkResource ( Locale locale ) { File file = new File ( this . getServletContext ( ) . getRealPath ( " / " ) + getUrl ( ) ) ; return file . exists ( ) ; }
aws/aws-sdk-java | public DescribeBudgetActionsForAccountRequestProtocolMarshaller ( com . amazonaws . protocol . json . SdkJsonProtocolFactory protocolFactory ) { this . protocolFactory = protocolFactory ; }
aws/aws-sdk-java | public Request < DescribeBudgetActionsForAccountRequest > marshall ( DescribeBudgetActionsForAccountRequest describeBudgetActionsForAccountRequest ) { if ( describeBudgetActionsForAccountRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } try { final ProtocolRequestMarshaller < DescribeBudgetActionsForAccountRequest > protocolMarshaller = protocolFactory . createProtocolMarshaller ( SDK_OPERATION_BINDING , describeBudgetActionsForAccountRequest ) ; protocolMarshaller . startMarshalling ( ) ; DescribeBudgetActionsForAccountRequestMarshaller . getInstance ( ) . marshall ( describeBudgetActionsForAccountRequest , protocolMarshaller ) ; return protocolMarshaller . finishMarshalling ( ) ; } catch ( Exception e ) { throw new SdkClientException ( " Unable ▁ to ▁ marshall ▁ request ▁ to ▁ JSON : ▁ " + e . getMessage ( ) , e ) ; } }
XClouded/t4f-core | public LittleEndianShortIn ( TypedByteIn linputStream ) { super ( linputStream ) ; }
XClouded/t4f-core | protected void fill ( ) throws IOException { int number = lin . readShort ( ) ; String s = Integer . toString ( number ) + System . getProperty ( " line . separator " , " \r \n " ) ; byte [ ] b = s . getBytes ( "8859_1" ) ; buf = new int [ b . length ] ; for ( int i = 0 ; i < b . length ; i ++ ) { buf [ i ] = b [ i ] ; } }
gosu-lang/old-gosu-repo | public UsingStatement ( ) { _varStmts = Collections . emptyList ( ) ; }
gosu-lang/old-gosu-repo | public Expression getExpression ( ) { return _expression ; }
gosu-lang/old-gosu-repo | public void setExpression ( IExpression expression ) { _expression = ( Expression ) expression ; }
gosu-lang/old-gosu-repo | public Statement getStatement ( ) { return _statement ; }
gosu-lang/old-gosu-repo | public void setStatement ( IStatement statement ) { _statement = ( Statement ) statement ; }
gosu-lang/old-gosu-repo | public List < IVarStatement > getVarStatements ( ) { return _varStmts ; }
gosu-lang/old-gosu-repo | public boolean hasVarStatements ( ) { return _varStmts != null && ! _varStmts . isEmpty ( ) ; }
gosu-lang/old-gosu-repo | public void setVarStatements ( List < IVarStatement > varStmts ) { _varStmts = varStmts ; }
gosu-lang/old-gosu-repo | public Statement getFinallyStatement ( ) { return _finallyStatement ; }
gosu-lang/old-gosu-repo | public void setFinallyStatement ( Statement finallyStatement ) { _finallyStatement = finallyStatement ; }
gosu-lang/old-gosu-repo | public Object execute ( ) { if ( ! isCompileTimeConstant ( ) ) { return super . execute ( ) ; } throw new IllegalStateException ( " Can ' t ▁ execute ▁ this ▁ parsed ▁ element ▁ directly " ) ; }
gosu-lang/old-gosu-repo | protected ITerminalStatement getLeastSignificantTerminalStatement_internal ( boolean [ ] bAbsolute ) { bAbsolute [ 0 ] = false ; return getStatement ( ) == null ? null : getStatement ( ) . getLeastSignificantTerminalStatement ( bAbsolute ) ; }
gosu-lang/old-gosu-repo | public String toString ( ) { return " using ( ▁ " + ( getExpression ( ) == null ? varStatementsToString ( ) : getExpression ( ) . toString ( ) ) + " ▁ ) \n " + getStatement ( ) == null ? " " : getStatement ( ) . toString ( ) + ( getFinallyStatement ( ) == null ? " " : ( " \n finally \n " + getFinallyStatement ( ) . toString ( ) ) ) ; }
gosu-lang/old-gosu-repo | private String varStatementsToString ( ) { String s = " " ; for ( IVarStatement varStmt : getVarStatements ( ) ) { if ( s . length ( ) == 0 ) { s += varStmt . toString ( ) ; } else { s += " , ▁ " ; } } return s ; }
Stratio/stratio-connector-commons | @ Override protected ClusterName getClusterName ( ) { return new ClusterName ( " discoverClusterName " ) ; }
Stratio/stratio-connector-commons | @ Override public void setUp ( ) throws ConnectorException { super . setUp ( ) ; prepareEnvironment ( tableMetadata ) ; prepareEnvironment ( tableMetadataSecondary ) ; Iterator < CatalogMetadata > iteratorMetadata = getConnector ( ) . getMetadataEngine ( ) . provideMetadata ( getClusterName ( ) ) . iterator ( ) ; boolean catalogFound = false ; while ( iteratorMetadata . hasNext ( ) && ! catalogFound ) { catalogMetadataProvided = iteratorMetadata . next ( ) ; catalogFound = catalogMetadataProvided . getName ( ) . getName ( ) . equals ( CATALOG ) ; } ; assertTrue ( " The ▁ catalog ▁ " + CATALOG + " ▁ must ▁ be ▁ recovered " , catalogFound ) ; }
Stratio/stratio-connector-commons | private void verifyIndexMetadata ( TableMetadata tableMetadataProvided ) { assertTrue ( " The ▁ index ▁ has ▁ not ▁ been ▁ created " , iConnectorHelper . containsIndex ( CATALOG , TABLE , INDEX_NAME ) ) ; Map < IndexName , IndexMetadata > indexes = tableMetadataProvided . getIndexes ( ) ; assertTrue ( " The ▁ index ▁ has ▁ not ▁ been ▁ recovered " , containsIndex ( indexes ) ) ; IndexType typeProvided = resolveIndexType ( indexes ) ; IndexType typeExpected = resolveIndexType ( tableMetadata . getIndexes ( ) ) ; assertEquals ( " The ▁ type ▁ is ▁ not ▁ the ▁ expected " , typeExpected , typeProvided ) ; Set < IndexName > keySet = tableMetadataProvided . getIndexes ( ) . keySet ( ) ; IndexMetadata indexMetadata = indexes . get ( keySet . iterator ( ) . next ( ) ) ; assertEquals ( " The ▁ index ▁ should ▁ have ▁ 2 ▁ columns " , 2 , indexMetadata . getColumns ( ) . keySet ( ) . size ( ) ) ; Iterator < ColumnName > iterator = indexMetadata . getColumns ( ) . keySet ( ) . iterator ( ) ; assertEquals ( " First ▁ column ▁ in ▁ composite ▁ index ▁ is ▁ not ▁ the ▁ expected " , COLUMN_1 , iterator . next ( ) . getName ( ) ) ; assertEquals ( " Second ▁ column ▁ in ▁ composite ▁ index ▁ is ▁ not ▁ the ▁ expected " , COLUMN_2 , iterator . next ( ) . getName ( ) ) ; }
Stratio/stratio-connector-commons | protected boolean containsIndex ( Map < IndexName , IndexMetadata > indexes ) { for ( IndexName indexName : indexes . keySet ( ) ) { if ( indexName . getName ( ) . equals ( INDEX_NAME ) ) { return true ; } } return false ; }
Stratio/stratio-connector-commons | protected IndexType resolveIndexType ( Map < IndexName , IndexMetadata > indexList ) { IndexType typeProvided = null ; for ( Entry < IndexName , IndexMetadata > indexName : indexList . entrySet ( ) ) { if ( indexName . getKey ( ) . getName ( ) . equals ( INDEX_NAME ) ) { typeProvided = indexName . getValue ( ) . getType ( ) ; } } return typeProvided ; }
Stratio/stratio-connector-commons | private TableMetadata createTableMetadataWithIndex ( ) { TableMetadataBuilder tableMetadataBuilder = new TableMetadataBuilder ( CATALOG , TABLE , getClusterName ( ) . getName ( ) ) ; tableMetadataBuilder . addColumn ( COLUMN_1 , new ColumnType ( DataType . INT ) ) . addColumn ( COLUMN_2 , new ColumnType ( DataType . TEXT ) ) ; tableMetadataBuilder . withPartitionKey ( COLUMN_1 ) ; IndexMetadataBuilder indexMetadataBuilder = new IndexMetadataBuilder ( CATALOG , TABLE , INDEX_NAME , IndexType . DEFAULT ) ; indexMetadataBuilder . addColumn ( COLUMN_1 , new ColumnType ( DataType . VARCHAR ) ) ; indexMetadataBuilder . addColumn ( COLUMN_2 , new ColumnType ( DataType . TEXT ) ) ; IndexMetadata indexMetadata = indexMetadataBuilder . build ( ) ; tableMetadataBuilder . addIndex ( indexMetadata ) ; tableMetadata = tableMetadataBuilder . build ( ) ; return tableMetadata ; }
Stratio/stratio-connector-commons | private TableMetadata createSimpleTableMetadata ( ) { TableMetadataBuilder tableMetadataBuilder = new TableMetadataBuilder ( CATALOG , SECOND_TABLE , getClusterName ( ) . getName ( ) ) ; tableMetadataBuilder . addColumn ( SECOND_TABLE_COLUMN , new ColumnType ( DataType . INT ) ) ; tableMetadataBuilder . withPartitionKey ( SECOND_TABLE_COLUMN ) ; return tableMetadataBuilder . build ( ) ; }
hyperfresh/mc-universe | @ Test public void testGsonSerializer ( ) { GsonSerializer serializer = new GsonSerializer ( ) ; long time = System . currentTimeMillis ( ) ; testPingPacketSerialization ( serializer ) ; testServerPacketSerialization ( serializer ) ; testSwitchPacketSerialization ( serializer ) ; System . out . println ( serializer . getName ( ) + " ▁ Serializer ▁ finished ▁ in ▁ " + ( System . currentTimeMillis ( ) - time ) + " ▁ ms " ) ; }
hyperfresh/mc-universe | @ Test public void testJavaSerializer ( ) { JavaSerializer serializer = new JavaSerializer ( ) ; long time = System . currentTimeMillis ( ) ; testPingPacketSerialization ( serializer ) ; testServerPacketSerialization ( serializer ) ; testSwitchPacketSerialization ( serializer ) ; System . out . println ( serializer . getName ( ) + " ▁ Serializer ▁ finished ▁ in ▁ " + ( System . currentTimeMillis ( ) - time ) + " ▁ ms " ) ; }
hyperfresh/mc-universe | public void testPingPacketSerialization ( SwitchCorePacketSerializer serializer ) { Packet packet ; String encoded ; encoded = serializer . serialize ( new PacketOutServerPing ( ) ) ; System . out . println ( " Encoded ▁ PacketOutServerPing : ▁ " + encoded ) ; packet = serializer . deserialize ( encoded ) ; System . out . println ( " Decoded ▁ SwitchPacket : ▁ " + packet . getClass ( ) . getName ( ) ) ; }
hyperfresh/mc-universe | public void testServerPacketSerialization ( SwitchCorePacketSerializer serializer ) { Packet packet ; String encoded ; encoded = serializer . serialize ( new PacketOutServerDiscover ( new FakeServer ( ) ) ) ; System . out . println ( " Encoded ▁ PacketOutServerDiscover : ▁ " + encoded ) ; packet = serializer . deserialize ( encoded ) ; System . out . println ( " Decoded ▁ SwitchPacket : ▁ " + ( ( PacketOutServerDiscover ) packet ) . getServer ( ) ) ; }
hyperfresh/mc-universe | public void testSwitchPacketSerialization ( SwitchCorePacketSerializer serializer ) { Packet packet ; String encoded ; encoded = serializer . serialize ( new PacketInPlayerSwitch ( ) ) ; System . out . println ( " Encoded ▁ PacketInPlayerSwitch : ▁ " + encoded ) ; packet = serializer . deserialize ( encoded ) ; System . out . println ( " Decoded ▁ PacketInPlayerSwitch : ▁ " + ( ( PacketInPlayerSwitch ) packet ) . getResult ( ) . name ( ) ) ; }
hyperfresh/mc-universe | @ Override public void setValue ( ServerValue type , Object object ) { }
hyperfresh/mc-universe | @ Override public Object getValue ( ServerValue type ) { return null ; }
hyperfresh/mc-universe | @ Override public int totalValues ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public Map < ServerValue , Object > toValueMap ( ) { return new HashMap < > ( ) ; }
hyperfresh/mc-universe | @ Override public boolean isExternal ( ) { return true ; }
hyperfresh/mc-universe | @ Override public boolean isOnline ( ) { return false ; }
hyperfresh/mc-universe | @ Override public String getServerIdentifier ( ) { return " test " ; }
hyperfresh/mc-universe | @ Override public String getServerName ( ) { return " test " ; }
hyperfresh/mc-universe | @ Override public String getServerVersion ( ) { return null ; }
hyperfresh/mc-universe | @ Override public int getMaxPlayers ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public boolean getWhitelistEnabled ( ) { return false ; }
hyperfresh/mc-universe | @ Override public String [ ] getWhitelistedPlayers ( ) { return new String [ 0 ] ; }
hyperfresh/mc-universe | @ Override public int getHubPriority ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public String [ ] getOnlinePlayers ( ) { return new String [ 0 ] ; }
hyperfresh/mc-universe | @ Override public String [ ] getQueuedPlayers ( ) { return new String [ 0 ] ; }
hyperfresh/mc-universe | @ Override public long getLastOnline ( ) { return 0 ; }
hyperfresh/mc-universe | @ Override public String toString ( ) { return " [ server : ▁ " + getServerIdentifier ( ) + " , ▁ values : ▁ " + totalValues ( ) + " , ▁ external : ▁ " + isExternal ( ) + " ] " ; }
crockpotveggies/deeplearning4j | @ Test public void testHasNext ( ) throws Exception { ClassPathResource reuters5250 = new ClassPathResource ( " / reuters / 5250" ) ; File f = reuters5250 . getFile ( ) ; StreamLineIterator iterator = new StreamLineIterator . Builder ( new FileInputStream ( f ) ) . setFetchSize ( 100 ) . build ( ) ; int cnt = 0 ; while ( iterator . hasNext ( ) ) { String line = iterator . nextSentence ( ) ; assertNotEquals ( null , line ) ; logger . info ( " Line : ▁ " + line ) ; cnt ++ ; } assertEquals ( 24 , cnt ) ; }
hawkular/wildfly-monitor | public MonitorWriteAttributeHandler ( AttributeDefinition ... definitions ) { super ( MonitorDefinition . MONITOR , definitions ) ; }
hawkular/wildfly-monitor | @ Override protected void recreateParentService ( OperationContext context , PathAddress parentAddress , ModelNode parentModel , ServiceVerificationHandler verificationHandler ) throws OperationFailedException { }
hawkular/wildfly-monitor | @ Override protected ServiceName getParentServiceName ( PathAddress parentAddress ) { return RhqMetricsService . SERVICE_NAME . append ( parentAddress . getLastElement ( ) . getValue ( ) ) ; }
ggeorg/WebXView | public SimpleImageHandler ( ImageHandler imageHandler ) { if ( imageHandler == null ) { throw new IllegalArgumentException ( ) ; } this . imageHandler = imageHandler ; }
ggeorg/WebXView | public void setDOMTreeManager ( DOMTreeManager domTreeManager ) { }
ggeorg/WebXView | public Element createElement ( SVGGeneratorContext generatorContext ) { Element imageElement = generatorContext . getDOMFactory ( ) . createElementNS ( SVG_NAMESPACE_URI , SVG_IMAGE_TAG ) ; return imageElement ; }
ggeorg/WebXView | public AffineTransform handleImage ( Image image , Element imageElement , int x , int y , int width , int height , SVGGeneratorContext generatorContext ) { int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; if ( imageWidth == 0 || imageHeight == 0 || width == 0 || height == 0 ) { handleEmptyImage ( imageElement ) ; } else { imageHandler . handleImage ( image , imageElement , generatorContext ) ; setImageAttributes ( imageElement , x , y , width , height , generatorContext ) ; } return null ; }
ggeorg/WebXView | public AffineTransform handleImage ( RenderedImage image , Element imageElement , int x , int y , int width , int height , SVGGeneratorContext generatorContext ) { int imageWidth = image . getWidth ( ) ; int imageHeight = image . getHeight ( ) ; if ( imageWidth == 0 || imageHeight == 0 || width == 0 || height == 0 ) { handleEmptyImage ( imageElement ) ; } else { imageHandler . handleImage ( image , imageElement , generatorContext ) ; setImageAttributes ( imageElement , x , y , width , height , generatorContext ) ; } return null ; }
ggeorg/WebXView | public AffineTransform handleImage ( RenderableImage image , Element imageElement , double x , double y , double width , double height , SVGGeneratorContext generatorContext ) { double imageWidth = image . getWidth ( ) ; double imageHeight = image . getHeight ( ) ; if ( imageWidth == 0 || imageHeight == 0 || width == 0 || height == 0 ) { handleEmptyImage ( imageElement ) ; } else { imageHandler . handleImage ( image , imageElement , generatorContext ) ; setImageAttributes ( imageElement , x , y , width , height , generatorContext ) ; } return null ; }
ggeorg/WebXView | protected void setImageAttributes ( Element imageElement , double x , double y , double width , double height , SVGGeneratorContext generatorContext ) { imageElement . setAttributeNS ( null , SVG_X_ATTRIBUTE , generatorContext . doubleString ( x ) ) ; imageElement . setAttributeNS ( null , SVG_Y_ATTRIBUTE , generatorContext . doubleString ( y ) ) ; imageElement . setAttributeNS ( null , SVG_WIDTH_ATTRIBUTE , generatorContext . doubleString ( width ) ) ; imageElement . setAttributeNS ( null , SVG_HEIGHT_ATTRIBUTE , generatorContext . doubleString ( height ) ) ; imageElement . setAttributeNS ( null , SVG_PRESERVE_ASPECT_RATIO_ATTRIBUTE , SVG_NONE_VALUE ) ; }
ggeorg/WebXView | protected void handleEmptyImage ( Element imageElement ) { imageElement . setAttributeNS ( XLINK_NAMESPACE_URI , XLINK_HREF_QNAME , " " ) ; imageElement . setAttributeNS ( null , SVG_WIDTH_ATTRIBUTE , "0" ) ; imageElement . setAttributeNS ( null , SVG_HEIGHT_ATTRIBUTE , "0" ) ; }
paradoxical-io/common | @ Override @ Nullable public ValueClass unmarshal ( @ Nullable UnderlyingType value ) throws Exception { return createNewInstance ( value ) ; }
paradoxical-io/common | @ Override @ Nullable public UnderlyingType marshal ( @ Nullable ValueClass valueClass ) throws Exception { if ( valueClass == null ) { return null ; } return valueClass . get ( ) ; }
vam-google/google-cloud-java | @ Test public void run ( ) { main ( null ) ; }
likelet/DAtools | public Aterm ( String DB , String DB_Object_ID , String DB_Object_Symbol , String GO_ID , String Aspect , String name , String namespace ) { this . DB = DB ; this . DB_Object_ID = DB_Object_ID ; this . DB_Object_Symbol = DB_Object_Symbol ; this . GO_ID = GO_ID ; this . Aspect = Aspect ; this . name = name ; this . namespace = namespace ; }
likelet/DAtools | public Aterm ( String DB_Object_Symbol , String GO_ID ) { this . DB_Object_Symbol = DB_Object_Symbol ; this . GO_ID = GO_ID ; }
likelet/DAtools | public String getAspect ( ) { return Aspect ; }
likelet/DAtools | public void setAspect ( String Aspect ) { this . Aspect = Aspect ; }
likelet/DAtools | public String getDB ( ) { return DB ; }
likelet/DAtools | public void setDB ( String DB ) { this . DB = DB ; }
likelet/DAtools | public String getDB_Object_ID ( ) { return DB_Object_ID ; }
likelet/DAtools | public void setDB_Object_ID ( String DB_Object_ID ) { this . DB_Object_ID = DB_Object_ID ; }
likelet/DAtools | public String getDB_Object_Symbol ( ) { return DB_Object_Symbol ; }
likelet/DAtools | public void setDB_Object_Symbol ( String DB_Object_Symbol ) { this . DB_Object_Symbol = DB_Object_Symbol ; }
likelet/DAtools | public String getGO_ID ( ) { return GO_ID ; }
likelet/DAtools | public void setGO_ID ( String GO_ID ) { this . GO_ID = GO_ID ; }
likelet/DAtools | public String getName ( ) { return name ; }
likelet/DAtools | public void setName ( String name ) { this . name = name ; }
likelet/DAtools | public String getNamespace ( ) { return namespace ; }
likelet/DAtools | public void setNamespace ( String namespace ) { this . namespace = namespace ; }
likelet/DAtools | @ Override public String toString ( ) { return DB + " \t " + DB_Object_ID + " \t " + DB_Object_Symbol + " \t " + GO_ID + " \t " + Aspect + " \t " + name + " \t " + namespace ; }
likelet/DAtools | public String toString2 ( ) { return DB_Object_Symbol + " \t " + GO_ID ; }
adataylor/ios-driver | public SetConfigurationNHandler ( IOSServerManager driver , WebDriverLikeRequest request ) { super ( driver , request ) ; }
adataylor/ios-driver | @ Override public Response handle ( ) throws Exception { WebDriverLikeCommand command = WebDriverLikeCommand . valueOf ( getRequest ( ) . getVariableValue ( " : command " ) ) ; JSONObject payload = getRequest ( ) . getPayload ( ) ; Iterator < String > iter = payload . keys ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; Object value = payload . opt ( key ) ; getSession ( ) . configure ( command ) . set ( key , value ) ; } Response resp = new Response ( ) ; resp . setSessionId ( getSession ( ) . getSessionId ( ) ) ; resp . setStatus ( 0 ) ; resp . setValue ( new JSONObject ( ) ) ; return resp ; }
adataylor/ios-driver | @ Override public JSONObject configurationDescription ( ) throws JSONException { return noConfigDefined ( ) ; }
Andimeo/OneNightUltimate | @ MessageMapping ( " / hello " ) @ SendTo ( " / topic / greetings " ) public Object greeting ( HelloMessage message ) throws InterruptedException { Thread . sleep ( 1000 ) ; return new Greeting ( " Hello . ▁ " + message . getName ( ) + " ! " ) ; }
erickubenka/code-examples | @ Test public void testT01_GoogleSearch ( ) throws MalformedURLException { final HttpCommandExecutor executor = new HttpCommandExecutor ( new HashMap < > ( ) , new URL ( " http : // localhost : 4444 / wd / hub " ) , new CustomHttpFactory ( ) ) ; final WebDriver driver = new RemoteWebDriver ( executor , new ChromeOptions ( ) ) ; driver . get ( " https : // google . de " ) ; }
suntion/suns_build | @ Override public final Serializable doCreate ( Session session ) { Serializable sessionId = this . generateSessionId ( session ) ; this . assignSessionId ( session , sessionId ) ; byte [ ] keyByte = getByteKey ( session . getId ( ) ) ; RedisUtil . set ( keyByte , serializer . serialize ( session ) , sessionCacheExprie / 1000 ) ; logger . trace ( " ↓ ↓ CREATE ↓ ↓ , ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ expire ▁ { } . ▁ url ▁ { } " , getStringKey ( keyByte ) , getHourMinuteSecend ( sessionCacheExprie ) , ShiroUtil . getRequestUrl ( ) ) ; return sessionId ; }
suntion/suns_build | @ Override public final void delete ( Session session ) { if ( session != null && session . getId ( ) != null ) { byte [ ] keyByte = getByteKey ( session . getId ( ) ) ; if ( RedisUtil . exists ( keyByte ) ) { RedisUtil . del ( keyByte ) ; logger . trace ( " DELETE ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ url ▁ { } " , getStringKey ( keyByte ) , ShiroUtil . getRequestUrl ( ) ) ; } } }
suntion/suns_build | @ Override public final void update ( Session session ) throws UnknownSessionException { byte [ ] keyByte = getByteKey ( session . getId ( ) ) ; RedisUtil . set ( keyByte , serializer . serialize ( session ) , sessionCacheExprie / 1000 ) ; logger . trace ( " ↓ ↓ UPDATE ↓ ↓ , ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ expire ▁ { } . ▁ url ▁ { } " , getStringKey ( keyByte ) , getHourMinuteSecend ( sessionCacheExprie ) , ShiroUtil . getRequestUrl ( ) ) ; }
suntion/suns_build | @ Override public Session doReadSession ( Serializable sessionId ) { byte [ ] keyByte = getByteKey ( sessionId ) ; Session session = ( Session ) serializer . deserialize ( RedisUtil . get ( keyByte ) ) ; logger . trace ( " ↑ ↑ ▁ READ ▁ ↑ ↑ , ▁ [ session ] ▁ redis ▁ by ▁ Key ▁ { } . ▁ expire ▁ less ▁ { } ▁ . ▁ url ▁ { } " , getStringKey ( keyByte ) , getHourMinuteSecend ( RedisUtil . ttl ( keyByte ) * 1000 ) , ShiroUtil . getRequestUrl ( ) ) ; return session ; }
suntion/suns_build | @ Override public final Collection < Session > getActiveSessions ( ) { Set < Session > sessions = new HashSet < Session > ( ) ; Set < byte [ ] > byteKeys = RedisUtil . keys ( ConstantsShiro . SHIRO_CACHE_SESSION + " : * " ) ; if ( byteKeys != null && byteKeys . size ( ) > 0 ) { for ( byte [ ] bs : byteKeys ) { Session s = ( Session ) serializer . deserialize ( RedisUtil . get ( bs ) ) ; sessions . add ( s ) ; } } logger . trace ( " VALUES ▁ [ session ] ▁ redis ▁ by ▁ Keys ▁ { } . " , ConstantsShiro . SHIRO_CACHE_SESSION + " : * " ) ; return sessions ; }
suntion/suns_build | public int getSessionCacheExprie ( ) { return sessionCacheExprie ; }
suntion/suns_build | public void setSessionCacheExprie ( int sessionCacheExprie ) { this . sessionCacheExprie = sessionCacheExprie ; }
kingland/java-design-patterns | @ Test public void test ( ) { App . main ( new String [ ] { } ) ; }
forgemo/bittrex-java-client | public Long getId ( ) { return id ; }
forgemo/bittrex-java-client | public void setId ( Long id ) { this . id = id ; }
forgemo/bittrex-java-client | public LocalDateTime getTimeStamp ( ) { return timeStamp ; }
forgemo/bittrex-java-client | public void setTimeStamp ( LocalDateTime timeStamp ) { this . timeStamp = timeStamp ; }
forgemo/bittrex-java-client | public BigDecimal getQuantity ( ) { return quantity ; }
forgemo/bittrex-java-client | public void setQuantity ( BigDecimal quantity ) { this . quantity = quantity ; }
forgemo/bittrex-java-client | public BigDecimal getPrice ( ) { return price ; }
forgemo/bittrex-java-client | public void setPrice ( BigDecimal price ) { this . price = price ; }
forgemo/bittrex-java-client | public BigDecimal getTotal ( ) { return total ; }
forgemo/bittrex-java-client | public void setTotal ( BigDecimal total ) { this . total = total ; }
forgemo/bittrex-java-client | public String getFillType ( ) { return fillType ; }
forgemo/bittrex-java-client | public void setFillType ( String fillType ) { this . fillType = fillType ; }
forgemo/bittrex-java-client | public String getOrderType ( ) { return orderType ; }
forgemo/bittrex-java-client | public void setOrderType ( String orderType ) { this . orderType = orderType ; }
danailKondov/dkondov | public Item ( ) { }
danailKondov/dkondov | public Item ( String name , String desc , long created ) { this . name = name ; this . desc = desc ; this . created = created ; }
danailKondov/dkondov | public String getID ( ) { return id ; }
danailKondov/dkondov | public void setID ( String id ) { this . id = id ; }
danailKondov/dkondov | public String getName ( ) { return name ; }
danailKondov/dkondov | public void setName ( String name ) { this . name = name ; }
danailKondov/dkondov | public String getDescription ( ) { return desc ; }
danailKondov/dkondov | public void setDescription ( String desc ) { this . desc = desc ; }
danailKondov/dkondov | public long getCreated ( ) { return created ; }
danailKondov/dkondov | public void setCreated ( long created ) { this . created = created ; }
danailKondov/dkondov | public ArrayList < String > getComments ( ) { return comments ; }
danailKondov/dkondov | public void setComments ( ArrayList < String > comments ) { this . comments = comments ; }
danailKondov/dkondov | @ Override public String toString ( ) { String comment = null ; if ( comments != null ) { comment = comments . toString ( ) ; } return " id : ▁ " + id + " , ▁ ▁ name : ▁ " + name + " , ▁ description : ▁ " + desc + " , ▁ created : ▁ " + created + " ▁ \n " + " comments : ▁ " + comment ; }
danailKondov/dkondov | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Item item = ( Item ) o ; if ( getCreated ( ) != item . getCreated ( ) ) return false ; if ( id != null ? ! id . equals ( item . id ) : item . id != null ) return false ; if ( getName ( ) != null ? ! getName ( ) . equals ( item . getName ( ) ) : item . getName ( ) != null ) return false ; return desc != null ? desc . equals ( item . desc ) : item . desc == null ; }
danailKondov/dkondov | @ Override public int hashCode ( ) { int result = id != null ? id . hashCode ( ) : 0 ; result = 31 * result + ( getName ( ) != null ? getName ( ) . hashCode ( ) : 0 ) ; result = 31 * result + ( desc != null ? desc . hashCode ( ) : 0 ) ; result = 31 * result + ( int ) ( getCreated ( ) ^ ( getCreated ( ) >>> 32 ) ) ; return result ; }
sajavadi/pinot | new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( int i = 0 ; i < jobs ; i ++ ) { bes . execute ( new Runnable ( ) { @ Override public void run ( ) { try { running . incrementAndGet ( ) ; syncer . startupBarrier . await ( ) ; syncer . validationBarrier . await ( ) ; running . decrementAndGet ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ) ; } } }
OblivionNW/Nucleus | @ Override public Instant deserialize ( TypeToken < ? > type , ConfigurationNode value ) { return Instant . ofEpochMilli ( value . getLong ( ) ) ; }
OblivionNW/Nucleus | @ Override public void serialize ( TypeToken < ? > type , Instant obj , ConfigurationNode value ) { value . setValue ( obj . toEpochMilli ( ) ) ; }
agentmilindu/stratos | @ Inject DefaultVDC ( @ Memoized Supplier < Set < ? extends Location > > locationsSupplier , IsDefaultVDC isDefaultVDC ) { this . locationsSupplier = checkNotNull ( locationsSupplier , " locationsSupplierSupplier " ) ; this . isDefaultVDC = checkNotNull ( isDefaultVDC , " isDefaultVDC " ) ; }
agentmilindu/stratos | @ Override public Location get ( ) { return find ( locationsSupplier . get ( ) , isDefaultVDC ) ; }
agentmilindu/stratos | @ Inject IsDefaultVDC ( @ VDC Supplier < ReferenceType > defaultVDCSupplier ) { this . defaultVDCSupplier = checkNotNull ( defaultVDCSupplier , " defaultVDCSupplier " ) ; }
agentmilindu/stratos | @ Override public boolean apply ( Location input ) { ReferenceType defaultVDC = defaultVDCSupplier . get ( ) ; return input . getScope ( ) == LocationScope . ZONE && input . getId ( ) . equals ( defaultVDC . getHref ( ) . toASCIIString ( ) ) ; }
agentmilindu/stratos | @ Override public String toString ( ) { return " isDefaultVDC ( ) " ; }
lukearndt/CommunityRosterSystem | public Member ( int aID , String aName , String aAddress , String aSuburb , String aState , String aPostCode , int aSpouseID , String aHomePhone , String aMobilePhone ) { ID = aID ; name = aName ; address = aAddress ; suburb = aSuburb ; state = aState ; postCode = aPostCode ; spouseID = aSpouseID ; homePhone = aHomePhone ; mobilePhone = aMobilePhone ; }
lukearndt/CommunityRosterSystem | public int getID ( ) { return ID ; }
lukearndt/CommunityRosterSystem | public void setID ( int iD ) { ID = iD ; }
lukearndt/CommunityRosterSystem | public String getName ( ) { return name ; }
lukearndt/CommunityRosterSystem | public void setName ( String name ) { this . name = name ; }
lukearndt/CommunityRosterSystem | public String getAddress ( ) { return address ; }
lukearndt/CommunityRosterSystem | public void setAddress ( String address ) { this . address = address ; }
lukearndt/CommunityRosterSystem | public String getSuburb ( ) { return suburb ; }
lukearndt/CommunityRosterSystem | public void setSuburb ( String suburb ) { this . suburb = suburb ; }
lukearndt/CommunityRosterSystem | public String getState ( ) { return state ; }
lukearndt/CommunityRosterSystem | public void setState ( String state ) { this . state = state ; }
lukearndt/CommunityRosterSystem | public String getPostCode ( ) { return postCode ; }
lukearndt/CommunityRosterSystem | public void setPostCode ( String postCode ) { this . postCode = postCode ; }
lukearndt/CommunityRosterSystem | public int getSpouseID ( ) { return spouseID ; }
lukearndt/CommunityRosterSystem | public void setSpouseID ( int spouseID ) { this . spouseID = spouseID ; }
lukearndt/CommunityRosterSystem | public String getHomePhone ( ) { return homePhone ; }
lukearndt/CommunityRosterSystem | public void setHomePhone ( String homePhone ) { this . homePhone = homePhone ; }
lukearndt/CommunityRosterSystem | public String getMobilePhone ( ) { return mobilePhone ; }
lukearndt/CommunityRosterSystem | public void setMobilePhone ( String mobilePhone ) { this . mobilePhone = mobilePhone ; }
Alex-Diez/Java-TDD-Katas | MinTriangleSum ( List < List < Integer > > triangle ) { this . triangle = triangle ; }
Alex-Diez/Java-TDD-Katas | int compute ( ) { return IntStream . range ( 0 , triangle . size ( ) ) . map ( i -> triangle . size ( ) - i - 1 ) . mapToObj ( triangle :: get ) . reduce ( this :: combine ) . map ( l -> l . get ( 0 ) ) . orElse ( 0 ) ; }
Alex-Diez/Java-TDD-Katas | private List < Integer > combine ( List < Integer > acc , List < Integer > list ) { return IntStream . range ( 0 , list . size ( ) ) . mapToObj ( j -> Math . min ( acc . get ( j ) , acc . get ( j + 1 ) ) + list . get ( j ) ) . collect ( Collectors . toCollection ( ( ) -> new ArrayList < > ( acc . size ( ) ) ) ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int pFromColor , final int pToColor , final LinearGradientDirection pLinearGradientDirection ) { this ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , pFromColor , pToColor , pLinearGradientDirection , null ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int pFromColor , final int pToColor , final LinearGradientDirection pLinearGradientDirection , final TextureAtlasSourceDecoratorOptions pTextureAtlasSourceDecoratorOptions ) { this ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , new int [ ] { pFromColor , pToColor } , null , pLinearGradientDirection , pTextureAtlasSourceDecoratorOptions ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int [ ] pColors , final float [ ] pPositions , final LinearGradientDirection pLinearGradientDirection ) { this ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , pColors , pPositions , pLinearGradientDirection , null ) ; }
iraupph/tictactoe-android | public LinearGradientFillBitmapTextureAtlasSourceDecorator ( final IBitmapTextureAtlasSource pBitmapTextureAtlasSource , final IBitmapTextureAtlasSourceDecoratorShape pBitmapTextureAtlasSourceDecoratorShape , final int [ ] pColors , final float [ ] pPositions , final LinearGradientDirection pLinearGradientDirection , final TextureAtlasSourceDecoratorOptions pTextureAtlasSourceDecoratorOptions ) { super ( pBitmapTextureAtlasSource , pBitmapTextureAtlasSourceDecoratorShape , pTextureAtlasSourceDecoratorOptions ) ; this . mColors = pColors ; this . mPositions = pPositions ; this . mLinearGradientDirection = pLinearGradientDirection ; this . mPaint . setStyle ( Style . FILL ) ; final int right = pBitmapTextureAtlasSource . getTextureWidth ( ) - 1 ; final int bottom = pBitmapTextureAtlasSource . getTextureHeight ( ) - 1 ; final float fromX = pLinearGradientDirection . getFromX ( right ) ; final float fromY = pLinearGradientDirection . getFromY ( bottom ) ; final float toX = pLinearGradientDirection . getToX ( right ) ; final float toY = pLinearGradientDirection . getToY ( bottom ) ; this . mPaint . setShader ( new LinearGradient ( fromX , fromY , toX , toY , pColors , pPositions , TileMode . CLAMP ) ) ; }
iraupph/tictactoe-android | @ Override public LinearGradientFillBitmapTextureAtlasSourceDecorator deepCopy ( ) { return new LinearGradientFillBitmapTextureAtlasSourceDecorator ( this . mBitmapTextureAtlasSource , this . mBitmapTextureAtlasSourceDecoratorShape , this . mColors , this . mPositions , this . mLinearGradientDirection , this . mTextureAtlasSourceDecoratorOptions ) ; }
iraupph/tictactoe-android | private LinearGradientDirection ( final int pFromX , final int pFromY , final int pToX , final int pToY ) { this . mFromX = pFromX ; this . mFromY = pFromY ; this . mToX = pToX ; this . mToY = pToY ; }
iraupph/tictactoe-android | final int getFromX ( int pRight ) { return this . mFromX * pRight ; }
iraupph/tictactoe-android | final int getFromY ( int pBottom ) { return this . mFromY * pBottom ; }
iraupph/tictactoe-android | final int getToX ( int pRight ) { return this . mToX * pRight ; }
iraupph/tictactoe-android | final int getToY ( int pBottom ) { return this . mToY * pBottom ; }
autoschool/splinter | public WebDriverRule ( WebDriver driver ) { this . driver = driver ; }
autoschool/splinter | public String getBaseUrl ( ) { return " http : // localhost : 8080" ; }
autoschool/splinter | public void before ( ) { }
autoschool/splinter | public void after ( ) { driver . close ( ) ; driver . quit ( ) ; }
thunderace/newtifry | @ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; }
BadWaka/SmallDianPing | catch ( NumberFormatException nfe ) { sdkInt = 10000 ; }
BadWaka/SmallDianPing | private CameraManager ( Context context ) { this . context = context ; this . configManager = new CameraConfigurationManager ( context ) ; useOneShotPreviewCallback = Integer . parseInt ( Build . VERSION . SDK ) > 3 ; previewCallback = new PreviewCallback ( configManager , useOneShotPreviewCallback ) ; autoFocusCallback = new AutoFocusCallback ( ) ; }
BadWaka/SmallDianPing | public void openDriver ( SurfaceHolder holder ) throws IOException { if ( camera == null ) { camera = Camera . open ( ) ; if ( camera == null ) { throw new IOException ( ) ; } camera . setPreviewDisplay ( holder ) ; camera . setDisplayOrientation ( 90 ) ; Camera . Parameters parameters = camera . getParameters ( ) ; parameters . setRotation ( 90 ) ; camera . setParameters ( parameters ) ; if ( ! initialized ) { initialized = true ; configManager . initFromCameraParameters ( camera ) ; } configManager . setDesiredCameraParameters ( camera ) ; FlashlightManager . enableFlashlight ( ) ; } }
BadWaka/SmallDianPing | public void closeDriver ( ) { if ( camera != null ) { FlashlightManager . disableFlashlight ( ) ; camera . release ( ) ; camera = null ; } }
BadWaka/SmallDianPing | public void startPreview ( ) { if ( camera != null && ! previewing ) { camera . startPreview ( ) ; previewing = true ; } }
BadWaka/SmallDianPing | public void stopPreview ( ) { if ( camera != null && previewing ) { if ( ! useOneShotPreviewCallback ) { camera . setPreviewCallback ( null ) ; } camera . stopPreview ( ) ; previewCallback . setHandler ( null , 0 ) ; autoFocusCallback . setHandler ( null , 0 ) ; previewing = false ; } }
BadWaka/SmallDianPing | public void requestPreviewFrame ( Handler handler , int message ) { if ( camera != null && previewing ) { previewCallback . setHandler ( handler , message ) ; if ( useOneShotPreviewCallback ) { camera . setOneShotPreviewCallback ( previewCallback ) ; } else { camera . setPreviewCallback ( previewCallback ) ; } } }
BadWaka/SmallDianPing | public void requestAutoFocus ( Handler handler , int message ) { if ( camera != null && previewing ) { autoFocusCallback . setHandler ( handler , message ) ; camera . autoFocus ( autoFocusCallback ) ; } }
BadWaka/SmallDianPing | public Rect getFramingRect ( ) { Point screenResolution = configManager . getScreenResolution ( ) ; if ( framingRect == null ) { if ( camera == null ) { return null ; } DisplayMetrics metrics = context . getResources ( ) . getDisplayMetrics ( ) ; int width = ( int ) ( metrics . widthPixels * 0.6 ) ; int height = ( int ) ( width * 0.9 ) ; int leftOffset = ( screenResolution . x - width ) / 2 ; int topOffset = ( screenResolution . y - height ) / 2 ; framingRect = new Rect ( leftOffset , topOffset , leftOffset + width , topOffset + height ) ; Log . d ( TAG , " Calculated ▁ framing ▁ rect : ▁ " + framingRect ) ; } return framingRect ; }
BadWaka/SmallDianPing | public Rect getFramingRectInPreview ( ) { if ( framingRectInPreview == null ) { Rect rect = new Rect ( getFramingRect ( ) ) ; Point cameraResolution = configManager . getCameraResolution ( ) ; Point screenResolution = configManager . getScreenResolution ( ) ; rect . left = rect . left * cameraResolution . x / screenResolution . x ; rect . right = rect . right * cameraResolution . x / screenResolution . x ; rect . top = rect . top * cameraResolution . y / screenResolution . y ; rect . bottom = rect . bottom * cameraResolution . y / screenResolution . y ; framingRectInPreview = rect ; } return framingRectInPreview ; }
BadWaka/SmallDianPing | public PlanarYUVLuminanceSource buildLuminanceSource ( byte [ ] data , int width , int height ) { Rect rect = getFramingRectInPreview ( ) ; int previewFormat = configManager . getPreviewFormat ( ) ; String previewFormatString = configManager . getPreviewFormatString ( ) ; switch ( previewFormat ) { case PixelFormat . YCbCr_420_SP : case PixelFormat . YCbCr_422_SP : return new PlanarYUVLuminanceSource ( data , width , height , rect . left , rect . top , rect . width ( ) , rect . height ( ) ) ; default : if ( " yuv420p " . equals ( previewFormatString ) ) { return new PlanarYUVLuminanceSource ( data , width , height , rect . left , rect . top , rect . width ( ) , rect . height ( ) ) ; } } throw new IllegalArgumentException ( " Unsupported ▁ picture ▁ format : ▁ " + previewFormat + ' / ' + previewFormatString ) ; }
yyitsz/myjavastudio | public MyEntity ( ) { }
yyitsz/myjavastudio | public MyEntity ( Long id , String name ) { super ( ) ; this . id = id ; this . name = name ; }
yyitsz/myjavastudio | public Long getId ( ) { return id ; }
yyitsz/myjavastudio | public void setId ( Long id ) { this . id = id ; }
yyitsz/myjavastudio | public String getName ( ) { return name ; }
yyitsz/myjavastudio | public void setName ( String name ) { this . name = name ; }
yyitsz/myjavastudio | @ Override public String toString ( ) { return " MyEntity ▁ [ id = " + id + " , ▁ name = " + name + " ] " ; }
sayan801/LiveSDK-for-Android | public MockHttpClient ( ) { }
sayan801/LiveSDK-for-Android | public MockHttpClient ( ClientProtocolException clientProtocolException ) { this . clientProtocolException = clientProtocolException ; }
sayan801/LiveSDK-for-Android | public MockHttpClient ( HttpResponse httpResponse ) { this . responseQueue = new LinkedList < HttpResponse > ( ) ; this . responseQueue . add ( httpResponse ) ; }
sayan801/LiveSDK-for-Android | public MockHttpClient ( IOException ioException ) { this . ioException = ioException ; }
sayan801/LiveSDK-for-Android | public void addHttpResponse ( HttpResponse httpResponse ) { this . responseQueue . add ( httpResponse ) ; }
sayan801/LiveSDK-for-Android | public void clearHttpResponseQueue ( ) { this . responseQueue . clear ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpHost target , HttpRequest request ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpHost target , HttpRequest request , HttpContext context ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpHost arg0 , HttpRequest arg1 , ResponseHandler < ? extends T > arg2 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpHost arg0 , HttpRequest arg1 , ResponseHandler < ? extends T > arg2 , HttpContext arg3 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpUriRequest request ) throws IOException { if ( this . ioException != null ) { throw this . ioException ; } else if ( this . clientProtocolException != null ) { throw this . clientProtocolException ; } else if ( this . responseQueue != null && ! this . responseQueue . isEmpty ( ) ) { return this . responseQueue . remove ( ) ; } else { throw new UnsupportedOperationException ( ) ; } }
sayan801/LiveSDK-for-Android | @ Override public HttpResponse execute ( HttpUriRequest request , HttpContext context ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpUriRequest arg0 , ResponseHandler < ? extends T > arg1 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public < T > T execute ( HttpUriRequest arg0 , ResponseHandler < ? extends T > arg1 , HttpContext arg2 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public ClientConnectionManager getConnectionManager ( ) { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | public HttpResponse getHttpResponse ( ) { return this . responseQueue . peek ( ) ; }
sayan801/LiveSDK-for-Android | @ Override public HttpParams getParams ( ) { throw new UnsupportedOperationException ( ) ; }
sayan801/LiveSDK-for-Android | public void setClientProtocolException ( ClientProtocolException clientProtocolException ) { this . clientProtocolException = clientProtocolException ; }
sayan801/LiveSDK-for-Android | public void setHttpResponse ( HttpResponse httpResponse ) { this . responseQueue . clear ( ) ; this . responseQueue . add ( httpResponse ) ; }
sayan801/LiveSDK-for-Android | public void setIoException ( IOException ioException ) { this . ioException = ioException ; }
lwd1815/Transition | public FourFragment ( ) { }
lwd1815/Transition | @ Override public void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; }
lwd1815/Transition | @ Nullable @ Override public View onCreateView ( LayoutInflater inflater , @ Nullable ViewGroup container , @ Nullable Bundle savedInstanceState ) { View view = View . inflate ( container . getContext ( ) , R . layout . fragment_child_four , null ) ; FrameLayout frameLayout = view . findViewById ( R . id . four_child ) ; FourView fourView = new FourView ( container . getContext ( ) ) ; frameLayout . addView ( fourView ) ; return view ; }
lwd1815/Transition | @ Override public void onLazyInitView ( @ Nullable Bundle savedInstanceState ) { super . onLazyInitView ( savedInstanceState ) ; }
jyoshiriro/Boogle | private Destination getDestination ( ) { try { Destination dest = new Destination ( this , BASE_URL ) ; int queryNumber = TestsMocks . getRandomInteger ( ) ; String query = TestsMocks . getQuery ( queryNumber ) ; dest . getRequestContext ( ) . addPathSegment ( " query " , query ) ; List < ResultDetail > expectedResults = TestsMocks . getExpectedResults ( queryNumber ) ; Map < String , List < ResultDetail > > expectedMap = new TreeMap < String , List < ResultDetail > > ( ) ; expectedMap . put ( BookUtil . RESULT_MATCHES_NAME , expectedResults ) ; ObjectMapper mapper = new ObjectMapper ( ) ; expectedResult = mapper . writeValueAsString ( expectedMap ) ; return dest ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
jyoshiriro/Boogle | " , type = MediaType . TEXT_HTML ) public void testSearch ( ) { assertOk ( response ) ; assertEquals ( response . getBody ( ) . trim ( ) , expectedResult . trim ( ) ) ; }
gocd-contrib/docker-elastic-agents | @ Override public GoPluginApiResponse execute ( ) { return new DefaultGoPluginApiResponse ( 200 , GSON . toJson ( FIELDS ) ) ; }
au-research/ANDS-RIFCS-API | protected CitationDate ( final Node n ) throws RIFCSException { super ( n , Constants . ELEMENT_DATE ) ; }
au-research/ANDS-RIFCS-API | public final void setType ( final String type ) { super . setAttributeValue ( Constants . ATTRIBUTE_TYPE , type ) ; }
au-research/ANDS-RIFCS-API | public final String getType ( ) { return super . getAttributeValue ( Constants . ATTRIBUTE_TYPE ) ; }
au-research/ANDS-RIFCS-API | public final void setValue ( final String value ) { super . setTextContent ( value ) ; }
au-research/ANDS-RIFCS-API | public final String getValue ( ) { return super . getTextContent ( ) ; }
mmazurkevich/sping-examples | @ Override public void afterConnected ( StompSession session , StompHeaders connectedHeaders ) { session . subscribe ( " / topic / connection " , new ConnectionHandler ( ) ) ; session . subscribe ( " / topic / messages " , new MessageHandler ( ) ) ; session . send ( " / app / login " , SocketClient . username ) ; }
JSDemos/android-sdk-20 | public GeofenceHardware ( IGeofenceHardware service ) { mService = service ; }
JSDemos/android-sdk-20 | public int [ ] getMonitoringTypes ( ) { try { return mService . getMonitoringTypes ( ) ; } catch ( RemoteException e ) { } return new int [ 0 ] ; }
JSDemos/android-sdk-20 | public int getStatusOfMonitoringType ( int monitoringType ) { try { return mService . getStatusOfMonitoringType ( monitoringType ) ; } catch ( RemoteException e ) { return MONITOR_UNSUPPORTED ; } }
JSDemos/android-sdk-20 | public boolean addGeofence ( int geofenceId , int monitoringType , GeofenceHardwareRequest geofenceRequest , GeofenceHardwareCallback callback ) { try { if ( geofenceRequest . getType ( ) == GeofenceHardwareRequest . GEOFENCE_TYPE_CIRCLE ) { return mService . addCircularFence ( geofenceId , monitoringType , geofenceRequest . getLatitude ( ) , geofenceRequest . getLongitude ( ) , geofenceRequest . getRadius ( ) , geofenceRequest . getLastTransition ( ) , geofenceRequest . getMonitorTransitions ( ) , geofenceRequest . getNotificationResponsiveness ( ) , geofenceRequest . getUnknownTimer ( ) , getCallbackWrapper ( callback ) ) ; } else { throw new IllegalArgumentException ( " Geofence ▁ Request ▁ type ▁ not ▁ supported " ) ; } } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean removeGeofence ( int geofenceId , int monitoringType ) { try { return mService . removeGeofence ( geofenceId , monitoringType ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean pauseGeofence ( int geofenceId , int monitoringType ) { try { return mService . pauseGeofence ( geofenceId , monitoringType ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean resumeGeofence ( int geofenceId , int monitoringType , int monitorTransition ) { try { return mService . resumeGeofence ( geofenceId , monitoringType , monitorTransition ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean registerForMonitorStateChangeCallback ( int monitoringType , GeofenceHardwareMonitorCallback callback ) { try { return mService . registerForMonitorStateChangeCallback ( monitoringType , getMonitorCallbackWrapper ( callback ) ) ; } catch ( RemoteException e ) { } return false ; }
JSDemos/android-sdk-20 | public boolean unregisterForMonitorStateChangeCallback ( int monitoringType , GeofenceHardwareMonitorCallback callback ) { boolean result = false ; try { result = mService . unregisterForMonitorStateChangeCallback ( monitoringType , getMonitorCallbackWrapper ( callback ) ) ; if ( result ) removeMonitorCallback ( callback ) ; } catch ( RemoteException e ) { } return result ; }
JSDemos/android-sdk-20 | private void removeCallback ( GeofenceHardwareCallback callback ) { synchronized ( mCallbacks ) { mCallbacks . remove ( callback ) ; } }
JSDemos/android-sdk-20 | private GeofenceHardwareCallbackWrapper getCallbackWrapper ( GeofenceHardwareCallback callback ) { synchronized ( mCallbacks ) { GeofenceHardwareCallbackWrapper wrapper = mCallbacks . get ( callback ) ; if ( wrapper == null ) { wrapper = new GeofenceHardwareCallbackWrapper ( callback ) ; mCallbacks . put ( callback , wrapper ) ; } return wrapper ; } }
JSDemos/android-sdk-20 | private void removeMonitorCallback ( GeofenceHardwareMonitorCallback callback ) { synchronized ( mMonitorCallbacks ) { mMonitorCallbacks . remove ( callback ) ; } }
JSDemos/android-sdk-20 | private GeofenceHardwareMonitorCallbackWrapper getMonitorCallbackWrapper ( GeofenceHardwareMonitorCallback callback ) { synchronized ( mMonitorCallbacks ) { GeofenceHardwareMonitorCallbackWrapper wrapper = mMonitorCallbacks . get ( callback ) ; if ( wrapper == null ) { wrapper = new GeofenceHardwareMonitorCallbackWrapper ( callback ) ; mMonitorCallbacks . put ( callback , wrapper ) ; } return wrapper ; } }
JSDemos/android-sdk-20 | GeofenceHardwareMonitorCallbackWrapper ( GeofenceHardwareMonitorCallback c ) { mCallback = new WeakReference < GeofenceHardwareMonitorCallback > ( c ) ; }
JSDemos/android-sdk-20 | public void onMonitoringSystemChange ( int monitoringType , boolean available , Location location ) { GeofenceHardwareMonitorCallback c = mCallback . get ( ) ; if ( c != null ) c . onMonitoringSystemChange ( monitoringType , available , location ) ; }
JSDemos/android-sdk-20 | GeofenceHardwareCallbackWrapper ( GeofenceHardwareCallback c ) { mCallback = new WeakReference < GeofenceHardwareCallback > ( c ) ; }
JSDemos/android-sdk-20 | public void onGeofenceTransition ( int geofenceId , int transition , Location location , long timestamp , int monitoringType ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) { c . onGeofenceTransition ( geofenceId , transition , location , timestamp , monitoringType ) ; } }
JSDemos/android-sdk-20 | public void onGeofenceAdd ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) c . onGeofenceAdd ( geofenceId , status ) ; }
JSDemos/android-sdk-20 | public void onGeofenceRemove ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) { c . onGeofenceRemove ( geofenceId , status ) ; removeCallback ( c ) ; } }
JSDemos/android-sdk-20 | public void onGeofencePause ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) { c . onGeofencePause ( geofenceId , status ) ; } }
JSDemos/android-sdk-20 | public void onGeofenceResume ( int geofenceId , int status ) { GeofenceHardwareCallback c = mCallback . get ( ) ; if ( c != null ) c . onGeofenceResume ( geofenceId , status ) ; }
artem-aliev/tinkerpop | @ Test public void shouldEvalBytecode ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " x " , g ) ; final Traversal evald = scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; assertTraversals ( t , evald ) ; assertThat ( manager . getBindings ( ) . containsKey ( GremlinScriptEngine . HIDDEN_G ) , is ( false ) ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithAliasInBindings ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " x " , g ) ; bindings . put ( GremlinScriptEngine . HIDDEN_G , g ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithAliasAsTraversalSource ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " x " , g ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , GremlinScriptEngine . HIDDEN_G ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithMissingBinding ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " z " , g ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; }
artem-aliev/tinkerpop | @ Test ( expected = IllegalArgumentException . class ) public void shouldNotAllowBytecodeEvalWithInvalidBinding ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final Graph graph = EmptyGraph . instance ( ) ; final GraphTraversalSource g = graph . traversal ( ) ; final GraphTraversal t = getTraversalWithLambda ( g ) ; final Bindings bindings = new SimpleBindings ( ) ; bindings . put ( " z " , g ) ; bindings . put ( " x " , " invalid - binding - for - x - given - x - should - be - traversal - source " ) ; scriptEngine . eval ( t . asAdmin ( ) . getBytecode ( ) , bindings , " x " ) ; }
artem-aliev/tinkerpop | @ Test public void shouldGetEngineByName ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; assertEquals ( ENGINE_TO_TEST , scriptEngine . getFactory ( ) . getEngineName ( ) ) ; }
artem-aliev/tinkerpop | @ Test public void shouldHaveCoreImportsInPlace ( ) throws Exception { final GremlinScriptEngine scriptEngine = manager . getEngineByName ( ENGINE_TO_TEST ) ; final List < Class > classesToCheck = Arrays . asList ( Vertex . class , Edge . class , Graph . class , VertexProperty . class ) ; for ( Class clazz : classesToCheck ) { assertEquals ( clazz , scriptEngine . eval ( clazz . getSimpleName ( ) ) ) ; } }
artem-aliev/tinkerpop | @ Test public void shouldReturnNoCustomizers ( ) { final GremlinScriptEngineManager mgr = new DefaultGremlinScriptEngineManager ( ) ; mgr . addPlugin ( ImportGremlinPlugin . build ( ) . classImports ( java . awt . Color . class ) . appliesTo ( Collections . singletonList ( " fake - script - engine " ) ) . create ( ) ) ; assertEquals ( 0 , mgr . getCustomizers ( ENGINE_TO_TEST ) . size ( ) ) ; }
stephencullinan/WeighBridge | public WeighBridgeFrame ( ) { try { UIManager . setLookAndFeel ( new SubstanceOfficeBlue2007LookAndFeel ( ) ) ; } catch ( Exception error ) { JOptionPane . showMessageDialog ( null , error ) ; } aWeighBridge = new WeighBridge ( ) ; frame = createFrame ( " WeighBridge ▁ Portal " ) ; selectWeightType ( ) ; frame . setVisible ( true ) ; }
stephencullinan/WeighBridge | public void selectWeightType ( ) { JPanel aPanel = new JPanel ( new GridLayout ( 2 , 2 ) ) ; JButton firstWeightTile = createTile ( " First ▁ Weight " , " " , 4 ) ; firstWeightTile . addActionListener ( x -> selectWeightDocketType ( ) ) ; aPanel . add ( firstWeightTile ) ; JButton secondWeightTile = createTile ( " Second ▁ Weight " , " " , 4 ) ; secondWeightTile . addActionListener ( x -> selectSecondWeight ( ) ) ; aPanel . add ( secondWeightTile ) ; JButton logOnTile = createTile ( " Log ▁ On " , " " , 4 ) ; logOnTile . addActionListener ( x -> { SwingUtilities . invokeLater ( ( ) -> { new LogOnFrame ( ) ; frame . dispose ( ) ; } ) ; } ) ; aPanel . add ( logOnTile ) ; JButton registrationTile = createTile ( " Registration " , " " , 4 ) ; registrationTile . addActionListener ( x -> { SwingUtilities . invokeLater ( ( ) -> { new RegistrationFrame ( ) ; frame . dispose ( ) ; } ) ; } ) ; aPanel . add ( registrationTile ) ; addComponent ( aPanel ) ; }
stephencullinan/WeighBridge | public void selectWeightDocketType ( ) { ArrayList < DocketType > docketTypesObjects = aWeighBridge . getDocketTypes ( ) ; JPanel docketTypesPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; docketTypesObjects . forEach ( z -> { JButton aDocketType = createTile ( z . toString ( ) , " " , docketTypesObjects . size ( ) ) ; aDocketType . addActionListener ( ( y ) -> { aWeighBridge . setSelectedDocketType ( z ) ; selectConsignee ( ) ; } ) ; docketTypesPanel . add ( aDocketType ) ; } ) ; addComponent ( docketTypesPanel ) ; }
stephencullinan/WeighBridge | public void selectConsignee ( ) { JPanel consigneesPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; ArrayList < Consignee > consigneesObjects = new ArrayList < > ( ) ; final int numberOfConsignees = consigneesObjects . size ( ) ; if ( aWeighBridge . getSelectedDocketType ( ) . getCode ( ) == 1 ) { consigneesObjects = aWeighBridge . getConsignees ( " suppliers " ) ; JButton addNewSupplierTile = createTile ( " Add ▁ New ▁ Supplier " , " " , numberOfConsignees + 1 ) ; addNewSupplierTile . addActionListener ( ( x ) -> addNewSupplier ( ) ) ; consigneesPanel . add ( addNewSupplierTile ) ; } else if ( aWeighBridge . getSelectedDocketType ( ) . getCode ( ) == 2 ) { consigneesObjects = aWeighBridge . getConsignees ( " customers " ) ; JButton addNewCustomerTile = createTile ( " Add ▁ New ▁ Customer " , " " , numberOfConsignees + 1 ) ; addNewCustomerTile . addActionListener ( ( x ) -> addNewCustomer ( ) ) ; consigneesPanel . add ( addNewCustomerTile ) ; } consigneesObjects . forEach ( x -> { JButton aConsignee = createTile ( x . toString ( ) , " " , numberOfConsignees + 1 ) ; aConsignee . addActionListener ( y -> { aWeighBridge . setSelectedConsignee ( x ) ; selectDriver ( ) ; } ) ; consigneesPanel . add ( aConsignee ) ; } ) ; addComponent ( consigneesPanel ) ; }
stephencullinan/WeighBridge | public void selectDriver ( ) { ArrayList < Driver > driverObjects = aWeighBridge . getDrivers ( ) ; JPanel driversPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; JButton createNewDriver = createTile ( " Add ▁ New ▁ Driver " , " " , driverObjects . size ( ) + 1 ) ; createNewDriver . addActionListener ( ( x ) -> addNewDriver ( ) ) ; driversPanel . add ( createNewDriver ) ; driverObjects . forEach ( x -> { JButton aDriver = createTile ( x . toString ( ) , " users / " + x . getCode ( ) + " . png " , driverObjects . size ( ) + 1 ) ; aDriver . addActionListener ( ( y ) -> { aWeighBridge . setSelectedDriver ( x ) ; selectCommodity ( ) ; } ) ; driversPanel . add ( aDriver ) ; } ) ; addComponent ( driversPanel ) ; }
stephencullinan/WeighBridge | public void addNewDriver ( ) { JPanel addNewDriversPanel = new JPanel ( new GridLayout ( 5 , 1 ) ) ; JTextField firstName = createTextField ( " " ) ; JTextField lastName = createTextField ( " " ) ; JButton addDriverButton = createButton ( " Add ▁ New ▁ Driver " ) ; addDriverButton . addActionListener ( ( x ) -> { if ( firstName . getText ( ) . length ( ) > 1 && lastName . getText ( ) . length ( ) > 1 ) { Driver aDriver = aWeighBridge . insertNewDriver ( firstName . getText ( ) , lastName . getText ( ) ) ; JPanel obtainPhotoPanel = new JPanel ( new GridLayout ( 2 , 1 ) ) ; JProgressBar obtainPhotoProgressBar = createProgressBar ( 0 , 100 ) ; JLabel obtainPhotoLabel = createLabel ( " Initialising ▁ The ▁ WebCam " ) ; obtainPhotoPanel . add ( obtainPhotoLabel ) ; obtainPhotoPanel . add ( obtainPhotoProgressBar ) ; addComponent ( obtainPhotoPanel ) ; ObtainPhoto obtainPhoto = new ObtainPhoto ( obtainPhotoLabel , obtainPhotoProgressBar , " images / users / " + aDriver . getCode ( ) + " . png " ) ; obtainPhoto . execute ( ) ; obtainPhoto . addPropertyChangeListener ( y -> { if ( y . getNewValue ( ) . toString ( ) . contains ( " DONE " ) && y . getPropertyName ( ) . toString ( ) . contains ( " state " ) ) selectCommodity ( ) ; } ) ; } else addNewDriver ( ) ; } ) ; addNewDriversPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ first ▁ name ▁ of ▁ the ▁ driver " ) ) ; addNewDriversPanel . add ( firstName ) ; addNewDriversPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ last ▁ name ▁ of ▁ the ▁ driver " ) ) ; addNewDriversPanel . add ( lastName ) ; addNewDriversPanel . add ( addDriverButton ) ; addComponent ( addNewDriversPanel ) ; }
stephencullinan/WeighBridge | public void addNewCommodity ( ) { JPanel addNewCommodityPanel = new JPanel ( new GridLayout ( 3 , 1 ) ) ; JTextField commodity = createTextField ( " " ) ; JButton addCommodityButton = createButton ( " Add ▁ New ▁ Entities . Commodity " ) ; addCommodityButton . addActionListener ( ( x ) -> { if ( commodity . getText ( ) . length ( ) > 1 ) { aWeighBridge . insertNewCommodity ( commodity . getText ( ) ) ; selectFirstWeight ( ) ; } else addNewCommodity ( ) ; } ) ; addNewCommodityPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ name ▁ of ▁ the ▁ commodity " ) ) ; addNewCommodityPanel . add ( commodity ) ; addNewCommodityPanel . add ( addCommodityButton ) ; addComponent ( addNewCommodityPanel ) ; }
stephencullinan/WeighBridge | public void addNewCustomer ( ) { JPanel addNewCustomerPanel = new JPanel ( new GridLayout ( 5 , 1 ) ) ; JTextField customerFirstName = createTextField ( " " ) ; JTextField customerLastName = createTextField ( " " ) ; JButton addCustomerButton = createButton ( " Add ▁ New ▁ Customer " ) ; addCustomerButton . addActionListener ( ( x ) -> { if ( customerFirstName . getText ( ) . length ( ) > 1 && customerLastName . getText ( ) . length ( ) > 1 ) { aWeighBridge . insertNewConsignee ( customerFirstName . getText ( ) , customerLastName . getText ( ) , " customers " ) ; selectDriver ( ) ; } else addNewCustomer ( ) ; } ) ; addNewCustomerPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ first ▁ name ▁ of ▁ the ▁ customer " ) ) ; addNewCustomerPanel . add ( customerFirstName ) ; addNewCustomerPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ last ▁ name ▁ of ▁ the ▁ customer " ) ) ; addNewCustomerPanel . add ( customerLastName ) ; addNewCustomerPanel . add ( addCustomerButton ) ; addComponent ( addNewCustomerPanel ) ; }
stephencullinan/WeighBridge | public void addNewSupplier ( ) { JPanel addNewSupplierPanel = new JPanel ( new GridLayout ( 5 , 1 ) ) ; JTextField supplierFirstName = createTextField ( " " ) ; JTextField supplierLastName = createTextField ( " " ) ; JButton addSupplierButton = createButton ( " Add ▁ New ▁ Supplier " ) ; addSupplierButton . addActionListener ( ( x ) -> { if ( supplierFirstName . getText ( ) . length ( ) > 1 && supplierLastName . getText ( ) . length ( ) > 1 ) { aWeighBridge . insertNewConsignee ( supplierFirstName . getText ( ) , supplierLastName . getText ( ) , " suppliers " ) ; selectDriver ( ) ; } else addNewSupplier ( ) ; } ) ; addNewSupplierPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ first ▁ name ▁ of ▁ the ▁ supplier " ) ) ; addNewSupplierPanel . add ( supplierFirstName ) ; addNewSupplierPanel . add ( createLabel ( " Please ▁ enter ▁ the ▁ last ▁ name ▁ of ▁ the ▁ supplier " ) ) ; addNewSupplierPanel . add ( supplierLastName ) ; addNewSupplierPanel . add ( addSupplierButton ) ; addComponent ( addNewSupplierPanel ) ; }
stephencullinan/WeighBridge | public void selectCommodity ( ) { ArrayList < Commodity > commoditiesObjects = aWeighBridge . getCommodities ( ) ; JPanel commoditiesPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; JButton addNewCommodityButton = createTile ( " Add ▁ New ▁ Commodity " , " " , commoditiesObjects . size ( ) + 1 ) ; addNewCommodityButton . addActionListener ( x -> addNewCommodity ( ) ) ; commoditiesPanel . add ( addNewCommodityButton ) ; commoditiesObjects . forEach ( x -> { JButton aCommodity = createTile ( x . getTitle ( ) , " commodities / " + x . getCode ( ) , commoditiesObjects . size ( ) + 1 ) ; aCommodity . addActionListener ( y -> { aWeighBridge . setSelectedCommodity ( x ) ; selectFirstWeight ( ) ; } ) ; commoditiesPanel . add ( aCommodity ) ; } ) ; addComponent ( commoditiesPanel ) ; }
stephencullinan/WeighBridge | public void selectFirstWeight ( ) { aWeighBridge . insertNewFirstWeight ( ) ; selectWeightType ( ) ; }
stephencullinan/WeighBridge | public void selectSecondWeight ( ) { ArrayList < ArrayList < String > > firstWeightsAwaitingSecondWeight = aWeighBridge . getDocketsAwaitingSecondWeightment ( ) ; JPanel secondWeightsPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; firstWeightsAwaitingSecondWeight . forEach ( x -> { aWeighBridge . retrieveParametersForSelectedSecondWeight ( x . get ( 1 ) , x . get ( 2 ) , x . get ( 5 ) , x . get ( 6 ) ) ; JButton currentButton = createTile ( aWeighBridge . getCaptionTitle ( ) , " " , firstWeightsAwaitingSecondWeight . size ( ) ) ; currentButton . addActionListener ( ( y ) -> { aWeighBridge . insertNewSecondWeight ( x . get ( 0 ) , x . get ( 3 ) , x . get ( 4 ) ) ; aWeighBridge . generateReport ( ) ; selectDocket ( ) ; } ) ; secondWeightsPanel . add ( currentButton ) ; } ) ; if ( firstWeightsAwaitingSecondWeight . size ( ) == 0 ) { JButton returnToMainMenuTile = createTile ( " Return ▁ To ▁ Main ▁ Menu " , " " , 1 ) ; returnToMainMenuTile . addActionListener ( ( ( y ) -> selectWeightType ( ) ) ) ; secondWeightsPanel . add ( returnToMainMenuTile ) ; } addComponent ( secondWeightsPanel ) ; }
stephencullinan/WeighBridge | public void selectDocket ( ) { JPanel processDocketPanel = new JPanel ( new GridLayout ( 0 , 3 ) ) ; JButton printDocketTile = createTile ( " Print ▁ Docket " , " " , 3 ) ; printDocketTile . addActionListener ( ( x ) -> { aWeighBridge . printReport ( ) ; selectWeightType ( ) ; } ) ; JButton emailDocketTile = createTile ( " Email ▁ Docket " , " " , 3 ) ; emailDocketTile . addActionListener ( ( x ) -> { JPanel emailDocketPanel = new JPanel ( new GridLayout ( 3 , 1 ) ) ; JTextField emailAddressTextField = createTextField ( " " ) ; emailDocketPanel . add ( createLabel ( " Please ▁ enter ▁ your ▁ email ▁ address " ) ) ; emailDocketPanel . add ( emailAddressTextField ) ; JButton emailDocketButton = createButton ( " Submit ▁ Your ▁ Email ▁ Address " ) ; emailDocketButton . addActionListener ( ( y ) -> { if ( emailAddressTextField . getText ( ) . length ( ) > 2 ) { aWeighBridge . emailReport ( emailAddressTextField . getText ( ) ) ; selectWeightType ( ) ; } } ) ; emailDocketPanel . add ( emailDocketButton ) ; addComponent ( emailDocketPanel ) ; } ) ; JButton returnToMainMenuTile = createTile ( " Return ▁ To ▁ Main ▁ Menu " , " " , 3 ) ; returnToMainMenuTile . addActionListener ( ( x ) -> { selectWeightType ( ) ; } ) ; processDocketPanel . add ( printDocketTile ) ; processDocketPanel . add ( emailDocketTile ) ; processDocketPanel . add ( returnToMainMenuTile ) ; addComponent ( processDocketPanel ) ; }
stephencullinan/WeighBridge | private void addComponent ( JComponent newComponent ) { if ( component != null ) frame . remove ( component ) ; component = newComponent ; frame . add ( component ) ; frame . invalidate ( ) ; frame . revalidate ( ) ; }
stephencullinan/WeighBridge | private void refreshComponent ( ) { frame . invalidate ( ) ; frame . revalidate ( ) ; }
facebook/presto | @ Inject public TestingAccessControlManager ( TransactionManager transactionManager ) { super ( transactionManager ) ; setSystemAccessControl ( AllowAllSystemAccessControl . NAME , ImmutableMap . of ( ) ) ; }
facebook/presto | public void deny ( TestingPrivilege ... deniedPrivileges ) { Collections . addAll ( this . denyPrivileges , deniedPrivileges ) ; }
facebook/presto | public void reset ( ) { denyPrivileges . clear ( ) ; }
facebook/presto | @ Override public void checkCanSetUser ( Identity identity , AccessControlContext context , Optional < Principal > principal , String userName ) { if ( shouldDenyPrivilege ( userName , userName , SET_USER ) ) { denySetUser ( principal , userName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetUser ( identity , context , principal , userName ) ; } }
facebook/presto | @ Override public void checkCanCreateSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , CREATE_SCHEMA ) ) { denyCreateSchema ( schemaName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateSchema ( transactionId , identity , context , schemaName ) ; } }
facebook/presto | @ Override public void checkCanDropSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , DROP_SCHEMA ) ) { denyDropSchema ( schemaName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropSchema ( transactionId , identity , context , schemaName ) ; } }
facebook/presto | @ Override public void checkCanRenameSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName , String newSchemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , RENAME_SCHEMA ) ) { denyRenameSchema ( schemaName . toString ( ) , newSchemaName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanRenameSchema ( transactionId , identity , context , schemaName , newSchemaName ) ; } }
facebook/presto | @ Override public void checkCanCreateTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , CREATE_TABLE ) ) { denyCreateTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanDropTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DROP_TABLE ) ) { denyDropTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanRenameTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , QualifiedObjectName newTableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , RENAME_TABLE ) ) { denyRenameTable ( tableName . toString ( ) , newTableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanRenameTable ( transactionId , identity , context , tableName , newTableName ) ; } }
facebook/presto | @ Override public void checkCanAddColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , ADD_COLUMN ) ) { denyAddColumn ( tableName . toString ( ) ) ; } super . checkCanAddColumns ( transactionId , identity , context , tableName ) ; }
facebook/presto | @ Override public void checkCanDropColumn ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DROP_COLUMN ) ) { denyDropColumn ( tableName . toString ( ) ) ; } super . checkCanDropColumn ( transactionId , identity , context , tableName ) ; }
facebook/presto | @ Override public void checkCanRenameColumn ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , RENAME_COLUMN ) ) { denyRenameColumn ( tableName . toString ( ) ) ; } super . checkCanRenameColumn ( transactionId , identity , context , tableName ) ; }
facebook/presto | @ Override public void checkCanInsertIntoTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , INSERT_TABLE ) ) { denyInsertTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanInsertIntoTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanDeleteFromTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DELETE_TABLE ) ) { denyDeleteTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDeleteFromTable ( transactionId , identity , context , tableName ) ; } }
facebook/presto | @ Override public void checkCanCreateView ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName viewName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , viewName . getObjectName ( ) , CREATE_VIEW ) ) { denyCreateView ( viewName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateView ( transactionId , identity , context , viewName ) ; } }
facebook/presto | @ Override public void checkCanDropView ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName viewName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , viewName . getObjectName ( ) , DROP_VIEW ) ) { denyDropView ( viewName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropView ( transactionId , identity , context , viewName ) ; } }
facebook/presto | @ Override public void checkCanSetSystemSessionProperty ( Identity identity , AccessControlContext context , String propertyName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , propertyName , SET_SESSION ) ) { denySetSystemSessionProperty ( propertyName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetSystemSessionProperty ( identity , context , propertyName ) ; } }
facebook/presto | @ Override public void checkCanCreateViewWithSelectFromColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , Set < String > columnNames ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , CREATE_VIEW_WITH_SELECT_COLUMNS ) ) { denyCreateViewWithSelect ( tableName . toString ( ) , identity ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateViewWithSelectFromColumns ( transactionId , identity , context , tableName , columnNames ) ; } }
facebook/presto | @ Override public void checkCanSetCatalogSessionProperty ( TransactionId transactionId , Identity identity , AccessControlContext context , String catalogName , String propertyName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , catalogName + " . " + propertyName , SET_SESSION ) ) { denySetCatalogSessionProperty ( catalogName , propertyName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetCatalogSessionProperty ( transactionId , identity , context , catalogName , propertyName ) ; } }
facebook/presto | @ Override public void checkCanSelectFromColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , Set < String > columns ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , SELECT_COLUMN ) ) { denySelectColumns ( tableName . toString ( ) , columns ) ; } for ( String column : columns ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , column , SELECT_COLUMN ) ) { denySelectColumns ( tableName . toString ( ) , columns ) ; } } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSelectFromColumns ( transactionId , identity , context , tableName , columns ) ; } }
facebook/presto | private boolean shouldDenyPrivilege ( String userName , String entityName , TestingPrivilegeType type ) { TestingPrivilege testPrivilege = privilege ( userName , entityName , type ) ; for ( TestingPrivilege denyPrivilege : denyPrivileges ) { if ( denyPrivilege . matches ( testPrivilege ) ) { return true ; } } return false ; }
facebook/presto | private TestingPrivilege ( Optional < String > userName , String entityName , TestingPrivilegeType type ) { this . userName = requireNonNull ( userName , " userName ▁ is ▁ null " ) ; this . entityName = requireNonNull ( entityName , " entityName ▁ is ▁ null " ) ; this . type = requireNonNull ( type , " type ▁ is ▁ null " ) ; }
facebook/presto | public boolean matches ( TestingPrivilege testPrivilege ) { return userName . map ( name -> testPrivilege . userName . get ( ) . equals ( name ) ) . orElse ( true ) && entityName . equals ( testPrivilege . entityName ) && type == testPrivilege . type ; }
facebook/presto | @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TestingPrivilege that = ( TestingPrivilege ) o ; return Objects . equals ( entityName , that . entityName ) && Objects . equals ( type , that . type ) ; }
facebook/presto | @ Override public int hashCode ( ) { return Objects . hash ( entityName , type ) ; }
facebook/presto | @ Override public String toString ( ) { return toStringHelper ( this ) . add ( " userName " , userName ) . add ( " entityName " , entityName ) . add ( " type " , type ) . toString ( ) ; }
KiviMao/kivi | if ( unpackNested ) { nestedEntry . setComment ( " UNPACK : 0000000000000000000000000000000000000000" ) ; }
markzhai/InterestingTitleBar | catch ( Throwable e ) { e . printStackTrace ( ) ; }
11xor6/presto | private DynamicFiltersTestUtil ( ) { }
Dhandapani/gluster-ovirt | @ Override public UICommand getUpdateCommand ( ) { return privateUpdateCommand ; }
Dhandapani/gluster-ovirt | private void setUpdateCommand ( UICommand value ) { privateUpdateCommand = value ; }
Dhandapani/gluster-ovirt | public UICommand getLoginAllCommand ( ) { return privateLoginAllCommand ; }
Dhandapani/gluster-ovirt | private void setLoginAllCommand ( UICommand value ) { privateLoginAllCommand = value ; }
Dhandapani/gluster-ovirt | public UICommand getDiscoverTargetsCommand ( ) { return privateDiscoverTargetsCommand ; }
Dhandapani/gluster-ovirt | private void setDiscoverTargetsCommand ( UICommand value ) { privateDiscoverTargetsCommand = value ; }
Dhandapani/gluster-ovirt | @ Override public StorageModel getContainer ( ) { return privateContainer ; }
Dhandapani/gluster-ovirt | @ Override public void setContainer ( StorageModel value ) { privateContainer = value ; }
Dhandapani/gluster-ovirt | @ Override public StorageDomainType getRole ( ) { return privateRole ; }
Dhandapani/gluster-ovirt | @ Override public void setRole ( StorageDomainType value ) { privateRole = value ; }
Dhandapani/gluster-ovirt | public EntityModel getAddress ( ) { return privateAddress ; }
Dhandapani/gluster-ovirt | private void setAddress ( EntityModel value ) { privateAddress = value ; }
Dhandapani/gluster-ovirt | public EntityModel getPort ( ) { return privatePort ; }
Dhandapani/gluster-ovirt | private void setPort ( EntityModel value ) { privatePort = value ; }
Dhandapani/gluster-ovirt | public EntityModel getUserName ( ) { return privateUserName ; }
Dhandapani/gluster-ovirt | private void setUserName ( EntityModel value ) { privateUserName = value ; }
Dhandapani/gluster-ovirt | public EntityModel getPassword ( ) { return privatePassword ; }
Dhandapani/gluster-ovirt | private void setPassword ( EntityModel value ) { privatePassword = value ; }
Dhandapani/gluster-ovirt | public EntityModel getUseUserAuth ( ) { return privateUseUserAuth ; }
Dhandapani/gluster-ovirt | private void setUseUserAuth ( EntityModel value ) { privateUseUserAuth = value ; }
Dhandapani/gluster-ovirt | public boolean getProposeDiscoverTargets ( ) { return proposeDiscoverTargets ; }
Dhandapani/gluster-ovirt | public void setProposeDiscoverTargets ( boolean value ) { if ( proposeDiscoverTargets != value ) { proposeDiscoverTargets = value ; OnPropertyChanged ( new PropertyChangedEventArgs ( " ProposeDiscoverTargets " ) ) ; } }
Dhandapani/gluster-ovirt | public boolean getIsAllLunsSelected ( ) { return isAllLunsSelected ; }
Dhandapani/gluster-ovirt | public void setIsAllLunsSelected ( boolean value ) { if ( isAllLunsSelected != value ) { isAllLunsSelected = value ; IsAllLunsSelectedChanged ( ) ; OnPropertyChanged ( new PropertyChangedEventArgs ( " IsAllLunsSelected " ) ) ; } }
Dhandapani/gluster-ovirt | protected SanStorageModelBase ( ) { setUpdateCommand ( new UICommand ( " Update " , this ) ) ; UICommand tempVar = new UICommand ( " LoginAll " , this ) ; tempVar . setIsExecutionAllowed ( false ) ; setLoginAllCommand ( tempVar ) ; setDiscoverTargetsCommand ( new UICommand ( " DiscoverTargets " , this ) ) ; setAddress ( new EntityModel ( ) ) ; EntityModel tempVar2 = new EntityModel ( ) ; tempVar2 . setEntity ( "3260" ) ; setPort ( tempVar2 ) ; setUserName ( new EntityModel ( ) ) ; setPassword ( new EntityModel ( ) ) ; EntityModel tempVar3 = new EntityModel ( ) ; tempVar3 . setEntity ( false ) ; setUseUserAuth ( tempVar3 ) ; getUseUserAuth ( ) . getEntityChangedEvent ( ) . addListener ( this ) ; UpdateUserAuthFields ( ) ; }
Dhandapani/gluster-ovirt | @ Override public void eventRaised ( Event ev , Object sender , EventArgs args ) { super . eventRaised ( ev , sender , args ) ; if ( ev . equals ( SanTargetModel . LoggedInEventDefinition ) ) { SanTargetModel_LoggedIn ( sender , args ) ; } else if ( ev . equals ( EntityChangedEventDefinition ) ) { UseUserAuth_EntityChanged ( sender , args ) ; } }
Dhandapani/gluster-ovirt | private void postLogin ( FrontendActionAsyncResult result ) { VdcReturnValueBase returnValue = result . getReturnValue ( ) ; SanStorageModelBase sanStorageModel = ( SanStorageModelBase ) result . getState ( ) ; SanTargetModel sanTargetModel = sanStorageModel . targetsToConnect . remove ( 0 ) ; boolean success = returnValue != null && returnValue . getSucceeded ( ) ; if ( success ) { sanTargetModel . setIsLoggedIn ( true ) ; sanTargetModel . getLoginCommand ( ) . setIsExecutionAllowed ( false ) ; } if ( sanStorageModel . targetsToConnect . isEmpty ( ) ) { sanStorageModel . getContainer ( ) . StopProgress ( ) ; sanStorageModel . UpdateInternal ( ) ; } }
Dhandapani/gluster-ovirt | private void connectTargets ( ) { VDS host = ( VDS ) getContainer ( ) . getHost ( ) . getSelectedItem ( ) ; if ( host == null ) { return ; } java . util . ArrayList < VdcActionType > actionTypes = new java . util . ArrayList < VdcActionType > ( ) ; ArrayList < VdcActionParametersBase > paramerters = new ArrayList < VdcActionParametersBase > ( ) ; ArrayList < IFrontendActionAsyncCallback > callbacks = new ArrayList < IFrontendActionAsyncCallback > ( ) ; IFrontendActionAsyncCallback loginCallback = new IFrontendActionAsyncCallback ( ) { @ Override public void Executed ( FrontendActionAsyncResult result ) { SanStorageModelBase sanStorageModel = ( SanStorageModelBase ) result . getState ( ) ; sanStorageModel . postLogin ( result ) ; } } ; for ( int i = 0 ; i < targetsToConnect . size ( ) ; i ++ ) { SanTargetModel model = targetsToConnect . get ( i ) ; storage_server_connections connection = new storage_server_connections ( ) ; connection . setportal ( "0" ) ; connection . setstorage_type ( StorageType . ISCSI ) ; connection . setuser_name ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getUserName ( ) . getEntity ( ) : " " ) ; connection . setpassword ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getPassword ( ) . getEntity ( ) : " " ) ; connection . setiqn ( model . getName ( ) ) ; connection . setconnection ( model . getAddress ( ) ) ; connection . setport ( String . valueOf ( model . getPort ( ) ) ) ; actionTypes . add ( VdcActionType . ConnectStorageToVds ) ; paramerters . add ( new StorageServerConnectionParametersBase ( connection , host . getId ( ) ) ) ; callbacks . add ( loginCallback ) ; } getContainer ( ) . StartProgress ( null ) ; Frontend . RunMultipleActions ( actionTypes , paramerters , callbacks , null , this ) ; }
Dhandapani/gluster-ovirt | private void SanTargetModel_LoggedIn ( Object sender , EventArgs args ) { SanTargetModel model = ( SanTargetModel ) sender ; targetsToConnect = new ArrayList < SanTargetModel > ( ) ; targetsToConnect . add ( model ) ; connectTargets ( ) ; }
Dhandapani/gluster-ovirt | private void LoginAll ( ) { java . util . List < SanTargetModel > items = ( java . util . List < SanTargetModel > ) getItems ( ) ; targetsToConnect = new ArrayList < SanTargetModel > ( ) ; for ( SanTargetModel item : items ) { if ( ! item . getIsLoggedIn ( ) ) { targetsToConnect . add ( item ) ; } } connectTargets ( ) ; }
Dhandapani/gluster-ovirt | private void DiscoverTargets ( ) { if ( getContainer ( ) . getProgress ( ) != null ) { return ; } if ( ! ValidateDiscoverTargetFields ( ) ) { return ; } VDS host = ( VDS ) getContainer ( ) . getHost ( ) . getSelectedItem ( ) ; storage_server_connections tempVar = new storage_server_connections ( ) ; tempVar . setconnection ( ( ( String ) getAddress ( ) . getEntity ( ) ) . trim ( ) ) ; tempVar . setport ( ( ( String ) getPort ( ) . getEntity ( ) ) . trim ( ) ) ; tempVar . setportal ( "0" ) ; tempVar . setstorage_type ( StorageType . ISCSI ) ; tempVar . setuser_name ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getUserName ( ) . getEntity ( ) : " " ) ; tempVar . setpassword ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ? ( String ) getPassword ( ) . getEntity ( ) : " " ) ; DiscoverSendTargetsQueryParameters parameters = new DiscoverSendTargetsQueryParameters ( host . getId ( ) , tempVar ) ; setMessage ( null ) ; getContainer ( ) . StartProgress ( null ) ; Frontend . RunQuery ( VdcQueryType . DiscoverSendTargets , parameters , new AsyncQuery ( this , new INewAsyncCallback ( ) { @ Override public void OnSuccess ( Object target , Object returnValue ) { SanStorageModelBase model = ( SanStorageModelBase ) target ; Object result = ( ( VdcQueryReturnValue ) returnValue ) . getReturnValue ( ) ; model . PostDiscoverTargetsInternal ( result != null ? ( java . util . ArrayList < storage_server_connections > ) result : new java . util . ArrayList < storage_server_connections > ( ) ) ; } } , true ) ) ; }
Dhandapani/gluster-ovirt | private void PostDiscoverTargetsInternal ( java . util . ArrayList < storage_server_connections > items ) { java . util . ArrayList < SanTargetModel > newItems = new java . util . ArrayList < SanTargetModel > ( ) ; for ( storage_server_connections a : items ) { SanTargetModel tempVar = new SanTargetModel ( ) ; tempVar . setAddress ( a . getconnection ( ) ) ; tempVar . setPort ( a . getport ( ) ) ; tempVar . setName ( a . getiqn ( ) ) ; tempVar . setLuns ( new ObservableCollection < LunModel > ( ) ) ; SanTargetModel model = tempVar ; model . getLoggedInEvent ( ) . addListener ( this ) ; newItems . add ( model ) ; } if ( items . isEmpty ( ) ) { setMessage ( " No ▁ new ▁ devices ▁ were ▁ found . ▁ This ▁ may ▁ be ▁ due ▁ to ▁ either : ▁ incorrect ▁ multipath ▁ configuration ▁ on ▁ the ▁ Host ▁ or ▁ wrong ▁ address ▁ of ▁ the ▁ iscsi ▁ target ▁ or ▁ a ▁ failure ▁ to ▁ authenticate ▁ on ▁ the ▁ target ▁ device . ▁ Please ▁ consult ▁ your ▁ Storage ▁ Administrator . " ) ; } PostDiscoverTargets ( newItems ) ; }
Dhandapani/gluster-ovirt | protected void PostDiscoverTargets ( java . util . ArrayList < SanTargetModel > newItems ) { }
Dhandapani/gluster-ovirt | private boolean ValidateDiscoverTargetFields ( ) { getContainer ( ) . getHost ( ) . ValidateSelectedItem ( new NotEmptyValidation [ ] { new NotEmptyValidation ( ) } ) ; getAddress ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) } ) ; IntegerValidation tempVar = new IntegerValidation ( ) ; tempVar . setMinimum ( 0 ) ; tempVar . setMaximum ( 65535 ) ; getPort ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) , tempVar } ) ; if ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ) { getUserName ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) } ) ; getPassword ( ) . ValidateEntity ( new IValidation [ ] { new NotEmptyValidation ( ) } ) ; } return getContainer ( ) . getHost ( ) . getIsValid ( ) && getAddress ( ) . getIsValid ( ) && getPort ( ) . getIsValid ( ) && getUserName ( ) . getIsValid ( ) && getPassword ( ) . getIsValid ( ) ; }
Dhandapani/gluster-ovirt | @ Override public boolean Validate ( ) { return true ; }
Dhandapani/gluster-ovirt | private void UseUserAuth_EntityChanged ( Object sender , EventArgs args ) { UpdateUserAuthFields ( ) ; }
Dhandapani/gluster-ovirt | private void UpdateUserAuthFields ( ) { getUserName ( ) . setIsValid ( true ) ; getUserName ( ) . setIsChangable ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ) ; getPassword ( ) . setIsValid ( true ) ; getPassword ( ) . setIsChangable ( ( Boolean ) getUseUserAuth ( ) . getEntity ( ) ) ; }
Dhandapani/gluster-ovirt | @ Override public void ExecuteCommand ( UICommand command ) { super . ExecuteCommand ( command ) ; if ( command == getUpdateCommand ( ) ) { Update ( ) ; } else if ( command == getLoginAllCommand ( ) ) { LoginAll ( ) ; } else if ( command == getDiscoverTargetsCommand ( ) ) { DiscoverTargets ( ) ; } }
Dhandapani/gluster-ovirt | protected void Update ( ) { UpdateInternal ( ) ; setIsValid ( true ) ; }
Dhandapani/gluster-ovirt | protected void UpdateInternal ( ) { }
Dhandapani/gluster-ovirt | protected void UpdateLoginAllAvailability ( ) { java . util . List < SanTargetModel > items = ( java . util . List < SanTargetModel > ) getItems ( ) ; boolean allow = false ; for ( SanTargetModel item : items ) { if ( ! item . getIsLoggedIn ( ) ) { allow = true ; break ; } } getLoginAllCommand ( ) . setIsExecutionAllowed ( allow ) ; }
Dhandapani/gluster-ovirt | protected void IsAllLunsSelectedChanged ( ) { }
keycloak/keycloak-quickstarts | public PropertyFileUserStorageProvider ( KeycloakSession session , ComponentModel model , Properties properties ) { this . session = session ; this . model = model ; this . properties = properties ; }
keycloak/keycloak-quickstarts | @ Override public UserModel getUserByUsername ( String username , RealmModel realm ) { UserModel adapter = loadedUsers . get ( username ) ; if ( adapter == null ) { String password = properties . getProperty ( username ) ; if ( password != null ) { adapter = createAdapter ( realm , username ) ; loadedUsers . put ( username , adapter ) ; } } return adapter ; }
keycloak/keycloak-quickstarts | protected UserModel createAdapter ( RealmModel realm , String username ) { return new AbstractUserAdapter ( session , realm , model ) { @ Override public String getUsername ( ) { return username ; } } ; }
keycloak/keycloak-quickstarts | @ Override public UserModel getUserById ( String id , RealmModel realm ) { StorageId storageId = new StorageId ( id ) ; String username = storageId . getExternalId ( ) ; return getUserByUsername ( username , realm ) ; }
keycloak/keycloak-quickstarts | @ Override public UserModel getUserByEmail ( String email , RealmModel realm ) { return null ; }
keycloak/keycloak-quickstarts | @ Override public boolean isConfiguredFor ( RealmModel realm , UserModel user , String credentialType ) { String password = properties . getProperty ( user . getUsername ( ) ) ; return credentialType . equals ( CredentialModel . PASSWORD ) && password != null ; }
keycloak/keycloak-quickstarts | @ Override public boolean supportsCredentialType ( String credentialType ) { return credentialType . equals ( CredentialModel . PASSWORD ) ; }
keycloak/keycloak-quickstarts | @ Override public boolean isValid ( RealmModel realm , UserModel user , CredentialInput input ) { if ( ! supportsCredentialType ( input . getType ( ) ) || ! ( input instanceof UserCredentialModel ) ) return false ; UserCredentialModel cred = ( UserCredentialModel ) input ; String password = properties . getProperty ( user . getUsername ( ) ) ; if ( password == null ) return false ; return password . equals ( cred . getValue ( ) ) ; }
keycloak/keycloak-quickstarts | @ Override public boolean updateCredential ( RealmModel realm , UserModel user , CredentialInput input ) { if ( input . getType ( ) . equals ( CredentialModel . PASSWORD ) ) throw new ReadOnlyException ( " user ▁ is ▁ read ▁ only ▁ for ▁ this ▁ update " ) ; return false ; }
keycloak/keycloak-quickstarts | @ Override public void disableCredentialType ( RealmModel realm , UserModel user , String credentialType ) { }
keycloak/keycloak-quickstarts | @ Override public Set < String > getDisableableCredentialTypes ( RealmModel realm , UserModel user ) { return Collections . EMPTY_SET ; }
keycloak/keycloak-quickstarts | @ Override public void close ( ) { }
FAU-Inf2/spongycastle | public OCSPResponse ( OCSPResponseStatus responseStatus , ResponseBytes responseBytes ) { this . responseStatus = responseStatus ; this . responseBytes = responseBytes ; }
FAU-Inf2/spongycastle | private OCSPResponse ( ASN1Sequence seq ) { responseStatus = OCSPResponseStatus . getInstance ( seq . getObjectAt ( 0 ) ) ; if ( seq . size ( ) == 2 ) { responseBytes = ResponseBytes . getInstance ( ( ASN1TaggedObject ) seq . getObjectAt ( 1 ) , true ) ; } }
FAU-Inf2/spongycastle | public OCSPResponseStatus getResponseStatus ( ) { return responseStatus ; }
FAU-Inf2/spongycastle | public ResponseBytes getResponseBytes ( ) { return responseBytes ; }
FAU-Inf2/spongycastle | public ASN1Primitive toASN1Primitive ( ) { ASN1EncodableVector v = new ASN1EncodableVector ( ) ; v . add ( responseStatus ) ; if ( responseBytes != null ) { v . add ( new DERTaggedObject ( true , 0 , responseBytes ) ) ; } return new DERSequence ( v ) ; }
JIGAsoftSTP/NICON | public AdministracaoBean ( ) { listaCategorias = rhd . listaCategorias ( ) ; }
JIGAsoftSTP/NICON | @ PostConstruct public void init ( ) { listArticles = this . rhd . listaArtigos ( ) ; funcionarios = this . rhd . employeers ( ) ; categories = this . rhd . categoryNames ( ) ; }
JIGAsoftSTP/NICON | public Artigo getArtigo ( ) { return ( artigo == null ) ? artigo = new Artigo ( ) : artigo ; }
JIGAsoftSTP/NICON | public void setArtigo ( Artigo artigo ) { this . artigo = artigo ; }
JIGAsoftSTP/NICON | public List < ComoBox > getFuncionarios ( ) { return funcionarios ; }
JIGAsoftSTP/NICON | public Artigo getArtigoSelecionado ( ) { return ( artigoSelecionado == null ) ? artigoSelecionado = new Artigo ( ) : artigoSelecionado ; }
JIGAsoftSTP/NICON | public void setArtigoSelecionado ( Artigo artigoSelecionado ) { this . artigoSelecionado = artigoSelecionado ; }
JIGAsoftSTP/NICON | public List < ComoBox > getCategories ( ) { return categories ; }
JIGAsoftSTP/NICON | public List < Artigo > getListArticles ( ) { return listArticles ; }
JIGAsoftSTP/NICON | public void newArticle ( ) { if ( SessionUtil . obterValor ( Funcionario . SESSION_NAME ) != null ) { artigo . setId ( null ) ; if ( Integer . valueOf ( artigo . getQuantidade ( ) ) > 0 ) { String result = this . rhd . registarArtigo ( artigo ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { if ( Integer . valueOf ( artigo . getQuantidade ( ) ) > 0 ) { result = this . rhd . registrarItemArtigo ( artigo , Integer . valueOf ( result . split ( " ; " ) [ 1 ] ) , 1 ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { Message . addInfoMsg ( " Artigo ▁ " + artigo . getNomeArtigo ( ) + " ▁ registrado ▁ com ▁ sucesso ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } else { RequestContext . getCurrentInstance ( ) . execute ( " nomeArtigoExiste ( ) " ) ; Message . addErrorMsg ( result . split ( " ; " ) [ 1 ] , " articleForm " , " articleGrowl " ) ; } } else { Message . addInfoMsg ( " Artigo ▁ " + artigo . getNomeArtigo ( ) + " ▁ registrado ▁ com ▁ sucesso ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } } else { RequestContext . getCurrentInstance ( ) . execute ( " nomeArtigoExiste ( ) " ) ; Message . addErrorMsg ( result . split ( " ; " ) [ 1 ] , " articleForm " , " articleGrowl " ) ; } } else { Message . addWarningMsg ( " Quantidade ▁ de ▁ artigo ▁ deve ▁ ser ▁ superior ▁ a ▁ zero ( 0 ) ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " ▁ $ ( ' . artigoQuantidade ' ) . focus ( ) " ) ; } } }
JIGAsoftSTP/NICON | public void changeQuantity ( String param , Artigo a ) { stock = param ; artigoSelecionado = a ; artigo = artigoSelecionado ; if ( param . equals ( " Retirar ▁ Artigo ▁ do ▁ Stock " ) && Integer . valueOf ( artigoSelecionado . getQuantidade ( ) ) == 0 ) Message . addWarningMsg ( " Nenhuma ▁ quantidade ▁ existente ▁ no ▁ stock ! " , " articleForm " , " articleGrowl " ) ; else if ( param . equals ( " Editar ▁ Artigo ▁ do ▁ Stock " ) ) { artigo . setNomeArtigo ( artigoSelecionado . getConsumivel ( ) ) ; artigo . setCategoria ( artigoSelecionado . getCategoria ( ) ) ; Validacao . atualizar ( " articleForm " , " articleName " , " articleCategory " ) ; RequestContext . getCurrentInstance ( ) . execute ( " articleChangeQuantity ( ' " + param + " ' , ' " + null + " ' ) " ) ; } else { artigo . setNomeArtigo ( artigoSelecionado . getConsumivel ( ) ) ; artigo . setCategoria ( artigoSelecionado . getCategoria ( ) ) ; Validacao . atualizar ( " articleForm " , " articleName " , " articleCategory " ) ; RequestContext . getCurrentInstance ( ) . execute ( " articleChangeQuantity ( ' " + param + " ' , ' " + artigo . getQuantidade ( ) + " ' ) " ) ; } }
JIGAsoftSTP/NICON | public String getId ( String nome ) { for ( ComoBox cb : this . categories ) { if ( cb . getValue ( ) . equals ( nome ) ) { return cb . getId ( ) ; } } return null ; }
JIGAsoftSTP/NICON | public String getIdArtigo ( String nomeArtigo ) { String id = null ; for ( Artigo cb : this . listArticles ) { if ( cb . getConsumivel ( ) . equals ( nomeArtigo ) ) { id = cb . getCodigo ( ) ; break ; } } return id ; }
JIGAsoftSTP/NICON | public void operation ( ) { String type , articleName ; FacesContext facesContext = FacesContext . getCurrentInstance ( ) ; artigo . setNomeArtigo ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " nome " ) ) ; artigo . setCategoria ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " categoria " ) ) ; artigo . setQuantidade ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " quantidade " ) ) ; artigo . setFuncionarioResponsavel ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " funcionario " ) ) ; artigo . setFornecedor ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " fornecedor " ) ) ; artigo . setDescricao ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " obs " ) ) ; artigo . setAdicionarRemover ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " adicionarRemover " ) ) ; artigo . setQuantidadeStock ( Integer . valueOf ( facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " stockQuantidade " ) ) ) ; articleName = facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " nomeArtigoAtualizar " ) ; type = facesContext . getExternalContext ( ) . getRequestParameterMap ( ) . get ( " typeOperation " ) ; switch ( type ) { case " novo " : this . newArticle ( ) ; break ; case " alterar ▁ quantidade " : alterarQuantidade ( ) ; break ; default : alterarNomeCategoriaArtigo ( articleName ) ; break ; } }
JIGAsoftSTP/NICON | public void atualizarTabelaArtigo ( ) { listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; }
JIGAsoftSTP/NICON | private void alterarNomeCategoriaArtigo ( String articleName ) { artigo . setId ( Integer . valueOf ( getIdArtigo ( articleName ) ) ) ; String result = rhd . registarArtigo ( artigo ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { listArticles . clear ( ) ; Message . addInfoMsg ( " Artigo ▁ atualizado ▁ com ▁ sucesso " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } else Message . addErrorMsg ( result . split ( " ; " ) [ 1 ] , " articleForm " , " articleGrowl " ) ; }
JIGAsoftSTP/NICON | public void alterarQuantidade ( ) { if ( SessionUtil . obterValor ( Funcionario . SESSION_NAME ) != null ) { if ( Integer . valueOf ( artigo . getQuantidade ( ) ) > 0 ) { if ( ! artigo . getAdicionarRemover ( ) . equals ( " Adicionar ▁ Artigo ▁ ao ▁ Stock " ) && ( Integer . valueOf ( artigo . getQuantidade ( ) ) > artigo . getQuantidadeStock ( ) ) ) Message . addErrorMsg ( " Quantidade ▁ de ▁ consumível ▁ superior ▁ ao ▁ existente ▁ do ▁ stock ! " , " articleForm " , " articleGrowl " ) ; else { String result = this . rhd . registrarItemArtigo ( artigo , Integer . valueOf ( getIdArtigo ( artigo . getNomeArtigo ( ) ) ) , ( ( artigo . getAdicionarRemover ( ) . equals ( " Adicionar ▁ Artigo ▁ ao ▁ Stock " ) ? 1 : 2 ) ) ) ; if ( result . split ( " ; " ) [ 0 ] . equals ( " true " ) ) { Message . addInfoMsg ( " Quantidade ▁ do ▁ artigo ▁ " + artigo . getNomeArtigo ( ) + " ▁ alterado ▁ no ▁ stock ! " , " articleForm " , " articleGrowl " ) ; RequestContext . getCurrentInstance ( ) . execute ( " artigoRegistrado ( ) " ) ; listArticles = this . rhd . listaArtigos ( ) ; Validacao . atualizar ( " formArticleTable " , " artigoTabela " ) ; } } } else { RequestContext . getCurrentInstance ( ) . execute ( " artigoQuantidadeBorda ( ) " ) ; Message . addWarningMsg ( " Quantidade ▁ deve ▁ ser ▁ superior ▁ a ▁ zero ( 0 ) ! " , " articleForm " , " articleGrowl " ) ; } } }
JIGAsoftSTP/NICON | public List < String > getListaCategorias ( ) { return listaCategorias ; }
JIGAsoftSTP/NICON | public List < String > completarListaCategoria ( String info ) { System . out . println ( " info ▁ categoria ▁ " + info ) ; listaCategorias . set ( 0 , info ) ; return likeStart ( this . listaCategorias , info ) ; }
eriqadams/computer-graphics | private EXTUnpackSubimage ( ) { }
angcyo/RLibrary | public DefaultDatabaseOpenHelper ( final Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; }
angcyo/RLibrary | @ Override public void onOpen ( SQLiteDatabase db ) { super . onOpen ( db ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) { setWriteAheadLoggingEnabled ( true ) ; } else if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { db . enableWriteAheadLogging ( ) ; } }
angcyo/RLibrary | @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ( ▁ " + FileDownloadModel . ID + " ▁ INTEGER ▁ PRIMARY ▁ KEY , ▁ " + FileDownloadModel . URL + " ▁ VARCHAR , ▁ " + FileDownloadModel . PATH + " ▁ VARCHAR , ▁ " + FileDownloadModel . STATUS + " ▁ TINYINT ( 7 ) , ▁ " + FileDownloadModel . SOFAR + " ▁ INTEGER , ▁ " + FileDownloadModel . TOTAL + " ▁ INTEGER , ▁ " + FileDownloadModel . ERR_MSG + " ▁ VARCHAR , ▁ " + FileDownloadModel . ETAG + " ▁ VARCHAR , ▁ " + FileDownloadModel . PATH_AS_DIRECTORY + " ▁ TINYINT ( 1 ) ▁ DEFAULT ▁ 0 , ▁ " + FileDownloadModel . FILENAME + " ▁ VARCHAR , ▁ " + FileDownloadModel . CONNECTION_COUNT + " ▁ INTEGER ▁ DEFAULT ▁ 1" + " ) " ) ; db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . CONNECTION_TABLE_NAME + " ( ▁ " + ConnectionModel . ID + " ▁ INTEGER , ▁ " + ConnectionModel . INDEX + " ▁ INTEGER , ▁ " + ConnectionModel . START_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . CURRENT_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . END_OFFSET + " ▁ INTEGER , ▁ " + " PRIMARY ▁ KEY ▁ ( ▁ " + ConnectionModel . ID + " , ▁ " + ConnectionModel . INDEX + " ▁ ) " + " ) " ) ; }
angcyo/RLibrary | @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { if ( oldVersion < 2 ) { String addAsDirectoryColumn = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . PATH_AS_DIRECTORY + " ▁ TINYINT ( 1 ) ▁ DEFAULT ▁ 0" ; db . execSQL ( addAsDirectoryColumn ) ; String addFilenameColumn = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . FILENAME + " ▁ VARCHAR " ; db . execSQL ( addFilenameColumn ) ; } if ( oldVersion < 3 ) { final String addConnectionCount = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . CONNECTION_COUNT + " ▁ INTEGER ▁ DEFAULT ▁ 1" ; db . execSQL ( addConnectionCount ) ; db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . CONNECTION_TABLE_NAME + " ( ▁ " + ConnectionModel . ID + " ▁ INTEGER , ▁ " + ConnectionModel . INDEX + " ▁ INTEGER , ▁ " + ConnectionModel . START_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . CURRENT_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . END_OFFSET + " ▁ INTEGER , ▁ " + " PRIMARY ▁ KEY ▁ ( ▁ " + ConnectionModel . ID + " , ▁ " + ConnectionModel . INDEX + " ▁ ) " + " ) " ) ; } }
AlexMinsk/camunda-bpm-platform | ) public void testStart ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; ProcessInstance processInstance ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; }
AlexMinsk/camunda-bpm-platform | protected void verifyVariables ( String caseInstanceId , List < VariableInstance > result ) { for ( VariableInstance variable : result ) { assertEquals ( caseInstanceId , variable . getCaseExecutionId ( ) ) ; assertEquals ( caseInstanceId , variable . getCaseInstanceId ( ) ) ; if ( variable . getName ( ) . equals ( " aVariableName " ) ) { assertEquals ( " aVariableName " , variable . getName ( ) ) ; assertEquals ( " abc " , variable . getValue ( ) ) ; } else if ( variable . getName ( ) . equals ( " anotherVariableName " ) ) { assertEquals ( " anotherVariableName " , variable . getName ( ) ) ; assertEquals ( 999 , variable . getValue ( ) ) ; } else { fail ( " Unexpected ▁ variable : ▁ " + variable . getName ( ) ) ; } } }
AlexMinsk/camunda-bpm-platform | ) public void testManualStart ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . manualStart ( ) ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartWithVariables ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; Map < String , Object > variables = new HashMap < String , Object > ( ) ; variables . put ( " aVariableName " , " abc " ) ; variables . put ( " anotherVariableName " , 999 ) ; caseService . withCaseExecution ( processTaskId ) . setVariables ( variables ) . manualStart ( ) ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; List < VariableInstance > result = runtimeService . createVariableInstanceQuery ( ) . list ( ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 2 , result . size ( ) ) ; verifyVariables ( caseInstanceId , result ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartWithLocalVariable ( ) { String caseInstanceId = createCaseInstance ( DEFINITION_KEY ) . getId ( ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . setVariableLocal ( " aVariableName " , " abc " ) . setVariableLocal ( " anotherVariableName " , 999 ) . manualStart ( ) ; processInstance = queryProcessInstance ( ) ; assertNotNull ( processInstance ) ; assertEquals ( caseInstanceId , processInstance . getCaseInstanceId ( ) ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; List < VariableInstance > result = runtimeService . createVariableInstanceQuery ( ) . list ( ) ; assertFalse ( result . isEmpty ( ) ) ; assertEquals ( 2 , result . size ( ) ) ; for ( VariableInstance variable : result ) { assertEquals ( processTaskId , variable . getCaseExecutionId ( ) ) ; assertEquals ( caseInstanceId , variable . getCaseInstanceId ( ) ) ; if ( variable . getName ( ) . equals ( " aVariableName " ) ) { assertEquals ( " aVariableName " , variable . getName ( ) ) ; assertEquals ( " abc " , variable . getValue ( ) ) ; } else if ( variable . getName ( ) . equals ( " anotherVariableName " ) ) { assertEquals ( " anotherVariableName " , variable . getName ( ) ) ; assertEquals ( 999 , variable . getValue ( ) ) ; } else { fail ( " Unexpected ▁ variable : ▁ " + variable . getName ( ) ) ; } } }
AlexMinsk/camunda-bpm-platform | ) public void testReenableAnEnabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; try { caseService . withCaseExecution ( processTaskId ) . reenable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ re - enable ▁ an ▁ enabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testReenableADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; caseService . withCaseExecution ( processTaskId ) . reenable ( ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isEnabled ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testReenableAnActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . reenable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ re - enable ▁ an ▁ active ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testDisableAnEnabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; ProcessInstance processInstance = queryProcessInstance ( ) ; assertNull ( processInstance ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isDisabled ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testDisableADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; try { caseService . withCaseExecution ( processTaskId ) . disable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ disable ▁ a ▁ already ▁ disabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testDisableAnActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . disable ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ disable ▁ an ▁ active ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartOfADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; try { caseService . withCaseExecution ( processTaskId ) . manualStart ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ start ▁ a ▁ disabled ▁ process ▁ task ▁ manually . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testManualStartOfAnActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . manualStart ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ start ▁ an ▁ already ▁ active ▁ process ▁ task ▁ manually . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testComplete ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . complete ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ complete ▁ a ▁ process ▁ task , ▁ while ▁ the ▁ process ▁ instance ▁ is ▁ still ▁ running . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testCompleteProcessInstanceShouldCompleteProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; String taskId = queryTask ( ) . getId ( ) ; taskService . complete ( taskId ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; CaseInstance caseInstance = caseService . createCaseInstanceQuery ( ) . singleResult ( ) ; assertNotNull ( caseInstance ) ; assertTrue ( caseInstance . isCompleted ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testDisableShouldCompleteCaseInstance ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; CaseInstance caseInstance = caseService . createCaseInstanceQuery ( ) . completed ( ) . singleResult ( ) ; assertNotNull ( caseInstance ) ; assertTrue ( caseInstance . isCompleted ( ) ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testCompleteAnEnabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . complete ( ) ; fail ( " Should ▁ not ▁ be ▁ able ▁ to ▁ complete ▁ an ▁ enabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testCompleteADisabledProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; caseService . withCaseExecution ( processTaskId ) . disable ( ) ; try { caseService . withCaseExecution ( processTaskId ) . complete ( ) ; fail ( " Should ▁ not ▁ be ▁ able ▁ to ▁ complete ▁ a ▁ disabled ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testClose ( ) { createCaseInstance ( DEFINITION_KEY ) ; String processTaskId = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) . getId ( ) ; try { caseService . withCaseExecution ( processTaskId ) . close ( ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ close ▁ a ▁ process ▁ task . " ) ; } catch ( NotAllowedException e ) { } }
AlexMinsk/camunda-bpm-platform | ) public void testTerminate ( ) { createCaseInstance ( DEFINITION_KEY ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; caseService . withCaseExecution ( processTask . getId ( ) ) . terminate ( ) ; processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testTerminateNonFluent ( ) { createCaseInstance ( DEFINITION_KEY ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isActive ( ) ) ; caseService . terminateCaseExecution ( processTask . getId ( ) ) ; processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertNull ( processTask ) ; }
AlexMinsk/camunda-bpm-platform | ) public void testTerminateNonActiveProcessTask ( ) { createCaseInstance ( DEFINITION_KEY ) ; CaseExecution processTask = queryCaseExecutionByActivityId ( PROCESS_TASK_KEY ) ; assertTrue ( processTask . isEnabled ( ) ) ; try { caseService . terminateCaseExecution ( processTask . getId ( ) ) ; fail ( " It ▁ should ▁ not ▁ be ▁ possible ▁ to ▁ terminate ▁ a ▁ task . " ) ; } catch ( NotAllowedException e ) { boolean result = e . getMessage ( ) . contains ( " The ▁ case ▁ execution ▁ must ▁ be ▁ in ▁ state ▁ ' active ' ▁ to ▁ terminate " ) ; assertTrue ( result ) ; } }
AlexMinsk/camunda-bpm-platform | protected CaseInstance createCaseInstance ( String caseDefinitionKey ) { return caseService . withCaseDefinitionByKey ( caseDefinitionKey ) . create ( ) ; }
AlexMinsk/camunda-bpm-platform | protected CaseExecution queryCaseExecutionByActivityId ( String activityId ) { return caseService . createCaseExecutionQuery ( ) . activityId ( activityId ) . singleResult ( ) ; }
AlexMinsk/camunda-bpm-platform | protected ProcessInstance queryProcessInstance ( ) { return runtimeService . createProcessInstanceQuery ( ) . singleResult ( ) ; }
AlexMinsk/camunda-bpm-platform | protected Task queryTask ( ) { return taskService . createTaskQuery ( ) . singleResult ( ) ; }
Nexmo/nexmo-java-sdk | public String getDialingPrefix ( ) { return dialingPrefix ; }
Nexmo/nexmo-java-sdk | public BigDecimal getDefaultPrice ( ) { return defaultPrice ; }
Nexmo/nexmo-java-sdk | public String getCurrency ( ) { return currency ; }
Nexmo/nexmo-java-sdk | public Country getCountry ( ) { return country ; }
Nexmo/nexmo-java-sdk | public List < Network > getNetworks ( ) { return networks ; }
griffon/griffon-hibernate4-plugin | @ Override public void handle ( AnnotationValues < Hibernate4Aware > annotation , Annotation source , EclipseNode annotationNode ) { EclipseType type = EclipseType . typeOf ( annotationNode , source ) ; if ( type . isAnnotation ( ) || type . isInterface ( ) ) { annotationNode . addError ( canBeUsedOnClassAndEnumOnly ( Hibernate4Aware . class ) ) ; return ; } EclipseUtil . addInterface ( type . get ( ) , Hibernate4AwareConstants . MYBATIS_CONTRIBUTION_HANDLER_TYPE , source ) ; handler . addHibernate4ProviderField ( type ) ; handler . addHibernate4ProviderAccessors ( type ) ; handler . addHibernate4ContributionMethods ( type ) ; type . editor ( ) . rebuild ( ) ; }
ThinkKeep/EvilsLive | public CameraOld ( Context context ) { this . context = context ; }
ThinkKeep/EvilsLive | Size ( int width , int height ) { this . width = width ; this . height = height ; }
ThinkKeep/EvilsLive | private Camera . PreviewCallback callback = new Camera . PreviewCallback ( ) { @ Override public void onPreviewFrame ( byte [ ] data , Camera camera ) { int width = camera . getParameters ( ) . getPreviewSize ( ) . width ; int height = camera . getParameters ( ) . getPreviewSize ( ) . height ; int index = JniManager . getInstance ( ) . getIndex ( ) ; if ( index >= 0 ) { EvilsLiveJni . sendStream ( index , data , width , height ) ; } if ( listener != null ) { listener . onPreviewFrameListener ( data , width , height ) ; } } }
ThinkKeep/EvilsLive | @ Override public CameraSupport open ( ) { cameraId = getCameraId ( ) ; this . camera = Camera . open ( cameraId ) ; startPreview ( ) ; return this ; }
ThinkKeep/EvilsLive | private int getCameraId ( ) { int cameraId = Defines . EcameraFacing . CAMERA_FACING_FRONT . index ; if ( config != null ) { Defines . EcameraFacing cameraFacing = config . getCameraFacing ( ) ; if ( cameraFacing != null ) { cameraId = cameraFacing . index ; } } return cameraId ; }
ThinkKeep/EvilsLive | @ Override public int startPushStream ( ) { if ( config != null && this . camera != null ) { String streamUrl = config . getStreamUrl ( ) ; if ( streamUrlValid ( streamUrl ) ) { JniManager . getInstance ( ) . startPushStream ( size , streamUrl . getBytes ( ) , 15 , 512 ) ; camera . setPreviewCallback ( callback ) ; isStartStream = true ; new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( isStartStream ) { int index = JniManager . getInstance ( ) . getIndex ( ) ; try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } JniManager . getInstance ( ) . setStreamConfig ( index , size . width , size . height , 15 , 512 , true ) ; } } } ) . start ( ) ; } } return 0 ; }
ThinkKeep/EvilsLive | private boolean streamUrlValid ( String streamUrl ) { return streamUrl != null && ! ( " " . equals ( streamUrl ) ) ; }
ThinkKeep/EvilsLive | @ Override public int getOrientation ( final int cameraId ) { Camera . CameraInfo info = new Camera . CameraInfo ( ) ; Camera . getCameraInfo ( cameraId , info ) ; return info . orientation ; }
ThinkKeep/EvilsLive | @ Override public void setDisplayPreview ( SurfaceView surfaceView ) { this . surfaceView = surfaceView ; }
ThinkKeep/EvilsLive | private void startPreview ( ) { try { Camera . Parameters parameters = setParameters ( ) ; camera . setParameters ( parameters ) ; if ( surfaceView != null ) { final Camera . Size previewSize = parameters . getPreviewSize ( ) ; runMainHanlder ( previewSize ) ; SurfaceHolder surfaceHolder = surfaceView . getHolder ( ) ; camera . setPreviewDisplay ( surfaceHolder ) ; } camera . startPreview ( ) ; } catch ( Exception e ) { Log . e ( TAG , " startPreview : ▁ error " + Log . getStackTraceString ( e ) ) ; } }
ThinkKeep/EvilsLive | private void runMainHanlder ( final Camera . Size previewSize ) { Handler mainHanlder = new Handler ( Looper . getMainLooper ( ) ) ; mainHanlder . post ( new Runnable ( ) { @ Override public void run ( ) { adjustViewSize ( previewSize ) ; } } ) ; }
ThinkKeep/EvilsLive | private void adjustViewSize ( Camera . Size cameraSize ) { Point previewSize = convertSizeToLandscapeOrientation ( new Point ( surfaceView . getWidth ( ) , surfaceView . getHeight ( ) ) ) ; float cameraRatio = ( ( float ) cameraSize . width ) / cameraSize . height ; float screenRatio = ( ( float ) previewSize . x ) / previewSize . y ; if ( screenRatio > cameraRatio ) { setViewSize ( ( int ) ( previewSize . y * cameraRatio ) , previewSize . y ) ; } else { setViewSize ( previewSize . x , ( int ) ( previewSize . x / cameraRatio ) ) ; } }
ThinkKeep/EvilsLive | private Point convertSizeToLandscapeOrientation ( Point size ) { if ( getDisplayOrientation ( ) % 180 == 0 ) { return size ; } else { return new Point ( size . y , size . x ) ; } }
ThinkKeep/EvilsLive | private void setViewSize ( int width , int height ) { ViewGroup . LayoutParams layoutParams = surfaceView . getLayoutParams ( ) ; int tmpWidth ; int tmpHeight ; if ( getDisplayOrientation ( ) % 180 == 0 ) { tmpWidth = width ; tmpHeight = height ; } else { tmpWidth = height ; tmpHeight = width ; } if ( mShouldScaleToFill ) { int parentWidth = ( ( View ) surfaceView . getParent ( ) ) . getWidth ( ) ; int parentHeight = ( ( View ) surfaceView . getParent ( ) ) . getHeight ( ) ; float ratioWidth = ( float ) parentWidth / ( float ) tmpWidth ; float ratioHeight = ( float ) parentHeight / ( float ) tmpHeight ; float compensation ; if ( ratioWidth > ratioHeight ) { compensation = ratioWidth ; } else { compensation = ratioHeight ; } tmpWidth = Math . round ( tmpWidth * compensation ) ; tmpHeight = Math . round ( tmpHeight * compensation ) ; } layoutParams . width = tmpWidth ; layoutParams . height = tmpHeight ; surfaceView . setLayoutParams ( layoutParams ) ; }
ThinkKeep/EvilsLive | public int getDisplayOrientation ( ) { if ( camera == null ) { return 0 ; } Camera . CameraInfo info = new Camera . CameraInfo ( ) ; if ( cameraId == - 1 ) { Camera . getCameraInfo ( Camera . CameraInfo . CAMERA_FACING_BACK , info ) ; } else { Camera . getCameraInfo ( cameraId , info ) ; } WindowManager wm = ( WindowManager ) context . getSystemService ( Context . WINDOW_SERVICE ) ; Display display = wm . getDefaultDisplay ( ) ; int rotation = display . getRotation ( ) ; int degrees = 0 ; switch ( rotation ) { case Surface . ROTATION_0 : degrees = 0 ; break ; case Surface . ROTATION_90 : degrees = 90 ; break ; case Surface . ROTATION_180 : degrees = 180 ; break ; case Surface . ROTATION_270 : degrees = 270 ; break ; } int result ; if ( info . facing == Camera . CameraInfo . CAMERA_FACING_FRONT ) { result = ( info . orientation + degrees ) % 360 ; result = ( 360 - result ) % 360 ; } else { result = ( info . orientation - degrees + 360 ) % 360 ; } return result ; }
ThinkKeep/EvilsLive | @ NonNull private Camera . Parameters setParameters ( ) { Camera . Parameters parameters = camera . getParameters ( ) ; size = choosePreviewSize ( parameters ) ; setPreviewFrameRate ( parameters ) ; camera . setDisplayOrientation ( 90 ) ; parameters . setRotation ( 90 ) ; parameters . setPreviewSize ( size . width , size . height ) ; int imageFormat = chooseImageFormat ( parameters ) ; parameters . setPreviewFormat ( imageFormat ) ; return parameters ; }
ThinkKeep/EvilsLive | private void setPreviewFrameRate ( Camera . Parameters parameters ) { int frameRate = Defines . DEFAULT_FRAME_RATE ; if ( config != null ) { int previewFrameRate = config . getPreviewFrameRate ( ) ; if ( previewFrameRate >= 0 ) { frameRate = previewFrameRate ; } } parameters . setPreviewFpsRange ( 25 * 1000 , 25 * 1000 ) ; }
ThinkKeep/EvilsLive | private int chooseImageFormat ( Camera . Parameters parameters ) { if ( config == null ) { return DEFAULT_IMAGE_FORMAT ; } List < Integer > list = parameters . getSupportedPreviewFormats ( ) ; for ( Integer val : list ) { LogUtils . e ( TAG , " hujd ▁ startPreview : ▁ val : ▁ " + val ) ; if ( val == config . getImageFormat ( ) ) { return val ; } } return DEFAULT_IMAGE_FORMAT ; }
ThinkKeep/EvilsLive | private Size choosePreviewSize ( Camera . Parameters parameters ) { Size size = null ; if ( config == null ) { return new Size ( Defines . EvideoResolution . E640P . getWidth ( ) , Defines . EvideoResolution . E640P . getHeight ( ) ) ; } Defines . EvideoResolution videoResolution = config . getVideoResolution ( ) ; if ( videoResolution != null ) { int width = videoResolution . getWidth ( ) ; int height = videoResolution . getHeight ( ) ; List < Camera . Size > sizeList = parameters . getSupportedPreviewSizes ( ) ; Camera . Size optimalSize = getOptimalSize ( sizeList , Math . max ( width , height ) , Math . min ( width , height ) ) ; size = new Size ( optimalSize . width , optimalSize . height ) ; } if ( size == null ) { size = new Size ( Defines . EvideoResolution . E640P . getWidth ( ) , Defines . EvideoResolution . E640P . getHeight ( ) ) ; } return size ; }
ThinkKeep/EvilsLive | private Camera . Size getOptimalSize ( @ NonNull List < Camera . Size > sizes , int width , int height ) { final double ASPECT_TOLERANCE = 0.1 ; assert ( width == 0 ) ; double targetRatio = ( double ) height / width ; Camera . Size optimalSize = null ; double minDiff = Double . MIN_VALUE ; int targetHeight = height ; for ( Camera . Size size : sizes ) { double ratio = ( double ) size . height / size . width ; if ( Math . abs ( ratio - targetRatio ) > ASPECT_TOLERANCE ) { continue ; } if ( Math . abs ( size . height - targetHeight ) < minDiff ) { optimalSize = size ; minDiff = Math . abs ( size . height - targetHeight ) ; } } if ( optimalSize == null ) { minDiff = Double . MIN_VALUE ; for ( Camera . Size size : sizes ) { if ( Math . abs ( size . height - targetHeight ) < minDiff ) { optimalSize = size ; minDiff = Math . abs ( size . height - targetHeight ) ; } } } return optimalSize ; }
ThinkKeep/EvilsLive | @ Override public void setOnPreviewFrameListener ( OnPreviewFrameListener listener ) { this . listener = listener ; }
ThinkKeep/EvilsLive | @ Override public void setStreamConfig ( EvilsLiveStreamerConfig config ) { this . config = config ; }
ThinkKeep/EvilsLive | @ Override public void stopPushStream ( ) { isStartStream = false ; if ( camera == null ) { return ; } int index = JniManager . getInstance ( ) . getIndex ( ) ; if ( index >= 0 ) { JniManager . getInstance ( ) . stopPushStream ( index ) ; } camera . setPreviewCallback ( null ) ; }
ThinkKeep/EvilsLive | @ Override public void close ( ) { if ( camera == null ) { return ; } camera . stopPreview ( ) ; camera . release ( ) ; camera = null ; }
wwz-zackjo/testgit | " , method = RequestMethod . GET ) public String detailBoard ( ModelMap modelMap , @ PathVariable ( " contentId " ) int contentId , @ RequestParam ( required = true , value = " pageNum " , defaultValue = "1" ) int pageNum ) { Board board = boardService . findContentWithComment ( contentId ) ; boolean isExist = true ; if ( board == null ) { isExist = false ; } else { boardService . modifyContentHit ( contentId ) ; board . setHit ( board . getHit ( ) + 1 ) ; } return " / boardDetail " ; }
mpmunasinghe/product-ei | @ BeforeClass ( alwaysRun = true ) public void setEnvironment ( ) throws Exception { init ( TestUserMode . SUPER_TENANT_ADMIN ) ; serverManager = new ServerConfigurationManager ( context ) ; serverManager . copyToComponentDropins ( new File ( getClass ( ) . getResource ( JRUBY_JAR_LOCATION + JRUBY_JAR ) . toURI ( ) ) ) ; Thread . sleep ( 3000 ) ; serverManager . restartGracefully ( ) ; init ( TestUserMode . SUPER_TENANT_ADMIN ) ; }
mpmunasinghe/product-ei | , description = " Script ▁ Mediator ▁ - Run ▁ a ▁ Ruby ▁ script ▁ with ▁ the ▁ mediator " ) public void testJRubyScriptMediation ( ) throws Exception { loadSampleESBConfiguration ( 353 ) ; OMElement response = axis2Client . sendCustomQuoteRequest ( getMainSequenceURL ( ) , null , " WSO2" ) ; assertNotNull ( response , " Fault ▁ response ▁ message ▁ null " ) ; assertNotNull ( response . getQName ( ) . getLocalPart ( ) , " Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getQName ( ) . getLocalPart ( ) , " CheckPriceResponse " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " ▁ Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " Code " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstChildWithName ( new QName ( " http : // services . samples / xsd " , " Price " ) ) , " Fault ▁ response ▁ null ▁ localpart " ) ; }
mpmunasinghe/product-ei | , description = " Script ▁ Mediator ▁ - Run ▁ a ▁ Ruby ▁ script ▁ with ▁ the ▁ mediator " + " ▁ - Script ▁ from ▁ gov ▁ registry " ) public void testJRubyScriptMediationScriptFromGovRegistry ( ) throws Exception { Thread . sleep ( 5000 ) ; updateESBRegistry ( File . separator + " artifacts " + File . separator + " ESB " + File . separator + " synapseconfig " + File . separator + " WSO2Registry . xml " ) ; enableDebugLogging ( ) ; uploadResourcesToConfigRegistry ( ) ; Thread . sleep ( 3000 ) ; loadESBConfigurationFromClasspath ( " / artifacts / ESB / synapseconfig / script _ mediator / retrieve _ script _ from _ gov _ reg _ mediation . xml " ) ; OMElement response = axis2Client . sendCustomQuoteRequest ( getMainSequenceURL ( ) , null , " WSO2" ) ; assertNotNull ( response , " Fault ▁ response ▁ message ▁ null " ) ; assertNotNull ( response . getQName ( ) . getLocalPart ( ) , " Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getQName ( ) . getLocalPart ( ) , " CheckPriceResponse " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " ▁ Fault ▁ response ▁ null ▁ localpart " ) ; assertEquals ( response . getFirstElement ( ) . getQName ( ) . getLocalPart ( ) , " Code " , " Fault ▁ localpart ▁ mismatched " ) ; assertNotNull ( response . getFirstChildWithName ( new QName ( " http : // services . samples / xsd " , " Price " ) ) , " Fault ▁ response ▁ null ▁ localpart " ) ; clearUploadedResource ( ) ; }
mpmunasinghe/product-ei | @ AfterClass ( alwaysRun = true ) public void destroy ( ) throws Exception { try { deleteSequence ( " main " ) ; cleanup ( ) ; Thread . sleep ( 5000 ) ; } finally { serverManager . restartGracefully ( ) ; Thread . sleep ( 3000 ) ; serverManager . removeFromComponentDropins ( JRUBY_JAR ) ; serverManager = null ; } }
mpmunasinghe/product-ei | private void uploadResourcesToConfigRegistry ( ) throws Exception { ResourceAdminServiceClient resourceAdminServiceStub = new ResourceAdminServiceClient ( contextUrls . getBackEndUrl ( ) , context . getContextTenant ( ) . getContextUser ( ) . getUserName ( ) , context . getContextTenant ( ) . getContextUser ( ) . getPassword ( ) ) ; resourceAdminServiceStub . deleteResource ( " / _ system / governance / script " ) ; resourceAdminServiceStub . addCollection ( " / _ system / governance / " , " script " , " " , " Contains ▁ test ▁ script ▁ files " ) ; resourceAdminServiceStub . addResource ( " / _ system / governance / script / stockquoteTransform . rb " , " application / xml " , " script ▁ files " , new DataHandler ( new URL ( " file : // / " + getClass ( ) . getResource ( " / artifacts / ESB / mediatorconfig / script / stockquoteTransform . rb " ) . getPath ( ) ) ) ) ; }
mpmunasinghe/product-ei | private void enableDebugLogging ( ) throws Exception { LoggingAdminClient logAdminClient = new LoggingAdminClient ( contextUrls . getBackEndUrl ( ) , getSessionCookie ( ) ) ; logAdminClient . updateLoggerData ( " org . apache . synapse " , " DEBUG " , true , false ) ; }
luoqii/ApkLauncher_legacy | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . chronometer ) ; Button button ; mChronometer = ( Chronometer ) findViewById ( R . id . chronometer ) ; button = ( Button ) findViewById ( R . id . start ) ; button . setOnClickListener ( mStartListener ) ; button = ( Button ) findViewById ( R . id . stop ) ; button . setOnClickListener ( mStopListener ) ; button = ( Button ) findViewById ( R . id . reset ) ; button . setOnClickListener ( mResetListener ) ; button = ( Button ) findViewById ( R . id . set_format ) ; button . setOnClickListener ( mSetFormatListener ) ; button = ( Button ) findViewById ( R . id . clear_format ) ; button . setOnClickListener ( mClearFormatListener ) ; }
luoqii/ApkLauncher_legacy | View . OnClickListener mStartListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . start ( ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mStopListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . stop ( ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mResetListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . setBase ( SystemClock . elapsedRealtime ( ) ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mSetFormatListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . setFormat ( " Formatted ▁ time ▁ ( % s ) " ) ; } }
luoqii/ApkLauncher_legacy | View . OnClickListener mClearFormatListener = new OnClickListener ( ) { public void onClick ( View v ) { mChronometer . setFormat ( null ) ; } }
cdeange/WKRPTapp | public VolleyLibrary ( final Context context ) { mContext = context ; mController = new OperationController ( context ) ; mQueue = Volley . newRequestQueue ( mContext ) ; mQueue . start ( ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . Get get ( final String url , final OperationParams . Get params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; mQueue . add ( new StringRequest ( Request . Method . GET , url , future , future ) ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . Get ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . Post post ( final String url , final OperationParams . Post params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; mQueue . add ( new PostFileRequest ( url , future , future , mContext . getResources ( ) . openRawResource ( params . rawResourceId ) ) ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . Post ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . MultipartPost postMultipart ( final String url , final OperationParams . Multipart params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; final MultipartRequest request = new MultipartRequest ( url , future , future ) ; request . addStringPart ( params . formField . first , params . formField . second ) ; request . addFilePart ( params . fileName , mContext . getResources ( ) . openRawResource ( params . rawResourceId ) ) ; mQueue . add ( request ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . MultipartPost ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats . ImageGet loadImage ( final String url , final OperationParams . Image params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < Bitmap > future = RequestFuture . newFuture ( ) ; mQueue . add ( new ImageRequest ( url , future , 0 , 0 , Bitmap . Config . ARGB_8888 , future ) ) ; final Bitmap response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . ImageGet ( mController , response ) ; }
cdeange/WKRPTapp | @ Override public ResponseStats batchGet ( final String ... urls ) throws IOException { mController . reset ( ) ; mController . start ( ) ; mCountdown = new Countdown ( ) ; for ( final String url : urls ) { final CountdownListener < String > listener = new CountdownListener < String > ( mCountdown ) ; mQueue . add ( new StringRequest ( Request . Method . GET , url , listener , listener ) ) ; mCountdown . await ( ) ; } mCountdown . blockUntilDone ( ) ; mController . stop ( ) ; return new ResponseStats ( mController ) ; }
7a6/medium | @ Bean public DataSource dataSource ( ) throws PropertyVetoException { ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource ( ) ; comboPooledDataSource . setDriverClass ( " com . mysql . jdbc . Driver " ) ; comboPooledDataSource . setJdbcUrl ( " jdbc : mysql : // localhost / test " ) ; comboPooledDataSource . setUser ( " dbuser " ) ; comboPooledDataSource . setPassword ( " password " ) ; return null ; }
eschwert/ontop | public void generateTriples ( ) throws Exception { OBDADataFactory fac = OBDADataFactoryImpl . getInstance ( ) ; OBDAModel obdaModel = fac . getOBDAModel ( ) ; ModelIOManager ioManager = new ModelIOManager ( obdaModel ) ; ioManager . load ( inputFile ) ; try ( OWLAPIMaterializer materializer = new OWLAPIMaterializer ( obdaModel , false ) ) { long numberOfTriples = materializer . getTriplesCount ( ) ; System . out . println ( " Generated ▁ triples : ▁ " + numberOfTriples ) ; QuestOWLIndividualAxiomIterator triplesIter = materializer . getIterator ( ) ; File fout = new File ( outputFile ) ; if ( fout . exists ( ) ) { fout . delete ( ) ; } try ( PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( fout , true ) ) ) ) { while ( triplesIter . hasNext ( ) ) { OWLIndividualAxiom individual = triplesIter . next ( ) ; out . println ( individual . toString ( ) ) ; } out . flush ( ) ; } } }
jjculber/defcoinj | public TestNet3Params ( ) { super ( ) ; id = ID_TESTNET ; packetMagic = 0xfcc1b7dc ; interval = INTERVAL ; targetTimespan = TARGET_TIMESPAN ; proofOfWorkLimit = Utils . decodeCompactBits ( 0x1e0ffff0L ) ; port = 44556 ; addressHeader = 113 ; p2shHeader = 196 ; acceptableAddressCodes = new int [ ] { addressHeader , p2shHeader } ; dumpedPrivateKeyHeader = 241 ; genesisBlock . setTime ( 1391503289L ) ; genesisBlock . setDifficultyTarget ( 0x1e0ffff0L ) ; genesisBlock . setNonce ( 997879 ) ; spendableCoinbaseDepth = 30 ; subsidyDecreaseBlockCount = 100000 ; String genesisHash = genesisBlock . getHashAsString ( ) ; checkState ( genesisHash . equals ( " bb0a78264637406b6360aad926284d544d7049f45189db5664f3c4d07350559e " ) ) ; alertSigningKey = Hex . decode ( "042756726da3c7ef515d89212ee1705023d14be389e25fe15611585661b9a20021908b2b80a3c7200a0139dd2b26946606aab0eef9aa7689a6dc2c7eee237fa834" ) ; diffChangeTarget = 50 ; dnsSeeds = new String [ ] { } ; }
jjculber/defcoinj | public String getPaymentProtocolId ( ) { return PAYMENT_PROTOCOL_ID_TESTNET ; }
kiall/ExoPlayer | @ Test public void testParcelable ( ) { DrmInitData . SchemeData drmData1 = new DrmInitData . SchemeData ( WIDEVINE_UUID , VIDEO_MP4 , TestUtil . buildTestData ( 128 , 1 ) ) ; DrmInitData . SchemeData drmData2 = new DrmInitData . SchemeData ( C . UUID_NIL , VIDEO_WEBM , TestUtil . buildTestData ( 128 , 1 ) ) ; DrmInitData drmInitData = new DrmInitData ( drmData1 , drmData2 ) ; byte [ ] projectionData = new byte [ ] { 1 , 2 , 3 } ; Metadata metadata = new Metadata ( new TextInformationFrame ( " id1" , " description1" , " value1" ) , new TextInformationFrame ( " id2" , " description2" , " value2" ) ) ; ColorInfo colorInfo = new ColorInfo ( C . COLOR_SPACE_BT709 , C . COLOR_RANGE_LIMITED , C . COLOR_TRANSFER_SDR , new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ) ; Format formatToParcel = new Format ( " id " , MimeTypes . VIDEO_MP4 , MimeTypes . VIDEO_H264 , null , 1024 , 2048 , 1920 , 1080 , 24 , 90 , 2 , projectionData , C . STEREO_MODE_TOP_BOTTOM , colorInfo , 6 , 44100 , C . ENCODING_PCM_24BIT , 1001 , 1002 , 0 , " und " , Format . NO_VALUE , Format . OFFSET_SAMPLE_RELATIVE , INIT_DATA , drmInitData , metadata ) ; Parcel parcel = Parcel . obtain ( ) ; formatToParcel . writeToParcel ( parcel , 0 ) ; parcel . setDataPosition ( 0 ) ; Format formatFromParcel = Format . CREATOR . createFromParcel ( parcel ) ; assertThat ( formatFromParcel ) . isEqualTo ( formatToParcel ) ; parcel . recycle ( ) ; }
kiall/ExoPlayer | @ Test public void testConversionToFrameworkMediaFormat ( ) { if ( Util . SDK_INT < 16 ) { return ; } testConversionToFrameworkMediaFormatV16 ( Format . createVideoSampleFormat ( null , " video / xyz " , null , 5000 , 102400 , 1280 , 720 , 30 , INIT_DATA , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createVideoSampleFormat ( null , " video / xyz " , null , 5000 , Format . NO_VALUE , 1280 , 720 , 30 , null , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createAudioSampleFormat ( null , " audio / xyz " , null , 500 , 128 , 5 , 44100 , INIT_DATA , null , 0 , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createAudioSampleFormat ( null , " audio / xyz " , null , 500 , Format . NO_VALUE , 5 , 44100 , null , null , 0 , null ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createTextSampleFormat ( null , " text / xyz " , 0 , " eng " ) ) ; testConversionToFrameworkMediaFormatV16 ( Format . createTextSampleFormat ( null , " text / xyz " , 0 , null ) ) ; }
windbender/wildlife-camera-machine | public LatLonPair ( Double lat , Double lon ) { super ( ) ; this . lat = lat ; this . lon = lon ; }
windbender/wildlife-camera-machine | public Double getLat ( ) { return lat ; }
windbender/wildlife-camera-machine | public Double getLon ( ) { return lon ; }
windbender/wildlife-camera-machine | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( lat == null ) ? 0 : lat . hashCode ( ) ) ; result = prime * result + ( ( lon == null ) ? 0 : lon . hashCode ( ) ) ; return result ; }
windbender/wildlife-camera-machine | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; LatLonPair other = ( LatLonPair ) obj ; if ( lat == null ) { if ( other . lat != null ) return false ; } else if ( ! lat . equals ( other . lat ) ) return false ; if ( lon == null ) { if ( other . lon != null ) return false ; } else if ( ! lon . equals ( other . lon ) ) return false ; return true ; }
windbender/wildlife-camera-machine | @ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " LatLonPair ▁ [ lat = " ) ; builder . append ( lat ) ; builder . append ( " , ▁ lon = " ) ; builder . append ( lon ) ; builder . append ( " ] " ) ; return builder . toString ( ) ; }
jk1/intellij-community | @ Override public void actionPerformed ( final AnActionEvent e ) { final Project project = e . getProject ( ) ; final Editor editor = e . getData ( CommonDataKeys . EDITOR ) ; if ( Boolean . TRUE . equals ( e . getData ( PlatformDataKeys . IS_MODAL_CONTEXT ) ) ) { return ; } if ( project != null && editor != null ) { if ( DumbService . getInstance ( project ) . isDumb ( ) ) { DumbService . getInstance ( project ) . showDumbModeNotification ( IdeBundle . message ( " goto . custom . region . message . dumb . mode " ) ) ; return ; } CommandProcessor processor = CommandProcessor . getInstance ( ) ; processor . executeCommand ( project , ( ) -> { Collection < FoldingDescriptor > foldingDescriptors = getCustomFoldingDescriptors ( editor , project ) ; if ( foldingDescriptors . size ( ) > 0 ) { CustomFoldingRegionsPopup . show ( foldingDescriptors , editor , project ) ; } else { notifyCustomRegionsUnavailable ( editor , project ) ; } } , IdeBundle . message ( " goto . custom . region . command " ) , null ) ; } }
jk1/intellij-community | @ Override public void update ( AnActionEvent e ) { Presentation presentation = e . getPresentation ( ) ; presentation . setText ( IdeBundle . message ( " goto . custom . region . menu . item " ) ) ; final Editor editor = e . getData ( CommonDataKeys . EDITOR ) ; final Project project = e . getProject ( ) ; boolean isAvailable = editor != null && project != null ; presentation . setEnabled ( isAvailable ) ; presentation . setVisible ( isAvailable ) ; }
dremio/dremio-oss | public ExcelFormatPlugin ( String name , SabotContext context , ExcelFormatPluginConfig formatConfig , FileSystemPlugin fsPlugin ) { super ( name , context , formatConfig , true , false , false , false , formatConfig . getExtensions ( ) , NAME , fsPlugin ) ; maxExcelFileSize = context . getOptionManager ( ) . getOption ( ExecConstants . EXCEL_MAX_FILE_SIZE_VALIDATOR ) ; }
dremio/dremio-oss | @ Override public boolean supportsPushDown ( ) { return false ; }
dremio/dremio-oss | @ Override public RecordReader getRecordReader ( OperatorContext context , FileSystem dfs , EasyDatasetSplitXAttr splitAttributes , List < SchemaPath > columns ) throws ExecutionSetupException { final Path path = dfs . makeQualified ( Path . of ( splitAttributes . getPath ( ) ) ) ; checkExcelFileSize ( path , dfs ) ; final ExcelFormatPluginConfig excelFormatConfig = ( ExcelFormatPluginConfig ) formatConfig ; return new ExcelRecordReader ( context , dfs , path , excelFormatConfig , columns ) ; }
dremio/dremio-oss | @ Override public RecordReader getRecordReader ( OperatorContext context , FileSystem dfs , EasyDatasetSplitXAttr splitAttributes , List < SchemaPath > columns , EasySubScan config ) throws ExecutionSetupException { RecordReader inner = getRecordReader ( context , dfs , splitAttributes , columns ) ; return new EasyCoercionReader ( context , columns , inner , config . getFullSchema ( ) , Iterables . getFirst ( config . getReferencedTables ( ) , null ) ) ; }
dremio/dremio-oss | private void checkExcelFileSize ( final Path path , final FileSystem dfs ) { try { long excelFileSize = dfs . getFileAttributes ( path ) . size ( ) ; if ( excelFileSize > maxExcelFileSize ) { final String errorMessage = String . format ( " File ▁ % s ▁ exceeds ▁ maximum ▁ size ▁ limit ▁ for ▁ Excel ▁ files ▁ of ▁ % d ▁ bytes " , path , maxExcelFileSize ) ; throw UserException . unsupportedError ( ) . message ( errorMessage ) . build ( logger ) ; } } catch ( IOException e ) { logger . error ( " Error ▁ occurred ▁ while ▁ fetching ▁ file ▁ attributes ▁ for ▁ " + path ) ; } }
dremio/dremio-oss | @ Override public int getReaderOperatorType ( ) { return CoreOperatorType . EXCEL_SUB_SCAN_VALUE ; }
dremio/dremio-oss | @ Override public RecordWriter getRecordWriter ( OperatorContext context , EasyWriter writer ) throws IOException { throw UserException . unsupportedError ( ) . message ( " Writing ▁ output ▁ in ▁ Excel ▁ format ▁ is ▁ not ▁ supported " ) . build ( logger ) ; }
dremio/dremio-oss | @ Override public int getWriterOperatorType ( ) { throw UserException . unsupportedError ( ) . message ( " Writing ▁ output ▁ in ▁ Excel ▁ format ▁ is ▁ not ▁ supported " ) . build ( logger ) ; }
frodoking/GradleAndroid-App | public MySimpleAdapter ( Context context , int layoutRes ) { super ( context , layoutRes , android . R . id . text1 ) ; }
frodoking/GradleAndroid-App | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . sample_act ) ; mAdapterView = ( MultiColumnListView ) findViewById ( R . id . list ) ; { for ( int i = 0 ; i < 3 ; ++ i ) { TextView tv = new TextView ( this ) ; tv . setLayoutParams ( new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ) ; tv . setText ( " Hello ▁ Header ! ! ▁ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . " ) ; mAdapterView . addHeaderView ( tv ) ; } } { for ( int i = 0 ; i < 3 ; ++ i ) { TextView tv = new TextView ( this ) ; tv . setLayoutParams ( new LayoutParams ( LayoutParams . MATCH_PARENT , LayoutParams . WRAP_CONTENT ) ) ; tv . setText ( " Hello ▁ Footer ! ! ▁ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . " ) ; mAdapterView . addFooterView ( tv ) ; } } }
frodoking/GradleAndroid-App | @ Override public boolean onCreateOptionsMenu ( Menu menu ) { menu . add ( Menu . NONE , 1001 , 0 , " Load ▁ More ▁ Contents " ) ; menu . add ( Menu . NONE , 1002 , 0 , " Launch ▁ Pull - To - Refresh ▁ Activity " ) ; return super . onCreateOptionsMenu ( menu ) ; }
frodoking/GradleAndroid-App | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case 1001 : { int startCount = mAdapter . getCount ( ) ; for ( int i = 0 ; i < 100 ; ++ i ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Hello ! ! [ " ) ; builder . append ( startCount + i ) ; builder . append ( " ] ▁ " ) ; char [ ] chars = new char [ mRand . nextInt ( 100 ) ] ; Arrays . fill ( chars , '1' ) ; builder . append ( chars ) ; mAdapter . add ( builder . toString ( ) ) ; } } break ; case 1002 : { Intent intent = new Intent ( this , PullToRefreshSampleActivity . class ) ; startActivity ( intent ) ; } break ; } return true ; }
frodoking/GradleAndroid-App | @ Override protected void onResume ( ) { super . onResume ( ) ; initAdapter ( ) ; mAdapterView . setAdapter ( mAdapter ) ; }
frodoking/GradleAndroid-App | private void initAdapter ( ) { mAdapter = new MySimpleAdapter ( this , R . layout . sample_item ) ; for ( int i = 0 ; i < 30 ; ++ i ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Hello ! ! [ " ) ; builder . append ( i ) ; builder . append ( " ] ▁ " ) ; char [ ] chars = new char [ mRand . nextInt ( 500 ) ] ; Arrays . fill ( chars , '1' ) ; builder . append ( chars ) ; mAdapter . add ( builder . toString ( ) ) ; } }
awhitford/DependencyCheck | @ Test public void testSanitizer ( ) { JsonObjectBuilder builder = Json . createObjectBuilder ( ) . add ( " name " , " my ▁ app " ) . add ( " version " , "1.0.0" ) . add ( " random " , " random " ) . add ( " lockfileVersion " , 1 ) . add ( " requires " , true ) . add ( " dependencies " , Json . createObjectBuilder ( ) . add ( " abbrev " , Json . createObjectBuilder ( ) . add ( " version " , "1.1.1" ) . add ( " resolved " , " https : // registry . npmjs . org / abbrev / - / abbrev - 1.1.1 . tgz " ) . add ( " integrity " , " sha512 - nne9 / IiQ / hzIhY6pdDnbBtz7DjPTKrY00P / zvPSm5pOFkl6xuGrGnXn / VtTNNfNtAfZ9/1RtehkszU9qcTii0Q = = " ) . add ( " dev " , true ) ) ) ; JsonObject packageJson = builder . build ( ) ; JsonObject sanitized = SanitizePackage . sanitize ( packageJson ) ; Assert . assertTrue ( sanitized . containsKey ( " name " ) ) ; Assert . assertTrue ( sanitized . containsKey ( " version " ) ) ; Assert . assertTrue ( sanitized . containsKey ( " dependencies " ) ) ; Assert . assertTrue ( sanitized . containsKey ( " requires " ) ) ; JsonObject requires = sanitized . getJsonObject ( " requires " ) ; Assert . assertTrue ( requires . containsKey ( " abbrev " ) ) ; Assert . assertEquals ( "1.1.1" , requires . getString ( " abbrev " ) ) ; Assert . assertFalse ( sanitized . containsKey ( " lockfileVersion " ) ) ; Assert . assertFalse ( sanitized . containsKey ( " random " ) ) ; }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void outputOfLSVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; File outputFile = new File ( ROOT , " / basicCheckOutput " ) ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; oiv . go ( ) ; HashMap < String , LsElements > fileOutput = readLsfile ( outputFile ) ; compareNamespaces ( writtenFiles , fileOutput ) ; } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } LOG . debug ( " Correctly ▁ generated ▁ ls - style ▁ output . " ) ; }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void unsupportedFSLayoutVersion ( ) throws IOException { File testFile = new File ( ROOT , " / invalidLayoutVersion " ) ; File outputFile = new File ( ROOT , " invalidLayoutVersionOutput " ) ; try { int badVersionNum = - 432 ; changeLayoutVersion ( originalFsimage , testFile , badVersionNum ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; try { oiv . go ( ) ; fail ( " Shouldn ' t ▁ be ▁ able ▁ to ▁ read ▁ invalid ▁ laytout ▁ version " ) ; } catch ( IOException e ) { if ( ! e . getMessage ( ) . contains ( Integer . toString ( badVersionNum ) ) ) throw e ; LOG . debug ( " Correctly ▁ failed ▁ at ▁ reading ▁ bad ▁ image ▁ version . " ) ; } } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void truncatedFSImage ( ) throws IOException { File testFile = new File ( ROOT , " / truncatedFSImage " ) ; File outputFile = new File ( ROOT , " / trucnatedFSImageOutput " ) ; try { copyPartOfFile ( originalFsimage , testFile ) ; assertTrue ( " Created ▁ truncated ▁ fsimage " , testFile . exists ( ) ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; try { oiv . go ( ) ; fail ( " Managed ▁ to ▁ process ▁ a ▁ truncated ▁ fsimage ▁ file " ) ; } catch ( EOFException e ) { LOG . debug ( " Correctly ▁ handled ▁ EOF " ) ; } } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | private void compareNamespaces ( HashMap < String , FileStatus > written , HashMap < String , LsElements > fileOutput ) { assertEquals ( " Should ▁ be ▁ the ▁ same ▁ number ▁ of ▁ files ▁ in ▁ both , ▁ plus ▁ one ▁ for ▁ root " + " ▁ in ▁ fileoutput " , fileOutput . keySet ( ) . size ( ) , written . keySet ( ) . size ( ) + 1 ) ; Set < String > inFile = fileOutput . keySet ( ) ; for ( String path : inFile ) { if ( path . equals ( " / " ) ) continue ; assertTrue ( " Path ▁ in ▁ file ▁ ( " + path + " ) ▁ was ▁ written ▁ to ▁ fs " , written . containsKey ( path ) ) ; compareFiles ( written . get ( path ) , fileOutput . get ( path ) ) ; written . remove ( path ) ; } assertEquals ( " No ▁ more ▁ files ▁ were ▁ written ▁ to ▁ fs " , 0 , written . size ( ) ) ; }
JuntaoZhang/myhadoop-2.2.0 | private void compareFiles ( FileStatus fs , LsElements elements ) { assertEquals ( " directory ▁ listed ▁ as ▁ such " , fs . isDirectory ( ) ? ' d ' : ' - ' , elements . dir ) ; assertEquals ( " perms ▁ string ▁ equal " , fs . getPermission ( ) . toString ( ) , elements . perms ) ; assertEquals ( " replication ▁ equal " , fs . getReplication ( ) , elements . replication ) ; assertEquals ( " owner ▁ equal " , fs . getOwner ( ) , elements . username ) ; assertEquals ( " group ▁ equal " , fs . getGroup ( ) , elements . groupname ) ; assertEquals ( " lengths ▁ equal " , fs . getLen ( ) , elements . filesize ) ; }
JuntaoZhang/myhadoop-2.2.0 | private HashMap < String , LsElements > readLsfile ( File lsFile ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( lsFile ) ) ; String line = null ; HashMap < String , LsElements > fileContents = new HashMap < String , LsElements > ( ) ; while ( ( line = br . readLine ( ) ) != null ) readLsLine ( line , fileContents ) ; br . close ( ) ; return fileContents ; }
JuntaoZhang/myhadoop-2.2.0 | private void readLsLine ( String line , HashMap < String , LsElements > fileContents ) { String elements [ ] = line . split ( " \\ s + " ) ; assertEquals ( " Not ▁ enough ▁ elements ▁ in ▁ ls ▁ output " , 8 , elements . length ) ; LsElements lsLine = new LsElements ( ) ; lsLine . dir = elements [ 0 ] . charAt ( 0 ) ; lsLine . perms = elements [ 0 ] . substring ( 1 ) ; lsLine . replication = elements [ 1 ] . equals ( " - " ) ? 0 : Integer . valueOf ( elements [ 1 ] ) ; lsLine . username = elements [ 2 ] ; lsLine . groupname = elements [ 3 ] ; lsLine . filesize = Long . valueOf ( elements [ 4 ] ) ; String path = elements [ 7 ] ; assertFalse ( " LS ▁ file ▁ had ▁ duplicate ▁ file ▁ entries " , fileContents . containsKey ( path ) ) ; fileContents . put ( path , lsLine ) ; }
JuntaoZhang/myhadoop-2.2.0 | private void changeLayoutVersion ( File src , File dest , int newVersion ) throws IOException { DataInputStream in = null ; DataOutputStream out = null ; try { in = new DataInputStream ( new FileInputStream ( src ) ) ; out = new DataOutputStream ( new FileOutputStream ( dest ) ) ; in . readInt ( ) ; out . writeInt ( newVersion ) ; byte [ ] b = new byte [ 1024 ] ; while ( in . read ( b ) > 0 ) { out . write ( b ) ; } } finally { if ( in != null ) in . close ( ) ; if ( out != null ) out . close ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | private void copyPartOfFile ( File src , File dest ) throws IOException { InputStream in = null ; OutputStream out = null ; byte [ ] b = new byte [ 256 ] ; int bytesWritten = 0 ; int count ; int maxBytes = 700 ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( dest ) ; while ( ( count = in . read ( b ) ) > 0 && bytesWritten < maxBytes ) { out . write ( b ) ; bytesWritten += count ; } } finally { if ( in != null ) in . close ( ) ; if ( out != null ) out . close ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void outputOfFileDistributionVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; File outputFile = new File ( ROOT , " / fileDistributionCheckOutput " ) ; int totalFiles = 0 ; BufferedReader reader = null ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; ImageVisitor v = new FileDistributionVisitor ( outputFile . getPath ( ) , 0 , 0 ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; oiv . go ( ) ; reader = new BufferedReader ( new FileReader ( outputFile ) ) ; String line = reader . readLine ( ) ; assertEquals ( line , " Size\tNumFiles " ) ; while ( ( line = reader . readLine ( ) ) != null ) { String [ ] row = line . split ( " \t " ) ; assertEquals ( row . length , 2 ) ; totalFiles += Integer . parseInt ( row [ 1 ] ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } assertEquals ( totalFiles , NUM_DIRS * FILES_PER_DIR ) ; }
JuntaoZhang/myhadoop-2.2.0 | TestImageVisitor ( ) { }
JuntaoZhang/myhadoop-2.2.0 | List < String > getDelegationTokenRenewers ( ) { return delegationTokenRenewers ; }
JuntaoZhang/myhadoop-2.2.0 | @ Override void start ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void finish ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void finishAbnormally ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void visit ( ImageElement element , String value ) throws IOException { if ( element == ImageElement . DELEGATION_TOKEN_IDENTIFIER_RENEWER ) { delegationTokenRenewers . add ( value ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ Override void visitEnclosingElement ( ImageElement element ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void visitEnclosingElement ( ImageElement element , ImageElement key , String value ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Override void leaveEnclosingElement ( ) throws IOException { }
JuntaoZhang/myhadoop-2.2.0 | @ Test public void outputOfTestVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; TestImageVisitor v = new TestImageVisitor ( ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , true ) ; oiv . go ( ) ; List < String > dtrs = v . getDelegationTokenRenewers ( ) ; assertEquals ( 1 , dtrs . size ( ) ) ; assertEquals ( TEST_RENEWER , dtrs . get ( 0 ) ) ; } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; } LOG . debug ( " Passed ▁ TestVisitor ▁ validation . " ) ; }
silvanheller/cineast | public BooleanProviderImpl ( boolean value ) { this . value = value ; }
silvanheller/cineast | @ Override public boolean getBoolean ( ) { return this . value ; }
silvanheller/cineast | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( value ? 1231 : 1237 ) ; return result ; }
silvanheller/cineast | @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } BooleanProviderImpl other = ( BooleanProviderImpl ) obj ; if ( value != other . value ) { return false ; } return true ; }
silvanheller/cineast | @ Override public String toString ( ) { return " BooleanProviderImpl ▁ [ value = " + value + " ] " ; }
bindstone/graphbank | @ RequestMapping ( value = " / " , method = RequestMethod . GET ) public ResponseEntity < List < Client > > getAll ( ) { List < Client > entities = clientService . findAll ( ) ; return ackEntities ( entities ) ; }
bindstone/graphbank | " , method = RequestMethod . GET ) public ResponseEntity < Client > findById ( @ PathVariable ( " id " ) String id ) { Client entity = clientService . findById ( id ) ; return ackEntity ( entity ) ; }
bindstone/graphbank | @ RequestMapping ( value = " / " , method = RequestMethod . POST ) @ CrossOrigin public ResponseEntity < Client > create ( @ RequestBody Client input ) throws ContextedException { Client entity = clientService . save ( input ) ; return ackEntity ( entity ) ; }
bindstone/graphbank | @ RequestMapping ( value = " / " , method = RequestMethod . PUT ) @ CrossOrigin public ResponseEntity < Client > update ( @ RequestBody Client input ) throws ContextedException { Client entity = clientService . save ( input ) ; return ackEntity ( entity ) ; }
bindstone/graphbank | " , method = RequestMethod . DELETE ) @ CrossOrigin public ResponseEntity < Void > delete ( @ PathVariable ( " id " ) String id ) { clientService . delete ( id ) ; return ack ( ) ; }
xiwc/thymeleaf.test | private StringUtil ( ) { super ( ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue AllBatchesLoadedEvent event ) { jmsClient . send ( event ) . inTransaction ( ) . withProperty ( " variantID " , event . getVariantID ( ) ) . to ( allBatchesLoadedQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue BatchLoadedEvent event ) { jmsClient . send ( event ) . inTransaction ( ) . withProperty ( " variantID " , event . getVariantID ( ) ) . to ( batchLoadedQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue TriggerMetricCollectionEvent event ) { jmsClient . send ( event ) . withDuplicateDetectionId ( event . getPushMessageInformationId ( ) ) . withDelayedDelivery ( 500L ) . to ( triggerMetricCollectionQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void queueMessage ( @ Observes @ DispatchToQueue TriggerVariantMetricCollectionEvent event ) { jmsClient . send ( event ) . to ( triggerVariantMetricCollectionQueue ) ; }
idelpivnitskiy/aerogear-unifiedpush-server | public void broadcastMessage ( @ Observes @ DispatchToQueue MetricsProcessingStartedEvent event ) { jmsClient . send ( event ) . to ( metricsProcessingStartedTopic ) ; }
jentfoo/aws-sdk-java | private AmazonWebServiceRequest originalRequest = new AmazonWebServiceRequest ( ) { }
jentfoo/aws-sdk-java | public EmptyHttpRequest ( String endpoint , HttpMethodName httpMethod ) { this ( endpoint , httpMethod , null ) ; }
jentfoo/aws-sdk-java | public EmptyHttpRequest ( String endpoint , HttpMethodName httpMethod , InputStream payload ) { this . endpoint = URI . create ( endpoint ) ; this . httpMethod = httpMethod ; this . content = payload ; }
jentfoo/aws-sdk-java | @ Override public void addHeader ( String name , String value ) { }
jentfoo/aws-sdk-java | @ Override public Map < String , String > getHeaders ( ) { return Collections . emptyMap ( ) ; }
jentfoo/aws-sdk-java | @ Override public void setHeaders ( Map < String , String > headers ) { }
jentfoo/aws-sdk-java | @ Override public void setResourcePath ( String path ) { }
jentfoo/aws-sdk-java | @ Override public String getResourcePath ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public void addParameter ( String name , String value ) { }
jentfoo/aws-sdk-java | @ Override public Request < Object > withParameter ( String name , String value ) { return this ; }
jentfoo/aws-sdk-java | @ Override public void addParameters ( String name , List < String > values ) { }
jentfoo/aws-sdk-java | @ Override public Map < String , List < String > > getParameters ( ) { return Collections . emptyMap ( ) ; }
jentfoo/aws-sdk-java | @ Override public void setParameters ( Map < String , List < String > > parameters ) { }
jentfoo/aws-sdk-java | @ Override public URI getEndpoint ( ) { return endpoint ; }
jentfoo/aws-sdk-java | @ Override public void setEndpoint ( URI endpoint ) { throw new UnsupportedOperationException ( ) ; }
jentfoo/aws-sdk-java | @ Override public HttpMethodName getHttpMethod ( ) { return httpMethod ; }
jentfoo/aws-sdk-java | @ Override public void setHttpMethod ( HttpMethodName httpMethod ) { throw new UnsupportedOperationException ( ) ; }
jentfoo/aws-sdk-java | @ Override public InputStream getContent ( ) { return content ; }
jentfoo/aws-sdk-java | @ Override public void setContent ( InputStream content ) { }
jentfoo/aws-sdk-java | @ Override public String getServiceName ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public AmazonWebServiceRequest getOriginalRequest ( ) { return originalRequest ; }
jentfoo/aws-sdk-java | public void setOriginalRequest ( AmazonWebServiceRequest originalRequest ) { this . originalRequest = originalRequest ; }
jentfoo/aws-sdk-java | @ Override public int getTimeOffset ( ) { return 0 ; }
jentfoo/aws-sdk-java | @ Override public void setTimeOffset ( int timeOffset ) { }
jentfoo/aws-sdk-java | @ Override public Request < Object > withTimeOffset ( int timeOffset ) { return this ; }
jentfoo/aws-sdk-java | @ Override public AWSRequestMetrics getAWSRequestMetrics ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public void setAWSRequestMetrics ( AWSRequestMetrics metrics ) { }
jentfoo/aws-sdk-java | @ Override public ReadLimitInfo getReadLimitInfo ( ) { return new AmazonWebServiceRequest ( ) { } ; }
jentfoo/aws-sdk-java | @ Override public InputStream getContentUnwrapped ( ) { return null ; }
jentfoo/aws-sdk-java | @ Override public Object getOriginalRequestObject ( ) { return new AmazonWebServiceRequest ( ) { } ; }
jentfoo/aws-sdk-java | @ Override public < X > void addHandlerContext ( HandlerContextKey < X > key , X value ) { }
jentfoo/aws-sdk-java | @ Override public < X > X getHandlerContext ( HandlerContextKey < X > key ) { return null ; }
artemrudenko/java_training16 | @ BeforeMethod public void ensurePreconditions ( ) { if ( app . db ( ) . groups ( ) . size ( ) == 0 ) { app . goTo ( ) . groupPage ( ) ; app . group ( ) . create ( new GroupData ( ) . withName ( " MyGroup " ) ) ; } app . goTo ( ) . groupPage ( ) ; }
artemrudenko/java_training16 | @ Test public void testGroupModification ( ) { Groups before = app . db ( ) . groups ( ) ; GroupData modifiedGroup = before . iterator ( ) . next ( ) ; GroupData group = new GroupData ( ) . withId ( modifiedGroup . getId ( ) ) . withName ( " NAMEE " ) . withHeader ( " HEADER " ) . withFooter ( " FOOTER " ) ; app . group ( ) . modify ( group ) ; assertThat ( app . group ( ) . count ( ) , equalTo ( before . size ( ) ) ) ; Groups after = app . db ( ) . groups ( ) ; assertThat ( after , equalTo ( before . withModified ( group ) ) ) ; verifyGroupListInUI ( ) ; }
jaehong-kim/pinpoint | public MqttV5ClientPublishInterceptor ( TraceContext traceContext , MethodDescriptor descriptor , PahoMqttPluginConfig config ) { super ( traceContext , descriptor , config ) ; }
jaehong-kim/pinpoint | @ Override protected void setCallerDataWhenSampled ( Trace trace , SpanEventRecorder recorder , Object [ ] args , boolean canSampled ) { MqttProperties mqttProperties = getMqttProperties ( args [ 1 ] ) ; if ( mqttProperties == null ) { return ; } List < UserProperty > mqttUserProperties = mqttProperties . getUserProperties ( ) ; List < UserProperty > userPropertiesWithHeader = new ArrayList < UserProperty > ( mqttUserProperties ) ; cleanPinpointHeader ( userPropertiesWithHeader ) ; if ( canSampled ) { final TraceId nextId = trace . getTraceId ( ) . getNextTraceId ( ) ; recorder . recordNextSpanId ( nextId . getSpanId ( ) ) ; userPropertiesWithHeader . addAll ( Arrays . asList ( new UserProperty ( Header . HTTP_TRACE_ID . toString ( ) , nextId . getTransactionId ( ) ) , new UserProperty ( Header . HTTP_SPAN_ID . toString ( ) , String . valueOf ( nextId . getSpanId ( ) ) ) , new UserProperty ( Header . HTTP_PARENT_SPAN_ID . toString ( ) , String . valueOf ( nextId . getParentSpanId ( ) ) ) , new UserProperty ( Header . HTTP_FLAGS . toString ( ) , String . valueOf ( nextId . getFlags ( ) ) ) , new UserProperty ( Header . HTTP_PARENT_APPLICATION_NAME . toString ( ) , String . valueOf ( traceContext . getApplicationName ( ) ) ) , new UserProperty ( Header . HTTP_PARENT_APPLICATION_TYPE . toString ( ) , Short . toString ( traceContext . getServerTypeCode ( ) ) ) ) ) ; } else { userPropertiesWithHeader . add ( new UserProperty ( Header . HTTP_SAMPLED . toString ( ) , SamplingFlagUtils . SAMPLING_RATE_FALSE ) ) ; } mqttProperties . setUserProperties ( userPropertiesWithHeader ) ; }
jaehong-kim/pinpoint | private MqttProperties getMqttProperties ( Object arg ) { if ( arg instanceof org . eclipse . paho . mqttv5 . common . MqttMessage ) { org . eclipse . paho . mqttv5 . common . MqttMessage mqttMessage = ( org . eclipse . paho . mqttv5 . common . MqttMessage ) arg ; return mqttMessage . getProperties ( ) ; } return null ; }
jaehong-kim/pinpoint | private void cleanPinpointHeader ( List < UserProperty > userPropertiesWithHeader ) { for ( UserProperty userProperty : userPropertiesWithHeader ) { String key = userProperty . getKey ( ) ; if ( Header . startWithPinpointHeader ( key ) ) { userPropertiesWithHeader . remove ( userProperty ) ; } } }
jhulick/zuul-netty | @ Test public void registeresHandlersOnceServerStarted ( ) throws Exception { httpServer = new HttpServer ( 9090 ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_enabled_after_disabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_disabled_after_enabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_disabled_after_default_enabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " properties " ) . startObject ( " some _ text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_enabled_after_enabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder expectedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " _ all " ) . field ( " enabled " , true ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testNoConflictWhileMergingAndMappingChanged ( mapping , mappingUpdate , expectedMapping ) ; }
Clairebi/ElasticsearchClone | @ Test public void test_all_disabled_after_disabled ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder expectedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testNoConflictWhileMergingAndMappingChanged ( mapping , mappingUpdate , expectedMapping ) ; }
Clairebi/ElasticsearchClone | private void testNoConflictWhileMergingAndMappingChanged ( XContentBuilder mapping , XContentBuilder mappingUpdate , XContentBuilder expectedMapping ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) , " type " , mapping ) ; DocumentMapper . MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( " type " ) . merge ( indexService . mapperService ( ) . parse ( " type " , new CompressedString ( mappingUpdate . bytes ( ) ) , true ) . mapping ( ) , DocumentMapper . MergeFlags . mergeFlags ( ) . simulate ( false ) ) ; assertThat ( mergeResult . conflicts ( ) . length , equalTo ( 0 ) ) ; CompressedString mappingAfterUpdate = indexService . mapperService ( ) . documentMapper ( " type " ) . mappingSource ( ) ; assertThat ( mappingAfterUpdate . toString ( ) , equalTo ( expectedMapping . string ( ) ) ) ; }
Clairebi/ElasticsearchClone | public void testConflictFieldsMapping ( String fieldName ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( fieldName ) . field ( " enabled " , true ) . field ( " store " , " no " ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mappingUpdate = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( fieldName ) . field ( " enabled " , true ) . field ( " store " , " yes " ) . endObject ( ) . startObject ( " properties " ) . startObject ( " text " ) . field ( " type " , " string " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; testConflictWhileMergingAndMappingUnchanged ( mapping , mappingUpdate ) ; }
Clairebi/ElasticsearchClone | protected void testConflictWhileMergingAndMappingUnchanged ( XContentBuilder mapping , XContentBuilder mappingUpdate ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) , " type " , mapping ) ; CompressedString mappingBeforeUpdate = indexService . mapperService ( ) . documentMapper ( " type " ) . mappingSource ( ) ; DocumentMapper . MergeResult mergeResult = indexService . mapperService ( ) . documentMapper ( " type " ) . merge ( indexService . mapperService ( ) . parse ( " type " , new CompressedString ( mappingUpdate . bytes ( ) ) , true ) . mapping ( ) , DocumentMapper . MergeFlags . mergeFlags ( ) . simulate ( true ) ) ; assertThat ( mergeResult . conflicts ( ) . length , equalTo ( 1 ) ) ; CompressedString mappingAfterUpdate = indexService . mapperService ( ) . documentMapper ( " type " ) . mappingSource ( ) ; assertThat ( mappingAfterUpdate , equalTo ( mappingBeforeUpdate ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testIndexFieldParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( " type " ) . startObject ( " _ index " ) . field ( " enabled " , enabled ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . indexMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . indexMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testTimestampParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( " type " ) . startObject ( " _ timestamp " ) . field ( " enabled " , enabled ) . field ( " store " , true ) . startObject ( " fielddata " ) . field ( " format " , " doc _ values " ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . hasDocValues ( ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . hasDocValues ( ) ) ; assertTrue ( documentMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testSizeParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder indexMapping = XContentFactory . jsonBuilder ( ) ; boolean enabled = randomBoolean ( ) ; indexMapping . startObject ( ) . startObject ( " type " ) . startObject ( " _ size " ) . field ( " enabled " , enabled ) . endObject ( ) . endObject ( ) . endObject ( ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( indexMapping . string ( ) ) , true ) ; assertThat ( documentMapper . sizeFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; assertTrue ( documentMapper . sizeFieldMapper ( ) . fieldType ( ) . stored ( ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . sizeFieldMapper ( ) . enabled ( ) , equalTo ( enabled ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testSizeTimestampIndexParsing ( ) throws IOException { IndexService indexService = createIndex ( " test " , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; String mapping = copyToStringFromClasspath ( " / org / elasticsearch / index / mapper / update / default _ mapping _ with _ disabled _ root _ types . json " ) ; DocumentMapper documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( mapping ) , true ) ; assertThat ( documentMapper . mappingSource ( ) . string ( ) , equalTo ( mapping ) ) ; documentMapper . refreshSource ( ) ; documentMapper = indexService . mapperService ( ) . parse ( " type " , new CompressedString ( documentMapper . mappingSource ( ) . string ( ) ) , true ) ; assertThat ( documentMapper . mappingSource ( ) . string ( ) , equalTo ( mapping ) ) ; }
Clairebi/ElasticsearchClone | @ Test public void testDefaultApplied ( ) throws IOException { createIndex ( " test1" , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; createIndex ( " test2" , ImmutableSettings . settingsBuilder ( ) . build ( ) ) ; XContentBuilder defaultMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( MapperService . DEFAULT_MAPPING ) . startObject ( " _ size " ) . field ( " enabled " , true ) . endObject ( ) . endObject ( ) . endObject ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( ) . setType ( MapperService . DEFAULT_MAPPING ) . setSource ( defaultMapping ) . get ( ) ; XContentBuilder typeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( " type " ) . startObject ( " _ all " ) . field ( " enabled " , false ) . endObject ( ) . endObject ( ) . endObject ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( " test1" ) . setType ( " type " ) . setSource ( typeMapping ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( " test1" , " test2" ) . setType ( " type " ) . setSource ( typeMapping ) . get ( ) ; GetMappingsResponse response = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( " test2" ) . get ( ) ; assertNotNull ( response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ all " ) ) ; assertFalse ( ( Boolean ) ( ( LinkedHashMap ) response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ all " ) ) . get ( " enabled " ) ) ; assertNotNull ( response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ size " ) ) ; assertTrue ( ( Boolean ) ( ( LinkedHashMap ) response . getMappings ( ) . get ( " test2" ) . get ( " type " ) . getSourceAsMap ( ) . get ( " _ size " ) ) . get ( " enabled " ) ) ; }
dmdlcoding/matrix | public void execute ( JobExecutionContext ctx ) throws JobExecutionException { while ( ConfigureCache . isExecuting ( " TaskReminderLock " ) ) { Thread . yield ( ) ; try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } ConfigureCache . setExecuting ( " TaskReminderLock " , true ) ; try { Iterator < Integer > itAlpha = ConfigureCache . taskCentralMap . keySet ( ) . iterator ( ) ; while ( itAlpha . hasNext ( ) ) { Integer userId = itAlpha . next ( ) ; Map < Integer , List < TaskCentral > > mapAlpha = ConfigureCache . taskCentralMap . get ( userId ) ; if ( mapAlpha . size ( ) > 0 ) { Iterator < Integer > itBeta = mapAlpha . keySet ( ) . iterator ( ) ; while ( itBeta . hasNext ( ) ) { Integer taskId = itBeta . next ( ) ; List < TaskCentral > taskList = mapAlpha . get ( taskId ) ; if ( taskList . size ( ) > 0 ) { Iterator < TaskCentral > itGamma = taskList . iterator ( ) ; while ( itGamma . hasNext ( ) ) { TaskCentral taskCentral = itGamma . next ( ) ; if ( System . currentTimeMillis ( ) - taskCentral . getArrivalTime ( ) . getTime ( ) > 1000 * 60 ) { itGamma . remove ( ) ; } } } else { itBeta . remove ( ) ; } } } else { itAlpha . remove ( ) ; } } } catch ( Exception e ) { logger . error ( e ) ; } ConfigureCache . setExecuting ( " TaskReminderLock " , false ) ; }
dmdlcoding/matrix | public void viewRealtimeData ( ) { try { JSONArray resultArr = new JSONArray ( ) ; Iterator < Integer > itAlpha = ConfigureCache . taskCentralMap . keySet ( ) . iterator ( ) ; while ( itAlpha . hasNext ( ) ) { Integer userId = itAlpha . next ( ) ; JSONObject alphaJson = new JSONObject ( ) ; alphaJson . accumulate ( " userId " , userId ) ; alphaJson . accumulate ( " children " , new JSONArray ( ) ) ; Map < Integer , List < TaskCentral > > taskMap = ConfigureCache . taskCentralMap . get ( userId ) ; Iterator < Integer > itBeta = taskMap . keySet ( ) . iterator ( ) ; while ( itBeta . hasNext ( ) ) { Integer taskId = itBeta . next ( ) ; JSONObject betaJson = new JSONObject ( ) ; betaJson . accumulate ( " taskId " , taskId ) ; betaJson . accumulate ( " children " , new JSONArray ( ) ) ; List < TaskCentral > taskList = taskMap . get ( taskId ) ; Iterator < TaskCentral > itGamma = taskList . iterator ( ) ; while ( itGamma . hasNext ( ) ) { TaskCentral taskCentral = itGamma . next ( ) ; TaskInfo taskInfo = ConfigureCache . taskInfoMap . get ( taskCentral . getUserInfoId ( ) ) . get ( taskCentral . getTaskInfoId ( ) ) ; JSONObject gammaJson = new JSONObject ( ) ; gammaJson . accumulate ( " userInfoId " , taskCentral . getUserInfoId ( ) ) ; gammaJson . accumulate ( " taskInfoId " , taskCentral . getTaskInfoId ( ) ) ; gammaJson . accumulate ( " arrivalTime " , DateTimeHelper . dateToStr ( taskCentral . getArrivalTime ( ) , DateTimeHelper . PATTERN_DATE_TIME ) ) ; gammaJson . accumulate ( " cronExpression " , taskInfo . getCronExpression ( ) ) ; betaJson . getJSONArray ( " children " ) . add ( gammaJson ) ; } alphaJson . getJSONArray ( " children " ) . add ( betaJson ) ; } resultArr . add ( alphaJson ) ; } System . out . println ( " \n " + resultArr + " \n " ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
AlexMinsk/camunda-bpm-platform | public ActivityInstanceStateImpl ( int suspensionCode , String string ) { this . stateCode = suspensionCode ; this . name = string ; }
AlexMinsk/camunda-bpm-platform | public int getStateCode ( ) { return stateCode ; }
AlexMinsk/camunda-bpm-platform | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + stateCode ; return result ; }
AlexMinsk/camunda-bpm-platform | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ActivityInstanceStateImpl other = ( ActivityInstanceStateImpl ) obj ; if ( stateCode != other . stateCode ) return false ; return true ; }
AlexMinsk/camunda-bpm-platform | @ Override public String toString ( ) { return name ; }
badvision/lawless-legends | TYPE ( boolean r ) { this . read = r ; }
badvision/lawless-legends | public boolean isRead ( ) { return read ; }
badvision/lawless-legends | public RAMEvent ( TYPE t , SCOPE s , VALUE v , int address , int oldValue , int newValue ) { setType ( t ) ; setScope ( s ) ; setValue ( v ) ; this . setAddress ( address ) ; this . setOldValue ( oldValue ) ; this . setNewValue ( newValue ) ; }
badvision/lawless-legends | public TYPE getType ( ) { return type ; }
badvision/lawless-legends | public final void setType ( TYPE type ) { this . type = type ; }
badvision/lawless-legends | public SCOPE getScope ( ) { return scope ; }
badvision/lawless-legends | public final void setScope ( SCOPE scope ) { this . scope = scope ; }
badvision/lawless-legends | public VALUE getValue ( ) { return value ; }
badvision/lawless-legends | public final void setValue ( VALUE value ) { this . value = value ; }
badvision/lawless-legends | public int getAddress ( ) { return address ; }
badvision/lawless-legends | public final void setAddress ( int address ) { this . address = address ; }
badvision/lawless-legends | public int getOldValue ( ) { return oldValue ; }
badvision/lawless-legends | public final void setOldValue ( int oldValue ) { this . oldValue = oldValue ; }
badvision/lawless-legends | public int getNewValue ( ) { return newValue ; }
badvision/lawless-legends | public final void setNewValue ( int newValue ) { this . newValue = newValue ; }
Cangol/Cangol-appcore | protected DownloadHttpClient ( final String group , boolean safe ) { this . group = group ; this . httpClient = HttpClientFactory . createDefaultHttpClient ( ) ; threadPool = PoolManager . buildPool ( group , DEFAULT_MAX ) ; this . requestMap = new WeakHashMap < > ( ) ; this . downloadRetryHandler = new DownloadRetryHandler ( DEFAULT_RETRYTIMES ) ; }
Cangol/Cangol-appcore | protected DownloadRetryHandler getDownloadRetryHandler ( ) { return downloadRetryHandler ; }
Cangol/Cangol-appcore | public Future send ( Object tag , String url , DownloadResponseHandler responseHandler , long from , String saveFile ) { final Request request = new Request . Builder ( ) . tag ( tag ) . addHeader ( " Range " , " bytes = " + from + " - " ) . url ( url ) . build ( ) ; return sendRequest ( request , responseHandler , saveFile ) ; }
Cangol/Cangol-appcore | protected Future sendRequest ( Request urlRequest , DownloadResponseHandler responseHandler , String saveFile ) { final Future < ? > request = threadPool . submit ( new DownloadThread ( this , httpClient , urlRequest , responseHandler , saveFile ) ) ; if ( urlRequest . tag ( ) != null ) { List < WeakReference < Future < ? > > > requestList = requestMap . get ( urlRequest . tag ( ) ) ; if ( requestList == null ) { requestList = new LinkedList < > ( ) ; requestMap . put ( urlRequest . tag ( ) , requestList ) ; } requestList . add ( new WeakReference < Future < ? > > ( request ) ) ; } return request ; }
Cangol/Cangol-appcore | public void cancelRequests ( Object tag , boolean mayInterruptIfRunning ) { final List < WeakReference < Future < ? > > > requestList = requestMap . get ( tag ) ; if ( requestList != null ) { for ( final WeakReference < Future < ? > > requestRef : requestList ) { final Future < ? > request = requestRef . get ( ) ; if ( request != null ) { request . cancel ( mayInterruptIfRunning ) ; } } } requestMap . remove ( tag ) ; for ( final Call call : httpClient . dispatcher ( ) . queuedCalls ( ) ) { if ( call . request ( ) . tag ( ) . equals ( group ) ) { call . cancel ( ) ; } } for ( final Call call : httpClient . dispatcher ( ) . runningCalls ( ) ) { if ( call . request ( ) . tag ( ) . equals ( group ) ) { call . cancel ( ) ; } } }
Cangol/Cangol-appcore | public void cancelAll ( ) { httpClient . dispatcher ( ) . cancelAll ( ) ; }
Cangol/Cangol-appcore | public void close ( ) { threadPool . close ( false ) ; }
darranl/keycloak | public MapAuthenticatedClientSessionAdapter ( KeycloakSession session , RealmModel realm , ClientModel client , UserSessionModel userSession , MapAuthenticatedClientSessionEntity < K > entity ) { super ( session , realm , client , userSession , entity ) ; }
darranl/keycloak | @ Override public int getTimestamp ( ) { return entity . getTimestamp ( ) ; }
darranl/keycloak | @ Override public void setTimestamp ( int timestamp ) { entity . setTimestamp ( timestamp ) ; }
darranl/keycloak | @ Override public UserSessionModel getUserSession ( ) { return userSession ; }
darranl/keycloak | @ Override public String getCurrentRefreshToken ( ) { return entity . getCurrentRefreshToken ( ) ; }
darranl/keycloak | @ Override public void setCurrentRefreshToken ( String currentRefreshToken ) { entity . setCurrentRefreshToken ( currentRefreshToken ) ; }
darranl/keycloak | @ Override public int getCurrentRefreshTokenUseCount ( ) { return entity . getCurrentRefreshTokenUseCount ( ) ; }
darranl/keycloak | @ Override public void setCurrentRefreshTokenUseCount ( int currentRefreshTokenUseCount ) { entity . setCurrentRefreshTokenUseCount ( currentRefreshTokenUseCount ) ; }
darranl/keycloak | @ Override public String getNote ( String name ) { return ( name != null ) ? entity . getNotes ( ) . get ( name ) : null ; }
darranl/keycloak | @ Override public void setNote ( String name , String value ) { if ( name != null ) { if ( value == null ) { entity . removeNote ( name ) ; } else { entity . addNote ( name , value ) ; } } }
darranl/keycloak | @ Override public void removeNote ( String name ) { if ( name != null ) { entity . removeNote ( name ) ; } }
darranl/keycloak | @ Override public Map < String , String > getNotes ( ) { return entity . getNotes ( ) ; }
darranl/keycloak | @ Override public String getRedirectUri ( ) { return entity . getRedirectUri ( ) ; }
darranl/keycloak | @ Override public void setRedirectUri ( String uri ) { entity . setRedirectUri ( uri ) ; }
darranl/keycloak | @ Override public RealmModel getRealm ( ) { return realm ; }
darranl/keycloak | @ Override public ClientModel getClient ( ) { return client ; }
darranl/keycloak | @ Override public String getAction ( ) { return entity . getAction ( ) ; }
darranl/keycloak | @ Override public void setAction ( String action ) { entity . setAction ( action ) ; }
darranl/keycloak | @ Override public String getProtocol ( ) { return entity . getAuthMethod ( ) ; }
darranl/keycloak | @ Override public void setProtocol ( String method ) { entity . setAuthMethod ( method ) ; }
darranl/keycloak | @ Override public String toString ( ) { return String . format ( " % s @ %08x " , getId ( ) , hashCode ( ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithMaxKeepaliveIsAliveRightNow ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , FOREVER ) ; assertTrue ( bean . isAlive ( now ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithMaxKeepaliveIsAliveAfterThreeDays ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , FOREVER ) ; assertTrue ( bean . isAlive ( threeDaysFromNow ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithOneSecondOfKeepaliveIsAliveRightNow ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , ONE_SECOND ) ; assertTrue ( bean . isAlive ( now ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithTwoHoursOfKeepaliveIsAliveAfterASecond ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , TWO_HOURS ) ; assertTrue ( bean . isAlive ( oneSecondFromNow ( ) ) ) ; }
Fewlaps/quitnow-cache | @ Test public void aJustCreatedBeanWithOneSecondOfKeepaliveIsNotAliveAfterTwoSeconds ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , ONE_SECOND ) ; assertFalse ( bean . isAlive ( twoHoursFromNow ( ) ) ) ; }
gfyoung/elasticsearch | public AliasValidator ( Settings settings ) { super ( settings ) ; }
gfyoung/elasticsearch | public void validateAlias ( Alias alias , String index , MetaData metaData ) { validateAlias ( alias . name ( ) , index , alias . indexRouting ( ) , metaData :: index ) ; }
gfyoung/elasticsearch | public void validateAliasMetaData ( AliasMetaData aliasMetaData , String index , MetaData metaData ) { validateAlias ( aliasMetaData . alias ( ) , index , aliasMetaData . indexRouting ( ) , metaData :: index ) ; }
gfyoung/elasticsearch | public void validateAliasStandalone ( Alias alias ) { validateAliasStandalone ( alias . name ( ) , alias . indexRouting ( ) ) ; if ( Strings . hasLength ( alias . filter ( ) ) ) { try { XContentHelper . convertToMap ( XContentFactory . xContent ( alias . filter ( ) ) , alias . filter ( ) , false ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " failed ▁ to ▁ parse ▁ filter ▁ for ▁ alias ▁ [ " + alias . name ( ) + " ] " , e ) ; } } }
gfyoung/elasticsearch | public void validateAlias ( String alias , String index , @ Nullable String indexRouting , Function < String , IndexMetaData > indexLookup ) { validateAliasStandalone ( alias , indexRouting ) ; if ( ! Strings . hasText ( index ) ) { throw new IllegalArgumentException ( " index ▁ name ▁ is ▁ required " ) ; } IndexMetaData indexNamedSameAsAlias = indexLookup . apply ( alias ) ; if ( indexNamedSameAsAlias != null ) { throw new InvalidAliasNameException ( indexNamedSameAsAlias . getIndex ( ) , alias , " an ▁ index ▁ exists ▁ with ▁ the ▁ same ▁ name ▁ as ▁ the ▁ alias " ) ; } }
gfyoung/elasticsearch | void validateAliasStandalone ( String alias , String indexRouting ) { if ( ! Strings . hasText ( alias ) ) { throw new IllegalArgumentException ( " alias ▁ name ▁ is ▁ required " ) ; } MetaDataCreateIndexService . validateIndexOrAliasName ( alias , InvalidAliasNameException :: new ) ; if ( indexRouting != null && indexRouting . indexOf ( ' , ' ) != - 1 ) { throw new IllegalArgumentException ( " alias ▁ [ " + alias + " ] ▁ has ▁ several ▁ index ▁ routing ▁ values ▁ associated ▁ with ▁ it " ) ; } }
gfyoung/elasticsearch | public void validateAliasFilter ( String alias , String filter , QueryShardContext queryShardContext , NamedXContentRegistry xContentRegistry ) { assert queryShardContext != null ; try ( XContentParser parser = XContentFactory . xContent ( filter ) . createParser ( xContentRegistry , LoggingDeprecationHandler . INSTANCE , filter ) ) { validateAliasFilter ( parser , queryShardContext ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " failed ▁ to ▁ parse ▁ filter ▁ for ▁ alias ▁ [ " + alias + " ] " , e ) ; } }
gfyoung/elasticsearch | public void validateAliasFilter ( String alias , byte [ ] filter , QueryShardContext queryShardContext , NamedXContentRegistry xContentRegistry ) { assert queryShardContext != null ; try ( XContentParser parser = XContentFactory . xContent ( filter ) . createParser ( xContentRegistry , LoggingDeprecationHandler . INSTANCE , filter ) ) { validateAliasFilter ( parser , queryShardContext ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( " failed ▁ to ▁ parse ▁ filter ▁ for ▁ alias ▁ [ " + alias + " ] " , e ) ; } }
smanvi-pivotal/geode | , optionContext = ConverterHint . MEMBERIDNAME , help = CliStrings . CREATE_GATEWAYRECEIVER__MEMBER__HELP ) String [ ] onMember , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__MANUALSTART , help = CliStrings . CREATE_GATEWAYRECEIVER__MANUALSTART__HELP ) Boolean manualStart , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__STARTPORT , help = CliStrings . CREATE_GATEWAYRECEIVER__STARTPORT__HELP ) Integer startPort , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__ENDPORT , help = CliStrings . CREATE_GATEWAYRECEIVER__ENDPORT__HELP ) Integer endPort , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__BINDADDRESS , help = CliStrings . CREATE_GATEWAYRECEIVER__BINDADDRESS__HELP ) String bindAddress , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__MAXTIMEBETWEENPINGS , help = CliStrings . CREATE_GATEWAYRECEIVER__MAXTIMEBETWEENPINGS__HELP ) Integer maximumTimeBetweenPings , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__SOCKETBUFFERSIZE , help = CliStrings . CREATE_GATEWAYRECEIVER__SOCKETBUFFERSIZE__HELP ) Integer socketBufferSize , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER , help = CliStrings . CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER__HELP ) String [ ] gatewayTransportFilters , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__HOSTNAMEFORSENDERS , help = CliStrings . CREATE_GATEWAYRECEIVER__HOSTNAMEFORSENDERS__HELP ) String hostnameForSenders ) { GatewayReceiverFunctionArgs gatewayReceiverFunctionArgs = new GatewayReceiverFunctionArgs ( manualStart , startPort , endPort , bindAddress , socketBufferSize , maximumTimeBetweenPings , gatewayTransportFilters , hostnameForSenders ) ; Set < DistributedMember > membersToCreateGatewayReceiverOn = getMembers ( onGroups , onMember ) ; List < CliFunctionResult > gatewayReceiverCreateResults = executeAndGetFunctionResult ( GatewayReceiverCreateFunction . INSTANCE , gatewayReceiverFunctionArgs , membersToCreateGatewayReceiverOn ) ; CommandResult result = ResultBuilder . buildResult ( gatewayReceiverCreateResults ) ; XmlEntity xmlEntity = findXmlEntity ( gatewayReceiverCreateResults ) ; if ( xmlEntity == null ) { return result ; } if ( onMember != null || getSharedConfiguration ( ) == null ) { result . setCommandPersisted ( false ) ; return result ; } getSharedConfiguration ( ) . addXmlEntity ( xmlEntity , onGroups ) ; return result ; }
smanvi-pivotal/geode | @ Override public Result preExecution ( GfshParseResult parseResult ) { Integer startPort = ( Integer ) parseResult . getParamValue ( " start - port " ) ; Integer endPort = ( Integer ) parseResult . getParamValue ( " end - port " ) ; if ( startPort == null ) { startPort = GatewayReceiver . DEFAULT_START_PORT ; } if ( endPort == null ) { endPort = GatewayReceiver . DEFAULT_END_PORT ; } if ( startPort > endPort ) { return ResultBuilder . createUserErrorResult ( " start - port ▁ must ▁ be ▁ smaller ▁ than ▁ end - port . " ) ; } return ResultBuilder . createInfoResult ( " " ) ; }
whiskeysierra/riptide | String getLogin ( ) { return login ; }
whiskeysierra/riptide | @ AfterEach void tearDown ( ) { executor . shutdown ( ) ; }
whiskeysierra/riptide | @ Test void shouldBuffer ( ) throws IOException { requestFactory . setBufferRequestBody ( true ) ; shouldReadContributors ( ) ; }
whiskeysierra/riptide | @ Test void shouldStream ( ) throws IOException { requestFactory . setBufferRequestBody ( false ) ; shouldReadContributors ( ) ; }
whiskeysierra/riptide | private void shouldReadContributors ( ) throws IOException { driver . addExpectation ( onRequestTo ( " / repos / zalando / riptide / contributors " ) , giveResponseAsBytes ( getResource ( " contributors . json " ) . openStream ( ) , " application / json " ) ) ; final AtomicReference < List < User > > reference = new AtomicReference < > ( ) ; http . get ( " / repos / { org } / { repo } / contributors " , " zalando " , " riptide " ) . dispatch ( series ( ) , on ( SUCCESSFUL ) . call ( listOf ( User . class ) , reference :: set ) ) . join ( ) ; final List < String > users = reference . get ( ) . stream ( ) . map ( User :: getLogin ) . collect ( toList ( ) ) ; assertThat ( users , hasItems ( " jhorstmann " , " lukasniemeier - zalando " , " whiskeysierra " ) ) ; }
stupidlittleboy/myprojectforsmu | @ Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View contactsLayout = inflater . inflate ( R . layout . complany_mana_layout , container , false ) ; return contactsLayout ; }
stupidlittleboy/myprojectforsmu | @ Override public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; init ( ) ; }
stupidlittleboy/myprojectforsmu | private void init ( ) { complanyMeeting = ( LinearLayout ) getActivity ( ) . findViewById ( R . id . layout_complany_meeting ) ; complanyContacts = ( LinearLayout ) getActivity ( ) . findViewById ( R . id . layout_complany_contacts ) ; complanyNotices = ( LinearLayout ) getActivity ( ) . findViewById ( R . id . layout_complany_noticts ) ; complanyMeeting . setOnClickListener ( this ) ; complanyContacts . setOnClickListener ( this ) ; complanyNotices . setOnClickListener ( this ) ; }
stupidlittleboy/myprojectforsmu | @ Override public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . layout_complany_meeting : ComplanyMeeting . startComplanyMeeting ( getActivity ( ) ) ; Toast . makeText ( getActivity ( ) , " 会议信息 " , Toast . LENGTH_SHORT ) . show ( ) ; break ; case R . id . layout_complany_contacts : ComplanyContacts . startComplanyContacts ( getActivity ( ) ) ; Toast . makeText ( getActivity ( ) , " 企业通讯录 " , Toast . LENGTH_SHORT ) . show ( ) ; break ; case R . id . layout_complany_noticts : ComplanyNotices . startComplanyNotices ( getActivity ( ) ) ; Toast . makeText ( getActivity ( ) , " 企业公告 " , Toast . LENGTH_SHORT ) . show ( ) ; break ; default : break ; } }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " seq " ) @ NotNull public Integer getSeq ( ) { return seq ; }
samuelfac/portalunico.siscomex.gov.br | public void setSeq ( Integer seq ) { this . seq = seq ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO seq ( Integer seq ) { this . seq = seq ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " codigoProduto " ) public Long getCodigoProduto ( ) { return codigoProduto ; }
samuelfac/portalunico.siscomex.gov.br | public void setCodigoProduto ( Long codigoProduto ) { this . codigoProduto = codigoProduto ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO codigoProduto ( Long codigoProduto ) { this . codigoProduto = codigoProduto ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " cpfCnpjRaiz " ) @ NotNull public String getCpfCnpjRaiz ( ) { return cpfCnpjRaiz ; }
samuelfac/portalunico.siscomex.gov.br | public void setCpfCnpjRaiz ( String cpfCnpjRaiz ) { this . cpfCnpjRaiz = cpfCnpjRaiz ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO cpfCnpjRaiz ( String cpfCnpjRaiz ) { this . cpfCnpjRaiz = cpfCnpjRaiz ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " numeroAto " ) @ NotNull public String getNumeroAto ( ) { return numeroAto ; }
samuelfac/portalunico.siscomex.gov.br | public void setNumeroAto ( String numeroAto ) { this . numeroAto = numeroAto ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO numeroAto ( String numeroAto ) { this . numeroAto = numeroAto ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ JsonProperty ( " numeroItem " ) @ NotNull public String getNumeroItem ( ) { return numeroItem ; }
samuelfac/portalunico.siscomex.gov.br | public void setNumeroItem ( String numeroItem ) { this . numeroItem = numeroItem ; }
samuelfac/portalunico.siscomex.gov.br | public RegimeEspecialIntegracaoDTO numeroItem ( String numeroItem ) { this . numeroItem = numeroItem ; return this ; }
samuelfac/portalunico.siscomex.gov.br | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " class ▁ RegimeEspecialIntegracaoDTO ▁ { \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ seq : ▁ " ) . append ( toIndentedString ( seq ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ codigoProduto : ▁ " ) . append ( toIndentedString ( codigoProduto ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ cpfCnpjRaiz : ▁ " ) . append ( toIndentedString ( cpfCnpjRaiz ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ numeroAto : ▁ " ) . append ( toIndentedString ( numeroAto ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ numeroItem : ▁ " ) . append ( toIndentedString ( numeroItem ) ) . append ( " \n " ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
allpaykz/webshop-service-examples | public ObjectFactory ( ) { }
allpaykz/webshop-service-examples | public WebShopResponseType createWebShopResponseType ( ) { return new WebShopResponseType ( ) ; }
allpaykz/webshop-service-examples | public TransationType createTransationType ( ) { return new TransationType ( ) ; }
allpaykz/webshop-service-examples | @ XmlElementDecl ( namespace = Constants . RESPONSE_XSD , name = " WebShopResponse " ) public JAXBElement < WebShopResponseType > createWebShopResponse ( WebShopResponseType value ) { return new JAXBElement < WebShopResponseType > ( _WebShopResponse_QNAME , WebShopResponseType . class , null , value ) ; }
apache/incubator-asterixdb | @ Test public void testNormalSequence ( ) throws HyracksDataException { int numMemoryComponents = 2 ; ILSMIndex mockIndex = Mockito . mock ( ILSMIndex . class ) ; String indexId = " mockIndexId " ; Mockito . when ( mockIndex . getNumberOfAllMemoryComponents ( ) ) . thenReturn ( numMemoryComponents ) ; Mockito . when ( mockIndex . getCurrentMemoryComponent ( ) ) . thenReturn ( Mockito . mock ( AbstractLSMMemoryComponent . class ) ) ; DatasetInfo dsInfo = new DatasetInfo ( 101 , null ) ; LSMComponentIdGenerator idGenerator = new LSMComponentIdGenerator ( numMemoryComponents , MIN_VALID_COMPONENT_ID ) ; LSMIOOperationCallback callback = new LSMIOOperationCallback ( dsInfo , mockIndex , idGenerator . getId ( ) , mockIndexCheckpointManagerProvider ( ) ) ; idGenerator . refresh ( ) ; long flushLsn = 1L ; ILSMComponentId nextComponentId = idGenerator . getId ( ) ; Map < String , Object > flushMap = new HashMap < > ( ) ; flushMap . put ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN , flushLsn ) ; flushMap . put ( LSMIOOperationCallback . KEY_NEXT_COMPONENT_ID , nextComponentId ) ; ILSMIndexAccessor firstAccessor = new TestLSMIndexAccessor ( new TestLSMIndexOperationContext ( mockIndex ) ) ; firstAccessor . getOpContext ( ) . setParameters ( flushMap ) ; FileReference firstTarget = new FileReference ( Mockito . mock ( IODeviceHandle . class ) , getComponentFileName ( ) ) ; LSMComponentFileReferences firstFiles = new LSMComponentFileReferences ( firstTarget , firstTarget , firstTarget ) ; FlushOperation firstFlush = new TestFlushOperation ( firstAccessor , firstTarget , callback , indexId , firstFiles , new LSMComponentId ( 0 , 0 ) ) ; callback . scheduled ( firstFlush ) ; callback . beforeOperation ( firstFlush ) ; idGenerator . refresh ( ) ; flushLsn = 2L ; nextComponentId = idGenerator . getId ( ) ; flushMap = new HashMap < > ( ) ; flushMap . put ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN , flushLsn ) ; flushMap . put ( LSMIOOperationCallback . KEY_NEXT_COMPONENT_ID , nextComponentId ) ; ILSMIndexAccessor secondAccessor = new TestLSMIndexAccessor ( new TestLSMIndexOperationContext ( mockIndex ) ) ; secondAccessor . getOpContext ( ) . setParameters ( flushMap ) ; FileReference secondTarget = new FileReference ( Mockito . mock ( IODeviceHandle . class ) , getComponentFileName ( ) ) ; LSMComponentFileReferences secondFiles = new LSMComponentFileReferences ( secondTarget , secondTarget , secondTarget ) ; FlushOperation secondFlush = new TestFlushOperation ( secondAccessor , secondTarget , callback , indexId , secondFiles , new LSMComponentId ( 1 , 1 ) ) ; callback . scheduled ( secondFlush ) ; callback . beforeOperation ( secondFlush ) ; Map < String , Object > firstFlushMap = firstFlush . getAccessor ( ) . getOpContext ( ) . getParameters ( ) ; long firstFlushLogLsn = ( Long ) firstFlushMap . get ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN ) ; Assert . assertEquals ( 1 , firstFlushLogLsn ) ; final ILSMDiskComponent diskComponent1 = mockDiskComponent ( ) ; firstFlush . setNewComponent ( diskComponent1 ) ; callback . afterOperation ( firstFlush ) ; callback . afterFinalize ( firstFlush ) ; callback . completed ( firstFlush ) ; Map < String , Object > secondFlushMap = secondFlush . getAccessor ( ) . getOpContext ( ) . getParameters ( ) ; long secondFlushLogLsn = ( Long ) secondFlushMap . get ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN ) ; Assert . assertEquals ( 2 , secondFlushLogLsn ) ; final ILSMDiskComponent diskComponent2 = mockDiskComponent ( ) ; secondFlush . setNewComponent ( diskComponent2 ) ; callback . afterOperation ( secondFlush ) ; callback . afterFinalize ( secondFlush ) ; callback . completed ( secondFlush ) ; }
apache/incubator-asterixdb | @ Test public void testAllocateComponentId ( ) throws HyracksDataException { int numMemoryComponents = 2 ; DatasetInfo dsInfo = new DatasetInfo ( 101 , null ) ; ILSMComponentIdGenerator idGenerator = new LSMComponentIdGenerator ( numMemoryComponents , MIN_VALID_COMPONENT_ID ) ; ILSMIndex mockIndex = Mockito . mock ( ILSMIndex . class ) ; Mockito . when ( mockIndex . getNumberOfAllMemoryComponents ( ) ) . thenReturn ( numMemoryComponents ) ; ILSMMemoryComponent mockComponent = Mockito . mock ( AbstractLSMMemoryComponent . class ) ; Mockito . when ( mockIndex . getCurrentMemoryComponent ( ) ) . thenReturn ( mockComponent ) ; LSMIOOperationCallback callback = new LSMIOOperationCallback ( dsInfo , mockIndex , idGenerator . getId ( ) , mockIndexCheckpointManagerProvider ( ) ) ; ILSMComponentId initialId = idGenerator . getId ( ) ; idGenerator . refresh ( ) ; long flushLsn = 1L ; ILSMComponentId nextComponentId = idGenerator . getId ( ) ; callback . allocated ( mockComponent ) ; callback . recycled ( mockComponent ) ; checkMemoryComponent ( initialId , mockComponent ) ; }
apache/incubator-asterixdb | @ Test public void testRecycleComponentId ( ) throws HyracksDataException { int numMemoryComponents = 2 ; DatasetInfo dsInfo = new DatasetInfo ( 101 , null ) ; ILSMComponentIdGenerator idGenerator = new LSMComponentIdGenerator ( numMemoryComponents , MIN_VALID_COMPONENT_ID ) ; ILSMIndex mockIndex = Mockito . mock ( ILSMIndex . class ) ; Mockito . when ( mockIndex . getNumberOfAllMemoryComponents ( ) ) . thenReturn ( numMemoryComponents ) ; ILSMMemoryComponent mockComponent = Mockito . mock ( AbstractLSMMemoryComponent . class ) ; Mockito . when ( mockIndex . getCurrentMemoryComponent ( ) ) . thenReturn ( mockComponent ) ; LSMIOOperationCallback callback = new LSMIOOperationCallback ( dsInfo , mockIndex , idGenerator . getId ( ) , mockIndexCheckpointManagerProvider ( ) ) ; String indexId = " mockIndexId " ; ILSMComponentId id = idGenerator . getId ( ) ; callback . recycled ( mockComponent ) ; checkMemoryComponent ( id , mockComponent ) ; Mockito . when ( mockIndex . isMemoryComponentsAllocated ( ) ) . thenReturn ( true ) ; for ( int i = 0 ; i < 100 ; i ++ ) { idGenerator . refresh ( ) ; ILSMComponentId expectedId = idGenerator . getId ( ) ; long flushLsn = 0L ; Map < String , Object > flushMap = new HashMap < > ( ) ; flushMap . put ( LSMIOOperationCallback . KEY_FLUSH_LOG_LSN , flushLsn ) ; flushMap . put ( LSMIOOperationCallback . KEY_NEXT_COMPONENT_ID , expectedId ) ; ILSMIndexAccessor accessor = new TestLSMIndexAccessor ( new TestLSMIndexOperationContext ( mockIndex ) ) ; accessor . getOpContext ( ) . setParameters ( flushMap ) ; FileReference target = new FileReference ( Mockito . mock ( IODeviceHandle . class ) , getComponentFileName ( ) ) ; LSMComponentFileReferences files = new LSMComponentFileReferences ( target , target , target ) ; FlushOperation flush = new TestFlushOperation ( accessor , target , callback , indexId , files , new LSMComponentId ( 0 , 0 ) ) ; callback . scheduled ( flush ) ; callback . beforeOperation ( flush ) ; callback . recycled ( mockComponent ) ; flush . setNewComponent ( mockDiskComponent ( ) ) ; callback . afterOperation ( flush ) ; callback . afterFinalize ( flush ) ; callback . completed ( flush ) ; checkMemoryComponent ( expectedId , mockComponent ) ; } }
apache/incubator-asterixdb | private void checkMemoryComponent ( ILSMComponentId expected , ILSMMemoryComponent memoryComponent ) throws HyracksDataException { ArgumentCaptor < ILSMComponentId > idArgument = ArgumentCaptor . forClass ( ILSMComponentId . class ) ; ArgumentCaptor < Boolean > forceArgument = ArgumentCaptor . forClass ( Boolean . class ) ; Mockito . verify ( memoryComponent ) . resetId ( idArgument . capture ( ) , forceArgument . capture ( ) ) ; assertEquals ( expected , idArgument . getValue ( ) ) ; assertEquals ( false , forceArgument . getValue ( ) . booleanValue ( ) ) ; Mockito . reset ( memoryComponent ) ; }
apache/incubator-asterixdb | private ILSMDiskComponent mockDiskComponent ( ) { ILSMDiskComponent component = Mockito . mock ( ILSMDiskComponent . class ) ; Mockito . when ( component . getMetadata ( ) ) . thenReturn ( Mockito . mock ( DiskComponentMetadata . class ) ) ; return component ; }
apache/incubator-asterixdb | protected IIndexCheckpointManagerProvider mockIndexCheckpointManagerProvider ( ) throws HyracksDataException { IIndexCheckpointManagerProvider indexCheckpointManagerProvider = Mockito . mock ( IIndexCheckpointManagerProvider . class ) ; IIndexCheckpointManager indexCheckpointManager = Mockito . mock ( IIndexCheckpointManager . class ) ; Mockito . doNothing ( ) . when ( indexCheckpointManager ) . flushed ( Mockito . anyLong ( ) , Mockito . anyLong ( ) , Mockito . anyLong ( ) ) ; Mockito . doReturn ( indexCheckpointManager ) . when ( indexCheckpointManagerProvider ) . get ( Mockito . any ( ) ) ; return indexCheckpointManagerProvider ; }
GeoSmartCity-CIP/gsc-datacatalogue | public UpdateShapeService ( ) { logger = Logger . getLogger ( this . getClass ( ) ) ; gsc007Dao = PersistenceServiceProvider . getService ( Gsc007DatasetPersistence . class ) ; gsc006Dao = PersistenceServiceProvider . getService ( Gsc006DatasourcePersistence . class ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | public List < Gsc007DatasetEntity > getUpdatableDatasets ( ) { String updatableDatasetsQuery = createGetUpdatableDatasetsQuery ( ) ; return gsc007Dao . getDatasets ( updatableDatasetsQuery ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | private String createGetUpdatableDatasetsQuery ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " SELECT ▁ * ▁ FROM ▁ " ) . append ( Constants . DATASETS_TABLE_NAME ) . append ( " ▁ dstT ▁ " ) ; sb . append ( " WHERE ▁ dstT . json - > > ' tobeingested ' ▁ = ▁ ' true ' ▁ AND ▁ ( " ) ; sb . append ( " to _ timestamp ( dstT . json - > > ' lastupdated ' , ' dd / MM / yyyy ▁ hh24 : mi : ss ' ) ▁ + ▁ " ) ; sb . append ( " ( CAST ( ( dstT . json - > > ' refreshinterval ' ) ▁ AS ▁ INTEGER ) ▁ * ▁ INTERVAL ▁ ' 1 ▁ hour ' ) ) " ) ; sb . append ( " < ▁ clock _ timestamp ( ) " ) ; return sb . toString ( ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | public Gsc007DatasetEntity updateFile ( Gsc007DatasetEntity dataset ) throws DCException { try { Long datasetId = dataset . getId ( ) ; String lastUpdateTimestamp = getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . LAST_UPDATE_TS ) ; String sourceURL = getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . URL ) ; Gsc006DatasourceEntity datasource = gsc006Dao . load ( Long . parseLong ( getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . DATASOURCE_ID_FIELD ) ) ) ; String destinationDirectory = getFieldValueFromJsonText ( datasource . getJson ( ) , Constants . PATH ) ; String fileName = getFieldValueFromJsonText ( dataset . getJson ( ) , Constants . DSET_REALNAME_FIELD ) ; String fileNameNoExtension = fileName . substring ( 0 , fileName . lastIndexOf ( " . " ) ) ; boolean updated = updateFile ( datasetId , sourceURL , fileNameNoExtension , destinationDirectory , lastUpdateTimestamp ) ; if ( updated ) { ObjectNode datasetNode = ( ( ObjectNode ) om . readTree ( dataset . getJson ( ) ) ) ; DateFormat formatter = new SimpleDateFormat ( " dd / MM / yyyy ▁ HH : mm : ss " ) ; String dateFormatted = formatter . format ( System . currentTimeMillis ( ) ) ; datasetNode . put ( Constants . LAST_UPDATE_TS , dateFormatted ) ; dataset . setJson ( om . writeValueAsString ( datasetNode ) ) ; return gsc007Dao . save ( dataset ) ; } return null ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private boolean updateFile ( Long datasetId , String sourceURL , String fileNameNoExtension , String destinationDirectory , String lastUpdateTimestamp ) throws DCException { try { File file = new File ( destinationDirectory + fileNameNoExtension + " . zip " ) ; if ( isFileModified ( sourceURL , file ) ) { String tempDestinationDirectory = destinationDirectory + " temp " ; File tempDir = new File ( tempDestinationDirectory ) ; if ( ! tempDir . exists ( ) ) { tempDir . mkdir ( ) ; } if ( datasetId != null ) { logger . info ( " Found ▁ new ▁ file ▁ for ▁ datasetId = " + datasetId + " . . . ▁ update ▁ in ▁ progress . " ) ; } FileUtils . copyURLToFile ( new URL ( sourceURL ) , file ) ; ZipInputStream zipIn = new ZipInputStream ( new FileInputStream ( destinationDirectory + fileNameNoExtension + " . zip " ) ) ; getZipFiles ( zipIn , tempDestinationDirectory ) ; File shpFile = new File ( destinationDirectory + fileNameNoExtension + " . shp " ) ; if ( shpFile . exists ( ) ) { String tempFilePath = tempDestinationDirectory + File . separator + fileNameNoExtension + " . shp " ; String oldFilePath = destinationDirectory + fileNameNoExtension + " . shp " ; logger . info ( " Check ▁ if ▁ metadata ▁ from ▁ " + tempFilePath + " ▁ file ▁ are ▁ equals ▁ to ▁ " + oldFilePath + " ▁ file " ) ; if ( ! metadataMatch ( tempFilePath , oldFilePath ) ) { logger . error ( " The ▁ retrieved ▁ file ▁ cannot ▁ be ▁ updated ▁ because ▁ its ▁ metadata ▁ do ▁ not ▁ match ▁ with ▁ the ▁ ones ▁ of ▁ the ▁ file ▁ that ▁ needs ▁ to ▁ be ▁ ovverridden " ) ; throw new DCException ( Constants . ER22 ) ; } else { FileUtils . copyDirectory ( tempDir , new File ( destinationDirectory ) ) ; } } else { FileUtils . copyDirectory ( tempDir , new File ( destinationDirectory ) ) ; } FileUtils . deleteDirectory ( tempDir ) ; return true ; } return false ; } catch ( DCException e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( e . getErrorCode ( ) ) ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private void getZipFiles ( ZipInputStream zipIn , String destDirectory ) throws DCException { try { ZipEntry entry = zipIn . getNextEntry ( ) ; while ( entry != null ) { String filePath = destDirectory + File . separator + entry . getName ( ) ; if ( ! entry . isDirectory ( ) ) { extractFile ( zipIn , filePath ) ; } else { File dir = new File ( filePath ) ; dir . mkdir ( ) ; } zipIn . closeEntry ( ) ; entry = zipIn . getNextEntry ( ) ; } zipIn . close ( ) ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private void extractFile ( ZipInputStream zipIn , String filePath ) throws IOException { BufferedOutputStream bos = new BufferedOutputStream ( new FileOutputStream ( filePath ) ) ; byte [ ] bytesIn = new byte [ 4096 ] ; int read = 0 ; while ( ( read = zipIn . read ( bytesIn ) ) != - 1 ) { bos . write ( bytesIn , 0 , read ) ; } bos . close ( ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | private boolean metadataMatch ( String tempFilePath , String localFilePath ) throws DCException { try { String tempFileMetadata = ServiceUtil . createJSONColumnsFromShapeFile ( tempFilePath ) ; String localFileMetadata = ServiceUtil . createJSONColumnsFromShapeFile ( localFilePath ) ; if ( localFileMetadata . equalsIgnoreCase ( tempFileMetadata ) ) { return true ; } return false ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private boolean isFileModified ( String sourceURL , File file ) throws DCException { return getRemoteLastModified ( sourceURL ) > getLocalLastModified ( file ) ; }
GeoSmartCity-CIP/gsc-datacatalogue | private long getRemoteLastModified ( String sourceURL ) throws DCException { try { URL url = new URL ( sourceURL ) ; HttpURLConnection httpCon = ( HttpURLConnection ) url . openConnection ( ) ; return httpCon . getLastModified ( ) ; } catch ( Exception e ) { logger . error ( " error ▁ trying ▁ to ▁ copy ▁ file " ) ; logger . error ( e ) ; throw new DCException ( Constants . ER21 ) ; } }
GeoSmartCity-CIP/gsc-datacatalogue | private long getLocalLastModified ( File file ) throws DCException { return file . lastModified ( ) ; }
Kangmo/bitcoinj | channelClient = new PaymentChannelClient ( wallet , myKey , maxValue , Sha256Hash . create ( serverId . getBytes ( ) ) , new PaymentChannelClient . ClientConnection ( ) { @ Override public void sendToServer ( Protos . TwoWayChannelMessage msg ) { wireParser . write ( msg ) ; } @ Override public void destroyConnection ( PaymentChannelCloseException . CloseReason reason ) { channelOpenFuture . setException ( new PaymentChannelCloseException ( " Payment ▁ channel ▁ client ▁ requested ▁ that ▁ the ▁ connection ▁ be ▁ closed : ▁ " + reason , reason ) ) ; wireParser . closeConnection ( ) ; } @ Override public void channelOpen ( boolean wasInitiated ) { wireParser . setSocketTimeout ( 0 ) ; channelOpenFuture . set ( PaymentChannelClientConnection . this ) ; } }
Kangmo/bitcoinj | wireParser = new ProtobufParser < Protos . TwoWayChannelMessage > ( new ProtobufParser . Listener < Protos . TwoWayChannelMessage > ( ) { @ Override public void messageReceived ( ProtobufParser < Protos . TwoWayChannelMessage > handler , Protos . TwoWayChannelMessage msg ) { try { channelClient . receiveMessage ( msg ) ; } catch ( InsufficientMoneyException e ) { channelOpenFuture . setException ( e ) ; } } @ Override public void connectionOpen ( ProtobufParser < Protos . TwoWayChannelMessage > handler ) { channelClient . connectionOpen ( ) ; } @ Override public void connectionClosed ( ProtobufParser < Protos . TwoWayChannelMessage > handler ) { channelClient . connectionClosed ( ) ; channelOpenFuture . setException ( new PaymentChannelCloseException ( " The ▁ TCP ▁ socket ▁ died " , PaymentChannelCloseException . CloseReason . CONNECTION_CLOSED ) ) ; } }
Kangmo/bitcoinj | public ListenableFuture < PaymentChannelClientConnection > getChannelOpenFuture ( ) { return channelOpenFuture ; }
Kangmo/bitcoinj | public PaymentChannelClientState state ( ) { return channelClient . state ( ) ; }
Kangmo/bitcoinj | public void settle ( ) { try { channelClient . settle ( ) ; } catch ( IllegalStateException e ) { } }
Kangmo/bitcoinj | public void disconnectWithoutSettlement ( ) { wireParser . closeConnection ( ) ; }
jasonstack/cassandra | public EncodingStats ( long minTimestamp , int minLocalDeletionTime , int minTTL ) { this . minTimestamp = minTimestamp == LivenessInfo . NO_TIMESTAMP ? TIMESTAMP_EPOCH : minTimestamp ; this . minLocalDeletionTime = minLocalDeletionTime == LivenessInfo . NO_EXPIRATION_TIME ? DELETION_TIME_EPOCH : minLocalDeletionTime ; this . minTTL = minTTL ; }
jasonstack/cassandra | public EncodingStats mergeWith ( EncodingStats that ) { long minTimestamp = this . minTimestamp == TIMESTAMP_EPOCH ? that . minTimestamp : ( that . minTimestamp == TIMESTAMP_EPOCH ? this . minTimestamp : Math . min ( this . minTimestamp , that . minTimestamp ) ) ; int minDelTime = this . minLocalDeletionTime == DELETION_TIME_EPOCH ? that . minLocalDeletionTime : ( that . minLocalDeletionTime == DELETION_TIME_EPOCH ? this . minLocalDeletionTime : Math . min ( this . minLocalDeletionTime , that . minLocalDeletionTime ) ) ; int minTTL = this . minTTL == TTL_EPOCH ? that . minTTL : ( that . minTTL == TTL_EPOCH ? this . minTTL : Math . min ( this . minTTL , that . minTTL ) ) ; return new EncodingStats ( minTimestamp , minDelTime , minTTL ) ; }
jasonstack/cassandra | @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; EncodingStats that = ( EncodingStats ) o ; return this . minLocalDeletionTime == that . minLocalDeletionTime && this . minTTL == that . minTTL && this . minTimestamp == that . minTimestamp ; }
jasonstack/cassandra | @ Override public int hashCode ( ) { return Objects . hash ( minTimestamp , minLocalDeletionTime , minTTL ) ; }
jasonstack/cassandra | @ Override public String toString ( ) { return String . format ( " EncodingStats ( ts = % d , ▁ ldt = % d , ▁ ttl = % d ) " , minTimestamp , minLocalDeletionTime , minTTL ) ; }
jasonstack/cassandra | public void update ( LivenessInfo info ) { if ( info . isEmpty ( ) ) return ; updateTimestamp ( info . timestamp ( ) ) ; if ( info . isExpiring ( ) ) { updateTTL ( info . ttl ( ) ) ; updateLocalDeletionTime ( info . localExpirationTime ( ) ) ; } }
jasonstack/cassandra | public void update ( Cell cell ) { updateTimestamp ( cell . timestamp ( ) ) ; if ( cell . isExpiring ( ) ) { updateTTL ( cell . ttl ( ) ) ; updateLocalDeletionTime ( cell . localDeletionTime ( ) ) ; } else if ( cell . isTombstone ( ) ) { updateLocalDeletionTime ( cell . localDeletionTime ( ) ) ; } }
jasonstack/cassandra | public void update ( DeletionTime deletionTime ) { if ( deletionTime . isLive ( ) ) return ; updateTimestamp ( deletionTime . markedForDeleteAt ( ) ) ; updateLocalDeletionTime ( deletionTime . localDeletionTime ( ) ) ; }
jasonstack/cassandra | public void updateTimestamp ( long timestamp ) { isTimestampSet = true ; minTimestamp = Math . min ( minTimestamp , timestamp ) ; }
jasonstack/cassandra | public void updateLocalDeletionTime ( int deletionTime ) { isDelTimeSet = true ; minDeletionTime = Math . min ( minDeletionTime , deletionTime ) ; }
jasonstack/cassandra | public void updateTTL ( int ttl ) { isTTLSet = true ; minTTL = Math . min ( minTTL , ttl ) ; }
jasonstack/cassandra | public void updateColumnSetPerRow ( long columnSetInRow ) { }
jasonstack/cassandra | public void updateHasLegacyCounterShards ( boolean hasLegacyCounterShards ) { }
jasonstack/cassandra | public EncodingStats get ( ) { return new EncodingStats ( isTimestampSet ? minTimestamp : TIMESTAMP_EPOCH , isDelTimeSet ? minDeletionTime : DELETION_TIME_EPOCH , isTTLSet ? minTTL : TTL_EPOCH ) ; }
jasonstack/cassandra | public void serialize ( EncodingStats stats , DataOutputPlus out ) throws IOException { out . writeUnsignedVInt ( stats . minTimestamp - TIMESTAMP_EPOCH ) ; out . writeUnsignedVInt ( stats . minLocalDeletionTime - DELETION_TIME_EPOCH ) ; out . writeUnsignedVInt ( stats . minTTL - TTL_EPOCH ) ; }
jasonstack/cassandra | public int serializedSize ( EncodingStats stats ) { return TypeSizes . sizeofUnsignedVInt ( stats . minTimestamp - TIMESTAMP_EPOCH ) + TypeSizes . sizeofUnsignedVInt ( stats . minLocalDeletionTime - DELETION_TIME_EPOCH ) + TypeSizes . sizeofUnsignedVInt ( stats . minTTL - TTL_EPOCH ) ; }
jasonstack/cassandra | public EncodingStats deserialize ( DataInputPlus in ) throws IOException { long minTimestamp = in . readUnsignedVInt ( ) + TIMESTAMP_EPOCH ; int minLocalDeletionTime = ( int ) in . readUnsignedVInt ( ) + DELETION_TIME_EPOCH ; int minTTL = ( int ) in . readUnsignedVInt ( ) + TTL_EPOCH ; return new EncodingStats ( minTimestamp , minLocalDeletionTime , minTTL ) ; }
FlorianHuebner/Adventurer-Conqueror-King-Mobile | @ Override public String getName ( ) { return DUNGEON_BASHING ; }
FlorianHuebner/Adventurer-Conqueror-King-Mobile | @ Override public String getDescription ( ) { return " The ▁ character ▁ is ▁ hardened ▁ to ▁ the ▁ heavy ▁ lifting ▁ and ▁ physical ▁ labor ▁ involved ▁ in ▁ " + " dungeon ▁ exploration . ▁ The ▁ character ▁ receives ▁ a ▁ + 4 ▁ bonus ▁ on ▁ throws ▁ to ▁ open ▁ doors ▁ " + " and ▁ similar ▁ acts ▁ of ▁ brute ▁ strength . " ; }
fernandoj92/mvca-parkinson | public FullEm ( MixedDataSet data , boolean reuseParameters , int restarts , int maxSteps , double threshold ) { super ( data ) ; use ( new EmParameters ( reuseParameters , restarts , 0 , maxSteps , threshold ) ) ; }
fernandoj92/mvca-parkinson | public FullEm ( MixedDataSet data ) { this ( data , true , 64 , 500 , 1e-2 ) ; }
fernandoj92/mvca-parkinson | @ Override protected Estimation [ ] createEstimations ( int size , Gltm model , Focus focus ) { Estimation [ ] estimations = new Estimation [ size ] ; for ( int i = 0 ; i < estimations . length ; i ++ ) estimations [ i ] = estimationFactory ( ) . createSimple ( model , data , parameters . smoothing ) ; return estimations ; }
jmockit/jmockit2 | public MockedTypeInfo ( @ Nonnull Type mockedType ) { Class < ? > mockedClass = Utilities . getClassType ( mockedType ) ; genericTypeMap = new GenericTypeReflection ( mockedClass , mockedType ) ; String signature = getGenericClassSignature ( mockedType ) ; String classDesc = mockedClass . getName ( ) . replace ( ' . ' , ' / ' ) ; implementationSignature = ' L ' + classDesc + signature ; }
giraudsa/serialisation | protected ActionJsonSimpleComportement ( final Class < T > type , final JsonUnmarshaller < ? > jsonUnmarshaller ) { super ( type , jsonUnmarshaller ) ; }
giraudsa/serialisation | @ Override protected void construitObjet ( ) { }
giraudsa/serialisation | @ Override public < U extends T > ActionAbstrait < U > getNewInstance ( final Class < U > type , final Unmarshaller unmarshaller ) { return new ActionJsonSimpleComportement < > ( type , ( JsonUnmarshaller < ? > ) unmarshaller ) ; }
giraudsa/serialisation | @ Override protected Class < ? > getTypeAttribute ( final String nomAttribut ) { if ( Constants . VALEUR . equals ( nomAttribut ) ) return type ; return null ; }
giraudsa/serialisation | @ Override protected < W > void integreObjet ( final String nomAttribut , final W objet ) { }
giraudsa/serialisation | @ Override protected void rempliData ( final String donnees ) throws InstanciationException { try { obj = type . getConstructor ( String . class ) . newInstance ( donnees ) ; } catch ( InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e ) { throw new InstanciationException ( " impossible ▁ de ▁ trouver ▁ un ▁ constructeur ▁ avec ▁ un ▁ string ▁ pour ▁ le ▁ type ▁ " + type . getName ( ) , e ) ; } }
aws/aws-sdk-java | if ( defaultMetricsEnabled ) { String [ ] values = defaultMetrics . split ( " , " ) ; boolean excludeMachineMetrics = false ; boolean includePerHostMetrics = false ; boolean useSingleMetricNamespace = false ; boolean enableHttpSocketReadMetric = false ; for ( String s : values ) { String part = s . trim ( ) ; if ( ! excludeMachineMetrics && EXCLUDE_MACHINE_METRICS . equals ( part ) ) { excludeMachineMetrics = true ; } else if ( ! includePerHostMetrics && INCLUDE_PER_HOST_METRICS . equals ( part ) ) { includePerHostMetrics = true ; } else if ( ! useSingleMetricNamespace && USE_SINGLE_METRIC_NAMESPACE . equals ( part ) ) { useSingleMetricNamespace = true ; } else if ( ! enableHttpSocketReadMetric && ENABLE_HTTP_SOCKET_READ_METRIC . equals ( part ) ) { enableHttpSocketReadMetric = true ; } else { String [ ] pair = part . split ( " = " ) ; if ( pair . length == 2 ) { String key = pair [ 0 ] . trim ( ) ; String value = pair [ 1 ] . trim ( ) ; try { if ( AWS_CREDENTIAL_PROPERTIES_FILE . equals ( key ) ) { setCredentialFile0 ( value ) ; } else if ( CLOUDWATCH_REGION . equals ( key ) ) { region = RegionUtils . getRegion ( value ) ; } else if ( METRIC_QUEUE_SIZE . equals ( key ) ) { Integer i = Integer . valueOf ( value ) ; if ( i . intValue ( ) < 1 ) throw new IllegalArgumentException ( METRIC_QUEUE_SIZE + " ▁ must ▁ be ▁ at ▁ least ▁ 1" ) ; metricQueueSize = i ; } else if ( QUEUE_POLL_TIMEOUT_MILLI . equals ( key ) ) { Long i = Long . valueOf ( value ) ; if ( i . intValue ( ) < 1000 ) throw new IllegalArgumentException ( QUEUE_POLL_TIMEOUT_MILLI + " ▁ must ▁ be ▁ at ▁ least ▁ 1000" ) ; queuePollTimeoutMilli = i ; } else if ( METRIC_NAME_SPACE . equals ( key ) ) { metricNameSpace = value ; } else if ( JVM_METRIC_NAME . equals ( key ) ) { jvmMetricName = value ; } else if ( HOST_METRIC_NAME . equals ( key ) ) { hostMetricName = value ; } else { LogFactory . getLog ( AwsSdkMetrics . class ) . debug ( " Ignoring ▁ unrecognized ▁ parameter : ▁ " + part ) ; } } catch ( Exception e ) { LogFactory . getLog ( AwsSdkMetrics . class ) . debug ( " Ignoring ▁ failure " , e ) ; } } } } machineMetricsExcluded = excludeMachineMetrics ; perHostMetricsIncluded = includePerHostMetrics ; singleMetricNamespace = useSingleMetricNamespace ; httpSocketReadMetricEnabled = enableHttpSocketReadMetric ; }
aws/aws-sdk-java | catch ( Exception ex ) { LogFactory . getLog ( AwsSdkMetrics . class ) . warn ( " " , ex ) ; }
aws/aws-sdk-java | synchronized ( AwsSdkMetrics . class ) { credentialProvider = new AWSCredentialsProvider ( ) { @ Override public void refresh ( ) { } @ Override public AWSCredentials getCredentials ( ) { return cred ; } } ; AwsSdkMetrics . credentialFile = filepath ; }
aws/aws-sdk-java | MetricRegistry ( ) { metricTypes . add ( Field . ClientExecuteTime ) ; metricTypes . add ( Field . Exception ) ; metricTypes . add ( Field . ThrottleException ) ; metricTypes . add ( Field . HttpClientRetryCount ) ; metricTypes . add ( Field . HttpRequestTime ) ; metricTypes . add ( Field . RequestCount ) ; metricTypes . add ( Field . RetryCount ) ; metricTypes . add ( Field . RetryCapacityConsumed ) ; metricTypes . add ( Field . ThrottledRetryCount ) ; metricTypes . add ( Field . HttpClientSendRequestTime ) ; metricTypes . add ( Field . HttpClientReceiveResponseTime ) ; metricTypes . add ( Field . HttpSocketReadTime ) ; metricTypes . add ( Field . HttpClientPoolAvailableCount ) ; metricTypes . add ( Field . HttpClientPoolLeasedCount ) ; metricTypes . add ( Field . HttpClientPoolPendingCount ) ; metricTypes . add ( AWSServiceMetrics . HttpClientGetConnectionTime ) ; syncReadOnly ( ) ; }
aws/aws-sdk-java | private void syncReadOnly ( ) { readOnly = Collections . unmodifiableSet ( new HashSet < MetricType > ( metricTypes ) ) ; }
aws/aws-sdk-java | public boolean addMetricType ( MetricType type ) { synchronized ( metricTypes ) { boolean added = metricTypes . add ( type ) ; if ( added ) syncReadOnly ( ) ; return added ; } }
aws/aws-sdk-java | public < T extends MetricType > boolean addMetricTypes ( Collection < T > types ) { synchronized ( metricTypes ) { boolean added = metricTypes . addAll ( types ) ; if ( added ) syncReadOnly ( ) ; return added ; } }
aws/aws-sdk-java | public < T extends MetricType > void setMetricTypes ( Collection < T > types ) { synchronized ( metricTypes ) { if ( types == null || types . size ( ) == 0 ) { if ( metricTypes . size ( ) == 0 ) return ; if ( types == null ) types = Collections . emptyList ( ) ; } metricTypes . clear ( ) ; if ( ! addMetricTypes ( types ) ) { syncReadOnly ( ) ; } } }
aws/aws-sdk-java | public boolean removeMetricType ( MetricType type ) { synchronized ( metricTypes ) { boolean removed = metricTypes . remove ( type ) ; if ( removed ) syncReadOnly ( ) ; return removed ; } }
aws/aws-sdk-java | public Set < MetricType > predefinedMetrics ( ) { return readOnly ; }
saga810203/jfw | public AbstractJobInfo ( String pId , String pName , String pDescrption , boolean pMoreRunning , JobSchedulerMode pJsm ) { this . name = pName ; this . jobId = pId ; this . descrption = pDescrption ; this . jsm = pJsm ; this . moreRunning = pMoreRunning ; }
saga810203/jfw | @ Override synchronized public JobInfo cloneJobInfo ( ) { ReadOnlyJobInfo roji = new ReadOnlyJobInfo ( this . jobId , this . name , this . descrption , this . moreRunning , this . jsm ) ; roji . actived = this . actived ; roji . errorReason = this . errorReason ; roji . firstBeginTime = this . firstBeginTime ; roji . firstEndTime = this . firstEndTime ; roji . lastBeginTime = this . lastBeginTime ; roji . lastEndTime = this . lastEndTime ; roji . lastErrorTime = this . lastErrorTime ; roji . lastHandleDataTime = this . lastHandleDataTime ; roji . lastThrowable = this . lastThrowable ; roji . nextRunningTime = this . nextRunningTime ; roji . noHandleDataReason = this . noHandleDataReason ; roji . noHandleDataTime = this . noHandleDataTime ; roji . numForFailrue = this . numForFailrue ; roji . numForHandleData = this . numForHandleData ; roji . numForRunning = this . numForRunning ; return roji ; }
saga810203/jfw | @ Override public String getLastErrorReason ( ) { return this . errorReason ; }
saga810203/jfw | @ Override public String getLastNoHandleDataReason ( ) { return this . noHandleDataReason ; }
saga810203/jfw | @ Override public long getNextRunningTime ( ) { return this . nextRunningTime ; }
saga810203/jfw | @ Override public long getNumForRunning ( ) { return this . numForRunning ; }
saga810203/jfw | @ Override public long getNumForHandleData ( ) { return this . numForHandleData ; }
saga810203/jfw | @ Override public long getNumForFailrue ( ) { return this . numForFailrue ; }
saga810203/jfw | @ Override public long getLastEndTime ( ) { return 0 ; }
saga810203/jfw | @ Override public long getLastHandleDataTime ( ) { return this . lastHandleDataTime ; }
saga810203/jfw | @ Override synchronized public void updateJobInfoBeforeExecuted ( ReadableExecutedInfo rei ) { if ( this . firstBeginTime == - 1 ) this . firstBeginTime = rei . getBeginTime ( ) ; this . lastBeginTime = rei . getBeginTime ( ) ; this . updateNextRunningTime ( true ) ; }
saga810203/jfw | @ Override public long getLastErrorTime ( ) { return this . lastErrorTime ; }
saga810203/jfw | @ Override public Throwable getLastThrowable ( ) { return this . lastThrowable ; }
saga810203/jfw | @ Override public String getId ( ) { return this . jobId ; }
saga810203/jfw | @ Override public String getName ( ) { return this . name ; }
saga810203/jfw | @ Override public boolean isActived ( ) { return this . actived ; }
saga810203/jfw | @ Override public void active ( boolean isActived ) { this . actived = isActived ; }
saga810203/jfw | @ Override public String getDescrption ( ) { return this . descrption ; }
saga810203/jfw | @ Override synchronized public void updateJobInfoAfterExecuted ( ReadableExecutedInfo rei ) { if ( this . firstEndTime == - 1 ) this . firstEndTime = rei . getEndTime ( ) ; this . lastEndTime = rei . getEndTime ( ) ; if ( this . lastEndTime == - 1 ) this . lastEndTime = System . currentTimeMillis ( ) ; ++ numForRunning ; if ( ! rei . isSuccessTermination ( ) ) { ++ numForFailrue ; this . lastErrorTime = this . lastEndTime ; this . lastThrowable = rei . getFailureException ( ) ; this . errorReason = rei . getFailureReason ( ) ; } if ( rei . isHanlded ( ) ) { ++ numForHandleData ; this . lastHandleDataTime = this . lastEndTime ; } else { this . noHandleDataReason = rei . getNotHandledReason ( ) ; this . noHandleDataTime = this . lastEndTime ; } updateNextRunningTime ( false ) ; }
saga810203/jfw | @ Override public boolean isMoreRunningJob ( ) { return this . moreRunning ; }
saga810203/jfw | @ Override public JobSchedulerMode getJobSchedulerMode ( ) { return this . jsm ; }
saga810203/jfw | @ Override public long getLastNoHandleDataTime ( ) { return this . noHandleDataTime ; }
saga810203/jfw | @ Override public long getLastBeginTime ( ) { return this . lastBeginTime ; }
OpenConext/OpenConext-api | if ( ! openSAMLContext . isSAMLResponse ( req ) ) { LOG . debug ( " Request ▁ is ▁ not ▁ a ▁ SAML ▁ response . ▁ Will ▁ continue ▁ filter ▁ chain . " ) ; chain . doFilter ( request , response ) ; return ; }
OpenConext/OpenConext-api | catch ( IOException e ) { LOG . info ( " Cannot ▁ redirect ▁ to ▁ original ▁ url " , e ) ; }
OpenConext/OpenConext-api | protected Object getPreAuthenticatedPrincipal ( HttpServletRequest request ) { if ( ! openSAMLContext . isSAMLResponse ( request ) ) { return null ; } Response samlResponse = openSAMLContext . extractSamlResponse ( request ) ; final UserDetails ud = openSAMLContext . authenticate ( samlResponse ) ; Assert . notNull ( ud , " Authentication ▁ using ▁ a ▁ saml ▁ response ▁ should ▁ always ▁ yield ▁ a ▁ UserDetails . " ) ; return new ClientMetaDataPrincipal ( ud . getUsername ( ) ) ; }
linkedin/PalDB | private StoreImpl ( ) { }
lime-company/lime-security-powerauth-webauth | public AuthenticationContext ( ) { }
lime-company/lime-security-powerauth-webauth | public AuthenticationContext ( PasswordProtectionType passwordProtection , String cipherTransformation ) { this . passwordProtection = passwordProtection ; this . cipherTransformation = cipherTransformation ; }
lime-company/lime-security-powerauth-webauth | public AuthenticationContext ( PasswordProtectionType passwordProtection , String cipherTransformation , SmsAuthorizationResult smsAuthorizationResult ) { this . passwordProtection = passwordProtection ; this . cipherTransformation = cipherTransformation ; this . smsAuthorizationResult = smsAuthorizationResult ; }
lime-company/lime-security-powerauth-webauth | public PasswordProtectionType getPasswordProtection ( ) { return passwordProtection ; }
lime-company/lime-security-powerauth-webauth | public void setPasswordProtection ( PasswordProtectionType passwordProtection ) { this . passwordProtection = passwordProtection ; }
lime-company/lime-security-powerauth-webauth | public String getCipherTransformation ( ) { return cipherTransformation ; }
lime-company/lime-security-powerauth-webauth | public void setCipherTransformation ( String cipherTransformation ) { this . cipherTransformation = cipherTransformation ; }
lime-company/lime-security-powerauth-webauth | public SmsAuthorizationResult getSmsAuthorizationResult ( ) { return smsAuthorizationResult ; }
lime-company/lime-security-powerauth-webauth | public void setSmsAuthorizationResult ( SmsAuthorizationResult smsAuthorizationResult ) { this . smsAuthorizationResult = smsAuthorizationResult ; }
ZiglioNZ/construct | i ++ ) { byte [ ] bin = int_to_bin ( i , 8 ) ; _char_to_bin [ i ] = bin ; }
Springws/Springweather | public int getErrNum ( ) { return errNum ; }
Springws/Springweather | public void setErrNum ( int errNum ) { this . errNum = errNum ; }
Springws/Springweather | public RetDataInfo getRetData ( ) { return retData ; }
Springws/Springweather | public void setRetData ( RetDataInfo retData ) { this . retData = retData ; }
Springws/Springweather | public String getErrMsg ( ) { return errMsg ; }
Springws/Springweather | public void setErrMsg ( String errMsg ) { this . errMsg = errMsg ; }
javidcf/masmusic | public MusicInputTracker ( ) { onsets = new ArrayList < > ( ) ; }
javidcf/masmusic | @ Override public String getStatementQuery ( ) { return " select " + " ▁ noteOnset ( * ) ▁ as ▁ onset " + " ▁ from ▁ TimeSpanNote . win : time ( " + ANALYSIS_WINDOW + " ▁ msec ) ▁ " + " ▁ output ▁ snapshot ▁ every ▁ " + ANALYSIS_FREQUENCY + " ▁ msec " + " ▁ order ▁ by ▁ timestamp ▁ asc " ; }
javidcf/masmusic | public void updateStart ( int countNew , int countOld ) { onsets . clear ( ) ; }
javidcf/masmusic | public void update ( Map < String , Onset > eventMap ) { onsets . add ( eventMap . get ( " onset " ) ) ; }
javidcf/masmusic | public void updateEnd ( ) { if ( ! onsets . isEmpty ( ) ) { publisher . publishEvent ( new MusicInputBufferUpdatedEvent ( this , onsets ) ) ; } }
noties/Storm2.0 | @ Test public void testNullCursor ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( null , null ) ; assertTrue ( iterator . isClosed ( ) ) ; assertTrue ( iterator . getCount ( ) == 0 ) ; assertTrue ( ! iterator . hasNext ( ) ) ; try { iterator . get ( 0 ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } try { iterator . next ( ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | @ Test public void testRemove ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( null , null ) ; try { iterator . remove ( ) ; assertTrue ( false ) ; } catch ( UnsupportedOperationException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | public void testBaseCursor ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { private boolean mIsClosed ; @ Override public int getCount ( ) { return 5 ; } @ Override public boolean moveToPosition ( int position ) { return position < 5 ; } @ Override public void close ( ) { mIsClosed = true ; } @ Override public boolean isClosed ( ) { return mIsClosed ; } } , null ) ; assertTrue ( iterator . hasNext ( ) ) ; assertTrue ( ! iterator . isClosed ( ) ) ; assertTrue ( iterator . getCount ( ) == 5 ) ; try { iterator . get ( 5 ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } iterator . close ( ) ; assertTrue ( ! iterator . hasNext ( ) ) ; assertTrue ( iterator . isClosed ( ) ) ; assertTrue ( iterator . getCount ( ) == 0 ) ; try { iterator . next ( ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | @ Test public void testWithParser ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { @ Override public int getCount ( ) { return 3 ; } @ Override public boolean moveToPosition ( int position ) { return position < 3 ; } } , new CursorIteratorParser < Object > ( ) { @ Override public Object parse ( Cursor cursor ) { return new Object ( ) ; } } ) ; Object o ; for ( int i = 0 , count = iterator . getCount ( ) ; i < count ; i ++ ) { o = iterator . get ( i ) ; assertTrue ( o != null ) ; } try { iterator . get ( 3 ) ; assertTrue ( false ) ; } catch ( IllegalStateException e ) { assertTrue ( true ) ; } }
noties/Storm2.0 | @ Test public void testForEach ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { @ Override public int getCount ( ) { return 2 ; } @ Override public boolean moveToPosition ( int position ) { return position < 2 ; } } , new CursorIteratorParser < Object > ( ) { @ Override public Object parse ( Cursor cursor ) { return new Object ( ) ; } } ) ; int iterated = 0 ; for ( Object o : iterator ) { iterated ++ ; } assertTrue ( iterated == 2 ) ; }
noties/Storm2.0 | @ Test public void testNullParser ( ) { final CursorIterator < Object > iterator = new CursorIteratorBaseImpl < > ( new CursorMock ( ) { @ Override public int getCount ( ) { return 4 ; } @ Override public boolean moveToPosition ( int position ) { return position < 4 ; } } , null ) ; try { for ( Object o : iterator ) { ; } assertTrue ( false ) ; } catch ( NullPointerException e ) { assertTrue ( true ) ; } }
Anadyr/OSRSe | public XTEA ( int [ ] xtea_keys , byte [ ] bytes , int startOffset ) { this . keys = xtea_keys ; this . data = bytes ; this . startOffset = startOffset ; }
Anadyr/OSRSe | public byte [ ] decipher ( ) { int offset = startOffset ; int length = data . length - startOffset ; int qword_count = ( length - offset ) / 8 ; ByteBuffer inbb = ByteBuffer . wrap ( data ) ; ByteBuffer outbb = ByteBuffer . allocate ( data . length ) ; for ( int i = 0 ; i < startOffset ; i ++ ) { outbb . put ( inbb . get ( ) ) ; } for ( int qword_pos = 0 ; qword_pos < qword_count ; qword_pos ++ ) { int dword_1 = inbb . getInt ( ) ; int dword_2 = inbb . getInt ( ) ; int const_1 = - 957401312 ; int const_2 = - 1640531527 ; int run_count = 32 ; while ( ( run_count -- ^ 0xffffffff ) < - 1 ) { dword_2 -= ( ( dword_1 >>> - 1563092443 ^ dword_1 << 611091524 ) + dword_1 ^ const_1 + keys [ const_1 >>> - 1002502837 & 0x56c00003 ] ) ; const_1 -= const_2 ; dword_1 -= ( ( dword_2 >>> 1337206757 ^ dword_2 << 363118692 ) - - dword_2 ^ const_1 + keys [ const_1 & 0x3 ] ) ; } outbb . putInt ( dword_1 ) ; outbb . putInt ( dword_2 ) ; } byte [ ] remaining = new byte [ inbb . remaining ( ) ] ; inbb . get ( remaining ) ; outbb . put ( remaining ) ; outbb . flip ( ) ; return outbb . array ( ) ; }
Anadyr/OSRSe | private void decipher ( int [ ] block ) { long sum = ( long ) SUM ; for ( int i = 0 ; i < NUM_ROUNDS ; i ++ ) { block [ 1 ] -= ( keys [ ( int ) ( ( sum & 0x1933 ) >>> 11 ) ] + sum ^ block [ 0 ] + ( block [ 0 ] << 4 ^ block [ 0 ] >>> 5 ) ) ; sum -= DELTA ; block [ 0 ] -= ( ( block [ 1 ] << 4 ^ block [ 1 ] >>> 5 ) + block [ 1 ] ^ keys [ ( int ) ( sum & 0x3 ) ] + sum ) ; } }
Anadyr/OSRSe | public byte [ ] decrypt ( int length ) { int numBlocks = length / 8 ; int [ ] block = new int [ 2 ] ; for ( int i = 0 ; i < numBlocks ; i ++ ) { block [ 0 ] = StreamUtilities . readInt ( ( i * 8 ) + startOffset , data ) ; block [ 1 ] = StreamUtilities . readInt ( ( i * 8 ) + startOffset + 4 , data ) ; decipher ( block ) ; StreamUtilities . writeInt ( block [ 0 ] , ( i * 8 ) + startOffset , data ) ; StreamUtilities . writeInt ( block [ 1 ] , ( i * 8 ) + startOffset + 4 , data ) ; } return data ; }
Team4761/TShirt-Cannon | public AlignGatling ( ) { requires ( Robot . cannonSubsystem ) ; }
Team4761/TShirt-Cannon | protected void initialize ( ) { Robot . cannonSubsystem . PID = false ; }
Team4761/TShirt-Cannon | protected void execute ( ) { Robot . cannonSubsystem . spinGatling ( 0.5 ) ; }
Team4761/TShirt-Cannon | protected boolean isFinished ( ) { return Robot . cannonSubsystem . getAligned ( ) ; }
Team4761/TShirt-Cannon | protected void end ( ) { Robot . cannonSubsystem . spinGatling ( 0 ) ; }
Team4761/TShirt-Cannon | protected void interrupted ( ) { Robot . cannonSubsystem . spinGatling ( 0 ) ; }
username115/FRCScouting | @ Override public void onCreatePreferences ( @ Nullable Bundle savedInstanceState , @ Nullable String rootKey ) { setPreferencesFromResource ( R . xml . mainprefs , rootKey ) ; passP = findPreference ( " passPref " ) ; urlP = findPreference ( " databaseURLPref " ) ; syncPreference = findPreference ( " enableSyncPref " ) ; passP . setOnPreferenceChangeListener ( new onPassChangeListener ( true ) ) ; urlP . setOnPreferenceChangeListener ( new onPassChangeListener ( false ) ) ; syncPreference . setOnPreferenceChangeListener ( new OnSyncChangeListener ( ) ) ; findPreference ( " syncFreqPref " ) . setEnabled ( getAutoSync ( getPreferenceManager ( ) . getContext ( ) , false ) ) ; eventP = findPreference ( " eventPref " ) ; db = new DB ( getPreferenceManager ( ) . getContext ( ) , binder ) ; List < String > events = db . getEventList ( ) ; if ( events != null ) updateEventPreference ( events ) ; Intent intent = new Intent ( getPreferenceManager ( ) . getContext ( ) , DBSyncService . class ) ; getPreferenceManager ( ) . getContext ( ) . bindService ( intent , watcher , Context . BIND_AUTO_CREATE ) ; }
username115/FRCScouting | @ Override public void onDestroyView ( ) { super . onDestroyView ( ) ; unbindDB ( ) ; }
username115/FRCScouting | public void unbindDB ( ) { getPreferenceManager ( ) . getContext ( ) . unbindService ( watcher ) ; }
username115/FRCScouting | public void onServiceConnected ( ComponentName name , IBinder service ) { if ( service instanceof LocalBinder ) { binder = ( LocalBinder ) service ; db . setBinder ( binder ) ; } }
username115/FRCScouting | public void onServiceDisconnected ( ComponentName name ) { }
username115/FRCScouting | private void updateEventPreference ( List < String > events ) { if ( ! events . isEmpty ( ) ) { Collections . sort ( events ) ; String [ ] entries = events . toArray ( new String [ 0 ] ) ; eventP . setEntries ( entries ) ; eventP . setEntryValues ( entries ) ; } }
username115/FRCScouting | public onPassChangeListener ( boolean pass ) { isPass = pass ; }
username115/FRCScouting | public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( isPass ) { DB db = new DB ( getPreferenceManager ( ) . getContext ( ) , null ) ; db . checkPass ( newValue . toString ( ) , new PasswordCallback ( true ) ) ; } else { String ret = newValue . toString ( ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } binder . refreshNotification ( ret ) ; } return true ; }
username115/FRCScouting | @ Override public boolean onPreferenceChange ( @ NonNull Preference preference , Object newValue ) { if ( ! ( newValue instanceof Boolean ) ) return false ; Boolean checked = ( Boolean ) newValue ; findPreference ( " syncFreqPref " ) . setEnabled ( checked ) ; return true ; }
username115/FRCScouting | public PasswordCallback ( boolean pass ) { isPass = pass ; }
username115/FRCScouting | @ Override public void onResponse ( @ NonNull String resp ) { Toast toast ; try { if ( resp . contains ( " success " ) ) { toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Password ▁ confirmed " , Toast . LENGTH_SHORT ) ; if ( binder != null ) { binder . setPassword ( getSavedPassword ( getPreferenceManager ( ) . getContext ( ) ) ) ; binder . initSync ( ) ; } } else toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Invalid ▁ password " , Toast . LENGTH_SHORT ) ; } catch ( Exception e ) { toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Invalid ▁ password " , Toast . LENGTH_SHORT ) ; } if ( isPass ) toast . show ( ) ; }
username115/FRCScouting | @ Override public void onError ( @ NonNull VolleyError e ) { Toast toast = Toast . makeText ( getPreferenceManager ( ) . getContext ( ) , " Cannot ▁ connect ▁ to ▁ Server " , Toast . LENGTH_SHORT ) ; toast . show ( ) ; }
hs71122/qualify-me | @ Test public void contextLoads ( ) { }
ngerakines/elasticservices | @ Bean public MessageFactory gossipMessageFactory ( ) { return new DefaultMessageFactory ( ImmutableList . < Message > of ( GossipServiceProto . ComponentOnline . getDefaultInstance ( ) , GossipServiceProto . ComponentStatus . getDefaultInstance ( ) ) ) ; }
ngerakines/elasticservices | @ Bean public ServiceProto . ServiceRef gossipServiceRef ( ) { return ServiceProto . ServiceRef . newBuilder ( ) . setComponentRef ( localComponentRef ) . setServiceId ( " gossip " ) . build ( ) ; }
ngerakines/elasticservices | @ Bean public TestPresenceListener testPresenceListener ( ) { return new TestPresenceListener ( ) ; }
ngerakines/elasticservices | @ Bean public Service gossipService ( ) { final List < ServicePresenceListener > servicePresenceListeners = Lists . newArrayList ( ) ; if ( serviceRegistry instanceof DefaultServiceRegistry ) { servicePresenceListeners . add ( ( ServicePresenceListener ) serviceRegistry ) ; } servicePresenceListeners . add ( testPresenceListener ( ) ) ; return new GossipService ( gossipMessageFactory ( ) , gossipServiceRef ( ) , servicePresenceListeners ) ; }
ngerakines/elasticservices | @ Bean public Work broadcastWork ( ) { return new BroadcastWork ( gossipServiceRef ( ) , serviceRegistry ) ; }
ngerakines/elasticservices | @ Bean public Ref mockGossipTransportRef ( ) { return RefUtils . localTransportRef ( " gossip " ) ; }
ngerakines/elasticservices | @ Bean public Transport mockGossipTransport ( ) { final Transport transport = mock ( Transport . class ) ; when ( transport . getRef ( ) ) . thenReturn ( mockGossipTransportRef ( ) ) ; return transport ; }
ngerakines/elasticservices | @ PostConstruct public void registerService ( ) { serviceRegistry . registerService ( gossipService ( ) , mockGossipTransport ( ) ) ; if ( localTransportClientFactory instanceof LocalTransportClientFactory ) { final LocalTransportClientFactory localTransportClientFactoryImpl = ( LocalTransportClientFactory ) localTransportClientFactory ; localTransportClientFactoryImpl . addService ( " gossip " , gossipService ( ) ) ; } serviceRegistry . initTransportClient ( gossipServiceRef ( ) , mockGossipTransportRef ( ) ) ; }
ngerakines/elasticservices | @ Test public void load ( ) { Assert . assertNotNull ( gossipService ) ; Assert . assertTrue ( waitUntil ( new Callable < Integer > ( ) { @ Override public Integer call ( ) throws Exception { return testPresenceListener . getCount ( ) ; } } , 3 , 60 ) ) ; Assert . assertTrue ( testPresenceListener . getCount ( ) > 0 ) ; }
ngerakines/elasticservices | private < T > boolean waitUntil ( final Callable < T > callable , final T value , final int seconds ) { final DateTime start = DateTime . now ( ) ; while ( DateTime . now ( ) . isBefore ( start . plusSeconds ( seconds ) ) ) { try { if ( callable . call ( ) . equals ( value ) ) { return true ; } Thread . sleep ( TimeUnit . SECONDS . toMillis ( 1 ) ) ; } catch ( final Exception e ) { return false ; } } return false ; }
ngerakines/elasticservices | @ Override public void updateComponentServices ( final ServiceProto . ComponentRef componentRef , final Multimap < ServiceProto . ServiceRef , String > services , final Multimap < ServiceProto . ServiceRef , Integer > serviceFlags ) { LOGGER . info ( " counter ▁ now ▁ at ▁ { } . " , counter . incrementAndGet ( ) ) ; }
ngerakines/elasticservices | public int getCount ( ) { return counter . get ( ) ; }
google/binnavi | public CInstructionUpdater ( final ZyGraph graph ) { m_graph = graph ; }
google/binnavi | private void rebuildNode ( ) { m_realizer . regenerate ( ) ; m_graph . updateViews ( ) ; }
google/binnavi | @ Override public void appendedComment ( final IInstruction instruction , final IComment comment ) { rebuildNode ( ) ; }
google/binnavi | @ Override public void deletedComment ( final IInstruction instruction , final IComment comment ) { rebuildNode ( ) ; }
google/binnavi | @ Override public void editedComment ( final IInstruction instruction , final IComment comment ) { rebuildNode ( ) ; }
google/binnavi | @ Override public void initializedComment ( final IInstruction instruction , final List < IComment > comment ) { rebuildNode ( ) ; }
google/binnavi | public void setRealizer ( final IZyNodeRealizer realizer ) { m_realizer = realizer ; }
fr0609/SeriesGuide | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_extensions_configure ) ; setupActionBar ( ) ; if ( getIntent ( ) . hasExtra ( SeriesGuideExtension . EXTRA_FROM_SERIESGUIDE_SETTINGS ) ) { if ( savedInstanceState == null ) { AmazonConfigurationFragment f = new AmazonConfigurationFragment ( ) ; android . app . FragmentTransaction ft = getFragmentManager ( ) . beginTransaction ( ) ; ft . add ( R . id . content_frame , f ) ; ft . commit ( ) ; } } else { if ( savedInstanceState == null ) { ExtensionsConfigurationFragment f = new ExtensionsConfigurationFragment ( ) ; FragmentTransaction ft = getSupportFragmentManager ( ) . beginTransaction ( ) ; ft . add ( R . id . content_frame , f ) ; ft . commit ( ) ; } } }
fr0609/SeriesGuide | private void setupActionBar ( ) { ActionBar actionBar = getActionBar ( ) ; actionBar . setTitle ( R . string . action_extensions_configure ) ; actionBar . setDisplayHomeAsUpEnabled ( true ) ; }
fr0609/SeriesGuide | @ Override public boolean onOptionsItemSelected ( MenuItem item ) { int itemId = item . getItemId ( ) ; if ( itemId == android . R . id . home ) { onBackPressed ( ) ; return true ; } return super . onOptionsItemSelected ( item ) ; }
Dragon-Boat/openAndroid | @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_home ) ; $ ( R . id . swapAdapter ) . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { getFragmentManager ( ) . beginTransaction ( ) . add ( android . R . id . content , SwapAdapterDemoFragment . instance ( ) , " " ) . addToBackStack ( " " ) . commit ( ) ; } } ) ; }
Dragon-Boat/openAndroid | @ Override public void onClick ( View v ) { }
jk1/intellij-community | private PyTypeChecker ( ) { }
jk1/intellij-community | public MatchContext ( @ NotNull TypeEvalContext context , @ NotNull Map < PyGenericType , PyType > substitutions ) { this ( context , substitutions , true , new HashSet < > ( ) ) ; }
jk1/intellij-community | private MatchContext ( @ NotNull TypeEvalContext context , @ NotNull Map < PyGenericType , PyType > substitutions , boolean recursive , @ NotNull Set < Pair < PyType , PyType > > matching ) { this . context = context ; this . substitutions = substitutions ; this . recursive = recursive ; this . matching = matching ; }
jk1/intellij-community | @ NotNull public MatchContext notRecursive ( ) { return new MatchContext ( context , substitutions , false , matching ) ; }
kasperdokter/Reo | public volatile QueueableHandler masterHandler = new QueueableHandler ( new Semaphore ( 1 ) , new QueueableHandlersQueue ( 1 ) ) { @ Override public boolean call ( ) { return false ; } }
kasperdokter/Reo | public void kickMaster ( ) { masterHandler . flag ( ) ; masterHandler . callAsync ( ) ; }
ButterflyNetwork/bazel | private ActionCacheTestHelper ( ) { }
mkl-software/websuites | public CheckAttributeValueContainingCommand ( String attribute ) { super ( attribute ) ; }
mkl-software/websuites | @ Override protected String getPredicateString ( ) { return " arguments [ 0 ] . attributes [ i ] . value ▁ ! = ▁ null ▁ & & ▁ " + " arguments [ 0 ] . attributes [ i ] . value . indexOf ( arguments [ 1 ] ) ▁ ! = ▁ - 1" ; }
mkl-software/websuites | @ Override protected void runSingleStringAssertion ( StringAssert assertion , String string ) { assertion . overridingErrorMessage ( " The ▁ attribute ▁ with ▁ value ▁ containing ▁ ' % s ' ▁ is ▁ expected ▁ to ▁ appear ▁ somewhere ▁ on ▁ the ▁ page ▁ " + " ( in ▁ any ▁ element ) " , attribute ) . isEqualTo ( " OK " ) ; }
topsale/leesite | public TwoDimensionCodeImage ( BufferedImage bufImg ) { this . bufImg = bufImg ; }
topsale/leesite | @ Override public int getHeight ( ) { return bufImg . getHeight ( ) ; }
topsale/leesite | @ Override public int getPixel ( int x , int y ) { return bufImg . getRGB ( x , y ) ; }
topsale/leesite | @ Override public int getWidth ( ) { return bufImg . getWidth ( ) ; }
tzou24/BPS | protected ListInfo getDataList ( String sortKey , boolean desc , long offset , int maxItem ) { ListInfo listInfo = new ListInfo ( ) ; ParsedPoolman poolman = PoolmanHelper . getParsedPoolman ( ) ; ParsedDataSource dataSource = ( ParsedDataSource ) poolman . getDataSourceList ( ) . get ( ( int ) offset ) ; List list = new ArrayList ( ) ; list . add ( dataSource ) ; listInfo . setDatas ( list ) ; listInfo . setTotalSize ( poolman . getDataSourceList ( ) . size ( ) ) ; return listInfo ; }
tzou24/BPS | protected ListInfo getDataList ( String sortKey , boolean desc ) { return null ; }
Dhandapani/gluster-ovirt | public DiskImageDynamic ( ) { }
Dhandapani/gluster-ovirt | @ XmlElement public Integer getread_rate ( ) { return readRate ; }
Dhandapani/gluster-ovirt | public void setread_rate ( Integer rate ) { readRate = rate ; }
Dhandapani/gluster-ovirt | @ XmlElement public Integer getwrite_rate ( ) { return writeRate ; }
Dhandapani/gluster-ovirt | public void setwrite_rate ( Integer rate ) { writeRate = rate ; }
Dhandapani/gluster-ovirt | @ XmlElement ( name = " ReadLatency " ) public Double getReadLatency ( ) { return readLatency ; }
Dhandapani/gluster-ovirt | public void setReadLatency ( Double readLatency ) { this . readLatency = readLatency ; }
Dhandapani/gluster-ovirt | @ XmlElement ( name = " WriteLatency " ) public Double getWriteLatency ( ) { return writeLatency ; }
Dhandapani/gluster-ovirt | public void setWriteLatency ( Double writeLatency ) { this . writeLatency = writeLatency ; }
Dhandapani/gluster-ovirt | @ XmlElement ( name = " FlushLatency " ) public Double getFlushLatency ( ) { return flushLatency ; }
Dhandapani/gluster-ovirt | public void setFlushLatency ( Double flushLatency ) { this . flushLatency = flushLatency ; }
Dhandapani/gluster-ovirt | @ XmlElement public long getactual_size ( ) { return this . actualSize ; }
Dhandapani/gluster-ovirt | public void setactual_size ( long size ) { this . actualSize = size ; OnPropertyChanged ( new PropertyChangedEventArgs ( " actual _ size " ) ) ; }
Dhandapani/gluster-ovirt | protected void OnPropertyChanged ( PropertyChangedEventArgs e ) { }
Dhandapani/gluster-ovirt | @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( int ) ( actualSize ^ ( actualSize >>> 32 ) ) ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; result = prime * result + ( ( readRate == null ) ? 0 : readRate . hashCode ( ) ) ; result = prime * result + ( ( writeRate == null ) ? 0 : writeRate . hashCode ( ) ) ; result = prime * result + ( ( writeLatency == null ) ? 0 : writeLatency . hashCode ( ) ) ; result = prime * result + ( ( readLatency == null ) ? 0 : readLatency . hashCode ( ) ) ; result = prime * result + ( ( flushLatency == null ) ? 0 : flushLatency . hashCode ( ) ) ; return result ; }
Dhandapani/gluster-ovirt | @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; DiskImageDynamic other = ( DiskImageDynamic ) obj ; if ( actualSize != other . actualSize ) return false ; if ( id == null ) { if ( other . id != null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; if ( readRate == null ) { if ( other . readRate != null ) return false ; } else if ( ! readRate . equals ( other . readRate ) ) return false ; if ( writeRate == null ) { if ( other . writeRate != null ) return false ; } else if ( ! writeRate . equals ( other . writeRate ) ) return false ; if ( readLatency == null ) { if ( other . readLatency != null ) return false ; } else if ( ! readLatency . equals ( other . readLatency ) ) return false ; if ( writeLatency == null ) { if ( other . writeLatency != null ) return false ; } else if ( ! writeLatency . equals ( other . writeLatency ) ) return false ; if ( flushLatency == null ) { if ( other . flushLatency != null ) return false ; } else if ( ! flushLatency . equals ( other . flushLatency ) ) return false ; return true ; }
Dhandapani/gluster-ovirt | @ Override @ XmlElement ( name = " Id " ) @ Id @ GeneratedValue ( generator = " system - uuid " ) @ GenericGenerator ( name = " system - uuid " , strategy = " org . ovirt . engine . core . dao . GuidGenerator " ) @ Column ( name = " image _ id " ) @ Type ( type = " guid " ) public Guid getId ( ) { return id ; }
Dhandapani/gluster-ovirt | @ Override public void setId ( Guid id ) { this . id = id ; }
QualiMaster/Infrastructure | public RecordingTopologyBuilder ( ) { }
QualiMaster/Infrastructure | public RecordingTopologyBuilder ( PipelineOptions options ) { this . options = options ; }
QualiMaster/Infrastructure | public void startRecording ( String id ) { currentId = id ; }
QualiMaster/Infrastructure | private void record ( String id , Object processor ) { if ( null != currentId && null != processor ) { List < String > tmp = recording . get ( currentId ) ; if ( null == tmp ) { tmp = new ArrayList < String > ( ) ; recording . put ( currentId , tmp ) ; } tmp . add ( id + SubTopologyMonitoringEvent . SEPARATOR + processor . getClass ( ) . getName ( ) ) ; } }
QualiMaster/Infrastructure | private Number getExecutorParallelism ( String id , Number dflt ) { Number result = dflt ; if ( null != options ) { result = options . getExecutorParallelism ( id , dflt ) ; if ( DEBUG ) { LOGGER . info ( " Executors ▁ for ▁ " + id + " : ▁ " + result ) ; } } return result ; }
QualiMaster/Infrastructure | < D extends ComponentConfigurationDeclarer < ? > > D setNumTasks ( String id , D declarer , Number dflt ) { Number tasks = dflt ; if ( null != options ) { tasks = options . getTaskParallelism ( id , null ) ; } if ( null != tasks ) { if ( DEBUG ) { LOGGER . info ( " Tasks ▁ for ▁ " + id + " : ▁ " + tasks ) ; } declarer . setNumTasks ( tasks ) ; } return declarer ; }
QualiMaster/Infrastructure | private BoltDeclarer setNumTasks ( String id , BoltDeclarer declarer ) { setNumTasks ( id , declarer , null ) ; return new MyBoltGetter ( id ) ; }
QualiMaster/Infrastructure | private SpoutDeclarer setNumTasks ( String id , SpoutDeclarer declarer ) { setNumTasks ( id , declarer , null ) ; return new MySpoutGetter ( id ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IRichBolt bolt ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , null ) ) ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IRichBolt bolt , Number parallelism_hint ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , parallelism_hint ) ) ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IBasicBolt bolt ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , null ) ) ) ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setBolt ( String id , IBasicBolt bolt , Number parallelism_hint ) { record ( id , bolt ) ; return setNumTasks ( id , super . setBolt ( id , bolt , getExecutorParallelism ( id , parallelism_hint ) ) ) ; }
QualiMaster/Infrastructure | @ Override public SpoutDeclarer setSpout ( String id , IRichSpout spout ) { record ( id , spout ) ; return setNumTasks ( id , super . setSpout ( id , spout , getExecutorParallelism ( id , null ) ) ) ; }
QualiMaster/Infrastructure | @ Override public SpoutDeclarer setSpout ( String id , IRichSpout spout , Number parallelism_hint ) { record ( id , spout ) ; return setNumTasks ( id , super . setSpout ( id , spout , getExecutorParallelism ( id , parallelism_hint ) ) ) ; }
QualiMaster/Infrastructure | public void endRecording ( ) { endRecording ( null ) ; }
QualiMaster/Infrastructure | public void endRecording ( ITopologyCreate topology ) { if ( null != currentId && topology instanceof IScalableTopology ) { IScalingDescriptor desc = ( ( IScalableTopology ) topology ) . getScalingDescriptor ( ) ; if ( null != desc ) { scalingDescriptors . put ( currentId , desc ) ; } } currentId = null ; }
QualiMaster/Infrastructure | public void close ( String pipelineName , @ SuppressWarnings ( " rawtypes " ) Map config ) { SubTopologyMonitoringEvent event = createClosingEvent ( pipelineName , config ) ; if ( null != event ) { EventManager . send ( event ) ; } }
QualiMaster/Infrastructure | public SubTopologyMonitoringEvent createClosingEvent ( String pipelineName , @ SuppressWarnings ( " rawtypes " ) Map config ) { SubTopologyMonitoringEvent result = null ; if ( ! recording . isEmpty ( ) ) { StormSignalConnection . configureEventBus ( config ) ; result = new SubTopologyMonitoringEvent ( pipelineName , recording , scalingDescriptors ) ; } return result ; }
QualiMaster/Infrastructure | public MyBoltGetter ( String boltId ) { super ( boltId ) ; this . boltId = boltId ; }
QualiMaster/Infrastructure | @ Override public BoltDeclarer setNumTasks ( Number val ) { Number tasks = val ; if ( null != options ) { tasks = options . getTaskParallelism ( boltId , val ) ; } return super . setNumTasks ( tasks ) ; }
QualiMaster/Infrastructure | public MySpoutGetter ( String spoutId ) { super ( spoutId ) ; this . spoutId = spoutId ; }
QualiMaster/Infrastructure | @ Override public SpoutDeclarer setNumTasks ( Number val ) { Number tasks = val ; if ( null != options ) { tasks = options . getTaskParallelism ( spoutId , val ) ; } return super . setNumTasks ( tasks ) ; }
rvillablanca/java-notes | public void alimentar ( ) { System . out . println ( " Alimentando ▁ a ▁ " + this . getClass ( ) . getSimpleName ( ) ) ; }
rvillablanca/java-notes | public void add ( T t ) { lista . add ( t ) ; }
rvillablanca/java-notes | public List < T > getLista ( ) { return lista ; }
mcaliman/dochi | public List < Object > getArgsAndGroups ( ) { if ( argsAndGroups == null ) { argsAndGroups = new ArrayList < Object > ( ) ; } return this . argsAndGroups ; }
mcaliman/dochi | public String getRole ( ) { return role ; }
mcaliman/dochi | public void setRole ( String value ) { this . role = value ; }
mcaliman/dochi | public String getId ( ) { return id ; }
mcaliman/dochi | public void setId ( String value ) { this . id = value ; }
mcaliman/dochi | public String getCommonVersion ( ) { return commonVersion ; }
mcaliman/dochi | public void setCommonVersion ( String value ) { this . commonVersion = value ; }
mcaliman/dochi | public String getXmlLang ( ) { return xmlLang ; }
mcaliman/dochi | public void setXmlLang ( String value ) { this . xmlLang = value ; }
mcaliman/dochi | public String getBase ( ) { return base ; }
mcaliman/dochi | public void setBase ( String value ) { this . base = value ; }
mcaliman/dochi | public String getRemap ( ) { return remap ; }
mcaliman/dochi | public void setRemap ( String value ) { this . remap = value ; }
mcaliman/dochi | public String getXreflabel ( ) { return xreflabel ; }
mcaliman/dochi | public void setXreflabel ( String value ) { this . xreflabel = value ; }
mcaliman/dochi | public String getRevisionflag ( ) { return revisionflag ; }
mcaliman/dochi | public void setRevisionflag ( String value ) { this . revisionflag = value ; }
mcaliman/dochi | public String getDir ( ) { return dir ; }
mcaliman/dochi | public void setDir ( String value ) { this . dir = value ; }
mcaliman/dochi | public String getArch ( ) { return arch ; }
mcaliman/dochi | public void setArch ( String value ) { this . arch = value ; }
mcaliman/dochi | public String getAudience ( ) { return audience ; }
mcaliman/dochi | public void setAudience ( String value ) { this . audience = value ; }
mcaliman/dochi | public String getCondition ( ) { return condition ; }
mcaliman/dochi | public void setCondition ( String value ) { this . condition = value ; }
mcaliman/dochi | public String getConformance ( ) { return conformance ; }
mcaliman/dochi | public void setConformance ( String value ) { this . conformance = value ; }
mcaliman/dochi | public String getOs ( ) { return os ; }
mcaliman/dochi | public void setOs ( String value ) { this . os = value ; }
mcaliman/dochi | public String getCommonRevision ( ) { return commonRevision ; }
mcaliman/dochi | public void setCommonRevision ( String value ) { this . commonRevision = value ; }
mcaliman/dochi | public String getSecurity ( ) { return security ; }
mcaliman/dochi | public void setSecurity ( String value ) { this . security = value ; }
mcaliman/dochi | public String getUserlevel ( ) { return userlevel ; }
mcaliman/dochi | public void setUserlevel ( String value ) { this . userlevel = value ; }
mcaliman/dochi | public String getVendor ( ) { return vendor ; }
mcaliman/dochi | public void setVendor ( String value ) { this . vendor = value ; }
mcaliman/dochi | public String getWordsize ( ) { return wordsize ; }
mcaliman/dochi | public void setWordsize ( String value ) { this . wordsize = value ; }
mcaliman/dochi | public String getAnnotations ( ) { return annotations ; }
mcaliman/dochi | public void setAnnotations ( String value ) { this . annotations = value ; }
mcaliman/dochi | public Object getLinkend ( ) { return linkend ; }
mcaliman/dochi | public void setLinkend ( Object value ) { this . linkend = value ; }
mcaliman/dochi | public String getHref ( ) { return href ; }
mcaliman/dochi | public void setHref ( String value ) { this . href = value ; }
mcaliman/dochi | public String getXlinkType ( ) { return xlinkType ; }
mcaliman/dochi | public void setXlinkType ( String value ) { this . xlinkType = value ; }
mcaliman/dochi | public String getXlinkRole ( ) { return xlinkRole ; }
mcaliman/dochi | public void setXlinkRole ( String value ) { this . xlinkRole = value ; }
mcaliman/dochi | public String getArcrole ( ) { return arcrole ; }
mcaliman/dochi | public void setArcrole ( String value ) { this . arcrole = value ; }
mcaliman/dochi | public String getXlinkTitle ( ) { return xlinkTitle ; }
mcaliman/dochi | public void setXlinkTitle ( String value ) { this . xlinkTitle = value ; }
mcaliman/dochi | public String getShow ( ) { return show ; }
mcaliman/dochi | public void setShow ( String value ) { this . show = value ; }
mcaliman/dochi | public String getActuate ( ) { return actuate ; }
mcaliman/dochi | public void setActuate ( String value ) { this . actuate = value ; }
codeprimate-software/cp-elements | default boolean isRunning ( ) { throw new IllegalStateException ( " The ▁ runnable ▁ state ▁ of ▁ this ▁ object ▁ cannot ▁ be ▁ determined " ) ; }
codeprimate-software/cp-elements | @ Override default T call ( ) { return execute ( ) ; }
codeprimate-software/cp-elements | @ Override default void run ( ) { execute ( ) ; }
redisson/redisson | @ Override RMultimapCache < String , String > getMultimapCache ( String name ) { return redisson . getSetMultimapCache ( name ) ; }
redisson/redisson | @ Test public void testValues ( ) throws InterruptedException { RMultimapCache < String , String > multimap = getMultimapCache ( " test " ) ; multimap . put ( "1" , "1" ) ; multimap . put ( "1" , "2" ) ; multimap . put ( "1" , "3" ) ; multimap . put ( "1" , "3" ) ; assertThat ( multimap . get ( "1" ) . size ( ) ) . isEqualTo ( 3 ) ; assertThat ( multimap . get ( "1" ) ) . containsExactlyInAnyOrder ( "1" , "2" , "3" ) ; assertThat ( multimap . get ( "1" ) . remove ( "3" ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . contains ( "3" ) ) . isFalse ( ) ; assertThat ( multimap . get ( "1" ) . contains ( "2" ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . containsAll ( Arrays . asList ( "1" ) ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . containsAll ( Arrays . asList ( "1" , "2" ) ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . retainAll ( Arrays . asList ( "1" ) ) ) . isTrue ( ) ; assertThat ( multimap . get ( "1" ) . removeAll ( Arrays . asList ( "1" ) ) ) . isTrue ( ) ; }
summer0581/sumflow | public CompleteGeneralTaskCmd ( GeneralTaskCommand abstractCustomExpandTaskCommand ) { super ( abstractCustomExpandTaskCommand ) ; }
summer0581/sumflow | public Void execute ( CommandContext commandContext ) { loadProcessParameter ( commandContext ) ; addVariable ( ) ; runCommandExpression ( ) ; TaskInstanceEntity taskInstance = getTaskInstanceEntity ( ) ; TaskCommandInst taskCommand = getTaskCommandInst ( ) ; if ( taskInstance != null ) { taskInstance . end ( taskCommand , this . taskComment ) ; } else { throw new FixFlowException ( " 没有找到id为 : ▁ " + taskId + " ▁ 的任务 " ) ; } saveProcessInstance ( commandContext ) ; return null ; }
killme2008/xmemcached | public MockHandler ( int version , String response ) { super ( ) ; this . response = response ; this . version = version ; }
killme2008/xmemcached | @ Override public void onMessageReceived ( Session session , Object message ) { if ( message . equals ( " quit " ) ) { session . close ( ) ; return ; } session . write ( " CONFIG ▁ cluster ▁ 0 ▁ " + this . response . length ( ) ) ; session . write ( String . valueOf ( version ) + " \n " + this . response ) ; session . write ( " END " ) ; this . version ++ ; }
killme2008/xmemcached | @ Override public void setUp ( ) throws Exception { Properties properties = ResourcesUtils . getResourceAsProperties ( " test . properties " ) ; List < InetSocketAddress > addresses = AddrUtil . getAddresses ( properties . getProperty ( " test . memcached . servers " ) ) ; StringBuffer sb = new StringBuffer ( ) ; boolean wasFirst = true ; for ( InetSocketAddress addr : addresses ) { if ( wasFirst ) { wasFirst = false ; } else { sb . append ( " ▁ " ) ; } sb . append ( addr . getHostName ( ) + " | " + addr . getHostName ( ) + " | " + addr . getPort ( ) ) ; } this . addresses = addresses ; serverList = sb . toString ( ) ; }
killme2008/xmemcached | @ Test public void testInvalidConfig ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , " invalid " ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2271 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertTrue ( e . getMessage ( ) . contains ( " failed " ) ) ; } finally { configServer . stop ( ) ; } }
killme2008/xmemcached | @ Test public void testPollConfigAndUsage ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , serverList ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2271 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( addresses . size ( ) , config . getNodeList ( ) . size ( ) ) ; client . set ( " aws - cache " , 0 , " foobar " ) ; assertEquals ( " foobar " , client . get ( " aws - cache " ) ) ; } finally { configServer . stop ( ) ; } }
killme2008/xmemcached | @ Test public void testPollConfigAndUsageWithBuilder ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , serverList ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2279 ) ) ; try { AWSElasticCacheClientBuilder builder = new AWSElasticCacheClientBuilder ( new InetSocketAddress ( 2279 ) ) ; builder . setConnectionPoolSize ( 2 ) ; builder . setEnableHealSession ( false ) ; AWSElasticCacheClient client = builder . build ( ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( addresses . size ( ) , config . getNodeList ( ) . size ( ) ) ; client . set ( " aws - cache " , 0 , " foobar " ) ; assertEquals ( " foobar " , client . get ( " aws - cache " ) ) ; } finally { configServer . stop ( ) ; } }
killme2008/xmemcached | @ Test public void testPollConfigInterval ( ) throws Exception { TCPController cs1 = new TCPController ( ) ; int version = 10 ; cs1 . setHandler ( new MockHandler ( version , " localhost | localhost | 2272" ) ) ; cs1 . setCodecFactory ( new TextLineCodecFactory ( ) ) ; cs1 . bind ( new InetSocketAddress ( 2271 ) ) ; TCPController cs2 = new TCPController ( ) ; cs2 . setHandler ( new MockHandler ( version + 1 , " localhost | localhost | 2271 ▁ localhost | localhost | 2272" ) ) ; cs2 . setCodecFactory ( new TextLineCodecFactory ( ) ) ; cs2 . bind ( new InetSocketAddress ( 2272 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) , 3000 ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( 1 , config . getNodeList ( ) . size ( ) ) ; assertEquals ( 2272 , config . getNodeList ( ) . get ( 0 ) . getPort ( ) ) ; Thread . sleep ( 3500 ) ; config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version + 1 ) ; assertEquals ( 2 , config . getNodeList ( ) . size ( ) ) ; assertEquals ( 2271 , config . getNodeList ( ) . get ( 0 ) . getPort ( ) ) ; assertEquals ( 2272 , config . getNodeList ( ) . get ( 1 ) . getPort ( ) ) ; } finally { cs1 . stop ( ) ; cs2 . stop ( ) ; } }
hgschmie/presto | public PagesSerde ( BlockEncodingSerde blockEncodingSerde , Optional < Compressor > compressor , Optional < Decompressor > decompressor , Optional < SpillCipher > spillCipher ) { this . blockEncodingSerde = requireNonNull ( blockEncodingSerde , " blockEncodingSerde ▁ is ▁ null " ) ; checkArgument ( compressor . isPresent ( ) == decompressor . isPresent ( ) , " compressor ▁ and ▁ decompressor ▁ must ▁ both ▁ be ▁ present ▁ or ▁ both ▁ be ▁ absent " ) ; this . compressor = requireNonNull ( compressor , " compressor ▁ is ▁ null " ) ; this . decompressor = requireNonNull ( decompressor , " decompressor ▁ is ▁ null " ) ; this . spillCipher = requireNonNull ( spillCipher , " spillCipher ▁ is ▁ null " ) ; }
hgschmie/presto | public SerializedPage serialize ( Page page ) { SliceOutput serializationBuffer = new DynamicSliceOutput ( toIntExact ( page . getSizeInBytes ( ) + Integer . BYTES ) ) ; writeRawPage ( page , serializationBuffer , blockEncodingSerde ) ; Slice slice = serializationBuffer . slice ( ) ; int uncompressedSize = serializationBuffer . size ( ) ; MarkerSet markers = MarkerSet . empty ( ) ; if ( compressor . isPresent ( ) ) { byte [ ] compressed = new byte [ compressor . get ( ) . maxCompressedLength ( uncompressedSize ) ] ; int compressedSize = compressor . get ( ) . compress ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , uncompressedSize , compressed , 0 , compressed . length ) ; if ( ( ( ( double ) compressedSize ) / uncompressedSize ) <= MINIMUM_COMPRESSION_RATIO ) { slice = Slices . wrappedBuffer ( compressed , 0 , compressedSize ) ; markers . add ( COMPRESSED ) ; } } if ( spillCipher . isPresent ( ) ) { byte [ ] encrypted = new byte [ spillCipher . get ( ) . encryptedMaxLength ( slice . length ( ) ) ] ; int encryptedSize = spillCipher . get ( ) . encrypt ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , encrypted , 0 ) ; slice = Slices . wrappedBuffer ( encrypted , 0 , encryptedSize ) ; markers . add ( ENCRYPTED ) ; } if ( ! slice . isCompact ( ) ) { slice = Slices . copyOf ( slice ) ; } return new SerializedPage ( slice , markers , page . getPositionCount ( ) , uncompressedSize ) ; }
hgschmie/presto | public Page deserialize ( SerializedPage serializedPage ) { checkArgument ( serializedPage != null , " serializedPage ▁ is ▁ null " ) ; Slice slice = serializedPage . getSlice ( ) ; if ( serializedPage . isEncrypted ( ) ) { checkState ( spillCipher . isPresent ( ) , " Page ▁ is ▁ encrypted , ▁ but ▁ spill ▁ cipher ▁ is ▁ missing " ) ; byte [ ] decrypted = new byte [ spillCipher . get ( ) . decryptedMaxLength ( slice . length ( ) ) ] ; int decryptedSize = spillCipher . get ( ) . decrypt ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , decrypted , 0 ) ; slice = Slices . wrappedBuffer ( decrypted , 0 , decryptedSize ) ; } if ( serializedPage . isCompressed ( ) ) { checkState ( decompressor . isPresent ( ) , " Page ▁ is ▁ compressed , ▁ but ▁ decompressor ▁ is ▁ missing " ) ; int uncompressedSize = serializedPage . getUncompressedSizeInBytes ( ) ; byte [ ] decompressed = new byte [ uncompressedSize ] ; checkState ( decompressor . get ( ) . decompress ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , decompressed , 0 , uncompressedSize ) == uncompressedSize ) ; slice = Slices . wrappedBuffer ( decompressed ) ; } return readRawPage ( serializedPage . getPositionCount ( ) , slice . getInput ( ) , blockEncodingSerde ) ; }
jennyqujy/GitHubApp | @ Override public void onCreate ( Bundle savedInstanceState ) { supportRequestWindowFeature ( Window . FEATURE_PROGRESS ) ; super . onCreate ( savedInstanceState ) ; getWindow ( ) . setFeatureInt ( Window . FEATURE_PROGRESS , Window . PROGRESS_VISIBILITY_ON ) ; mWebView = new WebView ( this ) ; mWebView . loadUrl ( repo . getUrl ( ) ) ; mWebView . setWebViewClient ( new WebViewClient ( ) { @ Override public boolean shouldOverrideUrlLoading ( WebView view , String url ) { view . loadUrl ( url ) ; return true ; } } ) ; this . setContentView ( mWebView ) ; }
jennyqujy/GitHubApp | @ Override public boolean onKeyDown ( final int keyCode , final KeyEvent event ) { if ( ( keyCode == KeyEvent . KEYCODE_BACK ) && mWebView . canGoBack ( ) ) { mWebView . goBack ( ) ; return true ; } return super . onKeyDown ( keyCode , event ) ; }
userKarl/sctd | @ Transient public ScStock getScStock ( ) { return scStock ; }
userKarl/sctd | public void setScStock ( ScStock scStock ) { this . scStock = scStock ; }
userKarl/sctd | @ Transient public ScFutures getScFutures ( ) { return scFutures ; }
userKarl/sctd | public void setScFutures ( ScFutures scFutures ) { this . scFutures = scFutures ; }
userKarl/sctd | @ Transient public Double getPrice ( ) { return price ; }
userKarl/sctd | public void setPrice ( Double price ) { this . price = price ; }
kawakicchi/jersey | @ Override public void filter ( final ContainerRequestContext requestContext ) throws IOException { String method = requestContext . getMethod ( ) ; if ( " POST " . equals ( method ) ) { ContainerRequest r = ( ContainerRequest ) requestContext . getRequest ( ) ; if ( MediaTypes . typeEqual ( MediaType . APPLICATION_JSON_TYPE , requestContext . getMediaType ( ) ) ) { if ( ! r . bufferEntity ( ) ) { System . out . println ( " - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - " ) ; } r . getEntityStream ( ) . reset ( ) ; } else if ( MediaTypes . typeEqual ( MediaType . MULTIPART_FORM_DATA_TYPE , requestContext . getMediaType ( ) ) ) { InputStream in = r . getEntityStream ( ) ; if ( in . getClass ( ) != ByteArrayInputStream . class ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ReaderWriter . writeTo ( in , baos ) ; in = new ByteArrayInputStream ( baos . toByteArray ( ) ) ; requestContext . setEntityStream ( in ) ; } MultivaluedMap < String , String > map = new MultivaluedHashMap < String , String > ( ) ; FormDataMultiPart form = r . readEntity ( FormDataMultiPart . class ) ; Map < String , List < FormDataBodyPart > > m = form . getFields ( ) ; for ( String key : m . keySet ( ) ) { List < FormDataBodyPart > parts = form . getFields ( key ) ; for ( FormDataBodyPart part : parts ) { if ( MediaTypes . typeEqual ( MediaType . TEXT_PLAIN_TYPE , part . getMediaType ( ) ) ) { map . add ( key , part . getValue ( ) ) ; } } } ByteArrayInputStream bais = ( ByteArrayInputStream ) in ; bais . reset ( ) ; } else { if ( ! r . bufferEntity ( ) ) { } Form f = r . readEntity ( Form . class ) ; MultivaluedMap < String , String > map = f . asMap ( ) ; r . getEntityStream ( ) . reset ( ) ; } } }
vespa-engine/vespa | public CloudTrialExpirer ( Controller controller , Duration interval ) { super ( controller , interval , null , SystemName . allOf ( SystemName :: isPublic ) ) ; this . extendedTrialTenants = PermanentFlags . EXTENDED_TRIAL_TENANTS . bindTo ( controller ( ) . flagSource ( ) ) ; }
vespa-engine/vespa | @ Override protected double maintain ( ) { var expiredTenants = controller ( ) . tenants ( ) . asList ( ) . stream ( ) . filter ( this :: tenantIsCloudTenant ) . filter ( this :: tenantHasTrialPlan ) . filter ( this :: tenantIsNotExemptFromExpiry ) . filter ( this :: tenantReadersNotLoggedIn ) . filter ( this :: tenantHasNoDeployments ) . collect ( Collectors . toList ( ) ) ; if ( ! expiredTenants . isEmpty ( ) ) { var expiredTenantNames = expiredTenants . stream ( ) . map ( Tenant :: name ) . map ( TenantName :: value ) . collect ( Collectors . joining ( " , ▁ " ) ) ; log . info ( " Moving ▁ expired ▁ tenants ▁ to ▁ ' none ' ▁ plan : ▁ " + expiredTenantNames ) ; } expireTenants ( expiredTenants ) ; return 1 ; }
vespa-engine/vespa | private boolean tenantIsCloudTenant ( Tenant tenant ) { return tenant . type ( ) == Tenant . Type . cloud ; }
vespa-engine/vespa | private boolean tenantReadersNotLoggedIn ( Tenant tenant ) { return tenant . lastLoginInfo ( ) . get ( LastLoginInfo . UserLevel . user ) . map ( instant -> { var sinceLastLogin = Duration . between ( instant , controller ( ) . clock ( ) . instant ( ) ) ; return sinceLastLogin . compareTo ( loginExpiry ) > 0 ; } ) . orElse ( false ) ; }
vespa-engine/vespa | private boolean tenantHasTrialPlan ( Tenant tenant ) { var planId = controller ( ) . serviceRegistry ( ) . billingController ( ) . getPlan ( tenant . name ( ) ) ; return " trial " . equals ( planId . value ( ) ) ; }
vespa-engine/vespa | private boolean tenantIsNotExemptFromExpiry ( Tenant tenant ) { return ! extendedTrialTenants . value ( ) . contains ( tenant . name ( ) . value ( ) ) ; }
vespa-engine/vespa | private boolean tenantHasNoDeployments ( Tenant tenant ) { return controller ( ) . applications ( ) . asList ( tenant . name ( ) ) . stream ( ) . flatMap ( app -> app . instances ( ) . values ( ) . stream ( ) ) . mapToLong ( instance -> instance . deployments ( ) . values ( ) . size ( ) ) . sum ( ) == 0 ; }
vespa-engine/vespa | private void expireTenants ( List < Tenant > tenants ) { tenants . forEach ( tenant -> { controller ( ) . serviceRegistry ( ) . billingController ( ) . setPlan ( tenant . name ( ) , PlanId . from ( " none " ) , false ) ; } ) ; }
1yvT0s/buck | @ Test public void testParseResults ( ) throws Exception { ProjectWorkspace workspace = TestDataHelper . createProjectWorkspaceForScenario ( this , " gtest " , tmp ) ; workspace . setUp ( ) ; ImmutableList < String > samples = ImmutableList . of ( " malformed _ output " , " malformed _ results " , " multisuite _ success " , " no _ tests " , " simple _ success " , " simple _ failure " , " simple _ failure _ with _ output " , " simple _ disabled " ) ; BuildTarget target = BuildTargetFactory . newInstance ( " // : test " ) ; ProjectFilesystem filesystem = new ProjectFilesystem ( tmp . getRoot ( ) . toPath ( ) ) ; CxxGtestTest test = new CxxGtestTest ( new FakeBuildRuleParamsBuilder ( target ) . setProjectFilesystem ( filesystem ) . build ( ) , new SourcePathResolver ( new BuildRuleResolver ( ) ) , new CommandTool . Builder ( ) . addArg ( new TestSourcePath ( " " ) ) . build ( ) , Suppliers . ofInstance ( ImmutableMap . < String , String > of ( ) ) , Suppliers . ofInstance ( ImmutableList . < String > of ( ) ) , Suppliers . ofInstance ( ImmutableSortedSet . < BuildRule > of ( ) ) , ImmutableSet . < Label > of ( ) , ImmutableSet . < String > of ( ) , ImmutableSet . < BuildRule > of ( ) , false ) ; ExecutionContext context = TestExecutionContext . newInstance ( ) ; for ( String sample : samples ) { Path exitCode = Paths . get ( " unused " ) ; Path output = workspace . resolve ( Paths . get ( sample ) ) . resolve ( " output " ) ; Path results = workspace . resolve ( Paths . get ( sample ) ) . resolve ( " results " ) ; Path summaries = workspace . resolve ( Paths . get ( sample ) ) . resolve ( " summaries " ) ; List < TestResultSummary > expectedSummaries = mapper . readValue ( summaries . toFile ( ) , SUMMARIES_REFERENCE ) ; ImmutableList < TestResultSummary > actualSummaries = test . parseResults ( context , exitCode , output , results ) ; assertEquals ( sample , expectedSummaries , actualSummaries ) ; } }
Cleveroad/CRAudioWidgetOverlay | public BaseFilter ( @ NonNull Context context ) throws AssertionError { highlightColor = ContextCompat . getColor ( context , R . color . colorAccent ) ; }
Cleveroad/CRAudioWidgetOverlay | public BaseFilter ( int highlightColor ) throws AssertionError { setHighlightColor ( highlightColor ) ; }
Cleveroad/CRAudioWidgetOverlay | public BaseFilter setHighlightColor ( int highlightColor ) throws AssertionError { this . highlightColor = highlightColor ; return this ; }
Cleveroad/CRAudioWidgetOverlay | void init ( @ NonNull FilterableAdapter < T > adapter ) throws AssertionError { this . adapter = adapter ; dataSetObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { super . onChanged ( ) ; if ( ! isFiltered ( ) ) return ; performFiltering ( lastConstraint ) ; } @ Override public void onInvalidated ( ) { super . onInvalidated ( ) ; if ( ! isFiltered ( ) ) return ; lastResults = new FilterResults ( ) ; lastResults . count = - 1 ; lastResults . values = Collections . emptyList ( ) ; } } ; adapterDataObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { super . onChanged ( ) ; if ( ! isFiltered ( ) ) return ; performFiltering ( lastConstraint ) ; } } ; }
Cleveroad/CRAudioWidgetOverlay | protected int getNonFilteredCount ( ) { return adapter . getNonFilteredCount ( ) ; }
Cleveroad/CRAudioWidgetOverlay | protected T getNonFilteredItem ( int position ) { return adapter . getNonFilteredItem ( position ) ; }
Cleveroad/CRAudioWidgetOverlay | @ NonNull @ Override protected final FilterResults performFiltering ( CharSequence constraint ) { return performFilteringImpl ( constraint ) ; }
Cleveroad/CRAudioWidgetOverlay | @ Override protected final void publishResults ( CharSequence constraint , FilterResults results ) throws AssertionError { lastConstraint = constraint ; lastResults = results ; adapter . notifyDataSetChanged ( ) ; }
Cleveroad/CRAudioWidgetOverlay | public boolean isFiltered ( ) { return lastResults != null && lastResults . count > - 1 ; }
Cleveroad/CRAudioWidgetOverlay | public T getItem ( int position ) throws ArrayIndexOutOfBoundsException { return ( ( List < T > ) lastResults . values ) . get ( position ) ; }
Cleveroad/CRAudioWidgetOverlay | public int getCount ( ) { return lastResults . count ; }
Cleveroad/CRAudioWidgetOverlay | public DataSetObserver getDataSetObserver ( ) { return dataSetObserver ; }
Cleveroad/CRAudioWidgetOverlay | public RecyclerView . AdapterDataObserver getAdapterDataObserver ( ) { return adapterDataObserver ; }
Cleveroad/CRAudioWidgetOverlay | public Spannable highlightFilteredSubstring ( String name ) { SpannableString string = new SpannableString ( name ) ; if ( ! isFiltered ( ) ) return string ; String filteredString = lastConstraint . toString ( ) . trim ( ) . toLowerCase ( ) ; String lowercase = name . toLowerCase ( ) ; int length = filteredString . length ( ) ; int index = - 1 , prevIndex ; do { prevIndex = index ; index = lowercase . indexOf ( filteredString , prevIndex + 1 ) ; if ( index == - 1 ) { break ; } string . setSpan ( new ForegroundColorSpan ( highlightColor ) , index , index + length , 0 ) ; } while ( true ) ; return string ; }
bing-ads-sdk/BingAds-Java-SDK | public Long getAccountId ( ) { return accountId ; }
bing-ads-sdk/BingAds-Java-SDK | public void setAccountId ( Long value ) { this . accountId = value ; }
bing-ads-sdk/BingAds-Java-SDK | public ArrayOfCampaign getCampaigns ( ) { return campaigns ; }
bing-ads-sdk/BingAds-Java-SDK | public void setCampaigns ( ArrayOfCampaign value ) { this . campaigns = value ; }
bing-ads-sdk/BingAds-Java-SDK | public Boolean getIncludeDynamicSearchAdsSource ( ) { return includeDynamicSearchAdsSource ; }
bing-ads-sdk/BingAds-Java-SDK | public void setIncludeDynamicSearchAdsSource ( Boolean value ) { this . includeDynamicSearchAdsSource = value ; }
greatman/legendarybot | i ++ ) { log . info ( " Starting ▁ shard ▁ " + i ) ; jdaList . add ( builder . useSharding ( i , maxShard ) . buildBlocking ( JDA . Status . CONNECTED ) ) ; }
greatman/legendarybot | for ( PluginWrapper wrapper : getPluginManager ( ) . getPlugins ( ) ) { getPluginManager ( ) . unloadPlugin ( wrapper . getPluginId ( ) ) ; }
greatman/legendarybot | @ Override public CommandHandler getCommandHandler ( ) { return commandHandler ; }
greatman/legendarybot | @ Override public GuildSettings getGuildSettings ( Guild guild ) { return guildSettings . get ( guild . getId ( ) ) ; }
greatman/legendarybot | @ Override public PluginManager getPluginManager ( ) { return pluginManager ; }
greatman/legendarybot | @ Override public void addGuild ( Guild guild ) { guildSettings . put ( guild . getId ( ) , new IGuildSettings ( guild , this ) ) ; }
greatman/legendarybot | @ Override public StacktraceHandler getStacktraceHandler ( ) { return stacktraceHandler ; }
greatman/legendarybot | @ Override public boolean isReady ( ) { return ready ; }
greatman/legendarybot | @ Override public TranslateManager getTranslateManager ( ) { return translateManager ; }
greatman/legendarybot | @ Override public Properties getBotSettings ( ) { return props ; }
greatman/legendarybot | @ Override public OkHttpClient getBattleNetHttpClient ( ) { return client ; }
greatman/legendarybot | @ Override public JDA getJDA ( Guild guild ) { for ( JDA jda : jdaList ) { if ( jda . getGuildById ( guild . getId ( ) ) != null ) { return jda ; } } return null ; }
greatman/legendarybot | @ Override public List < JDA > getJDA ( ) { return Collections . unmodifiableList ( jdaList ) ; }
mesutcelik/hazelcast | public ClientQueueProxy ( String serviceName , String name , ClientContext context ) { super ( serviceName , name , context ) ; }
mesutcelik/hazelcast | @ Nonnull @ Override public UUID addItemListener ( @ Nonnull ItemListener < E > listener , boolean includeValue ) { checkNotNull ( listener , " Null ▁ listener ▁ is ▁ not ▁ allowed ! " ) ; EventHandler < ClientMessage > eventHandler = new ItemEventHandler ( includeValue , listener ) ; return registerListener ( createItemListenerCodec ( includeValue ) , eventHandler ) ; }
mesutcelik/hazelcast | private ListenerMessageCodec createItemListenerCodec ( final boolean includeValue ) { return new ListenerMessageCodec ( ) { @ Override public ClientMessage encodeAddRequest ( boolean localOnly ) { return QueueAddListenerCodec . encodeRequest ( name , includeValue , localOnly ) ; } @ Override public UUID decodeAddResponse ( ClientMessage clientMessage ) { return QueueAddListenerCodec . decodeResponse ( clientMessage ) . response ; } @ Override public ClientMessage encodeRemoveRequest ( UUID realRegistrationId ) { return QueueRemoveListenerCodec . encodeRequest ( name , realRegistrationId ) ; } @ Override public boolean decodeRemoveResponse ( ClientMessage clientMessage ) { return QueueRemoveListenerCodec . decodeResponse ( clientMessage ) . response ; } } ; }
mesutcelik/hazelcast | ItemEventHandler ( boolean includeValue , ItemListener < E > listener ) { this . includeValue = includeValue ; this . listener = listener ; }
mesutcelik/hazelcast | @ Override public void handleItemEvent ( Data dataItem , UUID uuid , int eventType ) { Member member = getContext ( ) . getClusterService ( ) . getMember ( uuid ) ; ItemEvent < E > itemEvent = new DataAwareItemEvent ( name , ItemEventType . getByType ( eventType ) , dataItem , member , getSerializationService ( ) ) ; if ( eventType == ItemEventType . ADDED . getType ( ) ) { listener . itemAdded ( itemEvent ) ; } else { listener . itemRemoved ( itemEvent ) ; } }
mesutcelik/hazelcast | @ Override public boolean removeItemListener ( @ Nonnull UUID registrationId ) { checkNotNull ( registrationId , " Null ▁ registrationId ▁ is ▁ not ▁ allowed ! " ) ; return deregisterListener ( registrationId ) ; }
mesutcelik/hazelcast | @ Override public LocalQueueStats getLocalQueueStats ( ) { throw new UnsupportedOperationException ( " Locality ▁ is ▁ ambiguous ▁ for ▁ client ! " ) ; }
mesutcelik/hazelcast | @ Override public boolean add ( @ Nonnull E e ) { if ( offer ( e ) ) { return true ; } throw new IllegalStateException ( " Queue ▁ is ▁ full ! " ) ; }
mesutcelik/hazelcast | @ Override public boolean offer ( @ Nonnull E e ) { try { return offer ( e , 0 , TimeUnit . SECONDS ) ; } catch ( InterruptedException ex ) { currentThread ( ) . interrupt ( ) ; return false ; } }
mesutcelik/hazelcast | @ Override public void put ( @ Nonnull E e ) throws InterruptedException { checkNotNull ( e , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( e ) ; ClientMessage request = QueuePutCodec . encodeRequest ( name , data ) ; invokeOnPartitionInterruptibly ( request ) ; }
mesutcelik/hazelcast | @ Override public boolean offer ( @ Nonnull E e , long timeout , @ Nonnull TimeUnit unit ) throws InterruptedException { checkNotNull ( e , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; checkNotNull ( unit , " Null ▁ timeUnit ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( e ) ; ClientMessage request = QueueOfferCodec . encodeRequest ( name , data , unit . toMillis ( timeout ) ) ; ClientMessage response = invokeOnPartitionInterruptibly ( request ) ; QueueOfferCodec . ResponseParameters resultParameters = QueueOfferCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Nonnull @ Override public E take ( ) throws InterruptedException { ClientMessage request = QueueTakeCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartitionInterruptibly ( request ) ; QueueTakeCodec . ResponseParameters resultParameters = QueueTakeCodec . decodeResponse ( response ) ; return toObject ( resultParameters . response ) ; }
mesutcelik/hazelcast | @ Override public E poll ( long timeout , @ Nonnull TimeUnit unit ) throws InterruptedException { checkNotNull ( unit , " Null ▁ timeUnit ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueuePollCodec . encodeRequest ( name , unit . toMillis ( timeout ) ) ; ClientMessage response = invokeOnPartitionInterruptibly ( request ) ; QueuePollCodec . ResponseParameters resultParameters = QueuePollCodec . decodeResponse ( response ) ; return toObject ( resultParameters . response ) ; }
mesutcelik/hazelcast | @ Override public int remainingCapacity ( ) { ClientMessage request = QueueRemainingCapacityCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueRemainingCapacityCodec . ResponseParameters resultParameters = QueueRemainingCapacityCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean remove ( @ Nonnull Object o ) { checkNotNull ( o , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( o ) ; ClientMessage request = QueueRemoveCodec . encodeRequest ( name , data ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueRemoveCodec . ResponseParameters resultParameters = QueueRemoveCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean contains ( @ Nonnull Object o ) { checkNotNull ( o , " Null ▁ item ▁ is ▁ not ▁ allowed ! " ) ; Data data = toData ( o ) ; ClientMessage request = QueueContainsCodec . encodeRequest ( name , data ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueContainsCodec . ResponseParameters resultParameters = QueueContainsCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public int drainTo ( @ Nonnull Collection < ? super E > objects ) { checkNotNull ( objects , " Null ▁ objects ▁ parameter ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueueDrainToCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueDrainToCodec . ResponseParameters resultParameters = QueueDrainToCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; for ( Data data : resultCollection ) { E e = toObject ( data ) ; objects . add ( e ) ; } return resultCollection . size ( ) ; }
mesutcelik/hazelcast | @ Override public int drainTo ( @ Nonnull Collection < ? super E > c , int maxElements ) { checkNotNull ( c , " Null ▁ collection ▁ parameter ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueueDrainToMaxSizeCodec . encodeRequest ( name , maxElements ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueDrainToMaxSizeCodec . ResponseParameters resultParameters = QueueDrainToMaxSizeCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; for ( Data data : resultCollection ) { E e = toObject ( data ) ; c . add ( e ) ; } return resultCollection . size ( ) ; }
mesutcelik/hazelcast | @ Override public E remove ( ) { final E res = poll ( ) ; if ( res == null ) { throw new NoSuchElementException ( " Queue ▁ is ▁ empty ! " ) ; } return res ; }
mesutcelik/hazelcast | @ Override public E poll ( ) { try { return poll ( 0 , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { currentThread ( ) . interrupt ( ) ; return null ; } }
mesutcelik/hazelcast | @ Override public E element ( ) { final E res = peek ( ) ; if ( res == null ) { throw new NoSuchElementException ( " Queue ▁ is ▁ empty ! " ) ; } return res ; }
mesutcelik/hazelcast | @ Override public E peek ( ) { ClientMessage request = QueuePeekCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueuePeekCodec . ResponseParameters resultParameters = QueuePeekCodec . decodeResponse ( response ) ; return toObject ( resultParameters . response ) ; }
mesutcelik/hazelcast | @ Override public int size ( ) { ClientMessage request = QueueSizeCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueSizeCodec . ResponseParameters resultParameters = QueueSizeCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean isEmpty ( ) { ClientMessage request = QueueIsEmptyCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIsEmptyCodec . ResponseParameters resultParameters = QueueIsEmptyCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public Iterator < E > iterator ( ) { ClientMessage request = QueueIteratorCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIteratorCodec . ResponseParameters resultParameters = QueueIteratorCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; return new QueueIterator < E > ( resultCollection . iterator ( ) , getSerializationService ( ) , false ) ; }
mesutcelik/hazelcast | @ Override public Object [ ] toArray ( ) { ClientMessage request = QueueIteratorCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIteratorCodec . ResponseParameters resultParameters = QueueIteratorCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; int i = 0 ; Object [ ] array = new Object [ resultCollection . size ( ) ] ; for ( Data data : resultCollection ) { array [ i ++ ] = toObject ( data ) ; } return array ; }
mesutcelik/hazelcast | @ Nonnull @ Override public < T > T [ ] toArray ( @ Nonnull T [ ] ts ) { checkNotNull ( ts , " Null ▁ array ▁ parameter ▁ is ▁ not ▁ allowed ! " ) ; ClientMessage request = QueueIteratorCodec . encodeRequest ( name ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueIteratorCodec . ResponseParameters resultParameters = QueueIteratorCodec . decodeResponse ( response ) ; Collection < Data > resultCollection = resultParameters . response ; int size = resultCollection . size ( ) ; if ( ts . length < size ) { ts = ( T [ ] ) java . lang . reflect . Array . newInstance ( ts . getClass ( ) . getComponentType ( ) , size ) ; } int i = 0 ; for ( Data data : resultCollection ) { ts [ i ++ ] = ( T ) toObject ( data ) ; } return ts ; }
mesutcelik/hazelcast | @ Override public boolean containsAll ( @ Nonnull Collection < ? > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueContainsAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueContainsAllCodec . ResponseParameters resultParameters = QueueContainsAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean addAll ( @ Nonnull Collection < ? extends E > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueAddAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueAddAllCodec . ResponseParameters resultParameters = QueueAddAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean removeAll ( @ Nonnull Collection < ? > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueCompareAndRemoveAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueCompareAndRemoveAllCodec . ResponseParameters resultParameters = QueueCompareAndRemoveAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public boolean retainAll ( @ Nonnull Collection < ? > c ) { checkNotNull ( c , " Null ▁ collection ▁ is ▁ not ▁ allowed ! " ) ; Collection < Data > dataCollection = objectToDataCollection ( c , getSerializationService ( ) ) ; ClientMessage request = QueueCompareAndRetainAllCodec . encodeRequest ( name , dataCollection ) ; ClientMessage response = invokeOnPartition ( request ) ; QueueCompareAndRetainAllCodec . ResponseParameters resultParameters = QueueCompareAndRetainAllCodec . decodeResponse ( response ) ; return resultParameters . response ; }
mesutcelik/hazelcast | @ Override public void clear ( ) { ClientMessage request = QueueClearCodec . encodeRequest ( name ) ; invokeOnPartition ( request ) ; }
mesutcelik/hazelcast | @ Override public String toString ( ) { return " IQueue { " + " name = ' " + name + ' \' ' + ' } ' ; }
jixieshi999/juahya | @ Override public IFLinearLayoutInFlater createIFlater ( ) { return new IFLinearLayoutInFlater ( ) ; }
jixieshi999/juahya | @ Override public IJuahyaFlateViewInFlaterAdapter createIFlater ( String name ) { for ( IJuahyaFlateViewInFlaterAdapter cls : list ) { if ( cls . shoulInflate ( name ) ) { try { return ( IJuahyaFlateViewInFlaterAdapter ) cls . getClass ( ) . newInstance ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } return new IJuahyaFlateViewInFlaterAdapter ( ) { @ Override public boolean shoulInflate ( String name ) { return false ; } @ Override public boolean OnInflateProperty ( String nameSpace , String attrName , String attrValue ) { return false ; } } ; }
GJL/flink | LongHashPartition ( LongHybridHashTable longTable , int partitionNum , BinaryRowDataSerializer buildSideSerializer , double estimatedRowCount , int maxSegs , int recursionLevel ) { this ( longTable , partitionNum , buildSideSerializer , getBucketBuffersByRowCount ( ( long ) estimatedRowCount , maxSegs , longTable . pageSize ( ) ) , recursionLevel , null , 0 ) ; this . buildSideWriteBuffer = new BuildSideBuffer ( longTable . nextSegment ( ) ) ; }
GJL/flink | LongHashPartition ( LongHybridHashTable longTable , int partitionNum , BinaryRowDataSerializer buildSideSerializer , int bucketNumSegs , int recursionLevel , List < MemorySegment > buffers , int lastSegmentLimit ) { this ( longTable , buildSideSerializer , listToArray ( buffers ) ) ; this . partitionNum = partitionNum ; this . recursionLevel = recursionLevel ; int numBuckets = MathUtils . roundDownToPowerOf2 ( bucketNumSegs * segmentSize / 16 ) ; MemorySegment [ ] buckets = new MemorySegment [ bucketNumSegs ] ; for ( int i = 0 ; i < bucketNumSegs ; i ++ ) { buckets [ i ] = longTable . nextSegment ( ) ; } setNewBuckets ( buckets , numBuckets ) ; this . finalBufferLimit = lastSegmentLimit ; }
GJL/flink | LongHashPartition ( LongHybridHashTable longTable , BinaryRowDataSerializer buildSideSerializer , MemorySegment [ ] partitionBuffers ) { super ( 0 ) ; this . longTable = longTable ; this . buildSideSerializer = buildSideSerializer ; this . buildReuseRow = buildSideSerializer . createInstance ( ) ; this . segmentSize = longTable . pageSize ( ) ; Preconditions . checkArgument ( segmentSize % 16 == 0 ) ; this . partitionBuffers = partitionBuffers ; this . segmentSizeBits = MathUtils . log2strict ( segmentSize ) ; this . segmentSizeMask = segmentSize - 1 ; this . finalBufferLimit = segmentSize ; this . iterator = new MatchIterator ( ) ; }
GJL/flink | private void setNewBuckets ( MemorySegment [ ] buckets , int numBuckets ) { for ( MemorySegment segment : buckets ) { for ( int i = 0 ; i < segmentSize ; i += 16 ) { segment . putLong ( i , 0 ) ; segment . putLong ( i + 8 , INVALID_ADDRESS ) ; } } this . buckets = buckets ; checkArgument ( MathUtils . isPowerOf2 ( numBuckets ) ) ; this . numBuckets = numBuckets ; this . numBucketsMask = numBuckets - 1 ; this . numKeys = 0 ; }
GJL/flink | MatchIterator valueIter ( long address ) { iterator . set ( address ) ; return iterator ; }
GJL/flink | public MatchIterator get ( long key , int hashCode ) { int bucket = findBucket ( hashCode ) ; int bucketOffset = bucket << 4 ; MemorySegment segment = buckets [ bucketOffset >>> segmentSizeBits ] ; int segOffset = bucketOffset & segmentSizeMask ; while ( true ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { if ( segment . getLong ( segOffset ) == key ) { return valueIter ( address ) ; } else { bucket = ( bucket + 1 ) & numBucketsMask ; if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { bucketOffset = bucket << 4 ; segOffset = bucketOffset & segmentSizeMask ; segment = buckets [ bucketOffset >>> segmentSizeBits ] ; } } } else { return valueIter ( INVALID_ADDRESS ) ; } } }
GJL/flink | private void updateIndex ( long key , int hashCode , long address , int size , MemorySegment dataSegment , int currentPositionInSegment ) throws IOException { assert ( numKeys <= numBuckets / 2 ) ; int bucketId = findBucket ( hashCode ) ; int bucketOffset = bucketId * SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES ; MemorySegment segment = buckets [ bucketOffset >>> segmentSizeBits ] ; int segOffset = bucketOffset & segmentSizeMask ; long currAddress ; while ( true ) { currAddress = segment . getLong ( segOffset + 8 ) ; if ( segment . getLong ( segOffset ) != key && currAddress != INVALID_ADDRESS ) { bucketId = ( bucketId + 1 ) & numBucketsMask ; if ( segOffset + SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES < segmentSize ) { segOffset += SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES ; } else { bucketOffset = bucketId * 16 ; segment = buckets [ bucketOffset >>> segmentSizeBits ] ; segOffset = bucketOffset & segmentSizeMask ; } } else { break ; } } if ( currAddress == INVALID_ADDRESS ) { segment . putLong ( segOffset , key ) ; segment . putLong ( segOffset + 8 , address ) ; numKeys += 1 ; if ( dataSegment != null ) { dataSegment . putLong ( currentPositionInSegment , toAddrAndLen ( INVALID_ADDRESS , size ) ) ; } if ( numKeys * 2 > numBuckets ) { resize ( ) ; } } else { dataSegment . putLong ( currentPositionInSegment , toAddrAndLen ( currAddress , size ) ) ; segment . putLong ( segOffset + 8 , address ) ; } }
GJL/flink | private int findBucket ( int hash ) { return partitionLevelHash ( hash ) & this . numBucketsMask ; }
GJL/flink | private void resize ( ) throws IOException { MemorySegment [ ] oldBuckets = this . buckets ; int oldNumBuckets = numBuckets ; int newNumSegs = oldBuckets . length * 2 ; int newNumBuckets = MathUtils . roundDownToPowerOf2 ( newNumSegs * segmentSize / 16 ) ; MemorySegment [ ] newBuckets = new MemorySegment [ newNumSegs ] ; for ( int i = 0 ; i < newNumSegs ; i ++ ) { MemorySegment seg = longTable . getNextBuffer ( ) ; if ( seg == null ) { final int spilledPart = longTable . spillPartition ( ) ; if ( spilledPart == partitionNum ) { longTable . returnAll ( Arrays . asList ( newBuckets ) ) ; return ; } seg = longTable . getNextBuffer ( ) ; if ( seg == null ) { throw new RuntimeException ( " Bug ▁ in ▁ HybridHashJoin : ▁ No ▁ memory ▁ became ▁ available ▁ after ▁ spilling ▁ a ▁ partition . " ) ; } } newBuckets [ i ] = seg ; } setNewBuckets ( newBuckets , newNumBuckets ) ; reHash ( oldBuckets , oldNumBuckets ) ; }
GJL/flink | private void reHash ( MemorySegment [ ] oldBuckets , int oldNumBuckets ) throws IOException { long reHashStartTime = System . currentTimeMillis ( ) ; int bucketOffset = 0 ; MemorySegment segment = oldBuckets [ bucketOffset ] ; int segOffset = 0 ; for ( int i = 0 ; i < oldNumBuckets ; i ++ ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { long key = segment . getLong ( segOffset ) ; updateIndex ( key , hashLong ( key , recursionLevel ) , address , 0 , null , 0 ) ; } if ( i != oldNumBuckets - 1 ) { if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { segment = oldBuckets [ ++ bucketOffset ] ; segOffset = 0 ; } } } longTable . returnAll ( Arrays . asList ( oldBuckets ) ) ; LOG . info ( " The ▁ rehash ▁ take ▁ { } ▁ ms ▁ for ▁ { } ▁ segments " , ( System . currentTimeMillis ( ) - reHashStartTime ) , numBuckets ) ; }
GJL/flink | public MemorySegment [ ] getBuckets ( ) { return buckets ; }
GJL/flink | int getBuildSideBlockCount ( ) { return this . partitionBuffers == null ? this . buildSideWriteBuffer . getBlockCount ( ) : this . partitionBuffers . length ; }
GJL/flink | int getProbeSideBlockCount ( ) { return this . probeSideBuffer == null ? - 1 : this . probeSideBuffer . getBlockCount ( ) ; }
GJL/flink | BlockChannelWriter < MemorySegment > getBuildSideChannel ( ) { return this . buildSideChannel ; }
GJL/flink | int getPartitionNumber ( ) { return this . partitionNum ; }
GJL/flink | MemorySegment [ ] getPartitionBuffers ( ) { return partitionBuffers ; }
GJL/flink | int getRecursionLevel ( ) { return this . recursionLevel ; }
GJL/flink | int getNumOccupiedMemorySegments ( ) { final int numPartitionBuffers = this . partitionBuffers != null ? this . partitionBuffers . length : this . buildSideWriteBuffer . getNumOccupiedMemorySegments ( ) ; return numPartitionBuffers + buckets . length ; }
GJL/flink | int spillPartition ( IOManager ioAccess , FileIOChannel . ID targetChannel , LinkedBlockingQueue < MemorySegment > bufferReturnQueue ) throws IOException { if ( ! isInMemory ( ) ) { throw new RuntimeException ( " Bug ▁ in ▁ Hybrid ▁ Hash ▁ Join : ▁ " + " Request ▁ to ▁ spill ▁ a ▁ partition ▁ that ▁ has ▁ already ▁ been ▁ spilled . " ) ; } if ( getNumOccupiedMemorySegments ( ) < 2 ) { throw new RuntimeException ( " Bug ▁ in ▁ Hybrid ▁ Hash ▁ Join : ▁ " + " Request ▁ to ▁ spill ▁ a ▁ partition ▁ with ▁ less ▁ than ▁ two ▁ buffers . " ) ; } this . buildSideChannel = FileChannelUtil . createBlockChannelWriter ( ioAccess , targetChannel , bufferReturnQueue , longTable . compressionEnable ( ) , longTable . compressionCodecFactory ( ) , longTable . compressionBlockSize ( ) , segmentSize ) ; return this . buildSideWriteBuffer . spill ( this . buildSideChannel ) ; }
GJL/flink | int finalizeBuildPhase ( IOManager ioAccess , FileIOChannel . Enumerator probeChannelEnumerator ) throws IOException { this . finalBufferLimit = this . buildSideWriteBuffer . getCurrentPositionInSegment ( ) ; this . partitionBuffers = this . buildSideWriteBuffer . close ( ) ; if ( ! isInMemory ( ) ) { this . buildSideChannel . close ( ) ; this . probeSideBuffer = FileChannelUtil . createOutputView ( ioAccess , probeChannelEnumerator . next ( ) , longTable . compressionEnable ( ) , longTable . compressionCodecFactory ( ) , longTable . compressionBlockSize ( ) , segmentSize ) ; return 1 ; } else { return 0 ; } }
GJL/flink | void finalizeProbePhase ( List < LongHashPartition > spilledPartitions ) throws IOException { if ( isInMemory ( ) ) { releaseBuckets ( ) ; longTable . returnAll ( Arrays . asList ( partitionBuffers ) ) ; this . partitionBuffers = null ; } else { if ( this . probeSideRecordCounter == 0 ) { this . probeSideBuffer . close ( ) ; this . buildSideChannel . deleteChannel ( ) ; this . probeSideBuffer . getChannel ( ) . deleteChannel ( ) ; } else { probeNumBytesInLastSeg = this . probeSideBuffer . close ( ) ; spilledPartitions . add ( this ) ; } } }
GJL/flink | final PartitionIterator newPartitionIterator ( ) { return new PartitionIterator ( ) ; }
GJL/flink | final int getLastSegmentLimit ( ) { return this . finalBufferLimit ; }
GJL/flink | @ Override public void setReadPosition ( long pointer ) { final int bufferNum = ( int ) ( pointer >>> this . segmentSizeBits ) ; final int offset = ( int ) ( pointer & segmentSizeMask ) ; this . currentBufferNum = bufferNum ; seekInput ( this . partitionBuffers [ bufferNum ] , offset , bufferNum < partitionBuffers . length - 1 ? segmentSize : finalBufferLimit ) ; }
GJL/flink | @ Override protected MemorySegment nextSegment ( MemorySegment current ) throws IOException { this . currentBufferNum ++ ; if ( this . currentBufferNum < this . partitionBuffers . length ) { return this . partitionBuffers [ this . currentBufferNum ] ; } else { throw new EOFException ( ) ; } }
GJL/flink | @ Override protected int getLimitForSegment ( MemorySegment segment ) { return segment == partitionBuffers [ partitionBuffers . length - 1 ] ? finalBufferLimit : segmentSize ; }
GJL/flink | boolean isInMemory ( ) { return buildSideChannel == null ; }
GJL/flink | final void insertIntoProbeBuffer ( BinaryRowDataSerializer probeSer , BinaryRowData record ) throws IOException { probeSer . serialize ( record , this . probeSideBuffer ) ; this . probeSideRecordCounter ++ ; }
GJL/flink | long getBuildSideRecordCount ( ) { return buildSideRecordCounter ; }
GJL/flink | long getMinKey ( ) { return minKey ; }
GJL/flink | long getMaxKey ( ) { return maxKey ; }
GJL/flink | private void updateMinMax ( long key ) { if ( key < minKey ) { minKey = key ; } if ( key > maxKey ) { maxKey = key ; } }
GJL/flink | void insertIntoBucket ( long key , int hashCode , int size , long address ) throws IOException { this . buildSideRecordCounter ++ ; updateMinMax ( key ) ; final int bufferNum = ( int ) ( address >>> this . segmentSizeBits ) ; final int offset = ( int ) ( address & ( this . segmentSize - 1 ) ) ; updateIndex ( key , hashCode , address , size , partitionBuffers [ bufferNum ] , offset ) ; }
GJL/flink | void insertIntoTable ( long key , int hashCode , BinaryRowData row ) throws IOException { this . buildSideRecordCounter ++ ; updateMinMax ( key ) ; int sizeInBytes = row . getSizeInBytes ( ) ; if ( sizeInBytes >= ( 1 << SIZE_BITS ) ) { throw new UnsupportedOperationException ( " Does ▁ not ▁ support ▁ row ▁ that ▁ is ▁ larger ▁ than ▁ 256M " ) ; } if ( isInMemory ( ) ) { checkWriteAdvance ( ) ; if ( isInMemory ( ) ) { updateIndex ( key , hashCode , buildSideWriteBuffer . getCurrentPointer ( ) , sizeInBytes , buildSideWriteBuffer . getCurrentSegment ( ) , buildSideWriteBuffer . getCurrentPositionInSegment ( ) ) ; } else { buildSideWriteBuffer . getCurrentSegment ( ) . putLong ( buildSideWriteBuffer . getCurrentPositionInSegment ( ) , toAddrAndLen ( INVALID_ADDRESS , sizeInBytes ) ) ; } buildSideWriteBuffer . skipBytesToWrite ( 8 ) ; if ( row . getSegments ( ) . length == 1 ) { buildSideWriteBuffer . write ( row . getSegments ( ) [ 0 ] , row . getOffset ( ) , sizeInBytes ) ; } else { BinaryRowDataSerializer . serializeWithoutLengthSlow ( row , buildSideWriteBuffer ) ; } } else { serializeToPages ( row ) ; } }
GJL/flink | public void serializeToPages ( BinaryRowData row ) throws IOException { int sizeInBytes = row . getSizeInBytes ( ) ; checkWriteAdvance ( ) ; buildSideWriteBuffer . getCurrentSegment ( ) . putLong ( buildSideWriteBuffer . getCurrentPositionInSegment ( ) , toAddrAndLen ( INVALID_ADDRESS , row . getSizeInBytes ( ) ) ) ; buildSideWriteBuffer . skipBytesToWrite ( 8 ) ; if ( row . getSegments ( ) . length == 1 ) { buildSideWriteBuffer . write ( row . getSegments ( ) [ 0 ] , row . getOffset ( ) , sizeInBytes ) ; } else { BinaryRowDataSerializer . serializeWithoutLengthSlow ( row , buildSideWriteBuffer ) ; } }
GJL/flink | void releaseBuckets ( ) { if ( buckets != null ) { longTable . returnAll ( Arrays . asList ( buckets ) ) ; buckets = null ; } }
GJL/flink | private BuildSideBuffer ( MemorySegment segment ) { super ( segment , segment . size ( ) , 0 ) ; this . targetList = new ArrayList < > ( ) ; }
GJL/flink | @ Override protected MemorySegment nextSegment ( MemorySegment current , int positionInCurrent ) throws IOException { final MemorySegment next ; if ( this . writer == null ) { this . targetList . add ( current ) ; next = longTable . nextSegment ( ) ; } else { this . writer . writeBlock ( current ) ; try { next = this . writer . getReturnQueue ( ) . take ( ) ; } catch ( InterruptedException iex ) { throw new IOException ( " Hash ▁ Join ▁ Partition ▁ was ▁ interrupted ▁ while ▁ " + " grabbing ▁ a ▁ new ▁ write - behind ▁ buffer . " ) ; } } this . currentBlockNumber ++ ; return next ; }
GJL/flink | long getCurrentPointer ( ) { return ( ( ( long ) this . currentBlockNumber ) << segmentSizeBits ) + getCurrentPositionInSegment ( ) ; }
GJL/flink | int getBlockCount ( ) { return this . currentBlockNumber + 1 ; }
GJL/flink | int getNumOccupiedMemorySegments ( ) { return this . targetList . size ( ) + 1 ; }
GJL/flink | int spill ( BlockChannelWriter < MemorySegment > writer ) throws IOException { this . writer = writer ; final int numSegments = this . targetList . size ( ) ; for ( MemorySegment segment : this . targetList ) { this . writer . writeBlock ( segment ) ; } this . targetList . clear ( ) ; return numSegments ; }
GJL/flink | MemorySegment [ ] close ( ) throws IOException { final MemorySegment current = getCurrentSegment ( ) ; if ( current == null ) { throw new IllegalStateException ( " Illegal ▁ State ▁ in ▁ LongHashTable : ▁ " + " No ▁ current ▁ buffer ▁ when ▁ finalizing ▁ build ▁ side . " ) ; } clear ( ) ; if ( this . writer == null ) { this . targetList . add ( current ) ; MemorySegment [ ] buffers = this . targetList . toArray ( new MemorySegment [ 0 ] ) ; this . targetList . clear ( ) ; return buffers ; } else { writer . writeBlock ( current ) ; return null ; } }
GJL/flink | public void set ( long address ) { this . address = address ; }
GJL/flink | @ Override public boolean advanceNext ( ) { if ( address != INVALID_ADDRESS ) { setReadPosition ( address ) ; long addrAndLen = getCurrentSegment ( ) . getLong ( getCurrentPositionInSegment ( ) ) ; this . address = toAddress ( addrAndLen ) ; int size = toLength ( addrAndLen ) ; try { skipBytesToRead ( 8 ) ; buildSideSerializer . pointTo ( size , buildReuseRow , LongHashPartition . this ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return true ; } return false ; }
GJL/flink | @ Override public BinaryRowData getRow ( ) { return buildReuseRow ; }
GJL/flink | void clearAllMemory ( LazyMemorySegmentPool pool ) { if ( this . buildSideWriteBuffer != null ) { if ( this . buildSideWriteBuffer . getCurrentSegment ( ) != null ) { pool . returnPage ( this . buildSideWriteBuffer . getCurrentSegment ( ) ) ; } pool . returnAll ( this . buildSideWriteBuffer . targetList ) ; this . buildSideWriteBuffer . targetList . clear ( ) ; this . buildSideWriteBuffer = null ; } releaseBuckets ( ) ; if ( this . partitionBuffers != null ) { pool . returnAll ( Arrays . asList ( this . partitionBuffers ) ) ; this . partitionBuffers = null ; } try { if ( this . buildSideChannel != null ) { this . buildSideChannel . close ( ) ; this . buildSideChannel . deleteChannel ( ) ; } if ( this . probeSideBuffer != null ) { this . probeSideBuffer . getChannel ( ) . closeAndDelete ( ) ; this . probeSideBuffer = null ; } } catch ( IOException ioex ) { throw new RuntimeException ( " Error ▁ deleting ▁ the ▁ partition ▁ files . ▁ " + " Some ▁ temporary ▁ files ▁ might ▁ not ▁ be ▁ removed . " , ioex ) ; } }
GJL/flink | private PartitionIterator ( ) { this . reuse = buildSideSerializer . createInstance ( ) ; setReadPosition ( 0 ) ; }
GJL/flink | @ Override public boolean advanceNext ( ) { try { checkReadAdvance ( ) ; int pos = getCurrentPositionInSegment ( ) ; this . currentPointer = ( ( ( long ) currentBufferNum ) << segmentSizeBits ) + pos ; long addrAndLen = getCurrentSegment ( ) . getLong ( pos ) ; skipBytesToRead ( 8 ) ; buildSideSerializer . pointTo ( toLength ( addrAndLen ) , reuse , LongHashPartition . this ) ; return true ; } catch ( EOFException e ) { return false ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
GJL/flink | final long getPointer ( ) { return this . currentPointer ; }
GJL/flink | @ Override public BinaryRowData getRow ( ) { return this . reuse ; }
GJL/flink | private void checkWriteAdvance ( ) throws IOException { if ( shouldAdvance ( buildSideWriteBuffer . getSegmentSize ( ) - buildSideWriteBuffer . getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { buildSideWriteBuffer . advance ( ) ; } }
GJL/flink | private void checkReadAdvance ( ) throws IOException { if ( shouldAdvance ( getCurrentSegmentLimit ( ) - getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { advance ( ) ; } }
GJL/flink | void iteratorToDenseBucket ( MemorySegment [ ] denseBuckets , long addressOffset , long globalMinKey ) { int bucketOffset = 0 ; MemorySegment segment = buckets [ bucketOffset ] ; int segOffset = 0 ; for ( int i = 0 ; i < numBuckets ; i ++ ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { long key = segment . getLong ( segOffset ) ; long denseBucket = key - globalMinKey ; long denseBucketOffset = denseBucket << 3 ; int denseSegIndex = ( int ) ( denseBucketOffset >>> segmentSizeBits ) ; int denseSegOffset = ( int ) ( denseBucketOffset & segmentSizeMask ) ; denseBuckets [ denseSegIndex ] . putLong ( denseSegOffset , address + addressOffset ) ; } if ( i != numBuckets - 1 ) { if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { segment = buckets [ ++ bucketOffset ] ; segOffset = 0 ; } } } }
GJL/flink | void updateDenseAddressOffset ( long addressOffset ) { if ( addressOffset != 0 ) { setReadPosition ( 0 ) ; while ( true ) { try { checkReadAdvance ( ) ; long addrAndLen = getCurrentSegment ( ) . getLong ( getCurrentPositionInSegment ( ) ) ; long address = LongHashPartition . toAddress ( addrAndLen ) ; int len = LongHashPartition . toLength ( addrAndLen ) ; if ( address != INVALID_ADDRESS ) { getCurrentSegment ( ) . putLong ( getCurrentPositionInSegment ( ) , LongHashPartition . toAddrAndLen ( address + addressOffset , len ) ) ; } skipBytesToRead ( 8 + len ) ; } catch ( EOFException e ) { break ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } }
mattgillooly/logscale-agent | @ Override EventBus create ( JsonNode config ) { return new NaiveEventBus ( ) ; }
mattgillooly/logscale-agent | @ Override EventBus create ( JsonNode config ) { return new KinesisEventBus ( config . get ( " accessKey " ) . asText ( ) , config . get ( " secretKey " ) . asText ( ) , config . get ( " stream " ) . asText ( ) ) ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public ItemsRange ( ) { this ( 0 , 0 ) ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public ItemsRange ( int first , int count ) { this . first = first ; this . count = count ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public int getFirst ( ) { return first ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public int getLast ( ) { return getFirst ( ) + getCount ( ) - 1 ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public int getCount ( ) { return count ; }
CiLiNet-Android/AndroidProject-CndSteel_External | public boolean contains ( int index ) { return index >= getFirst ( ) && index <= getLast ( ) ; }
OpenHFT/Chronicle-Wire | public ValueOutTest ( WireType wireType ) { this . wireType = wireType ; }
OpenHFT/Chronicle-Wire | @ Test public void test ( ) { final Wire wire = wireType . apply ( Bytes . elasticByteBuffer ( ) ) ; wire . usePadding ( true ) ; assert wire . startUse ( ) ; @ NotNull final byte [ ] expected = " this ▁ is ▁ my ▁ byte ▁ array " . getBytes ( ISO_8859_1 ) ; wire . writeDocument ( false , w -> w . write ( ) . object ( expected ) ) ; wire . readDocument ( null , w -> { @ NotNull final byte [ ] actual = ( byte [ ] ) w . read ( ) . object ( ) ; Assert . assertArrayEquals ( expected , actual ) ; } ) ; wire . bytes ( ) . releaseLast ( ) ; }
OpenHFT/Chronicle-Wire | @ Test public void testRequestedType ( ) { final Wire wire = wireType . apply ( Bytes . elasticByteBuffer ( ) ) ; wire . usePadding ( true ) ; assert wire . startUse ( ) ; @ NotNull final byte [ ] expected = " this ▁ is ▁ my ▁ byte ▁ array " . getBytes ( ISO_8859_1 ) ; wire . writeDocument ( false , w -> w . write ( ) . object ( expected ) ) ; wire . readDocument ( null , w -> { @ Nullable final byte [ ] actual = w . read ( ) . object ( byte [ ] . class ) ; Assert . assertArrayEquals ( expected , actual ) ; } ) ; wire . bytes ( ) . releaseLast ( ) ; }
OpenHFT/Chronicle-Wire | @ Test public void testAllBytes ( ) { final Wire wire = wireType . apply ( Bytes . elasticByteBuffer ( ) ) ; wire . usePadding ( true ) ; assert wire . startUse ( ) ; for ( int i = - 128 ; i < 127 ; i ++ ) { @ NotNull final byte [ ] expected = { ( byte ) i } ; wire . writeDocument ( false , w -> w . write ( ) . object ( expected ) ) ; assertNotNull ( Wires . fromSizePrefixedBlobs ( wire . bytes ( ) ) ) ; wire . readDocument ( null , w -> { @ Nullable final byte [ ] actual = ( byte [ ] ) w . read ( ) . object ( ) ; Assert . assertArrayEquals ( expected , actual ) ; } ) ; } wire . bytes ( ) . releaseLast ( ) ; }
guard163/cassandra | public RowIndexEntry ( long position ) { this . position = position ; }
guard163/cassandra | protected int promotedSize ( IndexHelper . IndexInfo . Serializer idxSerializer ) { return 0 ; }
guard163/cassandra | public boolean isIndexed ( ) { return ! columnsIndex ( ) . isEmpty ( ) ; }
guard163/cassandra | public DeletionTime deletionTime ( ) { throw new UnsupportedOperationException ( ) ; }
guard163/cassandra | public long headerOffset ( ) { return 0 ; }
guard163/cassandra | public long headerLength ( ) { throw new UnsupportedOperationException ( ) ; }
guard163/cassandra | public List < T > columnsIndex ( ) { return Collections . emptyList ( ) ; }
guard163/cassandra | public long unsharedHeapSize ( ) { return EMPTY_SIZE ; }
guard163/cassandra | public Serializer ( CFMetaData metadata , Version version , SerializationHeader header ) { this . idxSerializer = new IndexHelper . IndexInfo . Serializer ( metadata , version , header ) ; this . version = version ; }
guard163/cassandra | public void serialize ( RowIndexEntry < IndexHelper . IndexInfo > rie , DataOutputPlus out ) throws IOException { assert version . storeRows ( ) : " We ▁ read ▁ old ▁ index ▁ files ▁ but ▁ we ▁ should ▁ never ▁ write ▁ them " ; out . writeUnsignedVInt ( rie . position ) ; out . writeUnsignedVInt ( rie . promotedSize ( idxSerializer ) ) ; if ( rie . isIndexed ( ) ) { out . writeUnsignedVInt ( rie . headerLength ( ) ) ; DeletionTime . serializer . serialize ( rie . deletionTime ( ) , out ) ; out . writeUnsignedVInt ( rie . columnsIndex ( ) . size ( ) ) ; int [ ] offsets = new int [ rie . columnsIndex ( ) . size ( ) ] ; if ( out . hasPosition ( ) ) { long start = out . position ( ) ; int i = 0 ; for ( IndexHelper . IndexInfo info : rie . columnsIndex ( ) ) { offsets [ i ] = i == 0 ? 0 : ( int ) ( out . position ( ) - start ) ; i ++ ; idxSerializer . serialize ( info , out ) ; } } else { int i = 0 ; int offset = 0 ; for ( IndexHelper . IndexInfo info : rie . columnsIndex ( ) ) { offsets [ i ++ ] = offset ; idxSerializer . serialize ( info , out ) ; offset += idxSerializer . serializedSize ( info ) ; } } for ( int off : offsets ) out . writeInt ( off ) ; } }
guard163/cassandra | public RowIndexEntry < IndexHelper . IndexInfo > deserialize ( DataInputPlus in ) throws IOException { if ( ! version . storeRows ( ) ) { long position = in . readLong ( ) ; int size = in . readInt ( ) ; if ( size > 0 ) { DeletionTime deletionTime = DeletionTime . serializer . deserialize ( in ) ; int entries = in . readInt ( ) ; List < IndexHelper . IndexInfo > columnsIndex = new ArrayList < > ( entries ) ; long headerLength = 0L ; for ( int i = 0 ; i < entries ; i ++ ) { IndexHelper . IndexInfo info = idxSerializer . deserialize ( in ) ; columnsIndex . add ( info ) ; if ( i == 0 ) headerLength = info . offset ; } return new IndexedEntry ( position , deletionTime , headerLength , columnsIndex ) ; } else { return new RowIndexEntry < > ( position ) ; } } long position = in . readUnsignedVInt ( ) ; int size = ( int ) in . readUnsignedVInt ( ) ; if ( size > 0 ) { long headerLength = in . readUnsignedVInt ( ) ; DeletionTime deletionTime = DeletionTime . serializer . deserialize ( in ) ; int entries = ( int ) in . readUnsignedVInt ( ) ; List < IndexHelper . IndexInfo > columnsIndex = new ArrayList < > ( entries ) ; for ( int i = 0 ; i < entries ; i ++ ) columnsIndex . add ( idxSerializer . deserialize ( in ) ) ; FileUtils . skipBytesFully ( in , entries * TypeSizes . sizeof ( 0 ) ) ; return new IndexedEntry ( position , deletionTime , headerLength , columnsIndex ) ; } else { return new RowIndexEntry < > ( position ) ; } }
guard163/cassandra | public int serializedSize ( RowIndexEntry < IndexHelper . IndexInfo > rie ) { assert version . storeRows ( ) : " We ▁ read ▁ old ▁ index ▁ files ▁ but ▁ we ▁ should ▁ never ▁ write ▁ them " ; int indexedSize = 0 ; if ( rie . isIndexed ( ) ) { List < IndexHelper . IndexInfo > index = rie . columnsIndex ( ) ; indexedSize += TypeSizes . sizeofUnsignedVInt ( rie . headerLength ( ) ) ; indexedSize += DeletionTime . serializer . serializedSize ( rie . deletionTime ( ) ) ; indexedSize += TypeSizes . sizeofUnsignedVInt ( index . size ( ) ) ; for ( IndexHelper . IndexInfo info : index ) indexedSize += idxSerializer . serializedSize ( info ) ; indexedSize += index . size ( ) * TypeSizes . sizeof ( 0 ) ; } return TypeSizes . sizeofUnsignedVInt ( rie . position ) + TypeSizes . sizeofUnsignedVInt ( indexedSize ) + indexedSize ; }
guard163/cassandra | private IndexedEntry ( long position , DeletionTime deletionTime , long headerLength , List < IndexHelper . IndexInfo > columnsIndex ) { super ( position ) ; assert deletionTime != null ; assert columnsIndex != null && columnsIndex . size ( ) > 1 ; this . deletionTime = deletionTime ; this . headerLength = headerLength ; this . columnsIndex = columnsIndex ; }
guard163/cassandra | @ Override public DeletionTime deletionTime ( ) { return deletionTime ; }
guard163/cassandra | @ Override public long headerLength ( ) { return headerLength ; }
guard163/cassandra | @ Override public List < IndexHelper . IndexInfo > columnsIndex ( ) { return columnsIndex ; }
guard163/cassandra | @ Override protected int promotedSize ( IndexHelper . IndexInfo . Serializer idxSerializer ) { long size = TypeSizes . sizeofUnsignedVInt ( headerLength ) + DeletionTime . serializer . serializedSize ( deletionTime ) + TypeSizes . sizeofUnsignedVInt ( columnsIndex . size ( ) ) ; for ( IndexHelper . IndexInfo info : columnsIndex ) size += idxSerializer . serializedSize ( info ) ; size += columnsIndex . size ( ) * TypeSizes . sizeof ( 0 ) ; return Ints . checkedCast ( size ) ; }
guard163/cassandra | @ Override public long unsharedHeapSize ( ) { long entrySize = 0 ; for ( IndexHelper . IndexInfo idx : columnsIndex ) entrySize += idx . unsharedHeapSize ( ) ; return BASE_SIZE + entrySize + deletionTime . unsharedHeapSize ( ) + ObjectSizes . sizeOfReferenceArray ( columnsIndex . size ( ) ) ; }
aborg0/hits | protected ImporterNodeModel ( ) { super ( 0 , 1 ) ; }
aborg0/hits | @ Override protected BufferedDataTable [ ] execute ( final BufferedDataTable [ ] inData , final ExecutionContext exec ) throws Exception { final boolean addAnnotations = ! annotationFileNameModel . getStringValue ( ) . isEmpty ( ) ; BufferedDataContainer container = null ; int rows , cols ; switch ( wellCountModel . getIntValue ( ) ) { case 96 : rows = 8 ; cols = 12 ; break ; case 384 : rows = 16 ; cols = 24 ; break ; default : throw new UnsupportedOperationException ( " Not ▁ implemented ▁ for ▁ other ▁ than ▁ 96 , ▁ or ▁ 384 ▁ wells . " ) ; } final String [ ] fileNames = filesModel . getStringArrayValue ( ) ; String [ ] [ ] [ ] annotations = null ; for ( int j = 0 ; j < fileNames . length ; j ++ ) { final String fileName = fileNames [ j ] ; final File file = new File ( fileName ) ; final InputStream fis ; try { fis = OpenStream . open ( new URI ( fileName ) ) ; try { final POIFSFileSystem fs = new POIFSFileSystem ( fis ) ; final HSSFWorkbook wb = new HSSFWorkbook ( fs ) ; final HSSFSheet perWellSheet = wb . getSheet ( " Summary ▁ by ▁ wells " ) ; final HSSFRow row = perWellSheet . getRow ( 1 ) ; final int specColNum = 4 ; int columns = specColNum ; for ( int i = row . getLastCellNum ( ) ; i -- > Math . max ( row . getFirstCellNum ( ) , 1 ) && row . getCell ( i ) != null ; ) { ++ columns ; } exec . checkCanceled ( ) ; if ( j == 0 ) { final DataTableSpec outputSpec = getDataTableSpecFromRow ( row ) ; container = exec . createDataContainer ( outputSpec ) ; try { annotations = readAnnotations ( plateCountModel . getIntValue ( ) , rows , cols , annotationFileNameModel . getStringValue ( ) ) ; } catch ( final Exception e ) { logger . warn ( " Unable ▁ to ▁ read ▁ the ▁ gene ▁ annontation ▁ file : ▁ " + annotationFileNameModel . getStringValue ( ) , e ) ; } } else { if ( ! getDataTableSpecFromRow ( row ) . equalStructure ( container . getTableSpec ( ) ) ) { assert false : " The ▁ table ▁ specification ▁ " + getDataTableSpecFromRow ( row ) + " ▁ is ▁ not ▁ the ▁ same ▁ as ▁ the ▁ original ▁ " + container . getTableSpec ( ) + " ▁ in ▁ file : ▁ " + file . getAbsolutePath ( ) ; } } final int replicateCount = replicateCountModel . getIntValue ( ) ; for ( int i = specColNum - 1 ; i < perWellSheet . getLastRowNum ( ) + 1 ; ++ i ) { final DataCell [ ] values = new DataCell [ columns + ( addAnnotations ? 2 : 0 ) ] ; values [ 0 ] = new StringCell ( fileName ) ; values [ 1 ] = new IntCell ( 1 + j / replicateCount ) ; values [ 2 ] = new IntCell ( 1 + j % replicateCount ) ; final HSSFRow currentRow = perWellSheet . getRow ( i ) ; final String wellName = currentRow . getCell ( 0 ) . getRichStringCellValue ( ) . getString ( ) . replace ( " ▁ - ▁ " , " " ) ; values [ 3 ] = new StringCell ( wellName ) ; for ( int c = specColNum ; c < columns ; ++ c ) { final HSSFCell cell = currentRow . getCell ( c - 2 ) ; values [ c ] = new DoubleCell ( cell . getNumericCellValue ( ) ) ; } final int wellIndex = getIndex ( wellName , rows , cols ) ; if ( wellIndex == - 1 ) { logger . debug ( wellName ) ; } final String annot = wellIndex == - 1 || annotations == null ? null : annotations [ j / replicateCount ] [ wellIndex ] [ 1 ] ; final String geneID = wellIndex == - 1 || annotations == null ? null : annotations [ j / replicateCount ] [ wellIndex ] [ 0 ] ; final String nonNullAnnot = annot == null ? " " : annot ; final String nonNullGeneID = geneID == null ? " " : geneID ; if ( addAnnotations ) { values [ columns ] = new StringCell ( nonNullGeneID ) ; values [ columns + 1 ] = new StringCell ( nonNullAnnot ) ; } final String keyString = j / replicateCount + 1 + " _ " + ( j % replicateCount + 1 ) + " _ " + ( i - 2 ) ; final DefaultRow defaultRow = new DefaultRow ( new RowKey ( keyString ) , values ) ; container . addRowToTable ( defaultRow ) ; } } finally { fis . close ( ) ; } } catch ( final FileNotFoundException e ) { throw new InvalidSettingsException ( " Not ▁ found : ▁ " + file . getAbsolutePath ( ) , e ) ; } catch ( final IOException e ) { throw new InvalidSettingsException ( e . getMessage ( ) , e ) ; } exec . setProgress ( j / ( double ) fileNames . length , " Processing ▁ file : ▁ " + fileName ) ; } container . close ( ) ; final BufferedDataTable out = container . getTable ( ) ; return new BufferedDataTable [ ] { out } ; }
aborg0/hits | @ Override protected void reset ( ) { }
aborg0/hits | @ Override protected DataTableSpec [ ] configure ( final DataTableSpec [ ] inSpecs ) throws InvalidSettingsException { if ( filesModel . getStringArrayValue ( ) . length == 0 ) { throw new InvalidSettingsException ( " No ▁ file ▁ set " ) ; } final String annotFile = annotationFileNameModel . getStringValue ( ) ; try { final InputStream stream = OpenStream . open ( OpenStream . convertURI ( annotFile ) ) ; stream . close ( ) ; } catch ( final IOException e ) { throw new InvalidSettingsException ( " Unable ▁ to ▁ read : ▁ " + annotFile , e ) ; } catch ( final URISyntaxException e ) { throw new InvalidSettingsException ( " Unable ▁ to ▁ convert ▁ file ▁ name ▁ ( " + annotFile + " ) ▁ to ▁ URI : ▁ " + e . getMessage ( ) , e ) ; } final InputStream fis ; try { fis = OpenStream . open ( OpenStream . convertURI ( filesModel . getStringArrayValue ( ) [ 0 ] ) ) ; try { final POIFSFileSystem fs = new POIFSFileSystem ( fis ) ; final HSSFWorkbook wb = new HSSFWorkbook ( fs ) ; final HSSFSheet perWellSheet = wb . getSheet ( " Summary ▁ by ▁ wells " ) ; final HSSFRow row = perWellSheet . getRow ( 1 ) ; final DataTableSpec dataTableSpec = getDataTableSpecFromRow ( row ) ; return new DataTableSpec [ ] { dataTableSpec } ; } finally { fis . close ( ) ; } } catch ( final FileNotFoundException e ) { String uri ; try { uri = OpenStream . convertURI ( filesModel . getStringArrayValue ( ) [ 0 ] ) . toString ( ) ; } catch ( final URISyntaxException e1 ) { uri = " " ; } throw new InvalidSettingsException ( " Not ▁ found : ▁ " + filesModel . getStringArrayValue ( ) [ 0 ] + " ( " + uri + " ) " , e ) ; } catch ( final IOException e ) { throw new InvalidSettingsException ( e . getMessage ( ) , e ) ; } catch ( final URISyntaxException e ) { throw new InvalidSettingsException ( " Unable ▁ to ▁ convert ▁ file ▁ name ▁ ( " + filesModel . getStringArrayValue ( ) [ 0 ] + " ) ▁ to ▁ URI : ▁ " + e . getMessage ( ) , e ) ; } }
aborg0/hits | private DataTableSpec getDataTableSpecFromRow ( final HSSFRow row ) { final List < String > header = new ArrayList < String > ( ) ; for ( int i = row . getLastCellNum ( ) ; i -- > Math . max ( row . getFirstCellNum ( ) , 1 ) && row . getCell ( i ) != null ; ) { header . add ( 0 , row . getCell ( i ) . getRichStringCellValue ( ) . getString ( ) ) ; } final boolean addAnnotations = ! annotationFileNameModel . getStringValue ( ) . isEmpty ( ) ; final DataType [ ] cellTypes = new DataType [ header . size ( ) + ( addAnnotations ? 6 : 4 ) ] ; for ( int i = 0 ; i < header . size ( ) ; i ++ ) { cellTypes [ i + 4 ] = DoubleCell . TYPE ; } cellTypes [ 0 ] = StringCell . TYPE ; cellTypes [ 1 ] = IntCell . TYPE ; cellTypes [ 2 ] = IntCell . TYPE ; cellTypes [ 3 ] = StringCell . TYPE ; header . add ( 0 , PublicConstants . WELL_COL_NAME ) ; header . add ( 0 , PublicConstants . REPLICATE_COL_NAME ) ; header . add ( 0 , PublicConstants . PLATE_COL_NAME ) ; header . add ( 0 , PublicConstants . BARCODE_COLUMN ) ; if ( addAnnotations ) { header . add ( PublicConstants . GENE_ID_COL_NAME ) ; header . add ( PublicConstants . GENE_ANNOTATION_COL_NAME ) ; cellTypes [ cellTypes . length - 2 ] = StringCell . TYPE ; cellTypes [ cellTypes . length - 1 ] = StringCell . TYPE ; } final DataTableSpec dataTableSpec = new DataTableSpec ( header . toArray ( new String [ header . size ( ) ] ) , cellTypes ) ; return addWellDomain ( dataTableSpec ) ; }
aborg0/hits | private DataTableSpec addWellDomain ( final DataTableSpec dataTableSpec ) { final DataColumnSpec [ ] resultSpecs = new DataColumnSpec [ dataTableSpec . getNumColumns ( ) ] ; final int wells = wellCountModel . getIntValue ( ) ; final int rows ; switch ( wells ) { case 96 : rows = 12 ; break ; case 384 : rows = 24 ; break ; default : throw new IllegalStateException ( " Wrong ▁ plate ▁ format : ▁ " + wells ) ; } int i = 0 ; for ( final DataColumnSpec dataColumnSpec : dataTableSpec ) { if ( dataColumnSpec . getName ( ) . equalsIgnoreCase ( PublicConstants . WELL_COL_NAME ) ) { final DataColumnSpecCreator specCreator = new DataColumnSpecCreator ( dataColumnSpec ) ; final DataCell [ ] possibleValues = new DataCell [ wells ] ; for ( int j = possibleValues . length ; j -- > 0 ; ) { possibleValues [ j ] = new StringCell ( Character . toString ( ( char ) ( ' A ' + j / rows ) ) + Integer . toString ( ( j % rows + 1 ) ) ) ; } final DataColumnDomain domain = new DataColumnDomainCreator ( possibleValues ) . createDomain ( ) ; specCreator . setDomain ( domain ) ; resultSpecs [ i ++ ] = specCreator . createSpec ( ) ; } else { resultSpecs [ i ++ ] = dataColumnSpec ; } } return new DataTableSpec ( resultSpecs ) ; }
aborg0/hits | @ Override protected void saveSettingsTo ( final NodeSettingsWO settings ) { annotationFileNameModel . saveSettingsTo ( settings ) ; filesModel . saveSettingsTo ( settings ) ; wellCountModel . saveSettingsTo ( settings ) ; plateCountModel . saveSettingsTo ( settings ) ; replicateCountModel . saveSettingsTo ( settings ) ; }
aborg0/hits | @ Override protected void loadValidatedSettingsFrom ( final NodeSettingsRO settings ) throws InvalidSettingsException { annotationFileNameModel . loadSettingsFrom ( settings ) ; filesModel . loadSettingsFrom ( settings ) ; wellCountModel . loadSettingsFrom ( settings ) ; plateCountModel . loadSettingsFrom ( settings ) ; replicateCountModel . loadSettingsFrom ( settings ) ; }
aborg0/hits | @ Override protected void validateSettings ( final NodeSettingsRO settings ) throws InvalidSettingsException { annotationFileNameModel . validateSettings ( settings ) ; wellCountModel . validateSettings ( settings ) ; plateCountModel . validateSettings ( settings ) ; replicateCountModel . validateSettings ( settings ) ; }
dagnir/aws-sdk-java | public Request < DescribeReservedNodeOfferingsRequest > marshall ( DescribeReservedNodeOfferingsRequest describeReservedNodeOfferingsRequest ) { if ( describeReservedNodeOfferingsRequest == null ) { throw new SdkClientException ( " Invalid ▁ argument ▁ passed ▁ to ▁ marshall ( . . . ) " ) ; } Request < DescribeReservedNodeOfferingsRequest > request = new DefaultRequest < DescribeReservedNodeOfferingsRequest > ( describeReservedNodeOfferingsRequest , " AmazonRedshift " ) ; request . addParameter ( " Action " , " DescribeReservedNodeOfferings " ) ; request . addParameter ( " Version " , "2012-12-01" ) ; request . setHttpMethod ( HttpMethodName . POST ) ; if ( describeReservedNodeOfferingsRequest . getReservedNodeOfferingId ( ) != null ) { request . addParameter ( " ReservedNodeOfferingId " , StringUtils . fromString ( describeReservedNodeOfferingsRequest . getReservedNodeOfferingId ( ) ) ) ; } if ( describeReservedNodeOfferingsRequest . getMaxRecords ( ) != null ) { request . addParameter ( " MaxRecords " , StringUtils . fromInteger ( describeReservedNodeOfferingsRequest . getMaxRecords ( ) ) ) ; } if ( describeReservedNodeOfferingsRequest . getMarker ( ) != null ) { request . addParameter ( " Marker " , StringUtils . fromString ( describeReservedNodeOfferingsRequest . getMarker ( ) ) ) ; } return request ; }
chicagozer/rheosoft | public String getPort1 ( ) { return Integer . toString ( port1 ) ; }
chicagozer/rheosoft | public String getPort2 ( ) { return Integer . toString ( port2 ) ; }
chicagozer/rheosoft | @ Override protected RouteBuilder createRouteBuilder ( ) { return new RouteBuilder ( ) { public void configure ( ) { from ( " cxf : bean : routerEndpoint ? dataFormat = PAYLOAD & publishedEndpointUrl = http : // www . simple . com / services / test " ) . to ( " cxf : bean : serviceEndpoint ? dataFormat = PAYLOAD " ) ; } } ; }
chicagozer/rheosoft | @ Override protected ClassPathXmlApplicationContext createApplicationContext ( ) { return new ClassPathXmlApplicationContext ( " org / apache / camel / component / cxf / GreeterEndpointPayloadBeans . xml " ) ; }
migulorama/feup-sdis-2014 | public PeerSpaceReclaiming ( BackupSystem bs ) { super ( bs . Comm . MC . Publisher ) ; _bs = bs ; start ( new MessageFilter ( Message . Type . REMOVED ) ) ; }
migulorama/feup-sdis-2014 | @ Override protected void ProcessMessage ( Message msg ) { System . err . println ( " Received ▁ REMOVED : ▁ " + msg . getFileID ( ) + " ▁ " + msg . getChunkNo ( ) ) ; if ( _bs . Files . containsPeer ( msg . getFileID ( ) , msg . getChunkNo ( ) , msg . Sender . toString ( ) ) ) { _bs . Files . removePeer ( msg . getFileID ( ) , msg . getChunkNo ( ) , msg . Sender . toString ( ) ) ; int realDegree = _bs . Files . getChunkRealReplicationDegree ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; int desiredDegree = _bs . Files . getChunkDesiredReplicationDegree ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; if ( realDegree < desiredDegree ) { final CounterObserver co = new CounterObserver ( ) ; byte [ ] chunkArray ; try { chunkArray = _bs . readChunk ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; } catch ( IOException e ) { _bs . Files . removeChunk ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; _bs . Comm . MC . Sender . Send ( Message . makeRemoved ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ) ; return ; } final Chunk chunk = new Chunk ( msg . getChunkNo ( ) , desiredDegree , msg . getFileID ( ) , chunkArray ) ; final Subscription sub = _bs . Comm . MDB . Publisher . getObservable ( ) . filter ( new MessageFilter ( Message . Type . PUTCHUNK , msg . getFileID ( ) , msg . getChunkNo ( ) ) ) . subscribe ( co ) ; Schedulers . io ( ) . schedule ( new Action1 < Scheduler . Inner > ( ) { @ Override public void call ( Scheduler . Inner arg0 ) { if ( ! co . received ( ) ) new ChunkBackup ( _bs , chunk ) ; sub . unsubscribe ( ) ; } } , rand . nextInt ( 401 ) , TimeUnit . MILLISECONDS ) ; } } }
FHannes/intellij-community | @ Test public void testEmpty ( ) { Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " " ) ; graph . put ( " t " , " " ) ; doTest ( graph ) ; }
FHannes/intellij-community | @ Test public void testOneEdge ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " st " ) ; }
FHannes/intellij-community | @ Test public void testNoPaths ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " a " ) ; graph . put ( " a " , " s " ) ; graph . put ( " b " , " at " ) ; graph . put ( " t " , " sab " ) ; doTest ( graph ) ; }
FHannes/intellij-community | @ Test public void testOneVertex ( ) { Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " " ) ; doTest ( graph , " s " , " s " , 5 , " s " ) ; }
FHannes/intellij-community | @ Test public void testTwoPaths ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " ta " ) ; graph . put ( " a " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " st " , " sat " ) ; }
FHannes/intellij-community | @ Test public void testManyEdgesToTarget ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " a " ) ; graph . put ( " a " , " bt " ) ; graph . put ( " b " , " ct " ) ; graph . put ( " c " , " dt " ) ; graph . put ( " d " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " sat " , " sabt " , " sabct " , " sabcdt " ) ; }
FHannes/intellij-community | @ Test public void testManyEdgesFromSource ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " abcdt " ) ; graph . put ( " a " , " b " ) ; graph . put ( " b " , " c " ) ; graph . put ( " c " , " d " ) ; graph . put ( " d " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " st " , " sdt " , " scdt " , " sbcdt " , " sabcdt " ) ; }
FHannes/intellij-community | @ Test public void testTwoParts ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " ab " ) ; graph . put ( " a " , " b " ) ; graph . put ( " b " , " cd " ) ; graph . put ( " c " , " t " ) ; graph . put ( " d " , " e " ) ; graph . put ( " e " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " sbct " , " sabct " , " sbdet " , " sabdet " ) ; }
FHannes/intellij-community | @ Test public void testHangingEdges ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " ae " ) ; graph . put ( " a " , " bc " ) ; graph . put ( " b " , " ac " ) ; graph . put ( " c " , " ab " ) ; graph . put ( " d " , " s " ) ; graph . put ( " e " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " set " ) ; }
FHannes/intellij-community | @ Test public void testSimpleCycle ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " t " ) ; graph . put ( " t " , " s " ) ; doTest ( graph , 4 , " st " , " stst " , " ststst " , " stststst " ) ; }
FHannes/intellij-community | @ Test public void testComplexCycle ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " p " ) ; graph . put ( " p " , " qt " ) ; graph . put ( " q " , " vt " ) ; graph . put ( " v " , " p " ) ; graph . put ( " t " , " " ) ; doTest ( graph , 5 , " spt " , " spqt " , " spqvpt " , " spqvpqt " , " spqvpqvpt " ) ; }
FHannes/intellij-community | @ Test public void testHeap ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " a " ) ; graph . put ( " a " , " bd " ) ; graph . put ( " b " , " cd " ) ; graph . put ( " c " , " td " ) ; graph . put ( " d " , " e " ) ; graph . put ( " e " , " f " ) ; graph . put ( " f " , " t " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " sabct " , " sadeft " , " sabdeft " , " sabcdeft " ) ; }
FHannes/intellij-community | @ Test public void testBigHeap ( ) { final Map < String , String > graph = new HashMap < > ( ) ; graph . put ( " s " , " lo " ) ; graph . put ( " a " , " tb " ) ; graph . put ( " b " , " t " ) ; graph . put ( " c " , " ad " ) ; graph . put ( " d " , " e " ) ; graph . put ( " e " , " b " ) ; graph . put ( " f " , " cg " ) ; graph . put ( " g " , " h " ) ; graph . put ( " h " , " d " ) ; graph . put ( " i " , " fj " ) ; graph . put ( " j " , " k " ) ; graph . put ( " k " , " g " ) ; graph . put ( " l " , " im " ) ; graph . put ( " m " , " n " ) ; graph . put ( " n " , " j " ) ; graph . put ( " o " , " p " ) ; graph . put ( " p " , " m " ) ; graph . put ( " t " , " " ) ; doTest ( graph , " slifcat " , " slifcabt " , " slifcdebt " , " slifghdebt " , " slijkghdebt " , " slmnjkghdebt " , " sopmnjkghdebt " ) ; }
georghinkel/ttc2017smartGrids | protected HeatRateCurveImpl ( ) { super ( ) ; }
georghinkel/ttc2017smartGrids | @ Override protected EClass eStaticClass ( ) { return ProductionPackage . Literals . HEAT_RATE_CURVE ; }
georghinkel/ttc2017smartGrids | public ThermalGeneratingUnit getThermalGeneratingUnit ( ) { if ( thermalGeneratingUnit != null && thermalGeneratingUnit . eIsProxy ( ) ) { InternalEObject oldThermalGeneratingUnit = ( InternalEObject ) thermalGeneratingUnit ; thermalGeneratingUnit = ( ThermalGeneratingUnit ) eResolveProxy ( oldThermalGeneratingUnit ) ; if ( thermalGeneratingUnit != oldThermalGeneratingUnit ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , oldThermalGeneratingUnit , thermalGeneratingUnit ) ) ; } } return thermalGeneratingUnit ; }
georghinkel/ttc2017smartGrids | public ThermalGeneratingUnit basicGetThermalGeneratingUnit ( ) { return thermalGeneratingUnit ; }
georghinkel/ttc2017smartGrids | public NotificationChain basicSetThermalGeneratingUnit ( ThermalGeneratingUnit newThermalGeneratingUnit , NotificationChain msgs ) { ThermalGeneratingUnit oldThermalGeneratingUnit = thermalGeneratingUnit ; thermalGeneratingUnit = newThermalGeneratingUnit ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , oldThermalGeneratingUnit , newThermalGeneratingUnit ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; }
georghinkel/ttc2017smartGrids | public void setThermalGeneratingUnit ( ThermalGeneratingUnit newThermalGeneratingUnit ) { if ( newThermalGeneratingUnit != thermalGeneratingUnit ) { NotificationChain msgs = null ; if ( thermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) thermalGeneratingUnit ) . eInverseRemove ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; if ( newThermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) newThermalGeneratingUnit ) . eInverseAdd ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; msgs = basicSetThermalGeneratingUnit ( newThermalGeneratingUnit , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , newThermalGeneratingUnit , newThermalGeneratingUnit ) ) ; }
georghinkel/ttc2017smartGrids | public boolean isIsNetGrossP ( ) { return isNetGrossP ; }
georghinkel/ttc2017smartGrids | public void setIsNetGrossP ( boolean newIsNetGrossP ) { boolean oldIsNetGrossP = isNetGrossP ; isNetGrossP = newIsNetGrossP ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P , oldIsNetGrossP , isNetGrossP ) ) ; }
georghinkel/ttc2017smartGrids | @ Override public NotificationChain eInverseAdd ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : if ( thermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) thermalGeneratingUnit ) . eInverseRemove ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; return basicSetThermalGeneratingUnit ( ( ThermalGeneratingUnit ) otherEnd , msgs ) ; } return super . eInverseAdd ( otherEnd , featureID , msgs ) ; }
georghinkel/ttc2017smartGrids | @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : return basicSetThermalGeneratingUnit ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; }
georghinkel/ttc2017smartGrids | @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : if ( resolve ) return getThermalGeneratingUnit ( ) ; return basicGetThermalGeneratingUnit ( ) ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : return isIsNetGrossP ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; }
georghinkel/ttc2017smartGrids | @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : setThermalGeneratingUnit ( ( ThermalGeneratingUnit ) newValue ) ; return ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : setIsNetGrossP ( ( Boolean ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; }
georghinkel/ttc2017smartGrids | @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : setThermalGeneratingUnit ( ( ThermalGeneratingUnit ) null ) ; return ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : setIsNetGrossP ( IS_NET_GROSS_P_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; }
georghinkel/ttc2017smartGrids | @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : return thermalGeneratingUnit != null ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : return isNetGrossP != IS_NET_GROSS_P_EDEFAULT ; } return super . eIsSet ( featureID ) ; }
georghinkel/ttc2017smartGrids | @ Override public String toString ( ) { if ( eIsProxy ( ) ) return super . toString ( ) ; StringBuffer result = new StringBuffer ( super . toString ( ) ) ; result . append ( " ▁ ( isNetGrossP : ▁ " ) ; result . append ( isNetGrossP ) ; result . append ( ' ) ' ) ; return result . toString ( ) ; }
mihalea/barebones | public NotAssignedException ( ) { this ( " " , - 1 ) ; }
mihalea/barebones | public NotAssignedException ( String additional ) { this ( additional , - 1 ) ; }
mihalea/barebones | public NotAssignedException ( int line ) { this ( " " , line ) ; }
mihalea/barebones | public NotAssignedException ( String additional , int line ) { super ( " Variable ▁ used ▁ before ▁ it ▁ had ▁ a ▁ value ▁ assigned " , additional , line ) ; }
dextorer/BuildingForAndroidTV | public Movie ( ) { }
dextorer/BuildingForAndroidTV | public Movie ( Parcel in ) { String [ ] data = new String [ 8 ] ; in . readStringArray ( data ) ; mId = data [ 0 ] ; mTitle = data [ 1 ] ; mDescription = data [ 2 ] ; mBgImageUrl = data [ 3 ] ; mCardImageUrl = data [ 4 ] ; mVideoUrl = data [ 5 ] ; mStudio = data [ 6 ] ; mCategory = data [ 7 ] ; }
dextorer/BuildingForAndroidTV | public String getId ( ) { return mId ; }
dextorer/BuildingForAndroidTV | public void setId ( String id ) { mId = id ; }
dextorer/BuildingForAndroidTV | public String getTitle ( ) { return mTitle ; }
dextorer/BuildingForAndroidTV | public void setTitle ( String title ) { mTitle = title ; }
dextorer/BuildingForAndroidTV | public String getDescription ( ) { return mDescription ; }
dextorer/BuildingForAndroidTV | public void setDescription ( String description ) { mDescription = description ; }
dextorer/BuildingForAndroidTV | public String getStudio ( ) { return mStudio ; }
dextorer/BuildingForAndroidTV | public void setStudio ( String studio ) { mStudio = studio ; }
dextorer/BuildingForAndroidTV | public String getVideoUrl ( ) { return mVideoUrl ; }
dextorer/BuildingForAndroidTV | public void setVideoUrl ( String videoUrl ) { mVideoUrl = videoUrl ; }
dextorer/BuildingForAndroidTV | public String getBackgroundImageUrl ( ) { return mBgImageUrl ; }
dextorer/BuildingForAndroidTV | public void setBackgroundImageUrl ( String bgImageUrl ) { mBgImageUrl = bgImageUrl ; }
dextorer/BuildingForAndroidTV | public String getCardImageUrl ( ) { return mCardImageUrl ; }
dextorer/BuildingForAndroidTV | public void setCardImageUrl ( String cardImageUrl ) { mCardImageUrl = cardImageUrl ; }
dextorer/BuildingForAndroidTV | public String getCategory ( ) { return mCategory ; }
dextorer/BuildingForAndroidTV | public void setCategory ( String category ) { mCategory = category ; }
dextorer/BuildingForAndroidTV | public URI getBackgroundImageURI ( ) { try { return new URI ( getBackgroundImageUrl ( ) ) ; } catch ( URISyntaxException e ) { return null ; } }
dextorer/BuildingForAndroidTV | public int describeContents ( ) { return 0 ; }
dextorer/BuildingForAndroidTV | @ Override public void writeToParcel ( Parcel dest , int flags ) { dest . writeStringArray ( new String [ ] { mId , mTitle , mDescription , mBgImageUrl , mCardImageUrl , mVideoUrl , mStudio , mCategory } ) ; }
dextorer/BuildingForAndroidTV | @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( 200 ) ; sb . append ( " Movie { " ) ; sb . append ( " mId = " + mId ) ; sb . append ( " , ▁ mTitle = ' " + mTitle + ' \' ' ) ; sb . append ( " , ▁ mVideoUrl = ' " + mVideoUrl + ' \' ' ) ; sb . append ( " , ▁ backgroundImageUrl = ' " + mBgImageUrl + ' \' ' ) ; sb . append ( " , ▁ backgroundImageURI = ' " + getBackgroundImageURI ( ) . toString ( ) + ' \' ' ) ; sb . append ( " , ▁ mCardImageUrl = ' " + mCardImageUrl + ' \' ' ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; }
gjordi/gwt-jquery-sparklines-lib | @ Override public void onModuleLoad ( ) { JQuerySparklinesClientBundle bundle = JQuerySparklinesClientBundle . INSTANCE ; logger . log ( Level . INFO , " Injecting ▁ sparklines ▁ javascript ▁ script ▁ element . " ) ; ScriptInjector . fromString ( bundle . sparklines ( ) . getText ( ) ) . setWindow ( ScriptInjector . TOP_WINDOW ) . inject ( ) ; }
JoelMarcey/buck | public PrebuiltGoLibraryDescription ( GoBuckConfig goBuckConfig , ToolchainProvider toolchainProvider ) { this . goBuckConfig = goBuckConfig ; this . toolchainProvider = toolchainProvider ; }
JoelMarcey/buck | @ Override public Class < PrebuiltGoLibraryDescriptionArg > getConstructorArgType ( ) { return PrebuiltGoLibraryDescriptionArg . class ; }
JoelMarcey/buck | @ Override public < U > Optional < U > createMetadata ( BuildTarget buildTarget , ActionGraphBuilder graphBuilder , CellPathResolver cellRoots , PrebuiltGoLibraryDescriptionArg args , Optional < ImmutableMap < BuildTarget , Version > > selectedVersions , Class < U > metadataClass ) { Optional < GoPlatform > platform = getGoToolchain ( buildTarget . getTargetConfiguration ( ) ) . getPlatformFlavorDomain ( ) . getValue ( buildTarget ) . map ( goPlatform -> goPlatform . resolve ( graphBuilder , buildTarget . getTargetConfiguration ( ) ) ) ; if ( metadataClass . isAssignableFrom ( GoLinkable . class ) ) { Preconditions . checkState ( platform . isPresent ( ) ) ; SourcePath output = graphBuilder . requireRule ( buildTarget ) . getSourcePathToOutput ( ) ; return Optional . of ( metadataClass . cast ( GoLinkable . of ( ImmutableMap . of ( args . getPackageName ( ) . map ( Paths :: get ) . orElse ( goBuckConfig . getDefaultPackageName ( buildTarget ) ) , output ) , args . getExportedDeps ( ) ) ) ) ; } else if ( buildTarget . getFlavors ( ) . contains ( GoDescriptors . TRANSITIVE_LINKABLES_FLAVOR ) ) { Preconditions . checkState ( platform . isPresent ( ) ) ; return Optional . of ( metadataClass . cast ( GoDescriptors . requireTransitiveGoLinkables ( buildTarget , graphBuilder , platform . get ( ) , Iterables . concat ( args . getDeps ( ) , args . getExportedDeps ( ) ) , true ) ) ) ; } else { return Optional . empty ( ) ; } }
JoelMarcey/buck | private GoToolchain getGoToolchain ( TargetConfiguration toolchainTargetConfiguration ) { return toolchainProvider . getByName ( GoToolchain . DEFAULT_NAME , toolchainTargetConfiguration , GoToolchain . class ) ; }
JoelMarcey/buck | @ Override public PrebuiltGoLibrary createBuildRule ( BuildRuleCreationContextWithTargetGraph context , BuildTarget buildTarget , BuildRuleParams params , PrebuiltGoLibraryDescriptionArg args ) { return new PrebuiltGoLibrary ( buildTarget , context . getProjectFilesystem ( ) , params , args . getPackageName ( ) . map ( Paths :: get ) . orElse ( goBuckConfig . getDefaultPackageName ( buildTarget ) ) , args . getLibrary ( ) , args . getExportedDeps ( ) ) ; }
coolcrowd/ObjectService | private ExperimentOuterClass ( ) { }
coolcrowd/ObjectService | com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner assigner = new com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner ( ) { public com . google . protobuf . ExtensionRegistry assignDescriptors ( com . google . protobuf . Descriptors . FileDescriptor root ) { descriptor = root ; return null ; } }
ericbottard/spring-cloud-dataflow | @ Before public void setupMockMVC ( ) { taskDefinitionRepository . save ( new TaskDefinition ( TASK_NAME_ORIG , " demo " ) ) ; appRegistry = mock ( AppRegistry . class ) ; resourceLoader = mock ( ResourceLoader . class ) ; metadataResolver = mock ( ApplicationConfigurationMetadataResolver . class ) ; taskLauncher = mock ( TaskLauncher . class ) ; when ( this . appRegistry . find ( anyString ( ) , any ( ApplicationType . class ) ) ) . thenReturn ( new AppRegistration ( " some - name " , task , URI . create ( " http : // helloworld " ) , resourceLoader ) ) ; when ( this . resourceLoader . getResource ( anyString ( ) ) ) . thenReturn ( mock ( Resource . class ) ) ; taskService = new DefaultTaskService ( dataSourceProperties , taskDefinitionRepository , taskExplorer , taskExecutionRepository , appRegistry , resourceLoader , taskLauncher , metadataResolver , new TaskConfigurationProperties ( ) , new InMemoryDeploymentIdRepository ( ) , null ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeSingleTaskTest ( ) { when ( taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; assertEquals ( 1L , this . taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeMultipleTasksTest ( ) { when ( taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; assertEquals ( 1L , this . taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ) ; assertEquals ( 2L , this . taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeTaskWithNullIDReturnedTest ( ) { boolean errorCaught = false ; when ( this . taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( null ) ; try { taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ; } catch ( IllegalStateException ise ) { errorCaught = true ; assertEquals ( " Deployment ▁ ID ▁ is ▁ null ▁ for ▁ the ▁ task : myTask _ ORIG " , ise . getMessage ( ) ) ; } if ( ! errorCaught ) { fail ( ) ; } }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void executeTaskWithNullDefinitionTest ( ) { boolean errorCaught = false ; when ( this . taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; TaskService taskService = new DefaultTaskService ( this . dataSourceProperties , mock ( TaskDefinitionRepository . class ) , this . taskExplorer , this . taskExecutionRepository , this . appRegistry , this . resourceLoader , this . taskLauncher , this . metadataResolver , new TaskConfigurationProperties ( ) , new InMemoryDeploymentIdRepository ( ) , null ) ; try { taskService . executeTask ( TASK_NAME_ORIG , new HashMap < > ( ) , new LinkedList < > ( ) ) ; } catch ( NoSuchTaskDefinitionException ise ) { errorCaught = true ; assertEquals ( " Could ▁ not ▁ find ▁ task ▁ definition ▁ named ▁ myTask _ ORIG " , ise . getMessage ( ) ) ; } if ( ! errorCaught ) { fail ( ) ; } }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createSequenceComposedTask ( ) { String dsl = " AAA ▁ & & ▁ BBB " ; taskService . saveTaskDefinition ( " seqTask " , dsl ) ; verifyTaskExistsInRepo ( " seqTask " , dsl ) ; verifyTaskExistsInRepo ( " seqTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " seqTask - BBB " , " BBB " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createSplitComposedTask ( ) { String dsl = " < AAA ▁ | | ▁ BBB > " ; taskService . saveTaskDefinition ( " splitTask " , dsl ) ; verifyTaskExistsInRepo ( " splitTask " , dsl ) ; verifyTaskExistsInRepo ( " splitTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " splitTask - BBB " , " BBB " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void verifyComposedTaskFlag ( ) { String composedTaskDsl = " < AAA ▁ | | ▁ BBB > " ; assertTrue ( " Expected ▁ true ▁ for ▁ composed ▁ task " , taskService . isComposedDefinition ( composedTaskDsl ) ) ; composedTaskDsl = " AAA ▁ ' FAILED ' ▁ - > ▁ BBB ▁ ' * ' ▁ - > ▁ CCC " ; assertTrue ( " Expected ▁ true ▁ for ▁ composed ▁ task " , taskService . isComposedDefinition ( composedTaskDsl ) ) ; composedTaskDsl = " AAA ▁ & & ▁ BBB ▁ & & ▁ CCC " ; assertTrue ( " Expected ▁ true ▁ for ▁ composed ▁ task " , taskService . isComposedDefinition ( composedTaskDsl ) ) ; String nonComposedTaskDsl = " AAA " ; assertFalse ( " Expected ▁ false ▁ for ▁ non - composed ▁ task " , taskService . isComposedDefinition ( nonComposedTaskDsl ) ) ; nonComposedTaskDsl = " AAA ▁ - - foo = bar " ; assertFalse ( " Expected ▁ false ▁ for ▁ non - composed ▁ task " , taskService . isComposedDefinition ( nonComposedTaskDsl ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createTransitionComposedTask ( ) { String dsl = " AAA ▁ ' FAILED ' ▁ - > ▁ BBB ▁ ' * ' ▁ - > ▁ CCC " ; taskService . saveTaskDefinition ( " transitionTask " , dsl ) ; verifyTaskExistsInRepo ( " transitionTask " , dsl ) ; verifyTaskExistsInRepo ( " transitionTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " transitionTask - BBB " , " BBB " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void createSimpleTask ( ) { taskService . saveTaskDefinition ( " simpleTask " , " AAA ▁ - - foo = bar " ) ; verifyTaskExistsInRepo ( " simpleTask " , " AAA ▁ - - foo = bar " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void deleteComposedTask ( ) { String dsl = " AAA ▁ & & ▁ BBB ▁ & & ▁ CCC " ; taskService . saveTaskDefinition ( " deleteTask " , dsl ) ; verifyTaskExistsInRepo ( " deleteTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " deleteTask - BBB " , " BBB " ) ; verifyTaskExistsInRepo ( " deleteTask - CCC " , " CCC " ) ; verifyTaskExistsInRepo ( " deleteTask " , dsl ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskService . deleteTaskDefinition ( " deleteTask " ) ; assertThat ( preDeleteSize - 4 , is ( equalTo ( taskDefinitionRepository . count ( ) ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void deleteComposedTaskDeleteOnlyChildren ( ) { taskService . saveTaskDefinition ( " deleteTask - AAA " , " AAA " ) ; String dsl = " BBB ▁ & & ▁ CCC " ; taskService . saveTaskDefinition ( " deleteTask " , dsl ) ; verifyTaskExistsInRepo ( " deleteTask - AAA " , " AAA " ) ; verifyTaskExistsInRepo ( " deleteTask - BBB " , " BBB " ) ; verifyTaskExistsInRepo ( " deleteTask - CCC " , " CCC " ) ; verifyTaskExistsInRepo ( " deleteTask " , dsl ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskService . deleteTaskDefinition ( " deleteTask " ) ; assertThat ( preDeleteSize - 3 , is ( equalTo ( taskDefinitionRepository . count ( ) ) ) ) ; verifyTaskExistsInRepo ( " deleteTask - AAA " , " AAA " ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void deleteComposedTaskWithLabel ( ) { String dsl = " LLL : ▁ AAA ▁ & & ▁ BBB " ; taskService . saveTaskDefinition ( " deleteTask " , dsl ) ; verifyTaskExistsInRepo ( " deleteTask - LLL " , " AAA " ) ; verifyTaskExistsInRepo ( " deleteTask - BBB " , " BBB " ) ; verifyTaskExistsInRepo ( " deleteTask " , dsl ) ; long preDeleteSize = taskDefinitionRepository . count ( ) ; taskService . deleteTaskDefinition ( " deleteTask " ) ; assertThat ( preDeleteSize - 3 , is ( equalTo ( taskDefinitionRepository . count ( ) ) ) ) ; }
ericbottard/spring-cloud-dataflow | @ Test @ DirtiesContext public void verifyDataFlowUriProperty ( ) throws Exception { when ( this . taskLauncher . launch ( anyObject ( ) ) ) . thenReturn ( "0" ) ; TaskService taskService = new DefaultTaskService ( this . dataSourceProperties , mock ( TaskDefinitionRepository . class ) , this . taskExplorer , this . taskExecutionRepository , this . appRegistry , this . resourceLoader , this . taskLauncher , this . metadataResolver , new TaskConfigurationProperties ( ) , new InMemoryDeploymentIdRepository ( ) , " http : // myserver : 9191" ) ; List < String > cmdLineArgs = new ArrayList < > ( ) ; Method method = ReflectionUtils . findMethod ( DefaultTaskService . class , " updateDataFlowUriIfNeeded " , Map . class , List . class ) ; ReflectionUtils . makeAccessible ( method ) ; Map < String , String > appDeploymentProperties = new HashMap < > ( ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ expected ▁ to ▁ be ▁ in ▁ the ▁ app ▁ deployment ▁ properties " , appDeploymentProperties . get ( " dataflowServerUri " ) . equals ( " http : // myserver : 9191" ) ) ; appDeploymentProperties . clear ( ) ; appDeploymentProperties . put ( " dataflow - server - uri " , " http : // localhost : 8080" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ incorrect " , appDeploymentProperties . get ( " dataflow - server - uri " ) . equals ( " http : // localhost : 8080" ) ) ; appDeploymentProperties . clear ( ) ; appDeploymentProperties . put ( " dataflowServerUri " , " http : // localhost : 8191" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ incorrect " , appDeploymentProperties . get ( " dataflowServerUri " ) . equals ( " http : // localhost : 8191" ) ) ; appDeploymentProperties . clear ( ) ; appDeploymentProperties . put ( " DATAFLOW _ SERVER _ URI " , " http : // localhost : 9000" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( " dataflowServerUri ▁ is ▁ incorrect " , appDeploymentProperties . get ( " DATAFLOW _ SERVER _ URI " ) . equals ( " http : // localhost : 9000" ) ) ; appDeploymentProperties . clear ( ) ; cmdLineArgs . add ( " - - dataflowServerUri = http : // localhost : 8383" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; cmdLineArgs . clear ( ) ; cmdLineArgs . add ( " DATAFLOW _ SERVER _ URI = http : // localhost : 8383" ) ; method . invoke ( taskService , appDeploymentProperties , cmdLineArgs ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " dataflowServerUri " ) ) ; assertTrue ( ! appDeploymentProperties . containsKey ( " DATAFLOW - SERVER - URI " ) ) ; }
ericbottard/spring-cloud-dataflow | private void verifyTaskExistsInRepo ( String taskName , String dsl ) { TaskDefinition taskDefinition = taskDefinitionRepository . findOne ( taskName ) ; assertThat ( taskDefinition . getName ( ) , is ( equalTo ( taskName ) ) ) ; assertThat ( taskDefinition . getDslText ( ) , is ( equalTo ( dsl ) ) ) ; }
asgarth/snow | public StatusBarFooter ( final ApplicationWindow parent ) { this ( parent , SWT . BORDER | SWT . SHADOW_OUT ) ; }
asgarth/snow | public StatusBarFooter ( final ApplicationWindow parent , final int style ) { super ( parent , style ) ; final FillLayout layout = new FillLayout ( ) ; layout . marginWidth = 5 ; setLayout ( layout ) ; status = new CLabel ( this , SWT . NONE ) ; }
asgarth/snow | public void log ( final String message ) { status . setText ( message ) ; }
asgarth/snow | public void error ( final String message ) { status . setText ( message ) ; }
asgarth/snow | @ Override public int getHeight ( ) { return HEIGHT ; }
andyj24/googleads-java-lib | public ThirdPartyAudienceSegmentAudienceSegmentApprovalStatus getApprovalStatus ( ) { return approvalStatus ; }
andyj24/googleads-java-lib | public void setApprovalStatus ( ThirdPartyAudienceSegmentAudienceSegmentApprovalStatus value ) { this . approvalStatus = value ; }
andyj24/googleads-java-lib | public Money getCost ( ) { return cost ; }
andyj24/googleads-java-lib | public void setCost ( Money value ) { this . cost = value ; }
andyj24/googleads-java-lib | public DateTime getStartDateTime ( ) { return startDateTime ; }
andyj24/googleads-java-lib | public void setStartDateTime ( DateTime value ) { this . startDateTime = value ; }
andyj24/googleads-java-lib | public DateTime getEndDateTime ( ) { return endDateTime ; }
andyj24/googleads-java-lib | public void setEndDateTime ( DateTime value ) { this . endDateTime = value ; }
nikolai-m/nmatveev | public Point ( int x , int y ) { this . x = x ; this . y = y ; }
nikolai-m/nmatveev | public int getX ( ) { return this . x ; }
nikolai-m/nmatveev | public int getY ( ) { return this . y ; }
nikolai-m/nmatveev | public boolean is ( int a , int b ) { return y == ( ( a * x ) + b ) ; }
coding0011/elasticsearch | @ Before public void setup ( ) throws IOException { String yaml = " / org / elasticsearch / index / analysis / phonetic - 1 . yml " ; Settings settings = Settings . builder ( ) . loadFromStream ( yaml , getClass ( ) . getResourceAsStream ( yaml ) , false ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) . build ( ) ; this . analysis = createTestAnalysis ( new Index ( " test " , " _ na _ " ) , settings , new AnalysisPhoneticPlugin ( ) ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterFactory ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " phonetic " ) ; MatcherAssert . assertThat ( filterFactory , instanceOf ( PhoneticTokenFilterFactory . class ) ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterBeiderMorseNoLanguage ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " beidermorsefilter " ) ; Tokenizer tokenizer = new WhitespaceTokenizer ( ) ; tokenizer . setReader ( new StringReader ( " ABADIAS " ) ) ; String [ ] expected = new String [ ] { " abYdias " , " abYdios " , " abadia " , " abadiaS " , " abadias " , " abadio " , " abadioS " , " abadios " , " abodia " , " abodiaS " , " abodias " , " abodio " , " abodioS " , " abodios " , " avadias " , " avadios " , " avodias " , " avodios " , " obadia " , " obadiaS " , " obadias " , " obadio " , " obadioS " , " obadios " , " obodia " , " obodiaS " , " obodias " , " obodioS " } ; BaseTokenStreamTestCase . assertTokenStreamContents ( filterFactory . create ( tokenizer ) , expected ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterBeiderMorseWithLanguage ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " beidermorsefilterfrench " ) ; Tokenizer tokenizer = new WhitespaceTokenizer ( ) ; tokenizer . setReader ( new StringReader ( " Rimbault " ) ) ; String [ ] expected = new String [ ] { " rimbD " , " rimbDlt " , " rimba " , " rimbalt " , " rimbo " , " rimbolt " , " rimbu " , " rimbult " , " rmbD " , " rmbDlt " , " rmba " , " rmbalt " , " rmbo " , " rmbolt " , " rmbu " , " rmbult " } ; BaseTokenStreamTestCase . assertTokenStreamContents ( filterFactory . create ( tokenizer ) , expected ) ; }
coding0011/elasticsearch | public void testPhoneticTokenFilterDaitchMotokoff ( ) throws IOException { TokenFilterFactory filterFactory = analysis . tokenFilter . get ( " daitch _ mokotoff " ) ; Tokenizer tokenizer = new WhitespaceTokenizer ( ) ; tokenizer . setReader ( new StringReader ( " chauptman " ) ) ; String [ ] expected = new String [ ] { "473660" , "573660" } ; assertThat ( filterFactory . create ( tokenizer ) , instanceOf ( DaitchMokotoffSoundexFilter . class ) ) ; BaseTokenStreamTestCase . assertTokenStreamContents ( filterFactory . create ( tokenizer ) , expected ) ; }
ernestp/consulo | CacheEntry ( int visualLine , @ NotNull Editor editor ) { this . visualLine = visualLine ; myEditor = editor ; }
ernestp/consulo | public void setLineStartPosition ( @ NotNull EditorPosition context ) { assert context . visualColumn == 0 ; startLogicalLine = context . logicalLine ; startLogicalColumn = context . logicalColumn ; visualLine = context . visualLine ; startOffset = context . offset ; startSoftWrapLinesBefore = context . softWrapLinesBefore ; startSoftWrapLinesCurrent = context . softWrapLinesCurrent ; startSoftWrapColumnDiff = context . softWrapColumnDiff ; startFoldedLines = context . foldedLines ; startFoldingColumnDiff = context . foldingColumnDiff ; }
ernestp/consulo | public void setLineEndPosition ( @ NotNull EditorPosition position ) { endOffset = position . offset ; endLogicalLine = position . logicalLine ; endLogicalColumn = position . logicalColumn ; endVisualColumn = position . visualColumn ; endSoftWrapLinesBefore = position . softWrapLinesBefore ; endSoftWrapLinesCurrent = position . softWrapLinesCurrent ; endSoftWrapColumnDiff = position . softWrapColumnDiff ; endFoldedLines = position . foldedLines ; endFoldingColumnDiff = position . foldingColumnDiff ; }
ernestp/consulo | public EditorPosition buildStartLinePosition ( ) { EditorPosition result = new EditorPosition ( myEditor ) ; result . logicalLine = startLogicalLine ; result . logicalColumn = startLogicalColumn ; result . offset = startOffset ; result . visualLine = visualLine ; result . visualColumn = 0 ; result . softWrapLinesBefore = startSoftWrapLinesBefore ; result . softWrapLinesCurrent = startSoftWrapLinesCurrent ; result . softWrapColumnDiff = startSoftWrapColumnDiff ; result . foldedLines = startFoldedLines ; result . foldingColumnDiff = startFoldingColumnDiff ; return result ; }
ernestp/consulo | public EditorPosition buildEndLinePosition ( ) { EditorPosition result = new EditorPosition ( myEditor ) ; result . logicalLine = endLogicalLine ; result . logicalColumn = endLogicalColumn ; result . offset = endOffset ; result . visualLine = visualLine ; result . visualColumn = endVisualColumn ; result . softWrapLinesBefore = endSoftWrapLinesBefore ; result . softWrapLinesCurrent = endSoftWrapLinesCurrent ; result . softWrapColumnDiff = endSoftWrapColumnDiff ; result . foldedLines = endFoldedLines ; result . foldingColumnDiff = endFoldingColumnDiff ; return result ; }
ernestp/consulo | public void removeAllDataAtOrAfter ( final int offset ) { if ( myFoldingData != DUMMY && ! myFoldingData . isEmpty ( ) ) { myFoldingData . retainEntries ( new TIntObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( int a , FoldingData b ) { return a < offset ; } } ) ; } int i ; for ( i = 0 ; i < myTabPositions . size ( ) ; i ++ ) { if ( myTabPositions . get ( i ) . offset >= offset ) { break ; } } myTabPositions . subList ( i , myTabPositions . size ( ) ) . clear ( ) ; }
ernestp/consulo | @ Nullable public FoldingData getFoldingData ( @ NotNull final FoldRegion region ) { FoldingData candidate = myFoldingData . get ( region . getStartOffset ( ) ) ; if ( candidate != null ) { return candidate ; } final Ref < FoldingData > result = new Ref < FoldingData > ( ) ; myFoldingData . forEachValue ( new TObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( FoldingData data ) { if ( data . getFoldRegion ( ) . equals ( region ) ) { result . set ( data ) ; return false ; } return true ; } } ) ; return result . get ( ) ; }
ernestp/consulo | public void store ( FoldingData foldData , int offset ) { if ( myFoldingData == DUMMY ) { myFoldingData = new TIntObjectHashMap < FoldingData > ( ) ; } myFoldingData . put ( offset , foldData ) ; }
ernestp/consulo | public List < TabData > getTabData ( ) { return myTabPositions ; }
ernestp/consulo | public void storeTabData ( TabData tabData ) { if ( myTabPositions == Collections . EMPTY_LIST ) { myTabPositions = new ArrayList < TabData > ( ) ; } myTabPositions . add ( tabData ) ; }
ernestp/consulo | public void advance ( final int offsetDiff ) { startOffset += offsetDiff ; endOffset += offsetDiff ; for ( int i = 0 ; i < myTabPositions . size ( ) ; i ++ ) { myTabPositions . get ( i ) . offset += offsetDiff ; } if ( myFoldingData . isEmpty ( ) ) { return ; } final TIntObjectHashMap < FoldingData > newFoldingData = new TIntObjectHashMap < FoldingData > ( myFoldingData . size ( ) ) ; myFoldingData . forEachEntry ( new TIntObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( int offset , FoldingData foldingData ) { newFoldingData . put ( offset + offsetDiff , foldingData ) ; return true ; } } ) ; myFoldingData = newFoldingData ; }
ernestp/consulo | @ TestOnly public TIntObjectHashMap < FoldingData > getFoldingData ( ) { return myFoldingData ; }
ernestp/consulo | @ Override public int compareTo ( CacheEntry e ) { return visualLine - e . visualLine ; }
ernestp/consulo | @ Override public String toString ( ) { return String . format ( " % d ▁ - ▁ visual ▁ line : ▁ % d , ▁ offsets : ▁ % d - % d , ▁ logical ▁ lines : ▁ % d - % d , ▁ logical ▁ columns : ▁ % d - % d , ▁ end ▁ visual ▁ column : ▁ % d , ▁ " + " fold ▁ regions : ▁ % s , ▁ tab ▁ data : ▁ % s " , System . identityHashCode ( this ) , visualLine , startOffset , endOffset , startLogicalLine , endLogicalLine , startLogicalColumn , endLogicalColumn , endVisualColumn , Arrays . toString ( myFoldingData . getValues ( ) ) , myTabPositions ) ; }
ernestp/consulo | @ Override protected CacheEntry clone ( ) { final CacheEntry result = new CacheEntry ( visualLine , myEditor ) ; result . startLogicalLine = startLogicalLine ; result . startLogicalColumn = startLogicalColumn ; result . startOffset = startOffset ; result . startSoftWrapLinesBefore = startSoftWrapLinesBefore ; result . startSoftWrapLinesCurrent = startSoftWrapLinesCurrent ; result . startSoftWrapColumnDiff = startSoftWrapColumnDiff ; result . startFoldedLines = startFoldedLines ; result . startFoldingColumnDiff = startFoldingColumnDiff ; result . endOffset = endOffset ; result . endLogicalLine = endLogicalLine ; result . endLogicalColumn = endLogicalColumn ; result . endVisualColumn = endVisualColumn ; result . endSoftWrapLinesBefore = endSoftWrapLinesBefore ; result . endSoftWrapLinesCurrent = endSoftWrapLinesCurrent ; result . endSoftWrapColumnDiff = endSoftWrapColumnDiff ; result . endFoldedLines = endFoldedLines ; result . endFoldingColumnDiff = endFoldingColumnDiff ; myFoldingData . forEachEntry ( new TIntObjectProcedure < FoldingData > ( ) { @ Override public boolean execute ( int offset , FoldingData foldData ) { result . store ( foldData , offset ) ; return true ; } } ) ; for ( TabData tabPosition : myTabPositions ) { result . storeTabData ( tabPosition ) ; } return result ; }
midiao/isst | private ArchiveCategory ( String subUrl , String nameInDB ) { this . subUrl = subUrl ; this . nameInDB = nameInDB ; }
midiao/isst | public String getSubUrl ( ) { return subUrl ; }
midiao/isst | public String getNameInDB ( ) { return nameInDB ; }
