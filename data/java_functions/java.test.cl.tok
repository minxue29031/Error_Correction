 public EClass getTArgument ( ) { return tArgumentEClass ; }
 public ProductColorJsonModel ( ) { }
 public EDataType getTBooleanObject ( ) { return tBooleanObjectEDataType ; }
 public EClass getTDeadline ( ) { return tDeadlineEClass ; }
 @ Override public JSONObject configurationDescription ( ) throws JSONException { return noConfigDefined ( ) ; }
 public Query ( ) { }
 public AndroidToolsDefaultsJarRule ( Class < ? extends AndroidToolsDefaultsJar > factoryClass , Label ... compatibleWithAndroidEnvironments ) { this . factoryClass = factoryClass ; this . compatibleWithAndroidEnvironments = compatibleWithAndroidEnvironments ; }
 @ Override public CCSSubgraph map ( CCSSubgraphEmbeddings subgraphEmbeddings ) throws Exception { reuseTuple . setCategory ( subgraphEmbeddings . getCategory ( ) ) ; reuseTuple . setCanonicalLabel ( subgraphEmbeddings . getCanonicalLabel ( ) ) ; reuseTuple . setEmbedding ( subgraphEmbeddings . getEmbeddings ( ) . iterator ( ) . next ( ) ) ; return reuseTuple ; }
 @ JsonProperty ( " CodeValueGroups " ) public void setCodeValueGroups ( List < CodeValueGroup > codeValueGroups ) { this . codeValueGroups = codeValueGroups ; }
 public EReference getTLocalNotification_Priority ( ) { return ( EReference ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Override public Memory unconvert ( Environment env , TraceInfo trace , long [ ] arg ) throws Throwable { return ArrayMemory . ofLongs ( arg ) . toConstant ( ) ; }
 @ Override public Img remove ( int index ) { if ( checkRange ( index ) ) { return array . remove ( index ) ; } return Undefined . IMAGE_ELEMENT ; }
 private void assertValueType ( VM vm , final Object key , final ValueType expectedType ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; Object value = region . getValueInVM ( key ) ; switch ( expectedType ) { case RAW_VALUE : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , ! ( value instanceof CachedDeserializable ) ) ; break ; case CD_SERIALIZED : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , value instanceof CachedDeserializable ) ; assertTrue ( " Value ▁ not ▁ serialized " , ( ( CachedDeserializable ) value ) . getValue ( ) instanceof byte [ ] ) ; break ; case CD_DESERIALIZED : assertTrue ( " Value ▁ was ▁ " + value + " ▁ type ▁ " + value . getClass ( ) , value instanceof CachedDeserializable ) ; assertTrue ( " Value ▁ was ▁ serialized " , ! ( ( ( CachedDeserializable ) value ) . getValue ( ) instanceof byte [ ] ) ) ; break ; case EVICTED : assertEquals ( null , value ) ; break ; } } } ) ; }
 @ Override public int getPort ( ) { return port ; }
 protected void initialize ( ) { Robot . cannonSubsystem . PID = false ; }
 @ Test public void test0004 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0013" , " $ { false ▁ & & ▁ null } " , " false " ) ; }
 private void resize ( ) throws IOException { MemorySegment [ ] oldBuckets = this . buckets ; int oldNumBuckets = numBuckets ; int newNumSegs = oldBuckets . length * 2 ; int newNumBuckets = MathUtils . roundDownToPowerOf2 ( newNumSegs * segmentSize / 16 ) ; MemorySegment [ ] newBuckets = new MemorySegment [ newNumSegs ] ; for ( int i = 0 ; i < newNumSegs ; i ++ ) { MemorySegment seg = longTable . getNextBuffer ( ) ; if ( seg == null ) { final int spilledPart = longTable . spillPartition ( ) ; if ( spilledPart == partitionNum ) { longTable . returnAll ( Arrays . asList ( newBuckets ) ) ; return ; } seg = longTable . getNextBuffer ( ) ; if ( seg == null ) { throw new RuntimeException ( " Bug ▁ in ▁ HybridHashJoin : ▁ No ▁ memory ▁ became ▁ available ▁ after ▁ spilling ▁ a ▁ partition . " ) ; } } newBuckets [ i ] = seg ; } setNewBuckets ( newBuckets , newNumBuckets ) ; reHash ( oldBuckets , oldNumBuckets ) ; }
 public String [ ] getMechanismNames ( Map < String , ? > props ) { return PolicyUtils . filterMechs ( myMechs , mechPolicies , props ) ; }
 public NestedSet < Artifact > getNonCodeInputs ( ) { NestedSetBuilder < Artifact > nonCodeInputs = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { nonCodeInputs . addAll ( linkerInput . getNonCodeInputs ( ) ) ; } return nonCodeInputs . build ( ) ; }
 @ Override public Metadata getMetadata ( ) { return Metadata . builder ( ) . name ( " android _ tools _ defaults _ jar " ) . ancestors ( BaseRuleClasses . BaseRule . class ) . factoryClass ( factoryClass ) . build ( ) ; }
 public Object evaluate ( Context context ) { return getNumber ( ) ; }
 public EAttribute getTHumanInteractions_QueryLanguage ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
 @ Override public int compareCustom ( ByteBuffer o1 , ByteBuffer o2 ) { return compareListOrSet ( elements , o1 , o2 ) ; }
 @ Override public long getNumForFailrue ( ) { return this . numForFailrue ; }
 public EAttribute getTTaskInterface_PortType ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 private ExperimentOuterClass ( ) { }
 public void update ( Cell cell ) { updateTimestamp ( cell . timestamp ( ) ) ; if ( cell . isExpiring ( ) ) { updateTTL ( cell . ttl ( ) ) ; updateLocalDeletionTime ( cell . localDeletionTime ( ) ) ; } else if ( cell . isTombstone ( ) ) { updateLocalDeletionTime ( cell . localDeletionTime ( ) ) ; } }
 @ Override public final String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " name " , name ) . toString ( ) ; }
 public Builder addNonCodeInputs ( List < Artifact > nonCodeInputs ) { this . nonCodeInputs . addAll ( nonCodeInputs ) ; return this ; }
 int spillPartition ( IOManager ioAccess , FileIOChannel . ID targetChannel , LinkedBlockingQueue < MemorySegment > bufferReturnQueue ) throws IOException { if ( ! isInMemory ( ) ) { throw new RuntimeException ( " Bug ▁ in ▁ Hybrid ▁ Hash ▁ Join : ▁ " + " Request ▁ to ▁ spill ▁ a ▁ partition ▁ that ▁ has ▁ already ▁ been ▁ spilled . " ) ; } if ( getNumOccupiedMemorySegments ( ) < 2 ) { throw new RuntimeException ( " Bug ▁ in ▁ Hybrid ▁ Hash ▁ Join : ▁ " + " Request ▁ to ▁ spill ▁ a ▁ partition ▁ with ▁ less ▁ than ▁ two ▁ buffers . " ) ; } this . buildSideChannel = FileChannelUtil . createBlockChannelWriter ( ioAccess , targetChannel , bufferReturnQueue , longTable . compressionEnable ( ) , longTable . compressionCodecFactory ( ) , longTable . compressionBlockSize ( ) , segmentSize ) ; return this . buildSideWriteBuffer . spill ( this . buildSideChannel ) ; }
 public EReference getDocumentRoot_Groups ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
 public DistributionManager getDM ( ) { return dm ; }
 public EReference getDocumentRoot_LogicalPeopleGroups ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 9 ) ; }
 public void endOfComplexColumn ( ) { this . tester = null ; }
 public EReference getTToParts_ToPart ( ) { return ( EReference ) tToPartsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 private GenerateSplitAtHalfwayPoint ( BoundedReader < T > reader ) { this . reader = reader ; }
 public void setGlusterVolumeId ( NGuid value ) { glusterVolumeId = value ; }
 @ RequestMapping ( value = " / edit . jsp " , method = RequestMethod . GET ) public ModelAndView showEditForm ( ServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ ModelAttribute ( " form " ) EditTopicRequest form ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; User user = tmpl . getCurrentUser ( ) ; PreparedTopic preparedMessage = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; if ( ! permissionService . isEditable ( preparedMessage , user ) && ! permissionService . isTagsEditable ( preparedMessage , user ) ) { throw new AccessViolationException ( " это ▁ сообщение ▁ нельзя ▁ править " ) ; } return prepareModel ( preparedMessage , form , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) ) ; }
 @ Override synchronized public void updateJobInfoAfterExecuted ( ReadableExecutedInfo rei ) { if ( this . firstEndTime == - 1 ) this . firstEndTime = rei . getEndTime ( ) ; this . lastEndTime = rei . getEndTime ( ) ; if ( this . lastEndTime == - 1 ) this . lastEndTime = System . currentTimeMillis ( ) ; ++ numForRunning ; if ( ! rei . isSuccessTermination ( ) ) { ++ numForFailrue ; this . lastErrorTime = this . lastEndTime ; this . lastThrowable = rei . getFailureException ( ) ; this . errorReason = rei . getFailureReason ( ) ; } if ( rei . isHanlded ( ) ) { ++ numForHandleData ; this . lastHandleDataTime = this . lastEndTime ; } else { this . noHandleDataReason = rei . getNotHandledReason ( ) ; this . noHandleDataTime = this . lastEndTime ; } updateNextRunningTime ( false ) ; }
 public ApplicationException ( Throwable cause ) { super ( cause ) ; }
 public NGuid getUserId ( ) { if ( mUserId . equals ( Guid . Empty ) && getCurrentUser ( ) != null ) { mUserId = getCurrentUser ( ) . getUserId ( ) ; } return mUserId ; }
 @ Override @ Transient public boolean isDetached ( ) { return newArrayList ( isAbstractTypeDetached ( ) , isAddressDetached ( ) ) . stream ( ) . filter ( e -> e . booleanValue ( ) ) . count ( ) > ZERO ; }
 catch ( NotSerializableException e ) { throw e ; }
 @ Test public void testRRHeapLRU ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRRHeapLRU ( vm0 ) ; createRRHeapLRU ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; get ( vm1 , " a " , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; }
 public boolean accept ( File dir , String name ) { if ( name . equals ( " common " ) ) { File commonDir = new File ( dir , name ) ; return commonDir . isDirectory ( ) ; } return false ; }
 @ Override protected MemorySegment nextSegment ( MemorySegment current ) throws IOException { this . currentBufferNum ++ ; if ( this . currentBufferNum < this . partitionBuffers . length ) { return this . partitionBuffers [ this . currentBufferNum ] ; } else { throw new EOFException ( ) ; } }
 public EReference getDocumentRoot_Notification ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 10 ) ; }
 @ Override public long getNextRunningTime ( ) { return this . nextRunningTime ; }
 @ Override public String toString ( ) { return " MUXFilterFeeder ( " + filterName + " , ▁ " + filter + " , ▁ bases : ▁ " + ( bases == null ? " N / A " : Strings . join ( bases , " , ▁ " ) ) + " ) " ; }
 private void createPR ( VM vm , final boolean enableLRU ) { vm . invoke ( new SerializableRunnable ( " Create ▁ pr " ) { public void run ( ) { Cache cache = getCache ( ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setDiskSynchronous ( true ) ; PartitionAttributesFactory < Integer , TestDelta > paf = new PartitionAttributesFactory < Integer , TestDelta > ( ) ; paf . setRedundantCopies ( 1 ) ; if ( enableLRU ) { paf . setLocalMaxMemory ( 1 ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUMemoryAttributes ( new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; } PartitionAttributes < Integer , TestDelta > prAttr = paf . create ( ) ; attr . setPartitionAttributes ( prAttr ) ; attr . setDataPolicy ( DataPolicy . PARTITION ) ; attr . setSubscriptionAttributes ( new SubscriptionAttributes ( InterestPolicy . ALL ) ) ; Region < Integer , TestDelta > region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
 private void setDeltaRecalculatesSize ( VM vm , final boolean shouldSizeChange ) { vm . invoke ( new SerializableRunnable ( " setDeltaRecalculatesSize " ) { public void run ( ) { GemFireCacheImpl . DELTAS_RECALCULATE_SIZE = shouldSizeChange ; } } ) ; }
 private boolean isAggregation ( Association association ) { return association . reversalAssociation . getAggregationSchema ( ) != AggregationSchema . NONE ; }
 if ( Main . config ( ) . getBoolean ( " images " ) ) { NodeList nodeList = doc . getElementsByTagName ( " image " ) ; for ( int temp = 0 ; temp < nodeList . getLength ( ) ; temp ++ ) { Node nNode = nodeList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; File imageFile = new File ( Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; if ( ! imageFile . exists ( ) ) { Cache . image ( eElement . getTextContent ( ) ) ; } if ( type == " chat " ) { if ( eElement . hasAttribute ( " height " ) ) { imageHeight = Integer . parseInt ( eElement . getAttribute ( " height " ) ) ; } else { imageHeight = 8 ; } image = Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ; } if ( type == " hologram " ) { if ( eElement . hasAttribute ( " height " ) ) { lines . put ( Integer . parseInt ( eElement . getAttribute ( " height " ) ) , " image : " + Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; } else { lines . put ( 8 , " image : " + Main . dataFolder ( ) + " / cache / images / " + eElement . getTextContent ( ) . replace ( " http : // " , " " ) . replace ( " https : // " , " " ) . replace ( " . . " , " " ) ) ; } } } } }
 public EClass getTLiteral ( ) { return tLiteralEClass ; }
 @ Override public void getSnapshotGlobalMetadata ( SnapshotId snapshotId , ActionListener < Metadata > listener ) { }
 public EncodingStats ( long minTimestamp , int minLocalDeletionTime , int minTTL ) { this . minTimestamp = minTimestamp == LivenessInfo . NO_TIMESTAMP ? TIMESTAMP_EPOCH : minTimestamp ; this . minLocalDeletionTime = minLocalDeletionTime == LivenessInfo . NO_EXPIRATION_TIME ? DELETION_TIME_EPOCH : minLocalDeletionTime ; this . minTTL = minTTL ; }
 @ Override public void restoreShard ( Store store , SnapshotId snapshotId , IndexId indexId , ShardId snapshotShardId , RecoveryState recoveryState , ActionListener < Void > listener ) { }
 FlowStatement ( FileLocations locs , TokenKind kind , int offset ) { super ( locs ) ; this . kind = kind ; this . offset = offset ; }
 private void reHash ( MemorySegment [ ] oldBuckets , int oldNumBuckets ) throws IOException { long reHashStartTime = System . currentTimeMillis ( ) ; int bucketOffset = 0 ; MemorySegment segment = oldBuckets [ bucketOffset ] ; int segOffset = 0 ; for ( int i = 0 ; i < oldNumBuckets ; i ++ ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { long key = segment . getLong ( segOffset ) ; updateIndex ( key , hashLong ( key , recursionLevel ) , address , 0 , null , 0 ) ; } if ( i != oldNumBuckets - 1 ) { if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { segment = oldBuckets [ ++ bucketOffset ] ; segOffset = 0 ; } } } longTable . returnAll ( Arrays . asList ( oldBuckets ) ) ; LOG . info ( " The ▁ rehash ▁ take ▁ { } ▁ ms ▁ for ▁ { } ▁ segments " , ( System . currentTimeMillis ( ) - reHashStartTime ) , numBuckets ) ; }
 @ Override public final String getName ( ) { return name ; }
 @ Override public void processElement ( WindowedValue < BoundedSourceShard < OutputT > > element ) throws Exception { BoundedSource < OutputT > source = element . getValue ( ) . getSource ( ) ; try ( final BoundedReader < OutputT > reader = source . createReader ( evaluationContext . getPipelineOptions ( ) ) ) { boolean contentsRemaining = reader . start ( ) ; Future < BoundedSource < OutputT > > residualFuture = startDynamicSplitThread ( source , reader ) ; UncommittedBundle < OutputT > output = evaluationContext . createBundle ( transform . getOutput ( ) ) ; while ( contentsRemaining ) { output . add ( WindowedValue . timestampedValueInGlobalWindow ( reader . getCurrent ( ) , reader . getCurrentTimestamp ( ) ) ) ; contentsRemaining = reader . advance ( ) ; } resultBuilder . addOutput ( output ) ; try { BoundedSource < OutputT > residual = residualFuture . get ( ) ; if ( residual != null ) { resultBuilder . addUnprocessedElements ( element . withValue ( BoundedSourceShard . of ( residual ) ) ) ; } } catch ( ExecutionException exex ) { throw UserCodeException . wrap ( exex . getCause ( ) ) ; } } }
 private void close ( boolean success ) { sequence . close ( success ) ; }
 public MsgClassGenerator ( ) { super ( ) ; }
 private void saveCheckArea ( ) { areaName = etName . getText ( ) . toString ( ) ; if ( areaName . isEmpty ( ) ) { showShortToast ( " 名称不能为空 " ) ; etName . requestFocus ( ) ; return ; } if ( taskId == null ) return ; RequestParams params = new RequestParams ( ) ; params . addBodyParameter ( " token " , token ) ; params . addBodyParameter ( " task _ id " , taskId ) ; params . addBodyParameter ( " name " , areaName ) ; params . addBodyParameter ( " type " , Constants . checkTypeArea ) ; String sels = " " ; if ( selInfoIds . size ( ) > 0 ) { for ( int i = 0 ; i < selInfoIds . size ( ) - 1 ; i ++ ) { sels += selInfoIds . get ( i ) + " , " ; } sels += selInfoIds . get ( selInfoIds . size ( ) - 1 ) ; } params . addBodyParameter ( " ids " , sels ) ; HttpUtils http = new HttpUtils ( ) ; String url = Constants . postUrl + Constants . path_saveCheckUnit ; http . send ( HttpMethod . POST , url , params , new RequestCallBack < String > ( ) { @ Override public void onStart ( ) { if ( progressDialog != null ) progressDialog . show ( ) ; } @ Override public void onFailure ( HttpException arg0 , String arg1 ) { if ( progressDialog != null ) progressDialog . dismiss ( ) ; showShortToast ( " 提交失败 ， 请检查网络连接 " ) ; } @ Override public void onSuccess ( ResponseInfo < String > arg0 ) { if ( progressDialog != null ) progressDialog . dismiss ( ) ; showShortToast ( " 操作成功 " ) ; intent = new Intent ( ) ; intent . putExtra ( " areaName " , areaName ) ; setResult ( RESULT_OK , intent ) ; onBackPressed ( ) ; } } ) ; }
 @ Test public void testRRMemLRUDelta ( ) { doRRMemLRUDeltaTest ( false ) ; }
 if ( directMsg != null && directMsg . supportsDirectAck ( ) && threadOwnsResources ( ) ) { directReply = true ; }
 @ Override @ FxThread protected int loadSize ( ) { return getConfig ( ) . getGlobalBottomToolHeight ( ) ; }
 private HTPackageImpl ( ) { super ( eNS_URI , HTFactory . eINSTANCE ) ; }
 long getBuildSideRecordCount ( ) { return buildSideRecordCounter ; }
 public void updateDetails ( ) { }
 public SerializationHelper ( TableMetadata metadata , int version , Flag flag ) { this ( metadata , version , flag , null ) ; }
 public long headerLength ( ) { throw new UnsupportedOperationException ( ) ; }
 public EAttribute getTImport_ImportType ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EAttribute getTExtension_MustUnderstand ( ) { return ( EAttribute ) tExtensionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EAttribute getTDocumentation_Lang ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 public EReference getTRenderings_Rendering ( ) { return ( EReference ) tRenderingsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Test public void aJustCreatedBeanWithMaxKeepaliveIsAliveRightNow ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , FOREVER ) ; assertTrue ( bean . isAlive ( now ( ) ) ) ; }
 public void testNullClip ( ) { try { GraphicsConfiguration gconf = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; VolatileImage vim = gconf . createCompatibleVolatileImage ( 10 , 10 ) ; Graphics2D g2 = ( Graphics2D ) vim . getGraphics ( ) ; g2 . setClip ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; fail ( " Cannot ▁ set ▁ null ▁ clip " ) ; } }
 @ Override public RepositoryMetadata getMetadata ( ) { return null ; }
 public EAttribute getTNotificationInterface_Operation ( ) { return ( EAttribute ) tNotificationInterfaceEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 private long writeOrCountBytes ( BufferedSink sink , boolean countBytes ) { long byteCount = 0L ; Buffer buffer ; if ( countBytes ) { buffer = new Buffer ( ) ; } else { buffer = sink . buffer ( ) ; } for ( int i = 0 , size = encodedNames . size ( ) ; i < size ; i ++ ) { if ( i > 0 ) buffer . writeByte ( ' & ' ) ; buffer . writeUtf8 ( encodedNames . get ( i ) ) ; buffer . writeByte ( ' = ' ) ; buffer . writeUtf8 ( encodedValues . get ( i ) ) ; } if ( countBytes ) { byteCount = buffer . size ( ) ; buffer . clear ( ) ; } return byteCount ; }
 public EDataType getTGroup ( ) { return tGroupEDataType ; }
 public VmTemplate getVmTemplate ( ) { if ( mVmTemplate == null && ( mVmTemplateId != null || getVm ( ) != null ) ) { mVmTemplate = getVmTemplateDAO ( ) . get ( mVmTemplateId != null ? getVmTemplateId ( ) : getVm ( ) . getvmt_guid ( ) ) ; } return mVmTemplate ; }
 private void finalizeRequestProcessing ( FileUploads uploadedFiles ) { inFlightRequestTracker . deregisterRequest ( ) ; cleanupFileUploads ( uploadedFiles ) ; }
 public Query ( String sentence ) { this . sentence = sentence ; }
 public GlobalBottomToolSplitPane ( @ NotNull Scene scene ) { super ( scene , EditorConfig . getInstance ( ) ) ; setOrientation ( Orientation . VERTICAL ) ; }
 @ Test public void testFindingItemsAtTheBeginning ( ) throws Exception { assertThat ( getFinder ( ) . find ( 1 , 1 , 2 , 3 , 4 , 5 ) , is ( 0 ) ) ; }
 private StoreImpl ( ) { }
 public EAttribute getTTaskInterface_Operation ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EReference getTTask_Priority ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 for ( Project . NameKey project : pc . keySet ( ) ) { try ( Repository repo = repoManager . openRepository ( project ) ; RevWalk rw = CodeReviewCommit . newRevWalk ( repo ) ) { for ( Change . Id cId : pc . get ( project ) ) { ChangeData cd = changeDataFactory . create ( db , project , cId ) ; cd . changeControl ( user ) ; SubmitTypeRecord str = cd . submitTypeRecord ( ) ; if ( ! str . isOk ( ) ) { logErrorAndThrow ( " Failed ▁ to ▁ get ▁ submit ▁ type ▁ for ▁ " + cd . getId ( ) + " : ▁ " + str . errorMessage ) ; } if ( str . type == SubmitType . CHERRY_PICK ) { ret . add ( cd ) ; continue ; } PatchSet ps = cd . currentPatchSet ( ) ; String objIdStr = ps . getRevision ( ) . get ( ) ; RevCommit commit = rw . parseCommit ( ObjectId . fromString ( objIdStr ) ) ; Branch . NameKey destBranch = cd . change ( ) . getDest ( ) ; repo . getRefDatabase ( ) . refresh ( ) ; Ref ref = repo . getRefDatabase ( ) . getRef ( destBranch . get ( ) ) ; rw . reset ( ) ; rw . sort ( RevSort . TOPO ) ; rw . markStart ( commit ) ; if ( ref != null ) { RevCommit head = rw . parseCommit ( ref . getObjectId ( ) ) ; rw . markUninteresting ( head ) ; } List < String > hashes = new ArrayList < > ( ) ; hashes . add ( objIdStr ) ; for ( RevCommit c : rw ) { if ( ! c . equals ( commit ) ) { hashes . add ( c . name ( ) ) ; } } if ( ! hashes . isEmpty ( ) ) { Iterable < ChangeData > destChanges = query ( ) . byCommitsOnBranchNotMerged ( repo , db , cd . change ( ) . getDest ( ) , hashes ) ; for ( ChangeData chd : destChanges ) { ret . add ( chd ) ; } } } } }
 @ JsonProperty ( " IsProductNumberAssignmentAllowed " ) public Boolean getIsProductNumberAssignmentAllowed ( ) { return isProductNumberAssignmentAllowed ; }
 @ Override public Object [ ] toArray ( ) { Object [ ] toArray = new Object [ array . length ( ) ] ; for ( int i = 0 ; i < array . length ( ) ; i ++ ) { toArray [ i ] = array . get ( i ) ; } return toArray ; }
 public boolean canSkipValue ( CellPath path ) { return path != null && tester != null && ! tester . fetchedCellIsQueried ( path ) ; }
 private Future < BoundedSource < OutputT > > startDynamicSplitThread ( BoundedSource < OutputT > source , BoundedReader < OutputT > reader ) throws Exception { if ( source . getEstimatedSizeBytes ( evaluationContext . getPipelineOptions ( ) ) > minimumDynamicSplitSize ) { return produceSplitExecutor . submit ( new GenerateSplitAtHalfwayPoint < > ( reader ) ) ; } else { SettableFuture < BoundedSource < OutputT > > emptyFuture = SettableFuture . create ( ) ; emptyFuture . set ( null ) ; return emptyFuture ; } }
 private void cleanQuery ( ) { this . sentence = this . sentence . replaceAll ( " \t + " , " ▁ " ) . replaceAll ( " \n + " , " ▁ " ) . replaceAll ( " ▁ + " , " ▁ " ) ; }
 public SerializationHelper ( TableMetadata metadata , int version , Flag flag , ColumnFilter columnsToFetch ) { this . flag = flag ; this . version = version ; this . columnsToFetch = columnsToFetch ; this . droppedColumns = metadata . droppedColumns ; this . hasDroppedColumns = droppedColumns . size ( ) > 0 ; }
 public TestKey ( String value ) { this . value = value ; }
 @ Test public void testLargeDelta ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , false ) ; setDeltaRecalculatesSize ( vm1 , false ) ; createPR ( vm0 , false ) ; createPR ( vm1 , false ) ; int BIG_DELTA_SIZE = 32 * 1024 * 2 ; StringBuilder sb = new StringBuilder ( BIG_DELTA_SIZE ) ; for ( int i = 0 ; i < BIG_DELTA_SIZE ; i ++ ) { sb . append ( '7' ) ; } TestDelta delta1 = new TestDelta ( true , sb . toString ( ) ) ; assignPRBuckets ( vm0 ) ; boolean vm0isPrimary = prHostsBucketForKey ( vm0 , 0 ) ; if ( ! vm0isPrimary ) { assertEquals ( true , prHostsBucketForKey ( vm1 , 0 ) ) ; } VM primaryVm ; VM secondaryVm ; if ( vm0isPrimary ) { primaryVm = vm0 ; secondaryVm = vm1 ; } else { primaryVm = vm1 ; secondaryVm = vm0 ; } put ( secondaryVm , 0 , delta1 ) ; }
 public String getCode ( ) { return code ; }
 @ Override public boolean isMoreRunningJob ( ) { return this . moreRunning ; }
 public boolean isDropped ( Cell cell , boolean isComplex ) { if ( ! hasDroppedColumns ) return false ; DroppedColumn dropped = isComplex ? currentDroppedComplex : droppedColumns . get ( cell . column ( ) . name . bytes ) ; return dropped != null && cell . timestamp ( ) <= dropped . droppedTime ; }
 public boolean canSkipValue ( ColumnMetadata column ) { return columnsToFetch != null && ! columnsToFetch . fetchedColumnIsQueried ( column ) ; }
 public AdGroupDAO getAdGroupDAO ( ) { return getDbFacade ( ) . getAdGroupDAO ( ) ; }
 public void receive ( DistributionMessage msg , int bytesRead ) throws MemberShunnedException { if ( disconnected ) { return ; } try { receiver . messageReceived ( msg ) ; } catch ( MemberShunnedException e ) { throw e ; } catch ( CancelException e ) { } catch ( Exception ex ) { if ( ! conduit . getCancelCriterion ( ) . isCancelInProgress ( ) ) { logger . fatal ( " While ▁ pulling ▁ a ▁ message " , ex ) ; } } }
 public EReference getTDeadline_Until ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 @ JsonProperty ( " CriteriaTypeCode " ) public String getCriteriaTypeCode ( ) { return criteriaTypeCode ; }
 public EncodingStats get ( ) { return new EncodingStats ( isTimestampSet ? minTimestamp : TIMESTAMP_EPOCH , isDelTimeSet ? minDeletionTime : DELETION_TIME_EPOCH , isTTLSet ? minTTL : TTL_EPOCH ) ; }
 if ( msg instanceof DirectReplyMessage ) { directMsg = ( DirectReplyMessage ) msg ; }
 @ Override public void debugPrint ( Printer printer ) { printer . append ( " < LinkerInput ( owner = " ) ; owner . debugPrint ( printer ) ; printer . append ( " , ▁ libraries = [ " ) ; for ( LibraryToLink libraryToLink : libraries ) { libraryToLink . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] , ▁ userLinkFlags = [ " ) ; printer . append ( Joiner . on ( " , ▁ " ) . join ( userLinkFlags ) ) ; printer . append ( " ] , ▁ nonCodeInputs = [ " ) ; for ( Artifact nonCodeInput : nonCodeInputs ) { nonCodeInput . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] ) > " ) ; }
 public EAttribute getTExpression_Any ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 private void logStatistics ( Profiler profiler , long startTime , Payload last ) { if ( ! ( log . isTraceEnabled ( ) || ( log . isDebugEnabled ( ) && profiler . getBeats ( ) % DEBUG_FEEDBACK == 0 ) || ( log . isInfoEnabled ( ) && profiler . getBeats ( ) % everyStatus == 0 ) ) ) { return ; } String ms = Double . toString ( ( System . nanoTime ( ) - startTime ) / 1000000.0 ) ; String currentAverage = profiler . getBps ( true ) < 10 ? Double . toString ( profiler . getBps ( true ) ) : Integer . toString ( ( int ) profiler . getBps ( true ) ) ; String overallAverage = profiler . getBps ( false ) < 10 ? Double . toString ( profiler . getBps ( false ) ) : Integer . toString ( ( int ) profiler . getBps ( false ) ) ; String message = String . format ( " % d ▁ pumps ▁ performed ▁ in ▁ % s , ▁ average ▁ speed ▁ for ▁ the ▁ last ▁ % d ▁ pumps ▁ was ▁ % s ▁ pumps / sec , ▁ overall ▁ average ▁ was ▁ " + " % s ▁ pumps / sec , ▁ last ▁ pump ▁ took ▁ % s ▁ ms ▁ and ▁ delivered ▁ % s " , profiler . getBeats ( ) , profiler . getSpendTime ( ) , profiler . getBpsSpan ( ) , currentAverage , overallAverage , ms , last == null ? " no ▁ Payload " : last . getId ( ) ) ; if ( profiler . getBeats ( ) % everyStatus == 0 ) { log . info ( message ) ; } else if ( profiler . getBeats ( ) % DEBUG_FEEDBACK == 0 ) { log . debug ( message ) ; } else { log . trace ( message ) ; } }
 public Guid getQuotaId ( ) { return getQuotaIdRef ( ) != null ? getQuotaIdRef ( ) . getValue ( ) : Guid . Empty ; }
 public AuditLogableBase ( final NGuid vdsId , final Guid vmId ) { this ( vdsId ) ; mVmId = vmId ; }
 public List < VisorCachePartition > primary ( ) { return primary ; }
 public void setStoragePoolId ( final NGuid value ) { _storagePoolId = value ; }
 public int serializedSize ( RowIndexEntry < IndexHelper . IndexInfo > rie ) { assert version . storeRows ( ) : " We ▁ read ▁ old ▁ index ▁ files ▁ but ▁ we ▁ should ▁ never ▁ write ▁ them " ; int indexedSize = 0 ; if ( rie . isIndexed ( ) ) { List < IndexHelper . IndexInfo > index = rie . columnsIndex ( ) ; indexedSize += TypeSizes . sizeofUnsignedVInt ( rie . headerLength ( ) ) ; indexedSize += DeletionTime . serializer . serializedSize ( rie . deletionTime ( ) ) ; indexedSize += TypeSizes . sizeofUnsignedVInt ( index . size ( ) ) ; for ( IndexHelper . IndexInfo info : index ) indexedSize += idxSerializer . serializedSize ( info ) ; indexedSize += index . size ( ) * TypeSizes . sizeof ( 0 ) ; } return TypeSizes . sizeofUnsignedVInt ( rie . position ) + TypeSizes . sizeofUnsignedVInt ( indexedSize ) + indexedSize ; }
 public int getPort ( ) { return this . conduit . getPort ( ) ; }
 public EReference getTDeadline_For ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 private void assertGroupsParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " groups " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ groups ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } Class < ? > [ ] defaultGroups = ( Class < ? > [ ] ) method . getDefaultValue ( ) ; if ( defaultGroups . length != 0 ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ groups ▁ " + " parameter ▁ default ▁ value ▁ is ▁ not ▁ the ▁ empty ▁ array . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " groups ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
 @ Override public void writeTo ( BufferedSink sink ) throws IOException { writeOrCountBytes ( sink , false ) ; }
 @ XmlElement @ Column ( name = PAYER_COLUMN_NAME ) public String getPayer ( ) { return payer ; }
 public EAttribute getDocumentRoot_User ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 21 ) ; }
 @ Override synchronized public void updateJobInfoBeforeExecuted ( ReadableExecutedInfo rei ) { if ( this . firstBeginTime == - 1 ) this . firstBeginTime = rei . getBeginTime ( ) ; this . lastBeginTime = rei . getBeginTime ( ) ; this . updateNextRunningTime ( true ) ; }
 if ( directMsg != null || msg . getProcessorId ( ) > 0 ) { ackTimeout = ( int ) ( ackWaitThreshold * 1000 ) ; if ( msg . isSevereAlertCompatible ( ) || ReplyProcessor21 . isSevereAlertProcessingForced ( ) ) { ackSDTimeout = ( int ) ( ackSAThreshold * 1000 ) ; if ( ReplyProcessor21 . getShortSevereAlertProcessing ( ) ) { ackSDTimeout = ( int ) ( ReplyProcessor21 . PR_SEVERE_ALERT_RATIO * ackSDTimeout ) ; } } }
 @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ProductColorJsonModel other = ( ProductColorJsonModel ) obj ; if ( code == null ) { if ( other . code != null ) return false ; } else if ( ! code . equals ( other . code ) ) return false ; if ( codeValueGroups == null ) { if ( other . codeValueGroups != null ) return false ; } else if ( ! codeValueGroups . equals ( other . codeValueGroups ) ) return false ; if ( description == null ) { if ( other . description != null ) return false ; } else if ( ! description . equals ( other . description ) ) return false ; if ( displayName == null ) { if ( other . displayName != null ) return false ; } else if ( ! displayName . equals ( other . displayName ) ) return false ; return true ; }
 public EClass getTNotification ( ) { return tNotificationEClass ; }
 @ Override public BoundedSource < T > call ( ) throws Exception { Double currentlyConsumed = reader . getFractionConsumed ( ) ; if ( currentlyConsumed == null || currentlyConsumed == 1.0 ) { return null ; } double halfwayBetweenCurrentAndCompletion = 0.5 + ( currentlyConsumed / 2 ) ; return reader . splitAtFraction ( halfwayBetweenCurrentAndCompletion ) ; }
 @ Override public String toString ( ) { return " ProductColorJsonModel ▁ [ code = " + code + " , ▁ description = " + description + " , ▁ displayName = " + displayName + " , ▁ codeValueGroups = " + codeValueGroups + " ] " ; }
 public AbstractType < T > getElementsType ( ) { return elements ; }
 public EReference getTTask_Deadlines ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 8 ) ; }
 public void settings ( ) { size ( multiplier * 600 , multiplier * 600 ) ; }
 public List < CodeValueGroupJsonModel > getCodeValueGroups ( ) { return codeValueGroups ; }
 public OrOperation ( ) { super ( NAME ) ; }
 @ Override public void onHandleIntent ( Intent intent ) { GoogleApiClient googleApiClient = new GoogleApiClient . Builder ( this ) . addApi ( Wearable . API ) . build ( ) ; ConnectionResult result = googleApiClient . blockingConnect ( CONNECT_TIMEOUT_MS , TimeUnit . MILLISECONDS ) ; if ( ! result . isSuccess ( ) ) { Log . e ( TAG , " Failed ▁ to ▁ connect ▁ to ▁ GoogleApiClient . " ) ; return ; } String login = intent . getStringExtra ( KEY_LOGIN ) ; Wearable . MessageApi . sendMessage ( googleApiClient , REQUEST_PATH , RESET_PATH , Base64Utils . encode ( login ) ) ; }
 protected void setVdsIdRef ( final NGuid value ) { mVdsId = value ; }
 @ Override @ FxThread protected double getExpandPosition ( double toolSize , double sceneSize ) { return 1D - super . getExpandPosition ( toolSize , sceneSize ) ; }
 public void controlEvent ( ControlEvent theEvent ) { System . out . println ( theEvent . getController ( ) . getName ( ) ) ; if ( city != " " ) { switch ( theEvent . getName ( ) ) { case " Dijkstra " : if ( destCity != " " ) { Dijkstra tmp = new Dijkstra ( spainGraph . getGraph ( ) ) ; tmp . setSource ( city ) ; trace = tmp . trace ( destCity ) ; sphero . putTo ( trace ) ; } break ; case " DFS " : trace = DFS . trace ( spainGraph . getGraph ( ) , city ) ; sphero . putTo ( trace ) ; break ; case " BFS " : trace = BFS . trace ( spainGraph . getGraph ( ) , city ) ; sphero . putTo ( trace ) ; break ; } } }
 private JsonCollectors ( ) { }
 for ( String ad : userAds ) { ads . add ( ad ) ; }
 protected AffineTransform getArrowTrans ( Point2D p1 , Point2D p2 , double width ) { m_arrowTrans . setToTranslation ( p2 . getX ( ) , p2 . getY ( ) ) ; m_arrowTrans . rotate ( - HALF_PI + Math . atan2 ( p2 . getY ( ) - p1 . getY ( ) , p2 . getX ( ) - p1 . getX ( ) ) ) ; if ( width > 1 ) { double scalar = width / 2 ; m_arrowTrans . scale ( scalar , scalar ) ; } return m_arrowTrans ; }
 @ Override public String toString ( ) { return S . toString ( IpcServerTcpEndpoint . class , this ) ; }
 public void setJobId ( NGuid jobId ) { this . jobId = jobId ; }
 public EAttribute getTEscalation_Name ( ) { return ( EAttribute ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
 @ JsonProperty ( " CodeValueGroups " ) public List < CodeValueGroup > getCodeValueGroups ( ) { return codeValueGroups ; }
 @ Override @ FxThread protected void addElements ( @ NotNull TabToolComponent toolComponent , @ NotNull Node other ) { getItems ( ) . setAll ( other , toolComponent ) ; }
 if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; }
 @ CacheEvict ( value = " Groups " , key = " # group . id " ) public void setParams ( final Group group , final String title , final String info , final String longInfo , final boolean resolvable , final String urlName ) { jdbcTemplate . execute ( " UPDATE ▁ groups ▁ SET ▁ title = ? , ▁ info = ? , ▁ longinfo = ? , resolvable = ? , urlname = ? ▁ WHERE ▁ id = ? " , ( PreparedStatement pst ) -> { pst . setString ( 1 , title ) ; if ( ! info . isEmpty ( ) ) { pst . setString ( 2 , info ) ; } else { pst . setString ( 2 , null ) ; } if ( ! longInfo . isEmpty ( ) ) { pst . setString ( 3 , longInfo ) ; } else { pst . setString ( 3 , null ) ; } pst . setBoolean ( 4 , resolvable ) ; pst . setString ( 5 , urlName ) ; pst . setInt ( 6 , group . getId ( ) ) ; pst . executeUpdate ( ) ; return null ; } ) ; }
 private void addListener ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Add ▁ listener " ) { public void run ( ) { Cache cache = getCache ( ) ; Region region = cache . getRegion ( " region " ) ; try { region . getAttributesMutator ( ) . addCacheListener ( new TestCacheListener ( ) ) ; } catch ( Exception e ) { Assert . fail ( " couldn ' t ▁ create ▁ index " , e ) ; } } } ) ; }
 @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof TestKey ) ) return false ; TestKey other = ( TestKey ) obj ; if ( value == null ) { if ( other . value != null ) return false ; } else if ( ! value . equals ( other . value ) ) return false ; return true ; }
 @ Test public void testPRHeapLRUDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , true , true , false ) ; }
 public Builder addLinkstamps ( List < Linkstamp > linkstamps ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLinkstamps ( linkstamps ) ; return this ; }
 @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ binary _ base " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( AndroidResourceSupportRule . class ) . build ( ) ; }
 @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( code == null ) ? 0 : code . hashCode ( ) ) ; result = prime * result + ( ( codeValueGroups == null ) ? 0 : codeValueGroups . hashCode ( ) ) ; result = prime * result + ( ( description == null ) ? 0 : description . hashCode ( ) ) ; result = prime * result + ( ( displayName == null ) ? 0 : displayName . hashCode ( ) ) ; return result ; }
 public String getChainName ( ) { return chainName ; }
 @ Override public Set < GroupConversionDescriptor > getGroupConversions ( ) { return groupConversions ; }
 @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof Linkstamp ) ) { return false ; } Linkstamp other = ( Linkstamp ) obj ; return artifact . equals ( other . artifact ) && Arrays . equals ( this . nestedDigest , other . nestedDigest ) ; }
 public EClass getTRenderings ( ) { return tRenderingsEClass ; }
 @ VisibleForTesting long maxBytesForLevel ( int level ) { if ( level == 0 ) return 4L * maxSSTableSizeInBytes ; double bytes = Math . pow ( 10 , level ) * maxSSTableSizeInBytes ; if ( bytes > Long . MAX_VALUE ) throw new RuntimeException ( " At ▁ most ▁ " + Long . MAX_VALUE + " ▁ bytes ▁ may ▁ be ▁ in ▁ a ▁ compaction ▁ level ; ▁ your ▁ maxSSTableSize ▁ must ▁ be ▁ absurdly ▁ high ▁ to ▁ compute ▁ " + bytes ) ; return ( long ) bytes ; }
 public RoleGroupMapDAO getRoleGroupMapDAO ( ) { return getDbFacade ( ) . getRoleGroupMapDAO ( ) ; }
 public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; switch ( type ) { case TYPE_VALUE : sb . append ( " VALUE ( " ) . append ( value ) . append ( " ) " ) ; break ; case TYPE_LEFT_BRACE : sb . append ( " LEFT ▁ BRACE ( { ) " ) ; break ; case TYPE_RIGHT_BRACE : sb . append ( " RIGHT ▁ BRACE ( } ) " ) ; break ; case TYPE_LEFT_SQUARE : sb . append ( " LEFT ▁ SQUARE ( [ ) " ) ; break ; case TYPE_RIGHT_SQUARE : sb . append ( " RIGHT ▁ SQUARE ( ] ) " ) ; break ; case TYPE_COMMA : sb . append ( " COMMA ( , ) " ) ; break ; case TYPE_COLON : sb . append ( " COLON ( : ) " ) ; break ; case TYPE_EOF : sb . append ( " END ▁ OF ▁ FILE " ) ; break ; default : throw new IllegalStateException ( " Not ▁ a ▁ known ▁ type " ) ; } return sb . toString ( ) ; }
 public < A extends Annotation > List < Annotation > getMultiValueConstraints ( A annotation ) { List < Annotation > annotationList = new ArrayList < Annotation > ( ) ; try { final Method method = ReflectionHelper . getMethod ( annotation . getClass ( ) , " value " ) ; if ( method != null ) { Class returnType = method . getReturnType ( ) ; if ( returnType . isArray ( ) && returnType . getComponentType ( ) . isAnnotation ( ) ) { Annotation [ ] annotations = ( Annotation [ ] ) method . invoke ( annotation ) ; for ( Annotation a : annotations ) { Class < ? extends Annotation > annotationType = a . annotationType ( ) ; if ( isConstraintAnnotation ( annotationType ) || isBuiltinConstraint ( annotationType ) ) { annotationList . add ( a ) ; } } } } } catch ( IllegalAccessException iae ) { } catch ( InvocationTargetException ite ) { } return annotationList ; }
 public int sizeof ( Object o ) { if ( InternalDistributedSystem . getLoggerI18n ( ) . fineEnabled ( ) ) { InternalDistributedSystem . getLoggerI18n ( ) . fine ( " TestObjectSizer ▁ invoked " ) ; } if ( o instanceof TestObject ) { invocations . incrementAndGet ( ) ; return ( ( TestObject ) o ) . sizeForSizer ; } if ( o instanceof TestDelta ) { invocations . incrementAndGet ( ) ; return ( ( TestDelta ) o ) . info . length ( ) ; } if ( o instanceof Integer ) { return 0 ; } if ( o instanceof TestKey ) { invocations . incrementAndGet ( ) ; return ( ( TestKey ) o ) . value . length ( ) ; } throw new RuntimeException ( " Unpected ▁ type ▁ to ▁ be ▁ sized ▁ " + o . getClass ( ) + " , ▁ object = " + o ) ; }
 public Builder addLibraries ( List < LibraryToLink > libraries ) { this . libraries . addAll ( libraries ) ; return this ; }
 if ( destinations . length == 0 ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ empty ▁ destinations ▁ passed ▁ in ▁ { } " , msg ) ; } return 0 ; }
 int finalizeBuildPhase ( IOManager ioAccess , FileIOChannel . Enumerator probeChannelEnumerator ) throws IOException { this . finalBufferLimit = this . buildSideWriteBuffer . getCurrentPositionInSegment ( ) ; this . partitionBuffers = this . buildSideWriteBuffer . close ( ) ; if ( ! isInMemory ( ) ) { this . buildSideChannel . close ( ) ; this . probeSideBuffer = FileChannelUtil . createOutputView ( ioAccess , probeChannelEnumerator . next ( ) , longTable . compressionEnable ( ) , longTable . compressionCodecFactory ( ) , longTable . compressionBlockSize ( ) , segmentSize ) ; return 1 ; } else { return 0 ; } }
 public boolean includes ( Cell cell , LivenessInfo rowLiveness ) { if ( columnsToFetch == null ) return true ; ColumnMetadata column = cell . column ( ) ; if ( column . isComplex ( ) ) { if ( ! includes ( cell . path ( ) ) ) return false ; return ! canSkipValue ( cell . path ( ) ) || cell . timestamp ( ) >= rowLiveness . timestamp ( ) ; } else { return columnsToFetch . fetchedColumnIsQueried ( column ) || cell . timestamp ( ) >= rowLiveness . timestamp ( ) ; } }
 protected int getObjectSizerInvocations ( LocalRegion region ) { TestObjectSizer sizer = ( TestObjectSizer ) region . getEvictionAttributes ( ) . getObjectSizer ( ) ; int result = sizer . invocations . get ( ) ; region . getCache ( ) . getLogger ( ) . info ( " objectSizerInvocations = " + result ) ; return result ; }
 int getBlockCount ( ) { return this . currentBlockNumber + 1 ; }
 public SaslClient createSaslClient ( String [ ] mechs , String authorizationId , String protocol , String serverName , Map < String , ? > props , CallbackHandler cbh ) throws SaslException { for ( int i = 0 ; i < mechs . length ; i ++ ) { if ( mechs [ i ] . equals ( myMechs [ EXTERNAL ] ) && PolicyUtils . checkPolicy ( mechPolicies [ EXTERNAL ] , props ) ) { return new ExternalClient ( authorizationId ) ; } else if ( mechs [ i ] . equals ( myMechs [ CRAMMD5 ] ) && PolicyUtils . checkPolicy ( mechPolicies [ CRAMMD5 ] , props ) ) { Object [ ] uinfo = getUserInfo ( " CRAM - MD5" , authorizationId , cbh ) ; return new CramMD5Client ( ( String ) uinfo [ 0 ] , ( byte [ ] ) uinfo [ 1 ] ) ; } else if ( mechs [ i ] . equals ( myMechs [ PLAIN ] ) && PolicyUtils . checkPolicy ( mechPolicies [ PLAIN ] , props ) ) { Object [ ] uinfo = getUserInfo ( " PLAIN " , authorizationId , cbh ) ; return new PlainClient ( authorizationId , ( String ) uinfo [ 0 ] , ( byte [ ] ) uinfo [ 1 ] ) ; } } return null ; }
 public void setVdsId ( final Guid value ) { mVdsId = value ; }
 public ExtraLinkTimeLibraries getExtraLinkTimeLibraries ( ) { return extraLinkTimeLibraries ; }
 public void setDataDeCriacao ( String dataDeCriacao ) { this . dataDeCriacao = dataDeCriacao ; }
 public EClass getTDocumentation ( ) { return tDocumentationEClass ; }
 public void setDescription ( String description ) { this . description = description ; }
 protected CompletableFuture < Void > closeHandlerAsync ( ) { return CompletableFuture . completedFuture ( null ) ; }
 public EReference getTNotification_Interface ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Override public long headerLength ( ) { return headerLength ; }
 public Yytoken ( int type , Object value ) { this . type = type ; this . value = value ; }
 public NGuid getVmIdRef ( ) { if ( mVmId == null && getVm ( ) != null ) { mVmId = getVm ( ) . getId ( ) ; } return mVmId ; }
 public NestedSet < LinkerInput > getLinkerInputs ( ) { return linkerInputs ; }
 public NGuid getVmTemplateIdRef ( ) { if ( mVmTemplateId == null && getVmTemplate ( ) != null ) { mVmTemplateId = getVmTemplate ( ) . getId ( ) ; } return mVmTemplateId ; }
 public SendLoginStatusService ( ) { super ( TAG ) ; }
 @ Override @ SuppressWarnings ( " unchecked " ) public boolean canList ( @ Nonnull World world , @ Nonnull EntityPlayer player ) { return TownHelper . getClosestTownToEntity ( player , false ) . hasBuilding ( building ) ; }
 public DeletionTime deletionTime ( ) { throw new UnsupportedOperationException ( ) ; }
 public boolean hasReceiversFor ( DistributedMember mbr ) { return this . conduit . hasReceiversFor ( mbr ) ; }
 @ Test public void whenZeroAndTenThenTen ( ) { Point first = new Point ( 0 , 0 ) ; Point second = new Point ( 0 , 10 ) ; double result = first . distance ( second ) ; first . info ( ) ; second . info ( ) ; System . out . println ( String . format ( " Result ▁ is ▁ % s " , result ) ) ; assertThat ( result , is ( 10D ) ) ; }
 @ ModelAttribute ( " ipBlockInfo " ) private IPBlockInfo loadIPBlock ( HttpServletRequest request ) { return ipBlockDao . getBlockInfo ( request . getRemoteAddr ( ) ) ; }
 public boolean isConstraintComposition ( Class < ? extends Annotation > annotationType ) { return annotationType == ConstraintComposition . class ; }
 void finalizeProbePhase ( List < LongHashPartition > spilledPartitions ) throws IOException { if ( isInMemory ( ) ) { releaseBuckets ( ) ; longTable . returnAll ( Arrays . asList ( partitionBuffers ) ) ; this . partitionBuffers = null ; } else { if ( this . probeSideRecordCounter == 0 ) { this . probeSideBuffer . close ( ) ; this . buildSideChannel . deleteChannel ( ) ; this . probeSideBuffer . getChannel ( ) . deleteChannel ( ) ; } else { probeNumBytesInLastSeg = this . probeSideBuffer . close ( ) ; spilledPartitions . add ( this ) ; } } }
 public boolean includes ( CellPath path ) { return path == null || tester == null || tester . fetches ( path ) ; }
 public boolean isFallback ( ) { return isFallback ; }
 public EReference getTPeopleAssignments_Recipients ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
 public EClass getTRendering ( ) { return tRenderingEClass ; }
 @ Override public Depset getStarlarkLinkerInputs ( ) { return Depset . of ( LinkerInput . TYPE , linkerInputs ) ; }
 @ Override @ FromAnyThread public void redo ( ) { operationControl . redo ( ) ; }
 @ Override public int getObservingOrder ( ) { return WEBSOCKET_OBSERVING_ORDER ; }
 public CellEditorListener [ ] getCellEditorListeners ( ) { return listenerList . getListeners ( CellEditorListener . class ) ; }
 @ XmlElement @ Column ( name = TAX_ID_TYPE_COLUMN_NAME ) public String getTaxIdType ( ) { return taxIdType ; }
 public void setBuyerMarketingEmail ( final String buyerMarketingEmail ) { this . buyerMarketingEmail = buyerMarketingEmail ; }
 @ Test public void whenCheckItself ( ) { Point point = new Point ( 0 , 0 ) ; double result = point . distance ( point ) ; assertThat ( result , is ( 0D ) ) ; }
 public EAttribute getTPresentationParameters_ExpressionLanguage ( ) { return ( EAttribute ) tPresentationParametersEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 @ Override public boolean isActived ( ) { return this . actived ; }
 public void close ( boolean success ) { filter . close ( success ) ; log . info ( " Closed ▁ feeder ▁ " + this ) ; }
 public EAttribute getTExtensibleMixedContentElements_Any ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 protected RenameColumnFamily ( ) { }
 for ( Class < ? > cls : evtHolderClasses ) { for ( Field field : cls . getFields ( ) ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) && field . getType ( ) . equals ( int . class ) ) { if ( field . getName ( ) . startsWith ( " EVT _ " ) ) { try { int type = field . getInt ( null ) ; String prev = GRID_EVT_NAMES . put ( type , field . getName ( ) . substring ( " EVT _ " . length ( ) ) ) ; assert prev == null : " Duplicate ▁ event ▁ [ type = " + type + " , ▁ name1 = " + prev + " , ▁ name2 = " + field . getName ( ) + ' ] ' ; } catch ( IllegalAccessException e ) { throw new IgniteException ( e ) ; } } } } }
 public EReference getTExtensibleMixedContentElements_Documentation ( ) { return ( EReference ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 @ Test public void testPRMemLRUDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , false , false , true ) ; }
 @ Test public void testPRHeapLRU ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPRHeapLRU ( vm0 ) ; createPRHeapLRU ( vm1 ) ; put ( vm0 , new TestKey ( " a " ) , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; long origSize0 = getSizeFromPRStats ( vm0 ) ; assertTrue ( " Size ▁ was ▁ " + origSize0 , 1000 > origSize0 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origSize1 = getSizeFromPRStats ( vm1 ) ; assertTrue ( " Size ▁ was ▁ " + origSize1 , 1000 > origSize1 ) ; get ( vm0 , new TestKey ( " a " ) , new TestObject ( 100 , 1000 ) ) ; assertValueType ( vm0 , new TestKey ( " a " ) , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , new TestKey ( " a " ) , ValueType . CD_SERIALIZED ) ; assertEquals ( 3 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; }
 public void setId ( long id ) { this . id = id ; }
 public EReference getTNotification_Priority ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public ApplicationException ( ) { super ( ) ; }
 @ Override public void accept ( NodeVisitor visitor ) { visitor . visit ( this ) ; }
 public void render ( Graphics2D g , VisualItem item , boolean isSelected ) { Association association = ( Association ) item . get ( " association " ) ; item . setSize ( isSelected ? 3 : 1 ) ; int color ; if ( ! Boolean . TRUE . equals ( item . get ( " full " ) ) ) { if ( ! full ) { return ; } color = associationColor ( association ) ; } else { if ( full ) { return ; } color = reversed ? associationColor ( association . reversalAssociation ) : associationColor ( association ) ; } item . setFillColor ( color ) ; item . setStrokeColor ( color ) ; BasicStroke stroke = item . getStroke ( ) ; if ( stroke != null ) { if ( reversed ) { if ( association != null ) { association = association . reversalAssociation ; } } if ( association != null && association . isRestricted ( ) && ! association . isIgnored ( ) ) { item . setStroke ( new BasicStroke ( stroke . getLineWidth ( ) , stroke . getEndCap ( ) , stroke . getLineJoin ( ) , stroke . getMiterLimit ( ) , new float [ ] { 8f , 6f } , 1.0f ) ) ; } else { item . setStroke ( new BasicStroke ( stroke . getLineWidth ( ) , stroke . getEndCap ( ) , stroke . getLineJoin ( ) , stroke . getMiterLimit ( ) ) ) ; } } if ( " XML " . equals ( association . getDataModel ( ) . getExportModus ( ) ) ) { m_arrowHead = updateArrowHead ( m_arrowWidth , m_arrowHeight , association , isSelected ) ; arrowIsPotAggregation = true ; } else { if ( arrowIsPotAggregation ) { m_arrowHead = updateArrowHead ( m_arrowWidth , m_arrowHeight ) ; } arrowIsPotAggregation = false ; } starPosition = null ; render ( g , item ) ; if ( starPosition != null && starImage != null ) { double size = STAR_SIZE ; transform . setTransform ( size , 0 , 0 , size , starPosition . getX ( ) - size * ( starWidth / 2 ) , starPosition . getY ( ) - size * ( starHeight / 2 ) ) ; g . drawImage ( starImage , transform , null ) ; starPosition = null ; } }
 public YoggException ( String messageTemplate , Object ... args ) { super ( String . format ( messageTemplate , args ) ) ; }
 @ Test public void testPollConfigInterval ( ) throws Exception { TCPController cs1 = new TCPController ( ) ; int version = 10 ; cs1 . setHandler ( new MockHandler ( version , " localhost | localhost | 2272" ) ) ; cs1 . setCodecFactory ( new TextLineCodecFactory ( ) ) ; cs1 . bind ( new InetSocketAddress ( 2271 ) ) ; TCPController cs2 = new TCPController ( ) ; cs2 . setHandler ( new MockHandler ( version + 1 , " localhost | localhost | 2271 ▁ localhost | localhost | 2272" ) ) ; cs2 . setCodecFactory ( new TextLineCodecFactory ( ) ) ; cs2 . bind ( new InetSocketAddress ( 2272 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) , 3000 ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( 1 , config . getNodeList ( ) . size ( ) ) ; assertEquals ( 2272 , config . getNodeList ( ) . get ( 0 ) . getPort ( ) ) ; Thread . sleep ( 3500 ) ; config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version + 1 ) ; assertEquals ( 2 , config . getNodeList ( ) . size ( ) ) ; assertEquals ( 2271 , config . getNodeList ( ) . get ( 0 ) . getPort ( ) ) ; assertEquals ( 2272 , config . getNodeList ( ) . get ( 1 ) . getPort ( ) ) ; } finally { cs1 . stop ( ) ; cs2 . stop ( ) ; } }
 private boolean isJodaTimeInClasspath ( ) { boolean isInClasspath ; try { ReflectionHelper . loadClass ( JODA_TIME_class_NAME , this . getClass ( ) ) ; isInClasspath = true ; } catch ( ValidationException e ) { isInClasspath = false ; } return isInClasspath ; }
 private String getPackageFromModule ( String modName ) { String pkgName = modName ; return pkgName . replaceAll ( " [ _ , - ] " , " " ) ; }
 @ Test public void aJustCreatedBeanWithOneSecondOfKeepaliveIsAliveRightNow ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , ONE_SECOND ) ; assertTrue ( bean . isAlive ( now ( ) ) ) ; }
 @ Test public void testRRListener ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; addListener ( vm0 ) ; addListener ( vm1 ) ; doListenerTestRR ( vm0 , vm1 ) ; }
 @ Override public String getLastNoHandleDataReason ( ) { return this . noHandleDataReason ; }
 public AssociationRenderer ( ) { full = true ; }
 @ Override protected String getKey ( ) { return getAuditLogTypeValue ( ) . toString ( ) ; }
 public Builder setExtraLinkTimeLibraries ( ExtraLinkTimeLibraries extraLinkTimeLibraries ) { Preconditions . checkState ( this . extraLinkTimeLibraries == null ) ; this . extraLinkTimeLibraries = extraLinkTimeLibraries ; return this ; }
 @ Override public long [ ] convert ( Environment env , TraceInfo trace , Memory arg ) throws Throwable { return arg . toValue ( ArrayMemory . class ) . toLongArray ( ) ; }
 @ Override public String toString ( ) { return kind . toString ( ) + " \n " ; }
 private File getDstDir ( String moduleName ) { File srcDir = new File ( dstDir , " modules / " + moduleName + " / src / main / java " ) ; if ( srcDir . exists ( ) && srcDir . isDirectory ( ) ) { String names [ ] = srcDir . list ( new FilenameCommonFilter ( ) ) ; if ( names . length > 0 ) { srcDir = new File ( srcDir , names [ 0 ] ) ; } } String path = " org / apache / harmony / " + getPackageFromModule ( moduleName ) + " / internal / nls " ; File dir = new File ( srcDir , path ) ; dir . mkdirs ( ) ; return dir ; }
 @ Override public void verify ( String verificationToken , DiscoveryNode localNode ) { }
 @ Override public Result preExecution ( GfshParseResult parseResult ) { Integer startPort = ( Integer ) parseResult . getParamValue ( " start - port " ) ; Integer endPort = ( Integer ) parseResult . getParamValue ( " end - port " ) ; if ( startPort == null ) { startPort = GatewayReceiver . DEFAULT_START_PORT ; } if ( endPort == null ) { endPort = GatewayReceiver . DEFAULT_END_PORT ; } if ( startPort > endPort ) { return ResultBuilder . createUserErrorResult ( " start - port ▁ must ▁ be ▁ smaller ▁ than ▁ end - port . " ) ; } return ResultBuilder . createInfoResult ( " " ) ; }
 public void makePrivate ( ) { }
 public synchronized String getElementText ( ) throws XMLStreamException { if ( closed ) { throw new XMLStreamException ( " Stream ▁ has ▁ been ▁ closed " ) ; } StringBuffer buffer = new StringBuffer ( ) ; while ( true ) { XMLEvent event = nextEvent ( ) ; if ( event . isCharacters ( ) ) { if ( event . getEventType ( ) != XMLEvent . SPACE ) { buffer . append ( event . asCharacters ( ) . getData ( ) ) ; } } else if ( event . isEndElement ( ) ) { break ; } else { throw new XMLStreamException ( " Non - text ▁ event ▁ encountered ▁ in ▁ getElementText ( ) : ▁ " + event ) ; } } return buffer . toString ( ) ; }
 public void DFS ( ) { System . out . println ( " DFS ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } }
 public MockHandler ( int version , String response ) { super ( ) ; this . response = response ; this . version = version ; }
 public synchronized SortedSet < SSTableReader > getLevelSorted ( int level , Comparator < SSTableReader > comparator ) { return ImmutableSortedSet . copyOf ( comparator , generations [ level ] ) ; }
 final void insertIntoProbeBuffer ( BinaryRowDataSerializer probeSer , BinaryRowData record ) throws IOException { probeSer . serialize ( record , this . probeSideBuffer ) ; this . probeSideRecordCounter ++ ; }
 @ Override public boolean advanceNext ( ) { if ( address != INVALID_ADDRESS ) { setReadPosition ( address ) ; long addrAndLen = getCurrentSegment ( ) . getLong ( getCurrentPositionInSegment ( ) ) ; this . address = toAddress ( addrAndLen ) ; int size = toLength ( addrAndLen ) ; try { skipBytesToRead ( 8 ) ; buildSideSerializer . pointTo ( size , buildReuseRow , LongHashPartition . this ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return true ; } return false ; }
 public String getStorageDomainName ( ) { if ( getStorageDomain ( ) != null ) { return getStorageDomain ( ) . getstorage_name ( ) ; } return " " ; }
 public EClass getTExtensibleElements ( ) { return tExtensibleElementsEClass ; }
 public DMStats getDMStats ( ) { return stats ; }
 public EReference getTPeopleAssignments_ExcludedOwners ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 @ Override public InterpreterResult interpret ( String text , InterpreterContext interpreterContext ) { return new InterpreterResult ( Code . SUCCESS , " % mathjax ▁ " + text ) ; }
 public String toString ( ) { return " [ ( DefaultNumberExpr ) : ▁ " + getNumber ( ) + " ] " ; }
 @ RequestMapping ( value = " / commit . jsp " , method = RequestMethod . GET ) public ModelAndView showCommitForm ( HttpServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ ModelAttribute ( " form " ) EditTopicRequest form ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Topic message = messageDao . getById ( msgid ) ; if ( message . isCommited ( ) ) { throw new UserErrorException ( " Сообщение ▁ уже ▁ подтверждено " ) ; } PreparedTopic preparedMessage = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; if ( ! preparedMessage . getSection ( ) . isPremoderated ( ) ) { throw new UserErrorException ( " Раздел ▁ не ▁ премодерируемый " ) ; } ModelAndView mv = prepareModel ( preparedMessage , form , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) ) ; mv . getModel ( ) . put ( " commit " , true ) ; return mv ; }
 private void logDistribution ( ) { if ( logger . isDebugEnabled ( ) ) { for ( int i = 0 ; i < generations . length ; i ++ ) { if ( ! generations [ i ] . isEmpty ( ) ) { logger . debug ( " L { } ▁ contains ▁ { } ▁ SSTables ▁ ( { } ▁ bytes ) ▁ in ▁ { } " , i , generations [ i ] . size ( ) , SSTableReader . getTotalBytes ( generations [ i ] ) , this ) ; } } } }
 temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; ads . add ( eElement . getTextContent ( ) ) ; } }
 public EReference getTEscalation_Condition ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EClass getTExtensions ( ) { return tExtensionsEClass ; }
 public EEnum getTBoolean ( ) { return tBooleanEEnum ; }
 @ Test public void testExecutionGraphGeneration ( ) throws Exception { final StreamExecutionEnvironment env = StreamExecutionEnvironment . getExecutionEnvironment ( ) ; env . setParallelism ( 4 ) ; DataStream < String > text = env . addSource ( new ParallelSourceFunction < String > ( ) { private static final long serialVersionUID = 7772338606389180774L ; @ Override public void run ( SourceContext < String > ctx ) throws Exception { } @ Override public void cancel ( ) { } } ) . setParallelism ( 2 ) ; DataStream < Tuple2 < String , Integer > > counts = text . rescale ( ) . flatMap ( new FlatMapFunction < String , Tuple2 < String , Integer > > ( ) { private static final long serialVersionUID = - 5255930322161596829L ; @ Override public void flatMap ( String value , Collector < Tuple2 < String , Integer > > out ) throws Exception { } } ) ; counts . rescale ( ) . print ( ) . setParallelism ( 2 ) ; JobGraph jobGraph = env . getStreamGraph ( ) . getJobGraph ( ) ; final JobID jobId = new JobID ( ) ; final String jobName = " Semi - Rebalance ▁ Test ▁ Job " ; final Configuration cfg = new Configuration ( ) ; List < JobVertex > jobVertices = jobGraph . getVerticesSortedTopologicallyFromSources ( ) ; JobVertex sourceVertex = jobVertices . get ( 0 ) ; JobVertex mapVertex = jobVertices . get ( 1 ) ; JobVertex sinkVertex = jobVertices . get ( 2 ) ; assertEquals ( 2 , sourceVertex . getParallelism ( ) ) ; assertEquals ( 4 , mapVertex . getParallelism ( ) ) ; assertEquals ( 2 , sinkVertex . getParallelism ( ) ) ; ExecutionGraph eg = new ExecutionGraph ( TestingUtils . defaultExecutor ( ) , TestingUtils . defaultExecutor ( ) , jobId , jobName , cfg , new SerializedValue < > ( new ExecutionConfig ( ) ) , AkkaUtils . getDefaultTimeout ( ) , new NoRestartStrategy ( ) , new ArrayList < BlobKey > ( ) , new ArrayList < URL > ( ) , new Scheduler ( TestingUtils . defaultExecutionContext ( ) ) , ExecutionGraph . class . getClassLoader ( ) ) ; try { eg . attachJobGraph ( jobVertices ) ; } catch ( JobException e ) { e . printStackTrace ( ) ; fail ( " Building ▁ ExecutionGraph ▁ failed : ▁ " + e . getMessage ( ) ) ; } ExecutionJobVertex execSourceVertex = eg . getJobVertex ( sourceVertex . getID ( ) ) ; ExecutionJobVertex execMapVertex = eg . getJobVertex ( mapVertex . getID ( ) ) ; ExecutionJobVertex execSinkVertex = eg . getJobVertex ( sinkVertex . getID ( ) ) ; assertEquals ( 0 , execSourceVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 1 , execMapVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 4 , execMapVertex . getParallelism ( ) ) ; ExecutionVertex [ ] mapTaskVertices = execMapVertex . getTaskVertices ( ) ; Map < Integer , Integer > mapInputPartitionCounts = new HashMap < > ( ) ; for ( ExecutionVertex mapTaskVertex : mapTaskVertices ) { assertEquals ( 1 , mapTaskVertex . getNumberOfInputs ( ) ) ; assertEquals ( 1 , mapTaskVertex . getInputEdges ( 0 ) . length ) ; ExecutionEdge inputEdge = mapTaskVertex . getInputEdges ( 0 ) [ 0 ] ; assertEquals ( sourceVertex . getID ( ) , inputEdge . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; int inputPartition = inputEdge . getSource ( ) . getPartitionNumber ( ) ; if ( ! mapInputPartitionCounts . containsKey ( inputPartition ) ) { mapInputPartitionCounts . put ( inputPartition , 1 ) ; } else { mapInputPartitionCounts . put ( inputPartition , mapInputPartitionCounts . get ( inputPartition ) + 1 ) ; } } assertEquals ( 2 , mapInputPartitionCounts . size ( ) ) ; for ( int count : mapInputPartitionCounts . values ( ) ) { assertEquals ( 2 , count ) ; } assertEquals ( 1 , execSinkVertex . getInputs ( ) . size ( ) ) ; assertEquals ( 2 , execSinkVertex . getParallelism ( ) ) ; ExecutionVertex [ ] sinkTaskVertices = execSinkVertex . getTaskVertices ( ) ; Set < Integer > mapSubpartitions = new HashSet < > ( ) ; for ( ExecutionVertex sinkTaskVertex : sinkTaskVertices ) { assertEquals ( 1 , sinkTaskVertex . getNumberOfInputs ( ) ) ; assertEquals ( 2 , sinkTaskVertex . getInputEdges ( 0 ) . length ) ; ExecutionEdge inputEdge1 = sinkTaskVertex . getInputEdges ( 0 ) [ 0 ] ; ExecutionEdge inputEdge2 = sinkTaskVertex . getInputEdges ( 0 ) [ 1 ] ; assertEquals ( mapVertex . getID ( ) , inputEdge1 . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; assertEquals ( mapVertex . getID ( ) , inputEdge2 . getSource ( ) . getProducer ( ) . getJobvertexId ( ) ) ; int inputPartition1 = inputEdge1 . getSource ( ) . getPartitionNumber ( ) ; assertFalse ( mapSubpartitions . contains ( inputPartition1 ) ) ; mapSubpartitions . add ( inputPartition1 ) ; int inputPartition2 = inputEdge2 . getSource ( ) . getPartitionNumber ( ) ; assertFalse ( mapSubpartitions . contains ( inputPartition2 ) ) ; mapSubpartitions . add ( inputPartition2 ) ; } assertEquals ( 4 , mapSubpartitions . size ( ) ) ; }
 public EClass getTUserlist ( ) { return tUserlistEClass ; }
 catch ( Exception e ) { e . printStackTrace ( ) ; }
 public int size ( ) { return encodedNames . size ( ) ; }
 public void updateLocalDeletionTime ( int deletionTime ) { isDelTimeSet = true ; minDeletionTime = Math . min ( minDeletionTime , deletionTime ) ; }
 protected VmDAO getVmDAO ( ) { return getDbFacade ( ) . getVmDAO ( ) ; }
 @ Override protected void getIntentData ( Bundle savedInstanceState ) { Intent intent = getIntent ( ) ; taskId = intent . getStringExtra ( " taskId " ) ; areaData = intent . getParcelableExtra ( " checkAreaData " ) ; }
 public DiseaseOutcomeWithProbabilitySetter ( ) { }
 public String getSemiMajorAxis ( ) { return semiMajorAxis ; }
 public void setStoragePool ( final storage_pool value ) { _storagePool = value ; }
 private void setPayload ( WebSocketMessage message , Object payload ) { try { if ( payload instanceof String ) { message . setReadablePayload ( ( String ) payload ) ; } else if ( payload instanceof byte [ ] ) { message . setPayload ( ( byte [ ] ) payload ) ; } } catch ( WebSocketException e ) { logger . error ( e ) ; } }
 GenericType < List < Entry > > entryListType = new GenericType < List < Entry > > ( ) { }
 @ JsonProperty ( " IsFlag " ) public Boolean getIsFlag ( ) { return isFlag ; }
 public ResultMessage execute ( QueryState state , QueryOptions options ) throws RequestValidationException { announceMigration ( ) ; String tableName = cfName == null || columnFamily ( ) == null ? " " : columnFamily ( ) ; return new ResultMessage . SchemaChange ( changeType ( ) , keyspace ( ) , tableName ) ; }
 @ Override public List < SetterReturnObject > set ( DiseaseOutcomeWithProbability t ) throws ApolloSetterException { List < SetterReturnObject > list = new ArrayList < SetterReturnObject > ( ) ; list . addAll ( setDiseaseOutcome ( t . getDiseaseOutcome ( ) ) ) ; list . addAll ( setProbability ( t . getProbability ( ) ) ) ; return list ; }
 private LinkOptions ( ImmutableList < String > linkOptions , Object symbolForEquality ) { this . linkOptions = Preconditions . checkNotNull ( linkOptions ) ; this . symbolForEquality = Preconditions . checkNotNull ( symbolForEquality ) ; }
 @ Override protected int promotedSize ( IndexHelper . IndexInfo . Serializer idxSerializer ) { long size = TypeSizes . sizeofUnsignedVInt ( headerLength ) + DeletionTime . serializer . serializedSize ( deletionTime ) + TypeSizes . sizeofUnsignedVInt ( columnsIndex . size ( ) ) ; for ( IndexHelper . IndexInfo info : columnsIndex ) size += idxSerializer . serializedSize ( info ) ; size += columnsIndex . size ( ) * TypeSizes . sizeof ( 0 ) ; return Ints . checkedCast ( size ) ; }
 int getNumOccupiedMemorySegments ( ) { return this . targetList . size ( ) + 1 ; }
 public String getPersonaje ( ) { return " Liberal " ; }
 @ Override public final int hashCode ( ) { return Objects . hashCode ( name ) ; }
 public EClass getTHumanInteractions ( ) { return tHumanInteractionsEClass ; }
 @ Override public Prepared prepare ( ) { return new Prepared ( this ) ; }
 public List < ByteBuffer > serializedValues ( Iterator < Cell > cells ) { assert isMultiCell ; List < ByteBuffer > bbs = new ArrayList < ByteBuffer > ( ) ; while ( cells . hasNext ( ) ) bbs . add ( cells . next ( ) . value ( ) ) ; return bbs ; }
 @ XmlElement ( required = true ) @ Column ( name = FIRST_NAME_COLUMN_NAME , nullable = false ) public String getFirstName ( ) { return firstName ; }
 public EAttribute getTExtensibleMixedContentElements_Mixed ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EAttribute getTParameter_Name ( ) { return ( EAttribute ) tParameterEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 if ( bytesWritten == 0 ) { bytesWritten = result ; }
 BoundedReadEvaluatorFactory ( EvaluationContext evaluationContext ) { this ( evaluationContext , REQUIRED_DYNAMIC_SPLIT_ORIGINAL_SIZE ) ; }
 public void update ( LivenessInfo info ) { if ( info . isEmpty ( ) ) return ; updateTimestamp ( info . timestamp ( ) ) ; if ( info . isExpiring ( ) ) { updateTTL ( info . ttl ( ) ) ; updateLocalDeletionTime ( info . localExpirationTime ( ) ) ; } }
 public int getValue ( ) { return this . ordinal ( ) ; }
 @ Override public Depset getDeclaredIncludeSrcsForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return Depset . of ( Artifact . TYPE , getDeclaredIncludeSrcs ( ) ) ; }
 @ XmlElement ( required = true ) @ Column ( name = BUYER_EMAIL_COLUMN_NAME , nullable = false ) public String getBuyerEmail ( ) { return buyerEmail ; }
 ) public MUXFilterFeeder ( Configuration conf , PayloadQueue out ) { log . trace ( " Constructing ▁ MUXFilterFeeder " ) ; if ( out == null ) { throw new IllegalArgumentException ( " out ▁ queue ▁ must ▁ not ▁ be ▁ null " ) ; } this . out = out ; pusher = new PushFilter ( conf . getInt ( CONF_QUEUE_MAXPAYLOADS , DEFAULT_QUEUE_MAXPAYLOADS ) , conf . getInt ( CONF_QUEUE_MAXBYTES , DEFAULT_QUEUE_MAXBYTES ) ) ; if ( conf . valueExists ( CONF_QUEUE_OUT_LENGTH ) ) { log . warn ( String . format ( " The ▁ configuration ▁ contained ▁ the ▁ deprecated ▁ key ▁ % s . ▁ " + " Use ▁ % s ▁ instead " , CONF_QUEUE_OUT_LENGTH , MUXFilter . CONF_OUTQUEUE_MAXPAYLOADS ) ) ; } if ( conf . valueExists ( CONF_QUEUE_OUT_MAXBYTES ) ) { log . warn ( String . format ( " The ▁ configuration ▁ contained ▁ the ▁ deprecated ▁ key ▁ % s . ▁ Use ▁ % s ▁ instead " , CONF_QUEUE_OUT_MAXBYTES , MUXFilter . CONF_OUTQUEUE_MAXBYTES ) ) ; } filter = createFilter ( conf ) ; filter . setSource ( pusher ) ; filterName = conf . getString ( CONF_FILTER_NAME , " Feeder ( " + filter . getClass ( ) . getSimpleName ( ) + " ) " ) ; isFallback = conf . getBoolean ( CONF_FILTER_ISFALLBACK , isFallback ) ; List < String > baseList = conf . getStrings ( CONF_FILTER_BASES , ( List < String > ) null ) ; if ( baseList != null && ! ( baseList . size ( ) == 1 && " * " . equals ( baseList . get ( 0 ) ) ) ) { bases = new HashSet < > ( baseList ) ; } Thread t = new Thread ( this , filterName + " - " + this . hashCode ( ) + " ▁ daemon " ) ; t . setDaemon ( true ) ; t . start ( ) ; log . info ( " Constructed ▁ and ▁ activated ▁ " + this ) ; }
 public void setStorageDomain ( final storage_domains value ) { _storageDomain = value ; }
 GenericType < List < Query > > queryListType = new GenericType < List < Query > > ( ) { }
 public void createPackageContents ( ) { if ( isCreated ) return ; isCreated = true ; documentRootEClass = createEClass ( DOCUMENT_ROOT ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__MIXED ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__XMLNS_PREFIX_MAP ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__XSI_SCHEMA_LOCATION ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__BUSINESS_ADMINISTRATORS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__EXCLUDED_OWNERS ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__GROUP ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__GROUPS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__HUMAN_INTERACTIONS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__IMPORT ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__LOGICAL_PEOPLE_GROUPS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__NOTIFICATION ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__NOTIFICATIONS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__ORGANIZATIONAL_ENTITY ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__PEOPLE_ASSIGNMENTS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__POTENTIAL_OWNERS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__PRIORITY ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__RECIPIENTS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK_INITIATOR ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASKS ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__TASK_STAKEHOLDERS ) ; createEAttribute ( documentRootEClass , DOCUMENT_ROOT__USER ) ; createEReference ( documentRootEClass , DOCUMENT_ROOT__USERS ) ; tArgumentEClass = createEClass ( TARGUMENT ) ; createEAttribute ( tArgumentEClass , TARGUMENT__EXPRESSION_LANGUAGE ) ; createEAttribute ( tArgumentEClass , TARGUMENT__NAME ) ; tBooleanExprEClass = createEClass ( TBOOLEAN_EXPR ) ; tDeadlineEClass = createEClass ( TDEADLINE ) ; createEReference ( tDeadlineEClass , TDEADLINE__FOR ) ; createEReference ( tDeadlineEClass , TDEADLINE__UNTIL ) ; createEReference ( tDeadlineEClass , TDEADLINE__ESCALATION ) ; tDeadlineExprEClass = createEClass ( TDEADLINE_EXPR ) ; tDeadlinesEClass = createEClass ( TDEADLINES ) ; createEReference ( tDeadlinesEClass , TDEADLINES__START_DEADLINE ) ; createEReference ( tDeadlinesEClass , TDEADLINES__COMPLETION_DEADLINE ) ; tDelegationEClass = createEClass ( TDELEGATION ) ; createEReference ( tDelegationEClass , TDELEGATION__FROM ) ; createEAttribute ( tDelegationEClass , TDELEGATION__POTENTIAL_DELEGATEES ) ; tDescriptionEClass = createEClass ( TDESCRIPTION ) ; createEAttribute ( tDescriptionEClass , TDESCRIPTION__CONTENT_TYPE ) ; createEAttribute ( tDescriptionEClass , TDESCRIPTION__LANG ) ; tDocumentationEClass = createEClass ( TDOCUMENTATION ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__MIXED ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__ANY ) ; createEAttribute ( tDocumentationEClass , TDOCUMENTATION__LANG ) ; tDurationExprEClass = createEClass ( TDURATION_EXPR ) ; tEscalationEClass = createEClass ( TESCALATION ) ; createEReference ( tEscalationEClass , TESCALATION__CONDITION ) ; createEReference ( tEscalationEClass , TESCALATION__TO_PARTS ) ; createEReference ( tEscalationEClass , TESCALATION__NOTIFICATION ) ; createEReference ( tEscalationEClass , TESCALATION__LOCAL_NOTIFICATION ) ; createEReference ( tEscalationEClass , TESCALATION__REASSIGNMENT ) ; createEAttribute ( tEscalationEClass , TESCALATION__NAME ) ; tExpressionEClass = createEClass ( TEXPRESSION ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__MIXED ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__ANY ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__EXPRESSION_LANGUAGE ) ; createEAttribute ( tExpressionEClass , TEXPRESSION__ANY_ATTRIBUTE ) ; tExtensibleElementsEClass = createEClass ( TEXTENSIBLE_ELEMENTS ) ; createEReference ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__DOCUMENTATION ) ; createEAttribute ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__ANY ) ; createEAttribute ( tExtensibleElementsEClass , TEXTENSIBLE_ELEMENTS__ANY_ATTRIBUTE ) ; tExtensibleMixedContentElementsEClass = createEClass ( TEXTENSIBLE_MIXED_CONTENT_ELEMENTS ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__MIXED ) ; createEReference ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__DOCUMENTATION ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__ANY ) ; createEAttribute ( tExtensibleMixedContentElementsEClass , TEXTENSIBLE_MIXED_CONTENT_ELEMENTS__ANY_ATTRIBUTE ) ; tExtensionEClass = createEClass ( TEXTENSION ) ; createEAttribute ( tExtensionEClass , TEXTENSION__MUST_UNDERSTAND ) ; createEAttribute ( tExtensionEClass , TEXTENSION__NAMESPACE ) ; tExtensionsEClass = createEClass ( TEXTENSIONS ) ; createEReference ( tExtensionsEClass , TEXTENSIONS__EXTENSION ) ; tFromEClass = createEClass ( TFROM ) ; createEReference ( tFromEClass , TFROM__ARGUMENT ) ; createEReference ( tFromEClass , TFROM__LITERAL ) ; createEAttribute ( tFromEClass , TFROM__EXPRESSION_LANGUAGE ) ; createEAttribute ( tFromEClass , TFROM__LOGICAL_PEOPLE_GROUP ) ; tGenericHumanRoleEClass = createEClass ( TGENERIC_HUMAN_ROLE ) ; createEReference ( tGenericHumanRoleEClass , TGENERIC_HUMAN_ROLE__FROM ) ; tGrouplistEClass = createEClass ( TGROUPLIST ) ; createEAttribute ( tGrouplistEClass , TGROUPLIST__GROUP ) ; tHumanInteractionsEClass = createEClass ( THUMAN_INTERACTIONS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__EXTENSIONS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__IMPORT ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__LOGICAL_PEOPLE_GROUPS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__TASKS ) ; createEReference ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__NOTIFICATIONS ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__EXPRESSION_LANGUAGE ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__QUERY_LANGUAGE ) ; createEAttribute ( tHumanInteractionsEClass , THUMAN_INTERACTIONS__TARGET_NAMESPACE ) ; tImportEClass = createEClass ( TIMPORT ) ; createEAttribute ( tImportEClass , TIMPORT__IMPORT_TYPE ) ; createEAttribute ( tImportEClass , TIMPORT__LOCATION ) ; createEAttribute ( tImportEClass , TIMPORT__NAMESPACE ) ; tLiteralEClass = createEClass ( TLITERAL ) ; createEAttribute ( tLiteralEClass , TLITERAL__MIXED ) ; createEAttribute ( tLiteralEClass , TLITERAL__ANY ) ; createEAttribute ( tLiteralEClass , TLITERAL__ANY_ATTRIBUTE ) ; tLocalNotificationEClass = createEClass ( TLOCAL_NOTIFICATION ) ; createEReference ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__PRIORITY ) ; createEReference ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__PEOPLE_ASSIGNMENTS ) ; createEAttribute ( tLocalNotificationEClass , TLOCAL_NOTIFICATION__REFERENCE ) ; tLogicalPeopleGroupEClass = createEClass ( TLOGICAL_PEOPLE_GROUP ) ; createEReference ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__PARAMETER ) ; createEAttribute ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__NAME ) ; createEAttribute ( tLogicalPeopleGroupEClass , TLOGICAL_PEOPLE_GROUP__REFERENCE ) ; tLogicalPeopleGroupsEClass = createEClass ( TLOGICAL_PEOPLE_GROUPS ) ; createEReference ( tLogicalPeopleGroupsEClass , TLOGICAL_PEOPLE_GROUPS__LOGICAL_PEOPLE_GROUP ) ; tNotificationEClass = createEClass ( TNOTIFICATION ) ; createEReference ( tNotificationEClass , TNOTIFICATION__INTERFACE ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PRIORITY ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PEOPLE_ASSIGNMENTS ) ; createEReference ( tNotificationEClass , TNOTIFICATION__PRESENTATION_ELEMENTS ) ; createEReference ( tNotificationEClass , TNOTIFICATION__RENDERINGS ) ; createEAttribute ( tNotificationEClass , TNOTIFICATION__NAME ) ; tNotificationInterfaceEClass = createEClass ( TNOTIFICATION_INTERFACE ) ; createEAttribute ( tNotificationInterfaceEClass , TNOTIFICATION_INTERFACE__OPERATION ) ; createEAttribute ( tNotificationInterfaceEClass , TNOTIFICATION_INTERFACE__PORT_TYPE ) ; tNotificationsEClass = createEClass ( TNOTIFICATIONS ) ; createEReference ( tNotificationsEClass , TNOTIFICATIONS__NOTIFICATION ) ; tOrganizationalEntityEClass = createEClass ( TORGANIZATIONAL_ENTITY ) ; createEReference ( tOrganizationalEntityEClass , TORGANIZATIONAL_ENTITY__USERS ) ; createEReference ( tOrganizationalEntityEClass , TORGANIZATIONAL_ENTITY__GROUPS ) ; tParameterEClass = createEClass ( TPARAMETER ) ; createEAttribute ( tParameterEClass , TPARAMETER__NAME ) ; createEAttribute ( tParameterEClass , TPARAMETER__TYPE ) ; tPeopleAssignmentsEClass = createEClass ( TPEOPLE_ASSIGNMENTS ) ; createEAttribute ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__GENERIC_HUMAN_ROLE ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__POTENTIAL_OWNERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__EXCLUDED_OWNERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__TASK_INITIATOR ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__TASK_STAKEHOLDERS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__BUSINESS_ADMINISTRATORS ) ; createEReference ( tPeopleAssignmentsEClass , TPEOPLE_ASSIGNMENTS__RECIPIENTS ) ; tPresentationElementsEClass = createEClass ( TPRESENTATION_ELEMENTS ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__NAME ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__PRESENTATION_PARAMETERS ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__SUBJECT ) ; createEReference ( tPresentationElementsEClass , TPRESENTATION_ELEMENTS__DESCRIPTION ) ; tPresentationParameterEClass = createEClass ( TPRESENTATION_PARAMETER ) ; tPresentationParametersEClass = createEClass ( TPRESENTATION_PARAMETERS ) ; createEReference ( tPresentationParametersEClass , TPRESENTATION_PARAMETERS__PRESENTATION_PARAMETER ) ; createEAttribute ( tPresentationParametersEClass , TPRESENTATION_PARAMETERS__EXPRESSION_LANGUAGE ) ; tPriorityEClass = createEClass ( TPRIORITY ) ; tQueryEClass = createEClass ( TQUERY ) ; createEAttribute ( tQueryEClass , TQUERY__MIXED ) ; createEAttribute ( tQueryEClass , TQUERY__ANY ) ; createEAttribute ( tQueryEClass , TQUERY__PART ) ; createEAttribute ( tQueryEClass , TQUERY__QUERY_LANGUAGE ) ; createEAttribute ( tQueryEClass , TQUERY__ANY_ATTRIBUTE ) ; tReassignmentEClass = createEClass ( TREASSIGNMENT ) ; createEReference ( tReassignmentEClass , TREASSIGNMENT__POTENTIAL_OWNERS ) ; tRenderingEClass = createEClass ( TRENDERING ) ; createEAttribute ( tRenderingEClass , TRENDERING__TYPE ) ; tRenderingsEClass = createEClass ( TRENDERINGS ) ; createEReference ( tRenderingsEClass , TRENDERINGS__RENDERING ) ; tTaskEClass = createEClass ( TTASK ) ; createEReference ( tTaskEClass , TTASK__INTERFACE ) ; createEReference ( tTaskEClass , TTASK__PRIORITY ) ; createEReference ( tTaskEClass , TTASK__PEOPLE_ASSIGNMENTS ) ; createEReference ( tTaskEClass , TTASK__DELEGATION ) ; createEReference ( tTaskEClass , TTASK__PRESENTATION_ELEMENTS ) ; createEReference ( tTaskEClass , TTASK__OUTCOME ) ; createEReference ( tTaskEClass , TTASK__SEARCH_BY ) ; createEReference ( tTaskEClass , TTASK__RENDERINGS ) ; createEReference ( tTaskEClass , TTASK__DEADLINES ) ; createEAttribute ( tTaskEClass , TTASK__NAME ) ; tTaskInterfaceEClass = createEClass ( TTASK_INTERFACE ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__OPERATION ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__PORT_TYPE ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__RESPONSE_OPERATION ) ; createEAttribute ( tTaskInterfaceEClass , TTASK_INTERFACE__RESPONSE_PORT_TYPE ) ; tTasksEClass = createEClass ( TTASKS ) ; createEReference ( tTasksEClass , TTASKS__TASK ) ; tTextEClass = createEClass ( TTEXT ) ; createEAttribute ( tTextEClass , TTEXT__LANG ) ; tToPartEClass = createEClass ( TTO_PART ) ; createEAttribute ( tToPartEClass , TTO_PART__EXPRESSION_LANGUAGE ) ; createEAttribute ( tToPartEClass , TTO_PART__NAME ) ; tToPartsEClass = createEClass ( TTO_PARTS ) ; createEReference ( tToPartsEClass , TTO_PARTS__TO_PART ) ; tUserlistEClass = createEClass ( TUSERLIST ) ; createEAttribute ( tUserlistEClass , TUSERLIST__USER ) ; tBooleanEEnum = createEEnum ( TBOOLEAN ) ; tPotentialDelegateesEEnum = createEEnum ( TPOTENTIAL_DELEGATEES ) ; tBooleanObjectEDataType = createEDataType ( TBOOLEAN_OBJECT ) ; tGroupEDataType = createEDataType ( TGROUP ) ; tPotentialDelegateesObjectEDataType = createEDataType ( TPOTENTIAL_DELEGATEES_OBJECT ) ; tUserEDataType = createEDataType ( TUSER ) ; }
 public DataChangedNotifier ( Collection < ? extends SqlTable < ? > > tables ) { this . tables . addAll ( tables ) ; }
 public EAttribute getTFrom_ExpressionLanguage ( ) { return ( EAttribute ) tFromEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 public int getLast ( ) { return getFirst ( ) + getCount ( ) - 1 ; }
 public AuditLogType getAuditLogTypeValue ( ) { return AuditLogType . UNASSIGNED ; }
 public State execute ( State [ ] inputs , Circuit or ) throws Exception { if ( inputs . length == 1 ) { return or . startExecuting ( inputs [ 0 ] ) ; } else { return binaryOperation ( or , inputs ) ; } }
 protected boolean isFinished ( ) { return Robot . cannonSubsystem . getAligned ( ) ; }
 @ Override public long getLastNoHandleDataTime ( ) { return this . noHandleDataTime ; }
 public EReference getDocumentRoot_XMLNSPrefixMap ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 private void assertPayloadParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " payload " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ payload ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } Class < ? > [ ] defaultPayload = ( Class < ? > [ ] ) method . getDefaultValue ( ) ; if ( defaultPayload . length != 0 ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ payload ▁ " + " parameter ▁ default ▁ value ▁ is ▁ not ▁ the ▁ empty ▁ array . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " payload ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
 @ Override public boolean isMultiCell ( ) { return isMultiCell ; }
 @ Override public void onMessageReceived ( Session session , Object message ) { if ( message . equals ( " quit " ) ) { session . close ( ) ; return ; } session . write ( " CONFIG ▁ cluster ▁ 0 ▁ " + this . response . length ( ) ) ; session . write ( String . valueOf ( version ) + " \n " + this . response ) ; session . write ( " END " ) ; this . version ++ ; }
 if ( len > 0 ) { arr = new Object [ len ] ; for ( int i = 0 ; i < len ; i ++ ) arr [ i ] = in . readObject ( ) ; }
 public Optional < Group > getGroupOpt ( Section section , String name , Boolean allowNumber ) { try { if ( allowNumber && StringUtils . isNumeric ( name ) ) { int id = jdbcTemplate . queryForObject ( " SELECT ▁ id ▁ FROM ▁ groups ▁ WHERE ▁ section = ? ▁ AND ▁ id = ? " , Integer . class , section . getId ( ) , Integer . parseInt ( name ) ) ; return Optional . of ( getGroup ( id ) ) ; } else if ( StringUtils . isAsciiPrintable ( name ) ) { int id = jdbcTemplate . queryForObject ( " SELECT ▁ id ▁ FROM ▁ groups ▁ WHERE ▁ section = ? ▁ AND ▁ urlname = ? " , Integer . class , section . getId ( ) , name ) ; return Optional . of ( getGroup ( id ) ) ; } else { return Optional . empty ( ) ; } } catch ( EmptyResultDataAccessException ex ) { logger . debug ( " Group ▁ ' { } ' ▁ not ▁ found ▁ in ▁ section ▁ { } " , name , section . getUrlName ( ) ) ; return Optional . empty ( ) ; } }
 public SetConfigurationNHandler ( IOSServerManager driver , WebDriverLikeRequest request ) { super ( driver , request ) ; }
 @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value == null ) ? 0 : value . hashCode ( ) ) ; return result ; }
 public EReference getTExtensions_Extension ( ) { return ( EReference ) tExtensionsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public VdsGroupDAO getVdsGroupDAO ( ) { return getDbFacade ( ) . getVdsGroupDAO ( ) ; }
 @ Override public String getHost ( ) { return host ; }
 @ Override public int hashCode ( ) { return artifact . hashCode ( ) ; }
 @ Override public JobSchedulerMode getJobSchedulerMode ( ) { return this . jsm ; }
 @ FromAnyThread protected void setIgnoreListeners ( final boolean ignoreListeners ) { this . ignoreListeners = ignoreListeners ; }
 if ( retryInfo != null ) { List retryMembers = retryInfo . getMembers ( ) ; InternalDistributedMember [ ] retryDest = new InternalDistributedMember [ retryMembers . size ( ) ] ; retryDest = ( InternalDistributedMember [ ] ) retryMembers . toArray ( retryDest ) ; destinations = retryDest ; retryInfo = null ; retry = true ; }
 public DirectChannel ( Membership < InternalDistributedMember > mgr , MessageListener < InternalDistributedMember > listener , ClusterDistributionManager dm ) throws ConnectionException { this . receiver = listener ; this . dm = dm ; this . stats = dm . getStats ( ) ; this . bufferPool = new BufferPool ( stats ) ; DistributionConfig dc = dm . getConfig ( ) ; this . address = initAddress ( dc ) ; boolean isBindAddress = dc . getBindAddress ( ) != null ; try { int port = Integer . getInteger ( " tcpServerPort " , 0 ) . intValue ( ) ; if ( port == 0 ) { port = dc . getTcpPort ( ) ; } Properties props = System . getProperties ( ) ; if ( props . getProperty ( " p2p . shareSockets " ) == null ) { props . setProperty ( " p2p . shareSockets " , String . valueOf ( dc . getConserveSockets ( ) ) ) ; } if ( dc . getSocketBufferSize ( ) != DistributionConfig . DEFAULT_SOCKET_BUFFER_SIZE ) { props . setProperty ( " p2p . tcpBufferSize " , String . valueOf ( dc . getSocketBufferSize ( ) ) ) ; } if ( props . getProperty ( " p2p . idleConnectionTimeout " ) == null ) { props . setProperty ( " p2p . idleConnectionTimeout " , String . valueOf ( dc . getSocketLeaseTime ( ) ) ) ; } int [ ] range = dc . getMembershipPortRange ( ) ; props . setProperty ( " membership _ port _ range _ start " , " " + range [ 0 ] ) ; props . setProperty ( " membership _ port _ range _ end " , " " + range [ 1 ] ) ; this . conduit = new TCPConduit ( mgr , port , address , isBindAddress , this , bufferPool , props ) ; disconnected = false ; disconnectCompleted = false ; logger . info ( " GemFire ▁ P2P ▁ Listener ▁ started ▁ on ▁ { } " , conduit . getSocketId ( ) ) ; } catch ( ConnectionException ce ) { logger . fatal ( String . format ( " Unable ▁ to ▁ initialize ▁ direct ▁ channel ▁ because : ▁ % s " , new Object [ ] { ce . getMessage ( ) } ) , ce ) ; throw ce ; } }
 @ XmlElement @ Column ( name = PAYER_BUSINESS_COLUMN_NAME ) public String getPayerBusiness ( ) { return payerBusiness ; }
 public EClass getTPriority ( ) { return tPriorityEClass ; }
 public EReference getTPresentationElements_Description ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 public void takeSnapshot ( ) { }
 @ Override public boolean add ( Img element ) { if ( element != null ) { array . push ( element ) ; return true ; } return false ; }
 public void setMiddleName ( final String middleName ) { this . middleName = middleName ; }
 @ JsonProperty ( " CriteriaLevelCode " ) public String getCriteriaLevelCode ( ) { return criteriaLevelCode ; }
 @ XmlElement @ Column ( name = TAX_ID_COLUMN_NAME ) public String getTaxId ( ) { return taxId ; }
 public EReference getTOrganizationalEntity_Groups ( ) { return ( EReference ) tOrganizationalEntityEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public YoggException ( Throwable cause , String messageTemplate , Object ... args ) { super ( String . format ( messageTemplate , args ) , cause ) ; }
 @ Override public boolean isCascaded ( ) { return cascaded ; }
 public void setStorageDomainId ( final NGuid value ) { _storageDomainId = value ; }
 @ Override public Scheduler getScheduler ( ) { return SchedulerFactory . singleton ( ) . createOrGetParallelScheduler ( Mathjax . class . getName ( ) + this . hashCode ( ) , 5 ) ; }
 public EEnum getTPotentialDelegatees ( ) { return tPotentialDelegateesEEnum ; }
 @ Override public long unsharedHeapSize ( ) { long entrySize = 0 ; for ( IndexHelper . IndexInfo idx : columnsIndex ) entrySize += idx . unsharedHeapSize ( ) ; return BASE_SIZE + entrySize + deletionTime . unsharedHeapSize ( ) + ObjectSizes . sizeOfReferenceArray ( columnsIndex . size ( ) ) ; }
 public void setStreet ( String street ) { this . street = street ; }
 @ Override public String getDescrption ( ) { return this . descrption ; }
 @ Override public void active ( boolean isActived ) { this . actived = isActived ; }
 public void BFS ( ) { System . out . println ( " BFS ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } }
 public void initializePackageContents ( ) { if ( isInitialized ) return ; isInitialized = true ; setName ( eNAME ) ; setNsPrefix ( eNS_PREFIX ) ; setNsURI ( eNS_URI ) ; XMLTypePackage theXMLTypePackage = ( XMLTypePackage ) EPackage . Registry . INSTANCE . getEPackage ( XMLTypePackage . eNS_URI ) ; XMLNamespacePackage theXMLNamespacePackage = ( XMLNamespacePackage ) EPackage . Registry . INSTANCE . getEPackage ( XMLNamespacePackage . eNS_URI ) ; tArgumentEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tBooleanExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tDeadlineEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDeadlineExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tDeadlinesEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDelegationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tDescriptionEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tDurationExprEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tEscalationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tExtensionEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tExtensionsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tFromEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tGenericHumanRoleEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tHumanInteractionsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tImportEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLocalNotificationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLogicalPeopleGroupEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tLogicalPeopleGroupsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationInterfaceEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tNotificationsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tParameterEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tPeopleAssignmentsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPresentationElementsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPresentationParameterEClass . getESuperTypes ( ) . add ( this . getTParameter ( ) ) ; tPresentationParametersEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tPriorityEClass . getESuperTypes ( ) . add ( this . getTExpression ( ) ) ; tReassignmentEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tRenderingEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tRenderingsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTaskEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTaskInterfaceEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTasksEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; tTextEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tToPartEClass . getESuperTypes ( ) . add ( this . getTExtensibleMixedContentElements ( ) ) ; tToPartsEClass . getESuperTypes ( ) . add ( this . getTExtensibleElements ( ) ) ; initEClass ( documentRootEClass , DocumentRoot . class , " DocumentRoot " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getDocumentRoot_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , null , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_XMLNSPrefixMap ( ) , ecorePackage . getEStringToStringMapEntry ( ) , null , " xMLNSPrefixMap " , null , 0 , - 1 , null , IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_XSISchemaLocation ( ) , ecorePackage . getEStringToStringMapEntry ( ) , null , " xSISchemaLocation " , null , 0 , - 1 , null , IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_BusinessAdministrators ( ) , this . getTGenericHumanRole ( ) , null , " businessAdministrators " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_ExcludedOwners ( ) , this . getTGenericHumanRole ( ) , null , " excludedOwners " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getDocumentRoot_Group ( ) , this . getTGroup ( ) , " group " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Groups ( ) , this . getTGrouplist ( ) , null , " groups " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_HumanInteractions ( ) , this . getTHumanInteractions ( ) , null , " humanInteractions " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Import ( ) , this . getTImport ( ) , null , " import " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_LogicalPeopleGroups ( ) , this . getTLogicalPeopleGroups ( ) , null , " logicalPeopleGroups " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Notifications ( ) , this . getTNotifications ( ) , null , " notifications " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_OrganizationalEntity ( ) , this . getTOrganizationalEntity ( ) , null , " organizationalEntity " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Recipients ( ) , this . getTGenericHumanRole ( ) , null , " recipients " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Task ( ) , this . getTTask ( ) , null , " task " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_TaskInitiator ( ) , this . getTGenericHumanRole ( ) , null , " taskInitiator " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Tasks ( ) , this . getTTasks ( ) , null , " tasks " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_TaskStakeholders ( ) , this . getTGenericHumanRole ( ) , null , " taskStakeholders " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getDocumentRoot_User ( ) , this . getTUser ( ) , " user " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getDocumentRoot_Users ( ) , this . getTUserlist ( ) , null , " users " , null , 0 , - 2 , null , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEClass ( tArgumentEClass , TArgument . class , " TArgument " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTArgument_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TArgument . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTArgument_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 0 , 1 , TArgument . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tBooleanExprEClass , TBooleanExpr . class , " TBooleanExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tDeadlineEClass , TDeadline . class , " TDeadline " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDeadline_For ( ) , this . getTDurationExpr ( ) , null , " for " , null , 0 , 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadline_Until ( ) , this . getTDeadlineExpr ( ) , null , " until " , null , 0 , 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadline_Escalation ( ) , this . getTEscalation ( ) , null , " escalation " , null , 0 , - 1 , TDeadline . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDeadlineExprEClass , TDeadlineExpr . class , " TDeadlineExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tDeadlinesEClass , TDeadlines . class , " TDeadlines " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDeadlines_StartDeadline ( ) , this . getTDeadline ( ) , null , " startDeadline " , null , 0 , - 1 , TDeadlines . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTDeadlines_CompletionDeadline ( ) , this . getTDeadline ( ) , null , " completionDeadline " , null , 0 , - 1 , TDeadlines . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDelegationEClass , TDelegation . class , " TDelegation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTDelegation_From ( ) , this . getTFrom ( ) , null , " from " , null , 0 , 1 , TDelegation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDelegation_PotentialDelegatees ( ) , this . getTPotentialDelegatees ( ) , " potentialDelegatees " , null , 1 , 1 , TDelegation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDescriptionEClass , TDescription . class , " TDescription " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTDescription_ContentType ( ) , theXMLTypePackage . getString ( ) , " contentType " , null , 0 , 1 , TDescription . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDescription_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TDescription . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDocumentationEClass , TDocumentation . class , " TDocumentation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTDocumentation_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TDocumentation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDocumentation_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TDocumentation . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTDocumentation_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TDocumentation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tDurationExprEClass , TDurationExpr . class , " TDurationExpr " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tEscalationEClass , TEscalation . class , " TEscalation " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTEscalation_Condition ( ) , this . getTBooleanExpr ( ) , null , " condition " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_ToParts ( ) , this . getTToParts ( ) , null , " toParts " , null , 0 , - 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_LocalNotification ( ) , this . getTLocalNotification ( ) , null , " localNotification " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTEscalation_Reassignment ( ) , this . getTReassignment ( ) , null , " reassignment " , null , 0 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTEscalation_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TEscalation . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExpressionEClass , TExpression . class , " TExpression " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExpression_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExpression . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExpression_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExpression . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensibleElementsEClass , TExtensibleElements . class , " TExtensibleElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTExtensibleElements_Documentation ( ) , this . getTDocumentation ( ) , null , " documentation " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleElements_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleElements_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExtensibleElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensibleMixedContentElementsEClass , TExtensibleMixedContentElements . class , " TExtensibleMixedContentElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExtensibleMixedContentElements_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TExtensibleMixedContentElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTExtensibleMixedContentElements_Documentation ( ) , this . getTDocumentation ( ) , null , " documentation " , null , 0 , - 1 , TExtensibleMixedContentElements . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleMixedContentElements_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TExtensibleMixedContentElements . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtensibleMixedContentElements_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TExtensibleMixedContentElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensionEClass , TExtension . class , " TExtension " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTExtension_MustUnderstand ( ) , this . getTBoolean ( ) , " mustUnderstand " , null , 1 , 1 , TExtension . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTExtension_Namespace ( ) , theXMLTypePackage . getAnyURI ( ) , " namespace " , null , 1 , 1 , TExtension . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tExtensionsEClass , TExtensions . class , " TExtensions " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTExtensions_Extension ( ) , this . getTExtension ( ) , null , " extension " , null , 1 , - 1 , TExtensions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tFromEClass , TFrom . class , " TFrom " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTFrom_Argument ( ) , this . getTArgument ( ) , null , " argument " , null , 0 , - 1 , TFrom . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTFrom_Literal ( ) , this . getTLiteral ( ) , null , " literal " , null , 0 , 1 , TFrom . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTFrom_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TFrom . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTFrom_LogicalPeopleGroup ( ) , theXMLTypePackage . getQName ( ) , " logicalPeopleGroup " , null , 0 , 1 , TFrom . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tGenericHumanRoleEClass , TGenericHumanRole . class , " TGenericHumanRole " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTGenericHumanRole_From ( ) , this . getTFrom ( ) , null , " from " , null , 1 , 1 , TGenericHumanRole . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tGrouplistEClass , TGrouplist . class , " TGrouplist " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTGrouplist_Group ( ) , this . getTGroup ( ) , " group " , null , 0 , - 1 , TGrouplist . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tHumanInteractionsEClass , THumanInteractions . class , " THumanInteractions " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTHumanInteractions_Extensions ( ) , this . getTExtensions ( ) , null , " extensions " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Import ( ) , this . getTImport ( ) , null , " import " , null , 0 , - 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_LogicalPeopleGroups ( ) , this . getTLogicalPeopleGroups ( ) , null , " logicalPeopleGroups " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Tasks ( ) , this . getTTasks ( ) , null , " tasks " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTHumanInteractions_Notifications ( ) , this . getTNotifications ( ) , null , " notifications " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_QueryLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " queryLanguage " , null , 0 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTHumanInteractions_TargetNamespace ( ) , theXMLTypePackage . getAnyURI ( ) , " targetNamespace " , null , 1 , 1 , THumanInteractions . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tImportEClass , TImport . class , " TImport " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTImport_ImportType ( ) , theXMLTypePackage . getAnyURI ( ) , " importType " , null , 1 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTImport_Location ( ) , theXMLTypePackage . getAnyURI ( ) , " location " , null , 0 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTImport_Namespace ( ) , theXMLTypePackage . getAnyURI ( ) , " namespace " , null , 0 , 1 , TImport . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLiteralEClass , TLiteral . class , " TLiteral " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTLiteral_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TLiteral . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLiteral_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TLiteral . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLiteral_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TLiteral . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLocalNotificationEClass , TLocalNotification . class , " TLocalNotification " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLocalNotification_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTLocalNotification_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 0 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLocalNotification_Reference ( ) , theXMLTypePackage . getQName ( ) , " reference " , null , 1 , 1 , TLocalNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLogicalPeopleGroupEClass , TLogicalPeopleGroup . class , " TLogicalPeopleGroup " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLogicalPeopleGroup_Parameter ( ) , this . getTParameter ( ) , null , " parameter " , null , 0 , - 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLogicalPeopleGroup_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTLogicalPeopleGroup_Reference ( ) , theXMLTypePackage . getNCName ( ) , " reference " , null , 0 , 1 , TLogicalPeopleGroup . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tLogicalPeopleGroupsEClass , TLogicalPeopleGroups . class , " TLogicalPeopleGroups " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTLogicalPeopleGroups_LogicalPeopleGroup ( ) , this . getTLogicalPeopleGroup ( ) , null , " logicalPeopleGroup " , null , 1 , - 1 , TLogicalPeopleGroups . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationEClass , TNotification . class , " TNotification " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTNotification_Interface ( ) , this . getTNotificationInterface ( ) , null , " interface " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_PresentationElements ( ) , this . getTPresentationElements ( ) , null , " presentationElements " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTNotification_Renderings ( ) , this . getTRenderings ( ) , null , " renderings " , null , 0 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTNotification_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TNotification . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationInterfaceEClass , TNotificationInterface . class , " TNotificationInterface " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTNotificationInterface_Operation ( ) , theXMLTypePackage . getNCName ( ) , " operation " , null , 1 , 1 , TNotificationInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTNotificationInterface_PortType ( ) , theXMLTypePackage . getQName ( ) , " portType " , null , 1 , 1 , TNotificationInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tNotificationsEClass , TNotifications . class , " TNotifications " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTNotifications_Notification ( ) , this . getTNotification ( ) , null , " notification " , null , 1 , - 1 , TNotifications . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tOrganizationalEntityEClass , TOrganizationalEntity . class , " TOrganizationalEntity " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTOrganizationalEntity_Users ( ) , this . getTUserlist ( ) , null , " users " , null , 0 , 1 , TOrganizationalEntity . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTOrganizationalEntity_Groups ( ) , this . getTGrouplist ( ) , null , " groups " , null , 0 , 1 , TOrganizationalEntity . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tParameterEClass , TParameter . class , " TParameter " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTParameter_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TParameter . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTParameter_Type ( ) , theXMLTypePackage . getQName ( ) , " type " , null , 1 , 1 , TParameter . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPeopleAssignmentsEClass , TPeopleAssignments . class , " TPeopleAssignments " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTPeopleAssignments_GenericHumanRole ( ) , ecorePackage . getEFeatureMapEntry ( ) , " genericHumanRole " , null , 0 , - 1 , TPeopleAssignments . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_ExcludedOwners ( ) , this . getTGenericHumanRole ( ) , null , " excludedOwners " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_TaskInitiator ( ) , this . getTGenericHumanRole ( ) , null , " taskInitiator " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_TaskStakeholders ( ) , this . getTGenericHumanRole ( ) , null , " taskStakeholders " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_BusinessAdministrators ( ) , this . getTGenericHumanRole ( ) , null , " businessAdministrators " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPeopleAssignments_Recipients ( ) , this . getTGenericHumanRole ( ) , null , " recipients " , null , 0 , - 1 , TPeopleAssignments . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEClass ( tPresentationElementsEClass , TPresentationElements . class , " TPresentationElements " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTPresentationElements_Name ( ) , this . getTText ( ) , null , " name " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_PresentationParameters ( ) , this . getTPresentationParameters ( ) , null , " presentationParameters " , null , 0 , 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_Subject ( ) , this . getTText ( ) , null , " subject " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTPresentationElements_Description ( ) , this . getTDescription ( ) , null , " description " , null , 0 , - 1 , TPresentationElements . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPresentationParameterEClass , TPresentationParameter . class , " TPresentationParameter " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tPresentationParametersEClass , TPresentationParameters . class , " TPresentationParameters " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTPresentationParameters_PresentationParameter ( ) , this . getTPresentationParameter ( ) , null , " presentationParameter " , null , 1 , - 1 , TPresentationParameters . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTPresentationParameters_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TPresentationParameters . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tPriorityEClass , TPriority . class , " TPriority " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEClass ( tQueryEClass , TQuery . class , " TQuery " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTQuery_Mixed ( ) , ecorePackage . getEFeatureMapEntry ( ) , " mixed " , null , 0 , - 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_Any ( ) , ecorePackage . getEFeatureMapEntry ( ) , " any " , null , 0 , - 1 , TQuery . class , IS_TRANSIENT , IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_Part ( ) , theXMLTypePackage . getAnySimpleType ( ) , " part " , null , 0 , 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_QueryLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " queryLanguage " , null , 0 , 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTQuery_AnyAttribute ( ) , ecorePackage . getEFeatureMapEntry ( ) , " anyAttribute " , null , 0 , - 1 , TQuery . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tReassignmentEClass , TReassignment . class , " TReassignment " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTReassignment_PotentialOwners ( ) , this . getTGenericHumanRole ( ) , null , " potentialOwners " , null , 1 , 1 , TReassignment . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tRenderingEClass , TRendering . class , " TRendering " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTRendering_Type ( ) , theXMLTypePackage . getQName ( ) , " type " , null , 1 , 1 , TRendering . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tRenderingsEClass , TRenderings . class , " TRenderings " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTRenderings_Rendering ( ) , this . getTRendering ( ) , null , " rendering " , null , 1 , - 1 , TRenderings . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTaskEClass , TTask . class , " TTask " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTTask_Interface ( ) , this . getTTaskInterface ( ) , null , " interface " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Priority ( ) , this . getTPriority ( ) , null , " priority " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_PeopleAssignments ( ) , this . getTPeopleAssignments ( ) , null , " peopleAssignments " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Delegation ( ) , this . getTDelegation ( ) , null , " delegation " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_PresentationElements ( ) , this . getTPresentationElements ( ) , null , " presentationElements " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Outcome ( ) , this . getTQuery ( ) , null , " outcome " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_SearchBy ( ) , this . getTExpression ( ) , null , " searchBy " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Renderings ( ) , this . getTRenderings ( ) , null , " renderings " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEReference ( getTTask_Deadlines ( ) , this . getTDeadlines ( ) , null , " deadlines " , null , 0 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTask_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TTask . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTaskInterfaceEClass , TTaskInterface . class , " TTaskInterface " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTTaskInterface_Operation ( ) , theXMLTypePackage . getNCName ( ) , " operation " , null , 1 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_PortType ( ) , theXMLTypePackage . getQName ( ) , " portType " , null , 1 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_ResponseOperation ( ) , theXMLTypePackage . getNCName ( ) , " responseOperation " , null , 0 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTTaskInterface_ResponsePortType ( ) , theXMLTypePackage . getQName ( ) , " responsePortType " , null , 0 , 1 , TTaskInterface . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTasksEClass , TTasks . class , " TTasks " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTTasks_Task ( ) , this . getTTask ( ) , null , " task " , null , 1 , - 1 , TTasks . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tTextEClass , TText . class , " TText " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTText_Lang ( ) , theXMLNamespacePackage . getLangType ( ) , " lang " , null , 0 , 1 , TText . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tToPartEClass , TToPart . class , " TToPart " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTToPart_ExpressionLanguage ( ) , theXMLTypePackage . getAnyURI ( ) , " expressionLanguage " , null , 0 , 1 , TToPart . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEAttribute ( getTToPart_Name ( ) , theXMLTypePackage . getNCName ( ) , " name " , null , 1 , 1 , TToPart . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tToPartsEClass , TToParts . class , " TToParts " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEReference ( getTToParts_ToPart ( ) , this . getTToPart ( ) , null , " toPart " , null , 1 , - 1 , TToParts . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , IS_COMPOSITE , ! IS_RESOLVE_PROXIES , ! IS_UNSETTABLE , IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEClass ( tUserlistEClass , TUserlist . class , " TUserlist " , ! IS_ABSTRACT , ! IS_INTERFACE , IS_GENERATED_INSTANCE_CLASS ) ; initEAttribute ( getTUserlist_User ( ) , this . getTUser ( ) , " user " , null , 0 , - 1 , TUserlist . class , ! IS_TRANSIENT , ! IS_VOLATILE , IS_CHANGEABLE , ! IS_UNSETTABLE , ! IS_ID , ! IS_UNIQUE , ! IS_DERIVED , IS_ORDERED ) ; initEEnum ( tBooleanEEnum , TBoolean . class , " TBoolean " ) ; addEEnumLiteral ( tBooleanEEnum , TBoolean . YES ) ; addEEnumLiteral ( tBooleanEEnum , TBoolean . NO ) ; initEEnum ( tPotentialDelegateesEEnum , TPotentialDelegatees . class , " TPotentialDelegatees " ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . ANYBODY ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . NOBODY ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . POTENTIAL_OWNERS ) ; addEEnumLiteral ( tPotentialDelegateesEEnum , TPotentialDelegatees . OTHER ) ; initEDataType ( tBooleanObjectEDataType , TBoolean . class , " TBooleanObject " , IS_SERIALIZABLE , IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tGroupEDataType , String . class , " TGroup " , IS_SERIALIZABLE , ! IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tPotentialDelegateesObjectEDataType , TPotentialDelegatees . class , " TPotentialDelegateesObject " , IS_SERIALIZABLE , IS_GENERATED_INSTANCE_CLASS ) ; initEDataType ( tUserEDataType , String . class , " TUser " , IS_SERIALIZABLE , ! IS_GENERATED_INSTANCE_CLASS ) ; createResource ( eNS_URI ) ; createExtendedMetaDataAnnotations ( ) ; }
 protected ApiEntity ( String id ) { this . id = hasText ( id ) ? id : null ; }
 public < A extends Annotation > void addConstraintValidatorDefinition ( Class < A > annotationClass , List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > definitionClasses ) { constraintValidatorDefinitions . putIfAbsent ( annotationClass , definitionClasses ) ; }
 public void draw ( ) { background ( 255 ) ; spainGraph . draw ( ) ; sphero . draw ( ) ; }
 public String value ( ) { return value ; }
 public EClass getTPeopleAssignments ( ) { return tPeopleAssignmentsEClass ; }
 public EReference getDocumentRoot_Recipients ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 16 ) ; }
 public TokenKind getKind ( ) { return kind ; }
 public Guid getVmId ( ) { return getVmIdRef ( ) != null ? getVmIdRef ( ) . getValue ( ) : Guid . Empty ; }
 @ Override default void run ( ) { execute ( ) ; }
 @ Override public SslContext getClientSslContext ( final SSLContextConfig config , final Map < String , Object > additionalOpts ) throws Exception { log . debugf ( " Creating ▁ Client ▁ OpenSSL ▁ Context ▁ with ▁ % s " , config ) ; return new SSLSupport ( config ) . setSslProvider ( TransportConstants . OPENSSL_PROVIDER ) . createNettyClientContext ( ) ; }
 @ Override public String toString ( ) { return S . toString ( VisorCachePartitions . class , this ) ; }
 public EReference getTFrom_Literal ( ) { return ( EReference ) tFromEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public AbstractType < UUID > nameComparator ( ) { return TimeUUIDType . instance ; }
 @ Override public final IntervalTable < AnimalYearResult > getAnnualCheckMap ( ) { return rolltable ; }
 public EAttribute getTImport_Namespace ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 BlockChannelWriter < MemorySegment > getBuildSideChannel ( ) { return this . buildSideChannel ; }
 public void test_getMessage ( ) { String s = " MYTESTSTRING " ; MissingFormatWidthException missingFormatWidthException = new MissingFormatWidthException ( s ) ; assertTrue ( null != missingFormatWidthException . getMessage ( ) ) ; }
 private int associationColor ( Association association ) { if ( association . isIgnored ( ) ) { return COLOR_IGNORED . getRGB ( ) ; } if ( association . isInsertDestinationBeforeSource ( ) ) { return COLOR_DEPENDENCY . getRGB ( ) ; } if ( association . isInsertSourceBeforeDestination ( ) ) { return COLOR_REVERSE_DEPENDENCY . getRGB ( ) ; } return COLOR_ASSOCIATION . getRGB ( ) ; }
 if ( Main . config ( ) . getBoolean ( " featured " ) ) { DocumentBuilderFactory dbFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder dBuilder = dbFactory . newDocumentBuilder ( ) ; String xmlFile = Main . dataFolder ( ) + " / cache / featured / " + type + " . xml " ; Document doc = dBuilder . parse ( xmlFile ) ; doc . getDocumentElement ( ) . normalize ( ) ; NodeList nList = doc . getElementsByTagName ( type ) ; for ( int temp = 0 ; temp < nList . getLength ( ) ; temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; ads . add ( eElement . getTextContent ( ) ) ; } } }
 @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; EncodingStats that = ( EncodingStats ) o ; return this . minLocalDeletionTime == that . minLocalDeletionTime && this . minTTL == that . minTTL && this . minTimestamp == that . minTimestamp ; }
 @ JsonProperty ( " IsMediaAssignmentAllowed " ) public void setIsMediaAssignmentAllowed ( Boolean isMediaAssignmentAllowed ) { this . isMediaAssignmentAllowed = isMediaAssignmentAllowed ; }
 @ Autowired public void setDateSource ( DataSource ds ) { jdbcTemplate = new JdbcTemplate ( ds ) ; }
 void updateDenseAddressOffset ( long addressOffset ) { if ( addressOffset != 0 ) { setReadPosition ( 0 ) ; while ( true ) { try { checkReadAdvance ( ) ; long addrAndLen = getCurrentSegment ( ) . getLong ( getCurrentPositionInSegment ( ) ) ; long address = LongHashPartition . toAddress ( addrAndLen ) ; int len = LongHashPartition . toLength ( addrAndLen ) ; if ( address != INVALID_ADDRESS ) { getCurrentSegment ( ) . putLong ( getCurrentPositionInSegment ( ) , LongHashPartition . toAddrAndLen ( address + addressOffset , len ) ) ; } skipBytesToRead ( 8 + len ) ; } catch ( EOFException e ) { break ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } }
 public EAttribute getTDocumentation_Any ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public List < LibraryToLink > getLibraries ( ) { return libraries ; }
 @ Override @ FxThread protected void storeSize ( int size ) { getConfig ( ) . setGlobalBottomToolHeight ( size ) ; }
 public EReference getTNotifications_Notification ( ) { return ( EReference ) tNotificationsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EReference getTReassignment_PotentialOwners ( ) { return ( EReference ) tReassignmentEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Override @ FxThread protected @ NotNull StackPane createRoot ( ) { return new StackPane ( ) ; }
 private void doRRMemLRUTest ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; Object v = new TestObject ( 200 , 200000 ) ; get ( vm1 , " a " , v ) ; int vSize = CachedDeserializableFactory . calcSerializedMemSize ( v ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; long evictionSizeAfterGet = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 200000 + CachedDeserializableFactory . overhead ( ) - vSize , evictionSizeAfterGet - finalEvictionSize1 ) ; put ( vm0 , " b " , new TestObject ( 100 , 1000000 ) ) ; assertEquals ( 1 , getEvictions ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm1 ) ) ; get ( vm1 , " b " , new TestObject ( 100 , 1000000 ) ) ; assertEquals ( 1 , getEvictions ( vm1 ) ) ; }
 public void start ( ) { bootstrap = new Bootstrap ( ) ; bootstrap . channel ( NioSocketChannel . class ) ; bootstrap . group ( new NioEventLoopGroup ( 10 ) ) ; bootstrap . handler ( new ChannelInitializer < Channel > ( ) { public void initChannel ( Channel channel ) throws Exception { } } ) ; }
 public void Dijkstra ( ) { System . out . println ( " Dijkstra ▁ event : ▁ " + input . getText ( ) ) ; if ( spainGraph . contains ( input . getText ( ) ) ) { city = input . getText ( ) ; } if ( spainGraph . contains ( destination . getText ( ) ) ) { destCity = destination . getText ( ) ; } }
 public List < Group > getGroups ( Section section ) { return jdbcTemplate . query ( " SELECT ▁ sections . moderate , ▁ vote , ▁ section , ▁ havelink , ▁ linktext , ▁ title , ▁ urlname , ▁ image , ▁ groups . restrict _ topics , ▁ restrict _ comments , ▁ stat3 , groups . id , groups . info , groups . longinfo , groups . resolvable ▁ FROM ▁ groups , ▁ sections ▁ WHERE ▁ sections . id = ? ▁ AND ▁ groups . section = sections . id ▁ ORDER ▁ BY ▁ id " , ( rs , rowNum ) -> Group . buildGroup ( rs ) , section . getId ( ) ) ; }
 @ FxThread @ Override protected boolean handleKeyActionImpl ( @ NotNull final KeyCode keyCode , final boolean isPressed , final boolean isControlDown , final boolean isShiftDown , final boolean isButtonMiddleDown ) { if ( isPressed && isControlDown && keyCode == KeyCode . Z ) { undo ( ) ; return true ; } else if ( isPressed && isControlDown && isShiftDown && keyCode == KeyCode . Z ) { redo ( ) ; return true ; } else if ( isPressed && isControlDown && keyCode == KeyCode . Y ) { redo ( ) ; return true ; } return super . handleKeyActionImpl ( keyCode , isPressed , isControlDown , isShiftDown , isButtonMiddleDown ) ; }
 @ Override public void snapshotShard ( Store store , MapperService mapperService , SnapshotId snapshotId , IndexId indexId , IndexCommit snapshotIndexCommit , IndexShardSnapshotStatus snapshotStatus , boolean writeShardGens , ActionListener < String > listener ) { }
 public EAttribute getTTaskInterface_ResponsePortType ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 private long getEvictions ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getEvictions ( region ) ; } } ) ; }
 public boolean accepts ( Payload payload ) { if ( bases == null ) { return true ; } if ( payload . getRecord ( ) == null ) { log . warn ( " A ▁ Payload ▁ without ▁ base ▁ was ▁ received ▁ in ▁ accepts ( " + payload + " ) ▁ in ▁ " + this ) ; return false ; } return bases . contains ( payload . getRecord ( ) . getBase ( ) ) ; }
 public DefaultPet ( final DefaultPet pet ) { super ( ) ; checkNotNull ( pet , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ pet " ) ; name = pet . name ; rolltable = pet . rolltable ; }
 public int validate ( Variable [ ] operands ) throws CircuitDescriptionException { if ( operands . length == 1 ) { int o = operands [ 0 ] . validate ( ) ; if ( o < 2 ) { throw createException ( " Unary ▁ or ▁ operation ▁ requires ▁ at ▁ least ▁ two ▁ bits " ) ; } return 1 ; } else { binaryOperation ( operands ) ; return operands [ 0 ] . validate ( ) ; } }
 public boolean isMultiValueConstraint ( Class < ? extends Annotation > annotationType ) { boolean isMultiValueConstraint = false ; final Method method = ReflectionHelper . getMethod ( annotationType , " value " ) ; if ( method != null ) { Class returnType = method . getReturnType ( ) ; if ( returnType . isArray ( ) && returnType . getComponentType ( ) . isAnnotation ( ) ) { @ SuppressWarnings ( " unchecked " ) Class < ? extends Annotation > componentType = ( Class < ? extends Annotation > ) returnType . getComponentType ( ) ; if ( isConstraintAnnotation ( componentType ) || isBuiltinConstraint ( componentType ) ) { isMultiValueConstraint = true ; } else { isMultiValueConstraint = false ; } } } return isMultiValueConstraint ; }
 if ( disconnected ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ channel ▁ is ▁ disconnected : ▁ { } " , msg ) ; } return 0 ; }
 @ Override public String toString ( ) { return " Address ▁ [ street = ▁ " + street + " , ▁ postcode = ▁ " + postcode + " ] " ; }
 private BuildSideBuffer ( MemorySegment segment ) { super ( segment , segment . size ( ) , 0 ) ; this . targetList = new ArrayList < > ( ) ; }
 public PermissionDAO getPermissionDAO ( ) { return getDbFacade ( ) . getPermissionDAO ( ) ; }
 @ Test public void testPRHeapLRUDeltaWithFlagPutOnSecondary ( ) { doPRDeltaTestLRU ( false , true , false , true ) ; }
 private String toString ( Iterable < SSTableReader > sstables ) { StringBuilder builder = new StringBuilder ( ) ; for ( SSTableReader sstable : sstables ) { builder . append ( sstable . descriptor . cfname ) . append ( ' - ' ) . append ( sstable . descriptor . generation ) . append ( " ( L " ) . append ( sstable . getSSTableLevel ( ) ) . append ( " ) , ▁ " ) ; } return builder . toString ( ) ; }
 public EReference getTExtensibleElements_Documentation ( ) { return ( EReference ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 private long getSizeFromPRStats ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; if ( region instanceof PartitionedRegion ) { long total = 0 ; PartitionedRegion pr = ( ( PartitionedRegion ) region ) ; for ( int i = 0 ; i < pr . getPartitionAttributes ( ) . getTotalNumBuckets ( ) ; i ++ ) { total += pr . getDataStore ( ) . getBucketSize ( i ) ; } return total ; } else { return 0L ; } } } ) ; }
 public void setTaxId ( final String taxId ) { this . taxId = taxId ; }
 public Address ( String street , String postcode ) { this . street = street ; this . postcode = postcode ; }
 protected void setVm ( final VM value ) { mVm = value ; }
 public NestedSet < Linkstamp > getLinkstamps ( ) { NestedSetBuilder < Linkstamp > linkstamps = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { linkstamps . addAll ( linkerInput . getLinkstamps ( ) ) ; } return linkstamps . build ( ) ; }
 protected VmStatisticsDAO getVmStatisticsDAO ( ) { return getDbFacade ( ) . getVmStatisticsDAO ( ) ; }
 public String getDataDeFinalizacao ( ) { return dataDeFinalizacao ; }
 public EReference getTTasks_Task ( ) { return ( EReference ) tTasksEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Override protected void onHandleIntent ( Intent intent ) { Logger logger = Logger . getLogger ( ) ; logger . log ( Log . DEBUG , " ReceiveTransitionsIntentService ▁ - ▁ onHandleIntent " ) ; Intent broadcastIntent = new Intent ( GeofenceTransitionIntent ) ; notifier = new GeoNotificationNotifier ( ( NotificationManager ) this . getSystemService ( Context . NOTIFICATION_SERVICE ) , this ) ; GeofencingEvent geofencingEvent = GeofencingEvent . fromIntent ( intent ) ; if ( geofencingEvent . hasError ( ) ) { int errorCode = geofencingEvent . getErrorCode ( ) ; String error = " Location ▁ Services ▁ error : ▁ " + Integer . toString ( errorCode ) ; logger . log ( Log . ERROR , error ) ; broadcastIntent . putExtra ( " error " , error ) ; } else { int transitionType = geofencingEvent . getGeofenceTransition ( ) ; if ( ( transitionType == Geofence . GEOFENCE_TRANSITION_ENTER ) || ( transitionType == Geofence . GEOFENCE_TRANSITION_EXIT ) ) { logger . log ( Log . DEBUG , " Geofence ▁ transition ▁ detected " ) ; List < Geofence > triggerList = geofencingEvent . getTriggeringGeofences ( ) ; List < GeoNotification > geoNotifications = new ArrayList < GeoNotification > ( ) ; for ( Geofence fence : triggerList ) { String fenceId = fence . getRequestId ( ) ; GeoNotification geoNotification = store . getGeoNotification ( fenceId ) ; if ( geoNotification != null ) { if ( geoNotification . notification != null ) { if ( geoNotification . isScheduled ( ) && geoNotification . isFrequencyOk ( ) ) { geoNotification . notification . setLastTriggered ( ) ; store . setGeoNotification ( geoNotification ) ; notifier . notify ( geoNotification . notification ) ; } } geoNotification . transitionType = transitionType ; geoNotifications . add ( geoNotification ) ; } } if ( geoNotifications . size ( ) > 0 ) { broadcastIntent . putExtra ( " transitionData " , Gson . get ( ) . toJson ( geoNotifications ) ) ; GeofencePlugin . onTransitionReceived ( geoNotifications ) ; } } else { String error = " Geofence ▁ transition ▁ error : ▁ " + transitionType ; logger . log ( Log . ERROR , error ) ; broadcastIntent . putExtra ( " error " , error ) ; } } sendBroadcast ( broadcastIntent ) ; }
 private void logErrorAndThrow ( String msg ) throws OrmException { logError ( msg ) ; throw new OrmException ( msg ) ; }
 public void startOfComplexColumn ( ColumnMetadata column ) { this . tester = columnsToFetch == null ? null : columnsToFetch . newTester ( column ) ; this . currentDroppedComplex = droppedColumns . get ( column . name . bytes ) ; }
 public AuditLogableBase ( final NGuid vdsId ) { mVdsId = vdsId ; }
 public DiseaseOutcomeWithProbabilitySetter ( ApolloTranslationEngine apolloTranslationEngine , String prefix , String section ) { super ( prefix , section , apolloTranslationEngine ) ; }
 protected int promotedSize ( IndexHelper . IndexInfo . Serializer idxSerializer ) { return 0 ; }
 private ChangeEvent getChangeEvent ( ) { if ( changeEvent == null ) { changeEvent = new ChangeEvent ( this ) ; } return changeEvent ; }
 public CcLinkingContext build ( ) { if ( hasDirectLinkerInput ) { linkerInputs . add ( linkerInputBuilder . build ( ) ) ; } return new CcLinkingContext ( linkerInputs . build ( ) , extraLinkTimeLibraries ) ; }
 private int findBucket ( int hash ) { return partitionLevelHash ( hash ) & this . numBucketsMask ; }
 public Guid getQuotaIdRef ( ) { if ( quotaId == null && getQuota ( ) != null ) { quotaId = getQuota ( ) . getId ( ) ; } return quotaId ; }
 protected void sendNotificationsToAll ( SquidDatabase database , Set < T > notifyObjects ) { for ( T notifyObject : notifyObjects ) { sendNotification ( database , notifyObject ) ; } }
 public EClass getTToPart ( ) { return tToPartEClass ; }
 public List < SSTableReader > getLevel ( int i ) { return generations [ i ] ; }
 public @ NotNull Path getAssetFolder ( ) { return notNull ( get ( ASSET ) ) ; }
 if ( ce != null ) { retryInfo = ce ; ce = null ; }
 public EReference getTDeadlines_CompletionDeadline ( ) { return ( EReference ) tDeadlinesEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 @ Override public int hashCode ( ) { return symbolForEquality . hashCode ( ) ; }
 void iteratorToDenseBucket ( MemorySegment [ ] denseBuckets , long addressOffset , long globalMinKey ) { int bucketOffset = 0 ; MemorySegment segment = buckets [ bucketOffset ] ; int segOffset = 0 ; for ( int i = 0 ; i < numBuckets ; i ++ ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { long key = segment . getLong ( segOffset ) ; long denseBucket = key - globalMinKey ; long denseBucketOffset = denseBucket << 3 ; int denseSegIndex = ( int ) ( denseBucketOffset >>> segmentSizeBits ) ; int denseSegOffset = ( int ) ( denseBucketOffset & segmentSizeMask ) ; denseBuckets [ denseSegIndex ] . putLong ( denseSegOffset , address + addressOffset ) ; } if ( i != numBuckets - 1 ) { if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { segment = buckets [ ++ bucketOffset ] ; segOffset = 0 ; } } } }
 @ Override public Response handle ( ) throws Exception { WebDriverLikeCommand command = WebDriverLikeCommand . valueOf ( getRequest ( ) . getVariableValue ( " : command " ) ) ; JSONObject payload = getRequest ( ) . getPayload ( ) ; Iterator < String > iter = payload . keys ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; Object value = payload . opt ( key ) ; getSession ( ) . configure ( command ) . set ( key , value ) ; } Response resp = new Response ( ) ; resp . setSessionId ( getSession ( ) . getSessionId ( ) ) ; resp . setStatus ( 0 ) ; resp . setValue ( new JSONObject ( ) ) ; return resp ; }
 private ConnectExceptions readAcks ( List sentCons , long startTime , long ackTimeout , long ackSDTimeout , ConnectExceptions cumulativeExceptions , DirectReplyProcessor processor ) { ConnectExceptions ce = cumulativeExceptions ; for ( Iterator it = sentCons . iterator ( ) ; it . hasNext ( ) ; ) { Connection con = ( Connection ) it . next ( ) ; if ( con . isSharedResource ( ) ) { continue ; } try { try { con . readAck ( processor ) ; } catch ( SocketTimeoutException ex ) { handleAckTimeout ( ackTimeout , ackSDTimeout , con , processor ) ; } } catch ( ConnectionException conEx ) { if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( con . getRemoteAddress ( ) , conEx ) ; } } return ce ; }
 public EReference getTLogicalPeopleGroup_Parameter ( ) { return ( EReference ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ XmlElement @ Column ( name = SALUTATION_COLUMN_NAME ) public String getSalutation ( ) { return salutation ; }
 public EClass getTDeadlineExpr ( ) { return tDeadlineExprEClass ; }
 public EReference getDocumentRoot_XSISchemaLocation ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 @ JsonProperty ( " Code " ) public void setCode ( String code ) { this . code = code ; }
 @ Override public void applyModels ( ) throws IOException { KSMetaData oldKsm = DatabaseDescriptor . getTableDefinition ( tableName ) ; CFMetaData . purge ( oldKsm . cfMetaData ( ) . get ( oldName ) ) ; KSMetaData ksm = makeNewKeyspaceDefinition ( DatabaseDescriptor . getTableDefinition ( tableName ) ) ; try { CFMetaData . map ( ksm . cfMetaData ( ) . get ( newName ) ) ; } catch ( ConfigurationException ex ) { throw new RuntimeException ( ex ) ; } DatabaseDescriptor . setTableDefinition ( ksm , newVersion ) ; if ( ! clientMode ) { Table . open ( ksm . name ) . renameCf ( cfId , newName ) ; } }
 protected void end ( ) { Robot . cannonSubsystem . spinGatling ( 0 ) ; }
 @ Override public void getSnapshotIndexMetadata ( SnapshotId snapshotId , Collection < IndexId > indexIds , ActionListener < Collection < IndexMetadata > > listener ) { }
 @ Test public void testPrintWelcome ( ) throws Exception { }
 public String getVdsGroupName ( ) { if ( getVdsGroup ( ) != null ) { return getVdsGroup ( ) . getname ( ) ; } return " " ; }
 @ Test public void aJustCreatedBeanWithMaxKeepaliveIsAliveAfterThreeDays ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , FOREVER ) ; assertTrue ( bean . isAlive ( threeDaysFromNow ( ) ) ) ; }
 public void unsetPt ( ) { this . pt = null ; }
 public synchronized int [ ] getAllLevelSize ( ) { int [ ] counts = new int [ generations . length ] ; for ( int i = 0 ; i < counts . length ; i ++ ) counts [ i ] = generations [ i ] . size ( ) ; return counts ; }
 public String getDescricaoGeral ( ) { return descricaoGeral ; }
 DefaultNumberExpr ( Double number ) { this . number = number ; }
 public void subinflate ( org . apache . cassandra . db . migration . avro . Migration mi ) { org . apache . cassandra . db . migration . avro . RenameColumnFamily rcf = ( org . apache . cassandra . db . migration . avro . RenameColumnFamily ) mi . migration ; tableName = rcf . ksname . toString ( ) ; cfId = rcf . cfid ; oldName = rcf . old_cfname . toString ( ) ; newName = rcf . new_cfname . toString ( ) ; }
 public EClass getTPresentationElements ( ) { return tPresentationElementsEClass ; }
 @ JsonProperty ( " IsAllowBasePrice " ) public Boolean getIsAllowBasePrice ( ) { return isAllowBasePrice ; }
 void doPRDeltaTestLRU ( boolean shouldSizeChange , boolean heapLRU , boolean putOnPrimary , boolean wasDelta ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; if ( heapLRU ) { createPRHeapLRU ( vm0 ) ; createPRHeapLRU ( vm1 ) ; } else { createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; } assignPRBuckets ( vm0 ) ; boolean vm0isPrimary = prHostsBucketForKey ( vm0 , 0 ) ; if ( ! vm0isPrimary ) { assertEquals ( true , prHostsBucketForKey ( vm1 , 0 ) ) ; } VM primaryVm ; VM secondaryVm ; if ( vm0isPrimary ) { primaryVm = vm0 ; secondaryVm = vm1 ; } else { primaryVm = vm1 ; secondaryVm = vm0 ; } TestDelta delta1 = new TestDelta ( false , "12345" ) ; if ( putOnPrimary ) { put ( primaryVm , 0 , delta1 ) ; } else { put ( secondaryVm , 0 , delta1 ) ; } if ( putOnPrimary ) { assertValueType ( primaryVm , 0 , ValueType . CD_DESERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( primaryVm ) ) ; } else { assertValueType ( primaryVm , 0 , ValueType . CD_SERIALIZED ) ; assertEquals ( 0 , getObjectSizerInvocations ( primaryVm ) ) ; } assertValueType ( secondaryVm , 0 , ValueType . CD_SERIALIZED ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( primaryVm ) ; long origEvictionSize1 = getSizeFromEvictionStats ( secondaryVm ) ; long origPRSize0 = getSizeFromPRStats ( primaryVm ) ; long origPRSize1 = getSizeFromPRStats ( secondaryVm ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; if ( putOnPrimary ) { put ( primaryVm , 0 , delta1 ) ; } else { put ( secondaryVm , 0 , delta1 ) ; } assertValueType ( primaryVm , 0 , ValueType . CD_DESERIALIZED ) ; assertValueType ( secondaryVm , 0 , ValueType . CD_DESERIALIZED ) ; if ( shouldSizeChange ) { assertEquals ( 2 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( secondaryVm ) ) ; } else if ( wasDelta ) { assertEquals ( 0 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; } else { assertEquals ( 1 , getObjectSizerInvocations ( primaryVm ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( secondaryVm ) ) ; } long finalEvictionSize0 = getSizeFromEvictionStats ( primaryVm ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( secondaryVm ) ; long finalPRSize0 = getSizeFromPRStats ( primaryVm ) ; long finalPRSize1 = getSizeFromPRStats ( secondaryVm ) ; if ( shouldSizeChange ) { assertTrue ( finalEvictionSize0 - origEvictionSize0 != 0 ) ; assertTrue ( finalPRSize0 - origPRSize0 != 0 ) ; assertTrue ( finalEvictionSize1 - origEvictionSize1 != 0 ) ; assertTrue ( finalPRSize1 - origPRSize1 != 0 ) ; } else { assertEquals ( 0 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 0 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 0 , finalPRSize1 - origPRSize1 ) ; } }
 @ Override @ FxThread protected void bindToScene ( ) { ObservableUtils . onChange ( scene . heightProperty ( ) , number -> handleSceneChanged ( getSceneSize ( ) ) ) ; }
 public synchronized void close ( ) throws XMLStreamException { if ( ! closed ) { closed = true ; } }
 @ Override public void afterCreate ( EntryEvent event ) { event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . fine ( " invoked ▁ afterCreate ▁ with ▁ " + event ) ; event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . info ( LocalizedStrings . DEBUG , " value ▁ is ▁ " + event . getNewValue ( ) ) ; }
 if ( ce != null ) { if ( failedCe != null ) { failedCe . getMembers ( ) . addAll ( ce . getMembers ( ) ) ; failedCe . getCauses ( ) . addAll ( ce . getCauses ( ) ) ; } else { failedCe = ce ; } ce = null ; }
 public void setSnapshotName ( final String value ) { privateSnapshotName = value ; }
 public void setIncludeDynamicSearchAdsSource ( Boolean value ) { this . includeDynamicSearchAdsSource = value ; }
 @ Override public void close ( ) { U . closeQuiet ( srvSock ) ; }
 public void queuePayload ( Payload payload ) { if ( log . isTraceEnabled ( ) ) { log . trace ( " Queueing ▁ " + payload + " ▁ in ▁ " + this ) ; } if ( ! accepts ( payload ) ) { throw new IllegalArgumentException ( String . format ( " % s ▁ does ▁ not ▁ accept ▁ % s " , this , payload ) ) ; } pusher . add ( payload ) ; }
 protected void setVdsName ( final String value ) { mVdsName = value ; }
 @ Override public List < BuildOptions > split ( BuildOptions buildOptions ) { AndroidConfiguration . Options androidOptions = buildOptions . get ( AndroidConfiguration . Options . class ) ; CppOptions cppOptions = buildOptions . get ( CppOptions . class ) ; Label androidCrosstoolTop = androidOptions . androidCrosstoolTop ; if ( androidOptions . fatApkCpus . isEmpty ( ) ) { if ( androidOptions . cpu . isEmpty ( ) || androidCrosstoolTop == null || androidCrosstoolTop . equals ( cppOptions . crosstoolTop ) ) { return ImmutableList . of ( buildOptions ) ; } else { BuildOptions splitOptions = buildOptions . clone ( ) ; splitOptions . get ( CoreOptions . class ) . cpu = androidOptions . cpu ; setCommonAndroidOptions ( androidOptions , splitOptions ) ; return ImmutableList . of ( splitOptions ) ; } } else { ImmutableList . Builder < BuildOptions > result = ImmutableList . builder ( ) ; for ( String cpu : ImmutableSortedSet . copyOf ( androidOptions . fatApkCpus ) ) { BuildOptions splitOptions = buildOptions . clone ( ) ; splitOptions . get ( AndroidConfiguration . Options . class ) . fatApkCpus = ImmutableList . of ( ) ; splitOptions . get ( AndroidConfiguration . Options . class ) . cpu = cpu ; splitOptions . get ( CoreOptions . class ) . cpu = cpu ; setCommonAndroidOptions ( androidOptions , splitOptions ) ; result . add ( splitOptions ) ; } return result . build ( ) ; } }
 public String getUserName ( ) { if ( StringUtils . isEmpty ( mUserName ) && getCurrentUser ( ) != null ) { mUserName = getCurrentUser ( ) . getUserName ( ) ; } return mUserName ; }
 @ XmlElement @ Column ( name = MIDDLE_NAME_COLUMN_NAME ) public String getMiddleName ( ) { return middleName ; }
 public void AddCustomValue ( final String name , final String value ) { customValues . put ( name . toLowerCase ( ) , value ) ; }
 public AbstractType < T > valueComparator ( ) { return elements ; }
 public void setContactPhone ( final String contactPhone ) { this . contactPhone = contactPhone ; }
 @ Override public boolean locatePoint ( Point2D p , VisualItem item ) { Shape s = getShape ( item ) ; if ( s == null ) { return false ; } else { double width = Math . max ( 14 , getLineWidth ( item ) ) ; double halfWidth = width / 2.0 ; return s . intersects ( p . getX ( ) - halfWidth , p . getY ( ) - halfWidth , width , width ) ; } }
 void releaseBuckets ( ) { if ( buckets != null ) { longTable . returnAll ( Arrays . asList ( buckets ) ) ; buckets = null ; } }
 public void setup ( ) { city = " " ; destCity = " " ; cp5 = new ControlP5 ( this ) ; dfs = cp5 . addButton ( " DFS " ) . setPosition ( 2 * width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; bfs = cp5 . addButton ( " BFS " ) . setPosition ( 3 * width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; input = cp5 . addTextfield ( " input " ) . setPosition ( 0 , 00 ) . setSize ( 100 * multiplier , 20 * multiplier ) ; destination = cp5 . addTextfield ( " destination " ) . setPosition ( 0 , 40 ) . setSize ( 100 * multiplier , 20 * multiplier ) ; spainGraph = new SpainGraph ( this , multiplier ) ; sphero = new Sphero ( this , multiplier , spainGraph . getGuiNodes ( ) ) ; dijkstra = cp5 . addButton ( " Dijkstra " ) . setPosition ( width / 4 , 20 * multiplier ) . setSize ( 100 * multiplier , 20 * multiplier ) ; }
 public void setSuffix ( final String suffix ) { this . suffix = suffix ; }
 @ Override public void finalizeSnapshot ( SnapshotId snapshotId , ShardGenerations shardGenerations , long startTime , String failure , int totalShards , List < SnapshotShardFailure > shardFailures , long repositoryStateId , boolean includeGlobalState , Metadata clusterMetadata , boolean writeShardGens , ActionListener < SnapshotInfo > listener ) { listener . onResponse ( null ) ; }
 void clearAllMemory ( LazyMemorySegmentPool pool ) { if ( this . buildSideWriteBuffer != null ) { if ( this . buildSideWriteBuffer . getCurrentSegment ( ) != null ) { pool . returnPage ( this . buildSideWriteBuffer . getCurrentSegment ( ) ) ; } pool . returnAll ( this . buildSideWriteBuffer . targetList ) ; this . buildSideWriteBuffer . targetList . clear ( ) ; this . buildSideWriteBuffer = null ; } releaseBuckets ( ) ; if ( this . partitionBuffers != null ) { pool . returnAll ( Arrays . asList ( this . partitionBuffers ) ) ; this . partitionBuffers = null ; } try { if ( this . buildSideChannel != null ) { this . buildSideChannel . close ( ) ; this . buildSideChannel . deleteChannel ( ) ; } if ( this . probeSideBuffer != null ) { this . probeSideBuffer . getChannel ( ) . closeAndDelete ( ) ; this . probeSideBuffer = null ; } } catch ( IOException ioex ) { throw new RuntimeException ( " Error ▁ deleting ▁ the ▁ partition ▁ files . ▁ " + " Some ▁ temporary ▁ files ▁ might ▁ not ▁ be ▁ removed . " , ioex ) ; } }
 @ Test public void testPRMemLRU ( ) { doPRMemLRUTest ( ) ; }
 @ Override public boolean addAll ( Collection < ? extends Img > collection ) { boolean modified = collection != null && ! collection . isEmpty ( ) ; if ( modified ) { Iterator < ? extends Img > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { modified = modified && add ( iter . next ( ) ) ; } } return modified ; }
 public void setAddress ( final Address address ) { this . address = address ; }
 public EAttribute getTNotification_Name ( ) { return ( EAttribute ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
 if ( ce != null ) { if ( retryInfo != null ) { retryInfo . getMembers ( ) . addAll ( ce . getMembers ( ) ) ; retryInfo . getCauses ( ) . addAll ( ce . getCauses ( ) ) ; } else { retryInfo = ce ; } ce = null ; }
 public AppGraph getComponent ( ) { return component ; }
 @ Override @ FromAnyThread public void execute ( @ NotNull final EditorOperation operation ) { operationControl . execute ( operation ) ; }
 public NGuid getGlusterVolumeId ( ) { return glusterVolumeId ; }
 @ Override @ FxThread protected void storeCollapsed ( boolean collapsed ) { getConfig ( ) . setGlobalBottomToolCollapsed ( collapsed ) ; }
 public void test_getFormatSpecifier ( ) { String s = " MYTESTSTRING " ; MissingFormatWidthException missingFormatWidthException = new MissingFormatWidthException ( s ) ; assertEquals ( s , missingFormatWidthException . getFormatSpecifier ( ) ) ; }
 public int getLevelCount ( ) { for ( int i = generations . length - 1 ; i >= 0 ; i -- ) { if ( generations [ i ] . size ( ) > 0 ) return i ; } return 0 ; }
 public Builder addLibrary ( LibraryToLink library ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLibrary ( library ) ; return this ; }
 long getCurrentPointer ( ) { return ( ( ( long ) this . currentBlockNumber ) << segmentSizeBits ) + getCurrentPositionInSegment ( ) ; }
 @ Override public void prepareKeyspace ( ClientState state ) throws InvalidRequestException { if ( isColumnFamilyLevel ) super . prepareKeyspace ( state ) ; }
 public WebSocketProxyListenerBreak ( ExtensionWebSocket extension , BreakpointMessageHandler messageHandler ) { this . extension = extension ; this . wsBrkMessageHandler = messageHandler ; }
 public List < Linkstamp > getLinkstamps ( ) { return linkstamps ; }
 @ Test public void testFindingItemInArrayOfSmallSize ( ) throws Exception { assertThat ( getFinder ( ) . find ( 2 , 1 , 2 ) , is ( 1 ) ) ; assertThat ( getFinder ( ) . find ( 3 , 3 , 4 ) , is ( 0 ) ) ; }
 private void createRR ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setDiskSynchronous ( true ) ; attr . setDataPolicy ( DataPolicy . REPLICATE ) ; attr . setScope ( Scope . DISTRIBUTED_ACK ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUMemoryAttributes ( 1 , new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; Region region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
 private Map getContainer ( final Map map , @ NotNull final String name ) { return ( Map ) map . get ( name ) ; }
 @ JsonProperty ( " Code " ) public String getCode ( ) { return code ; }
 public EClass getDocumentRoot ( ) { return documentRootEClass ; }
 public long unsharedHeapSize ( ) { return EMPTY_SIZE ; }
 public EClass getTTasks ( ) { return tTasksEClass ; }
 private FormBody ( List < String > encodedNames , List < String > encodedValues ) { this . encodedNames = Util . immutableList ( encodedNames ) ; this . encodedValues = Util . immutableList ( encodedValues ) ; }
 public AndroidBinaryBaseRule ( AndroidNeverlinkAspect androidNeverlinkAspect , DexArchiveAspect dexArchiveAspect ) { this . androidNeverlinkAspect = androidNeverlinkAspect ; this . dexArchiveAspect = dexArchiveAspect ; }
 public EClass getTLogicalPeopleGroup ( ) { return tLogicalPeopleGroupEClass ; }
 @ JsonProperty ( " IsFlag " ) public void setIsFlag ( Boolean isFlag ) { this . isFlag = isFlag ; }
 final PartitionIterator newPartitionIterator ( ) { return new PartitionIterator ( ) ; }
 public EAttribute getDocumentRoot_Group ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
 @ Before public void setPartitioner ( ) { distributePartitioner = new RescalePartitioner < Tuple > ( ) ; }
 public boolean isBuiltinConstraint ( Class < ? extends Annotation > annotationType ) { return builtinConstraints . containsKey ( annotationType ) ; }
 public List < Artifact > getNonCodeInputs ( ) { return nonCodeInputs ; }
 @ Test public void testPRMemLRUDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , false , true , false ) ; }
 public CcLinkingContext ( NestedSet < LinkerInput > linkerInputs , @ Nullable ExtraLinkTimeLibraries extraLinkTimeLibraries ) { this . linkerInputs = linkerInputs ; this . extraLinkTimeLibraries = extraLinkTimeLibraries ; }
 @ Override default T call ( ) { return execute ( ) ; }
 @ Override public void endVerification ( String verificationToken ) { }
 public int getFirst ( ) { return first ; }
 public ProductColorJsonModel ( String code , String description , String displayName , List < CodeValueGroupJsonModel > codeValueGroups ) { this . code = code ; this . description = description ; this . displayName = displayName ; this . codeValueGroups = codeValueGroups ; }
 public synchronized void disconnect ( Exception cause ) { this . disconnected = true ; this . disconnectCompleted = false ; this . conduit . stop ( cause ) ; this . disconnectCompleted = true ; }
 public EAttribute getTPeopleAssignments_GenericHumanRole ( ) { return ( EAttribute ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 private InetAddress initAddress ( DistributionConfig dc ) { String bindAddress = dc . getBindAddress ( ) ; try { if ( bindAddress != null && bindAddress . length ( ) > 0 ) { return InetAddress . getByName ( bindAddress ) ; } else { return LocalHostUtil . getLocalHost ( ) ; } } catch ( java . net . UnknownHostException unhe ) { throw new RuntimeException ( unhe ) ; } }
 @ Override public boolean setBlockIDWithMetadata ( int x , int y , int z , Block block , int meta ) { if ( super . setBlockIDWithMetadata ( x , y , z , block , meta ) ) { sendQueue . add ( new ChunkPosition ( x , y , z ) ) ; return true ; } return false ; }
 protected void setVmTemplateName ( final String value ) { mVmTemplateName = value ; }
 public EReference getTNotification_Renderings ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
 public EReference getDocumentRoot_Task ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 17 ) ; }
 @ XmlElement @ Column ( name = SUFFIX_COLUMN_NAME ) public String getSuffix ( ) { return suffix ; }
 @ Override public Context accept ( final IContextVisitor visitor ) { return visitor . visit ( this ) ; }
 @ Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { return setOrListToJsonString ( buffer , elements , protocolVersion ) ; }
 public FilterPump ( Configuration configuration ) throws IOException { classLog . trace ( " Constructing ▁ FilterPump ▁ with ▁ config ▁ class ▁ " + configuration . getClass ( ) ) ; chainName = configuration . getString ( Filter . CONF_FILTER_NAME , chainName ) ; classLog . trace ( " Creating ▁ chain ▁ log ▁ for ▁ chain : ▁ " + chainName ) ; log = LogFactory . getLog ( FilterPump . class . getName ( ) + " # " + chainName ) ; log . info ( " Constructing ▁ FilterPump ▁ for ▁ chain ▁ ' " + chainName + " ' " ) ; sequence = new FilterSequence ( configuration ) ; everyStatus = configuration . getInt ( CONF_STATUS_EVERY , DEFAULT_STATUS_EVERY ) ; log . debug ( " Constructed ▁ filter ▁ sequence " ) ; }
 protected NetworkDAO getNetworkDAO ( ) { return getDbFacade ( ) . getNetworkDAO ( ) ; }
 public RowIndexEntry < IndexHelper . IndexInfo > deserialize ( DataInputPlus in ) throws IOException { if ( ! version . storeRows ( ) ) { long position = in . readLong ( ) ; int size = in . readInt ( ) ; if ( size > 0 ) { DeletionTime deletionTime = DeletionTime . serializer . deserialize ( in ) ; int entries = in . readInt ( ) ; List < IndexHelper . IndexInfo > columnsIndex = new ArrayList < > ( entries ) ; long headerLength = 0L ; for ( int i = 0 ; i < entries ; i ++ ) { IndexHelper . IndexInfo info = idxSerializer . deserialize ( in ) ; columnsIndex . add ( info ) ; if ( i == 0 ) headerLength = info . offset ; } return new IndexedEntry ( position , deletionTime , headerLength , columnsIndex ) ; } else { return new RowIndexEntry < > ( position ) ; } } long position = in . readUnsignedVInt ( ) ; int size = ( int ) in . readUnsignedVInt ( ) ; if ( size > 0 ) { long headerLength = in . readUnsignedVInt ( ) ; DeletionTime deletionTime = DeletionTime . serializer . deserialize ( in ) ; int entries = ( int ) in . readUnsignedVInt ( ) ; List < IndexHelper . IndexInfo > columnsIndex = new ArrayList < > ( entries ) ; for ( int i = 0 ; i < entries ; i ++ ) columnsIndex . add ( idxSerializer . deserialize ( in ) ) ; FileUtils . skipBytesFully ( in , entries * TypeSizes . sizeof ( 0 ) ) ; return new IndexedEntry ( position , deletionTime , headerLength , columnsIndex ) ; } else { return new RowIndexEntry < > ( position ) ; } }
 @ Override public boolean advanceNext ( ) { try { checkReadAdvance ( ) ; int pos = getCurrentPositionInSegment ( ) ; this . currentPointer = ( ( ( long ) currentBufferNum ) << segmentSizeBits ) + pos ; long addrAndLen = getCurrentSegment ( ) . getLong ( pos ) ; skipBytesToRead ( 8 ) ; buildSideSerializer . pointTo ( toLength ( addrAndLen ) , reuse , LongHashPartition . this ) ; return true ; } catch ( EOFException e ) { return false ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
 public EClass getTEscalation ( ) { return tEscalationEClass ; }
 public EAttribute getTParameter_Type ( ) { return ( EAttribute ) tParameterEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 protected void setQuota ( final Quota value ) { quota = value ; quotaName = null ; }
 public EReference getTLogicalPeopleGroups_LogicalPeopleGroup ( ) { return ( EReference ) tLogicalPeopleGroupsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EAttribute getTExpression_Mixed ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Before public void startBroker ( ) throws Exception { broker = createBroker ( ) ; TransportConnector connector = broker . addConnector ( " tcp : // 0.0.0.0:0" ) ; broker . deleteAllMessages ( ) ; broker . start ( ) ; broker . waitUntilStarted ( ) ; PolicyEntry policy = new PolicyEntry ( ) ; policy . setMaxBrowsePageSize ( browserLimit ) ; broker . setDestinationPolicy ( new PolicyMap ( ) ) ; broker . getDestinationPolicy ( ) . setDefaultEntry ( policy ) ; connectUri = connector . getConnectUri ( ) ; factory = new ActiveMQConnectionFactory ( connectUri ) ; }
 @ Test public void verifyCQPermissions ( ) throws Exception { String query = " select ▁ * ▁ from ▁ / AuthRegion " ; int serverPort = server . getPort ( ) ; client1 = cluster . startClientVM ( 1 , c2 -> c2 . withCredential ( " test " , " test " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client2 = cluster . startClientVM ( 2 , c1 -> c1 . withCredential ( " clusterManageQuery " , " clusterManageQuery " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client3 = cluster . startClientVM ( 3 , c -> c . withCredential ( " clusterManageQuery , dataRead " , " clusterManageQuery , dataRead " ) . withPoolSubscription ( true ) . withServerConnection ( serverPort ) ) ; client1 . invoke ( ( ) -> { final Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; assertNotAuthorized ( cq :: execute , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( cq :: executeWithInitialResults , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( qs :: getAllDurableCqsFromServer , " CLUSTER : READ " ) ; } ) ; client2 . invoke ( ( ) -> { final Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; assertNotAuthorized ( cq :: execute , " DATA : READ : AuthRegion " ) ; assertNotAuthorized ( cq :: executeWithInitialResults , " DATA : READ : AuthRegion " ) ; cq . close ( ) ; } ) ; client3 . invoke ( ( ) -> { Region region = ClusterStartupRule . clientCacheRule . createProxyRegion ( REGION_NAME ) ; Pool pool = PoolManager . find ( region ) ; QueryService qs = pool . getQueryService ( ) ; CqAttributes cqa = new CqAttributesFactory ( ) . create ( ) ; CqQuery cq = qs . newCq ( " CQ1" , query , cqa ) ; cq . execute ( ) ; cq . stop ( ) ; } ) ; }
 @ Override public Sequence < String > getStarlarkUserLinkFlags ( ) { return StarlarkList . immutableCopyOf ( getUserLinkFlags ( ) . stream ( ) . map ( LinkOptions :: get ) . flatMap ( Collection :: stream ) . collect ( ImmutableList . toImmutableList ( ) ) ) ; }
 @ Override public String getName ( ) { return this . name ; }
 @ Test public void testPRListener ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; addListener ( vm0 ) ; addListener ( vm1 ) ; doListenerTestPR ( vm0 , vm1 ) ; }
 @ Override @ FxThread protected double getSceneSize ( ) { var height = scene . getHeight ( ) ; return Double . compare ( height , 0D ) == 0 ? scene . getHeight ( ) : height ; }
 @ JsonProperty ( " CriteriaLevelCode " ) public void setCriteriaLevelCode ( String criteriaLevelCode ) { this . criteriaLevelCode = criteriaLevelCode ; }
 @ InitBinder ( " form " ) public void requestValidator ( WebDataBinder binder ) { binder . setValidator ( editTopicRequestValidator ) ; binder . setBindingErrorProcessor ( new ExceptionBindingErrorProcessor ( ) ) ; }
 public void serialize ( EncodingStats stats , DataOutputPlus out ) throws IOException { out . writeUnsignedVInt ( stats . minTimestamp - TIMESTAMP_EPOCH ) ; out . writeUnsignedVInt ( stats . minLocalDeletionTime - DELETION_TIME_EPOCH ) ; out . writeUnsignedVInt ( stats . minTTL - TTL_EPOCH ) ; }
 @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ base " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( BaseRuleClasses . RuleBase . class ) . build ( ) ; }
 @ Override public Statement . Kind kind ( ) { return Statement . Kind . FLOW ; }
 public int getBoundTerms ( ) { return 0 ; }
 public AuditLogableBase ( ) { }
 public EAttribute getDocumentRoot_Mixed ( ) { return ( EAttribute ) documentRootEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 private synchronized void sendBackToL0 ( SSTableReader sstable ) { remove ( sstable ) ; String metaDataFile = sstable . descriptor . filenameFor ( Component . STATS ) ; try { mutateLevel ( sstable . getSSTableMetadata ( ) , sstable . descriptor , metaDataFile , 0 ) ; sstable . reloadSSTableMetadata ( ) ; add ( sstable ) ; } catch ( IOException e ) { throw new RuntimeException ( " Could ▁ not ▁ reload ▁ sstable ▁ meta ▁ data " , e ) ; } }
 public EReference getDocumentRoot_PeopleAssignments ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 13 ) ; }
 public EReference getTPeopleAssignments_TaskInitiator ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 public YoggException ( Throwable cause ) { super ( cause ) ; }
 @ Override public void deleteSnapshot ( SnapshotId snapshotId , long repositoryStateId , boolean writeShardGens , ActionListener < Void > listener ) { }
 ) protected void runMethod ( ) { log . debug ( " Running ▁ FilterChain ▁ ' " + chainName + " ' " ) ; Profiler profiler = new Profiler ( ) ; profiler . setBpsSpan ( 1000 ) ; Payload pumped ; try { long startTime ; while ( getStatus ( ) == STATUS . running ) { startTime = System . nanoTime ( ) ; if ( ! sequence . hasNext ( ) ) { profiler . beat ( ) ; log . info ( String . format ( " Finished ▁ pumping ▁ ' % s ' ▁ % d ▁ times ▁ in ▁ % s , ▁ overall ▁ average ▁ speed ▁ was ▁ % s ▁ pumps / sec " , chainName , profiler . getBeats ( ) , profiler . getSpendTime ( ) , profiler . getBps ( false ) ) ) ; break ; } pumped = sequence . next ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " Pump ▁ received ▁ ▁ " + ( pumped . getRecord ( ) == null ? pumped : pumped . getRecord ( ) ) ) ; } profiler . beat ( ) ; logStatistics ( profiler , startTime , pumped ) ; } } catch ( Throwable t ) { String error = " Throwable ▁ caught ▁ running ▁ FilterPump " ; log . error ( error , t ) ; setError ( error , t ) ; } log . debug ( " Finished ▁ run ▁ with ▁ status ▁ " + getStatus ( ) ) ; if ( STATUS . error == getStatus ( ) ) { log . warn ( " The ▁ run ▁ was ▁ finished ▁ with ▁ error ▁ ' " + getErrorMessage ( ) , getErrorCause ( ) ) ; } else { log . debug ( " No ▁ error ▁ in ▁ run , ▁ calling ▁ close ( true ) " ) ; } close ( true ) ; }
 @ Test public void testPRMemLRUAndFlagDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , false , false , true ) ; }
 public boolean isOpen ( ) { return ! disconnectCompleted ; }
 public EAttribute getTExtensibleMixedContentElements_AnyAttribute ( ) { return ( EAttribute ) tExtensibleMixedContentElementsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 LongHashPartition ( LongHybridHashTable longTable , BinaryRowDataSerializer buildSideSerializer , MemorySegment [ ] partitionBuffers ) { super ( 0 ) ; this . longTable = longTable ; this . buildSideSerializer = buildSideSerializer ; this . buildReuseRow = buildSideSerializer . createInstance ( ) ; this . segmentSize = longTable . pageSize ( ) ; Preconditions . checkArgument ( segmentSize % 16 == 0 ) ; this . partitionBuffers = partitionBuffers ; this . segmentSizeBits = MathUtils . log2strict ( segmentSize ) ; this . segmentSizeMask = segmentSize - 1 ; this . finalBufferLimit = segmentSize ; this . iterator = new MatchIterator ( ) ; }
 public EAttribute getTDelegation_PotentialDelegatees ( ) { return ( EAttribute ) tDelegationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public Circuit create_circuit ( State [ ] operands ) throws Exception { if ( operands . length == 1 ) { return new OR_L_1 ( operands [ 0 ] . getWidth ( ) ) ; } else { return new OR_2L_L ( operands [ 0 ] . getWidth ( ) ) ; } }
 @ Override public Depset getLinkstampsForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return Depset . of ( Linkstamp . TYPE , getLinkstamps ( ) ) ; }
 public Serializer ( CFMetaData metadata , Version version , SerializationHeader header ) { this . idxSerializer = new IndexHelper . IndexInfo . Serializer ( metadata , version , header ) ; this . version = version ; }
 public void setGlusterVolumeName ( String value ) { glusterVolumeName = value ; }
 if ( ! directReply && directMsg != null ) { directMsg . registerProcessor ( ) ; }
 @ Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " userLinkFlags " , userLinkFlags ) . add ( " linkstamps " , linkstamps ) . add ( " libraries " , libraries ) . add ( " nonCodeInputs " , nonCodeInputs ) . toString ( ) ; }
 public void setQuotaId ( final Guid value ) { quotaId = value ; }
 public EReference getDocumentRoot_HumanInteractions ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
 public void emergencyClose ( ) { this . conduit . emergencyClose ( ) ; }
 public ConstraintHelper ( ) { List < Class < ? extends ConstraintValidator < ? , ? > > > constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( AssertFalseValidator . class ) ; builtinConstraints . put ( AssertFalse . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( AssertTrueValidator . class ) ; builtinConstraints . put ( AssertTrue . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DecimalMaxValidatorForNumber . class ) ; constraintList . add ( DecimalMaxValidatorForString . class ) ; builtinConstraints . put ( DecimalMax . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DecimalMinValidatorForNumber . class ) ; constraintList . add ( DecimalMinValidatorForString . class ) ; builtinConstraints . put ( DecimalMin . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( DigitsValidatorForString . class ) ; constraintList . add ( DigitsValidatorForNumber . class ) ; builtinConstraints . put ( Digits . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( FutureValidatorForCalendar . class ) ; constraintList . add ( FutureValidatorForDate . class ) ; if ( isJodaTimeInClasspath ( ) ) { constraintList . add ( FutureValidatorForAbstractInstant . class ) ; constraintList . add ( FutureValidatorForAbstractPartial . class ) ; } builtinConstraints . put ( Future . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( MaxValidatorForNumber . class ) ; constraintList . add ( MaxValidatorForString . class ) ; builtinConstraints . put ( Max . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( MinValidatorForNumber . class ) ; constraintList . add ( MinValidatorForString . class ) ; builtinConstraints . put ( Min . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( NotNullValidator . class ) ; builtinConstraints . put ( NotNull . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( NullValidator . class ) ; builtinConstraints . put ( Null . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( PastValidatorForCalendar . class ) ; constraintList . add ( PastValidatorForDate . class ) ; if ( isJodaTimeInClasspath ( ) ) { constraintList . add ( PastValidatorForAbstractInstant . class ) ; constraintList . add ( PastValidatorForAbstractPartial . class ) ; } builtinConstraints . put ( Past . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( PatternValidator . class ) ; builtinConstraints . put ( Pattern . class , constraintList ) ; constraintList = new ArrayList < Class < ? extends ConstraintValidator < ? , ? > > > ( ) ; constraintList . add ( SizeValidatorForString . class ) ; constraintList . add ( SizeValidatorForCollection . class ) ; constraintList . add ( SizeValidatorForArray . class ) ; constraintList . add ( SizeValidatorForMap . class ) ; constraintList . add ( SizeValidatorForArraysOfBoolean . class ) ; constraintList . add ( SizeValidatorForArraysOfByte . class ) ; constraintList . add ( SizeValidatorForArraysOfChar . class ) ; constraintList . add ( SizeValidatorForArraysOfDouble . class ) ; constraintList . add ( SizeValidatorForArraysOfFloat . class ) ; constraintList . add ( SizeValidatorForArraysOfInt . class ) ; constraintList . add ( SizeValidatorForArraysOfLong . class ) ; builtinConstraints . put ( Size . class , constraintList ) ; }
 public void setDisplayName ( String displayName ) { this . displayName = displayName ; }
 public EReference getDocumentRoot_Notifications ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 11 ) ; }
 public String getCorrelationId ( ) { return correlationId ; }
 public int circuit_id ( State [ ] operands ) { int id = operands [ 0 ] . getWidth ( ) ; if ( operands . length == 1 ) return - id ; else return id ; }
 public void monodroidClearReferences ( ) { if ( refList != null ) refList . clear ( ) ; }
 @ Override protected int getLimitForSegment ( MemorySegment segment ) { return segment == partitionBuffers [ partitionBuffers . length - 1 ] ? finalBufferLimit : segmentSize ; }
 protected AbstractHandler ( @ Nonnull GatewayRetriever < ? extends T > leaderRetriever , @ Nonnull Time timeout , @ Nonnull Map < String , String > responseHeaders , @ Nonnull UntypedResponseMessageHeaders < R , M > untypedResponseMessageHeaders ) { super ( leaderRetriever , timeout , responseHeaders ) ; this . untypedResponseMessageHeaders = Preconditions . checkNotNull ( untypedResponseMessageHeaders ) ; this . inFlightRequestTracker = new InFlightRequestTracker ( ) ; }
 @ Override public boolean onMessageFrame ( int channelId , WebSocketMessage wsMessage ) { boolean continueNotifying = false ; WebSocketMessageDTO message = wsMessage . getDTO ( ) ; if ( ! extension . isSafe ( message ) ) { return true ; } if ( ! wsMessage . isFinished ( ) ) { boolean isRequest = ( wsMessage . getDirection ( ) . equals ( Direction . OUTGOING ) ) ; if ( wsBrkMessageHandler . isBreakpoint ( message , isRequest , false ) ) { continueNotifying = false ; } else { continueNotifying = true ; } return continueNotifying ; } if ( message . isOutgoing ) { if ( wsBrkMessageHandler . handleMessageReceivedFromClient ( message , false ) ) { setPayload ( wsMessage , message . payload ) ; continueNotifying = true ; } } else { if ( wsBrkMessageHandler . handleMessageReceivedFromServer ( message , false ) ) { setPayload ( wsMessage , message . payload ) ; continueNotifying = true ; } } return continueNotifying ; }
 public EAttribute getTImport_Location ( ) { return ( EAttribute ) tImportEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public EAttribute getTRendering_Type ( ) { return ( EAttribute ) tRenderingEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EClass getTExpression ( ) { return tExpressionEClass ; }
 @ Override public String getDisplayName ( ) { return TextHelper . formatHF ( " structures . demolish " , building . getLocalisedName ( ) ) ; }
 @ Test public void testExportImport ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 , 2 ) ; journal . forceMoveNextFile ( ) ; delete ( 1 , 2 ) ; add ( 3 , 4 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 6 , 7 , 8 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 9 ) ; commit ( 5 ) ; journal . forceMoveNextFile ( ) ; deleteTx ( 10 , 6 , 7 , 8 , 9 ) ; commit ( 10 ) ; addTx ( 11 , 11 , 12 ) ; updateTx ( 11 , 11 , 12 ) ; commit ( 11 ) ; journal . forceMoveNextFile ( ) ; update ( 11 , 12 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
 public void serialize ( RowIndexEntry < IndexHelper . IndexInfo > rie , DataOutputPlus out ) throws IOException { assert version . storeRows ( ) : " We ▁ read ▁ old ▁ index ▁ files ▁ but ▁ we ▁ should ▁ never ▁ write ▁ them " ; out . writeUnsignedVInt ( rie . position ) ; out . writeUnsignedVInt ( rie . promotedSize ( idxSerializer ) ) ; if ( rie . isIndexed ( ) ) { out . writeUnsignedVInt ( rie . headerLength ( ) ) ; DeletionTime . serializer . serialize ( rie . deletionTime ( ) , out ) ; out . writeUnsignedVInt ( rie . columnsIndex ( ) . size ( ) ) ; int [ ] offsets = new int [ rie . columnsIndex ( ) . size ( ) ] ; if ( out . hasPosition ( ) ) { long start = out . position ( ) ; int i = 0 ; for ( IndexHelper . IndexInfo info : rie . columnsIndex ( ) ) { offsets [ i ] = i == 0 ? 0 : ( int ) ( out . position ( ) - start ) ; i ++ ; idxSerializer . serialize ( info , out ) ; } } else { int i = 0 ; int offset = 0 ; for ( IndexHelper . IndexInfo info : rie . columnsIndex ( ) ) { offsets [ i ++ ] = offset ; idxSerializer . serialize ( info , out ) ; offset += idxSerializer . serializedSize ( info ) ; } } for ( int off : offsets ) out . writeInt ( off ) ; } }
 public int serializedSize ( EncodingStats stats ) { return TypeSizes . sizeofUnsignedVInt ( stats . minTimestamp - TIMESTAMP_EPOCH ) + TypeSizes . sizeofUnsignedVInt ( stats . minLocalDeletionTime - DELETION_TIME_EPOCH ) + TypeSizes . sizeofUnsignedVInt ( stats . minTTL - TTL_EPOCH ) ; }
 final boolean onDataChanged ( SqlTable < ? > table , SquidDatabase database , DBOperation operation , AbstractModel modelValues , long rowId ) { if ( ! enabled ) { return false ; } return accumulateNotificationObjects ( notifyObjectAccumulator . get ( ) , table , database , operation , modelValues , rowId ) ; }
 @ Override public Sequence < Artifact > getStarlarkNonCodeInputs ( ) { return StarlarkList . immutableCopyOf ( getNonCodeInputs ( ) ) ; }
 public PropertyDescriptorImpl ( Type returnType , String propertyName , Set < ConstraintDescriptorImpl < ? > > constraints , boolean cascaded , boolean defaultGroupSequenceRedefined , List < Class < ? > > defaultGroupSequence , Set < GroupConversionDescriptor > groupConversions ) { super ( returnType , constraints , defaultGroupSequenceRedefined , defaultGroupSequence ) ; this . property = propertyName ; this . cascaded = cascaded ; this . groupConversions = Collections . unmodifiableSet ( groupConversions ) ; }
 @ Override public boolean verify ( String hostname , SSLSession ses ) { return true ; }
 public EReference getTEscalation_LocalNotification ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 public EReference getDocumentRoot_BusinessAdministrators ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 public void setSalutation ( final String salutation ) { this . salutation = salutation ; }
 @ Override public List < InterpreterCompletion > completion ( String buf , int cursor , InterpreterContext interpreterContext ) { return null ; }
 public String getVmName ( ) { if ( mVmName == null && getVm ( ) != null ) { mVmName = getVm ( ) . getvm_name ( ) ; } return mVmName ; }
 @ Override public long getLastEndTime ( ) { return 0 ; }
 @ Test public void test0001 ( ) { TestResource . testExpression ( " DN - 21-0010" , " $ { true ▁ & & ▁ false } " , " false " ) ; }
 @ Test public void testFindingItemThatIsNotThere ( ) throws Exception { assertThat ( getFinder ( ) . find ( - 1 , 1 , 2 , 3 , 4 ) , is ( - 1 ) ) ; }
 @ Override public boolean canDo ( @ Nonnull World world , @ Nonnull EntityPlayer player , int amount ) { return amount == 1 && TownHelper . getClosestTownToEntity ( player , false ) . hasBuilding ( building ) ; }
 @ FxThread protected @ Nullable Supplier < EditorState > getEditorStateFactory ( ) { return null ; }
 private void updateIndex ( long key , int hashCode , long address , int size , MemorySegment dataSegment , int currentPositionInSegment ) throws IOException { assert ( numKeys <= numBuckets / 2 ) ; int bucketId = findBucket ( hashCode ) ; int bucketOffset = bucketId * SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES ; MemorySegment segment = buckets [ bucketOffset >>> segmentSizeBits ] ; int segOffset = bucketOffset & segmentSizeMask ; long currAddress ; while ( true ) { currAddress = segment . getLong ( segOffset + 8 ) ; if ( segment . getLong ( segOffset ) != key && currAddress != INVALID_ADDRESS ) { bucketId = ( bucketId + 1 ) & numBucketsMask ; if ( segOffset + SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES < segmentSize ) { segOffset += SPARSE_BUCKET_ELEMENT_SIZE_IN_BYTES ; } else { bucketOffset = bucketId * 16 ; segment = buckets [ bucketOffset >>> segmentSizeBits ] ; segOffset = bucketOffset & segmentSizeMask ; } } else { break ; } } if ( currAddress == INVALID_ADDRESS ) { segment . putLong ( segOffset , key ) ; segment . putLong ( segOffset + 8 , address ) ; numKeys += 1 ; if ( dataSegment != null ) { dataSegment . putLong ( currentPositionInSegment , toAddrAndLen ( INVALID_ADDRESS , size ) ) ; } if ( numKeys * 2 > numBuckets ) { resize ( ) ; } } else { dataSegment . putLong ( currentPositionInSegment , toAddrAndLen ( currAddress , size ) ) ; segment . putLong ( segOffset + 8 , address ) ; } }
 synchronized ( Event . class ) { EVENT_TYPE = new EventType < > ( SceneEvent . EVENT_TYPE , AssetComponentLoadedEvent . class . getSimpleName ( ) ) ; }
 @ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( ! ( obj instanceof LinkOptions ) ) { return false ; } LinkOptions that = ( LinkOptions ) obj ; if ( ! this . symbolForEquality . equals ( that . symbolForEquality ) ) { return false ; } if ( this . linkOptions . equals ( that . linkOptions ) ) { return true ; } BugReport . sendBugReport ( new IllegalStateException ( " Unexpected ▁ inequality ▁ with ▁ equal ▁ symbols : ▁ " + this + " , ▁ " + that ) ) ; return false ; }
 catch ( NoSuchMethodException e ) { throw withCause ( new AssertionError ( " Object ▁ class ▁ does ▁ not ▁ have ▁ empty ▁ constructor ▁ ( is ▁ JDK ▁ corrupted ? ) . " ) , e ) ; }
 private void doRRMemLRUDeltaTest ( boolean shouldSizeChange ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; createRR ( vm0 ) ; createRR ( vm1 ) ; TestDelta delta1 = new TestDelta ( false , "12345" ) ; put ( vm0 , " a " , delta1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_SERIALIZED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; put ( vm0 , " a " , delta1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 5 , finalEvictionSize0 - origEvictionSize0 ) ; if ( shouldSizeChange ) { assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertTrue ( finalEvictionSize1 - origEvictionSize1 != 0 ) ; } else { assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 0 , finalEvictionSize1 - origEvictionSize1 ) ; } }
 private void handleAckTimeout ( long ackTimeout , long ackSATimeout , Connection c , DirectReplyProcessor processor ) throws ConnectionException { Set activeMembers = dm . getDistributionManagerIds ( ) ; dm . getStats ( ) . incReplyTimeouts ( ) ; { String msg = " % s ▁ seconds ▁ have ▁ elapsed ▁ while ▁ waiting ▁ for ▁ reply ▁ from ▁ % s ▁ on ▁ % s ▁ whose ▁ current ▁ membership ▁ list ▁ is : ▁ [ % s ] " ; final Object [ ] msgArgs = new Object [ ] { Long . valueOf ( ackTimeout / 1000 ) , c . getRemoteAddress ( ) , dm . getId ( ) , activeMembers } ; logger . warn ( String . format ( msg , msgArgs ) ) ; msgArgs [ 3 ] = " ( omitted ) " ; Breadcrumbs . setProblem ( msg , msgArgs ) ; if ( ReplyProcessor21 . THROW_EXCEPTION_ON_TIMEOUT ) { TimeoutException cause = new TimeoutException ( " Timed ▁ out ▁ waiting ▁ for ▁ ACKS . " ) ; throw new InternalGemFireException ( String . format ( msg , msgArgs ) , cause ) ; } } if ( activeMembers . contains ( c . getRemoteAddress ( ) ) ) { if ( ackSATimeout > 0 ) { try { c . readAck ( processor ) ; return ; } catch ( SocketTimeoutException e ) { Object [ ] args = new Object [ ] { Long . valueOf ( ( ackSATimeout + ackTimeout ) / 1000 ) , c . getRemoteAddress ( ) , dm . getId ( ) , activeMembers } ; logger . fatal ( " { } ▁ seconds ▁ have ▁ elapsed ▁ while ▁ waiting ▁ for ▁ reply ▁ from ▁ { } ▁ on ▁ { } ▁ whose ▁ currentFull ▁ membership ▁ list ▁ is : ▁ [ { } ] " , args ) ; } } try { c . readAck ( processor ) ; } catch ( SocketTimeoutException ex ) { logger . error ( String . format ( " Unexpected ▁ timeout ▁ while ▁ waiting ▁ for ▁ ack ▁ from ▁ % s " , c . getRemoteAddress ( ) ) , ex ) ; } } else { logger . warn ( " View ▁ no ▁ longer ▁ has ▁ { } ▁ as ▁ an ▁ active ▁ member , ▁ so ▁ we ▁ will ▁ no ▁ longer ▁ wait ▁ for ▁ it . " , c . getRemoteAddress ( ) ) ; processor . memberDeparted ( getDM ( ) , c . getRemoteAddress ( ) , true ) ; } }
 public String toString ( ) { String outputString = " " ; return super . toString ( ) + " [ " + " semiMajorAxis " + " : " + getSemiMajorAxis ( ) + " ] " + outputString ; }
 @ JsonProperty ( " CriteriaGroupCode " ) public String getCriteriaGroupCode ( ) { return criteriaGroupCode ; }
 public EllipticalShape ( String aCenter , String aSemiMajorAxis ) { super ( aCenter ) ; semiMajorAxis = aSemiMajorAxis ; }
 public boolean includes ( ColumnMetadata column ) { return columnsToFetch == null || columnsToFetch . fetches ( column ) ; }
 public void toData ( DataOutput out ) throws IOException { out . writeInt ( sizeForSizer ) ; out . writeInt ( sizeForSerialization ) ; out . write ( new byte [ sizeForSerialization ] ) ; }
 public ArrayImageList ( ) { this ( null ) ; }
 @ Override public RuleClass build ( RuleClass . Builder builder , final RuleDefinitionEnvironment env ) { return builder . add ( attr ( " manifest " , LABEL ) . allowedFileTypes ( FileType . of ( " . xml " ) ) ) . add ( attr ( " resource _ files " , LABEL_LIST ) . allowedFileTypes ( FileTypeSet . ANY_FILE ) ) . add ( attr ( " assets _ dir " , STRING ) ) . add ( attr ( " assets " , LABEL_LIST ) . allowedFileTypes ( FileTypeSet . ANY_FILE ) ) . add ( attr ( " inline _ constants " , BOOLEAN ) . undocumented ( " deprecated ▁ noop ▁ on ▁ library " ) . value ( false ) ) . add ( attr ( " custom _ package " , STRING ) ) . add ( attr ( " enable _ data _ binding " , Type . BOOLEAN ) ) . add ( attr ( DataBinding . DATABINDING_ANNOTATION_PROCESSOR_ATTR , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( env . getToolsLabel ( " // tools / android : databinding _ annotation _ processor " ) ) ) . add ( attr ( DataBinding . DATABINDING_EXEC_PROCESSOR_ATTR , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : databinding _ exec " ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( AndroidResourcesInfo . PROVIDER . getKey ( ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( AndroidNativeLibsInfo . PROVIDER . getKey ( ) ) ) . build ( ) ; }
 public SheetProcessor ( ParameterVault parameterVault , CountDownLatch startSignal , CountDownLatch doneSignal , CellStyle cs , SXSSFSheet sheet , int columnCount , Map < Integer , Input2TableInfo > input2TableInfoMap , OutputWriterHolder outputWriterHolder ) { this . parameterVault = parameterVault ; this . startSignal = startSignal ; this . doneSignal = doneSignal ; this . cs = cs ; this . sheet = sheet ; this . columnCount = columnCount ; this . input2TableInfoMap = input2TableInfoMap ; this . outputWriterHolder = outputWriterHolder ; }
 public AlignGatling ( ) { requires ( Robot . cannonSubsystem ) ; }
 public EAttribute getTLogicalPeopleGroup_Name ( ) { return ( EAttribute ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 @ Test public void testSelectChannelsInterval ( ) { sd . setInstance ( streamRecord ) ; assertEquals ( 0 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 2 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; assertEquals ( 0 , distributePartitioner . selectChannels ( sd , 3 ) [ 0 ] ) ; }
 protected Command getCompleteCreateRelationshipCommand ( CreateRelationshipRequest req ) { if ( EsbElementTypes . EsbLink_4001 == req . getElementType ( ) ) { return null ; } return null ; }
 @ JsonProperty ( " CriteriaGroupCode " ) public void setCriteriaGroupCode ( String criteriaGroupCode ) { this . criteriaGroupCode = criteriaGroupCode ; }
 private void createPRHeapLRU ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ pr " ) { public void run ( ) { Cache cache = getCache ( ) ; ResourceManager manager = cache . getResourceManager ( ) ; manager . setCriticalHeapPercentage ( 95 ) ; manager . setEvictionHeapPercentage ( 90 ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; PartitionAttributesFactory < Integer , TestDelta > paf = new PartitionAttributesFactory < Integer , TestDelta > ( ) ; paf . setRedundantCopies ( 1 ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUHeapAttributes ( new TestObjectSizer ( ) , EvictionAction . LOCAL_DESTROY ) ) ; PartitionAttributes < Integer , TestDelta > prAttr = paf . create ( ) ; attr . setPartitionAttributes ( prAttr ) ; attr . setDataPolicy ( DataPolicy . PARTITION ) ; attr . setSubscriptionAttributes ( new SubscriptionAttributes ( InterestPolicy . ALL ) ) ; Region < Integer , TestDelta > region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
 public void test_missingFormatWidthException ( ) { try { new MissingFormatWidthException ( null ) ; fail ( " should ▁ throw ▁ NullPointerExcepiton " ) ; } catch ( NullPointerException e ) { } }
 private ModelAndView prepareModel ( PreparedTopic preparedTopic , EditTopicRequest form , User currentUser , Profile profile ) throws PollNotFoundException { Map < String , Object > params = new HashMap < > ( ) ; final Topic message = preparedTopic . getMessage ( ) ; params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedTopic ) ; Group group = preparedTopic . getGroup ( ) ; params . put ( " group " , group ) ; params . put ( " groups " , groupDao . getGroups ( preparedTopic . getSection ( ) ) ) ; params . put ( " newMsg " , message ) ; TopicMenu topicMenu = prepareService . getTopicMenu ( preparedTopic , currentUser , profile , true ) ; params . put ( " topicMenu " , topicMenu ) ; List < EditHistoryRecord > editInfoList = editHistoryService . getEditInfo ( message . getId ( ) , EditHistoryObjectTypeEnum . TOPIC ) ; if ( ! editInfoList . isEmpty ( ) ) { params . put ( " editInfo " , editInfoList . get ( 0 ) ) ; ImmutableSet < User > editors = editHistoryService . getEditorUsers ( message , editInfoList ) ; form . setEditorBonus ( editors . stream ( ) . collect ( Collectors . toMap ( User :: getId , u -> 0 ) ) ) ; params . put ( " editors " , editors ) ; } params . put ( " commit " , false ) ; if ( group . isLinksAllowed ( ) ) { form . setLinktext ( message . getLinktext ( ) ) ; form . setUrl ( message . getUrl ( ) ) ; } form . setTitle ( StringEscapeUtils . unescapeHtml4 ( message . getTitle ( ) ) ) ; form . setMsg ( msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ) ; if ( message . getSectionId ( ) == Section . SECTION_NEWS ) { form . setMinor ( message . isMinor ( ) ) ; } if ( ! preparedTopic . getTags ( ) . isEmpty ( ) ) { form . setTags ( TagRef . names ( preparedTopic . getTags ( ) ) ) ; } if ( preparedTopic . getSection ( ) . isPollPostAllowed ( ) ) { Poll poll = pollDao . getPollByTopicId ( message . getId ( ) ) ; form . setPoll ( PollVariant . toMap ( poll . getVariants ( ) ) ) ; form . setMultiselect ( poll . isMultiSelect ( ) ) ; } params . put ( " imagepost " , permissionService . isImagePostingAllowed ( preparedTopic . getSection ( ) , currentUser ) ) ; return new ModelAndView ( " edit " , params ) ; }
 private List < SetterReturnObject > setDiseaseOutcome ( DiseaseOutcomeEnum outcome ) throws ApolloSetterException { DiseaseOutcomeSetter setter = new DiseaseOutcomeSetter ( apolloTranslationEngine , type + " . " + DISEASE_OUTCOME_FIELD , section ) ; return setter . set ( outcome ) ; }
 @ Override protected ItemStack getPurchasedStack ( ) { return building . getSpawner ( ) ; }
 public EReference getTHumanInteractions_Extensions ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Override public String toString ( ) { return " Manifest @ " + hashCode ( ) ; }
 protected Polygon updateArrowHead ( int w , int h , Association association , boolean isSelected ) { if ( isAggregation ( association ) ) { if ( m_arrowHead == null ) { m_arrowHead = new Polygon ( ) ; } else { m_arrowHead . reset ( ) ; } double ws = 0.9 ; double hs = 2.0 / 3.0 ; if ( isSelected ) { ws /= 1.3 ; hs /= 1.3 ; } m_arrowHead . addPoint ( 0 , 0 ) ; m_arrowHead . addPoint ( ( int ) ( ws * - w ) , ( int ) ( hs * ( - h ) ) ) ; m_arrowHead . addPoint ( 0 , ( int ) ( hs * ( - 2 * h ) ) ) ; m_arrowHead . addPoint ( ( int ) ( ws * w ) , ( int ) ( hs * ( - h ) ) ) ; m_arrowHead . addPoint ( 0 , 0 ) ; return m_arrowHead ; } else { return updateArrowHead ( w , h ) ; } }
 public boolean isIndexed ( ) { return ! columnsIndex ( ) . isEmpty ( ) ; }
 public Number getNumber ( ) { return this . number ; }
 public TestObject ( int sizeForSerialization , int sizeForSizer ) { super ( ) ; this . sizeForSizer = sizeForSizer ; this . sizeForSerialization = sizeForSerialization ; }
 public ReceiveTransitionsIntentService ( ) { super ( " ReceiveTransitionsIntentService " ) ; beepHelper = new BeepHelper ( ) ; store = new GeoNotificationStore ( this ) ; Logger . setLogger ( new Logger ( GeofencePlugin . TAG , this , false ) ) ; }
 public void AppendCustomValue ( final String name , final String value , final String separator ) { final String key = name . toLowerCase ( ) ; String newValue = value ; if ( customValues . containsKey ( key ) ) { newValue = String . format ( " % 1 $ s % 2 $ s % 3 $ s " , customValues . get ( key ) , separator , value ) ; } customValues . put ( name . toLowerCase ( ) , newValue ) ; }
 public List < Filter > getFilters ( ) { return sequence . getFilters ( ) ; }
 public void execute ( ) { HumanTaskServerConfiguration serverConfiguration = HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getServerConfig ( ) ; final SimpleQueryCriteria queryCriteria = createQueryCriteria ( serverConfiguration ) ; log . info ( " Running ▁ the ▁ task ▁ cleanup ▁ service . . . . . " ) ; try { HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getTaskEngine ( ) . getScheduler ( ) . execTransaction ( new Callable < Object > ( ) { public Object call ( ) throws Exception { HumanTaskDAOConnection daoConnection = HumanTaskCleanupSchedulerServiceComponent . getHumanTaskServer ( ) . getDaoConnectionFactory ( ) . getConnection ( ) ; daoConnection . removeTasks ( queryCriteria ) ; return null ; } } ) ; } catch ( Exception ex ) { String errMsg = " Task ▁ Cleanup ▁ operation ▁ failed ! ▁ : " ; log . error ( errMsg , ex ) ; throw new HumanTaskRuntimeException ( errMsg , ex ) ; } }
 @ XmlElement @ Column ( name = BUYER_MARKETING_EMAIL_COLUMN_NAME ) public String getBuyerMarketingEmail ( ) { return buyerMarketingEmail ; }
 private void templateReplace ( File srcFile , File dstFile , String moduleName ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( srcFile ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( dstFile ) ) ; String s ; while ( ( s = br . readLine ( ) ) != null ) { if ( s . indexOf ( MODULE_PATTERN_NAME ) != - 1 ) { s = s . replaceAll ( MODULE_PATTERN_NAME , moduleName ) ; } bw . write ( s ) ; bw . newLine ( ) ; } bw . close ( ) ; br . close ( ) ; }
 protected void setVds ( final VDS value ) { mVds = value ; mVdsName = null ; }
 public Builder addUserLinkFlags ( List < LinkOptions > userLinkFlags ) { hasDirectLinkerInput = true ; linkerInputBuilder . addUserLinkFlags ( userLinkFlags ) ; return this ; }
 private void createMsgsProperties ( String moduleName ) throws Exception { File dstFile = new File ( getDstDir ( moduleName ) , MSGS_PROPERTIES_NAME ) ; if ( dstFile . exists ( ) ) { return ; } FileInputStream fis = new FileInputStream ( MSGS_PROPERTIES_FILE ) ; FileOutputStream fos = new FileOutputStream ( dstFile ) ; byte [ ] data = new byte [ fis . available ( ) ] ; while ( fis . read ( data ) > 0 ) { fos . write ( data ) ; data = new byte [ fis . available ( ) ] ; } fis . close ( ) ; fos . close ( ) ; logMessage ( " \t " + dstFile . getAbsolutePath ( ) ) ; }
 if ( directReply && ! sentCons . isEmpty ( ) ) { long readAckStart = 0 ; if ( stats != null ) { readAckStart = stats . startReplyWait ( ) ; } try { ce = readAcks ( sentCons , startTime , ackTimeout , ackSDTimeout , ce , directMsg . getDirectReplyProcessor ( ) ) ; } finally { if ( stats != null ) { stats . endReplyWait ( readAckStart , startTime ) ; } } }
 private File [ ] getMyDiskDirs ( ) { long random = new Random ( ) . nextLong ( ) ; File file = new File ( Long . toString ( random ) ) ; file . mkdirs ( ) ; return new File [ ] { file } ; }
 public long getId ( ) { return id ; }
 public void generateSheetData ( ParameterVault parameterVault , CellStyle cs , SXSSFSheet sheet , int columnCount , Map < Integer , Input2TableInfo > hashMap ) { Cell cell ; int idx = 0 ; int idy = 0 ; Row row = sheet . createRow ( idx ) ; Input2TableInfo input2TableInfo ; for ( Integer key : hashMap . keySet ( ) ) { input2TableInfo = hashMap . get ( key ) ; cell = row . createCell ( idy ) ; cell . setCellValue ( input2TableInfo . getFieldText ( ) ) ; cell . setCellStyle ( cs ) ; sheet . setColumnWidth ( idy , ( input2TableInfo . getFieldText ( ) . trim ( ) . length ( ) * 500 ) ) ; idy ++ ; } ThreadLocalRandom randomGenerator = ThreadLocalRandom . current ( ) ; for ( int i = 1 ; i < parameterVault . rowCount ( ) + 1 ; i ++ ) { row = sheet . createRow ( i ) ; if ( i != 0 && i % 10000 == 0 ) { outputWriterHolder . writeValueInLine ( Thread . currentThread ( ) . getName ( ) + " ▁ Processed ▁ " + i + " ▁ rows " ) ; } for ( int colCount = 0 ; colCount < columnCount ; colCount ++ ) { final Cell dataCell = row . createCell ( colCount ) ; input2TableInfo = hashMap . get ( colCount ) ; final CellStyle cellStyle = input2TableInfo . getCellStyle ( ) ; input2TableInfo . generator ( ) . generate ( parameterVault . setIterationNumber ( i ) , randomGenerator , new ValueVault ( ) { @ Override public void storeValue ( DataWrapper wrapper ) { FieldType fieldType = wrapper . getFieldType ( ) ; switch ( fieldType ) { case DATE : dataCell . setCellValue ( wrapper . getDateValue ( ) ) ; dataCell . setCellStyle ( cellStyle ) ; break ; case FLOAT : case INTEGER : dataCell . setCellType ( Cell . CELL_TYPE_NUMERIC ) ; dataCell . setCellValue ( wrapper . getNumberValue ( ) ) ; break ; case AUTONUMBER : dataCell . setCellType ( Cell . CELL_TYPE_NUMERIC ) ; dataCell . setCellValue ( wrapper . getNumberValue ( ) ) ; case SEQUENCE : default : dataCell . setCellValue ( wrapper . getStringValue ( ) ) ; } } } ) ; } } }
 @ Override public void add ( int index , Img element ) { if ( element != null ) { array . insertAt ( index , element ) ; } }
 @ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + sizeForSerialization ; result = prime * result + sizeForSizer ; return result ; }
 public EAttribute getTQuery_QueryLanguage ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 public ControlMetricType metricType ( ) { return metricType ; }
 @ Override public final boolean equals ( final Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; DefaultPet other = ( DefaultPet ) obj ; return Objects . equals ( name , other . name ) ; }
 public EClass getTPresentationParameters ( ) { return tPresentationParametersEClass ; }
 private int getObjectSizerInvocations ( VM vm0 ) { return ( Integer ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getObjectSizerInvocations ( region ) ; } } ) ; }
 public Set < SqlTable < ? > > whichTables ( ) { return tables ; }
 @ Override public void stop ( ) { log . info ( " Stopping ▁ filter ▁ pump ▁ " + getChainName ( ) ) ; super . stop ( ) ; sequence . close ( true ) ; log . info ( String . format ( " Filter ▁ pump ▁ % s ▁ stopped " , getChainName ( ) ) ) ; }
 @ Override public ExtraLinkTimeLibraries getExtraLinkTimeLibrariesForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return getExtraLinkTimeLibraries ( ) ; }
 public void setDescricaoGeral ( String descricaoGeral ) { this . descricaoGeral = descricaoGeral ; }
 public void monodroidAddReference ( java . lang . Object obj ) { if ( refList == null ) refList = new java . util . ArrayList ( ) ; refList . add ( obj ) ; }
 private void checkWriteAdvance ( ) throws IOException { if ( shouldAdvance ( buildSideWriteBuffer . getSegmentSize ( ) - buildSideWriteBuffer . getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { buildSideWriteBuffer . advance ( ) ; } }
 public EReference getTFrom_Argument ( ) { return ( EReference ) tFromEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Override public long getNumForHandleData ( ) { return this . numForHandleData ; }
 @ Override public FormType getFormType ( ) { return FormType . SIMPLE ; }
 @ Override public Sequence < LibraryToLink > getStarlarkLibrariesToLink ( StarlarkSemantics semantics ) { return StarlarkList . immutableCopyOf ( getLibraries ( ) ) ; }
 protected void createExtendedMetaDataAnnotations ( ) { String source = " http : // / org / eclipse / emf / ecore / util / ExtendedMetaData " ; addAnnotation ( documentRootEClass , source , new String [ ] { " name " , " " , " kind " , " mixed " } ) ; addAnnotation ( getDocumentRoot_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getDocumentRoot_XMLNSPrefixMap ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " xmlns : prefix " } ) ; addAnnotation ( getDocumentRoot_XSISchemaLocation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " xsi : schemaLocation " } ) ; addAnnotation ( getDocumentRoot_BusinessAdministrators ( ) , source , new String [ ] { " kind " , " element " , " name " , " businessAdministrators " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_ExcludedOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " excludedOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Group ( ) , source , new String [ ] { " kind " , " element " , " name " , " group " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Groups ( ) , source , new String [ ] { " kind " , " element " , " name " , " groups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_HumanInteractions ( ) , source , new String [ ] { " kind " , " element " , " name " , " humanInteractions " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Import ( ) , source , new String [ ] { " kind " , " element " , " name " , " import " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_LogicalPeopleGroups ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Notifications ( ) , source , new String [ ] { " kind " , " element " , " name " , " notifications " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_OrganizationalEntity ( ) , source , new String [ ] { " kind " , " element " , " name " , " organizationalEntity " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Recipients ( ) , source , new String [ ] { " kind " , " element " , " name " , " recipients " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Task ( ) , source , new String [ ] { " kind " , " element " , " name " , " task " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_TaskInitiator ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskInitiator " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Tasks ( ) , source , new String [ ] { " kind " , " element " , " name " , " tasks " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_TaskStakeholders ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskStakeholders " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_User ( ) , source , new String [ ] { " kind " , " element " , " name " , " user " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getDocumentRoot_Users ( ) , source , new String [ ] { " kind " , " element " , " name " , " users " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tArgumentEClass , source , new String [ ] { " name " , " tArgument " , " kind " , " mixed " } ) ; addAnnotation ( getTArgument_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTArgument_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tBooleanEEnum , source , new String [ ] { " name " , " tBoolean " } ) ; addAnnotation ( tBooleanExprEClass , source , new String [ ] { " name " , " tBoolean - expr " , " kind " , " mixed " } ) ; addAnnotation ( tBooleanObjectEDataType , source , new String [ ] { " name " , " tBoolean : Object " , " baseType " , " tBoolean " } ) ; addAnnotation ( tDeadlineEClass , source , new String [ ] { " name " , " tDeadline " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDeadline_For ( ) , source , new String [ ] { " kind " , " element " , " name " , " for " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadline_Until ( ) , source , new String [ ] { " kind " , " element " , " name " , " until " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadline_Escalation ( ) , source , new String [ ] { " kind " , " element " , " name " , " escalation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tDeadlineExprEClass , source , new String [ ] { " name " , " tDeadline - expr " , " kind " , " mixed " } ) ; addAnnotation ( tDeadlinesEClass , source , new String [ ] { " name " , " tDeadlines " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDeadlines_StartDeadline ( ) , source , new String [ ] { " kind " , " element " , " name " , " startDeadline " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDeadlines_CompletionDeadline ( ) , source , new String [ ] { " kind " , " element " , " name " , " completionDeadline " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tDelegationEClass , source , new String [ ] { " name " , " tDelegation " , " kind " , " elementOnly " } ) ; addAnnotation ( getTDelegation_From ( ) , source , new String [ ] { " kind " , " element " , " name " , " from " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTDelegation_PotentialDelegatees ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " potentialDelegatees " } ) ; addAnnotation ( tDescriptionEClass , source , new String [ ] { " name " , " tDescription " , " kind " , " mixed " } ) ; addAnnotation ( getTDescription_ContentType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " contentType " } ) ; addAnnotation ( getTDescription_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tDocumentationEClass , source , new String [ ] { " name " , " tDocumentation " , " kind " , " mixed " } ) ; addAnnotation ( getTDocumentation_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTDocumentation_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTDocumentation_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tDurationExprEClass , source , new String [ ] { " name " , " tDuration - expr " , " kind " , " mixed " } ) ; addAnnotation ( tEscalationEClass , source , new String [ ] { " name " , " tEscalation " , " kind " , " elementOnly " } ) ; addAnnotation ( getTEscalation_Condition ( ) , source , new String [ ] { " kind " , " element " , " name " , " condition " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_ToParts ( ) , source , new String [ ] { " kind " , " element " , " name " , " toParts " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_LocalNotification ( ) , source , new String [ ] { " kind " , " element " , " name " , " localNotification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Reassignment ( ) , source , new String [ ] { " kind " , " element " , " name " , " reassignment " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTEscalation_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tExpressionEClass , source , new String [ ] { " name " , " tExpression " , " kind " , " mixed " } ) ; addAnnotation ( getTExpression_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTExpression_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTExpression_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTExpression_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 3" , " processing " , " lax " } ) ; addAnnotation ( tExtensibleElementsEClass , source , new String [ ] { " name " , " tExtensibleElements " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtensibleElements_Documentation ( ) , source , new String [ ] { " kind " , " element " , " name " , " documentation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTExtensibleElements_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTExtensibleElements_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " lax " } ) ; addAnnotation ( tExtensibleMixedContentElementsEClass , source , new String [ ] { " name " , " tExtensibleMixedContentElements " , " kind " , " mixed " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Documentation ( ) , source , new String [ ] { " kind " , " element " , " name " , " documentation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTExtensibleMixedContentElements_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " skip " } ) ; addAnnotation ( getTExtensibleMixedContentElements_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 3" , " processing " , " lax " } ) ; addAnnotation ( tExtensionEClass , source , new String [ ] { " name " , " tExtension " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtension_MustUnderstand ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " mustUnderstand " } ) ; addAnnotation ( getTExtension_Namespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " namespace " } ) ; addAnnotation ( tExtensionsEClass , source , new String [ ] { " name " , " tExtensions " , " kind " , " elementOnly " } ) ; addAnnotation ( getTExtensions_Extension ( ) , source , new String [ ] { " kind " , " element " , " name " , " extension " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tFromEClass , source , new String [ ] { " name " , " tFrom " , " kind " , " mixed " } ) ; addAnnotation ( getTFrom_Argument ( ) , source , new String [ ] { " kind " , " element " , " name " , " argument " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTFrom_Literal ( ) , source , new String [ ] { " kind " , " element " , " name " , " literal " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTFrom_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTFrom_LogicalPeopleGroup ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " logicalPeopleGroup " } ) ; addAnnotation ( tGenericHumanRoleEClass , source , new String [ ] { " name " , " tGenericHumanRole " , " kind " , " elementOnly " } ) ; addAnnotation ( getTGenericHumanRole_From ( ) , source , new String [ ] { " kind " , " element " , " name " , " from " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tGroupEDataType , source , new String [ ] { " name " , " tGroup " , " baseType " , " http : // www . eclipse . org / emf / 2003 / XMLType # string " } ) ; addAnnotation ( tGrouplistEClass , source , new String [ ] { " name " , " tGrouplist " , " kind " , " elementOnly " } ) ; addAnnotation ( getTGrouplist_Group ( ) , source , new String [ ] { " kind " , " element " , " name " , " group " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tHumanInteractionsEClass , source , new String [ ] { " name " , " tHumanInteractions " , " kind " , " elementOnly " } ) ; addAnnotation ( getTHumanInteractions_Extensions ( ) , source , new String [ ] { " kind " , " element " , " name " , " extensions " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Import ( ) , source , new String [ ] { " kind " , " element " , " name " , " import " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_LogicalPeopleGroups ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Tasks ( ) , source , new String [ ] { " kind " , " element " , " name " , " tasks " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_Notifications ( ) , source , new String [ ] { " kind " , " element " , " name " , " notifications " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTHumanInteractions_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTHumanInteractions_QueryLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " queryLanguage " } ) ; addAnnotation ( getTHumanInteractions_TargetNamespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " targetNamespace " } ) ; addAnnotation ( tImportEClass , source , new String [ ] { " name " , " tImport " , " kind " , " elementOnly " } ) ; addAnnotation ( getTImport_ImportType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " importType " } ) ; addAnnotation ( getTImport_Location ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " location " } ) ; addAnnotation ( getTImport_Namespace ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " namespace " } ) ; addAnnotation ( tLiteralEClass , source , new String [ ] { " name " , " tLiteral " , " kind " , " mixed " } ) ; addAnnotation ( getTLiteral_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTLiteral_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # any " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTLiteral_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 2" , " processing " , " lax " } ) ; addAnnotation ( tLocalNotificationEClass , source , new String [ ] { " name " , " tLocalNotification " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLocalNotification_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLocalNotification_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLocalNotification_Reference ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " reference " } ) ; addAnnotation ( tLogicalPeopleGroupEClass , source , new String [ ] { " name " , " tLogicalPeopleGroup " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLogicalPeopleGroup_Parameter ( ) , source , new String [ ] { " kind " , " element " , " name " , " parameter " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTLogicalPeopleGroup_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( getTLogicalPeopleGroup_Reference ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " reference " } ) ; addAnnotation ( tLogicalPeopleGroupsEClass , source , new String [ ] { " name " , " tLogicalPeopleGroups " , " kind " , " elementOnly " } ) ; addAnnotation ( getTLogicalPeopleGroups_LogicalPeopleGroup ( ) , source , new String [ ] { " kind " , " element " , " name " , " logicalPeopleGroup " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tNotificationEClass , source , new String [ ] { " name " , " tNotification " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotification_Interface ( ) , source , new String [ ] { " kind " , " element " , " name " , " interface " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_PresentationElements ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationElements " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Renderings ( ) , source , new String [ ] { " kind " , " element " , " name " , " renderings " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTNotification_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tNotificationInterfaceEClass , source , new String [ ] { " name " , " tNotificationInterface " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotificationInterface_Operation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " operation " } ) ; addAnnotation ( getTNotificationInterface_PortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " portType " } ) ; addAnnotation ( tNotificationsEClass , source , new String [ ] { " name " , " tNotifications " , " kind " , " elementOnly " } ) ; addAnnotation ( getTNotifications_Notification ( ) , source , new String [ ] { " kind " , " element " , " name " , " notification " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tOrganizationalEntityEClass , source , new String [ ] { " name " , " tOrganizationalEntity " , " kind " , " elementOnly " } ) ; addAnnotation ( getTOrganizationalEntity_Users ( ) , source , new String [ ] { " kind " , " element " , " name " , " users " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTOrganizationalEntity_Groups ( ) , source , new String [ ] { " kind " , " element " , " name " , " groups " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tParameterEClass , source , new String [ ] { " name " , " tParameter " , " kind " , " mixed " } ) ; addAnnotation ( getTParameter_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( getTParameter_Type ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " type " } ) ; addAnnotation ( tPeopleAssignmentsEClass , source , new String [ ] { " name " , " tPeopleAssignments " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPeopleAssignments_GenericHumanRole ( ) , source , new String [ ] { " kind " , " group " , " name " , " GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_ExcludedOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " excludedOwners " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_TaskInitiator ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskInitiator " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_TaskStakeholders ( ) , source , new String [ ] { " kind " , " element " , " name " , " taskStakeholders " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_BusinessAdministrators ( ) , source , new String [ ] { " kind " , " element " , " name " , " businessAdministrators " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( getTPeopleAssignments_Recipients ( ) , source , new String [ ] { " kind " , " element " , " name " , " recipients " , " namespace " , " # # targetNamespace " , " group " , " # GenericHumanRole : 3" } ) ; addAnnotation ( tPotentialDelegateesEEnum , source , new String [ ] { " name " , " tPotentialDelegatees " } ) ; addAnnotation ( tPotentialDelegateesObjectEDataType , source , new String [ ] { " name " , " tPotentialDelegatees : Object " , " baseType " , " tPotentialDelegatees " } ) ; addAnnotation ( tPresentationElementsEClass , source , new String [ ] { " name " , " tPresentationElements " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPresentationElements_Name ( ) , source , new String [ ] { " kind " , " element " , " name " , " name " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_PresentationParameters ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationParameters " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_Subject ( ) , source , new String [ ] { " kind " , " element " , " name " , " subject " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationElements_Description ( ) , source , new String [ ] { " kind " , " element " , " name " , " description " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tPresentationParameterEClass , source , new String [ ] { " name " , " tPresentationParameter " , " kind " , " mixed " } ) ; addAnnotation ( tPresentationParametersEClass , source , new String [ ] { " name " , " tPresentationParameters " , " kind " , " elementOnly " } ) ; addAnnotation ( getTPresentationParameters_PresentationParameter ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationParameter " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTPresentationParameters_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( tPriorityEClass , source , new String [ ] { " name " , " tPriority " , " kind " , " mixed " } ) ; addAnnotation ( tQueryEClass , source , new String [ ] { " name " , " tQuery " , " kind " , " mixed " } ) ; addAnnotation ( getTQuery_Mixed ( ) , source , new String [ ] { " kind " , " elementWildcard " , " name " , " : mixed " } ) ; addAnnotation ( getTQuery_Any ( ) , source , new String [ ] { " kind " , " elementWildcard " , " wildcards " , " # # other " , " name " , " : 1" , " processing " , " lax " } ) ; addAnnotation ( getTQuery_Part ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " part " } ) ; addAnnotation ( getTQuery_QueryLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " queryLanguage " } ) ; addAnnotation ( getTQuery_AnyAttribute ( ) , source , new String [ ] { " kind " , " attributeWildcard " , " wildcards " , " # # other " , " name " , " : 4" , " processing " , " lax " } ) ; addAnnotation ( tReassignmentEClass , source , new String [ ] { " name " , " tReassignment " , " kind " , " elementOnly " } ) ; addAnnotation ( getTReassignment_PotentialOwners ( ) , source , new String [ ] { " kind " , " element " , " name " , " potentialOwners " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tRenderingEClass , source , new String [ ] { " name " , " tRendering " , " kind " , " elementOnly " } ) ; addAnnotation ( getTRendering_Type ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " type " } ) ; addAnnotation ( tRenderingsEClass , source , new String [ ] { " name " , " tRenderings " , " kind " , " elementOnly " } ) ; addAnnotation ( getTRenderings_Rendering ( ) , source , new String [ ] { " kind " , " element " , " name " , " rendering " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tTaskEClass , source , new String [ ] { " name " , " tTask " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTask_Interface ( ) , source , new String [ ] { " kind " , " element " , " name " , " interface " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Priority ( ) , source , new String [ ] { " kind " , " element " , " name " , " priority " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_PeopleAssignments ( ) , source , new String [ ] { " kind " , " element " , " name " , " peopleAssignments " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Delegation ( ) , source , new String [ ] { " kind " , " element " , " name " , " delegation " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_PresentationElements ( ) , source , new String [ ] { " kind " , " element " , " name " , " presentationElements " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Outcome ( ) , source , new String [ ] { " kind " , " element " , " name " , " outcome " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_SearchBy ( ) , source , new String [ ] { " kind " , " element " , " name " , " searchBy " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Renderings ( ) , source , new String [ ] { " kind " , " element " , " name " , " renderings " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Deadlines ( ) , source , new String [ ] { " kind " , " element " , " name " , " deadlines " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( getTTask_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tTaskInterfaceEClass , source , new String [ ] { " name " , " tTaskInterface " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTaskInterface_Operation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " operation " } ) ; addAnnotation ( getTTaskInterface_PortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " portType " } ) ; addAnnotation ( getTTaskInterface_ResponseOperation ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " responseOperation " } ) ; addAnnotation ( getTTaskInterface_ResponsePortType ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " responsePortType " } ) ; addAnnotation ( tTasksEClass , source , new String [ ] { " name " , " tTasks " , " kind " , " elementOnly " } ) ; addAnnotation ( getTTasks_Task ( ) , source , new String [ ] { " kind " , " element " , " name " , " task " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tTextEClass , source , new String [ ] { " name " , " tText " , " kind " , " mixed " } ) ; addAnnotation ( getTText_Lang ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " lang " , " namespace " , " http : // www . w3 . org / XML / 1998 / namespace " } ) ; addAnnotation ( tToPartEClass , source , new String [ ] { " name " , " tToPart " , " kind " , " mixed " } ) ; addAnnotation ( getTToPart_ExpressionLanguage ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " expressionLanguage " } ) ; addAnnotation ( getTToPart_Name ( ) , source , new String [ ] { " kind " , " attribute " , " name " , " name " } ) ; addAnnotation ( tToPartsEClass , source , new String [ ] { " name " , " tToParts " , " kind " , " elementOnly " } ) ; addAnnotation ( getTToParts_ToPart ( ) , source , new String [ ] { " kind " , " element " , " name " , " toPart " , " namespace " , " # # targetNamespace " } ) ; addAnnotation ( tUserEDataType , source , new String [ ] { " name " , " tUser " , " baseType " , " http : // www . eclipse . org / emf / 2003 / XMLType # string " } ) ; addAnnotation ( tUserlistEClass , source , new String [ ] { " name " , " tUserlist " , " kind " , " elementOnly " } ) ; addAnnotation ( getTUserlist_User ( ) , source , new String [ ] { " kind " , " element " , " name " , " user " , " namespace " , " # # targetNamespace " } ) ; }
 public String getOutputDexFilename ( ) { return this == OFF ? " classes . dex " : " classes . dex . zip " ; }
 public void setHost ( String host ) { this . host = host ; }
 public void setPayerStatus ( final String payerStatus ) { this . payerStatus = payerStatus ; }
 @ Override public void addLifecycleListener ( LifecycleListener listener ) { }
 public List < Artifact > getStaticModeParamsForExecutableLibraries ( ) { ImmutableList . Builder < Artifact > libraryListBuilder = ImmutableList . builder ( ) ; for ( LibraryToLink libraryToLink : getLibraries ( ) . toList ( ) ) { if ( libraryToLink . getStaticLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getStaticLibrary ( ) ) ; } else if ( libraryToLink . getPicStaticLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getPicStaticLibrary ( ) ) ; } else if ( libraryToLink . getInterfaceLibrary ( ) != null ) { libraryListBuilder . add ( libraryToLink . getInterfaceLibrary ( ) ) ; } else { libraryListBuilder . add ( libraryToLink . getDynamicLibrary ( ) ) ; } } return libraryListBuilder . build ( ) ; }
 private ObjectFilter createFilter ( Configuration configuration ) { Class < ? extends ObjectFilter > filter = configuration . getClass ( CONF_FILTER_CLASS , ObjectFilter . class ) ; log . debug ( String . format ( " Got ▁ filter ▁ class ▁ % s . ▁ Commencing ▁ creation " , filter ) ) ; return Configuration . create ( filter , configuration ) ; }
 @ Test public void testPollConfigAndUsageWithBuilder ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , serverList ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2279 ) ) ; try { AWSElasticCacheClientBuilder builder = new AWSElasticCacheClientBuilder ( new InetSocketAddress ( 2279 ) ) ; builder . setConnectionPoolSize ( 2 ) ; builder . setEnableHealSession ( false ) ; AWSElasticCacheClient client = builder . build ( ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( addresses . size ( ) , config . getNodeList ( ) . size ( ) ) ; client . set ( " aws - cache " , 0 , " foobar " ) ; assertEquals ( " foobar " , client . get ( " aws - cache " ) ) ; } finally { configServer . stop ( ) ; } }
 catch ( IOException e ) { throw new InternalGemFireException ( " Unknown ▁ error ▁ serializing ▁ message " , e ) ; }
 @ FxThread protected @ NotNull EditorOperationControl createOperationControl ( ) { return new EditorOperationControl ( this ) ; }
 public void setPayer ( final String payer ) { this . payer = payer ; }
 public NGuid getStoragePoolId ( ) { if ( _storagePoolId == null ) { if ( _storagePool != null ) { _storagePoolId = _storagePool . getId ( ) ; } else if ( getStorageDomain ( ) != null ) { _storagePoolId = getStorageDomain ( ) . getstorage_pool_id ( ) ; } } return _storagePoolId ; }
 @ Test public void testRRMemLRU ( ) { doRRMemLRUTest ( ) ; }
 @ Test public void testExportImport2 ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
 @ Test public void testBrowsingLimited ( ) throws Exception { int messageToSend = 470 ; ActiveMQQueue queue = new ActiveMQQueue ( " TEST " ) ; Connection connection = factory . createConnection ( ) ; connection . start ( ) ; Session session = connection . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; MessageProducer producer = session . createProducer ( queue ) ; String data = " " ; for ( int i = 0 ; i < 1024 * 2 ; i ++ ) { data += " x " ; } for ( int i = 0 ; i < messageToSend ; i ++ ) { producer . send ( session . createTextMessage ( data ) ) ; } QueueBrowser browser = session . createBrowser ( queue ) ; Enumeration < ? > enumeration = browser . getEnumeration ( ) ; int received = 0 ; while ( enumeration . hasMoreElements ( ) ) { Message m = ( Message ) enumeration . nextElement ( ) ; received ++ ; LOG . info ( " Browsed ▁ message ▁ " + received + " : ▁ " + m . getJMSMessageID ( ) ) ; } browser . close ( ) ; assertEquals ( browserLimit , received ) ; }
 public EAttribute getTLiteral_AnyAttribute ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 public String getAttributeValue ( ) { return toString ( ) . toLowerCase ( ) ; }
 public void setAssetFolder ( @ NotNull Path assetFolder ) { set ( ASSET , assetFolder ) ; }
 public EReference getTLocalNotification_PeopleAssignments ( ) { return ( EReference ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 private EventNotificationEntity ( ApplicationMode applicationMode ) { this . availableInModes = applicationMode . getValue ( ) ; }
 public EAttribute getTHumanInteractions_TargetNamespace ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
 public EReference getTHumanInteractions_LogicalPeopleGroups ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 private int skipLevels ( int newLevel , Iterable < SSTableReader > added ) { while ( maxBytesForLevel ( newLevel ) < SSTableReader . getTotalBytes ( added ) && generations [ ( newLevel + 1 ) ] . isEmpty ( ) ) { newLevel ++ ; } return newLevel ; }
 @ Override protected void initData ( ) { SharedPreferences sharedPref = PreferenceManager . getDefaultSharedPreferences ( this ) ; token = sharedPref . getString ( " token " , null ) ; solutions = areaData . list ; initAdapter ( ) ; }
 public EAttribute getTArgument_Name ( ) { return ( EAttribute ) tArgumentEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public EReference getTPresentationElements_PresentationParameters ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 int getProbeSideBlockCount ( ) { return this . probeSideBuffer == null ? - 1 : this . probeSideBuffer . getBlockCount ( ) ; }
 @ Override public boolean isImmutable ( ) { return true ; }
 public Label getOwner ( ) { return owner ; }
 public BrokerService createBroker ( ) throws IOException { return new BrokerService ( ) ; }
 @ Override public TransformResult finishBundle ( ) { return resultBuilder . build ( ) ; }
 @ Test public void test ( ) { List < GeolocationResult > results = service . queryGeoLocateMulti ( " USA " , " Arizona " , " " , "1 ▁ mi . ▁ S ▁ of ▁ Portal " , "31.899097" , " - 109.14083" ) ; assertTrue ( results . size ( ) > 0 ) ; }
 public void delete ( ) { super . delete ( ) ; }
 private String testMethods ( ) { return " foo " ; }
 public void makePublic ( ) { }
 public ApplicationException ( String msg , Throwable cause ) { super ( msg , cause ) ; }
 public void setCode ( String code ) { this . code = code ; }
 public QuestionConcept ( String title , int pageId ) { this . title = title ; this . pageId = pageId ; }
 public AMQPClientConnectionContext connect ( String host , int port ) throws Exception { SocketAddress remoteDestination = new InetSocketAddress ( host , port ) ; ChannelFuture future = bootstrap . connect ( remoteDestination ) ; future . awaitUninterruptibly ( ) ; AMQPClientSPI clientConnectionSPI = new AMQPClientSPI ( future . channel ( ) ) ; final AMQPClientConnectionContext connection = ( AMQPClientConnectionContext ) ProtonClientConnectionContextFactory . getFactory ( ) . createConnection ( clientConnectionSPI ) ; future . channel ( ) . pipeline ( ) . addLast ( new ChannelDuplexHandler ( ) { @ Override public void channelRead ( final ChannelHandlerContext ctx , final Object msg ) throws Exception { ByteBuf buffer = ( ByteBuf ) msg ; connection . inputBuffer ( buffer ) ; } } ) ; return connection ; }
 int getNumOccupiedMemorySegments ( ) { final int numPartitionBuffers = this . partitionBuffers != null ? this . partitionBuffers . length : this . buildSideWriteBuffer . getNumOccupiedMemorySegments ( ) ; return numPartitionBuffers + buckets . length ; }
 public void AddCustomValue ( CustomAuditLogKeys key , final String value ) { AddCustomValue ( key . name ( ) , value ) ; }
 public void setPayerBusiness ( final String payerBusiness ) { this . payerBusiness = payerBusiness ; }
 private Object [ ] getUserInfo ( String prefix , String authorizationId , CallbackHandler cbh ) throws SaslException { if ( cbh == null ) { throw new SaslException ( " Callback ▁ handler ▁ to ▁ get ▁ username / password ▁ required " ) ; } try { String userPrompt = prefix + " ▁ authentication ▁ id : ▁ " ; String passwdPrompt = prefix + " ▁ password : ▁ " ; NameCallback ncb = authorizationId == null ? new NameCallback ( userPrompt ) : new NameCallback ( userPrompt , authorizationId ) ; PasswordCallback pcb = new PasswordCallback ( passwdPrompt , false ) ; cbh . handle ( new Callback [ ] { ncb , pcb } ) ; char [ ] pw = pcb . getPassword ( ) ; byte [ ] bytepw ; String authId ; if ( pw != null ) { bytepw = new String ( pw ) . getBytes ( " UTF8" ) ; pcb . clearPassword ( ) ; } else { bytepw = null ; } authId = ncb . getName ( ) ; return new Object [ ] { authId , bytepw } ; } catch ( IOException e ) { throw new SaslException ( " Cannot ▁ get ▁ password " , e ) ; } catch ( UnsupportedCallbackException e ) { throw new SaslException ( " Cannot ▁ get ▁ userid / password " , e ) ; } }
 @ Override public Sequence < String > getStarlarkUserLinkFlags ( ) { return StarlarkList . immutableCopyOf ( getFlattenedUserLinkFlags ( ) ) ; }
 long getMaxKey ( ) { return maxKey ; }
 public List < Artifact > getDynamicLibrariesForRuntime ( boolean linkingStatically ) { return LibraryToLink . getDynamicLibrariesForRuntime ( linkingStatically , getLibraries ( ) . toList ( ) ) ; }
 public EAttribute getTFrom_LogicalPeopleGroup ( ) { return ( EAttribute ) tFromEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 private long getEvictions ( LocalRegion region ) { return region . getTotalEvictions ( ) ; }
 public EClass getTQuery ( ) { return tQueryEClass ; }
 FieldChoicesdialogs ( String v ) { value = v ; }
 public EReference getTHumanInteractions_Tasks ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 @ Override public BinaryRowData getRow ( ) { return buildReuseRow ; }
 if ( logger . isDebugEnabled ( ) ) { logger . debug ( " { } ▁ on ▁ these ▁ { } ▁ connections : ▁ { } " , ( retry ? " Retrying ▁ send " : " Sending " ) , cons . size ( ) , cons ) ; }
 public List < T > columnsIndex ( ) { return Collections . emptyList ( ) ; }
 public Builder addEncoded ( String name , String value ) { names . add ( HttpUrl . canonicalize ( name , FORM_ENCODE_SET , true , true , true ) ) ; values . add ( HttpUrl . canonicalize ( value , FORM_ENCODE_SET , true , true , true ) ) ; return this ; }
 @ Override public String toString ( ) { return " TestObject ▁ [ sizeForSerialization = " + sizeForSerialization + " , ▁ sizeForSizer = " + sizeForSizer + " ] " ; }
 private CompletableFuture < Void > handleException ( Throwable throwable , ChannelHandlerContext ctx , HttpRequest httpRequest ) { ClusterEntryPointExceptionUtils . tryEnrichClusterEntryPointError ( throwable ) ; FlinkHttpObjectAggregator flinkHttpObjectAggregator = ctx . pipeline ( ) . get ( FlinkHttpObjectAggregator . class ) ; if ( flinkHttpObjectAggregator == null ) { log . warn ( " The ▁ connection ▁ was ▁ unexpectedly ▁ closed ▁ by ▁ the ▁ client . " ) ; return CompletableFuture . completedFuture ( null ) ; } int maxLength = flinkHttpObjectAggregator . maxContentLength ( ) - OTHER_RESP_PAYLOAD_OVERHEAD ; if ( throwable instanceof RestHandlerException ) { RestHandlerException rhe = ( RestHandlerException ) throwable ; String stackTrace = ExceptionUtils . stringifyException ( rhe ) ; String truncatedStackTrace = Ascii . truncate ( stackTrace , maxLength , " . . . " ) ; if ( log . isDebugEnabled ( ) ) { log . error ( " Exception ▁ occurred ▁ in ▁ REST ▁ handler . " , rhe ) ; } else if ( rhe . logException ( ) ) { log . error ( " Exception ▁ occurred ▁ in ▁ REST ▁ handler : ▁ { } " , rhe . getMessage ( ) ) ; } return HandlerUtils . sendErrorResponse ( ctx , httpRequest , new ErrorResponseBody ( truncatedStackTrace ) , rhe . getHttpResponseStatus ( ) , responseHeaders ) ; } else { log . error ( " Unhandled ▁ exception . " , throwable ) ; String stackTrace = String . format ( " < Exception ▁ on ▁ server ▁ side : % n % s % nEnd ▁ of ▁ exception ▁ on ▁ server ▁ side > " , ExceptionUtils . stringifyException ( throwable ) ) ; String truncatedStackTrace = Ascii . truncate ( stackTrace , maxLength , " . . . " ) ; return HandlerUtils . sendErrorResponse ( ctx , httpRequest , new ErrorResponseBody ( Arrays . asList ( " Internal ▁ server ▁ error . " , truncatedStackTrace ) ) , HttpResponseStatus . INTERNAL_SERVER_ERROR , responseHeaders ) ; } }
 private void updateMinMax ( long key ) { if ( key < minKey ) { minKey = key ; } if ( key > maxKey ) { maxKey = key ; } }
 public void setFirstName ( final String firstName ) { this . firstName = firstName ; }
 @ Override protected SequentialFileFactory getFileFactory ( ) throws Exception { return new NIOSequentialFileFactory ( getTestDirfile ( ) , true , 1 ) ; }
 private IssueData parseIssueData ( @ NotNull final Map map ) throws Exception { final Map fields = getContainer ( map , Containers . CONTAINER_FIELDS ) ; final Map links = getContainer ( map , Containers . CONTAINER_LINKS ) ; final Map html = getContainer ( links , Containers . CONTAINER_HTML ) ; final String href = getField ( html , Fields . FIELD_HREF ) ; final String actualProject = getField ( fields , Fields . FIELD_PROJECT ) ; return new IssueData ( String . valueOf ( map . get ( " id " ) ) , CollectionsUtil . asMap ( IssueData . SUMMARY_FIELD , getField ( fields , Fields . FIELD_SUMMARY ) , IssueData . STATE_FIELD , getField ( fields , Fields . FIELD_STATE ) , IssueData . TYPE_FIELD , getField ( fields , Fields . FIELD_TYPE ) , IssueDataFields . ID_FIELD_PROJECT , actualProject , IssueDataFields . ID_FIELD_HREF , href ) , false , " Feature " . equals ( getField ( fields , Fields . FIELD_TYPE ) ) , href ) ; }
 public TestObject ( ) { }
 @ After public void stopBroker ( ) throws Exception { broker . stop ( ) ; broker . waitUntilStopped ( ) ; }
 @ Override public MediaType contentType ( ) { return CONTENT_TYPE ; }
 @ Override @ FxThread public @ Nullable BorderPane get3DArea ( ) { return null ; }
 public EClass getTDescription ( ) { return tDescriptionEClass ; }
 if ( Boolean . parseBoolean ( System . getProperty ( IGNITE_DISABLE_HOSTNAME_VERIFIER ) ) ) { HttpsURLConnection . setDefaultHostnameVerifier ( new HostnameVerifier ( ) { @ Override public boolean verify ( String hostname , SSLSession sslSes ) { return true ; } } ) ; }
 public LinkerInput build ( ) { return new LinkerInput ( owner , libraries . build ( ) , userLinkFlags . build ( ) , nonCodeInputs . build ( ) , linkstamps . build ( ) ) ; }
 @ Cacheable ( " Groups " ) public Group getGroup ( int id ) throws GroupNotFoundException { try { return jdbcTemplate . queryForObject ( " SELECT ▁ sections . moderate , ▁ vote , ▁ section , ▁ havelink , ▁ linktext , ▁ title , ▁ urlname , ▁ image , ▁ groups . restrict _ topics , ▁ restrict _ comments , stat3 , groups . id , ▁ groups . info , ▁ groups . longinfo , ▁ groups . resolvable ▁ FROM ▁ groups , ▁ sections ▁ WHERE ▁ groups . id = ? ▁ AND ▁ groups . section = sections . id " , ( resultSet , i ) -> Group . buildGroup ( resultSet ) , id ) ; } catch ( EmptyResultDataAccessException ex ) { throw new GroupNotFoundException ( " Группа ▁ " + id + " ▁ не ▁ существует " , ex ) ; } }
 @ Override public String getLastErrorReason ( ) { return this . errorReason ; }
 @ Test public void testFindingFromAnEmptyList ( ) throws Exception { assertThat ( getFinder ( ) . find ( 0 ) , is ( - 1 ) ) ; }
 public void test ( ) { print ( this :: ) }
 @ Override public void clear ( ) { array . clear ( ) ; }
 @ Override protected void populateObject ( Object object ) throws Exception { super . populateObject ( object ) ; RemoveSubscriptionInfo info = ( RemoveSubscriptionInfo ) object ; info . setConnectionId ( createConnectionId ( " ConnectionId : 1" ) ) ; info . setSubscriptionName ( " SubcriptionName : 2" ) ; info . setClientId ( " ClientId : 3" ) ; }
 @ XmlElement ( required = true ) @ Column ( name = LAST_NAME_COLUMN_NAME , nullable = false ) public String getLastName ( ) { return lastName ; }
 protected NetworkClusterDAO getNetworkClusterDAO ( ) { return getDbFacade ( ) . getNetworkClusterDAO ( ) ; }
 public VM getVm ( ) { if ( mVm == null && mVmId != null && ! mVmId . equals ( Guid . Empty ) ) { try { mVm = getVmDAO ( ) . get ( mVmId . getValue ( ) ) ; if ( mVm != null ) { mVm . setInterfaces ( getVmNetworkInterfaceDAO ( ) . getAllForVm ( mVmId . getValue ( ) ) ) ; } } catch ( final Exception e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ vm ▁ { 0 } " , mVmId ) ; log . debug ( e ) ; } } return mVm ; }
 @ Override public void afterUpdate ( EntryEvent event ) { event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . fine ( " invoked ▁ afterUpdate ▁ with ▁ " ) ; event . getRegion ( ) . getCache ( ) . getLoggerI18n ( ) . info ( LocalizedStrings . DEBUG , " value ▁ is ▁ " + event . getNewValue ( ) ) ; }
 public void setCodeValueGroups ( List < CodeValueGroupJsonModel > codeValueGroups ) { this . codeValueGroups = codeValueGroups ; }
 @ Override protected void onSetBlockAsFilledAir ( int x , int y , int z ) { }
 private void createRRHeapLRU ( VM vm ) { vm . invoke ( new SerializableRunnable ( " Create ▁ rr " ) { public void run ( ) { Cache cache = getCache ( ) ; ResourceManager manager = cache . getResourceManager ( ) ; manager . setCriticalHeapPercentage ( 95 ) ; manager . setEvictionHeapPercentage ( 90 ) ; AttributesFactory < Integer , TestDelta > attr = new AttributesFactory < Integer , TestDelta > ( ) ; attr . setEvictionAttributes ( EvictionAttributes . createLRUHeapAttributes ( new TestObjectSizer ( ) , EvictionAction . OVERFLOW_TO_DISK ) ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; attr . setDataPolicy ( DataPolicy . REPLICATE ) ; attr . setScope ( Scope . DISTRIBUTED_ACK ) ; attr . setDiskDirs ( getMyDiskDirs ( ) ) ; Region region = cache . createRegion ( " region " , attr . create ( ) ) ; } } ) ; }
 public void setLastName ( final String lastName ) { this . lastName = lastName ; }
 public BoundedReadEvaluator ( AppliedPTransform < ? , PCollection < OutputT > , ? > transform , EvaluationContext evaluationContext , long minimumDynamicSplitSize , ExecutorService executor ) { this . transform = transform ; this . evaluationContext = evaluationContext ; resultBuilder = StepTransformResult . withoutHold ( transform ) ; this . minimumDynamicSplitSize = minimumDynamicSplitSize ; this . produceSplitExecutor = executor ; }
 public void setPayerId ( final String payerId ) { this . payerId = payerId ; }
 @ StarlarkMethod ( name = " linkstamps " , documented = false , structField = true ) public Sequence < Linkstamp > getLinkstampsForStarlark ( ) { return StarlarkList . immutableCopyOf ( getLinkstamps ( ) ) ; }
 public EClass getTBooleanExpr ( ) { return tBooleanExprEClass ; }
 public EReference getDocumentRoot_PotentialOwners ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 14 ) ; }
 @ Override public void onCreate ( ) { super . onCreate ( ) ; if ( LeakCanary . isInAnalyzerProcess ( this ) ) { return ; } LeakCanary . install ( this ) ; Stetho . initializeWithDefaults ( this ) ; if ( BuildConfig . DEBUG ) { Timber . plant ( new Timber . DebugTree ( ) ) ; Timber . plant ( new StethoTree ( ) ) ; } component = DaggerApplicationComponent . builder ( ) . applicationModule ( new ApplicationModule ( this ) ) . build ( ) ; component . inject ( this ) ; }
 @ Test public void whenShowInfo ( ) { Point first = new Point ( 1 , 1 ) ; first . info ( ) ; Point second = new Point ( 2 , 2 ) ; second . info ( ) ; }
 if ( EVTS_ALL == null || EVTS_ALL_MINUS_METRIC_UPDATE == null ) { try { Field f1 = EventType . class . getDeclaredField ( " EVTS _ ALL " ) ; Field f2 = EventType . class . getDeclaredField ( " EVTS _ ALL _ MINUS _ METRIC _ UPDATE " ) ; assert f1 != null ; assert f2 != null ; UNSAFE . putObjectVolatile ( UNSAFE . staticFieldBase ( f1 ) , UNSAFE . staticFieldOffset ( f1 ) , gridEvents ( ) ) ; UNSAFE . putObjectVolatile ( UNSAFE . staticFieldBase ( f2 ) , UNSAFE . staticFieldOffset ( f2 ) , gridEvents ( EVT_NODE_METRICS_UPDATED ) ) ; assert EVTS_ALL != null ; assert EVTS_ALL . length == GRID_EVTS . length ; assert EVTS_ALL_MINUS_METRIC_UPDATE != null ; assert EVTS_ALL_MINUS_METRIC_UPDATE . length == GRID_EVTS . length - 1 ; for ( int type : GRID_EVTS ) { assert containsIntArray ( EVTS_ALL , type ) ; if ( type != EVT_NODE_METRICS_UPDATED ) assert containsIntArray ( EVTS_ALL_MINUS_METRIC_UPDATE , type ) ; } assert ! containsIntArray ( EVTS_ALL_MINUS_METRIC_UPDATE , EVT_NODE_METRICS_UPDATED ) ; } catch ( NoSuchFieldException e ) { throw new IgniteException ( e ) ; } }
 public synchronized void add ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level < generations . length : " Invalid ▁ level ▁ " + level + " ▁ out ▁ of ▁ " + ( generations . length - 1 ) ; logDistribution ( ) ; logger . debug ( " Adding ▁ { } ▁ to ▁ L { } " , reader , level ) ; generations [ level ] . add ( reader ) ; }
 private JsArrayUtil ( ) { }
 if ( cons . isEmpty ( ) ) { if ( failedCe != null ) { throw failedCe ; } return bytesWritten ; }
 public EReference getDocumentRoot_ExcludedOwners ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
 public EClass getTImport ( ) { return tImportEClass ; }
 @ Override public String toString ( ) { return ' [ ' + Joiner . on ( " , " ) . join ( linkOptions ) + " ] ▁ ( owner : ▁ " + symbolForEquality ; }
 @ Override public DeletionTime deletionTime ( ) { return deletionTime ; }
 LongHashPartition ( LongHybridHashTable longTable , int partitionNum , BinaryRowDataSerializer buildSideSerializer , double estimatedRowCount , int maxSegs , int recursionLevel ) { this ( longTable , partitionNum , buildSideSerializer , getBucketBuffersByRowCount ( ( long ) estimatedRowCount , maxSegs , longTable . pageSize ( ) ) , recursionLevel , null , 0 ) ; this . buildSideWriteBuffer = new BuildSideBuffer ( longTable . nextSegment ( ) ) ; }
 public Boolean getIncludeDynamicSearchAdsSource ( ) { return includeDynamicSearchAdsSource ; }
 public synchronized int getLevelSize ( int i ) { if ( i >= generations . length ) throw new ArrayIndexOutOfBoundsException ( " Maximum ▁ valid ▁ generation ▁ is ▁ " + ( generations . length - 1 ) ) ; return generations [ i ] . size ( ) ; }
 @ Override public boolean isCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isCompatibleWith ( ( ( ListType ) previous ) . elements ) ; }
 public List < LinkOptions > getUserLinkFlags ( ) { return userLinkFlags ; }
 public EReference getDocumentRoot_TaskInitiator ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 18 ) ; }
 public boolean isCellEditable ( final EventObject e ) { return true ; }
 public EAttribute getTQuery_AnyAttribute ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
 protected void execute ( ) { Robot . cannonSubsystem . spinGatling ( 0.5 ) ; }
 public void closeEndpoint ( InternalDistributedMember member , String reason , boolean notifyDisconnect ) { TCPConduit tc = this . conduit ; if ( tc != null ) { tc . removeEndpoint ( member , reason , notifyDisconnect ) ; } }
 private PartitionIterator ( ) { this . reuse = buildSideSerializer . createInstance ( ) ; setReadPosition ( 0 ) ; }
 public NGuid getStorageDomainId ( ) { if ( _storageDomain != null ) { return _storageDomain . getId ( ) ; } return _storageDomainId ; }
 @ Test public void aJustCreatedBeanWithOneSecondOfKeepaliveIsNotAliveAfterTwoSeconds ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , ONE_SECOND ) ; assertFalse ( bean . isAlive ( twoHoursFromNow ( ) ) ) ; }
 public EReference getTNotification_PeopleAssignments ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 @ Test public void testFindingItemsAtTheEnd ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , 1 , 2 , 3 , 4 , 5 ) , is ( 4 ) ) ; }
 public Builder add ( String name , String value ) { names . add ( HttpUrl . canonicalize ( name , FORM_ENCODE_SET , false , true , true ) ) ; values . add ( HttpUrl . canonicalize ( value , FORM_ENCODE_SET , false , true , true ) ) ; return this ; }
 @ Override public Collection < CommittedBundle < BoundedSourceShard < T > > > getInitialInputs ( AppliedPTransform < PBegin , PCollection < T > , Read . Bounded < T > > transform , int targetParallelism ) throws Exception { BoundedSource < T > source = transform . getTransform ( ) . getSource ( ) ; PipelineOptions options = evaluationContext . getPipelineOptions ( ) ; long estimatedBytes = source . getEstimatedSizeBytes ( options ) ; long bytesPerBundle = estimatedBytes / targetParallelism ; List < ? extends BoundedSource < T > > bundles = source . splitIntoBundles ( bytesPerBundle , options ) ; ImmutableList . Builder < CommittedBundle < BoundedSourceShard < T > > > shards = ImmutableList . builder ( ) ; for ( BoundedSource < T > bundle : bundles ) { CommittedBundle < BoundedSourceShard < T > > inputShard = evaluationContext . < BoundedSourceShard < T > > createRootBundle ( ) . add ( WindowedValue . valueInGlobalWindow ( BoundedSourceShard . of ( bundle ) ) ) . commit ( BoundedWindow . TIMESTAMP_MAX_VALUE ) ; shards . add ( inputShard ) ; } return shards . build ( ) ; }
 @ XmlElement @ Column ( name = CONTACT_PHONE_COLUMN_NAME ) public String getContactPhone ( ) { return contactPhone ; }
 final void flushAccumulatedNotifications ( SquidDatabase database , boolean shouldSendNotifications ) { Set < T > accumulatedNotifications = notifyObjectAccumulator . get ( ) ; if ( enabled && shouldSendNotifications ) { sendNotificationsToAll ( database , accumulatedNotifications ) ; } accumulatedNotifications . clear ( ) ; }
 public void updateHasLegacyCounterShards ( boolean hasLegacyCounterShards ) { }
 public boolean isEOFReached ( ) { return eofReached ; }
 protected ReadOnlyProperty ( @ NonNull Observable < T > observable ) { mObservable = Observable . concat ( Observable . just ( null ) , observable ) ; }
 public Builder setOwner ( Label owner ) { linkerInputBuilder . setOwner ( owner ) ; return this ; }
 public ArrayOfCampaign getCampaigns ( ) { return campaigns ; }
 @ Override public boolean setBlockMetadata ( int x , int y , int z , int meta ) { if ( super . setBlockMetadata ( x , y , z , meta ) ) { sendQueue . add ( new ChunkPosition ( x , y , z ) ) ; return true ; } return false ; }
 @ Override public String toString ( ) { StringWriter sw = new StringWriter ( 500 ) ; sw . append ( getStatus ( ) . toString ( ) ) . append ( " : ▁ " ) ; sw . append ( sequence . toString ( ) ) ; sw . append ( " ▁ pump " ) ; return sw . toString ( ) ; }
 @ Override public void run ( ) { try { startSignal . await ( ) ; generateSheetData ( parameterVault , cs , sheet , columnCount , input2TableInfoMap ) ; doneSignal . countDown ( ) ; } catch ( InterruptedException e ) { LOGGER . error ( e . getMessage ( ) , e ) ; } }
 public NGuid getVdsIdRef ( ) { if ( mVdsId == null && getVds ( ) != null ) { mVdsId = getVds ( ) . getId ( ) ; } return mVdsId ; }
 while ( ! done ) { List < ChangeData > chgs = new ArrayList < > ( ) ; done = true ; for ( ChangeData cd : newCs . changes ( ) ) { chgs . add ( cd ) ; String topic = cd . change ( ) . getTopic ( ) ; if ( ! Strings . isNullOrEmpty ( topic ) && ! topicsTraversed . contains ( topic ) ) { chgs . addAll ( query ( ) . byTopicOpen ( topic ) ) ; done = false ; topicsTraversed . add ( topic ) ; } } changes = new ChangeSet ( chgs ) ; newCs = completeChangeSetWithoutTopic ( db , changes , user ) ; }
 public RegexPattern ( String _family , String _id , String _description ) { family = _family ; id = _id ; description = _description ; }
 public EAttribute getTQuery_Part ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 public QuotaDAO getQuotaDAO ( ) { return getDbFacade ( ) . getQuotaDAO ( ) ; }
 public void addPrimary ( int part , int heap , long offheap , long swap ) { primary . add ( new VisorCachePartition ( part , heap , offheap , swap ) ) ; }
 protected VDS getVds ( ) { if ( mVds == null && ( mVdsId != null || ( getVm ( ) != null && getVm ( ) . getrun_on_vds ( ) != null ) ) ) { if ( mVdsId == null ) { mVdsId = new Guid ( getVm ( ) . getrun_on_vds ( ) . toString ( ) ) ; } try { mVds = getVdsDAO ( ) . get ( getVdsId ( ) ) ; } catch ( final RuntimeException e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ vds ▁ { 0 } \n { 1 } " , mVdsId , e . getMessage ( ) ) ; } } return mVds ; }
 protected void fireEditingStopped ( ) { CellEditorListener [ ] listeners = getCellEditorListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { listeners [ i ] . editingStopped ( getChangeEvent ( ) ) ; } }
 @ Override public ExtraLinkTimeLibraryApi getGoLinkCArchiveForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; ExtraLinkTimeLibrary goLinkCArchive = null ; if ( extraLinkTimeLibraries != null ) { for ( ExtraLinkTimeLibrary extraLibrary : extraLinkTimeLibraries . getExtraLibraries ( ) ) { if ( goLinkCArchive != null ) { throw new EvalException ( " multiple ▁ GoLinkCArchive ▁ entries ▁ in ▁ go _ link _ c _ archive " ) ; } goLinkCArchive = extraLibrary ; } } return goLinkCArchive ; }
 @ Override public boolean isManagement ( ) { return mgmt ; }
 @ Override public IpcEndpoint accept ( ) throws IgniteCheckedException { try { Socket sock = srvSock . accept ( ) ; return new IpcClientTcpEndpoint ( sock ) ; } catch ( IOException e ) { throw new IgniteCheckedException ( e ) ; } }
 protected MessageListener getReceiver ( ) { return receiver ; }
 public String name ( int index ) { return percentDecode ( encodedName ( index ) , true ) ; }
 public void testSerializationCompatibility ( ) throws Exception { SerializationTest . verifyGolden ( this , new MissingFormatWidthException ( " MYTESTSTRING " ) , exComparator ) ; }
 public Request < DeleteLoadBalancerListenersRequest > marshall ( DeleteLoadBalancerListenersRequest deleteLoadBalancerListenersRequest ) { Request < DeleteLoadBalancerListenersRequest > request = new DefaultRequest < DeleteLoadBalancerListenersRequest > ( deleteLoadBalancerListenersRequest , " AmazonElasticLoadBalancing " ) ; request . addParameter ( " Action " , " DeleteLoadBalancerListeners " ) ; request . addParameter ( " Version " , "2010-07-01" ) ; if ( deleteLoadBalancerListenersRequest != null ) { if ( deleteLoadBalancerListenersRequest . getLoadBalancerName ( ) != null ) { request . addParameter ( " LoadBalancerName " , StringUtils . fromString ( deleteLoadBalancerListenersRequest . getLoadBalancerName ( ) ) ) ; } } if ( deleteLoadBalancerListenersRequest != null ) { java . util . List < Integer > loadBalancerPortsList = deleteLoadBalancerListenersRequest . getLoadBalancerPorts ( ) ; int loadBalancerPortsListIndex = 1 ; for ( Integer loadBalancerPortsListValue : loadBalancerPortsList ) { if ( loadBalancerPortsListValue != null ) { request . addParameter ( " LoadBalancerPorts . member . " + loadBalancerPortsListIndex , StringUtils . fromInteger ( loadBalancerPortsListValue ) ) ; } loadBalancerPortsListIndex ++ ; } } return request ; }
 @ Override public void getRepositoryData ( ActionListener < RepositoryData > listener ) { final IndexId indexId = new IndexId ( indexName , " blah " ) ; listener . onResponse ( new RepositoryData ( EMPTY_REPO_GEN , Map . of ( ) , Map . of ( ) , Map . of ( ) , Map . of ( indexId , Set . of ( ) ) , ShardGenerations . EMPTY ) ) ; }
 @ Override public final CompletableFuture < Void > closeAsync ( ) { synchronized ( lock ) { if ( terminationFuture == null ) { this . terminationFuture = FutureUtils . composeAfterwards ( closeHandlerAsync ( ) , inFlightRequestTracker :: awaitAsync ) ; } else { log . warn ( " The ▁ handler ▁ instance ▁ for ▁ { } ▁ had ▁ already ▁ been ▁ closed , ▁ but ▁ another ▁ attempt ▁ at ▁ closing ▁ it ▁ was ▁ made . " , untypedResponseMessageHeaders . getTargetRestEndpointURL ( ) ) ; } return this . terminationFuture ; } }
 public boolean contains ( int index ) { return index >= getFirst ( ) && index <= getLast ( ) ; }
 public MobileChunkServer ( World world , EntityShip entityship ) { super ( world , entityship ) ; sendQueue = new HashSet < ChunkPosition > ( ) ; }
 public boolean isSetPt ( ) { return ( ( this . pt != null ) && ( ! this . pt . isEmpty ( ) ) ) ; }
 public EReference getTHumanInteractions_Import ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public String getQuotaName ( ) { if ( quotaName == null && getQuota ( ) != null ) { quotaName = getQuota ( ) . getQuotaName ( ) ; } return quotaName ; }
 public void setVdsGroupId ( final Guid value ) { mVdsGroupId = value ; }
 private void get ( VM vm0 , final Object key , final Object value ) { vm0 . invoke ( new SerializableRunnable ( " Put ▁ data " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; assertEquals ( value , region . get ( key ) ) ; } } ) ; }
 if ( retryInfo != null ) { this . conduit . getCancelCriterion ( ) . checkCancelInProgress ( null ) ; }
 @ SideOnly ( Side . CLIENT ) @ Override public void addTooltip ( List < String > list ) { list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning1" ) ) ; list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning2" ) ) ; list . add ( TextFormatting . RED + TextHelper . translate ( " structures . warning3" ) ) ; }
 @ Override public String getPropertyName ( ) { return property ; }
 public YoggException ( String message ) { super ( message ) ; }
 private void logError ( String msg ) { if ( log . isErrorEnabled ( ) ) { log . error ( msg ) ; } }
 public EReference getTPresentationElements_Subject ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 , optionContext = ConverterHint . MEMBERIDNAME , help = CliStrings . CREATE_GATEWAYRECEIVER__MEMBER__HELP ) String [ ] onMember , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__MANUALSTART , help = CliStrings . CREATE_GATEWAYRECEIVER__MANUALSTART__HELP ) Boolean manualStart , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__STARTPORT , help = CliStrings . CREATE_GATEWAYRECEIVER__STARTPORT__HELP ) Integer startPort , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__ENDPORT , help = CliStrings . CREATE_GATEWAYRECEIVER__ENDPORT__HELP ) Integer endPort , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__BINDADDRESS , help = CliStrings . CREATE_GATEWAYRECEIVER__BINDADDRESS__HELP ) String bindAddress , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__MAXTIMEBETWEENPINGS , help = CliStrings . CREATE_GATEWAYRECEIVER__MAXTIMEBETWEENPINGS__HELP ) Integer maximumTimeBetweenPings , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__SOCKETBUFFERSIZE , help = CliStrings . CREATE_GATEWAYRECEIVER__SOCKETBUFFERSIZE__HELP ) Integer socketBufferSize , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER , help = CliStrings . CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER__HELP ) String [ ] gatewayTransportFilters , @ CliOption ( key = CliStrings . CREATE_GATEWAYRECEIVER__HOSTNAMEFORSENDERS , help = CliStrings . CREATE_GATEWAYRECEIVER__HOSTNAMEFORSENDERS__HELP ) String hostnameForSenders ) { GatewayReceiverFunctionArgs gatewayReceiverFunctionArgs = new GatewayReceiverFunctionArgs ( manualStart , startPort , endPort , bindAddress , socketBufferSize , maximumTimeBetweenPings , gatewayTransportFilters , hostnameForSenders ) ; Set < DistributedMember > membersToCreateGatewayReceiverOn = getMembers ( onGroups , onMember ) ; List < CliFunctionResult > gatewayReceiverCreateResults = executeAndGetFunctionResult ( GatewayReceiverCreateFunction . INSTANCE , gatewayReceiverFunctionArgs , membersToCreateGatewayReceiverOn ) ; CommandResult result = ResultBuilder . buildResult ( gatewayReceiverCreateResults ) ; XmlEntity xmlEntity = findXmlEntity ( gatewayReceiverCreateResults ) ; if ( xmlEntity == null ) { return result ; } if ( onMember != null || getSharedConfiguration ( ) == null ) { result . setCommandPersisted ( false ) ; return result ; } getSharedConfiguration ( ) . addXmlEntity ( xmlEntity , onGroups ) ; return result ; }
 public List < Artifact > getStaticModeParamsForDynamicLibraryLibraries ( ) { ImmutableList . Builder < Artifact > artifactListBuilder = ImmutableList . builder ( ) ; for ( LibraryToLink library : getLibraries ( ) . toList ( ) ) { if ( library . getPicStaticLibrary ( ) != null ) { artifactListBuilder . add ( library . getPicStaticLibrary ( ) ) ; } else if ( library . getStaticLibrary ( ) != null ) { artifactListBuilder . add ( library . getStaticLibrary ( ) ) ; } else if ( library . getInterfaceLibrary ( ) != null ) { artifactListBuilder . add ( library . getInterfaceLibrary ( ) ) ; } else { artifactListBuilder . add ( library . getDynamicLibrary ( ) ) ; } } return artifactListBuilder . build ( ) ; }
 public Guid getVdsGroupId ( ) { if ( mVdsGroupId != null ) { return mVdsGroupId ; } else if ( getVdsGroup ( ) != null ) { mVdsGroupId = getVdsGroup ( ) . getId ( ) ; return mVdsGroupId ; } else { return Guid . Empty ; } }
 @ XmlElement @ Column ( name = PAYER_ID_COLUMN_NAME ) public String getPayerId ( ) { return payerId ; }
 public Mathjax ( Properties property ) { super ( property ) ; }
 public EReference getTEscalation_ToParts ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 protected VmNetworkInterfaceDAO getVmNetworkInterfaceDAO ( ) { return getDbFacade ( ) . getVmNetworkInterfaceDAO ( ) ; }
 public int getNextLevel ( Collection < SSTableReader > sstables ) { int maximumLevel = Integer . MIN_VALUE ; int minimumLevel = Integer . MAX_VALUE ; for ( SSTableReader sstable : sstables ) { maximumLevel = Math . max ( sstable . getSSTableLevel ( ) , maximumLevel ) ; minimumLevel = Math . min ( sstable . getSSTableLevel ( ) , minimumLevel ) ; } int newLevel ; if ( minimumLevel == 0 && minimumLevel == maximumLevel && SSTable . getTotalBytes ( sstables ) < maxSSTableSizeInBytes ) { newLevel = 0 ; } else { newLevel = minimumLevel == maximumLevel ? maximumLevel + 1 : maximumLevel ; newLevel = skipLevels ( newLevel , sstables ) ; assert newLevel > 0 ; } return newLevel ; }
 protected void fireEditingCanceled ( ) { CellEditorListener [ ] listeners = getCellEditorListeners ( ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { listeners [ i ] . editingCanceled ( getChangeEvent ( ) ) ; } }
 public EClass getTParameter ( ) { return tParameterEClass ; }
 @ Override public String startVerification ( ) { return null ; }
 public StorageDomainDAO getStorageDomainDAO ( ) { return getDbFacade ( ) . getStorageDomainDAO ( ) ; }
 private void put ( VM vm0 , final Object key , final Object value ) { vm0 . invoke ( new SerializableRunnable ( " Put ▁ data " ) { public void run ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; region . put ( key , value ) ; } } ) ; }
 if ( destinations . length == 1 ) { return sendToOne ( mgr , destinations , msg , ackWaitThreshold , ackSAThreshold ) ; }
 @ Override @ FxThread public void openFile ( @ NotNull final Path file ) { super . openFile ( file ) ; try { doOpenFile ( file ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } EXECUTOR_MANAGER . addFxTask ( this :: loadState ) ; }
 , orphanRemoval = true ) public Address getAddress ( ) { return address ; }
 public EReference getDocumentRoot_TaskStakeholders ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 20 ) ; }
 public RestoreOnlyRepository ( String indexName ) { this . indexName = indexName ; }
 public EAttribute getTExtension_Namespace ( ) { return ( EAttribute ) tExtensionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public void setDataKindReferenceID ( List < String > dataKindReferenceID ) { this . dataKindReferenceID = dataKindReferenceID ; }
 default boolean isRunning ( ) { throw new IllegalStateException ( " The ▁ runnable ▁ state ▁ of ▁ this ▁ object ▁ cannot ▁ be ▁ determined " ) ; }
 @ Override protected void loadXml ( ) { setContentView ( R . layout . activity_add_area_check ) ; }
 @ JsonProperty ( " IsMediaAssignmentAllowed " ) public Boolean getIsMediaAssignmentAllowed ( ) { return isMediaAssignmentAllowed ; }
 public EReference getTEscalation_Reassignment ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
 public DistributionConfig getDMConfig ( ) { if ( dm != null ) { return dm . getConfig ( ) ; } else { return null ; } }
 public void setManagement ( boolean mgmt ) { this . mgmt = mgmt ; }
 final long getPointer ( ) { return this . currentPointer ; }
 public Object getProperty ( String name ) throws IllegalArgumentException { throw new IllegalArgumentException ( " Property ▁ not ▁ supported : ▁ " + name ) ; }
 @ Override public void stop ( ) { }
 public AssociationRenderer ( boolean reversed ) { super ( Constants . EDGE_TYPE_LINE , reversed ? Constants . EDGE_ARROW_REVERSE : Constants . EDGE_ARROW_FORWARD ) ; this . reversed = reversed ; }
 @ Override public boolean equals ( Object otherObject ) { if ( ! ( otherObject instanceof CcLinkingContext ) ) { return false ; } CcLinkingContext other = ( CcLinkingContext ) otherObject ; if ( this == other ) { return true ; } return this . linkerInputs . shallowEquals ( other . linkerInputs ) ; }
 public void subdeflate ( org . apache . cassandra . db . migration . avro . Migration mi ) { org . apache . cassandra . db . migration . avro . RenameColumnFamily rcf = new org . apache . cassandra . db . migration . avro . RenameColumnFamily ( ) ; rcf . ksname = new org . apache . avro . util . Utf8 ( tableName ) ; rcf . cfid = cfId ; rcf . old_cfname = new org . apache . avro . util . Utf8 ( oldName ) ; rcf . new_cfname = new org . apache . avro . util . Utf8 ( newName ) ; mi . migration = rcf ; }
 @ Override public RuleClass build ( RuleClass . Builder builder , RuleDefinitionEnvironment environment ) { builder . setUndocumented ( ) . add ( attr ( " : android _ sdk " , LABEL ) . allowedRuleClasses ( " android _ sdk " ) . value ( getAndroidSdkLabel ( environment . getToolsLabel ( DEFAULT_SDK ) ) ) ) ; if ( compatibleWithAndroidEnvironments . length > 0 ) { builder . compatibleWith ( compatibleWithAndroidEnvironments ) ; } return builder . build ( ) ; }
 public String toString ( ) { return id + " , ▁ Pattern : " + regex . pattern ( ) . toString ( ) ; }
 @ Test public void aJustCreatedBeanWithTwoHoursOfKeepaliveIsAliveAfterASecond ( ) { QNCacheBean < Object > bean = new QNCacheBean < Object > ( A_VALUE , now ( ) , TWO_HOURS ) ; assertTrue ( bean . isAlive ( oneSecondFromNow ( ) ) ) ; }
 private SimpleQueryCriteria createQueryCriteria ( HumanTaskServerConfiguration serverConfiguration ) { SimpleQueryCriteria queryCriteria = new SimpleQueryCriteria ( ) ; queryCriteria . setSimpleQueryType ( SimpleQueryCriteria . QueryType . REMOVE_TASKS ) ; queryCriteria . setStatuses ( serverConfiguration . getRemovableTaskStatuses ( ) ) ; return queryCriteria ; }
 protected SchemaAlteringStatement ( ) { super ( null ) ; this . isColumnFamilyLevel = false ; }
 public ApplicationException ( String msg ) { super ( msg ) ; }
 public EClass getTDeadlines ( ) { return tDeadlinesEClass ; }
 public RoleDAO getRoleDao ( ) { return getDbFacade ( ) . getRoleDAO ( ) ; }
 public Address ( ) { }
 public int getPageId ( ) { return pageId ; }
 public void updateColumnSetPerRow ( long columnSetInRow ) { }
 void insertIntoBucket ( long key , int hashCode , int size , long address ) throws IOException { this . buildSideRecordCounter ++ ; updateMinMax ( key ) ; final int bufferNum = ( int ) ( address >>> this . segmentSizeBits ) ; final int offset = ( int ) ( address & ( this . segmentSize - 1 ) ) ; updateIndex ( key , hashCode , address , size , partitionBuffers [ bufferNum ] , offset ) ; }
 public String getTitle ( ) { return title ; }
 @ NonNull public final Observable < T > asObservable ( ) { return mObservable . skip ( 1 ) ; }
 public LinkerInput ( Label owner , ImmutableList < LibraryToLink > libraries , ImmutableList < LinkOptions > userLinkFlags , ImmutableList < Artifact > nonCodeInputs , ImmutableList < Linkstamp > linkstamps ) { this . owner = owner ; this . libraries = libraries ; this . userLinkFlags = userLinkFlags ; this . nonCodeInputs = nonCodeInputs ; this . linkstamps = linkstamps ; }
 public IVdcUser getCurrentUser ( ) { return mVdcUser ; }
 int spill ( BlockChannelWriter < MemorySegment > writer ) throws IOException { this . writer = writer ; final int numSegments = this . targetList . size ( ) ; for ( MemorySegment segment : this . targetList ) { this . writer . writeBlock ( segment ) ; } this . targetList . clear ( ) ; return numSegments ; }
 catch ( Exception e ) { lines . clear ( ) ; System . out . println ( " There ▁ is ▁ an ▁ error ▁ with ▁ the ▁ ad ▁ file ▁ at ▁ " + random ) ; if ( type == " scoreboard " ) { int number = Phrases . config . getStringList ( " ad _ error _ scoreboard " ) . size ( ) ; for ( String line : Phrases . config . getStringList ( " ad _ error _ scoreboard " ) ) { number -- ; lines . put ( number , line ) ; } } else { lines . put ( 1 , Phrases . config . getString ( " ad _ error " ) ) ; } }
 public List < String > getDataKindReferenceID ( ) { if ( dataKindReferenceID == null ) { dataKindReferenceID = new ArrayList < String > ( ) ; } return dataKindReferenceID ; }
 @ Override @ FxThread protected double getCollapsedPosition ( ) { return 1 ; }
 @ RequestMapping ( value = " / edit . jsp " , method = RequestMethod . POST ) public ModelAndView edit ( HttpServletRequest request , @ RequestParam ( " msgid " ) int msgid , @ RequestParam ( value = " lastEdit " , required = false ) Long lastEdit , @ RequestParam ( value = " chgrp " , required = false ) Integer changeGroupId , @ Valid @ ModelAttribute ( " form " ) EditTopicRequest form , Errors errors , @ ModelAttribute ( " ipBlockInfo " ) IPBlockInfo ipBlockInfo ) throws Exception { Template tmpl = Template . getTemplate ( request ) ; if ( ! tmpl . isSessionAuthorized ( ) ) { throw new AccessViolationException ( " Not ▁ authorized " ) ; } Map < String , Object > params = new HashMap < > ( ) ; final Topic message = messageDao . getById ( msgid ) ; PreparedTopic preparedTopic = prepareService . prepareTopic ( message , request . isSecure ( ) , tmpl . getCurrentUser ( ) ) ; Group group = preparedTopic . getGroup ( ) ; User user = tmpl . getCurrentUser ( ) ; IPBlockDao . checkBlockIP ( ipBlockInfo , errors , user ) ; boolean tagsEditable = permissionService . isTagsEditable ( preparedTopic , user ) ; boolean editable = permissionService . isEditable ( preparedTopic , user ) ; if ( ! editable && ! tagsEditable ) { throw new AccessViolationException ( " это ▁ сообщение ▁ нельзя ▁ править " ) ; } params . put ( " message " , message ) ; params . put ( " preparedMessage " , preparedTopic ) ; params . put ( " group " , group ) ; params . put ( " topicMenu " , prepareService . getTopicMenu ( preparedTopic , tmpl . getCurrentUser ( ) , tmpl . getProf ( ) , true ) ) ; params . put ( " groups " , groupDao . getGroups ( preparedTopic . getSection ( ) ) ) ; if ( editable ) { String title = request . getParameter ( " title " ) ; if ( title == null || title . trim ( ) . isEmpty ( ) ) { throw new BadInputException ( " заголовок ▁ сообщения ▁ не ▁ может ▁ быть ▁ пустым " ) ; } } boolean preview = request . getParameter ( " preview " ) != null ; if ( preview ) { params . put ( " info " , " Предпросмотр " ) ; } boolean publish = request . getParameter ( " publish " ) != null ; List < EditHistoryRecord > editInfoList = editHistoryService . getEditInfo ( message . getId ( ) , EditHistoryObjectTypeEnum . TOPIC ) ; if ( ! editInfoList . isEmpty ( ) ) { EditHistoryRecord editHistoryRecord = editInfoList . get ( 0 ) ; params . put ( " editInfo " , editHistoryRecord ) ; if ( lastEdit == null || editHistoryRecord . getEditdate ( ) . getTime ( ) != lastEdit ) { errors . reject ( null , " Сообщение ▁ было ▁ отредактировано ▁ независимо " ) ; } } boolean commit = request . getParameter ( " commit " ) != null ; if ( commit ) { user . checkCommit ( ) ; if ( message . isCommited ( ) ) { throw new BadInputException ( " сообщение ▁ уже ▁ подтверждено " ) ; } } params . put ( " commit " , ! message . isCommited ( ) && preparedTopic . getSection ( ) . isPremoderated ( ) && user . isModerator ( ) ) ; Topic newMsg = new Topic ( group , message , form , publish ) ; boolean modified = false ; if ( ! message . getTitle ( ) . equals ( newMsg . getTitle ( ) ) ) { modified = true ; } if ( form . getMsg ( ) != null ) { String oldText = msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ; if ( ! oldText . equals ( form . getMsg ( ) ) ) { modified = true ; } } if ( message . getLinktext ( ) == null ) { if ( newMsg . getLinktext ( ) != null ) { modified = true ; } } else if ( ! message . getLinktext ( ) . equals ( newMsg . getLinktext ( ) ) ) { modified = true ; } if ( group . isLinksAllowed ( ) ) { if ( message . getUrl ( ) == null ) { if ( newMsg . getUrl ( ) != null ) { modified = true ; } } else if ( ! message . getUrl ( ) . equals ( newMsg . getUrl ( ) ) ) { modified = true ; } } UploadedImagePreview imagePreview = null ; if ( permissionService . isImagePostingAllowed ( preparedTopic . getSection ( ) , user ) ) { if ( permissionService . isTopicPostingAllowed ( group , user ) ) { File image = imageService . processUploadImage ( request ) ; imagePreview = imageService . processUpload ( user , request . getSession ( ) , image , errors ) ; if ( imagePreview != null ) { modified = true ; } } } if ( ! editable && modified ) { throw new AccessViolationException ( " нельзя ▁ править ▁ это ▁ сообщение , ▁ только ▁ теги " ) ; } if ( form . getMinor ( ) != null && ! tmpl . isModeratorSession ( ) ) { throw new AccessViolationException ( " вы ▁ не ▁ можете ▁ менять ▁ статус ▁ новости " ) ; } List < String > newTags = null ; if ( form . getTags ( ) != null ) { newTags = TagName . parseAndSanitizeTags ( form . getTags ( ) ) ; } if ( changeGroupId != null ) { if ( message . getGroupId ( ) != changeGroupId ) { Group changeGroup = groupDao . getGroup ( changeGroupId ) ; int section = message . getSectionId ( ) ; if ( changeGroup . getSectionId ( ) != section ) { throw new AccessViolationException ( " Can ' t ▁ move ▁ topics ▁ between ▁ sections " ) ; } } } Poll newPoll = null ; if ( preparedTopic . getSection ( ) . isPollPostAllowed ( ) && form . getPoll ( ) != null && tmpl . isModeratorSession ( ) ) { newPoll = buildNewPoll ( message , form ) ; } String newText ; if ( form . getMsg ( ) != null ) { newText = form . getMsg ( ) ; } else { newText = msgbaseDao . getMessageText ( message . getId ( ) ) . getText ( ) ; } if ( form . getEditorBonus ( ) != null ) { ImmutableSet < Integer > editors = editHistoryService . getEditors ( message , editInfoList ) ; form . getEditorBonus ( ) . keySet ( ) . stream ( ) . filter ( userid -> ! editors . contains ( userid ) ) . forEach ( userid -> errors . reject ( " editorBonus " , " некорректный ▁ корректор ? ! " ) ) ; } if ( ! preview && ! errors . hasErrors ( ) && ipBlockInfo . isCaptchaRequired ( ) ) { captcha . checkCaptcha ( request , errors ) ; } if ( ! preview && ! errors . hasErrors ( ) ) { boolean changed = topicService . updateAndCommit ( newMsg , message , user , newTags , newText , commit , changeGroupId , form . getBonus ( ) , newPoll != null ? newPoll . getVariants ( ) : null , form . isMultiselect ( ) , form . getEditorBonus ( ) , imagePreview ) ; if ( changed || commit || publish ) { if ( ! newMsg . isDraft ( ) ) { searchQueueSender . updateMessage ( newMsg . getId ( ) , true ) ; } if ( ! publish || ! preparedTopic . getSection ( ) . isPremoderated ( ) ) { return new ModelAndView ( new RedirectView ( TopicLinkBuilder . baseLink ( message ) . forceLastmod ( ) . build ( ) ) ) ; } else { params . put ( " moderated " , true ) ; params . put ( " url " , TopicLinkBuilder . baseLink ( message ) . forceLastmod ( ) . build ( ) ) ; return new ModelAndView ( " add - done - moderated " , params ) ; } } else { errors . reject ( null , " Нет ▁ изменений " ) ; } } params . put ( " newMsg " , newMsg ) ; Image imageObject = null ; if ( imagePreview != null ) { imageObject = new Image ( 0 , 0 , " gallery / preview / " + imagePreview . mainFile ( ) . getName ( ) ) ; } params . put ( " newPreparedMessage " , prepareService . prepareTopicPreview ( newMsg , newTags != null ? TagService . namesToRefs ( newTags ) : null , newPoll , request . isSecure ( ) , newText , imageObject ) ) ; return new ModelAndView ( " edit " , params ) ; }
 @ Test public void test0002 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0011" , " $ { true ▁ & & ▁ null } " , " false " ) ; }
 @ FxThread protected void loadState ( ) { final Supplier < EditorState > stateFactory = getEditorStateFactory ( ) ; if ( stateFactory == null ) { return ; } final WorkspaceManager workspaceManager = WorkspaceManager . getInstance ( ) ; final Workspace currentWorkspace = notNull ( workspaceManager . getCurrentWorkspace ( ) ) ; editorState = currentWorkspace . getEditorState ( getEditFile ( ) , stateFactory ) ; }
 if ( Submit . wholeTopicEnabled ( cfg ) ) { return completeChangeSetIncludingTopics ( db , new ChangeSet ( cd ) , user ) ; }
 public void setDateOfBirth ( final Date dateOfBirth ) { this . dateOfBirth = dateOfBirth ; }
 public void addAll ( Img ... values ) { if ( values != null && values . length > 0 ) { for ( Img val : values ) { add ( val ) ; } } }
 public void init ( ) { System . out . println ( " init ▁ called , ▁ Bean ▁ created : ▁ " + this ) ; }
 protected void setVmName ( final String value ) { mVmName = value ; }
 public String GetCustomValue ( final String name ) { if ( customValues . containsKey ( name ) ) { return customValues . get ( name ) ; } return " " ; }
 public void addBackup ( int part , int heap , long offheap , long swap ) { backup . add ( new VisorCachePartition ( part , heap , offheap , swap ) ) ; }
 public Guid getVmTemplateId ( ) { return getVmTemplateIdRef ( ) != null ? getVmTemplateIdRef ( ) . getValue ( ) : Guid . Empty ; }
 @ Override public void applyTypeHinting ( ParameterEntity parameter ) { parameter . setType ( HintType . ARRAY ) ; }
 public NGuid getJobId ( ) { return jobId ; }
 public boolean setSemiMajorAxis ( String aSemiMajorAxis ) { boolean wasSet = false ; semiMajorAxis = aSemiMajorAxis ; wasSet = true ; return wasSet ; }
 @ Override public Throwable getLastThrowable ( ) { return this . lastThrowable ; }
 private void setNewBuckets ( MemorySegment [ ] buckets , int numBuckets ) { for ( MemorySegment segment : buckets ) { for ( int i = 0 ; i < segmentSize ; i += 16 ) { segment . putLong ( i , 0 ) ; segment . putLong ( i + 8 , INVALID_ADDRESS ) ; } } this . buckets = buckets ; checkArgument ( MathUtils . isPowerOf2 ( numBuckets ) ) ; this . numBuckets = numBuckets ; this . numBucketsMask = numBuckets - 1 ; this . numKeys = 0 ; }
 public EClass getTExtensibleMixedContentElements ( ) { return tExtensibleMixedContentElementsEClass ; }
 public EDataType getTUser ( ) { return tUserEDataType ; }
 @ Override public void cancel ( InterpreterContext context ) { }
 public EClass getTTaskInterface ( ) { return tTaskInterfaceEClass ; }
 public EReference getTTask_PresentationElements ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
 public String getSnapshotName ( ) { return privateSnapshotName ; }
 public EClass getTReassignment ( ) { return tReassignmentEClass ; }
 public List < VisorCachePartition > backup ( ) { return backup ; }
 public NewResource ( ) { }
 @ Override protected void respondAsLeader ( ChannelHandlerContext ctx , RoutedRequest routedRequest , T gateway ) { HttpRequest httpRequest = routedRequest . getRequest ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " Received ▁ request ▁ " + httpRequest . uri ( ) + ' . ' ) ; } FileUploads uploadedFiles = null ; try { if ( ! inFlightRequestTracker . registerRequest ( ) ) { log . debug ( " The ▁ handler ▁ instance ▁ for ▁ { } ▁ had ▁ already ▁ been ▁ closed . " , untypedResponseMessageHeaders . getTargetRestEndpointURL ( ) ) ; ctx . channel ( ) . close ( ) ; return ; } if ( ! ( httpRequest instanceof FullHttpRequest ) ) { log . error ( " Implementation ▁ error : ▁ Received ▁ a ▁ request ▁ that ▁ wasn ' t ▁ a ▁ FullHttpRequest . " ) ; throw new RestHandlerException ( " Bad ▁ request ▁ received . " , HttpResponseStatus . BAD_REQUEST ) ; } final ByteBuf msgContent = ( ( FullHttpRequest ) httpRequest ) . content ( ) ; uploadedFiles = FileUploadHandler . getMultipartFileUploads ( ctx ) ; if ( ! untypedResponseMessageHeaders . acceptsFileUploads ( ) && ! uploadedFiles . getUploadedFiles ( ) . isEmpty ( ) ) { throw new RestHandlerException ( " File ▁ uploads ▁ not ▁ allowed . " , HttpResponseStatus . BAD_REQUEST ) ; } R request ; if ( msgContent . capacity ( ) == 0 ) { try { request = MAPPER . readValue ( " { } " , untypedResponseMessageHeaders . getRequestClass ( ) ) ; } catch ( JsonParseException | JsonMappingException je ) { throw new RestHandlerException ( " Bad ▁ request ▁ received . ▁ Request ▁ did ▁ not ▁ conform ▁ to ▁ expected ▁ format . " , HttpResponseStatus . BAD_REQUEST , je ) ; } } else { try { InputStream in = new ByteBufInputStream ( msgContent ) ; request = MAPPER . readValue ( in , untypedResponseMessageHeaders . getRequestClass ( ) ) ; } catch ( JsonParseException | JsonMappingException je ) { throw new RestHandlerException ( String . format ( " Request ▁ did ▁ not ▁ match ▁ expected ▁ format ▁ % s . " , untypedResponseMessageHeaders . getRequestClass ( ) . getSimpleName ( ) ) , HttpResponseStatus . BAD_REQUEST , je ) ; } } final HandlerRequest < R , M > handlerRequest ; try { handlerRequest = new HandlerRequest < R , M > ( request , untypedResponseMessageHeaders . getUnresolvedMessageParameters ( ) , routedRequest . getRouteResult ( ) . pathParams ( ) , routedRequest . getRouteResult ( ) . queryParams ( ) , uploadedFiles . getUploadedFiles ( ) ) ; } catch ( HandlerRequestException hre ) { log . error ( " Could ▁ not ▁ create ▁ the ▁ handler ▁ request . " , hre ) ; throw new RestHandlerException ( String . format ( " Bad ▁ request , ▁ could ▁ not ▁ parse ▁ parameters : ▁ % s " , hre . getMessage ( ) ) , HttpResponseStatus . BAD_REQUEST , hre ) ; } log . trace ( " Starting ▁ request ▁ processing . " ) ; CompletableFuture < Void > requestProcessingFuture = respondToRequest ( ctx , httpRequest , handlerRequest , gateway ) ; final FileUploads finalUploadedFiles = uploadedFiles ; requestProcessingFuture . handle ( ( Void ignored , Throwable throwable ) -> { if ( throwable != null ) { return handleException ( ExceptionUtils . stripCompletionException ( throwable ) , ctx , httpRequest ) ; } return CompletableFuture . < Void > completedFuture ( null ) ; } ) . thenCompose ( Function . identity ( ) ) . whenComplete ( ( Void ignored , Throwable throwable ) -> { if ( throwable != null ) { log . warn ( " An ▁ exception ▁ occurred ▁ while ▁ handling ▁ another ▁ exception . " , throwable ) ; } finalizeRequestProcessing ( finalUploadedFiles ) ; } ) ; } catch ( Throwable e ) { final FileUploads finalUploadedFiles = uploadedFiles ; handleException ( e , ctx , httpRequest ) . whenComplete ( ( Void ignored , Throwable throwable ) -> finalizeRequestProcessing ( finalUploadedFiles ) ) ; } }
 public String getEtag ( ) { return etag ; }
 @ Override public int getPriority ( ) { return 5 ; }
 public void getChannelStates ( DistributedMember member , Map result ) { TCPConduit tc = this . conduit ; if ( tc != null ) { tc . getThreadOwnedOrderedConnectionState ( member , result ) ; } }
 public EDataType getTPotentialDelegateesObject ( ) { return tPotentialDelegateesObjectEDataType ; }
 @ Override public Term fromJSONObject ( Object parsed ) throws MarshalException { if ( parsed instanceof String ) parsed = Json . decodeJson ( ( String ) parsed ) ; if ( ! ( parsed instanceof List ) ) throw new MarshalException ( String . format ( " Expected ▁ a ▁ list , ▁ but ▁ got ▁ a ▁ % s : ▁ % s " , parsed . getClass ( ) . getSimpleName ( ) , parsed ) ) ; List list = ( List ) parsed ; List < Term > terms = new ArrayList < > ( list . size ( ) ) ; for ( Object element : list ) { if ( element == null ) throw new MarshalException ( " Invalid ▁ null ▁ element ▁ in ▁ list " ) ; terms . add ( elements . fromJSONObject ( element ) ) ; } return new Lists . DelayedValue ( terms ) ; }
 private ConnectExceptions getConnections ( Membership mgr , DistributionMessage msg , InternalDistributedMember [ ] destinations , boolean preserveOrder , boolean retry , long ackTimeout , long ackSDTimeout , List cons ) { ConnectExceptions ce = null ; for ( int i = 0 ; i < destinations . length ; i ++ ) { InternalDistributedMember destination = destinations [ i ] ; if ( destination == null ) { continue ; } if ( localAddr . equals ( destination ) ) { continue ; } if ( ! mgr . memberExists ( destination ) || mgr . shutdownInProgress ( ) || mgr . isShunned ( destination ) ) { if ( logger . isTraceEnabled ( LogMarker . DM_VERBOSE ) ) { logger . trace ( LogMarker . DM_VERBOSE , " Not ▁ a ▁ member : ▁ { } " , destination ) ; } if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( destination , new ShunnedMemberException ( String . format ( " Member ▁ is ▁ being ▁ shunned : ▁ % s " , destination ) ) ) ; } else { try { long startTime = 0 ; if ( ackTimeout > 0 ) { startTime = System . currentTimeMillis ( ) ; } Connection con = conduit . getConnection ( destination , preserveOrder , retry , startTime , ackTimeout , ackSDTimeout ) ; con . setInUse ( true , startTime , 0 , 0 , null ) ; cons . add ( con ) ; if ( con . isSharedResource ( ) && msg instanceof DirectReplyMessage ) { DirectReplyMessage directMessage = ( DirectReplyMessage ) msg ; directMessage . registerProcessor ( ) ; } } catch ( IOException ex ) { if ( ce == null ) { ce = new ConnectExceptions ( ) ; } ce . addFailure ( destination , ex ) ; } } } return ce ; }
 @ Nonnull public Group getGroup ( Section section , String name ) throws GroupNotFoundException { Optional < Group > group = getGroupOpt ( section , name , false ) ; if ( group . isEmpty ( ) ) { logger . info ( " Group ▁ ' { } ' ▁ not ▁ found ▁ in ▁ section ▁ { } " , name , section . getUrlName ( ) ) ; throw new GroupNotFoundException ( " group ▁ not ▁ found " ) ; } else { return group . get ( ) ; } }
 @ Override public long contentLength ( ) { return writeOrCountBytes ( null , true ) ; }
 private List < SetterReturnObject > setProbability ( ProbabilisticParameter value ) throws ApolloSetterException { ProbabilisticParameterSetter setter = new ProbabilisticParameterSetter ( apolloTranslationEngine , type + " . " + PROBABILITY_FIELD , section ) ; return setter . set ( value ) ; }
 public YoggException ( ) { super ( ) ; }
 public EAttribute getTText_Lang ( ) { return ( EAttribute ) tTextEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ JsonProperty ( " DisplayName " ) public String getDisplayName ( ) { return displayName ; }
 protected void setVmTemplate ( final VmTemplate value ) { mVmTemplate = value ; }
 public EClass getTGenericHumanRole ( ) { return tGenericHumanRoleEClass ; }
 public VdsDAO getVdsDAO ( ) { return getDbFacade ( ) . getVdsDAO ( ) ; }
 int getPartitionNumber ( ) { return this . partitionNum ; }
 public EClass getTToParts ( ) { return tToPartsEClass ; }
 @ Override protected void initView ( ) { ivBack = ( ImageView ) findViewById ( R . id . activity_add_area_check_back ) ; tvSave = ( TextView ) findViewById ( R . id . activity_add_area_check_save ) ; etName = ( EditText ) findViewById ( R . id . area_name_et_activity_add_area_check ) ; elv = ( ExpandableListView ) findViewById ( R . id . activity_add_area_check_lv ) ; progressDialog = ProgressDialogHandle . getProgressDialog ( this , null ) ; }
 public void foo ( ) { System . out . println ( " abstract ▁ foo " ) ; }
 @ Override public Lifecycle . State lifecycleState ( ) { return null ; }
 @ Override public boolean equals ( Object otherObject ) { if ( ! ( otherObject instanceof LinkerInput ) ) { return false ; } LinkerInput other = ( LinkerInput ) otherObject ; if ( this == other ) { return true ; } return Objects . equal ( this . owner , other . owner ) && this . libraries . equals ( other . libraries ) && this . userLinkFlags . equals ( other . userLinkFlags ) && this . linkstamps . equals ( other . linkstamps ) && this . nonCodeInputs . equals ( other . nonCodeInputs ) ; }
 @ Test public void testPRNoLRUDelta ( ) { doPRNoLRUDeltaTest ( false ) ; }
 public Builder addLibraries ( List < LibraryToLink > libraries ) { hasDirectLinkerInput = true ; linkerInputBuilder . addLibraries ( libraries ) ; return this ; }
 public EAttribute getTNotificationInterface_PortType ( ) { return ( EAttribute ) tNotificationInterfaceEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 protected void setQuotaName ( final String value ) { quotaName = value ; }
 @ Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( " linkerInputs " , linkerInputs ) . toString ( ) ; }
 public Builder addLinkstamps ( List < Linkstamp > linkstamps ) { this . linkstamps . addAll ( linkstamps ) ; return this ; }
 public EReference getTGenericHumanRole_From ( ) { return ( EReference ) tGenericHumanRoleEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof TestObject ) ) return false ; TestObject other = ( TestObject ) obj ; if ( sizeForSerialization != other . sizeForSerialization ) return false ; if ( sizeForSizer != other . sizeForSizer ) return false ; return true ; }
 @ XmlElement @ Column ( name = DATE_OF_BIRTH_COLUMN_NAME ) public Date getDateOfBirth ( ) { return dateOfBirth ; }
 boolean threadOwnsResources ( ) { if ( dm != null ) { return dm . getSystem ( ) . threadOwnsResources ( ) && ! AlertingAction . isThreadAlerting ( ) ; } return false ; }
 public EAttribute getTGrouplist_Group ( ) { return ( EAttribute ) tGrouplistEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EClass getTFrom ( ) { return tFromEClass ; }
 private InternalChangeQuery query ( ) { Set < String > fields = ImmutableSet . of ( ChangeField . CHANGE . getName ( ) , ChangeField . PATCH_SET . getName ( ) ) ; return queryProvider . get ( ) . setRequestedFields ( fields ) ; }
 MatchIterator valueIter ( long address ) { iterator . set ( address ) ; return iterator ; }
 public EReference getDocumentRoot_Tasks ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 19 ) ; }
 @ Test ( expected = FieldEmptyException . class ) public void testFieldEmptyException ( ) { throw new FieldEmptyException ( " xml标签属性字段未找到的异常 " ) ; }
 @ Override public void removeLifecycleListener ( LifecycleListener listener ) { }
 @ Test public void testExportImport3 ( ) throws Exception { setup ( 10 , 10 * 4096 , true ) ; createJournal ( ) ; startJournal ( ) ; load ( ) ; add ( 1 , 2 ) ; journal . forceMoveNextFile ( ) ; delete ( 1 , 2 ) ; add ( 3 , 4 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 6 , 7 , 8 ) ; journal . forceMoveNextFile ( ) ; addTx ( 5 , 9 ) ; commit ( 5 ) ; journal . forceMoveNextFile ( ) ; deleteTx ( 10 , 6 , 7 , 8 , 9 ) ; commit ( 10 ) ; addTx ( 11 , 12 , 13 ) ; EncodingSupport xid = new SimpleEncoding ( 10 , ( byte ) 0 ) ; prepare ( 11 , xid ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; commit ( 11 ) ; stopJournal ( ) ; exportImportJournal ( ) ; createJournal ( ) ; startJournal ( ) ; loadAndCheck ( ) ; }
 if ( osLow . contains ( " win " ) ) { if ( osLow . contains ( "95" ) ) win95 = true ; else if ( osLow . contains ( "98" ) ) win98 = true ; else if ( osLow . contains ( " nt " ) ) winNt = true ; else if ( osLow . contains ( "2000" ) ) win2k = true ; else if ( osLow . contains ( " vista " ) ) winVista = true ; else if ( osLow . contains ( " xp " ) ) winXp = true ; else if ( osLow . contains ( "2003" ) ) win2003 = true ; else if ( osLow . contains ( "2008" ) ) win2008 = true ; else if ( osLow . contains ( "7" ) ) win7 = true ; else if ( osLow . contains ( "8.1" ) ) win81 = true ; else if ( osLow . contains ( "8" ) ) win8 = true ; else unknownWin = true ; }
 public String getSentence ( ) { return sentence ; }
 private void print ( Supplier < String > message ) { System . out . println ( message . get ( ) ) ; }
 if ( destinations == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Returning ▁ from ▁ DirectChannel ▁ send ▁ because ▁ null ▁ set ▁ passed ▁ in : ▁ { } " , msg ) ; } return 0 ; }
 public DataChangedNotifier ( ) { }
 @ Test public void testPRMemLRUAndFlagDeltaPutOnPrimary ( ) { doPRDeltaTestLRU ( false , false , true , false ) ; }
 public Builder setOwner ( Label owner ) { this . owner = owner ; return this ; }
 if ( locAddr . isAnyLocalAddress ( ) ) { IgniteBiTuple < Collection < String > , Collection < String > > res = cachedLocalAddr ; if ( res == null ) { List < InetAddress > localAddrs = new ArrayList < > ( ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) { for ( InetAddress addr : asIterable ( itf . getInetAddresses ( ) ) ) { if ( ! addr . isLinkLocalAddress ( ) ) localAddrs . add ( addr ) ; } } localAddrs = filterReachable ( localAddrs ) ; for ( InetAddress addr : localAddrs ) addresses ( addr , addrs , hostNames ) ; if ( F . isEmpty ( addrs ) ) throw new IgniteCheckedException ( " No ▁ network ▁ addresses ▁ found ▁ ( is ▁ networking ▁ enabled ? ) . " ) ; res = F . t ( addrs , hostNames ) ; cachedLocalAddr = res ; } return res ; }
 public void testCopyArea ( ) { GraphicsConfiguration gconf = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; VolatileImage vim = gconf . createCompatibleVolatileImage ( 20 , 20 ) ; Graphics2D g2 = ( Graphics2D ) vim . getGraphics ( ) ; g2 . setColor ( Color . WHITE ) ; g2 . fillRect ( 0 , 0 , 20 , 20 ) ; g2 . setColor ( Color . RED ) ; g2 . fillRect ( 2 , 2 , 1 , 1 ) ; g2 . copyArea ( 2 , 2 , 1 , 1 , 2 , 4 ) ; int pix [ ] = vim . getSnapshot ( ) . getRaster ( ) . getPixel ( 4 , 6 , ( int [ ] ) null ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 0 ] , 255 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 1 ] , 0 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ untranslated ▁ graphics " , pix [ 2 ] , 0 ) ; g2 . setTransform ( AffineTransform . getTranslateInstance ( 2 , 2 ) ) ; g2 . copyArea ( 0 , 0 , 1 , 1 , 4 , 8 ) ; pix = vim . getSnapshot ( ) . getRaster ( ) . getPixel ( 6 , 10 , ( int [ ] ) null ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 0 ] , 255 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 1 ] , 0 ) ; assertEquals ( " copyArea ▁ failed ▁ for ▁ translated ▁ graphics " , pix [ 2 ] , 0 ) ; }
 public ItemsRange ( int first , int count ) { this . first = first ; this . count = count ; }
 public void setSentence ( String sentence ) { this . sentence = sentence ; cleanQuery ( ) ; }
 public storage_domains getStorageDomain ( ) { if ( _storageDomain == null && getStorageDomainId ( ) != null ) { if ( _storagePoolId != null && getStoragePool ( ) != null ) { _storageDomain = getStorageDomainDAO ( ) . getForStoragePool ( getStorageDomainId ( ) . getValue ( ) , getStoragePool ( ) . getId ( ) ) ; } if ( _storageDomain == null ) { final List < storage_domains > storageDomainList = getStorageDomainDAO ( ) . getAllForStorageDomain ( getStorageDomainId ( ) . getValue ( ) ) ; if ( storageDomainList . size ( ) != 0 ) { _storageDomain = storageDomainList . get ( 0 ) ; for ( final storage_domains storageDomainFromList : storageDomainList ) { if ( storageDomainFromList . getstatus ( ) != null && storageDomainFromList . getstatus ( ) == StorageDomainStatus . Active ) { _storageDomain = storageDomainFromList ; break ; } } } } } return _storageDomain ; }
 public void toData ( DataOutput out ) throws IOException { DataSerializer . writeString ( value , out ) ; }
 @ JsonProperty ( " IsAllowBasePrice " ) public void setIsAllowBasePrice ( Boolean isAllowBasePrice ) { this . isAllowBasePrice = isAllowBasePrice ; }
 @ FromAnyThread protected @ Nullable S getEditorState ( ) { return editorState ; }
 int getBuildSideBlockCount ( ) { return this . partitionBuffers == null ? this . buildSideWriteBuffer . getBlockCount ( ) : this . partitionBuffers . length ; }
 temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; if ( eElement . hasAttribute ( " number " ) ) { lines . put ( Integer . parseInt ( eElement . getAttribute ( " number " ) ) , eElement . getTextContent ( ) ) ; } else { lines . put ( temp , eElement . getTextContent ( ) ) ; } } }
 ArrayImageList ( ArrayImage array ) { if ( array == null ) { this . array = new ArrayImage ( ) ; } else { this . array = array ; } }
 public int getFreeSlots ( ) { return pusher . getFreeSlots ( ) ; }
 public YoggException ( String message , Throwable cause ) { super ( message , cause ) ; }
 @ Override public void start ( ) { }
 public List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > getBuiltInConstraints ( Class < ? extends Annotation > annotationClass ) { final List < Class < ? extends ConstraintValidator < ? , ? > > > builtInList = builtinConstraints . get ( annotationClass ) ; if ( builtInList == null || builtInList . size ( ) == 0 ) { throw new ValidationException ( " Unable ▁ to ▁ find ▁ constraints ▁ for ▁ ▁ " + annotationClass ) ; } List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > constraints = new ArrayList < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > ( builtInList . size ( ) ) ; for ( Class < ? extends ConstraintValidator < ? , ? > > validatorClass : builtInList ) { @ SuppressWarnings ( " unchecked " ) Class < ConstraintValidator < ? extends Annotation , ? > > safeValidatorClass = ( Class < ConstraintValidator < ? extends Annotation , ? > > ) validatorClass ; constraints . add ( safeValidatorClass ) ; } return constraints ; }
 private KSMetaData makeNewKeyspaceDefinition ( KSMetaData ksm ) { CFMetaData oldCfm = ksm . cfMetaData ( ) . get ( oldName ) ; List < CFMetaData > newCfs = new ArrayList < CFMetaData > ( ksm . cfMetaData ( ) . values ( ) ) ; newCfs . remove ( oldCfm ) ; assert newCfs . size ( ) == ksm . cfMetaData ( ) . size ( ) - 1 ; CFMetaData newCfm = CFMetaData . rename ( oldCfm , newName ) ; newCfs . add ( newCfm ) ; return new KSMetaData ( ksm . name , ksm . strategyClass , ksm . strategyOptions , ksm . replicationFactor , newCfs . toArray ( new CFMetaData [ newCfs . size ( ) ] ) ) ; }
 public boolean isDroppedComplexDeletion ( DeletionTime complexDeletion ) { return currentDroppedComplex != null && complexDeletion . markedForDeleteAt ( ) <= currentDroppedComplex . droppedTime ; }
 public void setUserName ( final String value ) { mUserName = value ; }
 public Collection < ChunkPosition > getSendQueue ( ) { return sendQueue ; }
 public EAttribute getTDescription_ContentType ( ) { return ( EAttribute ) tDescriptionEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 protected GlusterVolumeEntity getGlusterVolume ( ) { if ( glusterVolume == null && glusterVolumeId != null ) { glusterVolume = getGlusterVolumeDao ( ) . getById ( glusterVolumeId . getValue ( ) ) ; } return glusterVolume ; }
 public EReference getDocumentRoot_OrganizationalEntity ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 12 ) ; }
 @ Override public int lastIndexOf ( Object object ) { if ( object instanceof Img ) { Img value = ( Img ) object ; return array . lastIndexOf ( value ) ; } return AbstractArrayList . NOT_FOUND ; }
 public EAttribute getTTask_Name ( ) { return ( EAttribute ) tTaskEClass . getEStructuralFeatures ( ) . get ( 9 ) ; }
 @ Override public Img get ( int index ) { if ( checkRange ( index ) ) { return array . get ( index ) ; } return null ; }
 public StoragePoolDAO getStoragePoolDAO ( ) { return getDbFacade ( ) . getStoragePoolDAO ( ) ; }
 com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner assigner = new com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner ( ) { public com . google . protobuf . ExtensionRegistry assignDescriptors ( com . google . protobuf . Descriptors . FileDescriptor root ) { descriptor = root ; return null ; } }
 public void waitForChannelState ( DistributedMember member , Map channelState ) throws InterruptedException { if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } TCPConduit tc = this . conduit ; if ( tc != null ) { tc . waitForThreadOwnedOrderedConnectionState ( member , channelState ) ; } }
 @ Override ArrayImage getArray ( ) { return array ; }
 public EReference getTTask_Outcome ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
 public storage_pool getStoragePool ( ) { if ( _storagePool == null && getStoragePoolId ( ) != null && ! Guid . Empty . equals ( getStoragePoolId ( ) ) ) { _storagePool = getStoragePoolDAO ( ) . get ( getStoragePoolId ( ) . getValue ( ) ) ; } return _storagePool ; }
 @ Override protected void registerListener ( ) { ivBack . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { onBackPressed ( ) ; } } ) ; tvSave . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { saveCheckArea ( ) ; } } ) ; elv . setOnChildClickListener ( new OnChildClickListener ( ) { @ Override public boolean onChildClick ( ExpandableListView parent , View v , int groupPosition , int childPosition , long id ) { CheckBox cBox = ( CheckBox ) v . findViewById ( R . id . item_add_book_check_listview_item_cbox ) ; if ( ! cBox . isChecked ( ) ) { cBox . setChecked ( true ) ; selInfoIds . add ( solutions . get ( groupPosition ) . children . get ( childPosition ) . sub_id ) ; } else { cBox . setChecked ( false ) ; selInfoIds . remove ( solutions . get ( groupPosition ) . children . get ( childPosition ) . sub_id ) ; } return false ; } } ) ; }
 public List < CTAdjPoint2D > getPt ( ) { if ( pt == null ) { pt = new ArrayList < CTAdjPoint2D > ( ) ; } return this . pt ; }
 public EClass getTTask ( ) { return tTaskEClass ; }
 public ListSerializer < T > getSerializer ( ) { return serializer ; }
 public EAttribute getTUserlist_User ( ) { return ( EAttribute ) tUserlistEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public void DefaultLog ( ) { }
 public EncodingStats deserialize ( DataInputPlus in ) throws IOException { long minTimestamp = in . readUnsignedVInt ( ) + TIMESTAMP_EPOCH ; int minLocalDeletionTime = ( int ) in . readUnsignedVInt ( ) + DELETION_TIME_EPOCH ; int minTTL = ( int ) in . readUnsignedVInt ( ) + TTL_EPOCH ; return new EncodingStats ( minTimestamp , minLocalDeletionTime , minTTL ) ; }
 public EAttribute getTQuery_Any ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 private CriterionTranslatorHelper ( ) { }
 public void setCampaigns ( ArrayOfCampaign value ) { this . campaigns = value ; }
 public ByteBuffer maybeClearCounterValue ( ByteBuffer value ) { return flag == Flag . FROM_REMOTE || ( flag == Flag . LOCAL && CounterContext . instance ( ) . shouldClearLocal ( value ) ) ? CounterContext . instance ( ) . clearAllLocal ( value ) : value ; }
 @ Override public void run ( ) { try { while ( filter . hasNext ( ) ) { payloadCount ++ ; try { log . trace ( " Polling ▁ filter ▁ for ▁ next ▁ processes ▁ Payload " ) ; Payload next = filter . next ( ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( " run ( ) ▁ got ▁ " + next ) ; } if ( next != null ) { try { log . trace ( " Offering ▁ payload ▁ to ▁ out ▁ queue ▁ in ▁ " + this ) ; out . put ( next ) ; log . trace ( " outQueue ▁ accepted ▁ Payload " ) ; } catch ( InterruptedException e ) { log . warn ( " Interrupted ▁ while ▁ trying ▁ to ▁ add ▁ " + next + " ▁ to ▁ outQueue ▁ in ▁ " + this + " . ▁ Retrying " ) ; } } } catch ( Exception e ) { log . warn ( String . format ( " Exception ▁ while ▁ calling ▁ next ▁ on ▁ filter ▁ ' % s ' ▁ in ▁ % s . ▁ Sleeping ▁ a ▁ bit , ▁ then ▁ retrying " , filter , this ) , e ) ; try { Thread . sleep ( 500 ) ; } catch ( InterruptedException ex ) { log . warn ( " Interrupted ▁ while ▁ sleeping ▁ before ▁ next ▁ poll ▁ in ▁ " + this , ex ) ; } } } log . debug ( " Emptied ▁ " + filter + " ▁ after ▁ " + payloadCount + " ▁ Payloads " ) ; eofReached = true ; out . uninterruptablePut ( STOP ) ; } catch ( Exception e ) { log . error ( String . format ( " Got ▁ unexpected ▁ exception ▁ in ▁ run - method ▁ for ▁ ' % s ' " , this ) , e ) ; } }
 public void setCorrelationId ( String correlationId ) { this . correlationId = correlationId ; }
 @ Override public int hashCode ( ) { return linkerInputs . shallowHashCode ( ) ; }
 public EClass getTLogicalPeopleGroups ( ) { return tLogicalPeopleGroupsEClass ; }
 public void setDataDeFinalizacao ( String dataDeFinalizacao ) { this . dataDeFinalizacao = dataDeFinalizacao ; }
 @ Override public int getProgress ( InterpreterContext context ) { return 0 ; }
 private void createSourceFromTemplate ( String moduleName , File srcFile , String templateName ) throws Exception { File dstFile = new File ( getDstDir ( moduleName ) , templateName + JAVA_EXT_NAME ) ; dstFile . createNewFile ( ) ; logMessage ( " \t " + dstFile . getAbsolutePath ( ) ) ; templateReplace ( srcFile , dstFile , getPackageFromModule ( moduleName ) ) ; }
 ) if ( osLow . contains ( os ) ) { unix = true ; break ; }
 public EAttribute getTQuery_Mixed ( ) { return ( EAttribute ) tQueryEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public TCPConduit getConduit ( ) { return this . conduit ; }
 public boolean isInternalExecution ( ) { return isInternalExecution ; }
 public void uploadResource ( ) { }
 catch ( IOException ex ) { throw new InternalGemFireException ( " Unknown ▁ error ▁ serializing ▁ message " , ex ) ; }
 @ Override public void debugPrint ( Printer printer ) { printer . append ( " < CcLinkingContext ( [ " ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { linkerInput . debugPrint ( printer ) ; printer . append ( " , ▁ " ) ; } printer . append ( " ] ) > " ) ; }
 public Long getAccountId ( ) { return accountId ; }
 @ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( " PropertyDescriptorImpl " ) ; sb . append ( " { property = " ) . append ( property ) ; sb . append ( " , ▁ cascaded = ' " ) . append ( cascaded ) . append ( ' \' ' ) ; sb . append ( ' } ' ) ; return sb . toString ( ) ; }
 public EReference getTOrganizationalEntity_Users ( ) { return ( EReference ) tOrganizationalEntityEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EReference getTPresentationParameters_PresentationParameter ( ) { return ( EReference ) tPresentationParametersEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public Builder addLibrary ( LibraryToLink library ) { this . libraries . add ( library ) ; return this ; }
 public void addCellEditorListener ( final CellEditorListener l ) { listenerList . add ( CellEditorListener . class , l ) ; }
 @ Override public void getSnapshotIndexMetadata ( SnapshotId snapshotId , IndexId indexId , ActionListener < IndexMetadata > listener ) throws IOException { }
 protected void interrupted ( ) { Robot . cannonSubsystem . spinGatling ( 0 ) ; }
 public EReference getTTask_Interface ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 @ NonNull public final Optional < T > get ( ) { return getLatest ( ) ; }
 @ Override public int indexOf ( Object object ) { if ( object instanceof Img ) { Img value = ( Img ) object ; return array . indexOf ( value ) ; } return AbstractArrayList . NOT_FOUND ; }
 @ FromAnyThread protected boolean isIgnoreListeners ( ) { return ignoreListeners ; }
 public String getDisplayName ( ) { return displayName ; }
 @ Test public void testInvalidConfig ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , " invalid " ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2271 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) ) ; fail ( ) ; } catch ( IllegalStateException e ) { assertTrue ( e . getMessage ( ) . contains ( " failed " ) ) ; } finally { configServer . stop ( ) ; } }
 public void updateTTL ( int ttl ) { isTTLSet = true ; minTTL = Math . min ( minTTL , ttl ) ; }
 public EAttribute getTExpression_ExpressionLanguage ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 private void assertMessageParameterExists ( Class < ? extends Annotation > annotationType ) { try { final Method method = ReflectionHelper . getMethod ( annotationType , " message " ) ; if ( method == null ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ does ▁ " + " not ▁ contain ▁ a ▁ message ▁ parameter . " ; throw new ConstraintDefinitionException ( msg ) ; } if ( method . getReturnType ( ) != String . class ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ message ▁ parameter ▁ " + " is ▁ not ▁ of ▁ type ▁ java . lang . String . " ; throw new ConstraintDefinitionException ( msg ) ; } } catch ( ClassCastException e ) { String msg = annotationType . getName ( ) + " ▁ contains ▁ Constraint ▁ annotation , ▁ but ▁ the ▁ " + " groups ▁ parameter ▁ is ▁ of ▁ wrong ▁ type . " ; throw new ConstraintDefinitionException ( msg , e ) ; } }
 public FormBody build ( ) { return new FormBody ( names , values ) ; }
 public String getDataDeCriacao ( ) { return dataDeCriacao ; }
 public String getText ( ) { return getNumber ( ) . toString ( ) ; }
 @ Override public Depset getStarlarkNonCodeInputs ( ) { return Depset . of ( Artifact . TYPE , getNonCodeInputs ( ) ) ; }
 @ Test public void testSelectChannelsLength ( ) { sd . setInstance ( streamRecord ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 1 ) . length ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 2 ) . length ) ; assertEquals ( 1 , distributePartitioner . selectChannels ( sd , 1024 ) . length ) ; }
 @ VisibleForTesting BoundedReadEvaluatorFactory ( EvaluationContext evaluationContext , long minimumDynamicSplitSize ) { this . evaluationContext = evaluationContext ; this . minimumDynamicSplitSize = minimumDynamicSplitSize ; }
 @ Test public void testFindingItemWhenListContainsInfinity ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , Integer . MIN_VALUE , 1 , 2 , 3 , 5 , Integer . MAX_VALUE ) , is ( 4 ) ) ; }
 protected BaseFileEditor ( ) { this . operationControl = createOperationControl ( ) ; this . changeCounter = new AtomicInteger ( ) ; }
 private List < SSTableReader > ageSortedSSTables ( Collection < SSTableReader > candidates ) { List < SSTableReader > ageSortedCandidates = new ArrayList < SSTableReader > ( candidates ) ; Collections . sort ( ageSortedCandidates , SSTable . maxTimestampComparator ) ; return ageSortedCandidates ; }
 public void setInternalExecution ( boolean isInternalExecution ) { this . isInternalExecution = isInternalExecution ; }
 @ Override public void repr ( SkylarkPrinter printer ) { printer . append ( " android _ common . multi _ cpu _ configuration " ) ; }
 public TestKey ( ) { }
 @ JsonProperty ( " IsAllowUpcharge " ) public Boolean getIsAllowUpcharge ( ) { return isAllowUpcharge ; }
 @ JsonProperty ( " DisplayName " ) public void setDisplayName ( String displayName ) { this . displayName = displayName ; }
 public ItemsRange ( ) { this ( 0 , 0 ) ; }
 public NestedSet < LibraryToLink > getLibraries ( ) { NestedSetBuilder < LibraryToLink > libraries = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { libraries . addAll ( linkerInput . libraries ) ; } return libraries . build ( ) ; }
 public boolean isConstraintAnnotation ( Class < ? extends Annotation > annotationType ) { Constraint constraint = annotationType . getAnnotation ( Constraint . class ) ; if ( constraint == null ) { return false ; } assertMessageParameterExists ( annotationType ) ; assertGroupsParameterExists ( annotationType ) ; assertPayloadParameterExists ( annotationType ) ; assertNoParameterStartsWithValid ( annotationType ) ; return true ; }
 public String getStoragePoolName ( ) { if ( getStoragePool ( ) != null ) { return getStoragePool ( ) . getname ( ) ; } return " " ; }
 public EReference getDocumentRoot_Import ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 8 ) ; }
 public void setEnabled ( boolean enabled ) { this . enabled = enabled ; }
 private long getSizeFromEvictionStats ( LocalRegion region ) { long result = region . getEvictionCounter ( ) ; return result ; }
 public EReference getTPeopleAssignments_PotentialOwners ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 @ Override public Object getStarlarkLibrariesToLink ( StarlarkSemantics semantics ) { if ( semantics . getBool ( BuildLanguageOptions . INCOMPATIBLE_DEPSET_FOR_LIBRARIES_TO_LINK_GETTER ) ) { return Depset . of ( LibraryToLink . TYPE , getLibraries ( ) ) ; } else { return StarlarkList . immutableCopyOf ( getLibraries ( ) . toList ( ) ) ; } }
 public void setPostcode ( String postcode ) { this . postcode = postcode ; }
 public VisorCachePartitions ( ) { primary = new ArrayList < > ( ) ; backup = new ArrayList < > ( ) ; }
 public synchronized int getEstimatedTasks ( ) { long tasks = 0 ; long [ ] estimated = new long [ generations . length ] ; for ( int i = generations . length - 1 ; i >= 0 ; i -- ) { List < SSTableReader > sstables = generations [ i ] ; estimated [ i ] = Math . max ( 0L , SSTableReader . getTotalBytes ( sstables ) - maxBytesForLevel ( i ) ) / maxSSTableSizeInBytes ; tasks += estimated [ i ] ; } logger . debug ( " Estimating ▁ { } ▁ compactions ▁ to ▁ do ▁ for ▁ { } . { } " , Arrays . toString ( estimated ) , cfs . table . getName ( ) , cfs . name ) ; return Ints . checkedCast ( tasks ) ; }
 public boolean containsConstraintValidatorDefinition ( Class < ? extends Annotation > annotationClass ) { return constraintValidatorDefinitions . containsKey ( annotationClass ) ; }
 @ Override public boolean isReadOnly ( ) { return false ; }
 public EReference getTDeadlines_StartDeadline ( ) { return ( EReference ) tDeadlinesEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 private ActionCacheTestHelper ( ) { }
 public EClass getTGrouplist ( ) { return tGrouplistEClass ; }
 private void doListenerTestPR ( VM vm0 , VM vm1 ) { assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long origPRSize0 = getSizeFromPRStats ( vm1 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertTrue ( origEvictionSize1 >= 100000 ) ; assertTrue ( origEvictionSize0 >= 100000 ) ; assertTrue ( origPRSize0 <= 500 ) ; assertTrue ( origPRSize1 <= 500 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm1 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100000 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 100 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 100 , finalPRSize1 - origPRSize1 ) ; }
 if ( directReply && msg . getProcessorId ( ) > 0 ) { directReply = false ; }
 @ Override public boolean retainAll ( Collection < ? > collection ) { boolean modified = collection != null && ! collection . isEmpty ( ) ; if ( modified ) { List < Img > contained = new ArrayList < > ( ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) { Img value = get ( i ) ; if ( ! collection . contains ( value ) ) { contained . add ( value ) ; } } if ( ! contained . isEmpty ( ) ) { for ( Img toRemove : contained ) { modified = modified && remove ( toRemove ) ; } } } return modified ; }
 public EnrichMediatorOutputConnectorItemSemanticEditPolicy ( ) { super ( EsbElementTypes . EnrichMediatorOutputConnector_3037 ) ; }
 private void doPRNoLRUDeltaTest ( boolean shouldSizeChange ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; setDeltaRecalculatesSize ( vm0 , shouldSizeChange ) ; setDeltaRecalculatesSize ( vm1 , shouldSizeChange ) ; createPR ( vm0 , false ) ; createPR ( vm1 , false ) ; TestDelta delta1 = new TestDelta ( false , "12345" ) ; put ( vm0 , " a " , delta1 ) ; long origPRSize0 = getSizeFromPRStats ( vm0 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; delta1 . info = "1234567890" ; delta1 . hasDelta = true ; put ( vm0 , " a " , delta1 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; if ( shouldSizeChange ) { assertTrue ( finalPRSize0 - origPRSize0 != 0 ) ; assertTrue ( finalPRSize1 - origPRSize1 != 0 ) ; } else { assertEquals ( 0 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 0 , finalPRSize1 - origPRSize1 ) ; } }
 private void checkReadAdvance ( ) throws IOException { if ( shouldAdvance ( getCurrentSegmentLimit ( ) - getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { advance ( ) ; } }
 public EReference getTNotification_PresentationElements ( ) { return ( EReference ) tNotificationEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 public void setCurrentUser ( final IVdcUser value ) { mVdcUser = value ; }
 public DataChangedNotifier ( SqlTable < ? > ... tables ) { SquidUtilities . addAll ( this . tables , tables ) ; }
 public boolean stopCellEditing ( ) { fireEditingStopped ( ) ; return true ; }
 void insertIntoTable ( long key , int hashCode , BinaryRowData row ) throws IOException { this . buildSideRecordCounter ++ ; updateMinMax ( key ) ; int sizeInBytes = row . getSizeInBytes ( ) ; if ( sizeInBytes >= ( 1 << SIZE_BITS ) ) { throw new UnsupportedOperationException ( " Does ▁ not ▁ support ▁ row ▁ that ▁ is ▁ larger ▁ than ▁ 256M " ) ; } if ( isInMemory ( ) ) { checkWriteAdvance ( ) ; if ( isInMemory ( ) ) { updateIndex ( key , hashCode , buildSideWriteBuffer . getCurrentPointer ( ) , sizeInBytes , buildSideWriteBuffer . getCurrentSegment ( ) , buildSideWriteBuffer . getCurrentPositionInSegment ( ) ) ; } else { buildSideWriteBuffer . getCurrentSegment ( ) . putLong ( buildSideWriteBuffer . getCurrentPositionInSegment ( ) , toAddrAndLen ( INVALID_ADDRESS , sizeInBytes ) ) ; } buildSideWriteBuffer . skipBytesToWrite ( 8 ) ; if ( row . getSegments ( ) . length == 1 ) { buildSideWriteBuffer . write ( row . getSegments ( ) [ 0 ] , row . getOffset ( ) , sizeInBytes ) ; } else { BinaryRowDataSerializer . serializeWithoutLengthSlow ( row , buildSideWriteBuffer ) ; } } else { serializeToPages ( row ) ; } }
 private void doListenerTestRR ( VM vm0 , VM vm1 ) { assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; put ( vm0 , " a " , new TestObject ( 100 , 100000 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertTrue ( origEvictionSize0 >= 100000 ) ; assertTrue ( origEvictionSize1 >= 100000 ) ; put ( vm0 , " a " , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 2 , getObjectSizerInvocations ( vm1 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , " a " , ValueType . RAW_VALUE ) ; assertValueType ( vm1 , " a " , ValueType . CD_DESERIALIZED ) ; assertEquals ( 100000 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100000 , finalEvictionSize1 - origEvictionSize1 ) ; }
 boolean isInMemory ( ) { return buildSideChannel == null ; }
 protected void setVdsGroup ( final VDSGroup value ) { mVdsGroup = value ; }
 public void testSerializationSelf ( ) throws Exception { SerializationTest . verifySelf ( new MissingFormatWidthException ( " MYTESTSTRING " ) , exComparator ) ; }
 catch ( NoSuchMethodException | ClassNotFoundException | IllegalAccessException | InvocationTargetException ignored ) { }
 public void setLocalAddr ( InternalDistributedMember localAddr ) { this . localAddr = localAddr ; conduit . setMemberId ( localAddr ) ; if ( disconnected ) { disconnected = false ; disconnectCompleted = false ; } }
 public EAttribute getTLocalNotification_Reference ( ) { return ( EAttribute ) tLocalNotificationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 @ Override protected Shape getRawShape ( VisualItem item ) { EdgeItem edge = ( EdgeItem ) item ; VisualItem item1 = edge . getSourceItem ( ) ; VisualItem item2 = edge . getTargetItem ( ) ; int type = m_edgeType ; boolean reversedCurve = false ; Association association = ( Association ) item . get ( " association " ) ; if ( association != null && association . source == association . destination ) { type = Constants . EDGE_TYPE_CURVE ; reversedCurve = association . reversed ; } getAlignedPoint ( m_tmpPoints [ 0 ] , item1 . getBounds ( ) , m_xAlign1 , m_yAlign1 ) ; getAlignedPoint ( m_tmpPoints [ 1 ] , item2 . getBounds ( ) , m_xAlign2 , m_yAlign2 ) ; m_curWidth = ( float ) ( m_width * getLineWidth ( item ) ) ; EdgeItem e = ( EdgeItem ) item ; boolean forward = ( m_edgeArrow == Constants . EDGE_ARROW_FORWARD ) ; Point2D start = null , end = null ; start = m_tmpPoints [ forward ? 0 : 1 ] ; end = m_tmpPoints [ forward ? 1 : 0 ] ; if ( ! full ) { double midX ; double midY ; Point2D sp = start , ep = end ; VisualItem dest = forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; int i = GraphicsLib . intersectLineRectangle ( start , end , dest . getBounds ( ) , m_isctPoints ) ; if ( i > 0 ) ep = m_isctPoints [ 0 ] ; VisualItem src = ! forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; i = GraphicsLib . intersectLineRectangle ( start , end , src . getBounds ( ) , m_isctPoints2 ) ; if ( i > 0 ) sp = m_isctPoints2 [ 0 ] ; midX = ( sp . getX ( ) + ep . getX ( ) ) / 2 ; midY = ( sp . getY ( ) + ep . getY ( ) ) / 2 ; m_tmpPoints [ reversed ? 1 : 0 ] . setLocation ( midX , midY ) ; } if ( e . isDirected ( ) && m_edgeArrow != Constants . EDGE_ARROW_NONE ) { if ( type == Constants . EDGE_TYPE_CURVE ) { AffineTransform t = new AffineTransform ( ) ; t . setToRotation ( Math . PI / 4 * ( reversedCurve ? 1 : - 1 ) ) ; Point2D p = new Point2D . Double ( ) , shift = new Point2D . Double ( ) ; double d = start . distance ( end ) / 5.0 ; p . setLocation ( ( end . getX ( ) - start . getX ( ) ) / d , ( end . getY ( ) - start . getY ( ) ) / d ) ; t . transform ( p , shift ) ; start . setLocation ( start . getX ( ) + shift . getX ( ) , start . getY ( ) + shift . getY ( ) ) ; end . setLocation ( end . getX ( ) + shift . getX ( ) , end . getY ( ) + shift . getY ( ) ) ; } VisualItem dest = forward ? e . getTargetItem ( ) : e . getSourceItem ( ) ; int i = GraphicsLib . intersectLineRectangle ( start , end , dest . getBounds ( ) , m_isctPoints ) ; if ( i > 0 ) end = m_isctPoints [ 0 ] ; AffineTransform at = getArrowTrans ( start , end , m_curWidth ) ; m_curArrow = at . createTransformedShape ( m_arrowHead ) ; if ( type == Constants . EDGE_TYPE_CURVE ) { if ( ! " XML " . equals ( association . getDataModel ( ) . getExportModus ( ) ) || ! isAggregation ( association ) ) { m_curArrow = null ; } } Point2D lineEnd = m_tmpPoints [ forward ? 1 : 0 ] ; lineEnd . setLocation ( 0 , type == Constants . EDGE_TYPE_CURVE ? 0 : - m_arrowHeight ) ; at . transform ( lineEnd , lineEnd ) ; } else { m_curArrow = null ; } Shape shape = null ; double n1x = m_tmpPoints [ 0 ] . getX ( ) ; double n1y = m_tmpPoints [ 0 ] . getY ( ) ; double n2x = m_tmpPoints [ 1 ] . getX ( ) ; double n2y = m_tmpPoints [ 1 ] . getY ( ) ; m_line . setLine ( n1x , n1y , n2x , n2y ) ; shape = m_line ; starBounds = null ; starPosition = null ; if ( ! forward && ( Cardinality . MANY_TO_MANY . equals ( association . getCardinality ( ) ) || Cardinality . MANY_TO_ONE . equals ( association . getCardinality ( ) ) ) || forward && ( Cardinality . MANY_TO_MANY . equals ( association . getCardinality ( ) ) || Cardinality . ONE_TO_MANY . equals ( association . getCardinality ( ) ) ) ) { starPosition = m_tmpPoints [ forward ? 1 : 0 ] ; start = starPosition ; end = m_tmpPoints [ forward ? 0 : 1 ] ; AffineTransform t = new AffineTransform ( ) ; t . setToRotation ( - Math . PI / 3 ) ; Point2D p = new Point2D . Double ( ) , shift = new Point2D . Double ( ) ; double d = m_tmpPoints [ 0 ] . distance ( m_tmpPoints [ 1 ] ) / 9.0 ; p . setLocation ( ( end . getX ( ) - start . getX ( ) ) / d , ( end . getY ( ) - start . getY ( ) ) / d ) ; t . transform ( p , shift ) ; starPosition . setLocation ( starPosition . getX ( ) + shift . getX ( ) , starPosition . getY ( ) + shift . getY ( ) ) ; starBounds = new Rectangle2D . Double ( starPosition . getX ( ) - STAR_SIZE * ( starWidth / 2 ) , starPosition . getY ( ) - STAR_SIZE * ( starHeight / 2 ) , starWidth * STAR_SIZE , starHeight * STAR_SIZE ) ; } return shape ; }
 public EReference getTDelegation_From ( ) { return ( EReference ) tDelegationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EAttribute getTLiteral_Mixed ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 protected Command getStartCreateRelationshipCommand ( CreateRelationshipRequest req ) { if ( EsbElementTypes . EsbLink_4001 == req . getElementType ( ) ) { return getGEFWrapper ( new EsbLinkCreateCommand ( req , req . getSource ( ) , req . getTarget ( ) ) ) ; } return null ; }
 public EClass getTNotifications ( ) { return tNotificationsEClass ; }
 public String getVmTemplateName ( ) { if ( mVmTemplateName == null && getVmTemplate ( ) != null ) { mVmTemplateName = getVmTemplate ( ) . getname ( ) ; } return mVmTemplateName ; }
 public Builder addUserLinkFlags ( List < LinkOptions > userLinkFlags ) { this . userLinkFlags . addAll ( userLinkFlags ) ; return this ; }
 public EAttribute getTHumanInteractions_ExpressionLanguage ( ) { return ( EAttribute ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
 public EClass getTDelegation ( ) { return tDelegationEClass ; }
 public EAttribute getTDocumentation_Mixed ( ) { return ( EAttribute ) tDocumentationEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public EAttribute getTArgument_ExpressionLanguage ( ) { return ( EAttribute ) tArgumentEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 protected VDSGroup getVdsGroup ( ) { if ( mVdsGroup == null ) { if ( mVdsGroupId != null ) { mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } else if ( getVds ( ) != null ) { mVdsGroupId = getVds ( ) . getvds_group_id ( ) ; mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } else if ( getVm ( ) != null ) { mVdsGroupId = getVm ( ) . getvds_group_id ( ) ; mVdsGroup = getVdsGroupDAO ( ) . get ( mVdsGroupId ) ; } } return mVdsGroup ; }
 @ Override public String toString ( boolean ignoreFreezing ) { boolean includeFrozenType = ! ignoreFreezing && ! isMultiCell ( ) ; StringBuilder sb = new StringBuilder ( ) ; if ( includeFrozenType ) sb . append ( FrozenType . class . getName ( ) ) . append ( " ( " ) ; sb . append ( getClass ( ) . getName ( ) ) ; sb . append ( TypeParser . stringifyTypeParameters ( Collections . < AbstractType < ? > > singletonList ( elements ) , ignoreFreezing || ! isMultiCell ) ) ; if ( includeFrozenType ) sb . append ( " ) " ) ; return sb . toString ( ) ; }
 public EReference getTEscalation_Notification ( ) { return ( EReference ) tEscalationEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 public String encodedValue ( int index ) { return encodedValues . get ( index ) ; }
 @ Override public void cleanup ( ) { }
 public EClass getTPresentationParameter ( ) { return tPresentationParameterEClass ; }
 private Poll buildNewPoll ( Topic message , EditTopicRequest form ) throws PollNotFoundException { Poll poll = pollDao . getPollByTopicId ( message . getId ( ) ) ; List < PollVariant > newVariants = new ArrayList < > ( ) ; for ( PollVariant v : poll . getVariants ( ) ) { String label = form . getPoll ( ) . get ( v . getId ( ) ) ; if ( ! Strings . isNullOrEmpty ( label ) ) { newVariants . add ( new PollVariant ( v . getId ( ) , label ) ) ; } } for ( String label : form . getNewPoll ( ) ) { if ( ! Strings . isNullOrEmpty ( label ) ) { newVariants . add ( new PollVariant ( 0 , label ) ) ; } } return poll . createNew ( newVariants ) ; }
 @ Override public void onPurchased ( EntityPlayer player ) { TownData town = TownHelper . getClosestTownToEntity ( player , false ) ; TownBuilding theBuilding = town . getBuilding ( building ) ; HFTemplate template = BuildingRegistry . INSTANCE . getTemplateForBuilding ( building ) ; if ( template != null && theBuilding != null ) { template . removeBlocks ( player . world , theBuilding . pos , theBuilding . rotation , Blocks . AIR . getDefaultState ( ) , true ) ; if ( theBuilding . building == HFBuildings . FESTIVAL_GROUNDS ) { BuildingFestival . getFestivalTemplateFromFestival ( town . getFestival ( ) ) . removeBlocks ( player . world , theBuilding . pos , theBuilding . rotation , Blocks . AIR . getDefaultState ( ) , true ) ; } TownHelper . < TownDataServer > getClosestTownToEntity ( player , false ) . removeBuilding ( theBuilding ) ; } }
 @ JsonProperty ( " IsAllowUpcharge " ) public void setIsAllowUpcharge ( Boolean isAllowUpcharge ) { this . isAllowUpcharge = isAllowUpcharge ; }
 ) { Connection con = ( Connection ) it . next ( ) ; con . setInUse ( false , 0 , 0 , 0 , null ) ; }
 private long getSizeFromEvictionStats ( VM vm0 ) { return ( Long ) vm0 . invoke ( new SerializableCallable ( ) { public Object call ( ) { Cache cache = getCache ( ) ; LocalRegion region = ( LocalRegion ) cache . getRegion ( " region " ) ; return getSizeFromEvictionStats ( region ) ; } } ) ; }
 public String getGlusterVolumeName ( ) { if ( glusterVolumeName == null && getGlusterVolume ( ) != null ) { glusterVolumeName = getGlusterVolume ( ) . getName ( ) ; } return glusterVolumeName ; }
 public EReference getTDeadline_Escalation ( ) { return ( EReference ) tDeadlineEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 private void initAdapter ( ) { groupTitles = new ArrayList < String > ( ) ; childItems = new ArrayList < ArrayList < ChildItem > > ( ) ; for ( Solution solu : solutions ) { groupTitles . add ( solu . solution ) ; ArrayList < ChildItem > subItems = new ArrayList < ChildItem > ( ) ; for ( SolutionChildItem item : solu . children ) { subItems . add ( new ChildItem ( item . sub_id , item . sub_name ) ) ; } childItems . add ( subItems ) ; } infoAdapter = new AddBookCheckListViewAdapter ( this ) ; infoAdapter . setDatas ( groupTitles , childItems , selInfoIds ) ; elv . setAdapter ( infoAdapter ) ; for ( int i = 0 ; i < groupTitles . size ( ) ; i ++ ) elv . expandGroup ( i ) ; }
 public EClass getTLocalNotification ( ) { return tLocalNotificationEClass ; }
 @ Override @ FxThread public void decrementChange ( ) { final int result = changeCounter . decrementAndGet ( ) ; setDirty ( result != 0 ) ; }
 @ Override public void start ( ) throws IgniteCheckedException { if ( port <= 0 || port >= 0xffff ) throw new IpcEndpointBindException ( " Port ▁ value ▁ is ▁ illegal : ▁ " + port ) ; try { srvSock = new ServerSocket ( ) ; assert host != null ; srvSock . bind ( new InetSocketAddress ( U . resolveLocalHost ( host ) , port ) ) ; if ( log . isInfoEnabled ( ) ) log . info ( " IPC ▁ server ▁ loopback ▁ endpoint ▁ started ▁ [ port = " + port + ' ] ' ) ; } catch ( IOException e ) { if ( srvSock != null ) U . closeQuiet ( srvSock ) ; throw new IpcEndpointBindException ( " Failed ▁ to ▁ bind ▁ loopback ▁ IPC ▁ endpoint ▁ ( is ▁ port ▁ already ▁ in ▁ " + " use ? ) : ▁ " + port , e ) ; } }
 @ Override public Artifact getArtifactForStarlark ( StarlarkThread thread ) throws EvalException { CcModule . checkPrivateStarlarkificationAllowlist ( thread ) ; return artifact ; }
 public PersonajeLiberal ( ) { }
 @ JsonProperty ( " Description " ) public void setDescription ( String description ) { this . description = description ; }
 @ XmlElement @ Column ( name = PAYER_STATUS_COLUMN_NAME ) public String getPayerStatus ( ) { return payerStatus ; }
 @ Override public int getEndOffset ( ) { return offset + kind . toString ( ) . length ( ) ; }
 public EReference getTTask_Renderings ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 7 ) ; }
 public void setupConfiguration ( Map < String , String > endpointCfg ) throws IgniteCheckedException { for ( Map . Entry < String , String > e : endpointCfg . entrySet ( ) ) { try { switch ( e . getKey ( ) ) { case " type " : break ; case " port " : setPort ( Integer . parseInt ( e . getValue ( ) ) ) ; break ; case " host " : setHost ( e . getValue ( ) ) ; break ; case " management " : setManagement ( Boolean . valueOf ( e . getValue ( ) ) ) ; break ; default : throw new IgniteCheckedException ( " Invalid ▁ property ▁ ' " + e . getKey ( ) + " ' ▁ of ▁ " + getClass ( ) . getSimpleName ( ) ) ; } } catch ( Throwable t ) { if ( t instanceof IgniteCheckedException || t instanceof Error ) throw t ; throw new IgniteCheckedException ( " Invalid ▁ value ▁ ' " + e . getValue ( ) + " ' ▁ of ▁ the ▁ property ▁ ' " + e . getKey ( ) + " ' ▁ in ▁ " + getClass ( ) . getSimpleName ( ) , t ) ; } } }
 @ Override public void open ( ) { }
 public EClass getTNotificationInterface ( ) { return tNotificationInterfaceEClass ; }
 public DbUserDAO getDbUserDAO ( ) { return getDbFacade ( ) . getDbUserDAO ( ) ; }
 public void setFriendlyName ( final String friendlyName ) { this . friendlyName = friendlyName ; }
 @ Override public void setUp ( ) throws Exception { Properties properties = ResourcesUtils . getResourceAsProperties ( " test . properties " ) ; List < InetSocketAddress > addresses = AddrUtil . getAddresses ( properties . getProperty ( " test . memcached . servers " ) ) ; StringBuffer sb = new StringBuffer ( ) ; boolean wasFirst = true ; for ( InetSocketAddress addr : addresses ) { if ( wasFirst ) { wasFirst = false ; } else { sb . append ( " ▁ " ) ; } sb . append ( addr . getHostName ( ) + " | " + addr . getHostName ( ) + " | " + addr . getPort ( ) ) ; } this . addresses = addresses ; serverList = sb . toString ( ) ; }
 public String getVdsName ( ) { if ( mVdsName == null && getVds ( ) != null ) { mVdsName = getVds ( ) . getvds_name ( ) ; } return mVdsName ; }
 public void setTaxIdType ( final String taxIdType ) { this . taxIdType = taxIdType ; }
 public ImmutableList < String > get ( ) { return linkOptions ; }
 public EAttribute getTLiteral_Any ( ) { return ( EAttribute ) tLiteralEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 @ NotNull public IssueData parse ( @ NotNull final String issueString ) throws Exception { try { final Map map = new ObjectMapper ( ) . readValue ( issueString , Map . class ) ; return parseIssueData ( map ) ; } catch ( Exception e ) { LOG . error ( " Could ▁ not ▁ parse ▁ issue ▁ json . ▁ Error ▁ message ▁ is : ▁ " + e . getMessage ( ) ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " Could ▁ not ▁ parse ▁ issue ▁ json . ▁ Response ▁ ( cut ▁ to ▁ first ▁ 100 ▁ symbols ) : ▁ [ " + issueString . substring ( Math . min ( 100 , issueString . length ( ) - 1 ) ) ) ; } throw e ; } }
 LongHashPartition ( LongHybridHashTable longTable , int partitionNum , BinaryRowDataSerializer buildSideSerializer , int bucketNumSegs , int recursionLevel , List < MemorySegment > buffers , int lastSegmentLimit ) { this ( longTable , buildSideSerializer , listToArray ( buffers ) ) ; this . partitionNum = partitionNum ; this . recursionLevel = recursionLevel ; int numBuckets = MathUtils . roundDownToPowerOf2 ( bucketNumSegs * segmentSize / 16 ) ; MemorySegment [ ] buckets = new MemorySegment [ bucketNumSegs ] ; for ( int i = 0 ; i < bucketNumSegs ; i ++ ) { buckets [ i ] = longTable . nextSegment ( ) ; } setNewBuckets ( buckets , numBuckets ) ; this . finalBufferLimit = lastSegmentLimit ; }
 private < OutputT > TransformEvaluator < ? > createEvaluator ( final AppliedPTransform < ? , PCollection < OutputT > , ? > transform ) { return new BoundedReadEvaluator < > ( transform , evaluationContext , minimumDynamicSplitSize , executor ) ; }
 public void setVmId ( final Guid value ) { mVmId = value ; }
 public VmStaticDAO getVmStaticDAO ( ) { return getDbFacade ( ) . getVmStaticDAO ( ) ; }
 public void serializeToPages ( BinaryRowData row ) throws IOException { int sizeInBytes = row . getSizeInBytes ( ) ; checkWriteAdvance ( ) ; buildSideWriteBuffer . getCurrentSegment ( ) . putLong ( buildSideWriteBuffer . getCurrentPositionInSegment ( ) , toAddrAndLen ( INVALID_ADDRESS , row . getSizeInBytes ( ) ) ) ; buildSideWriteBuffer . skipBytesToWrite ( 8 ) ; if ( row . getSegments ( ) . length == 1 ) { buildSideWriteBuffer . write ( row . getSegments ( ) [ 0 ] , row . getOffset ( ) , sizeInBytes ) ; } else { BinaryRowDataSerializer . serializeWithoutLengthSlow ( row , buildSideWriteBuffer ) ; } }
 public BufferPool getBufferPool ( ) { return bufferPool ; }
 public RowIndexEntry ( long position ) { this . position = position ; }
 @ Override public int hashCode ( ) { return Objects . hash ( minTimestamp , minLocalDeletionTime , minTTL ) ; }
 public EAttribute getTDescription_Lang ( ) { return ( EAttribute ) tDescriptionEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 public SheetProcessor ( OutputWriterHolder outputWriterHolder ) { this . outputWriterHolder = outputWriterHolder ; }
 public HTFactory getHTFactory ( ) { return ( HTFactory ) getEFactoryInstance ( ) ; }
 public EReference getTPresentationElements_Name ( ) { return ( EReference ) tPresentationElementsEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public synchronized void repairOverlappingSSTables ( int level ) { SSTableReader previous = null ; Collections . sort ( generations [ level ] , SSTable . sstableComparator ) ; List < SSTableReader > outOfOrderSSTables = new ArrayList < SSTableReader > ( ) ; for ( SSTableReader current : generations [ level ] ) { if ( previous != null && current . first . compareTo ( previous . last ) <= 0 ) { logger . warn ( String . format ( " At ▁ level ▁ % d , ▁ % s ▁ [ % s , ▁ % s ] ▁ overlaps ▁ % s ▁ [ % s , ▁ % s ] . ▁ ▁ This ▁ could ▁ be ▁ caused ▁ by ▁ a ▁ bug ▁ in ▁ Cassandra ▁ 1.1.0 ▁ . . ▁ 1.1.3 ▁ or ▁ due ▁ to ▁ the ▁ fact ▁ that ▁ you ▁ have ▁ dropped ▁ sstables ▁ from ▁ another ▁ node ▁ into ▁ the ▁ data ▁ directory . ▁ " + " Sending ▁ back ▁ to ▁ L0 . ▁ ▁ If ▁ you ▁ didn ' t ▁ drop ▁ in ▁ sstables , ▁ and ▁ have ▁ not ▁ yet ▁ run ▁ scrub , ▁ you ▁ should ▁ do ▁ so ▁ since ▁ you ▁ may ▁ also ▁ have ▁ rows ▁ out - of - order ▁ within ▁ an ▁ sstable " , level , previous , previous . first , previous . last , current , current . first , current . last ) ) ; outOfOrderSSTables . add ( current ) ; } else { previous = current ; } } if ( ! outOfOrderSSTables . isEmpty ( ) ) { for ( SSTableReader sstable : outOfOrderSSTables ) sendBackToL0 ( sstable ) ; } }
 @ Test public void testPRHeapLRUDeltaPutOnSecondary ( ) { doPRDeltaTestLRU ( false , true , false , true ) ; }
 public AbstractJobInfo ( String pId , String pName , String pDescrption , boolean pMoreRunning , JobSchedulerMode pJsm ) { this . name = pName ; this . jobId = pId ; this . descrption = pDescrption ; this . jsm = pJsm ; this . moreRunning = pMoreRunning ; }
 @ Override public RuleClass build ( RuleClass . Builder builder , RuleDefinitionEnvironment env ) { return builder . add ( attr ( " : android _ sdk " , LABEL ) . allowedRuleClasses ( " android _ sdk " ) . value ( getAndroidSdkLabel ( env . getToolsLabel ( AndroidRuleClasses . DEFAULT_SDK ) ) ) ) . add ( attr ( " plugins " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . allowedRuleClasses ( " java _ plugin " ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " : java _ plugins " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . allowedRuleClasses ( " java _ plugin " ) . silentRuleClassFilter ( ) . value ( JavaSemantics . JAVA_PLUGINS ) ) . add ( attr ( " javacopts " , STRING_LIST ) ) . add ( attr ( " $ idlclass " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : IdlClass " ) ) ) . add ( attr ( " $ desugar _ java8 _ extra _ bootclasspath " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( env . getToolsLabel ( " // tools / android : desugar _ java8 _ extra _ bootclasspath " ) ) ) . add ( attr ( " $ android _ resources _ busybox " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( DEFAULT_RESOURCES_BUSYBOX ) ) ) . build ( ) ; }
 public CancelCriterion getCancelCriterion ( ) { return conduit . getCancelCriterion ( ) ; }
 public String value ( int index ) { return percentDecode ( encodedValue ( index ) , true ) ; }
 protected Command getCreateRelationshipCommand ( CreateRelationshipRequest req ) { Command command = req . getTarget ( ) == null ? getStartCreateRelationshipCommand ( req ) : getCompleteCreateRelationshipCommand ( req ) ; return command != null ? command : super . getCreateRelationshipCommand ( req ) ; }
 MemorySegment [ ] getPartitionBuffers ( ) { return partitionBuffers ; }
 private ThreadLocal < Set < T > > notifyObjectAccumulator = new ThreadLocal < Set < T > > ( ) { protected Set < T > initialValue ( ) { return new HashSet < > ( ) ; } }
 @ Override synchronized public JobInfo cloneJobInfo ( ) { ReadOnlyJobInfo roji = new ReadOnlyJobInfo ( this . jobId , this . name , this . descrption , this . moreRunning , this . jsm ) ; roji . actived = this . actived ; roji . errorReason = this . errorReason ; roji . firstBeginTime = this . firstBeginTime ; roji . firstEndTime = this . firstEndTime ; roji . lastBeginTime = this . lastBeginTime ; roji . lastEndTime = this . lastEndTime ; roji . lastErrorTime = this . lastErrorTime ; roji . lastHandleDataTime = this . lastHandleDataTime ; roji . lastThrowable = this . lastThrowable ; roji . nextRunningTime = this . nextRunningTime ; roji . noHandleDataReason = this . noHandleDataReason ; roji . noHandleDataTime = this . noHandleDataTime ; roji . numForFailrue = this . numForFailrue ; roji . numForHandleData = this . numForHandleData ; roji . numForRunning = this . numForRunning ; return roji ; }
 @ XmlElement @ Column ( name = FRIENDLY_NAME_COLUMN_NAME ) public String getFriendlyName ( ) { if ( isBlank ( friendlyName ) ) { if ( isNotBlank ( getMiddleName ( ) ) ) { friendlyName = getFirstName ( ) + " ▁ " + getMiddleName ( ) + " ▁ " + getLastName ( ) ; } else { friendlyName = getFirstName ( ) + " ▁ " + getLastName ( ) ; } } return friendlyName ; }
 @ Override public String toString ( ) { return String . format ( " Rename ▁ column ▁ family ▁ ( % d ) ▁ % s . % s ▁ to ▁ % s . % s " , cfId , tableName , oldName , tableName , newName ) ; }
 public Builder addTransitiveLinkerInputs ( NestedSet < LinkerInput > linkerInputs ) { this . linkerInputs . addTransitive ( linkerInputs ) ; return this ; }
 public void setAccountId ( Long value ) { this . accountId = value ; }
 @ NonNull protected Optional < T > getLatest ( ) { try { return Optional . ofNullable ( mObservable . toBlocking ( ) . latest ( ) . iterator ( ) . next ( ) ) ; } catch ( NoSuchElementException e ) { return Optional . ofNullable ( mObservable . toBlocking ( ) . last ( ) ) ; } }
 public void setBounds ( VisualItem item ) { super . setBounds ( item ) ; if ( starBounds != null ) { Rectangle2D bbox = ( Rectangle2D ) item . get ( VisualItem . BOUNDS ) ; Rectangle2D . union ( bbox , starBounds , bbox ) ; } }
 protected Command getDestroyElementCommand ( DestroyElementRequest req ) { View view = ( View ) getHost ( ) . getModel ( ) ; CompositeTransactionalCommand cmd = new CompositeTransactionalCommand ( getEditingDomain ( ) , null ) ; cmd . setTransactionNestingEnabled ( false ) ; for ( Iterator < ? > it = view . getSourceEdges ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Edge outgoingLink = ( Edge ) it . next ( ) ; if ( EsbVisualIDRegistry . getVisualID ( outgoingLink ) == EsbLinkEditPart . VISUAL_ID ) { DestroyElementRequest r = new DestroyElementRequest ( outgoingLink . getElement ( ) , false ) ; cmd . add ( new DestroyElementCommand ( r ) ) ; cmd . add ( new DeleteCommand ( getEditingDomain ( ) , outgoingLink ) ) ; continue ; } } EAnnotation annotation = view . getEAnnotation ( " Shortcut " ) ; if ( annotation == null ) { addDestroyShortcutsCommand ( cmd , view ) ; cmd . add ( new DestroyElementCommand ( req ) ) ; } else { cmd . add ( new DeleteCommand ( getEditingDomain ( ) , view ) ) ; } return getGEFWrapper ( cmd . reduce ( ) ) ; }
 @ Override public int getStartOffset ( ) { return offset ; }
 public void config ( ) throws IOException { file = new File ( Main . dataFolder ( ) , " ads . yml " ) ; config = YamlConfiguration . loadConfiguration ( file ) ; config . options ( ) . copyDefaults ( true ) ; Reader textResource = Main . textResource ( " ads . yml " ) ; config . setDefaults ( YamlConfiguration . loadConfiguration ( textResource ) ) ; config . save ( file ) ; }
 @ Override public void getSnapshotInfo ( SnapshotId snapshotId , ActionListener < SnapshotInfo > listener ) { listener . onResponse ( null ) ; }
 public EReference getTHumanInteractions_Notifications ( ) { return ( EReference ) tHumanInteractionsEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
 public String encodedName ( int index ) { return encodedNames . get ( index ) ; }
 @ Test public void testFindingItemInTheMiddle ( ) throws Exception { assertThat ( getFinder ( ) . find ( 5 , 1 , 3 , 5 , 7 , 9 ) , is ( 2 ) ) ; }
 public ClientFactoryImpl ( ) { }
 if ( ackTimeout > 0 ) { startTime = System . currentTimeMillis ( ) ; }
 public EAttribute getTExtensibleElements_Any ( ) { return ( EAttribute ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 if ( failedCe != null ) { throw failedCe ; }
 public VmTemplateDAO getVmTemplateDAO ( ) { return getDbFacade ( ) . getVmTemplateDAO ( ) ; }
 public < T extends Annotation > List < Class < ? extends ConstraintValidator < T , ? > > > getConstraintValidatorDefinition ( Class < T > annotationClass ) { if ( annotationClass == null ) { throw new IllegalArgumentException ( " Class ▁ cannot ▁ be ▁ null " ) ; } final List < Class < ? extends ConstraintValidator < ? extends Annotation , ? > > > list = constraintValidatorDefinitions . get ( annotationClass ) ; List < Class < ? extends ConstraintValidator < T , ? > > > constraintsValidators = new ArrayList < Class < ? extends ConstraintValidator < T , ? > > > ( list . size ( ) ) ; for ( Class < ? extends ConstraintValidator < ? , ? > > validatorClass : list ) { @ SuppressWarnings ( " unchecked " ) Class < ConstraintValidator < T , ? > > safeValidatorClass = ( Class < ConstraintValidator < T , ? > > ) validatorClass ; constraintsValidators . add ( safeValidatorClass ) ; } return constraintsValidators ; }
 @ Override protected MemorySegment nextSegment ( MemorySegment current , int positionInCurrent ) throws IOException { final MemorySegment next ; if ( this . writer == null ) { this . targetList . add ( current ) ; next = longTable . nextSegment ( ) ; } else { this . writer . writeBlock ( current ) ; try { next = this . writer . getReturnQueue ( ) . take ( ) ; } catch ( InterruptedException iex ) { throw new IOException ( " Hash ▁ Join ▁ Partition ▁ was ▁ interrupted ▁ while ▁ " + " grabbing ▁ a ▁ new ▁ write - behind ▁ buffer . " ) ; } } this . currentBlockNumber ++ ; return next ; }
 public SizingFlagDUnitTest ( ) { super ( ) ; }
 Builder addNonCodeInputs ( List < Artifact > nonCodeInputs ) { hasDirectLinkerInput = true ; linkerInputBuilder . addNonCodeInputs ( nonCodeInputs ) ; return this ; }
 protected SchemaAlteringStatement ( CFName name ) { super ( name ) ; this . isColumnFamilyLevel = true ; }
 public EClass getTText ( ) { return tTextEClass ; }
 public EReference getTTask_SearchBy ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 6 ) ; }
 private void setCommonAndroidOptions ( AndroidConfiguration . Options androidOptions , BuildOptions newOptions ) { newOptions . get ( CppOptions . class ) . cppCompiler = androidOptions . cppCompiler ; newOptions . get ( CppOptions . class ) . libcTopLabel = androidOptions . androidLibcTopLabel ; newOptions . get ( CppOptions . class ) . dynamicMode = androidOptions . dynamicMode ; setCrosstoolToAndroid ( newOptions ) ; newOptions . get ( PlatformOptions . class ) . platforms = ImmutableList . of ( ) ; }
 @ Override public boolean isValueCompatibleWithFrozen ( CollectionType < ? > previous ) { assert ! isMultiCell ; return this . elements . isValueCompatibleWithInternal ( ( ( ListType ) previous ) . elements ) ; }
 public void setVmTemplateId ( final Guid value ) { mVmTemplateId = value ; }
 @ Override public int hashCode ( ) { return Objects . hashCode ( libraries . hashCode ( ) , userLinkFlags . hashCode ( ) , linkstamps . hashCode ( ) , nonCodeInputs . hashCode ( ) ) ; }
 public String getPostcode ( ) { return postcode ; }
 private Collection < SSTableReader > getCandidatesFor ( int level ) { assert ! generations [ level ] . isEmpty ( ) ; logger . debug ( " Choosing ▁ candidates ▁ for ▁ L { } " , level ) ; final Set < SSTableReader > compacting = cfs . getDataTracker ( ) . getCompacting ( ) ; if ( level == 0 ) { Set < SSTableReader > candidates = new HashSet < SSTableReader > ( ) ; Set < SSTableReader > remaining = new HashSet < SSTableReader > ( ) ; Iterables . addAll ( remaining , Iterables . filter ( generations [ 0 ] , Predicates . not ( suspectP ) ) ) ; for ( SSTableReader sstable : ageSortedSSTables ( remaining ) ) { if ( candidates . contains ( sstable ) ) continue ; for ( SSTableReader newCandidate : Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , remaining ) ) ) { if ( ! compacting . contains ( newCandidate ) ) { candidates . add ( newCandidate ) ; remaining . remove ( newCandidate ) ; } } if ( candidates . size ( ) > MAX_COMPACTING_L0 ) { candidates = new HashSet < SSTableReader > ( ageSortedSSTables ( candidates ) . subList ( 0 , MAX_COMPACTING_L0 ) ) ; break ; } } if ( SSTable . getTotalBytes ( candidates ) > maxSSTableSizeInBytes ) { candidates = Sets . union ( candidates , overlapping ( candidates , generations [ 1 ] ) ) ; Iterable < SSTableReader > compactingL0 = Iterables . filter ( generations [ 0 ] , Predicates . in ( compacting ) ) ; if ( ! Sets . intersection ( candidates , compacting ) . isEmpty ( ) || ! overlapping ( candidates , compactingL0 ) . isEmpty ( ) ) return Collections . emptyList ( ) ; } return candidates . size ( ) > 1 ? candidates : Collections . < SSTableReader > emptyList ( ) ; } Collections . sort ( generations [ level ] , SSTable . sstableComparator ) ; int start = 0 ; for ( int i = 0 ; i < generations [ level ] . size ( ) ; i ++ ) { SSTableReader sstable = generations [ level ] . get ( i ) ; if ( sstable . first . compareTo ( lastCompactedKeys [ level ] ) > 0 ) { start = i ; break ; } } for ( int i = 0 ; i < generations [ level ] . size ( ) ; i ++ ) { SSTableReader sstable = generations [ level ] . get ( ( start + i ) % generations [ level ] . size ( ) ) ; Set < SSTableReader > candidates = Sets . union ( Collections . singleton ( sstable ) , overlapping ( sstable , generations [ level + 1 ] ) ) ; if ( Iterables . any ( candidates , suspectP ) ) continue ; if ( Sets . intersection ( candidates , compacting ) . isEmpty ( ) ) return candidates ; } return Collections . emptyList ( ) ; }
 final int getLastSegmentLimit ( ) { return this . finalBufferLimit ; }
 private IndexedEntry ( long position , DeletionTime deletionTime , long headerLength , List < IndexHelper . IndexInfo > columnsIndex ) { super ( position ) ; assert deletionTime != null ; assert columnsIndex != null && columnsIndex . size ( ) > 1 ; this . deletionTime = deletionTime ; this . headerLength = headerLength ; this . columnsIndex = columnsIndex ; }
 public XMLEvent nextTag ( ) throws XMLStreamException { if ( closed ) { throw new XMLStreamException ( " Stream ▁ has ▁ been ▁ closed " ) ; } XMLEvent event ; do { if ( hasNext ( ) ) { event = nextEvent ( ) ; if ( event . isStartElement ( ) || event . isEndElement ( ) ) { return event ; } else if ( event . isCharacters ( ) ) { if ( ! event . asCharacters ( ) . isWhiteSpace ( ) ) { throw new XMLStreamException ( " Non - ignorable ▁ space ▁ encountered " ) ; } } else if ( ! ( event instanceof Comment ) ) { throw new XMLStreamException ( " Non - ignorable ▁ event ▁ encountered : ▁ " + event ) ; } } else { throw new XMLStreamException ( " Ran ▁ out ▁ of ▁ events ▁ in ▁ nextTag ( ) " ) ; } } while ( ! event . isStartElement ( ) && ! event . isEndElement ( ) ) ; return event ; }
 @ Override @ FxThread public void incrementChange ( ) { final int result = changeCounter . incrementAndGet ( ) ; setDirty ( result != 0 ) ; }
 private boolean prHostsBucketForKey ( VM vm , final Object key ) { Boolean result = ( Boolean ) vm . invoke ( new SerializableCallable ( " prHostsBucketForKey " ) { public Object call ( ) { Cache cache = getCache ( ) ; DistributedMember myId = cache . getDistributedSystem ( ) . getDistributedMember ( ) ; Region region = cache . getRegion ( " region " ) ; DistributedMember hostMember = PartitionRegionHelper . getPrimaryMemberForKey ( region , key ) ; if ( hostMember == null ) { throw new IllegalStateException ( " bucket ▁ for ▁ key ▁ " + key + " ▁ is ▁ not ▁ hosted ! " ) ; } boolean res = Boolean . valueOf ( myId . equals ( hostMember ) ) ; return res ; } } ) ; return result . booleanValue ( ) ; }
 public EAttribute getTExpression_AnyAttribute ( ) { return ( EAttribute ) tExpressionEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 @ Test public void test0003 ( ) throws Exception { TestResource . testExpression ( " DN - 21-0012" , " $ { null ▁ & & ▁ null } " , " false " ) ; }
 if ( logger . isDebugEnabled ( ) ) { logger . debug ( " Sending ▁ ( { } ) ▁ to ▁ { } ▁ peers ▁ ( { } ) ▁ via ▁ tcp / ip " , msg , p_destinations . length , Arrays . toString ( p_destinations ) ) ; }
 @ Override public Img set ( int index , Img element ) { if ( element != null && checkRange ( index ) ) { Img old = array . get ( index ) ; array . set ( index , element ) ; return old ; } return null ; }
 MemorySegment [ ] close ( ) throws IOException { final MemorySegment current = getCurrentSegment ( ) ; if ( current == null ) { throw new IllegalStateException ( " Illegal ▁ State ▁ in ▁ LongHashTable : ▁ " + " No ▁ current ▁ buffer ▁ when ▁ finalizing ▁ build ▁ side . " ) ; } clear ( ) ; if ( this . writer == null ) { this . targetList . add ( current ) ; MemorySegment [ ] buffers = this . targetList . toArray ( new MemorySegment [ 0 ] ) ; this . targetList . clear ( ) ; return buffers ; } else { writer . writeBlock ( current ) ; return null ; } }
 public EAttribute getTExtensibleElements_AnyAttribute ( ) { return ( EAttribute ) tExtensibleElementsEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 protected ApiEntity ( ) { }
 public EAttribute getTTaskInterface_ResponseOperation ( ) { return ( EAttribute ) tTaskInterfaceEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 public Artifact getArtifact ( ) { return artifact ; }
 public void cancelCellEditing ( ) { fireEditingCanceled ( ) ; }
 @ JsonProperty ( " Description " ) public String getDescription ( ) { return description ; }
 @ Override public String toString ( ) { return String . format ( " EncodingStats ( ts = % d , ▁ ldt = % d , ▁ ttl = % d ) " , minTimestamp , minLocalDeletionTime , minTTL ) ; }
 public Object next ( ) { try { return nextEvent ( ) ; } catch ( XMLStreamException e ) { NoSuchElementException ex = new NoSuchElementException ( " Error ▁ getting ▁ next ▁ event " ) ; ex . initCause ( e ) ; throw ex ; } }
 public void setBuyerEmail ( final String buyerEmail ) { this . buyerEmail = buyerEmail ; }
 @ Override public RuleClass build ( RuleClass . Builder builder , final RuleDefinitionEnvironment env ) { return builder . requiresConfigurationFragments ( AndroidConfiguration . class , JavaConfiguration . class , CppConfiguration . class ) . add ( attr ( " srcs " , LABEL_LIST ) . direct_compile_time_input ( ) . allowedFileTypes ( JavaSemantics . JAVA_SOURCE , JavaSemantics . SOURCE_JAR ) ) . override ( builder . copy ( " manifest " ) . mandatory ( ) ) . override ( builder . copy ( " deps " ) . cfg ( TransitionFactories . of ( ANDROID_SPLIT_TRANSITION ) ) . allowedRuleClasses ( ALLOWED_DEPENDENCIES ) . allowedFileTypes ( ) . mandatoryProviders ( CONTAINS_CC_INFO_PARAMS ) . mandatoryProviders ( JavaRuleClasses . CONTAINS_JAVA_PROVIDER ) . mandatoryProviders ( SkylarkProviderIdentifier . forKey ( AndroidResourcesInfo . PROVIDER . getKey ( ) ) , SkylarkProviderIdentifier . forKey ( AndroidAssetsInfo . PROVIDER . getKey ( ) ) ) . aspect ( androidNeverlinkAspect ) . aspect ( dexArchiveAspect , DexArchiveAspect . PARAM_EXTRACTOR ) ) . add ( attr ( " debug _ key " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . legacyAllowAnyFileType ( ) . value ( env . getToolsLabel ( " // tools / android : debug _ keystore " ) ) ) . add ( attr ( " nocompress _ extensions " , STRING_LIST ) ) . add ( attr ( " crunch _ png " , BOOLEAN ) . value ( true ) ) . add ( attr ( ResourceFilterFactory . RESOURCE_CONFIGURATION_FILTERS_NAME , STRING_LIST ) ) . add ( attr ( " shrink _ resources " , TRISTATE ) . value ( TriState . AUTO ) ) . add ( attr ( ResourceFilterFactory . DENSITIES_NAME , STRING_LIST ) ) . add ( attr ( " $ build _ incremental _ dexmanifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( BUILD_INCREMENTAL_DEXMANIFEST_LABEL ) ) ) . add ( attr ( " $ stubify _ manifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( STUBIFY_MANIFEST_LABEL ) ) ) . add ( attr ( " $ shuffle _ jars " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : shuffle _ jars " ) ) ) . add ( attr ( " $ dexbuilder " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexbuilder " ) ) ) . add ( attr ( " $ dexbuilder _ after _ proguard " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexbuilder _ after _ proguard " ) ) ) . add ( attr ( " $ dexsharder " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexsharder " ) ) ) . add ( attr ( " $ dexmerger " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dexmerger " ) ) ) . add ( attr ( " $ merge _ dexzips " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : merge _ dexzips " ) ) ) . add ( attr ( " $ incremental _ install " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( INCREMENTAL_INSTALL_LABEL ) ) ) . add ( attr ( " $ build _ split _ manifest " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( BUILD_SPLIT_MANIFEST_LABEL ) ) ) . add ( attr ( " $ strip _ resources " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( STRIP_RESOURCES_LABEL ) ) ) . add ( attr ( " $ incremental _ stub _ application " , LABEL ) . value ( env . getToolsLabel ( DEFAULT_INCREMENTAL_STUB_APPLICATION ) ) . aspect ( dexArchiveAspect , DexArchiveAspect . ONLY_DESUGAR_JAVA8 ) ) . add ( attr ( " $ incremental _ split _ stub _ application " , LABEL ) . value ( env . getToolsLabel ( DEFAULT_INCREMENTAL_SPLIT_STUB_APPLICATION ) ) . aspect ( dexArchiveAspect , DexArchiveAspect . ONLY_DESUGAR_JAVA8 ) ) . add ( attr ( " $ desugar " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : desugar _ java8" ) ) ) . add ( attr ( " $ java8 _ legacy _ dex " , LABEL ) . value ( env . getToolsLabel ( " // tools / android : java8 _ legacy _ dex " ) ) ) . add ( attr ( " $ build _ java8 _ legacy _ dex " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : build _ java8 _ legacy _ dex " ) ) ) . add ( attr ( " $ desugared _ java8 _ legacy _ apis " , LABEL ) . value ( env . getToolsLabel ( " // tools / android : desugared _ java8 _ legacy _ apis " ) ) ) . add ( attr ( " dexopts " , STRING_LIST ) ) . add ( attr ( " dex _ shards " , INTEGER ) . value ( 1 ) ) . add ( attr ( " incremental _ dexing " , TRISTATE ) . nonconfigurable ( " AspectParameters ▁ don ' t ▁ support ▁ configurations . " ) ) . add ( attr ( " multidex " , STRING ) . allowedValues ( new AllowedValueSet ( MultidexMode . getValidValues ( ) ) ) . value ( MultidexMode . OFF . getAttributeValue ( ) ) ) . add ( attr ( " main _ dex _ list _ opts " , STRING_LIST ) ) . add ( attr ( " main _ dex _ list " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " main _ dex _ proguard _ specs " , LABEL_LIST ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ specs " , LABEL_LIST ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ generate _ mapping " , BOOLEAN ) . value ( false ) . nonconfigurable ( " value ▁ is ▁ referenced ▁ in ▁ an ▁ ImplicitOutputsFunction " ) ) . add ( attr ( " proguard _ apply _ mapping " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " proguard _ apply _ dictionary " , LABEL ) . legacyAllowAnyFileType ( ) ) . add ( attr ( " : extra _ proguard _ specs " , LABEL_LIST ) . value ( JavaSemantics . EXTRA_PROGUARD_SPECS ) ) . add ( attr ( " $ dex _ list _ obfuscator " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : dex _ list _ obfuscator " ) ) ) . add ( attr ( " : bytecode _ optimizers " , LABEL_LIST ) . cfg ( HostTransition . createFactory ( ) ) . value ( JavaSemantics . BYTECODE_OPTIMIZERS ) ) . add ( attr ( " $ cc _ toolchain _ split " , LABEL ) . cfg ( TransitionFactories . of ( ANDROID_SPLIT_TRANSITION ) ) . value ( env . getToolsLabel ( " // tools / cpp : current _ cc _ toolchain " ) ) ) . add ( attr ( " manifest _ values " , STRING_DICT ) ) . add ( attr ( " aapt _ version " , STRING ) . allowedValues ( new AllowedValueSet ( AndroidAaptVersion . getAttributeValues ( ) ) ) . value ( AndroidAaptVersion . getRuleAttributeDefault ( ) ) ) . add ( attr ( AndroidFeatureFlagSetProvider . FEATURE_FLAG_ATTR , LABEL_KEYED_STRING_DICT ) . undocumented ( " the ▁ feature ▁ flag ▁ feature ▁ has ▁ not ▁ yet ▁ been ▁ launched " ) . allowedRuleClasses ( " config _ feature _ flag " ) . allowedFileTypes ( ) . nonconfigurable ( " defines ▁ an ▁ aspect ▁ of ▁ configuration " ) . mandatoryProviders ( ImmutableList . of ( ConfigFeatureFlagProvider . id ( ) ) ) ) . add ( AndroidFeatureFlagSetProvider . getWhitelistAttribute ( env ) ) . add ( attr ( " $ resource _ extractor " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : resource _ extractor " ) ) ) . add ( attr ( " instruments " , LABEL ) . allowedRuleClasses ( " android _ binary " ) . allowedFileTypes ( NO_FILE ) ) . add ( attr ( " $ instrumentation _ test _ check " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . value ( new Attribute . ComputedDefault ( ) { @ Override public Object getDefault ( AttributeMap rule ) { return rule . isAttributeValueExplicitlySpecified ( " instruments " ) ? env . getToolsLabel ( " // tools / android : instrumentation _ test _ check " ) : null ; } } ) . exec ( ) ) . add ( attr ( " $ zip _ filter " , LABEL ) . cfg ( HostTransition . createFactory ( ) ) . exec ( ) . value ( env . getToolsLabel ( " // tools / android : zip _ filter " ) ) ) . add ( attr ( " application _ resources " , LABEL ) . mandatoryProviders ( AndroidApplicationResourceInfo . PROVIDER . id ( ) ) . allowedFileTypes ( NO_FILE ) . undocumented ( " Do ▁ not ▁ use ▁ this ▁ attribute . ▁ It ' s ▁ for ▁ the ▁ migration ▁ of ▁ " + " Android ▁ resource ▁ processing ▁ to ▁ Starlark ▁ only . " ) ) . removeAttribute ( " data " ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( ApkInfo . PROVIDER . getKey ( ) ) ) . advertiseSkylarkProvider ( SkylarkProviderIdentifier . forKey ( JavaInfo . PROVIDER . getKey ( ) ) ) . build ( ) ; }
 public EReference getDocumentRoot_Priority ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 15 ) ; }
 @ FxThread protected void doOpenFile ( @ NotNull final Path file ) throws IOException { }
 public long headerOffset ( ) { return 0 ; }
 @ Override public void onStateChange ( State state , WebSocketProxy proxy ) { }
 InputProvider ( EvaluationContext evaluationContext ) { this . evaluationContext = evaluationContext ; }
 private String getField ( final Map map , @ NotNull final String name ) { return ( String ) map . get ( name ) ; }
 public int getAvailableInModes ( ) { return availableInModes ; }
 public EAttribute getTToPart_ExpressionLanguage ( ) { return ( EAttribute ) tToPartEClass . getEStructuralFeatures ( ) . get ( 0 ) ; }
 public PurchasableDestroy ( long cost , Building building ) { super ( cost , null ) ; this . building = building ; this . cost = cost ; this . resource = ( ( cost >= 0 ) ? " buy : " : " sell : " ) + building . getResource ( ) . toString ( ) . replace ( " : " , " _ " ) ; }
 @ Override public Object createObject ( ) throws Exception { RemoveSubscriptionInfo info = new RemoveSubscriptionInfo ( ) ; populateObject ( info ) ; return info ; }
 @ Override @ FromAnyThread public void undo ( ) { operationControl . undo ( ) ; }
 private ListType ( AbstractType < T > elements , boolean isMultiCell ) { super ( ComparisonType . CUSTOM , Kind . LIST ) ; this . elements = elements ; this . serializer = ListSerializer . getInstance ( elements . getSerializer ( ) ) ; this . isMultiCell = isMultiCell ; }
 int getRecursionLevel ( ) { return this . recursionLevel ; }
 @ Override public Collection < GPFunc < GpGlobal > > create ( ) { return Arrays . asList ( new If4 < GpGlobal > ( ) , new Add < GpGlobal > ( ) , new Sub < GpGlobal > ( ) , new Div < GpGlobal > ( ) , new Mul < GpGlobal > ( ) , new Pow < GpGlobal > ( ) , new Neg < GpGlobal > ( ) , new Min < GpGlobal > ( ) , new Max < GpGlobal > ( ) , new Constant < GpGlobal > ( 10 ) , new Constant < GpGlobal > ( 2 ) , new Constant < GpGlobal > ( 1 ) , new Constant < GpGlobal > ( 0 ) , new InsertionFlexibility ( ) , new InsertionCost ( ) , new InsertionTravelTime ( ) , new InsertionTardiness ( ) , new InsertionOverTime ( ) , new TimeLeft ( ) , new Slack ( ) , new Ado ( ) , new Mido ( ) , new Mado ( ) , new RouteLength ( ) , new PickupUrgency ( ) , new DeliveryUrgency ( ) ) ; }
 @ Override public Class < ? > [ ] getOperationClasses ( ) { return new Class < ? > [ ] { long [ ] . class } ; }
 @ Override public long getNumForRunning ( ) { return this . numForRunning ; }
 protected void log ( ) { final Transaction transaction = TransactionSupport . suspend ( ) ; try { try { AuditLogDirector . log ( this ) ; } catch ( final RuntimeException ex ) { log . errorFormat ( " Error ▁ during ▁ log ▁ command : ▁ { 0 } . ▁ Exception ▁ { 1 } " , getClass ( ) . getName ( ) , ex ) ; } } finally { TransactionSupport . resume ( transaction ) ; } }
 public EReference getTPeopleAssignments_BusinessAdministrators ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 5 ) ; }
 @ JsonProperty ( " IsProductNumberAssignmentAllowed " ) public void setIsProductNumberAssignmentAllowed ( Boolean isProductNumberAssignmentAllowed ) { this . isProductNumberAssignmentAllowed = isProductNumberAssignmentAllowed ; }
 public void setUserId ( final NGuid value ) { mUserId = value . getValue ( ) ; }
 public EClass getTOrganizationalEntity ( ) { return tOrganizationalEntityEClass ; }
 if ( len > 0 ) { arr = new Class < ? > [ len ] ; for ( int i = 0 ; i < len ; i ++ ) arr [ i ] = ( Class < ? > ) in . readObject ( ) ; }
 private void assignPRBuckets ( VM vm ) { vm . invoke ( new SerializableRunnable ( " assignPRBuckets " ) { public void run ( ) { Cache cache = getCache ( ) ; PartitionRegionHelper . assignBucketsToPartitions ( cache . getRegion ( " region " ) ) ; } } ) ; }
 public AssetComponentLoadedEvent ( @ NotNull Path assetFolder ) { super ( EVENT_TYPE ) ; setAssetFolder ( assetFolder ) ; }
 public NestedSet < Artifact > getDeclaredIncludeSrcs ( ) { return declaredIncludeSrcs ; }
 @ Override public long getLastHandleDataTime ( ) { return this . lastHandleDataTime ; }
 protected Quota getQuota ( ) { if ( quota == null && quotaId != null ) { try { quota = getQuotaDAO ( ) . getById ( getQuotaId ( ) ) ; } catch ( final RuntimeException e ) { log . infoFormat ( " Failed ▁ to ▁ get ▁ quota ▁ { 0 } \n { 1 } " , quotaId , e . getMessage ( ) ) ; } } return quota ; }
 long getMinKey ( ) { return minKey ; }
 @ Override public void setReadPosition ( long pointer ) { final int bufferNum = ( int ) ( pointer >>> this . segmentSizeBits ) ; final int offset = ( int ) ( pointer & segmentSizeMask ) ; this . currentBufferNum = bufferNum ; seekInput ( this . partitionBuffers [ bufferNum ] , offset , bufferNum < partitionBuffers . length - 1 ? segmentSize : finalBufferLimit ) ; }
 public boolean shouldSelectCell ( final EventObject event ) { return true ; }
 @ Override @ FxThread public boolean isInside ( final double sceneX , final double sceneY , @ NotNull final Class < ? extends Event > eventType ) { return false ; }
 @ Test public void testPollConfigAndUsage ( ) throws Exception { TCPController configServer = new TCPController ( ) ; int version = 10 ; configServer . setHandler ( new MockHandler ( version , serverList ) ) ; configServer . setCodecFactory ( new TextLineCodecFactory ( ) ) ; configServer . bind ( new InetSocketAddress ( 2271 ) ) ; try { AWSElasticCacheClient client = new AWSElasticCacheClient ( new InetSocketAddress ( 2271 ) ) ; ClusterConfiguration config = client . getCurrentConfig ( ) ; assertEquals ( config . getVersion ( ) , version ) ; assertEquals ( addresses . size ( ) , config . getNodeList ( ) . size ( ) ) ; client . set ( " aws - cache " , 0 , " foobar " ) ; assertEquals ( " foobar " , client . get ( " aws - cache " ) ) ; } finally { configServer . stop ( ) ; } }
 public EClass getTDurationExpr ( ) { return tDurationExprEClass ; }
 @ Override public List < IndexHelper . IndexInfo > columnsIndex ( ) { return columnsIndex ; }
 public ControlMetric ( ControlMetricType metricType , MetricValue metricValue ) { this . metricType = metricType ; this . metricValue = metricValue ; }
 private void doPRMemLRUTest ( ) { Host host = Host . getHost ( 0 ) ; VM vm0 = host . getVM ( 0 ) ; VM vm1 = host . getVM ( 1 ) ; createPR ( vm0 , true ) ; createPR ( vm1 , true ) ; put ( vm0 , 0 , new TestObject ( 100 , 100000 ) ) ; assertValueType ( vm0 , 0 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 0 , ValueType . CD_SERIALIZED ) ; long origEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long origEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long origPRSize0 = getSizeFromPRStats ( vm0 ) ; long origPRSize1 = getSizeFromPRStats ( vm1 ) ; put ( vm0 , 0 , new TestObject ( 200 , 200000 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm0 ) ) ; long finalEvictionSize0 = getSizeFromEvictionStats ( vm0 ) ; long finalPRSize0 = getSizeFromPRStats ( vm0 ) ; long finalEvictionSize1 = getSizeFromEvictionStats ( vm1 ) ; long finalPRSize1 = getSizeFromPRStats ( vm1 ) ; assertEquals ( 100 , finalEvictionSize0 - origEvictionSize0 ) ; assertEquals ( 100 , finalEvictionSize1 - origEvictionSize1 ) ; assertEquals ( 100 , finalPRSize0 - origPRSize0 ) ; assertEquals ( 100 , finalPRSize1 - origPRSize1 ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; Object v = new TestObject ( 200 , 200000 ) ; get ( vm0 , 0 , v ) ; int vSize = CachedDeserializableFactory . calcSerializedMemSize ( v ) ; assertValueType ( vm0 , 0 , ValueType . CD_DESERIALIZED ) ; assertValueType ( vm1 , 0 , ValueType . CD_SERIALIZED ) ; long evictionSizeAfterGet = getSizeFromEvictionStats ( vm0 ) ; long prSizeAfterGet = getSizeFromPRStats ( vm0 ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 200000 + CachedDeserializableFactory . overhead ( ) - vSize , evictionSizeAfterGet - finalEvictionSize0 ) ; assertEquals ( 0 , prSizeAfterGet - finalPRSize0 ) ; put ( vm0 , 113 , new TestObject ( 100 , 1024 * 1024 ) ) ; assertValueType ( vm0 , 113 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 113 , ValueType . CD_SERIALIZED ) ; long evictionSizeAfterPutVm1 = getSizeFromEvictionStats ( vm1 ) ; assertEquals ( 0 , getEvictions ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm1 ) ) ; get ( vm1 , 113 , new TestObject ( 100 , 1024 * 1024 ) ) ; long evictionSizeAfterGetVm1 = getSizeFromEvictionStats ( vm1 ) ; assertValueType ( vm0 , 113 , ValueType . CD_SERIALIZED ) ; assertValueType ( vm1 , 113 , ValueType . EVICTED ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm0 ) ) ; assertEquals ( 0 , getEvictions ( vm0 ) ) ; assertEquals ( 1 , getObjectSizerInvocations ( vm1 ) ) ; assertEquals ( 2 , getEvictions ( vm1 ) ) ; }
 @ Override public BinaryRowData getRow ( ) { return this . reuse ; }
 public void makeNotes ( ) { }
 public void set ( long address ) { this . address = address ; }
 @ Override public AbstractType < ? > freeze ( ) { if ( isMultiCell ) return getInstance ( this . elements , false ) ; else return this ; }
 public void signalEOF ( ) { log . debug ( " signalEOF ( ) ▁ entered ▁ for ▁ " + this ) ; pusher . signalEOF ( ) ; log . trace ( " signalEOF ( ) ▁ completed ▁ for ▁ " + this ) ; }
 @ Override public long getLastErrorTime ( ) { return this . lastErrorTime ; }
 @ Inject MergeSuperSet ( @ GerritServerConfig Config cfg , ChangeData . Factory changeDataFactory , Provider < InternalChangeQuery > queryProvider , GitRepositoryManager repoManager ) { this . cfg = cfg ; this . changeDataFactory = changeDataFactory ; this . queryProvider = queryProvider ; this . repoManager = repoManager ; }
 public ResultMessage executeInternal ( QueryState state ) { throw new UnsupportedOperationException ( ) ; }
 public ImmutableList < String > getFlattenedUserLinkFlags ( ) { return getUserLinkFlags ( ) . toList ( ) . stream ( ) . map ( LinkOptions :: get ) . flatMap ( Collection :: stream ) . collect ( ImmutableList . toImmutableList ( ) ) ; }
 public EncodingStats mergeWith ( EncodingStats that ) { long minTimestamp = this . minTimestamp == TIMESTAMP_EPOCH ? that . minTimestamp : ( that . minTimestamp == TIMESTAMP_EPOCH ? this . minTimestamp : Math . min ( this . minTimestamp , that . minTimestamp ) ) ; int minDelTime = this . minLocalDeletionTime == DELETION_TIME_EPOCH ? that . minLocalDeletionTime : ( that . minLocalDeletionTime == DELETION_TIME_EPOCH ? this . minLocalDeletionTime : Math . min ( this . minLocalDeletionTime , that . minLocalDeletionTime ) ) ; int minTTL = this . minTTL == TTL_EPOCH ? that . minTTL : ( that . minTTL == TTL_EPOCH ? this . minTTL : Math . min ( this . minTTL , that . minTTL ) ) ; return new EncodingStats ( minTimestamp , minDelTime , minTTL ) ; }
 public EAttribute getTLogicalPeopleGroup_Reference ( ) { return ( EAttribute ) tLogicalPeopleGroupEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 @ Override public Metadata getMetadata ( ) { return RuleDefinition . Metadata . builder ( ) . name ( " $ android _ resource _ support " ) . type ( RuleClassType . ABSTRACT ) . ancestors ( AndroidRuleClasses . AndroidBaseRule . class ) . build ( ) ; }
 public EReference getTTask_PeopleAssignments ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 2 ) ; }
 public void updateTimestamp ( long timestamp ) { isTimestampSet = true ; minTimestamp = Math . min ( minTimestamp , timestamp ) ; }
 public Guid getVdsId ( ) { return mVdsId != null ? mVdsId . getValue ( ) : Guid . Empty ; }
 protected Command getReorientRelationshipCommand ( ReorientRelationshipRequest req ) { switch ( getVisualID ( req ) ) { case EsbLinkEditPart . VISUAL_ID : return getGEFWrapper ( new EsbLinkReorientCommand ( req ) ) ; } return super . getReorientRelationshipCommand ( req ) ; }
 public DefaultPet ( final String name , final IntervalTable < AnimalYearResult > rolltable ) { super ( ) ; checkNotNull ( name , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ name " ) ; checkNotNull ( rolltable , " Received ▁ a ▁ null ▁ pointer ▁ as ▁ roll ▁ table " ) ; this . name = name ; this . rolltable = rolltable ; }
 public EAttribute getTToPart_Name ( ) { return ( EAttribute ) tToPartEClass . getEStructuralFeatures ( ) . get ( 1 ) ; }
 private void assertNoParameterStartsWithValid ( Class < ? extends Annotation > annotationType ) { final Method [ ] methods = ReflectionHelper . getMethods ( annotationType ) ; for ( Method m : methods ) { if ( m . getName ( ) . startsWith ( " valid " ) ) { String msg = " Parameters ▁ starting ▁ with ▁ ' valid ' ▁ are ▁ not ▁ allowed ▁ in ▁ a ▁ constraint . " ; throw new ConstraintDefinitionException ( msg ) ; } } }
 @ Override public final boolean isImmutable ( ) { return true ; }
 @ Override @ FxThread protected boolean loadCollapsed ( ) { return getConfig ( ) . isGlobalBottomToolCollapsed ( ) ; }
 @ Override @ FxThread protected void addListeners ( @ NotNull TabToolComponent toolComponent ) { ObservableUtils . onChange ( toolComponent . heightProperty ( ) , this :: handleToolChanged ) ; }
 @ Test public void testRRMemLRUDeltaAndFlag ( ) { doRRMemLRUDeltaTest ( true ) ; }
 public NestedSet < LinkOptions > getUserLinkFlags ( ) { NestedSetBuilder < LinkOptions > userLinkFlags = NestedSetBuilder . linkOrder ( ) ; for ( LinkerInput linkerInput : linkerInputs . toList ( ) ) { userLinkFlags . addAll ( linkerInput . getUserLinkFlags ( ) ) ; } return userLinkFlags . build ( ) ; }
 @ Test public void testPRHeapLRUDeltaWithFlagPutOnPrimary ( ) { doPRDeltaTestLRU ( false , true , true , false ) ; }
 public void generate ( File dir , File props ) { File modProps ; if ( props == null ) { modProps = getResourceFromJar ( ENTRY_PATH , MODULES_PROPERTIES_NAME ) ; modProps . deleteOnExit ( ) ; } else { modProps = props ; } dstDir = ( dir != null ) ? dir : new File ( userDir ) ; Properties prs = null ; FileInputStream fis = null ; int fails = 0 ; try { fis = new FileInputStream ( modProps ) ; } catch ( FileNotFoundException e ) { logMessage ( " Generation ▁ error : ▁ Specified ▁ file ▁ " + modProps . getPath ( ) + " ▁ doesn ' t ▁ exist ! " ) ; return ; } prs = new Properties ( ) ; try { prs . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { logMessage ( " \n Generation ▁ error : " + e . getMessage ( ) ) ; } logMessage ( " \n Generation ▁ started : \n " ) ; logMessage ( " Modules ▁ generation ▁ status : ▁ " ) ; Enumeration en = prs . keys ( ) ; while ( en . hasMoreElements ( ) ) { String modName = prs . getProperty ( ( String ) en . nextElement ( ) ) . trim ( ) ; logMessage ( modName + " ▁ : ▁ " ) ; try { createSourceFromTemplate ( modName , MESSAGES_TEMPLATE_FILE , MSG_class_NAME ) ; createMsgsProperties ( modName ) ; } catch ( Exception e ) { logMessage ( " error : ▁ " + e . getMessage ( ) ) ; fails ++ ; continue ; } logMessage ( " completed " ) ; } if ( fails == 0 ) { logMessage ( " \n Generation ▁ successfully ▁ finished ! " ) ; } else { logMessage ( " \n Generation ▁ finished ▁ with ▁ " + fails + " ▁ fails ! " ) ; logMessage ( " See ▁ output ▁ information ▁ for ▁ details ! " ) ; } }
 @ FromAnyThread protected @ NotNull EditorOperationControl getOperationControl ( ) { return operationControl ; }
 public DeleteClusterResponse ( ) { }
 ) @ Override @ Nullable public < InputT > TransformEvaluator < InputT > forApplication ( AppliedPTransform < ? , ? , ? > application , CommittedBundle < ? > inputBundle ) throws IOException { return createEvaluator ( ( AppliedPTransform ) application ) ; }
 protected DbFacade getDbFacade ( ) { return DbFacade . getInstance ( ) ; }
 public GlusterVolumeDao getGlusterVolumeDao ( ) { return getDbFacade ( ) . getGlusterVolumeDao ( ) ; }
 public void removeCellEditorListener ( final CellEditorListener l ) { listenerList . remove ( CellEditorListener . class , l ) ; }
 public EClass getTExtension ( ) { return tExtensionEClass ; }
 public synchronized void replace ( Iterable < SSTableReader > removed , Iterable < SSTableReader > added ) { assert ! Iterables . isEmpty ( removed ) ; logDistribution ( ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Replacing ▁ [ " + toString ( removed ) + " ] " ) ; for ( SSTableReader sstable : removed ) remove ( sstable ) ; if ( ! added . iterator ( ) . hasNext ( ) ) return ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Adding ▁ [ { } ] " , toString ( added ) ) ; int minLevel = Integer . MAX_VALUE ; for ( SSTableReader ssTableReader : added ) { minLevel = Math . min ( minLevel , ssTableReader . getSSTableLevel ( ) ) ; add ( ssTableReader ) ; } lastCompactedKeys [ minLevel ] = SSTable . sstableOrdering . max ( added ) . last ; }
 public Map < String , String > getCustomValues ( ) { return customValues ; }
 public String getStreet ( ) { return street ; }
 @ VisibleForTesting public int remove ( SSTableReader reader ) { int level = reader . getSSTableLevel ( ) ; assert level >= 0 : reader + " ▁ not ▁ present ▁ in ▁ manifest : ▁ " + level ; generations [ level ] . remove ( reader ) ; return level ; }
 @ Transient private boolean isAddressDetached ( ) { return address != null && address . isDetached ( ) ; }
 public MemorySegment [ ] getBuckets ( ) { return buckets ; }
 private void cleanupFileUploads ( @ Nullable FileUploads uploadedFiles ) { if ( uploadedFiles != null ) { try { uploadedFiles . close ( ) ; } catch ( IOException e ) { log . warn ( " Could ▁ not ▁ cleanup ▁ uploaded ▁ files . " , e ) ; } } }
 public EReference getTTask_Delegation ( ) { return ( EReference ) tTaskEClass . getEStructuralFeatures ( ) . get ( 3 ) ; }
 public void update ( DeletionTime deletionTime ) { if ( deletionTime . isLive ( ) ) return ; updateTimestamp ( deletionTime . markedForDeleteAt ( ) ) ; updateLocalDeletionTime ( deletionTime . localDeletionTime ( ) ) ; }
 @ Override public String getId ( ) { return this . jobId ; }
 @ Override public long getLastBeginTime ( ) { return this . lastBeginTime ; }
 public EReference getTPeopleAssignments_TaskStakeholders ( ) { return ( EReference ) tPeopleAssignmentsEClass . getEStructuralFeatures ( ) . get ( 4 ) ; }
 @ Override public final DefaultPet createNewInstance ( ) { return new DefaultPet ( this ) ; }
 @ Test public void testPRNoLRUAndFlagDelta ( ) { doPRNoLRUDeltaTest ( true ) ; }
 public MatchIterator get ( long key , int hashCode ) { int bucket = findBucket ( hashCode ) ; int bucketOffset = bucket << 4 ; MemorySegment segment = buckets [ bucketOffset >>> segmentSizeBits ] ; int segOffset = bucketOffset & segmentSizeMask ; while ( true ) { long address = segment . getLong ( segOffset + 8 ) ; if ( address != INVALID_ADDRESS ) { if ( segment . getLong ( segOffset ) == key ) { return valueIter ( address ) ; } else { bucket = ( bucket + 1 ) & numBucketsMask ; if ( segOffset + 16 < segmentSize ) { segOffset += 16 ; } else { bucketOffset = bucket << 4 ; segOffset = bucketOffset & segmentSizeMask ; segment = buckets [ bucketOffset >>> segmentSizeBits ] ; } } } else { return valueIter ( INVALID_ADDRESS ) ; } } }
 public MetricValue metricValue ( ) { return metricValue ; }
 private LeveledManifest ( ColumnFamilyStore cfs , int maxSSTableSizeInMB , SizeTieredCompactionStrategyOptions options ) { this . cfs = cfs ; this . maxSSTableSizeInBytes = maxSSTableSizeInMB * 1024 * 1024 ; this . options = options ; int n = ( int ) Math . log10 ( 1000 * 1000 * 1000 / maxSSTableSizeInMB ) ; generations = new List [ n ] ; lastCompactedKeys = new RowPosition [ n ] ; for ( int i = 0 ; i < generations . length ; i ++ ) { generations [ i ] = new ArrayList < SSTableReader > ( ) ; lastCompactedKeys [ i ] = cfs . partitioner . getMinimumToken ( ) . minKeyBound ( ) ; } }
 public EReference getDocumentRoot_Users ( ) { return ( EReference ) documentRootEClass . getEStructuralFeatures ( ) . get ( 22 ) ; }
 @ Override public ItemStack getDisplayStack ( ) { return building . getSpawner ( ) ; }
 public synchronized Pair < ? extends Collection < SSTableReader > , Integer > getCompactionCandidates ( ) { for ( int i = generations . length - 1 ; i > 0 ; i -- ) { List < SSTableReader > sstables = generations [ i ] ; if ( sstables . isEmpty ( ) ) continue ; Set < SSTableReader > sstablesInLevel = Sets . newHashSet ( sstables ) ; Set < SSTableReader > remaining = Sets . difference ( sstablesInLevel , cfs . getDataTracker ( ) . getCompacting ( ) ) ; double score = ( double ) SSTableReader . getTotalBytes ( remaining ) / ( double ) maxBytesForLevel ( i ) ; logger . debug ( " Compaction ▁ score ▁ for ▁ level ▁ { } ▁ is ▁ { } " , i , score ) ; if ( score > 1.001 ) { if ( generations [ 0 ] . size ( ) > MAX_COMPACTING_L0 ) { Iterable < SSTableReader > candidates = cfs . getDataTracker ( ) . getUncompactingSSTables ( generations [ 0 ] ) ; List < Pair < SSTableReader , Long > > pairs = SizeTieredCompactionStrategy . createSSTableAndLengthPairs ( AbstractCompactionStrategy . filterSuspectSSTables ( candidates ) ) ; List < List < SSTableReader > > buckets = SizeTieredCompactionStrategy . getBuckets ( pairs , options . bucketHigh , options . bucketLow , options . minSSTableSize ) ; List < SSTableReader > mostInteresting = SizeTieredCompactionStrategy . mostInterestingBucket ( buckets , 4 , 32 ) ; if ( ! mostInteresting . isEmpty ( ) ) return Pair . create ( mostInteresting , 0 ) ; } Collection < SSTableReader > candidates = getCandidatesFor ( i ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( " Compaction ▁ candidates ▁ for ▁ L { } ▁ are ▁ { } " , i , toString ( candidates ) ) ; if ( ! candidates . isEmpty ( ) ) return Pair . create ( candidates , getNextLevel ( candidates ) ) ; } } if ( generations [ 0 ] . isEmpty ( ) ) return null ; Collection < SSTableReader > candidates = getCandidatesFor ( 0 ) ; if ( candidates . isEmpty ( ) ) return null ; return Pair . create ( candidates , getNextLevel ( candidates ) ) ; }
 @ Override public SslContext getServerSslContext ( final SSLContextConfig config , final Map < String , Object > additionalOpts ) throws Exception { log . debugf ( " Creating ▁ Server ▁ OpenSSL ▁ Context ▁ with ▁ % s " , config ) ; return new SSLSupport ( config ) . setSslProvider ( TransportConstants . OPENSSL_PROVIDER ) . createNettyContext ( ) ; }
 @ Override public Label getStarlarkOwner ( ) throws EvalException { if ( owner == null ) { throw Starlark . errorf ( " Owner ▁ is ▁ null . ▁ This ▁ means ▁ that ▁ some ▁ target ▁ upstream ▁ is ▁ of ▁ a ▁ rule ▁ type ▁ that ▁ uses ▁ the " + " ▁ old ▁ API ▁ of ▁ create _ linking _ context " ) ; } return owner ; }
 @ JsonProperty ( " CriteriaTypeCode " ) public void setCriteriaTypeCode ( String criteriaTypeCode ) { this . criteriaTypeCode = criteriaTypeCode ; }
