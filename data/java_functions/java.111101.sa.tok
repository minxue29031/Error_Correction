GlenRSmith/elasticsearch | static TokenizerFactory newFactory ( String name , Supplier < Tokenizer > supplier ) { return new TokenizerFactory ( ) { @ Override public String name ( ) { return name ; } @ Override public Tokenizer create ( ) { return supplier . get ( ) ; } } ; }
sscdotopen/giraph-compensations | public static void setGraphState ( BasicVertex vertex , GraphState graphState ) throws Exception { Class < ? extends BasicVertex > c = BasicVertex . class ; Method m = c . getDeclaredMethod ( " setGraphState " , GraphState . class ) ; m . setAccessible ( true ) ; m . invoke ( vertex , graphState ) ; }
sscdotopen/giraph-compensations | public static < I extends WritableComparable , V extends Writable , E extends Writable , M extends Writable > void assertValidVertex ( Configuration conf , GraphState < I , V , E , M > graphState , BasicVertex < I , V , E , M > actual , I expectedId , V expectedValue , Edge < I , E > ... edges ) throws Exception { BasicVertex < I , V , E , M > expected = BspUtils . createVertex ( conf ) ; setGraphState ( expected , graphState ) ; Map < I , E > edgeMap = Maps . newHashMap ( ) ; for ( Edge < I , E > edge : edges ) { edgeMap . put ( edge . getDestVertexId ( ) , edge . getEdgeValue ( ) ) ; } expected . initialize ( expectedId , expectedValue , edgeMap , null ) ; assertValid ( expected , actual ) ; }
sscdotopen/giraph-compensations | public static < I extends WritableComparable , V extends Writable , E extends Writable , M extends Writable > void assertValid ( BasicVertex < I , V , E , M > expected , BasicVertex < I , V , E , M > actual ) { assertEquals ( expected . getVertexId ( ) , actual . getVertexId ( ) ) ; assertEquals ( expected . getVertexValue ( ) , actual . getVertexValue ( ) ) ; assertEquals ( expected . getNumEdges ( ) , actual . getNumEdges ( ) ) ; List < Edge < I , E > > expectedEdges = Lists . newArrayList ( ) ; List < Edge < I , E > > actualEdges = Lists . newArrayList ( ) ; for ( I actualDestId : actual ) { actualEdges . add ( new Edge < I , E > ( actualDestId , actual . getEdgeValue ( actualDestId ) ) ) ; } for ( I expectedDestId : expected ) { expectedEdges . add ( new Edge < I , E > ( expectedDestId , expected . getEdgeValue ( expectedDestId ) ) ) ; } Collections . sort ( expectedEdges ) ; Collections . sort ( actualEdges ) ; for ( int i = 0 ; i < expectedEdges . size ( ) ; i ++ ) { assertEquals ( expectedEdges . get ( i ) , actualEdges . get ( i ) ) ; } }
podpage/J-lexa | public static Header parse ( List < String > lines ) throws IOException { Header header = new Header ( ) ; lines . forEach ( line -> { if ( header . getRequestMethod ( ) == null ) { for ( RequestMethod requestMethod : RequestMethod . values ( ) ) { if ( line . startsWith ( requestMethod . name ( ) + " ▁ " ) ) { header . setRequestURL ( line . split ( " ▁ " ) [ 1 ] ) ; header . setRequestMethod ( requestMethod ) ; break ; } } } for ( HeaderField headerField : HeaderField . values ( ) ) { if ( headerField . getType ( ) != HeaderType . RESPONSE ) { if ( line . toLowerCase ( ) . startsWith ( headerField . getName ( ) . toLowerCase ( ) + " : " ) ) { headerField . setContent ( line . substring ( line . indexOf ( " : " ) + 1 , line . length ( ) ) . trim ( ) ) ; header . addHeaderField ( headerField ) ; } } } } ) ; return header ; }
Sargul/dbeaver | private static String formatReleaseNotes ( String releaseNotes ) { while ( releaseNotes . startsWith ( " \n " ) ) { releaseNotes = releaseNotes . substring ( 1 ) ; } String [ ] rnLines = releaseNotes . split ( " \n " ) ; int leadSpacesNum = 0 ; for ( int i = 0 ; i < rnLines [ 0 ] . length ( ) ; i ++ ) { if ( rnLines [ 0 ] . charAt ( i ) == ' ▁ ' ) { leadSpacesNum ++ ; } else { break ; } } StringBuilder result = new StringBuilder ( ) ; for ( String rnLine : rnLines ) { if ( rnLine . length ( ) > leadSpacesNum ) { if ( result . length ( ) > 0 ) result . append ( " \n " ) ; result . append ( rnLine . substring ( leadSpacesNum ) ) ; } } return result . toString ( ) ; }
dagnir/aws-sdk-java | public static DeleteFlowLogsResultStaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new DeleteFlowLogsResultStaxUnmarshaller ( ) ; return instance ; }
GlenRSmith/elasticsearch | public static ParsedValueCount fromXContent ( XContentParser parser , final String name ) { ParsedValueCount sum = PARSER . apply ( parser , null ) ; sum . setName ( name ) ; return sum ; }
raviperi/storm | public static byte [ ] serialize ( Object obj ) throws IOException { try ( ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ) { try ( ObjectOutputStream o = new ObjectOutputStream ( b ) ) { o . writeObject ( obj ) ; } return b . toByteArray ( ) ; } }
haikuowuya/android_system_code | public static boolean isWhitespace ( char ch ) { return ch == SP || ch == HT || ch == CR || ch == LF ; }
dydeve/web | public static InternMapStorage of ( boolean threadSafe , InternStorage . ValueConstructor valueConstructor ) { if ( threadSafe ) { return new InternMapStorage ( new ConcurrentHashMap < > ( ) , valueConstructor ) ; } return new InternMapStorage ( new HashMap < > ( ) , valueConstructor ) ; }
bbottema/java-reflection | private static Collection < ValueFunction < File , ? > > produceFileConverters ( ) { ArrayList < ValueFunction < File , ? > > converters = new ArrayList < > ( ) ; converters . add ( new ValueFunctionImpl < > ( File . class , File . class , Functions . < File > identity ( ) ) ) ; converters . add ( new ValueFunctionImpl < > ( File . class , DataSource . class , new FileToDataSourceFunction ( ) ) ) ; converters . add ( new ValueFunctionImpl < > ( File . class , byte [ ] . class , new FileToByteArrayFunction ( ) ) ) ; converters . add ( new ValueFunctionImpl < > ( File . class , InputStream . class , new FileToInputStreamFunction ( ) ) ) ; return converters ; }
pphdsny/ArithmeticTest | public static void main ( String [ ] args ) { _1052_maxSatisfied maxSatisfied = new _1052_maxSatisfied ( ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 1 , 0 , 1 , 2 , 1 , 1 , 7 , 5 } , new int [ ] { 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 } , 3 ) ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 1 } , new int [ ] { 0 } , 1 ) ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 4 , 10 , 10 } , new int [ ] { 1 , 1 , 0 } , 2 ) ) ; }
FDevman/VIDEVOX-Beta | public static boolean preview ( String text ) throws VidevoxException { String cmd = " echo ▁ \" " + text + " \" ▁ | ▁ festival ▁ - - tts " ; logger . debug ( " command ▁ is : ▁ " + cmd ) ; ProcessBuilder builder = new ProcessBuilder ( " / bin / bash " , " - c " , cmd ) ; try { builder . start ( ) . waitFor ( ) ; } catch ( IOException | InterruptedException e ) { throw new VidevoxException ( " Text ▁ to ▁ speech ▁ preview ▁ is ▁ not ▁ working ▁ at ▁ the ▁ moment " ) ; } return true ; }
FDevman/VIDEVOX-Beta | public static boolean textToMP3 ( File destination , String speech ) throws VidevoxException { File tempWAV = ModelHelper . enforceFileExtension ( destination , " . wav " ) ; logger . debug ( " File ▁ name ▁ is ▁ actually : ▁ " + tempWAV . getAbsolutePath ( ) ) ; destination = ModelHelper . enforceFileExtension ( destination , " . mp3" ) ; String cmd = " echo ▁ ' " + speech + " ' ▁ | ▁ text2wave ▁ " + " - o ▁ " + " \" " + tempWAV . getAbsolutePath ( ) + " \" " ; logger . debug ( " textToMP3 ▁ - ▁ cmd ▁ = ▁ " + cmd ) ; ProcessBuilder builder = new ProcessBuilder ( " / bin / bash " , " - c " , cmd ) ; try { Process process = builder . start ( ) ; int returnVal = process . waitFor ( ) ; if ( returnVal != 0 ) { throw new VidevoxException ( " Wav ▁ file ▁ unable ▁ to ▁ be ▁ created : ▁ Check ▁ that ▁ festival ▁ is ▁ installed ▁ correctly " ) ; } logger . trace ( " created ▁ wav ▁ at : ▁ " + tempWAV . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new VidevoxException ( " Unknown ▁ IO ▁ Exception ▁ during ▁ WAV ▁ creation " ) ; } catch ( InterruptedException e ) { throw new VidevoxException ( " Festival ▁ thread ▁ interrupted : ▁ Unknown ▁ source " ) ; } cmd = " ffmpeg ▁ - i ▁ " + " \" " + tempWAV . getAbsolutePath ( ) + " \" " + " ▁ - y ▁ - f ▁ mp3 ▁ " + " \" " + destination . getAbsolutePath ( ) + " \" " ; logger . debug ( " cmd ▁ = ▁ " + cmd ) ; builder = new ProcessBuilder ( " / bin / bash " , " - c " , cmd ) ; try { Process process = builder . start ( ) ; int returnVal = process . waitFor ( ) ; if ( returnVal != 0 ) { throw new VidevoxException ( " Unable ▁ to ▁ convert ▁ to ▁ mp3 : ▁ Check ▁ that ▁ festival ▁ is ▁ installed ▁ correctly " ) ; } logger . debug ( " Created ▁ mp3 ▁ at : ▁ " + destination . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new VidevoxException ( " Unknown ▁ IO ▁ Exception ▁ during ▁ mp3 ▁ conversion " ) ; } catch ( InterruptedException e ) { throw new VidevoxException ( " Festival ▁ thread ▁ interrupted : ▁ Unknown ▁ source " ) ; } logger . trace ( " Done ▁ with ▁ textToMP3" ) ; return true ; }
kkhatua/drill | public static Map < Scan , FieldList > getFieldLists ( LogicalPlan plan ) { Collection < SinkOperator > ops = plan . getGraph ( ) . getRoots ( ) ; Preconditions . checkArgument ( ops . size ( ) == 1 , " Scan ▁ Field ▁ determiner ▁ currently ▁ only ▁ works ▁ with ▁ plans ▁ that ▁ have ▁ a ▁ single ▁ root . " ) ; ScanFieldDeterminer sfd = new ScanFieldDeterminer ( ) ; ops . iterator ( ) . next ( ) . accept ( sfd , new FieldList ( ) ) ; return sfd . scanFields ; }
vpipkt/geomesa | public static void configureDataStore ( Job job , Map < String , String > dataStoreParams ) { Object m = JavaConverters . mapAsScalaMapConverter ( dataStoreParams ) . asScala ( ) ; scala . collection . immutable . Map < String , String > scalaParams = ( ( scala . collection . mutable . Map < String , String > ) m ) . toMap ( Predef . < Tuple2 < String , String > > conforms ( ) ) ; GeoMesaOutputFormat$ . MODULE$ . configureDataStore ( job , scalaParams ) ; }
vpipkt/geomesa | public static void configureBatchWriter ( Job job , BatchWriterConfig writerConfig ) { GeoMesaOutputFormat$ . MODULE$ . configureBatchWriter ( job , writerConfig ) ; }
Flibio/Ultimate-Spleef | public static Optional < UArena > createArena ( String arenaName , ArenaData data ) { if ( isDataPresent ( data ) ) { return Optional . of ( new UArena ( arenaName , data ) ) ; } else { return Optional . empty ( ) ; } }
Flibio/Ultimate-Spleef | public static boolean isDataPresent ( ArenaData data ) { if ( data . getLocation ( " lobby " ) . isPresent ( ) && data . getLocation ( " circlecenter " ) . isPresent ( ) && data . getLocation ( " circleedge " ) . isPresent ( ) && data . getVariable ( " dedicated " , Boolean . class ) . isPresent ( ) ) { return ! data . getVariable ( " dedicated " , Boolean . class ) . get ( ) ? data . getLocation ( " joinsign " ) . isPresent ( ) : true ; } else { return false ; } }
yuweijun/learning-programming | public static void main ( String [ ] args ) throws IOException { OkHttpTimeoutExample okHttpTimeoutExample = new OkHttpTimeoutExample ( ) ; okHttpTimeoutExample . run ( ) ; }
cnishina/jmeter-client | public static JMeterElement getType ( TYPE findType , List < JMeterElement > inList ) { for ( JMeterElement je : inList ) { if ( je . type == findType ) return je ; } return null ; }
cnishina/jmeter-client | public static List < JMeterElement > getListType ( TYPE findType , List < JMeterElement > inList ) { List < JMeterElement > jmeterEls = new ArrayList < JMeterElement > ( ) ; for ( JMeterElement je : inList ) { if ( je . type == findType ) jmeterEls . add ( je ) ; } return jmeterEls ; }
byrao123/clickfortech | public static MapProviderFactory getInstance ( ) { if ( mapFactory == null ) { mapFactory = new MapProviderFactory ( ) ; } return mapFactory ; }
byrao123/clickfortech | public static MapProvider getMapProviderForName ( String providerClassName ) { return getInstance ( ) . getMapProvider ( providerClassName ) ; }
danielkec/Ansible | @ org . junit . BeforeClass public static void setUp ( ) throws Exception { System . out . println ( " = = = ▁ Setting ▁ up ▁ inmemory ▁ db ▁ for ▁ Ansible ▁ DAO ▁ Test ▁ = = = " ) ; CREATE_TMP_DB_SQL = new Scanner ( new FileInputStream ( SQL_FOLDER_PATH + " recreateDb . sql " ) ) . useDelimiter ( " \\ A " ) . next ( ) ; JdbcDataSource ds = new JdbcDataSource ( ) ; ds . setURL ( JDBC_URL ) ; ds . setUser ( " sa " ) ; ds . setPassword ( " sa " ) ; Connection conn = ds . getConnection ( ) ; conn = ds . getConnection ( ) ; conn . createStatement ( ) . execute ( CREATE_TMP_DB_SQL ) ; conn . commit ( ) ; conn . close ( ) ; }
danielkec/Ansible | @ AfterClass public static void tearDown ( ) throws SQLException { System . out . println ( " = = = = ▁ Cleaning ▁ inmemory ▁ db ▁ = = = = " ) ; RunScript . execute ( JDBC_URL , " sa " , " sa " , " classpath : cz / kec / of / ansible / dao / clearDb . sql " , Charset . forName ( " UTF - 8" ) , false ) ; }
mkeijzer/push-forth | public static Instruction getInstruction ( String name ) { return instructionMap . get ( name ) ; }
mkeijzer/push-forth | public static Instruction [ ] getAllInstructions ( ) { Collection < Instruction > ins = instructionMap . values ( ) ; return ins . toArray ( new Instruction [ ins . size ( ) ] ) ; }
mkeijzer/push-forth | public static List < Instruction > getAllInstructionsButOne ( String toExclude ) { List < Instruction > ins = new ArrayList < Instruction > ( ) ; for ( Map . Entry < String , Instruction > entry : instructionMap . entrySet ( ) ) { if ( ! entry . getKey ( ) . equals ( toExclude ) ) { ins . add ( entry . getValue ( ) ) ; } } return ins ; }
mkeijzer/push-forth | public static void put ( String name , Instruction result ) { instructionMap . put ( name , result ) ; }
mkeijzer/push-forth | public static Instruction get ( String name ) { return instructionMap . get ( name ) ; }
mkeijzer/push-forth | public static Instruction safeget ( String name ) { Instruction res = instructionMap . get ( name ) ; if ( res == null ) { throw new RuntimeException ( " Instruction ▁ with ▁ name ▁ " + name + " ▁ not ▁ found " ) ; } return res ; }
mkeijzer/push-forth | public static void remove ( String name ) { instructionMap . remove ( name ) ; }
mkeijzer/push-forth | public static Instruction randomInstruction ( Random random ) { int choice = random . nextInt ( instructionMap . size ( ) ) ; for ( Instruction ins : instructionMap . values ( ) ) { if ( choice -- == 0 ) { return ins ; } } throw new RuntimeException ( " Dictionary : ▁ should ▁ not ▁ happen " ) ; }
andrewgaul/aws-sdk-java | public static ConfigurationOptionDescriptionStaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new ConfigurationOptionDescriptionStaxUnmarshaller ( ) ; return instance ; }
perezd/bazel | public static LinkOptions of ( ImmutableList < String > linkOptions , SymbolGenerator < ? > symbolGenerator ) { return new LinkOptions ( linkOptions , symbolGenerator . generate ( ) ) ; }
perezd/bazel | public static Builder builder ( ) { return new Builder ( ) ; }
perezd/bazel | public static CcLinkingContext merge ( List < CcLinkingContext > ccLinkingContexts ) { Builder mergedCcLinkingContext = CcLinkingContext . builder ( ) ; ExtraLinkTimeLibraries . Builder mergedExtraLinkTimeLibraries = ExtraLinkTimeLibraries . builder ( ) ; for ( CcLinkingContext ccLinkingContext : ccLinkingContexts ) { mergedCcLinkingContext . addTransitiveLinkerInputs ( ccLinkingContext . getLinkerInputs ( ) ) ; if ( ccLinkingContext . getExtraLinkTimeLibraries ( ) != null ) { mergedExtraLinkTimeLibraries . addTransitive ( ccLinkingContext . getExtraLinkTimeLibraries ( ) ) ; } } mergedCcLinkingContext . setExtraLinkTimeLibraries ( mergedExtraLinkTimeLibraries . build ( ) ) ; return mergedCcLinkingContext . build ( ) ; }
perezd/bazel | public static Builder builder ( ) { return new Builder ( ) ; }
sekys/ivis | public static void main ( String [ ] args ) { Dimension size = new Dimension ( 200 , 100 ) ; DrawingJPanel panel = new DrawingJPanel ( size ) ; panel . fill ( Color . WHITE . getRGB ( ) ) ; panel . repaint ( ) ; JFrame frame = new JFrame ( " " ) ; frame . add ( panel ) ; frame . setUndecorated ( true ) ; frame . setVisible ( true ) ; frame . setResizable ( false ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . pack ( ) ; }
dyu/protostuff-1.0.x | public static Bear filledBear ( ) { Bear bear = new Bear ( ) ; bear . someBearField = " bearField " ; bear . normalBodyTemperature = 20f ; bear . properName = " bear " ; return bear ; }
dyu/protostuff-1.0.x | public static Tiger filledTiger ( ) { Tiger tiger = new Tiger ( ) ; tiger . someTigerField = " tigerField " ; tiger . normalBodyTemperature = 30f ; tiger . properName = " tiger " ; return tiger ; }
dyu/protostuff-1.0.x | public static Elephant filledElephant ( ) { Elephant elephant = new Elephant ( ) ; elephant . someElephantField = " elephantField " ; elephant . normalBodyTemperature = 25f ; elephant . properName = " elephant " ; return elephant ; }
dyu/protostuff-1.0.x | public static Zoo filledZoo ( ) { Zoo zoo = new Zoo ( ) ; Elephant elephant = filledElephant ( ) ; Bear bear = filledBear ( ) ; Tiger tiger = filledTiger ( ) ; zoo . largestAnimal = elephant ; zoo . animals . add ( bear ) ; zoo . animals . add ( tiger ) ; zoo . animals . add ( elephant ) ; return zoo ; }
rohit5ram/carjoin | public static TripShareDAO getInstance ( final Context context ) { if ( singleton == null ) { singleton = new TripShareDAO ( context . getApplicationContext ( ) ) ; } return singleton ; }
hastef88/carbon-business-messaging | public static String getHtmlString ( String message ) { return message . replaceAll ( " < " , " & lt ; " ) . replaceAll ( " > " , " & gt ; " ) ; }
hastef88/carbon-business-messaging | public static AndesAdminServiceStub getAndesAdminServiceStub ( ServletConfig config , HttpSession session , HttpServletRequest request ) throws AxisFault { String backendServerURL = CarbonUIUtil . getServerURL ( config . getServletContext ( ) , session ) ; backendServerURL = backendServerURL + ANDES_ADMIN_SERVICE_NAME ; ConfigurationContext configContext = ( ConfigurationContext ) config . getServletContext ( ) . getAttribute ( CarbonConstants . CONFIGURATION_CONTEXT ) ; AndesAdminServiceStub stub = new AndesAdminServiceStub ( configContext , backendServerURL ) ; String cookie = ( String ) session . getAttribute ( ServerConstants . ADMIN_SERVICE_COOKIE ) ; if ( cookie != null ) { Options option = stub . _getServiceClient ( ) . getOptions ( ) ; option . setManageSession ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTPConstants . COOKIE_STRING , cookie ) ; } return stub ; }
hastef88/carbon-business-messaging | public static AndesManagerServiceStub getAndesManagerServiceStub ( ServletConfig config , HttpSession session ) throws AxisFault { String backendServerURL = CarbonUIUtil . getServerURL ( config . getServletContext ( ) , session ) ; String serviceURL = backendServerURL + ANDES_MANAGER_SERVICE_NAME ; ConfigurationContext configContext = ( ConfigurationContext ) config . getServletContext ( ) . getAttribute ( CarbonConstants . CONFIGURATION_CONTEXT ) ; AndesManagerServiceStub stub = new AndesManagerServiceStub ( configContext , serviceURL ) ; String cookie = ( String ) session . getAttribute ( ServerConstants . ADMIN_SERVICE_COOKIE ) ; if ( cookie != null ) { Options option = stub . _getServiceClient ( ) . getOptions ( ) ; option . setManageSession ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTPConstants . COOKIE_STRING , cookie ) ; } return stub ; }
hastef88/carbon-business-messaging | public static AndesEventAdminServiceStub getAndesEventAdminServiceStub ( ServletConfig config , HttpSession session , HttpServletRequest request ) throws AxisFault { String backendServerURL = CarbonUIUtil . getServerURL ( config . getServletContext ( ) , session ) ; backendServerURL = backendServerURL + ANDES_ADMIN_EVENT_SERVICE_NAME ; ConfigurationContext configContext = ( ConfigurationContext ) config . getServletContext ( ) . getAttribute ( CarbonConstants . CONFIGURATION_CONTEXT ) ; AndesEventAdminServiceStub stub = new AndesEventAdminServiceStub ( configContext , backendServerURL ) ; String cookie = ( String ) session . getAttribute ( ServerConstants . ADMIN_SERVICE_COOKIE ) ; if ( cookie != null ) { Options option = stub . _getServiceClient ( ) . getOptions ( ) ; option . setManageSession ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTPConstants . COOKIE_STRING , cookie ) ; } return stub ; }
hastef88/carbon-business-messaging | public static Queue [ ] getFilteredQueueList ( Queue [ ] fullList , int startingIndex , int maxQueueCount ) { Queue [ ] queueDetailsArray ; int resultSetSize = maxQueueCount ; ArrayList < Queue > resultList = new ArrayList < Queue > ( ) ; Collections . addAll ( resultList , fullList ) ; if ( ( resultList . size ( ) - startingIndex ) < maxQueueCount ) { resultSetSize = ( resultList . size ( ) - startingIndex ) ; } queueDetailsArray = new Queue [ resultSetSize ] ; int index = 0 ; int queueDetailsIndex = 0 ; for ( Queue queueDetail : resultList ) { if ( startingIndex == index || startingIndex < index ) { queueDetailsArray [ queueDetailsIndex ] = new Queue ( ) ; queueDetailsArray [ queueDetailsIndex ] . setQueueName ( queueDetail . getQueueName ( ) ) ; queueDetailsArray [ queueDetailsIndex ] . setMessageCount ( queueDetail . getMessageCount ( ) ) ; queueDetailsIndex ++ ; if ( queueDetailsIndex == maxQueueCount ) { break ; } } index ++ ; } return queueDetailsArray ; }
hastef88/carbon-business-messaging | public static Subscription [ ] getFilteredSubscriptionList ( Subscription [ ] fullList , int startingIndex , int maxSubscriptionCount ) { Subscription [ ] subscriptionDetailsArray ; int resultSetSize = maxSubscriptionCount ; ArrayList < Subscription > resultList = new ArrayList < Subscription > ( ) ; Collections . addAll ( resultList , fullList ) ; if ( ( resultList . size ( ) - startingIndex ) < maxSubscriptionCount ) { resultSetSize = ( resultList . size ( ) - startingIndex ) ; } subscriptionDetailsArray = new Subscription [ resultSetSize ] ; int index = 0 ; int subscriptionDetailsIndex = 0 ; for ( Subscription subscriptionDetail : resultList ) { if ( startingIndex == index || startingIndex < index ) { Subscription subscription = new Subscription ( ) ; subscription . setSubscriptionIdentifier ( subscriptionDetail . getSubscriptionIdentifier ( ) ) ; subscription . setSubscribedQueueOrTopicName ( subscriptionDetail . getSubscribedQueueOrTopicName ( ) ) ; subscription . setSubscriberQueueBoundExchange ( subscriptionDetail . getSubscriberQueueBoundExchange ( ) ) ; subscription . setSubscriberQueueName ( subscriptionDetail . getSubscriberQueueName ( ) ) ; subscription . setSubscriptionIdentifier ( subscriptionDetail . getSubscriptionIdentifier ( ) ) ; subscription . setDurable ( subscriptionDetail . getDurable ( ) ) ; subscription . setActive ( subscriptionDetail . getActive ( ) ) ; subscription . setNumberOfMessagesRemainingForSubscriber ( subscriptionDetail . getNumberOfMessagesRemainingForSubscriber ( ) ) ; subscription . setConnectedNodeAddress ( subscriptionDetail . getConnectedNodeAddress ( ) ) ; subscription . setDestination ( subscriptionDetail . getDestination ( ) ) ; subscription . setProtocolType ( subscriptionDetail . getProtocolType ( ) ) ; subscription . setDestinationType ( subscriptionDetail . getDestinationType ( ) ) ; subscription . setOriginHostAddress ( subscriptionDetail . getOriginHostAddress ( ) ) ; subscriptionDetailsArray [ subscriptionDetailsIndex ] = subscription ; subscriptionDetailsIndex ++ ; if ( subscriptionDetailsIndex == maxSubscriptionCount ) { break ; } } index ++ ; } return subscriptionDetailsArray ; }
hastef88/carbon-business-messaging | public static ArrayList < QueueRolePermission > getFilteredRoleList ( ArrayList < QueueRolePermission > allPermissions , int startingIndex , int maxRolesCount ) { int numberOfPermissionsToShow = maxRolesCount ; if ( ( allPermissions . size ( ) - startingIndex ) < maxRolesCount ) { numberOfPermissionsToShow = ( allPermissions . size ( ) - startingIndex ) ; } ArrayList < QueueRolePermission > permissionList = new ArrayList < QueueRolePermission > ( ) ; for ( int i = startingIndex ; i < startingIndex + numberOfPermissionsToShow ; i ++ ) { permissionList . add ( allPermissions . get ( i ) ) ; } return permissionList ; }
Edwin-Ran/es_source_read | static SearchContext createSearchContext ( String indexName , String parentType , String childType ) throws IOException { IndexService indexService = createIndex ( indexName ) ; MapperService mapperService = indexService . mapperService ( ) ; mapperService . merge ( childType , new CompressedString ( PutMappingRequest . buildFromSimplifiedDef ( childType , " _ parent " , " type = " + parentType ) . string ( ) ) , true ) ; return createSearchContext ( indexService ) ; }
Edwin-Ran/es_source_read | static void assertBitSet ( FixedBitSet actual , FixedBitSet expected , IndexSearcher searcher ) throws IOException { if ( ! actual . equals ( expected ) ) { Description description = new StringDescription ( ) ; description . appendText ( reason ( actual , expected , searcher ) ) ; description . appendText ( " \n Expected : ▁ " ) ; description . appendValue ( expected ) ; description . appendText ( " \n ▁ ▁ ▁ ▁ ▁ got : ▁ " ) ; description . appendValue ( actual ) ; description . appendText ( " \n " ) ; throw new java . lang . AssertionError ( description . toString ( ) ) ; } }
Edwin-Ran/es_source_read | static String reason ( FixedBitSet actual , FixedBitSet expected , IndexSearcher indexSearcher ) throws IOException { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " expected ▁ cardinality : " ) . append ( expected . cardinality ( ) ) . append ( ' \n ' ) ; DocIdSetIterator iterator = expected . iterator ( ) ; for ( int doc = iterator . nextDoc ( ) ; doc != DocIdSetIterator . NO_MORE_DOCS ; doc = iterator . nextDoc ( ) ) { builder . append ( " Expected ▁ doc [ " ) . append ( doc ) . append ( " ] ▁ with ▁ id ▁ value ▁ " ) . append ( indexSearcher . doc ( doc ) . get ( UidFieldMapper . NAME ) ) . append ( ' \n ' ) ; } builder . append ( " actual ▁ cardinality : ▁ " ) . append ( actual . cardinality ( ) ) . append ( ' \n ' ) ; iterator = actual . iterator ( ) ; for ( int doc = iterator . nextDoc ( ) ; doc != DocIdSetIterator . NO_MORE_DOCS ; doc = iterator . nextDoc ( ) ) { builder . append ( " Actual ▁ doc [ " ) . append ( doc ) . append ( " ] ▁ with ▁ id ▁ value ▁ " ) . append ( indexSearcher . doc ( doc ) . get ( UidFieldMapper . NAME ) ) . append ( ' \n ' ) ; } return builder . toString ( ) ; }
Edwin-Ran/es_source_read | static void assertTopDocs ( TopDocs actual , TopDocs expected ) { assertThat ( " actual . totalHits ▁ ! = ▁ expected . totalHits " , actual . totalHits , equalTo ( expected . totalHits ) ) ; assertThat ( " actual . getMaxScore ( ) ▁ ! = ▁ expected . getMaxScore ( ) " , actual . getMaxScore ( ) , equalTo ( expected . getMaxScore ( ) ) ) ; assertThat ( " actual . scoreDocs . length ▁ ! = ▁ expected . scoreDocs . length " , actual . scoreDocs . length , equalTo ( actual . scoreDocs . length ) ) ; for ( int i = 0 ; i < actual . scoreDocs . length ; i ++ ) { ScoreDoc actualHit = actual . scoreDocs [ i ] ; ScoreDoc expectedHit = expected . scoreDocs [ i ] ; assertThat ( " actualHit . doc ▁ ! = ▁ expectedHit . doc " , actualHit . doc , equalTo ( expectedHit . doc ) ) ; assertThat ( " actualHit . score ▁ ! = ▁ expectedHit . score " , actualHit . score , equalTo ( expectedHit . score ) ) ; } }
Edwin-Ran/es_source_read | static Filter wrap ( Filter filter ) { return SearchContext . current ( ) . filterCache ( ) . cache ( filter ) ; }
Edwin-Ran/es_source_read | static FixedBitSetFilter wrapWithFixedBitSetFilter ( Filter filter ) { return SearchContext . current ( ) . fixedBitSetFilterCache ( ) . getFixedBitSetFilter ( filter ) ; }
dcapwell/jmh-tests | public static int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | public final static int finalAdd ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | public static int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | public final static int finalAdd ( int i , int j ) { return i + j ; }
hernad/oo-netbeans | public static void start ( final ComponentTypePropertyEditor editor , final PolyStruct plStruct ) { NewTemplateTypesDialog templTypes = new NewTemplateTypesDialog ( editor , plStruct ) ; DialogDescriptor ddscr = new DialogDescriptor ( templTypes , NbBundle . getMessage ( ComponentWizardIterator . class , " LBL _ TemplateTypes _ Title " ) ) ; ddscr . setButtonListener ( templTypes ) ; Dialog d = DialogDisplayer . getDefault ( ) . createDialog ( ddscr ) ; d . setVisible ( true ) ; }
Lekanich/intellij-community | public static void executeOnPooledThread ( Runnable runnable ) { myAsyncTasks . add ( ApplicationManager . getApplication ( ) . executeOnPooledThread ( runnable ) ) ; }
Lekanich/intellij-community | private static void edt ( @ NotNull final ThrowableRunnable < Exception > runnable ) throws Exception { final AtomicReference < Exception > exception = new AtomicReference < Exception > ( ) ; UIUtil . invokeAndWaitIfNeeded ( new Runnable ( ) { @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Exception throwable ) { exception . set ( throwable ) ; } } } ) ; if ( exception . get ( ) != null ) { throw exception . get ( ) ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String substituteConfigParameters ( String applicationId , String string ) { StrSubstitutor sub = new StrSubstitutor ( new ConfigStringLookup ( applicationId ) ) ; return sub . replace ( string ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String substituteConfigParameters ( String string ) { return SUBSTITUTOR . replace ( string ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String parseGroupNamespaceCode ( String namespaceAndNameCombo ) { if ( namespaceAndNameCombo == null ) { return null ; } String [ ] groupData = namespaceAndNameCombo . split ( KewApiConstants . KIM_GROUP_NAMESPACE_NAME_DELIMITER_CHARACTER ) ; if ( groupData . length == 1 ) { return KimConstants . KIM_GROUP_WORKFLOW_NAMESPACE_CODE ; } else if ( groupData . length == 2 ) { return groupData [ 0 ] . trim ( ) ; } else { return null ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String parseGroupName ( String namespaceAndNameCombo ) { if ( namespaceAndNameCombo == null ) { return null ; } String [ ] groupData = namespaceAndNameCombo . split ( KewApiConstants . KIM_GROUP_NAMESPACE_NAME_DELIMITER_CHARACTER ) ; if ( groupData . length == 1 ) { return groupData [ 0 ] . trim ( ) ; } else if ( groupData . length == 2 ) { return groupData [ 1 ] . trim ( ) ; } else { return null ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static boolean checkDateRanges ( String fromDate , String toDate ) { try { Date parsedDate = CoreApiServiceLocator . getDateTimeService ( ) . convertToDate ( fromDate . trim ( ) ) ; Calendar fromCalendar = Calendar . getInstance ( ) ; fromCalendar . setLenient ( false ) ; fromCalendar . setTime ( parsedDate ) ; fromCalendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; fromCalendar . set ( Calendar . MINUTE , 0 ) ; fromCalendar . set ( Calendar . SECOND , 0 ) ; fromCalendar . set ( Calendar . MILLISECOND , 0 ) ; parsedDate = CoreApiServiceLocator . getDateTimeService ( ) . convertToDate ( toDate . trim ( ) ) ; Calendar toCalendar = Calendar . getInstance ( ) ; toCalendar . setLenient ( false ) ; toCalendar . setTime ( parsedDate ) ; toCalendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; toCalendar . set ( Calendar . MINUTE , 0 ) ; toCalendar . set ( Calendar . SECOND , 0 ) ; toCalendar . set ( Calendar . MILLISECOND , 0 ) ; if ( fromCalendar . after ( toCalendar ) ) { return false ; } return true ; } catch ( Exception ex ) { return false ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static < T extends KeyValue > Map < String , String > getKeyValueCollectionAsMap ( List < T > collection ) { Map < String , String > map = new HashMap < String , String > ( collection . size ( ) ) ; for ( KeyValue kv : collection ) { map . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } return map ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static < T extends KeyValue > Map < String , T > getKeyValueCollectionAsLookupTable ( List < T > collection ) { Map < String , T > map = new HashMap < String , T > ( collection . size ( ) ) ; for ( T kv : collection ) { map . put ( kv . getKey ( ) , kv ) ; } return map ; }
erichwang/presto | public static void main ( String [ ] args ) throws RunnerException { Options options = new OptionsBuilder ( ) . verbosity ( VerboseMode . NORMAL ) . include ( " . * " + BenchmarkPagesSort . class . getSimpleName ( ) + " . * " ) . build ( ) ; new Runner ( options ) . run ( ) ; }
Fokko/druid | static void configureSsl ( Binder binder ) { final SSLContext context ; try { context = SSLContext . getDefault ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } binder . bind ( SSLContext . class ) . toProvider ( Providers . of ( context ) ) . in ( LazySingleton . class ) ; }
Fokko/druid | static AsyncHttpClient createAsyncHttpClient ( String nameFormat , String timerThreadNameFormat , @ Nullable SSLContext sslContext ) { final DefaultAsyncHttpClientConfig . Builder builder = new DefaultAsyncHttpClientConfig . Builder ( ) . setThreadFactory ( Execs . makeThreadFactory ( nameFormat ) ) . setNettyTimer ( new HashedWheelTimer ( Execs . makeThreadFactory ( timerThreadNameFormat ) ) ) ; if ( sslContext != null ) { builder . setSslContext ( new JdkSslContext ( sslContext , true , ClientAuth . NONE ) ) ; } return new DefaultAsyncHttpClient ( builder . build ( ) ) ; }
Fokko/druid | public static SSLContext getEffectiveSSLContext ( HttpEmitterSSLClientConfig sslConfig , SSLContext sslContext ) { SSLContext effectiveSSLContext ; if ( sslConfig . isUseDefaultJavaContext ( ) ) { try { effectiveSSLContext = SSLContext . getDefault ( ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new RuntimeException ( nsae ) ; } } else if ( sslConfig . getTrustStorePath ( ) != null ) { log . info ( " Creating ▁ SSLContext ▁ for ▁ HttpEmitter ▁ client ▁ using ▁ config ▁ [ % s ] " , sslConfig ) ; effectiveSSLContext = new TLSUtils . ClientSSLContextBuilder ( ) . setProtocol ( sslConfig . getProtocol ( ) ) . setTrustStoreType ( sslConfig . getTrustStoreType ( ) ) . setTrustStorePath ( sslConfig . getTrustStorePath ( ) ) . setTrustStoreAlgorithm ( sslConfig . getTrustStoreAlgorithm ( ) ) . setTrustStorePasswordProvider ( sslConfig . getTrustStorePasswordProvider ( ) ) . build ( ) ; } else { effectiveSSLContext = sslContext ; } return effectiveSSLContext ; }
hotchemi/wearzaim | public static Intent createIntent ( Context context , boolean login ) { Intent intent = new Intent ( context , SendLoginStatusService . class ) ; intent . putExtra ( KEY_LOGIN , String . valueOf ( login ) ) ; return intent ; }
coderkiss/ImageLoader | public static ImageLoader getInstance ( ) { synchronized ( ImageLoader . class ) { if ( instance == null ) { instance = new ImageLoader ( ) ; } } return instance ; }
shalk/TIJ4Code | public static void main ( String [ ] args ) { }
euler-form/web-form | public static int getI18nRefreshFreq ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_CACHE_I18N_REFRESH_FREQ , key -> { return properties . getIntValue ( WebConfigKey . CORE_CACHE_I18N_REFRESH_FREQ , WebConfigDefault . CORE_CACHE_I18N_REFRESH_FREQ ) ; } ) ; return ( int ) cachedConfig ; }
euler-form/web-form | public static String getWebUrl ( ) { try { String result = properties . get ( WebConfigKey . WEB_URL ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( WebConfigKey . WEB_URL + " can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " / " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } return result ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( e ) ; } }
euler-form/web-form | public static boolean isApiEnabled ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_API_ENABLED , key -> { return properties . getBooleanValue ( key , WebConfigDefault . WEB_API_ENABLED ) ; } ) ; return ( boolean ) cachedConfig ; }
euler-form/web-form | public static String getApiRootPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_API_ROOT_PATH , key -> { String result = properties . get ( key , WebConfigDefault . WEB_API_ROOT_PATH ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( key + " can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = CommonUtils . convertDirToUnixFormat ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminRootPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_ROOT_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result = properties . get ( WebConfigKey . WEB_ADMIN_ROOT_PATH , WebConfigDefault . WEB_ADMIN_ROOT_PATH ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( WebConfigKey . WEB_ADMIN_ROOT_PATH + " ▁ can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = CommonUtils . convertDirToUnixFormat ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getStaticPagesRootPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_STATIC_PAGES_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result = properties . get ( key , WebConfigDefault . WEB_STATIC_PAGES_PATH ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( key + " ▁ can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = CommonUtils . convertDirToUnixFormat ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getJspPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_JSP_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return CommonUtils . convertDirToUnixFormat ( properties . get ( WebConfigKey . WEB_JSP_PATH , WebConfigDefault . WEB_JSP_PATH ) , true ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminJspPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_JSP_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return CommonUtils . convertDirToUnixFormat ( properties . get ( WebConfigKey . WEB_ADMIN_JSP_PATH , WebConfigDefault . WEB_ADMIN_JSP_PATH ) , true ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getRuntimePath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_RUNTIME_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result ; try { result = properties . get ( WebConfigKey . CORE_RUNTIME_PATH ) ; } catch ( PropertyNotFoundException e ) { if ( isWindows ( ) ) { LOGGER . info ( " OS ▁ is ▁ windows " ) ; result = WebConfigDefault . CORE_RUNTIME_PATH_WIN ; } else { LOGGER . info ( " OS ▁ isn ' t ▁ windows " ) ; result = WebConfigDefault . CORE_RUNTIME_PATH_UNIX ; } LOGGER . warn ( " Couldn ' t ▁ load ▁ " + WebConfigKey . CORE_RUNTIME_PATH + " ▁ , ▁ use ▁ " + result + " ▁ for ▁ default . " ) ; } result = CommonUtils . convertDirToUnixFormat ( result , true ) ; if ( ! result . startsWith ( " / " ) && ! result . startsWith ( " file : // " ) ) { throw new RuntimeException ( WebConfigKey . CORE_RUNTIME_PATH + " ▁ must ▁ bengin ▁ with ▁ file : // ▁ or ▁ / " ) ; } else { if ( result . startsWith ( " file : // " ) ) { result = result . substring ( " file : // " . length ( ) ) ; } } if ( isWindows ( ) && result . startsWith ( " / " ) ) { result = " C : " + result ; } return CommonUtils . convertDirToUnixFormat ( result , false ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static long getRamCacheCleanFreq ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_CAHCE_RAMCACHE_POOL_CLEAN_FREQ , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . getLongValue ( WebConfigKey . CORE_CAHCE_RAMCACHE_POOL_CLEAN_FREQ , WebConfigDefault . CORE_CAHCE_RAMCACHE_POOL_CLEAN_FREQ ) ; } } ) ; return ( long ) cachedConfig ; }
euler-form/web-form | public static MultiPartConfig getMultiPartConfig ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_MULITPART , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String location = properties . get ( WebConfigKey . WEB_MULITPART_LOCATION , WebConfigDefault . WEB_MULITPART_LOCATION ) ; long maxFileSize = properties . getLongValue ( WebConfigKey . WEB_MULITPART_MAX_FILE_SIZE , WebConfigDefault . WEB_MULITPART_MAX_FILE_SIZE ) ; long maxRequestSize = properties . getLongValue ( WebConfigKey . WEB_MULITPART_MAX_REQUEST_SIZE , WebConfigDefault . WEB_MULITPART_MAX_REQUEST_SIZE ) ; int fileSizeThreshold = properties . getIntValue ( WebConfigKey . WEB_MULITPART_FILE_SIZE_THRESHOLD , WebConfigDefault . WEB_MULITPART_FILE_SIZE_THRESHOLD ) ; MultiPartConfig result = new MultiPartConfig ( location , maxFileSize , maxRequestSize , fileSizeThreshold ) ; return result ; } } ) ; return ( MultiPartConfig ) cachedConfig ; }
euler-form/web-form | public static ProjectMode getProjectMode ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_MODE , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . getEnumValue ( WebConfigKey . PROJECT_MODE , WebConfigDefault . PROJECT_MODE , true ) ; } } ) ; return ( ProjectMode ) cachedConfig ; }
euler-form/web-form | public static String getProjectVersion ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_VERSION , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { try { return properties . get ( WebConfigKey . PROJECT_VERSION ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( " Couldn ' t ▁ load ▁ " + WebConfigKey . PROJECT_VERSION ) ; } } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getProjectBuildtime ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_BUILDTIME , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { try { return properties . get ( WebConfigKey . PROJECT_BUILDTIME ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( " Couldn ' t ▁ load ▁ " + WebConfigKey . PROJECT_BUILDTIME ) ; } } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getCopyrightHolder ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_COPYRIGHT_HOLDER , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . PROJECT_COPYRIGHT_HOLDER , WebConfigDefault . PROJECT_COPYRIGHT_HOLDER ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getSitename ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_SITENAME , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_SITENAME , WebConfigDefault . WEB_SITENAME ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAssetsPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ASSETS_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_ASSETS_PATH , WebConfigDefault . WEB_ASSETS_PATH ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static boolean isDebugMode ( ) { return getProjectMode ( ) . equals ( ProjectMode . DEVELOP ) || getProjectMode ( ) . equals ( ProjectMode . DEBUG ) ; }
euler-form/web-form | public static String getDefaultTheme ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_DEFAULT_THEME , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_DEFAULT_THEME , WebConfigDefault . WEB_DEFAULT_THEME ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminDashboardBrandIcon ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_ICON , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_ICON , WebConfigDefault . WEB_ADMIN_DASHBOARD_BRAND_ICON ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminDashboardBrandText ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_TEXT , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_TEXT , WebConfigDefault . WEB_ADMIN_DASHBOARD_BRAND_TEXT ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getRootContextConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_ROOT_CONTEXT_CONFIG_CLASS , key -> { return properties . get ( key , WebConfigDefault . CORE_ROOT_CONTEXT_CONFIG_CLASS ) ; } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getWebConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_WEB_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_WEB_CONFIG_CLASS , WebConfigDefault . CORE_WEB_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAjaxConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_AJAX_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_AJAX_CONFIG_CLASS , WebConfigDefault . CORE_AJAX_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminWebConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_ADMIN_WEB_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_ADMIN_WEB_CONFIG_CLASS , WebConfigDefault . CORE_ADMIN_WEB_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminAjaxConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_ADMIN_AJAX_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_ADMIN_AJAX_CONFIG_CLASS , WebConfigDefault . CORE_ADMIN_AJAX_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getApiConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_API_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_API_CONFIG_CLASS , WebConfigDefault . CORE_API_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static Locale getDefaultLanguage ( ) { return ( Locale ) CONFIG_CAHCE . get ( WebConfigKey . WEB_DEFAULT_LANGUAGE , key -> { try { String defaultLanguagesStr = properties . get ( key ) ; Assert . hasText ( defaultLanguagesStr , WebConfigKey . WEB_DEFAULT_LANGUAGE + " ▁ can ▁ not ▁ be ▁ empty " ) ; return CommonUtils . parseLocale ( defaultLanguagesStr ) ; } catch ( PropertyNotFoundException e ) { return WebConfigDefault . WEB_DEFAULT_LANGUAGE ; } } ) ; }
euler-form/web-form | public static Locale [ ] getSupportLanguages ( ) { return ( Locale [ ] ) CONFIG_CAHCE . get ( WebConfigKey . WEB_SUPPORT_LANGUAGES , key -> { try { String supportLanguagesStr = properties . get ( key ) ; String [ ] supportLanguagesStrArray = supportLanguagesStr . split ( " , " ) ; Locale [ ] ret = new Locale [ supportLanguagesStrArray . length ] ; for ( int i = 0 ; i < supportLanguagesStrArray . length ; i ++ ) { ret [ i ] = CommonUtils . parseLocale ( supportLanguagesStrArray [ i ] ) ; ; } return ret ; } catch ( PropertyNotFoundException e ) { return WebConfigDefault . WEB_SUPPORT_LANGUAGES ; } } ) ; }
euler-form/web-form | public static String getConfigPath ( ) { return getRuntimePath ( ) + " / conf / config . properties " ; }
euler-form/web-form | public static boolean isWindows ( ) { return System . getProperty ( " os . name " ) . toLowerCase ( ) . indexOf ( " windows " ) > - 1 ; }
euler-form/web-form | public static String getSmtp ( ) { return ( String ) CONFIG_CAHCE . get ( WebConfigKey . MAIL_SMTP , key -> { try { return properties . get ( key ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( e ) ; } } ) ; }
euler-form/web-form | public static RedisType getRedisType ( ) { return ( RedisType ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_TYPE , key -> properties . getEnumValue ( key , WebConfigDefault . REDIS_TYPE , true ) ) ; }
euler-form/web-form | public static String getRedisHost ( ) { return ( String ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_HOST , key -> properties . get ( key , WebConfigDefault . REDIS_HOST ) ) ; }
euler-form/web-form | public static String getRedisPassword ( ) { return ( String ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_PASSWORD , key -> properties . get ( key , WebConfigDefault . REDIS_PASSWORD ) ) ; }
euler-form/web-form | public static int getRedisPort ( ) { return ( int ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_PORT , key -> properties . getIntValue ( key , WebConfigDefault . REDIS_PORT ) ) ; }
euler-form/web-form | public static String [ ] getRedisSentinels ( ) { String str = ( String ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_SENTINELS , key -> { try { return properties . get ( key ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( e ) ; } } ) ; Assert . hasText ( str , ( ) -> WebConfigKey . REDIS_SENTINELS + " can ▁ not ▁ be ▁ empty " ) ; return str . split ( " , " ) ; }
sajavadi/pinot | public static SegmentPruner getSegmentPruner ( String prunerClassName , Configuration segmentPrunerConfig ) { try { Class < ? extends SegmentPruner > cls = PRUNER_MAP . get ( prunerClassName . toLowerCase ( ) ) ; if ( cls != null ) { SegmentPruner segmentPruner = cls . newInstance ( ) ; segmentPruner . init ( segmentPrunerConfig ) ; return segmentPruner ; } } catch ( Exception ex ) { throw new RuntimeException ( " Not ▁ support ▁ SegmentPruner ▁ type ▁ with ▁ - ▁ " + prunerClassName , ex ) ; } throw new UnsupportedOperationException ( " No ▁ SegmentPruner ▁ type ▁ with ▁ - ▁ " + prunerClassName ) ; }
jgaupp/arx | private static int checkStyle ( int style ) { if ( ( style & SWT . BORDER ) != 0 ) style |= SWT . SHADOW_IN ; int mask = SWT . SHADOW_IN | SWT . SHADOW_OUT | SWT . SHADOW_NONE | SWT . LEFT_TO_RIGHT | SWT . RIGHT_TO_LEFT ; style = style & mask ; return style |= SWT . NO_FOCUS | SWT . DOUBLE_BUFFERED ; }
SDRC-India/collect | public static void setWebCredentialsFromPreferences ( Context context ) { final SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context ) ; String username = getUserName ( settings ) ; String password = getPassword ( settings ) ; if ( username == null || username . isEmpty ( ) ) return ; String host = Uri . parse ( getServer ( settings , context ) ) . getHost ( ) ; WebUtils . addCredentials ( username , password , host ) ; }
SDRC-India/collect | private static String getServer ( SharedPreferences settings , Context context ) { return settings . getString ( PreferenceKeys . KEY_SERVER_URL , context . getString ( R . string . default_server_url ) ) ; }
SDRC-India/collect | private static String getPassword ( SharedPreferences settings ) { return settings . getString ( PreferenceKeys . KEY_PASSWORD , null ) ; }
SDRC-India/collect | private static String getUserName ( SharedPreferences settings ) { return settings . getString ( PreferenceKeys . KEY_USERNAME , null ) ; }
lj3lj3/XBridge | public static XBridgeFragment getFragment ( Bundle bundle ) { XBridgeFragment fragment = new XBridgeFragment ( ) ; fragment . setArguments ( bundle ) ; return fragment ; }
baiyubin/javatemplates | public static void main ( String [ ] args ) { IterativeTwo i2 = new IterativeTwo ( ) ; System . out . println ( i2 . solutionSteps ( 3 ) ) ; }
google/fest | public static void pause ( @ Nonnull Condition condition ) { pause ( condition , DEFAULT_DELAY ) ; }
google/fest | public static void pause ( @ Nonnull Condition condition , @ Nonnull Timeout timeout ) { checkNotNull ( timeout ) ; pause ( condition , timeout . duration ( ) ) ; }
google/fest | public static void pause ( @ Nonnull Condition condition , long timeout ) { checkNotNull ( condition ) ; TimeoutWatch watch = startWatchWithTimeoutOf ( timeout ) ; while ( ! condition . test ( ) ) { if ( watch . isTimeOut ( ) && ! condition . test ( ) ) { condition . done ( ) ; throw new WaitTimedOutError ( String . format ( " Timed ▁ out ▁ waiting ▁ for ▁ % s " , condition . toString ( ) ) ) ; } pause ( SLEEP_INTERVAL ) ; } condition . done ( ) ; }
google/fest | public static void pause ( @ Nonnull Condition [ ] conditions ) { pause ( conditions , DEFAULT_DELAY ) ; }
google/fest | public static void pause ( @ Nonnull Condition [ ] conditions , @ Nonnull Timeout timeout ) { pause ( conditions , timeout . duration ( ) ) ; }
google/fest | public static void pause ( @ Nonnull Condition [ ] conditions , long timeout ) { checkNotNullOrEmpty ( conditions ) ; TimeoutWatch watch = startWatchWithTimeoutOf ( timeout ) ; while ( ! areSatisfied ( conditions ) ) { if ( watch . isTimeOut ( ) ) { for ( Condition condition : conditions ) { condition . done ( ) ; } throw new WaitTimedOutError ( String . format ( " Timed ▁ out ▁ waiting ▁ for ▁ % s " , format ( conditions ) ) ) ; } pause ( SLEEP_INTERVAL ) ; } for ( Condition condition : conditions ) { condition . done ( ) ; } }
google/fest | private static boolean areSatisfied ( @ Nonnull Condition [ ] conditions ) { for ( Condition condition : conditions ) { checkNotNull ( condition ) ; if ( ! condition . test ( ) ) { return false ; } } return true ; }
google/fest | public static void pause ( long timeout , @ Nonnull TimeUnit unit ) { checkNotNull ( unit ) ; pause ( unit . toMillis ( timeout ) ) ; }
google/fest | public static void pause ( long ms ) { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } }
google/fest | public static void pause ( ) { pause ( SLEEP_INTERVAL ) ; }
apache/activemq-openwire | static private void add ( DataStreamMarshaller dsm ) { marshaller [ dsm . getDataStructureType ( ) ] = dsm ; }
apache/activemq-openwire | static public DataStreamMarshaller [ ] createMarshallerMap ( OpenWireFormat wireFormat ) { return marshaller ; }
cfieber/orca | private static Map < String , Object > findBuildInfoInUpstreamStage ( Stage currentStage , List < Pattern > packageFilePatterns ) { Stage upstreamStage = currentStage . ancestors ( ) . stream ( ) . filter ( it -> { Map < String , Object > buildInfo = ( Map < String , Object > ) it . getOutputs ( ) . get ( " buildInfo " ) ; return buildInfo != null && artifactMatch ( ( List < Map < String , String > > ) buildInfo . get ( " artifacts " ) , packageFilePatterns ) ; } ) . findFirst ( ) . orElse ( null ) ; return upstreamStage != null ? ( Map < String , Object > ) upstreamStage . getOutputs ( ) . get ( " buildInfo " ) : emptyMap ( ) ; }
cfieber/orca | private static boolean artifactMatch ( List < Map < String , String > > artifacts , List < Pattern > patterns ) { return artifacts != null && artifacts . stream ( ) . anyMatch ( ( Map artifact ) -> patterns . stream ( ) . anyMatch ( p -> p . matcher ( String . valueOf ( artifact . get ( " fileName " ) ) ) . matches ( ) ) ) ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( ) { return new AffinityGroupFilterOptions ( false ) ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( boolean matchesAny ) { return new AffinityGroupFilterOptions ( matchesAny ) ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( @ Nonnull String regex ) { AffinityGroupFilterOptions options = new AffinityGroupFilterOptions ( false ) ; options . regex = regex ; return options ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( boolean matchesAny , @ Nonnull String regex ) { AffinityGroupFilterOptions options = new AffinityGroupFilterOptions ( matchesAny ) ; options . regex = regex ; return options ; }
272029252/Metamorphosis | public static AddMsgLocation decode ( final ByteBuffer buf ) { if ( ! buf . hasRemaining ( ) ) { return null ; } final long offset = buf . getLong ( ) ; final int length = buf . getInt ( ) ; final int checksum = buf . getInt ( ) ; final int descLen = buf . getInt ( ) ; final byte [ ] descBytes = new byte [ descLen ] ; buf . get ( descBytes ) ; final String desc = ByteUtils . getString ( descBytes ) ; return new AddMsgLocation ( offset , length , checksum , desc ) ; }
GunoH/intellij-community | public static < A , B > List < B > map ( Function < A , B > fn , List < A > as ) { return null ; }
GunoH/intellij-community | public static < A , B > B foldLeft ( BiFunction < B , A , B > fn , B b , List < A > as ) { return null ; }
GunoH/intellij-community | public static void main ( String [ ] args ) { List < CoProduct2 < String , Integer > > criteria = emptyList ( ) ; foldLeft ( ( r , t ) -> t . into ( ( s , i ) -> null ) , new Tuple2 < List < Object > , List < Object > > ( new ArrayList < > ( ) , new ArrayList < > ( ) ) , map ( CoProduct2 :: project , criteria ) ) ; }
GunoH/intellij-community | private static < Am , Bm > List < Bm > map ( Function < Am , Bm > fn , List < Am > as ) { return null ; }
GunoH/intellij-community | private static < Al > void foldLeft ( Consumer < Al > fn , List < Al > as ) { }
GunoH/intellij-community | public static void foo ( final List < CoProduct2 < String > > criteria ) { foldLeft ( ( t ) -> t . into ( ) , map ( CoProduct2 :: project , criteria ) ) ; }
wintersandroid/lego-display-sequencer | @ NonNull public static SequenceThread parseSnapshot ( @ NonNull DataSnapshot snapshot ) { Log . d ( TAG , " parseSnapshot ▁ " + snapshot . toString ( ) ) ; SequenceThread sequenceThread = snapshot . getValue ( SequenceThread . class ) ; sequenceThread . setKey ( snapshot . getKey ( ) ) ; return sequenceThread ; }
don-philipe/graphhopper | private static GraphHopperServerConfiguration createConfig ( ) { GraphHopperServerConfiguration config = new GraphHopperServerTestConfiguration ( ) ; config . getGraphHopperConfiguration ( ) . putObject ( " graph . flag _ encoders " , " car | turn _ costs = true " ) . putObject ( " routing . ch . disabling _ allowed " , true ) . putObject ( " prepare . min _ network _ size " , 0 ) . putObject ( " datareader . file " , " . . / core / files / moscow . osm . gz " ) . putObject ( " graph . encoded _ values " , " road _ class , surface , road _ environment , max _ speed " ) . putObject ( " graph . location " , DIR ) . setProfiles ( Arrays . asList ( new Profile ( " my _ car _ turn _ costs " ) . setVehicle ( " car " ) . setWeighting ( " fastest " ) . setTurnCosts ( true ) , new Profile ( " my _ car _ no _ turn _ costs " ) . setVehicle ( " car " ) . setWeighting ( " fastest " ) . setTurnCosts ( false ) ) ) . setCHProfiles ( Arrays . asList ( new CHProfile ( " my _ car _ turn _ costs " ) , new CHProfile ( " my _ car _ no _ turn _ costs " ) ) ) . setLMProfiles ( Arrays . asList ( new LMProfile ( " my _ car _ no _ turn _ costs " ) , new LMProfile ( " my _ car _ turn _ costs " ) . setPreparationProfile ( " my _ car _ no _ turn _ costs " ) ) ) ; return config ; }
don-philipe/graphhopper | @ BeforeAll @ AfterAll public static void cleanUp ( ) { Helper . removeDir ( new File ( DIR ) ) ; }
clemus90/competitive-programming | static Scanner newInput ( ) throws IOException { if ( System . getProperty ( " JUDGE " ) != null ) { return new Scanner ( new File ( " chairs . in " ) ) ; } else { return new Scanner ( System . in ) ; } }
clemus90/competitive-programming | static PrintWriter newOutput ( ) throws IOException { if ( System . getProperty ( " JUDGE " ) != null ) { return new PrintWriter ( " chairs . out " ) ; } else { return new PrintWriter ( System . out ) ; } }
clemus90/competitive-programming | public static void main ( String [ ] args ) throws IOException { try ( Scanner in = newInput ( ) ; PrintWriter out = newOutput ( ) ) { double [ ] sides = new double [ 3 ] ; double avg = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = ( in . nextDouble ( ) ) / 2.0 ; avg += sides [ i ] ; } avg /= 3 ; NumberFormat f = new DecimalFormat ( " # 0.0000000" ) ; out . println ( f . format ( avg ) ) ; } }
arthurthouzeau/SudokuSolverGUI | public static SudokuBoard importFromCSV ( String inputFile ) throws ImportException { try ( CSVReader reader = new CSVReader ( new FileReader ( inputFile ) ) ) { String [ ] nextLine ; int countLines = 0 ; if ( ( nextLine = reader . readNext ( ) ) == null ) { throw new ImportException ( " Please ▁ check ▁ that ▁ the ▁ file ▁ is ▁ not ▁ empty . " ) ; } int tst = ( int ) Math . sqrt ( nextLine . length ) ; if ( tst * tst != nextLine . length ) { throw new ImportException ( " Please ▁ check ▁ the ▁ number ▁ of ▁ columns . \n " + " It ▁ should ▁ be ▁ a ▁ perfect ▁ square . " ) ; } SudokuBoard sb = new SudokuBoard ( nextLine . length ) ; do { if ( nextLine . length != sb . SIZE ) { throw new ImportException ( " Please ▁ check ▁ each ▁ row ▁ has ▁ " + sb . SIZE + " ▁ columns . ▁ ( Same ▁ as ▁ first ▁ row ) " ) ; } for ( int j = 0 ; j < nextLine . length ; j ++ ) { sb . set ( Integer . parseInt ( nextLine [ j ] . trim ( ) ) , countLines , j ) ; } countLines ++ ; } while ( ( nextLine = reader . readNext ( ) ) != null && countLines < sb . SIZE ) ; if ( countLines < sb . SIZE || nextLine != null ) { throw new ImportException ( " Please ▁ check ▁ the ▁ input ▁ CSV ▁ file ▁ has ▁ " + sb . SIZE + " ▁ rows . ▁ ( To ▁ match ▁ the ▁ number ▁ of ▁ columns ) " ) ; } return sb ; } catch ( FileNotFoundException e ) { String errorMsg = " The ▁ file ▁ you ▁ specified ▁ was ▁ not ▁ found . " ; throw new ImportException ( errorMsg ) ; } catch ( NumberFormatException e ) { String errorMsg = " Please ▁ check ▁ all ▁ values ▁ are ▁ integer . " ; throw new ImportException ( errorMsg ) ; } catch ( IOException e ) { throw new ImportException ( e . toString ( ) ) ; } }
xitrum-framework/scalive | public static void agentmain ( String agentArgs , Instrumentation inst ) throws IOException { final String [ ] args = agentArgs . split ( " ▁ " ) ; final String [ ] jarSearchDirs = args [ 0 ] . split ( File . pathSeparator ) ; final int port = Integer . parseInt ( args [ 1 ] ) ; final ServerSocket serverSocket = Server . open ( port ) ; new Thread ( Agent . class . getName ( ) + " - Server " ) { @ Override public void run ( ) { try { Server . run ( serverSocket , jarSearchDirs ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } . start ( ) ; }
gems-uff/dominoes | public static void Open ( ) { File f = new File ( database_file ) ; boolean createStructure = false ; if ( ! f . exists ( ) ) createStructure = true ; try { Class . forName ( " org . sqlite . JDBC " ) ; conn = DriverManager . getConnection ( " jdbc : sqlite : " + database_file ) ; if ( createStructure ) CreateGitMinerRepoStructure ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static void Close ( ) { try { conn . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static Map < String , Commit > Unserialize ( String _repository ) throws SQLException { Map < String , Commit > resultSet = new HashMap < String , Commit > ( ) ; String sql ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; sql = " SELECT ▁ TC . date , ▁ TC . hashcode , ▁ TU . name ▁ AS ▁ UserName , ▁ Tc . message , ▁ TFile . newName ▁ AS ▁ FileName , ▁ " + " TClass . name ▁ AS ▁ ClassName , ▁ TFunction . name ▁ AS ▁ FuncName ▁ " + " FROM ▁ TCommit ▁ TC ▁ " + " INNER ▁ JOIN ▁ TRepository ▁ TR ▁ ON ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " INNER ▁ JOIN ▁ TUser ▁ TU ▁ ON ▁ TC . userid ▁ = ▁ TU . id ▁ " + " LEFT ▁ JOIN ▁ TFile ▁ ON ▁ TFile . commitid ▁ = ▁ TC . id ▁ " + " LEFT ▁ JOIN ▁ TClass ▁ on ▁ TClass . fileid ▁ = ▁ TFile . id ▁ " + " LEFT ▁ JOIN ▁ TFunction ▁ ON ▁ TFunction . classid ▁ = ▁ TClass . id ▁ " + " WHERE ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . date ; ▁ " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { Commit currentCommit = resultSet . get ( rs . getString ( " HashCode " ) ) ; if ( currentCommit == null ) { currentCommit = new Commit ( rs . getString ( " HashCode " ) , rs . getString ( " UserName " ) ) ; try { currentCommit . date = sdf . parse ( rs . getString ( " date " ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } resultSet . put ( currentCommit . hash , currentCommit ) ; } String _fileName = rs . getString ( " FileName " ) ; if ( _fileName != null ) { FileArch currentFile = currentCommit . files . get ( _fileName ) ; if ( currentFile == null ) { currentFile = new FileArch ( _fileName ) ; currentCommit . files . put ( currentFile . filename , currentFile ) ; String _className = rs . getString ( " ClassName " ) ; if ( _className != null ) { FileClass currentClass = currentFile . classes . get ( _className ) ; if ( currentClass == null ) { currentClass = new FileClass ( _className ) ; currentFile . classes . put ( currentClass . className , currentClass ) ; } String _funcName = rs . getString ( " FuncName " ) ; if ( _funcName != null ) { currentClass . functions . add ( _funcName ) ; } } } } } rs . close ( ) ; smt . close ( ) ; return resultSet ; }
gems-uff/dominoes | public static Date AddRepository ( RepositoryNode repo ) { Statement smt ; String sql ; Date lastCommitDate = null ; try { smt = conn . createStatement ( ) ; lastCommitDate = GetLastCommitDate ( repo . getName ( ) ) ; if ( lastCommitDate == null ) { sql = " INSERT ▁ INTO ▁ TREPOSITORY ( Name ) ▁ VALUES ▁ ( ' " + repo . getName ( ) + " ' ) ; " ; smt . executeUpdate ( sql ) ; smt . close ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return lastCommitDate ; }
gems-uff/dominoes | public static void Serialize ( RepositoryNode repo ) { Statement smt ; String sql ; try { smt = conn . createStatement ( ) ; Date lastCommitDate = AddRepository ( repo ) ; InsertUsers ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; List < CommitNode > commits = repo . getCommits ( ) ; for ( CommitNode commit : commits ) { if ( lastCommitDate == null || ( lastCommitDate != null && commit . getDate ( ) . after ( lastCommitDate ) ) ) { sql = " INSERT ▁ INTO ▁ TCOMMIT ▁ ( RepoId , ▁ UserId , ▁ HashCode , ▁ Date , ▁ Message ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TREPOSITORY ▁ TR ▁ WHERE ▁ TR . Name ▁ = ▁ ' " + repo . getName ( ) + " ' ) , " + " ( SELECT ▁ id ▁ FROM ▁ TUSER ▁ TU ▁ WHERE ▁ TU . Name ▁ = ▁ ' " + commit . getUser ( ) . getName ( ) + " ' ) , " + " ' " + commit . getId ( ) + " ' , " + " ' " + sdf . format ( commit . getDate ( ) ) + " ' , " + " ' " + commit . getLogMessage ( ) . replaceAll ( " ' " , " ' ' " ) + " ' ) ; " ; for ( FileNode fileNode : commit . getFiles ( ) ) { sql += " INSERT ▁ INTO ▁ TFILE ▁ ( CommitId , ▁ NewName , ▁ OldName , ▁ NewObjId , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TCOMMIT ▁ TC ▁ WHERE ▁ TC . HashCode ▁ = ▁ ' " + commit . getId ( ) + " ' ) , " + " ' " + fileNode . newName + " ' , " + " ' " + fileNode . oldName + " ' , " + " ' " + fileNode . newObjId + " ' , " + " ' " + fileNode . changeType + " ' ) ; " ; for ( ClassNode classNode : fileNode . getClasses ( ) ) { sql += " INSERT ▁ INTO ▁ TCLASS ▁ ( FileId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TFILE ▁ TF ▁ WHERE ▁ TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ) , " + " ' " + classNode . getName ( ) + " ' , " + classNode . getLineStart ( ) + " , " + classNode . getLineEnd ( ) + " , " + " ' " + classNode . getChangeType ( ) + " ' ) ; " ; for ( FunctionNode functionNode : classNode . getFunctions ( ) ) { sql += " INSERT ▁ INTO ▁ TFUNCTION ▁ ( ClassId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCLASS ▁ TC , ▁ TFILE ▁ TF ▁ WHERE ▁ TC . Name ▁ = ▁ ' " + classNode . getName ( ) + " ' ▁ AND ▁ " + " TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ▁ AND ▁ TC . FileId ▁ = ▁ TF . id ) , " + " ' " + functionNode . getName ( ) + " ' , " + functionNode . getLineStart ( ) + " , " + functionNode . getLineEnd ( ) + " , " + " ' " + functionNode . getChangeType ( ) + " ' ) ; " ; } } } sql += " UPDATE ▁ TREPOSITORY ▁ SET ▁ LastCommitId ▁ = ▁ " + " ( SELECT ▁ distinct ( id ) ▁ FROM ▁ TCOMMIT ▁ where ▁ date ▁ = ▁ ( select ▁ max ( date ) ▁ from ▁ TCOMMIT ) ) " + " WHERE ▁ Name ▁ = ▁ ' " + repo . getName ( ) + " ' ; " ; smt . executeUpdate ( sql ) ; } } smt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | private static Date GetLastCommitDate ( String name ) { Date result = null ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; String sql = " SELECT ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TR . LastCommitId ▁ = ▁ TC . id ▁ AND ▁ " + " TR . Name ▁ = ▁ ' " + name + " ' ; " ; Statement stm ; ResultSet rs ; try { stm = conn . createStatement ( ) ; rs = stm . executeQuery ( sql ) ; while ( rs . next ( ) ) { try { result = sdf . parse ( rs . getString ( " date " ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return result ; }
gems-uff/dominoes | private static void InsertUsers ( ) throws SQLException { Map < String , UserNode > users = UserNode . getUsers ( ) ; Statement smt = conn . createStatement ( ) ; for ( UserNode user : users . values ( ) ) { String sql = " SELECT ▁ * ▁ FROM ▁ TUSER ▁ WHERE ▁ name ▁ = ▁ ' " + user . getName ( ) + " ' ; " ; ResultSet rs = smt . executeQuery ( sql ) ; if ( ! rs . next ( ) ) { sql = " INSERT ▁ INTO ▁ TUSER ▁ ( Name ) ▁ VALUES ▁ ( ' " + user . getName ( ) + " ' ) ; " ; smt . executeUpdate ( sql ) ; } rs . close ( ) ; } smt . close ( ) ; }
gems-uff/dominoes | public static int getUserId ( String name ) { name = name . replaceAll ( " ' " , " ' ' " ) ; try { Statement smt = conn . createStatement ( ) ; String sql = " SELECT ▁ * ▁ FROM ▁ TUSER ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ; ResultSet rs = smt . executeQuery ( sql ) ; if ( ! rs . next ( ) ) { sql = " INSERT ▁ INTO ▁ TUSER ▁ ( Name ) ▁ VALUES ▁ ( ' " + name + " ' ) ; " ; smt . executeUpdate ( sql ) ; } else { return rs . getInt ( " id " ) ; } sql = " SELECT ▁ * ▁ FROM ▁ TUSER ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ; rs = smt . executeQuery ( sql ) ; if ( rs . next ( ) ) return rs . getInt ( " id " ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return - 1 ; }
gems-uff/dominoes | private static void CreateGitMinerRepoStructure ( ) { try { Statement smt = conn . createStatement ( ) ; String sql = " CREATE ▁ TABLE ▁ TREPOSITORY ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " Name ▁ STRING ▁ UNIQUE ▁ NOT ▁ NULL , " + " LastCommitId ▁ INTEGER ▁ REFERENCES ▁ TCOMMIT ( id ) ) ; " + " CREATE ▁ TABLE ▁ TUSER ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " Name ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TCOMMIT ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " RepoId ▁ INTEGER ▁ REFERENCES ▁ TREPOSITORY ( id ) ▁ NOT ▁ NULL , " + " UserID ▁ INTEGER ▁ REFERENCES ▁ TUSER ( id ) ▁ NOT ▁ NULL , " + " HashCode ▁ STRING ▁ NOT ▁ NULL , " + " Date ▁ STRING ▁ NOT ▁ NULL , " + " Message ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TFILE ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " CommitId ▁ INTEGER ▁ REFERENCES ▁ TCOMMIT ( id ) , " + " NewName ▁ STRING ▁ NOT ▁ NULL , " + " OldName ▁ STRING ▁ NOT ▁ NULL , " + " NewObjId ▁ STRING ▁ NOT ▁ NULL , " + " PackageName ▁ STRING ▁ NOT ▁ NULL , " + " ChangeType ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TCLASS ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " FileId ▁ INTEGER ▁ REFERENCES ▁ TFILE ( id ) , " + " Name ▁ STRING ▁ NOT ▁ NULL , " + " LineStart ▁ INT ▁ NOT ▁ NULL , " + " LineEnd ▁ INT ▁ NOT ▁ NULL , " + " ChangeType ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TFUNCTION ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " ClassId ▁ INTEGER ▁ REFERENCES ▁ TCLASS ( id ) , " + " Name ▁ STRING ▁ NOT ▁ NULL , " + " LineStart ▁ INT ▁ NOT ▁ NULL , " + " LineEnd ▁ INT ▁ NOT ▁ NULL , " + " ChangeType ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TBUG ( " + " id ▁ STRING ▁ NOT ▁ NULL , " + " CommitID ▁ STRING ▁ NOT ▁ NULL ) ; " ; smt . executeUpdate ( sql ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static Matrix2D ExtractCommitArtifactMatrix ( Analyzer . Grain grain , String _repository , String filename ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . COMMIT , InfoType . ARTIFACT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR , ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . commitid ▁ = ▁ TC . id ▁ AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddRowDesc ( rs . getString ( " HashCode " ) ) ; } switch ( grain ) { case FILE : sql = " SELECT ▁ Distinct ( TF . NewName ) ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TF . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " NewName " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TFL . NewName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TFL . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; sql = sql . concat ( " GROUP ▁ BY ▁ TFL . NewName , ▁ TCL . name , ▁ TF . name ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " NewName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; rs . close ( ) ; break ; } Matrix2D mat = new Matrix2D ( descriptor ) ; switch ( grain ) { case FILE : sql = " SELECT ▁ TC . HashCode , ▁ TF . NewName ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TF . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TF . NewName ; " ) ; rs = smt . executeQuery ( sql ) ; int count = 0 ; while ( rs . next ( ) ) { count ++ ; mat . SetElement ( rs . getString ( " HashCode " ) , rs . getString ( " NewName " ) , 1 ) ; } System . out . println ( count ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ TC . hashcode , ▁ TFL . NewName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ from ▁ TFunction ▁ TF , ▁ " + " TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ " + " TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TFL . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TFL . newname , ▁ TCL . name , ▁ TF . name ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " HashCode " ) , rs . getString ( " NewName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; } rs . close ( ) ; break ; } smt . close ( ) ; return mat ; }
gems-uff/dominoes | public static Matrix2D ExtractFileClassMethodComposition ( String _repository ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . ARTIFACT , InfoType . ARTIFACT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ DISTINCT ▁ TFL . NewName ▁ AS ▁ FileName ▁ " + " FROM ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TCL . fileId ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . NewName , ▁ TCL . name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddRowDesc ( rs . getString ( " FileName " ) ) ; } sql = " SELECT ▁ DISTINCT ▁ TFL . NewName ▁ AS ▁ FileName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . NewName , ▁ TCL . name , ▁ TF . Name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddColDesc ( rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; } Matrix2D result = new Matrix2D ( descriptor ) ; sql = " SELECT ▁ DISTINCT ▁ TFL . NewName ▁ AS ▁ FileName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . NewName , ▁ TCL . Name , ▁ TF . Name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) result . SetElement ( rs . getString ( " FileName " ) , rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; return result ; }
gems-uff/dominoes | public static Matrix2D ExtractDeveloperCommitMatrix ( String _repository , String filename ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . USER , InfoType . COMMIT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR , ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . commitid ▁ = ▁ TC . id ▁ AND ▁ TF . newname ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddColDesc ( rs . getString ( " HashCode " ) ) ; } sql = " SELECT ▁ Distinct ( TU . name ) ▁ FROM ▁ TUser ▁ TU , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . userID ▁ = ▁ TU . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddRowDesc ( rs . getString ( " name " ) ) ; } Matrix2D mat = new Matrix2D ( descriptor ) ; sql = " SELECT ▁ TU . name , ▁ TC . HashCode ▁ FROM ▁ TUser ▁ TU , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR , ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TC . userID ▁ = ▁ TU . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . commitid ▁ = ▁ TC . id ▁ AND ▁ TF . newname ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " name " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; smt . close ( ) ; return mat ; }
gems-uff/dominoes | public static String [ ] AvailableProjects ( ) throws SQLException { List < String > repos = new ArrayList < String > ( ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ Name ▁ FROM ▁ TREPOSITORY ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { repos . add ( rs . getString ( " name " ) ) ; } rs . close ( ) ; smt . close ( ) ; return ( String [ ] ) repos . toArray ( new String [ 0 ] ) ; }
gems-uff/dominoes | public static int NumCommits ( String projName ) { int total = 0 ; try { Statement smt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ TCommit . HashCode ▁ FROM ▁ TCOMMIT , ▁ TREPOSITORY ▁ " + " WHERE ▁ TCOMMIT . RepoId ▁ = ▁ TREPOSITORY . id ▁ AND ▁ " + " TREPOSITORY . Name ▁ = ▁ ' " + projName + " ' ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { total ++ ; } rs . close ( ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return total ; }
gems-uff/dominoes | public static Map < String , Integer > Commits_Month ( String projName ) { Map < String , Integer > res = new LinkedHashMap < String , Integer > ( ) ; try { Statement smt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ strftime ( ' % m - % Y ' , ▁ TCommit . Date ) ▁ as ▁ ' month - year ' , ▁ " + " COUNT ( TCommit . Date ) ▁ AS ▁ TotalMonth ▁ FROM ▁ TCOMMIT , ▁ TREPOSITORY , ▁ TFILE ▁ " + " WHERE ▁ TCOMMIT . RepoId ▁ = ▁ TREPOSITORY . id ▁ AND ▁ " + " TFILE . commitId ▁ = ▁ TCOMMIT . id ▁ AND ▁ TFile . newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ AND ▁ " + " TREPOSITORY . Name ▁ = ▁ ' " + projName + " ' ▁ " + " GROUP ▁ BY ▁ strftime ( ' % m - % Y ' , ▁ Date ) ▁ ORDER ▁ BY ▁ TotalMonth ▁ desc ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { res . put ( rs . getString ( " month - year " ) , rs . getInt ( " TotalMonth " ) ) ; } rs . close ( ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return res ; }
gems-uff/dominoes | public static void UpdateRepoToLastCommit ( RepositoryNode repoNode ) { Statement smt ; String sql ; try { smt = conn . createStatement ( ) ; sql = " UPDATE ▁ TREPOSITORY ▁ SET ▁ LastCommitId ▁ = ▁ " + " ( SELECT ▁ distinct ( id ) ▁ FROM ▁ TCOMMIT ▁ where ▁ date ▁ = ▁ ( select ▁ max ( date ) ▁ from ▁ TCOMMIT ) ) " + " WHERE ▁ Name ▁ = ▁ ' " + repoNode . getName ( ) + " ' ; " ; smt . executeUpdate ( sql ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static void AddCommit ( CommitNode commit , RepositoryNode repoNode ) { Statement smt ; String sql ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; try { smt = conn . createStatement ( ) ; sql = " INSERT ▁ INTO ▁ TCOMMIT ▁ ( RepoId , ▁ UserId , ▁ HashCode , ▁ Date , ▁ Message ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TREPOSITORY ▁ TR ▁ WHERE ▁ TR . Name ▁ = ▁ ' " + repoNode . getName ( ) + " ' ) , " + Integer . toString ( getUserId ( commit . getUser ( ) . getName ( ) ) ) + " , " + " ' " + commit . getId ( ) + " ' , " + " ' " + sdf . format ( commit . getDate ( ) ) + " ' , " + " ' " + commit . getLogMessage ( ) . replaceAll ( " ' " , " ' ' " ) + " ' ) ; " ; for ( FileNode fileNode : commit . getFiles ( ) ) { sql += " INSERT ▁ INTO ▁ TFILE ▁ ( CommitId , ▁ NewName , ▁ OldName , ▁ NewObjId , ▁ PackageName , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TCOMMIT ▁ TC ▁ WHERE ▁ TC . HashCode ▁ = ▁ ' " + commit . getId ( ) + " ' ) , " + " ' " + fileNode . newName + " ' , " + " ' " + fileNode . oldName + " ' , " + " ' " + fileNode . newObjId + " ' , " + " ' " + fileNode . packageName + " ' , " + " ' " + fileNode . changeType + " ' ) ; " ; for ( ClassNode classNode : fileNode . getClasses ( ) ) { sql += " INSERT ▁ INTO ▁ TCLASS ▁ ( FileId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TFILE ▁ TF ▁ WHERE ▁ TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ) , " + " ' " + classNode . getName ( ) + " ' , " + classNode . getLineStart ( ) + " , " + classNode . getLineEnd ( ) + " , " + " ' " + classNode . getChangeType ( ) + " ' ) ; " ; for ( FunctionNode functionNode : classNode . getFunctions ( ) ) { sql += " INSERT ▁ INTO ▁ TFUNCTION ▁ ( ClassId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCLASS ▁ TC , ▁ TFILE ▁ TF ▁ WHERE ▁ TC . Name ▁ = ▁ ' " + classNode . getName ( ) + " ' ▁ AND ▁ " + " TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ▁ AND ▁ TC . FileId ▁ = ▁ TF . id ) , " + " ' " + functionNode . getName ( ) + " ' , " + functionNode . getLineStart ( ) + " , " + functionNode . getLineEnd ( ) + " , " + " ' " + functionNode . getChangeType ( ) + " ' ) ; " ; } } } smt . executeUpdate ( sql ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static void MineBugs ( String bugMatch , RepositoryNode repository ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . USER , InfoType . COMMIT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Message ▁ FROM ▁ TCommit ▁ TC , ▁ TRepository ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + repository . getName ( ) + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date ; " ; rs = smt . executeQuery ( sql ) ; List < Entry < String , String > > bugCommit = new ArrayList < Map . Entry < String , String > > ( ) ; while ( rs . next ( ) ) { String hashCode = rs . getString ( " HashCode " ) ; String message = rs . getString ( " Message " ) ; String bugId = extractBugId ( message , bugMatch ) ; if ( bugId != null ) { Map . Entry < String , String > pair = new AbstractMap . SimpleEntry ( bugId , hashCode ) ; bugCommit . add ( pair ) ; } } for ( Entry < String , String > record : bugCommit ) { sql = " INSERT ▁ INTO ▁ TBUG ▁ ( id , ▁ commitId ) " + " ▁ VALUES ▁ ( ' " + record . getKey ( ) + " ' , ▁ ' " + record . getValue ( ) + " ' ) ; " ; smt . executeUpdate ( sql ) ; } rs . close ( ) ; smt . close ( ) ; }
gems-uff/dominoes | private static String extractBugId ( String text , String match ) { String idBug = " derby - " ; String res = idBug ; int start = text . toLowerCase ( ) . indexOf ( idBug ) ; for ( int i = start + idBug . length ( ) ; i < text . length ( ) ; i ++ ) { if ( ! Character . isDigit ( text . charAt ( i ) ) ) { break ; } res += text . charAt ( i ) ; } if ( idBug . equals ( res ) ) return null ; return res ; }
gems-uff/dominoes | public static Matrix2D ExtractCommitSubMatrix ( Grain grain , String _repository , int offset , int size ) { try { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . ARTIFACT , InfoType . COMMIT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date ▁ ASC ▁ " + " LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddColDesc ( rs . getString ( " HashCode " ) ) ; } switch ( grain ) { case FILE : sql = " SELECT ▁ Distinct ( TF . NewName ) ▁ FROM ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TF . CommitId ▁ IN ▁ " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' " + " ORDER ▁ BY ▁ TC . date ▁ ASC ▁ LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ) " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddRowDesc ( rs . getString ( " NewName " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " GROUP ▁ BY ▁ TCL . name , ▁ TF . name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddRowDesc ( rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; rs . close ( ) ; break ; } Matrix2D mat = new Matrix2D ( descriptor ) ; switch ( grain ) { case FILE : sql = " SELECT ▁ TC . HashCode , ▁ TF . NewName ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC ▁ " + " WHERE ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ TC . id ▁ IN ▁ " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' " + " ORDER ▁ BY ▁ TC . date ▁ ASC ▁ LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ) " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " NewName " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ TC . hashcode , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ from ▁ TFunction ▁ TF , ▁ " + " TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ " + " TC . RepoId ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . newname , ▁ TCL . name , ▁ TF . name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; break ; } smt . close ( ) ; return mat ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
AlexaGh/JavaMainRepo | public static void main ( String [ ] args ) throws Exception { String [ ] species = { Constants . Species . Aquatics , Constants . Species . Mammals , Constants . Species . Birds , Constants . Species . Insects , Constants . Species . Reptiles } ; String [ ] [ ] animals = { { Constants . Animals . Aquatics . SeaTurtle , Constants . Animals . Aquatics . SeaHorse , Constants . Animals . Aquatics . MoonJellyfish } , { Constants . Animals . Mammals . Tiger , Constants . Animals . Mammals . Cow , Constants . Animals . Mammals . Monkey } , { Constants . Animals . Birds . Dove , Constants . Animals . Birds . Woodpecker , Constants . Animals . Birds . Nightingale } , { Constants . Animals . Insects . Butterfly , Constants . Animals . Insects . LadyBug , Constants . Animals . Insects . Spider } , { Constants . Animals . Reptiles . Crocodile , Constants . Animals . Reptiles . Dragon , Constants . Animals . Reptiles . Turtule } } ; AnimalFactory abstractFactory = new AnimalFactory ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { SpeciesFactory speciesFactory1 = abstractFactory . getSpeciesFactory ( species [ i ] ) ; Animal a1 = speciesFactory1 . getAnimal ( animals [ i ] [ j ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ animal ▁ with ▁ % d ▁ legs ▁ whose ▁ name ▁ is ▁ % s ! \n " , a1 . getNrOfLegs ( ) , a1 . getName ( ) ) ; } } int i = 0 ; while ( i <= 50 || i == 0 ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory2 = abstractFactory . getSpeciesFactory ( species [ chooseSpecies ] ) ; Animal a2 = speciesFactory2 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ animal ▁ with ▁ % d ▁ legs ▁ whose ▁ name ▁ is ▁ % s ! \n " , a2 . getNrOfLegs ( ) , a2 . getName ( ) ) ; i ++ ; } AnimalFactory abstractFactory2 = new AnimalFactory ( ) ; Animal [ ] allAnimals = new Animal [ 15 ] ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory3 = abstractFactory2 . getSpeciesFactory ( species [ chooseSpecies ] ) ; allAnimals [ k ] = speciesFactory3 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; } CareTakerFactory abstractTakers = new CareTakerFactory ( ) ; Employee employee = abstractTakers . getEmployeeFactory ( Constants . Employees . Caretaker ) ; employee . setDead ( false ) ; employee . setName ( " Jack " ) ; Employee [ ] caretakers = new CareTaker [ 15 ] ; for ( int x = 0 ; x < 15 ; x ++ ) { caretakers [ x ] = abstractTakers . getEmployeeFactory ( Constants . Employees . Caretaker ) ; caretakers [ x ] . setDead ( false ) ; } boolean isTakenCareOf = false ; for ( int x = 0 ; x < caretakers . length ; x ++ ) { for ( int k = 0 ; k < allAnimals . length ; k ++ ) { if ( ! caretakers [ k ] . isDead ( ) && ! allAnimals [ k ] . isTakenCareOf ( ) ) { String result = ( ( CareTaker ) caretakers [ x ] ) . takeCareOf ( allAnimals [ k ] ) ; if ( result . equals ( Constants . Employees . Caretakers . TCO_KILLED ) ) { System . out . println ( " caretaker " + k + " ▁ killed ▁ by ▁ " + allAnimals [ k ] . getName ( ) ) ; caretakers [ k ] . setDead ( true ) ; } else if ( result . equals ( Constants . Employees . Caretakers . TCO_NO_TIME ) ) { continue ; } else { allAnimals [ k ] . setTakenCareOf ( true ) ; } } if ( allAnimals [ k ] . isTakenCareOf ( ) ) { isTakenCareOf = true ; } else { isTakenCareOf = false ; } } } PrintWriter writer = new PrintWriter ( " output . txt " , " UTF - 8" ) ; if ( isTakenCareOf ) { System . out . println ( " All ▁ animals ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; writer . println ( " All ▁ animals ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; } else { System . out . println ( " There ▁ are ▁ animals ▁ that ▁ still ▁ need ▁ to ▁ be ▁ cared ▁ of ! " ) ; writer . println ( " There ▁ are ▁ animals ▁ that ▁ still ▁ need ▁ to ▁ be ▁ cared ▁ of ! " ) ; } for ( int l = 0 ; l < allAnimals . length ; l ++ ) { if ( ! isTakenCareOf ) { System . out . println ( allAnimals [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; writer . println ( allAnimals [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; } } AnimalFactory abstractFactory3 = new AnimalFactory ( ) ; AnimalRepository ar = new AnimalRepository ( ) ; ArrayList < Animal > animalsList = new ArrayList < > ( ) ; ArrayList < Animal > animalsListToDisplay = new ArrayList < > ( ) ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory3 = abstractFactory3 . getSpeciesFactory ( species [ chooseSpecies ] ) ; Animal allAnimalsAsAList = speciesFactory3 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; animalsList . add ( allAnimalsAsAList ) ; } ar . save ( animalsList ) ; animalsListToDisplay = ar . load ( ) ; System . out . println ( ) ; System . out . println ( " saved ▁ list : " ) ; writer . println ( ) ; writer . println ( " saved ▁ list : " ) ; for ( Animal ani2 : animalsList ) { System . out . println ( ani2 . getName ( ) ) ; writer . println ( ani2 . getName ( ) ) ; } System . out . println ( ) ; System . out . println ( " loaded ▁ list : " ) ; writer . println ( ) ; writer . println ( " loaded ▁ list : " ) ; for ( Animal ani : animalsListToDisplay ) { System . out . println ( ani . getName ( ) ) ; writer . println ( ani . getName ( ) ) ; } ArrayList < Employee > employeesList = new ArrayList < > ( ) ; ArrayList < Employee > employeesListToDisplay = new ArrayList < > ( ) ; CareTakerFactory abstractTakers2 = new CareTakerFactory ( ) ; EmployeeRepository er = new EmployeeRepository ( ) ; for ( int k = 0 ; k < 10 ; k ++ ) { Employee employee2 = abstractTakers2 . getEmployeeFactory ( Constants . Employees . Caretaker ) ; employeesList . add ( employee2 ) ; } er . save ( employeesList ) ; employeesListToDisplay = er . load ( ) ; for ( int k = 0 ; k < employeesList . size ( ) ; k ++ ) { System . out . println ( String . valueOf ( employeesListToDisplay . get ( k ) . getName ( ) ) ) ; } writer . close ( ) ; }
eminn/jet-word-count | public static void main ( String [ ] args ) throws Exception { DAG dag = new DAG ( ) ; Vertex source = dag . newVertex ( " source " , Sources . readMap ( " lines " ) ) ; Pattern delimiter = Pattern . compile ( " \\ W + " ) ; Vertex tokenize = dag . newVertex ( " tokenize " , Processors . flatMap ( ( Entry < Integer , String > e ) -> Traversers . traverseArray ( delimiter . split ( e . getValue ( ) . toLowerCase ( ) ) ) . filter ( word -> ! word . isEmpty ( ) ) ) ) ; Vertex accumulate = dag . newVertex ( " accumulate " , Processors . accumulateByKey ( DistributedFunctions . wholeItem ( ) , AggregateOperations . counting ( ) ) ) ; Vertex combine = dag . newVertex ( " combine " , Processors . combineByKey ( AggregateOperations . counting ( ) ) ) ; Vertex sink = dag . newVertex ( " sink " , Sinks . writeMap ( " counts " ) ) ; dag . edge ( between ( source , tokenize ) ) . edge ( between ( tokenize , accumulate ) . partitioned ( DistributedFunctions . wholeItem ( ) , Partitioner . HASH_CODE ) ) . edge ( between ( accumulate , combine ) . distributed ( ) . partitioned ( DistributedFunctions . entryKey ( ) ) ) . edge ( between ( combine , sink ) ) ; JetInstance jet = JetBootstrap . getInstance ( ) ; IMap < Integer , String > map = jet . getMap ( " lines " ) ; map . put ( 0 , " It ▁ was ▁ the ▁ best ▁ of ▁ times , " ) ; map . put ( 1 , " it ▁ was ▁ the ▁ worst ▁ of ▁ times , " ) ; map . put ( 2 , " it ▁ was ▁ the ▁ age ▁ of ▁ wisdom , " ) ; map . put ( 3 , " it ▁ was ▁ the ▁ age ▁ of ▁ foolishness , " ) ; map . put ( 4 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ belief , " ) ; map . put ( 5 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ incredulity , " ) ; map . put ( 6 , " it ▁ was ▁ the ▁ season ▁ of ▁ Light , " ) ; map . put ( 7 , " it ▁ was ▁ the ▁ season ▁ of ▁ Darkness " ) ; map . put ( 8 , " it ▁ was ▁ the ▁ spring ▁ of ▁ hope , " ) ; map . put ( 9 , " it ▁ was ▁ the ▁ winter ▁ of ▁ despair , " ) ; map . put ( 10 , " we ▁ had ▁ everything ▁ before ▁ us , " ) ; map . put ( 11 , " we ▁ had ▁ nothing ▁ before ▁ us , " ) ; map . put ( 12 , " we ▁ were ▁ all ▁ going ▁ direct ▁ to ▁ Heaven , " ) ; map . put ( 13 , " we ▁ were ▁ all ▁ going ▁ direct ▁ the ▁ other ▁ way ▁ - - " ) ; map . put ( 14 , " in ▁ short , ▁ the ▁ period ▁ was ▁ so ▁ far ▁ like ▁ the ▁ present ▁ period , ▁ that ▁ some ▁ of ▁ " + " its ▁ noisiest ▁ authorities ▁ insisted ▁ on ▁ its ▁ being ▁ received , ▁ for ▁ good ▁ or ▁ for ▁ " + " evil , ▁ in ▁ the ▁ superlative ▁ degree ▁ of ▁ comparison ▁ only . " ) ; Job job = jet . newJob ( dag ) ; Future < Void > future = job . execute ( ) ; future . get ( ) ; System . out . println ( jet . getMap ( " counts " ) . entrySet ( ) ) ; }
lamberthu/hrpc | public static void testServer ( ) throws Exception { RpcContext context = new RpcContext ( ) ; RpcServer rpcServer = new RpcServer ( context ) ; rpcServer . addService ( new HelloServiceImpl ( ) ) ; rpcServer . start ( ) ; }
lamberthu/hrpc | public static void main ( String [ ] args ) throws Exception { testServer ( ) ; }
bedward70/bedward70-fitnesse-io | public static B70ParseBinder create ( Fixture fixture , String name ) throws RuntimeException { B70ParseBinder result ; if ( name . startsWith ( ASSIGNMENT_STRING ) ) { result = new B70ParseBinder . RecallBinding ( name . substring ( 1 ) ) ; } else if ( regexMethodPattern . matcher ( name ) . matches ( ) || methodPattern . matcher ( name ) . matches ( ) ) { final TypeAdapter adapter = makeAdapter ( fixture , name ) ; result = new B70ParseBinder . QueryBinding ( adapter ) ; } else { result = new B70ParseBinder . DefaultBuilding ( name ) ; } return result ; }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapter ( Fixture fixture , String name ) throws RuntimeException { Matcher regexMatcher = regexMethodPattern . matcher ( name ) ; if ( regexMatcher . find ( ) ) { return makeAdapterForRegexMethod ( name , fixture , regexMatcher ) ; } else { Matcher methodMatcher = methodPattern . matcher ( name ) ; return methodMatcher . find ( ) ? makeAdapterForMethod ( name , fixture , methodMatcher ) : makeAdapterForField ( name , fixture ) ; } }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForMethod ( String name , Fixture fixture , Matcher matcher ) { return makeAdapterForMethod ( name , fixture , matcher , false ) ; }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForRegexMethod ( String name , Fixture fixture , Matcher matcher ) { return makeAdapterForMethod ( name , fixture , matcher , true ) ; }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForMethod ( String name , Fixture fixture , Matcher matcher , boolean isRegex ) { Method method = getMethod ( name , fixture , matcher ) ; if ( method == null ) { throw new NoSuchMethodFitFailureException ( name ) ; } else { return TypeAdapter . on ( fixture , method , isRegex ) ; } }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForField ( String name , Fixture fixture ) { Field field = null ; if ( GracefulNamer . isGracefulName ( name ) ) { String simpleName = GracefulNamer . disgrace ( name ) . toLowerCase ( ) ; field = findField ( fixture , simpleName ) ; } else { Matcher matcher = fieldPattern . matcher ( name ) ; matcher . find ( ) ; String fieldName = matcher . group ( 1 ) ; Class clazz = getTargetClass ( fixture ) ; try { field = clazz . getField ( fieldName ) ; } catch ( NoSuchFieldException var9 ) { try { field = getField ( clazz , fieldName ) ; } catch ( NoSuchFieldException var8 ) { ; } } } if ( field == null ) { throw new NoSuchFieldFitFailureException ( name ) ; } else { return TypeAdapter . on ( fixture , field ) ; } }
bedward70/bedward70-fitnesse-io | private static Class < ? > getTargetClass ( Fixture fixture ) { return fixture . getClass ( ) ; }
bedward70/bedward70-fitnesse-io | private static Field getField ( Class < ? > clazz , String fieldName ) throws NoSuchFieldException { try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException var4 ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( superClass == null ) { throw var4 ; } else { return getField ( superClass , fieldName ) ; } } }
bedward70/bedward70-fitnesse-io | private static Method getMethod ( String name , Fixture fixture , Matcher matcher ) { Method method = null ; String methodName ; if ( GracefulNamer . isGracefulName ( name ) ) { methodName = GracefulNamer . disgrace ( name ) . toLowerCase ( ) ; method = findMethod ( fixture , methodName ) ; } else { try { methodName = matcher . group ( 1 ) ; Class < ? > targetClass = getTargetClass ( fixture ) ; method = targetClass . getMethod ( methodName , new Class [ 0 ] ) ; } catch ( NoSuchMethodException var6 ) { ; } } return method ; }
bedward70/bedward70-fitnesse-io | private static Field findField ( Fixture fixture , String simpleName ) { List < Field > fields = getAllDeclaredFields ( getTargetClass ( fixture ) ) ; Field field = null ; Iterator var4 = fields . iterator ( ) ; while ( var4 . hasNext ( ) ) { Field possibleField = ( Field ) var4 . next ( ) ; if ( simpleName . equalsIgnoreCase ( possibleField . getName ( ) ) ) { field = possibleField ; break ; } } return field ; }
bedward70/bedward70-fitnesse-io | private static List < Field > getAllDeclaredFields ( Class < ? > clazz ) { if ( clazz . getSuperclass ( ) != null ) { List < Field > fields = getAllDeclaredFields ( clazz . getSuperclass ( ) ) ; fields . addAll ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; return fields ; } else { return new ArrayList ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; } }
bedward70/bedward70-fitnesse-io | private static Method findMethod ( Fixture fixture , String simpleName ) { Method [ ] methods = getTargetClass ( fixture ) . getMethods ( ) ; Method method = null ; Method [ ] var4 = methods ; int var5 = methods . length ; for ( int var6 = 0 ; var6 < var5 ; ++ var6 ) { Method possibleMethod = var4 [ var6 ] ; if ( simpleName . equalsIgnoreCase ( possibleMethod . getName ( ) ) ) { method = possibleMethod ; break ; } } return method ; }
Battsooj/gocd | public static void setNail ( BuildrNail _nail ) { nail = _nail ; }
Battsooj/gocd | public static void nailMain ( NGContext ctx ) { nail . main ( ctx ) ; }
thombergs/wicked-charts | public static List < ConstLabel > of ( String ... texts ) { List < ConstLabel > resultList = new ArrayList < ConstLabel > ( ) ; for ( String text : texts ) { resultList . add ( new ConstLabel ( text ) ) ; } return resultList ; }
thombergs/wicked-charts | public static List < ConstLabel > of ( List < String > textList ) { List < ConstLabel > resultList = new ArrayList < ConstLabel > ( ) ; for ( String text : textList ) { resultList . add ( new ConstLabel ( text ) ) ; } return resultList ; }
Nzen/PD-Litmus | public static void main ( String [ ] args ) { LitmusFrame representsPd = new LitmusFrame ( ) ; }
freeVM/freeVM | public static void main ( String [ ] args ) { junit . textui . TestRunner . run ( XGraphics2DRTest . class ) ; }
Bragaman/atom | public static void main ( String [ ] args ) throws Exception { out . println ( VM . current ( ) . details ( ) ) ; PrintWriter pw = new PrintWriter ( out , true ) ; long last = VM . current ( ) . addressOf ( new Object ( ) ) ; for ( int l = 0 ; l < 1000 * 1000 * 1000 ; l ++ ) { long current = VM . current ( ) . addressOf ( new Object ( ) ) ; long distance = Math . abs ( current - last ) ; if ( distance > 16 * 1024 ) { pw . printf ( " Jumping ▁ from ▁ % x ▁ to ▁ % x ▁ ( distance ▁ = ▁ % d ▁ bytes , ▁ % dK , ▁ % dM ) % n " , last , current , distance , distance / 1024 , distance / 1024 / 1024 ) ; } last = current ; } pw . close ( ) ; }
allotria/intellij-community | public static VirtualEnvSdkFlavor getInstance ( ) { return PythonSdkFlavor . EP_NAME . findExtension ( VirtualEnvSdkFlavor . class ) ; }
allotria/intellij-community | @ Nullable public static VirtualFile getPyEnvDefaultLocations ( ) { final String path = System . getenv ( ) . get ( " PYENV _ ROOT " ) ; if ( ! StringUtil . isEmpty ( path ) ) { final VirtualFile pyEnvRoot = LocalFileSystem . getInstance ( ) . findFileByPath ( FileUtil . expandUserHome ( path ) . replace ( ' \ \' , ' / ' ) ) ; if ( pyEnvRoot != null ) { return pyEnvRoot . findFileByRelativePath ( " versions " ) ; } } final VirtualFile userHome = LocalFileSystem . getInstance ( ) . findFileByPath ( SystemProperties . getUserHome ( ) . replace ( ' \ \' , ' / ' ) ) ; if ( userHome != null ) { return userHome . findFileByRelativePath ( " . pyenv / versions " ) ; } return null ; }
allotria/intellij-community | public static VirtualFile getDefaultLocation ( ) { final String path = System . getenv ( ) . get ( " WORKON _ HOME " ) ; if ( ! StringUtil . isEmpty ( path ) ) { return LocalFileSystem . getInstance ( ) . findFileByPath ( FileUtil . expandUserHome ( path ) . replace ( ' \ \' , ' / ' ) ) ; } final VirtualFile userHome = LocalFileSystem . getInstance ( ) . findFileByPath ( SystemProperties . getUserHome ( ) . replace ( ' \ \' , ' / ' ) ) ; if ( userHome != null ) { final VirtualFile predefinedFolder = userHome . findChild ( " . virtualenvs " ) ; if ( predefinedFolder == null ) return userHome ; return predefinedFolder ; } return null ; }
allotria/intellij-community | public static Collection < String > findInBaseDirectory ( @ Nullable VirtualFile baseDir ) { List < String > candidates = new ArrayList < > ( ) ; if ( baseDir != null ) { baseDir . refresh ( true , false ) ; VirtualFile [ ] suspects = baseDir . getChildren ( ) ; for ( VirtualFile child : suspects ) { candidates . addAll ( findInRootDirectory ( child ) ) ; } } return candidates ; }
allotria/intellij-community | @ NotNull public static Collection < String > findInRootDirectory ( @ Nullable VirtualFile rootDir ) { final List < String > candidates = new ArrayList < > ( ) ; if ( rootDir != null && rootDir . isDirectory ( ) ) { final VirtualFile bin = rootDir . findChild ( " bin " ) ; final VirtualFile scripts = rootDir . findChild ( " Scripts " ) ; if ( bin != null ) { final String interpreter = findInterpreter ( bin ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } if ( scripts != null ) { final String interpreter = findInterpreter ( scripts ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } if ( candidates . isEmpty ( ) ) { final String interpreter = findInterpreter ( rootDir ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } } return candidates ; }
allotria/intellij-community | @ Nullable private static String findInterpreter ( VirtualFile dir ) { for ( VirtualFile child : dir . getChildren ( ) ) { if ( ! child . isDirectory ( ) ) { final String childName = StringUtil . toLowerCase ( child . getName ( ) ) ; for ( String name : NAMES ) { if ( SystemInfo . isWindows ) { if ( childName . equals ( name ) ) { return FileUtil . toSystemDependentName ( child . getPath ( ) ) ; } } else { if ( childName . startsWith ( name ) || PYTHON_RE . matcher ( childName ) . matches ( ) ) { if ( ! childName . endsWith ( " - config " ) ) { return child . getPath ( ) ; } } } } } } return null ; }
cstudioteam/csFrame | public static FWLogName setLogName ( FWLogName name ) { FWLogName currenLogName = getCurrentLogName ( ) ; if ( name == null ) { remove ( LOG_NAME ) ; } else { MDC . put ( LOG_NAME , name . toString ( ) ) ; } return currenLogName ; }
cstudioteam/csFrame | public static FWLogName getCurrentLogName ( ) { String logName = MDC . get ( LOG_NAME ) ; FWLogName retName = null ; if ( logName != null ) { retName = FWLogName . valueOf ( logName ) ; } return retName ; }
cstudioteam/csFrame | public static void clear ( ) { MDC . clear ( ) ; }
cstudioteam/csFrame | public static void put ( String key , String value ) { MDC . put ( key , value ) ; }
cstudioteam/csFrame | public static void remove ( String key ) { MDC . remove ( key ) ; }
TopQuadrant/shacl | public static ExtendedIterator < RDFNode > distinct ( ExtendedIterator < RDFNode > base ) { Set < RDFNode > seen = new HashSet < > ( ) ; return recording ( rejecting ( base , seen ) , seen ) ; }
TopQuadrant/shacl | private static < T > ExtendedIterator < T > recording ( ClosableIterator < T > i , Set < T > seen ) { return new NiceIterator < T > ( ) { @ Override public void remove ( ) { i . remove ( ) ; } @ Override public boolean hasNext ( ) { return i . hasNext ( ) ; } @ Override public T next ( ) { T x = i . next ( ) ; seen . add ( x ) ; return x ; } @ Override public void close ( ) { i . close ( ) ; } } ; }
TopQuadrant/shacl | private static ExtendedIterator < RDFNode > rejecting ( ExtendedIterator < RDFNode > i , Set < RDFNode > seen ) { return i . filterDrop ( seen :: contains ) ; }
uvasoftware/scanii-java | public static < T > T load ( String js , Class < T > valueType ) { try { return mapper . readValue ( js , valueType ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
uvasoftware/scanii-java | public static JsonNode load ( String js ) { try { return mapper . readTree ( js ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
AsciiBunny/Bunny-Control-System | public static void main ( String [ ] args ) throws IOException { BunnyServer server ; if ( args . length > 0 ) server = new BunnyServer ( Integer . parseInt ( args [ 0 ] ) , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; else server = new BunnyServer ( ) ; Thread t = new Thread ( server ) ; t . start ( ) ; }
Syncleus/AetherMUD | private static String getItem ( String fullCommand ) { if ( ! StringUtils . containsIgnoreCase ( fullCommand , ON_KEYWORD ) ) { return fullCommand ; } List < String > parts = Arrays . asList ( fullCommand . split ( " ( ? i ) " + ON_KEYWORD , 2 ) ) ; String item = parts . get ( 0 ) ; return item . trim ( ) ; }
Syncleus/AetherMUD | private static Optional < String > getItemTarget ( String fullCommand ) { if ( ! StringUtils . containsIgnoreCase ( fullCommand , ON_KEYWORD ) ) { return Optional . empty ( ) ; } List < String > parts = Arrays . asList ( fullCommand . split ( " ( ? i ) " + ON_KEYWORD , 2 ) ) ; if ( parts . size ( ) > 1 ) { String item = parts . get ( 1 ) ; return Optional . of ( item . trim ( ) ) ; } return Optional . empty ( ) ; }
miniway/presto | public static Builder builder ( ColumnMetadata ... columns ) { return builder ( ImmutableList . copyOf ( columns ) ) ; }
miniway/presto | public static Builder builder ( List < ColumnMetadata > columns ) { ImmutableList . Builder < String > names = ImmutableList . builder ( ) ; ImmutableList . Builder < Type > types = ImmutableList . builder ( ) ; for ( ColumnMetadata column : columns ) { names . add ( column . getName ( ) ) ; types . add ( column . getType ( ) ) ; } return new Builder ( names . build ( ) , types . build ( ) ) ; }
flyzsd/java-code-snippets | private static JMXConnectorServer getConnectorServerAsService ( ClassLoader loader , JMXServiceURL url , Map < String , ? > map , MBeanServer mbs ) throws IOException { Iterator < JMXConnectorServerProvider > providers = JMXConnectorFactory . getProviderIterator ( JMXConnectorServerProvider . class , loader ) ; IOException exception = null ; while ( providers . hasNext ( ) ) { try { return providers . next ( ) . newJMXConnectorServer ( url , map , mbs ) ; } catch ( JMXProviderException e ) { throw e ; } catch ( Exception e ) { if ( logger . traceOn ( ) ) logger . trace ( " getConnectorAsService " , " URL [ " + url + " ] ▁ Service ▁ provider ▁ exception : ▁ " + e ) ; if ( ! ( e instanceof MalformedURLException ) ) { if ( exception == null ) { if ( e instanceof IOException ) { exception = ( IOException ) e ; } else { exception = EnvHelp . initCause ( new IOException ( e . getMessage ( ) ) , e ) ; } } } continue ; } } if ( exception == null ) return null ; else throw exception ; }
flyzsd/java-code-snippets | public static JMXConnectorServer newJMXConnectorServer ( JMXServiceURL serviceURL , Map < String , ? > environment , MBeanServer mbeanServer ) throws IOException { Map < String , Object > envcopy ; if ( environment == null ) envcopy = new HashMap < String , Object > ( ) ; else { EnvHelp . checkAttributes ( environment ) ; envcopy = new HashMap < String , Object > ( environment ) ; } final Class < JMXConnectorServerProvider > targetInterface = JMXConnectorServerProvider . class ; final ClassLoader loader = JMXConnectorFactory . resolveClassLoader ( envcopy ) ; final String protocol = serviceURL . getProtocol ( ) ; final String providerClassName = " ServerProvider " ; JMXConnectorServerProvider provider = JMXConnectorFactory . getProvider ( serviceURL , envcopy , providerClassName , targetInterface , loader ) ; IOException exception = null ; if ( provider == null ) { if ( loader != null ) { try { JMXConnectorServer connection = getConnectorServerAsService ( loader , serviceURL , envcopy , mbeanServer ) ; if ( connection != null ) return connection ; } catch ( JMXProviderException e ) { throw e ; } catch ( IOException e ) { exception = e ; } } provider = JMXConnectorFactory . getProvider ( protocol , PROTOCOL_PROVIDER_DEFAULT_PACKAGE , JMXConnectorFactory . class . getClassLoader ( ) , providerClassName , targetInterface ) ; } if ( provider == null ) { MalformedURLException e = new MalformedURLException ( " Unsupported ▁ protocol : ▁ " + protocol ) ; if ( exception == null ) { throw e ; } else { throw EnvHelp . initCause ( e , exception ) ; } } envcopy = Collections . unmodifiableMap ( envcopy ) ; return provider . newJMXConnectorServer ( serviceURL , envcopy , mbeanServer ) ; }
gosu-lang/old-gosu-repo | public static CompilerSettings getInstance ( ) { return ServiceManager . getService ( CompilerSettings . class ) ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Barcode > toBarcodeMap ( ResultSet resultSet ) throws SQLException { Map < Integer , Barcode > result = new HashMap < Integer , Barcode > ( ) ; while ( resultSet . next ( ) ) { Barcode barcode = new Barcode ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; result . put ( resultSet . getInt ( 1 ) , barcode ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Company > toCompanyMap ( ResultSet resultSet ) throws SQLException { Map < Integer , Company > result = new HashMap < Integer , Company > ( ) ; while ( resultSet . next ( ) ) { Company company = new Company ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getString ( 3 ) , resultSet . getString ( 4 ) , resultSet . getString ( 5 ) ) ; result . put ( resultSet . getInt ( 1 ) , company ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Item > toItemMap ( ResultSet resultSet , Map < Integer , Barcode > barcodeMap , Map < Integer , Company > companyMap ) throws SQLException { Map < Integer , Item > result = new HashMap < Integer , Item > ( ) ; while ( resultSet . next ( ) ) { Item item = new Item ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , companyMap . get ( resultSet . getInt ( 3 ) ) , barcodeMap . get ( resultSet . getInt ( 4 ) ) , resultSet . getString ( 5 ) ) ; result . put ( resultSet . getInt ( 1 ) , item ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , String > toItemTypeMap ( ResultSet resultSet ) throws SQLException { Map < Integer , String > result = new HashMap < Integer , String > ( ) ; while ( resultSet . next ( ) ) { result . put ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Location > toLocationMap ( ResultSet resultSet ) throws SQLException { Map < Integer , Location > result = new HashMap < Integer , Location > ( ) ; while ( resultSet . next ( ) ) { Location location = new Location ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getInt ( 3 ) , resultSet . getInt ( 4 ) ) ; result . put ( resultSet . getInt ( 1 ) , location ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , String > toPrivilegesMap ( ResultSet resultSet ) throws SQLException { Map < Integer , String > result = new HashMap < Integer , String > ( ) ; while ( resultSet . next ( ) ) { result . put ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , User > toUserMap ( ResultSet resultSet ) throws SQLException { Map < Integer , User > result = new HashMap < Integer , User > ( ) ; while ( resultSet . next ( ) ) { User user = new User ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getString ( 4 ) , resultSet . getInt ( 5 ) ) ; user . setHash ( resultSet . getString ( 3 ) ) ; result . put ( resultSet . getInt ( 1 ) , user ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Inventory > toInventoryMap ( ResultSet resultSet , Map < Integer , Item > itemMap , Map < Integer , Company > companyMap , Map < Integer , Location > locationMap , Map < Integer , Barcode > barcodeMap ) throws SQLException { Map < Integer , Inventory > result = new HashMap < Integer , Inventory > ( ) ; while ( resultSet . next ( ) ) { Inventory inventory = new Inventory ( resultSet . getInt ( 1 ) , itemMap . get ( resultSet . getInt ( 2 ) ) , resultSet . getInt ( 3 ) , companyMap . get ( resultSet . getInt ( 4 ) ) , resultSet . getInt ( 5 ) , resultSet . getInt ( 6 ) , resultSet . getDate ( 7 ) , resultSet . getDate ( 8 ) , locationMap . get ( resultSet . getInt ( 9 ) ) , barcodeMap . get ( resultSet . getInt ( 10 ) ) ) ; result . put ( resultSet . getInt ( 1 ) , inventory ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | public static int getMaxResult ( ResultSet resultSet ) throws SQLException { resultSet . next ( ) ; return resultSet . getInt ( 1 ) ; }
apacheignite/ignite | public static C1 < IgniteCheckedException , IgniteException > getExceptionConverter ( Class < ? extends IgniteCheckedException > clazz ) { return exceptionConverters . get ( clazz ) ; }
apacheignite/ignite | private static Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , IgniteException > > exceptionConverters ( ) { Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , IgniteException > > m = new HashMap < > ( ) ; m . put ( IgniteInterruptedCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteInterruptedException ( e . getMessage ( ) , ( InterruptedException ) e . getCause ( ) ) ; } } ) ; m . put ( IgniteFutureCancelledCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteFutureCancelledException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteFutureTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteFutureTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ClusterGroupEmptyCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ClusterGroupEmptyException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ClusterTopologyCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { ClusterTopologyException topEx = new ClusterTopologyException ( e . getMessage ( ) , e ) ; ClusterTopologyCheckedException checked = ( ClusterTopologyCheckedException ) e ; if ( checked . retryReadyFuture ( ) != null ) topEx . retryReadyFuture ( new IgniteFutureImpl < > ( checked . retryReadyFuture ( ) ) ) ; return topEx ; } } ) ; m . put ( IgniteDeploymentCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteDeploymentException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ComputeTaskTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ComputeTaskTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ComputeTaskCancelledCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ComputeTaskCancelledException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxRollbackCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionRollbackException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxHeuristicCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionHeuristicException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxOptimisticCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionOptimisticException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteClientDisconnectedCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteClientDisconnectedException ( ( ( IgniteClientDisconnectedCheckedException ) e ) . reconnectFuture ( ) , e . getMessage ( ) , e ) ; } } ) ; return m ; }
apacheignite/ignite | public static List < PluginProvider > allPluginProviders ( ) { return AccessController . doPrivileged ( new PrivilegedAction < List < PluginProvider > > ( ) { @ Override public List < PluginProvider > run ( ) { List < PluginProvider > providers = new ArrayList < > ( ) ; ServiceLoader < PluginProvider > ldr = ServiceLoader . load ( PluginProvider . class ) ; for ( PluginProvider provider : ldr ) providers . add ( provider ) ; return providers ; } } ) ; }
apacheignite/ignite | public static Exception convertExceptionNoWrap ( IgniteCheckedException e ) { C1 < IgniteCheckedException , IgniteException > converter = exceptionConverters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof IgniteException ) return ( Exception ) e . getCause ( ) ; return e ; }
apacheignite/ignite | public static IgniteException convertException ( IgniteCheckedException e ) { IgniteClientDisconnectedException e0 = e . getCause ( IgniteClientDisconnectedException . class ) ; if ( e0 != null ) { assert e0 . reconnectFuture ( ) != null : e0 ; throw e0 ; } IgniteClientDisconnectedCheckedException disconnectedErr = e . getCause ( IgniteClientDisconnectedCheckedException . class ) ; if ( disconnectedErr != null ) { assert disconnectedErr . reconnectFuture ( ) != null : disconnectedErr ; e = disconnectedErr ; } C1 < IgniteCheckedException , IgniteException > converter = exceptionConverters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof IgniteException ) return ( IgniteException ) e . getCause ( ) ; return new IgniteException ( e . getMessage ( ) , e ) ; }
apacheignite/ignite | public static long currentTimeMillis ( ) { return curTimeMillis ; }
apacheignite/ignite | public static long microTime ( ) { return System . nanoTime ( ) / 1000 ; }
apacheignite/ignite | public static int ceilPow2 ( int v ) { return Integer . highestOneBit ( v - 1 ) << 1 ; }
apacheignite/ignite | public static boolean isPow2 ( int i ) { return i > 0 && ( i & ( i - 1 ) ) == 0 ; }
apacheignite/ignite | @ Nullable public static Method ctorFactory ( ) { return CTOR_FACTORY ; }
apacheignite/ignite | public static Constructor objectConstructor ( ) { return OBJECT_CTOR ; }
apacheignite/ignite | @ Nullable public static Object sunReflectionFactory ( ) { return SUN_REFLECT_FACTORY ; }
apacheignite/ignite | public static String gridEventName ( int type ) { String name = GRID_EVT_NAMES . get ( type ) ; return name != null ? name : Integer . toString ( type ) ; }
apacheignite/ignite | public static int [ ] gridEvents ( final int ... excl ) { if ( F . isEmpty ( excl ) ) return GRID_EVTS ; List < Integer > evts = toIntList ( GRID_EVTS , new P1 < Integer > ( ) { @ Override public boolean apply ( Integer i ) { return ! containsIntArray ( excl , i ) ; } } ) ; return toIntArray ( evts ) ; }
apacheignite/ignite | public static boolean discoOrdered ( DiscoverySpi discoSpi ) { DiscoverySpiOrderSupport ann = U . getAnnotation ( discoSpi . getClass ( ) , DiscoverySpiOrderSupport . class ) ; return ann != null && ann . value ( ) ; }
apacheignite/ignite | public static boolean relaxDiscoveryOrdered ( ) { return " true " . equalsIgnoreCase ( System . getProperty ( IGNITE_NO_DISCO_ORDER ) ) ; }
apacheignite/ignite | @ Deprecated public static void debug ( Object msg ) { X . error ( debugPrefix ( ) + msg ) ; }
apacheignite/ignite | @ Deprecated public static void debugx ( String msg ) { X . printerrln ( debugPrefix ( ) + msg ) ; }
apacheignite/ignite | @ Deprecated public static void debug ( IgniteLogger log , String msg ) { log . info ( msg ) ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( ) { dumpStack ( " Dumping ▁ stack . " ) ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( String msg ) { new Exception ( debugPrefix ( ) + msg ) . printStackTrace ( System . out ) ; }
apacheignite/ignite | public static void dumpStack ( @ Nullable IgniteLogger log , String msg ) { U . error ( log , " Dumping ▁ stack . " , new Exception ( msg ) ) ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( String msg , PrintStream out ) { new Exception ( msg ) . printStackTrace ( out ) ; }
apacheignite/ignite | @ Deprecated public static void debugStack ( IgniteLogger log , String msg ) { log . error ( msg , new Exception ( debugPrefix ( ) + msg ) ) ; }
apacheignite/ignite | private static String debugPrefix ( ) { return ' < ' + DEBUG_DATE_FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + ' > ' + ' ▁ ' ; }
apacheignite/ignite | public static void debugHeapUsage ( ) { System . gc ( ) ; Runtime runtime = Runtime . getRuntime ( ) ; X . println ( ' < ' + DEBUG_DATE_FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + " > ▁ Heap ▁ stats ▁ [ free = " + runtime . freeMemory ( ) / ( 1024 * 1024 ) + " M , ▁ total = " + runtime . totalMemory ( ) / ( 1024 * 1024 ) + " M ] " ) ; }
apacheignite/ignite | public static double heapSize ( ClusterNode node , int precision ) { return heapSize ( Collections . singleton ( node ) , precision ) ; }
apacheignite/ignite | public static double heapSize ( Iterable < ClusterNode > nodes , int precision ) { double heap = 0.0 ; for ( ClusterNode n : nodesPerJvm ( nodes ) ) { ClusterMetrics m = n . metrics ( ) ; heap += Math . max ( m . getHeapMemoryInitialized ( ) , m . getHeapMemoryMaximum ( ) ) ; } return roundedHeapSize ( heap , precision ) ; }
apacheignite/ignite | private static Iterable < ClusterNode > nodesPerJvm ( Iterable < ClusterNode > nodes ) { Map < String , ClusterNode > grpMap = new HashMap < > ( ) ; for ( ClusterNode node : nodes ) { String grpId = node . attribute ( ATTR_MACS ) + " | " + node . attribute ( ATTR_JVM_PID ) ; if ( ! grpMap . containsKey ( grpId ) ) grpMap . put ( grpId , node ) ; } return grpMap . values ( ) ; }
apacheignite/ignite | public static double heapSize ( int precision ) { return roundedHeapSize ( Runtime . getRuntime ( ) . maxMemory ( ) , precision ) ; }
apacheignite/ignite | private static double roundedHeapSize ( double heap , int precision ) { double rounded = new BigDecimal ( heap / ( 1024 * 1024 * 1024d ) ) . round ( new MathContext ( precision ) ) . doubleValue ( ) ; return rounded < 0.1 ? 0.1 : rounded ; }
apacheignite/ignite | public static void dumpThreads ( @ Nullable IgniteLogger log ) { ThreadMXBean mxBean = ManagementFactory . getThreadMXBean ( ) ; final Set < Long > deadlockedThreadsIds = getDeadlockedThreadIds ( mxBean ) ; if ( deadlockedThreadsIds . size ( ) == 0 ) warn ( log , " No ▁ deadlocked ▁ threads ▁ detected . " ) ; else warn ( log , " Deadlocked ▁ threads ▁ detected ▁ ( see ▁ thread ▁ dump ▁ below ) ▁ " + " [ deadlockedThreadsCnt = " + deadlockedThreadsIds . size ( ) + ' ] ' ) ; ThreadInfo [ ] threadInfos = mxBean . dumpAllThreads ( mxBean . isObjectMonitorUsageSupported ( ) , mxBean . isSynchronizerUsageSupported ( ) ) ; GridStringBuilder sb = new GridStringBuilder ( " Thread ▁ dump ▁ at ▁ " ) . a ( new SimpleDateFormat ( " yyyy / MM / dd ▁ HH : mm : ss ▁ z " ) . format ( new Date ( U . currentTimeMillis ( ) ) ) ) . a ( NL ) ; for ( ThreadInfo info : threadInfos ) { printThreadInfo ( info , sb , deadlockedThreadsIds ) ; sb . a ( NL ) ; if ( info . getLockedSynchronizers ( ) != null && info . getLockedSynchronizers ( ) . length > 0 ) { printSynchronizersInfo ( info . getLockedSynchronizers ( ) , sb ) ; sb . a ( NL ) ; } } sb . a ( NL ) ; warn ( log , sb . toString ( ) ) ; }
apacheignite/ignite | private static Set < Long > getDeadlockedThreadIds ( ThreadMXBean mxBean ) { final long [ ] deadlockedIds = mxBean . findDeadlockedThreads ( ) ; final Set < Long > deadlockedThreadsIds ; if ( ! F . isEmpty ( deadlockedIds ) ) { Set < Long > set = new HashSet < > ( ) ; for ( long id : deadlockedIds ) set . add ( id ) ; deadlockedThreadsIds = Collections . unmodifiableSet ( set ) ; } else deadlockedThreadsIds = Collections . emptySet ( ) ; return deadlockedThreadsIds ; }
apacheignite/ignite | private static void printThreadInfo ( ThreadInfo threadInfo , GridStringBuilder sb , Set < Long > deadlockedIdSet ) { final long id = threadInfo . getThreadId ( ) ; if ( deadlockedIdSet . contains ( id ) ) sb . a ( " # # # # # ▁ DEADLOCKED ▁ " ) ; sb . a ( " Thread ▁ [ name = \" " ) . a ( threadInfo . getThreadName ( ) ) . a ( " \" , ▁ id = " ) . a ( threadInfo . getThreadId ( ) ) . a ( " , ▁ state = " ) . a ( threadInfo . getThreadState ( ) ) . a ( " , ▁ blockCnt = " ) . a ( threadInfo . getBlockedCount ( ) ) . a ( " , ▁ waitCnt = " ) . a ( threadInfo . getWaitedCount ( ) ) . a ( " ] " ) . a ( NL ) ; LockInfo lockInfo = threadInfo . getLockInfo ( ) ; if ( lockInfo != null ) { sb . a ( " ▁ ▁ ▁ ▁ Lock ▁ [ object = " ) . a ( lockInfo ) . a ( " , ▁ ownerName = " ) . a ( threadInfo . getLockOwnerName ( ) ) . a ( " , ▁ ownerId = " ) . a ( threadInfo . getLockOwnerId ( ) ) . a ( " ] " ) . a ( NL ) ; } MonitorInfo [ ] monitors = threadInfo . getLockedMonitors ( ) ; StackTraceElement [ ] elements = threadInfo . getStackTrace ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { StackTraceElement e = elements [ i ] ; sb . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ at ▁ " ) . a ( e . toString ( ) ) ; for ( MonitorInfo monitor : monitors ) { if ( monitor . getLockedStackDepth ( ) == i ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ locked ▁ " ) . a ( monitor ) ; } sb . a ( NL ) ; } }
apacheignite/ignite | private static void printSynchronizersInfo ( LockInfo [ ] syncs , GridStringBuilder sb ) { sb . a ( " ▁ ▁ ▁ ▁ Locked ▁ synchronizers : " ) ; for ( LockInfo info : syncs ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) . a ( info ) ; }
apacheignite/ignite | @ Nullable public static Constructor < ? > forceEmptyConstructor ( Class < ? > cls ) throws IgniteCheckedException { Constructor < ? > ctor = null ; try { return cls . getDeclaredConstructor ( ) ; } catch ( Exception ignore ) { Method ctorFac = U . ctorFactory ( ) ; Object sunRefFac = U . sunReflectionFactory ( ) ; if ( ctorFac != null && sunRefFac != null ) try { ctor = ( Constructor ) ctorFac . invoke ( sunRefFac , cls , U . objectConstructor ( ) ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ object ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } } return ctor ; }
apacheignite/ignite | @ Nullable public static Class < ? > classForName ( String cls , @ Nullable Class < ? > dflt ) { try { return cls == null ? dflt : Class . forName ( cls ) ; } catch ( ClassNotFoundException ignore ) { return dflt ; } }
apacheignite/ignite | @ Nullable public static < T > T newInstance ( String cls ) throws IgniteCheckedException { Class < ? > cls0 ; try { cls0 = Class . forName ( cls ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } return ( T ) newInstance ( cls0 ) ; }
apacheignite/ignite | @ Nullable public static < T > T newInstance ( Class < T > cls ) throws IgniteCheckedException { boolean set = false ; Constructor < T > ctor = null ; try { ctor = cls . getDeclaredConstructor ( ) ; if ( ctor == null ) return null ; if ( ! ctor . isAccessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ctor . newInstance ( ) ; } catch ( NoSuchMethodException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ find ▁ empty ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( ctor != null && set ) ctor . setAccessible ( false ) ; } }
apacheignite/ignite | ) @ Nullable public static < T > T forceNewInstance ( Class < ? > cls ) throws IgniteCheckedException { Constructor ctor = forceEmptyConstructor ( cls ) ; if ( ctor == null ) return null ; boolean set = false ; try { if ( ! ctor . isAccessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ( T ) ctor . newInstance ( ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( set ) ctor . setAccessible ( false ) ; } }
apacheignite/ignite | public static String formatMins ( long mins ) { assert mins >= 0 ; if ( mins == 0 ) return " < ▁ 1 ▁ min " ; SB sb = new SB ( ) ; long dd = mins / 1440 ; if ( dd > 0 ) sb . a ( dd ) . a ( dd == 1 ? " ▁ day ▁ " : " ▁ days ▁ " ) ; mins %= 1440 ; long hh = mins / 60 ; if ( hh > 0 ) sb . a ( hh ) . a ( hh == 1 ? " ▁ hour ▁ " : " ▁ hours ▁ " ) ; mins %= 60 ; if ( mins > 0 ) sb . a ( mins ) . a ( mins == 1 ? " ▁ min ▁ " : " ▁ mins ▁ " ) ; return sb . toString ( ) . trim ( ) ; }
apacheignite/ignite | public static String id8 ( UUID id ) { return id . toString ( ) . substring ( 0 , 8 ) ; }
apacheignite/ignite | public static String id8 ( IgniteUuid id ) { String s = id . toString ( ) ; return s . substring ( 0 , 4 ) + s . substring ( s . length ( ) - 4 ) ; }
apacheignite/ignite | public static String filler ( int len , char ch ) { char [ ] a = new char [ len ] ; Arrays . fill ( a , ch ) ; return new String ( a ) ; }
apacheignite/ignite | public static < T > void writeArray ( ObjectOutput out , T [ ] arr ) throws IOException { int len = arr == null ? 0 : arr . length ; out . writeInt ( len ) ; if ( arr != null && arr . length > 0 ) for ( T t : arr ) out . writeObject ( t ) ; }
apacheignite/ignite | public static void writeCollection ( ObjectOutput out , Collection < ? > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Object o : col ) out . writeObject ( o ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static void writeIntCollection ( DataOutput out , Collection < Integer > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Integer i : col ) out . writeInt ( i ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | @ Nullable public static Collection < Integer > readIntCollection ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Collection < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
apacheignite/ignite | public static < K , V > Map < K , V > copyMap ( Map < K , V > m ) { return new HashMap < > ( m ) ; }
apacheignite/ignite | public static < K , V > Map < K , V > sealMap ( Map < K , V > m ) { assert m != null ; return Collections . unmodifiableMap ( new HashMap < > ( m ) ) ; }
apacheignite/ignite | public static < E > List < E > sealList ( Collection < E > c ) { return Collections . unmodifiableList ( new ArrayList < > ( c ) ) ; }
apacheignite/ignite | public static < E > List < E > sealList ( E ... a ) { return Collections . unmodifiableList ( Arrays . asList ( a ) ) ; }
apacheignite/ignite | @ Nullable public static String getNetworkInterfaceName ( String addr ) { assert addr != null ; try { InetAddress inetAddr = InetAddress . getByName ( addr ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) for ( InetAddress itfAddr : asIterable ( itf . getInetAddresses ( ) ) ) if ( itfAddr . equals ( inetAddr ) ) return itf . getDisplayName ( ) ; } catch ( UnknownHostException ignore ) { return null ; } catch ( SocketException ignore ) { return null ; } return null ; }
apacheignite/ignite | public static InetAddress resolveLocalHost ( @ Nullable String hostName ) throws IOException { return F . isEmpty ( hostName ) ? new InetSocketAddress ( 0 ) . getAddress ( ) : InetAddress . getByName ( hostName ) ; }
apacheignite/ignite | public static synchronized boolean isLocalHostChanged ( ) throws IOException { InetAddress locHost0 = locHost ; return locHost0 != null && ! resetLocalHost ( ) . equals ( locHost0 ) ; }
apacheignite/ignite | public static List < InetAddress > filterReachable ( List < InetAddress > addrs ) { final int reachTimeout = 2000 ; if ( addrs . isEmpty ( ) ) return Collections . emptyList ( ) ; if ( addrs . size ( ) == 1 ) { InetAddress addr = addrs . get ( 0 ) ; if ( reachable ( addr , reachTimeout ) ) return Collections . singletonList ( addr ) ; return Collections . emptyList ( ) ; } final List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Collection < Future < ? > > futs = new ArrayList < > ( addrs . size ( ) ) ; ExecutorService executor = Executors . newFixedThreadPool ( Math . min ( 10 , addrs . size ( ) ) ) ; for ( final InetAddress addr : addrs ) { futs . add ( executor . submit ( new Runnable ( ) { @ Override public void run ( ) { if ( reachable ( addr , reachTimeout ) ) { synchronized ( res ) { res . add ( addr ) ; } } } } ) ) ; } for ( Future < ? > fut : futs ) { try { fut . get ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteException ( " Thread ▁ has ▁ been ▁ interrupted . " , e ) ; } catch ( ExecutionException e ) { throw new IgniteException ( e ) ; } } executor . shutdown ( ) ; return res ; }
apacheignite/ignite | private static void addresses ( InetAddress addr , Collection < String > addrs , Collection < String > hostNames ) { String hostName = addr . getHostName ( ) ; String ipAddr = addr . getHostAddress ( ) ; addrs . add ( ipAddr ) ; if ( ! F . isEmpty ( hostName ) && ! addr . isLoopbackAddress ( ) ) hostNames . add ( hostName ) ; }
apacheignite/ignite | public static synchronized InetAddress getLocalHost ( ) throws IOException { if ( locHost == null ) resetLocalHost ( ) ; return locHost ; }
apacheignite/ignite | private static synchronized InetAddress resetLocalHost ( ) throws IOException { locHost = null ; String sysLocHost = IgniteSystemProperties . getString ( IGNITE_LOCAL_HOST ) ; if ( sysLocHost != null ) sysLocHost = sysLocHost . trim ( ) ; if ( ! F . isEmpty ( sysLocHost ) ) locHost = InetAddress . getByName ( sysLocHost ) ; else { List < NetworkInterface > itfs = new ArrayList < > ( ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) itfs . add ( itf ) ; Collections . sort ( itfs , new Comparator < NetworkInterface > ( ) { @ Override public int compare ( NetworkInterface itf1 , NetworkInterface itf2 ) { return itf1 . getName ( ) . compareTo ( itf2 . getName ( ) ) ; } } ) ; int reachTimeout = 2000 ; for ( NetworkInterface itf : itfs ) { boolean found = false ; for ( InetAddress addr : asIterable ( itf . getInetAddresses ( ) ) ) { if ( ! addr . isLoopbackAddress ( ) && ! addr . isLinkLocalAddress ( ) && reachable ( itf , addr , reachTimeout ) ) { locHost = addr ; found = true ; break ; } } if ( found ) break ; } } if ( locHost == null ) locHost = InetAddress . getLocalHost ( ) ; return locHost ; }
apacheignite/ignite | public static boolean reachable ( NetworkInterface itf , InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( itf , 0 , reachTimeout ) ; } catch ( IOException ignore ) { return false ; } }
apacheignite/ignite | public static boolean reachable ( InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( reachTimeout ) ; } catch ( IOException ignore ) { return false ; } }
apacheignite/ignite | public static boolean sameMacs ( ClusterNode loc , ClusterNode rmt ) { assert loc != null ; assert rmt != null ; String locMacs = loc . attribute ( IgniteNodeAttributes . ATTR_MACS ) ; String rmtMacs = rmt . attribute ( IgniteNodeAttributes . ATTR_MACS ) ; return locMacs != null && locMacs . equals ( rmtMacs ) ; }
apacheignite/ignite | public static synchronized Collection < String > allLocalIps ( ) { List < String > ips = new ArrayList < > ( 4 ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { if ( ! itf . isLoopback ( ) ) { Enumeration < InetAddress > addrs = itf . getInetAddresses ( ) ; for ( InetAddress addr : asIterable ( addrs ) ) { String hostAddr = addr . getHostAddress ( ) ; if ( ! addr . isLoopbackAddress ( ) && ! ips . contains ( hostAddr ) ) ips . add ( hostAddr ) ; } } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( ips ) ; return ips ; }
apacheignite/ignite | public static synchronized Collection < String > allLocalMACs ( ) { List < String > macs = new ArrayList < > ( 3 ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { byte [ ] hwAddr = itf . getHardwareAddress ( ) ; if ( hwAddr != null && hwAddr . length > 0 ) { String mac = byteArray2HexString ( hwAddr ) ; if ( ! macs . contains ( mac ) ) macs . add ( mac ) ; } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( macs ) ; return macs ; }
apacheignite/ignite | public static File downloadUrl ( URL url , File file ) throws IOException { assert url != null ; assert file != null ; InputStream in = null ; OutputStream out = null ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpsURLConnection ) { HttpsURLConnection https = ( HttpsURLConnection ) conn ; https . setHostnameVerifier ( new DeploymentHostnameVerifier ( ) ) ; SSLContext ctx = SSLContext . getInstance ( HTTPS_PROTOCOL ) ; ctx . init ( null , getTrustManagers ( ) , null ) ; https . setSSLSocketFactory ( ctx . getSocketFactory ( ) ) ; } in = conn . getInputStream ( ) ; if ( in == null ) throw new IOException ( " Failed ▁ to ▁ open ▁ connection : ▁ " + url . toString ( ) ) ; out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; copy ( in , out ) ; } catch ( NoSuchAlgorithmException | KeyManagementException e ) { throw new IOException ( " Failed ▁ to ▁ open ▁ HTTPs ▁ connection ▁ [ url = " + url . toString ( ) + " , ▁ msg = " + e + ' ] ' , e ) ; } finally { close ( in , null ) ; close ( out , null ) ; } return file ; }
apacheignite/ignite | private static TrustManager [ ] getTrustManagers ( ) { return new TrustManager [ ] { new X509TrustManager ( ) { @ Nullable @ Override public X509Certificate [ ] getAcceptedIssuers ( ) { return null ; } @ Override public void checkClientTrusted ( X509Certificate [ ] certs , String authType ) { } @ Override public void checkServerTrusted ( X509Certificate [ ] certs , String authType ) { } } } ; }
apacheignite/ignite | @ Nullable public static String hidePassword ( @ Nullable String uri ) { if ( uri == null ) return null ; if ( Pattern . matches ( " . * : // ( . * : . * ) @ . * " , uri ) ) { int userInfoLastIdx = uri . indexOf ( ' @ ' ) ; assert userInfoLastIdx != - 1 ; String str = uri . substring ( 0 , userInfoLastIdx ) ; int userInfoStartIdx = str . lastIndexOf ( ' / ' ) ; str = str . substring ( userInfoStartIdx + 1 ) ; String [ ] params = str . split ( " ; " ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < params . length ; i ++ ) { int idx ; if ( ( idx = params [ i ] . indexOf ( ' : ' ) ) != - 1 ) params [ i ] = params [ i ] . substring ( 0 , idx + 1 ) + ' * ' ; builder . append ( params [ i ] ) ; if ( i != params . length - 1 ) builder . append ( ' ; ' ) ; } return new StringBuilder ( uri ) . replace ( userInfoStartIdx + 1 , userInfoLastIdx , builder . toString ( ) ) . toString ( ) ; } return uri ; }
apacheignite/ignite | public static ClassLoader gridClassLoader ( ) { return gridClassLoader ; }
apacheignite/ignite | public static boolean hasParent ( @ Nullable ClassLoader parent , ClassLoader ldr ) { if ( parent != null ) { for ( ; ldr != null ; ldr = ldr . getParent ( ) ) { if ( ldr . equals ( parent ) ) return true ; } return false ; } return true ; }
apacheignite/ignite | public static void writeBytesCollection ( DataOutput out , Collection < byte [ ] > bytes ) throws IOException { if ( bytes != null ) { out . writeInt ( bytes . size ( ) ) ; for ( byte [ ] b : bytes ) writeByteArray ( out , b ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static List < byte [ ] > readBytesList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size < 0 ) return null ; List < byte [ ] > res = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) res . add ( readByteArray ( in ) ) ; return res ; }
apacheignite/ignite | public static void writeByteArray ( DataOutput out , @ Nullable byte [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; out . write ( arr ) ; } }
apacheignite/ignite | public static void writeByteArray ( DataOutput out , @ Nullable byte [ ] arr , int maxLen ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { int len = Math . min ( arr . length , maxLen ) ; out . writeInt ( len ) ; out . write ( arr , 0 , len ) ; } }
apacheignite/ignite | @ Nullable public static byte [ ] readByteArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; byte [ ] res = new byte [ len ] ; in . readFully ( res ) ; return res ; }
apacheignite/ignite | public static byte [ ] readByteArray ( ByteBuffer ... bufs ) { assert ! F . isEmpty ( bufs ) ; int size = 0 ; for ( ByteBuffer buf : bufs ) size += buf . remaining ( ) ; byte [ ] res = new byte [ size ] ; int off = 0 ; for ( ByteBuffer buf : bufs ) { int len = buf . remaining ( ) ; if ( len != 0 ) { buf . get ( res , off , len ) ; off += len ; } } assert off == res . length ; return res ; }
apacheignite/ignite | public static void writeByteCollection ( DataOutput out , Collection < Byte > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Byte i : col ) out . writeByte ( i ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | @ Nullable public static List < Byte > readByteList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Byte > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readByte ( ) ) ; return col ; }
apacheignite/ignite | public static byte [ ] join ( byte [ ] ... bufs ) { int size = 0 ; for ( byte [ ] buf : bufs ) { size += buf . length ; } byte [ ] res = new byte [ size ] ; int position = 0 ; for ( byte [ ] buf : bufs ) { arrayCopy ( buf , 0 , res , position , buf . length ) ; position += buf . length ; } return res ; }
apacheignite/ignite | public static String byteArray2String ( byte [ ] arr , String hdrFmt , String bodyFmt ) { assert arr != null ; assert hdrFmt != null ; assert bodyFmt != null ; SB sb = new SB ( ) ; sb . a ( ' { ' ) ; boolean first = true ; for ( byte b : arr ) if ( first ) { sb . a ( String . format ( hdrFmt , b ) ) ; first = false ; } else sb . a ( String . format ( bodyFmt , b ) ) ; sb . a ( ' } ' ) ; return sb . toString ( ) ; }
apacheignite/ignite | public static byte [ ] hexString2ByteArray ( String hex ) throws IllegalArgumentException { if ( hex . length ( ) % 2 != 0 ) hex = '0' + hex ; char [ ] chars = hex . toCharArray ( ) ; byte [ ] bytes = new byte [ chars . length / 2 ] ; int byteCnt = 0 ; for ( int i = 0 ; i < chars . length ; i += 2 ) { int newByte = 0 ; newByte |= hexCharToByte ( chars [ i ] ) ; newByte <<= 4 ; newByte |= hexCharToByte ( chars [ i + 1 ] ) ; bytes [ byteCnt ] = ( byte ) newByte ; byteCnt ++ ; } return bytes ; }
apacheignite/ignite | ) private static byte hexCharToByte ( char ch ) throws IllegalArgumentException { switch ( ch ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : return ( byte ) ( ch - '0' ) ; case ' a ' : case ' A ' : return 0xa ; case ' b ' : case ' B ' : return 0xb ; case ' c ' : case ' C ' : return 0xc ; case ' d ' : case ' D ' : return 0xd ; case ' e ' : case ' E ' : return 0xe ; case ' f ' : case ' F ' : return 0xf ; default : throw new IllegalArgumentException ( " Hex ▁ decoding ▁ wrong ▁ input ▁ character ▁ [ character = " + ch + ' ] ' ) ; } }
apacheignite/ignite | public static byte [ ] doubleToBytes ( double d ) { return longToBytes ( Double . doubleToLongBits ( d ) ) ; }
apacheignite/ignite | public static int doubleToBytes ( double d , byte [ ] bytes , int off ) { return longToBytes ( Double . doubleToLongBits ( d ) , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] floatToBytes ( float f ) { return intToBytes ( Float . floatToIntBits ( f ) ) ; }
apacheignite/ignite | public static int floatToBytes ( float f , byte [ ] bytes , int off ) { return intToBytes ( Float . floatToIntBits ( f ) , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] longToBytes ( long l ) { return GridClientByteUtils . longToBytes ( l ) ; }
apacheignite/ignite | public static int longToBytes ( long l , byte [ ] bytes , int off ) { return off + GridClientByteUtils . longToBytes ( l , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] intToBytes ( int i ) { return GridClientByteUtils . intToBytes ( i ) ; }
apacheignite/ignite | public static int intToBytes ( int i , byte [ ] bytes , int off ) { return off + GridClientByteUtils . intToBytes ( i , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] shortToBytes ( short s ) { return GridClientByteUtils . shortToBytes ( s ) ; }
apacheignite/ignite | public static int shortToBytes ( short s , byte [ ] bytes , int off ) { return off + GridClientByteUtils . shortToBytes ( s , bytes , off ) ; }
apacheignite/ignite | public static int uuidToBytes ( @ Nullable UUID uuid , byte [ ] arr , int off ) { return off + GridClientByteUtils . uuidToBytes ( uuid , arr , off ) ; }
apacheignite/ignite | public static byte [ ] uuidToBytes ( @ Nullable UUID uuid ) { return GridClientByteUtils . uuidToBytes ( uuid ) ; }
apacheignite/ignite | public static short bytesToShort ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Short . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; short res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
apacheignite/ignite | public static int bytesToInt ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Integer . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; int res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
apacheignite/ignite | public static long bytesToLong ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Long . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; long res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
apacheignite/ignite | public static UUID bytesToUuid ( byte [ ] bytes , int off ) { return GridClientByteUtils . bytesToUuid ( bytes , off ) ; }
apacheignite/ignite | public static double bytesToDouble ( byte [ ] bytes , int off ) { return Double . longBitsToDouble ( bytesToLong ( bytes , off ) ) ; }
apacheignite/ignite | public static float bytesToFloat ( byte [ ] bytes , int off ) { return Float . intBitsToFloat ( bytesToInt ( bytes , off ) ) ; }
apacheignite/ignite | public static boolean bytesEqual ( byte [ ] a , int aOff , byte [ ] b , int bOff , int len ) { if ( aOff + len > a . length || bOff + len > b . length ) return false ; else { for ( int i = 0 ; i < len ; i ++ ) if ( a [ aOff + i ] != b [ bOff + i ] ) return false ; return true ; } }
apacheignite/ignite | public static byte [ ] decodeHex ( char [ ] data ) throws IgniteCheckedException { int len = data . length ; if ( ( len & 0x01 ) != 0 ) throw new IgniteCheckedException ( " Odd ▁ number ▁ of ▁ characters . " ) ; byte [ ] out = new byte [ len >> 1 ] ; for ( int i = 0 , j = 0 ; j < len ; i ++ ) { int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f |= toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; }
apacheignite/ignite | public static String dash ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' - ' ) ; dash [ 0 ] = dash [ len - 1 ] = ' + ' ; return new String ( dash ) ; }
apacheignite/ignite | public static String pad ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' ▁ ' ) ; return new String ( dash ) ; }
apacheignite/ignite | public static String format ( long sysTime ) { return LONG_DATE_FMT . format ( new java . util . Date ( sysTime ) ) ; }
apacheignite/ignite | public static < T > Iterable < T > randomIterable ( Collection < T > col ) { List < T > list = new ArrayList < > ( col ) ; Collections . shuffle ( list ) ; return list ; }
apacheignite/ignite | public static < T > Iterable < T > asIterable ( final Enumeration < T > e ) { return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { @ Override public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } @ SuppressWarnings ( { " IteratorNextCanNotThrowNoSuchElementException " } ) @ Override public T next ( ) { return e . nextElement ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; }
apacheignite/ignite | public static void copy ( File src , File dest , boolean overwrite ) throws IOException { assert src != null ; assert dest != null ; if ( ! src . exists ( ) ) throw new FileNotFoundException ( " Source ▁ can ' t ▁ be ▁ found : ▁ " + src ) ; if ( src . getAbsoluteFile ( ) . equals ( dest . getAbsoluteFile ( ) ) ) throw new IOException ( " Source ▁ and ▁ destination ▁ are ▁ the ▁ same ▁ [ src = " + src + " , ▁ dest = " + dest + ' ] ' ) ; if ( dest . exists ( ) ) { if ( ! dest . isDirectory ( ) && ! overwrite ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + dest ) ; if ( ! dest . canWrite ( ) ) throw new IOException ( " Destination ▁ is ▁ not ▁ writable : " + dest ) ; } else { File parent = dest . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) parent . mkdirs ( ) ; if ( src . isDirectory ( ) ) dest . mkdir ( ) ; } if ( src . isDirectory ( ) ) { File [ ] files = src . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { File dir = new File ( dest , file . getName ( ) ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) throw new IOException ( " Can ' t ▁ create ▁ directory : ▁ " + dir ) ; copy ( file , dir , overwrite ) ; } else copy ( file , dest , overwrite ) ; } } else { File file = dest . exists ( ) && dest . isDirectory ( ) ? new File ( dest , src . getName ( ) ) : dest ; if ( ! overwrite && file . exists ( ) ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + file ) ; FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( file ) ; copy ( in , out ) ; } finally { if ( in != null ) in . close ( ) ; if ( out != null ) { out . getFD ( ) . sync ( ) ; out . close ( ) ; } } } }
apacheignite/ignite | public static void onGridStart ( ) { synchronized ( mux ) { if ( gridCnt == 0 ) { assert timer == null ; timer = new Thread ( new Runnable ( ) { @ SuppressWarnings ( { " BusyWait " , " InfiniteLoopStatement " } ) @ Override public void run ( ) { while ( true ) { curTimeMillis = System . currentTimeMillis ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException ignored ) { break ; } } } } , " ignite - clock " ) ; timer . setDaemon ( true ) ; timer . setPriority ( 10 ) ; timer . start ( ) ; } ++ gridCnt ; } }
apacheignite/ignite | public static void onGridStop ( ) throws InterruptedException { synchronized ( mux ) { if ( gridCnt == 0 ) return ; -- gridCnt ; Thread timer0 = timer ; if ( gridCnt == 0 && timer0 != null ) { timer = null ; timer0 . interrupt ( ) ; timer0 . join ( ) ; } } }
apacheignite/ignite | public static int copy ( InputStream in , OutputStream out ) throws IOException { assert in != null ; assert out != null ; byte [ ] buf = new byte [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
apacheignite/ignite | public static int copy ( Reader in , Writer out ) throws IOException { assert in != null ; assert out != null ; char [ ] buf = new char [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
apacheignite/ignite | public static void writeStringToFile ( File file , String s ) throws IOException { writeStringToFile ( file , s , Charset . defaultCharset ( ) . toString ( ) , false ) ; }
apacheignite/ignite | public static void writeStringToFile ( File file , String s , String charset ) throws IOException { writeStringToFile ( file , s , charset , false ) ; }
apacheignite/ignite | public static String readFileToString ( String fileName , String charset ) throws IOException { Reader input = new InputStreamReader ( new FileInputStream ( fileName ) , charset ) ; StringWriter output = new StringWriter ( ) ; char [ ] buf = new char [ 4096 ] ; int n ; while ( ( n = input . read ( buf ) ) != - 1 ) output . write ( buf , 0 , n ) ; return output . toString ( ) ; }
apacheignite/ignite | public static void writeStringToFile ( File file , String s , String charset , boolean append ) throws IOException { if ( s == null ) return ; try ( OutputStream out = new FileOutputStream ( file , append ) ) { out . write ( s . getBytes ( charset ) ) ; } }
apacheignite/ignite | public static < E extends Throwable > E withCause ( E e , @ Nullable Throwable cause ) { assert e != null ; if ( cause != null ) e . initCause ( cause ) ; return e ; }
apacheignite/ignite | public static boolean delete ( @ Nullable File file ) { if ( file == null ) return false ; boolean res = true ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; if ( files != null && files . length > 0 ) for ( File file1 : files ) if ( file1 . isDirectory ( ) ) res &= delete ( file1 ) ; else if ( file1 . getName ( ) . endsWith ( " jar " ) ) try { new JarFile ( file1 , false ) . close ( ) ; res &= file1 . delete ( ) ; } catch ( IOException ignore ) { } else res &= file1 . delete ( ) ; res &= file . delete ( ) ; } else res = file . delete ( ) ; return res ; }
apacheignite/ignite | public static boolean mkdirs ( File dir ) { assert dir != null ; return dir . mkdirs ( ) || dir . exists ( ) ; }
apacheignite/ignite | @ Nullable private static String resolveProjectHome ( ) { assert Thread . holdsLock ( IgniteUtils . class ) ; String ggHome0 = IgniteSystemProperties . getString ( IGNITE_HOME ) ; if ( ! F . isEmpty ( ggHome0 ) ) return ggHome0 ; String appWorkDir = System . getProperty ( " user . dir " ) ; if ( appWorkDir != null ) { ggHome0 = findProjectHome ( new File ( appWorkDir ) ) ; if ( ggHome0 != null ) return ggHome0 ; } URI classesUri ; Class < IgniteUtils > cls = IgniteUtils . class ; try { ProtectionDomain domain = cls . getProtectionDomain ( ) ; if ( domain == null || domain . getCodeSource ( ) == null || domain . getCodeSource ( ) . getLocation ( ) == null ) { logResolveFailed ( cls , null ) ; return null ; } classesUri = domain . getCodeSource ( ) . getLocation ( ) . toURI ( ) ; if ( isWindows ( ) && classesUri . getAuthority ( ) != null ) classesUri = new URI ( classesUri . toString ( ) . replace ( " file : // " , " file : / " ) ) ; } catch ( URISyntaxException | SecurityException e ) { logResolveFailed ( cls , e ) ; return null ; } File classesFile ; try { classesFile = new File ( classesUri ) ; } catch ( IllegalArgumentException e ) { logResolveFailed ( cls , e ) ; return null ; } return findProjectHome ( classesFile ) ; }
apacheignite/ignite | private static String findProjectHome ( File startDir ) { for ( File cur = startDir . getAbsoluteFile ( ) ; cur != null ; cur = cur . getParentFile ( ) ) { if ( ! new File ( cur , " bin " ) . isDirectory ( ) || ! new File ( cur , " config " ) . isDirectory ( ) ) continue ; return cur . getPath ( ) ; } return null ; }
apacheignite/ignite | private static void logResolveFailed ( Class cls , Exception e ) { warn ( null , " Failed ▁ to ▁ resolve ▁ IGNITE _ HOME ▁ automatically ▁ for ▁ class ▁ codebase ▁ " + " [ class = " + cls + ( e == null ? " " : " , ▁ e = " + e . getMessage ( ) ) + ' ] ' ) ; }
apacheignite/ignite | @ Nullable public static String getIgniteHome ( ) { GridTuple < String > ggHomeTup = ggHome ; String ggHome0 ; if ( ggHomeTup == null ) { synchronized ( IgniteUtils . class ) { ggHomeTup = ggHome ; if ( ggHomeTup == null ) { ggHome = F . t ( ggHome0 = resolveProjectHome ( ) ) ; if ( ggHome0 != null ) System . setProperty ( IGNITE_HOME , ggHome0 ) ; } else ggHome0 = ggHomeTup . get ( ) ; } } else ggHome0 = ggHomeTup . get ( ) ; return ggHome0 ; }
apacheignite/ignite | public static void setIgniteHome ( @ Nullable String path ) { GridTuple < String > ggHomeTup = ggHome ; String ggHome0 ; if ( ggHomeTup == null ) { synchronized ( IgniteUtils . class ) { ggHomeTup = ggHome ; if ( ggHomeTup == null ) { if ( F . isEmpty ( path ) ) System . clearProperty ( IGNITE_HOME ) ; else System . setProperty ( IGNITE_HOME , path ) ; ggHome = F . t ( path ) ; return ; } else ggHome0 = ggHomeTup . get ( ) ; } } else ggHome0 = ggHomeTup . get ( ) ; if ( ggHome0 != null && ! ggHome0 . equals ( path ) ) throw new IgniteException ( " Failed ▁ to ▁ set ▁ IGNITE _ HOME ▁ after ▁ it ▁ has ▁ been ▁ already ▁ resolved ▁ " + " [ igniteHome = " + ggHome0 + " , ▁ newIgniteHome = " + path + ' ] ' ) ; }
apacheignite/ignite | @ Nullable public static File resolveIgnitePath ( String path ) { assert path != null ; String home = getIgniteHome ( ) ; if ( home != null ) { File file = new File ( home , path ) ; if ( file . exists ( ) ) return file ; } File file = new File ( path ) ; if ( file . exists ( ) ) return file ; return null ; }
apacheignite/ignite | @ Nullable public static URL resolveIgniteUrl ( String path ) { return resolveIgniteUrl ( path , true ) ; }
apacheignite/ignite | public static URL resolveSpringUrl ( String springCfgPath ) throws IgniteCheckedException { A . notNull ( springCfgPath , " springCfgPath " ) ; URL url ; try { url = new URL ( springCfgPath ) ; } catch ( MalformedURLException e ) { url = U . resolveIgniteUrl ( springCfgPath ) ; if ( url == null ) url = resolveInClasspath ( springCfgPath ) ; if ( url == null ) throw new IgniteCheckedException ( " Spring ▁ XML ▁ configuration ▁ path ▁ is ▁ invalid : ▁ " + springCfgPath + " . ▁ Note ▁ that ▁ this ▁ path ▁ should ▁ be ▁ either ▁ absolute ▁ or ▁ a ▁ relative ▁ local ▁ file ▁ system ▁ path , ▁ " + " relative ▁ to ▁ META - INF ▁ in ▁ classpath ▁ or ▁ valid ▁ URL ▁ to ▁ IGNITE _ HOME . " , e ) ; } return url ; }
apacheignite/ignite | @ Nullable private static URL resolveInClasspath ( String path ) { ClassLoader clsLdr = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( clsLdr == null ) return null ; return clsLdr . getResource ( path . replaceAll ( " \\ \ \" , " / " ) ) ; }
apacheignite/ignite | ) @ Nullable public static URL resolveIgniteUrl ( String path , boolean metaInf ) { File f = resolveIgnitePath ( path ) ; if ( f != null ) { try { return f . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { } } ClassLoader clsLdr = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( clsLdr != null ) { String locPath = ( metaInf ? " META - INF / " : " " ) + path . replaceAll ( " \\ \ \" , " / " ) ; return clsLdr . getResource ( locPath ) ; } else return null ; }
apacheignite/ignite | public static String byteArray2HexString ( byte [ ] arr ) { SB sb = new SB ( arr . length << 1 ) ; for ( byte b : arr ) sb . a ( Integer . toHexString ( MASK & b >>> 4 ) ) . a ( Integer . toHexString ( MASK & b ) ) ; return sb . toString ( ) . toUpperCase ( ) ; }
apacheignite/ignite | public static boolean containsObjectArray ( @ Nullable Object [ ] arr , Object val , @ Nullable Object ... vals ) { if ( arr == null || arr . length == 0 ) return false ; for ( Object o : arr ) { if ( F . eq ( o , val ) ) return true ; if ( vals != null && vals . length > 0 ) for ( Object v : vals ) if ( F . eq ( o , v ) ) return true ; } return false ; }
apacheignite/ignite | public static boolean containsObjectArray ( @ Nullable Object [ ] arr , @ Nullable Collection < Object > c ) { if ( arr == null || arr . length == 0 || c == null || c . isEmpty ( ) ) return false ; for ( Object o : arr ) { if ( c . contains ( o ) ) return true ; } return false ; }
apacheignite/ignite | public static boolean containsIntArray ( int [ ] arr , int val ) { assert arr != null ; if ( arr . length == 0 ) return false ; for ( int i : arr ) if ( i == val ) return true ; return false ; }
apacheignite/ignite | public static boolean containsStringArray ( String [ ] arr , @ Nullable String val , boolean ignoreCase ) { assert arr != null ; for ( String s : arr ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignoreCase ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
apacheignite/ignite | public static boolean containsStringCollection ( Iterable < String > c , @ Nullable String val , boolean ignoreCase ) { assert c != null ; for ( String s : c ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignoreCase ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
apacheignite/ignite | public static void close ( @ Nullable AutoCloseable rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void closeQuiet ( @ Nullable AutoCloseable rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception ignored ) { } }
apacheignite/ignite | public static void close ( @ Nullable SelectionKey rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) close ( rsrc . channel ( ) , log ) ; }
apacheignite/ignite | public static void closeQuiet ( @ Nullable SelectionKey rsrc ) { if ( rsrc != null ) closeQuiet ( rsrc . channel ( ) ) ; }
apacheignite/ignite | public static void close ( @ Nullable DatagramSocket rsrc ) { if ( rsrc != null ) rsrc . close ( ) ; }
apacheignite/ignite | public static void close ( @ Nullable Selector rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void closeQuiet ( @ Nullable Selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException ignored ) { } }
apacheignite/ignite | public static void close ( @ Nullable Context rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void closeQuiet ( @ Nullable Context rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException ignored ) { } }
apacheignite/ignite | public static void close ( @ Nullable URLClassLoader clsLdr , @ Nullable IgniteLogger log ) { if ( clsLdr != null ) try { URLClassPath path = SharedSecrets . getJavaNetAccess ( ) . getURLClassPath ( clsLdr ) ; Field ldrFld = path . getClass ( ) . getDeclaredField ( " loaders " ) ; ldrFld . setAccessible ( true ) ; Iterable ldrs = ( Iterable ) ldrFld . get ( path ) ; for ( Object ldr : ldrs ) if ( ldr . getClass ( ) . getName ( ) . endsWith ( " JarLoader " ) ) try { Field jarFld = ldr . getClass ( ) . getDeclaredField ( " jar " ) ; jarFld . setAccessible ( true ) ; ZipFile jar = ( ZipFile ) jarFld . get ( ldr ) ; jar . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void releaseQuiet ( @ Nullable FileLock lock ) { if ( lock != null ) try { lock . release ( ) ; } catch ( Exception ignored ) { } }
apacheignite/ignite | public static void rollbackConnection ( @ Nullable Connection rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException e ) { warn ( log , " Failed ▁ to ▁ rollback ▁ JDBC ▁ connection : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void courtesy ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; courtesy ( log , s , s ) ; }
apacheignite/ignite | public static void courtesy ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) log . getLogger ( IgniteConfiguration . COURTESY_LOGGER_NAME ) . warning ( compact ( longMsg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( courtesy ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; }
apacheignite/ignite | public static void warn ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; warn ( log , s , s ) ; }
apacheignite/ignite | public static void quietAndWarn ( IgniteLogger log , Object msg ) { quietAndWarn ( log , msg , msg ) ; }
apacheignite/ignite | public static void quietAndWarn ( IgniteLogger log , Object msg , Object shortMsg ) { warn ( log , msg ) ; if ( log . isQuiet ( ) ) quiet ( false , shortMsg ) ; }
apacheignite/ignite | public static void error ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; if ( msg instanceof Throwable ) { Throwable t = ( Throwable ) msg ; error ( log , t . getMessage ( ) , t ) ; } else { String s = msg . toString ( ) ; error ( log , s , s , null ) ; } }
apacheignite/ignite | public static void warn ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) log . warning ( compact ( longMsg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( wrn ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; }
apacheignite/ignite | public static void log ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) { if ( log . isInfoEnabled ( ) ) log . info ( compact ( longMsg . toString ( ) ) ) ; } else quiet ( false , shortMsg ) ; }
apacheignite/ignite | public static void log ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; log ( log , s , s ) ; }
apacheignite/ignite | public static void error ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg , @ Nullable Throwable e ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) { if ( e == null ) log . error ( compact ( longMsg . toString ( ) ) ) ; else log . error ( compact ( longMsg . toString ( ) ) , e ) ; } else { X . printerr ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( err ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; if ( e != null ) e . printStackTrace ( System . err ) ; else X . printerrln ( ) ; } }
apacheignite/ignite | public static void error ( @ Nullable IgniteLogger log , Object shortMsg , @ Nullable Throwable e ) { assert shortMsg != null ; String s = shortMsg . toString ( ) ; error ( log , s , s , e ) ; }
apacheignite/ignite | public static void quiet ( boolean err , Object ... objs ) { assert objs != null ; String time = SHORT_DATE_FMT . format ( new java . util . Date ( ) ) ; SB sb = new SB ( ) ; for ( Object obj : objs ) sb . a ( ' [ ' ) . a ( time ) . a ( " ] ▁ " ) . a ( obj . toString ( ) ) . a ( NL ) ; PrintStream ps = err ? System . err : System . out ; ps . print ( compact ( sb . toString ( ) ) ) ; }
apacheignite/ignite | public static void quietAndInfo ( IgniteLogger log , String msg ) { if ( log . isQuiet ( ) ) U . quiet ( false , msg ) ; if ( log . isInfoEnabled ( ) ) log . info ( msg ) ; }
apacheignite/ignite | public static void rollbackConnectionQuiet ( @ Nullable Connection rsrc ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException ignored ) { } }
apacheignite/ignite | public static ObjectName makeMBeanName ( @ Nullable String gridName , @ Nullable String grp , String name ) throws MalformedObjectNameException { SB sb = new SB ( JMX_DOMAIN + ' : ' ) ; appendClassLoaderHash ( sb ) ; appendJvmId ( sb ) ; if ( gridName != null && ! gridName . isEmpty ( ) ) sb . a ( " grid = " ) . a ( gridName ) . a ( ' , ' ) ; if ( grp != null ) sb . a ( " group = " ) . a ( grp ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
apacheignite/ignite | private static void appendClassLoaderHash ( SB sb ) { if ( getBoolean ( IGNITE_MBEAN_APPEND_class_LOADER_ID , true ) ) { String clsLdrHash = Integer . toHexString ( Ignite . class . getClassLoader ( ) . hashCode ( ) ) ; sb . a ( " clsLdr = " ) . a ( clsLdrHash ) . a ( ' , ' ) ; } }
apacheignite/ignite | private static void appendJvmId ( SB sb ) { if ( getBoolean ( IGNITE_MBEAN_APPEND_JVM_ID ) ) { String jvmId = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; sb . a ( " jvmId = " ) . a ( jvmId ) . a ( ' , ' ) ; } }
apacheignite/ignite | public static String maskName ( @ Nullable String cacheName ) { return cacheName == null ? " default " : cacheName ; }
apacheignite/ignite | public static ObjectName makeCacheMBeanName ( @ Nullable String gridName , @ Nullable String cacheName , String name ) throws MalformedObjectNameException { SB sb = new SB ( JMX_DOMAIN + ' : ' ) ; appendClassLoaderHash ( sb ) ; appendJvmId ( sb ) ; if ( gridName != null && ! gridName . isEmpty ( ) ) sb . a ( " grid = " ) . a ( gridName ) . a ( ' , ' ) ; cacheName = maskName ( cacheName ) ; sb . a ( " group = " ) . a ( cacheName ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
apacheignite/ignite | public static < T > ObjectName registerMBean ( MBeanServer mbeanSrv , @ Nullable String gridName , @ Nullable String grp , String name , T impl , @ Nullable Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , makeMBeanName ( gridName , grp , name ) ) . getObjectName ( ) ; }
apacheignite/ignite | public static < T > ObjectName registerMBean ( MBeanServer mbeanSrv , ObjectName name , T impl , Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , name ) . getObjectName ( ) ; }
apacheignite/ignite | public static < T > ObjectName registerCacheMBean ( MBeanServer mbeanSrv , @ Nullable String gridName , @ Nullable String cacheName , String name , T impl , Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , makeCacheMBeanName ( gridName , cacheName , name ) ) . getObjectName ( ) ; }
apacheignite/ignite | public static void interrupt ( @ Nullable Thread t ) { if ( t != null ) t . interrupt ( ) ; }
apacheignite/ignite | public static void interrupt ( Iterable < ? extends Thread > workers ) { if ( workers != null ) for ( Thread worker : workers ) worker . interrupt ( ) ; }
apacheignite/ignite | public static boolean join ( @ Nullable Thread t , @ Nullable IgniteLogger log ) { if ( t != null ) try { t . join ( ) ; return true ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ a ▁ thread : ▁ " + t ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
apacheignite/ignite | public static boolean joinThreads ( Iterable < ? extends Thread > workers , @ Nullable IgniteLogger log ) { boolean retval = true ; if ( workers != null ) for ( Thread worker : workers ) if ( ! join ( worker , log ) ) retval = false ; return retval ; }
apacheignite/ignite | public static void startThreads ( Iterable < ? extends Thread > threads ) { if ( threads != null ) { for ( Thread thread : threads ) { if ( thread != null ) thread . start ( ) ; } } }
apacheignite/ignite | public static void cancel ( @ Nullable GridWorker w ) { if ( w != null ) w . cancel ( ) ; }
apacheignite/ignite | public static void cancel ( Iterable < ? extends GridWorker > ws ) { if ( ws != null ) for ( GridWorker w : ws ) w . cancel ( ) ; }
apacheignite/ignite | public static boolean join ( @ Nullable GridWorker w , @ Nullable IgniteLogger log ) { if ( w != null ) try { w . join ( ) ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ runnable : ▁ " + w ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
apacheignite/ignite | public static boolean join ( Iterable < ? extends GridWorker > ws , IgniteLogger log ) { boolean retval = true ; if ( ws != null ) for ( GridWorker w : ws ) if ( ! join ( w , log ) ) retval = false ; return retval ; }
apacheignite/ignite | public static void shutdownNow ( Class < ? > owner , @ Nullable ExecutorService exec , @ Nullable IgniteLogger log ) { if ( exec != null ) { List < Runnable > tasks = exec . shutdownNow ( ) ; if ( ! F . isEmpty ( tasks ) ) U . warn ( log , " Runnable ▁ tasks ▁ outlived ▁ thread ▁ pool ▁ executor ▁ service ▁ [ owner = " + getSimpleName ( owner ) + " , ▁ tasks = " + tasks + ' ] ' ) ; try { exec . awaitTermination ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ignored ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ executor ▁ service ▁ to ▁ stop . " ) ; exec . shutdownNow ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } } }
apacheignite/ignite | public static ClusterGroupEmptyCheckedException emptyTopologyException ( ) { return new ClusterGroupEmptyCheckedException ( " Cluster ▁ group ▁ is ▁ empty . " ) ; }
apacheignite/ignite | public static void writeUuids ( DataOutput out , @ Nullable Collection < UUID > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( UUID id : col ) writeUuid ( out , id ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | @ Nullable public static List < UUID > readUuids ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < UUID > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( readUuid ( in ) ) ; return col ; }
apacheignite/ignite | public static void writeGridUuids ( DataOutput out , @ Nullable Collection < IgniteUuid > col ) throws IOException { if ( col != null ) { out . writeBoolean ( true ) ; out . writeInt ( col . size ( ) ) ; for ( IgniteUuid id : col ) writeGridUuid ( out , id ) ; } else out . writeBoolean ( false ) ; }
apacheignite/ignite | @ Nullable public static List < IgniteUuid > readGridUuids ( DataInput in ) throws IOException { List < IgniteUuid > col = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( readGridUuid ( in ) ) ; } return col ; }
apacheignite/ignite | public static void writeUuid ( DataOutput out , UUID uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . getMostSignificantBits ( ) ) ; out . writeLong ( uid . getLeastSignificantBits ( ) ) ; } }
apacheignite/ignite | @ Nullable public static UUID readUuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; return IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) ; } return null ; }
apacheignite/ignite | public static void writeGridUuid ( DataOutput out , IgniteUuid uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . globalId ( ) . getMostSignificantBits ( ) ) ; out . writeLong ( uid . globalId ( ) . getLeastSignificantBits ( ) ) ; out . writeLong ( uid . localId ( ) ) ; } }
apacheignite/ignite | @ Nullable public static IgniteUuid readGridUuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; UUID globalId = IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) ; long locId = in . readLong ( ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
apacheignite/ignite | public static byte [ ] igniteUuidToBytes ( IgniteUuid uuid ) { assert uuid != null ; byte [ ] out = new byte [ 24 ] ; igniteUuidToBytes ( uuid , out , 0 ) ; return out ; }
apacheignite/ignite | public static void igniteUuidToBytes ( IgniteUuid uuid , byte [ ] out , int off ) { assert uuid != null ; longToBytes ( uuid . globalId ( ) . getMostSignificantBits ( ) , out , off ) ; longToBytes ( uuid . globalId ( ) . getLeastSignificantBits ( ) , out , off + 8 ) ; longToBytes ( uuid . localId ( ) , out , off + 16 ) ; }
apacheignite/ignite | public static IgniteUuid bytesToIgniteUuid ( byte [ ] in , int off ) { long most = bytesToLong ( in , off ) ; long least = bytesToLong ( in , off + 8 ) ; long locId = bytesToLong ( in , off + 16 ) ; return new IgniteUuid ( IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) , locId ) ; }
apacheignite/ignite | public static void writeBooleanArray ( DataOutput out , @ Nullable boolean [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( boolean b : arr ) out . writeBoolean ( b ) ; } }
apacheignite/ignite | public static void writeIntArray ( DataOutput out , @ Nullable int [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( int b : arr ) out . writeInt ( b ) ; } }
apacheignite/ignite | @ Nullable public static boolean [ ] readBooleanArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; boolean [ ] res = new boolean [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readBoolean ( ) ; return res ; }
apacheignite/ignite | @ Nullable public static int [ ] readIntArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; int [ ] res = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readInt ( ) ; return res ; }
apacheignite/ignite | public static int hashCode ( ByteBuffer ... bufs ) { int res = 1 ; for ( ByteBuffer buf : bufs ) { int pos = buf . position ( ) ; while ( buf . hasRemaining ( ) ) res = 31 * res + buf . get ( ) ; buf . position ( pos ) ; } return res ; }
apacheignite/ignite | public static void writeMap ( ObjectOutput out , Map < ? , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < ? , ? > e : map . entrySet ( ) ) { out . writeObject ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static void writeStringMap ( DataOutput out , @ Nullable Map < String , String > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < String , String > e : map . entrySet ( ) ) { writeUTFStringNullable ( out , e . getKey ( ) ) ; writeUTFStringNullable ( out , e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static Map < String , String > readStringMap ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; else { Map < String , String > map = U . newHashMap ( size ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( readUTFStringNullable ( in ) , readUTFStringNullable ( in ) ) ; return map ; } }
apacheignite/ignite | public static void writeUTFStringNullable ( DataOutput out , @ Nullable String val ) throws IOException { if ( val != null ) { out . writeBoolean ( true ) ; out . writeUTF ( val ) ; } else out . writeBoolean ( false ) ; }
apacheignite/ignite | public static String readUTFStringNullable ( DataInput in ) throws IOException { return in . readBoolean ( ) ? in . readUTF ( ) : null ; }
apacheignite/ignite | public static void writeIntKeyMap ( ObjectOutput out , Map < Integer , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , ? > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static void writeIntKeyIntValueMap ( DataOutput out , Map < Integer , Integer > map ) throws IOException { if ( map != null ) { out . writeBoolean ( true ) ; out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeInt ( e . getValue ( ) ) ; } } else out . writeBoolean ( false ) ; }
apacheignite/ignite | ) @ Nullable public static Map < Integer , Integer > readIntKeyIntValueMap ( DataInput in ) throws IOException { Map < Integer , Integer > map = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; map = new HashMap < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( in . readInt ( ) , in . readInt ( ) ) ; } return map ; }
apacheignite/ignite | @ Nullable public static List < Integer > readIntList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
apacheignite/ignite | @ Nullable public static Set < Integer > readIntSet ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Set < Integer > set = new HashSet < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) set . add ( in . readInt ( ) ) ; return set ; }
apacheignite/ignite | public static void writeString ( DataOutput out , String s ) throws IOException { out . writeBoolean ( s == null ) ; if ( s != null ) out . writeUTF ( s ) ; }
apacheignite/ignite | @ Nullable public static String readString ( DataInput in ) throws IOException { return ! in . readBoolean ( ) ? in . readUTF ( ) : null ; }
apacheignite/ignite | public static < E extends Enum > void writeEnum ( DataOutput out , E e ) throws IOException { out . writeByte ( e == null ? - 1 : e . ordinal ( ) ) ; }
apacheignite/ignite | public static < T > T getByIndex ( Collection < T > vals , int idx ) { assert idx < vals . size ( ) ; int i = 0 ; for ( T val : vals ) { if ( idx == i ) return val ; i ++ ; } assert false : " Should ▁ never ▁ be ▁ reached . " ; return null ; }
apacheignite/ignite | @ Nullable public static < T extends Annotation > T getAnnotation ( Class < ? > cls , Class < T > annCls ) { if ( cls == Object . class ) return null ; T ann = cls . getAnnotation ( annCls ) ; if ( ann != null ) return ann ; for ( Class < ? > itf : cls . getInterfaces ( ) ) { ann = getAnnotation ( itf , annCls ) ; if ( ann != null ) return ann ; } if ( ! cls . isInterface ( ) ) { ann = getAnnotation ( cls . getSuperclass ( ) , annCls ) ; if ( ann != null ) return ann ; } return null ; }
apacheignite/ignite | public static < T extends Annotation > boolean hasAnnotation ( Class < ? > cls , Class < T > annCls ) { return getAnnotation ( cls , annCls ) != null ; }
apacheignite/ignite | public static < T extends Annotation > boolean hasAnnotation ( Object o , Class < T > annCls ) { return o != null && hasAnnotation ( o . getClass ( ) , annCls ) ; }
apacheignite/ignite | public static String getSimpleName ( Class < ? > cls ) { String name = cls . getSimpleName ( ) ; if ( F . isEmpty ( name ) ) name = cls . getName ( ) . substring ( cls . getPackage ( ) . getName ( ) . length ( ) + 1 ) ; return name ; }
apacheignite/ignite | ) public static boolean containsAll ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) if ( base . containsKey ( entry . getKey ( ) ) ) { Object val = base . get ( entry . getKey ( ) ) ; if ( val == null && entry . getValue ( ) == null ) continue ; if ( val == null || entry . getValue ( ) == null || ! val . equals ( entry . getValue ( ) ) ) return false ; } else return false ; return true ; }
apacheignite/ignite | public static String getTaskName ( Class < ? extends ComputeTask < ? , ? > > taskCls ) { ComputeTaskName nameAnn = getAnnotation ( taskCls , ComputeTaskName . class ) ; return nameAnn == null ? taskCls . getName ( ) : nameAnn . value ( ) ; }
apacheignite/ignite | public static String spiAttribute ( IgniteSpi spi , String attrName ) { assert spi != null ; assert spi . getName ( ) != null ; return spi . getName ( ) + ' . ' + attrName ; }
apacheignite/ignite | public static String classNameToResourceName ( String clsName ) { return clsName . replaceAll ( " \\ . " , " / " ) + " . class " ; }
apacheignite/ignite | public static RuntimeMXBean getRuntimeMx ( ) { return ManagementFactory . getRuntimeMXBean ( ) ; }
apacheignite/ignite | public static ThreadMXBean getThreadMx ( ) { return ManagementFactory . getThreadMXBean ( ) ; }
apacheignite/ignite | public static OperatingSystemMXBean getOsMx ( ) { return ManagementFactory . getOperatingSystemMXBean ( ) ; }
apacheignite/ignite | public static MemoryMXBean getMemoryMx ( ) { return ManagementFactory . getMemoryMXBean ( ) ; }
apacheignite/ignite | public static CompilationMXBean getCompilerMx ( ) { return ManagementFactory . getCompilationMXBean ( ) ; }
apacheignite/ignite | public static Class < ? > detectClass ( Object obj ) { assert obj != null ; if ( obj instanceof GridPeerDeployAware ) return ( ( GridPeerDeployAware ) obj ) . deployClass ( ) ; if ( U . isPrimitiveArray ( obj ) ) return obj . getClass ( ) ; if ( ! U . isJdk ( obj . getClass ( ) ) ) return obj . getClass ( ) ; if ( obj instanceof Iterable < ? > ) { Object o = F . first ( ( Iterable < ? > ) obj ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } if ( obj instanceof Map ) { Map . Entry < ? , ? > e = F . firstEntry ( ( Map < ? , ? > ) obj ) ; if ( e != null ) { Object k = e . getKey ( ) ; if ( k != null && ! U . isJdk ( k . getClass ( ) ) ) return k . getClass ( ) ; Object v = e . getValue ( ) ; return v != null ? v . getClass ( ) : obj . getClass ( ) ; } } if ( obj . getClass ( ) . isArray ( ) ) { int len = Array . getLength ( obj ) ; if ( len > 0 ) { Object o = Array . get ( obj , 0 ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } else return obj . getClass ( ) . getComponentType ( ) ; } return obj . getClass ( ) ; }
apacheignite/ignite | public static ClassLoader detectClassLoader ( Class < ? > cls ) { return GridClassLoaderCache . classLoader ( cls ) ; }
apacheignite/ignite | @ Nullable public static ClassLoader detectObjectClassLoader ( @ Nullable Object obj ) { if ( obj == null ) return null ; if ( obj instanceof GridPeerDeployAware ) return ( ( GridPeerDeployAware ) obj ) . classLoader ( ) ; return detectClassLoader ( obj . getClass ( ) ) ; }
apacheignite/ignite | public static boolean isLoadableBy ( String clsName , @ Nullable ClassLoader ldr ) { assert clsName != null ; if ( ldr == null ) ldr = gridClassLoader ; String lambdaParent = U . lambdaEnclosingClassName ( clsName ) ; try { ldr . loadClass ( lambdaParent == null ? clsName : lambdaParent ) ; return true ; } catch ( ClassNotFoundException ignore ) { return false ; } }
apacheignite/ignite | public static GridPeerDeployAware peerDeployAware0 ( @ Nullable Iterable < ? > c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; Collection < Object > tmpC = new ArrayList < > ( ) ; for ( Object e : c ) tmpC . add ( e ) ; tmpC . add ( c ) ; boolean notAllNulls = false ; for ( Object obj : tmpC ) { if ( obj != null ) { notAllNulls = true ; if ( hasCommonClassLoader ( obj , tmpC ) ) return obj == c ? peerDeployAware ( obj ) : peerDeployAware0 ( obj ) ; } } if ( notAllNulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peerDeployAware ( c ) ; }
apacheignite/ignite | private static boolean hasCommonClassLoader ( Object obj , Iterable < ? > c ) { assert obj != null ; assert c != null ; ClassLoader ldr = obj instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj ) . classLoader ( ) : detectClassLoader ( obj . getClass ( ) ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String clsName = obj2 instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj2 ) . deployClass ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! isLoadableBy ( clsName , ldr ) ) { found = false ; break ; } } return found ; }
apacheignite/ignite | ) public static GridPeerDeployAware peerDeployAware0 ( @ Nullable Object ... c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; boolean notAllNulls = false ; for ( Object obj : c ) { if ( obj != null ) { notAllNulls = true ; ClassLoader ldr = obj instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj ) . classLoader ( ) : obj . getClass ( ) . getClassLoader ( ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String clsName = obj2 instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj2 ) . deployClass ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! isLoadableBy ( clsName , ldr ) ) { found = false ; break ; } } if ( found ) return peerDeployAware0 ( obj ) ; } } if ( notAllNulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peerDeployAware ( new Object [ 0 ] ) ; }
apacheignite/ignite | public static GridPeerDeployAware peerDeployAware0 ( Object obj ) { if ( obj instanceof Iterable ) return peerDeployAware0 ( ( Iterable ) obj ) ; if ( obj . getClass ( ) . isArray ( ) && ! U . isPrimitiveArray ( obj ) ) return peerDeployAware0 ( ( Object [ ] ) obj ) ; return peerDeployAware ( obj ) ; }
apacheignite/ignite | public static GridPeerDeployAware peerDeployAware ( Object obj ) { assert obj != null ; if ( obj instanceof GridPeerDeployAware ) return ( GridPeerDeployAware ) obj ; final Class < ? > cls = obj instanceof Class ? ( Class ) obj : obj . getClass ( ) ; return new GridPeerDeployAware ( ) { private ClassLoader ldr ; @ Override public Class < ? > deployClass ( ) { return cls ; } @ Override public ClassLoader classLoader ( ) { if ( ldr == null ) ldr = detectClassLoader ( cls ) ; return ldr ; } } ; }
apacheignite/ignite | public static GridPeerDeployAware detectPeerDeployAware ( GridPeerDeployAware obj ) { GridPeerDeployAware p = nestedPeerDeployAware ( obj , true , new GridLeanIdentitySet < > ( ) ) ; return p != null ? p : peerDeployAware ( obj . getClass ( ) ) ; }
apacheignite/ignite | @ Nullable private static GridPeerDeployAware nestedPeerDeployAware ( Object obj , boolean top , Set < Object > processed ) { if ( ! processed . add ( obj ) ) return null ; if ( obj instanceof GridPeerDeployAware ) { GridPeerDeployAware p = ( GridPeerDeployAware ) obj ; if ( ! top && p . deployClass ( ) != null ) return p ; for ( Class < ? > cls = obj . getClass ( ) ; ! cls . equals ( Object . class ) ; cls = cls . getSuperclass ( ) ) { IgniteBiTuple < Class < ? > , Collection < Field > > tup = p2pFields . get ( cls . getName ( ) ) ; boolean cached = tup != null && tup . get1 ( ) . equals ( cls ) ; Iterable < Field > fields = cached ? tup . get2 ( ) : Arrays . asList ( cls . getDeclaredFields ( ) ) ; if ( ! cached ) { tup = F . t2 ( ) ; tup . set1 ( cls ) ; } for ( Field f : fields ) if ( cached || f . getName ( ) . startsWith ( " this $ " ) || f . getName ( ) . startsWith ( " val $ " ) ) { if ( ! cached ) { f . setAccessible ( true ) ; if ( tup . get2 ( ) == null ) tup . set2 ( new LinkedList < Field > ( ) ) ; tup . get2 ( ) . add ( f ) ; } try { Object o = f . get ( obj ) ; if ( o != null ) { p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) { if ( ! cached ) p2pFields . put ( cls . getName ( ) , tup ) ; return p ; } } } catch ( IllegalAccessException ignored ) { return null ; } } } } else if ( isIgnite ( obj . getClass ( ) ) ) return null ; else if ( obj instanceof Iterable ) for ( Object o : ( Iterable < ? > ) obj ) { GridPeerDeployAware p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) return p ; } else if ( obj . getClass ( ) . isArray ( ) ) { Class < ? > type = obj . getClass ( ) . getComponentType ( ) ; if ( ! type . isPrimitive ( ) && ! isJdk ( type ) ) { Object [ ] arr = ( Object [ ] ) obj ; for ( Object o : arr ) { GridPeerDeployAware p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) return p ; } } } return null ; }
apacheignite/ignite | public static boolean isIgnite ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite " ) ; }
apacheignite/ignite | public static boolean isGrid ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite . internal " ) ; }
apacheignite/ignite | public static String compact ( String s ) { return s . replace ( " org . apache . ignite . internal . visor . " , " o . a . i . i . v . " ) . replace ( " org . apache . ignite . internal . " , " o . a . i . i . " ) . replace ( " org . apache . ignite . scalar . " , " o . a . i . s . " ) . replace ( " org . apache . ignite . " , " o . a . i . " ) ; }
apacheignite/ignite | public static boolean isJdk ( Class < ? > cls ) { if ( cls . isPrimitive ( ) ) return true ; String s = cls . getName ( ) ; return s . startsWith ( " java . " ) || s . startsWith ( " javax . " ) ; }
apacheignite/ignite | ) public static void wait ( Object mux ) throws IgniteInterruptedCheckedException { try { mux . wait ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | ) public static void unzip ( File zipFile , File toDir , @ Nullable IgniteLogger log ) throws IOException { ZipFile zip = null ; try { zip = new ZipFile ( zipFile ) ; for ( ZipEntry entry : asIterable ( zip . entries ( ) ) ) { if ( entry . isDirectory ( ) ) { new File ( toDir , entry . getName ( ) ) . mkdirs ( ) ; continue ; } InputStream in = null ; OutputStream out = null ; try { in = zip . getInputStream ( entry ) ; File outFile = new File ( toDir , entry . getName ( ) ) ; if ( ! outFile . getParentFile ( ) . exists ( ) ) outFile . getParentFile ( ) . mkdirs ( ) ; out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; copy ( in , out ) ; } finally { close ( in , log ) ; close ( out , log ) ; } } } finally { if ( zip != null ) zip . close ( ) ; } }
apacheignite/ignite | public static String osJdkString ( ) { return osJdkStr ; }
apacheignite/ignite | public static String osString ( ) { return osStr ; }
apacheignite/ignite | public static String jdkString ( ) { return jdkStr ; }
apacheignite/ignite | public static boolean isLinux ( ) { return linux ; }
apacheignite/ignite | public static String jdkName ( ) { return jdkName ; }
apacheignite/ignite | public static String jdkVendor ( ) { return jdkVendor ; }
apacheignite/ignite | public static String jdkVersion ( ) { return jdkVer ; }
apacheignite/ignite | public static String osArchitecture ( ) { return osArch ; }
apacheignite/ignite | public static String osName ( ) { return osName ; }
apacheignite/ignite | public static String osVersion ( ) { return osVer ; }
apacheignite/ignite | public static boolean isMacOs ( ) { return mac ; }
apacheignite/ignite | public static boolean isNetWare ( ) { return netware ; }
apacheignite/ignite | public static boolean isSolaris ( ) { return solaris ; }
apacheignite/ignite | public static boolean isSolarisSparc ( ) { return solaris && sparc ; }
apacheignite/ignite | public static boolean isSolarisX86 ( ) { return solaris && x86 ; }
apacheignite/ignite | public static boolean isUnix ( ) { return unix ; }
apacheignite/ignite | public static boolean isWindows ( ) { return win7 || win8 || win81 || winXp || win95 || win98 || winNt || win2k || win2003 || win2008 || winVista || unknownWin ; }
apacheignite/ignite | public static boolean isWindowsVista ( ) { return winVista ; }
apacheignite/ignite | public static boolean isWindows7 ( ) { return win7 ; }
apacheignite/ignite | public static boolean isWindows8 ( ) { return win8 ; }
apacheignite/ignite | public static boolean isWindows81 ( ) { return win81 ; }
apacheignite/ignite | public static boolean isWindows2k ( ) { return win2k ; }
apacheignite/ignite | public static boolean isWindows2003 ( ) { return win2003 ; }
apacheignite/ignite | public static boolean isWindows2008 ( ) { return win2008 ; }
apacheignite/ignite | public static boolean isWindows95 ( ) { return win95 ; }
apacheignite/ignite | public static boolean isWindows98 ( ) { return win98 ; }
apacheignite/ignite | public static boolean isWindowsNt ( ) { return winNt ; }
apacheignite/ignite | public static boolean isSufficientlyTestedOs ( ) { return win7 || win8 || win81 || winXp || winVista || mac || linux || solaris ; }
apacheignite/ignite | public static boolean isWindowsXp ( ) { return winXp ; }
apacheignite/ignite | public static String jvmSpec ( ) { return jvmSpecName ; }
apacheignite/ignite | public static String jvmVersion ( ) { return jvmImplVer ; }
apacheignite/ignite | public static String jvmVendor ( ) { return jvmImplVendor ; }
apacheignite/ignite | public static String jvmName ( ) { return jvmImplName ; }
apacheignite/ignite | public static int compareVersionNumbers ( @ Nullable String v1 , @ Nullable String v2 ) { if ( v1 == null && v2 == null ) return 0 ; if ( v1 == null ) return - 1 ; if ( v2 == null ) return 1 ; String [ ] part1 = v1 . split ( " [ \\ . \\ _ \\ - ] " ) ; String [ ] part2 = v2 . split ( " [ \\ . \\ _ \\ - ] " ) ; int idx = 0 ; for ( ; idx < part1 . length && idx < part2 . length ; idx ++ ) { String p1 = part1 [ idx ] ; String p2 = part2 [ idx ] ; int cmp = ( p1 . matches ( " \\ d + " ) && p2 . matches ( " \\ d + " ) ) ? Integer . valueOf ( p1 ) . compareTo ( Integer . valueOf ( p2 ) ) : p1 . compareTo ( p2 ) ; if ( cmp != 0 ) return cmp ; } if ( part1 . length == part2 . length ) return 0 ; else return part1 . length > idx ? 1 : - 1 ; }
apacheignite/ignite | public static IgniteProductVersion productVersion ( ClusterNode node ) { String verStr = node . attribute ( ATTR_BUILD_VER ) ; String buildDate = node . attribute ( ATTR_BUILD_DATE ) ; if ( buildDate != null ) verStr += ' - ' + buildDate ; return IgniteProductVersion . fromString ( verStr ) ; }
apacheignite/ignite | public static boolean isJavaVersionAtLeast ( String v ) { return compareVersionNumbers ( javaRtVer , v ) >= 0 ; }
apacheignite/ignite | public static String jreName ( ) { return javaRtName ; }
apacheignite/ignite | public static String jreVersion ( ) { return javaRtVer ; }
apacheignite/ignite | public static boolean isHotSpot ( ) { return jvmImplName . contains ( " Java ▁ HotSpot ( TM ) " ) ; }
apacheignite/ignite | @ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , Callable < R > c ) throws IgniteCheckedException { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . call ( ) ; } catch ( IgniteCheckedException | RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
apacheignite/ignite | @ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , IgniteOutClosure < R > c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . apply ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
apacheignite/ignite | public static void wrapThreadLoader ( ClassLoader ldr , Runnable c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; c . run ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
apacheignite/ignite | public static String toShortString ( ClusterNode n ) { return " GridNode ▁ [ id = " + n . id ( ) + " , ▁ order = " + n . order ( ) + " , ▁ addr = " + n . addresses ( ) + " , ▁ daemon = " + n . isDaemon ( ) + ' ] ' ; }
apacheignite/ignite | public static String toShortString ( Collection < ? extends ClusterNode > ns ) { SB sb = new SB ( " Grid ▁ nodes ▁ [ cnt = " + ns . size ( ) ) ; for ( ClusterNode n : ns ) sb . a ( " , ▁ " ) . a ( toShortString ( n ) ) ; return sb . a ( ' ] ' ) . toString ( ) ; }
apacheignite/ignite | public static int [ ] toIntArray ( @ Nullable Collection < Integer > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_INTS ; int [ ] arr = new int [ c . size ( ) ] ; int idx = 0 ; for ( Integer i : c ) arr [ idx ++ ] = i ; return arr ; }
apacheignite/ignite | public static int [ ] addAll ( int [ ] arr1 , int [ ] arr2 ) { int [ ] all = new int [ arr1 . length + arr2 . length ] ; System . arraycopy ( arr1 , 0 , all , 0 , arr1 . length ) ; System . arraycopy ( arr2 , 0 , all , arr1 . length , arr2 . length ) ; return all ; }
apacheignite/ignite | public static List < Integer > toIntList ( @ Nullable int [ ] arr , IgnitePredicate < Integer > ... p ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Integer > ret = new ArrayList < > ( arr . length ) ; if ( F . isEmpty ( p ) ) for ( int i : arr ) ret . add ( i ) ; else { for ( int i : arr ) if ( F . isAll ( i , p ) ) ret . add ( i ) ; } return ret ; }
apacheignite/ignite | public static long [ ] toLongArray ( @ Nullable Collection < Long > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_LONGS ; long [ ] arr = new long [ c . size ( ) ] ; int idx = 0 ; for ( Long l : c ) arr [ idx ++ ] = l ; return arr ; }
apacheignite/ignite | public static List < Long > toLongList ( @ Nullable long [ ] arr ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Long > ret = new ArrayList < > ( arr . length ) ; for ( long l : arr ) ret . add ( l ) ; return ret ; }
apacheignite/ignite | ) public static < T > T [ ] toArray ( Collection < ? extends T > c , T [ ] arr ) { T [ ] a = c . toArray ( arr ) ; assert a == arr ; return arr ; }
apacheignite/ignite | public static int [ ] unique ( int [ ] a , int aLen , int [ ] b , int bLen ) { assert a != null ; assert b != null ; assert isIncreasingArray ( a , aLen ) ; assert isIncreasingArray ( b , bLen ) ; int [ ] res = new int [ aLen + bLen ] ; int resLen = 0 ; int i = 0 ; int j = 0 ; while ( i < aLen && j < bLen ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ resLen ++ ] = a [ i ++ ] ; else res [ resLen ++ ] = b [ j ++ ] ; } while ( i < aLen ) res [ resLen ++ ] = a [ i ++ ] ; while ( j < bLen ) res [ resLen ++ ] = b [ j ++ ] ; return copyIfExceeded ( res , resLen ) ; }
apacheignite/ignite | public static int [ ] difference ( int [ ] a , int aLen , int [ ] b , int bLen ) { assert a != null ; assert b != null ; assert isIncreasingArray ( a , aLen ) ; assert isIncreasingArray ( b , bLen ) ; int [ ] res = new int [ aLen ] ; int resLen = 0 ; int i = 0 ; int j = 0 ; while ( i < aLen && j < bLen ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ resLen ++ ] = a [ i ++ ] ; else j ++ ; } while ( i < aLen ) res [ resLen ++ ] = a [ i ++ ] ; return copyIfExceeded ( res , resLen ) ; }
apacheignite/ignite | public static boolean isIncreasingArray ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) return false ; } return true ; }
apacheignite/ignite | public static boolean isNonDecreasingArray ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) return false ; } return true ; }
apacheignite/ignite | public static int [ ] copyIfExceeded ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; return len == arr . length ? arr : Arrays . copyOf ( arr , len ) ; }
apacheignite/ignite | private static boolean checkNextToken ( StringTokenizer t , String str , String date ) throws IgniteCheckedException { try { if ( t . nextToken ( ) . equals ( str ) ) return true ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + date ) ; } catch ( NoSuchElementException ignored ) { return false ; } }
apacheignite/ignite | public static Calendar parseIsoDate ( String str ) throws IgniteCheckedException { StringTokenizer t = new StringTokenizer ( str , " + - : . TZ " , true ) ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; try { if ( t . hasMoreTokens ( ) ) cal . set ( Calendar . YEAR , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( checkNextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MONTH , Integer . parseInt ( t . nextToken ( ) ) - 1 ) ; else return cal ; if ( checkNextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . DAY_OF_MONTH , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( checkNextToken ( t , " T " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . HOUR_OF_DAY , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; return cal ; } if ( checkNextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MINUTE , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; return cal ; } if ( ! t . hasMoreTokens ( ) ) return cal ; String tok = t . nextToken ( ) ; if ( " : " . equals ( tok ) ) { if ( t . hasMoreTokens ( ) ) { cal . set ( Calendar . SECOND , Integer . parseInt ( t . nextToken ( ) ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; if ( " . " . equals ( tok ) ) { String nt = t . nextToken ( ) ; while ( nt . length ( ) < 3 ) nt += "0" ; nt = nt . substring ( 0 , 3 ) ; cal . set ( Calendar . MILLISECOND , Integer . parseInt ( nt ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; } else cal . set ( Calendar . MILLISECOND , 0 ) ; } else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } else { cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; } if ( ! " Z " . equals ( tok ) ) { if ( ! " + " . equals ( tok ) && ! " - " . equals ( tok ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; boolean plus = " + " . equals ( tok ) ; if ( ! t . hasMoreTokens ( ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; tok = t . nextToken ( ) ; int tzHour ; int tzMin ; if ( tok . length ( ) == 4 ) { tzHour = Integer . parseInt ( tok . substring ( 0 , 2 ) ) ; tzMin = Integer . parseInt ( tok . substring ( 2 , 4 ) ) ; } else { tzHour = Integer . parseInt ( tok ) ; if ( checkNextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) tzMin = Integer . parseInt ( t . nextToken ( ) ) ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } if ( plus ) cal . set ( Calendar . ZONE_OFFSET , ( tzHour * 60 + tzMin ) * 60 * 1000 ) ; else cal . set ( Calendar . ZONE_OFFSET , - ( tzHour * 60 + tzMin ) * 60 * 1000 ) ; } else cal . setTimeZone ( TimeZone . getTimeZone ( " GMT " ) ) ; } catch ( NumberFormatException ex ) { throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str , ex ) ; } return cal ; }
apacheignite/ignite | public static < V , C extends Collection < ? super V > > C addAll ( C c , V ... vals ) { Collections . addAll ( c , vals ) ; return c ; }
apacheignite/ignite | public static < K , V , M extends Map < K , V > > M addAll ( M m , Map . Entry < K , V > ... entries ) { for ( Map . Entry < K , V > e : entries ) m . put ( e . getKey ( ) , e . getValue ( ) ) ; return m ; }
apacheignite/ignite | public static < K , V , M extends Map < K , V > > M addAll ( M m , IgniteBiTuple < K , V > ... entries ) { for ( IgniteBiTuple < K , V > t : entries ) m . put ( t . get1 ( ) , t . get2 ( ) ) ; return m ; }
apacheignite/ignite | public static JMException jmException ( Throwable e ) { JMException x = new JMException ( ) ; x . initCause ( e ) ; return x ; }
apacheignite/ignite | public static Exception unwrap ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof GridClosureException ) { t = ( ( GridClosureException ) t ) . unwrap ( ) ; continue ; } return ( Exception ) t ; } }
apacheignite/ignite | public static IgniteCheckedException cast ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof GridClosureException ) { t = ( ( GridClosureException ) t ) . unwrap ( ) ; continue ; } if ( t instanceof IgniteCheckedException ) return ( IgniteCheckedException ) t ; if ( ! ( t instanceof IgniteException ) || t . getCause ( ) == null ) return new IgniteCheckedException ( t ) ; assert t . getCause ( ) != null ; t = t . getCause ( ) ; } }
apacheignite/ignite | public static boolean p2pLoader ( Object o ) { return o != null && p2pLoader ( o . getClass ( ) . getClassLoader ( ) ) ; }
apacheignite/ignite | public static boolean p2pLoader ( ClassLoader ldr ) { return ldr instanceof GridDeploymentInfo ; }
apacheignite/ignite | public static String format ( Date date , String ptrn ) { java . text . DateFormat format = new java . text . SimpleDateFormat ( ptrn ) ; return format . format ( date ) ; }
apacheignite/ignite | public static IgniteClosure < UUID , ClusterNode > id2Node ( final GridKernalContext ctx ) { assert ctx != null ; return new C1 < UUID , ClusterNode > ( ) { @ Nullable @ Override public ClusterNode apply ( UUID id ) { return ctx . discovery ( ) . node ( id ) ; } } ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( Thread t ) { dumpStack ( t , System . err ) ; }
apacheignite/ignite | ) @ Deprecated public static void dumpStack ( Thread t , PrintStream s ) { synchronized ( s ) { s . println ( " Dumping ▁ stack ▁ trace ▁ for ▁ thread : ▁ " + t ) ; for ( StackTraceElement trace : t . getStackTrace ( ) ) s . println ( " \tat ▁ " + trace ) ; } }
apacheignite/ignite | public static boolean isPrimitiveArray ( Object obj ) { Class < ? > cls = obj . getClass ( ) ; return cls . isArray ( ) && cls . getComponentType ( ) . isPrimitive ( ) ; }
apacheignite/ignite | public static boolean isPrimitiveOrWrapper ( Class < ? > cls ) { return cls . isPrimitive ( ) || Boolean . class . equals ( cls ) || Byte . class . equals ( cls ) || Character . class . equals ( cls ) || Short . class . equals ( cls ) || Integer . class . equals ( cls ) || Long . class . equals ( cls ) || Float . class . equals ( cls ) || Double . class . equals ( cls ) || Void . class . equals ( cls ) ; }
apacheignite/ignite | public static void await ( Condition cond ) throws IgniteInterruptedCheckedException { try { cond . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static boolean await ( Condition cond , long time , TimeUnit unit ) throws IgniteInterruptedCheckedException { try { return cond . await ( time , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void await ( CountDownLatch latch ) throws IgniteInterruptedCheckedException { try { if ( latch . getCount ( ) > 0 ) latch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static boolean await ( CountDownLatch latch , long timeout , TimeUnit unit ) throws IgniteInterruptedCheckedException { try { return latch . await ( timeout , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void awaitQuiet ( CountDownLatch latch ) { boolean interrupted = false ; while ( true ) { try { latch . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
apacheignite/ignite | public static void awaitQuiet ( CyclicBarrier barrier ) { boolean interrupted = false ; while ( true ) { try { barrier . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } catch ( BrokenBarrierException ignored ) { break ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
apacheignite/ignite | public static void sleep ( long ms ) throws IgniteInterruptedCheckedException { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void join ( GridWorker w ) throws IgniteInterruptedCheckedException { try { if ( w != null ) w . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static < T > T get ( Future < T > fut ) throws IgniteCheckedException { try { return fut . get ( ) ; } catch ( ExecutionException e ) { throw new IgniteCheckedException ( e . getCause ( ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } catch ( CancellationException e ) { throw new IgniteCheckedException ( e ) ; } }
apacheignite/ignite | public static void join ( Thread t ) throws IgniteInterruptedCheckedException { try { t . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void acquire ( Semaphore sem ) throws IgniteInterruptedCheckedException { try { sem . acquire ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static GridCacheAttributes [ ] cacheAttributes ( ClusterNode n ) { return n . attribute ( ATTR_CACHE ) ; }
apacheignite/ignite | public static boolean hasNearCache ( ClusterNode n , String cacheName ) { GridCacheAttributes [ ] caches = n . attribute ( ATTR_CACHE ) ; if ( caches != null ) for ( GridCacheAttributes attrs : caches ) if ( F . eq ( cacheName , attrs . cacheName ( ) ) ) return attrs . nearCacheEnabled ( ) ; return false ; }
apacheignite/ignite | public static void asyncLogError ( IgniteInternalFuture < ? > f , final IgniteLogger log ) { if ( f != null ) f . listen ( new CI1 < IgniteInternalFuture < ? > > ( ) { @ Override public void apply ( IgniteInternalFuture < ? > f ) { try { f . get ( ) ; } catch ( IgniteCheckedException e ) { U . error ( log , " Failed ▁ to ▁ execute ▁ future : ▁ " + f , e ) ; } } } ) ; }
apacheignite/ignite | public static Collection < UUID > nodeIds ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . viewReadOnly ( nodes , F . node2id ( ) ) ; }
apacheignite/ignite | public static Collection < UUID > gridIds ( @ Nullable Collection < ? extends Ignite > grids ) { return F . viewReadOnly ( grids , new C1 < Ignite , UUID > ( ) { @ Override public UUID apply ( Ignite g ) { return g . cluster ( ) . localNode ( ) . id ( ) ; } } ) ; }
apacheignite/ignite | public static Collection < String > grids2names ( @ Nullable Collection < ? extends Ignite > grids ) { return F . viewReadOnly ( grids , new C1 < Ignite , String > ( ) { @ Override public String apply ( Ignite g ) { return g . name ( ) ; } } ) ; }
apacheignite/ignite | public static Collection < String > nodes2names ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . viewReadOnly ( nodes , new C1 < ClusterNode , String > ( ) { @ Override public String apply ( ClusterNode n ) { return G . ignite ( n . id ( ) ) . name ( ) ; } } ) ; }
apacheignite/ignite | public static boolean addLastCause ( @ Nullable Throwable e , @ Nullable Throwable cause , IgniteLogger log ) { if ( e == null || cause == null ) return false ; for ( Throwable t = e ; t != null ; t = t . getCause ( ) ) { if ( t == cause ) return false ; if ( t . getCause ( ) == null || t . getCause ( ) == t ) { try { t . initCause ( cause ) ; } catch ( IllegalStateException ignored ) { error ( log , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain ▁ ( cause ▁ is ▁ printed ▁ here ▁ but ▁ will ▁ " + " not ▁ be ▁ propagated ▁ to ▁ callee ) : ▁ " + e , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain : ▁ " + e , cause ) ; } return true ; } } return false ; }
apacheignite/ignite | public static String nl ( ) { return NL ; }
apacheignite/ignite | public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Object obj ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( obj . getClass ( ) ) ) ; log = logRef . get ( ) ; } return log ; }
apacheignite/ignite | public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Class < ? > cls ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( cls ) ) ; log = logRef . get ( ) ; } return log ; }
apacheignite/ignite | public static int concurrentMapSegment ( int hash , int concurLvl ) { hash += ( hash << 15 ) ^ 0xffffcd7d ; hash ^= ( hash >>> 10 ) ; hash += ( hash << 3 ) ; hash ^= ( hash >>> 6 ) ; hash += ( hash << 2 ) + ( hash << 14 ) ; int shift = 0 ; int size = 1 ; while ( size < concurLvl ) { ++ shift ; size <<= 1 ; } int segmentShift = 32 - shift ; int segmentMask = size - 1 ; return ( hash >>> segmentShift ) & segmentMask ; }
apacheignite/ignite | public static < K , V > void printConcurrentHashMapInfo ( ConcurrentHashMap < K , V > map ) { assert map != null ; Object [ ] segs = field ( map , " segments " ) ; X . println ( " Concurrent ▁ map ▁ stats ▁ [ identityHash = ▁ " + System . identityHashCode ( map ) + " , ▁ segsCnt = " + segs . length + ' ] ' ) ; int emptySegsCnt = 0 ; int totalCollisions = 0 ; for ( int i = 0 ; i < segs . length ; i ++ ) { int segCnt = IgniteUtils . < Integer > field ( segs [ i ] , " count " ) ; if ( segCnt == 0 ) { emptySegsCnt ++ ; continue ; } Object [ ] tab = field ( segs [ i ] , " table " ) ; int tabLen = tab . length ; X . println ( " ▁ ▁ ▁ ▁ Segment - " + i + " ▁ [ count = " + segCnt + " , ▁ len = " + tabLen + ' ] ' ) ; Map < Integer , Integer > bucketsStats = new TreeMap < > ( ) ; for ( Object entry : tab ) { int cnt = 0 ; while ( entry != null ) { cnt ++ ; entry = field ( entry , " next " ) ; } Integer bucketCnt = bucketsStats . get ( cnt ) ; if ( bucketCnt == null ) bucketCnt = 0 ; bucketCnt ++ ; bucketsStats . put ( cnt , bucketCnt ) ; if ( cnt > 1 ) totalCollisions += ( cnt - 1 ) ; } for ( Map . Entry < Integer , Integer > e : bucketsStats . entrySet ( ) ) X . println ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Buckets ▁ with ▁ count ▁ " + e . getKey ( ) + " : ▁ " + e . getValue ( ) ) ; } X . println ( " ▁ ▁ ▁ ▁ Map ▁ summary ▁ [ emptySegs = " + emptySegsCnt + " , ▁ collisions = " + totalCollisions + ' ] ' ) ; }
apacheignite/ignite | public static < T > T field ( Object obj , String fieldName ) { assert obj != null ; assert fieldName != null ; try { for ( Class cls = obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { for ( Field field : cls . getDeclaredFields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; T val = ( T ) field . get ( obj ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } } } catch ( Exception e ) { throw new IgniteException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' , e ) ; } throw new IgniteException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' ) ; }
apacheignite/ignite | public static < T > T field ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Class c = cls ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { for ( Field field : c . getDeclaredFields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ class ▁ field ▁ ( field ▁ is ▁ not ▁ static ) ▁ [ cls = " + cls + " , ▁ fieldName = " + fieldName + ' ] ' ) ; boolean accessible = field . isAccessible ( ) ; T val ; try { field . setAccessible ( true ) ; val = ( T ) field . get ( null ) ; } finally { if ( ! accessible ) field . setAccessible ( false ) ; } return val ; } } } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ ( field ▁ was ▁ not ▁ found ) ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mtdName , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mtdName != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { Method mtd = null ; for ( Method declaredMtd : c . getDeclaredMethods ( ) ) { if ( declaredMtd . getName ( ) . equals ( mtdName ) ) { if ( mtd == null ) mtd = declaredMtd ; else throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( ambigous ▁ method ▁ name ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; } } if ( mtd == null ) continue ; boolean accessible = mtd . isAccessible ( ) ; T res ; try { mtd . setAccessible ( true ) ; res = ( T ) mtd . invoke ( obj , params ) ; } finally { if ( ! accessible ) mtd . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mtdName , Class [ ] paramTypes , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mtdName != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { Method mtd ; try { mtd = c . getDeclaredMethod ( mtdName , paramTypes ) ; } catch ( NoSuchMethodException ignored ) { continue ; } boolean accessible = mtd . isAccessible ( ) ; T res ; try { mtd . setAccessible ( true ) ; res = ( T ) mtd . invoke ( obj , params ) ; } finally { if ( ! accessible ) mtd . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | public static < T > T property ( Object obj , String propName ) { assert obj != null ; assert propName != null ; try { Method m ; try { m = obj . getClass ( ) . getMethod ( " get " + capitalFirst ( propName ) ) ; } catch ( NoSuchMethodException ignored ) { m = obj . getClass ( ) . getMethod ( " is " + capitalFirst ( propName ) ) ; } assert F . isEmpty ( m . getParameterTypes ( ) ) ; boolean accessible = m . isAccessible ( ) ; try { m . setAccessible ( true ) ; return ( T ) m . invoke ( obj ) ; } finally { m . setAccessible ( accessible ) ; } } catch ( Exception e ) { throw new IgniteException ( " Failed ▁ to ▁ get ▁ property ▁ value ▁ [ property = " + propName + " , ▁ obj = " + obj + ' ] ' , e ) ; } }
apacheignite/ignite | public static < T > T staticField ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Field field : cls . getDeclaredFields ( ) ) if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . isAccessible ( ) ; if ( ! accessible ) field . setAccessible ( true ) ; T val = ( T ) field . get ( null ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | private static String capitalFirst ( @ Nullable String str ) { return str == null ? null : str . isEmpty ( ) ? " " : Character . toUpperCase ( str . charAt ( 0 ) ) + str . substring ( 1 ) ; }
apacheignite/ignite | public static boolean isVisorNodeStartProperty ( String name ) { return IGNITE_SSH_HOST . equals ( name ) || IGNITE_SSH_USER_NAME . equals ( name ) ; }
apacheignite/ignite | public static boolean isVisorRequiredProperty ( String name ) { return " java . version " . equals ( name ) || " java . vm . name " . equals ( name ) || " os . arch " . equals ( name ) || " os . name " . equals ( name ) || " os . version " . equals ( name ) ; }
apacheignite/ignite | public static IgniteBiTuple < Object , Object > addLog4jNoOpLogger ( ) throws IgniteCheckedException { Object rootLog ; Object nullApp ; try { Class < ? > logCls = Class . forName ( " org . apache . log4j . Logger " ) ; rootLog = logCls . getMethod ( " getRootLogger " ) . invoke ( logCls ) ; try { nullApp = Class . forName ( " org . apache . log4j . varia . NullAppender " ) . newInstance ( ) ; } catch ( ClassNotFoundException ignore ) { return new IgniteBiTuple < > ( rootLog , null ) ; } Class appCls = Class . forName ( " org . apache . log4j . Appender " ) ; rootLog . getClass ( ) . getMethod ( " addAppender " , appCls ) . invoke ( rootLog , nullApp ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ add ▁ no - op ▁ logger ▁ for ▁ Log4j . " , e ) ; } return new IgniteBiTuple < > ( rootLog , nullApp ) ; }
apacheignite/ignite | public static void removeLog4jNoOpLogger ( IgniteBiTuple < Object , Object > t ) throws IgniteCheckedException { Object rootLog = t . get1 ( ) ; Object nullApp = t . get2 ( ) ; if ( nullApp == null ) return ; try { Class appenderCls = Class . forName ( " org . apache . log4j . Appender " ) ; rootLog . getClass ( ) . getMethod ( " removeAppender " , appenderCls ) . invoke ( rootLog , nullApp ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ remove ▁ previously ▁ added ▁ no - op ▁ logger ▁ for ▁ Log4j . " , e ) ; } }
apacheignite/ignite | public static Collection < Handler > addJavaNoOpLogger ( ) { Collection < Handler > savedHnds = new ArrayList < > ( ) ; Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . getHandlers ( ) ) { log . removeHandler ( h ) ; savedHnds . add ( h ) ; } ConsoleHandler hnd = new ConsoleHandler ( ) ; hnd . setLevel ( Level . OFF ) ; log . addHandler ( hnd ) ; return savedHnds ; }
apacheignite/ignite | public static void removeJavaNoOpLogger ( Collection < Handler > rmvHnds ) { Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . getHandlers ( ) ) log . removeHandler ( h ) ; if ( ! F . isEmpty ( rmvHnds ) ) { for ( Handler h : rmvHnds ) log . addHandler ( h ) ; } }
apacheignite/ignite | public static String nodeIdLogFileName ( UUID nodeId , String fileName ) { assert nodeId != null ; assert fileName != null ; fileName = GridFilenameUtils . separatorsToSystem ( fileName ) ; int dot = fileName . lastIndexOf ( ' . ' ) ; if ( dot < 0 || dot == fileName . length ( ) - 1 ) return fileName + ' - ' + U . id8 ( nodeId ) ; else return fileName . substring ( 0 , dot ) + ' - ' + U . id8 ( nodeId ) + fileName . substring ( dot ) ; }
apacheignite/ignite | public static String customDirectoryLogFileName ( @ Nullable String dir , String fileName ) { assert fileName != null ; if ( dir == null ) return fileName ; int sep = fileName . lastIndexOf ( File . separator ) ; return dir + ( sep < 0 ? File . separator + fileName : fileName . substring ( sep ) ) ; }
apacheignite/ignite | public static String fl ( String msg , Object ... args ) { assert args . length % 2 == 0 ; StringBuilder sb = new StringBuilder ( msg ) ; if ( args . length > 0 ) { sb . append ( " ▁ [ " ) ; for ( int i = 0 ; i < args . length / 2 ; i ++ ) { sb . append ( args [ i * 2 ] ) . append ( ' = ' ) . append ( args [ i * 2 + 1 ] ) ; sb . append ( " , ▁ " ) ; } sb . delete ( sb . length ( ) - 2 , sb . length ( ) ) ; sb . append ( ' ] ' ) ; } return sb . toString ( ) ; }
apacheignite/ignite | public static int safeAbs ( int i ) { i = Math . abs ( i ) ; return i < 0 ? 0 : i ; }
apacheignite/ignite | @ Nullable public static Class < ? > box ( @ Nullable Class < ? > cls ) { if ( cls == null ) return null ; if ( ! cls . isPrimitive ( ) ) return cls ; return boxedClsMap . get ( cls ) ; }
apacheignite/ignite | public static Class < ? > forName ( String clsName , @ Nullable ClassLoader ldr ) throws ClassNotFoundException { assert clsName != null ; Class < ? > cls = primitiveMap . get ( clsName ) ; if ( cls != null ) return cls ; if ( ldr == null ) ldr = gridClassLoader ; ConcurrentMap < String , Class > ldrMap = classCache . get ( ldr ) ; if ( ldrMap == null ) { ConcurrentMap < String , Class > old = classCache . putIfAbsent ( ldr , ldrMap = new ConcurrentHashMap8 < > ( ) ) ; if ( old != null ) ldrMap = old ; } cls = ldrMap . get ( clsName ) ; if ( cls == null ) { Class old = ldrMap . putIfAbsent ( clsName , cls = Class . forName ( clsName , true , ldr ) ) ; if ( old != null ) cls = old ; } return cls ; }
apacheignite/ignite | public static void clearClassCache ( ClassLoader ldr ) { classCache . remove ( ldr ) ; }
apacheignite/ignite | public static void clearClassCache ( ) { classCache . clear ( ) ; }
apacheignite/ignite | public static int hash ( int h ) { h ^= h >>> 16 ; h *= 0x85ebca6b ; h ^= h >>> 13 ; h *= 0xc2b2ae35 ; return ( h >>> 16 ) ^ h ; }
apacheignite/ignite | public static int hash ( Object key ) { return hash ( key . hashCode ( ) ) ; }
apacheignite/ignite | public static int jvmPid ( ) { String name = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; try { int idx = name . indexOf ( ' @ ' ) ; return idx > 0 ? Integer . parseInt ( name . substring ( 0 , idx ) ) : - 1 ; } catch ( NumberFormatException ignored ) { return - 1 ; } }
apacheignite/ignite | public static List < String > jvmArgs ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; }
apacheignite/ignite | private static boolean unsafeByteArrayCopyAvailable ( ) { try { Class < ? extends Unsafe > unsafeCls = UNSAFE . getClass ( ) ; unsafeCls . getMethod ( " copyMemory " , Object . class , long . class , Object . class , long . class , long . class ) ; return true ; } catch ( Exception ignored ) { return false ; } }
apacheignite/ignite | public static int arrayCopy ( byte [ ] src , int off , byte [ ] resBuf , int resOff , int len ) { assert resBuf . length >= resOff + len ; if ( UNSAFE_BYTE_ARR_CP ) UNSAFE . copyMemory ( src , BYTE_ARRAY_DATA_OFFSET + off , resBuf , BYTE_ARRAY_DATA_OFFSET + resOff , len ) ; else System . arraycopy ( src , off , resBuf , resOff , len ) ; return resOff + len ; }
apacheignite/ignite | public static String consistentId ( Collection < String > addrs , int port ) { assert ! F . isEmpty ( addrs ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String addr : addrs ) sb . append ( addr ) . append ( ' , ' ) ; sb . delete ( sb . length ( ) - 1 , sb . length ( ) ) ; sb . append ( ' : ' ) . append ( port ) ; return sb . toString ( ) ; }
apacheignite/ignite | public static boolean overridesEqualsAndHashCode ( Object obj ) { try { Class < ? > cls = obj . getClass ( ) ; return ! Object . class . equals ( cls . getMethod ( " equals " , Object . class ) . getDeclaringClass ( ) ) && ! Object . class . equals ( cls . getMethod ( " hashCode " ) . getDeclaringClass ( ) ) ; } catch ( NoSuchMethodException | SecurityException ignore ) { return true ; } }
apacheignite/ignite | public static boolean isMacInvalidArgumentError ( Exception e ) { return U . isMacOs ( ) && e instanceof SocketException && e . getMessage ( ) != null && e . getMessage ( ) . toLowerCase ( ) . contains ( " invalid ▁ argument " ) ; }
apacheignite/ignite | @ Nullable public static < T > T firstNotNull ( @ Nullable T ... vals ) { if ( vals == null ) return null ; for ( T val : vals ) { if ( val != null ) return val ; } return null ; }
apacheignite/ignite | public static void startLifecycleAware ( Iterable < ? > objs ) throws IgniteCheckedException { try { for ( Object obj : objs ) { if ( obj instanceof LifecycleAware ) ( ( LifecycleAware ) obj ) . start ( ) ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ start ▁ component : ▁ " + e , e ) ; } }
apacheignite/ignite | public static void stopLifecycleAware ( IgniteLogger log , Iterable < ? > objs ) { for ( Object obj : objs ) { if ( obj instanceof LifecycleAware ) { try { ( ( LifecycleAware ) obj ) . stop ( ) ; } catch ( Exception e ) { U . error ( log , " Failed ▁ to ▁ stop ▁ component ▁ ( ignoring ) : ▁ " + obj , e ) ; } } } }
apacheignite/ignite | public static Map < String , Collection < ClusterNode > > neighborhood ( Iterable < ClusterNode > nodes ) { Map < String , Collection < ClusterNode > > map = new HashMap < > ( ) ; for ( ClusterNode n : nodes ) { String macs = n . attribute ( ATTR_MACS ) ; assert macs != null : " Missing ▁ MACs ▁ attribute : ▁ " + n ; Collection < ClusterNode > neighbors = map . get ( macs ) ; if ( neighbors == null ) map . put ( macs , neighbors = new ArrayList < > ( 2 ) ) ; neighbors . add ( n ) ; } return map ; }
apacheignite/ignite | public static Collection < InetAddress > toInetAddresses ( ClusterNode node ) throws IgniteCheckedException { return toInetAddresses ( node . addresses ( ) , node . hostNames ( ) ) ; }
apacheignite/ignite | public static Collection < InetAddress > toInetAddresses ( Collection < String > addrs , Collection < String > hostNames ) throws IgniteCheckedException { List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; for ( String addr : addrs ) { String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; InetAddress inetAddr = null ; if ( ! F . isEmpty ( hostName ) ) { try { inetAddr = InetAddress . getByName ( hostName ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr == null || inetAddr . isLoopbackAddress ( ) ) { try { inetAddr = InetAddress . getByName ( addr ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr != null ) res . add ( inetAddr ) ; } if ( res . isEmpty ( ) ) throw new IgniteCheckedException ( " Addresses ▁ can ▁ not ▁ be ▁ resolved ▁ [ addr = " + addrs + " , ▁ hostNames = " + hostNames + ' ] ' ) ; return F . viewListReadOnly ( res , F . < InetAddress > identity ( ) ) ; }
apacheignite/ignite | public static Collection < InetSocketAddress > toSocketAddresses ( ClusterNode node , int port ) { return toSocketAddresses ( node . addresses ( ) , node . hostNames ( ) , port ) ; }
apacheignite/ignite | public static Collection < InetSocketAddress > toSocketAddresses ( Collection < String > addrs , Collection < String > hostNames , int port ) { List < InetSocketAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; for ( String addr : addrs ) { String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; if ( ! F . isEmpty ( hostName ) ) { InetSocketAddress inetSockAddr = new InetSocketAddress ( hostName , port ) ; if ( inetSockAddr . isUnresolved ( ) || inetSockAddr . getAddress ( ) . isLoopbackAddress ( ) ) inetSockAddr = new InetSocketAddress ( addr , port ) ; res . add ( inetSockAddr ) ; } res . add ( new InetSocketAddress ( addr , port ) ) ; } return F . viewListReadOnly ( res , F . < InetSocketAddress > identity ( ) ) ; }
apacheignite/ignite | public static Collection < InetSocketAddress > resolveAddresses ( AddressResolver addrRslvr , Iterable < String > addrs , int port ) throws IgniteSpiException { assert addrRslvr != null ; Collection < InetSocketAddress > extAddrs = new HashSet < > ( ) ; for ( String addr : addrs ) { InetSocketAddress sockAddr = new InetSocketAddress ( addr , port ) ; if ( ! sockAddr . isUnresolved ( ) ) { try { Collection < InetSocketAddress > extAddrs0 = addrRslvr . getExternalAddresses ( sockAddr ) ; if ( extAddrs0 != null ) extAddrs . addAll ( extAddrs0 ) ; } catch ( IgniteCheckedException e ) { throw new IgniteSpiException ( " Failed ▁ to ▁ get ▁ mapped ▁ external ▁ addresses ▁ " + " [ addrRslvr = " + addrRslvr + " , ▁ addr = " + addr + ' ] ' , e ) ; } } } return extAddrs ; }
apacheignite/ignite | public static String addressesAsString ( ClusterNode node ) { return addressesAsString ( node . addresses ( ) , node . hostNames ( ) ) ; }
apacheignite/ignite | public static String addressesAsString ( Collection < String > addrs , Collection < String > hostNames ) { if ( F . isEmpty ( addrs ) ) return " " ; if ( F . isEmpty ( hostNames ) ) return addrs . toString ( ) ; SB sb = new SB ( " [ " ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; boolean first = true ; for ( String addr : addrs ) { if ( first ) first = false ; else sb . a ( " , ▁ " ) ; String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; sb . a ( hostName != null ? hostName : " " ) . a ( ' / ' ) . a ( addr ) ; } sb . a ( ' ] ' ) ; return sb . toString ( ) ; }
apacheignite/ignite | public static void setWorkDirectory ( @ Nullable String userWorkDir , @ Nullable String userIgniteHome ) throws IgniteCheckedException { String igniteWork0 = igniteWork ; if ( igniteWork0 == null ) { synchronized ( IgniteUtils . class ) { igniteWork0 = igniteWork ; if ( igniteWork0 != null ) return ; File workDir ; if ( ! F . isEmpty ( userWorkDir ) ) workDir = new File ( userWorkDir ) ; else if ( ! F . isEmpty ( IGNITE_WORK_DIR ) ) workDir = new File ( IGNITE_WORK_DIR ) ; else if ( ! F . isEmpty ( userIgniteHome ) ) workDir = new File ( userIgniteHome , " work " ) ; else { String tmpDirPath = System . getProperty ( " java . io . tmpdir " ) ; if ( tmpDirPath == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ work ▁ directory ▁ in ▁ OS ▁ temp ▁ " + " ( property ▁ ' java . io . tmpdir ' ▁ is ▁ null ) . " ) ; workDir = new File ( tmpDirPath , " ignite " + File . separator + " work " ) ; } if ( ! workDir . isAbsolute ( ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ path ▁ must ▁ be ▁ absolute : ▁ " + workDir ) ; if ( ! mkdirs ( workDir ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + workDir ) ; if ( ! workDir . canRead ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ work ▁ directory : ▁ " + workDir ) ; if ( ! workDir . canWrite ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ work ▁ directory : ▁ " + workDir ) ; igniteWork = workDir . getAbsolutePath ( ) ; } } }
apacheignite/ignite | public static void nullifyHomeDirectory ( ) { ggHome = null ; }
apacheignite/ignite | public static void nullifyWorkDirectory ( ) { igniteWork = null ; }
apacheignite/ignite | public static File resolveWorkDirectory ( String path , boolean delIfExist ) throws IgniteCheckedException { File dir = new File ( path ) ; if ( ! dir . isAbsolute ( ) ) { String ggWork0 = igniteWork ; if ( F . isEmpty ( ggWork0 ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ resolve ▁ path ▁ ( work ▁ directory ▁ has ▁ not ▁ been ▁ set ) : ▁ " + path ) ; dir = new File ( ggWork0 , dir . getPath ( ) ) ; } if ( delIfExist && dir . exists ( ) ) { if ( ! U . delete ( dir ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ delete ▁ directory : ▁ " + dir ) ; } if ( ! mkdirs ( dir ) ) throw new IgniteCheckedException ( " Directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + dir ) ; if ( ! dir . canRead ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ directory : ▁ " + dir ) ; if ( ! dir . canWrite ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ directory : ▁ " + dir ) ; return dir ; }
apacheignite/ignite | public static IgniteCheckedException exceptionWithSuppressed ( String msg , @ Nullable Collection < Throwable > suppressed ) { IgniteCheckedException e = new IgniteCheckedException ( msg ) ; if ( suppressed != null ) { for ( Throwable th : suppressed ) e . addSuppressed ( th ) ; } return e ; }
apacheignite/ignite | @ Nullable public static String lambdaEnclosingClassName ( String clsName ) { int idx = clsName . indexOf ( " $ $ Lambda $ " ) ; return idx != - 1 ? clsName . substring ( 0 , idx ) : null ; }
apacheignite/ignite | public static int toDigit ( char ch , int idx ) throws IgniteCheckedException { int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) throw new IgniteCheckedException ( " Illegal ▁ hexadecimal ▁ character ▁ " + ch + " ▁ at ▁ index ▁ " + idx ) ; return digit ; }
apacheignite/ignite | public static ClusterNode oldest ( Collection < ClusterNode > c , @ Nullable IgnitePredicate < ClusterNode > p ) { ClusterNode oldest = null ; long minOrder = Long . MAX_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) < minOrder ) { oldest = n ; minOrder = n . order ( ) ; } } return oldest ; }
apacheignite/ignite | public static ClusterNode youngest ( Collection < ClusterNode > c , @ Nullable IgnitePredicate < ClusterNode > p ) { ClusterNode youngest = null ; long maxOrder = Long . MIN_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) > maxOrder ) { youngest = n ; maxOrder = n . order ( ) ; } } return youngest ; }
apacheignite/ignite | public static long writeGridUuid ( byte [ ] arr , long off , @ Nullable IgniteUuid uid ) { UNSAFE . putBoolean ( arr , off ++ , uid != null ) ; if ( uid != null ) { UNSAFE . putLong ( arr , off , uid . globalId ( ) . getMostSignificantBits ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , uid . globalId ( ) . getLeastSignificantBits ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , uid . localId ( ) ) ; off += 8 ; } return off ; }
apacheignite/ignite | @ Nullable public static IgniteUuid readGridUuid ( byte [ ] arr , long off ) { if ( UNSAFE . getBoolean ( arr , off ++ ) ) { long most = UNSAFE . getLong ( arr , off ) ; off += 8 ; long least = UNSAFE . getLong ( arr , off ) ; off += 8 ; UUID globalId = new UUID ( most , least ) ; long locId = UNSAFE . getLong ( arr , off ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
apacheignite/ignite | @ Nullable public static IgniteUuid readGridUuid ( long ptr ) { if ( UNSAFE . getBoolean ( null , ptr ++ ) ) { long most = UNSAFE . getLong ( ptr ) ; ptr += 8 ; long least = UNSAFE . getLong ( ptr ) ; ptr += 8 ; UUID globalId = new UUID ( most , least ) ; long locId = UNSAFE . getLong ( ptr ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
apacheignite/ignite | public static long writeVersion ( byte [ ] arr , long off , GridCacheVersion ver ) { boolean verEx = ver instanceof GridCacheVersionEx ; UNSAFE . putBoolean ( arr , off ++ , verEx ) ; if ( verEx ) { GridCacheVersion drVer = ver . conflictVersion ( ) ; assert drVer != null ; UNSAFE . putInt ( arr , off , drVer . topologyVersion ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , drVer . nodeOrderAndDrIdRaw ( ) ) ; off += 4 ; UNSAFE . putLong ( arr , off , drVer . globalTime ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , drVer . order ( ) ) ; off += 8 ; } UNSAFE . putInt ( arr , off , ver . topologyVersion ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , ver . nodeOrderAndDrIdRaw ( ) ) ; off += 4 ; UNSAFE . putLong ( arr , off , ver . globalTime ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , ver . order ( ) ) ; off += 8 ; return off ; }
apacheignite/ignite | public static GridCacheVersion readVersion ( long ptr , boolean verEx ) { GridCacheVersion ver = new GridCacheVersion ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) ) ; if ( verEx ) { ptr += 24 ; ver = new GridCacheVersionEx ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) , ver ) ; } return ver ; }
apacheignite/ignite | public static GridCacheVersion readVersion ( byte [ ] arr , long off , boolean verEx ) { int topVer = UNSAFE . getInt ( arr , off ) ; off += 4 ; int nodeOrderDrId = UNSAFE . getInt ( arr , off ) ; off += 4 ; long globalTime = UNSAFE . getLong ( arr , off ) ; off += 8 ; long order = UNSAFE . getLong ( arr , off ) ; off += 8 ; GridCacheVersion ver = new GridCacheVersion ( topVer , nodeOrderDrId , globalTime , order ) ; if ( verEx ) { topVer = UNSAFE . getInt ( arr , off ) ; off += 4 ; nodeOrderDrId = UNSAFE . getInt ( arr , off ) ; off += 4 ; globalTime = UNSAFE . getLong ( arr , off ) ; off += 8 ; order = UNSAFE . getLong ( arr , off ) ; ver = new GridCacheVersionEx ( topVer , nodeOrderDrId , globalTime , order , ver ) ; } return ver ; }
apacheignite/ignite | public static byte [ ] copyMemory ( long ptr , int size ) { byte [ ] res = new byte [ size ] ; UNSAFE . copyMemory ( null , ptr , res , BYTE_ARRAY_DATA_OFFSET , size ) ; return res ; }
apacheignite/ignite | public static int capacity ( int expSize ) { if ( expSize < 3 ) return expSize + 1 ; if ( expSize < ( 1 << 30 ) ) return expSize + expSize / 3 ; return Integer . MAX_VALUE ; }
apacheignite/ignite | public static < K , V > HashMap < K , V > newHashMap ( int expSize ) { return new HashMap < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < K , V > LinkedHashMap < K , V > newLinkedHashMap ( int expSize ) { return new LinkedHashMap < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < T > HashSet < T > newHashSet ( int expSize ) { return new HashSet < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < T > LinkedHashSet < T > newLinkedHashSet ( int expSize ) { return new LinkedHashSet < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < K , V > Map < K , V > limitedMap ( int limit ) { if ( limit == 0 ) return Collections . emptyMap ( ) ; if ( limit < 5 ) return new GridLeanMap < > ( limit ) ; return new HashMap < > ( capacity ( limit ) , 0.75f ) ; }
apacheignite/ignite | public static Comparator < InetSocketAddress > inetAddressesComparator ( final boolean sameHost ) { return new Comparator < InetSocketAddress > ( ) { @ Override public int compare ( InetSocketAddress addr1 , InetSocketAddress addr2 ) { if ( addr1 . isUnresolved ( ) && addr2 . isUnresolved ( ) ) return 0 ; if ( addr1 . isUnresolved ( ) || addr2 . isUnresolved ( ) ) return addr1 . isUnresolved ( ) ? 1 : - 1 ; boolean addr1Loopback = addr1 . getAddress ( ) . isLoopbackAddress ( ) ; if ( addr1Loopback == addr2 . getAddress ( ) . isLoopbackAddress ( ) ) return 0 ; if ( sameHost ) return addr1Loopback ? - 1 : 1 ; else return addr1Loopback ? 1 : - 1 ; } } ; }
apacheignite/ignite | @ Nullable public static Method findNonPublicMethod ( Class < ? > cls , String name , Class < ? > ... paramTypes ) { while ( cls != null ) { try { Method mtd = cls . getDeclaredMethod ( name , paramTypes ) ; if ( mtd . getReturnType ( ) != void . class ) { mtd . setAccessible ( true ) ; return mtd ; } } catch ( NoSuchMethodException ignored ) { } cls = cls . getSuperclass ( ) ; } return null ; }
apacheignite/ignite | public static < T extends R , R > List < R > arrayList ( Collection < T > c , @ Nullable IgnitePredicate < ? super T > ... p ) { assert c != null ; return IgniteUtils . arrayList ( c , c . size ( ) , p ) ; }
apacheignite/ignite | public static < T extends R , R > List < R > arrayList ( Collection < T > c ) { assert c != null ; return new ArrayList < R > ( c ) ; }
apacheignite/ignite | public static < T extends R , R > List < R > arrayList ( Iterable < T > c , int cap , @ Nullable IgnitePredicate < ? super T > ... p ) { assert c != null ; assert cap >= 0 ; List < R > list = new ArrayList < > ( cap ) ; for ( T t : c ) { if ( F . isAll ( t , p ) ) list . add ( t ) ; } return list ; }
apacheignite/ignite | public static int writeMessageFully ( Message msg , OutputStream out , ByteBuffer buf , MessageWriter writer ) throws IOException { assert msg != null ; assert out != null ; assert buf != null ; assert buf . hasArray ( ) ; boolean finished = false ; int cnt = 0 ; while ( ! finished ) { finished = msg . writeTo ( buf , writer ) ; out . write ( buf . array ( ) , 0 , buf . position ( ) ) ; cnt += buf . position ( ) ; buf . clear ( ) ; } return cnt ; }
apacheignite/ignite | public static void assertParameter ( boolean cond , String condDesc ) throws IgniteException { if ( ! cond ) throw new IgniteException ( " Parameter ▁ failed ▁ condition ▁ check : ▁ " + condDesc ) ; }
apacheignite/ignite | public static boolean hasSharedMemory ( ) { if ( hasShmem == null ) { if ( isWindows ( ) ) hasShmem = false ; else { try { IpcSharedMemoryNativeLoader . load ( null ) ; hasShmem = true ; } catch ( IgniteCheckedException ignore ) { hasShmem = false ; } } } return hasShmem ; }
apacheignite/ignite | public static void writeLock ( ReadWriteLock lock ) throws IgniteInterruptedCheckedException { try { lock . writeLock ( ) . lockInterruptibly ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static byte directProtocolVersion ( GridKernalContext ctx , UUID nodeId ) throws IgniteCheckedException { assert nodeId != null ; ClusterNode node = ctx . discovery ( ) . node ( nodeId ) ; if ( node == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ define ▁ communication ▁ protocol ▁ version ▁ " + " ( has ▁ node ▁ left ▁ topology ? ) : ▁ " + nodeId ) ; assert ! node . isLocal ( ) ; Byte attr = node . attribute ( GridIoManager . DIRECT_PROTO_VER_ATTR ) ; byte rmtProtoVer = attr != null ? attr : 1 ; if ( rmtProtoVer < GridIoManager . DIRECT_PROTO_VER ) return rmtProtoVer ; else return GridIoManager . DIRECT_PROTO_VER ; }
BlueBrain/bluima | public static String extractText ( Article article ) { StringBuilder sb = new StringBuilder ( ) ; List < Abstract > abstracts = article . getFront ( ) . getArticleMeta ( ) . getAbstract ( ) ; for ( Abstract abstrct : abstracts ) { for ( Sec sec : abstrct . getSec ( ) ) { processTextContent ( sec . getAddressOrAlternativesOrArray ( ) , sb , true ) ; } } sb . append ( ' \n ' ) ; Body body = article . getBody ( ) ; if ( body != null ) { for ( Sec sec : body . getSec ( ) ) { Title title = sec . getTitle ( ) ; if ( title != null && title . getContent ( ) != null ) { processTextContent ( title . getContent ( ) , sb , true ) ; sb . append ( ' \n ' ) ; } processTextContent ( sec . getAddressOrAlternativesOrArray ( ) , sb , false ) ; } } return removeNoise ( sb . toString ( ) ) ; }
BlueBrain/bluima | private static String removeNoise ( String s ) { return s . replace ( " ▁ ▁ ▁ " , " ▁ " ) . replace ( " ▁ ▁ " , " ▁ " ) . replace ( " ▁ , ▁ " , " ▁ " ) . replace ( " ▁ ( ▁ ) " , " " ) . replace ( " & # x000a0 ; " , " ▁ " ) . replace ( " " , " ▁ " ) . replace ( " [ ▁ – ▁ ] " , " ▁ " ) . replace ( " [ ▁ ] " , " " ) ; }
BlueBrain/bluima | private static void processTextContent ( List < Object > contents , StringBuilder sb , boolean addSpace ) { for ( Object o : contents ) { if ( o instanceof P ) { P p = ( P ) o ; processTextContent ( p . getContent ( ) , sb , true ) ; sb . append ( ' \n ' ) ; } else if ( o instanceof Italic ) { Italic i = ( Italic ) o ; processTextContent ( i . getContent ( ) , sb , true ) ; } else if ( o instanceof Bold ) { Bold b = ( Bold ) o ; processTextContent ( b . getContent ( ) , sb , true ) ; } else if ( o instanceof Monospace ) { Monospace m = ( Monospace ) o ; processTextContent ( m . getContent ( ) , sb , true ) ; } else if ( o instanceof Sup ) { Sup s = ( Sup ) o ; processTextContent ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof Sub ) { Sub s = ( Sub ) o ; processTextContent ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof Sc ) { Sc s = ( Sc ) o ; processTextContent ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof Xref ) { } else if ( o instanceof String ) { sb . append ( o ) ; if ( addSpace ) sb . append ( ' ▁ ' ) ; } else { } } }
BlueBrain/bluima | public static Integer extractPmid ( Article article ) { try { List < ArticleId > ids = article . getFront ( ) . getArticleMeta ( ) . getArticleId ( ) ; for ( ArticleId id : ids ) { if ( " pmid " . equals ( id . getPubIdType ( ) ) ) { return parseInt ( id . getContent ( ) ) ; } } if ( ! ids . isEmpty ( ) && isNumeric ( ids . get ( 0 ) . getContent ( ) ) ) { return parseInt ( ids . get ( 0 ) . getContent ( ) ) ; } } catch ( Exception e ) { System . err . println ( e ) ; } return null ; }
BlueBrain/bluima | public static String extractDoi ( Article article ) { try { List < ArticleId > ids = article . getFront ( ) . getArticleMeta ( ) . getArticleId ( ) ; for ( ArticleId id : ids ) { if ( " doi " . equals ( id . getPubIdType ( ) ) ) { return id . getContent ( ) ; } } } catch ( Exception e ) { System . err . println ( e ) ; } return null ; }
BlueBrain/bluima | public static String extractTitle ( Article article ) { return null ; }
guedeWebGate/org.openntf.base | public static FieldChoicesdialogs fromValue ( String v ) { for ( FieldChoicesdialogs c : FieldChoicesdialogs . values ( ) ) { if ( c . value . equals ( v ) ) { return c ; } } throw new IllegalArgumentException ( v ) ; }
sapirgolan/MFIBlocking | public static CandidateMatchComparator getInstance ( ) { if ( self == null ) { self = new CandidateMatchComparator ( ) ; } return self ; }
zuoweitan/Hitalk | public static long addCap ( long a , long b ) { long u = a + b ; if ( u < 0L ) { u = Long . MAX_VALUE ; } return u ; }
zuoweitan/Hitalk | public static long getAndAddRequest ( AtomicLong requested , long n ) { while ( true ) { long current = requested . get ( ) ; long next = addCap ( current , n ) ; if ( requested . compareAndSet ( current , next ) ) { return current ; } } }
zuoweitan/Hitalk | public static void print ( ) { }
joewalnes/idea-community | public static void invokeLater ( Project p , Runnable r ) { invokeLater ( p , ModalityState . defaultModalityState ( ) , r ) ; }
joewalnes/idea-community | public static void invokeLater ( final Project p , final ModalityState state , final Runnable r ) { if ( isNoBackgroundMode ( ) ) { r . run ( ) ; } else { ApplicationManager . getApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { if ( p . isDisposed ( ) ) return ; r . run ( ) ; } } , state ) ; } }
joewalnes/idea-community | public static void invokeAndWait ( Project p , Runnable r ) { invokeAndWait ( p , ModalityState . defaultModalityState ( ) , r ) ; }
joewalnes/idea-community | public static void invokeAndWait ( final Project p , final ModalityState state , final Runnable r ) { if ( isNoBackgroundMode ( ) ) { r . run ( ) ; } else { if ( ApplicationManager . getApplication ( ) . isDispatchThread ( ) ) { r . run ( ) ; } else { ApplicationManager . getApplication ( ) . invokeAndWait ( new Runnable ( ) { public void run ( ) { if ( p . isDisposed ( ) ) return ; r . run ( ) ; } } , state ) ; } } }
joewalnes/idea-community | public static void invokeAndWaitWriteAction ( Project p , final Runnable r ) { invokeAndWait ( p , new Runnable ( ) { public void run ( ) { ApplicationManager . getApplication ( ) . runWriteAction ( r ) ; } } ) ; }
joewalnes/idea-community | public static void runDumbAware ( final Project project , final Runnable r ) { if ( DumbService . isDumbAware ( r ) ) { r . run ( ) ; } else { DumbService . getInstance ( project ) . runWhenSmart ( new Runnable ( ) { public void run ( ) { if ( project . isDisposed ( ) ) return ; r . run ( ) ; } } ) ; } }
joewalnes/idea-community | public static void runWhenInitialized ( final Project project , final Runnable r ) { if ( project . isDisposed ( ) ) return ; if ( isNoBackgroundMode ( ) ) { r . run ( ) ; return ; } if ( ! project . isInitialized ( ) ) { StartupManager . getInstance ( project ) . registerPostStartupActivity ( r ) ; return ; } runDumbAware ( project , r ) ; }
joewalnes/idea-community | public static boolean isNoBackgroundMode ( ) { return ( ApplicationManager . getApplication ( ) . isUnitTestMode ( ) || ApplicationManager . getApplication ( ) . isHeadlessEnvironment ( ) ) ; }
joewalnes/idea-community | public static boolean isInModalContext ( ) { if ( isNoBackgroundMode ( ) ) return false ; return LaterInvocator . isInModalContext ( ) ; }
joewalnes/idea-community | public static void showError ( Project project , String title , Throwable e ) { MavenLog . LOG . warn ( title , e ) ; Notifications . Bus . notify ( new Notification ( MAVEN_NOTIFICATION_GROUP , title , e . getMessage ( ) , NotificationType . ERROR ) , project ) ; }
joewalnes/idea-community | public static Properties getSystemProperties ( ) { Properties result = ( Properties ) System . getProperties ( ) . clone ( ) ; for ( String each : new THashSet < String > ( ( Set ) result . keySet ( ) ) ) { if ( each . startsWith ( " idea . " ) ) { result . remove ( each ) ; } } return result ; }
joewalnes/idea-community | public static Properties getEnvProperties ( ) { Properties reuslt = new Properties ( ) ; for ( Map . Entry < String , String > each : System . getenv ( ) . entrySet ( ) ) { if ( isMagicalProperty ( each . getKey ( ) ) ) continue ; reuslt . put ( each . getKey ( ) , each . getValue ( ) ) ; } return reuslt ; }
joewalnes/idea-community | private static boolean isMagicalProperty ( String key ) { return key . startsWith ( " = " ) ; }
joewalnes/idea-community | public static File getPluginSystemDir ( String folder ) { return new File ( PathManager . getSystemPath ( ) , " Maven " + " / " + folder ) . getAbsoluteFile ( ) ; }
joewalnes/idea-community | public static VirtualFile findProfilesXmlFile ( VirtualFile pomFile ) { return pomFile . getParent ( ) . findChild ( MavenConstants . PROFILES_XML ) ; }
joewalnes/idea-community | public static File getProfilesXmlIoFile ( VirtualFile pomFile ) { return new File ( pomFile . getParent ( ) . getPath ( ) , MavenConstants . PROFILES_XML ) ; }
joewalnes/idea-community | public static < T , U > List < T > collectFirsts ( List < Pair < T , U > > pairs ) { List < T > result = new ArrayList < T > ( pairs . size ( ) ) ; for ( Pair < T , ? > each : pairs ) { result . add ( each . first ) ; } return result ; }
joewalnes/idea-community | public static < T , U > List < U > collectSeconds ( List < Pair < T , U > > pairs ) { List < U > result = new ArrayList < U > ( pairs . size ( ) ) ; for ( Pair < T , U > each : pairs ) { result . add ( each . second ) ; } return result ; }
joewalnes/idea-community | public static List < String > collectPaths ( List < VirtualFile > files ) { return ContainerUtil . map ( files , new Function < VirtualFile , String > ( ) { public String fun ( VirtualFile file ) { return file . getPath ( ) ; } } ) ; }
joewalnes/idea-community | public static List < VirtualFile > collectFiles ( Collection < MavenProject > projects ) { return ContainerUtil . map ( projects , new Function < MavenProject , VirtualFile > ( ) { public VirtualFile fun ( MavenProject project ) { return project . getFile ( ) ; } } ) ; }
joewalnes/idea-community | public static < T > boolean equalAsSets ( final Collection < T > collection1 , final Collection < T > collection2 ) { return toSet ( collection1 ) . equals ( toSet ( collection2 ) ) ; }
joewalnes/idea-community | private static < T > Collection < T > toSet ( final Collection < T > collection ) { return ( collection instanceof Set ? collection : new THashSet < T > ( collection ) ) ; }
joewalnes/idea-community | public static < T , U > List < Pair < T , U > > mapToList ( Map < T , U > map ) { return ContainerUtil . map2List ( map . entrySet ( ) , new Function < Map . Entry < T , U > , Pair < T , U > > ( ) { public Pair < T , U > fun ( Map . Entry < T , U > tuEntry ) { return Pair . create ( tuEntry . getKey ( ) , tuEntry . getValue ( ) ) ; } } ) ; }
joewalnes/idea-community | public static String formatHtmlImage ( URL url ) { return " < img ▁ src = \" " + url + " \" > ▁ " ; }
joewalnes/idea-community | public static void runOrApplyMavenProjectFileTemplate ( Project project , VirtualFile file , MavenId projectId , MavenId parentId , boolean interactive ) throws IOException { Properties properties = new Properties ( ) ; Properties conditions = new Properties ( ) ; properties . setProperty ( " GROUP _ ID " , projectId . getGroupId ( ) ) ; properties . setProperty ( " ARTIFACT _ ID " , projectId . getArtifactId ( ) ) ; properties . setProperty ( " VERSION " , projectId . getVersion ( ) ) ; if ( parentId != null ) { conditions . setProperty ( " HAS _ PARENT " , " true " ) ; properties . setProperty ( " PARENT _ GROUP _ ID " , parentId . getGroupId ( ) ) ; properties . setProperty ( " PARENT _ ARTIFACT _ ID " , parentId . getArtifactId ( ) ) ; properties . setProperty ( " PARENT _ VERSION " , parentId . getVersion ( ) ) ; } runOrApplyFileTemplate ( project , file , MavenFileTemplateGroupFactory . MAVEN_PROJECT_XML_TEMPLATE , properties , conditions , interactive ) ; }
joewalnes/idea-community | public static void runFileTemplate ( Project project , VirtualFile file , String templateName ) throws IOException { runOrApplyFileTemplate ( project , file , templateName , new Properties ( ) , new Properties ( ) , true ) ; }
joewalnes/idea-community | private static void runOrApplyFileTemplate ( Project project , VirtualFile file , String templateName , Properties properties , Properties conditions , boolean interactive ) throws IOException { FileTemplateManager manager = FileTemplateManager . getInstance ( ) ; FileTemplate fileTemplate = manager . getJ2eeTemplate ( templateName ) ; Properties allProperties = manager . getDefaultProperties ( ) ; if ( ! interactive ) { allProperties . putAll ( properties ) ; } allProperties . putAll ( conditions ) ; String text = fileTemplate . getText ( allProperties ) ; Pattern pattern = Pattern . compile ( " \\ $ \\ { ( . * ) \\ } " ) ; Matcher matcher = pattern . matcher ( text ) ; StringBuffer builder = new StringBuffer ( ) ; while ( matcher . find ( ) ) { matcher . appendReplacement ( builder , " \\ $ " + matcher . group ( 1 ) . toUpperCase ( ) + " \\ $ " ) ; } matcher . appendTail ( builder ) ; text = builder . toString ( ) ; TemplateImpl template = ( TemplateImpl ) TemplateManager . getInstance ( project ) . createTemplate ( " " , " " , text ) ; for ( int i = 0 ; i < template . getSegmentsCount ( ) ; i ++ ) { if ( i == template . getEndSegmentNumber ( ) ) continue ; String name = template . getSegmentName ( i ) ; String value = " \" " + properties . getProperty ( name , " " ) + " \" " ; template . addVariable ( name , value , value , true ) ; } if ( interactive ) { OpenFileDescriptor descriptor = new OpenFileDescriptor ( project , file ) ; Editor editor = FileEditorManager . getInstance ( project ) . openTextEditor ( descriptor , true ) ; editor . getDocument ( ) . setText ( " " ) ; TemplateManager . getInstance ( project ) . startTemplate ( editor , template ) ; } else { VfsUtil . saveText ( file , template . getTemplateText ( ) ) ; } }
joewalnes/idea-community | public static < T extends Collection < Pattern > > T collectPattern ( String text , T result ) { String antPattern = FileUtil . convertAntToRegexp ( text . trim ( ) ) ; try { result . add ( Pattern . compile ( antPattern ) ) ; } catch ( PatternSyntaxException ignore ) { } return result ; }
joewalnes/idea-community | public static boolean isIncluded ( String relativeName , List < Pattern > includes , List < Pattern > excludes ) { boolean result = false ; for ( Pattern each : includes ) { if ( each . matcher ( relativeName ) . matches ( ) ) { result = true ; break ; } } if ( ! result ) return false ; for ( Pattern each : excludes ) { if ( each . matcher ( relativeName ) . matches ( ) ) return false ; } return true ; }
joewalnes/idea-community | public static void run ( Project project , String title , final MavenTask task ) throws MavenProcessCanceledException { final Exception [ ] canceledEx = new Exception [ 1 ] ; final RuntimeException [ ] runtimeEx = new RuntimeException [ 1 ] ; final Error [ ] errorEx = new Error [ 1 ] ; ProgressManager . getInstance ( ) . run ( new Task . Modal ( project , title , true ) { public void run ( @ NotNull ProgressIndicator i ) { try { task . run ( new MavenProgressIndicator ( i ) ) ; } catch ( MavenProcessCanceledException e ) { canceledEx [ 0 ] = e ; } catch ( ProcessCanceledException e ) { canceledEx [ 0 ] = e ; } catch ( RuntimeException e ) { runtimeEx [ 0 ] = e ; } catch ( Error e ) { errorEx [ 0 ] = e ; } } } ) ; if ( canceledEx [ 0 ] instanceof MavenProcessCanceledException ) throw ( MavenProcessCanceledException ) canceledEx [ 0 ] ; if ( canceledEx [ 0 ] instanceof ProcessCanceledException ) throw new MavenProcessCanceledException ( ) ; if ( runtimeEx [ 0 ] != null ) throw runtimeEx [ 0 ] ; if ( errorEx [ 0 ] != null ) throw errorEx [ 0 ] ; }
joewalnes/idea-community | public static MavenTaskHandler runInBackground ( final Project project , final String title , final boolean cancellable , final MavenTask task ) { final MavenProgressIndicator indicator = new MavenProgressIndicator ( ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { try { task . run ( indicator ) ; } catch ( MavenProcessCanceledException ignore ) { indicator . cancel ( ) ; } catch ( ProcessCanceledException ignore ) { indicator . cancel ( ) ; } } } ; if ( isNoBackgroundMode ( ) ) { runnable . run ( ) ; return new MavenTaskHandler ( ) { public void waitFor ( ) { } } ; } else { final Future < ? > future = ApplicationManager . getApplication ( ) . executeOnPooledThread ( runnable ) ; final MavenTaskHandler handler = new MavenTaskHandler ( ) { public void waitFor ( ) { try { future . get ( ) ; } catch ( InterruptedException e ) { MavenLog . LOG . error ( e ) ; } catch ( ExecutionException e ) { MavenLog . LOG . error ( e ) ; } } } ; invokeLater ( project , new Runnable ( ) { public void run ( ) { if ( future . isDone ( ) ) return ; new Task . Backgroundable ( project , title , cancellable ) { public void run ( @ NotNull ProgressIndicator i ) { indicator . setIndicator ( i ) ; handler . waitFor ( ) ; } } . queue ( ) ; } } ) ; return handler ; } }
joewalnes/idea-community | @ Nullable public static File resolveMavenHomeDirectory ( @ Nullable String overrideMavenHome ) { if ( ! isEmptyOrSpaces ( overrideMavenHome ) ) { return new File ( overrideMavenHome ) ; } String m2home = System . getenv ( ENV_M2_HOME ) ; if ( ! isEmptyOrSpaces ( m2home ) ) { final File homeFromEnv = new File ( m2home ) ; if ( isValidMavenHome ( homeFromEnv ) ) { return homeFromEnv ; } } String userHome = System . getProperty ( PROP_USER_HOME ) ; if ( ! isEmptyOrSpaces ( userHome ) ) { final File underUserHome = new File ( userHome , M2_DIR ) ; if ( isValidMavenHome ( underUserHome ) ) { return underUserHome ; } } return null ; }
joewalnes/idea-community | public static boolean isEmptyOrSpaces ( @ Nullable String str ) { return str == null || str . length ( ) == 0 || str . trim ( ) . length ( ) == 0 ; }
joewalnes/idea-community | public static boolean isValidMavenHome ( File home ) { return getMavenConfFile ( home ) . exists ( ) ; }
joewalnes/idea-community | public static File getMavenConfFile ( File mavenHome ) { return new File ( new File ( mavenHome , BIN_DIR ) , M2_CONF_FILE ) ; }
joewalnes/idea-community | @ Nullable public static File resolveGlobalSettingsFile ( @ Nullable String overriddenMavenHome ) { File directory = resolveMavenHomeDirectory ( overriddenMavenHome ) ; if ( directory == null ) return null ; return new File ( new File ( directory , CONF_DIR ) , SETTINGS_XML ) ; }
joewalnes/idea-community | @ NotNull public static File resolveUserSettingsFile ( @ Nullable String overriddenUserSettingsFile ) { if ( ! isEmptyOrSpaces ( overriddenUserSettingsFile ) ) return new File ( overriddenUserSettingsFile ) ; return new File ( resolveM2Dir ( ) , SETTINGS_XML ) ; }
joewalnes/idea-community | @ NotNull public static File resolveM2Dir ( ) { return new File ( System . getProperty ( PROP_USER_HOME ) , DOT_M2_DIR ) ; }
joewalnes/idea-community | @ NotNull public static File resolveLocalRepository ( @ Nullable String overridenLocalRepository , @ Nullable String overridenMavenHome , @ Nullable String overriddenUserSettingsFile ) { File result = null ; if ( ! isEmptyOrSpaces ( overridenLocalRepository ) ) result = new File ( overridenLocalRepository ) ; if ( result == null ) { result = doResolveLocalRepository ( resolveUserSettingsFile ( overriddenUserSettingsFile ) , resolveGlobalSettingsFile ( overridenMavenHome ) ) ; } try { return result . getCanonicalFile ( ) ; } catch ( IOException e ) { return result ; } }
joewalnes/idea-community | @ NotNull public static File doResolveLocalRepository ( @ Nullable File userSettingsFile , @ Nullable File globalSettingsFile ) { if ( userSettingsFile != null ) { final String fromUserSettings = getRepositoryFromSettings ( userSettingsFile ) ; if ( ! StringUtil . isEmpty ( fromUserSettings ) ) { return new File ( fromUserSettings ) ; } } if ( globalSettingsFile != null ) { final String fromGlobalSettings = getRepositoryFromSettings ( globalSettingsFile ) ; if ( ! StringUtil . isEmpty ( fromGlobalSettings ) ) { return new File ( fromGlobalSettings ) ; } } return new File ( resolveM2Dir ( ) , REPOSITORY_DIR ) ; }
joewalnes/idea-community | @ Nullable public static String getRepositoryFromSettings ( final File file ) { try { byte [ ] bytes = FileUtil . loadFileBytes ( file ) ; return expandProperties ( MavenJDOMUtil . findChildValueByPath ( MavenJDOMUtil . read ( bytes , null ) , " localRepository " , null ) ) ; } catch ( IOException e ) { return null ; } }
joewalnes/idea-community | public static String expandProperties ( String text ) { if ( StringUtil . isEmptyOrSpaces ( text ) ) return text ; Properties props = MavenFacadeUtil . collectSystemProperties ( ) ; for ( Map . Entry < Object , Object > each : props . entrySet ( ) ) { Object val = each . getValue ( ) ; text = text . replace ( " $ { " + each . getKey ( ) + " } " , val instanceof CharSequence ? ( CharSequence ) val : val . toString ( ) ) ; } return text ; }
joewalnes/idea-community | @ NotNull public static VirtualFile resolveSuperPomFile ( @ Nullable File mavenHome ) { VirtualFile result = null ; if ( mavenHome != null ) { result = doResolveSuperPomFile ( new File ( mavenHome , LIB_DIR ) ) ; } if ( result == null ) { result = doResolveSuperPomFile ( MavenFacadeManager . collectClassPathAndLIbsFolder ( ) . second ) ; } return result ; }
joewalnes/idea-community | @ Nullable public static VirtualFile doResolveSuperPomFile ( @ Nullable File mavenHome ) { File lib = resolveMavenLib ( mavenHome ) ; if ( lib == null ) return null ; VirtualFile file = LocalFileSystem . getInstance ( ) . findFileByIoFile ( lib ) ; if ( file == null ) return null ; VirtualFile root = JarFileSystem . getInstance ( ) . getJarRootForLocalFile ( file ) ; if ( root == null ) return null ; return root . findFileByRelativePath ( SUPER_POM_PATH ) ; }
joewalnes/idea-community | @ Nullable public static File resolveMavenLib ( @ NotNull File dir ) { File [ ] files = dir . listFiles ( ) ; if ( files != null ) { Pattern pattern = Pattern . compile ( " maven - \\ d + \\ . \\ d + \\ . \\ d + - uber \\ . jar " ) ; for ( File each : files ) { if ( pattern . matcher ( each . getName ( ) ) . matches ( ) ) { return each ; } } } return null ; }
Buzzardo/spring-boot | private static String buildMessage ( ConfigurationPropertyName name , Bindable < ? > target ) { StringBuilder message = new StringBuilder ( ) ; message . append ( " Failed ▁ to ▁ bind ▁ properties " ) ; message . append ( ( name != null ) ? " ▁ under ▁ ' " + name + " ' " : " " ) ; message . append ( " ▁ to ▁ " ) . append ( target . getType ( ) ) ; return message . toString ( ) ; }
camunda/camunda-bpm-platform | @ Deployment public static WebArchive processArchive ( ) { return initWebArchiveDeployment ( ) . addAsLibraries ( ShrinkWrap . create ( JavaArchive . class , " engine1 . jar " ) . addAsResource ( " singleEngine . xml " , " META - INF / processes . xml " ) ) ; }
trejkaz/derby | private static ContextService getContextService ( ) { return AccessController . doPrivileged ( new PrivilegedAction < ContextService > ( ) { public ContextService run ( ) { return ContextService . getFactory ( ) ; } } ) ; }
trejkaz/derby | private static Object createPersistentService ( final String factoryInterface , final String serviceName , final Properties properties ) throws StandardException { try { return AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { public Object run ( ) throws StandardException { return Monitor . createPersistentService ( factoryInterface , serviceName , properties ) ; } } ) ; } catch ( PrivilegedActionException pae ) { throw StandardException . plainWrapException ( pae ) ; } }
aemay2/hapi-fhir | @ Bean public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer ( ) { return new PropertySourcesPlaceholderConfigurer ( ) ; }
Alachisoft/TayzGrid | public static void registerAllExtensions ( com . google . protobuf . ExtensionRegistry registry ) { }
Alachisoft/TayzGrid | public static RegisterBulkKeyNotifResponse getDefaultInstance ( ) { return defaultInstance ; }
Alachisoft/TayzGrid | public static final com . google . protobuf . Descriptors . Descriptor getDescriptor ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_descriptor ; }
Alachisoft/TayzGrid | public static Builder newBuilder ( ) { return Builder . create ( ) ; }
Alachisoft/TayzGrid | public static Builder newBuilder ( com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse prototype ) { return newBuilder ( ) . mergeFrom ( prototype ) ; }
Alachisoft/TayzGrid | private static Builder create ( ) { Builder builder = new Builder ( ) ; builder . result = new com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ( ) ; return builder ; }
Alachisoft/TayzGrid | public static com . google . protobuf . Descriptors . FileDescriptor getDescriptor ( ) { return descriptor ; }
Alachisoft/TayzGrid | public static void internalForceInit ( ) { }
MovingBlocks/box2d-editor | public static Assets inst ( ) { return instance ; }
JuntaoZhang/myhadoop-2.2.0 | private static boolean isDfsClientClose ( DFSClient c ) { try { c . exists ( " " ) ; } catch ( IOException e ) { return e . getMessage ( ) . equals ( " Filesystem ▁ closed " ) ; } return false ; }
andy-goryachev/FindFiles | public static < T > void add ( GlobalProperty < T > p ) { properties . add ( p ) ; p . addListener ( ( src , old , cur ) -> store ( p ) ) ; load ( p ) ; }
andy-goryachev/FindFiles | protected static < T > void store ( GlobalProperty < T > p ) { try { String k = p . getName ( ) ; T v = p . getValue ( ) ; String s ; if ( v == null ) { s = null ; } else { StringConverter < T > c = p . getConverter ( ) ; s = c . toString ( v ) ; } GlobalSettings . setString ( k , s ) ; } catch ( Exception e ) { Log . ex ( e ) ; } }
andy-goryachev/FindFiles | protected static < T > void load ( GlobalProperty < T > p ) { try { String k = p . getName ( ) ; String s = GlobalSettings . getString ( k ) ; if ( s != null ) { T v = p . getConverter ( ) . fromString ( s ) ; p . setValue ( v ) ; } } catch ( Exception e ) { Log . ex ( e ) ; } }
JackSprat/Knifeybot | protected static SQLException appendMessageToException ( SQLException sqlEx , String messageToAppend , ExceptionInterceptor interceptor ) { String origMessage = sqlEx . getMessage ( ) ; String sqlState = sqlEx . getSQLState ( ) ; int vendorErrorCode = sqlEx . getErrorCode ( ) ; StringBuilder messageBuf = new StringBuilder ( origMessage . length ( ) + messageToAppend . length ( ) ) ; messageBuf . append ( origMessage ) ; messageBuf . append ( messageToAppend ) ; SQLException sqlExceptionWithNewMessage = SQLError . createSQLException ( messageBuf . toString ( ) , sqlState , vendorErrorCode , interceptor ) ; try { Method getStackTraceMethod = null ; Method setStackTraceMethod = null ; Object theStackTraceAsObject = null ; Class < ? > stackTraceElementClass = Class . forName ( " java . lang . StackTraceElement " ) ; Class < ? > stackTraceElementArrayClass = Array . newInstance ( stackTraceElementClass , new int [ ] { 0 } ) . getClass ( ) ; getStackTraceMethod = Throwable . class . getMethod ( " getStackTrace " , new Class [ ] { } ) ; setStackTraceMethod = Throwable . class . getMethod ( " setStackTrace " , new Class [ ] { stackTraceElementArrayClass } ) ; if ( getStackTraceMethod != null && setStackTraceMethod != null ) { theStackTraceAsObject = getStackTraceMethod . invoke ( sqlEx , new Object [ 0 ] ) ; setStackTraceMethod . invoke ( sqlExceptionWithNewMessage , new Object [ ] { theStackTraceAsObject } ) ; } } catch ( NoClassDefFoundError noClassDefFound ) { } catch ( NoSuchMethodException noSuchMethodEx ) { } catch ( Throwable catchAll ) { } return sqlExceptionWithNewMessage ; }
JackSprat/Knifeybot | protected static Connection getInstance ( String hostToConnectTo , int portToConnectTo , Properties info , String databaseToConnectTo , String url ) throws SQLException { if ( ! Util . isJdbc4 ( ) ) { return new ConnectionImpl ( hostToConnectTo , portToConnectTo , info , databaseToConnectTo , url ) ; } return ( Connection ) Util . handleNewInstance ( JDBC_4_CONNECTION_CTOR , new Object [ ] { hostToConnectTo , Integer . valueOf ( portToConnectTo ) , info , databaseToConnectTo , url } , null ) ; }
JackSprat/Knifeybot | protected static synchronized int getNextRoundRobinHostIndex ( String url , List < ? > hostList ) { int indexRange = hostList . size ( ) ; int index = random . nextInt ( indexRange ) ; return index ; }
JackSprat/Knifeybot | private static boolean nullSafeCompare ( String s1 , String s2 ) { if ( s1 == null && s2 == null ) { return true ; } if ( s1 == null && s2 != null ) { return false ; } return s1 != null && s1 . equals ( s2 ) ; }
navalev/azure-sdk-for-java | @ JsonCreator public static ApplicationGatewayTier fromString ( String name ) { return fromString ( name , ApplicationGatewayTier . class ) ; }
navalev/azure-sdk-for-java | public static Collection < ApplicationGatewayTier > values ( ) { return values ( ApplicationGatewayTier . class ) ; }
google/copybara | private static String detailedError ( String httpMethod , String path , @ Nullable String request , String response , int httpCode ) { StringBuilder sb = new StringBuilder ( " GitHub ▁ API ▁ call ▁ failed ▁ with ▁ code ▁ " ) . append ( httpCode ) . append ( " ▁ The ▁ request ▁ was ▁ " ) . append ( httpMethod ) . append ( ' ▁ ' ) . append ( path ) . append ( ' \n ' ) ; if ( request != null ) { sb . append ( " Request ▁ object : \n " ) . append ( request ) . append ( " \n " ) ; } sb . append ( " Response : \n " ) . append ( response ) . append ( " \n " ) ; return sb . toString ( ) ; }
google/copybara | private static ResponseCode parseResponseCode ( int code ) { ResponseCode responseCode = CODE_MAP . get ( code ) ; return responseCode == null ? ResponseCode . UNKNOWN : responseCode ; }
gjordi/gwt-jsni | public static JsArrayString wrapArray ( String [ ] srcArray ) { JsArrayString result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static String [ ] unwrapArray ( JsArrayString jsArrayString ) { String [ ] result = new String [ jsArrayString . length ( ) ] ; for ( int i = 0 ; i < jsArrayString . length ( ) ; i ++ ) { result [ i ] = jsArrayString . get ( i ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayNumber wrapArray ( float [ ] srcArray ) { JsArrayNumber result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayNumber wrapArray ( double [ ] srcArray ) { JsArrayNumber result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayInteger wrapArray ( int [ ] srcArray ) { JsArrayInteger result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayInteger wrapArray ( byte [ ] srcArray ) { JsArrayInteger result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayBoolean wrapArray ( boolean [ ] srcArray ) { JsArrayBoolean result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
daniel-beck/sorcerer | public static < T > JsArray < T > create ( ) { return ( JsArray < T > ) createArray ( ) ; }
ginere/ginere-base | public static String getStringSize ( long size ) { Language lang = I18NConnector . getThreadLocalLanguage ( ) ; return getStringSize ( lang , size ) ; }
ginere/ginere-base | public static String getStringSize ( Language language , long size ) { NumberFormat format = NumberFormat . getNumberInstance ( language . getLocale ( ) ) ; if ( size < BYTES_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , BYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < KB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / BYTES_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , KBYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < MB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / KB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , MBYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < GB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / MB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , GBYTE_LBL ) ) ; return buffer . toString ( ) ; } else { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / GB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , GBYTE_LBL ) ) ; return buffer . toString ( ) ; } }
joypupil/study | public static SystemInfo getInstance ( ) { if ( currentSystem == null ) currentSystem = new SystemInfo ( ) ; return currentSystem ; }
joypupil/study | public static void main ( String [ ] args ) { String mac = " " ; try { Process p = new ProcessBuilder ( " ifconfig " ) . start ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { Pattern pat = Pattern . compile ( " \\ b \\ w + : \\ w + : \\ w + : \\ w + : \\ w + : \\ w + \\ b " ) ; Matcher mat = pat . matcher ( line ) ; if ( mat . find ( ) ) { mac = mat . group ( 0 ) ; } } br . close ( ) ; } catch ( IOException e ) { } System . out . println ( " 本机MAC地址为 : \n " + mac ) ; }
wangsongpeng/jdk-src | public static TemporalQuery < ZoneId > zoneId ( ) { return TemporalQueries . ZONE_ID ; }
wangsongpeng/jdk-src | public static TemporalQuery < Chronology > chronology ( ) { return TemporalQueries . CHRONO ; }
wangsongpeng/jdk-src | public static TemporalQuery < TemporalUnit > precision ( ) { return TemporalQueries . PRECISION ; }
wangsongpeng/jdk-src | public static TemporalQuery < ZoneId > zone ( ) { return TemporalQueries . ZONE ; }
wangsongpeng/jdk-src | public static TemporalQuery < ZoneOffset > offset ( ) { return TemporalQueries . OFFSET ; }
wangsongpeng/jdk-src | public static TemporalQuery < LocalDate > localDate ( ) { return TemporalQueries . LOCAL_DATE ; }
wangsongpeng/jdk-src | public static TemporalQuery < LocalTime > localTime ( ) { return TemporalQueries . LOCAL_TIME ; }
justin-espedal/polydes | public static PaintExtension get ( ) { return _instance ; }
indashnet/InDashNet.Open.UN2000 | public static int getMaxSpeechInputLength ( ) { return 4000 ; }
india-rose/old-indiarose | public static Typeface loadFont ( String _fontPath ) { if ( ! m_fonts . containsKey ( _fontPath ) ) { Typeface font = Typeface . createFromFile ( _fontPath ) ; if ( font == null ) { font = Typeface . DEFAULT ; } m_fonts . put ( _fontPath , font ) ; } return m_fonts . get ( _fontPath ) ; }
aws/aws-sdk-java | public static DescribeAuditStreamConfigurationResultJsonUnmarshaller getInstance ( ) { if ( instance == null ) instance = new DescribeAuditStreamConfigurationResultJsonUnmarshaller ( ) ; return instance ; }
mattyb149/pentaho-kettle | public static void validateImportedElement ( ImportRules importRules , Object subject ) throws KettleException { List < ImportValidationFeedback > feedback = importRules . verifyRules ( subject ) ; List < ImportValidationFeedback > errors = ImportValidationFeedback . getErrors ( feedback ) ; if ( ! errors . isEmpty ( ) ) { StringBuilder message = new StringBuilder ( BaseMessages . getString ( PKG , " RepositoryImporter . ValidationFailed . Message " , subject . toString ( ) ) ) ; message . append ( Const . CR ) ; for ( ImportValidationFeedback error : errors ) { message . append ( " ▁ - ▁ " ) ; message . append ( error . toString ( ) ) ; message . append ( Const . CR ) ; } throw new KettleException ( message . toString ( ) ) ; } }
mattyb149/pentaho-kettle | private static boolean containsVariables ( String entryPath ) { List < String > variablesList = new ArrayList < String > ( ) ; StringUtil . getUsedVariables ( entryPath , variablesList , true ) ; return ! variablesList . isEmpty ( ) ; }
MobileCloudNetworking/icnaas | @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { CCNTestBase . setUpBeforeClass ( ) ; }
MobileCloudNetworking/icnaas | @ AfterClass public static void tearDownAfterClass ( ) throws Exception { CCNTestBase . tearDownAfterClass ( ) ; }
salyh/geronimo-specs | public static Collector < JsonValue , JsonArrayBuilder , JsonArray > toJsonArray ( ) { return null ; }
salyh/geronimo-specs | public static Collector < Map . Entry < String , JsonValue > , JsonObjectBuilder , JsonObject > toJsonObject ( ) { return null ; }
salyh/geronimo-specs | public static Collector < JsonValue , JsonObjectBuilder , JsonObject > toJsonObject ( Function < JsonValue , String > keyMapper , Function < JsonValue , JsonValue > valueMapper ) { return null ; }
salyh/geronimo-specs | public static Collector < JsonValue , Map < String , JsonArrayBuilder > , JsonObject > groupingBy ( Function < JsonValue , String > classifier , Collector < JsonValue , JsonArrayBuilder , JsonArray > downstream ) { return null ; }
salyh/geronimo-specs | public static Collector < JsonValue , Map < String , JsonArrayBuilder > , JsonObject > groupingBy ( Function < JsonValue , String > classifier ) { return null ; }
cguzel/gora | public static void main ( String [ ] args ) { if ( args . length == 1 && ( args [ 0 ] . equals ( " - - help " ) || args [ 0 ] . equals ( " - h " ) ) ) { printHelp ( ) ; System . exit ( 0 ) ; } if ( args . length < 2 ) { LOG . error ( " Must ▁ supply ▁ at ▁ least ▁ one ▁ source ▁ file ▁ and ▁ an ▁ output ▁ directory . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } LicenseHeaders licenseHeader = new LicenseHeaders ( " ASLv2" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( " - license " . equals ( args [ i ] ) ) { if ( i == args . length - 1 ) { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } if ( licenseHeader . isValidLicense ( args [ i + 1 ] ) ) { licenseHeader . setLicenseName ( args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . removeElement ( args , args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . removeElement ( args , args [ i ] ) ; } else { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } } } File outputDir = new File ( args [ args . length - 1 ] ) ; if ( ! outputDir . isDirectory ( ) ) { LOG . error ( " Must ▁ supply ▁ a ▁ directory ▁ for ▁ output " ) ; printHelp ( ) ; System . exit ( 1 ) ; } File inputDir = new File ( args [ 0 ] ) ; File [ ] inputFiles = null ; if ( inputDir . isDirectory ( ) ) { if ( inputDir . length ( ) > 0 ) inputFiles = inputDir . listFiles ( ) ; else { LOG . error ( " Input ▁ directory ▁ must ▁ include ▁ at ▁ least ▁ one ▁ file . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } } else { inputFiles = new File [ args . length - 1 ] ; for ( int i = 0 ; i < inputFiles . length ; i ++ ) { File inputFile = new File ( args [ i ] ) ; if ( ! inputFile . isFile ( ) ) { LOG . error ( " Input ▁ must ▁ be ▁ a ▁ file . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } inputFiles [ i ] = inputFile ; } } try { GoraCompiler . compileSchema ( inputFiles , outputDir , licenseHeader ) ; LOG . info ( " Compiler ▁ executed ▁ SUCCESSFULL . " ) ; } catch ( IOException e ) { LOG . error ( " Error ▁ while ▁ compiling ▁ schema ▁ files . ▁ Check ▁ that ▁ the ▁ schemas ▁ are ▁ properly ▁ formatted . " ) ; printHelp ( ) ; throw new RuntimeException ( e ) ; } }
cguzel/gora | private static void printHelp ( ) { LOG . info ( " Usage : ▁ gora - compiler ▁ ( ▁ - h ▁ | ▁ - - help ▁ ) ▁ | ▁ ( < input > ▁ [ < input > . . . ] ▁ < output > ▁ [ - license ▁ < id > ] ) " ) ; LOG . error ( " License ▁ header ▁ options ▁ include ; \n " + " \t\t ▁ ▁ ASLv2 ▁ ▁ ▁ ( Apache ▁ Software ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ AGPLv3 ▁ ▁ ( GNU ▁ Affero ▁ General ▁ Public ▁ License ) ▁ \n " + " \t\t ▁ ▁ CDDLv1 ▁ ▁ ( Common ▁ Development ▁ and ▁ Distribution ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ FDLv13 ▁ ▁ ( GNU ▁ Free ▁ Documentation ▁ License ▁ v1.3 ) ▁ \n " + " \t\t ▁ ▁ GPLv1 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ GPLv2 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ GPLv3 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v3.0 ) ▁ \n " + " \t\t ▁ ▁ LGPLv21 ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v2.1 ) ▁ \n " + " \t\t ▁ ▁ LGPLv3 ▁ ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v2.1 ) " ) ; }
AstromechZA/HoughCircleDetection | public static ShortImageBuffer norm ( ShortImageBuffer input ) { ShortImageBuffer after = input . copyShape ( ) ; int min = 0xFFFF ; int max = 0 ; for ( int y = 0 ; y < input . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < input . getWidth ( ) ; x ++ ) { int v = input . get ( y , x ) & 0xFFFF ; min = ( v < min ) ? v : min ; max = ( v > max ) ? v : max ; } } int diff = ( max - min ) ; if ( diff > 0 ) { float scale = ( ( float ) 0xFF ) / diff ; for ( int y = 0 ; y < input . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < input . getWidth ( ) ; x ++ ) { int v = input . get ( y , x ) & 0xFFFF ; after . set ( y , x , ( short ) ( ( int ) ( ( v - min ) * scale ) & 0xFF ) ) ; } } } return after ; }
jeikerxiao/SpringBootStudy | public static void main ( String [ ] args ) { SpringApplication . run ( SpringBootActuatorApplication . class , args ) ; }
khomisha/ui | public static CSSInjector getCSSInjector ( ) { return ( cssInjector ) ; }
khomisha/ui | public static void setCssInjector ( CSSInjector cssInjector ) { CSSHelper . cssInjector = cssInjector ; }
khomisha/ui | public static void addCSSName ( Element elem , String sCSSName ) { elem . addClassName ( sCSSName ) ; }
khomisha/ui | public static void addCSSName ( UIObject parent , String sChildCssName , String sCSSName ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; if ( ( e . getClassName ( ) ) . contains ( sChildCssName ) ) { addCSSName ( e , sCSSName ) ; } } }
khomisha/ui | public static void addCSSName ( UIObject parent , Map < String , String > customCSS ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; String [ ] as = e . getClassName ( ) . split ( " ▁ " ) ; for ( String sClassName : as ) { if ( customCSS . containsKey ( sClassName ) ) { addCSSName ( e , customCSS . get ( sClassName ) ) ; } } } }
khomisha/ui | public static Element getChild ( UIObject parent , String sCssClass ) { Element child = null ; NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; if ( ( e . getClassName ( ) ) . contains ( sCssClass ) ) { child = e ; break ; } } return ( child ) ; }
MerritCR/merrit | public static void reloadChanges ( ChangeSet cs ) throws OrmException { for ( ChangeData cd : cs . changes ( ) ) { cd . reloadChange ( ) ; cd . setPatchSets ( null ) ; } }
AntoineAugusti/incubator-zeppelin | private static < I extends Iface > Map < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > getProcessMap ( Map < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > processMap ) { processMap . put ( " createInterpreter " , new createInterpreter ( ) ) ; processMap . put ( " open " , new open ( ) ) ; processMap . put ( " close " , new close ( ) ) ; processMap . put ( " interpret " , new interpret ( ) ) ; processMap . put ( " cancel " , new cancel ( ) ) ; processMap . put ( " getProgress " , new getProgress ( ) ) ; processMap . put ( " getFormType " , new getFormType ( ) ) ; processMap . put ( " completion " , new completion ( ) ) ; processMap . put ( " shutdown " , new shutdown ( ) ) ; processMap . put ( " getStatus " , new getStatus ( ) ) ; processMap . put ( " getEvent " , new getEvent ( ) ) ; processMap . put ( " angularObjectUpdate " , new angularObjectUpdate ( ) ) ; processMap . put ( " angularObjectAdd " , new angularObjectAdd ( ) ) ; processMap . put ( " angularObjectRemove " , new angularObjectRemove ( ) ) ; return processMap ; }
AntoineAugusti/incubator-zeppelin | private static < I extends AsyncIface > Map < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > getProcessMap ( Map < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > processMap ) { processMap . put ( " createInterpreter " , new createInterpreter ( ) ) ; processMap . put ( " open " , new open ( ) ) ; processMap . put ( " close " , new close ( ) ) ; processMap . put ( " interpret " , new interpret ( ) ) ; processMap . put ( " cancel " , new cancel ( ) ) ; processMap . put ( " getProgress " , new getProgress ( ) ) ; processMap . put ( " getFormType " , new getFormType ( ) ) ; processMap . put ( " completion " , new completion ( ) ) ; processMap . put ( " shutdown " , new shutdown ( ) ) ; processMap . put ( " getStatus " , new getStatus ( ) ) ; processMap . put ( " getEvent " , new getEvent ( ) ) ; processMap . put ( " angularObjectUpdate " , new angularObjectUpdate ( ) ) ; processMap . put ( " angularObjectAdd " , new angularObjectAdd ( ) ) ; processMap . put ( " angularObjectRemove " , new angularObjectRemove ( ) ) ; return processMap ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return PROPERTIES ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return ST ; case 3 : return INTERPRETER_CONTEXT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return INTERPRETER_CONTEXT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return INTERPRETER_CONTEXT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return BUF ; case 3 : return CURSOR ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return JOB_ID ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_ID ; case 3 : return OBJECT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_ID ; case 3 : return OBJECT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_ID ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull public static < T > ReadOnlyProperty < T > create ( @ NonNull Observable < T > observable ) { return new ReadOnlyProperty < > ( observable ) ; }
tesseract2048/ansj_segd | public static void main ( String [ ] args ) throws Exception { loadFormFile ( ) ; loadFormStr ( ) ; Value value = new Value ( " 三个和尚 " , " 三个 " , " m " , " 和尚 " , " n " ) ; Library . insertWord ( UserDefineLibrary . ambiguityForest , value ) ; Library . removeWord ( UserDefineLibrary . ambiguityForest , " 三个和尚 " ) ; }
tesseract2048/ansj_segd | private static void loadFormStr ( ) { Forest forest = new Forest ( ) ; Value value = new Value ( " 三个和尚 " , " 三个 " , " m " , " 和尚 " , " n " ) ; Library . insertWord ( forest , value ) ; UserDefineLibrary . ambiguityForest = forest ; }
tesseract2048/ansj_segd | private static void loadFormFile ( ) throws Exception { Forest forest = Library . makeForest ( " new _ Library _ Path " ) ; UserDefineLibrary . ambiguityForest = forest ; }
dukechain/Qassandra | public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , List < SSTableReader > sstables ) { return create ( cfs , maxSSTableSize , sstables , new SizeTieredCompactionStrategyOptions ( ) ) ; }
dukechain/Qassandra | public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , Iterable < SSTableReader > sstables , SizeTieredCompactionStrategyOptions options ) { LeveledManifest manifest = new LeveledManifest ( cfs , maxSSTableSize , options ) ; for ( SSTableReader ssTableReader : sstables ) { manifest . add ( ssTableReader ) ; } for ( int i = 1 ; i < manifest . getAllLevelSize ( ) . length ; i ++ ) { manifest . repairOverlappingSSTables ( i ) ; } return manifest ; }
dukechain/Qassandra | private static Set < SSTableReader > overlapping ( Collection < SSTableReader > candidates , Iterable < SSTableReader > others ) { assert ! candidates . isEmpty ( ) ; Iterator < SSTableReader > iter = candidates . iterator ( ) ; SSTableReader sstable = iter . next ( ) ; Token first = sstable . first . token ; Token last = sstable . last . token ; while ( iter . hasNext ( ) ) { sstable = iter . next ( ) ; first = first . compareTo ( sstable . first . token ) <= 0 ? first : sstable . first . token ; last = last . compareTo ( sstable . last . token ) >= 0 ? last : sstable . last . token ; } return overlapping ( first , last , others ) ; }
dukechain/Qassandra | @ VisibleForTesting static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > others ) { return overlapping ( sstable . first . token , sstable . last . token , others ) ; }
dukechain/Qassandra | private static Set < SSTableReader > overlapping ( Token start , Token end , Iterable < SSTableReader > sstables ) { assert start . compareTo ( end ) <= 0 ; Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; Bounds < Token > promotedBounds = new Bounds < Token > ( start , end ) ; for ( SSTableReader candidate : sstables ) { Bounds < Token > candidateBounds = new Bounds < Token > ( candidate . first . token , candidate . last . token ) ; if ( candidateBounds . intersects ( promotedBounds ) ) overlapped . add ( candidate ) ; } return overlapped ; }
dukechain/Qassandra | private static final Predicate < SSTableReader > suspectP = new Predicate < SSTableReader > ( ) { public boolean apply ( SSTableReader candidate ) { return candidate . isMarkedSuspect ( ) ; } }
dukechain/Qassandra | public static synchronized void mutateLevel ( SSTableMetadata oldMetadata , Descriptor descriptor , String filename , int level ) throws IOException { logger . debug ( " Mutating ▁ { } ▁ to ▁ level ▁ { } " , descriptor . filenameFor ( Component . STATS ) , level ) ; SSTableMetadata metadata = SSTableMetadata . copyWithNewSSTableLevel ( oldMetadata , level ) ; DataOutputStream out = new DataOutputStream ( new FileOutputStream ( filename + " - tmp " ) ) ; SSTableMetadata . serializer . legacySerialize ( metadata , descriptor , out ) ; out . flush ( ) ; out . close ( ) ; FileUtils . renameWithConfirm ( filename + " - tmp " , filename ) ; }
virajsenevirathne/wso2-commons-vfs | public static FTPSClient createConnection ( String hostname , int port , char [ ] username , char [ ] password , String workingDirectory , FileSystemOptions fileSystemOptions ) throws FileSystemException { return createConnection ( hostname , port , username , password , workingDirectory , fileSystemOptions , null ) ; }
virajsenevirathne/wso2-commons-vfs | public static FTPSClient createConnection ( String hostname , int port , char [ ] username , char [ ] password , String workingDirectory , FileSystemOptions fileSystemOptions , Integer defaultTimeout ) throws FileSystemException { if ( username == null ) { username = " anonymous " . toCharArray ( ) ; } if ( password == null ) { password = " anonymous " . toCharArray ( ) ; } try { final FTPSClient client ; if ( FtpsFileSystemConfigBuilder . getInstance ( ) . getFtpsType ( fileSystemOptions ) . equals ( " explicit " ) ) { client = new FTPSClient ( ) ; } else if ( FtpsFileSystemConfigBuilder . getInstance ( ) . getFtpsType ( fileSystemOptions ) . equals ( " implicit " ) ) { client = new FTPSClient ( true ) ; } else { throw new FileSystemException ( " Invalid ▁ FTPS ▁ type ▁ of ▁ " + FtpsFileSystemConfigBuilder . getInstance ( ) . getFtpsType ( fileSystemOptions ) + " ▁ specified . ▁ Must ▁ be ▁ ' implicit ' ▁ or ▁ ' explicit ' " ) ; } String key = FtpsFileSystemConfigBuilder . getInstance ( ) . getEntryParser ( fileSystemOptions ) ; if ( key != null ) { FTPClientConfig config = new FTPClientConfig ( key ) ; String serverLanguageCode = FtpsFileSystemConfigBuilder . getInstance ( ) . getServerLanguageCode ( fileSystemOptions ) ; if ( serverLanguageCode != null ) { config . setServerLanguageCode ( serverLanguageCode ) ; } String defaultDateFormat = FtpsFileSystemConfigBuilder . getInstance ( ) . getDefaultDateFormat ( fileSystemOptions ) ; if ( defaultDateFormat != null ) { config . setDefaultDateFormatStr ( defaultDateFormat ) ; } String recentDateFormat = FtpsFileSystemConfigBuilder . getInstance ( ) . getRecentDateFormat ( fileSystemOptions ) ; if ( recentDateFormat != null ) { config . setRecentDateFormatStr ( recentDateFormat ) ; } String serverTimeZoneId = FtpsFileSystemConfigBuilder . getInstance ( ) . getServerTimeZoneId ( fileSystemOptions ) ; if ( serverTimeZoneId != null ) { config . setServerTimeZoneId ( serverTimeZoneId ) ; } String [ ] shortMonthNames = FtpsFileSystemConfigBuilder . getInstance ( ) . getShortMonthNames ( fileSystemOptions ) ; if ( shortMonthNames != null ) { StringBuilder shortMonthNamesStr = new StringBuilder ( 40 ) ; for ( int i = 0 ; i < shortMonthNames . length ; i ++ ) { if ( shortMonthNamesStr . length ( ) > 0 ) { shortMonthNamesStr . append ( " | " ) ; } shortMonthNamesStr . append ( shortMonthNames [ i ] ) ; } config . setShortMonthNames ( shortMonthNamesStr . toString ( ) ) ; } client . configure ( config ) ; } FTPFileEntryParserFactory myFactory = FtpsFileSystemConfigBuilder . getInstance ( ) . getEntryParserFactory ( fileSystemOptions ) ; if ( myFactory != null ) { client . setParserFactory ( myFactory ) ; } try { addSSLParameters ( client , fileSystemOptions ) ; if ( defaultTimeout != null && ( defaultTimeout > 0 ) ) { client . setDefaultTimeout ( defaultTimeout ) ; } client . connect ( hostname , port ) ; if ( defaultTimeout != null && ( defaultTimeout > 0 ) ) { client . setSoTimeout ( defaultTimeout ) ; } log . info ( " Successfully ▁ connected ▁ to ▁ the ▁ FTP ▁ server " ) ; int reply = client . getReplyCode ( ) ; if ( ! FTPReply . isPositiveCompletion ( reply ) ) { throw new FileSystemException ( " vfs . provider . ftp / connect - rejected . error " , hostname ) ; } if ( ! client . login ( UserAuthenticatorUtils . toString ( username ) , UserAuthenticatorUtils . toString ( password ) ) ) { throw new FileSystemException ( " vfs . provider . ftp / login . error " , new Object [ ] { hostname , UserAuthenticatorUtils . toString ( username ) } , null ) ; } Integer fileType = FtpsFileSystemConfigBuilder . getInstance ( ) . getFileType ( fileSystemOptions ) ; if ( fileType == null ) { fileType = FTP . BINARY_FILE_TYPE ; } if ( ! client . setFileType ( fileType ) ) { throw new FileSystemException ( " vfs . provider . ftp / set - fileType . error " , hostname ) ; } Integer dataTimeout = FtpsFileSystemConfigBuilder . getInstance ( ) . getDataTimeout ( fileSystemOptions ) ; if ( dataTimeout != null ) { client . setDataTimeout ( dataTimeout . intValue ( ) ) ; } Boolean userDirIsRoot = FtpsFileSystemConfigBuilder . getInstance ( ) . getUserDirIsRoot ( fileSystemOptions ) ; if ( workingDirectory != null && ( userDirIsRoot == null || ! userDirIsRoot . booleanValue ( ) ) ) { if ( ! client . changeWorkingDirectory ( workingDirectory ) ) { throw new FileSystemException ( " vfs . provider . ftp / change - work - directory . error " , workingDirectory ) ; } } Boolean passiveMode = FtpsFileSystemConfigBuilder . getInstance ( ) . getPassiveMode ( fileSystemOptions ) ; if ( passiveMode != null && passiveMode . booleanValue ( ) ) { client . enterLocalPassiveMode ( ) ; } } catch ( final IOException e ) { if ( client . isConnected ( ) ) { client . disconnect ( ) ; } throw e ; } return client ; } catch ( final Exception exc ) { log . error ( exc ) ; throw new FileSystemException ( " vfs . provider . ftp / connect . error " , new Object [ ] { hostname } , exc ) ; } }
virajsenevirathne/wso2-commons-vfs | private static void addSSLParameters ( FTPSClient ftpsClient , FileSystemOptions fileSystemOptions ) throws Exception { KEYSTORE = FtpsFileSystemConfigBuilder . getInstance ( ) . getKeyStore ( fileSystemOptions ) ; TRUSTSTORE = FtpsFileSystemConfigBuilder . getInstance ( ) . getTrustStore ( fileSystemOptions ) ; KS_PASSWD = FtpsFileSystemConfigBuilder . getInstance ( ) . getKeyStorePW ( fileSystemOptions ) ; TS_PASSWD = FtpsFileSystemConfigBuilder . getInstance ( ) . getTrustStorePW ( fileSystemOptions ) ; KEY_PASSWD = FtpsFileSystemConfigBuilder . getInstance ( ) . getKeyPW ( fileSystemOptions ) ; KeyManagerFactory keyManagerFactory = null ; TrustManagerFactory trustManagerFactory = null ; try { FileInputStream keystorePath = new FileInputStream ( new File ( KEYSTORE ) ) ; FileInputStream truststorePath = new FileInputStream ( new File ( TRUSTSTORE ) ) ; KeyStore keyStore = KeyStore . getInstance ( " jks " ) ; KeyStore trustStore = KeyStore . getInstance ( " jks " ) ; keyStore . load ( keystorePath , KS_PASSWD . toCharArray ( ) ) ; trustStore . load ( truststorePath , TS_PASSWD . toCharArray ( ) ) ; keystorePath . close ( ) ; truststorePath . close ( ) ; keyManagerFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; keyManagerFactory . init ( keyStore , KEY_PASSWD . toCharArray ( ) ) ; trustManagerFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustManagerFactory . init ( trustStore ) ; } catch ( KeyStoreException e ) { log . error ( " Error ▁ occurred ▁ when ▁ initializing ▁ keystores " , e ) ; throw e ; } catch ( IOException e ) { log . error ( " Error ▁ occurred ▁ while ▁ retrieving ▁ the ▁ keystore ▁ paths " , e ) ; throw e ; } catch ( NoSuchAlgorithmException e ) { log . error ( " Error ▁ when ▁ getting ▁ the ▁ default ▁ algorithm " , e ) ; throw e ; } catch ( CertificateException e ) { log . error ( " Certificate ▁ exception ▁ occurred ▁ when ▁ loading ▁ the ▁ KeyStores ▁ " , e ) ; throw e ; } catch ( UnrecoverableKeyException e ) { log . error ( " Unrecoverable ▁ Key ▁ exception ▁ occurred " , e ) ; throw e ; } clientKeyManager = keyManagerFactory . getKeyManagers ( ) [ 0 ] ; clientTrustManager = trustManagerFactory . getTrustManagers ( ) [ 0 ] ; ftpsClient . setKeyManager ( clientKeyManager ) ; ftpsClient . setTrustManager ( clientTrustManager ) ; log . info ( " SSL ▁ parameters ▁ added ▁ to ▁ the ▁ FTPS ▁ client " ) ; }
asedunov/intellij-community | public static TempFileSystem getInstance ( ) { return ApplicationManager . getApplication ( ) . getComponent ( TempFileSystem . class ) ; }
akjava/akjava_gwtlib | public static Voice getVoiceAtLang ( String lang ) { JsArray < Voice > voices = SpeechSynthesis . get ( ) . getVoices ( ) ; for ( int i = 0 ; i < voices . length ( ) ; i ++ ) { if ( voices . get ( i ) . getLang ( ) . equals ( lang ) ) { return voices . get ( i ) ; } } return null ; }
akjava/akjava_gwtlib | public static Voice getVoiceAtLang ( List < Voice > voices , String lang ) { String hifun = lang . replace ( ' _ ' , ' - ' ) ; for ( int i = 0 ; i < voices . size ( ) ; i ++ ) { if ( voices . get ( i ) . getLang ( ) . equals ( lang ) || voices . get ( i ) . getLang ( ) . equals ( hifun ) ) { return voices . get ( i ) ; } } return null ; }
emil-wcislo/sbql4j8 | public static void main ( String [ ] args ) { TestLiteralCodeInPre tester = new TestLiteralCodeInPre ( ) ; run ( tester , ARGS , TEST , NEGATED_TEST ) ; tester . printSummary ( ) ; }
rokn/Count_Words_2015 | public static final Mac getInstance ( String algorithm ) throws NoSuchAlgorithmException { List services = GetInstance . getServices ( " Mac " , algorithm ) ; Iterator t = services . iterator ( ) ; while ( t . hasNext ( ) ) { Service s = ( Service ) t . next ( ) ; if ( JceSecurity . canUseProvider ( s . getProvider ( ) ) == false ) { continue ; } return new Mac ( s , t , algorithm ) ; } throw new NoSuchAlgorithmException ( " Algorithm ▁ " + algorithm + " ▁ not ▁ available " ) ; }
rokn/Count_Words_2015 | public static final Mac getInstance ( String algorithm , Provider provider ) throws NoSuchAlgorithmException { Instance instance = JceSecurity . getInstance ( " Mac " , MacSpi . class , algorithm , provider ) ; return new Mac ( ( MacSpi ) instance . impl , instance . provider , algorithm ) ; }
smblott-github/intent_radio | public static String copy ( Context context , int id , String path ) { return copy ( context , id , path , false ) ; }
smblott-github/intent_radio | public static String copy ( Context context , int id , String path , boolean overwrite ) { log ( " CopyResource ▁ id : ▁ " , " " + id ) ; log ( " CopyResource ▁ path : ▁ " , path ) ; File tmp = null ; InputStream input = null ; FileOutputStream output = null ; boolean success = true ; File sdcard = Environment . getExternalStorageDirectory ( ) ; if ( sdcard == null || ! Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { return " SD ▁ card ▁ not ▁ found ▁ or ▁ not ▁ ready . " ; } path = sdcard . getAbsolutePath ( ) + " / " + path ; log ( " CopyResource ▁ full ▁ path : ▁ " , path ) ; File file = new File ( path ) ; if ( file . exists ( ) && ! overwrite ) { return " File ▁ already ▁ exists , ▁ not ▁ copied . . . " ; } File directory = new File ( file . getParent ( ) ) ; if ( ! directory . isDirectory ( ) ) { return " Directory ▁ does ▁ not ▁ exist . . . " ; } try { tmp = File . createTempFile ( prefix , null , directory ) ; log ( " CopyResource ▁ tmp ▁ path : ▁ " , tmp . toString ( ) ) ; input = context . getResources ( ) . openRawResource ( id ) ; output = new FileOutputStream ( tmp ) ; byte [ ] buffer = new byte [ 1024 ] ; int count = 0 ; while ( 0 < ( count = input . read ( buffer ) ) ) output . write ( buffer , 0 , count ) ; } catch ( Exception e1 ) { success = false ; } finally { try { if ( output != null ) output . close ( ) ; } catch ( Exception e2 ) { success = false ; } try { if ( input != null ) input . close ( ) ; } catch ( Exception e2 ) { } } if ( success ) success = tmp . renameTo ( file ) ; if ( tmp != null && tmp . exists ( ) ) if ( ! tmp . delete ( ) ) log ( " CopyResource ▁ failed ▁ to ▁ delete : ▁ " , tmp . toString ( ) ) ; return success ? null : " Unknown ▁ error . . . " ; }
tommista/android-net | static final void registerGson ( GsonBuilder gb ) { gb . registerTypeAdapter ( ObjectRef . class , AutoParcelAdapter . create ( AutoParcel_ObjectRef . class ) ) ; }
tommista/android-net | public static final Builder builder ( ) { return new AutoParcel_ObjectRef . Builder ( ) ; }
akhettar/camel | @ Converter public static ACK toACK ( String body ) throws HL7Exception { return toMessage ( ACK . class , body ) ; }
akhettar/camel | @ Converter public static ADR_A19 toAdrA19 ( String body ) throws HL7Exception { return toMessage ( ADR_A19 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A01 toAdtA01 ( String body ) throws HL7Exception { return toMessage ( ADT_A01 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A02 toAdtA02 ( String body ) throws HL7Exception { return toMessage ( ADT_A02 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A03 toAdtA03 ( String body ) throws HL7Exception { return toMessage ( ADT_A03 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A04 toAdtA04 ( String body ) throws HL7Exception { return toMessage ( ADT_A04 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A05 toAdtA05 ( String body ) throws HL7Exception { return toMessage ( ADT_A05 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A06 toAdtA06 ( String body ) throws HL7Exception { return toMessage ( ADT_A06 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A07 toAdtA07 ( String body ) throws HL7Exception { return toMessage ( ADT_A07 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A08 toAdtA08 ( String body ) throws HL7Exception { return toMessage ( ADT_A08 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A09 toAdtA09 ( String body ) throws HL7Exception { return toMessage ( ADT_A09 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A10 toAdtA10 ( String body ) throws HL7Exception { return toMessage ( ADT_A10 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A11 toAdtA11 ( String body ) throws HL7Exception { return toMessage ( ADT_A11 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A12 toAdtA12 ( String body ) throws HL7Exception { return toMessage ( ADT_A12 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A13 toAdtA13 ( String body ) throws HL7Exception { return toMessage ( ADT_A13 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A14 toAdtA14 ( String body ) throws HL7Exception { return toMessage ( ADT_A14 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A15 toAdtA15 ( String body ) throws HL7Exception { return toMessage ( ADT_A15 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A16 toAdtA16 ( String body ) throws HL7Exception { return toMessage ( ADT_A16 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A17 toAdtA17 ( String body ) throws HL7Exception { return toMessage ( ADT_A17 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A18 toAdtA18 ( String body ) throws HL7Exception { return toMessage ( ADT_A18 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A20 toAdtA20 ( String body ) throws HL7Exception { return toMessage ( ADT_A20 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A21 toAdtA21 ( String body ) throws HL7Exception { return toMessage ( ADT_A21 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A22 toAdtA22 ( String body ) throws HL7Exception { return toMessage ( ADT_A22 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A23 toAdtA23 ( String body ) throws HL7Exception { return toMessage ( ADT_A23 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A24 toAdtA24 ( String body ) throws HL7Exception { return toMessage ( ADT_A24 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A25 toAdtA25 ( String body ) throws HL7Exception { return toMessage ( ADT_A25 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A26 toAdtA26 ( String body ) throws HL7Exception { return toMessage ( ADT_A26 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A27 toAdtA27 ( String body ) throws HL7Exception { return toMessage ( ADT_A27 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A28 toAdtA28 ( String body ) throws HL7Exception { return toMessage ( ADT_A28 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A29 toAdtA29 ( String body ) throws HL7Exception { return toMessage ( ADT_A29 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A30 toAdtA30 ( String body ) throws HL7Exception { return toMessage ( ADT_A30 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A31 toAdtA31 ( String body ) throws HL7Exception { return toMessage ( ADT_A31 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A32 toAdtA32 ( String body ) throws HL7Exception { return toMessage ( ADT_A32 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A33 toAdtA33 ( String body ) throws HL7Exception { return toMessage ( ADT_A33 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A34 toAdtA34 ( String body ) throws HL7Exception { return toMessage ( ADT_A34 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A35 toAdtA35 ( String body ) throws HL7Exception { return toMessage ( ADT_A35 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A36 toAdtA36 ( String body ) throws HL7Exception { return toMessage ( ADT_A36 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A37 toAdtA37 ( String body ) throws HL7Exception { return toMessage ( ADT_A37 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A38 toAdtA38 ( String body ) throws HL7Exception { return toMessage ( ADT_A38 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A39 toAdtA39 ( String body ) throws HL7Exception { return toMessage ( ADT_A39 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A40 toAdtA40 ( String body ) throws HL7Exception { return toMessage ( ADT_A40 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A41 toAdtA41 ( String body ) throws HL7Exception { return toMessage ( ADT_A41 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A42 toAdtA42 ( String body ) throws HL7Exception { return toMessage ( ADT_A42 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A43 toAdtA43 ( String body ) throws HL7Exception { return toMessage ( ADT_A43 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A44 toAdtA44 ( String body ) throws HL7Exception { return toMessage ( ADT_A44 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A45 toAdtA45 ( String body ) throws HL7Exception { return toMessage ( ADT_A45 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A46 toAdtA46 ( String body ) throws HL7Exception { return toMessage ( ADT_A46 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A47 toAdtA47 ( String body ) throws HL7Exception { return toMessage ( ADT_A47 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A48 toAdtA48 ( String body ) throws HL7Exception { return toMessage ( ADT_A48 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A49 toAdtA49 ( String body ) throws HL7Exception { return toMessage ( ADT_A49 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A50 toAdtA50 ( String body ) throws HL7Exception { return toMessage ( ADT_A50 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A51 toAdtA51 ( String body ) throws HL7Exception { return toMessage ( ADT_A51 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_AXX toAdtAXX ( String body ) throws HL7Exception { return toMessage ( ADT_AXX . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P01 toBarP01 ( String body ) throws HL7Exception { return toMessage ( BAR_P01 . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P02 toBarP02 ( String body ) throws HL7Exception { return toMessage ( BAR_P02 . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P05 toBarP05 ( String body ) throws HL7Exception { return toMessage ( BAR_P05 . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P06 toBarP06 ( String body ) throws HL7Exception { return toMessage ( BAR_P06 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C01 toCrmC01 ( String body ) throws HL7Exception { return toMessage ( CRM_C01 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C02 toCrmC02 ( String body ) throws HL7Exception { return toMessage ( CRM_C02 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C03 toCrmC03 ( String body ) throws HL7Exception { return toMessage ( CRM_C03 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C04 toCrmC04 ( String body ) throws HL7Exception { return toMessage ( CRM_C04 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C05 toCrmC05 ( String body ) throws HL7Exception { return toMessage ( CRM_C05 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C06 toCrmC06 ( String body ) throws HL7Exception { return toMessage ( CRM_C06 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C07 toCrmC07 ( String body ) throws HL7Exception { return toMessage ( CRM_C07 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C08 toCrmC08 ( String body ) throws HL7Exception { return toMessage ( CRM_C08 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C09 toCsuC09 ( String body ) throws HL7Exception { return toMessage ( CSU_C09 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C10 toCsuC10 ( String body ) throws HL7Exception { return toMessage ( CSU_C10 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C11 toCsuC11 ( String body ) throws HL7Exception { return toMessage ( CSU_C11 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C12 toCsuC12 ( String body ) throws HL7Exception { return toMessage ( CSU_C12 . class , body ) ; }
akhettar/camel | @ Converter public static DFT_P03 toDftP03 ( String body ) throws HL7Exception { return toMessage ( DFT_P03 . class , body ) ; }
akhettar/camel | @ Converter public static DOC_T12 toDocT12 ( String body ) throws HL7Exception { return toMessage ( DOC_T12 . class , body ) ; }
akhettar/camel | @ Converter public static DSR_Q01 toDsrQ01 ( String body ) throws HL7Exception { return toMessage ( DSR_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static DSR_Q03 toDsrQ03 ( String body ) throws HL7Exception { return toMessage ( DSR_Q03 . class , body ) ; }
akhettar/camel | @ Converter public static EDR_Q01 toEdrQ01 ( String body ) throws HL7Exception { return toMessage ( EDR_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static EQQ_Q01 toEqqQ01 ( String body ) throws HL7Exception { return toMessage ( EQQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static ERP_Q01 toErpQ01 ( String body ) throws HL7Exception { return toMessage ( ERP_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T01 toMdmT01 ( String body ) throws HL7Exception { return toMessage ( MDM_T01 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T02 toMdmT02 ( String body ) throws HL7Exception { return toMessage ( MDM_T02 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T03 toMdmT03 ( String body ) throws HL7Exception { return toMessage ( MDM_T03 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T04 toMdmT04 ( String body ) throws HL7Exception { return toMessage ( MDM_T04 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T05 toMdmT05 ( String body ) throws HL7Exception { return toMessage ( MDM_T05 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T06 toMdmT06 ( String body ) throws HL7Exception { return toMessage ( MDM_T06 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T07 toMdmT07 ( String body ) throws HL7Exception { return toMessage ( MDM_T07 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T08 toMdmT08 ( String body ) throws HL7Exception { return toMessage ( MDM_T08 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T09 toMdmT09 ( String body ) throws HL7Exception { return toMessage ( MDM_T09 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T10 toMdmT10 ( String body ) throws HL7Exception { return toMessage ( MDM_T10 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T11 toMdmT11 ( String body ) throws HL7Exception { return toMessage ( MDM_T11 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M01 toMfkM01 ( String body ) throws HL7Exception { return toMessage ( MFK_M01 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M02 toMfkM02 ( String body ) throws HL7Exception { return toMessage ( MFK_M02 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M03 toMfkM03 ( String body ) throws HL7Exception { return toMessage ( MFK_M03 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M04 toMfkM04 ( String body ) throws HL7Exception { return toMessage ( MFK_M04 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M05 toMfkM05 ( String body ) throws HL7Exception { return toMessage ( MFK_M05 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M07 toMfkM07 ( String body ) throws HL7Exception { return toMessage ( MFK_M07 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M01 toMfnM01 ( String body ) throws HL7Exception { return toMessage ( MFN_M01 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M02 toMfnM02 ( String body ) throws HL7Exception { return toMessage ( MFN_M02 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M03 toMfnM03 ( String body ) throws HL7Exception { return toMessage ( MFN_M03 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M04 toMfnM04 ( String body ) throws HL7Exception { return toMessage ( MFN_M04 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M05 toMfnM05 ( String body ) throws HL7Exception { return toMessage ( MFN_M05 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M06 toMfnM06 ( String body ) throws HL7Exception { return toMessage ( MFN_M06 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M07 toMfnM07 ( String body ) throws HL7Exception { return toMessage ( MFN_M07 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M08 toMfnM08 ( String body ) throws HL7Exception { return toMessage ( MFN_M08 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M09 toMfnM09 ( String body ) throws HL7Exception { return toMessage ( MFN_M09 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M10 toMfnM10 ( String body ) throws HL7Exception { return toMessage ( MFN_M10 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M11 toMfnM11 ( String body ) throws HL7Exception { return toMessage ( MFN_M11 . class , body ) ; }
akhettar/camel | @ Converter public static OMD_O01 toOmdO01 ( String body ) throws HL7Exception { return toMessage ( OMD_O01 . class , body ) ; }
akhettar/camel | @ Converter public static OMN_O01 toOmnO01 ( String body ) throws HL7Exception { return toMessage ( OMN_O01 . class , body ) ; }
akhettar/camel | @ Converter public static OMS_O01 toOmsO01 ( String body ) throws HL7Exception { return toMessage ( OMS_O01 . class , body ) ; }
akhettar/camel | @ Converter public static ORD_O02 toOrdO02 ( String body ) throws HL7Exception { return toMessage ( ORD_O02 . class , body ) ; }
akhettar/camel | @ Converter public static ORF_R02 toOrfR02 ( String body ) throws HL7Exception { return toMessage ( ORF_R02 . class , body ) ; }
akhettar/camel | @ Converter public static ORF_R04 toOrfR04 ( String body ) throws HL7Exception { return toMessage ( ORF_R04 . class , body ) ; }
akhettar/camel | @ Converter public static ORM_O01 toOrmO01 ( String body ) throws HL7Exception { return toMessage ( ORM_O01 . class , body ) ; }
akhettar/camel | @ Converter public static ORN_O02 toOrnO02 ( String body ) throws HL7Exception { return toMessage ( ORN_O02 . class , body ) ; }
akhettar/camel | @ Converter public static ORR_O02 toOrrO02 ( String body ) throws HL7Exception { return toMessage ( ORR_O02 . class , body ) ; }
akhettar/camel | @ Converter public static ORU_R01 toOruR01 ( String body ) throws HL7Exception { return toMessage ( ORU_R01 . class , body ) ; }
akhettar/camel | @ Converter public static OSQ_Q06 toOsqQ06 ( String body ) throws HL7Exception { return toMessage ( OSQ_Q06 . class , body ) ; }
akhettar/camel | @ Converter public static OSR_Q06 toOsrQ06 ( String body ) throws HL7Exception { return toMessage ( OSR_Q06 . class , body ) ; }
akhettar/camel | @ Converter public static PEX_P07 toPexP07 ( String body ) throws HL7Exception { return toMessage ( PEX_P07 . class , body ) ; }
akhettar/camel | @ Converter public static PEX_P08 toPexP08 ( String body ) throws HL7Exception { return toMessage ( PEX_P08 . class , body ) ; }
akhettar/camel | @ Converter public static PGL_PC6 toPglPc6 ( String body ) throws HL7Exception { return toMessage ( PGL_PC6 . class , body ) ; }
akhettar/camel | @ Converter public static PGL_PC7 toPglPc7 ( String body ) throws HL7Exception { return toMessage ( PGL_PC7 . class , body ) ; }
akhettar/camel | @ Converter public static PGL_PC8 toPglPc8 ( String body ) throws HL7Exception { return toMessage ( PGL_PC8 . class , body ) ; }
akhettar/camel | @ Converter public static PIN_I07 toPinI07 ( String body ) throws HL7Exception { return toMessage ( PIN_I07 . class , body ) ; }
akhettar/camel | @ Converter public static PPG_PCG toPpgPcg ( String body ) throws HL7Exception { return toMessage ( PPG_PCG . class , body ) ; }
akhettar/camel | @ Converter public static PPG_PCH toPpgPch ( String body ) throws HL7Exception { return toMessage ( PPG_PCH . class , body ) ; }
akhettar/camel | @ Converter public static PPG_PCJ toPpgPcj ( String body ) throws HL7Exception { return toMessage ( PPG_PCJ . class , body ) ; }
akhettar/camel | @ Converter public static PPP_PCB toPppPcb ( String body ) throws HL7Exception { return toMessage ( PPP_PCB . class , body ) ; }
akhettar/camel | @ Converter public static PPP_PCC toPppPcc ( String body ) throws HL7Exception { return toMessage ( PPP_PCC . class , body ) ; }
akhettar/camel | @ Converter public static PPP_PCD toPppPcd ( String body ) throws HL7Exception { return toMessage ( PPP_PCD . class , body ) ; }
akhettar/camel | @ Converter public static PPR_PC1 toPprPc1 ( String body ) throws HL7Exception { return toMessage ( PPR_PC1 . class , body ) ; }
akhettar/camel | @ Converter public static PPR_PC2 toPprPc2 ( String body ) throws HL7Exception { return toMessage ( PPR_PC2 . class , body ) ; }
akhettar/camel | @ Converter public static PPR_PC3 toPprPc3 ( String body ) throws HL7Exception { return toMessage ( PPR_PC3 . class , body ) ; }
akhettar/camel | @ Converter public static PPT_PCL toPptPcl ( String body ) throws HL7Exception { return toMessage ( PPT_PCL . class , body ) ; }
akhettar/camel | @ Converter public static PPV_PCA toPpvPca ( String body ) throws HL7Exception { return toMessage ( PPV_PCA . class , body ) ; }
akhettar/camel | @ Converter public static PRR_PC5 toPrrPc5 ( String body ) throws HL7Exception { return toMessage ( PRR_PC5 . class , body ) ; }
akhettar/camel | @ Converter public static PTR_PCF toPtrPcf ( String body ) throws HL7Exception { return toMessage ( PTR_PCF . class , body ) ; }
akhettar/camel | @ Converter public static QCK_Q02 toQckQ02 ( String body ) throws HL7Exception { return toMessage ( QCK_Q02 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_A19 toQryA19 ( String body ) throws HL7Exception { return toMessage ( QRY_A19 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PC4 toQryPC4 ( String body ) throws HL7Exception { return toMessage ( QRY_PC4 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PC9 toQryPC9 ( String body ) throws HL7Exception { return toMessage ( QRY_PC9 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PCE toQryPCE ( String body ) throws HL7Exception { return toMessage ( QRY_PCE . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PCK toQryPCK ( String body ) throws HL7Exception { return toMessage ( QRY_PCK . class , body ) ; }
akhettar/camel | @ Converter public static QRY_Q01 toQryQ01 ( String body ) throws HL7Exception { return toMessage ( QRY_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_Q02 toQryQ02 ( String body ) throws HL7Exception { return toMessage ( QRY_Q02 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_R02 toQryR02 ( String body ) throws HL7Exception { return toMessage ( QRY_R02 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_T12 toQryT12 ( String body ) throws HL7Exception { return toMessage ( QRY_T12 . class , body ) ; }
akhettar/camel | @ Converter public static RAR_RAR toRarRar ( String body ) throws HL7Exception { return toMessage ( RAR_RAR . class , body ) ; }
akhettar/camel | @ Converter public static RAS_O01 toRasO01 ( String body ) throws HL7Exception { return toMessage ( RAS_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RAS_O02 toRasO02 ( String body ) throws HL7Exception { return toMessage ( RAS_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RCI_I05 toRciI05 ( String body ) throws HL7Exception { return toMessage ( RCI_I05 . class , body ) ; }
akhettar/camel | @ Converter public static RCL_I06 toRclI06 ( String body ) throws HL7Exception { return toMessage ( RCL_I06 . class , body ) ; }
akhettar/camel | @ Converter public static RDE_O01 toRdeO01 ( String body ) throws HL7Exception { return toMessage ( RDE_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RDO_O01 toRdoO01 ( String body ) throws HL7Exception { return toMessage ( RDO_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RDR_RDR toRdrRdr ( String body ) throws HL7Exception { return toMessage ( RDR_RDR . class , body ) ; }
akhettar/camel | @ Converter public static RDS_O01 toRdsO01 ( String body ) throws HL7Exception { return toMessage ( RDS_O01 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I12 toRefI12 ( String body ) throws HL7Exception { return toMessage ( REF_I12 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I13 toRefI13 ( String body ) throws HL7Exception { return toMessage ( REF_I13 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I14 toRefI14 ( String body ) throws HL7Exception { return toMessage ( REF_I14 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I15 toRefI15 ( String body ) throws HL7Exception { return toMessage ( REF_I15 . class , body ) ; }
akhettar/camel | @ Converter public static RER_RER toRerRer ( String body ) throws HL7Exception { return toMessage ( RER_RER . class , body ) ; }
akhettar/camel | @ Converter public static RGR_RGR toRgrRgr ( String body ) throws HL7Exception { return toMessage ( RGR_RGR . class , body ) ; }
akhettar/camel | @ Converter public static RGV_O01 toRgvO01 ( String body ) throws HL7Exception { return toMessage ( RGV_O01 . class , body ) ; }
akhettar/camel | @ Converter public static ROR_ROR toRorRor ( String body ) throws HL7Exception { return toMessage ( ROR_ROR . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I08 toRpaI08 ( String body ) throws HL7Exception { return toMessage ( RPA_I08 . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I09 toRpaI09 ( String body ) throws HL7Exception { return toMessage ( RPA_I09 . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I10 toRpaI10 ( String body ) throws HL7Exception { return toMessage ( RPA_I10 . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I11 toRpaI11 ( String body ) throws HL7Exception { return toMessage ( RPA_I11 . class , body ) ; }
akhettar/camel | @ Converter public static RPI_I01 toRpiI01 ( String body ) throws HL7Exception { return toMessage ( RPI_I01 . class , body ) ; }
akhettar/camel | @ Converter public static RPI_I04 toRpiI04 ( String body ) throws HL7Exception { return toMessage ( RPI_I04 . class , body ) ; }
akhettar/camel | @ Converter public static RPL_I02 toRplI02 ( String body ) throws HL7Exception { return toMessage ( RPL_I02 . class , body ) ; }
akhettar/camel | @ Converter public static RPR_I03 toRprI03 ( String body ) throws HL7Exception { return toMessage ( RPR_I03 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I08 toRqaI08 ( String body ) throws HL7Exception { return toMessage ( RQA_I08 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I09 toRqaI09 ( String body ) throws HL7Exception { return toMessage ( RQA_I09 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I10 toRqaI10 ( String body ) throws HL7Exception { return toMessage ( RQA_I10 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I11 toRqaI11 ( String body ) throws HL7Exception { return toMessage ( RQA_I11 . class , body ) ; }
akhettar/camel | @ Converter public static RQC_I05 toRqcI05 ( String body ) throws HL7Exception { return toMessage ( RQC_I05 . class , body ) ; }
akhettar/camel | @ Converter public static RQC_I06 toRqcI06 ( String body ) throws HL7Exception { return toMessage ( RQC_I06 . class , body ) ; }
akhettar/camel | @ Converter public static RQI_I01 toRqiI01 ( String body ) throws HL7Exception { return toMessage ( RQI_I01 . class , body ) ; }
akhettar/camel | @ Converter public static RQI_I02 toRqiI02 ( String body ) throws HL7Exception { return toMessage ( RQI_I02 . class , body ) ; }
akhettar/camel | @ Converter public static RQI_I03 toRqiI03 ( String body ) throws HL7Exception { return toMessage ( RQI_I03 . class , body ) ; }
akhettar/camel | @ Converter public static RQP_I04 toRqpI04 ( String body ) throws HL7Exception { return toMessage ( RQP_I04 . class , body ) ; }
akhettar/camel | @ Converter public static RQQ_Q01 toRqqQ01 ( String body ) throws HL7Exception { return toMessage ( RQQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static RRA_O02 toRraO02 ( String body ) throws HL7Exception { return toMessage ( RRA_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RRD_O02 toRrdO02 ( String body ) throws HL7Exception { return toMessage ( RRD_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RRE_O01 toRreO01 ( String body ) throws HL7Exception { return toMessage ( RRE_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RRG_O02 toRrgO02 ( String body ) throws HL7Exception { return toMessage ( RRG_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I12 toRriI12 ( String body ) throws HL7Exception { return toMessage ( RRI_I12 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I13 toRriI13 ( String body ) throws HL7Exception { return toMessage ( RRI_I13 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I14 toRriI14 ( String body ) throws HL7Exception { return toMessage ( RRI_I14 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I15 toRriI15 ( String body ) throws HL7Exception { return toMessage ( RRI_I15 . class , body ) ; }
akhettar/camel | @ Converter public static RRO_O02 toRroO02 ( String body ) throws HL7Exception { return toMessage ( RRO_O02 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S12 toSiuS12 ( String body ) throws HL7Exception { return toMessage ( SIU_S12 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S13 toSiuS13 ( String body ) throws HL7Exception { return toMessage ( SIU_S13 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S14 toSiuS14 ( String body ) throws HL7Exception { return toMessage ( SIU_S14 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S15 toSiuS15 ( String body ) throws HL7Exception { return toMessage ( SIU_S15 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S16 toSiuS16 ( String body ) throws HL7Exception { return toMessage ( SIU_S16 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S17 toSiuS17 ( String body ) throws HL7Exception { return toMessage ( SIU_S17 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S18 toSiuS18 ( String body ) throws HL7Exception { return toMessage ( SIU_S18 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S19 toSiuS19 ( String body ) throws HL7Exception { return toMessage ( SIU_S19 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S20 toSiuS20 ( String body ) throws HL7Exception { return toMessage ( SIU_S20 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S21 toSiuS21 ( String body ) throws HL7Exception { return toMessage ( SIU_S21 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S22 toSiuS22 ( String body ) throws HL7Exception { return toMessage ( SIU_S22 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S23 toSiuS23 ( String body ) throws HL7Exception { return toMessage ( SIU_S23 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S24 toSiuS24 ( String body ) throws HL7Exception { return toMessage ( SIU_S24 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S26 toSiuS26 ( String body ) throws HL7Exception { return toMessage ( SIU_S26 . class , body ) ; }
akhettar/camel | @ Converter public static SPQ_Q01 toSpqQ01 ( String body ) throws HL7Exception { return toMessage ( SPQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static SQM_S25 toSqmS25 ( String body ) throws HL7Exception { return toMessage ( SQM_S25 . class , body ) ; }
akhettar/camel | @ Converter public static SQR_S25 toSqrS25 ( String body ) throws HL7Exception { return toMessage ( SQR_S25 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S01 toSrmS01 ( String body ) throws HL7Exception { return toMessage ( SRM_S01 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S02 toSrmS02 ( String body ) throws HL7Exception { return toMessage ( SRM_S02 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S03 toSrmS03 ( String body ) throws HL7Exception { return toMessage ( SRM_S03 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S04 toSrmS04 ( String body ) throws HL7Exception { return toMessage ( SRM_S04 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S05 toSrmS05 ( String body ) throws HL7Exception { return toMessage ( SRM_S05 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S06 toSrmS06 ( String body ) throws HL7Exception { return toMessage ( SRM_S06 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S07 toSrmS07 ( String body ) throws HL7Exception { return toMessage ( SRM_S07 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S08 toSrmS08 ( String body ) throws HL7Exception { return toMessage ( SRM_S08 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S09 toSrmS09 ( String body ) throws HL7Exception { return toMessage ( SRM_S09 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S10 toSrmS10 ( String body ) throws HL7Exception { return toMessage ( SRM_S10 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S11 toSrmS11 ( String body ) throws HL7Exception { return toMessage ( SRM_S11 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S01 toSrrS01 ( String body ) throws HL7Exception { return toMessage ( SRR_S01 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S02 toSrrS02 ( String body ) throws HL7Exception { return toMessage ( SRR_S02 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S03 toSrrS03 ( String body ) throws HL7Exception { return toMessage ( SRR_S03 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S04 toSrrS04 ( String body ) throws HL7Exception { return toMessage ( SRR_S04 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S05 toSrrS05 ( String body ) throws HL7Exception { return toMessage ( SRR_S05 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S06 toSrrS06 ( String body ) throws HL7Exception { return toMessage ( SRR_S06 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S07 toSrrS07 ( String body ) throws HL7Exception { return toMessage ( SRR_S07 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S08 toSrrS08 ( String body ) throws HL7Exception { return toMessage ( SRR_S08 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S09 toSrrS09 ( String body ) throws HL7Exception { return toMessage ( SRR_S09 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S10 toSrrS10 ( String body ) throws HL7Exception { return toMessage ( SRR_S10 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S11 toSrrS11 ( String body ) throws HL7Exception { return toMessage ( SRR_S11 . class , body ) ; }
akhettar/camel | @ Converter public static SUR_P09 toSurP09 ( String body ) throws HL7Exception { return toMessage ( SUR_P09 . class , body ) ; }
akhettar/camel | @ Converter public static TBR_Q01 toTbrQ01 ( String body ) throws HL7Exception { return toMessage ( TBR_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static UDM_Q05 toUdmQ05 ( String body ) throws HL7Exception { return toMessage ( UDM_Q05 . class , body ) ; }
akhettar/camel | @ Converter public static VQQ_Q01 toVqqQ01 ( String body ) throws HL7Exception { return toMessage ( VQQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static VXQ_V01 toVxqV01 ( String body ) throws HL7Exception { return toMessage ( VXQ_V01 . class , body ) ; }
akhettar/camel | @ Converter public static VXR_V03 toVxrV03 ( String body ) throws HL7Exception { return toMessage ( VXR_V03 . class , body ) ; }
akhettar/camel | @ Converter public static VXU_V04 toVxuV04 ( String body ) throws HL7Exception { return toMessage ( VXU_V04 . class , body ) ; }
akhettar/camel | @ Converter public static VXX_V02 toVxxV02 ( String body ) throws HL7Exception { return toMessage ( VXX_V02 . class , body ) ; }
akhettar/camel | static < T extends Message > T toMessage ( Class < T > messageClass , String hl7String ) { try { T genericMessage = DEFAULT_CONTEXT . newMessage ( messageClass ) ; genericMessage . parse ( hl7String ) ; return genericMessage ; } catch ( HL7Exception conversionEx ) { throw new TypeConversionException ( hl7String , String . class , conversionEx ) ; } }
akhettar/camel | static < T extends Message > T toMessage ( Class < T > messageClass , byte [ ] hl7Bytes , Exchange exchange ) { try { T genericMessage = DEFAULT_CONTEXT . newMessage ( messageClass ) ; genericMessage . parse ( IOConverter . toString ( hl7Bytes , exchange ) ) ; return genericMessage ; } catch ( HL7Exception | IOException conversionEx ) { throw new TypeConversionException ( hl7Bytes , byte [ ] . class , conversionEx ) ; } }
impro3-nerdle/nerdle | public static SingletonGraph getInstance ( ) throws ConfigurationException { if ( SingletonGraph . instance == null ) { SingletonGraph . instance = new SingletonGraph ( ) ; } return SingletonGraph . instance ; }
mrodrigues/ASD-Teaching-Tool | public static Context getContext ( ) { return initialContext ; }
lifechurch/nuclei-android | public static Matcher < View > atPosition ( final int position , @ NonNull final Matcher < View > itemMatcher ) { return new BoundedMatcher < View , RecyclerView > ( RecyclerView . class ) { @ Override public void describeTo ( Description description ) { description . appendText ( " adapter ▁ position ▁ " + position + " : ▁ " ) ; itemMatcher . describeTo ( description ) ; } @ Override protected boolean matchesSafely ( final RecyclerView view ) { RecyclerView . ViewHolder viewHolder = view . findViewHolderForAdapterPosition ( position ) ; return viewHolder != null && itemMatcher . matches ( viewHolder . itemView ) ; } } ; }
lifechurch/nuclei-android | public static ViewAction scrollToPosition ( final int position ) { return new ViewAction ( ) { @ SuppressWarnings ( " unchecked " ) @ Override public Matcher < View > getConstraints ( ) { return isAssignableFrom ( RecyclerView . class ) ; } @ Override public void perform ( UiController uiController , View view ) { ( ( RecyclerView ) view ) . scrollToPosition ( position ) ; } @ Override public String getDescription ( ) { return " scroll ▁ to " ; } } ; }
SpannaProject/SpannaAPI | public static List < Command > parse ( Component component ) { List < Command > componentCmds = new ArrayList < Command > ( ) ; Map < String , Map < String , Object > > map = component . getDescription ( ) . getCommands ( ) ; if ( map == null ) { return componentCmds ; } for ( Entry < String , Map < String , Object > > entry : map . entrySet ( ) ) { if ( entry . getKey ( ) . contains ( " : " ) ) { Spanna . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ command ▁ " + entry . getKey ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; continue ; } Command newCmd = new ComponentCommand ( entry . getKey ( ) , component ) ; Object description = entry . getValue ( ) . get ( " description " ) ; Object usage = entry . getValue ( ) . get ( " usage " ) ; Object aliases = entry . getValue ( ) . get ( " aliases " ) ; Object permission = entry . getValue ( ) . get ( " permission " ) ; Object permissionMessage = entry . getValue ( ) . get ( " permission - message " ) ; if ( description != null ) { newCmd . setDescription ( description . toString ( ) ) ; } if ( usage != null ) { newCmd . setUsage ( usage . toString ( ) ) ; } if ( aliases != null ) { List < String > aliasList = new ArrayList < String > ( ) ; if ( aliases instanceof List ) { for ( Object o : ( List < ? > ) aliases ) { if ( o . toString ( ) . contains ( " : " ) ) { Spanna . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ alias ▁ " + o . toString ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; continue ; } aliasList . add ( o . toString ( ) ) ; } } else { if ( aliases . toString ( ) . contains ( " : " ) ) { Spanna . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ alias ▁ " + aliases . toString ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; } else { aliasList . add ( aliases . toString ( ) ) ; } } newCmd . setAliases ( aliasList ) ; } if ( permission != null ) { newCmd . setPermission ( permission . toString ( ) ) ; } if ( permissionMessage != null ) { newCmd . setPermissionMessage ( permissionMessage . toString ( ) ) ; } componentCmds . add ( newCmd ) ; } return componentCmds ; }
DDTH/ddth-queue | public static Test suite ( ) { return new TestSuite ( TestInmemQueueBoundSmallEphemeralDisabled . class ) ; }
IBM-Bluemix/BluemixBoutique | private static EntityManager getEm ( ) { InitialContext ic ; try { ic = new InitialContext ( ) ; return ( EntityManager ) ic . lookup ( " java : comp / env / bluemixboutiquepu / entitymanager " ) ; } catch ( NamingException e ) { System . out . println ( " ERROR ▁ obtaining ▁ EntityManager " ) ; e . printStackTrace ( ) ; } return null ; }
Java-Discord-Bot-System/JDA | public static OffsetDateTime getCreationTime ( String entityId ) { try { long timestamp = ( ( Long . parseLong ( entityId ) >> 22 ) + 1420070400000L ) ; Calendar gmt = Calendar . getInstance ( TimeZone . getTimeZone ( " GMT " ) ) ; gmt . setTimeInMillis ( timestamp ) ; return OffsetDateTime . ofInstant ( gmt . toInstant ( ) , gmt . getTimeZone ( ) . toZoneId ( ) ) ; } catch ( NumberFormatException ex ) { return null ; } }
Java-Discord-Bot-System/JDA | public static OffsetDateTime getCreationTime ( Object entity ) { try { Method idMethod = entity . getClass ( ) . getMethod ( " getId " ) ; if ( idMethod . getReturnType ( ) != String . class ) { JDAImpl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } String objId = ( String ) idMethod . invoke ( entity ) ; return getCreationTime ( objId ) ; } catch ( Exception e ) { JDAImpl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } }
Java-Discord-Bot-System/JDA | public static String getDateTimeString ( OffsetDateTime time ) { return time . format ( dtFormatter ) ; }
BryceARich/TransactionsMR | private static HttpServletRequest createMockRequest ( String handler , boolean taskQueueRequest , boolean ajaxRequest ) { HttpServletRequest request = createMock ( HttpServletRequest . class ) ; if ( taskQueueRequest ) { expect ( request . getHeader ( " X - AppEngine - QueueName " ) ) . andReturn ( " default " ) . anyTimes ( ) ; } else { expect ( request . getHeader ( " X - AppEngine - QueueName " ) ) . andReturn ( null ) . anyTimes ( ) ; } if ( ajaxRequest ) { expect ( request . getHeader ( " X - Requested - With " ) ) . andReturn ( " XMLHttpRequest " ) . anyTimes ( ) ; } else { expect ( request . getHeader ( " X - Requested - With " ) ) . andReturn ( null ) . anyTimes ( ) ; } expect ( request . getPathInfo ( ) ) . andReturn ( " / " + handler ) . anyTimes ( ) ; return request ; }
sapirgolan/MFIBlocking | public static String tokenTerm ( String inputTerm ) { StringBuilder builder = new StringBuilder ( ) ; try { TokenStream tokenStream = analyzer . tokenStream ( null , inputTerm ) ; OffsetAttribute offsetAttribute = tokenStream . addAttribute ( OffsetAttribute . class ) ; CharTermAttribute charTermAttribute = tokenStream . addAttribute ( CharTermAttribute . class ) ; tokenStream . reset ( ) ; while ( tokenStream . incrementToken ( ) ) { int startOffset = offsetAttribute . startOffset ( ) ; int endOffset = offsetAttribute . endOffset ( ) ; String term = charTermAttribute . toString ( ) ; builder . append ( term ) . append ( ' ▁ ' ) ; } tokenStream . end ( ) ; tokenStream . close ( ) ; } catch ( IOException e ) { logger . error ( " Failed ▁ to ▁ tokenize ▁ " + inputTerm , e ) ; } if ( builder . length ( ) != 0 ) { builder . deleteCharAt ( builder . length ( ) - 1 ) ; } return builder . toString ( ) ; }
xuegongzi/rabbitframework | public static < E > Set < E > asSet ( E ... elements ) { if ( elements == null || elements . length == 0 ) { return Collections . emptySet ( ) ; } if ( elements . length == 1 ) { return Collections . singleton ( elements [ 0 ] ) ; } LinkedHashSet < E > set = new LinkedHashSet < E > ( elements . length * 4 / 3 + 1 ) ; Collections . addAll ( set , elements ) ; return set ; }
xuegongzi/rabbitframework | public static boolean isEmpty ( Collection c ) { return c == null || c . isEmpty ( ) ; }
xuegongzi/rabbitframework | public static boolean isEmpty ( Map m ) { return m == null || m . isEmpty ( ) ; }
xuegongzi/rabbitframework | public static int size ( Collection c ) { return c != null ? c . size ( ) : 0 ; }
xuegongzi/rabbitframework | public static int size ( Map m ) { return m != null ? m . size ( ) : 0 ; }
xuegongzi/rabbitframework | public static boolean isEmpty ( PrincipalCollection principals ) { return principals == null || principals . isEmpty ( ) ; }
xuegongzi/rabbitframework | public static < E > List < E > asList ( E ... elements ) { if ( elements == null || elements . length == 0 ) { return Collections . emptyList ( ) ; } return Arrays . asList ( elements ) ; }
xuegongzi/rabbitframework | static int computeListCapacity ( int arraySize ) { return ( int ) Math . min ( 5L + arraySize + ( arraySize / 10 ) , Integer . MAX_VALUE ) ; }
ecarm002/incubator-asterixdb | public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory ( ) { @ Override public IFunctionDescriptor createFunctionDescriptor ( ) { return new StringPositionDescriptor ( ) ; } @ Override public IFunctionTypeInferer createFunctionTypeInferer ( ) { return FunctionTypeInferers . SET_STRING_OFFSET ; } }
jalian-systems/marathonv5 | public static void main ( String [ ] args ) { launch ( args ) ; }
McJty/EFab | private static void rotateFacing ( TileEntity tileEntity ) { IBlockState state = tileEntity . getWorld ( ) . getBlockState ( tileEntity . getPos ( ) ) ; EnumFacing orientation = BaseBlock . getFrontDirection ( ModBlocks . gridBlock . getRotationType ( ) , state ) ; switch ( orientation ) { case NORTH : GlStateManager . rotate ( 180 , 0 , 1 , 0 ) ; break ; case SOUTH : break ; case WEST : GlStateManager . rotate ( 270 , 0 , 1 , 0 ) ; break ; case EAST : GlStateManager . rotate ( 90 , 0 , 1 , 0 ) ; break ; case DOWN : case UP : break ; } }
McJty/EFab | private static void renderHandle ( GridTE te , int x , int y , boolean half ) { ItemStack stackInSlot = te . getStackInSlot ( y * 3 + x ) ; if ( ! stackInSlot . isEmpty ( ) ) { renderItemStackInWorld ( new Vec3d ( x * .3 - .3 , .1 + ( half ? 0.2 : 1 ) , y * .3 - .3 ) , stackInSlot ) ; } }
McJty/EFab | private static void renderItemStackInWorld ( Vec3d offset , ItemStack stack ) { net . minecraft . client . renderer . RenderHelper . enableStandardItemLighting ( ) ; GlStateManager . translate ( offset . x , offset . y , offset . z ) ; renderItemCustom ( stack , 0 , 0.1f ) ; GlStateManager . translate ( - offset . x , - offset . y , - offset . z ) ; }
McJty/EFab | public static void renderItemCustom ( ItemStack is , int rotation , float scale ) { if ( ! is . isEmpty ( ) ) { GlStateManager . pushMatrix ( ) ; GlStateManager . scale ( scale , scale , scale ) ; if ( rotation != 0 ) { GlStateManager . rotate ( rotation , 0F , 1F , 0F ) ; } customRenderItem ( is ) ; GlStateManager . popMatrix ( ) ; } }
McJty/EFab | public static void customRenderItem ( ItemStack is ) { RenderItem renderItem = Minecraft . getMinecraft ( ) . getRenderItem ( ) ; TextureManager textureManager = Minecraft . getMinecraft ( ) . getTextureManager ( ) ; EntityPlayerSP player = Minecraft . getMinecraft ( ) . player ; IBakedModel ibakedmodel = renderItem . getItemModelWithOverrides ( is , player . getEntityWorld ( ) , player ) ; textureManager . bindTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) ; textureManager . getTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) . setBlurMipmap ( false , false ) ; preTransform ( renderItem , is ) ; GlStateManager . enableRescaleNormal ( ) ; GlStateManager . alphaFunc ( 516 , 0.1F ) ; GlStateManager . enableBlend ( ) ; GlStateManager . tryBlendFuncSeparate ( GlStateManager . SourceFactor . SRC_ALPHA , GlStateManager . DestFactor . ONE_MINUS_SRC_ALPHA , GlStateManager . SourceFactor . ONE , GlStateManager . DestFactor . ZERO ) ; GlStateManager . pushMatrix ( ) ; ibakedmodel = net . minecraftforge . client . ForgeHooksClient . handleCameraTransforms ( ibakedmodel , ItemCameraTransforms . TransformType . NONE , false ) ; renderItem . renderItem ( is , ibakedmodel ) ; GlStateManager . cullFace ( GlStateManager . CullFace . BACK ) ; GlStateManager . popMatrix ( ) ; GlStateManager . disableRescaleNormal ( ) ; GlStateManager . disableBlend ( ) ; textureManager . bindTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) ; textureManager . getTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) . restoreLastBlurMipmap ( ) ; }
McJty/EFab | private static void preTransform ( RenderItem renderItem , ItemStack stack ) { IBakedModel ibakedmodel = renderItem . getItemModelMesher ( ) . getItemModel ( stack ) ; Item item = stack . getItem ( ) ; if ( item != null ) { boolean flag = ibakedmodel . isGui3d ( ) ; if ( ! flag ) { GlStateManager . scale ( 2.0F , 2.0F , 2.0F ) ; } GlStateManager . color ( 1.0F , 1.0F , 1.0F , 1.0F ) ; } }
McJty/EFab | public static void register ( ) { ClientRegistry . bindTileEntitySpecialRenderer ( GridTE . class , new GridRenderer ( ) ) ; }
samtingleff/dgrid | public static void main ( String [ ] args ) { System . out . println ( " Hello , ▁ world " ) ; }
facebook/fresco | public static String toString ( @ ImageLoadStatus int imageLoadStatus ) { switch ( imageLoadStatus ) { case ImageLoadStatus . REQUESTED : return " requested " ; case ImageLoadStatus . ORIGIN_AVAILABLE : return " origin _ available " ; case ImageLoadStatus . SUCCESS : return " success " ; case ImageLoadStatus . CANCELED : return " canceled " ; case ImageLoadStatus . INTERMEDIATE_AVAILABLE : return " intermediate _ available " ; case ImageLoadStatus . ERROR : return " error " ; default : return " unknown " ; } }
charlesccychen/beam | private static void checkBigQueryOptions ( String dataset , String table ) { Preconditions . checkArgument ( dataset != null , " Please ▁ specify ▁ - - bigQueryDataset ▁ option ▁ if ▁ you ▁ want ▁ to ▁ publish ▁ to ▁ BigQuery " ) ; Preconditions . checkArgument ( table != null , " Please ▁ specify ▁ - - bigQueryTable ▁ option ▁ if ▁ you ▁ want ▁ to ▁ publish ▁ to ▁ BigQuery " ) ; }
Kokil/opengse | public static MutableWebAppContextParam create ( ) { return new MutableWebAppContextParam ( ) ; }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getSSAVariables ( @ NotNull ControlFlow flow ) { return getSSAVariables ( flow , 0 , flow . getSize ( ) , false ) ; }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getSSAVariables ( @ NotNull ControlFlow flow , int from , int to , boolean reportVarsIfNonInitializingPathExists ) { List < Instruction > instructions = flow . getInstructions ( ) ; Collection < PsiVariable > writtenVariables = getWrittenVariables ( flow , from , to , false ) ; List < PsiVariable > result = new ArrayList < > ( 1 ) ; variables : for ( PsiVariable psiVariable : writtenVariables ) { final List < SSAInstructionState > queue = new ArrayList < > ( ) ; queue . add ( new SSAInstructionState ( 0 , from ) ) ; Set < SSAInstructionState > processedStates = new THashSet < > ( ) ; while ( ! queue . isEmpty ( ) ) { final SSAInstructionState state = queue . remove ( 0 ) ; if ( state . getWriteCount ( ) > 1 ) continue variables ; if ( ! processedStates . contains ( state ) ) { processedStates . add ( state ) ; int i = state . getInstructionIdx ( ) ; if ( i < to ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReturnInstruction ) { int [ ] offsets = ( ( ReturnInstruction ) instruction ) . getPossibleReturnOffsets ( ) ; for ( int offset : offsets ) { queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , Math . min ( offset , to ) ) ) ; } } else if ( instruction instanceof GoToInstruction ) { int nextOffset = ( ( GoToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; } else if ( instruction instanceof ThrowToInstruction ) { int nextOffset = ( ( ThrowToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; } else if ( instruction instanceof ConditionalGoToInstruction ) { int nextOffset = ( ( ConditionalGoToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } else if ( instruction instanceof ConditionalThrowToInstruction ) { int nextOffset = ( ( ConditionalThrowToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } else if ( instruction instanceof WriteVariableInstruction ) { WriteVariableInstruction write = ( WriteVariableInstruction ) instruction ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) + ( write . variable == psiVariable ? 1 : 0 ) , i + 1 ) ) ; } else if ( instruction instanceof ReadVariableInstruction ) { ReadVariableInstruction read = ( ReadVariableInstruction ) instruction ; if ( read . variable == psiVariable && state . getWriteCount ( ) == 0 ) continue variables ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } else { queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } } else if ( ! reportVarsIfNonInitializingPathExists && state . getWriteCount ( ) == 0 ) continue variables ; } } result . add ( psiVariable ) ; } return result ; }
msebire/intellij-community | public static boolean needVariableValueAt ( @ NotNull PsiVariable variable , @ NotNull ControlFlow flow , final int offset ) { InstructionClientVisitor < Boolean > visitor = new InstructionClientVisitor < Boolean > ( ) { final boolean [ ] neededBelow = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void procedureEntered ( int startOffset , int endOffset ) { for ( int i = startOffset ; i < endOffset ; i ++ ) neededBelow [ i ] = false ; } @ Override public void visitReadVariableInstruction ( ReadVariableInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean needed = neededBelow [ nextOffset ] ; if ( instruction . variable . equals ( variable ) ) { needed = true ; } neededBelow [ offset ] |= needed ; } @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean needed = neededBelow [ nextOffset ] ; if ( instruction . variable . equals ( variable ) ) { needed = false ; } neededBelow [ offset ] = needed ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean needed = neededBelow [ nextOffset ] ; neededBelow [ offset ] |= needed ; } @ Override public Boolean getResult ( ) { return neededBelow [ offset ] ; } } ; depthFirstSearch ( flow , visitor , offset , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | @ NotNull public static Collection < PsiVariable > getWrittenVariables ( @ NotNull ControlFlow flow , int start , int end , final boolean ignoreNotReachingWrites ) { Set < PsiVariable > set = new HashSet < > ( ) ; getWrittenVariables ( flow , start , end , ignoreNotReachingWrites , set ) ; return set ; }
msebire/intellij-community | public static void getWrittenVariables ( @ NotNull ControlFlow flow , int start , int end , final boolean ignoreNotReachingWrites , @ NotNull Collection < ? super PsiVariable > set ) { List < Instruction > instructions = flow . getInstructions ( ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof WriteVariableInstruction && ( ! ignoreNotReachingWrites || isInstructionReachable ( flow , end , i ) ) ) { set . add ( ( ( WriteVariableInstruction ) instruction ) . variable ) ; } } }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getUsedVariables ( @ NotNull ControlFlow flow , int start , int end ) { List < PsiVariable > array = new ArrayList < > ( ) ; if ( start < 0 ) return array ; List < Instruction > instructions = flow . getInstructions ( ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { PsiVariable variable = ( ( ReadVariableInstruction ) instruction ) . variable ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } else if ( instruction instanceof WriteVariableInstruction ) { PsiVariable variable = ( ( WriteVariableInstruction ) instruction ) . variable ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } } return array ; }
msebire/intellij-community | public static boolean isVariableUsed ( @ NotNull ControlFlow flow , int start , int end , @ NotNull PsiVariable variable ) { List < Instruction > instructions = flow . getInstructions ( ) ; LOG . assertTrue ( start >= 0 , " flow ▁ start " ) ; LOG . assertTrue ( end <= instructions . size ( ) , " flow ▁ end " ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { if ( ( ( ReadVariableInstruction ) instruction ) . variable == variable ) { return true ; } } else if ( instruction instanceof WriteVariableInstruction ) { if ( ( ( WriteVariableInstruction ) instruction ) . variable == variable ) { return true ; } } } return false ; }
msebire/intellij-community | private static int findSingleReadOffset ( @ NotNull ControlFlow flow , int startOffset , int endOffset , @ NotNull PsiVariable variable ) { List < Instruction > instructions = flow . getInstructions ( ) ; if ( startOffset < 0 || endOffset < 0 || endOffset > instructions . size ( ) ) return - 1 ; int readOffset = - 1 ; for ( int i = startOffset ; i < endOffset ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { if ( ( ( ReadVariableInstruction ) instruction ) . variable == variable ) { if ( readOffset < 0 ) { readOffset = i ; } else { return - 1 ; } } } else if ( instruction instanceof WriteVariableInstruction ) { if ( ( ( WriteVariableInstruction ) instruction ) . variable == variable ) { return - 1 ; } } } return readOffset ; }
msebire/intellij-community | public static PsiReferenceExpression findSingleReadOccurrence ( @ NotNull ControlFlow flow , @ NotNull PsiElement element , @ NotNull PsiVariable variable ) { int readOffset = findSingleReadOffset ( flow , flow . getStartOffset ( element ) , flow . getEndOffset ( element ) , variable ) ; if ( readOffset >= 0 ) { PsiElement readElement = flow . getElement ( readOffset ) ; readElement = PsiTreeUtil . findFirstParent ( readElement , false , e -> e == element || e instanceof PsiReferenceExpression ) ; if ( readElement instanceof PsiReferenceExpression ) { return ( PsiReferenceExpression ) readElement ; } } return null ; }
msebire/intellij-community | public static boolean isVariableReadInFinally ( @ NotNull ControlFlow flow , @ Nullable PsiElement startElement , @ NotNull PsiElement enclosingCodeFragment , @ NotNull PsiVariable variable ) { for ( PsiElement element = startElement ; element != null && element != enclosingCodeFragment ; element = element . getParent ( ) ) { if ( element instanceof PsiCodeBlock ) { final PsiElement parent = element . getParent ( ) ; if ( parent instanceof PsiTryStatement ) { final PsiTryStatement tryStatement = ( PsiTryStatement ) parent ; if ( tryStatement . getTryBlock ( ) == element ) { final PsiCodeBlock finallyBlock = tryStatement . getFinallyBlock ( ) ; if ( finallyBlock != null ) { final List < Instruction > instructions = flow . getInstructions ( ) ; final int startOffset = flow . getStartOffset ( finallyBlock ) ; final int endOffset = flow . getEndOffset ( finallyBlock ) ; LOG . assertTrue ( startOffset >= 0 , " flow ▁ start " ) ; LOG . assertTrue ( endOffset <= instructions . size ( ) , " flow ▁ end " ) ; for ( int i = startOffset ; i < endOffset ; i ++ ) { final Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction && ( ( ReadVariableInstruction ) instruction ) . variable == variable ) { return true ; } } } } } } } return false ; }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getInputVariables ( @ NotNull ControlFlow flow , int start , int end ) { List < PsiVariable > usedVariables = getUsedVariables ( flow , start , end ) ; List < PsiVariable > array = new ArrayList < > ( usedVariables . size ( ) ) ; for ( PsiVariable variable : usedVariables ) { if ( needVariableValueAt ( variable , flow , start ) ) { array . add ( variable ) ; } } return array ; }
msebire/intellij-community | @ NotNull public static PsiVariable [ ] getOutputVariables ( @ NotNull ControlFlow flow , int start , int end , @ NotNull int [ ] exitPoints ) { Collection < PsiVariable > writtenVariables = getWrittenVariables ( flow , start , end , false ) ; List < PsiVariable > array = new ArrayList < > ( ) ; for ( PsiVariable variable : writtenVariables ) { for ( int exitPoint : exitPoints ) { if ( needVariableValueAt ( variable , flow , exitPoint ) ) { array . add ( variable ) ; } } } PsiVariable [ ] outputVariables = array . toArray ( new PsiVariable [ 0 ] ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " output ▁ variables : " ) ; for ( PsiVariable variable : outputVariables ) { LOG . debug ( " ▁ ▁ " + variable ) ; } } return outputVariables ; }
msebire/intellij-community | @ NotNull public static Collection < PsiStatement > findExitPointsAndStatements ( @ NotNull ControlFlow flow , final int start , final int end , @ NotNull IntArrayList exitPoints , @ NotNull Class < ? extends PsiStatement > ... classesFilter ) { if ( end == start ) { exitPoints . add ( end ) ; return Collections . emptyList ( ) ; } final Collection < PsiStatement > exitStatements = new THashSet < > ( ) ; InstructionClientVisitor visitor = new InstructionClientVisitor ( ) { @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { processGotoStatement ( exitStatements , findStatement ( flow , offset ) , classesFilter ) ; } @ Override public void visitBranchingInstruction ( BranchingInstruction instruction , int offset , int nextOffset ) { processGoto ( flow , start , end , exitPoints , exitStatements , instruction , findStatement ( flow , offset ) , classesFilter ) ; } @ Override public void visitReturnInstruction ( ReturnInstruction instruction , int offset , int nextOffset ) { } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { visitInstruction ( instruction , offset , nextOffset ) ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( offset >= end - 1 ) { int exitOffset = end ; exitOffset = promoteThroughGotoChain ( flow , exitOffset ) ; if ( ! exitPoints . contains ( exitOffset ) ) { exitPoints . add ( exitOffset ) ; } } } @ Override public Object getResult ( ) { return null ; } } ; depthFirstSearch ( flow , visitor , start , end ) ; return exitStatements ; }
msebire/intellij-community | private static void processGoto ( @ NotNull ControlFlow flow , int start , int end , @ NotNull IntArrayList exitPoints , @ NotNull Collection < ? super PsiStatement > exitStatements , @ NotNull BranchingInstruction instruction , final PsiStatement statement , @ NotNull Class ... classesFilter ) { if ( statement == null ) return ; int gotoOffset = instruction . offset ; if ( start > gotoOffset || gotoOffset >= end || isElementOfClass ( statement , classesFilter ) ) { gotoOffset = promoteThroughGotoChain ( flow , gotoOffset ) ; if ( gotoOffset > 0 && ( gotoOffset >= end || gotoOffset < start ) && ! exitPoints . contains ( gotoOffset ) ) { exitPoints . add ( gotoOffset ) ; } if ( gotoOffset >= end || gotoOffset < start ) { processGotoStatement ( exitStatements , statement , classesFilter ) ; } else { boolean isReturn = instruction instanceof GoToInstruction && ( ( GoToInstruction ) instruction ) . isReturn ; final Instruction gotoInstruction = flow . getInstructions ( ) . get ( gotoOffset ) ; isReturn |= gotoInstruction instanceof GoToInstruction && ( ( GoToInstruction ) gotoInstruction ) . isReturn ; if ( isReturn ) { processGotoStatement ( exitStatements , statement , classesFilter ) ; } } } }
msebire/intellij-community | private static void processGotoStatement ( @ NotNull Collection < ? super PsiStatement > exitStatements , PsiStatement statement , @ NotNull Class ... classesFilter ) { if ( statement != null && isElementOfClass ( statement , classesFilter ) ) { exitStatements . add ( statement ) ; } }
msebire/intellij-community | private static boolean isElementOfClass ( @ NotNull PsiElement element , @ NotNull Class ... classesFilter ) { for ( Class aClassesFilter : classesFilter ) { if ( ReflectionUtil . isAssignable ( aClassesFilter , element . getClass ( ) ) ) { return true ; } } return false ; }
msebire/intellij-community | private static int promoteThroughGotoChain ( @ NotNull ControlFlow flow , int offset ) { List < Instruction > instructions = flow . getInstructions ( ) ; while ( true ) { if ( offset >= instructions . size ( ) ) break ; Instruction instruction = instructions . get ( offset ) ; if ( ! ( instruction instanceof GoToInstruction ) || ( ( GoToInstruction ) instruction ) . isReturn ) break ; offset = ( ( BranchingInstruction ) instruction ) . offset ; } return offset ; }
msebire/intellij-community | private static PsiStatement findStatement ( @ NotNull ControlFlow flow , int offset ) { PsiElement element = flow . getElement ( offset ) ; return PsiTreeUtil . getParentOfType ( element , PsiStatement . class , false ) ; }
msebire/intellij-community | public static boolean hasObservableThrowExitPoints ( @ NotNull final ControlFlow flow , final int flowStart , final int flowEnd , @ NotNull PsiElement [ ] elements , @ NotNull PsiElement enclosingCodeFragment ) { final List < Instruction > instructions = flow . getInstructions ( ) ; class Worker { @ NotNull private Map < PsiVariable , IntArrayList > getWritesOffsets ( ) { final Map < PsiVariable , IntArrayList > writeOffsets = new THashMap < > ( ) ; for ( int i = flowStart ; i < flowEnd ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof WriteVariableInstruction ) { final PsiVariable variable = ( ( WriteVariableInstruction ) instruction ) . variable ; if ( variable instanceof PsiLocalVariable || variable instanceof PsiParameter ) { IntArrayList offsets = writeOffsets . get ( variable ) ; if ( offsets == null ) writeOffsets . put ( variable , offsets = new IntArrayList ( ) ) ; offsets . add ( i ) ; } } } LOG . debug ( " writeOffsets : " , writeOffsets ) ; return writeOffsets ; } @ NotNull private Map < PsiVariable , IntArrayList > getVisibleReadsOffsets ( @ NotNull Map < PsiVariable , IntArrayList > writeOffsets , @ NotNull PsiCodeBlock tryBlock ) { final Map < PsiVariable , IntArrayList > visibleReadOffsets = new THashMap < > ( ) ; for ( PsiVariable variable : writeOffsets . keySet ( ) ) { if ( ! PsiTreeUtil . isAncestor ( tryBlock , variable , true ) ) { visibleReadOffsets . put ( variable , new IntArrayList ( ) ) ; } } if ( visibleReadOffsets . isEmpty ( ) ) return visibleReadOffsets ; for ( int i = 0 ; i < instructions . size ( ) ; i ++ ) { final Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { final PsiVariable variable = ( ( ReadVariableInstruction ) instruction ) . variable ; final IntArrayList readOffsets = visibleReadOffsets . get ( variable ) ; if ( readOffsets != null ) { readOffsets . add ( i ) ; } } } LOG . debug ( " visibleReadOffsets : " , visibleReadOffsets ) ; return visibleReadOffsets ; } @ NotNull private Map < PsiVariable , Set < PsiElement > > getReachableAfterWrite ( @ NotNull Map < PsiVariable , IntArrayList > writeOffsets , @ NotNull Map < PsiVariable , IntArrayList > visibleReadOffsets ) { final Map < PsiVariable , Set < PsiElement > > afterWrite = new THashMap < > ( ) ; for ( PsiVariable variable : visibleReadOffsets . keySet ( ) ) { final Function < Integer , BitSet > calculator = getReachableInstructionsCalculator ( ) ; final BitSet collectedOffsets = new BitSet ( flowEnd ) ; for ( final int writeOffset : writeOffsets . get ( variable ) . toArray ( ) ) { LOG . assertTrue ( writeOffset >= flowStart , " writeOffset " ) ; final BitSet reachableOffsets = calculator . fun ( writeOffset ) ; collectedOffsets . or ( reachableOffsets ) ; } Set < PsiElement > throwSources = afterWrite . get ( variable ) ; if ( throwSources == null ) afterWrite . put ( variable , throwSources = new THashSet < > ( ) ) ; for ( int i = flowStart ; i < flowEnd ; i ++ ) { if ( collectedOffsets . get ( i ) ) { throwSources . add ( flow . getElement ( i ) ) ; } } final List < PsiElement > subordinates = new ArrayList < > ( ) ; for ( PsiElement element : throwSources ) { if ( throwSources . contains ( element . getParent ( ) ) ) { subordinates . add ( element ) ; } } throwSources . removeAll ( subordinates ) ; } LOG . debug ( " afterWrite : " , afterWrite ) ; return afterWrite ; } @ NotNull private IntArrayList getCatchOrFinallyOffsets ( @ NotNull List < ? extends PsiTryStatement > tryStatements , @ NotNull List < ? extends PsiClassType > thrownExceptions ) { final IntArrayList catchOrFinallyOffsets = new IntArrayList ( ) ; for ( PsiTryStatement tryStatement : tryStatements ) { final PsiCodeBlock finallyBlock = tryStatement . getFinallyBlock ( ) ; if ( finallyBlock != null ) { int offset = flow . getStartOffset ( finallyBlock ) ; if ( offset >= 0 ) { catchOrFinallyOffsets . add ( offset - 2 ) ; } } for ( PsiCatchSection catchSection : tryStatement . getCatchSections ( ) ) { final PsiCodeBlock catchBlock = catchSection . getCatchBlock ( ) ; final PsiParameter parameter = catchSection . getParameter ( ) ; if ( catchBlock != null && parameter != null ) { for ( PsiClassType throwType : thrownExceptions ) { if ( isCaughtExceptionType ( throwType , parameter . getType ( ) ) ) { int offset = flow . getStartOffset ( catchBlock ) ; if ( offset >= 0 ) { catchOrFinallyOffsets . add ( offset - 1 ) ; } } } } } } return catchOrFinallyOffsets ; } private boolean isAnyReadOffsetReachableFrom ( @ Nullable IntArrayList readOffsets , @ NotNull IntArrayList fromOffsets ) { if ( readOffsets != null && ! readOffsets . isEmpty ( ) ) { final int [ ] readOffsetsArray = readOffsets . toArray ( ) ; for ( int j = 0 ; j < fromOffsets . size ( ) ; j ++ ) { int fromOffset = fromOffsets . get ( j ) ; if ( areInstructionsReachable ( flow , readOffsetsArray , fromOffset ) ) { LOG . debug ( " reachableFromOffset : " , fromOffset ) ; return true ; } } } return false ; } @ NotNull private Function < Integer , BitSet > getReachableInstructionsCalculator ( ) { final ControlFlowGraph graph = new ControlFlowGraph ( flow . getSize ( ) ) { @ Override void addArc ( int offset , int nextOffset ) { nextOffset = promoteThroughGotoChain ( flow , nextOffset ) ; if ( nextOffset >= flowStart && nextOffset < flowEnd ) { super . addArc ( offset , nextOffset ) ; } } } ; graph . buildFrom ( flow ) ; return startOffset -> { BitSet visitedOffsets = new BitSet ( flowEnd ) ; graph . depthFirstSearch ( startOffset , visitedOffsets ) ; return visitedOffsets ; } ; } } final Worker worker = new Worker ( ) ; final Map < PsiVariable , IntArrayList > writeOffsets = worker . getWritesOffsets ( ) ; if ( writeOffsets . isEmpty ( ) ) return false ; final PsiElement commonParent = elements . length != 1 ? PsiTreeUtil . findCommonParent ( elements ) : elements [ 0 ] . getParent ( ) ; final List < PsiTryStatement > tryStatements = collectTryStatementStack ( commonParent , enclosingCodeFragment ) ; if ( tryStatements . isEmpty ( ) ) return false ; final PsiCodeBlock tryBlock = tryStatements . get ( 0 ) . getTryBlock ( ) ; if ( tryBlock == null ) return false ; final Map < PsiVariable , IntArrayList > visibleReadOffsets = worker . getVisibleReadsOffsets ( writeOffsets , tryBlock ) ; if ( visibleReadOffsets . isEmpty ( ) ) return false ; final Map < PsiVariable , Set < PsiElement > > afterWrite = worker . getReachableAfterWrite ( writeOffsets , visibleReadOffsets ) ; if ( afterWrite . isEmpty ( ) ) return false ; for ( Map . Entry < PsiVariable , Set < PsiElement > > entry : afterWrite . entrySet ( ) ) { final PsiVariable variable = entry . getKey ( ) ; final PsiElement [ ] psiElements = entry . getValue ( ) . toArray ( PsiElement . EMPTY_ARRAY ) ; final List < PsiClassType > thrownExceptions = ExceptionUtil . getThrownExceptions ( psiElements ) ; if ( ! thrownExceptions . isEmpty ( ) ) { final IntArrayList catchOrFinallyOffsets = worker . getCatchOrFinallyOffsets ( tryStatements , thrownExceptions ) ; if ( worker . isAnyReadOffsetReachableFrom ( visibleReadOffsets . get ( variable ) , catchOrFinallyOffsets ) ) { return true ; } } } return false ; }
msebire/intellij-community | @ Nullable private static PsiTryStatement getEnclosingTryStatementHavingCatchOrFinally ( @ Nullable PsiElement startElement , @ NotNull PsiElement enclosingCodeFragment ) { for ( PsiElement element = startElement ; element != null && element != enclosingCodeFragment ; element = element . getParent ( ) ) { if ( element instanceof PsiCodeBlock ) { final PsiElement parent = element . getParent ( ) ; if ( parent instanceof PsiTryStatement ) { final PsiTryStatement tryStatement = ( PsiTryStatement ) parent ; if ( tryStatement . getTryBlock ( ) == element && ( tryStatement . getFinallyBlock ( ) != null || tryStatement . getCatchBlocks ( ) . length != 0 ) ) { return tryStatement ; } } } } return null ; }
msebire/intellij-community | @ NotNull private static List < PsiTryStatement > collectTryStatementStack ( @ Nullable PsiElement startElement , @ NotNull PsiElement enclosingCodeFragment ) { final List < PsiTryStatement > stack = new ArrayList < > ( ) ; for ( PsiTryStatement tryStatement = getEnclosingTryStatementHavingCatchOrFinally ( startElement , enclosingCodeFragment ) ; tryStatement != null ; tryStatement = getEnclosingTryStatementHavingCatchOrFinally ( tryStatement , enclosingCodeFragment ) ) { stack . add ( tryStatement ) ; } return stack ; }
msebire/intellij-community | @ NotNull public static PsiElement findCodeFragment ( @ NotNull PsiElement element ) { PsiElement codeFragment = element ; PsiElement parent = codeFragment . getParent ( ) ; while ( parent != null ) { if ( parent instanceof PsiDirectory || parent instanceof PsiMethod || parent instanceof PsiField || parent instanceof PsiClassInitializer || parent instanceof DummyHolder || parent instanceof PsiLambdaExpression ) { break ; } codeFragment = parent ; parent = parent . getParent ( ) ; } return codeFragment ; }
msebire/intellij-community | private static boolean checkReferenceExpressionScope ( @ NotNull PsiReferenceExpression ref , @ NotNull PsiElement targetClassMember ) { final JavaResolveResult resolveResult = ref . advancedResolve ( false ) ; final PsiElement def = resolveResult . getElement ( ) ; if ( def != null ) { PsiElement parent = def . getParent ( ) ; PsiElement commonParent = parent == null ? null : PsiTreeUtil . findCommonParent ( parent , targetClassMember ) ; if ( commonParent == null ) { parent = resolveResult . getCurrentFileResolveScope ( ) ; } if ( parent instanceof PsiClass ) { final PsiClass clss = ( PsiClass ) parent ; if ( PsiTreeUtil . isAncestor ( targetClassMember , clss , false ) ) return false ; PsiClass containingClass = PsiTreeUtil . getParentOfType ( ref , PsiClass . class ) ; while ( containingClass != null ) { if ( containingClass . isInheritor ( clss , true ) && PsiTreeUtil . isAncestor ( targetClassMember , containingClass , false ) ) { return false ; } containingClass = containingClass . getContainingClass ( ) ; } } } return true ; }
msebire/intellij-community | public static boolean collectOuterLocals ( @ NotNull List < ? super PsiVariable > array , @ NotNull PsiElement scope , @ NotNull PsiElement member , @ NotNull PsiElement targetClassMember ) { if ( scope instanceof PsiMethodCallExpression ) { final PsiMethodCallExpression call = ( PsiMethodCallExpression ) scope ; if ( ! checkReferenceExpressionScope ( call . getMethodExpression ( ) , targetClassMember ) ) { return false ; } } else if ( scope instanceof PsiReferenceExpression ) { if ( ! checkReferenceExpressionScope ( ( PsiReferenceExpression ) scope , targetClassMember ) ) { return false ; } } if ( scope instanceof PsiJavaCodeReferenceElement ) { final PsiJavaCodeReferenceElement ref = ( PsiJavaCodeReferenceElement ) scope ; final JavaResolveResult result = ref . advancedResolve ( false ) ; final PsiElement refElement = result . getElement ( ) ; if ( refElement != null ) { PsiElement parent = refElement . getParent ( ) ; parent = parent != null ? PsiTreeUtil . findCommonParent ( parent , member ) : null ; if ( parent == null ) { parent = result . getCurrentFileResolveScope ( ) ; } if ( parent != null && ! member . equals ( parent ) ) { parent = PsiTreeUtil . findCommonParent ( parent , targetClassMember ) ; if ( targetClassMember . equals ( parent ) ) { if ( refElement instanceof PsiVariable ) { if ( scope instanceof PsiReferenceExpression && PsiUtil . isAccessedForWriting ( ( PsiReferenceExpression ) scope ) ) { return false ; } PsiVariable variable = ( PsiVariable ) refElement ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } else { return false ; } } } } } else if ( scope instanceof PsiThisExpression ) { PsiJavaCodeReferenceElement qualifier = ( ( PsiThisExpression ) scope ) . getQualifier ( ) ; if ( qualifier == null ) { return false ; } } else if ( scope instanceof PsiSuperExpression ) { if ( ( ( PsiSuperExpression ) scope ) . getQualifier ( ) == null ) { return false ; } } for ( PsiElement child = scope . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { if ( ! collectOuterLocals ( array , child , member , targetClassMember ) ) return false ; } return true ; }
msebire/intellij-community | public static boolean returnPresent ( @ NotNull ControlFlow flow ) { InstructionClientVisitor < Boolean > visitor = new ReturnPresentClientVisitor ( flow ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean processReturns ( @ NotNull ControlFlow flow , @ NotNull ReturnStatementsVisitor afterVisitor ) throws IncorrectOperationException { final ConvertReturnClientVisitor instructionsVisitor = new ConvertReturnClientVisitor ( flow , afterVisitor ) ; depthFirstSearch ( flow , instructionsVisitor ) ; instructionsVisitor . afterProcessing ( ) ; return instructionsVisitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean returnPresentBetween ( @ NotNull ControlFlow flow , final int startOffset , final int endOffset ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] isNormalCompletion = new boolean [ flow . getSize ( ) + 1 ] ; MyVisitor ( ) { int i ; final int length = flow . getSize ( ) ; for ( i = 0 ; i < startOffset ; i ++ ) { isNormalCompletion [ i ] = true ; } for ( i = endOffset ; i <= length ; i ++ ) { isNormalCompletion [ i ] = true ; } } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; int throwToOffset = instruction . offset ; boolean isNormal ; if ( throwToOffset == nextOffset ) { if ( throwToOffset <= endOffset ) { isNormal = ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] ; } else { return ; } } else { isNormal = isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; } isNormalCompletion [ offset ] |= isNormal ; } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset <= endOffset ) { boolean isNormal = ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; } } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset > endOffset && nextOffset != offset + 1 ) { return ; } boolean isNormal = isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; } @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; boolean isRethrowFromFinally = instruction instanceof ReturnInstruction && ( ( ReturnInstruction ) instruction ) . isRethrowFromFinally ( ) ; boolean isNormal = ! instruction . isReturn && isNormalCompletion [ nextOffset ] && ! isRethrowFromFinally ; isNormalCompletion [ offset ] |= isNormal ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; final boolean isNormal = isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; } @ Override @ NotNull public Boolean getResult ( ) { return ! isNormalCompletion [ startOffset ] ; } } final MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , endOffset ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean canCompleteNormally ( @ NotNull ControlFlow flow , final int startOffset , final int endOffset ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] canCompleteNormally = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visitConditionalGoToInstruction ( ConditionalGoToInstruction instruction , int offset , int nextOffset ) { checkInstruction ( offset , nextOffset , false ) ; } @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { checkInstruction ( offset , nextOffset , instruction . isReturn ) ; } private void checkInstruction ( int offset , int nextOffset , boolean isReturn ) { if ( offset > endOffset ) return ; if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean isNormal = nextOffset <= endOffset && ! isReturn && ( nextOffset == endOffset || canCompleteNormally [ nextOffset ] ) ; if ( isNormal && nextOffset == endOffset ) { PsiElement element = flow . getElement ( offset ) ; if ( element instanceof PsiBreakStatement ) { PsiStatement exitedStatement = ( ( PsiBreakStatement ) element ) . findExitedStatement ( ) ; if ( exitedStatement == null || flow . getStartOffset ( exitedStatement ) < startOffset ) { isNormal = false ; } } else if ( element instanceof PsiContinueStatement ) { PsiStatement continuedStatement = ( ( PsiContinueStatement ) element ) . findContinuedStatement ( ) ; if ( continuedStatement == null || flow . getStartOffset ( continuedStatement ) < startOffset ) { isNormal = false ; } } } canCompleteNormally [ offset ] |= isNormal ; } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; int throwToOffset = instruction . offset ; boolean isNormal ; if ( throwToOffset == nextOffset ) { isNormal = throwToOffset <= endOffset && ! isLeaf ( nextOffset ) && canCompleteNormally [ nextOffset ] ; } else { isNormal = canCompleteNormally [ nextOffset ] ; } canCompleteNormally [ offset ] |= isNormal ; } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset <= endOffset ) { boolean isNormal = ! isLeaf ( nextOffset ) && canCompleteNormally [ nextOffset ] ; canCompleteNormally [ offset ] |= isNormal ; } } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset > endOffset && nextOffset != offset + 1 ) { return ; } boolean isNormal = canCompleteNormally [ nextOffset ] ; canCompleteNormally [ offset ] |= isNormal ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { checkInstruction ( offset , nextOffset , false ) ; } @ Override @ NotNull public Boolean getResult ( ) { return canCompleteNormally [ startOffset ] ; } } final MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , endOffset ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static PsiElement getUnreachableStatement ( @ NotNull ControlFlow flow ) { final InstructionClientVisitor < PsiElement > visitor = new UnreachableStatementClientVisitor ( flow ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | @ Nullable private static PsiElement getUnreachableExpressionParent ( @ Nullable PsiElement element ) { if ( element instanceof PsiExpression ) { final PsiElement expression = PsiTreeUtil . findFirstParent ( element , e -> ! ( e . getParent ( ) instanceof PsiParenthesizedExpression ) ) ; if ( expression != null ) { final PsiElement parent = expression . getParent ( ) ; if ( parent instanceof PsiExpressionStatement ) { return getUnreachableStatementParent ( parent ) ; } if ( parent instanceof PsiIfStatement && ( ( PsiIfStatement ) parent ) . getCondition ( ) == expression || parent instanceof PsiSwitchBlock && ( ( PsiSwitchBlock ) parent ) . getExpression ( ) == expression || parent instanceof PsiWhileStatement && ( ( PsiWhileStatement ) parent ) . getCondition ( ) == expression || parent instanceof PsiForeachStatement && ( ( PsiForeachStatement ) parent ) . getIteratedValue ( ) == expression ) { return parent ; } } } return null ; }
msebire/intellij-community | @ Nullable private static PsiElement getEnclosingUnreachableStatement ( @ NotNull PsiElement statement ) { final PsiElement parent = statement . getParent ( ) ; if ( parent instanceof PsiDoWhileStatement && ( ( PsiDoWhileStatement ) parent ) . getBody ( ) == statement ) { return parent ; } if ( parent instanceof PsiCodeBlock && PsiTreeUtil . getNextSiblingOfType ( parent . getFirstChild ( ) , PsiStatement . class ) == statement ) { final PsiBlockStatement blockStatement = ObjectUtils . tryCast ( parent . getParent ( ) , PsiBlockStatement . class ) ; if ( blockStatement != null ) { final PsiElement blockParent = blockStatement . getParent ( ) ; if ( blockParent instanceof PsiDoWhileStatement && ( ( PsiDoWhileStatement ) blockParent ) . getBody ( ) == blockStatement ) { return blockParent ; } } } return getUnreachableStatementParent ( statement ) ; }
msebire/intellij-community | @ Nullable private static PsiElement getUnreachableStatementParent ( @ NotNull PsiElement statement ) { final PsiElement parent = statement . getParent ( ) ; if ( parent instanceof PsiForStatement && ( ( PsiForStatement ) parent ) . getInitialization ( ) == statement ) { return parent ; } return null ; }
msebire/intellij-community | private static PsiReferenceExpression getEnclosingReferenceExpression ( @ NotNull PsiElement element , @ NotNull PsiVariable variable ) { final PsiReferenceExpression reference = findReferenceTo ( element , variable ) ; if ( reference != null ) return reference ; while ( element != null ) { if ( element instanceof PsiReferenceExpression ) { return ( PsiReferenceExpression ) element ; } if ( element instanceof PsiMethod || element instanceof PsiClass ) { return null ; } element = element . getParent ( ) ; } return null ; }
msebire/intellij-community | private static PsiReferenceExpression findReferenceTo ( @ NotNull PsiElement element , @ NotNull PsiVariable variable ) { if ( element instanceof PsiReferenceExpression && ExpressionUtil . isEffectivelyUnqualified ( ( PsiReferenceExpression ) element ) && ( ( PsiReferenceExpression ) element ) . resolve ( ) == variable ) { return ( PsiReferenceExpression ) element ; } final PsiElement [ ] children = element . getChildren ( ) ; for ( PsiElement child : children ) { final PsiReferenceExpression reference = findReferenceTo ( child , variable ) ; if ( reference != null ) return reference ; } return null ; }
msebire/intellij-community | public static boolean isDominator ( ControlFlow flow , int maybeDominator , int target ) { class MyVisitor extends InstructionClientVisitor < Boolean > { final BitSet myReachedWithoutDominator = new BitSet ( ) ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { super . visitInstruction ( instruction , offset , nextOffset ) ; if ( nextOffset != maybeDominator && ( target == nextOffset || myReachedWithoutDominator . get ( nextOffset ) ) ) { myReachedWithoutDominator . set ( offset ) ; } } @ Override public Boolean getResult ( ) { return myReachedWithoutDominator . get ( 0 ) ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , 0 , target ) ; return ! visitor . getResult ( ) ; }
msebire/intellij-community | public static boolean isVariableDefinitelyAssigned ( @ NotNull final PsiVariable variable , @ NotNull final ControlFlow flow ) { final int variableDeclarationOffset = flow . getStartOffset ( variable . getParent ( ) ) ; int offset = variableDeclarationOffset > - 1 ? variableDeclarationOffset : 0 ; boolean [ ] unassignedOffsets = getVariablePossiblyUnassignedOffsets ( variable , flow ) ; return ! unassignedOffsets [ offset ] ; }
msebire/intellij-community | public static boolean [ ] getVariablePossiblyUnassignedOffsets ( @ NotNull PsiVariable variable , @ NotNull ControlFlow flow ) { class MyVisitor extends InstructionClientVisitor < boolean [ ] > { private final boolean [ ] maybeUnassigned = new boolean [ flow . getSize ( ) + 1 ] ; { maybeUnassigned [ maybeUnassigned . length - 1 ] = true ; } @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { if ( instruction . variable == variable ) { maybeUnassigned [ offset ] = false ; } else { visitInstruction ( instruction , offset , nextOffset ) ; } } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = offset == flow . getSize ( ) - 1 || ! isLeaf ( nextOffset ) && maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { visitInstruction ( instruction , offset , nextOffset ) ; for ( int i = instruction . procBegin ; i < instruction . procEnd + 3 ; i ++ ) { maybeUnassigned [ i ] = false ; } } @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { if ( instruction . isReturn && variable instanceof PsiLocalVariable ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = ! isLeaf ( nextOffset ) && maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } else { super . visitGoToInstruction ( instruction , offset , nextOffset ) ; } } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = ! isLeaf ( nextOffset ) && maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = isLeaf ( nextOffset ) || maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } @ Override @ NotNull public boolean [ ] getResult ( ) { return maybeUnassigned ; } } if ( flow . getSize ( ) == 0 ) return new boolean [ ] { true } ; MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | public static boolean isVariableDefinitelyNotAssigned ( @ NotNull PsiVariable variable , @ NotNull ControlFlow flow ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] maybeAssigned = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean assigned = instruction . variable == variable || maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean assigned = ! isLeaf ( nextOffset ) && maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; int throwToOffset = instruction . offset ; boolean assigned = throwToOffset == nextOffset ? ! isLeaf ( nextOffset ) && maybeAssigned [ nextOffset ] : maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean assigned = maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override @ NotNull public Boolean getResult ( ) { return ! maybeAssigned [ 0 ] ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean isValueUsedWithoutVisitingStop ( @ NotNull ControlFlow flow , final int start , final int stop , @ NotNull PsiVariable variable ) { if ( start == stop ) return false ; class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] maybeReferenced = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( offset == stop ) { maybeReferenced [ offset ] = false ; return ; } if ( instruction instanceof WriteVariableInstruction && ( ( WriteVariableInstruction ) instruction ) . variable == variable ) { maybeReferenced [ offset ] = false ; return ; } if ( maybeReferenced [ offset ] ) return ; if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean nextState = maybeReferenced [ nextOffset ] ; maybeReferenced [ offset ] = nextState || instruction instanceof ReadVariableInstruction && ( ( ReadVariableInstruction ) instruction ) . variable == variable ; } @ Override @ NotNull public Boolean getResult ( ) { return maybeReferenced [ start ] ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , start , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean isVariableAccess ( @ NotNull ControlFlow flow , int offset , @ NotNull PsiVariable variable ) { Instruction instruction = flow . getInstructions ( ) . get ( offset ) ; return instruction instanceof ReadVariableInstruction && ( ( ReadVariableInstruction ) instruction ) . variable == variable || instruction instanceof WriteVariableInstruction && ( ( WriteVariableInstruction ) instruction ) . variable == variable ; }
msebire/intellij-community | @ NotNull public static List < ControlFlowEdge > getEdges ( @ NotNull ControlFlow flow , int start ) { final List < ControlFlowEdge > list = new ArrayList < > ( ) ; depthFirstSearch ( flow , new InstructionClientVisitor < Void > ( ) { @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { list . add ( new ControlFlowEdge ( offset , nextOffset ) ) ; } @ Override public Void getResult ( ) { return null ; } } , start , flow . getSize ( ) ) ; return list ; }
msebire/intellij-community | public static int getMinDefinitelyReachedOffset ( @ NotNull ControlFlow flow , final int sourceOffset , @ NotNull List < ? extends PsiElement > references ) { class MyVisitor extends InstructionClientVisitor < Integer > { private final TIntHashSet [ ] exitPoints = new TIntHashSet [ flow . getSize ( ) ] ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( exitPoints [ offset ] == null ) { exitPoints [ offset ] = new TIntHashSet ( ) ; } if ( isLeaf ( nextOffset ) ) { exitPoints [ offset ] . add ( offset ) ; } else if ( exitPoints [ nextOffset ] != null ) { exitPoints [ offset ] . addAll ( exitPoints [ nextOffset ] . toArray ( ) ) ; } } @ Override @ NotNull public Integer getResult ( ) { int minOffset = flow . getSize ( ) ; int maxExitPoints = 0 ; nextOffset : for ( int i = sourceOffset ; i < exitPoints . length ; i ++ ) { TIntHashSet exitPointSet = exitPoints [ i ] ; final int size = exitPointSet == null ? 0 : exitPointSet . size ( ) ; if ( size > maxExitPoints ) { for ( PsiElement element : references ) { final PsiElement statement = PsiUtil . getEnclosingStatement ( element ) ; if ( statement == null ) continue ; final int endOffset = flow . getEndOffset ( statement ) ; if ( endOffset == - 1 ) continue ; if ( i != endOffset && ! isInstructionReachable ( flow , i , endOffset ) ) continue nextOffset ; } minOffset = i ; maxExitPoints = size ; } } return minOffset ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) . intValue ( ) ; }
msebire/intellij-community | private static int findUnprocessed ( int startOffset , int endOffset , @ NotNull InstructionClientVisitor < ? > visitor ) { for ( int i = startOffset ; i < endOffset ; i ++ ) { if ( ! visitor . processedInstructions [ i ] ) { return i ; } } return endOffset ; }
msebire/intellij-community | private static void depthFirstSearch ( @ NotNull ControlFlow flow , @ NotNull InstructionClientVisitor visitor ) { depthFirstSearch ( flow , visitor , 0 , flow . getSize ( ) ) ; }
msebire/intellij-community | private static void depthFirstSearch ( @ NotNull ControlFlow flow , @ NotNull InstructionClientVisitor visitor , int startOffset , int endOffset ) { visitor . processedInstructions = new boolean [ endOffset ] ; internalDepthFirstSearch ( flow . getInstructions ( ) , visitor , startOffset , endOffset ) ; }
msebire/intellij-community | private static void internalDepthFirstSearch ( @ NotNull List < ? extends Instruction > instructions , @ NotNull InstructionClientVisitor clientVisitor , int startOffset , int endOffset ) { final WalkThroughStack walkThroughStack = new WalkThroughStack ( instructions . size ( ) / 2 ) ; walkThroughStack . push ( startOffset ) ; synchronized ( instructions ) { final IntArrayList currentProcedureReturnOffsets = new IntArrayList ( ) ; ControlFlowInstructionVisitor getNextOffsetVisitor = new ControlFlowInstructionVisitor ( ) { @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { instruction . execute ( offset + 1 ) ; int newOffset = instruction . offset ; int i ; for ( i = instruction . procBegin ; i < clientVisitor . processedInstructions . length && ( i < instruction . procEnd || i < instructions . size ( ) && instructions . get ( i ) instanceof ReturnInstruction ) ; i ++ ) { clientVisitor . processedInstructions [ i ] = false ; } clientVisitor . procedureEntered ( instruction . procBegin , i ) ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; currentProcedureReturnOffsets . add ( offset + 1 ) ; } @ Override public void visitReturnInstruction ( ReturnInstruction instruction , int offset , int nextOffset ) { int newOffset = instruction . execute ( false ) ; if ( newOffset != - 1 ) { walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; } } @ Override public void visitBranchingInstruction ( BranchingInstruction instruction , int offset , int nextOffset ) { int newOffset = instruction . offset ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; } @ Override public void visitConditionalBranchingInstruction ( ConditionalBranchingInstruction instruction , int offset , int nextOffset ) { int newOffset = instruction . offset ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( offset , offset + 1 ) ; walkThroughStack . push ( newOffset ) ; walkThroughStack . push ( offset + 1 ) ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { int newOffset = offset + 1 ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; } } ; while ( ! walkThroughStack . isEmpty ( ) ) { final int offset = walkThroughStack . peekOldOffset ( ) ; final int newOffset = walkThroughStack . popNewOffset ( ) ; if ( offset >= endOffset ) { continue ; } Instruction instruction = instructions . get ( offset ) ; if ( clientVisitor . processedInstructions [ offset ] ) { if ( newOffset != - 1 ) { instruction . accept ( clientVisitor , offset , newOffset ) ; } if ( ! currentProcedureReturnOffsets . isEmpty ( ) && currentProcedureReturnOffsets . get ( currentProcedureReturnOffsets . size ( ) - 1 ) - 1 == offset ) { currentProcedureReturnOffsets . remove ( currentProcedureReturnOffsets . size ( ) - 1 ) ; } continue ; } if ( ! currentProcedureReturnOffsets . isEmpty ( ) ) { int returnOffset = currentProcedureReturnOffsets . get ( currentProcedureReturnOffsets . size ( ) - 1 ) ; CallInstruction callInstruction = ( CallInstruction ) instructions . get ( returnOffset - 1 ) ; synchronized ( callInstruction . stack ) { if ( callInstruction . procBegin <= offset && offset < callInstruction . procEnd + 2 && ( callInstruction . stack . size ( ) == 0 || callInstruction . stack . peekReturnOffset ( ) != returnOffset ) ) { callInstruction . stack . push ( returnOffset , callInstruction ) ; } } } clientVisitor . processedInstructions [ offset ] = true ; instruction . accept ( getNextOffsetVisitor , offset , newOffset ) ; } } }
msebire/intellij-community | private static boolean isInsideReturnStatement ( PsiElement element ) { while ( element instanceof PsiExpression ) element = element . getParent ( ) ; return element instanceof PsiReturnStatement ; }
msebire/intellij-community | @ NotNull public static CopyOnWriteList add ( @ Nullable CopyOnWriteList list , @ NotNull VariableInfo value ) { return list == null ? new CopyOnWriteList ( value ) : list . add ( value ) ; }
msebire/intellij-community | private static void merge ( int offset , CopyOnWriteList source , @ NotNull CopyOnWriteList [ ] target ) { if ( source != null ) { CopyOnWriteList existing = target [ offset ] ; target [ offset ] = existing == null ? source : existing . addAll ( source ) ; } }
msebire/intellij-community | @ NotNull public static List < PsiReferenceExpression > getReadBeforeWriteLocals ( @ NotNull ControlFlow flow ) { final InstructionClientVisitor < List < PsiReferenceExpression > > visitor = new ReadBeforeWriteClientVisitor ( flow , true ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | @ NotNull public static List < PsiReferenceExpression > getReadBeforeWrite ( @ NotNull ControlFlow flow ) { return getReadBeforeWrite ( flow , 0 ) ; }
msebire/intellij-community | @ NotNull private static List < PsiReferenceExpression > getReadBeforeWrite ( @ NotNull ControlFlow flow , int startOffset ) { if ( startOffset < 0 || startOffset >= flow . getSize ( ) ) { return Collections . emptyList ( ) ; } final ReadBeforeWriteClientVisitor visitor = new ReadBeforeWriteClientVisitor ( flow , false ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( startOffset ) ; }
msebire/intellij-community | private static boolean isMethodParameter ( @ NotNull PsiVariable variable ) { if ( variable instanceof PsiParameter ) { final PsiParameter parameter = ( PsiParameter ) variable ; return ! ( parameter . getDeclarationScope ( ) instanceof PsiForeachStatement ) ; } return false ; }
msebire/intellij-community | public static int getCompletionReasons ( @ NotNull ControlFlow flow , final int offset , final int endOffset ) { class MyVisitor extends InstructionClientVisitor < Integer > { private final boolean [ ] normalCompletion = new boolean [ endOffset ] ; private final boolean [ ] returnCalled = new boolean [ endOffset ] ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { boolean ret = nextOffset < endOffset && returnCalled [ nextOffset ] ; boolean normal = nextOffset < endOffset && normalCompletion [ nextOffset ] ; final PsiElement element = flow . getElement ( offset ) ; boolean goToReturn = instruction instanceof GoToInstruction && ( ( GoToInstruction ) instruction ) . isReturn ; if ( goToReturn || isInsideReturnStatement ( element ) ) { ret = true ; } else if ( instruction instanceof ConditionalThrowToInstruction ) { final int throwOffset = ( ( ConditionalThrowToInstruction ) instruction ) . offset ; boolean normalWhenThrow = throwOffset < endOffset && normalCompletion [ throwOffset ] ; boolean normalWhenNotThrow = offset == endOffset - 1 || normalCompletion [ offset + 1 ] ; normal = normalWhenThrow || normalWhenNotThrow ; } else if ( ! ( instruction instanceof ThrowToInstruction ) && nextOffset >= endOffset ) { normal = true ; } returnCalled [ offset ] |= ret ; normalCompletion [ offset ] |= normal ; } @ Override @ NotNull public Integer getResult ( ) { return ( returnCalled [ offset ] ? RETURN_COMPLETION_REASON : 0 ) | ( normalCompletion [ offset ] ? NORMAL_COMPLETION_REASON : 0 ) ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , offset , endOffset ) ; return visitor . getResult ( ) . intValue ( ) ; }
msebire/intellij-community | @ NotNull public static Collection < VariableInfo > getInitializedTwice ( @ NotNull ControlFlow flow ) { return getInitializedTwice ( flow , 0 , flow . getSize ( ) ) ; }
msebire/intellij-community | @ NotNull public static Collection < VariableInfo > getInitializedTwice ( @ NotNull ControlFlow flow , int startOffset , int endOffset ) { while ( startOffset < endOffset ) { InitializedTwiceClientVisitor visitor = new InitializedTwiceClientVisitor ( flow , startOffset ) ; depthFirstSearch ( flow , visitor , startOffset , endOffset ) ; Collection < VariableInfo > result = visitor . getResult ( ) ; if ( ! result . isEmpty ( ) ) { return result ; } startOffset = findUnprocessed ( startOffset , endOffset , visitor ) ; } return Collections . emptyList ( ) ; }
msebire/intellij-community | @ Nullable private static PsiElement getExpression ( @ NotNull PsiElement element ) { if ( element instanceof PsiAssignmentExpression ) { PsiExpression target = PsiUtil . skipParenthesizedExprDown ( ( ( PsiAssignmentExpression ) element ) . getLExpression ( ) ) ; return ObjectUtils . tryCast ( target , PsiReferenceExpression . class ) ; } if ( element instanceof PsiUnaryExpression ) { PsiExpression target = PsiUtil . skipParenthesizedExprDown ( ( ( PsiUnaryExpression ) element ) . getOperand ( ) ) ; return ObjectUtils . tryCast ( target , PsiReferenceExpression . class ) ; } if ( element instanceof PsiDeclarationStatement ) { return element ; } return null ; }
msebire/intellij-community | @ Nullable private static PsiElement getLatestWriteVarExpression ( @ Nullable CopyOnWriteList writeVars , @ NotNull PsiVariable variable ) { if ( writeVars == null ) return null ; for ( final VariableInfo variableInfo : writeVars . getList ( ) ) { if ( variableInfo . variable == variable ) { return variableInfo . expression ; } } return null ; }
msebire/intellij-community | @ NotNull public static Map < PsiElement , PsiVariable > getWritesBeforeReads ( @ NotNull ControlFlow flow , @ NotNull Set < PsiVariable > writeVars , @ NotNull Set < PsiVariable > readVars , final int stopPoint ) { Map < PsiElement , PsiVariable > writes = new HashMap < > ( ) ; List < Instruction > instructions = flow . getInstructions ( ) ; for ( int i = 0 ; i < instructions . size ( ) ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( ! ( instruction instanceof WriteVariableInstruction ) ) continue ; PsiVariable writtenVar = ( ( WriteVariableInstruction ) instruction ) . variable ; if ( ! writeVars . contains ( writtenVar ) ) continue ; if ( readBeforeStopPoint ( flow , readVars , i , stopPoint ) ) writes . put ( flow . getElement ( i ) , writtenVar ) ; } return writes ; }
msebire/intellij-community | private static boolean readBeforeStopPoint ( @ NotNull final ControlFlow flow , @ NotNull Set < PsiVariable > readVars , final int startOffset , final int stopPoint ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private boolean reachable = false ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( offset == stopPoint || isWriteToReadVar ( instruction ) ) { reachable = false ; return ; } boolean foundRead = instruction instanceof ReadVariableInstruction && readVars . contains ( ( ( ReadVariableInstruction ) instruction ) . variable ) ; reachable |= foundRead ; } private boolean isWriteToReadVar ( Instruction instruction ) { return instruction instanceof WriteVariableInstruction && readVars . contains ( ( ( WriteVariableInstruction ) instruction ) . variable ) ; } @ Override public Boolean getResult ( ) { return reachable ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , flow . getSize ( ) ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | public static boolean isInstructionReachable ( @ NotNull final ControlFlow flow , final int instructionOffset , final int startOffset ) { return areInstructionsReachable ( flow , new int [ ] { instructionOffset } , startOffset ) ; }
msebire/intellij-community | private static boolean areInstructionsReachable ( @ NotNull final ControlFlow flow , @ NotNull final int [ ] instructionOffsets , final int startOffset ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private boolean reachable ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { reachable |= ArrayUtil . indexOf ( instructionOffsets , nextOffset ) >= 0 ; } @ Override @ NotNull public Boolean getResult ( ) { return reachable ; } } if ( startOffset != 0 && hasCalls ( flow ) ) { return areInstructionsReachableWithCalls ( flow , instructionOffsets , startOffset ) ; } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | private static boolean hasCalls ( @ NotNull ControlFlow flow ) { for ( Instruction instruction : flow . getInstructions ( ) ) { if ( instruction instanceof CallInstruction ) { return true ; } } return false ; }
msebire/intellij-community | private static boolean areInstructionsReachableWithCalls ( @ NotNull final ControlFlow flow , @ NotNull final int [ ] instructionOffsets , final int startOffset ) { ControlFlowGraph graph = new ControlFlowGraph ( flow . getSize ( ) ) { @ Override boolean isComplete ( int offset , int nextOffset ) { return ArrayUtil . indexOf ( instructionOffsets , nextOffset ) >= 0 ; } } ; graph . buildFrom ( flow ) ; return graph . depthFirstSearch ( startOffset ) ; }
msebire/intellij-community | public static boolean isVariableAssignedInLoop ( @ NotNull PsiReferenceExpression expression , @ NotNull PsiElement resolved ) { if ( ! ( expression . getParent ( ) instanceof PsiAssignmentExpression ) || ( ( PsiAssignmentExpression ) expression . getParent ( ) ) . getLExpression ( ) != expression ) { return false ; } PsiExpression qualifier = expression . getQualifierExpression ( ) ; if ( qualifier != null && ! ( qualifier instanceof PsiThisExpression ) ) return false ; if ( ! ( resolved instanceof PsiVariable ) ) return false ; PsiVariable variable = ( PsiVariable ) resolved ; final PsiElement codeBlock = PsiUtil . getVariableCodeBlock ( variable , expression ) ; if ( codeBlock == null ) return false ; final ControlFlow flow ; try { flow = ControlFlowFactory . getInstance ( codeBlock . getProject ( ) ) . getControlFlow ( codeBlock , LocalsOrMyInstanceFieldsControlFlowPolicy . getInstance ( ) , true ) ; } catch ( AnalysisCanceledException e ) { return false ; } final PsiAssignmentExpression assignmentExpression = ( PsiAssignmentExpression ) expression . getParent ( ) ; int startOffset = flow . getStartOffset ( assignmentExpression ) ; return startOffset != - 1 && isInstructionReachable ( flow , startOffset , startOffset ) ; }
msebire/intellij-community | static boolean isCaughtExceptionType ( @ NotNull PsiClassType throwType , @ NotNull PsiType catchType ) { return catchType . isAssignableFrom ( throwType ) || mightBeAssignableFromSubclass ( throwType , catchType ) ; }
msebire/intellij-community | private static boolean mightBeAssignableFromSubclass ( @ NotNull final PsiClassType throwType , @ NotNull PsiType catchType ) { if ( catchType instanceof PsiDisjunctionType ) { for ( PsiType catchDisjunction : ( ( PsiDisjunctionType ) catchType ) . getDisjunctions ( ) ) { if ( throwType . isAssignableFrom ( catchDisjunction ) ) { return true ; } } return false ; } return throwType . isAssignableFrom ( catchType ) ; }
msebire/intellij-community | public static boolean areVariablesUnmodifiedAtLocations ( @ NotNull ControlFlow flow , int startOffset , int endOffset , @ NotNull Set < ? extends PsiVariable > variables , @ NotNull Iterable < ? extends PsiElement > locations ) { List < Instruction > instructions = flow . getInstructions ( ) ; startOffset = Math . max ( startOffset , 0 ) ; endOffset = Math . min ( endOffset , instructions . size ( ) ) ; IntArrayList locationOffsetList = new IntArrayList ( ) ; for ( PsiElement location : locations ) { int offset = flow . getStartOffset ( location ) ; if ( offset >= startOffset && offset < endOffset ) { locationOffsetList . add ( offset ) ; } } int [ ] locationOffsets = locationOffsetList . toArray ( ) ; for ( int offset = startOffset ; offset < endOffset ; offset ++ ) { Instruction instruction = instructions . get ( offset ) ; if ( instruction instanceof WriteVariableInstruction && variables . contains ( ( ( WriteVariableInstruction ) instruction ) . variable ) ) { if ( areInstructionsReachable ( flow , locationOffsets , offset ) ) { return false ; } } } return true ; }
Karm/undertow | public static void cleanClose ( StreamConnection connection , Closeable ... additional ) { try { connection . getSinkChannel ( ) . shutdownWrites ( ) ; if ( ! connection . getSinkChannel ( ) . flush ( ) ) { connection . getSinkChannel ( ) . setWriteListener ( ChannelListeners . flushingChannelListener ( new ChannelListener < ConduitStreamSinkChannel > ( ) { @ Override public void handleEvent ( ConduitStreamSinkChannel channel ) { doDrain ( connection , additional ) ; } } , new ChannelExceptionHandler < ConduitStreamSinkChannel > ( ) { @ Override public void handleException ( ConduitStreamSinkChannel channel , IOException exception ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( exception ) ; IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } } ) ) ; connection . getSinkChannel ( ) . resumeWrites ( ) ; } else { doDrain ( connection , additional ) ; } } catch ( Throwable e ) { if ( e instanceof IOException ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( ( IOException ) e ) ; } else { UndertowLogger . REQUEST_IO_LOGGER . ioException ( new IOException ( e ) ) ; } IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } }
Karm/undertow | private static void doDrain ( final StreamConnection connection , final Closeable ... additional ) { if ( ! connection . getSourceChannel ( ) . isOpen ( ) ) { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; return ; } final ByteBuffer b = ByteBuffer . allocate ( 1 ) ; try { int res = connection . getSourceChannel ( ) . read ( b ) ; b . clear ( ) ; if ( res == 0 ) { final XnioExecutor . Key key = WorkerUtils . executeAfter ( connection . getIoThread ( ) , new Runnable ( ) { @ Override public void run ( ) { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } } , MAX_DRAIN_TIME , TimeUnit . MILLISECONDS ) ; connection . getSourceChannel ( ) . setReadListener ( new ChannelListener < ConduitStreamSourceChannel > ( ) { @ Override public void handleEvent ( ConduitStreamSourceChannel channel ) { try { int res = channel . read ( b ) ; if ( res != 0 ) { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; key . remove ( ) ; } } catch ( Exception e ) { if ( e instanceof IOException ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( ( IOException ) e ) ; } else { UndertowLogger . REQUEST_IO_LOGGER . ioException ( new IOException ( e ) ) ; } IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; key . remove ( ) ; } } } ) ; connection . getSourceChannel ( ) . resumeReads ( ) ; } else { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } } catch ( Throwable e ) { if ( e instanceof IOException ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( ( IOException ) e ) ; } else { UndertowLogger . REQUEST_IO_LOGGER . ioException ( new IOException ( e ) ) ; } IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } }
jack0707/coldweather | public synchronized static ColdWeatherDB getInstance ( Context context ) { if ( coldWeatherDB == null ) { coldWeatherDB = new ColdWeatherDB ( context ) ; } return coldWeatherDB ; }
Alachisoft/TayzGrid | public static boolean IsValidIP ( String ip ) { if ( ip == null || ip . isEmpty ( ) ) { return false ; } ip = ip . trim ( ) ; if ( ( ip . length ( ) < 6 ) & ( ip . length ( ) > 15 ) ) { return false ; } try { Pattern pattern = Pattern . compile ( " ^ ( ? : ( ? :25[0-5 ] | 2[0-4 ] [ 0-9 ] | [ 01 ] ? [0-9 ] [ 0-9 ] ? ) \\ . ) { 3 } ( ? : 25[0-5 ] | 2[0-4 ] [ 0-9 ] | [ 01 ] ? [0-9 ] [ 0-9 ] ? ) $ " ) ; Matcher matcher = pattern . matcher ( ip ) ; return matcher . matches ( ) ; } catch ( PatternSyntaxException ex ) { return false ; } }
Alachisoft/TayzGrid | private static boolean ValidateParameters ( ) { AssemblyUsage . PrintLogo ( cParam . getIsLogo ( ) ) ; if ( tangible . DotNetToJavaStringHelper . isNullOrEmpty ( cParam . getCacheId ( ) ) ) { System . err . println ( " Error : ▁ Cache ▁ Name ▁ not ▁ specified " ) ; return false ; } if ( tangible . DotNetToJavaStringHelper . isNullOrEmpty ( cParam . getServer ( ) ) ) { System . err . println ( " Error : ▁ Server ▁ not ▁ specified " ) ; return false ; } if ( ! IsValidIP ( cParam . getServer ( ) ) ) { System . err . println ( " Error : ▁ Invalid ▁ Server ▁ IP " ) ; return false ; } if ( tangible . DotNetToJavaStringHelper . isNullOrEmpty ( cParam . getClientNode ( ) ) ) { System . err . println ( " Error : ▁ Client ▁ Node ▁ not ▁ specified " ) ; return false ; } if ( ! IsValidIP ( cParam . getClientNode ( ) ) ) { System . err . println ( " Error : ▁ ClientNode ( IP ) ▁ is ▁ invalid " ) ; return false ; } return true ; }
Alachisoft/TayzGrid | private static void LogEvent ( String msg ) { EventLogEntryType type = EventLogEntryType . Error ; try { } finally { } }
Alachisoft/TayzGrid | private static boolean IsValidAddress ( String iPaddress ) { InetAddress address = null ; try { address = InetAddress . getByName ( iPaddress ) ; } catch ( UnknownHostException e ) { return false ; } return true ; }
Alachisoft/TayzGrid | private static com . alachisoft . tayzgrid . management . clientconfiguration . CacheServerList GetSeversPriorityList ( ) throws UnknownHostException { java . util . HashMap < Integer , com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer > serversPriorityList = new java . util . HashMap < Integer , com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer > ( ) ; java . util . ArrayList < Address > hosts = config . getCacheDeployment ( ) . getServers ( ) . GetAllConfiguredNodes ( ) ; int priority = 0 ; for ( Address addr : hosts ) { com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer server = new com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer ( ) ; server . setServerName ( addr . getIpAddress ( ) . getHostAddress ( ) ) ; server . setPriority ( priority ) ; serversPriorityList . put ( priority , server ) ; priority ++ ; } com . alachisoft . tayzgrid . management . clientconfiguration . CacheServerList csList = new com . alachisoft . tayzgrid . management . clientconfiguration . CacheServerList ( ) ; csList . setServersList ( serversPriorityList ) ; return csList ; }
shakamunyi/drill | @ BeforeClass public static void testSetUp ( ) throws Exception { testDrillDriver = new Driver ( ) ; }
wentch/redkale | public static HttpScope refer ( String template ) { HttpScope rs = new HttpScope ( ) ; rs . setReferid ( template ) ; return rs ; }
miniway/presto | @ InputFunction public static void input ( @ AggregationState GeometryState state , @ SqlType ( GEOMETRY_TYPE_NAME ) Slice input ) { OGCGeometry geometry = GeometrySerde . deserialize ( input ) ; if ( state . getGeometry ( ) == null ) { state . setGeometry ( geometry . convexHull ( ) ) ; } else if ( ! geometry . isEmpty ( ) ) { state . setGeometry ( state . getGeometry ( ) . union ( geometry ) . convexHull ( ) ) ; } }
miniway/presto | @ CombineFunction public static void combine ( @ AggregationState GeometryState state , @ AggregationState GeometryState otherState ) { if ( state . getGeometry ( ) == null ) { state . setGeometry ( otherState . getGeometry ( ) ) ; } else if ( otherState . getGeometry ( ) != null && ! otherState . getGeometry ( ) . isEmpty ( ) ) { state . setGeometry ( state . getGeometry ( ) . union ( otherState . getGeometry ( ) ) . convexHull ( ) ) ; } }
miniway/presto | @ OutputFunction ( GEOMETRY_TYPE_NAME ) public static void output ( @ AggregationState GeometryState state , BlockBuilder out ) { if ( state . getGeometry ( ) == null ) { out . appendNull ( ) ; } else { GEOMETRY . writeSlice ( out , GeometrySerde . serialize ( state . getGeometry ( ) ) ) ; } }
miniway/presto | private static void validateType ( String function , OGCGeometry geometry , Set < GeometryType > validTypes ) { GeometryType type = GeometryType . getForEsriGeometryType ( geometry . geometryType ( ) ) ; if ( ! validTypes . contains ( type ) ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , format ( " % s ▁ only ▁ applies ▁ to ▁ % s . ▁ Input ▁ type ▁ is : ▁ % s " , function , OR_JOINER . join ( validTypes ) , type ) ) ; } }
clairton/repository-vraptor | public static Record valueOf ( final String [ ] values ) { if ( values . length == 1 ) { return valueOf ( values [ 0 ] ) ; } else { return new Record ( values , EQUAL ) ; } }
clairton/repository-vraptor | public static Record valueOf ( final String value ) { for ( final Comparator comparator : values ( ) ) { final String expression = escaper . matcher ( comparator . toString ( ) ) . replaceAll ( " \\ \\ $ 1" ) . replace ( " ^ " , " \\ ^ " ) ; final String regex = " ^ " + expression + " . * " ; logger . log ( FINE , regex ) ; if ( value . matches ( regex ) ) { return new Record ( value . replaceAll ( expression , " " ) , comparator ) ; } } return new Record ( value , EQUAL ) ; }
jentfoo/aws-sdk-java | public static ChangeBatchStaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new ChangeBatchStaxUnmarshaller ( ) ; return instance ; }
Azure/azure-sdk-for-java | public static void main ( String [ ] args ) throws Exception { final MachineEventsProcessor aggregator = new MachineEventsProcessor ( REPORTING_INTERVAL ) ; final EventProcessorClient client = new EventProcessorClientBuilder ( ) . consumerGroup ( EventHubClientBuilder . DEFAULT_CONSUMER_GROUP_NAME ) . connectionString ( EH_CONNECTION_STRING ) . processPartitionInitialization ( context -> aggregator . onInitialize ( context ) ) . processPartitionClose ( context -> aggregator . onClose ( context ) ) . processEvent ( event -> aggregator . onEvent ( event ) ) . processError ( error -> aggregator . onError ( error ) ) . checkpointStore ( new SampleCheckpointStore ( ) ) . buildEventProcessorClient ( ) ; System . out . println ( " Starting ▁ event ▁ processor " ) ; final AtomicBoolean isRunning = new AtomicBoolean ( true ) ; client . start ( ) ; generateEvents ( isRunning ) . subscribe ( ) ; System . out . println ( " Sleeping . . . " ) ; Thread . sleep ( TimeUnit . SECONDS . toMillis ( 30 ) ) ; isRunning . set ( false ) ; System . out . println ( " Stopping ▁ event ▁ processor " ) ; client . stop ( ) ; System . out . println ( " Exiting ▁ process " ) ; }
Azure/azure-sdk-for-java | private static Mono < Void > generateEvents ( AtomicBoolean isRunning ) { final Logger logger = LoggerFactory . getLogger ( " Producer " ) ; final Scheduler scheduler = Schedulers . elastic ( ) ; final Duration operationTimeout = Duration . ofSeconds ( 5 ) ; final String [ ] machineIds = new String [ ] { "2A " , "9B " , "6C " } ; final Random random = new Random ( ) ; final EventHubProducerAsyncClient client = new EventHubClientBuilder ( ) . connectionString ( EH_CONNECTION_STRING ) . buildAsyncProducerClient ( ) ; return Mono . < Void > fromRunnable ( ( ) -> { while ( isRunning . get ( ) ) { int milliseconds = random . nextInt ( 1000 ) ; try { TimeUnit . MILLISECONDS . sleep ( milliseconds ) ; } catch ( InterruptedException ignored ) { } final String machineId = machineIds [ random . nextInt ( machineIds . length ) ] ; final int temperature = Math . abs ( random . nextInt ( ) % 101 ) ; logger . info ( " [ { } ] ▁ Temperature : ▁ { } C " , machineId , temperature ) ; final EventData event = new EventData ( String . valueOf ( temperature ) ) ; final CreateBatchOptions batchOptions = new CreateBatchOptions ( ) . setPartitionKey ( machineId ) ; client . createBatch ( batchOptions ) . flatMap ( batch -> { batch . tryAdd ( event ) ; return client . send ( batch ) ; } ) . block ( operationTimeout ) ; } } ) . subscribeOn ( scheduler ) . doFinally ( signal -> { logger . info ( " Disposing ▁ of ▁ producer . " ) ; client . close ( ) ; } ) ; }
xasx/assertj-core | public static ErrorMessageFactory shouldEndWith ( Object actual , Object expected , ComparisonStrategy comparisonStrategy ) { return new ShouldEndWith ( actual , expected , comparisonStrategy ) ; }
xasx/assertj-core | public static ErrorMessageFactory shouldEndWith ( Object actual , Object expected ) { return new ShouldEndWith ( actual , expected , StandardComparisonStrategy . instance ( ) ) ; }
Netflix/photon | public static void validateRangeRequest ( long resourceSize , long rangeStart , long rangeEnd ) { if ( rangeStart < 0 ) { throw new IllegalArgumentException ( String . format ( " rangeStart ▁ = ▁ % d ▁ is ▁ < ▁ 0" , rangeStart ) ) ; } if ( rangeStart > rangeEnd ) { throw new IllegalArgumentException ( String . format ( " rangeStart ▁ = ▁ % d ▁ is ▁ not ▁ < = ▁ % d ▁ rangeEnd " , rangeStart , rangeEnd ) ) ; } if ( rangeEnd > ( resourceSize - 1 ) ) { throw new IllegalArgumentException ( String . format ( " rangeEnd ▁ = ▁ % d ▁ is ▁ not ▁ < = ▁ ( resourceSize ▁ - 1 ) ▁ = ▁ % d " , rangeEnd , ( resourceSize - 1 ) ) ) ; } }
GunoH/intellij-community | private static void zipOutput ( @ NotNull String traceFilePath ) { Path traceFile = Paths . get ( traceFilePath ) ; Path parent = traceFile . getParent ( ) ; String zipName = traceFile . getFileName ( ) + " . zip " ; System . out . println ( " Preparing ▁ zip . " ) ; try { Path zipFile = parent . resolve ( zipName ) ; ZipUtil . compressFile ( traceFile , zipFile ) ; FileUtil . delete ( traceFile ) ; System . out . println ( " archive ▁ " + zipFile + " ▁ prepared " ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
haakom/EnergiWeb-remake | public static void main ( String [ ] args ) { RadiusReader test = new RadiusReader ( ) ; RadiusData data = test . readData ( ) ; System . out . println ( " Antall ▁ terminaler : ▁ " + data . getNumSegments ( ) ) ; System . out . println ( " Neste ▁ IP : ▁ " + data . nextAvailableIP ( 0 ) ) ; if ( data . getNumSegments ( ) > 0 ) { } }
wuyinlei/MyHearts | public static CategoryFragment newInstance ( int index ) { Bundle bundle = new Bundle ( ) ; bundle . putInt ( Contants . INDEX , index ) ; CategoryFragment fragment = new CategoryFragment ( ) ; fragment . setArguments ( bundle ) ; return fragment ; }
bbranan/fcrepo4 | private static String currentVersion ( final FedoraSession session , final FedoraResource resource ) throws RepositoryException { return getJcrSession ( session ) . getWorkspace ( ) . getVersionManager ( ) . getBaseVersion ( getJcrNode ( resource ) . getPath ( ) ) . getFrozenNode ( ) . getIdentifier ( ) ; }
bbranan/fcrepo4 | private static long countVersions ( final FedoraSession session , final FedoraResource resource ) throws RepositoryException { final VersionHistory versions = getJcrSession ( session ) . getWorkspace ( ) . getVersionManager ( ) . getVersionHistory ( getJcrNode ( resource ) . getPath ( ) ) ; return versions . getAllVersions ( ) . getSize ( ) ; }
dhaval0129/PSAlgs | private static int LCSubStr_DP ( char X [ ] , char Y [ ] ) { int m = X . length ; int n = Y . length ; int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = 1 + LCStuff [ i - 1 ] [ j - 1 ] ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else { LCStuff [ i ] [ j ] = 0 ; } } } return result ; }
dhaval0129/PSAlgs | public static void main ( String [ ] args ) { String X = " abcdaf " ; String Y = " zbcdf " ; System . out . println ( " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ▁ " + LCSubStr_DP ( X . toCharArray ( ) , Y . toCharArray ( ) ) ) ; }
HelloBugs/Review-It | public static String getFirstNodeText ( Elements elements ) { return elements . get ( 0 ) . text ( ) ; }
apache/jackrabbit-oak | @ NotNull private static SharedAccessBlobPolicy policy ( EnumSet < SharedAccessBlobPermissions > permissions , Instant expirationTime ) { SharedAccessBlobPolicy sharedAccessBlobPolicy = new SharedAccessBlobPolicy ( ) ; sharedAccessBlobPolicy . setPermissions ( permissions ) ; sharedAccessBlobPolicy . setSharedAccessExpiryTime ( Date . from ( expirationTime ) ) ; return sharedAccessBlobPolicy ; }
apache/jackrabbit-oak | @ NotNull private static SharedAccessBlobPolicy policy ( EnumSet < SharedAccessBlobPermissions > permissions ) { return policy ( permissions , Instant . now ( ) . plus ( Duration . ofDays ( 7 ) ) ) ; }
apache/jackrabbit-oak | private static void assertReadAccessGranted ( SegmentNodeStorePersistence persistence , Set < String > expectedBlobs ) throws Exception { CloudBlobContainer container = getContainerFrom ( persistence ) ; Set < String > actualBlobNames = StreamSupport . stream ( container . listBlobs ( ) . spliterator ( ) , false ) . map ( blob -> blob . getUri ( ) . getPath ( ) ) . map ( path -> path . substring ( path . lastIndexOf ( ' / ' ) + 1 ) ) . collect ( toSet ( ) ) ; Set < String > expectedBlobNames = expectedBlobs . stream ( ) . map ( name -> name + " . txt " ) . collect ( toSet ( ) ) ; assertEquals ( expectedBlobNames , actualBlobNames ) ; Set < String > actualBlobContent = actualBlobNames . stream ( ) . map ( name -> { try { return container . getBlockBlobReference ( name ) . downloadText ( ) ; } catch ( StorageException | IOException | URISyntaxException e ) { throw new RuntimeException ( " Error ▁ while ▁ reading ▁ blob ▁ " + name , e ) ; } } ) . collect ( toSet ( ) ) ; assertEquals ( expectedBlobs , actualBlobContent ) ; }
apache/jackrabbit-oak | private static void assertWriteAccessGranted ( SegmentNodeStorePersistence persistence ) throws Exception { getContainerFrom ( persistence ) . getBlockBlobReference ( " test . txt " ) . uploadText ( " test " ) ; }
apache/jackrabbit-oak | private static CloudBlobContainer getContainerFrom ( SegmentNodeStorePersistence persistence ) throws Exception { return ( ( AzurePersistence ) persistence ) . getSegmentstoreDirectory ( ) . getContainer ( ) ; }
apache/jackrabbit-oak | private static void assertWriteAccessNotGranted ( SegmentNodeStorePersistence persistence ) { try { assertWriteAccessGranted ( persistence ) ; fail ( " Write ▁ access ▁ should ▁ not ▁ be ▁ granted , ▁ but ▁ writing ▁ to ▁ the ▁ storage ▁ succeeded . " ) ; } catch ( Exception e ) { } }
apache/jackrabbit-oak | private static void assertReadAccessNotGranted ( SegmentNodeStorePersistence persistence ) { try { assertReadAccessGranted ( persistence , BLOBS ) ; fail ( " Read ▁ access ▁ should ▁ not ▁ be ▁ granted , ▁ but ▁ reading ▁ from ▁ the ▁ storage ▁ succeeded . " ) ; } catch ( Exception e ) { } }
apache/jackrabbit-oak | private static Instant yesterday ( ) { return Instant . now ( ) . minus ( Duration . ofDays ( 1 ) ) ; }
apache/jackrabbit-oak | private static ImmutableSet < String > concat ( ImmutableSet < String > blobs , String element ) { return ImmutableSet . < String > builder ( ) . addAll ( blobs ) . add ( element ) . build ( ) ; }
apache/jackrabbit-oak | private static Configuration getConfigurationWithSharedAccessSignature ( String sasToken ) { return getConfiguration ( sasToken , null , null ) ; }
apache/jackrabbit-oak | private static Configuration getConfigurationWithAccessKey ( String accessKey ) { return getConfiguration ( null , accessKey , null ) ; }
apache/jackrabbit-oak | private static Configuration getConfigurationWithConfigurationURL ( String accessKey ) { String connectionString = " DefaultEndpointsProtocol = https ; " + " BlobEndpoint = " + azurite . getBlobEndpoint ( ) + ' ; ' + " AccountName = " + AzuriteDockerRule . ACCOUNT_NAME + ' ; ' + " AccountKey = " + accessKey + ' ; ' ; return getConfiguration ( null , null , connectionString ) ; }
apache/jackrabbit-oak | @ NotNull private static Configuration getConfiguration ( String sasToken , String accessKey , String connectionURL ) { return new Configuration ( ) { @ Override public String accountName ( ) { return AzuriteDockerRule . ACCOUNT_NAME ; } @ Override public String containerName ( ) { return AzureSegmentStoreService . DEFAULT_CONTAINER_NAME ; } @ Override public String accessKey ( ) { return accessKey != null ? accessKey : " " ; } @ Override public String rootPath ( ) { return AzureSegmentStoreService . DEFAULT_ROOT_PATH ; } @ Override public String connectionURL ( ) { return connectionURL != null ? connectionURL : " " ; } @ Override public String sharedAccessSignature ( ) { return sasToken != null ? sasToken : " " ; } @ Override public String blobEndpoint ( ) { return azurite . getBlobEndpoint ( ) ; } @ Override public Class < ? extends Annotation > annotationType ( ) { return Configuration . class ; } } ; }
Log10Solutions/querydsl | @ QueryDelegate ( DelegateTest . User . class ) public static StringPath getName ( QDelegateTest_User user ) { return user . name ; }
apache/tomcat | public static boolean arrayequals ( final byte [ ] a , final byte [ ] b , final int count ) { for ( int i = 0 ; i < count ; i ++ ) { if ( a [ i ] != b [ i ] ) { return false ; } } return true ; }
rekhajoshm/pig | public static void replaceWithPOJoinPackage ( PhysicalPlan plan , MapReduceOper mr , POPackage pack , POForEach forEach , String chunkSize ) throws VisitorException { String scope = pack . getOperatorKey ( ) . scope ; NodeIdGenerator nig = NodeIdGenerator . getGenerator ( ) ; POJoinPackage joinPackage ; joinPackage = new POJoinPackage ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , pack , forEach ) ; joinPackage . setChunkSize ( Long . parseLong ( chunkSize ) ) ; List < PhysicalOperator > succs = plan . getSuccessors ( forEach ) ; if ( succs != null ) { if ( succs . size ( ) != 1 ) { int errCode = 2028 ; String msg = " ForEach ▁ can ▁ only ▁ have ▁ one ▁ successor . ▁ Found ▁ " + succs . size ( ) + " ▁ successors . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } } plan . remove ( pack ) ; try { plan . replace ( forEach , joinPackage ) ; } catch ( PlanException e ) { int errCode = 2029 ; String msg = " Error ▁ rewriting ▁ POJoinPackage . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } mr . phyToMRMap . put ( forEach , joinPackage ) ; LogFactory . getLog ( LastInputStreamingOptimizer . class ) . info ( " Rewrite : ▁ POPackage - > POForEach ▁ to ▁ POJoinPackage " ) ; }
eayun/ovirt-engine | public static EventNotificationEntity forValue ( int value ) { return values ( ) [ value ] ; }
HappyRay/azkaban | public static SlaAlertAction createFromJson ( final Object obj ) throws Exception { return createFromJson ( ( HashMap < String , Object > ) obj ) ; }
HappyRay/azkaban | public static SlaAlertAction createFromJson ( final HashMap < String , Object > obj ) throws Exception { final Map < String , Object > jsonObj = ( HashMap < String , Object > ) obj ; if ( ! jsonObj . get ( " type " ) . equals ( type ) ) { throw new Exception ( " Cannot ▁ create ▁ action ▁ of ▁ " + type + " ▁ from ▁ " + jsonObj . get ( " type " ) ) ; } final String actionId = ( String ) jsonObj . get ( " actionId " ) ; SlaOption slaOption ; List < String > emails ; slaOption = SlaOption . fromObject ( jsonObj . get ( " slaOption " ) ) ; final int execId = Integer . valueOf ( ( String ) jsonObj . get ( " execId " ) ) ; return new SlaAlertAction ( actionId , slaOption , execId ) ; }
marszczybrew/Diorite | private static boolean isDigit ( final char ch ) { return ( ch >= '0' ) && ( ch <= '9' ) ; }
marszczybrew/Diorite | private static String getChunk ( final CharSequence s , final int slength , int marker ) { final StringBuilder chunk = new StringBuilder ( ) ; char c = s . charAt ( marker ) ; chunk . append ( c ) ; marker ++ ; if ( isDigit ( c ) ) { while ( marker < slength ) { c = s . charAt ( marker ) ; if ( ! isDigit ( c ) ) { break ; } chunk . append ( c ) ; marker ++ ; } } else { while ( marker < slength ) { c = s . charAt ( marker ) ; if ( isDigit ( c ) ) { break ; } chunk . append ( c ) ; marker ++ ; } } return chunk . toString ( ) ; }
marszczybrew/Diorite | public static int compareStatic ( final String s1 , final String s2 ) { int thisMarker = 0 ; int thatMarker = 0 ; final int s1Length = s1 . length ( ) ; final int s2Length = s2 . length ( ) ; while ( ( thisMarker < s1Length ) && ( thatMarker < s2Length ) ) { final String thisChunk = getChunk ( s1 , s1Length , thisMarker ) ; thisMarker += thisChunk . length ( ) ; final String thatChunk = getChunk ( s2 , s2Length , thatMarker ) ; thatMarker += thatChunk . length ( ) ; int result ; if ( isDigit ( thisChunk . charAt ( 0 ) ) && isDigit ( thatChunk . charAt ( 0 ) ) ) { final int thisChunkLength = thisChunk . length ( ) ; result = thisChunkLength - thatChunk . length ( ) ; if ( result == 0 ) { for ( int i = 0 ; i < thisChunkLength ; i ++ ) { result = thisChunk . charAt ( i ) - thatChunk . charAt ( i ) ; if ( result != 0 ) { return result ; } } } } else { result = thisChunk . compareTo ( thatChunk ) ; } if ( result != 0 ) { return result ; } } return s1Length - s2Length ; }
deroneriksson/incubator-systemml | private static boolean [ ] createAssignment ( int len , int off , long pos ) { boolean [ ] ret = new boolean [ off + len ] ; Arrays . fill ( ret , 0 , off , true ) ; long tmp = pos ; for ( int i = 0 ; i < len ; i ++ ) { long mask = UtilFunctions . pow ( 2 , len - i - 1 ) ; ret [ off + i ] = tmp >= mask ; tmp %= mask ; } return ret ; }
deroneriksson/incubator-systemml | private static long getNumSkipPlans ( boolean [ ] plan ) { int pos = ArrayUtils . lastIndexOf ( plan , true ) ; return UtilFunctions . pow ( 2 , plan . length - pos - 1 ) ; }
deroneriksson/incubator-systemml | private static double getLowerBoundCosts ( PlanPartition part , InterestingPoint [ ] M , CPlanMemoTable memo , StaticCosts costs , boolean [ ] plan ) { double lb = Math . max ( costs . _read , costs . _compute ) + costs . _write + getMaterializationCost ( part , M , memo , plan ) ; if ( part . hasOuter ( ) ) lb *= costs . _minSparsity ; return lb ; }
deroneriksson/incubator-systemml | private static double getMaterializationCost ( PlanPartition part , InterestingPoint [ ] M , CPlanMemoTable memo , boolean [ ] plan ) { double costs = 0 ; HashSet < Long > matTargets = new HashSet < > ( ) ; for ( int i = 0 ; i < plan . length ; i ++ ) { long hopID = M [ i ] . getToHopID ( ) ; if ( plan [ i ] && ! matTargets . contains ( hopID ) ) { matTargets . add ( hopID ) ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; long size = getSize ( hop ) ; costs += size * 8 / WRITE_BANDWIDTH_MEM + size * 8 / READ_BANDWIDTH_MEM ; } } for ( Long hopID : part . getExtConsumed ( ) ) if ( ! matTargets . contains ( hopID ) ) { matTargets . add ( hopID ) ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSize ( hop ) * 8 / WRITE_BANDWIDTH_MEM ; } return costs ; }
deroneriksson/incubator-systemml | private static double getReadCost ( PlanPartition part , CPlanMemoTable memo ) { double costs = 0 ; for ( Long hopID : part . getInputs ( ) ) { Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSafeMemEst ( hop ) / READ_BANDWIDTH_MEM ; } return costs ; }
deroneriksson/incubator-systemml | private static double getWriteCost ( Collection < Long > R , CPlanMemoTable memo ) { double costs = 0 ; for ( Long hopID : R ) { Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSize ( hop ) * 8 / WRITE_BANDWIDTH_MEM ; } return costs ; }
deroneriksson/incubator-systemml | private static double sumComputeCost ( HashMap < Long , Double > computeCosts ) { return computeCosts . values ( ) . stream ( ) . mapToDouble ( d -> d / COMPUTE_BANDWIDTH ) . sum ( ) ; }
deroneriksson/incubator-systemml | private static double minOuterSparsity ( PlanPartition part , CPlanMemoTable memo ) { return ! part . hasOuter ( ) ? 1.0 : part . getPartition ( ) . stream ( ) . map ( k -> HopRewriteUtils . getLargestInput ( memo . getHopRefs ( ) . get ( k ) ) ) . mapToDouble ( h -> h . dimsKnown ( true ) ? h . getSparsity ( ) : SPARSE_SAFE_SPARSITY_EST ) . min ( ) . orElse ( SPARSE_SAFE_SPARSITY_EST ) ; }
deroneriksson/incubator-systemml | private static double sumTmpInputOutputSize ( CPlanMemoTable memo , CostVector vect ) { return vect . outSize + vect . inSizes . entrySet ( ) . stream ( ) . filter ( e -> ! HopRewriteUtils . isData ( memo . getHopRefs ( ) . get ( e . getKey ( ) ) , DataOpTypes . TRANSIENTREAD ) ) . mapToDouble ( e -> e . getValue ( ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | private static double sumInputMemoryEstimates ( CPlanMemoTable memo , CostVector vect ) { return vect . inSizes . keySet ( ) . stream ( ) . mapToDouble ( e -> getSafeMemEst ( memo . getHopRefs ( ) . get ( e ) ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | private static double getSafeMemEst ( Hop hop ) { return ! hop . dimsKnown ( ) ? getSize ( hop ) * 8 : hop . getOutputMemEstimate ( ) ; }
deroneriksson/incubator-systemml | private static long getSize ( Hop hop ) { return Math . max ( hop . getDim1 ( ) , 1 ) * Math . max ( hop . getDim2 ( ) , 1 ) ; }
deroneriksson/incubator-systemml | private static void createAndAddMultiAggPlans ( CPlanMemoTable memo , HashSet < Long > partition , HashSet < Long > R ) { HashSet < Long > refHops = new HashSet < > ( ) ; for ( Entry < Long , List < MemoTableEntry > > e : memo . getPlans ( ) . entrySet ( ) ) if ( ! e . getValue ( ) . isEmpty ( ) ) { Hop hop = memo . getHopRefs ( ) . get ( e . getKey ( ) ) ; for ( Hop c : hop . getInput ( ) ) refHops . add ( c . getHopID ( ) ) ; } ArrayList < Long > fullAggs = new ArrayList < > ( ) ; for ( Long hopID : R ) { Hop root = memo . getHopRefs ( ) . get ( hopID ) ; if ( ! refHops . contains ( hopID ) && isMultiAggregateRoot ( root ) ) fullAggs . add ( hopID ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Found ▁ within - partition ▁ ua ( RC ) ▁ aggregations : ▁ " + Arrays . toString ( fullAggs . toArray ( new Long [ 0 ] ) ) ) ; } for ( int i = 0 ; i < fullAggs . size ( ) ; i += 3 ) { int ito = Math . min ( i + 3 , fullAggs . size ( ) ) ; if ( ito - i >= 2 ) { MemoTableEntry me = new MemoTableEntry ( TemplateType . MAGG , fullAggs . get ( i ) , fullAggs . get ( i + 1 ) , ( ( ito - i ) == 3 ) ? fullAggs . get ( i + 2 ) : - 1 , ito - i ) ; if ( isValidMultiAggregate ( memo , me ) ) { for ( int j = i ; j < ito ; j ++ ) { memo . add ( memo . getHopRefs ( ) . get ( fullAggs . get ( j ) ) , me ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Added ▁ multiagg ▁ plan : ▁ " + fullAggs . get ( j ) + " ▁ " + me ) ; } } else if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ invalid ▁ multiagg ▁ plan : ▁ " + me ) ; } } } }
deroneriksson/incubator-systemml | private static boolean isMultiAggregateRoot ( Hop root ) { return ( HopRewriteUtils . isAggUnaryOp ( root , AggOp . SUM , AggOp . SUM_SQ , AggOp . MIN , AggOp . MAX ) && ( ( AggUnaryOp ) root ) . getDirection ( ) == Direction . RowCol ) || ( root instanceof AggBinaryOp && root . getDim1 ( ) == 1 && root . getDim2 ( ) == 1 && HopRewriteUtils . isTransposeOperation ( root . getInput ( ) . get ( 0 ) ) ) ; }
deroneriksson/incubator-systemml | private static boolean isValidMultiAggregate ( CPlanMemoTable memo , MemoTableEntry me ) { boolean ret = true ; Hop refSize = memo . getHopRefs ( ) . get ( me . input1 ) . getInput ( ) . get ( 0 ) ; for ( int i = 1 ; ret && i < 3 ; i ++ ) { if ( me . isPlanRef ( i ) ) ret &= HopRewriteUtils . isEqualSize ( refSize , memo . getHopRefs ( ) . get ( me . input ( i ) ) . getInput ( ) . get ( 0 ) ) ; } for ( int i = 0 ; ret && i < 3 ; i ++ ) if ( me . isPlanRef ( i ) ) { HashSet < Long > probe = new HashSet < > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) if ( i != j ) probe . add ( me . input ( j ) ) ; ret &= rCheckMultiAggregate ( memo . getHopRefs ( ) . get ( me . input ( i ) ) , probe ) ; } return ret ; }
deroneriksson/incubator-systemml | private static boolean rCheckMultiAggregate ( Hop current , HashSet < Long > probe ) { boolean ret = true ; for ( Hop c : current . getInput ( ) ) ret &= rCheckMultiAggregate ( c , probe ) ; ret &= ! probe . contains ( current . getHopID ( ) ) ; return ret ; }
deroneriksson/incubator-systemml | private static void rCollectFullAggregates ( Hop current , HashSet < Long > aggs ) { if ( current . isVisited ( ) ) return ; if ( isMultiAggregateRoot ( current ) ) aggs . add ( current . getHopID ( ) ) ; for ( Hop c : current . getInput ( ) ) rCollectFullAggregates ( c , aggs ) ; current . setVisited ( ) ; }
deroneriksson/incubator-systemml | private static void rExtractAggregateInfo ( CPlanMemoTable memo , Hop current , AggregateInfo aggInfo , TemplateType type ) { if ( isMultiAggregateRoot ( current ) ) aggInfo . addInputAggregate ( current . getHopID ( ) ) ; MemoTableEntry me = ( type != null ) ? memo . getBest ( current . getHopID ( ) ) : null ; for ( int i = 0 ; i < current . getInput ( ) . size ( ) ; i ++ ) { Hop c = current . getInput ( ) . get ( i ) ; if ( me != null && me . isPlanRef ( i ) ) rExtractAggregateInfo ( memo , c , aggInfo , type ) ; else { if ( type != null && c . getDataType ( ) . isMatrix ( ) ) aggInfo . addFusedInput ( c . getHopID ( ) ) ; rExtractAggregateInfo ( memo , c , aggInfo , null ) ; } } }
deroneriksson/incubator-systemml | private static HashSet < Long > collectIrreplaceableRowOps ( CPlanMemoTable memo , PlanPartition part ) { HashSet < Long > blacklist = new HashSet < > ( ) ; HashSet < Pair < Long , Integer > > visited = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) { rCollectDependentRowOps ( memo . getHopRefs ( ) . get ( hopID ) , memo , part , blacklist , visited , null , false ) ; } return blacklist ; }
deroneriksson/incubator-systemml | private static void rCollectDependentRowOps ( Hop hop , CPlanMemoTable memo , PlanPartition part , HashSet < Long > blacklist , HashSet < Pair < Long , Integer > > visited , TemplateType type , boolean foundRowOp ) { Pair < Long , Integer > key = Pair . of ( hop . getHopID ( ) , ( foundRowOp ? Short . MAX_VALUE : 0 ) + ( ( type != null ) ? type . ordinal ( ) + 1 : 0 ) ) ; if ( visited . contains ( key ) || ! part . getPartition ( ) . contains ( hop . getHopID ( ) ) ) { return ; } MemoTableEntry me = ( type == null ) ? memo . getBest ( hop . getHopID ( ) ) : memo . getBest ( hop . getHopID ( ) , type ) ; boolean inRow = ( me != null && me . type == TemplateType . ROW && type == TemplateType . ROW ) ; boolean diffPlans = part . getMatPointsExt ( ) . length > 0 && memo . contains ( hop . getHopID ( ) , TemplateType . ROW ) && ! memo . hasOnlyExactMatches ( hop . getHopID ( ) , TemplateType . ROW , TemplateType . CELL ) ; if ( inRow && foundRowOp ) blacklist . add ( hop . getHopID ( ) ) ; if ( isRowAggOp ( hop , inRow ) || diffPlans ) { blacklist . add ( hop . getHopID ( ) ) ; foundRowOp = true ; } for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) { boolean lfoundRowOp = foundRowOp && me != null && ( me . isPlanRef ( i ) || isImplicitlyFused ( hop , i , me . type ) ) ; rCollectDependentRowOps ( hop . getInput ( ) . get ( i ) , memo , part , blacklist , visited , me != null ? me . type : null , lfoundRowOp ) ; } if ( ! blacklist . contains ( hop . getHopID ( ) ) ) { for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) if ( me != null && me . type == TemplateType . ROW && ( me . isPlanRef ( i ) || isImplicitlyFused ( hop , i , me . type ) ) && blacklist . contains ( hop . getInput ( ) . get ( i ) . getHopID ( ) ) ) { blacklist . add ( hop . getHopID ( ) ) ; } } visited . add ( key ) ; }
deroneriksson/incubator-systemml | private static boolean isRowAggOp ( Hop hop , boolean inRow ) { return HopRewriteUtils . isBinary ( hop , OpOp2 . CBIND ) || HopRewriteUtils . isNary ( hop , OpOpN . CBIND ) || ( hop instanceof AggBinaryOp && ( inRow || ! hop . dimsKnown ( ) || ( hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) ) ) || ( HopRewriteUtils . isTransposeOperation ( hop ) && ( hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) && ! HopRewriteUtils . isDataGenOp ( hop . getInput ( ) . get ( 0 ) , DataGenMethod . SEQ ) ) || ( hop instanceof AggUnaryOp && inRow ) ; }
deroneriksson/incubator-systemml | private static boolean isValidRow2CellOp ( Hop hop ) { return ! ( HopRewriteUtils . isBinary ( hop , OpOp2 . CBIND ) || ( hop instanceof AggBinaryOp && hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) ) ; }
deroneriksson/incubator-systemml | private static void pruneInvalidAndSpecialCasePlans ( CPlanMemoTable memo , PlanPartition part ) { if ( OptimizerUtils . isSparkExecutionMode ( ) ) { for ( Long hopID : part . getPartition ( ) ) { if ( ! memo . contains ( hopID , TemplateType . ROW ) ) continue ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; boolean isSpark = ConfigurationManager . getExecutionMode ( ) == RUNTIME_PLATFORM . SPARK || OptimizerUtils . getTotalMemEstimate ( hop . getInput ( ) . toArray ( new Hop [ 0 ] ) , hop , true ) > OptimizerUtils . getLocalMemBudget ( ) ; boolean validNcol = hop . getDataType ( ) . isScalar ( ) || ( HopRewriteUtils . isTransposeOperation ( hop ) ? hop . getDim1 ( ) <= hop . getRowsInBlock ( ) : hop . getDim2 ( ) <= hop . getColsInBlock ( ) ) ; for ( Hop in : hop . getInput ( ) ) validNcol &= in . getDataType ( ) . isScalar ( ) || ( in . getDim2 ( ) <= in . getColsInBlock ( ) ) || ( hop instanceof AggBinaryOp && in . getDim1 ( ) <= in . getRowsInBlock ( ) && HopRewriteUtils . isTransposeOperation ( in ) ) ; if ( isSpark && ! validNcol ) { List < MemoTableEntry > blacklist = memo . get ( hopID , TemplateType . ROW ) ; memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , TemplateType . ROW ) ; memo . removeAllRefTo ( hopID , TemplateType . ROW ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / ▁ violated ▁ blocksize ▁ constraint ▁ ( " + hopID + " ) : ▁ " + Arrays . toString ( blacklist . toArray ( new MemoTableEntry [ 0 ] ) ) ) ; } } } } HashSet < Long > blacklist = collectIrreplaceableRowOps ( memo , part ) ; for ( Long hopID : part . getPartition ( ) ) { if ( blacklist . contains ( hopID ) ) continue ; MemoTableEntry me = memo . getBest ( hopID , TemplateType . ROW ) ; if ( me != null && me . type == TemplateType . ROW && memo . hasOnlyExactMatches ( hopID , TemplateType . ROW , TemplateType . CELL ) ) { List < MemoTableEntry > rmList = memo . get ( hopID , TemplateType . ROW ) ; memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , new HashSet < > ( rmList ) ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / o ▁ aggregation : ▁ " + Arrays . toString ( rmList . toArray ( new MemoTableEntry [ 0 ] ) ) ) ; } } } for ( Long hopID : part . getPartition ( ) ) { if ( memo . countEntries ( hopID , TemplateType . OUTER ) == 2 ) { List < MemoTableEntry > entries = memo . get ( hopID , TemplateType . OUTER ) ; MemoTableEntry me1 = entries . get ( 0 ) ; MemoTableEntry me2 = entries . get ( 1 ) ; MemoTableEntry rmEntry = TemplateOuterProduct . dropAlternativePlan ( memo , me1 , me2 ) ; if ( rmEntry != null ) { memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , Collections . singleton ( rmEntry ) ) ; memo . getPlansBlacklisted ( ) . remove ( rmEntry . input ( rmEntry . getPlanRefIndex ( ) ) ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ dominated ▁ outer ▁ product ▁ memo ▁ table ▁ entry : ▁ " + rmEntry ) ; } } } }
deroneriksson/incubator-systemml | private static void rPruneSuboptimalPlans ( CPlanMemoTable memo , Hop current , HashSet < Long > visited , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan ) { if ( visited . contains ( current . getHopID ( ) ) ) return ; long hopID = current . getHopID ( ) ; if ( part . getPartition ( ) . contains ( hopID ) && memo . contains ( hopID ) ) { Iterator < MemoTableEntry > iter = memo . get ( hopID ) . iterator ( ) ; while ( iter . hasNext ( ) ) { MemoTableEntry me = iter . next ( ) ; if ( ! hasNoRefToMatPoint ( hopID , me , matPoints , plan ) && me . type != TemplateType . OUTER ) { iter . remove ( ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ memo ▁ table ▁ entry : ▁ " + me ) ; } } } for ( Hop c : current . getInput ( ) ) rPruneSuboptimalPlans ( memo , c , visited , part , matPoints , plan ) ; visited . add ( current . getHopID ( ) ) ; }
deroneriksson/incubator-systemml | private static void rPruneInvalidPlans ( CPlanMemoTable memo , Hop current , HashSet < Long > visited , PlanPartition part , boolean [ ] plan ) { if ( visited . contains ( current . getHopID ( ) ) ) return ; for ( Hop c : current . getInput ( ) ) rPruneInvalidPlans ( memo , c , visited , part , plan ) ; long hopID = current . getHopID ( ) ; if ( part . getPartition ( ) . contains ( hopID ) && memo . contains ( hopID , TemplateType . ROW ) ) { Iterator < MemoTableEntry > iter = memo . get ( hopID , TemplateType . ROW ) . iterator ( ) ; while ( iter . hasNext ( ) ) { MemoTableEntry me = iter . next ( ) ; boolean applyLeaf = ( ! me . hasPlanRef ( ) && ! TemplateUtils . hasMatrixInput ( current ) ) ; boolean applyInner = ! applyLeaf && ! ROW_TPL . open ( current ) ; for ( int i = 0 ; i < 3 & applyInner ; i ++ ) if ( me . isPlanRef ( i ) ) applyInner &= ! memo . contains ( me . input ( i ) , TemplateType . ROW ) ; if ( applyLeaf || applyInner ) { String type = applyLeaf ? " leaf " : " inner " ; if ( isValidRow2CellOp ( current ) ) { me . type = TemplateType . CELL ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Converted ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ from ▁ row ▁ to ▁ cell : ▁ " + me ) ; } else { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ row ▁ ( unsupported ▁ cell ) : ▁ " + me ) ; iter . remove ( ) ; } } } } visited . add ( current . getHopID ( ) ) ; }
deroneriksson/incubator-systemml | private static void getComputeCosts ( Hop current , HashMap < Long , Double > computeCosts ) { double costs = 1 ; if ( current instanceof UnaryOp ) { switch ( ( ( UnaryOp ) current ) . getOp ( ) ) { case ABS : case ROUND : case CEIL : case FLOOR : case SIGN : costs = 1 ; break ; case SPROP : case SQRT : costs = 2 ; break ; case EXP : costs = 18 ; break ; case SIGMOID : costs = 21 ; break ; case LOG : case LOG_NZ : costs = 32 ; break ; case NCOL : case NROW : case PRINT : case ASSERT : case CAST_AS_BOOLEAN : case CAST_AS_DOUBLE : case CAST_AS_INT : case CAST_AS_MATRIX : case CAST_AS_SCALAR : costs = 1 ; break ; case SIN : costs = 18 ; break ; case COS : costs = 22 ; break ; case TAN : costs = 42 ; break ; case ASIN : costs = 93 ; break ; case ACOS : costs = 103 ; break ; case ATAN : costs = 40 ; break ; case SINH : costs = 93 ; break ; case COSH : costs = 103 ; break ; case TANH : costs = 40 ; break ; case CUMSUM : case CUMMIN : case CUMMAX : case CUMPROD : costs = 1 ; break ; case CUMSUMPROD : costs = 2 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( UnaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof BinaryOp ) { switch ( ( ( BinaryOp ) current ) . getOp ( ) ) { case MULT : case PLUS : case MINUS : case MIN : case MAX : case AND : case OR : case EQUAL : case NOTEQUAL : case LESS : case LESSEQUAL : case GREATER : case GREATEREQUAL : case CBIND : case RBIND : costs = 1 ; break ; case INTDIV : costs = 6 ; break ; case MODULUS : costs = 8 ; break ; case DIV : costs = 22 ; break ; case LOG : case LOG_NZ : costs = 32 ; break ; case POW : costs = ( HopRewriteUtils . isLiteralOfValue ( current . getInput ( ) . get ( 1 ) , 2 ) ? 1 : 16 ) ; break ; case MINUS_NZ : case MINUS1_MULT : costs = 2 ; break ; case MOMENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof LiteralOp ? HopRewriteUtils . getIntValueSafe ( ( LiteralOp ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 1 ; break ; case 1 : costs = 8 ; break ; case 2 : costs = 16 ; break ; case 3 : costs = 31 ; break ; case 4 : costs = 51 ; break ; case 5 : costs = 16 ; break ; } break ; case COV : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( BinaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof TernaryOp ) { switch ( ( ( TernaryOp ) current ) . getOp ( ) ) { case IFELSE : case PLUS_MULT : case MINUS_MULT : costs = 2 ; break ; case CTABLE : costs = 3 ; break ; case MOMENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof LiteralOp ? HopRewriteUtils . getIntValueSafe ( ( LiteralOp ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 2 ; break ; case 1 : costs = 9 ; break ; case 2 : costs = 17 ; break ; case 3 : costs = 32 ; break ; case 4 : costs = 52 ; break ; case 5 : costs = 17 ; break ; } break ; case COV : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( TernaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof NaryOp ) { costs = HopRewriteUtils . isNary ( current , OpOpN . MIN , OpOpN . MAX ) ? current . getInput ( ) . size ( ) : 1 ; } else if ( current instanceof ParameterizedBuiltinOp ) { costs = 1 ; } else if ( current instanceof IndexingOp ) { costs = 1 ; } else if ( current instanceof ReorgOp ) { costs = 1 ; } else if ( current instanceof DnnOp ) { switch ( ( ( DnnOp ) current ) . getOp ( ) ) { case BIASADD : case BIASMULT : costs = 2 ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( DnnOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof AggBinaryOp ) { costs = 2 * current . getInput ( ) . get ( 0 ) . getDim2 ( ) ; if ( current . getInput ( ) . get ( 0 ) . dimsKnown ( true ) ) costs *= current . getInput ( ) . get ( 0 ) . getSparsity ( ) ; } else if ( current instanceof AggUnaryOp ) { switch ( ( ( AggUnaryOp ) current ) . getOp ( ) ) { case SUM : costs = 4 ; break ; case SUM_SQ : costs = 5 ; break ; case MIN : case MAX : costs = 1 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( AggUnaryOp ) current ) . getOp ( ) ) ; } switch ( ( ( AggUnaryOp ) current ) . getDirection ( ) ) { case Col : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . getDim1 ( ) , 1 ) ; break ; case Row : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . getDim2 ( ) , 1 ) ; break ; case RowCol : costs *= getSize ( current . getInput ( ) . get ( 0 ) ) ; break ; } } costs *= getSize ( current ) ; computeCosts . put ( current . getHopID ( ) , costs ) ; }
deroneriksson/incubator-systemml | private static boolean hasNoRefToMatPoint ( long hopID , MemoTableEntry me , InterestingPoint [ ] M , boolean [ ] plan ) { return ! InterestingPoint . isMatPoint ( M , hopID , me , plan ) ; }
deroneriksson/incubator-systemml | private static boolean isImplicitlyFused ( Hop hop , int index , TemplateType type ) { return type == TemplateType . ROW && HopRewriteUtils . isMatrixMultiply ( hop ) && index == 0 && HopRewriteUtils . isTransposeOperation ( hop . getInput ( ) . get ( index ) ) ; }
deroneriksson/incubator-systemml | private static boolean probePlanCache ( InterestingPoint [ ] matPoints ) { return matPoints . length >= PLAN_CACHE_NUM_POINTS ; }
deroneriksson/incubator-systemml | private static boolean [ ] getPlan ( PartitionSignature pKey ) { boolean [ ] plan = null ; synchronized ( _planCache ) { plan = _planCache . get ( pKey ) ; } if ( ConfigurationManager . isStatistics ( ) ) { if ( plan != null ) Statistics . incrementCodegenPlanCacheHits ( ) ; Statistics . incrementCodegenPlanCacheTotal ( ) ; } return plan ; }
deroneriksson/incubator-systemml | private static void putPlan ( PartitionSignature pKey , boolean [ ] plan ) { synchronized ( _planCache ) { if ( _planCache . size ( ) >= PLAN_CACHE_SIZE ) { Iterator < Entry < PartitionSignature , boolean [ ] > > iter = _planCache . entrySet ( ) . iterator ( ) ; iter . next ( ) ; iter . remove ( ) ; } _planCache . put ( pKey , plan ) ; } }
archos-sa/aos-MediaLib | public static MetaFile2 getMetaFileForUrl ( Uri uri ) throws Exception { if ( " upnp " . equals ( uri . getScheme ( ) ) ) { return UpnpFile2 . fromUri ( uri ) ; } if ( " http " . equals ( uri . getScheme ( ) ) || " https " . equals ( uri . getScheme ( ) ) ) { return HttpFile2 . fromUri ( uri ) ; } else return MetaFile2Factory . getMetaFileForUrl ( uri ) ; }
freeVM/freeVM | public static void run ( File dir , File props ) { new MsgClassGenerator ( ) . generate ( dir , props ) ; }
freeVM/freeVM | private static File getResourceFromJar ( String entryPath , String fileName ) { try { InputStream jis = MsgClassGenerator . class . getClassLoader ( ) . getResourceAsStream ( entryPath + fileName ) ; if ( jis == null ) { logMessage ( " Error : ▁ there ▁ is ▁ no ▁ " + entryPath + fileName + " ▁ in ▁ the ▁ resources ! " ) ; return null ; } File resFile = new File ( fileName ) ; resFile . createNewFile ( ) ; resFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( resFile ) ; byte [ ] data = new byte [ jis . available ( ) ] ; int i ; while ( ( i = jis . read ( data ) ) > 0 ) { fos . write ( data , 0 , i ) ; data = new byte [ jis . available ( ) ] ; } jis . close ( ) ; fos . close ( ) ; return resFile ; } catch ( Exception e ) { logMessage ( " Couldn ' t ▁ extract ▁ resource ! " ) ; e . printStackTrace ( ) ; return null ; } }
freeVM/freeVM | public static void logMessage ( String msg ) { System . out . println ( msg ) ; }
Susankha/developer-studio | public static HTPackage init ( ) { if ( isInited ) return ( HTPackage ) EPackage . Registry . INSTANCE . getEPackage ( HTPackage . eNS_URI ) ; HTPackageImpl theHTPackage = ( HTPackageImpl ) ( EPackage . Registry . INSTANCE . get ( eNS_URI ) instanceof HTPackageImpl ? EPackage . Registry . INSTANCE . get ( eNS_URI ) : new HTPackageImpl ( ) ) ; isInited = true ; XMLNamespacePackage . eINSTANCE . eClass ( ) ; XMLTypePackage . eINSTANCE . eClass ( ) ; theHTPackage . createPackageContents ( ) ; theHTPackage . initializePackageContents ( ) ; theHTPackage . freeze ( ) ; EPackage . Registry . INSTANCE . put ( HTPackage . eNS_URI , theHTPackage ) ; return theHTPackage ; }
arivanajoki/keycloak | public static ClientModel authorizeClient ( String authorizationHeader , MultivaluedMap < String , String > formData , EventBuilder event , RealmModel realm ) { String client_id = null ; String clientSecret = null ; if ( authorizationHeader != null ) { String [ ] usernameSecret = BasicAuthHelper . parseHeader ( authorizationHeader ) ; if ( usernameSecret != null ) { client_id = usernameSecret [ 0 ] ; clientSecret = usernameSecret [ 1 ] ; } else { if ( ! formData . containsKey ( OAuth2Constants . CLIENT_ID ) ) { throw new UnauthorizedException ( " Bad ▁ Authorization ▁ header " , Response . status ( 401 ) . header ( HttpHeaders . WWW_AUTHENTICATE , " Basic ▁ realm = \" " + realm . getName ( ) + " \" " ) . build ( ) ) ; } } } if ( client_id == null ) { client_id = formData . getFirst ( OAuth2Constants . CLIENT_ID ) ; clientSecret = formData . getFirst ( " client _ secret " ) ; } if ( client_id == null ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2Constants . ERROR_DESCRIPTION , " Missing ▁ client _ id ▁ parameter " ) ; throw new BadRequestException ( " Could ▁ not ▁ find ▁ client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } event . client ( client_id ) ; ClientModel client = realm . getClientByClientId ( client_id ) ; if ( client == null ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2Constants . ERROR_DESCRIPTION , " Could ▁ not ▁ find ▁ client " ) ; event . error ( Errors . CLIENT_NOT_FOUND ) ; throw new BadRequestException ( " Could ▁ not ▁ find ▁ client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } if ( ! client . isEnabled ( ) ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2Constants . ERROR_DESCRIPTION , " Client ▁ is ▁ not ▁ enabled " ) ; event . error ( Errors . CLIENT_DISABLED ) ; throw new BadRequestException ( " Client ▁ is ▁ not ▁ enabled " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } if ( ! client . isPublicClient ( ) ) { if ( clientSecret == null || ! client . validateSecret ( clientSecret ) ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " unauthorized _ client " ) ; event . error ( Errors . INVALID_CLIENT_CREDENTIALS ) ; throw new BadRequestException ( " Unauthorized ▁ Client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } } return client ; }
jkandasa/hawkular-java-client | public static Metric < Double > genGaugeDef ( ) { return ( Metric < Double > ) genDef ( MetricType . GAUGE ) ; }
jkandasa/hawkular-java-client | public static Metric < Long > genCounterDef ( ) { return ( Metric < Long > ) genDef ( MetricType . COUNTER ) ; }
jkandasa/hawkular-java-client | public static Metric < AvailabilityType > genAvailDef ( ) { return ( Metric < AvailabilityType > ) genDef ( MetricType . AVAILABILITY ) ; }
jkandasa/hawkular-java-client | public static < T > Metric < ? > genDef ( MetricType < T > metricType ) { MetricId < ? > id = new MetricId < > ( BaseTest . getRandomId ( ) , metricType , BaseTest . getRandomId ( ) ) ; return new Metric < > ( id , TAGS , DATA_RETENTION ) ; }
nicolaferraro/camel | static CordaComponentBuilder corda ( ) { return new CordaComponentBuilderImpl ( ) ; }
c3p0hz/microscope | private static final DefaultFormat DATE_FORMAT = new DefaultFormat ( DateTimeFormat . getFormat ( " yyyy / MM / dd - HH : mm : ss " ) ) { @ Override public Date parse ( final DateBox box , final String text , final boolean report_error ) { if ( text . endsWith ( " ▁ ago " ) || text . endsWith ( " - ago " ) ) { int interval ; final int lastchar = text . length ( ) - 5 ; try { interval = Integer . parseInt ( text . substring ( 0 , lastchar ) ) ; } catch ( NumberFormatException e ) { setError ( box ) ; return null ; } if ( interval <= 0 ) { setError ( box ) ; return null ; } switch ( text . charAt ( lastchar ) ) { case ' s ' : break ; case ' m ' : interval *= 60 ; break ; case ' h ' : interval *= 3600 ; break ; case ' d ' : interval *= 3600 * 24 ; break ; case ' w ' : interval *= 3600 * 24 * 7 ; break ; case ' y ' : interval *= 3600 * 24 * 365 ; break ; } final Date d = new Date ( ) ; d . setTime ( d . getTime ( ) - interval * 1000L ) ; return d ; } else if ( text . length ( ) == 5 ) { try { return HHMM_FORMAT . parse ( text ) ; } catch ( IllegalArgumentException ignored ) { setError ( box ) ; return null ; } } return super . parse ( box , text , report_error ) ; } private void setError ( final DateBox box ) { box . addStyleName ( " dateBoxFormatError " ) ; } }
Kisamegr/Crawler | public static void main ( String [ ] args ) { new Exctractor ( ) ; new Analyzer ( ) ; }
yeastrc/proxl-web-app | public static DB_Insert_UnifiedRepPepIsotopeLabelLookupDAO getInstance ( ) { return new DB_Insert_UnifiedRepPepIsotopeLabelLookupDAO ( ) ; }
adrapereira/jena | @ BeforeClass public static void beforeClass ( ) { RIOT . init ( ) ; }
emory-libraries-ecds/namedropper-oxygen | public static String getGeoNamesUsername ( ) { return PluginOptions . getOption ( SelectionActionGeoNames . GEONAMES_USERNAME ) ; }
emory-libraries-ecds/namedropper-oxygen | public static void setGeoNamesUsername ( String value ) { PluginOptions . setOption ( SelectionActionGeoNames . GEONAMES_USERNAME , value ) ; }
georgewfraser/vscode-javac | private static String testMethodStatic ( ) { return " foo " ; }
Applications-Development/SimpleRssReader | public static < T > T get ( final Context context , final String key , final Class < T > clazz ) { if ( clazz . equals ( String . class ) ) { return ( T ) getSharedPreferences ( context ) . getString ( key , null ) ; } return ( T ) ( Integer ) getSharedPreferences ( context ) . getInt ( key , 0 ) ; }
Applications-Development/SimpleRssReader | public static < T > void put ( final Context context , final String key , @ Nullable final T value ) { final SharedPreferences . Editor preferences = getSharedPreferences ( context ) . edit ( ) ; if ( value == null || value instanceof String ) { preferences . putString ( key , ( String ) value ) ; } else { preferences . putInt ( key , ( Integer ) value ) ; } preferences . apply ( ) ; }
Applications-Development/SimpleRssReader | private static SharedPreferences getSharedPreferences ( final Context context ) { if ( sSharedPreferences == null ) { sSharedPreferences = context . getSharedPreferences ( KEY_SHARED_PREFERENCES , Context . MODE_PRIVATE ) ; } return sSharedPreferences ; }
Applications-Development/SimpleRssReader | private static LinkedListMultimap < String , String > getSubscriptions ( final Context context ) { if ( sSubscriptions == null ) { sSubscriptions = LinkedListMultimap . create ( ) ; final String subscriptions = get ( context , KEY_SUBSCRIPTIONS , String . class ) ; if ( ! TextUtils . isEmpty ( subscriptions ) ) { try { final JSONObject JSON = new JSONObject ( subscriptions ) ; final JSONArray titlesJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_TITLES ) ; final JSONArray categoriesJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_CATEGORIES ) ; final JSONArray idsJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_IDS ) ; final JSONArray urlsJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_URLS ) ; for ( int i = 0 ; i < titlesJSON . length ( ) ; i ++ ) { final String title = titlesJSON . getString ( i ) ; sSubscriptions . put ( title , categoriesJSON . getString ( i ) ) ; sSubscriptions . put ( title , idsJSON . getString ( i ) ) ; sSubscriptions . put ( title , urlsJSON . getString ( i ) ) ; } } catch ( final JSONException e ) { LogUtils . logError ( e ) ; } } } return sSubscriptions ; }
Applications-Development/SimpleRssReader | public static String getSubscriptionTitleAt ( final Context context , final int position ) { final List < String > titles = new ArrayList < > ( getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) ; if ( titles . size ( ) > position ) { return titles . get ( position ) ; } return null ; }
Applications-Development/SimpleRssReader | public static String getSubscriptionIdAt ( final Context context , final int position ) { final String title = getSubscriptionTitleAt ( context , position ) ; if ( ! TextUtils . isEmpty ( title ) ) { return getSubscriptions ( context ) . get ( title ) . get ( 1 ) ; } return null ; }
Applications-Development/SimpleRssReader | public static String getSubscriptionUrlAt ( final Context context , final int position ) { final String title = getSubscriptionTitleAt ( context , position ) ; if ( ! TextUtils . isEmpty ( title ) ) { return getSubscriptions ( context ) . get ( title ) . get ( 2 ) ; } return null ; }
Applications-Development/SimpleRssReader | public static List < String > getSubscriptionTitlesFor ( final Context context , final List < Integer > positions ) { final List < String > titles = new ArrayList < > ( getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) ; final List < String > result = new ArrayList < > ( positions . size ( ) ) ; for ( final int position : positions ) { result . add ( titles . get ( position ) ) ; } return result ; }
Applications-Development/SimpleRssReader | public static List < List < Object > > getSubscriptionsFor ( final Context context , final String newCategory ) { if ( sSubscriptionList == null ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final boolean queryEmpty = TextUtils . isEmpty ( newCategory ) ; sSubscriptionList = new ArrayList < > ( subscriptions . size ( ) ) ; int i = 0 ; for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { final String category = subscriptions . get ( title ) . get ( 0 ) ; if ( queryEmpty || newCategory . equals ( category ) ) { if ( queryEmpty ) { sSubscriptionList . add ( Arrays . < Object > asList ( title , category ) ) ; } else { sSubscriptionList . add ( Arrays . < Object > asList ( title , category , i ) ) ; } } i ++ ; } } return sSubscriptionList ; }
Applications-Development/SimpleRssReader | static List < Object > getSubscriptionsAsOutlines ( final Context context , final boolean retainCategories ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final List < Object > outlines = new ArrayList < > ( subscriptions . size ( ) ) ; final LinkedListMultimap < String , Outline > outlineGroups = LinkedListMultimap . create ( ) ; for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { final String category = subscriptions . get ( title ) . get ( 0 ) ; final String xmlUrl = subscriptions . get ( title ) . get ( 2 ) ; final Outline outline = new Outline . Builder ( ) . setText ( title ) . setTitle ( title ) . setXmlUrl ( xmlUrl ) . build ( ) ; if ( retainCategories ) { outlineGroups . put ( category , outline ) ; } else { outlines . add ( outline ) ; } } if ( retainCategories ) { for ( final String category : outlineGroups . asMap ( ) . keySet ( ) ) { outlines . add ( new OutlineGroup . Builder ( ) . setText ( category ) . setTitle ( category ) . addSubOutlines ( outlineGroups . get ( category ) ) . build ( ) ) ; } } return outlines ; }
Applications-Development/SimpleRssReader | public static String [ ] getSubscriptionCategories ( final Context context , final boolean edit ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final Set < String > categories = new TreeSet < > ( ) ; if ( ! edit ) { categories . add ( context . getString ( R . string . all_categories ) ) ; } else { categories . add ( context . getString ( R . string . clear_category ) ) ; } for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { categories . add ( subscriptions . get ( title ) . get ( 0 ) ) ; } return categories . toArray ( new String [ categories . size ( ) ] ) ; }
Applications-Development/SimpleRssReader | private static int getSubscriptionPositionAfterEdit ( final Context context , final String newTitle ) { int i = 0 ; for ( final String title : getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) { if ( title . equals ( newTitle ) ) { break ; } i ++ ; } return i ; }
Applications-Development/SimpleRssReader | public static int getSubscriptionsCnt ( final Context context ) { return getSubscriptions ( context ) . asMap ( ) . size ( ) ; }
Applications-Development/SimpleRssReader | public static int addSubscription ( final Context context , final String title , final String category , final String url ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final String currentTitle = getCurrentFeedTitle ( context ) ; subscriptions . putAll ( title , Arrays . asList ( category , " " , url ) ) ; saveSubscriptions ( context , subscriptions ) ; return updateCurrentFeedPosition ( context , currentTitle ) ; }
Applications-Development/SimpleRssReader | public static void addSubscriptions ( final Context context , final List outlines ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; for ( final Object outline : outlines ) { if ( outline instanceof Outline ) { final String text = ( ( Outline ) outline ) . getText ( ) ; final String xmlUrl = ( ( Outline ) outline ) . getXmlUrl ( ) ; final String category = context . getString ( R . string . uncategorized ) ; if ( ! TextUtils . isEmpty ( xmlUrl ) && ! TextUtils . isEmpty ( text ) && ! subscriptions . containsKey ( text ) ) { subscriptions . putAll ( text . trim ( ) , Arrays . asList ( category , " " , xmlUrl ) ) ; } } else { for ( final Outline subOutline : ( ( OutlineGroup ) outline ) . getOutlines ( ) ) { final String text = subOutline . getText ( ) ; final String xmlUrl = subOutline . getXmlUrl ( ) ; final String category = ( ( OutlineGroup ) outline ) . getText ( ) ; if ( ! TextUtils . isEmpty ( xmlUrl ) && ! TextUtils . isEmpty ( text ) && ! subscriptions . containsKey ( text ) ) { subscriptions . putAll ( text . trim ( ) , Arrays . asList ( category , " " , xmlUrl ) ) ; } } } } final String currentTitle = getCurrentFeedTitle ( context ) ; saveSubscriptions ( context , subscriptions ) ; updateCurrentFeedPosition ( context , currentTitle ) ; }
Applications-Development/SimpleRssReader | private static void saveSubscriptions ( final Context context , final LinkedListMultimap < String , String > subscriptions ) { if ( subscriptions != null ) { final JSONObject JSON = new JSONObject ( ) ; final JSONArray titlesJSON = new JSONArray ( ) ; final JSONArray categoriesJSON = new JSONArray ( ) ; final JSONArray idsJSON = new JSONArray ( ) ; final JSONArray urlsJSON = new JSONArray ( ) ; final List < String > titles = new ArrayList < > ( subscriptions . asMap ( ) . keySet ( ) ) ; Collections . sort ( titles ) ; for ( final String title : titles ) { final Iterator < String > iter = subscriptions . get ( title ) . iterator ( ) ; titlesJSON . put ( title ) ; categoriesJSON . put ( iter . next ( ) ) ; idsJSON . put ( iter . next ( ) ) ; urlsJSON . put ( iter . next ( ) ) ; } try { JSON . put ( KEY_SUBSCRIPTION_TITLES , titlesJSON ) ; JSON . put ( KEY_SUBSCRIPTION_CATEGORIES , categoriesJSON ) ; JSON . put ( KEY_SUBSCRIPTION_IDS , idsJSON ) ; JSON . put ( KEY_SUBSCRIPTION_URLS , urlsJSON ) ; put ( context , KEY_SUBSCRIPTIONS , JSON . toString ( ) ) ; } catch ( final JSONException e ) { LogUtils . logError ( e ) ; } } else { put ( context , KEY_SUBSCRIPTIONS , null ) ; } sSubscriptions = null ; sSubscriptionList = null ; }
Applications-Development/SimpleRssReader | public static void updateSubscriptionUrl ( final Context context , final String feedUrl ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final int position = getCurrentFeedPosition ( context ) ; final String title = getSubscriptionTitleAt ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; values . set ( 2 , feedUrl ) ; subscriptions . replaceValues ( title , values ) ; saveSubscriptions ( context , subscriptions ) ; }
Applications-Development/SimpleRssReader | public static void updateSubscriptionIdAt ( final Context context , final String id , final int position ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final String title = getSubscriptionTitleAt ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; values . set ( 1 , id ) ; subscriptions . replaceValues ( title , values ) ; saveSubscriptions ( context , subscriptions ) ; }
Applications-Development/SimpleRssReader | public static void updateSubscriptionCategoryTitleAt ( final Context context , final String category , final String newTitle , final int position ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final String title = getSubscriptionTitleAt ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; final boolean newCategory = ! values . get ( 0 ) . equals ( category ) ; if ( newCategory || ! newTitle . equals ( title ) ) { if ( newCategory ) { final List < String > newValues = new ArrayList < > ( subscriptions . removeAll ( title ) ) ; newValues . set ( 0 , category ) ; subscriptions . putAll ( newTitle , newValues ) ; } else { subscriptions . putAll ( newTitle , subscriptions . removeAll ( title ) ) ; } saveSubscriptions ( context , subscriptions ) ; updateCurrentFeedPosition ( context , newTitle ) ; } }
Applications-Development/SimpleRssReader | public static boolean unsubscribe ( final Context context , final List < String > titles ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; if ( subscriptions . asMap ( ) . size ( ) < 2 ) { saveSubscriptions ( context , null ) ; putCurrentFeedPosition ( context , 0 ) ; putPreviousFeedPosition ( context , 0 ) ; return false ; } final String currentTitle = getCurrentFeedTitle ( context ) ; for ( final String title : titles ) { subscriptions . removeAll ( title ) ; } if ( subscriptions . isEmpty ( ) ) { saveSubscriptions ( context , null ) ; putCurrentFeedPosition ( context , 0 ) ; putPreviousFeedPosition ( context , 0 ) ; return false ; } saveSubscriptions ( context , subscriptions ) ; if ( subscriptions . containsKey ( currentTitle ) ) { updateCurrentFeedPosition ( context , currentTitle ) ; return false ; } return true ; }
Applications-Development/SimpleRssReader | public static void invalidateSubscriptionList ( ) { sSubscriptionList = null ; }
Applications-Development/SimpleRssReader | public static boolean isSubscriptionsEmpty ( final Context context ) { return getSubscriptions ( context ) . isEmpty ( ) ; }
Applications-Development/SimpleRssReader | public static SearchResults getSearchResultsFor ( final Context context , final String query , final int position ) { final List < Integer > positions = new ArrayList < > ( ) ; final List < LinkedHashMap < Integer , Integer > > indices = new ArrayList < > ( ) ; int i = 0 ; for ( final String title : getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) { if ( StringUtils . containsIgnoreCase ( title , query ) ) { indices . add ( SearchUtils . getIndicesForQuery ( title , query ) ) ; positions . add ( i ) ; } i ++ ; } return new SearchResults ( position , positions , indices ) ; }
Applications-Development/SimpleRssReader | public static int getCurrentFeedPosition ( final Context context ) { return get ( context , KEY_CURRENT_FEED_POSITION , Integer . class ) ; }
Applications-Development/SimpleRssReader | public static void putCurrentFeedPosition ( final Context context , final int position ) { putPreviousFeedPosition ( context , getCurrentFeedPosition ( context ) ) ; put ( context , KEY_CURRENT_FEED_POSITION , position ) ; }
Applications-Development/SimpleRssReader | private static void putPreviousFeedPosition ( final Context context , final int position ) { put ( context , KEY_PREVIOUS_FEED_POSITION , position ) ; }
Applications-Development/SimpleRssReader | public static int getPreviousFeedPosition ( final Context context ) { return get ( context , KEY_PREVIOUS_FEED_POSITION , Integer . class ) ; }
Applications-Development/SimpleRssReader | private static int updateCurrentFeedPosition ( final Context context , final String title ) { if ( ! TextUtils . isEmpty ( title ) ) { final int position = getSubscriptionPositionAfterEdit ( context , title ) ; putCurrentFeedPosition ( context , position ) ; return position ; } return 0 ; }
Applications-Development/SimpleRssReader | public static String getCurrentFeedUrl ( final Context context ) { return getSubscriptionUrlAt ( context , getCurrentFeedPosition ( context ) ) ; }
Applications-Development/SimpleRssReader | public static String getCurrentFeedTitle ( final Context context ) { return getSubscriptionTitleAt ( context , getCurrentFeedPosition ( context ) ) ; }
leafclick/intellij-community | @ Contract ( " _ ▁ - > ▁ new " ) @ NotNull public static DFAType create ( @ Nullable PsiType type ) { return new DFAType ( type ) ; }
leafclick/intellij-community | private static boolean eq ( PsiType t1 , PsiType t2 ) { return t1 == t2 || Comparing . equal ( TypeConversionUtil . erasure ( t1 ) , TypeConversionUtil . erasure ( t2 ) ) ; }
leafclick/intellij-community | @ NotNull public static DFAType create ( DFAType t1 , DFAType t2 , PsiManager manager ) { if ( t1 . equals ( t2 ) ) return t1 ; final PsiType primary = TypesUtil . getLeastUpperBoundNullable ( t1 . primary , t2 . primary , manager ) ; final DFAType type = new DFAType ( primary ) ; final PsiType type1 = reduce ( t1 . mixins ) ; final PsiType type2 = reduce ( t2 . mixins ) ; if ( type1 != null && type2 != null ) { type . addMixin ( GenericsUtil . getLeastUpperBound ( type1 , type2 , manager ) , null ) ; } return type ; }
leafclick/intellij-community | private static PsiType reduce ( List < Mixin > mixins ) { List < PsiType > types = mixins . stream ( ) . filter ( it -> ! it . myNegated ) . map ( it -> it . myType ) . collect ( toList ( ) ) ; return types . isEmpty ( ) ? null : PsiIntersectionType . createIntersection ( types ) ; }
joinAero/DroidTurbo | public static boolean checkPermissionGranted ( @ NonNull Context context , @ NonNull String permission ) { return ContextCompat . checkSelfPermission ( context , permission ) == PackageManager . PERMISSION_GRANTED ; }
joinAero/DroidTurbo | public static boolean checkPermissionsGranted ( @ NonNull Context context , @ NonNull String ... permissions ) { for ( String permission : permissions ) { if ( ContextCompat . checkSelfPermission ( context , permission ) != PackageManager . PERMISSION_GRANTED ) { return false ; } } return true ; }
joinAero/DroidTurbo | public static boolean shouldPermissionShowRationale ( @ NonNull Activity activity , @ NonNull String permission ) { return ActivityCompat . shouldShowRequestPermissionRationale ( activity , permission ) ; }
joinAero/DroidTurbo | public static boolean shouldPermissionsShowRationale ( @ NonNull Activity activity , @ NonNull String ... permissions ) { for ( String permission : permissions ) { if ( ActivityCompat . shouldShowRequestPermissionRationale ( activity , permission ) ) { return true ; } } return false ; }
joinAero/DroidTurbo | public static boolean verifyPermission ( int [ ] grantResults ) { return grantResults . length == 1 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ; }
joinAero/DroidTurbo | public static boolean verifyPermissions ( int [ ] grantResults ) { if ( grantResults . length < 1 ) { return false ; } for ( int result : grantResults ) { if ( result != PackageManager . PERMISSION_GRANTED ) { return false ; } } return true ; }
poornan/product-is | public static List < KeyValue > extractDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { String [ ] tokens = line . split ( " ' " ) ; KeyValue keyValue = new KeyValue ( key , tokens [ keyPositionMap . get ( key ) ] ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractInputValueFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " value = \" ( \\ S + ) \" " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractLabelValueFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " > ( \\ S + ) < / label > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractTableRowDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { boolean lineReached = false ; List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { lineReached = true ; continue ; } if ( lineReached ) { if ( line . contains ( " < td > " ) ) { Pattern p = Pattern . compile ( " < td > ( \\ S + ) < / td > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractSessionConsentDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { boolean lineReached = false ; List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { lineReached = true ; } if ( lineReached ) { if ( line . contains ( " value " ) ) { String [ ] tokens = line . split ( " \" " ) ; KeyValue keyValue = new KeyValue ( key , tokens [ 1 ] ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static String extractAccessTokenFromQueryString ( String query ) { String [ ] params = query . split ( " & " ) ; for ( String param : params ) { String name = param . split ( " = " ) [ 0 ] ; String value = param . split ( " = " ) [ 1 ] ; if ( name . contains ( " access _ token " ) ) return value ; } return null ; }
poornan/product-is | public static String getContentData ( HttpResponse response ) throws IOException { BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; StringBuffer result = new StringBuffer ( ) ; while ( ( line = rd . readLine ( ) ) != null ) { result = result . append ( line ) ; } rd . close ( ) ; return result . toString ( ) ; }
gustavoanatoly/flink | public static DataStream < Tuple3 < Integer , Long , String > > getSmall3TupleDataSet ( StreamExecutionEnvironment env ) { List < Tuple3 < Integer , Long , String > > data = new ArrayList < > ( ) ; data . add ( new Tuple3 < > ( 1 , 1L , " Hi " ) ) ; data . add ( new Tuple3 < > ( 2 , 2L , " Hello " ) ) ; data . add ( new Tuple3 < > ( 3 , 2L , " Hello ▁ world " ) ) ; Collections . shuffle ( data ) ; return env . fromCollection ( data ) ; }
gustavoanatoly/flink | public static DataStream < Tuple5 < Integer , Long , Integer , String , Long > > get5TupleDataStream ( StreamExecutionEnvironment env ) { List < Tuple5 < Integer , Long , Integer , String , Long > > data = new ArrayList < > ( ) ; data . add ( new Tuple5 < > ( 1 , 1L , 0 , " Hallo " , 1L ) ) ; data . add ( new Tuple5 < > ( 2 , 2L , 1 , " Hallo ▁ Welt " , 2L ) ) ; data . add ( new Tuple5 < > ( 2 , 3L , 2 , " Hallo ▁ Welt ▁ wie " , 1L ) ) ; data . add ( new Tuple5 < > ( 3 , 4L , 3 , " Hallo ▁ Welt ▁ wie ▁ gehts ? " , 2L ) ) ; data . add ( new Tuple5 < > ( 3 , 5L , 4 , " ABC " , 2L ) ) ; data . add ( new Tuple5 < > ( 3 , 6L , 5 , " BCD " , 3L ) ) ; data . add ( new Tuple5 < > ( 4 , 7L , 6 , " CDE " , 2L ) ) ; data . add ( new Tuple5 < > ( 4 , 8L , 7 , " DEF " , 1L ) ) ; data . add ( new Tuple5 < > ( 4 , 9L , 8 , " EFG " , 1L ) ) ; data . add ( new Tuple5 < > ( 4 , 10L , 9 , " FGH " , 2L ) ) ; data . add ( new Tuple5 < > ( 5 , 11L , 10 , " GHI " , 1L ) ) ; data . add ( new Tuple5 < > ( 5 , 12L , 11 , " HIJ " , 3L ) ) ; data . add ( new Tuple5 < > ( 5 , 13L , 12 , " IJK " , 3L ) ) ; data . add ( new Tuple5 < > ( 5 , 15L , 14 , " KLM " , 2L ) ) ; data . add ( new Tuple5 < > ( 5 , 14L , 13 , " JKL " , 2L ) ) ; return env . fromCollection ( data ) ; }
nobry/karuta-backend | public static java . sql . Timestamp toSQLTimestamp ( ZonedDateTime dt ) { java . sql . Timestamp ts = ( dt == null ? null : new java . sql . Timestamp ( dt . toInstant ( ) . toEpochMilli ( ) ) ) ; return ts ; }
nobry/karuta-backend | public static java . util . Date toJavaDate ( ZonedDateTime dt ) { java . util . Date ts = ( dt == null ? null : new java . util . Date ( dt . toInstant ( ) . toEpochMilli ( ) ) ) ; return ts ; }
nobry/karuta-backend | public static String toTimeZoneID ( ZonedDateTime dt ) { String s = ( dt == null ? null : dt . getZone ( ) . getId ( ) ) ; return s ; }
nobry/karuta-backend | public static java . sql . Date toSQLDate ( LocalDate ld ) { java . sql . Date d = ( ld == null ? null : new java . sql . Date ( ld . atStartOfDay ( paris ) . toInstant ( ) . toEpochMilli ( ) ) ) ; return d ; }
nobry/karuta-backend | public static java . util . Date toJavaDate ( LocalDate ld ) { java . util . Date d = ( ld == null ? null : Date . from ( ld . atStartOfDay ( paris ) . toInstant ( ) ) ) ; return d ; }
nobry/karuta-backend | public static String toString ( LocalDate ld ) { String s = ( ld == null ? null : localDateFormatter . withZone ( ZoneId . of ( " UTC " ) ) . format ( ld ) ) ; return s ; }
nobry/karuta-backend | public static java . sql . Timestamp toSQLTimestamp ( LocalDateTime ldt ) { java . sql . Timestamp ts = ( ldt == null ? null : Timestamp . valueOf ( ldt ) ) ; return ts ; }
nobry/karuta-backend | public static java . util . Date toJavaDate ( LocalDateTime ldt ) { java . util . Date d = ( ldt == null ? null : Date . from ( ldt . atZone ( paris ) . toInstant ( ) ) ) ; return d ; }
nobry/karuta-backend | public static java . sql . Time toSQLTime ( LocalTime lt ) { java . sql . Time t = ( lt == null ? null : Time . valueOf ( lt ) ) ; return t ; }
nobry/karuta-backend | public static Long toNanoSecond ( LocalTime lt ) { Long i = ( lt == null ? null : new Long ( lt . toNanoOfDay ( ) ) ) ; return i ; }
nobry/karuta-backend | public static String toString ( LocalTime lt ) { String s = ( lt == null ? null : lt . toString ( ) ) ; return s ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . sql . Date d ) { ZonedDateTime dm = ( d == null ? null : d . toLocalDate ( ) . atStartOfDay ( paris ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . util . Date d ) { ZonedDateTime dm = ( d == null ? null : toLocalDate ( d ) . atStartOfDay ( paris ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . sql . Date d , String timeZoneID ) { ZonedDateTime dm = ( d == null ? null : d . toLocalDate ( ) . atStartOfDay ( ZoneId . of ( timeZoneID ) ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . util . Date d , String timeZoneID ) { ZonedDateTime dm = ( d == null ? null : toLocalDate ( d ) . atStartOfDay ( ZoneId . of ( timeZoneID ) ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . sql . Timestamp ts ) { ZonedDateTime dt = ( ts == null ? null : ZonedDateTime . ofInstant ( ts . toInstant ( ) , paris ) ) ; return dt ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . util . Date d ) { ZonedDateTime dt = ( d == null ? null : ZonedDateTime . ofInstant ( d . toInstant ( ) , paris ) ) ; return dt ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . sql . Timestamp ts , String timeZoneID ) { ZonedDateTime dt = ( ts == null ? null : ZonedDateTime . ofInstant ( ts . toInstant ( ) , ZoneId . of ( timeZoneID ) ) ) ; return dt ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . util . Date d , String timeZoneID ) { ZonedDateTime dt = ( d == null ? null : ZonedDateTime . ofInstant ( d . toInstant ( ) , ZoneId . of ( timeZoneID ) ) ) ; return dt ; }
nobry/karuta-backend | public static LocalDate toLocalDate ( java . sql . Date d ) { LocalDate ld = ( d == null ? null : d . toLocalDate ( ) ) ; return ld ; }
nobry/karuta-backend | public static LocalDate toLocalDate ( java . util . Date d ) { LocalDate ld = ( d == null ? null : d . toInstant ( ) . atZone ( paris ) . toLocalDate ( ) ) ; return ld ; }
nobry/karuta-backend | public static LocalDate toLocalDate ( String s ) { LocalDate ld = ( s == null ? null : LocalDate . parse ( s , localDateFormatter . withZone ( ZoneId . of ( " UTC " ) ) ) ) ; return ld ; }
nobry/karuta-backend | public static LocalDateTime toLocalDateTime ( java . sql . Timestamp ts ) { LocalDateTime ldt = ( ts == null ? null : ts . toLocalDateTime ( ) ) ; return ldt ; }
nobry/karuta-backend | public static LocalDateTime toLocalDateTime ( java . util . Date d ) { LocalDateTime ldt = ( d == null ? null : d . toInstant ( ) . atZone ( paris ) . toLocalDateTime ( ) ) ; return ldt ; }
nobry/karuta-backend | public static LocalTime toLocalTime ( java . sql . Time t ) { LocalTime lt = ( t == null ? null : t . toInstant ( ) . atZone ( ZoneId . of ( " UTC " ) ) . toLocalTime ( ) ) ; return lt ; }
nobry/karuta-backend | public static LocalTime toLocalTime ( Long i ) { LocalTime lt = ( i == null ? null : LocalTime . ofNanoOfDay ( i ) ) ; return lt ; }
nobry/karuta-backend | public static LocalTime toLocalTime ( String s ) { LocalTime lt = ( s == null ? null : LocalTime . parse ( s ) ) ; return lt ; }
nobry/karuta-backend | public static void main ( String [ ] args ) { System . out . println ( " ▁ " ) ; test_dateTime ( ) ; System . out . println ( " ▁ " ) ; test_dateTime_tz ( ) ; System . out . println ( " ▁ " ) ; test_localDate ( ) ; System . out . println ( " ▁ " ) ; test_localDate_tz ( ) ; System . out . println ( " ▁ " ) ; test_localDateTime ( ) ; System . out . println ( " ▁ " ) ; test_localDate_shift_java_tz ( ) ; System . out . println ( " ▁ " ) ; test_localTime_as_integer ( ) ; System . out . println ( " ▁ " ) ; test_localTime_as_string ( ) ; System . out . println ( " ▁ " ) ; }
nobry/karuta-backend | public static void test_dateTime ( ) { System . out . println ( " Test ▁ ZonedDateTime " ) ; ZonedDateTime dt1 = ZonedDateTime . now ( ) ; java . sql . Timestamp ts = toSQLTimestamp ( dt1 ) ; ZonedDateTime dt2 = toDateTime ( ts ) ; System . out . println ( " ZonedDateTime ▁ 1 ▁ = ▁ " + dt1 ) ; System . out . println ( " Timestamp ▁ ▁ = ▁ " + ts ) ; System . out . println ( " ZonedDateTime ▁ 2 ▁ = ▁ " + dt2 ) ; if ( ! dt2 . equals ( dt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_dateTime_tz ( ) { System . out . println ( " Test ▁ ZonedDateTime ▁ with ▁ timezone " ) ; ZonedDateTime dt1 = ZonedDateTime . now ( losAngeles ) ; java . sql . Timestamp ts = toSQLTimestamp ( dt1 ) ; String tzID = toTimeZoneID ( dt1 ) ; ZonedDateTime dt2 = toDateTime ( ts , tzID ) ; System . out . println ( " ZonedDateTime ▁ 1 ▁ = ▁ " + dt1 ) ; System . out . println ( " Timestamp ▁ ▁ = ▁ " + ts ) ; System . out . println ( " TimeZoneID ▁ = ▁ " + tzID ) ; System . out . println ( " ZonedDateTime ▁ 2 ▁ = ▁ " + dt2 ) ; if ( ! dt2 . equals ( dt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDate ( ) { System . out . println ( " Test ▁ LocalDate " ) ; LocalDate ld1 = LocalDate . now ( ) ; java . sql . Date d = toSQLDate ( ld1 ) ; LocalDate ld2 = toLocalDate ( d ) ; System . out . println ( " LocalDate ▁ 1 ▁ = ▁ " + ld1 ) ; System . out . println ( " Date ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + d ) ; System . out . println ( " LocalDate ▁ 2 ▁ = ▁ " + ld2 ) ; if ( ! ld2 . equals ( ld1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDate_tz ( ) { System . out . println ( " Test ▁ LocalDate ▁ with ▁ timezone " ) ; LocalDate ld1 = LocalDate . now ( losAngeles ) ; java . sql . Date d = toSQLDate ( ld1 ) ; LocalDate ld2 = toLocalDate ( d ) ; System . out . println ( " LocalDate ▁ 1 ▁ = ▁ " + ld1 ) ; System . out . println ( " Date ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + d ) ; System . out . println ( " LocalDate ▁ 2 ▁ = ▁ " + ld2 ) ; if ( ! ld2 . equals ( ld1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDate_shift_java_tz ( ) { System . out . println ( " Test ▁ LocalDate ▁ with ▁ shifted ▁ Java ▁ timezone " ) ; TimeZone originalTZ = TimeZone . getDefault ( ) ; TimeZone losAngelesTZ = TimeZone . getTimeZone ( " America / Los _ Angeles " ) ; TimeZone . setDefault ( losAngelesTZ ) ; LocalDate ld1 = LocalDate . now ( ) ; System . out . println ( " ld1 ▁ LocalDate ( ) ▁ ▁ ▁ = ▁ " + ld1 + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; java . sql . Date d = toSQLDate ( ld1 ) ; System . out . println ( " d ▁ toSQLDate ( ld1 ) ▁ ▁ = ▁ " + d + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; TimeZone . setDefault ( originalTZ ) ; System . out . println ( " d ▁ toSQLDate ( ld1 ) ▁ ▁ = ▁ " + d + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; LocalDate ld2 = toLocalDate ( d ) ; System . out . println ( " ld2 ▁ toLocalDate ( d ) ▁ = ▁ " + ld2 + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; TimeZone . setDefault ( originalTZ ) ; if ( ! ld2 . equals ( ld1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDateTime ( ) { System . out . println ( " Test ▁ LocalDateTime " ) ; LocalDateTime ldt1 = LocalDateTime . now ( ) ; java . sql . Timestamp ts = toSQLTimestamp ( ldt1 ) ; LocalDateTime ldt2 = toLocalDateTime ( ts ) ; System . out . println ( " LocalDateTime ▁ 1 ▁ = ▁ " + ldt1 ) ; System . out . println ( " Timestamp ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + ts ) ; System . out . println ( " LocalDateTime ▁ 2 ▁ = ▁ " + ldt2 ) ; if ( ! ldt2 . equals ( ldt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localTime_as_integer ( ) { System . out . println ( " Test ▁ LocalTime ▁ as ▁ Integer " ) ; LocalTime lt1 = LocalTime . now ( ) ; Long i = toNanoSecond ( lt1 ) ; LocalTime lt2 = toLocalTime ( i ) ; System . out . println ( " LocalTime ▁ 1 ▁ = ▁ " + lt1 ) ; System . out . println ( " Integer ▁ ▁ ▁ ▁ ▁ = ▁ " + i ) ; System . out . println ( " LocalTime ▁ 2 ▁ = ▁ " + lt2 ) ; if ( ! lt2 . equals ( lt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localTime_as_string ( ) { System . out . println ( " Test ▁ LocalTime ▁ as ▁ String " ) ; LocalTime lt1 = LocalTime . now ( ) ; String t = toString ( lt1 ) ; LocalTime lt2 = toLocalTime ( t ) ; System . out . println ( " LocalTime ▁ 1 ▁ = ▁ " + lt1 ) ; System . out . println ( " String ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + t ) ; System . out . println ( " LocalTime ▁ 2 ▁ = ▁ " + lt2 ) ; if ( ! lt2 . equals ( lt1 ) ) { throw new IllegalStateException ( ) ; } }
tdelev/MULLAN | public static void main ( String [ ] argv ) { runFilter ( new ClassOrder ( ) , argv ) ; }
Alex-Diez/Java-TDD-Katas | private static final Set < Character > LEGAL_NUMBER_CHAR = new HashSet < Character > ( ) { { add ( '0' ) ; add ( '1' ) ; add ( '2' ) ; add ( '3' ) ; add ( '4' ) ; add ( '5' ) ; add ( '6' ) ; add ( '7' ) ; add ( '8' ) ; add ( '9' ) ; add ( ' . ' ) ; } }
Alex-Diez/Java-TDD-Katas | public static double calculate ( String source ) { Chars chars = new Chars ( source ) ; return parseExpression ( chars ) ; }
Alex-Diez/Java-TDD-Katas | private static double parseExpression ( Chars chars ) { double term = parseTerm ( chars ) ; while ( chars . hasNext ( ) ) { char c = chars . peek ( ) ; if ( c == ' + ' ) { chars . next ( ) ; term += parseTerm ( chars ) ; } else if ( c == ' - ' ) { chars . next ( ) ; term -= parseTerm ( chars ) ; } else { break ; } } return term ; }
Alex-Diez/Java-TDD-Katas | private static double parseTerm ( Chars chars ) { double arg = parseArg ( chars ) ; while ( chars . hasNext ( ) ) { char c = chars . peek ( ) ; if ( c == ' × ' ) { chars . next ( ) ; arg *= parseArg ( chars ) ; } else if ( c == ' ÷ ' ) { chars . next ( ) ; arg /= parseArg ( chars ) ; } else { break ; } } return arg ; }
Alex-Diez/Java-TDD-Katas | private static double parseArg ( Chars chars ) { int start = chars . index ( ) ; while ( chars . hasNext ( ) && LEGAL_NUMBER_CHAR . contains ( chars . peek ( ) ) ) { chars . next ( ) ; } int end = chars . index ( ) ; return Double . parseDouble ( chars . subString ( start , end ) ) ; }
jentfoo/aws-sdk-java | public static StartSchemaExtensionRequestMarshaller getInstance ( ) { return instance ; }
DLotts/incubator-rya | public static Bytes spoFormat ( final RyaStatement triple ) throws TripleRowResolverException { checkNotNull ( triple ) ; final Map < TABLE_LAYOUT , TripleRow > serialized = TRIPLE_RESOLVER . serialize ( triple ) ; final TripleRow spoRow = serialized . get ( TABLE_LAYOUT . SPO ) ; return addTriplePrefixAndConvertToBytes ( spoRow . getRow ( ) ) ; }
PeterASteele/CodeForcesSolutions | public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; int cases = in . nextInt ( ) ; for ( int q = 0 ; q < cases ; q ++ ) { int n = in . nextInt ( ) ; int [ ] arr1 = new int [ n ] ; int [ ] arr2 = new int [ n ] ; HashSet < Integer > set = new HashSet < Integer > ( ) ; for ( int a = 0 ; a < n ; a ++ ) { arr1 [ a ] = in . nextInt ( ) ; } for ( int a = 0 ; a < n ; a ++ ) { arr2 [ a ] = in . nextInt ( ) ; } int start = 1 ; int end = 1 ; StringBuilder out = new StringBuilder ( ) ; for ( int a = 0 ; a < n ; a ++ ) { addRemoveSet ( arr1 [ a ] , set ) ; addRemoveSet ( arr2 [ a ] , set ) ; if ( set . size ( ) == 0 ) { out . append ( start + " - " + end + " ▁ " ) ; start = end + 1 ; end = start ; } else { end ++ ; } } System . out . println ( out ) ; } }
PeterASteele/CodeForcesSolutions | public static void addRemoveSet ( int i , HashSet < Integer > set ) { if ( set . contains ( i ) ) { set . remove ( i ) ; } else { set . add ( i ) ; } }
castagna/jax-rs-example | @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { client = Client . create ( ) ; }
castagna/jax-rs-example | @ AfterClass public static void tearDownAfterClass ( ) throws Exception { if ( client != null ) { client . destroy ( ) ; client = null ; } }
gygesM/test | public static void main ( String [ ] args ) { PageData pd = new PageData ( ) ; pd . put ( " username " , " zhangsan " ) ; checkParam ( " registered " , pd ) ; }
gygesM/test | public static boolean checkParam ( String method , PageData pd ) { boolean result = false ; int falseCount = 0 ; String [ ] paramArray = new String [ 20 ] ; String [ ] valueArray = new String [ 20 ] ; String [ ] tempArray = new String [ 20 ] ; if ( method == " registered " ) { paramArray = Const . APP_REGISTERED_PARAM_ARRAY ; valueArray = Const . APP_REGISTERED_VALUE_ARRAY ; } else if ( method == " getAppuserByUsernmae " ) { paramArray = Const . APP_GETAPPUSER_PARAM_ARRAY ; valueArray = Const . APP_GETAPPUSER_VALUE_ARRAY ; } int size = paramArray . length ; for ( int i = 0 ; i < size ; i ++ ) { String param = paramArray [ i ] ; if ( ! pd . containsKey ( param ) ) { tempArray [ falseCount ] = valueArray [ i ] + " - - " + param ; falseCount += 1 ; } } if ( falseCount > 0 ) { logger . error ( method + " 接口 ， 请求协议中缺少 ▁ " + falseCount + " 个 ▁ 参数 " ) ; for ( int j = 1 ; j <= falseCount ; j ++ ) { logger . error ( " ▁ ▁ ▁ 第 " + j + " 个 ： " + tempArray [ j - 1 ] ) ; } } else { result = true ; } return result ; }
gygesM/test | public static PageData setPageParam ( PageData pd ) { String page_now_str = pd . get ( " page _ now " ) . toString ( ) ; int pageNowInt = Integer . parseInt ( page_now_str ) - 1 ; String page_size_str = pd . get ( " page _ size " ) . toString ( ) ; int pageSizeInt = Integer . parseInt ( page_size_str ) ; String page_now = pageNowInt + " " ; String page_start = ( pageNowInt * pageSizeInt ) + " " ; pd . put ( " page _ now " , page_now ) ; pd . put ( " page _ start " , page_start ) ; return pd ; }
gygesM/test | public static List < PageData > setListDistance ( List < PageData > list , PageData pd ) { List < PageData > listReturn = new ArrayList < PageData > ( ) ; String user_longitude = " " ; String user_latitude = " " ; try { user_longitude = pd . get ( " user _ longitude " ) . toString ( ) ; user_latitude = pd . get ( " user _ latitude " ) . toString ( ) ; } catch ( Exception e ) { logger . error ( " 缺失参数 - - user _ longitude和user _ longitude " ) ; logger . error ( " lost ▁ param ： user _ longitude ▁ and ▁ user _ longitude " ) ; } PageData pdTemp = new PageData ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { pdTemp = list . get ( i ) ; String longitude = pdTemp . get ( " longitude " ) . toString ( ) ; String latitude = pdTemp . get ( " latitude " ) . toString ( ) ; String distance = MapDistance . getDistance ( user_longitude , user_latitude , longitude , latitude ) ; pdTemp . put ( " distance " , distance ) ; pdTemp . put ( " size " , distance . length ( ) ) ; listReturn . add ( pdTemp ) ; } return listReturn ; }
gygesM/test | public static Object returnObject ( PageData pd , Map map ) { if ( pd . containsKey ( " callback " ) ) { String callback = pd . get ( " callback " ) . toString ( ) ; return new JSONPObject ( callback , map ) ; } else { return map ; } }
JSDemos/android-sdk-20 | private static boolean checkKeysEqual ( PublicKey pk1 , PublicKey pk2 ) { String format1 = pk1 . getFormat ( ) ; String format2 ; if ( ( pk2 == null ) || ( ( ( format2 = pk2 . getFormat ( ) ) != null ) ^ ( format1 != null ) ) || ( ( format1 != null ) && ! format1 . equals ( format2 ) ) ) { return false ; } return Arrays . equals ( pk1 . getEncoded ( ) , pk2 . getEncoded ( ) ) ; }
somi92/sqldbb | public static void testEntityProcessorAndQueryBuilders ( ) { ClassD d = new ClassD ( 41 , " d1" ) ; ClassC c = new ClassC ( 31 , 3 ) ; ClassB b = new ClassB ( 21 , " b1" , c ) ; ClassA a = new ClassA ( 11 , 111 , " a1" , b , d ) ; ClassF f = new ClassF ( ) ; DatabaseEntity dbe1 = EntityProcessor . createEntity ( a . getClass ( ) ) ; EntityProcessor . printEntity ( dbe1 ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; QueryBuilder qb = new QueryBuilder ( new SelectQueryBuilder ( true ) ) ; qb . buildQuery ( dbe1 ) ; Query query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new UpdateQueryBuilder ( ) ) ; qb . buildQuery ( dbe1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new InsertQueryBuilder ( ) ) ; qb . buildQuery ( dbe1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new DeleteQueryBuilder ( false ) ) ; qb . buildQuery ( dbe1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; }
somi92/sqldbb | public static void testEntityLoading ( ) throws SQLException { ClassD d = new ClassD ( ) ; d . setD1 ( 44 ) ; ClassC c = new ClassC ( ) ; c . setC1 ( 32 ) ; ClassB b = new ClassB ( ) ; b . setB1 ( 21 ) ; ClassA a = new ClassA ( ) ; a . setA1 ( 11 ) ; a . setA11 ( 111 ) ; Object [ ] loaded = new Object [ 4 ] ; loaded [ 0 ] = broker . loadEntity ( d , false ) ; loaded [ 1 ] = broker . loadEntity ( c , false ) ; loaded [ 2 ] = broker . loadEntity ( b , false ) ; loaded [ 3 ] = broker . loadEntity ( a , false ) ; System . out . println ( " " ) ; for ( Object o : loaded ) { System . out . println ( o ) ; } }
somi92/sqldbb | public static void testComplexKeys ( ) throws SQLException { ClassCD loaded = new ClassCD ( ) ; loaded . setC ( new ClassC ( 31 , 0 ) ) ; loaded . setD ( new ClassD ( 44 , null ) ) ; loaded = broker . loadEntity ( loaded , false ) ; System . out . println ( loaded ) ; }
somi92/sqldbb | public static void testInsert ( ) { try { ClassD d1 = new ClassD ( 41 , null ) ; ClassD d2 = new ClassD ( 43 , null ) ; ClassD d3 = new ClassD ( 45 , null ) ; ClassB b1 = new ClassB ( 21 , null , null ) ; ClassB b2 = new ClassB ( 23 , null , null ) ; ClassA a1 = new ClassA ( 14 , 114 , " a4 - b3 - d5" , b2 , d3 ) ; ClassA a2 = new ClassA ( 15 , 115 , " a5 - b1 - d3" , b1 , d2 ) ; ClassA a3 = new ClassA ( 16 , 116 , " a6 - b3 - d1" , b2 , d1 ) ; List < ClassA > list = new ArrayList < > ( ) ; list . add ( a1 ) ; list . add ( a2 ) ; list . add ( a3 ) ; ClassA a4 = new ClassA ( 17 , 117 , " a6 - b3 - d1" , b2 , d1 ) ; broker . insertEntity ( a4 ) ; broker . commitTransaction ( ) ; System . out . println ( " Inserting ▁ entities ▁ successful . " ) ; } catch ( SQLException ex ) { broker . rollbackTransaction ( ) ; System . out . println ( " Inserting ▁ entities ▁ - ▁ transaction ▁ rollback : ▁ " + ex . getMessage ( ) ) ; } }
somi92/sqldbb | public static void testCollections ( ) throws SQLException { ClassF f = new ClassF ( ) ; f . setF2 ( " F1" ) ; List < String > search = new ArrayList < > ( ) ; search . add ( " f2" ) ; List < ClassF > loadedF = broker . loadEntities ( f , null , true ) ; for ( ClassF fe : loadedF ) { System . out . println ( fe ) ; } }
somi92/sqldbb | public static void testTypes ( ) { try { TypesTesting tt = new TypesTesting ( ) ; tt . setL ( 1000 ) ; TypesTesting loaded = broker . loadEntity ( tt , false ) ; System . out . println ( loaded ) ; broker . commitTransaction ( ) ; System . out . println ( " Types ▁ testing ▁ - ▁ OK ! " ) ; } catch ( SQLException ex ) { broker . rollbackTransaction ( ) ; System . out . println ( " Types ▁ testing ▁ - ▁ Error : ▁ " + ex . getMessage ( ) ) ; } }
thiagosena/Halligator | public static TextureContainer < TiledTextureRegion > produce ( final Texture texture , final Context context , final String assetPath , final int texturePositionX , final int texturePositionY , final int tileColumns , final int tileRows ) { return new TextureContainer < TiledTextureRegion > ( TextureRegionFactory . createTiledFromAsset ( texture , context , assetPath , texturePositionX , texturePositionY , tileColumns , tileRows ) , getPixels ( assetPath , context , tileColumns , tileRows ) , assetPath ) ; }
thiagosena/Halligator | public static TextureContainer < TextureRegion > produce ( final Texture texture , final Context context , final String assetPath , final int texturePositionX , final int texturePositionY ) { return new TextureContainer < TextureRegion > ( TextureRegionFactory . createFromAsset ( texture , context , assetPath , texturePositionX , texturePositionY ) , getPixels ( assetPath , context , 1 , 1 ) , assetPath ) ; }
thiagosena/Halligator | private static boolean [ ] [ ] getPixels ( final String assetPath , final Context context , final int tileColumns , final int tileRows ) { final Bitmap bitmap = getBitmap ( assetPath , context ) ; if ( bitmap == null ) { return null ; } final int xOffset = bitmap . getWidth ( ) / tileColumns ; final int yOffset = bitmap . getHeight ( ) / tileRows ; final boolean [ ] [ ] pixels = new boolean [ xOffset ] [ yOffset ] ; for ( int x = 0 ; x < xOffset ; x ++ ) { for ( int y = 0 ; y < yOffset ; y ++ ) { pixels [ x ] [ y ] = bitmap . getPixel ( x , y ) == Color . TRANSPARENT ? ALPHA : PIXEL ; } } return pixels ; }
thiagosena/Halligator | private static Bitmap getBitmap ( final String assetPath , final Context context ) { InputStream stream = null ; Bitmap bitmap = null ; try { stream = context . getAssets ( ) . open ( HalligatorActivity . GRAPHIC_ASSETS_PATH + assetPath ) ; bitmap = BitmapFactory . decodeStream ( stream ) ; } catch ( IOException e ) { Log . e ( " TextureContainerProvider " , " Exception " , e ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { Log . e ( " TextureContainerProvider " , " Exception " , e ) ; } } return bitmap ; }
PrismTech/agentv | public static void insert ( org . omg . CORBA . Any a , com . prismtech . agentv . core . types . UpgradeMicrosvc that ) { org . omg . CORBA . portable . OutputStream out = a . create_output_stream ( ) ; a . type ( type ( ) ) ; write ( out , that ) ; a . read_value ( out . create_input_stream ( ) , type ( ) ) ; }
PrismTech/agentv | public static com . prismtech . agentv . core . types . UpgradeMicrosvc extract ( org . omg . CORBA . Any a ) { return read ( a . create_input_stream ( ) ) ; }
PrismTech/agentv | synchronized public static org . omg . CORBA . TypeCode type ( ) { if ( __typeCode == null ) { synchronized ( org . omg . CORBA . TypeCode . class ) { if ( __typeCode == null ) { if ( __active ) { return org . omg . CORBA . ORB . init ( ) . create_recursive_tc ( _id ) ; } __active = true ; org . omg . CORBA . StructMember [ ] _members0 = new org . omg . CORBA . StructMember [ 3 ] ; org . omg . CORBA . TypeCode _tcOf_members0 = null ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_string_tc ( 0 ) ; _members0 [ 0 ] = new org . omg . CORBA . StructMember ( " microsvc " , _tcOf_members0 , null ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . get_primitive_tc ( org . omg . CORBA . TCKind . tk_boolean ) ; _members0 [ 1 ] = new org . omg . CORBA . StructMember ( " backup " , _tcOf_members0 , null ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . get_primitive_tc ( org . omg . CORBA . TCKind . tk_octet ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_sequence_tc ( 0 , _tcOf_members0 ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_alias_tc ( com . prismtech . agentv . core . types . ByteSeqHelper . id ( ) , " ByteSeq " , _tcOf_members0 ) ; _members0 [ 2 ] = new org . omg . CORBA . StructMember ( " payload " , _tcOf_members0 , null ) ; __typeCode = org . omg . CORBA . ORB . init ( ) . create_struct_tc ( com . prismtech . agentv . core . types . UpgradeMicrosvcHelper . id ( ) , " UpgradeMicrosvc " , _members0 ) ; __active = false ; } } } return __typeCode ; }
PrismTech/agentv | public static String id ( ) { return _id ; }
PrismTech/agentv | public static com . prismtech . agentv . core . types . UpgradeMicrosvc read ( org . omg . CORBA . portable . InputStream istream ) { com . prismtech . agentv . core . types . UpgradeMicrosvc value = new com . prismtech . agentv . core . types . UpgradeMicrosvc ( ) ; value . microsvc = istream . read_string ( ) ; value . backup = istream . read_boolean ( ) ; value . payload = com . prismtech . agentv . core . types . ByteSeqHelper . read ( istream ) ; return value ; }
PrismTech/agentv | public static void write ( org . omg . CORBA . portable . OutputStream ostream , com . prismtech . agentv . core . types . UpgradeMicrosvc value ) { ostream . write_string ( value . microsvc ) ; ostream . write_boolean ( value . backup ) ; com . prismtech . agentv . core . types . ByteSeqHelper . write ( ostream , value . payload ) ; }
emag/wildfly-swarm | public static void main ( final String [ ] args ) throws Exception { try { generateSwarmJar ( args ) ; } catch ( ExitException e ) { final String msg = e . getMessage ( ) ; if ( msg != null ) { System . err . println ( msg ) ; } if ( e . printHelp ) { if ( msg != null ) { System . err . println ( ) ; } System . err . println ( String . format ( " Usage : ▁ % s ▁ < options > ▁ artifact - path \n " , executableName ( ) ) ) ; try { OPT_PARSER . printHelpOn ( System . err ) ; } catch ( IOException ignored ) { } } System . exit ( e . status ) ; } }
emag/wildfly-swarm | protected static String executableName ( ) { String name = System . getenv ( " SWARMTOOL _ NAME " ) ; if ( name == null ) { name = " java ▁ - jar ▁ swarmtool - standalone . jar " ; } return name ; }
emag/wildfly-swarm | protected static File generateSwarmJar ( final String [ ] args ) throws Exception { OptionSet foundOptions = null ; try { foundOptions = OPT_PARSER . parse ( args ) ; } catch ( OptionException e ) { exit ( e . getMessage ( ) , true ) ; } if ( foundOptions . has ( HELP_OPT ) ) { exit ( null , 0 , true ) ; } if ( foundOptions . has ( VERSION_OPT ) ) { exit ( " swarmtool ▁ v " + VERSION , 0 ) ; } final List < File > nonOptArgs = foundOptions . valuesOf ( SOURCE_OPT ) ; if ( nonOptArgs . isEmpty ( ) ) { exit ( " No ▁ source ▁ artifact ▁ specified . " , true ) ; } if ( nonOptArgs . size ( ) > 1 ) { exit ( " Too ▁ many ▁ source ▁ artifacts ▁ provided ▁ ( " + nonOptArgs + " ) " , true ) ; } final File source = nonOptArgs . get ( 0 ) ; if ( ! source . exists ( ) ) { exit ( " File ▁ " + source . getAbsolutePath ( ) + " ▁ does ▁ not ▁ exist . " ) ; } final Properties properties = new Properties ( ) ; if ( foundOptions . has ( SYSPROPS_FILE_OPT ) ) { try ( InputStream in = new FileInputStream ( foundOptions . valueOf ( SYSPROPS_FILE_OPT ) ) ) { properties . load ( in ) ; } } foundOptions . valuesOf ( SYSPROPS_OPT ) . forEach ( prop -> { final String [ ] parts = prop . split ( " = " ) ; properties . put ( parts [ 0 ] , parts [ 1 ] ) ; } ) ; final DeclaredDependencies dependencies = new DeclaredDependencies ( ) ; foundOptions . valuesOf ( DEPENDENCIES_OPT ) . stream ( ) . map ( DeclaredDependencies :: createSpec ) . forEach ( dependencies :: add ) ; final String [ ] parts = source . getName ( ) . split ( " \\ . ( ? = [ ^ \\ . ] + $ ) " ) ; final String baseName = parts [ 0 ] ; final String type = parts [ 1 ] == null ? " jar " : parts [ 1 ] ; final String jarName = foundOptions . has ( NAME_OPT ) ? foundOptions . valueOf ( NAME_OPT ) : baseName ; final String outDir = new File ( foundOptions . valueOf ( OUTPUT_DIR_OPT ) ) . getCanonicalPath ( ) ; final String suffix = foundOptions . has ( HOLLOW_OPT ) ? " - hollow - swarm " : " - swarm " ; final BuildTool tool = new BuildTool ( getResolvingHelper ( foundOptions . valuesOf ( REPOS_OPT ) ) ) . projectArtifact ( " " , baseName , " " , type , source ) . declaredDependencies ( dependencies ) . fractionDetectionMode ( foundOptions . has ( DISABLE_AUTO_DETECT_OPT ) ? BuildTool . FractionDetectionMode . never : BuildTool . FractionDetectionMode . force ) . bundleDependencies ( ! foundOptions . has ( DISABLE_BUNDLE_DEPS_OPT ) ) . executable ( foundOptions . has ( EXECUTABLE_OPT ) ) . properties ( properties ) . hollow ( foundOptions . has ( HOLLOW_OPT ) ) ; if ( foundOptions . has ( MAIN_OPT ) ) { tool . mainClass ( foundOptions . valueOf ( MAIN_OPT ) ) ; } if ( foundOptions . has ( MODULES_OPT ) ) { tool . additionalModules ( foundOptions . valuesOf ( MODULES_OPT ) ) ; } if ( foundOptions . has ( DEBUG_LOGGING ) ) { tool . logger ( BuildTool . STD_LOGGER_WITH_DEBUG ) ; } addSwarmFractions ( tool , foundOptions . valuesOf ( FRACTIONS_OPT ) ) ; System . err . println ( String . format ( " Building ▁ % s / % s - % s . jar " , outDir , jarName , suffix ) ) ; return tool . build ( jarName , Paths . get ( outDir ) ) ; }
emag/wildfly-swarm | private static void exit ( String message ) { exit ( message , 1 ) ; }
emag/wildfly-swarm | private static void exit ( String message , boolean printHelp ) { exit ( message , 1 , printHelp ) ; }
emag/wildfly-swarm | private static void exit ( String message , int code ) { exit ( message , code , false ) ; }
emag/wildfly-swarm | private static void exit ( String message , int code , boolean printHelp ) { throw new ExitException ( code , printHelp , message ) ; }
emag/wildfly-swarm | private static ArtifactResolvingHelper getResolvingHelper ( final List < String > repos ) { final ConfigurableMavenResolverSystem resolver = Maven . configureResolver ( ) . withMavenCentralRepo ( true ) . withRemoteRepo ( MavenRemoteRepositories . createRemoteRepository ( " jboss - public - repository - group " , " https : // repository . jboss . org / nexus / content / groups / public / " , " default " ) . setChecksumPolicy ( MavenChecksumPolicy . CHECKSUM_POLICY_IGNORE ) . setUpdatePolicy ( MavenUpdatePolicy . UPDATE_POLICY_NEVER ) ) ; repos . forEach ( r -> resolver . withRemoteRepo ( MavenRemoteRepositories . createRemoteRepository ( r , r , " default " ) . setChecksumPolicy ( MavenChecksumPolicy . CHECKSUM_POLICY_IGNORE ) . setUpdatePolicy ( MavenUpdatePolicy . UPDATE_POLICY_NEVER ) ) ) ; return new ShrinkwrapArtifactResolvingHelper ( resolver ) ; }
emag/wildfly-swarm | private static void addSwarmFractions ( BuildTool tool , final List < String > deps ) { deps . stream ( ) . map ( f -> f . split ( " : " ) ) . map ( parts -> { switch ( parts . length ) { case 1 : final FractionDescriptor desc = FractionList . get ( ) . getFractionDescriptor ( " org . wildfly . swarm " , parts [ 0 ] ) ; if ( desc != null ) { return desc ; } else { System . err . println ( " Warning : ▁ Unknown ▁ fraction : ▁ " + parts [ 0 ] ) ; return null ; } case 2 : return new FractionDescriptor ( " org . wildfly . swarm " , parts [ 0 ] , parts [ 1 ] ) ; case 3 : return new FractionDescriptor ( parts [ 0 ] , parts [ 1 ] , parts [ 2 ] ) ; default : System . err . println ( " Warning : ▁ Invalid ▁ fraction ▁ specifier : ▁ " + String . join ( " : " , parts ) ) ; return null ; } } ) . filter ( f -> f != null ) . forEach ( f -> tool . fraction ( ArtifactSpec . fromFractionDescriptor ( f ) ) ) ; }
Esjob-Cloud-DevOps/elastic-job | public static void reset ( ) { completed = false ; }
aehlig/bazel | public static LabelLateBoundDefault < ? > getAndroidSdkLabel ( Label androidSdk ) { return LabelLateBoundDefault . fromTargetConfiguration ( AndroidConfiguration . class , androidSdk , ( rule , attributes , configuration ) -> configuration . getSdk ( ) ) ; }
aehlig/bazel | private static void setCrosstoolToAndroid ( BuildOptions options ) { AndroidConfiguration . Options androidOptions = options . get ( AndroidConfiguration . Options . class ) ; CppOptions cppOptions = options . get ( CppOptions . class ) ; if ( androidOptions . androidCrosstoolTop != null ) { cppOptions . crosstoolTop = androidOptions . androidCrosstoolTop ; } androidOptions . configurationDistinguisher = ConfigurationDistinguisher . ANDROID ; }
aehlig/bazel | public static boolean hasProguardSpecs ( AttributeMap rule ) { return rule . isConfigurable ( " proguard _ specs " ) || ! rule . get ( " proguard _ specs " , LABEL_LIST ) . isEmpty ( ) ; }
aehlig/bazel | public static final SafeImplicitOutputsFunction ANDROID_BINARY_IMPLICIT_OUTPUTS = new SafeImplicitOutputsFunction ( ) { @ Override public Iterable < String > getImplicitOutputs ( EventHandler eventHandler , AttributeMap rule ) { List < SafeImplicitOutputsFunction > functions = Lists . newArrayList ( ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_APK ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_UNSIGNED_APK ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_DEPLOY_JAR ) ; if ( hasProguardSpecs ( rule ) ) { functions . add ( AndroidRuleClasses . ANDROID_BINARY_PROGUARD_JAR ) ; functions . add ( JavaSemantics . JAVA_BINARY_PROGUARD_CONFIG ) ; if ( ProguardHelper . genProguardMapping ( rule ) ) { functions . add ( JavaSemantics . JAVA_BINARY_PROGUARD_MAP ) ; } } return fromFunctions ( functions ) . getImplicitOutputs ( eventHandler , rule ) ; } }
aehlig/bazel | public static final SafeImplicitOutputsFunction ANDROID_LIBRARY_IMPLICIT_OUTPUTS = new SafeImplicitOutputsFunction ( ) { @ Override public Iterable < String > getImplicitOutputs ( EventHandler eventHandler , AttributeMap attributes ) { ImmutableList . Builder < SafeImplicitOutputsFunction > implicitOutputs = ImmutableList . builder ( ) ; implicitOutputs . add ( AndroidRuleClasses . ANDROID_LIBRARY_class_JAR , AndroidRuleClasses . ANDROID_LIBRARY_SOURCE_JAR , AndroidRuleClasses . ANDROID_LIBRARY_AAR ) ; if ( AndroidResources . definesAndroidResources ( attributes ) ) { implicitOutputs . add ( AndroidRuleClasses . ANDROID_JAVA_SOURCE_JAR , AndroidRuleClasses . ANDROID_R_TXT , AndroidRuleClasses . ANDROID_RESOURCES_class_JAR ) ; } return fromFunctions ( implicitOutputs . build ( ) ) . getImplicitOutputs ( eventHandler , attributes ) ; } }
aehlig/bazel | public static MultidexMode fromValue ( String value ) { for ( MultidexMode mode : values ( ) ) { if ( mode . getAttributeValue ( ) . equals ( value ) ) { return mode ; } } return null ; }
aehlig/bazel | public static List < String > getValidValues ( ) { List < String > ans = Lists . newArrayList ( ) ; for ( MultidexMode mode : MultidexMode . values ( ) ) { ans . add ( mode . getAttributeValue ( ) ) ; } return ans ; }
