 private static double getWrite@@ Cost ( Collection < Long > R , CP@@ lan@@ Memo@@ Table memo ) { double costs = 0 ; for ( Long hop@@ ID : R ) { Hop hop = memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) ; costs += getSize ( hop ) * 8 / WRITE_@@ B@@ AND@@ WIDTH_@@ MEM ; } return costs ; }
 private static void prun@@ e@@ Invalid@@ And@@ Special@@ Case@@ Plan@@ s ( CP@@ lan@@ Memo@@ Table memo , Plan@@ Partition part ) { if ( Optimizer@@ Utils . is@@ Spark@@ Execution@@ Mode ( ) ) { for ( Long hop@@ ID : part . get@@ Partition ( ) ) { if ( ! memo . contains ( hop@@ ID , Template@@ Type . ROW ) ) continue ; Hop hop = memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) ; boolean is@@ Spark = Configuration@@ Manager . getExecution@@ Mode ( ) == RUNTIME_@@ PLATFORM . SPAR@@ K || Optimizer@@ Utils . getTotal@@ Mem@@ Estimate ( hop . getInput ( ) . toArray ( new Hop [ 0 ] ) , hop , true ) > Optimizer@@ Utils . getLocal@@ Mem@@ Bud@@ get ( ) ; boolean valid@@ N@@ col = hop . getDataType ( ) . is@@ Scalar ( ) || ( Hop@@ Rewrite@@ Utils . is@@ Transpo@@ se@@ Operation ( hop ) ? hop . get@@ Di@@ m1 ( ) <= hop . getRow@@ sIn@@ Block ( ) : hop . get@@ Di@@ m2 ( ) <= hop . getCol@@ sIn@@ Block ( ) ) ; for ( Hop in : hop . getInput ( ) ) valid@@ N@@ col &= in . getDataType ( ) . is@@ Scalar ( ) || ( in . get@@ Di@@ m2 ( ) <= in . getCol@@ sIn@@ Block ( ) ) || ( hop instanceof Agg@@ Binary@@ Op && in . get@@ Di@@ m1 ( ) <= in . getRow@@ sIn@@ Block ( ) && Hop@@ Rewrite@@ Utils . is@@ Transpo@@ se@@ Operation ( in ) ) ; if ( is@@ Spark && ! valid@@ N@@ col ) { List < Memo@@ TableEntry > blacklist = memo . get ( hop@@ ID , Template@@ Type . ROW ) ; memo . remove ( memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) , Template@@ Type . ROW ) ; memo . removeAll@@ Ref@@ To ( hop@@ ID , Template@@ Type . ROW ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / ▁ viol@@ ated ▁ blocksize ▁ constraint ▁ ( " + hop@@ ID + " ) : ▁ " + Arrays . toString ( blacklist . toArray ( new Memo@@ TableEntry [ 0 ] ) ) ) ; } } } } HashSet < Long > blacklist = collect@@ Ir@@ replace@@ able@@ Row@@ Ops ( memo , part ) ; for ( Long hop@@ ID : part . get@@ Partition ( ) ) { if ( blacklist . contains ( hop@@ ID ) ) continue ; Memo@@ TableEntry me = memo . get@@ Best ( hop@@ ID , Template@@ Type . ROW ) ; if ( me != null && me . type == Template@@ Type . ROW && memo . has@@ Only@@ Exact@@ Matches ( hop@@ ID , Template@@ Type . ROW , Template@@ Type . CELL ) ) { List < Memo@@ TableEntry > rm@@ List = memo . get ( hop@@ ID , Template@@ Type . ROW ) ; memo . remove ( memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) , new HashSet < > ( rm@@ List ) ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / o ▁ aggregation : ▁ " + Arrays . toString ( rm@@ List . toArray ( new Memo@@ TableEntry [ 0 ] ) ) ) ; } } } for ( Long hop@@ ID : part . get@@ Partition ( ) ) { if ( memo . count@@ Entries ( hop@@ ID , Template@@ Type . OUTER ) == 2 ) { List < Memo@@ TableEntry > entries = memo . get ( hop@@ ID , Template@@ Type . OUTER ) ; Memo@@ TableEntry me@@ 1 = entries . get ( 0 ) ; Memo@@ TableEntry me@@ 2 = entries . get ( 1 ) ; Memo@@ TableEntry rm@@ Entry = Template@@ Outer@@ Product . drop@@ Alternative@@ Plan ( memo , me@@ 1 , me@@ 2 ) ; if ( rm@@ Entry != null ) { memo . remove ( memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) , Collections . singleton ( rm@@ Entry ) ) ; memo . get@@ Pl@@ ans@@ Black@@ listed ( ) . remove ( rm@@ Entry . input ( rm@@ Entry . get@@ Plan@@ Ref@@ Index ( ) ) ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ domin@@ ated ▁ outer ▁ product ▁ memo ▁ table ▁ entry : ▁ " + rm@@ Entry ) ; } } } }
 public static Database@@ Model create@@ Model@@ From@@ XML ( File xml@@ File ) { Database@@ Model model = new Database@@ Model ( ) ; DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; try { DocumentBuilder builder = dbf . new@@ DocumentBuilder ( ) ; Document dom = builder . parse ( xml@@ File ) ; Element doc@@ Element = dom . getDocument@@ Element ( ) ; NodeList property@@ Groups = doc@@ Element . getElementsByTagName ( " Properties " ) ; if ( property@@ Groups . getLength ( ) == 0 ) return null ; for ( int i = 0 ; i < property@@ Groups . getLength ( ) ; i ++ ) { Element property@@ List = ( Element ) property@@ Groups . item ( i ) ; NodeList properties = property@@ List . getChildNodes ( ) ; for ( int j = 0 ; j < properties . getLength ( ) ; j ++ ) { if ( properties . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element property@@ Elem = ( Element ) properties . item ( j ) ; Database@@ Property property@@ Template = parse@@ Property@@ Template ( property@@ Elem ) ; model . add@@ Property@@ To@@ Database ( property@@ Template ) ; } } NodeList item@@ Groups = doc@@ Element . getElementsByTagName ( " Items " ) ; if ( item@@ Groups . getLength ( ) == 0 ) return null ; Map < String , Database@@ Item > item@@ Map = new HashMap < String , Database@@ Item > ( ) ; for ( int i = 0 ; i < item@@ Groups . getLength ( ) ; i ++ ) { Element itemList = ( Element ) item@@ Groups . item ( i ) ; NodeList items = itemList . getChildNodes ( ) ; for ( int j = 0 ; j < items . getLength ( ) ; j ++ ) { if ( items . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element item@@ Elem = ( Element ) items . item ( j ) ; Database@@ Item item = parse@@ Item ( item@@ Elem ) ; model . add@@ Item@@ To@@ Database ( item ) ; item@@ Map . put ( item . getName ( ) , item ) ; } } for ( Database@@ Item item : model . getItem@@ List ( ) ) { item . resolve@@ Name@@ sTo@@ Items ( item@@ Map ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return model ; }
 public static Offset@@ DateTime get@@ Creation@@ Time ( Object entity ) { try { Method id@@ Method = entity . getClass ( ) . getMethod ( " getId " ) ; if ( id@@ Method . getReturnType ( ) != String . class ) { J@@ DA@@ Impl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } String obj@@ Id = ( String ) id@@ Method . invoke ( entity ) ; return get@@ Creation@@ Time ( obj@@ Id ) ; } catch ( Exception e ) { J@@ DA@@ Impl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } }
 private static void r@@ Collect@@ Dependent@@ Row@@ Ops ( Hop hop , CP@@ lan@@ Memo@@ Table memo , Plan@@ Partition part , HashSet < Long > blacklist , HashSet < Pair < Long , Integer > > visited , Template@@ Type type , boolean found@@ Row@@ Op ) { Pair < Long , Integer > key = Pair . of ( hop . getH@@ op@@ ID ( ) , ( found@@ Row@@ Op ? Short . MAX_VALUE : 0 ) + ( ( type != null ) ? type . ordinal ( ) + 1 : 0 ) ) ; if ( visited . contains ( key ) || ! part . get@@ Partition ( ) . contains ( hop . getH@@ op@@ ID ( ) ) ) { return ; } Memo@@ TableEntry me = ( type == null ) ? memo . get@@ Best ( hop . getH@@ op@@ ID ( ) ) : memo . get@@ Best ( hop . getH@@ op@@ ID ( ) , type ) ; boolean in@@ Row = ( me != null && me . type == Template@@ Type . ROW && type == Template@@ Type . ROW ) ; boolean diff@@ Plan@@ s = part . get@@ Mat@@ Points@@ Ext ( ) . length > 0 && memo . contains ( hop . getH@@ op@@ ID ( ) , Template@@ Type . ROW ) && ! memo . has@@ Only@@ Exact@@ Matches ( hop . getH@@ op@@ ID ( ) , Template@@ Type . ROW , Template@@ Type . CELL ) ; if ( in@@ Row && found@@ Row@@ Op ) blacklist . add ( hop . getH@@ op@@ ID ( ) ) ; if ( is@@ Row@@ Agg@@ Op ( hop , in@@ Row ) || diff@@ Plan@@ s ) { blacklist . add ( hop . getH@@ op@@ ID ( ) ) ; found@@ Row@@ Op = true ; } for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) { boolean l@@ found@@ Row@@ Op = found@@ Row@@ Op && me != null && ( me . is@@ Plan@@ Ref ( i ) || is@@ Implicit@@ ly@@ F@@ used ( hop , i , me . type ) ) ; r@@ Collect@@ Dependent@@ Row@@ Ops ( hop . getInput ( ) . get ( i ) , memo , part , blacklist , visited , me != null ? me . type : null , l@@ found@@ Row@@ Op ) ; } if ( ! blacklist . contains ( hop . getH@@ op@@ ID ( ) ) ) { for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) if ( me != null && me . type == Template@@ Type . ROW && ( me . is@@ Plan@@ Ref ( i ) || is@@ Implicit@@ ly@@ F@@ used ( hop , i , me . type ) ) && blacklist . contains ( hop . getInput ( ) . get ( i ) . getH@@ op@@ ID ( ) ) ) { blacklist . add ( hop . getH@@ op@@ ID ( ) ) ; } } visited . add ( key ) ; }
 private static void assert@@ Table@@ Columns@@ Equal ( List < TableColumn > actual , List < TableColumn > expected ) { assertEquals ( actual . size ( ) , expected . size ( ) ) ; for ( int i = 0 ; i < actual . size ( ) ; i ++ ) { assert@@ Table@@ Column@@ Equal ( actual . get ( i ) , expected . get ( i ) ) ; } }
 private static boolean probe@@ Plan@@ Cache ( Interest@@ ing@@ Point [ ] mat@@ Points ) { return mat@@ Points . length >= PL@@ AN_@@ CACHE_@@ NUM_@@ POINTS ; }
 @ AfterClass public static void delete@@ Original@@ FSI@@ mage ( ) throws IOException { if ( original@@ F@@ si@@ mage != null && original@@ F@@ si@@ mage . exists ( ) ) { original@@ F@@ si@@ mage . delete ( ) ; } }
 private static void exit ( String message , int code ) { exit ( message , code , false ) ; }
 public static synchronized Simple@@ Hive@@ Conn@@ Manager getInstance ( ) { if ( instance == null ) { instance = new Simple@@ Hive@@ Conn@@ Manager ( ) ; } clients ++ ; return instance ; }
 private static < T > T get ( final Request@@ Future < T > future ) throws IOException { T response ; try { response = future . get ( ) ; } catch ( final Exception e ) { throw new IOException ( e ) ; } return response ; }
 private static void put@@ Plan ( Partition@@ Signature pKey , boolean [ ] plan ) { synchronized ( _@@ plan@@ Cache ) { if ( _@@ plan@@ Cache . size ( ) >= PL@@ AN_@@ CACHE_@@ SIZE ) { Iterator < Entry < Partition@@ Signature , boolean [ ] > > iter = _@@ plan@@ Cache . entrySet ( ) . iterator ( ) ; iter . next ( ) ; iter . remove ( ) ; } _@@ plan@@ Cache . put ( pKey , plan ) ; } }
 public static Element getChild ( UI@@ Object parent , String s@@ Css@@ Class ) { Element child = null ; NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int i@@ Node = 0 ; i@@ Node < list . getLength ( ) ; i@@ Node ++ ) { Element e = list . getItem ( i@@ Node ) ; if ( ( e . getClassName ( ) ) . contains ( s@@ Css@@ Class ) ) { child = e ; break ; } } return ( child ) ; }
 public static String getContent@@ Data ( HttpResponse response ) throws IOException { BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; StringBuffer result = new StringBuffer ( ) ; while ( ( line = rd . readLine ( ) ) != null ) { result = result . append ( line ) ; } rd . close ( ) ; return result . toString ( ) ; }
 private static void assert@@ Throws ( String message , Throw@@ ing@@ Runnable runnable ) { try { runnable . run ( ) ; fail ( " expected ▁ exception " ) ; } catch ( Throwable t ) { assertEquals ( t . getMessage ( ) , message ) ; } }
 public static void main ( String [ ] args ) { Spring@@ Application . run ( SpringBoot@@ Actu@@ ator@@ Application . class , args ) ; }
 private static double sum@@ Compute@@ Cost ( HashMap < Long , Double > compute@@ Co@@ sts ) { return compute@@ Co@@ sts . values ( ) . stream ( ) . mapTo@@ Double ( d -> d / COMP@@ UTE_@@ B@@ AND@@ WIDTH ) . sum ( ) ; }
 public static CSS@@ Injector getC@@ SS@@ Injector ( ) { return ( css@@ Injector ) ; }
 private static Database@@ Item parse@@ Item ( Element item@@ Elem ) { String itemName = item@@ Elem . getAttribute ( " name " ) ; Database@@ Item item = new Database@@ Item ( itemName ) ; NodeList item@@ Properties = item@@ Elem . getChildNodes ( ) ; for ( int i = 0 ; i < item@@ Properties . getLength ( ) ; i ++ ) { if ( item@@ Properties . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element property@@ Elem = ( Element ) item@@ Properties . item ( i ) ; Database@@ Property property = parse@@ Full@@ Property ( property@@ Elem ) ; item . addProperty ( property . getName ( ) , property ) ; } return item ; }
 protected static File generate@@ S@@ warm@@ Jar ( final String [ ] args ) throws Exception { Option@@ Set found@@ Options = null ; try { found@@ Options = OPT_@@ PARSER . parse ( args ) ; } catch ( Option@@ Exception e ) { exit ( e . getMessage ( ) , true ) ; } if ( found@@ Options . has ( HELP_@@ OPT ) ) { exit ( null , 0 , true ) ; } if ( found@@ Options . has ( VERSION_@@ OPT ) ) { exit ( " s@@ war@@ mt@@ ool ▁ v " + VERSION , 0 ) ; } final List < File > non@@ Opt@@ Args = found@@ Options . values@@ Of ( SOURCE_@@ OPT ) ; if ( non@@ Opt@@ Args . isEmpty ( ) ) { exit ( " No ▁ source ▁ artifact ▁ specified . " , true ) ; } if ( non@@ Opt@@ Args . size ( ) > 1 ) { exit ( " Too ▁ many ▁ source ▁ artifacts ▁ provided ▁ ( " + non@@ Opt@@ Args + " ) " , true ) ; } final File source = non@@ Opt@@ Args . get ( 0 ) ; if ( ! source . exists ( ) ) { exit ( " File ▁ " + source . getAbsolutePath ( ) + " ▁ does ▁ not ▁ exist . " ) ; } final Properties properties = new Properties ( ) ; if ( found@@ Options . has ( SY@@ SPRO@@ PS_@@ FILE_@@ OPT ) ) { try ( InputStream in = new FileInputStream ( found@@ Options . valueOf ( SY@@ SPRO@@ PS_@@ FILE_@@ OPT ) ) ) { properties . load ( in ) ; } } found@@ Options . values@@ Of ( SY@@ SPRO@@ PS_@@ OPT ) . forEach ( prop -> { final String [ ] parts = prop . split ( " = " ) ; properties . put ( parts [ 0 ] , parts [ 1 ] ) ; } ) ; final Declared@@ Dependencies dependencies = new Declared@@ Dependencies ( ) ; found@@ Options . values@@ Of ( DEPEND@@ ENCI@@ ES_@@ OPT ) . stream ( ) . map ( Declared@@ Dependencies :: create@@ Spec ) . forEach ( dependencies :: add ) ; final String [ ] parts = source . getName ( ) . split ( " \\ . ( ? = [ ^ \\ . ] + $ ) " ) ; final String baseName = parts [ 0 ] ; final String type = parts [ 1 ] == null ? " jar " : parts [ 1 ] ; final String jar@@ Name = found@@ Options . has ( NAME_@@ OPT ) ? found@@ Options . valueOf ( NAME_@@ OPT ) : baseName ; final String outDir = new File ( found@@ Options . valueOf ( OUTPUT_@@ DIR_@@ OPT ) ) . getCanonical@@ Path ( ) ; final String suffix = found@@ Options . has ( HOL@@ LOW_@@ OPT ) ? " - hol@@ low - s@@ warm " : " - s@@ warm " ; final Build@@ Tool tool = new Build@@ Tool ( get@@ Resol@@ ving@@ Helper ( found@@ Options . values@@ Of ( RE@@ POS_@@ OPT ) ) ) . project@@ Artifact ( " " , baseName , " " , type , source ) . declared@@ Dependencies ( dependencies ) . fraction@@ Detection@@ Mode ( found@@ Options . has ( DISABLE_@@ AUTO_@@ DETE@@ CT_@@ OPT ) ? Build@@ Tool . Fraction@@ Detection@@ Mode . never : Build@@ Tool . Fraction@@ Detection@@ Mode . force ) . bundle@@ Dependencies ( ! found@@ Options . has ( DISABLE_@@ BUNDLE_@@ DEP@@ S_@@ OPT ) ) . executable ( found@@ Options . has ( EXECU@@ TABLE_@@ OPT ) ) . properties ( properties ) . hol@@ low ( found@@ Options . has ( HOL@@ LOW_@@ OPT ) ) ; if ( found@@ Options . has ( MAIN_@@ OPT ) ) { tool . main@@ Class ( found@@ Options . valueOf ( MAIN_@@ OPT ) ) ; } if ( found@@ Options . has ( MODUL@@ ES_@@ OPT ) ) { tool . additional@@ Modules ( found@@ Options . values@@ Of ( MODUL@@ ES_@@ OPT ) ) ; } if ( found@@ Options . has ( DEBUG_@@ LOGGING ) ) { tool . logger ( Build@@ Tool . STD_@@ LOGGER_@@ WITH_@@ DEBUG ) ; } add@@ S@@ warm@@ Fr@@ actions ( tool , found@@ Options . values@@ Of ( FR@@ ACTION@@ S_@@ OPT ) ) ; System . err . println ( String . format ( " Building ▁ % s / % s - % s . jar " , outDir , jar@@ Name , suffix ) ) ; return tool . build ( jar@@ Name , Paths . get ( outDir ) ) ; }
 public static Bytes spo@@ Format ( final R@@ ya@@ Statement triple ) throws Triple@@ Row@@ Resolver@@ Exception { checkNotNull ( triple ) ; final Map < TABLE_@@ LAYOUT , Triple@@ Row > serialized = TR@@ IP@@ LE_@@ RESOL@@ VER . serialize ( triple ) ; final Triple@@ Row spo@@ Row = serialized . get ( TABLE_@@ LAYOUT . SP@@ O ) ; return add@@ Triple@@ Prefix@@ And@@ ConvertTo@@ Bytes ( spo@@ Row . getRow ( ) ) ; }
 private static void exit ( String message ) { exit ( message , 1 ) ; }
 private static void r@@ Prun@@ e@@ Invalid@@ Plan@@ s ( CP@@ lan@@ Memo@@ Table memo , Hop current , HashSet < Long > visited , Plan@@ Partition part , boolean [ ] plan ) { if ( visited . contains ( current . getH@@ op@@ ID ( ) ) ) return ; for ( Hop c : current . getInput ( ) ) r@@ Prun@@ e@@ Invalid@@ Plan@@ s ( memo , c , visited , part , plan ) ; long hop@@ ID = current . getH@@ op@@ ID ( ) ; if ( part . get@@ Partition ( ) . contains ( hop@@ ID ) && memo . contains ( hop@@ ID , Template@@ Type . ROW ) ) { Iterator < Memo@@ TableEntry > iter = memo . get ( hop@@ ID , Template@@ Type . ROW ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Memo@@ TableEntry me = iter . next ( ) ; boolean apply@@ Leaf = ( ! me . has@@ Plan@@ Ref ( ) && ! Template@@ Utils . has@@ Matrix@@ Input ( current ) ) ; boolean apply@@ Inner = ! apply@@ Leaf && ! ROW_@@ TP@@ L . open ( current ) ; for ( int i = 0 ; i < 3 & apply@@ Inner ; i ++ ) if ( me . is@@ Plan@@ Ref ( i ) ) apply@@ Inner &= ! memo . contains ( me . input ( i ) , Template@@ Type . ROW ) ; if ( apply@@ Leaf || apply@@ Inner ) { String type = apply@@ Leaf ? " leaf " : " inner " ; if ( isValid@@ Row@@ 2@@ Cell@@ Op ( current ) ) { me . type = Template@@ Type . CELL ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Conver@@ ted ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ from ▁ row ▁ to ▁ cell : ▁ " + me ) ; } else { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ row ▁ ( unsupported ▁ cell ) : ▁ " + me ) ; iter . remove ( ) ; } } } } visited . add ( current . getH@@ op@@ ID ( ) ) ; }
 public static < K , V > List@@ HashMap < K , V > new@@ List@@ HashMap ( ) { return new List@@ HashMap < K , V > ( ) ; }
 public static Builder builder ( List < Column@@ Metadata > columns ) { ImmutableList . Builder < String > names = ImmutableList . builder ( ) ; ImmutableList . Builder < Type > types = ImmutableList . builder ( ) ; for ( Column@@ Metadata column : columns ) { names . add ( column . getName ( ) ) ; types . add ( column . getType ( ) ) ; } return new Builder ( names . build ( ) , types . build ( ) ) ; }
 private static Database@@ Property parse@@ Property@@ Template ( Element property@@ Elem ) { String propertyName = property@@ Elem . getAttribute ( " name " ) ; Database@@ Property property ; String property@@ Type = property@@ Elem . get@@ TagName ( ) ; if ( property@@ Type . equals ( " Boolean@@ Property " ) ) property = new Boolean@@ Database@@ Property ( propertyName ) ; else if ( property@@ Type . equals ( " Integer@@ Property " ) ) property = new Integer@@ Database@@ Property ( propertyName ) ; else if ( property@@ Type . equals ( " Text@@ Property " ) ) property = new Text@@ Database@@ Property ( propertyName ) ; else if ( property@@ Type . equals ( " Item@@ List@@ Property " ) ) property = new Item@@ List@@ Database@@ Property ( propertyName ) ; else if ( property@@ Type . equals ( " String@@ List@@ Property " ) ) property = new String@@ List@@ Database@@ Property ( propertyName ) ; else if ( property@@ Type . equals ( " String@@ Pair@@ List@@ Property " ) ) property = new String@@ Pair@@ List@@ Database@@ Property ( propertyName ) ; else if ( property@@ Type . equals ( " Custom@@ Property " ) ) { NodeList sub@@ Property@@ Elems = property@@ Elem . getChildNodes ( ) ; List < Database@@ Property > sub@@ Properties = new ArrayList < Database@@ Property > ( ) ; for ( int i = 0 ; i < sub@@ Property@@ Elems . getLength ( ) ; i ++ ) { if ( sub@@ Property@@ Elems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element sub@@ Property@@ Elem = ( Element ) sub@@ Property@@ Elems . item ( i ) ; sub@@ Properties . add ( parse@@ Property@@ Template ( sub@@ Property@@ Elem ) ) ; } Database@@ Property [ ] sub@@ Property@@ Array = new Database@@ Property [ sub@@ Properties . size ( ) ] ; property = new Custom@@ Property ( propertyName , sub@@ Properties . toArray ( sub@@ Property@@ Array ) ) ; } else property = null ; return property ; }
 public static void main ( String [ ] args ) { if ( args . length == 1 && ( args [ 0 ] . equals ( " - - help " ) || args [ 0 ] . equals ( " - h " ) ) ) { print@@ Help ( ) ; System . exit ( 0 ) ; } if ( args . length < 2 ) { LOG . error ( " Must ▁ supply ▁ at ▁ least ▁ one ▁ source ▁ file ▁ and ▁ an ▁ output ▁ directory . " ) ; print@@ Help ( ) ; System . exit ( 1 ) ; } License@@ Headers license@@ Header = new License@@ Headers ( " AS@@ L@@ v2" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( " - license " . equals ( args [ i ] ) ) { if ( i == args . length - 1 ) { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; print@@ Help ( ) ; System . exit ( 1 ) ; } if ( license@@ Header . isValid@@ License ( args [ i + 1 ] ) ) { license@@ Header . set@@ License@@ Name ( args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . remove@@ Element ( args , args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . remove@@ Element ( args , args [ i ] ) ; } else { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; print@@ Help ( ) ; System . exit ( 1 ) ; } } } File outputDir = new File ( args [ args . length - 1 ] ) ; if ( ! outputDir . isDirectory ( ) ) { LOG . error ( " Must ▁ supply ▁ a ▁ directory ▁ for ▁ output " ) ; print@@ Help ( ) ; System . exit ( 1 ) ; } File input@@ Dir = new File ( args [ 0 ] ) ; File [ ] input@@ Files = null ; if ( input@@ Dir . isDirectory ( ) ) { if ( input@@ Dir . length ( ) > 0 ) input@@ Files = input@@ Dir . listFiles ( ) ; else { LOG . error ( " Input ▁ directory ▁ must ▁ include ▁ at ▁ least ▁ one ▁ file . " ) ; print@@ Help ( ) ; System . exit ( 1 ) ; } } else { input@@ Files = new File [ args . length - 1 ] ; for ( int i = 0 ; i < input@@ Files . length ; i ++ ) { File inputFile = new File ( args [ i ] ) ; if ( ! inputFile . isFile ( ) ) { LOG . error ( " Input ▁ must ▁ be ▁ a ▁ file . " ) ; print@@ Help ( ) ; System . exit ( 1 ) ; } input@@ Files [ i ] = inputFile ; } } try { G@@ ora@@ Compiler . compile@@ Schema ( input@@ Files , outputDir , license@@ Header ) ; LOG . info ( " Compiler ▁ executed ▁ SUCCE@@ SS@@ FULL . " ) ; } catch ( IOException e ) { LOG . error ( " Error ▁ while ▁ compiling ▁ schema ▁ files . ▁ Check ▁ that ▁ the ▁ schemas ▁ are ▁ properly ▁ formatted . " ) ; print@@ Help ( ) ; throw new RuntimeException ( e ) ; } }
 public static void agent@@ main ( String agent@@ Args , Instrumentation inst ) throws IOException { final String [ ] args = agent@@ Args . split ( " ▁ " ) ; final String [ ] jar@@ Search@@ Dirs = args [ 0 ] . split ( File . path@@ Separator ) ; final int port = Integer . parseInt ( args [ 1 ] ) ; final ServerSocket serverSocket = Server . open ( port ) ; new Thread ( Agent . class . getName ( ) + " - Server " ) { @ Override public void run ( ) { try { Server . run ( serverSocket , jar@@ Search@@ Dirs ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } . start ( ) ; }
 protected static String executable@@ Name ( ) { String name = System . getenv ( " S@@ WAR@@ M@@ TOOL _ NAME " ) ; if ( name == null ) { name = " java ▁ - jar ▁ s@@ war@@ mt@@ ool - standalone . jar " ; } return name ; }
 private static double min@@ Outer@@ Spar@@ sity ( Plan@@ Partition part , CP@@ lan@@ Memo@@ Table memo ) { return ! part . has@@ Outer ( ) ? 1.0 : part . get@@ Partition ( ) . stream ( ) . map ( k -> Hop@@ Rewrite@@ Utils . get@@ Largest@@ Input ( memo . getH@@ op@@ Refs ( ) . get ( k ) ) ) . mapTo@@ Double ( h -> h . di@@ ms@@ Known ( true ) ? h . getS@@ par@@ sity ( ) : SPAR@@ SE_@@ SAFE_@@ SPAR@@ SI@@ TY_@@ EST ) . min ( ) . orElse ( SPAR@@ SE_@@ SAFE_@@ SPAR@@ SI@@ TY_@@ EST ) ; }
 public static void main ( String [ ] args ) throws Exception { DAG dag = new DAG ( ) ; Vertex source = dag . new@@ Vertex ( " source " , Sources . read@@ Map ( " lines " ) ) ; Pattern delimiter = Pattern . compile ( " \\ W + " ) ; Vertex tokenize = dag . new@@ Vertex ( " tokenize " , Processors . flatMap ( ( Entry < Integer , String > e ) -> Traver@@ ser@@ s . traverse@@ Array ( delimiter . split ( e . getValue ( ) . toLowerCase ( ) ) ) . filter ( word -> ! word . isEmpty ( ) ) ) ) ; Vertex accumulate = dag . new@@ Vertex ( " accumulate " , Processors . accumul@@ ate@@ ByKey ( Distributed@@ Functions . whole@@ Item ( ) , Aggregate@@ Operations . counting ( ) ) ) ; Vertex combine = dag . new@@ Vertex ( " combine " , Processors . combine@@ ByKey ( Aggregate@@ Operations . counting ( ) ) ) ; Vertex sink = dag . new@@ Vertex ( " sink " , Sin@@ ks . write@@ Map ( " counts " ) ) ; dag . edge ( between ( source , tokenize ) ) . edge ( between ( tokenize , accumulate ) . partitioned ( Distributed@@ Functions . whole@@ Item ( ) , Partitioner . HASH_@@ CODE ) ) . edge ( between ( accumulate , combine ) . distributed ( ) . partitioned ( Distributed@@ Functions . entry@@ Key ( ) ) ) . edge ( between ( combine , sink ) ) ; Jet@@ Instance j@@ et = Jet@@ Bootstrap . getInstance ( ) ; I@@ Map < Integer , String > map = j@@ et . getMap ( " lines " ) ; map . put ( 0 , " It ▁ was ▁ the ▁ best ▁ of ▁ times , " ) ; map . put ( 1 , " it ▁ was ▁ the ▁ worst ▁ of ▁ times , " ) ; map . put ( 2 , " it ▁ was ▁ the ▁ age ▁ of ▁ w@@ is@@ dom , " ) ; map . put ( 3 , " it ▁ was ▁ the ▁ age ▁ of ▁ foo@@ lish@@ ness , " ) ; map . put ( 4 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ beli@@ ef , " ) ; map . put ( 5 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ incre@@ du@@ lity , " ) ; map . put ( 6 , " it ▁ was ▁ the ▁ season ▁ of ▁ Light , " ) ; map . put ( 7 , " it ▁ was ▁ the ▁ season ▁ of ▁ Dark@@ ness " ) ; map . put ( 8 , " it ▁ was ▁ the ▁ spring ▁ of ▁ hope , " ) ; map . put ( 9 , " it ▁ was ▁ the ▁ w@@ inter ▁ of ▁ de@@ sp@@ air , " ) ; map . put ( 10 , " we ▁ had ▁ everything ▁ before ▁ us , " ) ; map . put ( 11 , " we ▁ had ▁ nothing ▁ before ▁ us , " ) ; map . put ( 12 , " we ▁ were ▁ all ▁ going ▁ direct ▁ to ▁ He@@ aven , " ) ; map . put ( 13 , " we ▁ were ▁ all ▁ going ▁ direct ▁ the ▁ other ▁ way ▁ - - " ) ; map . put ( 14 , " in ▁ short , ▁ the ▁ period ▁ was ▁ so ▁ far ▁ like ▁ the ▁ present ▁ period , ▁ that ▁ some ▁ of ▁ " + " its ▁ no@@ isi@@ est ▁ author@@ ities ▁ in@@ sist@@ ed ▁ on ▁ its ▁ being ▁ received , ▁ for ▁ good ▁ or ▁ for ▁ " + " e@@ vil , ▁ in ▁ the ▁ super@@ l@@ ative ▁ degree ▁ of ▁ comparison ▁ only . " ) ; Job job = j@@ et . new@@ Job ( dag ) ; Future < Void > future = job . execute ( ) ; future . get ( ) ; System . out . println ( j@@ et . getMap ( " counts " ) . entrySet ( ) ) ; }
 public static void main ( String [ ] args ) throws Exception { String [ ] species = { Constants . Species . A@@ qu@@ atics , Constants . Species . Mam@@ m@@ als , Constants . Species . Bir@@ ds , Constants . Species . In@@ sec@@ ts , Constants . Species . Rep@@ tiles } ; String [ ] [ ] anim@@ als = { { Constants . Anim@@ als . A@@ qu@@ atics . Se@@ a@@ Turtle , Constants . Anim@@ als . A@@ qu@@ atics . Se@@ a@@ Hor@@ se , Constants . Anim@@ als . A@@ qu@@ atics . Moon@@ J@@ ell@@ y@@ fish } , { Constants . Anim@@ als . Mam@@ m@@ als . Ti@@ ger , Constants . Anim@@ als . Mam@@ m@@ als . Co@@ w , Constants . Anim@@ als . Mam@@ m@@ als . Monkey } , { Constants . Anim@@ als . Bir@@ ds . Do@@ ve , Constants . Anim@@ als . Bir@@ ds . W@@ ood@@ pec@@ ker , Constants . Anim@@ als . Bir@@ ds . N@@ ight@@ ing@@ ale } , { Constants . Anim@@ als . In@@ sec@@ ts . Butter@@ fly , Constants . Anim@@ als . In@@ sec@@ ts . L@@ ad@@ y@@ Bug , Constants . Anim@@ als . In@@ sec@@ ts . Spider } , { Constants . Anim@@ als . Rep@@ tiles . Cro@@ codi@@ le , Constants . Anim@@ als . Rep@@ tiles . Drag@@ on , Constants . Anim@@ als . Rep@@ tiles . Tur@@ tu@@ le } } ; Anim@@ al@@ Factory abstract@@ Factory = new Anim@@ al@@ Factory ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { Speci@@ es@@ Factory speci@@ es@@ Factory@@ 1 = abstract@@ Factory . get@@ Speci@@ es@@ Factory ( species [ i ] ) ; An@@ imal a1 = speci@@ es@@ Factory@@ 1 . get@@ An@@ imal ( anim@@ als [ i ] [ j ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ an@@ imal ▁ with ▁ % d ▁ leg@@ s ▁ whose ▁ name ▁ is ▁ % s ! \n " , a1 . getN@@ r@@ Of@@ Le@@ gs ( ) , a1 . getName ( ) ) ; } } int i = 0 ; while ( i <= 50 || i == 0 ) { Random rand = new Random ( ) ; int choose@@ Species = rand . nextInt ( 5 ) ; int choose@@ An@@ imal = rand . nextInt ( 3 ) ; Speci@@ es@@ Factory speci@@ es@@ Factory@@ 2 = abstract@@ Factory . get@@ Speci@@ es@@ Factory ( species [ choose@@ Species ] ) ; An@@ imal a2 = speci@@ es@@ Factory@@ 2 . get@@ An@@ imal ( anim@@ als [ choose@@ Species ] [ choose@@ An@@ imal ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ an@@ imal ▁ with ▁ % d ▁ leg@@ s ▁ whose ▁ name ▁ is ▁ % s ! \n " , a2 . getN@@ r@@ Of@@ Le@@ gs ( ) , a2 . getName ( ) ) ; i ++ ; } Anim@@ al@@ Factory abstract@@ Factory@@ 2 = new Anim@@ al@@ Factory ( ) ; An@@ imal [ ] all@@ Anim@@ als = new An@@ imal [ 15 ] ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int choose@@ Species = rand . nextInt ( 5 ) ; int choose@@ An@@ imal = rand . nextInt ( 3 ) ; Speci@@ es@@ Factory speci@@ es@@ Factory@@ 3 = abstract@@ Factory@@ 2 . get@@ Speci@@ es@@ Factory ( species [ choose@@ Species ] ) ; all@@ Anim@@ als [ k ] = speci@@ es@@ Factory@@ 3 . get@@ An@@ imal ( anim@@ als [ choose@@ Species ] [ choose@@ An@@ imal ] ) ; } Care@@ Ta@@ ker@@ Factory abstract@@ Ta@@ kers = new Care@@ Ta@@ ker@@ Factory ( ) ; Employee employee = abstract@@ Ta@@ kers . get@@ Employee@@ Factory ( Constants . Employe@@ es . Care@@ ta@@ ker ) ; employee . set@@ Dead ( false ) ; employee . setName ( " J@@ ack " ) ; Employee [ ] care@@ ta@@ kers = new Care@@ Ta@@ ker [ 15 ] ; for ( int x = 0 ; x < 15 ; x ++ ) { care@@ ta@@ kers [ x ] = abstract@@ Ta@@ kers . get@@ Employee@@ Factory ( Constants . Employe@@ es . Care@@ ta@@ ker ) ; care@@ ta@@ kers [ x ] . set@@ Dead ( false ) ; } boolean is@@ Ta@@ ken@@ Care@@ Of = false ; for ( int x = 0 ; x < care@@ ta@@ kers . length ; x ++ ) { for ( int k = 0 ; k < all@@ Anim@@ als . length ; k ++ ) { if ( ! care@@ ta@@ kers [ k ] . is@@ Dead ( ) && ! all@@ Anim@@ als [ k ] . is@@ Ta@@ ken@@ Care@@ Of ( ) ) { String result = ( ( Care@@ Ta@@ ker ) care@@ ta@@ kers [ x ] ) . take@@ Care@@ Of ( all@@ Anim@@ als [ k ] ) ; if ( result . equals ( Constants . Employe@@ es . Care@@ ta@@ kers . T@@ CO_@@ KIL@@ LED ) ) { System . out . println ( " care@@ ta@@ ker " + k + " ▁ killed ▁ by ▁ " + all@@ Anim@@ als [ k ] . getName ( ) ) ; care@@ ta@@ kers [ k ] . set@@ Dead ( true ) ; } else if ( result . equals ( Constants . Employe@@ es . Care@@ ta@@ kers . T@@ CO_@@ NO_@@ TIME ) ) { continue ; } else { all@@ Anim@@ als [ k ] . set@@ Ta@@ ken@@ Care@@ Of ( true ) ; } } if ( all@@ Anim@@ als [ k ] . is@@ Ta@@ ken@@ Care@@ Of ( ) ) { is@@ Ta@@ ken@@ Care@@ Of = true ; } else { is@@ Ta@@ ken@@ Care@@ Of = false ; } } } PrintWriter writer = new PrintWriter ( " output . txt " , " UTF - 8" ) ; if ( is@@ Ta@@ ken@@ Care@@ Of ) { System . out . println ( " All ▁ anim@@ als ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; writer . println ( " All ▁ anim@@ als ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; } else { System . out . println ( " There ▁ are ▁ anim@@ als ▁ that ▁ still ▁ need ▁ to ▁ be ▁ ca@@ red ▁ of ! " ) ; writer . println ( " There ▁ are ▁ anim@@ als ▁ that ▁ still ▁ need ▁ to ▁ be ▁ ca@@ red ▁ of ! " ) ; } for ( int l = 0 ; l < all@@ Anim@@ als . length ; l ++ ) { if ( ! is@@ Ta@@ ken@@ Care@@ Of ) { System . out . println ( all@@ Anim@@ als [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; writer . println ( all@@ Anim@@ als [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; } } Anim@@ al@@ Factory abstract@@ Factory@@ 3 = new Anim@@ al@@ Factory ( ) ; Anim@@ al@@ Repository ar = new Anim@@ al@@ Repository ( ) ; ArrayList < An@@ imal > anim@@ al@@ sList = new ArrayList < > ( ) ; ArrayList < An@@ imal > anim@@ als@@ List@@ To@@ Display = new ArrayList < > ( ) ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int choose@@ Species = rand . nextInt ( 5 ) ; int choose@@ An@@ imal = rand . nextInt ( 3 ) ; Speci@@ es@@ Factory speci@@ es@@ Factory@@ 3 = abstract@@ Factory@@ 3 . get@@ Speci@@ es@@ Factory ( species [ choose@@ Species ] ) ; An@@ imal all@@ Anim@@ als@@ As@@ A@@ List = speci@@ es@@ Factory@@ 3 . get@@ An@@ imal ( anim@@ als [ choose@@ Species ] [ choose@@ An@@ imal ] ) ; anim@@ al@@ sList . add ( all@@ Anim@@ als@@ As@@ A@@ List ) ; } ar . save ( anim@@ al@@ sList ) ; anim@@ als@@ List@@ To@@ Display = ar . load ( ) ; System . out . println ( ) ; System . out . println ( " saved ▁ list : " ) ; writer . println ( ) ; writer . println ( " saved ▁ list : " ) ; for ( An@@ imal ani@@ 2 : anim@@ al@@ sList ) { System . out . println ( ani@@ 2 . getName ( ) ) ; writer . println ( ani@@ 2 . getName ( ) ) ; } System . out . println ( ) ; System . out . println ( " loaded ▁ list : " ) ; writer . println ( ) ; writer . println ( " loaded ▁ list : " ) ; for ( An@@ imal ani : anim@@ als@@ List@@ To@@ Display ) { System . out . println ( ani . getName ( ) ) ; writer . println ( ani . getName ( ) ) ; } ArrayList < Employee > employe@@ es@@ List = new ArrayList < > ( ) ; ArrayList < Employee > employe@@ es@@ List@@ To@@ Display = new ArrayList < > ( ) ; Care@@ Ta@@ ker@@ Factory abstract@@ Ta@@ ker@@ s2 = new Care@@ Ta@@ ker@@ Factory ( ) ; Employee@@ Repository er = new Employee@@ Repository ( ) ; for ( int k = 0 ; k < 10 ; k ++ ) { Employee employe@@ e2 = abstract@@ Ta@@ ker@@ s2 . get@@ Employee@@ Factory ( Constants . Employe@@ es . Care@@ ta@@ ker ) ; employe@@ es@@ List . add ( employe@@ e2 ) ; } er . save ( employe@@ es@@ List ) ; employe@@ es@@ List@@ To@@ Display = er . load ( ) ; for ( int k = 0 ; k < employe@@ es@@ List . size ( ) ; k ++ ) { System . out . println ( String . valueOf ( employe@@ es@@ List@@ To@@ Display . get ( k ) . getName ( ) ) ) ; } writer . close ( ) ; }
 public static void write ( org . omg . CORBA . portable . OutputStream ostream , com . pri@@ sm@@ tech . agent@@ v . core . types . Upgrade@@ Micro@@ svc value ) { ostream . write_string ( value . micro@@ svc ) ; ostream . write_@@ boolean ( value . backup ) ; com . pri@@ sm@@ tech . agent@@ v . core . types . Byte@@ Seq@@ Helper . write ( ostream , value . payload ) ; }
 public static com . pri@@ sm@@ tech . agent@@ v . core . types . Upgrade@@ Micro@@ svc extract ( org . omg . CORBA . Any a ) { return read ( a . create_@@ input_stream ( ) ) ; }
 private static boolean isMulti@@ Aggregate@@ Root ( Hop root ) { return ( Hop@@ Rewrite@@ Utils . is@@ Agg@@ Unary@@ Op ( root , Agg@@ Op . SUM , Agg@@ Op . SUM@@ _S@@ Q , Agg@@ Op . MIN , Agg@@ Op . MAX ) && ( ( Agg@@ Unary@@ Op ) root ) . get@@ Direction ( ) == Direction . Row@@ Col ) || ( root instanceof Agg@@ Binary@@ Op && root . get@@ Di@@ m1 ( ) == 1 && root . get@@ Di@@ m2 ( ) == 1 && Hop@@ Rewrite@@ Utils . is@@ Transpo@@ se@@ Operation ( root . getInput ( ) . get ( 0 ) ) ) ; }
 public static Compiler@@ Settings getInstance ( ) { return ServiceManager . getService ( Compiler@@ Settings . class ) ; }
 public static List < KeyValue > extract@@ Table@@ Row@@ DataFrom@@ Response ( HttpResponse response , Map < String , Integer > key@@ Position@@ Map ) throws IOException { boolean line@@ Reached = false ; List < KeyValue > key@@ Values = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : key@@ Position@@ Map . keySet ( ) ) { if ( line . contains ( key ) ) { line@@ Reached = true ; continue ; } if ( line@@ Reached ) { if ( line . contains ( " < td > " ) ) { Pattern p = Pattern . compile ( " < td > ( \\ S + ) < / td > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue key@@ Value = new KeyValue ( key , m . group ( 1 ) ) ; key@@ Values . add ( key@@ Value ) ; return key@@ Values ; } } } } } rd . close ( ) ; return null ; }
 private static void get@@ Compute@@ Co@@ sts ( Hop current , HashMap < Long , Double > compute@@ Co@@ sts ) { double costs = 1 ; if ( current instanceof Unary@@ Op ) { switch ( ( ( Unary@@ Op ) current ) . get@@ Op ( ) ) { case ABS : case ROUND : case CE@@ IL : case FLO@@ OR : case SIGN : costs = 1 ; break ; case SPRO@@ P : case SQ@@ RT : costs = 2 ; break ; case EXP : costs = 18 ; break ; case SIG@@ MO@@ ID : costs = 21 ; break ; case LOG : case LOG_@@ N@@ Z : costs = 32 ; break ; case N@@ COL : case N@@ ROW : case PRINT : case ASSERT : case CAST_@@ AS_@@ BOOLEAN : case CAST_@@ AS_@@ DOUBLE : case CAST_@@ AS_@@ INT : case CAST_@@ AS_@@ MATRIX : case CAST_@@ AS@@ _SCAL@@ AR : costs = 1 ; break ; case SI@@ N : costs = 18 ; break ; case CO@@ S : costs = 22 ; break ; case TA@@ N : costs = 42 ; break ; case AS@@ IN : costs = 93 ; break ; case A@@ CO@@ S : costs = 103 ; break ; case ATA@@ N : costs = 40 ; break ; case SIN@@ H : costs = 93 ; break ; case CO@@ SH : costs = 103 ; break ; case TAN@@ H : costs = 40 ; break ; case C@@ UM@@ SUM : case C@@ UM@@ MIN : case C@@ UM@@ MAX : case C@@ UM@@ PRO@@ D : costs = 1 ; break ; case C@@ UM@@ SUM@@ PRO@@ D : costs = 2 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( Unary@@ Op ) current ) . get@@ Op ( ) ) ; } } else if ( current instanceof Binary@@ Op ) { switch ( ( ( Binary@@ Op ) current ) . get@@ Op ( ) ) { case MUL@@ T : case PLUS : case MINUS : case MIN : case MAX : case AND : case OR : case EQUAL : case NOTE@@ QUAL : case LESS : case LES@@ SEQU@@ AL : case GREATER : case GRE@@ ATER@@ EQUAL : case C@@ BIND : case R@@ BIND : costs = 1 ; break ; case INT@@ DIV : costs = 6 ; break ; case MODUL@@ US : costs = 8 ; break ; case DIV : costs = 22 ; break ; case LOG : case LOG_@@ N@@ Z : costs = 32 ; break ; case PO@@ W : costs = ( Hop@@ Rewrite@@ Utils . is@@ Literal@@ Of@@ Value ( current . getInput ( ) . get ( 1 ) , 2 ) ? 1 : 16 ) ; break ; case MINUS_@@ N@@ Z : case MIN@@ US@@ 1_@@ MUL@@ T : costs = 2 ; break ; case MO@@ MENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof Literal@@ Op ? Hop@@ Rewrite@@ Utils . getInt@@ Value@@ Safe ( ( Literal@@ Op ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 1 ; break ; case 1 : costs = 8 ; break ; case 2 : costs = 16 ; break ; case 3 : costs = 31 ; break ; case 4 : costs = 51 ; break ; case 5 : costs = 16 ; break ; } break ; case CO@@ V : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( Binary@@ Op ) current ) . get@@ Op ( ) ) ; } } else if ( current instanceof Ter@@ n@@ ary@@ Op ) { switch ( ( ( Ter@@ n@@ ary@@ Op ) current ) . get@@ Op ( ) ) { case IF@@ ELSE : case PL@@ US_@@ MUL@@ T : case MINUS_@@ MUL@@ T : costs = 2 ; break ; case C@@ TABLE : costs = 3 ; break ; case MO@@ MENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof Literal@@ Op ? Hop@@ Rewrite@@ Utils . getInt@@ Value@@ Safe ( ( Literal@@ Op ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 2 ; break ; case 1 : costs = 9 ; break ; case 2 : costs = 17 ; break ; case 3 : costs = 32 ; break ; case 4 : costs = 52 ; break ; case 5 : costs = 17 ; break ; } break ; case CO@@ V : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( Ter@@ n@@ ary@@ Op ) current ) . get@@ Op ( ) ) ; } } else if ( current instanceof N@@ ary@@ Op ) { costs = Hop@@ Rewrite@@ Utils . is@@ N@@ ary ( current , Op@@ Op@@ N . MIN , Op@@ Op@@ N . MAX ) ? current . getInput ( ) . size ( ) : 1 ; } else if ( current instanceof Parameterized@@ Builtin@@ Op ) { costs = 1 ; } else if ( current instanceof Indexing@@ Op ) { costs = 1 ; } else if ( current instanceof Re@@ org@@ Op ) { costs = 1 ; } else if ( current instanceof D@@ nn@@ Op ) { switch ( ( ( D@@ nn@@ Op ) current ) . get@@ Op ( ) ) { case BI@@ AS@@ ADD : case BI@@ AS@@ MUL@@ T : costs = 2 ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( D@@ nn@@ Op ) current ) . get@@ Op ( ) ) ; } } else if ( current instanceof Agg@@ Binary@@ Op ) { costs = 2 * current . getInput ( ) . get ( 0 ) . get@@ Di@@ m2 ( ) ; if ( current . getInput ( ) . get ( 0 ) . di@@ ms@@ Known ( true ) ) costs *= current . getInput ( ) . get ( 0 ) . getS@@ par@@ sity ( ) ; } else if ( current instanceof Agg@@ Unary@@ Op ) { switch ( ( ( Agg@@ Unary@@ Op ) current ) . get@@ Op ( ) ) { case SUM : costs = 4 ; break ; case SUM@@ _S@@ Q : costs = 5 ; break ; case MIN : case MAX : costs = 1 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( Agg@@ Unary@@ Op ) current ) . get@@ Op ( ) ) ; } switch ( ( ( Agg@@ Unary@@ Op ) current ) . get@@ Direction ( ) ) { case Col : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . get@@ Di@@ m1 ( ) , 1 ) ; break ; case Row : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . get@@ Di@@ m2 ( ) , 1 ) ; break ; case Row@@ Col : costs *= getSize ( current . getInput ( ) . get ( 0 ) ) ; break ; } } costs *= getSize ( current ) ; compute@@ Co@@ sts . put ( current . getH@@ op@@ ID ( ) , costs ) ; }
 private static String to@@ In@@ den@@ tedString ( java . lang . Object o ) { if ( o == null ) { return " null " ; } return o . toString ( ) . replace ( " \n " , " \n ▁ ▁ ▁ ▁ " ) ; }
 public static Drill@@ Service@@ Instance getDefaultInstance ( ) { return DEFAULT_@@ INSTANCE ; }
 public static void main ( String [ ] argv ) { run@@ Filter ( new Class@@ Order ( ) , argv ) ; }
 public static Weather handle@@ Weather@@ Response ( String response ) { try { JSONObject jsonObject = new JSONObject ( response ) ; JSONArray json@@ Array = jsonObject . get@@ JSONArray ( " He@@ Weather " ) ; String weather@@ Content = json@@ Array . getJSONObject ( 0 ) . toString ( ) ; return new Gson ( ) . fromJson ( weather@@ Content , Weather . class ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; }
 @ BeforeClass public static void create@@ Original@@ FSI@@ mage ( ) throws IOException { MiniDFSCluster cluster = null ; try { Configuration conf = new Hdfs@@ Configuration ( ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_@@ DELEG@@ ATION_@@ TOKEN_@@ MAX_@@ LI@@ FE@@ TIME_@@ KEY , 10000 ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_@@ DELEG@@ ATION_@@ TOKEN_@@ RE@@ NEW_@@ INTERVAL_@@ KEY , 5000 ) ; conf . setBoolean ( DFSConfigKeys . DFS_NAMENODE_@@ DELEG@@ ATION_@@ TOKEN_@@ ALWAYS_@@ USE_@@ KEY , true ) ; conf . set ( Common@@ Configuration@@ Keys@@ Public . HADO@@ OP@@ _SECURI@@ TY_@@ AUTH_@@ TO_@@ LOCAL , " RULE : [2 : $ 1 @ $ 0 ] ( Job@@ Tracker @ . * FOO . COM ) s / @ . * // " + " DEFAULT " ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 4 ) . build ( ) ; cluster . wait@@ Active ( ) ; FileSystem hdfs = cluster . getFileSystem ( ) ; int filesize = 256 ; for ( int i = 0 ; i < NUM_@@ DIRS ; i ++ ) { Path dir = new Path ( " / dir " + i ) ; hdfs . mkdirs ( dir ) ; written@@ Files . put ( dir . toString ( ) , pathTo@@ FileEntry ( hdfs , dir . toString ( ) ) ) ; for ( int j = 0 ; j < FILE@@ S_PER_@@ DIR ; j ++ ) { Path file = new Path ( dir , " file " + j ) ; FSDataOutputStream o = hdfs . create ( file ) ; o . write ( new byte [ filesize ++ ] ) ; o . close ( ) ; written@@ Files . put ( file . toString ( ) , pathTo@@ FileEntry ( hdfs , file . toString ( ) ) ) ; } } Token < ? > [ ] deleg@@ ation@@ Tokens = hdfs . add@@ Delegation@@ Tokens ( TEST_@@ RE@@ NEW@@ ER , null ) ; for ( Token < ? > t : deleg@@ ation@@ Tokens ) { LOG . debug ( " got ▁ token ▁ " + t ) ; } cluster . getName@@ Node@@ Rpc ( ) . set@@ Safe@@ Mode ( Safe@@ Mode@@ Action . SAFE@@ MODE_@@ ENTER , false ) ; cluster . getName@@ Node@@ Rpc ( ) . save@@ Namespace ( ) ; original@@ F@@ si@@ mage = FSI@@ mage@@ TestUtil . find@@ Latest@@ ImageFile ( FSI@@ mage@@ TestUtil . getF@@ SI@@ mage ( cluster . getName@@ Node ( ) ) . get@@ Storage ( ) . getStorage@@ Dir ( 0 ) ) ; if ( original@@ F@@ si@@ mage == null ) { throw new RuntimeException ( " Did@@ n ' t ▁ generate ▁ or ▁ can ' t ▁ find ▁ f@@ si@@ mage " ) ; } LOG . debug ( " original ▁ FS ▁ image ▁ file ▁ is ▁ " + original@@ F@@ si@@ mage ) ; } finally { if ( cluster != null ) cluster . shutdown ( ) ; } }
 public static Trip@@ Share@@ DAO getInstance ( final Context context ) { if ( singleton == null ) { singleton = new Trip@@ Share@@ DAO ( context . getApplicationContext ( ) ) ; } return singleton ; }
 public static void main ( String [ ] args ) { _@@ 105@@ 2_@@ max@@ Satisfied max@@ Satisfied = new _@@ 105@@ 2_@@ max@@ Satisfied ( ) ; System . out . println ( max@@ Satisfied . max@@ Satisfied ( new int [ ] { 1 , 0 , 1 , 2 , 1 , 1 , 7 , 5 } , new int [ ] { 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 } , 3 ) ) ; System . out . println ( max@@ Satisfied . max@@ Satisfied ( new int [ ] { 1 } , new int [ ] { 0 } , 1 ) ) ; System . out . println ( max@@ Satisfied . max@@ Satisfied ( new int [ ] { 4 , 10 , 10 } , new int [ ] { 1 , 1 , 0 } , 2 ) ) ; }
 private static Connector@@ Table@@ Metadata getOrder@@ sTable ( ) { return getOrder@@ sTable ( ImmutableMap . of ( ) ) ; }
 private static double get@@ Safe@@ Mem@@ E@@ st ( Hop hop ) { return ! hop . di@@ ms@@ Known ( ) ? getSize ( hop ) * 8 : hop . getOutput@@ Mem@@ Estimate ( ) ; }
 private static String getItem ( String full@@ Command ) { if ( ! StringUtils . contains@@ IgnoreCase ( full@@ Command , ON_@@ KEYWORD ) ) { return full@@ Command ; } List < String > parts = Arrays . asList ( full@@ Command . split ( " ( ? i ) " + ON_@@ KEYWORD , 2 ) ) ; String item = parts . get ( 0 ) ; return item . trim ( ) ; }
 public static List < KeyValue > extract@@ DataFrom@@ Response ( HttpResponse response , Map < String , Integer > key@@ Position@@ Map ) throws IOException { List < KeyValue > key@@ Values = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : key@@ Position@@ Map . keySet ( ) ) { if ( line . contains ( key ) ) { String [ ] tokens = line . split ( " ' " ) ; KeyValue key@@ Value = new KeyValue ( key , tokens [ key@@ Position@@ Map . get ( key ) ] ) ; key@@ Values . add ( key@@ Value ) ; return key@@ Values ; } } } rd . close ( ) ; return null ; }
 public static String get@@ Simpli@@ fied@@ Domain@@ String ( long low , long high , int range@@ Count , Type type ) { String formatted@@ Values ; if ( range@@ Count == 1 ) { formatted@@ Values = format ( " { [ % d ] } " , low ) ; } else if ( range@@ Count == 2 ) { formatted@@ Values = Long@@ Stream . of ( low , high ) . mapTo@@ Obj ( value -> " [ " + value + " ] " ) . collect ( Collectors . joining ( " , ▁ " , " { " , " } " ) ) ; } else { formatted@@ Values = format ( " { [ % d ] , ▁ . . . , ▁ [ % d ] } " , low , high ) ; } return " [ ▁ " + new String@@ Joiner ( " , ▁ " , Sorted@@ RangeSet . class . getSimpleName ( ) + " [ " , " ] " ) . add ( " type = " + type ) . add ( " ranges = " + range@@ Count ) . add ( formatted@@ Values ) + " ▁ ] " ; }
 public static void main ( String [ ] args ) throws Exception { String dataDir = " src / program@@ mer@@ s@@ guide / working@@ with@@ as@@ pose@@ pd@@ ff@@ ac@@ a@@ des / working@@ with@@ text / extract@@ text@@ fro@@ min@@ divid@@ ual@@ pages / data / " ; com . as@@ pose . pdf . fac@@ a@@ des . Pdf@@ Extractor pdf@@ Extractor = new com . as@@ pose . pdf . fac@@ a@@ des . Pdf@@ Extractor ( ) ; pdf@@ Extractor . bind@@ P@@ df ( dataDir + " Input@@ 1 . pdf " ) ; pdf@@ Extractor . extract@@ Text ( ) ; int pageNumber = 1 ; while ( pdf@@ Extractor . has@@ Next@@ Page@@ Text ( ) ) { pdf@@ Extractor . getNext@@ Page@@ Text ( dataDir + " output " + pageNumber + " . txt " ) ; pageNumber ++ ; } }
 public static E@@ le@@ ph@@ ant fil@@ led@@ E@@ le@@ ph@@ ant ( ) { E@@ le@@ ph@@ ant ele@@ ph@@ ant = new E@@ le@@ ph@@ ant ( ) ; ele@@ ph@@ ant . some@@ E@@ le@@ ph@@ ant@@ Field = " ele@@ ph@@ ant@@ Field " ; ele@@ ph@@ ant . normal@@ Body@@ Temperature = 25f ; ele@@ ph@@ ant . proper@@ Name = " ele@@ ph@@ ant " ; return ele@@ ph@@ ant ; }
 public static void main ( String [ ] args ) throws Runner@@ Exception { Options options = new Options@@ Builder ( ) . verbosity ( Verbose@@ Mode . NORMAL ) . include ( " . * " + Benchmark@@ Pages@@ Sort . class . getSimpleName ( ) + " . * " ) . build ( ) ; new Runner ( options ) . run ( ) ; }
 private static void createAnd@@ Add@@ Multi@@ Agg@@ Plan@@ s ( CP@@ lan@@ Memo@@ Table memo , HashSet < Long > partition , HashSet < Long > R ) { HashSet < Long > ref@@ H@@ ops = new HashSet < > ( ) ; for ( Entry < Long , List < Memo@@ TableEntry > > e : memo . get@@ Plan@@ s ( ) . entrySet ( ) ) if ( ! e . getValue ( ) . isEmpty ( ) ) { Hop hop = memo . getH@@ op@@ Refs ( ) . get ( e . getKey ( ) ) ; for ( Hop c : hop . getInput ( ) ) ref@@ H@@ ops . add ( c . getH@@ op@@ ID ( ) ) ; } ArrayList < Long > full@@ Ag@@ gs = new ArrayList < > ( ) ; for ( Long hop@@ ID : R ) { Hop root = memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) ; if ( ! ref@@ H@@ ops . contains ( hop@@ ID ) && isMulti@@ Aggregate@@ Root ( root ) ) full@@ Ag@@ gs . add ( hop@@ ID ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Found ▁ within - partition ▁ ua ( RC ) ▁ aggregations : ▁ " + Arrays . toString ( full@@ Ag@@ gs . toArray ( new Long [ 0 ] ) ) ) ; } for ( int i = 0 ; i < full@@ Ag@@ gs . size ( ) ; i += 3 ) { int ito = Math . min ( i + 3 , full@@ Ag@@ gs . size ( ) ) ; if ( ito - i >= 2 ) { Memo@@ TableEntry me = new Memo@@ TableEntry ( Template@@ Type . MAG@@ G , full@@ Ag@@ gs . get ( i ) , full@@ Ag@@ gs . get ( i + 1 ) , ( ( ito - i ) == 3 ) ? full@@ Ag@@ gs . get ( i + 2 ) : - 1 , ito - i ) ; if ( isValid@@ Multi@@ Aggregate ( memo , me ) ) { for ( int j = i ; j < ito ; j ++ ) { memo . add ( memo . getH@@ op@@ Refs ( ) . get ( full@@ Ag@@ gs . get ( j ) ) , me ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Added ▁ multi@@ agg ▁ plan : ▁ " + full@@ Ag@@ gs . get ( j ) + " ▁ " + me ) ; } } else if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ invalid ▁ multi@@ agg ▁ plan : ▁ " + me ) ; } } } }
 public static Ti@@ ger fil@@ led@@ Ti@@ ger ( ) { Ti@@ ger ti@@ ger = new Ti@@ ger ( ) ; ti@@ ger . some@@ T@@ ig@@ er@@ Field = " ti@@ ger@@ Field " ; ti@@ ger . normal@@ Body@@ Temperature = 3@@ 0f ; ti@@ ger . proper@@ Name = " ti@@ ger " ; return ti@@ ger ; }
 private static FileStatus pathTo@@ FileEntry ( FileSystem hdfs , String file ) throws IOException { return hdfs . getFileStatus ( new Path ( file ) ) ; }
 private static Connector@@ Table@@ Metadata getOrder@@ sTable ( Map < String , Object > properties ) { return build@@ Table ( properties , table@@ Metadata@@ Builder ( DEFAULT_@@ TEST_@@ OR@@ DERS ) . column ( " order@@ key " , BIGINT ) . column ( " cust@@ key " , BIGINT ) . column ( " total@@ price " , DOUBLE ) . column ( " order@@ date " , DATE ) ) ; }
 private static double get@@ Lower@@ Bound@@ Co@@ sts ( Plan@@ Partition part , Interest@@ ing@@ Point [ ] M , CP@@ lan@@ Memo@@ Table memo , Static@@ Co@@ sts costs , boolean [ ] plan ) { double lb = Math . max ( costs . _read , costs . _@@ compute ) + costs . _write + get@@ Materializ@@ ation@@ Cost ( part , M , memo , plan ) ; if ( part . has@@ Outer ( ) ) lb *= costs . _min@@ Spar@@ sity ; return lb ; }
 private static void print@@ Help ( ) { LOG . info ( " Usage : ▁ gor@@ a - compiler ▁ ( ▁ - h ▁ | ▁ - - help ▁ ) ▁ | ▁ ( < input > ▁ [ < input > . . . ] ▁ < output > ▁ [ - license ▁ < id > ] ) " ) ; LOG . error ( " License ▁ header ▁ options ▁ include ; \n " + " \t\t ▁ ▁ AS@@ L@@ v2 ▁ ▁ ▁ ( Apache ▁ Software ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ AG@@ PL@@ v3 ▁ ▁ ( GNU ▁ Affero ▁ General ▁ Public ▁ License ) ▁ \n " + " \t\t ▁ ▁ CD@@ DL@@ v1 ▁ ▁ ( Common ▁ Development ▁ and ▁ Distribution ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ FD@@ L@@ v@@ 13 ▁ ▁ ( GNU ▁ Free ▁ Documentation ▁ License ▁ v@@ 1.3 ) ▁ \n " + " \t\t ▁ ▁ GPL@@ v1 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ GPLv2 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ GPL@@ v3 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v3.0 ) ▁ \n " + " \t\t ▁ ▁ LGPLv21 ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v@@ 2.1 ) ▁ \n " + " \t\t ▁ ▁ LGPLv3 ▁ ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v@@ 2.1 ) " ) ; }
 public static void add@@ CSS@@ Name ( Element elem , String s@@ CSS@@ Name ) { elem . add@@ ClassName ( s@@ CSS@@ Name ) ; }
 protected static synchronized int getNext@@ Round@@ Rob@@ in@@ Host@@ Index ( String url , List < ? > host@@ List ) { int index@@ Range = host@@ List . size ( ) ; int index = random . nextInt ( index@@ Range ) ; return index ; }
 private static double getRead@@ Cost ( Plan@@ Partition part , CP@@ lan@@ Memo@@ Table memo ) { double costs = 0 ; for ( Long hop@@ ID : part . getIn@@ puts ( ) ) { Hop hop = memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) ; costs += get@@ Safe@@ Mem@@ E@@ st ( hop ) / READ_@@ B@@ AND@@ WIDTH_@@ MEM ; } return costs ; }
 private static Database@@ Property parse@@ Full@@ Property ( Element property@@ Elem ) { String propertyName = property@@ Elem . getAttribute ( " name " ) ; Database@@ Property property ; String property@@ Type = property@@ Elem . get@@ TagName ( ) ; if ( property@@ Type . equals ( " Boolean@@ Property " ) ) { property = new Boolean@@ Database@@ Property ( propertyName ) ; boolean value = property@@ Elem . getAttribute ( " value " ) . equals ( " true " ) ; ( ( Boolean@@ Database@@ Property ) property ) . setValue ( value ) ; } else if ( property@@ Type . equals ( " Integer@@ Property " ) ) { property = new Integer@@ Database@@ Property ( propertyName ) ; int value = Integer . parseInt ( property@@ Elem . getAttribute ( " value " ) ) ; ( ( Integer@@ Database@@ Property ) property ) . setValue ( value ) ; } else if ( property@@ Type . equals ( " Text@@ Property " ) ) { property = new Text@@ Database@@ Property ( propertyName ) ; String text = property@@ Elem . getAttribute ( " text " ) ; ( ( Text@@ Database@@ Property ) property ) . setText ( text ) ; } else if ( property@@ Type . equals ( " Item@@ List@@ Property " ) ) { property = new Item@@ List@@ Database@@ Property ( propertyName ) ; NodeList item@@ Refs = property@@ Elem . getElementsByTagName ( " Item@@ Reference " ) ; for ( int i = 0 ; i < item@@ Refs . getLength ( ) ; i ++ ) { Element item@@ Ref = ( Element ) item@@ Refs . item ( i ) ; String itemName = item@@ Ref . getAttribute ( " name " ) ; ( ( Item@@ List@@ Database@@ Property ) property ) . add@@ Item@@ Name ( itemName ) ; } } else if ( property@@ Type . equals ( " String@@ List@@ Property " ) ) { property = new String@@ List@@ Database@@ Property ( propertyName ) ; NodeList string@@ Refs = property@@ Elem . getElementsByTagName ( " String " ) ; String [ ] string@@ List = new String [ string@@ Refs . getLength ( ) ] ; for ( int i = 0 ; i < string@@ Refs . getLength ( ) ; i ++ ) { Element string@@ Ref = ( Element ) string@@ Refs . item ( i ) ; string@@ List [ i ] = string@@ Ref . getAttribute ( " string " ) ; } ( ( String@@ List@@ Database@@ Property ) property ) . set@@ StringList ( string@@ List ) ; } else if ( property@@ Type . equals ( " String@@ Pair@@ List@@ Property " ) ) { property = new String@@ Pair@@ List@@ Database@@ Property ( propertyName ) ; NodeList pair@@ Refs = property@@ Elem . getElementsByTagName ( " String@@ Pair " ) ; String@@ Pair [ ] pair@@ List = new String@@ Pair [ pair@@ Refs . getLength ( ) ] ; for ( int i = 0 ; i < pair@@ Refs . getLength ( ) ; i ++ ) { Element pair@@ Ref = ( Element ) pair@@ Refs . item ( i ) ; String string1 = pair@@ Ref . getAttribute ( " string@@ 1" ) ; String string@@ 2 = pair@@ Ref . getAttribute ( " string@@ 2" ) ; pair@@ List [ i ] = new String@@ Pair ( string1 , string@@ 2 ) ; } ( ( String@@ Pair@@ List@@ Database@@ Property ) property ) . set@@ String@@ Pairs ( pair@@ List ) ; } else if ( property@@ Type . equals ( " Custom@@ Property " ) ) { NodeList sub@@ Property@@ Elems = property@@ Elem . getChildNodes ( ) ; List < Database@@ Property > sub@@ Properties = new ArrayList < Database@@ Property > ( ) ; for ( int i = 0 ; i < sub@@ Property@@ Elems . getLength ( ) ; i ++ ) { if ( sub@@ Property@@ Elems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element sub@@ Property@@ Elem = ( Element ) sub@@ Property@@ Elems . item ( i ) ; sub@@ Properties . add ( parse@@ Full@@ Property ( sub@@ Property@@ Elem ) ) ; } Database@@ Property [ ] sub@@ Property@@ Array = new Database@@ Property [ sub@@ Properties . size ( ) ] ; property = new Custom@@ Property ( propertyName , sub@@ Properties . toArray ( sub@@ Property@@ Array ) ) ; } else property = null ; return property ; }
 private static boolean isValid@@ Multi@@ Aggregate ( CP@@ lan@@ Memo@@ Table memo , Memo@@ TableEntry me ) { boolean ret = true ; Hop ref@@ Size = memo . getH@@ op@@ Refs ( ) . get ( me . input1 ) . getInput ( ) . get ( 0 ) ; for ( int i = 1 ; ret && i < 3 ; i ++ ) { if ( me . is@@ Plan@@ Ref ( i ) ) ret &= Hop@@ Rewrite@@ Utils . is@@ Equal@@ Size ( ref@@ Size , memo . getH@@ op@@ Refs ( ) . get ( me . input ( i ) ) . getInput ( ) . get ( 0 ) ) ; } for ( int i = 0 ; ret && i < 3 ; i ++ ) if ( me . is@@ Plan@@ Ref ( i ) ) { HashSet < Long > probe = new HashSet < > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) if ( i != j ) probe . add ( me . input ( j ) ) ; ret &= r@@ Check@@ Multi@@ Aggregate ( memo . getH@@ op@@ Refs ( ) . get ( me . input ( i ) ) , probe ) ; } return ret ; }
 private static boolean is@@ Implicit@@ ly@@ F@@ used ( Hop hop , int index , Template@@ Type type ) { return type == Template@@ Type . ROW && Hop@@ Rewrite@@ Utils . is@@ Matrix@@ Multiply ( hop ) && index == 0 && Hop@@ Rewrite@@ Utils . is@@ Transpo@@ se@@ Operation ( hop . getInput ( ) . get ( index ) ) ; }
 public static Download@@ HttpClient build ( String group , boolean safe ) { return new Download@@ HttpClient ( group , safe ) ; }
 public static Z@@ oo fil@@ led@@ Z@@ oo ( ) { Z@@ oo z@@ oo = new Z@@ oo ( ) ; E@@ le@@ ph@@ ant ele@@ ph@@ ant = fil@@ led@@ E@@ le@@ ph@@ ant ( ) ; Be@@ ar be@@ ar = fil@@ led@@ Be@@ ar ( ) ; Ti@@ ger ti@@ ger = fil@@ led@@ Ti@@ ger ( ) ; z@@ oo . lar@@ gest@@ An@@ imal = ele@@ ph@@ ant ; z@@ oo . anim@@ als . add ( be@@ ar ) ; z@@ oo . anim@@ als . add ( ti@@ ger ) ; z@@ oo . anim@@ als . add ( ele@@ ph@@ ant ) ; return z@@ oo ; }
 private static void validate@@ Type ( String function , O@@ GC@@ Geometry geometry , Set < Geometry@@ Type > valid@@ Types ) { Geometry@@ Type type = Geometry@@ Type . get@@ For@@ Es@@ ri@@ Geometry@@ Type ( geometry . geometry@@ Type ( ) ) ; if ( ! valid@@ Types . contains ( type ) ) { throw new Presto@@ Exception ( INVALID_@@ FUNCTION_@@ ARGUMENT , format ( " % s ▁ only ▁ applies ▁ to ▁ % s . ▁ Input ▁ type ▁ is : ▁ % s " , function , OR_@@ JOIN@@ ER . join ( valid@@ Types ) , type ) ) ; } }
 public static Testing@@ Privilege privilege ( String userName , String entity@@ Name , Testing@@ Privilege@@ Type type ) { return new Testing@@ Privilege ( Optional . of ( userName ) , entity@@ Name , type ) ; }
 private static boolean isValid@@ Row@@ 2@@ Cell@@ Op ( Hop hop ) { return ! ( Hop@@ Rewrite@@ Utils . is@@ Binary ( hop , Op@@ Op2 . C@@ BIND ) || ( hop instanceof Agg@@ Binary@@ Op && hop . get@@ Di@@ m1 ( ) != 1 && hop . get@@ Di@@ m2 ( ) != 1 ) ) ; }
 private static boolean null@@ Safe@@ Compare ( String s1 , String s2 ) { if ( s1 == null && s2 == null ) { return true ; } if ( s1 == null && s2 != null ) { return false ; } return s1 != null && s1 . equals ( s2 ) ; }
 private static double get@@ Materializ@@ ation@@ Cost ( Plan@@ Partition part , Interest@@ ing@@ Point [ ] M , CP@@ lan@@ Memo@@ Table memo , boolean [ ] plan ) { double costs = 0 ; HashSet < Long > mat@@ Targets = new HashSet < > ( ) ; for ( int i = 0 ; i < plan . length ; i ++ ) { long hop@@ ID = M [ i ] . getTo@@ Hop@@ ID ( ) ; if ( plan [ i ] && ! mat@@ Targets . contains ( hop@@ ID ) ) { mat@@ Targets . add ( hop@@ ID ) ; Hop hop = memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) ; long size = getSize ( hop ) ; costs += size * 8 / WRITE_@@ B@@ AND@@ WIDTH_@@ MEM + size * 8 / READ_@@ B@@ AND@@ WIDTH_@@ MEM ; } } for ( Long hop@@ ID : part . get@@ Ext@@ Consumed ( ) ) if ( ! mat@@ Targets . contains ( hop@@ ID ) ) { mat@@ Targets . add ( hop@@ ID ) ; Hop hop = memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) ; costs += getSize ( hop ) * 8 / WRITE_@@ B@@ AND@@ WIDTH_@@ MEM ; } return costs ; }
 synchronized public static org . omg . CORBA . TypeCode type ( ) { if ( __@@ type@@ Code == null ) { synchronized ( org . omg . CORBA . TypeCode . class ) { if ( __@@ type@@ Code == null ) { if ( __@@ active ) { return org . omg . CORBA . ORB . init ( ) . create_@@ recursive_@@ tc ( _id ) ; } __@@ active = true ; org . omg . CORBA . Struct@@ Member [ ] _@@ member@@ s0 = new org . omg . CORBA . Struct@@ Member [ 3 ] ; org . omg . CORBA . TypeCode _tc@@ O@@ f_@@ member@@ s0 = null ; _tc@@ O@@ f_@@ member@@ s0 = org . omg . CORBA . ORB . init ( ) . create_@@ string_@@ tc ( 0 ) ; _@@ member@@ s0 [ 0 ] = new org . omg . CORBA . Struct@@ Member ( " micro@@ svc " , _tc@@ O@@ f_@@ member@@ s0 , null ) ; _tc@@ O@@ f_@@ member@@ s0 = org . omg . CORBA . ORB . init ( ) . get_@@ primitive_@@ tc ( org . omg . CORBA . TC@@ Kind . t@@ k_@@ boolean ) ; _@@ member@@ s0 [ 1 ] = new org . omg . CORBA . Struct@@ Member ( " backup " , _tc@@ O@@ f_@@ member@@ s0 , null ) ; _tc@@ O@@ f_@@ member@@ s0 = org . omg . CORBA . ORB . init ( ) . get_@@ primitive_@@ tc ( org . omg . CORBA . TC@@ Kind . t@@ k_@@ octet ) ; _tc@@ O@@ f_@@ member@@ s0 = org . omg . CORBA . ORB . init ( ) . create_@@ sequence_@@ tc ( 0 , _tc@@ O@@ f_@@ member@@ s0 ) ; _tc@@ O@@ f_@@ member@@ s0 = org . omg . CORBA . ORB . init ( ) . create_@@ alias_@@ tc ( com . pri@@ sm@@ tech . agent@@ v . core . types . Byte@@ Seq@@ Helper . id ( ) , " ByteSeq " , _tc@@ O@@ f_@@ member@@ s0 ) ; _@@ member@@ s0 [ 2 ] = new org . omg . CORBA . Struct@@ Member ( " payload " , _tc@@ O@@ f_@@ member@@ s0 , null ) ; __@@ type@@ Code = org . omg . CORBA . ORB . init ( ) . create_@@ struct_@@ tc ( com . pri@@ sm@@ tech . agent@@ v . core . types . Upgrade@@ Micro@@ sv@@ c@@ Helper . id ( ) , " Upgrade@@ Micro@@ svc " , _@@ member@@ s0 ) ; __@@ active = false ; } } } return __@@ type@@ Code ; }
 private static boolean has@@ No@@ Ref@@ To@@ Mat@@ Point ( long hop@@ ID , Memo@@ TableEntry me , Interest@@ ing@@ Point [ ] M , boolean [ ] plan ) { return ! Interest@@ ing@@ Point . is@@ Mat@@ Point ( M , hop@@ ID , me , plan ) ; }
 private static void exit ( String message , int code , boolean print@@ Help ) { throw new Exit@@ Exception ( code , print@@ Help , message ) ; }
 public static Be@@ ar fil@@ led@@ Be@@ ar ( ) { Be@@ ar be@@ ar = new Be@@ ar ( ) ; be@@ ar . some@@ Be@@ ar@@ Field = " bear@@ Field " ; be@@ ar . normal@@ Body@@ Temperature = 2@@ 0f ; be@@ ar . proper@@ Name = " be@@ ar " ; return be@@ ar ; }
 public static void set@@ Css@@ Injector ( CSS@@ Injector css@@ Injector ) { CS@@ SH@@ el@@ per . css@@ Injector = css@@ Injector ; }
 public static String getString@@ Size ( Language language , long size ) { NumberFormat format = NumberFormat . getNumber@@ Instance ( language . getLocale ( ) ) ; if ( size < BYTES_@@ LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18@@ N@@ Connector . getLabel ( language , String@@ FileSize . class , BYTE_@@ LB@@ L ) ) ; return buffer . toString ( ) ; } else if ( size < K@@ B_@@ LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / BYTES_@@ LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18@@ N@@ Connector . getLabel ( language , String@@ FileSize . class , K@@ BYTE_@@ LB@@ L ) ) ; return buffer . toString ( ) ; } else if ( size < MB_@@ LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / K@@ B_@@ LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18@@ N@@ Connector . getLabel ( language , String@@ FileSize . class , M@@ BYTE_@@ LB@@ L ) ) ; return buffer . toString ( ) ; } else if ( size < G@@ B_@@ LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / MB_@@ LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18@@ N@@ Connector . getLabel ( language , String@@ FileSize . class , G@@ BYTE_@@ LB@@ L ) ) ; return buffer . toString ( ) ; } else { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / G@@ B_@@ LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18@@ N@@ Connector . getLabel ( language , String@@ FileSize . class , G@@ BYTE_@@ LB@@ L ) ) ; return buffer . toString ( ) ; } }
 public static Testing@@ Privilege privilege ( String entity@@ Name , Testing@@ Privilege@@ Type type ) { return new Testing@@ Privilege ( Optional . empty ( ) , entity@@ Name , type ) ; }
 private static long getNum@@ Skip@@ Plan@@ s ( boolean [ ] plan ) { int pos = ArrayUtils . lastIndexOf ( plan , true ) ; return Util@@ Functions . pow ( 2 , plan . length - pos - 1 ) ; }
 public static com . pri@@ sm@@ tech . agent@@ v . core . types . Upgrade@@ Micro@@ svc read ( org . omg . CORBA . portable . InputStream istream ) { com . pri@@ sm@@ tech . agent@@ v . core . types . Upgrade@@ Micro@@ svc value = new com . pri@@ sm@@ tech . agent@@ v . core . types . Upgrade@@ Micro@@ svc ( ) ; value . micro@@ svc = istream . read_@@ string ( ) ; value . backup = istream . read_@@ boolean ( ) ; value . payload = com . pri@@ sm@@ tech . agent@@ v . core . types . Byte@@ Seq@@ Helper . read ( istream ) ; return value ; }
 public static List < KeyValue > extract@@ Label@@ ValueFrom@@ Response ( HttpResponse response , Map < String , Integer > key@@ Position@@ Map ) throws IOException { List < KeyValue > key@@ Values = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : key@@ Position@@ Map . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " > ( \\ S + ) < / label > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue key@@ Value = new KeyValue ( key , m . group ( 1 ) ) ; key@@ Values . add ( key@@ Value ) ; return key@@ Values ; } } } } rd . close ( ) ; return null ; }
 protected static SQLException append@@ MessageTo@@ Exception ( SQLException sql@@ Ex , String message@@ To@@ Append , Exception@@ Interceptor interceptor ) { String orig@@ Message = sql@@ Ex . getMessage ( ) ; String sql@@ State = sql@@ Ex . get@@ SQL@@ State ( ) ; int vendor@@ ErrorCode = sql@@ Ex . get@@ ErrorCode ( ) ; StringBuilder message@@ Buf = new StringBuilder ( orig@@ Message . length ( ) + message@@ To@@ Append . length ( ) ) ; message@@ Buf . append ( orig@@ Message ) ; message@@ Buf . append ( message@@ To@@ Append ) ; SQLException sql@@ Exception@@ With@@ New@@ Message = SQL@@ Error . create@@ SQLException ( message@@ Buf . toString ( ) , sql@@ State , vendor@@ ErrorCode , interceptor ) ; try { Method get@@ StackTrace@@ Method = null ; Method set@@ StackTrace@@ Method = null ; Object the@@ StackTrace@@ As@@ Object = null ; Class < ? > stack@@ Trace@@ Element@@ Class = Class . forName ( " java . lang . StackTraceElement " ) ; Class < ? > stack@@ Trace@@ Element@@ Array@@ Class = Array . newInstance ( stack@@ Trace@@ Element@@ Class , new int [ ] { 0 } ) . getClass ( ) ; get@@ StackTrace@@ Method = Throwable . class . getMethod ( " getStackTrace " , new Class [ ] { } ) ; set@@ StackTrace@@ Method = Throwable . class . getMethod ( " set@@ StackTrace " , new Class [ ] { stack@@ Trace@@ Element@@ Array@@ Class } ) ; if ( get@@ StackTrace@@ Method != null && set@@ StackTrace@@ Method != null ) { the@@ StackTrace@@ As@@ Object = get@@ StackTrace@@ Method . invoke ( sql@@ Ex , new Object [ 0 ] ) ; set@@ StackTrace@@ Method . invoke ( sql@@ Exception@@ With@@ New@@ Message , new Object [ ] { the@@ StackTrace@@ As@@ Object } ) ; } } catch ( No@@ Class@@ Def@@ Found@@ Error no@@ Class@@ Def@@ Found ) { } catch ( NoSuchMethodException no@@ Such@@ Method@@ Ex ) { } catch ( Throwable catch@@ All ) { } return sql@@ Exception@@ With@@ New@@ Message ; }
 @ Output@@ Function ( GEOME@@ TRY_@@ TYPE_NAME ) public static void output ( @ Aggregation@@ State Geometry@@ State state , BlockBuilder out ) { if ( state . get@@ Geometry ( ) == null ) { out . append@@ Null ( ) ; } else { GEOME@@ TRY . write@@ Slice ( out , Geometry@@ Ser@@ de . serialize ( state . get@@ Geometry ( ) ) ) ; } }
 public static boolean handle@@ Provin@@ ce@@ Response ( String response ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray all@@ Provin@@ ces = new JSONArray ( response ) ; for ( int i = 0 ; i < all@@ Provin@@ ces . length ( ) ; i ++ ) { JSONObject provin@@ ce@@ Object = all@@ Provin@@ ces . getJSONObject ( i ) ; Provin@@ ce provin@@ ce = new Provin@@ ce ( ) ; provin@@ ce . set@@ Provin@@ ce@@ Name ( provin@@ ce@@ Object . getString ( " name " ) ) ; provin@@ ce . set@@ Provin@@ ce@@ Code ( provin@@ ce@@ Object . getInt ( " id " ) ) ; provin@@ ce . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
 private static boolean [ ] create@@ Assignment ( int len , int off , long pos ) { boolean [ ] ret = new boolean [ off + len ] ; Arrays . fill ( ret , 0 , off , true ) ; long tmp = pos ; for ( int i = 0 ; i < len ; i ++ ) { long mask = Util@@ Functions . pow ( 2 , len - i - 1 ) ; ret [ off + i ] = tmp >= mask ; tmp %= mask ; } return ret ; }
 private static double sum@@ Tmp@@ Input@@ Output@@ Size ( CP@@ lan@@ Memo@@ Table memo , Cost@@ Vector vect ) { return vect . out@@ Size + vect . in@@ Sizes . entrySet ( ) . stream ( ) . filter ( e -> ! Hop@@ Rewrite@@ Utils . is@@ Data ( memo . getH@@ op@@ Refs ( ) . get ( e . getKey ( ) ) , Data@@ Op@@ Types . TRANSI@@ ENT@@ READ ) ) . mapTo@@ Double ( e -> e . getValue ( ) ) . sum ( ) ; }
 private static boolean [ ] get@@ Plan ( Partition@@ Signature pKey ) { boolean [ ] plan = null ; synchronized ( _@@ plan@@ Cache ) { plan = _@@ plan@@ Cache . get ( pKey ) ; } if ( Configuration@@ Manager . is@@ Statistics ( ) ) { if ( plan != null ) Statistics . increment@@ Code@@ gen@@ Plan@@ Cache@@ Hits ( ) ; Statistics . increment@@ Code@@ gen@@ Plan@@ Cache@@ Total ( ) ; } return plan ; }
 private static synchronized int get@@ Updated@@ Length ( int length , int numberOf@@ Incre@@ asing@@ Elements ) { if ( numberOf@@ Incre@@ asing@@ Elements > length ) { return numberOf@@ Incre@@ asing@@ Elements ; } else { return length ; } }
 public static Download@@ HttpClient build ( String group ) { return build ( group , true ) ; }
 public static String getString@@ Size ( long size ) { Language lang = I18@@ N@@ Connector . get@@ ThreadLocal@@ Language ( ) ; return getString@@ Size ( lang , size ) ; }
 protected static Connection getInstance ( String host@@ To@@ Connect@@ To , int port@@ To@@ Connect@@ To , Properties info , String database@@ To@@ Connect@@ To , String url ) throws SQLException { if ( ! Util . is@@ Jdbc@@ 4 ( ) ) { return new Connection@@ Impl ( host@@ To@@ Connect@@ To , port@@ To@@ Connect@@ To , info , database@@ To@@ Connect@@ To , url ) ; } return ( Connection ) Util . handle@@ New@@ Instance ( JDB@@ C_@@ 4_@@ CONNECTION_@@ CTOR , new Object [ ] { host@@ To@@ Connect@@ To , Integer . valueOf ( port@@ To@@ Connect@@ To ) , info , database@@ To@@ Connect@@ To , url } , null ) ; }
 private static void r@@ Collect@@ Full@@ Aggreg@@ ates ( Hop current , HashSet < Long > ag@@ gs ) { if ( current . is@@ Visited ( ) ) return ; if ( isMulti@@ Aggregate@@ Root ( current ) ) ag@@ gs . add ( current . getH@@ op@@ ID ( ) ) ; for ( Hop c : current . getInput ( ) ) r@@ Collect@@ Full@@ Aggreg@@ ates ( c , ag@@ gs ) ; current . set@@ Visited ( ) ; }
 private static void r@@ Prun@@ e@@ Sub@@ optim@@ al@@ Plan@@ s ( CP@@ lan@@ Memo@@ Table memo , Hop current , HashSet < Long > visited , Plan@@ Partition part , Interest@@ ing@@ Point [ ] mat@@ Points , boolean [ ] plan ) { if ( visited . contains ( current . getH@@ op@@ ID ( ) ) ) return ; long hop@@ ID = current . getH@@ op@@ ID ( ) ; if ( part . get@@ Partition ( ) . contains ( hop@@ ID ) && memo . contains ( hop@@ ID ) ) { Iterator < Memo@@ TableEntry > iter = memo . get ( hop@@ ID ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Memo@@ TableEntry me = iter . next ( ) ; if ( ! has@@ No@@ Ref@@ To@@ Mat@@ Point ( hop@@ ID , me , mat@@ Points , plan ) && me . type != Template@@ Type . OUTER ) { iter . remove ( ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ memo ▁ table ▁ entry : ▁ " + me ) ; } } } for ( Hop c : current . getInput ( ) ) r@@ Prun@@ e@@ Sub@@ optim@@ al@@ Plan@@ s ( memo , c , visited , part , mat@@ Points , plan ) ; visited . add ( current . getH@@ op@@ ID ( ) ) ; }
 @ Nonnull private static String getGeneric@@ Class@@ Signature ( @ Nonnull Type mocked@@ Type ) { StringBuilder signature = new StringBuilder ( 100 ) ; if ( mocked@@ Type instanceof ParameterizedType ) { ParameterizedType parameter@@ ized@@ Type = ( ParameterizedType ) mocked@@ Type ; Type [ ] type@@ Arguments = parameter@@ ized@@ Type . getActual@@ Type@@ Arguments ( ) ; if ( type@@ Arguments . length > 0 ) { signature . append ( ' < ' ) ; for ( Type type@@ Arg : type@@ Arguments ) { if ( type@@ Arg instanceof Class < ? > ) { Class < ? > class@@ Arg = ( Class < ? > ) type@@ Arg ; signature . append ( ' L ' ) . append ( class@@ Arg . getName ( ) . replace ( ' . ' , ' / ' ) ) . append ( ' ; ' ) ; } else { signature . append ( ' * ' ) ; } } signature . append ( ' > ' ) ; } } signature . append ( ' ; ' ) ; return signature . toString ( ) ; }
 public static String extract@@ AccessToken@@ From@@ QueryString ( String query ) { String [ ] params = query . split ( " & " ) ; for ( String param : params ) { String name = param . split ( " = " ) [ 0 ] ; String value = param . split ( " = " ) [ 1 ] ; if ( name . contains ( " access _ token " ) ) return value ; } return null ; }
 public static List < KeyValue > extract@@ Session@@ Con@@ sent@@ DataFrom@@ Response ( HttpResponse response , Map < String , Integer > key@@ Position@@ Map ) throws IOException { boolean line@@ Reached = false ; List < KeyValue > key@@ Values = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : key@@ Position@@ Map . keySet ( ) ) { if ( line . contains ( key ) ) { line@@ Reached = true ; } if ( line@@ Reached ) { if ( line . contains ( " value " ) ) { String [ ] tokens = line . split ( " \@@ " " ) ; KeyValue key@@ Value = new KeyValue ( key , tokens [ 1 ] ) ; key@@ Values . add ( key@@ Value ) ; return key@@ Values ; } } } } rd . close ( ) ; return null ; }
 private static Connector@@ Table@@ Metadata build@@ Table ( Map < String , Object > properties , Table@@ Metadata@@ Builder builder ) { if ( ! properties . isEmpty ( ) ) { for ( Map . Entry < String , Object > entry : properties . entrySet ( ) ) { builder . property ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return builder . build ( ) ; }
 public static Schema < Drill@@ Service@@ Instance > getSchema ( ) { return DEFAULT_@@ INSTANCE ; }
 public static void insert ( org . omg . CORBA . Any a , com . pri@@ sm@@ tech . agent@@ v . core . types . Upgrade@@ Micro@@ svc that ) { org . omg . CORBA . portable . OutputStream out = a . create_@@ output_@@ stream ( ) ; a . type ( type ( ) ) ; write ( out , that ) ; a . read_@@ value ( out . create_@@ input_stream ( ) , type ( ) ) ; }
 public static Builder builder ( Column@@ Metadata ... columns ) { return builder ( ImmutableList . copyOf ( columns ) ) ; }
 public static boolean handle@@ City@@ Response ( String response , int provin@@ ce@@ Id ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray all@@ C@@ ities = new JSONArray ( response ) ; for ( int i = 0 ; i < all@@ C@@ ities . length ( ) ; i ++ ) { JSONObject city@@ Object = all@@ C@@ ities . getJSONObject ( i ) ; City city = new City ( ) ; city . set@@ City@@ Name ( city@@ Object . getString ( " name " ) ) ; city . set@@ City@@ Code ( city@@ Object . getInt ( " id " ) ) ; city . set@@ Provin@@ ce@@ Id ( provin@@ ce@@ Id ) ; city . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
 @ Combine@@ Function public static void combine ( @ Aggregation@@ State Geometry@@ State state , @ Aggregation@@ State Geometry@@ State other@@ State ) { if ( state . get@@ Geometry ( ) == null ) { state . setGeometry ( other@@ State . get@@ Geometry ( ) ) ; } else if ( other@@ State . get@@ Geometry ( ) != null && ! other@@ State . get@@ Geometry ( ) . isEmpty ( ) ) { state . setGeometry ( state . get@@ Geometry ( ) . union ( other@@ State . get@@ Geometry ( ) ) . convex@@ Hull ( ) ) ; } }
 private static HashSet < Long > collect@@ Ir@@ replace@@ able@@ Row@@ Ops ( CP@@ lan@@ Memo@@ Table memo , Plan@@ Partition part ) { HashSet < Long > blacklist = new HashSet < > ( ) ; HashSet < Pair < Long , Integer > > visited = new HashSet < > ( ) ; for ( Long hop@@ ID : part . get@@ Roots ( ) ) { r@@ Collect@@ Dependent@@ Row@@ Ops ( memo . getH@@ op@@ Refs ( ) . get ( hop@@ ID ) , memo , part , blacklist , visited , null , false ) ; } return blacklist ; }
 private static final Default@@ Format DATE_FORMAT = new Default@@ Format ( DateTimeFormat . getFormat ( " yyyy / MM / dd - HH : mm : ss " ) ) { @ Override public Date parse ( final Date@@ Box box , final String text , final boolean report_@@ error ) { if ( text . endsWith ( " ▁ ago " ) || text . endsWith ( " - ago " ) ) { int interval ; final int last@@ char = text . length ( ) - 5 ; try { interval = Integer . parseInt ( text . substring ( 0 , last@@ char ) ) ; } catch ( NumberFormatException e ) { setError ( box ) ; return null ; } if ( interval <= 0 ) { setError ( box ) ; return null ; } switch ( text . charAt ( last@@ char ) ) { case ' s ' : break ; case ' m ' : interval *= 60 ; break ; case ' h ' : interval *= 3600 ; break ; case ' d ' : interval *= 3600 * 24 ; break ; case ' w ' : interval *= 3600 * 24 * 7 ; break ; case ' y ' : interval *= 3600 * 24 * 365 ; break ; } final Date d = new Date ( ) ; d . setTime ( d . getTime ( ) - interval * 1000L ) ; return d ; } else if ( text . length ( ) == 5 ) { try { return HH@@ MM_@@ FORMAT . parse ( text ) ; } catch ( IllegalArgumentException ignored ) { setError ( box ) ; return null ; } } return super . parse ( box , text , report_@@ error ) ; } private void setError ( final Date@@ Box box ) { box . add@@ StyleName ( " date@@ Box@@ Format@@ Error " ) ; } }
 public static void add@@ CSS@@ Name ( UI@@ Object parent , String s@@ Child@@ Css@@ Name , String s@@ CSS@@ Name ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int i@@ Node = 0 ; i@@ Node < list . getLength ( ) ; i@@ Node ++ ) { Element e = list . getItem ( i@@ Node ) ; if ( ( e . getClassName ( ) ) . contains ( s@@ Child@@ Css@@ Name ) ) { add@@ CSS@@ Name ( e , s@@ CSS@@ Name ) ; } } }
 private static double sum@@ Input@@ Memory@@ Estimat@@ es ( CP@@ lan@@ Memo@@ Table memo , Cost@@ Vector vect ) { return vect . in@@ Sizes . keySet ( ) . stream ( ) . mapTo@@ Double ( e -> get@@ Safe@@ Mem@@ E@@ st ( memo . getH@@ op@@ Refs ( ) . get ( e ) ) ) . sum ( ) ; }
 public static String id ( ) { return _id ; }
 public static Map < Scan , Field@@ List > getField@@ Lists ( Logical@@ Plan plan ) { Collection < Sink@@ Operator > ops = plan . get@@ Graph ( ) . get@@ Roots ( ) ; Preconditions . checkArgument ( ops . size ( ) == 1 , " Scan ▁ Field ▁ determin@@ er ▁ currently ▁ only ▁ works ▁ with ▁ plans ▁ that ▁ have ▁ a ▁ single ▁ root . " ) ; Scan@@ Field@@ Determin@@ er s@@ fd = new Scan@@ Field@@ Determin@@ er ( ) ; ops . iterator ( ) . next ( ) . accept ( s@@ fd , new Field@@ List ( ) ) ; return s@@ fd . scan@@ Fields ; }
 private static boolean r@@ Check@@ Multi@@ Aggregate ( Hop current , HashSet < Long > probe ) { boolean ret = true ; for ( Hop c : current . getInput ( ) ) ret &= r@@ Check@@ Multi@@ Aggregate ( c , probe ) ; ret &= ! probe . contains ( current . getH@@ op@@ ID ( ) ) ; return ret ; }
 public static synchronized int run ( Vector x ) { Vector@@ Rules . isValid ( x ) ; int n = x . get@@ Dimensions ( ) ; int length = 1 ; int numberOf@@ Incre@@ asing@@ Elements = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( x . get ( i ) . is@@ LessThan ( x . get ( i + 1 ) ) ) { numberOf@@ Incre@@ asing@@ Elements += 1 ; if ( i == n - 2 ) { length = get@@ Updated@@ Length ( length , numberOf@@ Incre@@ asing@@ Elements ) ; } continue ; } else { length = get@@ Updated@@ Length ( length , numberOf@@ Incre@@ asing@@ Elements ) ; numberOf@@ Incre@@ asing@@ Elements = 1 ; } } return length ; }
 private static void r@@ Extract@@ Aggregate@@ Info ( CP@@ lan@@ Memo@@ Table memo , Hop current , Aggregate@@ Info agg@@ Info , Template@@ Type type ) { if ( isMulti@@ Aggregate@@ Root ( current ) ) agg@@ Info . add@@ Input@@ Aggregate ( current . getH@@ op@@ ID ( ) ) ; Memo@@ TableEntry me = ( type != null ) ? memo . get@@ Best ( current . getH@@ op@@ ID ( ) ) : null ; for ( int i = 0 ; i < current . getInput ( ) . size ( ) ; i ++ ) { Hop c = current . getInput ( ) . get ( i ) ; if ( me != null && me . is@@ Plan@@ Ref ( i ) ) r@@ Extract@@ Aggregate@@ Info ( memo , c , agg@@ Info , type ) ; else { if ( type != null && c . getDataType ( ) . is@@ Matrix ( ) ) agg@@ Info . add@@ F@@ used@@ Input ( c . getH@@ op@@ ID ( ) ) ; r@@ Extract@@ Aggregate@@ Info ( memo , c , agg@@ Info , null ) ; } } }
 public static void main ( String [ ] args ) { System . out . println ( " Hello , ▁ world " ) ; }
 private static void assert@@ Table@@ Equal ( Connector@@ Table@@ Metadata actual , Connector@@ Table@@ Metadata expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; List < Column@@ Metadata > actual@@ Columns = actual . getColumns ( ) . stream ( ) . filter ( column@@ Metadata -> ! column@@ Metadata . isHidden ( ) ) . collect ( Collectors . toList ( ) ) ; List < Column@@ Metadata > expected@@ Columns = expected . getColumns ( ) ; assertEquals ( actual@@ Columns . size ( ) , expected@@ Columns . size ( ) ) ; for ( int i = 0 ; i < actual@@ Columns . size ( ) ; i ++ ) { Column@@ Metadata actual@@ Column = actual@@ Columns . get ( i ) ; Column@@ Metadata expected@@ Column = expected@@ Columns . get ( i ) ; assertEquals ( actual@@ Column . getName ( ) , expected@@ Column . getName ( ) ) ; assertEquals ( actual@@ Column . getType ( ) , expected@@ Column . getType ( ) ) ; } assertEquals ( actual . getProperties ( ) , expected . getProperties ( ) ) ; }
 private static Optional < String > getItem@@ Target ( String full@@ Command ) { if ( ! StringUtils . contains@@ IgnoreCase ( full@@ Command , ON_@@ KEYWORD ) ) { return Optional . empty ( ) ; } List < String > parts = Arrays . asList ( full@@ Command . split ( " ( ? i ) " + ON_@@ KEYWORD , 2 ) ) ; if ( parts . size ( ) > 1 ) { String item = parts . get ( 1 ) ; return Optional . of ( item . trim ( ) ) ; } return Optional . empty ( ) ; }
 private static Connector@@ Table@@ Metadata getLine@@ Items@@ Table ( Map < String , Object > properties ) { return build@@ Table ( properties , table@@ Metadata@@ Builder ( DEFAULT_@@ TEST_@@ LINE@@ ITEMS ) . column ( " order@@ key " , BIGINT ) . column ( " part@@ key " , BIGINT ) . column ( " quantity " , DOUBLE ) . column ( " price " , DOUBLE ) ) ; }
 public static boolean handle@@ Country@@ Response ( String res@@ onse , int city@@ Id ) { if ( ! TextUtils . isEmpty ( res@@ onse ) ) { try { JSONArray all@@ Coun@@ tries = new JSONArray ( res@@ onse ) ; for ( int i = 0 ; i < all@@ Coun@@ tries . length ( ) ; i ++ ) { JSONObject country@@ Object = all@@ Coun@@ tries . getJSONObject ( i ) ; Country country = new Country ( ) ; country . set@@ Country@@ Name ( country@@ Object . getString ( " name " ) ) ; country . set@@ Weather@@ Id ( country@@ Object . getString ( " weather _ id " ) ) ; country . set@@ City@@ Id ( city@@ Id ) ; country . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
 public static String get@@ DateTime@@ String ( Offset@@ DateTime time ) { return time . format ( dt@@ Formatter ) ; }
 @ BeforeClass public static void testSet@@ Up ( ) throws Exception { test@@ Drill@@ Driver = new Driver ( ) ; }
 private static Artifact@@ Resol@@ ving@@ Helper get@@ Resol@@ ving@@ Helper ( final List < String > repos ) { final Configurable@@ Maven@@ Resolver@@ System resolver = M@@ aven . configure@@ Resolver ( ) . with@@ Maven@@ Central@@ Repo ( true ) . with@@ Remote@@ Repo ( Maven@@ Remote@@ Repositories . create@@ Remote@@ Repository ( " jboss - public - repository - group " , " https : // repository . jboss . org / nexus / content / groups / public / " , " default " ) . set@@ Checksum@@ Policy ( Maven@@ Checksum@@ Policy . CHECK@@ S@@ UM_@@ POLICY_@@ IGNORE ) . set@@ Update@@ Policy ( Maven@@ Update@@ Policy . UPDATE_@@ POLICY_@@ NEVER ) ) ; repos . forEach ( r -> resolver . with@@ Remote@@ Repo ( Maven@@ Remote@@ Repositories . create@@ Remote@@ Repository ( r , r , " default " ) . set@@ Checksum@@ Policy ( Maven@@ Checksum@@ Policy . CHECK@@ S@@ UM_@@ POLICY_@@ IGNORE ) . set@@ Update@@ Policy ( Maven@@ Update@@ Policy . UPDATE_@@ POLICY_@@ NEVER ) ) ) ; return new Shr@@ in@@ kw@@ rap@@ Artifact@@ Resol@@ ving@@ Helper ( resolver ) ; }
 public static Offset@@ DateTime get@@ Creation@@ Time ( String entityId ) { try { long timestamp = ( ( Long . parseLong ( entityId ) >> 22 ) + 14@@ 2007@@ 04@@ 0000@@ 0L ) ; Calendar g@@ mt = Calendar . getInstance ( TimeZone . getTimeZone ( " GMT " ) ) ; g@@ mt . setTime@@ InMillis ( timestamp ) ; return Offset@@ DateTime . of@@ Instant ( g@@ mt . to@@ Instant ( ) , g@@ mt . getTimeZone ( ) . to@@ ZoneId ( ) ) ; } catch ( NumberFormatException ex ) { return null ; } }
 private static void assert@@ Table@@ Column@@ Equal ( TableColumn actual , TableColumn expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; assertEquals ( actual . getColumn@@ Id ( ) , expected . getColumn@@ Id ( ) ) ; assertEquals ( actual . getColumn@@ Name ( ) , expected . getColumn@@ Name ( ) ) ; assertEquals ( actual . getDataType ( ) , expected . getDataType ( ) ) ; assertEquals ( actual . getOr@@ din@@ al@@ Position ( ) , expected . getOr@@ din@@ al@@ Position ( ) ) ; assertEquals ( actual . getBucket@@ Ordinal ( ) , expected . getBucket@@ Ordinal ( ) ) ; assertEquals ( actual . get@@ Sort@@ Ordinal ( ) , expected . get@@ Sort@@ Ordinal ( ) ) ; assertEquals ( actual . is@@ Tempor@@ al ( ) , expected . is@@ Tempor@@ al ( ) ) ; }
 private static long getSize ( Hop hop ) { return Math . max ( hop . get@@ Di@@ m1 ( ) , 1 ) * Math . max ( hop . get@@ Di@@ m2 ( ) , 1 ) ; }
 private static void add@@ S@@ warm@@ Fr@@ actions ( Build@@ Tool tool , final List < String > deps ) { deps . stream ( ) . map ( f -> f . split ( " : " ) ) . map ( parts -> { switch ( parts . length ) { case 1 : final Fraction@@ Descriptor desc = Fraction@@ List . get ( ) . get@@ Fraction@@ Descriptor ( " org . wildfly . s@@ warm " , parts [ 0 ] ) ; if ( desc != null ) { return desc ; } else { System . err . println ( " Warning : ▁ Unknown ▁ fraction : ▁ " + parts [ 0 ] ) ; return null ; } case 2 : return new Fraction@@ Descriptor ( " org . wildfly . s@@ warm " , parts [ 0 ] , parts [ 1 ] ) ; case 3 : return new Fraction@@ Descriptor ( parts [ 0 ] , parts [ 1 ] , parts [ 2 ] ) ; default : System . err . println ( " Warning : ▁ Invalid ▁ fraction ▁ specifier : ▁ " + String . join ( " : " , parts ) ) ; return null ; } } ) . filter ( f -> f != null ) . forEach ( f -> tool . fraction ( Artifact@@ Spec . from@@ Fraction@@ Descriptor ( f ) ) ) ; }
 @ Input@@ Function public static void input ( @ Aggregation@@ State Geometry@@ State state , @ SqlType ( GEOME@@ TRY_@@ TYPE_NAME ) Slice input ) { O@@ GC@@ Geometry geometry = Geometry@@ Ser@@ de . deserialize ( input ) ; if ( state . get@@ Geometry ( ) == null ) { state . setGeometry ( geometry . convex@@ Hull ( ) ) ; } else if ( ! geometry . isEmpty ( ) ) { state . setGeometry ( state . get@@ Geometry ( ) . union ( geometry ) . convex@@ Hull ( ) ) ; } }
 public static void add@@ CSS@@ Name ( UI@@ Object parent , Map < String , String > custom@@ CSS ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int i@@ Node = 0 ; i@@ Node < list . getLength ( ) ; i@@ Node ++ ) { Element e = list . getItem ( i@@ Node ) ; String [ ] as = e . getClassName ( ) . split ( " ▁ " ) ; for ( String s@@ ClassName : as ) { if ( custom@@ CSS . containsKey ( s@@ ClassName ) ) { add@@ CSS@@ Name ( e , custom@@ CSS . get ( s@@ ClassName ) ) ; } } } }
 private static boolean is@@ Row@@ Agg@@ Op ( Hop hop , boolean in@@ Row ) { return Hop@@ Rewrite@@ Utils . is@@ Binary ( hop , Op@@ Op2 . C@@ BIND ) || Hop@@ Rewrite@@ Utils . is@@ N@@ ary ( hop , Op@@ Op@@ N . C@@ BIND ) || ( hop instanceof Agg@@ Binary@@ Op && ( in@@ Row || ! hop . di@@ ms@@ Known ( ) || ( hop . get@@ Di@@ m1 ( ) != 1 && hop . get@@ Di@@ m2 ( ) != 1 ) ) ) || ( Hop@@ Rewrite@@ Utils . is@@ Transpo@@ se@@ Operation ( hop ) && ( hop . get@@ Di@@ m1 ( ) != 1 && hop . get@@ Di@@ m2 ( ) != 1 ) && ! Hop@@ Rewrite@@ Utils . is@@ Data@@ Gen@@ Op ( hop . getInput ( ) . get ( 0 ) , Data@@ Gen@@ Method . SEQ ) ) || ( hop instanceof Agg@@ Unary@@ Op && in@@ Row ) ; }
 public static void main ( final String [ ] args ) throws Exception { try { generate@@ S@@ warm@@ Jar ( args ) ; } catch ( Exit@@ Exception e ) { final String msg = e . getMessage ( ) ; if ( msg != null ) { System . err . println ( msg ) ; } if ( e . print@@ Help ) { if ( msg != null ) { System . err . println ( ) ; } System . err . println ( String . format ( " Usage : ▁ % s ▁ < options > ▁ artifact - path \n " , executable@@ Name ( ) ) ) ; try { OPT_@@ PARSER . print@@ Help@@ On ( System . err ) ; } catch ( IOException ignored ) { } } System . exit ( e . status ) ; } }
 public static List < KeyValue > extract@@ Input@@ ValueFrom@@ Response ( HttpResponse response , Map < String , Integer > key@@ Position@@ Map ) throws IOException { List < KeyValue > key@@ Values = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : key@@ Position@@ Map . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " value = \@@ " ( \\ S + ) \@@ " " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue key@@ Value = new KeyValue ( key , m . group ( 1 ) ) ; key@@ Values . add ( key@@ Value ) ; return key@@ Values ; } } } } rd . close ( ) ; return null ; }
 public static void set@@ ThreadPool ( Pool@@ Manager . Pool pool ) { threadPool = pool ; }
 private static boolean is@@ D@@ fs@@ Client@@ Close ( DFS@@ Client c ) { try { c . exists ( " " ) ; } catch ( IOException e ) { return e . getMessage ( ) . equals ( " Filesystem ▁ closed " ) ; } return false ; }
 private static void exit ( String message , boolean print@@ Help ) { exit ( message , 1 , print@@ Help ) ; }
