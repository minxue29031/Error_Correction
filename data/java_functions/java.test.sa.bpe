 @ Nullable public static boolean [ ] read@@ Boolean@@ Array ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; boolean [ ] res = new boolean [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readBoolean ( ) ; return res ; }
 public static Store@@ Reader create@@ Reader ( InputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ stream , ▁ copying ▁ into ▁ temp ▁ folder " ) ; try { File file = Temp@@ Utils . copy@@ Into@@ Temp@@ File ( " pal@@ db@@ temp@@ reader " , stream ) ; LOGGER . log ( Level . INFO , " Copied ▁ stream ▁ into ▁ temp ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new Reader@@ Impl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
 public static void set@@ Ignite@@ Home ( @ Nullable String path ) { Grid@@ Tuple < String > gg@@ Home@@ T@@ up = gg@@ Home ; String gg@@ Home@@ 0 ; if ( gg@@ Home@@ T@@ up == null ) { synchronized ( Ignite@@ Utils . class ) { gg@@ Home@@ T@@ up = gg@@ Home ; if ( gg@@ Home@@ T@@ up == null ) { if ( F . isEmpty ( path ) ) System . clear@@ Property ( IGN@@ ITE_@@ HOME ) ; else System . setProperty ( IGN@@ ITE_@@ HOME , path ) ; gg@@ Home = F . t ( path ) ; return ; } else gg@@ Home@@ 0 = gg@@ Home@@ T@@ up . get ( ) ; } } else gg@@ Home@@ 0 = gg@@ Home@@ T@@ up . get ( ) ; if ( gg@@ Home@@ 0 != null && ! gg@@ Home@@ 0 . equals ( path ) ) throw new Ignite@@ Exception ( " Failed ▁ to ▁ set ▁ IGN@@ ITE _ HOME ▁ after ▁ it ▁ has ▁ been ▁ already ▁ resolved ▁ " + " [ ignite@@ Home = " + gg@@ Home@@ 0 + " , ▁ new@@ Ignite@@ Home = " + path + ' ] ' ) ; }
 @ Nullable public static String getNetwork@@ Interface@@ Name ( String addr ) { assert addr != null ; try { InetAddress inet@@ Addr = InetAddress . getByName ( addr ) ; for ( NetworkInterface it@@ f : as@@ Iterable ( NetworkInterface . getNetwork@@ Interfaces ( ) ) ) for ( InetAddress it@@ f@@ Addr : as@@ Iterable ( it@@ f . get@@ Inet@@ Addresses ( ) ) ) if ( it@@ f@@ Addr . equals ( inet@@ Addr ) ) return it@@ f . getDisplayName ( ) ; } catch ( UnknownHostException ignore ) { return null ; } catch ( SocketException ignore ) { return null ; } return null ; }
 private static Set < Long > get@@ Dead@@ locked@@ Thread@@ Ids ( Thread@@ MXBean mx@@ Bean ) { final long [ ] dead@@ locked@@ Ids = mx@@ Bean . find@@ Dead@@ locked@@ Threads ( ) ; final Set < Long > dead@@ locked@@ Threads@@ Ids ; if ( ! F . isEmpty ( dead@@ locked@@ Ids ) ) { Set < Long > set = new HashSet < > ( ) ; for ( long id : dead@@ locked@@ Ids ) set . add ( id ) ; dead@@ locked@@ Threads@@ Ids = Collections . unmodifiable@@ Set ( set ) ; } else dead@@ locked@@ Threads@@ Ids = Collections . emptySet ( ) ; return dead@@ locked@@ Threads@@ Ids ; }
 public static void qui@@ et@@ And@@ Warn ( Ignite@@ Logger log , Object msg , Object short@@ Msg ) { warn ( log , msg ) ; if ( log . is@@ Qu@@ i@@ et ( ) ) quiet ( false , short@@ Msg ) ; }
 public static String to@@ OS@@ FilePath ( String path ) { if ( path == null ) { return null ; } String norm@@ ali@@ ed@@ OS@@ Path = path . replace ( ' \ \@@ ' , File . separator@@ Char ) . replace ( ' / ' , File . separator@@ Char ) ; return normalize@@ Path ( norm@@ ali@@ ed@@ OS@@ Path ) ; }
 public static < T > void write@@ Array ( ObjectOutput out , T [ ] arr ) throws IOException { int len = arr == null ? 0 : arr . length ; out . writeInt ( len ) ; if ( arr != null && arr . length > 0 ) for ( T t : arr ) out . writeObject ( t ) ; }
 public static void write@@ Bytes@@ Collection ( DataOutput out , Collection < byte [ ] > bytes ) throws IOException { if ( bytes != null ) { out . writeInt ( bytes . size ( ) ) ; for ( byte [ ] b : bytes ) write@@ ByteArray ( out , b ) ; } else out . writeInt ( - 1 ) ; }
 public static boolean is@@ Solaris ( ) { return sol@@ aris ; }
 public static File getFile@@ From@@ InputStream ( InputStream inputStream , String file@@ Extension ) { FileOutputStream file@@ OutputStream = null ; File file = null ; try { file = File . createTempFile ( " eb@@ ay@@ Code@@ gen " , file@@ Extension ) ; byte [ ] bytes = new byte [ 10000 ] ; file@@ OutputStream = new FileOutputStream ( file ) ; int read@@ Count = 0 ; while ( ( read@@ Count = inputStream . read ( bytes ) ) > 0 ) { file@@ OutputStream . write ( bytes , 0 , read@@ Count ) ; } } catch ( IOException e ) { getLogger ( ) . log ( Level . INFO , " exception ▁ while ▁ trying ▁ to ▁ create ▁ the ▁ te@@ k@@ mp ▁ file ▁ : ▁ exception ▁ is ▁ : ▁ " + e . getMessage ( ) ) ; } finally { if ( file@@ OutputStream != null ) { try { file@@ OutputStream . close ( ) ; } catch ( IOException e ) { getLogger ( ) . log ( Level . FINE , " Exception ▁ while ▁ closing ▁ the ▁ file ▁ out@@ ut ▁ stream ▁ for ▁ the ▁ file ▁ " ) ; } } } return file ; }
 public static boolean contains@@ StringArray ( String [ ] arr , @ Nullable String val , boolean ignore@@ Case ) { assert arr != null ; for ( String s : arr ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignore@@ Case ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
 public static Ignite@@ Logger logger ( Grid@@ Ker@@ nal@@ Context ctx , AtomicReference < Ignite@@ Logger > log@@ Ref , Object obj ) { Ignite@@ Logger log = log@@ Ref . get ( ) ; if ( log == null ) { log@@ Ref . compareAndSet ( null , ctx . log ( obj . getClass ( ) ) ) ; log = log@@ Ref . get ( ) ; } return log ; }
 public static byte [ ] uuid@@ To@@ Bytes ( @ Nullable UUID uuid ) { return Grid@@ Client@@ Byte@@ Utils . uuid@@ To@@ Bytes ( uuid ) ; }
 public static void closeQuietly ( WSDL@@ Locator locator ) { if ( locator == null ) { return ; } locator . close ( ) ; }
 public static Collector < JsonValue , Json@@ Object@@ Builder , JsonObject > to@@ JsonObject ( Function < JsonValue , String > key@@ Mapper , Function < JsonValue , JsonValue > value@@ Mapper ) { return null ; }
 public static int [ ] to@@ IntArray ( @ Nullable Collection < Integer > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_@@ INTS ; int [ ] arr = new int [ c . size ( ) ] ; int idx = 0 ; for ( Integer i : c ) arr [ idx ++ ] = i ; return arr ; }
 public static long [ ] to@@ Long@@ Array ( @ Nullable Collection < Long > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_@@ LON@@ GS ; long [ ] arr = new long [ c . size ( ) ] ; int idx = 0 ; for ( Long l : c ) arr [ idx ++ ] = l ; return arr ; }
 private static String find@@ Project@@ Home ( File start@@ Dir ) { for ( File cur = start@@ Dir . getAbsolute@@ File ( ) ; cur != null ; cur = cur . getParentFile ( ) ) { if ( ! new File ( cur , " bin " ) . isDirectory ( ) || ! new File ( cur , " config " ) . isDirectory ( ) ) continue ; return cur . getPath ( ) ; } return null ; }
 public static void write@@ Int@@ Key@@ Int@@ ValueMap ( DataOutput out , Map < Integer , Integer > map ) throws IOException { if ( map != null ) { out . writeBoolean ( true ) ; out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeInt ( e . getValue ( ) ) ; } } else out . writeBoolean ( false ) ; }
 public static boolean is@@ Primitive@@ Array ( Object obj ) { Class < ? > cls = obj . getClass ( ) ; return cls . isArray ( ) && cls . getComponentType ( ) . is@@ Primitive ( ) ; }
 public static byte [ ] read@@ ByteArray ( ByteBuffer ... bufs ) { assert ! F . isEmpty ( bufs ) ; int size = 0 ; for ( ByteBuffer buf : bufs ) size += buf . remaining ( ) ; byte [ ] res = new byte [ size ] ; int off = 0 ; for ( ByteBuffer buf : bufs ) { int len = buf . remaining ( ) ; if ( len != 0 ) { buf . get ( res , off , len ) ; off += len ; } } assert off == res . length ; return res ; }
 public static boolean relax@@ Discovery@@ Ordered ( ) { return " true " . equalsIgnoreCase ( System . getProperty ( IGN@@ ITE_@@ NO_@@ DIS@@ CO_@@ ORDER ) ) ; }
 public static boolean reachable ( InetAddress addr , int reach@@ Timeout ) { try { return addr . is@@ Reachable ( reach@@ Timeout ) ; } catch ( IOException ignore ) { return false ; } }
 public static void delete@@ File ( File file ) throws IOException { if ( file == null || ! file . exists ( ) ) { return ; } if ( ! file . delete ( ) ) { throw new IOException ( " Can ' t ▁ delete ▁ file ▁ : ▁ " + file . getPath ( ) ) ; } }
 public static List < Plugin@@ Provider > all@@ Plugin@@ Providers ( ) { return AccessController . doPrivileged ( new PrivilegedAction < List < Plugin@@ Provider > > ( ) { @ Override public List < Plugin@@ Provider > run ( ) { List < Plugin@@ Provider > providers = new ArrayList < > ( ) ; Service@@ Loader < Plugin@@ Provider > ldr = Service@@ Loader . load ( Plugin@@ Provider . class ) ; for ( Plugin@@ Provider provider : ldr ) providers . add ( provider ) ; return providers ; } } ) ; }
 public static byte [ ] float@@ To@@ Bytes ( float f ) { return int@@ To@@ Bytes ( Float . float@@ To@@ Int@@ Bits ( f ) ) ; }
 @ Nullable public static Class < ? > class@@ ForName ( String cls , @ Nullable Class < ? > d@@ flt ) { try { return cls == null ? d@@ flt : Class . forName ( cls ) ; } catch ( ClassNotFoundException ignore ) { return d@@ flt ; } }
 public static boolean add@@ Last@@ Cause ( @ Nullable Throwable e , @ Nullable Throwable cause , Ignite@@ Logger log ) { if ( e == null || cause == null ) return false ; for ( Throwable t = e ; t != null ; t = t . getCause ( ) ) { if ( t == cause ) return false ; if ( t . getCause ( ) == null || t . getCause ( ) == t ) { try { t . initCause ( cause ) ; } catch ( IllegalStateException ignored ) { error ( log , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain ▁ ( cause ▁ is ▁ printed ▁ here ▁ but ▁ will ▁ " + " not ▁ be ▁ propagated ▁ to ▁ callee ) : ▁ " + e , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain : ▁ " + e , cause ) ; } return true ; } } return false ; }
 public static void cancel ( Iterable < ? extends Grid@@ Worker > ws ) { if ( ws != null ) for ( Grid@@ Worker w : ws ) w . cancel ( ) ; }
 private static File getResource@@ From@@ Jar ( String entry@@ Path , String fileName ) { try { InputStream jis = Msg@@ Class@@ Generator . class . getClassLoader ( ) . getResourceAsStream ( entry@@ Path + fileName ) ; if ( jis == null ) { logMessage ( " Error : ▁ there ▁ is ▁ no ▁ " + entry@@ Path + fileName + " ▁ in ▁ the ▁ resources ! " ) ; return null ; } File res@@ File = new File ( fileName ) ; res@@ File . createNew@@ File ( ) ; res@@ File . delete@@ OnExit ( ) ; FileOutputStream fos = new FileOutputStream ( res@@ File ) ; byte [ ] data = new byte [ jis . available ( ) ] ; int i ; while ( ( i = jis . read ( data ) ) > 0 ) { fos . write ( data , 0 , i ) ; data = new byte [ jis . available ( ) ] ; } jis . close ( ) ; fos . close ( ) ; return res@@ File ; } catch ( Exception e ) { logMessage ( " Couldn ' t ▁ extract ▁ resource ! " ) ; e . printStackTrace ( ) ; return null ; } }
 public static Collection < String > grid@@ s2@@ names ( @ Nullable Collection < ? extends Ignite > grids ) { return F . view@@ ReadOnly ( grids , new C1 < Ignite , String > ( ) { @ Override public String apply ( Ignite g ) { return g . name ( ) ; } } ) ; }
 public static boolean is@@ Hot@@ Spot ( ) { return jvm@@ Impl@@ Name . contains ( " Java ▁ Hot@@ Spot ( TM ) " ) ; }
 public static int array@@ Copy ( byte [ ] src , int off , byte [ ] res@@ Buf , int res@@ Off , int len ) { assert res@@ Buf . length >= res@@ Off + len ; if ( UN@@ SAFE_@@ BYTE_@@ AR@@ R_@@ CP ) UNSAFE . copy@@ Memory ( src , BYTE_@@ ARRAY_@@ DATA_@@ OFFSET + off , res@@ Buf , BYTE_@@ ARRAY_@@ DATA_@@ OFFSET + res@@ Off , len ) ; else System . arraycopy ( src , off , res@@ Buf , res@@ Off , len ) ; return res@@ Off + len ; }
 public static GridCache@@ Version read@@ Version ( long ptr , boolean ver@@ Ex ) { GridCache@@ Version ver = new GridCache@@ Version ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) ) ; if ( ver@@ Ex ) { ptr += 24 ; ver = new GridCache@@ Version@@ Ex ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) , ver ) ; } return ver ; }
 public static void main ( String [ ] args ) { }
 public static boolean same@@ Mac@@ s ( ClusterNode loc , ClusterNode r@@ mt ) { assert loc != null ; assert r@@ mt != null ; String loc@@ Mac@@ s = loc . attribute ( Ignite@@ Node@@ Attributes . ATTR_@@ MAC@@ S ) ; String rm@@ t@@ Mac@@ s = r@@ mt . attribute ( Ignite@@ Node@@ Attributes . ATTR_@@ MAC@@ S ) ; return loc@@ Mac@@ s != null && loc@@ Mac@@ s . equals ( rm@@ t@@ Mac@@ s ) ; }
 public static void nul@@ li@@ fy@@ Work@@ Directory ( ) { ignite@@ Work = null ; }
 public static void cour@@ te@@ sy ( @ Nullable Ignite@@ Logger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; cour@@ te@@ sy ( log , s , s ) ; }
 public static < K , V > void print@@ Concurrent@@ HashMap@@ Info ( ConcurrentHashMap < K , V > map ) { assert map != null ; Object [ ] segs = field ( map , " segments " ) ; X . println ( " Con@@ current ▁ map ▁ stats ▁ [ identity@@ Hash = ▁ " + System . identity@@ HashCode ( map ) + " , ▁ se@@ gs@@ Cnt = " + segs . length + ' ] ' ) ; int empty@@ Se@@ gs@@ Cnt = 0 ; int total@@ Colli@@ sions = 0 ; for ( int i = 0 ; i < segs . length ; i ++ ) { int seg@@ Cnt = Ignite@@ Utils . < Integer > field ( segs [ i ] , " count " ) ; if ( seg@@ Cnt == 0 ) { empty@@ Se@@ gs@@ Cnt ++ ; continue ; } Object [ ] tab = field ( segs [ i ] , " table " ) ; int tab@@ Len = tab . length ; X . println ( " ▁ ▁ ▁ ▁ Segment - " + i + " ▁ [ count = " + seg@@ Cnt + " , ▁ len = " + tab@@ Len + ' ] ' ) ; Map < Integer , Integer > bucket@@ s@@ Stats = new TreeMap < > ( ) ; for ( Object entry : tab ) { int cnt = 0 ; while ( entry != null ) { cnt ++ ; entry = field ( entry , " next " ) ; } Integer bucket@@ Cnt = bucket@@ s@@ Stats . get ( cnt ) ; if ( bucket@@ Cnt == null ) bucket@@ Cnt = 0 ; bucket@@ Cnt ++ ; bucket@@ s@@ Stats . put ( cnt , bucket@@ Cnt ) ; if ( cnt > 1 ) total@@ Colli@@ sions += ( cnt - 1 ) ; } for ( Map . Entry < Integer , Integer > e : bucket@@ s@@ Stats . entrySet ( ) ) X . println ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Buckets ▁ with ▁ count ▁ " + e . getKey ( ) + " : ▁ " + e . getValue ( ) ) ; } X . println ( " ▁ ▁ ▁ ▁ Map ▁ summary ▁ [ empty@@ Seg@@ s = " + empty@@ Se@@ gs@@ Cnt + " , ▁ collisions = " + total@@ Colli@@ sions + ' ] ' ) ; }
 public static String format ( long sys@@ Time ) { return LONG_@@ DATE_@@ FMT . format ( new java . util . Date ( sys@@ Time ) ) ; }
 public static final Action@@ Cache AM@@ NE@@ SI@@ AC_@@ CACHE = new Action@@ Cache ( ) { @ Override public void put ( String fingerprint , Entry entry ) { } @ Override public Entry get ( String fingerprint ) { return null ; } @ Override public void remove ( String key ) { } @ Override public long save ( ) { return - 1 ; } @ Override public void clear ( ) { } @ Override public void dump ( PrintStream out ) { } @ Override public void account@@ Hit ( ) { } @ Override public void account@@ Mis@@ s ( Mis@@ s@@ Reason reason ) { } @ Override public void merge@@ Into@@ Action@@ Cache@@ Statistics ( Action@@ Cache@@ Statistics . Builder builder ) { } @ Override public void reset@@ Statistics ( ) { } }
 public static void close ( @ Nullable Auto@@ Closeable rsrc , @ Nullable Ignite@@ Logger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static byte [ ] decode@@ Hex ( char [ ] data ) throws IgniteCheckedException { int len = data . length ; if ( ( len & 0x01 ) != 0 ) throw new IgniteCheckedException ( " Odd ▁ number ▁ of ▁ characters . " ) ; byte [ ] out = new byte [ len >> 1 ] ; for ( int i = 0 , j = 0 ; j < len ; i ++ ) { int f = to@@ Digit ( data [ j ] , j ) << 4 ; j ++ ; f |= to@@ Digit ( data [ j ] , j ) ; j ++ ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; }
 public static void skip ( DataInput@@ Plus in , Version version ) throws IOException { read@@ Position ( in , version ) ; skip@@ Promo@@ ted@@ Index ( in , version ) ; }
 public static String jvm@@ Name ( ) { return jvm@@ Impl@@ Name ; }
 public static void assert@@ Parameter ( boolean cond , String cond@@ Desc ) throws Ignite@@ Exception { if ( ! cond ) throw new Ignite@@ Exception ( " Parameter ▁ failed ▁ condition ▁ check : ▁ " + cond@@ Desc ) ; }
 public static void writeLock ( ReadWriteLock lock ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { lock . writeLock ( ) . lock@@ Interrup@@ tibly ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static String jdk@@ Version ( ) { return jdk@@ Ver ; }
 public static boolean has@@ Shared@@ Memory ( ) { if ( has@@ Sh@@ mem == null ) { if ( is@@ Windows ( ) ) has@@ Sh@@ mem = false ; else { try { Ipc@@ Shared@@ Memory@@ Native@@ Loader . load ( null ) ; has@@ Sh@@ mem = true ; } catch ( IgniteCheckedException ignore ) { has@@ Sh@@ mem = false ; } } } return has@@ Sh@@ mem ; }
 public static void closeQuietly ( JarFile jar@@ file ) { if ( jar@@ file == null ) { return ; } try { jar@@ file . close ( ) ; } catch ( IOException ignore ) { } }
 public static String format ( Date date , String ptr@@ n ) { java . text . DateFormat format = new java . text . SimpleDateFormat ( ptr@@ n ) ; return format . format ( date ) ; }
 public static void write@@ StringTo@@ File ( File file , String s , String charset , boolean append ) throws IOException { if ( s == null ) return ; try ( OutputStream out = new FileOutputStream ( file , append ) ) { out . write ( s . getBytes ( charset ) ) ; } }
 private static Set < SSTableReader > overlapping ( Collection < SSTableReader > candidates , Iterable < SSTableReader > others ) { assert ! candidates . isEmpty ( ) ; Iterator < SSTableReader > iter = candidates . iterator ( ) ; SSTableReader sstable = iter . next ( ) ; Token first = sstable . first . token ; Token last = sstable . last . token ; while ( iter . hasNext ( ) ) { sstable = iter . next ( ) ; first = first . compareTo ( sstable . first . token ) <= 0 ? first : sstable . first . token ; last = last . compareTo ( sstable . last . token ) >= 0 ? last : sstable . last . token ; } return overlapping ( first , last , others ) ; }
 public static < K , V > Map < K , V > se@@ al@@ Map ( Map < K , V > m ) { assert m != null ; return Collections . unmodifiableMap ( new HashMap < > ( m ) ) ; }
 public static Builder builder ( ) { return new Builder ( ) ; }
 private static TrustManager [ ] get@@ Trust@@ Managers ( ) { return new TrustManager [ ] { new X509@@ TrustManager ( ) { @ Nullable @ Override public X509Certificate [ ] get@@ Accepted@@ Issu@@ ers ( ) { return null ; } @ Override public void check@@ Client@@ Tru@@ sted ( X509Certificate [ ] certs , String auth@@ Type ) { } @ Override public void check@@ Server@@ Tru@@ sted ( X509Certificate [ ] certs , String auth@@ Type ) { } } } ; }
 public static < E > List < E > se@@ al@@ List ( E ... a ) { return Collections . unmodifiableList ( Arrays . asList ( a ) ) ; }
 public static String get@@ NS@@ From@@ PackageName ( String packageName ) { StringBuffer str@@ Buf = new StringBuffer ( ) ; int prev@@ Index = packageName . length ( ) ; int currentIndex = packageName . lastIndexOf ( PACKAGE_@@ class_@@ DELIMITER ) ; if ( currentIndex > 0 ) { str@@ Buf . append ( HTTP ) ; } else if ( prev@@ Index > 0 ) { str@@ Buf . append ( HTTP ) ; str@@ Buf . append ( packageName ) ; return str@@ Buf . toString ( ) ; } else if ( currentIndex == - 1 ) { return str@@ Buf . toString ( ) ; } while ( currentIndex != - 1 ) { str@@ Buf . append ( packageName . substring ( currentIndex + 1 , prev@@ Index ) ) ; prev@@ Index = currentIndex ; currentIndex = packageName . lastIndexOf ( PACKAGE_@@ class_@@ DELIMITER , prev@@ Index - 1 ) ; str@@ Buf . append ( PACKAGE_@@ class_@@ DELIMITER ) ; if ( currentIndex == - 1 ) { str@@ Buf . append ( packageName . substring ( 0 , prev@@ Index ) ) ; } } return str@@ Buf . toString ( ) ; }
 public static Constructor object@@ Constructor ( ) { return OBJECT_@@ CTOR ; }
 public static Ignite@@ Bi@@ Tuple < Object , Object > add@@ Log@@ 4j@@ No@@ Op@@ Logger ( ) throws IgniteCheckedException { Object root@@ Log ; Object null@@ App ; try { Class < ? > log@@ Cls = Class . forName ( " org . apache . log4j . Logger " ) ; root@@ Log = log@@ Cls . getMethod ( " getRoot@@ Logger " ) . invoke ( log@@ Cls ) ; try { null@@ App = Class . forName ( " org . apache . log4j . vari@@ a . Null@@ Appender " ) . newInstance ( ) ; } catch ( ClassNotFoundException ignore ) { return new Ignite@@ Bi@@ Tuple < > ( root@@ Log , null ) ; } Class app@@ Cls = Class . forName ( " org . apache . log4j . Appender " ) ; root@@ Log . getClass ( ) . getMethod ( " add@@ Appender " , app@@ Cls ) . invoke ( root@@ Log , null@@ App ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ add ▁ no - op ▁ logger ▁ for ▁ Log@@ 4j . " , e ) ; } return new Ignite@@ Bi@@ Tuple < > ( root@@ Log , null@@ App ) ; }
 private static void append@@ ClassLoader@@ Hash ( SB sb ) { if ( getBoolean ( IGN@@ ITE_@@ M@@ BEAN_@@ APP@@ END_@@ class_@@ LOA@@ DER_@@ ID , true ) ) { String cls@@ L@@ dr@@ Hash = Integer . toHexString ( Ignite . class . getClassLoader ( ) . hashCode ( ) ) ; sb . a ( " cls@@ L@@ dr = " ) . a ( cls@@ L@@ dr@@ Hash ) . a ( ' , ' ) ; } }
 public static boolean await ( Condition cond , long time , TimeUnit unit ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { return cond . await ( time , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static String read@@ UTF@@ String@@ Nullable ( DataInput in ) throws IOException { return in . readBoolean ( ) ? in . read@@ UTF ( ) : null ; }
 public static boolean is@@ Generic@@ ArrayType ( Type type ) { return ( type instanceof Generic@@ ArrayType ) ; }
 public static void write@@ StringTo@@ File ( File file , String s ) throws IOException { write@@ StringTo@@ File ( file , s , Charset . default@@ Charset ( ) . toString ( ) , false ) ; }
 @ Nullable public static String hide@@ Password ( @ Nullable String uri ) { if ( uri == null ) return null ; if ( Pattern . matches ( " . * : // ( . * : . * ) @ . * " , uri ) ) { int user@@ Info@@ Last@@ Idx = uri . indexOf ( ' @ ' ) ; assert user@@ Info@@ Last@@ Idx != - 1 ; String str = uri . substring ( 0 , user@@ Info@@ Last@@ Idx ) ; int user@@ Info@@ Start@@ Idx = str . lastIndexOf ( ' / ' ) ; str = str . substring ( user@@ Info@@ Start@@ Idx + 1 ) ; String [ ] params = str . split ( " ; " ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < params . length ; i ++ ) { int idx ; if ( ( idx = params [ i ] . indexOf ( ' : ' ) ) != - 1 ) params [ i ] = params [ i ] . substring ( 0 , idx + 1 ) + ' * ' ; builder . append ( params [ i ] ) ; if ( i != params . length - 1 ) builder . append ( ' ; ' ) ; } return new StringBuilder ( uri ) . replace ( user@@ Info@@ Start@@ Idx + 1 , user@@ Info@@ Last@@ Idx , builder . toString ( ) ) . toString ( ) ; } return uri ; }
 public static int hash ( int h ) { h ^= h >@@ >> 16 ; h *= 0x8@@ 5@@ eb@@ ca@@ 6b ; h ^= h >@@ >> 13 ; h *= 0xc@@ 2@@ b2@@ ae@@ 35 ; return ( h >@@ >> 16 ) ^ h ; }
 public static Label@@ Late@@ Bound@@ Default < ? > get@@ Android@@ Sdk@@ Label ( Label android@@ Sdk ) { return Label@@ Late@@ Bound@@ Default . from@@ Target@@ Configuration ( Android@@ Configuration . class , android@@ Sdk , ( rule , attributes , configuration ) -> configuration . getS@@ dk ( ) ) ; }
 public static boolean is@@ Wild@@ Card@@ Type ( Type type ) { return ( type instanceof Wildcard@@ Type ) ; }
 public static synchronized Collection < String > all@@ Local@@ I@@ ps ( ) { List < String > ips = new ArrayList < > ( 4 ) ; try { Enumeration < NetworkInterface > it@@ fs = NetworkInterface . getNetwork@@ Interfaces ( ) ; if ( it@@ fs != null ) { for ( NetworkInterface it@@ f : as@@ Iterable ( it@@ fs ) ) { if ( ! it@@ f . is@@ Loop@@ back ( ) ) { Enumeration < InetAddress > addrs = it@@ f . get@@ Inet@@ Addresses ( ) ; for ( InetAddress addr : as@@ Iterable ( addrs ) ) { String host@@ Addr = addr . getHost@@ Address ( ) ; if ( ! addr . is@@ Loop@@ back@@ Address ( ) && ! ips . contains ( host@@ Addr ) ) ips . add ( host@@ Addr ) ; } } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( ips ) ; return ips ; }
 public static int hashCode ( ByteBuffer ... bufs ) { int res = 1 ; for ( ByteBuffer buf : bufs ) { int pos = buf . position ( ) ; while ( buf . has@@ Remaining ( ) ) res = 31 * res + buf . get ( ) ; buf . position ( pos ) ; } return res ; }
 public static boolean contains@@ IntArray ( int [ ] arr , int val ) { assert arr != null ; if ( arr . length == 0 ) return false ; for ( int i : arr ) if ( i == val ) return true ; return false ; }
 public static < T > T getBy@@ Index ( Collection < T > vals , int idx ) { assert idx < vals . size ( ) ; int i = 0 ; for ( T val : vals ) { if ( idx == i ) return val ; i ++ ; } assert false : " Should ▁ never ▁ be ▁ reached . " ; return null ; }
 public static String consist@@ ent@@ Id ( Collection < String > addrs , int port ) { assert ! F . isEmpty ( addrs ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String addr : addrs ) sb . append ( addr ) . append ( ' , ' ) ; sb . delete ( sb . length ( ) - 1 , sb . length ( ) ) ; sb . append ( ' : ' ) . append ( port ) ; return sb . toString ( ) ; }
 public static void write@@ Map ( ObjectOutput out , Map < ? , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < ? , ? > e : map . entrySet ( ) ) { out . writeObject ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
 private static String convertTo@@ Java@@ Src@@ FilePath ( String qualified@@ Java@@ Name ) { if ( is@@ EmptyString ( qualified@@ Java@@ Name ) ) { return qualified@@ Java@@ Name ; } int dot@@ Java@@ Pos = qualified@@ Java@@ Name . lastIndexOf ( " . java " ) ; if ( dot@@ Java@@ Pos > - 1 ) { return convertTo@@ FilePath ( qualified@@ Java@@ Name . substring ( 0 , dot@@ Java@@ Pos ) , " . java " ) ; } else { return convertTo@@ FilePath ( qualified@@ Java@@ Name , " . java " ) ; } }
 static void deserialize@@ From@@ Pages ( Binary@@ Row@@ Data reuse , Channel@@ Reader@@ Input@@ View in@@ View , Binary@@ Row@@ Data@@ Serializer build@@ Side@@ Serializer ) throws IOException { if ( should@@ Advance ( in@@ View . getCurrent@@ Segment@@ Limit ( ) - in@@ View . getCurrent@@ PositionIn@@ Segment ( ) , build@@ Side@@ Serializer ) ) { in@@ View . advance ( ) ; } Memory@@ Segment segment = ( reuse . get@@ Segments ( ) != null ) ? reuse . get@@ Segments ( ) [ 0 ] : null ; int length = to@@ Length ( in@@ View . getCurrent@@ Segment ( ) . getLong ( in@@ View . getCurrent@@ PositionIn@@ Segment ( ) ) ) ; in@@ View . skip@@ BytesTo@@ Read ( 8 ) ; if ( segment == null || segment . size ( ) < length ) { segment = Memory@@ Segment@@ Factory . wrap ( new byte [ length ] ) ; } in@@ View . readFully ( segment . get@@ Heap@@ Memory ( ) , 0 , length ) ; reuse . point@@ To ( segment , 0 , length ) ; }
 @ Nullable public static byte [ ] read@@ ByteArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; byte [ ] res = new byte [ len ] ; in . readFully ( res ) ; return res ; }
 public static String os@@ Name ( ) { return os@@ Name ; }
 public static < T extends R , R > List < R > array@@ List ( Collection < T > c , @ Nullable Ignite@@ Predicate < ? super T > ... p ) { assert c != null ; return Ignite@@ Utils . array@@ List ( c , c . size ( ) , p ) ; }
 public static boolean is@@ Non@@ Decre@@ asing@@ Array ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) return false ; } return true ; }
 @ Deprecated public static void dump@@ Stack ( Thread t ) { dump@@ Stack ( t , System . err ) ; }
 public static boolean is@@ Grid ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite . internal " ) ; }
 @ Deprecated public static void debug@@ x ( String msg ) { X . printer@@ r@@ ln ( debug@@ Prefix ( ) + msg ) ; }
 public static File url@@ ToFile ( URL url ) { File file = null ; try { file = new File ( url . toURI ( ) ) ; } catch ( Exception exception ) { file = new File ( url . getPath ( ) ) ; } return file ; }
 public static Field@@ Cho@@ i@@ ces@@ dialogs fromValue ( String v ) { for ( Field@@ Cho@@ i@@ ces@@ dialogs c : Field@@ Cho@@ i@@ ces@@ dialogs . values ( ) ) { if ( c . value . equals ( v ) ) { return c ; } } throw new IllegalArgumentException ( v ) ; }
 public static String make@@ First@@ Letter@@ Upper ( String str ) { if ( is@@ EmptyString ( str ) ) { return str ; } char first@@ Char = str . charAt ( 0 ) ; if ( Character . is@@ Letter ( first@@ Char ) && Character . is@@ LowerCase ( first@@ Char ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toUpperCase ( first@@ Char ) ; return String . valueOf ( chars ) ; } else { return str ; } }
 public static int ceil@@ Po@@ w2 ( int v ) { return Integer . highest@@ One@@ Bit ( v - 1 ) << 1 ; }
 public static String getJava@@ ClassName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( idx + 1 ) ; }
 public static File get@@ Dir ( String dest@@ Dir ) throws IOException { if ( dest@@ Dir == null ) { return null ; } File dir = new File ( dest@@ Dir ) ; if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new IOException ( dest@@ Dir + " : ▁ non - existent ▁ directory " ) ; } return dir ; }
 public static void close ( @ Nullable Selector rsrc , @ Nullable Ignite@@ Logger log ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static void write@@ Int@@ KeyMap ( ObjectOutput out , Map < Integer , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , ? > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
 public static String class@@ NameTo@@ Resource@@ Name ( String cl@@ sName ) { return cl@@ sName . replaceAll ( " \\ . " , " / " ) + " . class " ; }
 public static boolean contains@@ ObjectArray ( @ Nullable Object [ ] arr , @ Nullable Collection < Object > c ) { if ( arr == null || arr . length == 0 || c == null || c . isEmpty ( ) ) return false ; for ( Object o : arr ) { if ( c . contains ( o ) ) return true ; } return false ; }
 public static void write@@ Int@@ Collection ( DataOutput out , Collection < Integer > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Integer i : col ) out . writeInt ( i ) ; } else out . writeInt ( - 1 ) ; }
 public static void log ( @ Nullable Ignite@@ Logger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; log ( log , s , s ) ; }
 public static int [ ] difference ( int [ ] a , int a@@ Len , int [ ] b , int b@@ Len ) { assert a != null ; assert b != null ; assert is@@ Incre@@ asing@@ Array ( a , a@@ Len ) ; assert is@@ Incre@@ asing@@ Array ( b , b@@ Len ) ; int [ ] res = new int [ a@@ Len ] ; int res@@ Len = 0 ; int i = 0 ; int j = 0 ; while ( i < a@@ Len && j < b@@ Len ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ res@@ Len ++ ] = a [ i ++ ] ; else j ++ ; } while ( i < a@@ Len ) res [ res@@ Len ++ ] = a [ i ++ ] ; return copy@@ If@@ Exceeded ( res , res@@ Len ) ; }
 @ Nullable public static Ignite@@ Uuid read@@ Grid@@ Uuid ( long ptr ) { if ( UNSAFE . getBoolean ( null , ptr ++ ) ) { long most = UNSAFE . getLong ( ptr ) ; ptr += 8 ; long least = UNSAFE . getLong ( ptr ) ; ptr += 8 ; UUID global@@ Id = new UUID ( most , least ) ; long loc@@ Id = UNSAFE . getLong ( ptr ) ; return new Ignite@@ Uuid ( global@@ Id , loc@@ Id ) ; } return null ; }
 public static boolean is@@ Windows@@ 81 ( ) { return win@@ 81 ; }
 public static void clear@@ Class@@ Cache ( ClassLoader ldr ) { class@@ Cache . remove ( ldr ) ; }
 public static boolean is@@ Net@@ W@@ are ( ) { return net@@ ware ; }
 public static Js@@ Array@@ Number wrap@@ Array ( double [ ] src@@ Array ) { Js@@ Array@@ Number result = JavaScript@@ Object . create@@ Array ( ) . cast ( ) ; for ( int i = 0 ; i < src@@ Array . length ; i ++ ) { result . set ( i , src@@ Array [ i ] ) ; } return result ; }
 public static String getTemplate@@ Content ( String template@@ Name ) throws IOException { ClassLoader classLoader = Thread . currentThread ( ) . getContext@@ ClassLoader ( ) ; InputStream inputStream = classLoader . getResourceAsStream ( template@@ Name ) ; if ( inputStream == null ) { throw new IOException ( " Failed ▁ to ▁ load ▁ resource ▁ : ▁ " + template@@ Name ) ; } String template@@ Content = read@@ Content ( inputStream ) ; return template@@ Content ; }
 @ Nullable public static < R > R wrap@@ Thread@@ Loader ( ClassLoader ldr , Ignite@@ Out@@ Closure < R > c ) { Thread cur@@ Thread = Thread . currentThread ( ) ; ClassLoader ctx@@ L@@ dr = cur@@ Thread . getContext@@ ClassLoader ( ) ; try { cur@@ Thread . setContext@@ ClassLoader ( ldr ) ; return c . apply ( ) ; } finally { cur@@ Thread . setContext@@ ClassLoader ( ctx@@ L@@ dr ) ; } }
 public static File resolve@@ Work@@ Directory ( String path , boolean del@@ If@@ Exist ) throws IgniteCheckedException { File dir = new File ( path ) ; if ( ! dir . is@@ Absolute ( ) ) { String gg@@ Work@@ 0 = ignite@@ Work ; if ( F . isEmpty ( gg@@ Work@@ 0 ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ resolve ▁ path ▁ ( work ▁ directory ▁ has ▁ not ▁ been ▁ set ) : ▁ " + path ) ; dir = new File ( gg@@ Work@@ 0 , dir . getPath ( ) ) ; } if ( del@@ If@@ Exist && dir . exists ( ) ) { if ( ! U . delete ( dir ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ delete ▁ directory : ▁ " + dir ) ; } if ( ! mkdirs ( dir ) ) throw new IgniteCheckedException ( " Directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + dir ) ; if ( ! dir . can@@ Read ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ directory : ▁ " + dir ) ; if ( ! dir . can@@ Write ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ directory : ▁ " + dir ) ; return dir ; }
 public static String compact ( String s ) { return s . replace ( " org . apache . ignite . internal . visor . " , " o . a . i . i . v . " ) . replace ( " org . apache . ignite . internal . " , " o . a . i . i . " ) . replace ( " org . apache . ignite . scalar . " , " o . a . i . s . " ) . replace ( " org . apache . ignite . " , " o . a . i . " ) ; }
 public static String to@@ Java@@ Src@@ FilePath ( String src@@ Dir , String qualified@@ Java@@ Name ) { if ( src@@ Dir == null || qualified@@ Java@@ Name == null ) { return null ; } String filePath = to@@ OS@@ FilePath ( src@@ Dir ) + convertTo@@ Java@@ Src@@ FilePath ( qualified@@ Java@@ Name ) ; return filePath ; }
 public static Collection < InetSocketAddress > resolve@@ Addresses ( Address@@ Resolver addr@@ R@@ sl@@ vr , Iterable < String > addrs , int port ) throws Ignite@@ Spi@@ Exception { assert addr@@ R@@ sl@@ vr != null ; Collection < InetSocketAddress > ext@@ Add@@ rs = new HashSet < > ( ) ; for ( String addr : addrs ) { InetSocketAddress sock@@ Addr = new InetSocketAddress ( addr , port ) ; if ( ! sock@@ Addr . isUn@@ resolved ( ) ) { try { Collection < InetSocketAddress > ext@@ Add@@ rs@@ 0 = addr@@ R@@ sl@@ vr . getExternal@@ Addresses ( sock@@ Addr ) ; if ( ext@@ Add@@ rs@@ 0 != null ) ext@@ Add@@ rs . addAll ( ext@@ Add@@ rs@@ 0 ) ; } catch ( IgniteCheckedException e ) { throw new Ignite@@ Spi@@ Exception ( " Failed ▁ to ▁ get ▁ mapped ▁ external ▁ addresses ▁ " + " [ addr@@ R@@ sl@@ vr = " + addr@@ R@@ sl@@ vr + " , ▁ addr = " + addr + ' ] ' , e ) ; } } } return ext@@ Add@@ rs ; }
 public static void on@@ Grid@@ Start ( ) { synchronized ( mux ) { if ( grid@@ Cnt == 0 ) { assert timer == null ; timer = new Thread ( new Runnable ( ) { @ SuppressWarnings ( { " Busy@@ Wait " , " Infin@@ ite@@ Loop@@ Statement " } ) @ Override public void run ( ) { while ( true ) { cur@@ TimeMillis = System . currentTimeMillis ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException ignored ) { break ; } } } } , " ignite - clock " ) ; timer . setDaemon ( true ) ; timer . setPriority ( 10 ) ; timer . start ( ) ; } ++ grid@@ Cnt ; } }
 public static < T > T get ( Future < T > fut ) throws IgniteCheckedException { try { return fut . get ( ) ; } catch ( ExecutionException e ) { throw new IgniteCheckedException ( e . getCause ( ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } catch ( Cancell@@ ationException e ) { throw new IgniteCheckedException ( e ) ; } }
 private static boolean [ ] [ ] get@@ Pixels ( final String asset@@ Path , final Context context , final int tile@@ Columns , final int tile@@ Rows ) { final Bitmap bitmap = get@@ Bitmap ( asset@@ Path , context ) ; if ( bitmap == null ) { return null ; } final int xOffset = bitmap . getWidth ( ) / tile@@ Columns ; final int yOffset = bitmap . getHeight ( ) / tile@@ Rows ; final boolean [ ] [ ] pixels = new boolean [ xOffset ] [ yOffset ] ; for ( int x = 0 ; x < xOffset ; x ++ ) { for ( int y = 0 ; y < yOffset ; y ++ ) { pixels [ x ] [ y ] = bitmap . get@@ Pixel ( x , y ) == Color . TRANSPARENT ? ALPHA : PIXEL ; } } return pixels ; }
 @ Nullable public static String readString ( DataInput in ) throws IOException { return ! in . readBoolean ( ) ? in . read@@ UTF ( ) : null ; }
 public static void interrupt ( @ Nullable Thread t ) { if ( t != null ) t . interrupt ( ) ; }
 public static Collector < JsonValue , Map < String , Json@@ Array@@ Builder > , JsonObject > grouping@@ By ( Function < JsonValue , String > classifier , Collector < JsonValue , Json@@ Array@@ Builder , JsonArray > downstream ) { return null ; }
 @ Nullable public static List < Ignite@@ Uuid > read@@ Grid@@ U@@ uids ( DataInput in ) throws IOException { List < Ignite@@ Uuid > col = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( read@@ Grid@@ Uuid ( in ) ) ; } return col ; }
 public static Collector < JsonValue , Map < String , Json@@ Array@@ Builder > , JsonObject > grouping@@ By ( Function < JsonValue , String > classifier ) { return null ; }
 public static void addAll@@ Files ( File dir , List < String > files ) { if ( dir . isDirectory ( ) ) { if ( ! dir . getName ( ) . equals ( " . " ) && ! dir . getName ( ) . equals ( " . . " ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { if ( children [ i ] . isDirectory ( ) ) { addAll@@ Files ( children [ i ] , files ) ; } else { files . add ( children [ i ] . getAbsolutePath ( ) ) ; } } } } }
 public static int to@@ Digit ( char ch , int idx ) throws IgniteCheckedException { int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) throw new IgniteCheckedException ( " Illegal ▁ hexadecimal ▁ character ▁ " + ch + " ▁ at ▁ index ▁ " + idx ) ; return digit ; }
 ) public static void unzip ( File zipFile , File to@@ Dir , @ Nullable Ignite@@ Logger log ) throws IOException { ZipFile zip = null ; try { zip = new ZipFile ( zipFile ) ; for ( ZipEntry entry : as@@ Iterable ( zip . entries ( ) ) ) { if ( entry . isDirectory ( ) ) { new File ( to@@ Dir , entry . getName ( ) ) . mkdirs ( ) ; continue ; } InputStream in = null ; OutputStream out = null ; try { in = zip . getInputStream ( entry ) ; File outFile = new File ( to@@ Dir , entry . getName ( ) ) ; if ( ! outFile . getParentFile ( ) . exists ( ) ) outFile . getParentFile ( ) . mkdirs ( ) ; out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; copy ( in , out ) ; } finally { close ( in , log ) ; close ( out , log ) ; } } } finally { if ( zip != null ) zip . close ( ) ; } }
 public static void wrap@@ Thread@@ Loader ( ClassLoader ldr , Runnable c ) { Thread cur@@ Thread = Thread . currentThread ( ) ; ClassLoader ctx@@ L@@ dr = cur@@ Thread . getContext@@ ClassLoader ( ) ; try { cur@@ Thread . setContext@@ ClassLoader ( ldr ) ; c . run ( ) ; } finally { cur@@ Thread . setContext@@ ClassLoader ( ctx@@ L@@ dr ) ; } }
 public static String jvm@@ Spec ( ) { return jvm@@ Spec@@ Name ; }
 public static < T extends Annotation > boolean has@@ Annotation ( Class < ? > cls , Class < T > ann@@ Cls ) { return getAnnotation ( cls , ann@@ Cls ) != null ; }
 public static boolean mkdirs ( File dir ) { assert dir != null ; return dir . mkdirs ( ) || dir . exists ( ) ; }
 public static int safe@@ Abs ( int i ) { i = Math . abs ( i ) ; return i < 0 ? 0 : i ; }
 @ Nullable public static < R > R wrap@@ Thread@@ Loader ( ClassLoader ldr , Callable < R > c ) throws IgniteCheckedException { Thread cur@@ Thread = Thread . currentThread ( ) ; ClassLoader ctx@@ L@@ dr = cur@@ Thread . getContext@@ ClassLoader ( ) ; try { cur@@ Thread . setContext@@ ClassLoader ( ldr ) ; return c . call ( ) ; } catch ( IgniteCheckedException | RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } finally { cur@@ Thread . setContext@@ ClassLoader ( ctx@@ L@@ dr ) ; } }
 public static void rollback@@ Connection@@ Qu@@ i@@ et ( @ Nullable Connection rsrc ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException ignored ) { } }
 public static void stop@@ Lifecycle@@ Aware ( Ignite@@ Logger log , Iterable < ? > objs ) { for ( Object obj : objs ) { if ( obj instanceof Lifecycle@@ Aware ) { try { ( ( Lifecycle@@ Aware ) obj ) . stop ( ) ; } catch ( Exception e ) { U . error ( log , " Failed ▁ to ▁ stop ▁ component ▁ ( ignoring ) : ▁ " + obj , e ) ; } } } }
 public static String nl ( ) { return NL ; }
 private static Iterable < ClusterNode > node@@ sPer@@ J@@ vm ( Iterable < ClusterNode > nodes ) { Map < String , ClusterNode > grp@@ Map = new HashMap < > ( ) ; for ( ClusterNode node : nodes ) { String grp@@ Id = node . attribute ( ATTR_@@ MAC@@ S ) + " | " + node . attribute ( ATTR_@@ JVM_@@ PID ) ; if ( ! grp@@ Map . containsKey ( grp@@ Id ) ) grp@@ Map . put ( grp@@ Id , node ) ; } return grp@@ Map . values ( ) ; }
 public static int [ ] copy@@ If@@ Exceeded ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; return len == arr . length ? arr : Arrays . copyOf ( arr , len ) ; }
 public static int doubleTo@@ Bytes ( double d , byte [ ] bytes , int off ) { return long@@ To@@ Bytes ( Double . doubleTo@@ LongBits ( d ) , bytes , off ) ; }
 public static void write@@ Uuid ( DataOutput out , UUID uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . get@@ Most@@ Significant@@ Bits ( ) ) ; out . writeLong ( uid . get@@ Least@@ Significant@@ Bits ( ) ) ; } }
 @ org . junit . BeforeClass public static void setUp ( ) throws Exception { System . out . println ( " = = = ▁ Setting ▁ up ▁ in@@ memory ▁ db ▁ for ▁ Ansible ▁ DAO ▁ Test ▁ = = = " ) ; CREATE_@@ T@@ MP_@@ DB@@ _S@@ QL = new Scanner ( new FileInputStream ( SQL_@@ FOL@@ DER_@@ PATH + " recre@@ ate@@ Db . sql " ) ) . use@@ Delimiter ( " \\ A " ) . next ( ) ; Jdbc@@ DataSource ds = new Jdbc@@ DataSource ( ) ; ds . set@@ URL ( JDB@@ C_@@ URL ) ; ds . set@@ User ( " sa " ) ; ds . setPassword ( " sa " ) ; Connection conn = ds . getConnection ( ) ; conn = ds . getConnection ( ) ; conn . createStatement ( ) . execute ( CREATE_@@ T@@ MP_@@ DB@@ _S@@ QL ) ; conn . commit ( ) ; conn . close ( ) ; }
 @ Nullable private static URL resolve@@ In@@ Classpath ( String path ) { ClassLoader cls@@ L@@ dr = Thread . currentThread ( ) . getContext@@ ClassLoader ( ) ; if ( cls@@ L@@ dr == null ) return null ; return cls@@ L@@ dr . getResource ( path . replaceAll ( " \\ \ \@@ " , " / " ) ) ; }
 private static final Predicate < SSTableReader > su@@ spect@@ P = new Predicate < SSTableReader > ( ) { public boolean apply ( SSTableReader candidate ) { return candidate . is@@ Marked@@ Su@@ spec@@ t ( ) ; } }
 public static < T > HashSet < T > newHashSet ( int exp@@ Size ) { return new HashSet < > ( capacity ( exp@@ Size ) ) ; }
 public static boolean delete ( @ Nullable File file ) { if ( file == null ) return false ; boolean res = true ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; if ( files != null && files . length > 0 ) for ( File file1 : files ) if ( file1 . isDirectory ( ) ) res &= delete ( file1 ) ; else if ( file1 . getName ( ) . endsWith ( " jar " ) ) try { new JarFile ( file1 , false ) . close ( ) ; res &= file1 . delete ( ) ; } catch ( IOException ignore ) { } else res &= file1 . delete ( ) ; res &= file . delete ( ) ; } else res = file . delete ( ) ; return res ; }
 public static synchronized void mut@@ ate@@ Level ( SSTable@@ Metadata old@@ Metadata , Descriptor descriptor , String filename , int level ) throws IOException { logger . debug ( " Mut@@ ating ▁ { } ▁ to ▁ level ▁ { } " , descriptor . filename@@ For ( Component . STATS ) , level ) ; SSTable@@ Metadata metadata = SSTable@@ Metadata . copy@@ With@@ New@@ SSTable@@ Level ( old@@ Metadata , level ) ; DataOutputStream out = new DataOutputStream ( new FileOutputStream ( filename + " - tmp " ) ) ; SSTable@@ Metadata . serializer . legacy@@ Serialize ( metadata , descriptor , out ) ; out . flush ( ) ; out . close ( ) ; FileUtils . rename@@ With@@ Confirm ( filename + " - tmp " , filename ) ; }
 public static void cour@@ te@@ sy ( @ Nullable Ignite@@ Logger log , Object long@@ Msg , Object short@@ Msg ) { assert long@@ Msg != null ; assert short@@ Msg != null ; if ( log != null ) log . getLogger ( IgniteConfiguration . COUR@@ TE@@ SY@@ _@@ LOGGER_@@ NAME ) . warning ( compact ( long@@ Msg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_@@ DATE_@@ FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( cour@@ te@@ sy ) ▁ " + compact ( short@@ Msg . toString ( ) ) ) ; }
 public static Map < String , String > read@@ StringMap ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; else { Map < String , String > map = U . newHashMap ( size ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( read@@ UTF@@ String@@ Nullable ( in ) , read@@ UTF@@ String@@ Nullable ( in ) ) ; return map ; } }
 public static boolean is@@ Incre@@ asing@@ Array ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) return false ; } return true ; }
 public static Le@@ ve@@ led@@ Manifest create ( ColumnFamily@@ Store cfs , int max@@ SSTable@@ Size , List < SSTableReader > sst@@ ables ) { return create ( cfs , max@@ SSTable@@ Size , sst@@ ables , new Size@@ Ti@@ ered@@ Compaction@@ Strategy@@ Options ( ) ) ; }
 public static byte [ ] copy@@ Memory ( long ptr , int size ) { byte [ ] res = new byte [ size ] ; UNSAFE . copy@@ Memory ( null , ptr , res , BYTE_@@ ARRAY_@@ DATA_@@ OFFSET , size ) ; return res ; }
 public static Page@@ Data setPage@@ Param ( Page@@ Data pd ) { String page_@@ now_@@ str = pd . get ( " page _ now " ) . toString ( ) ; int page@@ Now@@ Int = Integer . parseInt ( page_@@ now_@@ str ) - 1 ; String page_@@ size_@@ str = pd . get ( " page _ size " ) . toString ( ) ; int page@@ Size@@ Int = Integer . parseInt ( page_@@ size_@@ str ) ; String page_@@ now = page@@ Now@@ Int + " " ; String page_@@ start = ( page@@ Now@@ Int * page@@ Size@@ Int ) + " " ; pd . put ( " page _ now " , page_@@ now ) ; pd . put ( " page _ start " , page_@@ start ) ; return pd ; }
 public static String get@@ Qualified@@ ClassName ( String java@@ FilePath , String src@@ Location ) { int pkg@@ StartPos = java@@ FilePath . indexOf ( src@@ Location ) ; String qualified@@ Java@@ File = null ; if ( pkg@@ StartPos > - 1 ) { String normalized@@ Src@@ Loc = CodeGen@@ Util . normalize@@ Path ( src@@ Location ) ; int startPos = pkg@@ StartPos + normalized@@ Src@@ Loc . length ( ) ; qualified@@ Java@@ File = java@@ FilePath . substring ( startPos ) ; } else { qualified@@ Java@@ File = java@@ FilePath ; } return to@@ Qualified@@ ClassName ( qualified@@ Java@@ File ) ; }
 public static void debug@@ Heap@@ Usage ( ) { System . gc ( ) ; Runtime runtime = Runtime . getRuntime ( ) ; X . println ( ' < ' + DEBUG_@@ DATE_@@ FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + " > ▁ Heap ▁ stats ▁ [ free = " + runtime . free@@ Memory ( ) / ( 1024 * 1024 ) + " M , ▁ total = " + runtime . total@@ Memory ( ) / ( 1024 * 1024 ) + " M ] " ) ; }
 public static void write@@ Boolean@@ Array ( DataOutput out , @ Nullable boolean [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( boolean b : arr ) out . writeBoolean ( b ) ; } }
 public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mt@@ d@@ Name , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mt@@ d@@ Name != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuper@@ class ( ) ) { Method m@@ td = null ; for ( Method declared@@ M@@ td : c . getDeclared@@ Methods ( ) ) { if ( declared@@ M@@ td . getName ( ) . equals ( mt@@ d@@ Name ) ) { if ( m@@ td == null ) m@@ td = declared@@ M@@ td ; else throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( amb@@ ig@@ ous ▁ method ▁ name ) ▁ [ mt@@ d@@ Name = " + mt@@ d@@ Name + " , ▁ cls = " + cls + ' ] ' ) ; } } if ( m@@ td == null ) continue ; boolean accessible = m@@ td . is@@ Accessible ( ) ; T res ; try { m@@ td . setAccessible ( true ) ; res = ( T ) m@@ td . invoke ( obj , params ) ; } finally { if ( ! accessible ) m@@ td . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mt@@ d@@ Name = " + mt@@ d@@ Name + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mt@@ d@@ Name = " + mt@@ d@@ Name + " , ▁ cls = " + cls + ' ] ' ) ; }
 public static < T extends R , R > List < R > array@@ List ( Iterable < T > c , int cap , @ Nullable Ignite@@ Predicate < ? super T > ... p ) { assert c != null ; assert cap >= 0 ; List < R > list = new ArrayList < > ( cap ) ; for ( T t : c ) { if ( F . is@@ All ( t , p ) ) list . add ( t ) ; } return list ; }
 private static Call@@ Tracking@@ Logger getLogger ( ) { return logger ; }
 public static String addres@@ ses@@ AsString ( Collection < String > addrs , Collection < String > host@@ Names ) { if ( F . isEmpty ( addrs ) ) return " " ; if ( F . isEmpty ( host@@ Names ) ) return addrs . toString ( ) ; SB sb = new SB ( " [ " ) ; Iterator < String > host@@ Names@@ It = host@@ Names . iterator ( ) ; boolean first = true ; for ( String addr : addrs ) { if ( first ) first = false ; else sb . a ( " , ▁ " ) ; String hostName = host@@ Names@@ It . hasNext ( ) ? host@@ Names@@ It . next ( ) : null ; sb . a ( hostName != null ? hostName : " " ) . a ( ' / ' ) . a ( addr ) ; } sb . a ( ' ] ' ) ; return sb . toString ( ) ; }
 @ Deprecated public static void dump@@ Stack ( ) { dump@@ Stack ( " Dump@@ ing ▁ stack . " ) ; }
 public static boolean is@@ Windows@@ Vista ( ) { return win@@ Vista ; }
 public static String to@@ Java@@ Src@@ FilePath ( String src@@ Dir , Class < ? > clazz ) { if ( src@@ Dir == null || clazz == null ) { return null ; } String filePath = to@@ Java@@ Src@@ FilePath ( src@@ Dir , clazz . getName ( ) ) ; return filePath ; }
 public static String getTask@@ Name ( Class < ? extends Compute@@ Task < ? , ? > > task@@ Cls ) { Compute@@ Task@@ Name name@@ An@@ n = getAnnotation ( task@@ Cls , Compute@@ Task@@ Name . class ) ; return name@@ An@@ n == null ? task@@ Cls . getName ( ) : name@@ An@@ n . value ( ) ; }
 public static String spi@@ Attribute ( Ignite@@ Spi spi , String attrName ) { assert spi != null ; assert spi . getName ( ) != null ; return spi . getName ( ) + ' . ' + attrName ; }
 public static long read@@ Position ( DataInput@@ Plus in , Version version ) throws IOException { return version . store@@ Rows ( ) ? in . readUnsigned@@ VInt ( ) : in . readLong ( ) ; }
 public static OutputStream getFile@@ OutputStream ( String dest@@ Dir , String fileName ) throws IOException { if ( is@@ EmptyString ( dest@@ Dir ) || is@@ EmptyString ( fileName ) ) { return null ; } File dir = create@@ Dir ( dest@@ Dir ) ; File outputFile = new File ( dir , fileName ) ; delete@@ File ( outputFile ) ; FileOutputStream file@@ OutStream = new FileOutputStream ( outputFile ) ; return file@@ OutStream ; }
 public static void main ( String [ ] args ) { Graph@@ Parent tmp = new Graph@@ Parent ( ) ; tmp . init ( ) ; }
 public static void closeQuietly ( InputSource input@@ Source ) { if ( input@@ Source == null ) { return ; } closeQuietly ( input@@ Source . getCharacter@@ Stream ( ) ) ; closeQuietly ( input@@ Source . get@@ ByteStream ( ) ) ; }
 private static String normalize@@ Path ( String path ) { if ( path == null ) { return null ; } if ( path . endsWith ( " \ \@@ " ) || path . endsWith ( " / " ) ) { return path ; } else { return path + File . separator@@ Char ; } }
 public static void copy ( File src , File dest , boolean overwrite ) throws IOException { assert src != null ; assert dest != null ; if ( ! src . exists ( ) ) throw new FileNotFoundException ( " Source ▁ can ' t ▁ be ▁ found : ▁ " + src ) ; if ( src . getAbsolute@@ File ( ) . equals ( dest . getAbsolute@@ File ( ) ) ) throw new IOException ( " Source ▁ and ▁ destination ▁ are ▁ the ▁ same ▁ [ src = " + src + " , ▁ dest = " + dest + ' ] ' ) ; if ( dest . exists ( ) ) { if ( ! dest . isDirectory ( ) && ! overwrite ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + dest ) ; if ( ! dest . can@@ Write ( ) ) throw new IOException ( " Destination ▁ is ▁ not ▁ writable : " + dest ) ; } else { File parent = dest . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) parent . mkdirs ( ) ; if ( src . isDirectory ( ) ) dest . mkdir ( ) ; } if ( src . isDirectory ( ) ) { File [ ] files = src . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { File dir = new File ( dest , file . getName ( ) ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) throw new IOException ( " Can ' t ▁ create ▁ directory : ▁ " + dir ) ; copy ( file , dir , overwrite ) ; } else copy ( file , dest , overwrite ) ; } } else { File file = dest . exists ( ) && dest . isDirectory ( ) ? new File ( dest , src . getName ( ) ) : dest ; if ( ! overwrite && file . exists ( ) ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + file ) ; FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( file ) ; copy ( in , out ) ; } finally { if ( in != null ) in . close ( ) ; if ( out != null ) { out . get@@ FD ( ) . sync ( ) ; out . close ( ) ; } } } }
 public static void remove@@ Java@@ No@@ Op@@ Logger ( Collection < Handler > rm@@ v@@ H@@ n@@ ds ) { Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . get@@ Handlers ( ) ) log . remove@@ Handler ( h ) ; if ( ! F . isEmpty ( rm@@ v@@ H@@ n@@ ds ) ) { for ( Handler h : rm@@ v@@ H@@ n@@ ds ) log . addHandler ( h ) ; } }
 public static String jvm@@ Version ( ) { return jvm@@ Impl@@ Ver ; }
 public static void await ( Condition cond ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { cond . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static Collection < UUID > node@@ Ids ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . view@@ ReadOnly ( nodes , F . node@@ 2@@ id ( ) ) ; }
 public static boolean is@@ Linux ( ) { return linux ; }
 public static long micro@@ Time ( ) { return System . nanoTime ( ) / 1000 ; }
 @ Nullable public static Class < ? > box ( @ Nullable Class < ? > cls ) { if ( cls == null ) return null ; if ( ! cls . is@@ Primitive ( ) ) return cls ; return box@@ ed@@ Cl@@ sMap . get ( cls ) ; }
 public static int [ ] addAll ( int [ ] ar@@ r1 , int [ ] ar@@ r2 ) { int [ ] all = new int [ ar@@ r1 . length + ar@@ r2 . length ] ; System . arraycopy ( ar@@ r1 , 0 , all , 0 , ar@@ r1 . length ) ; System . arraycopy ( ar@@ r2 , 0 , all , ar@@ r1 . length , ar@@ r2 . length ) ; return all ; }
 private static boolean check@@ NextToken ( StringTokenizer t , String str , String date ) throws IgniteCheckedException { try { if ( t . nextToken ( ) . equals ( str ) ) return true ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + date ) ; } catch ( NoSuchElementException ignored ) { return false ; } }
 private static Memory@@ Segment [ ] list@@ To@@ Array ( List < Memory@@ Segment > list ) { if ( list != null ) { return list . toArray ( new Memory@@ Segment [ 0 ] ) ; } return null ; }
 public static boolean bytes@@ Equal ( byte [ ] a , int a@@ Off , byte [ ] b , int b@@ Off , int len ) { if ( a@@ Off + len > a . length || b@@ Off + len > b . length ) return false ; else { for ( int i = 0 ; i < len ; i ++ ) if ( a [ a@@ Off + i ] != b [ b@@ Off + i ] ) return false ; return true ; } }
 public static Map < String , Collection < ClusterNode > > neighbor@@ hood ( Iterable < ClusterNode > nodes ) { Map < String , Collection < ClusterNode > > map = new HashMap < > ( ) ; for ( ClusterNode n : nodes ) { String macs = n . attribute ( ATTR_@@ MAC@@ S ) ; assert macs != null : " Missing ▁ MAC@@ s ▁ attribute : ▁ " + n ; Collection < ClusterNode > neighbors = map . get ( macs ) ; if ( neighbors == null ) map . put ( macs , neighbors = new ArrayList < > ( 2 ) ) ; neighbors . add ( n ) ; } return map ; }
 public static void logMessage ( String msg ) { System . out . println ( msg ) ; }
 ) @ Nullable public static URL resolve@@ Ignite@@ Url ( String path , boolean meta@@ Inf ) { File f = resolve@@ Ignite@@ Path ( path ) ; if ( f != null ) { try { return f . toURI ( ) . to@@ URL ( ) ; } catch ( MalformedURLException e ) { } } ClassLoader cls@@ L@@ dr = Thread . currentThread ( ) . getContext@@ ClassLoader ( ) ; if ( cls@@ L@@ dr != null ) { String loc@@ Path = ( meta@@ Inf ? " META - INF / " : " " ) + path . replaceAll ( " \\ \ \@@ " , " / " ) ; return cls@@ L@@ dr . getResource ( loc@@ Path ) ; } else return null ; }
 public static Link@@ Options of ( ImmutableList < String > link@@ Options , Symbol@@ Generator < ? > symbol@@ Generator ) { return new Link@@ Options ( link@@ Options , symbol@@ Generator . generate ( ) ) ; }
 public static Compilation@@ MXBean get@@ Compiler@@ M@@ x ( ) { return Management@@ Factory . get@@ Compilation@@ MXBean ( ) ; }
 private static String debug@@ Prefix ( ) { return ' < ' + DEBUG_@@ DATE_@@ FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + ' > ' + ' ▁ ' ; }
 public static void write@@ IntArray ( DataOutput out , @ Nullable int [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( int b : arr ) out . writeInt ( b ) ; } }
 public static String addres@@ ses@@ AsString ( ClusterNode node ) { return addres@@ ses@@ AsString ( node . addresses ( ) , node . host@@ Names ( ) ) ; }
 public static < T > ObjectName register@@ Cache@@ MBean ( MBeanServer mbean@@ S@@ rv , @ Nullable String grid@@ Name , @ Nullable String cacheName , String name , T impl , Class < T > it@@ f ) throws JM@@ Exception { assert mbean@@ S@@ rv != null ; assert name != null ; assert it@@ f != null ; Dynamic@@ MBean mbean = new Ignite@@ Standard@@ MXBean ( impl , it@@ f ) ; mbean . get@@ MBean@@ Info ( ) ; return mbean@@ S@@ rv . register@@ MBean ( mbean , make@@ Cache@@ MBean@@ Name ( grid@@ Name , cacheName , name ) ) . get@@ ObjectName ( ) ; }
 public static void close ( @ Nullable Datagram@@ Socket rsrc ) { if ( rsrc != null ) rsrc . close ( ) ; }
 private static String test@@ Method@@ Static ( ) { return " foo " ; }
 @ Nullable public static Method find@@ Non@@ Public@@ Method ( Class < ? > cls , String name , Class < ? > ... param@@ Types ) { while ( cls != null ) { try { Method m@@ td = cls . getDeclared@@ Method ( name , param@@ Types ) ; if ( m@@ td . getReturnType ( ) != void . class ) { m@@ td . setAccessible ( true ) ; return m@@ td ; } } catch ( NoSuchMethodException ignored ) { } cls = cls . getSuper@@ class ( ) ; } return null ; }
 public static String read@@ File@@ ToString ( String fileName , String charset ) throws IOException { Reader input = new InputStreamReader ( new FileInputStream ( fileName ) , charset ) ; StringWriter output = new StringWriter ( ) ; char [ ] buf = new char [ 4096 ] ; int n ; while ( ( n = input . read ( buf ) ) != - 1 ) output . write ( buf , 0 , n ) ; return output . toString ( ) ; }
 public static Ignite@@ Closure < UUID , ClusterNode > id2@@ Node ( final Grid@@ Ker@@ nal@@ Context ctx ) { assert ctx != null ; return new C1 < UUID , ClusterNode > ( ) { @ Nullable @ Override public ClusterNode apply ( UUID id ) { return ctx . discovery ( ) . node ( id ) ; } } ; }
 public static GridCache@@ Attributes [ ] cache@@ Attributes ( ClusterNode n ) { return n . attribute ( ATTR_@@ CACHE ) ; }
 public static boolean is@@ Suf@@ fici@@ ent@@ ly@@ Test@@ ed@@ Os ( ) { return win@@ 7 || win@@ 8 || win@@ 81 || win@@ X@@ p || win@@ Vista || mac || linux || sol@@ aris ; }
 public static void close@@ Qu@@ i@@ et ( @ Nullable Selection@@ Key rsrc ) { if ( rsrc != null ) close@@ Qu@@ i@@ et ( rsrc . channel ( ) ) ; }
 public static Class < ? > forName ( String cl@@ sName , @ Nullable ClassLoader ldr ) throws ClassNotFoundException { assert cl@@ sName != null ; Class < ? > cls = primitive@@ Map . get ( cl@@ sName ) ; if ( cls != null ) return cls ; if ( ldr == null ) ldr = grid@@ ClassLoader ; ConcurrentMap < String , Class > ld@@ r@@ Map = class@@ Cache . get ( ldr ) ; if ( ld@@ r@@ Map == null ) { ConcurrentMap < String , Class > old = class@@ Cache . putIfAbsent ( ldr , ld@@ r@@ Map = new Concurrent@@ HashMap@@ 8 < > ( ) ) ; if ( old != null ) ld@@ r@@ Map = old ; } cls = ld@@ r@@ Map . get ( cl@@ sName ) ; if ( cls == null ) { Class old = ld@@ r@@ Map . putIfAbsent ( cl@@ sName , cls = Class . forName ( cl@@ sName , true , ldr ) ) ; if ( old != null ) cls = old ; } return cls ; }
 private static Set < SSTableReader > overlapping ( Token start , Token end , Iterable < SSTableReader > sst@@ ables ) { assert start . compareTo ( end ) <= 0 ; Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; Bounds < Token > promo@@ ted@@ Bounds = new Bounds < Token > ( start , end ) ; for ( SSTableReader candidate : sst@@ ables ) { Bounds < Token > candidate@@ Bounds = new Bounds < Token > ( candidate . first . token , candidate . last . token ) ; if ( candidate@@ Bounds . intersects ( promo@@ ted@@ Bounds ) ) overlapped . add ( candidate ) ; } return overlapped ; }
 private static int getBucket@@ Buffer@@ sBy@@ RowCount ( long rowCount , int max@@ Seg@@ s , int segment@@ Size ) { int min@@ Num@@ Buckets = ( int ) Math . ceil ( ( rowCount / 0.5 ) ) ; Preconditions . checkArgument ( segment@@ Size % 16 == 0 ) ; return MathUtils . round@@ Down@@ To@@ PowerOf@@ 2 ( ( int ) Math . max ( 1 , Math . min ( max@@ Seg@@ s , Math . ceil ( ( ( double ) min@@ Num@@ Buckets ) * 16 / segment@@ Size ) ) ) ) ; }
 public static Memory@@ MXBean getMemory@@ M@@ x ( ) { return Management@@ Factory . getMemory@@ MXBean ( ) ; }
 public static double heap@@ Size ( int precision ) { return ro@@ unded@@ Heap@@ Size ( Runtime . getRuntime ( ) . max@@ Memory ( ) , precision ) ; }
 public static int write@@ Message@@ Fully ( Message msg , OutputStream out , ByteBuffer buf , Message@@ Writer writer ) throws IOException { assert msg != null ; assert out != null ; assert buf != null ; assert buf . has@@ Array ( ) ; boolean finished = false ; int cnt = 0 ; while ( ! finished ) { finished = msg . writeTo ( buf , writer ) ; out . write ( buf . array ( ) , 0 , buf . position ( ) ) ; cnt += buf . position ( ) ; buf . clear ( ) ; } return cnt ; }
 public static boolean contains@@ String@@ Collection ( Iterable < String > c , @ Nullable String val , boolean ignore@@ Case ) { assert c != null ; for ( String s : c ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignore@@ Case ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
 public static int copy ( InputStream in , OutputStream out ) throws IOException { assert in != null ; assert out != null ; byte [ ] buf = new byte [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
 public static boolean is@@ Mac@@ Os ( ) { return mac ; }
 public static boolean is@@ Windows@@ 7 ( ) { return win@@ 7 ; }
 public static String to@@ Short@@ String ( ClusterNode n ) { return " Grid@@ Node ▁ [ id = " + n . id ( ) + " , ▁ order = " + n . order ( ) + " , ▁ addr = " + n . addresses ( ) + " , ▁ daemon = " + n . is@@ Daemon ( ) + ' ] ' ; }
 public static < T > ObjectName register@@ MBean ( MBeanServer mbean@@ S@@ rv , ObjectName name , T impl , Class < T > it@@ f ) throws JM@@ Exception { assert mbean@@ S@@ rv != null ; assert name != null ; assert it@@ f != null ; Dynamic@@ MBean mbean = new Ignite@@ Standard@@ MXBean ( impl , it@@ f ) ; mbean . get@@ MBean@@ Info ( ) ; return mbean@@ S@@ rv . register@@ MBean ( mbean , name ) . get@@ ObjectName ( ) ; }
 public static void dump@@ Threads ( @ Nullable Ignite@@ Logger log ) { Thread@@ MXBean mx@@ Bean = Management@@ Factory . getThread@@ MXBean ( ) ; final Set < Long > dead@@ locked@@ Threads@@ Ids = get@@ Dead@@ locked@@ Thread@@ Ids ( mx@@ Bean ) ; if ( dead@@ locked@@ Threads@@ Ids . size ( ) == 0 ) warn ( log , " No ▁ dead@@ locked ▁ threads ▁ detected . " ) ; else warn ( log , " Dead@@ locked ▁ threads ▁ detected ▁ ( see ▁ thread ▁ dump ▁ below ) ▁ " + " [ dead@@ locked@@ Threads@@ Cnt = " + dead@@ locked@@ Threads@@ Ids . size ( ) + ' ] ' ) ; Thread@@ Info [ ] thread@@ Infos = mx@@ Bean . dump@@ All@@ Threads ( mx@@ Bean . is@@ Object@@ Monitor@@ Usage@@ Supported ( ) , mx@@ Bean . is@@ Synchron@@ izer@@ Usage@@ Supported ( ) ) ; Grid@@ StringBuilder sb = new Grid@@ StringBuilder ( " Thread ▁ dump ▁ at ▁ " ) . a ( new SimpleDateFormat ( " yyyy / MM / dd ▁ HH : mm : ss ▁ z " ) . format ( new Date ( U . currentTimeMillis ( ) ) ) ) . a ( NL ) ; for ( Thread@@ Info info : thread@@ Infos ) { print@@ Thread@@ Info ( info , sb , dead@@ locked@@ Threads@@ Ids ) ; sb . a ( NL ) ; if ( info . get@@ Locked@@ Synchron@@ izers ( ) != null && info . get@@ Locked@@ Synchron@@ izers ( ) . length > 0 ) { print@@ Synchron@@ izer@@ sInfo ( info . get@@ Locked@@ Synchron@@ izers ( ) , sb ) ; sb . a ( NL ) ; } } sb . a ( NL ) ; warn ( log , sb . toString ( ) ) ; }
 @ Nullable public static List < UUID > read@@ U@@ uids ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < UUID > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( read@@ Uuid ( in ) ) ; return col ; }
 public static boolean join ( @ Nullable Thread t , @ Nullable Ignite@@ Logger log ) { if ( t != null ) try { t . join ( ) ; return true ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ a ▁ thread : ▁ " + t ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
 public static String grid@@ Event@@ Name ( int type ) { String name = GRID_@@ EVT_@@ NAMES . get ( type ) ; return name != null ? name : Integer . toString ( type ) ; }
 public static void acquire ( Semaphore sem ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { sem . acquire ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static String byteArray@@ 2@@ String ( byte [ ] arr , String hdr@@ Fmt , String body@@ Fmt ) { assert arr != null ; assert hdr@@ Fmt != null ; assert body@@ Fmt != null ; SB sb = new SB ( ) ; sb . a ( ' { ' ) ; boolean first = true ; for ( byte b : arr ) if ( first ) { sb . a ( String . format ( hdr@@ Fmt , b ) ) ; first = false ; } else sb . a ( String . format ( body@@ Fmt , b ) ) ; sb . a ( ' } ' ) ; return sb . toString ( ) ; }
 public static boolean has@@ Near@@ Cache ( ClusterNode n , String cacheName ) { GridCache@@ Attributes [ ] caches = n . attribute ( ATTR_@@ CACHE ) ; if ( caches != null ) for ( GridCache@@ Attributes attrs : caches ) if ( F . eq ( cacheName , attrs . cacheName ( ) ) ) return attrs . near@@ Cache@@ Enabled ( ) ; return false ; }
 public static void ignite@@ Uuid@@ To@@ Bytes ( Ignite@@ Uuid uuid , byte [ ] out , int off ) { assert uuid != null ; long@@ To@@ Bytes ( uuid . global@@ Id ( ) . get@@ Most@@ Significant@@ Bits ( ) , out , off ) ; long@@ To@@ Bytes ( uuid . global@@ Id ( ) . get@@ Least@@ Significant@@ Bits ( ) , out , off + 8 ) ; long@@ To@@ Bytes ( uuid . local@@ Id ( ) , out , off + 16 ) ; }
 public static String to@@ Qualified@@ ClassName ( String java@@ FilePath ) { String file@@ Path@@ No@@ Ext = null ; if ( java@@ FilePath == null ) { return null ; } boolean is@@ Java@@ Extension@@ Present = java@@ FilePath . endsWith ( " . java " ) ; if ( is@@ Java@@ Extension@@ Present ) { file@@ Path@@ No@@ Ext = java@@ FilePath . substring ( 0 , java@@ FilePath . length ( ) - 5 ) ; } boolean is@@ Class@@ Extension@@ Present = java@@ FilePath . endsWith ( " . class " ) ; if ( is@@ Class@@ Extension@@ Present ) { file@@ Path@@ No@@ Ext = java@@ FilePath . substring ( 0 , java@@ FilePath . length ( ) - 6 ) ; } if ( file@@ Path@@ No@@ Ext == null ) file@@ Path@@ No@@ Ext = java@@ FilePath ; return file@@ Path@@ No@@ Ext . replace ( ' \ \@@ ' , ' . ' ) . replace ( ' / ' , ' . ' ) ; }
 public static synchronized InetAddress getLocal@@ Host ( ) throws IOException { if ( loc@@ Host == null ) reset@@ LocalHost ( ) ; return loc@@ Host ; }
 public static String pad ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' ▁ ' ) ; return new String ( dash ) ; }
 public static String dash ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' - ' ) ; dash [ 0 ] = dash [ len - 1 ] = ' + ' ; return new String ( dash ) ; }
 public static void write@@ StringMap ( DataOutput out , @ Nullable Map < String , String > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < String , String > e : map . entrySet ( ) ) { write@@ UTF@@ String@@ Nullable ( out , e . getKey ( ) ) ; write@@ UTF@@ String@@ Nullable ( out , e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
 public static boolean contains@@ ObjectArray ( @ Nullable Object [ ] arr , Object val , @ Nullable Object ... vals ) { if ( arr == null || arr . length == 0 ) return false ; for ( Object o : arr ) { if ( F . eq ( o , val ) ) return true ; if ( vals != null && vals . length > 0 ) for ( Object v : vals ) if ( F . eq ( o , v ) ) return true ; } return false ; }
 public static List < String > jvm@@ Args ( ) { return Management@@ Factory . getRuntime@@ MXBean ( ) . getInput@@ Arguments ( ) ; }
 private static boolean should@@ Advance ( int available , Binary@@ Row@@ Data@@ Serializer serializer ) { return available < 8 + serializer . get@@ Fixed@@ Length@@ Part@@ Size ( ) ; }
 private static String read@@ Content ( InputStream input ) throws IOException { Charset default@@ Charset = Charset . default@@ Charset ( ) ; InputStreamReader is@@ r = new InputStreamReader ( input , default@@ Charset ) ; BufferedReader reader = new BufferedReader ( is@@ r ) ; StringBuilder str@@ Buff = new StringBuilder ( ) ; try { char [ ] char@@ Buff = new char [ 512 ] ; int chars@@ Read = - 1 ; while ( ( chars@@ Read = reader . read ( char@@ Buff ) ) > - 1 ) { str@@ Buff . append ( char@@ Buff , 0 , chars@@ Read ) ; } } finally { reader . close ( ) ; } return str@@ Buff . toString ( ) ; }
 public static boolean is@@ Windows@@ 2003 ( ) { return win@@ 2003 ; }
 public static void close@@ Qu@@ i@@ et ( @ Nullable Context rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException ignored ) { } }
 public static Grid@@ Peer@@ Deploy@@ Aware peer@@ Deploy@@ Aware@@ 0 ( @ Nullable Iterable < ? > c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; Collection < Object > tmp@@ C = new ArrayList < > ( ) ; for ( Object e : c ) tmp@@ C . add ( e ) ; tmp@@ C . add ( c ) ; boolean not@@ All@@ Nulls = false ; for ( Object obj : tmp@@ C ) { if ( obj != null ) { not@@ All@@ Nulls = true ; if ( has@@ Common@@ ClassLoader ( obj , tmp@@ C ) ) return obj == c ? peer@@ Deploy@@ Aware ( obj ) : peer@@ Deploy@@ Aware@@ 0 ( obj ) ; } } if ( not@@ All@@ Nulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peer@@ Deploy@@ Aware ( c ) ; }
 public static String byteArray@@ 2@@ HexString ( byte [ ] arr ) { SB sb = new SB ( arr . length << 1 ) ; for ( byte b : arr ) sb . a ( Integer . toHexString ( MASK & b >@@ >> 4 ) ) . a ( Integer . toHexString ( MASK & b ) ) ; return sb . toString ( ) . toUpperCase ( ) ; }
 public static < K , V > Map < K , V > copy@@ Map ( Map < K , V > m ) { return new HashMap < > ( m ) ; }
 public static byte [ ] ignite@@ Uuid@@ To@@ Bytes ( Ignite@@ Uuid uuid ) { assert uuid != null ; byte [ ] out = new byte [ 24 ] ; ignite@@ Uuid@@ To@@ Bytes ( uuid , out , 0 ) ; return out ; }
 public static File create@@ Dir ( String dirPath ) throws IOException { File dir = new File ( dirPath ) ; if ( dir . exists ( ) ) { return dir ; } if ( dir . mkdirs ( ) == false ) { throw new IOException ( " Failed ▁ to ▁ create ▁ dir ( s ) ▁ : ▁ " + dirPath ) ; } return dir ; }
 public static void cancel ( @ Nullable Grid@@ Worker w ) { if ( w != null ) w . cancel ( ) ; }
 public static String id@@ 8 ( Ignite@@ Uuid id ) { String s = id . toString ( ) ; return s . substring ( 0 , 4 ) + s . substring ( s . length ( ) - 4 ) ; }
 public static int bytesTo@@ Int ( byte [ ] bytes , int off ) { assert bytes != null ; int bytes@@ Cnt = Integer . SIZE >> 3 ; if ( off + bytes@@ Cnt > bytes . length ) bytes@@ Cnt = bytes . length - off ; int res = 0 ; for ( int i = 0 ; i < bytes@@ Cnt ; i ++ ) { int shift = bytes@@ Cnt - i - 1 << 3 ; res |= ( 0xff@@ L & bytes [ off ++ ] ) << shift ; } return res ; }
 public static Js@@ Array@@ Number wrap@@ Array ( float [ ] src@@ Array ) { Js@@ Array@@ Number result = JavaScript@@ Object . create@@ Array ( ) . cast ( ) ; for ( int i = 0 ; i < src@@ Array . length ; i ++ ) { result . set ( i , src@@ Array [ i ] ) ; } return result ; }
 public static int copy ( Reader in , Writer out ) throws IOException { assert in != null ; assert out != null ; char [ ] buf = new char [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
 private static void set@@ Scores ( Dynamic@@ Endpoint@@ Sn@@ itch d@@ sn@@ itch , int rounds , List < InetAddress > hosts , Integer ... scores ) throws InterruptedException { for ( int round = 0 ; round < rounds ; round ++ ) { for ( int i = 0 ; i < hosts . size ( ) ; i ++ ) d@@ sn@@ itch . receive@@ Timing ( hosts . get ( i ) , scores [ i ] ) ; } Thread . sleep ( 150 ) ; }
 public static Store@@ Reader create@@ Reader ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new Reader@@ Impl ( config , file ) ; }
 public static void write@@ Grid@@ U@@ uids ( DataOutput out , @ Nullable Collection < Ignite@@ Uuid > col ) throws IOException { if ( col != null ) { out . writeBoolean ( true ) ; out . writeInt ( col . size ( ) ) ; for ( Ignite@@ Uuid id : col ) write@@ Grid@@ Uuid ( out , id ) ; } else out . writeBoolean ( false ) ; }
 public static Object return@@ Object ( Page@@ Data pd , Map map ) { if ( pd . containsKey ( " callback " ) ) { String callback = pd . get ( " callback " ) . toString ( ) ; return new JSON@@ P@@ Object ( callback , map ) ; } else { return map ; } }
 public static boolean is@@ J@@ dk ( Class < ? > cls ) { if ( cls . is@@ Primitive ( ) ) return true ; String s = cls . getName ( ) ; return s . startsWith ( " java . " ) || s . startsWith ( " javax . " ) ; }
 public static InputStream getInput@@ Stream@@ For@@ A@@ File@@ From@@ Classpath ( String relative@@ FilePath , ClassLoader parent@@ ClassLoader ) { relative@@ FilePath = relative@@ FilePath . replace ( " \ \@@ " , " / " ) ; getLogger ( ) . log ( Level . INFO , " call ▁ to ▁ getInput@@ Stream@@ For@@ A@@ File@@ From@@ Classpath ▁ for ▁ path ▁ : ▁ " + relative@@ FilePath ) ; InputStream inStream = null ; if ( parent@@ ClassLoader != null ) inStream = parent@@ ClassLoader . getResourceAsStream ( relative@@ FilePath ) ; if ( inStream == null ) { ClassLoader my@@ ClassLoader = Thread . currentThread ( ) . getContext@@ ClassLoader ( ) ; inStream = my@@ ClassLoader . getResourceAsStream ( relative@@ FilePath ) ; } if ( inStream == null ) inStream = CodeGen@@ Util . class . getClassLoader ( ) . getResourceAsStream ( relative@@ FilePath ) ; if ( inStream == null ) getLogger ( ) . log ( Level . WARNING , " Could ▁ not ▁ find ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relative@@ FilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInput@@ Stream@@ For@@ A@@ File@@ From@@ Classpath " ) ; else getLogger ( ) . log ( Level . INFO , " Found ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relative@@ FilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInput@@ Stream@@ For@@ A@@ File@@ From@@ Classpath " ) ; return inStream ; }
 public static long currentTimeMillis ( ) { return cur@@ TimeMillis ; }
 public static String [ ] unwrap@@ Array ( Js@@ Array@@ String js@@ Array@@ String ) { String [ ] result = new String [ js@@ Array@@ String . length ( ) ] ; for ( int i = 0 ; i < js@@ Array@@ String . length ( ) ; i ++ ) { result [ i ] = js@@ Array@@ String . get ( i ) ; } return result ; }
 public static void rollback@@ Connection ( @ Nullable Connection rsrc , @ Nullable Ignite@@ Logger log ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException e ) { warn ( log , " Failed ▁ to ▁ rollback ▁ JDBC ▁ connection : ▁ " + e . getMessage ( ) ) ; } }
 static Pi@@ Field@@ Match translate@@ Criterion ( Criterion criterion , Pi@@ Match@@ Field@@ Id fieldId , Pi@@ Match@@ Type match@@ Type , int bit@@ Width ) throws Pi@@ TranslationException { if ( ! TRANSL@@ ATORS . containsKey ( criterion . getClass ( ) ) ) { throw new Pi@@ TranslationException ( format ( " Translation ▁ of ▁ criterion ▁ class ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . getClass ( ) . getSimpleName ( ) ) ) ; } Criter@@ ion@@ Translator translator = TRANSL@@ ATORS . get ( criterion . getClass ( ) ) ; try { translator . init ( criterion , bit@@ Width ) ; switch ( match@@ Type ) { case EX@@ ACT : return new Pi@@ Exact@@ Field@@ Match ( fieldId , translator . exact@@ Match ( ) ) ; case TER@@ N@@ ARY : Pair < Immutable@@ Byte@@ Sequence , Immutable@@ Byte@@ Sequence > tp = translator . tern@@ ary@@ Match ( ) ; return new Pi@@ Ter@@ n@@ ary@@ Field@@ Match ( fieldId , tp . getLeft ( ) , tp . getRight ( ) ) ; case LP@@ M : Pair < Immutable@@ Byte@@ Sequence , Integer > lp = translator . lp@@ m@@ Match ( ) ; return new Pi@@ L@@ pm@@ Field@@ Match ( fieldId , lp . getLeft ( ) , lp . getRight ( ) ) ; default : throw new Pi@@ TranslationException ( format ( " Translation ▁ of ▁ criterion ▁ % s ▁ ( % s ▁ class ) ▁ to ▁ match ▁ type ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . type ( ) . name ( ) , criterion . getClass ( ) . getSimpleName ( ) , match@@ Type . name ( ) ) ) ; } } catch ( Byte@@ Sequence@@ Trim@@ Exception e ) { throw new Pi@@ TranslationException ( format ( " Size ▁ mismatch ▁ for ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } catch ( Criter@@ ion@@ Translator@@ Exception e ) { throw new Pi@@ TranslationException ( format ( " Unable ▁ to ▁ translate ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } }
 public static double heap@@ Size ( Iterable < ClusterNode > nodes , int precision ) { double heap = 0.0 ; for ( ClusterNode n : node@@ sPer@@ J@@ vm ( nodes ) ) { Cluster@@ Metrics m = n . metrics ( ) ; heap += Math . max ( m . get@@ Heap@@ Memory@@ Initialized ( ) , m . get@@ Heap@@ Memory@@ Maximum ( ) ) ; } return ro@@ unded@@ Heap@@ Size ( heap , precision ) ; }
 public static void write@@ U@@ uids ( DataOutput out , @ Nullable Collection < UUID > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( UUID id : col ) write@@ Uuid ( out , id ) ; } else out . writeInt ( - 1 ) ; }
 @ Deprecated public static void dump@@ Stack ( String msg ) { new Exception ( debug@@ Prefix ( ) + msg ) . printStackTrace ( System . out ) ; }
 public static void writeString ( DataOutput out , String s ) throws IOException { out . writeBoolean ( s == null ) ; if ( s != null ) out . write@@ UTF ( s ) ; }
 public static Cluster@@ Group@@ Empty@@ CheckedException empty@@ Topology@@ Exception ( ) { return new Cluster@@ Group@@ Empty@@ CheckedException ( " Cluster ▁ group ▁ is ▁ empty . " ) ; }
 public static String get@@ FilePath ( String dir , String fileName ) { if ( dir == null || fileName == null ) { return null ; } String filePath = to@@ OS@@ FilePath ( dir ) + fileName ; return filePath ; }
 public static void error ( @ Nullable Ignite@@ Logger log , Object long@@ Msg , Object short@@ Msg , @ Nullable Throwable e ) { assert long@@ Msg != null ; assert short@@ Msg != null ; if ( log != null ) { if ( e == null ) log . error ( compact ( long@@ Msg . toString ( ) ) ) ; else log . error ( compact ( long@@ Msg . toString ( ) ) , e ) ; } else { X . printer@@ r ( " [ " + SHORT_@@ DATE_@@ FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( err ) ▁ " + compact ( short@@ Msg . toString ( ) ) ) ; if ( e != null ) e . printStackTrace ( System . err ) ; else X . printer@@ r@@ ln ( ) ; } }
 public static String fl ( String msg , Object ... args ) { assert args . length % 2 == 0 ; StringBuilder sb = new StringBuilder ( msg ) ; if ( args . length > 0 ) { sb . append ( " ▁ [ " ) ; for ( int i = 0 ; i < args . length / 2 ; i ++ ) { sb . append ( args [ i * 2 ] ) . append ( ' = ' ) . append ( args [ i * 2 + 1 ] ) ; sb . append ( " , ▁ " ) ; } sb . delete ( sb . length ( ) - 2 , sb . length ( ) ) ; sb . append ( ' ] ' ) ; } return sb . toString ( ) ; }
 public static Event@@ Notification@@ Entity for@@ Value ( int value ) { return values ( ) [ value ] ; }
 public static byte [ ] long@@ To@@ Bytes ( long l ) { return Grid@@ Client@@ Byte@@ Utils . long@@ To@@ Bytes ( l ) ; }
 private static void log@@ Resolve@@ Failed ( Class cls , Exception e ) { warn ( null , " Failed ▁ to ▁ resolve ▁ IGN@@ ITE _ HOME ▁ automatically ▁ for ▁ class ▁ code@@ base ▁ " + " [ class = " + cls + ( e == null ? " " : " , ▁ e = " + e . getMessage ( ) ) + ' ] ' ) ; }
 public static int capacity ( int exp@@ Size ) { if ( exp@@ Size < 3 ) return exp@@ Size + 1 ; if ( exp@@ Size < ( 1 << 30 ) ) return exp@@ Size + exp@@ Size / 3 ; return Integer . MAX_VALUE ; }
 public static Cc@@ Link@@ ingContext merge ( List < Cc@@ Link@@ ingContext > cc@@ Link@@ ing@@ Contexts ) { Builder merged@@ Cc@@ Link@@ ingContext = Cc@@ Link@@ ingContext . builder ( ) ; Extra@@ Link@@ Time@@ Libraries . Builder merged@@ Extra@@ Link@@ Time@@ Libraries = Extra@@ Link@@ Time@@ Libraries . builder ( ) ; for ( Cc@@ Link@@ ingContext cc@@ Link@@ ingContext : cc@@ Link@@ ing@@ Contexts ) { merged@@ Cc@@ Link@@ ingContext . add@@ Transi@@ tive@@ Linker@@ Inputs ( cc@@ Link@@ ingContext . get@@ Linker@@ Inputs ( ) ) ; if ( cc@@ Link@@ ingContext . get@@ Extra@@ Link@@ Time@@ Libraries ( ) != null ) { merged@@ Extra@@ Link@@ Time@@ Libraries . add@@ Transi@@ tive ( cc@@ Link@@ ingContext . get@@ Extra@@ Link@@ Time@@ Libraries ( ) ) ; } } merged@@ Cc@@ Link@@ ingContext . set@@ Extra@@ Link@@ Time@@ Libraries ( merged@@ Extra@@ Link@@ Time@@ Libraries . build ( ) ) ; return merged@@ Cc@@ Link@@ ingContext . build ( ) ; }
 @ Nullable public static String lambda@@ Enclosing@@ ClassName ( String cl@@ sName ) { int idx = cl@@ sName . indexOf ( " $ $ Lambda $ " ) ; return idx != - 1 ? cl@@ sName . substring ( 0 , idx ) : null ; }
 public static Grid@@ Peer@@ Deploy@@ Aware detect@@ Peer@@ Deploy@@ Aware ( Grid@@ Peer@@ Deploy@@ Aware obj ) { Grid@@ Peer@@ Deploy@@ Aware p = nested@@ Peer@@ Deploy@@ Aware ( obj , true , new Grid@@ Le@@ an@@ Identity@@ Set < > ( ) ) ; return p != null ? p : peer@@ Deploy@@ Aware ( obj . getClass ( ) ) ; }
 public static void error ( @ Nullable Ignite@@ Logger log , Object msg ) { assert msg != null ; if ( msg instanceof Throwable ) { Throwable t = ( Throwable ) msg ; error ( log , t . getMessage ( ) , t ) ; } else { String s = msg . toString ( ) ; error ( log , s , s , null ) ; } }
 public static String getSimpleName ( Class < ? > cls ) { String name = cls . getSimpleName ( ) ; if ( F . isEmpty ( name ) ) name = cls . getName ( ) . substring ( cls . getPackage ( ) . getName ( ) . length ( ) + 1 ) ; return name ; }
 public static int [ ] grid@@ Events ( final int ... ex@@ cl ) { if ( F . isEmpty ( ex@@ cl ) ) return GRID_@@ EV@@ TS ; List < Integer > ev@@ ts = to@@ Int@@ List ( GRID_@@ EV@@ TS , new P1 < Integer > ( ) { @ Override public boolean apply ( Integer i ) { return ! contains@@ IntArray ( ex@@ cl , i ) ; } } ) ; return to@@ IntArray ( ev@@ ts ) ; }
 public static boolean has@@ Pro@@ guard@@ Specs ( Attribute@@ Map rule ) { return rule . is@@ Configurable ( " pro@@ guard _ specs " ) || ! rule . get ( " pro@@ guard _ specs " , LABEL_@@ LIST ) . isEmpty ( ) ; }
 public static Collection < InetSocketAddress > to@@ Socket@@ Addresses ( ClusterNode node , int port ) { return to@@ Socket@@ Addresses ( node . addresses ( ) , node . host@@ Names ( ) , port ) ; }
 public static boolean dis@@ co@@ Ordered ( Discovery@@ Spi dis@@ co@@ Spi ) { Discovery@@ Spi@@ Order@@ Support ann = U . getAnnotation ( dis@@ co@@ Spi . getClass ( ) , Discovery@@ Spi@@ Order@@ Support . class ) ; return ann != null && ann . value ( ) ; }
 public static boolean join ( @ Nullable Grid@@ Worker w , @ Nullable Ignite@@ Logger log ) { if ( w != null ) try { w . join ( ) ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ runnable : ▁ " + w ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
 public static void move ( String src@@ FilePath , String dest@@ Loc , boolean override ) throws IOException { File src@@ File = new File ( src@@ FilePath ) ; File dest@@ Dir = create@@ Dir ( dest@@ Loc ) ; File newFile = new File ( dest@@ Dir , src@@ File . getName ( ) ) ; if ( newFile . exists ( ) ) { if ( override == false ) { return ; } else { delete@@ File ( newFile ) ; } } boolean success = src@@ File . rename@@ To ( newFile ) ; if ( success == false ) { throw new IOException ( " Failed ▁ to ▁ move ▁ file ▁ : ▁ " + src@@ FilePath + " ▁ to ▁ " + dest@@ Loc ) ; } }
 @ Nullable public static < T > T newInstance ( Class < T > cls ) throws IgniteCheckedException { boolean set = false ; Constructor < T > ctor = null ; try { ctor = cls . getDeclared@@ Constructor ( ) ; if ( ctor == null ) return null ; if ( ! ctor . is@@ Accessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ctor . newInstance ( ) ; } catch ( NoSuchMethodException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ find ▁ empty ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( ctor != null && set ) ctor . setAccessible ( false ) ; } }
 public static Collector < Map . Entry < String , JsonValue > , Json@@ Object@@ Builder , JsonObject > to@@ JsonObject ( ) { return null ; }
 public static < K , V > LinkedHashMap < K , V > new@@ LinkedHashMap ( int exp@@ Size ) { return new LinkedHashMap < > ( capacity ( exp@@ Size ) ) ; }
 @ Nullable private static String resolve@@ Project@@ Home ( ) { assert Thread . hol@@ ds@@ Lock ( Ignite@@ Utils . class ) ; String gg@@ Home@@ 0 = Ignite@@ SystemProperties . getString ( IGN@@ ITE_@@ HOME ) ; if ( ! F . isEmpty ( gg@@ Home@@ 0 ) ) return gg@@ Home@@ 0 ; String app@@ Work@@ Dir = System . getProperty ( " user . dir " ) ; if ( app@@ Work@@ Dir != null ) { gg@@ Home@@ 0 = find@@ Project@@ Home ( new File ( app@@ Work@@ Dir ) ) ; if ( gg@@ Home@@ 0 != null ) return gg@@ Home@@ 0 ; } URI classes@@ Uri ; Class < Ignite@@ Utils > cls = Ignite@@ Utils . class ; try { Protection@@ Domain domain = cls . get@@ Protection@@ Domain ( ) ; if ( domain == null || domain . getCode@@ Source ( ) == null || domain . getCode@@ Source ( ) . getLocation ( ) == null ) { log@@ Resolve@@ Failed ( cls , null ) ; return null ; } classes@@ Uri = domain . getCode@@ Source ( ) . getLocation ( ) . toURI ( ) ; if ( is@@ Windows ( ) && classes@@ Uri . get@@ Authority ( ) != null ) classes@@ Uri = new URI ( classes@@ Uri . toString ( ) . replace ( " file : // " , " file : / " ) ) ; } catch ( URISyntaxException | SecurityException e ) { log@@ Resolve@@ Failed ( cls , e ) ; return null ; } File classes@@ File ; try { classes@@ File = new File ( classes@@ Uri ) ; } catch ( IllegalArgumentException e ) { log@@ Resolve@@ Failed ( cls , e ) ; return null ; } return find@@ Project@@ Home ( classes@@ File ) ; }
 public static int hash ( Object key ) { return hash ( key . hashCode ( ) ) ; }
 private static void print@@ Thread@@ Info ( Thread@@ Info thread@@ Info , Grid@@ StringBuilder sb , Set < Long > dead@@ locked@@ IdSet ) { final long id = thread@@ Info . get@@ ThreadId ( ) ; if ( dead@@ locked@@ IdSet . contains ( id ) ) sb . a ( " # # # # # ▁ DEAD@@ LOCKED ▁ " ) ; sb . a ( " Thread ▁ [ name = \@@ " " ) . a ( thread@@ Info . getThread@@ Name ( ) ) . a ( " \@@ " , ▁ id = " ) . a ( thread@@ Info . get@@ ThreadId ( ) ) . a ( " , ▁ state = " ) . a ( thread@@ Info . getThread@@ State ( ) ) . a ( " , ▁ block@@ Cnt = " ) . a ( thread@@ Info . getB@@ locked@@ Count ( ) ) . a ( " , ▁ wait@@ Cnt = " ) . a ( thread@@ Info . get@@ Wa@@ ited@@ Count ( ) ) . a ( " ] " ) . a ( NL ) ; Lock@@ Info lock@@ Info = thread@@ Info . get@@ Lock@@ Info ( ) ; if ( lock@@ Info != null ) { sb . a ( " ▁ ▁ ▁ ▁ Lock ▁ [ object = " ) . a ( lock@@ Info ) . a ( " , ▁ owner@@ Name = " ) . a ( thread@@ Info . get@@ Lock@@ Owner@@ Name ( ) ) . a ( " , ▁ owner@@ Id = " ) . a ( thread@@ Info . get@@ Lock@@ Owner@@ Id ( ) ) . a ( " ] " ) . a ( NL ) ; } Monitor@@ Info [ ] monitors = thread@@ Info . get@@ Locked@@ Monit@@ ors ( ) ; StackTraceElement [ ] elements = thread@@ Info . getStackTrace ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { StackTraceElement e = elements [ i ] ; sb . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ at ▁ " ) . a ( e . toString ( ) ) ; for ( Monitor@@ Info monitor : monitors ) { if ( monitor . get@@ Locked@@ Stack@@ Depth ( ) == i ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ locked ▁ " ) . a ( monitor ) ; } sb . a ( NL ) ; } }
 public static boolean is@@ Windows@@ 2008 ( ) { return win@@ 2008 ; }
 public static boolean delete@@ Content@@ sOf@@ Dir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = delete@@ Dir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return true ; }
 public static Map < String , String > create@@ NS@@ 2@@ Package@@ Map ( Input@@ Options input@@ Options ) { Map < String , String > ns@@ 2@@ Pkg@@ Map = new HashMap < String , String > ( ) ; Pkg@@ To@@ NS@@ Mapping@@ List pkg@@ N@@ sMap@@ List = input@@ Options . getP@@ kg@@ NS@@ Mappings ( ) ; if ( pkg@@ N@@ sMap@@ List != null && ! pkg@@ N@@ sMap@@ List . getP@@ kg@@ N@@ sMap ( ) . isEmpty ( ) ) { for ( Pkg@@ NS@@ Mapping@@ Type pkg@@ Ns@@ MapType : pkg@@ N@@ sMap@@ List . getP@@ kg@@ N@@ sMap ( ) ) { ns@@ 2@@ Pkg@@ Map . put ( pkg@@ Ns@@ MapType . getNamespace ( ) , pkg@@ Ns@@ MapType . getPackage ( ) ) ; } } return ns@@ 2@@ Pkg@@ Map ; }
 public static Calendar parse@@ Iso@@ Date ( String str ) throws IgniteCheckedException { StringTokenizer t = new StringTokenizer ( str , " + - : . TZ " , true ) ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; try { if ( t . hasMoreTokens ( ) ) cal . set ( Calendar . YEAR , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( check@@ NextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MONTH , Integer . parseInt ( t . nextToken ( ) ) - 1 ) ; else return cal ; if ( check@@ NextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . DAY_OF_MONTH , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( check@@ NextToken ( t , " T " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . HOUR_@@ OF_@@ DAY , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . HOUR_@@ OF_@@ DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLI@@ SECOND , 0 ) ; return cal ; } if ( check@@ NextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MINUTE , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLI@@ SECOND , 0 ) ; return cal ; } if ( ! t . hasMoreTokens ( ) ) return cal ; String tok = t . nextToken ( ) ; if ( " : " . equals ( tok ) ) { if ( t . hasMoreTokens ( ) ) { cal . set ( Calendar . SECOND , Integer . parseInt ( t . nextToken ( ) ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; if ( " . " . equals ( tok ) ) { String nt = t . nextToken ( ) ; while ( nt . length ( ) < 3 ) nt += "0" ; nt = nt . substring ( 0 , 3 ) ; cal . set ( Calendar . MILLI@@ SECOND , Integer . parseInt ( nt ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; } else cal . set ( Calendar . MILLI@@ SECOND , 0 ) ; } else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } else { cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLI@@ SECOND , 0 ) ; } if ( ! " Z " . equals ( tok ) ) { if ( ! " + " . equals ( tok ) && ! " - " . equals ( tok ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; boolean plus = " + " . equals ( tok ) ; if ( ! t . hasMoreTokens ( ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; tok = t . nextToken ( ) ; int tz@@ Hour ; int tz@@ Min ; if ( tok . length ( ) == 4 ) { tz@@ Hour = Integer . parseInt ( tok . substring ( 0 , 2 ) ) ; tz@@ Min = Integer . parseInt ( tok . substring ( 2 , 4 ) ) ; } else { tz@@ Hour = Integer . parseInt ( tok ) ; if ( check@@ NextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) tz@@ Min = Integer . parseInt ( t . nextToken ( ) ) ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } if ( plus ) cal . set ( Calendar . ZONE_@@ OFFSET , ( tz@@ Hour * 60 + tz@@ Min ) * 60 * 1000 ) ; else cal . set ( Calendar . ZONE_@@ OFFSET , - ( tz@@ Hour * 60 + tz@@ Min ) * 60 * 1000 ) ; } else cal . set@@ TimeZone ( TimeZone . getTimeZone ( " GMT " ) ) ; } catch ( NumberFormatException ex ) { throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str , ex ) ; } return cal ; }
 public static Js@@ Array@@ Integer wrap@@ Array ( int [ ] src@@ Array ) { Js@@ Array@@ Integer result = JavaScript@@ Object . create@@ Array ( ) . cast ( ) ; for ( int i = 0 ; i < src@@ Array . length ; i ++ ) { result . set ( i , src@@ Array [ i ] ) ; } return result ; }
 public static boolean is@@ Java@@ Version@@ At@@ Least ( String v ) { return compare@@ Version@@ Numbers ( java@@ Rt@@ Ver , v ) >= 0 ; }
 public static Comparator < InetSocketAddress > inet@@ Addres@@ ses@@ Comparator ( final boolean same@@ Host ) { return new Comparator < InetSocketAddress > ( ) { @ Override public int compare ( InetSocketAddress addr1 , InetSocketAddress addr2 ) { if ( addr1 . isUn@@ resolved ( ) && addr2 . isUn@@ resolved ( ) ) return 0 ; if ( addr1 . isUn@@ resolved ( ) || addr2 . isUn@@ resolved ( ) ) return addr1 . isUn@@ resolved ( ) ? 1 : - 1 ; boolean addr@@ 1@@ Loop@@ back = addr1 . getAddress ( ) . is@@ Loop@@ back@@ Address ( ) ; if ( addr@@ 1@@ Loop@@ back == addr2 . getAddress ( ) . is@@ Loop@@ back@@ Address ( ) ) return 0 ; if ( same@@ Host ) return addr@@ 1@@ Loop@@ back ? - 1 : 1 ; else return addr@@ 1@@ Loop@@ back ? 1 : - 1 ; } } ; }
 public static void nul@@ li@@ fy@@ Home@@ Directory ( ) { gg@@ Home = null ; }
 public static String custom@@ Directory@@ Log@@ FileName ( @ Nullable String dir , String fileName ) { assert fileName != null ; if ( dir == null ) return fileName ; int sep = fileName . lastIndexOf ( File . separator ) ; return dir + ( sep < 0 ? File . separator + fileName : fileName . substring ( sep ) ) ; }
 public static < K , V > Map < K , V > li@@ mited@@ Map ( int limit ) { if ( limit == 0 ) return Collections . emptyMap ( ) ; if ( limit < 5 ) return new Grid@@ Le@@ an@@ Map < > ( limit ) ; return new HashMap < > ( capacity ( limit ) , 0.75@@ f ) ; }
 public static void release@@ Qu@@ i@@ et ( @ Nullable File@@ Lock lock ) { if ( lock != null ) try { lock . release ( ) ; } catch ( Exception ignored ) { } }
 public static ClusterNode oldest ( Collection < ClusterNode > c , @ Nullable Ignite@@ Predicate < ClusterNode > p ) { ClusterNode oldest = null ; long min@@ Order = Long . MAX_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) < min@@ Order ) { oldest = n ; min@@ Order = n . order ( ) ; } } return oldest ; }
 public static boolean is@@ Windows ( ) { return win@@ 7 || win@@ 8 || win@@ 81 || win@@ X@@ p || win@@ 95 || win@@ 98 || win@@ N@@ t || win@@ 2@@ k || win@@ 2003 || win@@ 2008 || win@@ Vista || unknown@@ Win ; }
 public static boolean p2@@ p@@ Loader ( ClassLoader ldr ) { return ldr instanceof Grid@@ Deployment@@ Info ; }
 public static void init ( ) { P@@ Applet . main ( " an@@ ph@@ ar@@ os . gui . Graph . Graph@@ Parent " ) ; }
 public static < E extends Throwable > E with@@ Cause ( E e , @ Nullable Throwable cause ) { assert e != null ; if ( cause != null ) e . initCause ( cause ) ; return e ; }
 public static ClusterNode youn@@ gest ( Collection < ClusterNode > c , @ Nullable Ignite@@ Predicate < ClusterNode > p ) { ClusterNode youn@@ gest = null ; long max@@ Order = Long . MIN_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) > max@@ Order ) { youn@@ gest = n ; max@@ Order = n . order ( ) ; } } return youn@@ gest ; }
 public static void closeQuietly ( Closeable close@@ able ) { if ( close@@ able == null ) { return ; } try { close@@ able . close ( ) ; } catch ( IOException ignore ) { } }
 public static URL resolve@@ Spring@@ Url ( String spring@@ Cfg@@ Path ) throws IgniteCheckedException { A . notNull ( spring@@ Cfg@@ Path , " spring@@ Cfg@@ Path " ) ; URL url ; try { url = new URL ( spring@@ Cfg@@ Path ) ; } catch ( MalformedURLException e ) { url = U . resolve@@ Ignite@@ Url ( spring@@ Cfg@@ Path ) ; if ( url == null ) url = resolve@@ In@@ Classpath ( spring@@ Cfg@@ Path ) ; if ( url == null ) throw new IgniteCheckedException ( " Spring ▁ XML ▁ configuration ▁ path ▁ is ▁ invalid : ▁ " + spring@@ Cfg@@ Path + " . ▁ Note ▁ that ▁ this ▁ path ▁ should ▁ be ▁ either ▁ absolute ▁ or ▁ a ▁ relative ▁ local ▁ file ▁ system ▁ path , ▁ " + " relative ▁ to ▁ META - INF ▁ in ▁ classpath ▁ or ▁ valid ▁ URL ▁ to ▁ IGN@@ ITE _ HOME . " , e ) ; } return url ; }
 public static boolean is@@ Ignite ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite " ) ; }
 public static Multi@@ dex@@ Mode fromValue ( String value ) { for ( Multi@@ dex@@ Mode mode : values ( ) ) { if ( mode . getAttributeValue ( ) . equals ( value ) ) { return mode ; } } return null ; }
 public static Ignite@@ Product@@ Version product@@ Version ( ClusterNode node ) { String ver@@ Str = node . attribute ( ATTR_@@ BUILD_@@ VER ) ; String build@@ Date = node . attribute ( ATTR_@@ BUILD_@@ DATE ) ; if ( build@@ Date != null ) ver@@ Str += ' - ' + build@@ Date ; return Ignite@@ Product@@ Version . fromString ( ver@@ Str ) ; }
 public static void flush@@ And@@ Close@@ Quietly ( Closeable close@@ able ) { if ( close@@ able == null ) { return ; } try { if ( close@@ able instanceof Flush@@ able ) { ( ( Flush@@ able ) close@@ able ) . flush ( ) ; } } catch ( IOException e ) { } try { close@@ able . close ( ) ; } catch ( IOException ignore ) { } }
 public static int uuid@@ To@@ Bytes ( @ Nullable UUID uuid , byte [ ] arr , int off ) { return off + Grid@@ Client@@ Byte@@ Utils . uuid@@ To@@ Bytes ( uuid , arr , off ) ; }
 public static void write@@ ByteArray ( DataOutput out , @ Nullable byte [ ] arr , int maxLen ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { int len = Math . min ( arr . length , maxLen ) ; out . writeInt ( len ) ; out . write ( arr , 0 , len ) ; } }
 public static List < Integer > to@@ Int@@ List ( @ Nullable int [ ] arr , Ignite@@ Predicate < Integer > ... p ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Integer > ret = new ArrayList < > ( arr . length ) ; if ( F . isEmpty ( p ) ) for ( int i : arr ) ret . add ( i ) ; else { for ( int i : arr ) if ( F . is@@ All ( i , p ) ) ret . add ( i ) ; } return ret ; }
 public static String os@@ Version ( ) { return os@@ Ver ; }
 public static boolean has@@ Parent ( @ Nullable ClassLoader parent , ClassLoader ldr ) { if ( parent != null ) { for ( ; ldr != null ; ldr = ldr . getParent ( ) ) { if ( ldr . equals ( parent ) ) return true ; } return false ; } return true ; }
 private static void print@@ Synchron@@ izer@@ sInfo ( Lock@@ Info [ ] syn@@ cs , Grid@@ StringBuilder sb ) { sb . a ( " ▁ ▁ ▁ ▁ Locked ▁ synchron@@ izers : " ) ; for ( Lock@@ Info info : syn@@ cs ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) . a ( info ) ; }
 public static String id@@ 8 ( UUID id ) { return id . toString ( ) . substring ( 0 , 8 ) ; }
 public static int compare@@ Version@@ Numbers ( @ Nullable String v1 , @ Nullable String v2 ) { if ( v1 == null && v2 == null ) return 0 ; if ( v1 == null ) return - 1 ; if ( v2 == null ) return 1 ; String [ ] part@@ 1 = v1 . split ( " [ \\ . \\ _ \\ - ] " ) ; String [ ] part@@ 2 = v2 . split ( " [ \\ . \\ _ \\ - ] " ) ; int idx = 0 ; for ( ; idx < part@@ 1 . length && idx < part@@ 2 . length ; idx ++ ) { String p1 = part@@ 1 [ idx ] ; String p2 = part@@ 2 [ idx ] ; int cmp = ( p1 . matches ( " \\ d + " ) && p2 . matches ( " \\ d + " ) ) ? Integer . valueOf ( p1 ) . compareTo ( Integer . valueOf ( p2 ) ) : p1 . compareTo ( p2 ) ; if ( cmp != 0 ) return cmp ; } if ( part@@ 1 . length == part@@ 2 . length ) return 0 ; else return part@@ 1 . length > idx ? 1 : - 1 ; }
 public static < T > T field ( Object obj , String fieldName ) { assert obj != null ; assert fieldName != null ; try { for ( Class cls = obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuper@@ class ( ) ) { for ( Field field : cls . getDeclared@@ Fields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . is@@ Accessible ( ) ; field . setAccessible ( true ) ; T val = ( T ) field . get ( obj ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } } } catch ( Exception e ) { throw new Ignite@@ Exception ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' , e ) ; } throw new Ignite@@ Exception ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' ) ; }
 public static float bytesTo@@ Float ( byte [ ] bytes , int off ) { return Float . int@@ BitsTo@@ Float ( bytesTo@@ Int ( bytes , off ) ) ; }
 public static boolean delete@@ Dir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = delete@@ Dir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return dir . delete ( ) ; }
 public static String node@@ Id@@ Log@@ FileName ( UUID nodeId , String fileName ) { assert nodeId != null ; assert fileName != null ; fileName = Grid@@ Filename@@ Utils . separator@@ sTo@@ System ( fileName ) ; int dot = fileName . lastIndexOf ( ' . ' ) ; if ( dot < 0 || dot == fileName . length ( ) - 1 ) return fileName + ' - ' + U . id@@ 8 ( nodeId ) ; else return fileName . substring ( 0 , dot ) + ' - ' + U . id@@ 8 ( nodeId ) + fileName . substring ( dot ) ; }
 public static Collection < InetAddress > to@@ Inet@@ Addresses ( ClusterNode node ) throws IgniteCheckedException { return to@@ Inet@@ Addresses ( node . addresses ( ) , node . host@@ Names ( ) ) ; }
 public static Js@@ Array@@ String wrap@@ Array ( String [ ] src@@ Array ) { Js@@ Array@@ String result = JavaScript@@ Object . create@@ Array ( ) . cast ( ) ; for ( int i = 0 ; i < src@@ Array . length ; i ++ ) { result . set ( i , src@@ Array [ i ] ) ; } return result ; }
 public static double heap@@ Size ( ClusterNode node , int precision ) { return heap@@ Size ( Collections . singleton ( node ) , precision ) ; }
 public static int long@@ To@@ Bytes ( long l , byte [ ] bytes , int off ) { return off + Grid@@ Client@@ Byte@@ Utils . long@@ To@@ Bytes ( l , bytes , off ) ; }
 private static void set@@ Cro@@ sst@@ ool@@ To@@ Android ( Build@@ Options options ) { Android@@ Configuration . Options android@@ Options = options . get ( Android@@ Configuration . Options . class ) ; Cpp@@ Options cpp@@ Options = options . get ( Cpp@@ Options . class ) ; if ( android@@ Options . android@@ Cro@@ sst@@ ool@@ Top != null ) { cpp@@ Options . cro@@ sst@@ ool@@ Top = android@@ Options . android@@ Cro@@ sst@@ ool@@ Top ; } android@@ Options . configuration@@ Dist@@ ingu@@ ish@@ er = Configuration@@ Dist@@ ingu@@ ish@@ er . ANDROID ; }
 @ Nullable public static ClassLoader detect@@ Object@@ ClassLoader ( @ Nullable Object obj ) { if ( obj == null ) return null ; if ( obj instanceof Grid@@ Peer@@ Deploy@@ Aware ) return ( ( Grid@@ Peer@@ Deploy@@ Aware ) obj ) . classLoader ( ) ; return detect@@ ClassLoader ( obj . getClass ( ) ) ; }
 public static < E extends Enum > void write@@ Enum ( DataOutput out , E e ) throws IOException { out . writeByte ( e == null ? - 1 : e . ordinal ( ) ) ; }
 public static Texture@@ Container < Tiled@@ Texture@@ Region > produce ( final Texture texture , final Context context , final String asset@@ Path , final int texture@@ Position@@ X , final int texture@@ Position@@ Y , final int tile@@ Columns , final int tile@@ Rows ) { return new Texture@@ Container < Tiled@@ Texture@@ Region > ( Texture@@ Region@@ Factory . create@@ Tiled@@ From@@ Asset ( texture , context , asset@@ Path , texture@@ Position@@ X , texture@@ Position@@ Y , tile@@ Columns , tile@@ Rows ) , get@@ Pixels ( asset@@ Path , context , tile@@ Columns , tile@@ Rows ) , asset@@ Path ) ; }
 public static boolean await ( CountDownLatch latch , long timeout , TimeUnit unit ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { return latch . await ( timeout , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static String jvm@@ Vendor ( ) { return jvm@@ Impl@@ Vendor ; }
 public static boolean check@@ Param ( String method , Page@@ Data pd ) { boolean result = false ; int false@@ Count = 0 ; String [ ] param@@ Array = new String [ 20 ] ; String [ ] value@@ Array = new String [ 20 ] ; String [ ] temp@@ Array = new String [ 20 ] ; if ( method == " registered " ) { param@@ Array = Const . APP_@@ REGISTER@@ ED_@@ PARAM_@@ ARRAY ; value@@ Array = Const . APP_@@ REGISTER@@ ED_@@ VALUE_@@ ARRAY ; } else if ( method == " get@@ Ap@@ pu@@ ser@@ By@@ User@@ n@@ ma@@ e " ) { param@@ Array = Const . APP_@@ GE@@ TA@@ P@@ PU@@ SER_@@ PARAM_@@ ARRAY ; value@@ Array = Const . APP_@@ GE@@ TA@@ P@@ PU@@ SER_@@ VALUE_@@ ARRAY ; } int size = param@@ Array . length ; for ( int i = 0 ; i < size ; i ++ ) { String param = param@@ Array [ i ] ; if ( ! pd . containsKey ( param ) ) { temp@@ Array [ false@@ Count ] = value@@ Array [ i ] + " - - " + param ; false@@ Count += 1 ; } } if ( false@@ Count > 0 ) { logger . error ( method + " 接@@ 口 ， 请@@ 求@@ 协@@ 议@@ 中@@ 缺@@ 少 ▁ " + false@@ Count + " 个 ▁ 参@@ 数 " ) ; for ( int j = 1 ; j <= false@@ Count ; j ++ ) { logger . error ( " ▁ ▁ ▁ 第 " + j + " 个 ： " + temp@@ Array [ j - 1 ] ) ; } } else { result = true ; } return result ; }
 public static void write@@ ByteArray ( DataOutput out , @ Nullable byte [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; out . write ( arr ) ; } }
 public static UUID bytesTo@@ Uuid ( byte [ ] bytes , int off ) { return Grid@@ Client@@ Byte@@ Utils . bytesTo@@ Uuid ( bytes , off ) ; }
 private static long to@@ Addr@@ And@@ Len ( long address , int size ) { return ( address << SIZE_@@ BITS ) | size ; }
 public static void clear@@ Class@@ Cache ( ) { class@@ Cache . clear ( ) ; }
 public static Runtime@@ MXBean getRuntime@@ M@@ x ( ) { return Management@@ Factory . getRuntime@@ MXBean ( ) ; }
 public static String convertTo@@ FilePath ( String qualified@@ Java@@ Name , String suffix ) { return qualified@@ Java@@ Name . replace ( ' . ' , File . separator@@ Char ) + suffix ; }
 @ Nullable public static URL resolve@@ Ignite@@ Url ( String path ) { return resolve@@ Ignite@@ Url ( path , true ) ; }
 public static int concurrent@@ Map@@ Segment ( int hash , int con@@ cur@@ L@@ vl ) { hash += ( hash << 15 ) ^ 0xffff@@ cd@@ 7d ; hash ^= ( hash >@@ >> 10 ) ; hash += ( hash << 3 ) ; hash ^= ( hash >@@ >> 6 ) ; hash += ( hash << 2 ) + ( hash << 14 ) ; int shift = 0 ; int size = 1 ; while ( size < con@@ cur@@ L@@ vl ) { ++ shift ; size <<= 1 ; } int segment@@ Shift = 32 - shift ; int segment@@ Mask = size - 1 ; return ( hash >@@ >> segment@@ Shift ) & segment@@ Mask ; }
 public static < V , C extends Collection < ? super V > > C addAll ( C c , V ... vals ) { Collections . addAll ( c , vals ) ; return c ; }
 public static List < InetAddress > filter@@ Reachable ( List < InetAddress > addrs ) { final int reach@@ Timeout = 2000 ; if ( addrs . isEmpty ( ) ) return Collections . emptyList ( ) ; if ( addrs . size ( ) == 1 ) { InetAddress addr = addrs . get ( 0 ) ; if ( reachable ( addr , reach@@ Timeout ) ) return Collections . singletonList ( addr ) ; return Collections . emptyList ( ) ; } final List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Collection < Future < ? > > fu@@ ts = new ArrayList < > ( addrs . size ( ) ) ; ExecutorService executor = Executors . new@@ Fixed@@ ThreadPool ( Math . min ( 10 , addrs . size ( ) ) ) ; for ( final InetAddress addr : addrs ) { fu@@ ts . add ( executor . submit ( new Runnable ( ) { @ Override public void run ( ) { if ( reachable ( addr , reach@@ Timeout ) ) { synchronized ( res ) { res . add ( addr ) ; } } } } ) ) ; } for ( Future < ? > fut : fu@@ ts ) { try { fut . get ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Exception ( " Thread ▁ has ▁ been ▁ interrupted . " , e ) ; } catch ( ExecutionException e ) { throw new Ignite@@ Exception ( e ) ; } } executor . shutdown ( ) ; return res ; }
 public static Collection < InetAddress > to@@ Inet@@ Addresses ( Collection < String > addrs , Collection < String > host@@ Names ) throws IgniteCheckedException { List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > host@@ Names@@ It = host@@ Names . iterator ( ) ; for ( String addr : addrs ) { String hostName = host@@ Names@@ It . hasNext ( ) ? host@@ Names@@ It . next ( ) : null ; InetAddress inet@@ Addr = null ; if ( ! F . isEmpty ( hostName ) ) { try { inet@@ Addr = InetAddress . getByName ( hostName ) ; } catch ( UnknownHostException ignored ) { } } if ( inet@@ Addr == null || inet@@ Addr . is@@ Loop@@ back@@ Address ( ) ) { try { inet@@ Addr = InetAddress . getByName ( addr ) ; } catch ( UnknownHostException ignored ) { } } if ( inet@@ Addr != null ) res . add ( inet@@ Addr ) ; } if ( res . isEmpty ( ) ) throw new IgniteCheckedException ( " Addresses ▁ can ▁ not ▁ be ▁ resolved ▁ [ addr = " + addrs + " , ▁ host@@ Names = " + host@@ Names + ' ] ' ) ; return F . view@@ List@@ ReadOnly ( res , F . < InetAddress > identity ( ) ) ; }
 public static void remove@@ Log@@ 4j@@ No@@ Op@@ Logger ( Ignite@@ Bi@@ Tuple < Object , Object > t ) throws IgniteCheckedException { Object root@@ Log = t . get@@ 1 ( ) ; Object null@@ App = t . get@@ 2 ( ) ; if ( null@@ App == null ) return ; try { Class app@@ ender@@ Cls = Class . forName ( " org . apache . log4j . Appender " ) ; root@@ Log . getClass ( ) . getMethod ( " remove@@ Appender " , app@@ ender@@ Cls ) . invoke ( root@@ Log , null@@ App ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ remove ▁ previously ▁ added ▁ no - op ▁ logger ▁ for ▁ Log@@ 4j . " , e ) ; } }
 public static boolean is@@ Load@@ able@@ By ( String cl@@ sName , @ Nullable ClassLoader ldr ) { assert cl@@ sName != null ; if ( ldr == null ) ldr = grid@@ ClassLoader ; String lambda@@ Parent = U . lambda@@ Enclosing@@ ClassName ( cl@@ sName ) ; try { ldr . loadClass ( lambda@@ Parent == null ? cl@@ sName : lambda@@ Parent ) ; return true ; } catch ( ClassNotFoundException ignore ) { return false ; } }
 public static boolean join@@ Threads ( Iterable < ? extends Thread > workers , @ Nullable Ignite@@ Logger log ) { boolean retval = true ; if ( workers != null ) for ( Thread worker : workers ) if ( ! join ( worker , log ) ) retval = false ; return retval ; }
 public static void main ( String [ ] args ) { Page@@ Data pd = new Page@@ Data ( ) ; pd . put ( " username " , " zhang@@ san " ) ; check@@ Param ( " registered " , pd ) ; }
 public static byte [ ] doubleTo@@ Bytes ( double d ) { return long@@ To@@ Bytes ( Double . doubleTo@@ LongBits ( d ) ) ; }
 public static boolean overri@@ des@@ Equal@@ sAnd@@ HashCode ( Object obj ) { try { Class < ? > cls = obj . getClass ( ) ; return ! Object . class . equals ( cls . getMethod ( " equals " , Object . class ) . getDeclar@@ ingClass ( ) ) && ! Object . class . equals ( cls . getMethod ( " hashCode " ) . getDeclar@@ ingClass ( ) ) ; } catch ( NoSuchMethodException | SecurityException ignore ) { return true ; } }
 @ Nullable public static List < Integer > read@@ Int@@ List ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
 public static String getPackageName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( 0 , idx ) ; }
 private static Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , Ignite@@ Exception > > exception@@ Converters ( ) { Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , Ignite@@ Exception > > m = new HashMap < > ( ) ; m . put ( Ignite@@ Interrup@@ ted@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Ignite@@ InterruptedException ( e . getMessage ( ) , ( InterruptedException ) e . getCause ( ) ) ; } } ) ; m . put ( Ignite@@ Future@@ Cancelled@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Ignite@@ Future@@ Cancelled@@ Exception ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Ignite@@ Future@@ Timeout@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Ignite@@ Future@@ TimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Cluster@@ Group@@ Empty@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Cluster@@ Group@@ Empty@@ Exception ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Cluster@@ Topology@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { Cluster@@ Topology@@ Exception top@@ Ex = new Cluster@@ Topology@@ Exception ( e . getMessage ( ) , e ) ; Cluster@@ Topology@@ CheckedException checked = ( Cluster@@ Topology@@ CheckedException ) e ; if ( checked . retry@@ Ready@@ Future ( ) != null ) top@@ Ex . retry@@ Ready@@ Future ( new Ignite@@ Future@@ Impl < > ( checked . retry@@ Ready@@ Future ( ) ) ) ; return top@@ Ex ; } } ) ; m . put ( Ignite@@ Deployment@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Ignite@@ Deployment@@ Exception ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Compute@@ Task@@ Timeout@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Compute@@ Task@@ TimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Compute@@ Task@@ Cancelled@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Compute@@ Task@@ Cancelled@@ Exception ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Ignite@@ Tx@@ Rollback@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Transaction@@ Rollback@@ Exception ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Ignite@@ Tx@@ Heur@@ istic@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Transaction@@ Heur@@ istic@@ Exception ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Ignite@@ Tx@@ Timeout@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Transaction@@ TimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Ignite@@ Tx@@ Optim@@ istic@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Transaction@@ Optim@@ istic@@ Exception ( e . getMessage ( ) , e ) ; } } ) ; m . put ( Ignite@@ Client@@ Dis@@ connected@@ CheckedException . class , new C1 < IgniteCheckedException , Ignite@@ Exception > ( ) { @ Override public Ignite@@ Exception apply ( IgniteCheckedException e ) { return new Ignite@@ Client@@ Dis@@ connec@@ tedException ( ( ( Ignite@@ Client@@ Dis@@ connected@@ CheckedException ) e ) . re@@ connect@@ Future ( ) , e . getMessage ( ) , e ) ; } } ) ; return m ; }
 public static boolean is@@ Windows@@ X@@ p ( ) { return win@@ X@@ p ; }
 ) public static boolean containsAll ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) if ( base . containsKey ( entry . getKey ( ) ) ) { Object val = base . get ( entry . getKey ( ) ) ; if ( val == null && entry . getValue ( ) == null ) continue ; if ( val == null || entry . getValue ( ) == null || ! val . equals ( entry . getValue ( ) ) ) return false ; } else return false ; return true ; }
 @ AfterClass public static void tearDown ( ) throws SQLException { System . out . println ( " = = = = ▁ Clean@@ ing ▁ in@@ memory ▁ db ▁ = = = = " ) ; Run@@ Script . execute ( JDB@@ C_@@ URL , " sa " , " sa " , " classpath : cz / ke@@ c / of / ansible / dao / clear@@ Db . sql " , Charset . forName ( " UTF - 8" ) , false ) ; }
 public static void start@@ Threads ( Iterable < ? extends Thread > threads ) { if ( threads != null ) { for ( Thread thread : threads ) { if ( thread != null ) thread . start ( ) ; } } }
 private static long to@@ Address ( long addr@@ And@@ Len ) { return addr@@ And@@ Len >@@ >> SIZE_@@ BITS ; }
 public static int jvm@@ Pid ( ) { String name = Management@@ Factory . getRuntime@@ MXBean ( ) . getName ( ) ; try { int idx = name . indexOf ( ' @ ' ) ; return idx > 0 ? Integer . parseInt ( name . substring ( 0 , idx ) ) : - 1 ; } catch ( NumberFormatException ignored ) { return - 1 ; } }
 public static < T extends R , R > List < R > array@@ List ( Collection < T > c ) { assert c != null ; return new ArrayList < R > ( c ) ; }
 public static double bytesTo@@ Double ( byte [ ] bytes , int off ) { return Double . long@@ BitsTo@@ Double ( bytesTo@@ Long ( bytes , off ) ) ; }
 public static void close ( @ Nullable Selection@@ Key rsrc , @ Nullable Ignite@@ Logger log ) { if ( rsrc != null ) close ( rsrc . channel ( ) , log ) ; }
 public static String j@@ re@@ Version ( ) { return java@@ Rt@@ Ver ; }
 public static void set@@ Work@@ Directory ( @ Nullable String user@@ Work@@ Dir , @ Nullable String user@@ Ignite@@ Home ) throws IgniteCheckedException { String ignite@@ Work@@ 0 = ignite@@ Work ; if ( ignite@@ Work@@ 0 == null ) { synchronized ( Ignite@@ Utils . class ) { ignite@@ Work@@ 0 = ignite@@ Work ; if ( ignite@@ Work@@ 0 != null ) return ; File work@@ Dir ; if ( ! F . isEmpty ( user@@ Work@@ Dir ) ) work@@ Dir = new File ( user@@ Work@@ Dir ) ; else if ( ! F . isEmpty ( IGN@@ ITE_@@ WORK_@@ DIR ) ) work@@ Dir = new File ( IGN@@ ITE_@@ WORK_@@ DIR ) ; else if ( ! F . isEmpty ( user@@ Ignite@@ Home ) ) work@@ Dir = new File ( user@@ Ignite@@ Home , " work " ) ; else { String tmp@@ DirPath = System . getProperty ( " java . io . tmpdir " ) ; if ( tmp@@ DirPath == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ work ▁ directory ▁ in ▁ OS ▁ temp ▁ " + " ( property ▁ ' java . io . tmpdir ' ▁ is ▁ null ) . " ) ; work@@ Dir = new File ( tmp@@ DirPath , " ignite " + File . separator + " work " ) ; } if ( ! work@@ Dir . is@@ Absolute ( ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ path ▁ must ▁ be ▁ absolute : ▁ " + work@@ Dir ) ; if ( ! mkdirs ( work@@ Dir ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + work@@ Dir ) ; if ( ! work@@ Dir . can@@ Read ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ work ▁ directory : ▁ " + work@@ Dir ) ; if ( ! work@@ Dir . can@@ Write ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ work ▁ directory : ▁ " + work@@ Dir ) ; ignite@@ Work = work@@ Dir . getAbsolutePath ( ) ; } } }
 public static Class < ? > detect@@ Class ( Object obj ) { assert obj != null ; if ( obj instanceof Grid@@ Peer@@ Deploy@@ Aware ) return ( ( Grid@@ Peer@@ Deploy@@ Aware ) obj ) . deploy@@ Class ( ) ; if ( U . is@@ Primitive@@ Array ( obj ) ) return obj . getClass ( ) ; if ( ! U . is@@ J@@ dk ( obj . getClass ( ) ) ) return obj . getClass ( ) ; if ( obj instanceof Iterable < ? > ) { Object o = F . first ( ( Iterable < ? > ) obj ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } if ( obj instanceof Map ) { Map . Entry < ? , ? > e = F . first@@ Entry ( ( Map < ? , ? > ) obj ) ; if ( e != null ) { Object k = e . getKey ( ) ; if ( k != null && ! U . is@@ J@@ dk ( k . getClass ( ) ) ) return k . getClass ( ) ; Object v = e . getValue ( ) ; return v != null ? v . getClass ( ) : obj . getClass ( ) ; } } if ( obj . getClass ( ) . isArray ( ) ) { int len = Array . getLength ( obj ) ; if ( len > 0 ) { Object o = Array . get ( obj , 0 ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } else return obj . getClass ( ) . getComponentType ( ) ; } return obj . getClass ( ) ; }
 @ Nullable public static Ignite@@ Uuid read@@ Grid@@ Uuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; UUID global@@ Id = Ignite@@ Uuid@@ Cache . on@@ Ignite@@ Uuid@@ Read ( new UUID ( most , least ) ) ; long loc@@ Id = in . readLong ( ) ; return new Ignite@@ Uuid ( global@@ Id , loc@@ Id ) ; } return null ; }
 public static Thread@@ MXBean getThread@@ M@@ x ( ) { return Management@@ Factory . getThread@@ MXBean ( ) ; }
 public static int int@@ To@@ Bytes ( int i , byte [ ] bytes , int off ) { return off + Grid@@ Client@@ Byte@@ Utils . int@@ To@@ Bytes ( i , bytes , off ) ; }
 private static void addresses ( InetAddress addr , Collection < String > addrs , Collection < String > host@@ Names ) { String hostName = addr . getHostName ( ) ; String ip@@ Addr = addr . getHost@@ Address ( ) ; addrs . add ( ip@@ Addr ) ; if ( ! F . isEmpty ( hostName ) && ! addr . is@@ Loop@@ back@@ Address ( ) ) host@@ Names . add ( hostName ) ; }
 public static < T > Iterable < T > random@@ Iterable ( Collection < T > col ) { List < T > list = new ArrayList < > ( col ) ; Collections . shuffle ( list ) ; return list ; }
 static private void add ( Data@@ Stream@@ Marshaller ds@@ m ) { marshaller [ ds@@ m . getData@@ Structure@@ Type ( ) ] = ds@@ m ; }
 ) @ Nullable public static Map < Integer , Integer > read@@ Int@@ Key@@ Int@@ ValueMap ( DataInput in ) throws IOException { Map < Integer , Integer > map = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; map = new HashMap < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( in . readInt ( ) , in . readInt ( ) ) ; } return map ; }
 public static DataStream < Tuple@@ 5 < Integer , Long , Integer , String , Long > > get@@ 5@@ Tuple@@ DataStream ( Stream@@ ExecutionEnvironment env ) { List < Tuple@@ 5 < Integer , Long , Integer , String , Long > > data = new ArrayList < > ( ) ; data . add ( new Tuple@@ 5 < > ( 1 , 1L , 0 , " H@@ all@@ o " , 1L ) ) ; data . add ( new Tuple@@ 5 < > ( 2 , 2L , 1 , " H@@ all@@ o ▁ W@@ elt " , 2L ) ) ; data . add ( new Tuple@@ 5 < > ( 2 , 3L , 2 , " H@@ all@@ o ▁ W@@ elt ▁ wi@@ e " , 1L ) ) ; data . add ( new Tuple@@ 5 < > ( 3 , 4L , 3 , " H@@ all@@ o ▁ W@@ elt ▁ wi@@ e ▁ ge@@ h@@ ts ? " , 2L ) ) ; data . add ( new Tuple@@ 5 < > ( 3 , 5L , 4 , " ABC " , 2L ) ) ; data . add ( new Tuple@@ 5 < > ( 3 , 6L , 5 , " BC@@ D " , 3L ) ) ; data . add ( new Tuple@@ 5 < > ( 4 , 7L , 6 , " C@@ DE " , 2L ) ) ; data . add ( new Tuple@@ 5 < > ( 4 , 8L , 7 , " DEF " , 1L ) ) ; data . add ( new Tuple@@ 5 < > ( 4 , 9@@ L , 8 , " EF@@ G " , 1L ) ) ; data . add ( new Tuple@@ 5 < > ( 4 , 10L , 9 , " F@@ GH " , 2L ) ) ; data . add ( new Tuple@@ 5 < > ( 5 , 11@@ L , 10 , " GH@@ I " , 1L ) ) ; data . add ( new Tuple@@ 5 < > ( 5 , 12@@ L , 11 , " HI@@ J " , 3L ) ) ; data . add ( new Tuple@@ 5 < > ( 5 , 13@@ L , 12 , " I@@ JK " , 3L ) ) ; data . add ( new Tuple@@ 5 < > ( 5 , 15@@ L , 14 , " K@@ LM " , 2L ) ) ; data . add ( new Tuple@@ 5 < > ( 5 , 14@@ L , 13 , " JK@@ L " , 2L ) ) ; return env . from@@ Collection ( data ) ; }
 @ Nullable public static int [ ] read@@ IntArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; int [ ] res = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readInt ( ) ; return res ; }
 public static String filler ( int len , char ch ) { char [ ] a = new char [ len ] ; Arrays . fill ( a , ch ) ; return new String ( a ) ; }
 public static void write@@ StringTo@@ File ( File file , String s , String charset ) throws IOException { write@@ StringTo@@ File ( file , s , charset , false ) ; }
 ) private static byte hex@@ CharTo@@ Byte ( char ch ) throws IllegalArgumentException { switch ( ch ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : return ( byte ) ( ch - '0' ) ; case ' a ' : case ' A ' : return 0xa ; case ' b ' : case ' B ' : return 0x@@ b ; case ' c ' : case ' C ' : return 0x@@ c ; case ' d ' : case ' D ' : return 0x@@ d ; case ' e ' : case ' E ' : return 0x@@ e ; case ' f ' : case ' F ' : return 0xf ; default : throw new IllegalArgumentException ( " Hex ▁ decoding ▁ wrong ▁ input ▁ character ▁ [ character = " + ch + ' ] ' ) ; } }
 @ Deprecated public static void debug@@ Stack ( Ignite@@ Logger log , String msg ) { log . error ( msg , new Exception ( debug@@ Prefix ( ) + msg ) ) ; }
 @ Nullable public static List < Byte > read@@ Byte@@ List ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Byte > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readByte ( ) ) ; return col ; }
 public static void await ( CountDownLatch latch ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { if ( latch . getCount ( ) > 0 ) latch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static String jdk@@ String ( ) { return jdk@@ Str ; }
 public static void warn ( @ Nullable Ignite@@ Logger log , Object long@@ Msg , Object short@@ Msg ) { assert long@@ Msg != null ; assert short@@ Msg != null ; if ( log != null ) log . warning ( compact ( long@@ Msg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_@@ DATE_@@ FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( wr@@ n ) ▁ " + compact ( short@@ Msg . toString ( ) ) ) ; }
 public static void write@@ Byte@@ Collection ( DataOutput out , Collection < Byte > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Byte i : col ) out . writeByte ( i ) ; } else out . writeInt ( - 1 ) ; }
 private static String cap@@ ital@@ First ( @ Nullable String str ) { return str == null ? null : str . isEmpty ( ) ? " " : Character . toUpperCase ( str . charAt ( 0 ) ) + str . substring ( 1 ) ; }
 public static < T > LinkedHashSet < T > new@@ LinkedHashSet ( int exp@@ Size ) { return new LinkedHashSet < > ( capacity ( exp@@ Size ) ) ; }
 public static synchronized < T > ListType < T > getInstance ( AbstractType < T > elements , boolean isMulti@@ Cell ) { Map < AbstractType < ? > , ListType > intern@@ Map = isMulti@@ Cell ? instances : frozen@@ Instances ; ListType < T > t = intern@@ Map . get ( elements ) ; if ( t == null ) { t = new ListType < T > ( elements , isMulti@@ Cell ) ; intern@@ Map . put ( elements , t ) ; } return t ; }
 public static Texture@@ Container < Texture@@ Region > produce ( final Texture texture , final Context context , final String asset@@ Path , final int texture@@ Position@@ X , final int texture@@ Position@@ Y ) { return new Texture@@ Container < Texture@@ Region > ( Texture@@ Region@@ Factory . createFrom@@ Asset ( texture , context , asset@@ Path , texture@@ Position@@ X , texture@@ Position@@ Y ) , get@@ Pixels ( asset@@ Path , context , 1 , 1 ) , asset@@ Path ) ; }
 @ NonNull public static < T > ReadOnly@@ Property < T > create ( @ NonNull Observable < T > observable ) { return new ReadOnly@@ Property < > ( observable ) ; }
 public static Exception unwrap ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof Grid@@ Closure@@ Exception ) { t = ( ( Grid@@ Closure@@ Exception ) t ) . unwrap ( ) ; continue ; } return ( Exception ) t ; } }
 public static InetAddress resolve@@ LocalHost ( @ Nullable String hostName ) throws IOException { return F . isEmpty ( hostName ) ? new InetSocketAddress ( 0 ) . getAddress ( ) : InetAddress . getByName ( hostName ) ; }
 public static C1 < IgniteCheckedException , Ignite@@ Exception > getException@@ Converter ( Class < ? extends IgniteCheckedException > clazz ) { return exception@@ Converters . get ( clazz ) ; }
 public static Collection < UUID > grid@@ Ids ( @ Nullable Collection < ? extends Ignite > grids ) { return F . view@@ ReadOnly ( grids , new C1 < Ignite , UUID > ( ) { @ Override public UUID apply ( Ignite g ) { return g . cluster ( ) . local@@ Node ( ) . id ( ) ; } } ) ; }
 @ Nullable public static Set < Integer > read@@ Int@@ Set ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Set < Integer > set = new HashSet < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) set . add ( in . readInt ( ) ) ; return set ; }
 public static Collector < JsonValue , Json@@ Array@@ Builder , JsonArray > to@@ JsonArray ( ) { return null ; }
 public static void interrupt ( Iterable < ? extends Thread > workers ) { if ( workers != null ) for ( Thread worker : workers ) worker . interrupt ( ) ; }
 @ Nullable private static Grid@@ Peer@@ Deploy@@ Aware nested@@ Peer@@ Deploy@@ Aware ( Object obj , boolean top , Set < Object > processed ) { if ( ! processed . add ( obj ) ) return null ; if ( obj instanceof Grid@@ Peer@@ Deploy@@ Aware ) { Grid@@ Peer@@ Deploy@@ Aware p = ( Grid@@ Peer@@ Deploy@@ Aware ) obj ; if ( ! top && p . deploy@@ Class ( ) != null ) return p ; for ( Class < ? > cls = obj . getClass ( ) ; ! cls . equals ( Object . class ) ; cls = cls . getSuper@@ class ( ) ) { Ignite@@ Bi@@ Tuple < Class < ? > , Collection < Field > > tup = p2@@ p@@ Fields . get ( cls . getName ( ) ) ; boolean cached = tup != null && tup . get@@ 1 ( ) . equals ( cls ) ; Iterable < Field > fields = cached ? tup . get@@ 2 ( ) : Arrays . asList ( cls . getDeclared@@ Fields ( ) ) ; if ( ! cached ) { tup = F . t2 ( ) ; tup . set1 ( cls ) ; } for ( Field f : fields ) if ( cached || f . getName ( ) . startsWith ( " this $ " ) || f . getName ( ) . startsWith ( " val $ " ) ) { if ( ! cached ) { f . setAccessible ( true ) ; if ( tup . get@@ 2 ( ) == null ) tup . set2 ( new LinkedList < Field > ( ) ) ; tup . get@@ 2 ( ) . add ( f ) ; } try { Object o = f . get ( obj ) ; if ( o != null ) { p = nested@@ Peer@@ Deploy@@ Aware ( o , false , processed ) ; if ( p != null ) { if ( ! cached ) p2@@ p@@ Fields . put ( cls . getName ( ) , tup ) ; return p ; } } } catch ( IllegalAccessException ignored ) { return null ; } } } } else if ( is@@ Ignite ( obj . getClass ( ) ) ) return null ; else if ( obj instanceof Iterable ) for ( Object o : ( Iterable < ? > ) obj ) { Grid@@ Peer@@ Deploy@@ Aware p = nested@@ Peer@@ Deploy@@ Aware ( o , false , processed ) ; if ( p != null ) return p ; } else if ( obj . getClass ( ) . isArray ( ) ) { Class < ? > type = obj . getClass ( ) . getComponentType ( ) ; if ( ! type . is@@ Primitive ( ) && ! is@@ J@@ dk ( type ) ) { Object [ ] arr = ( Object [ ] ) obj ; for ( Object o : arr ) { Grid@@ Peer@@ Deploy@@ Aware p = nested@@ Peer@@ Deploy@@ Aware ( o , false , processed ) ; if ( p != null ) return p ; } } } return null ; }
 public static Collection < InetSocketAddress > to@@ Socket@@ Addresses ( Collection < String > addrs , Collection < String > host@@ Names , int port ) { List < InetSocketAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > host@@ Names@@ It = host@@ Names . iterator ( ) ; for ( String addr : addrs ) { String hostName = host@@ Names@@ It . hasNext ( ) ? host@@ Names@@ It . next ( ) : null ; if ( ! F . isEmpty ( hostName ) ) { InetSocketAddress inet@@ Sock@@ Addr = new InetSocketAddress ( hostName , port ) ; if ( inet@@ Sock@@ Addr . isUn@@ resolved ( ) || inet@@ Sock@@ Addr . getAddress ( ) . is@@ Loop@@ back@@ Address ( ) ) inet@@ Sock@@ Addr = new InetSocketAddress ( addr , port ) ; res . add ( inet@@ Sock@@ Addr ) ; } res . add ( new InetSocketAddress ( addr , port ) ) ; } return F . view@@ List@@ ReadOnly ( res , F . < InetSocketAddress > identity ( ) ) ; }
 public static < T > T property ( Object obj , String propName ) { assert obj != null ; assert propName != null ; try { Method m ; try { m = obj . getClass ( ) . getMethod ( " get " + cap@@ ital@@ First ( propName ) ) ; } catch ( NoSuchMethodException ignored ) { m = obj . getClass ( ) . getMethod ( " is " + cap@@ ital@@ First ( propName ) ) ; } assert F . isEmpty ( m . getParameterTypes ( ) ) ; boolean accessible = m . is@@ Accessible ( ) ; try { m . setAccessible ( true ) ; return ( T ) m . invoke ( obj ) ; } finally { m . setAccessible ( accessible ) ; } } catch ( Exception e ) { throw new Ignite@@ Exception ( " Failed ▁ to ▁ get ▁ property ▁ value ▁ [ property = " + propName + " , ▁ obj = " + obj + ' ] ' , e ) ; } }
 public static Grid@@ Peer@@ Deploy@@ Aware peer@@ Deploy@@ Aware ( Object obj ) { assert obj != null ; if ( obj instanceof Grid@@ Peer@@ Deploy@@ Aware ) return ( Grid@@ Peer@@ Deploy@@ Aware ) obj ; final Class < ? > cls = obj instanceof Class ? ( Class ) obj : obj . getClass ( ) ; return new Grid@@ Peer@@ Deploy@@ Aware ( ) { private ClassLoader ldr ; @ Override public Class < ? > deploy@@ Class ( ) { return cls ; } @ Override public ClassLoader classLoader ( ) { if ( ldr == null ) ldr = detect@@ ClassLoader ( cls ) ; return ldr ; } } ; }
 public static String j@@ re@@ Name ( ) { return java@@ Rt@@ Name ; }
 public static HT@@ Package init ( ) { if ( isIn@@ ited ) return ( HT@@ Package ) E@@ Package . Registry . INSTANCE . getE@@ Package ( HT@@ Package . e@@ NS_@@ URI ) ; HT@@ Package@@ Impl the@@ HT@@ Package = ( HT@@ Package@@ Impl ) ( E@@ Package . Registry . INSTANCE . get ( e@@ NS_@@ URI ) instanceof HT@@ Package@@ Impl ? E@@ Package . Registry . INSTANCE . get ( e@@ NS_@@ URI ) : new HT@@ Package@@ Impl ( ) ) ; isIn@@ ited = true ; XML@@ Namespace@@ Package . eINSTANCE . e@@ Class ( ) ; XML@@ Type@@ Package . eINSTANCE . e@@ Class ( ) ; the@@ HT@@ Package . create@@ Package@@ Contents ( ) ; the@@ HT@@ Package . initialize@@ Package@@ Contents ( ) ; the@@ HT@@ Package . freeze ( ) ; E@@ Package . Registry . INSTANCE . put ( HT@@ Package . e@@ NS_@@ URI , the@@ HT@@ Package ) ; return the@@ HT@@ Package ; }
 public static boolean is@@ Sol@@ ar@@ is@@ X86 ( ) { return sol@@ aris && x86 ; }
 @ Nullable public static < T > T newInstance ( String cls ) throws IgniteCheckedException { Class < ? > cl@@ s0 ; try { cl@@ s0 = Class . forName ( cls ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } return ( T ) newInstance ( cl@@ s0 ) ; }
 public static boolean is@@ Primitive@@ Or@@ Wrapper ( Class < ? > cls ) { return cls . is@@ Primitive ( ) || Boolean . class . equals ( cls ) || Byte . class . equals ( cls ) || Character . class . equals ( cls ) || Short . class . equals ( cls ) || Integer . class . equals ( cls ) || Long . class . equals ( cls ) || Float . class . equals ( cls ) || Double . class . equals ( cls ) || Void . class . equals ( cls ) ; }
 private static boolean unsafe@@ ByteArray@@ Copy@@ Available ( ) { try { Class < ? extends Unsafe > unsafe@@ Cls = UNSAFE . getClass ( ) ; unsafe@@ Cls . getMethod ( " copy@@ Memory " , Object . class , long . class , Object . class , long . class , long . class ) ; return true ; } catch ( Exception ignored ) { return false ; } }
 public static String os@@ String ( ) { return os@@ Str ; }
 public static void close@@ Qu@@ i@@ et ( @ Nullable Auto@@ Closeable rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception ignored ) { } }
 ) @ Nullable public static < T > T force@@ New@@ Instance ( Class < ? > cls ) throws IgniteCheckedException { Constructor ctor = force@@ Empty@@ Constructor ( cls ) ; if ( ctor == null ) return null ; boolean set = false ; try { if ( ! ctor . is@@ Accessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ( T ) ctor . newInstance ( ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( set ) ctor . setAccessible ( false ) ; } }
 public static < T > T field ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Class c = cls ; cls != Object . class ; cls = cls . getSuper@@ class ( ) ) { for ( Field field : c . getDeclared@@ Fields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ class ▁ field ▁ ( field ▁ is ▁ not ▁ static ) ▁ [ cls = " + cls + " , ▁ fieldName = " + fieldName + ' ] ' ) ; boolean accessible = field . is@@ Accessible ( ) ; T val ; try { field . setAccessible ( true ) ; val = ( T ) field . get ( null ) ; } finally { if ( ! accessible ) field . setAccessible ( false ) ; } return val ; } } } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ ( field ▁ was ▁ not ▁ found ) ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
 ) public static void wait ( Object mux ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { mux . wait ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 @ Nullable public static < T extends Annotation > T getAnnotation ( Class < ? > cls , Class < T > ann@@ Cls ) { if ( cls == Object . class ) return null ; T ann = cls . getAnnotation ( ann@@ Cls ) ; if ( ann != null ) return ann ; for ( Class < ? > it@@ f : cls . get@@ Interfaces ( ) ) { ann = getAnnotation ( it@@ f , ann@@ Cls ) ; if ( ann != null ) return ann ; } if ( ! cls . isInterface ( ) ) { ann = getAnnotation ( cls . getSuper@@ class ( ) , ann@@ Cls ) ; if ( ann != null ) return ann ; } return null ; }
 public static Collection < String > node@@ s2@@ names ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . view@@ ReadOnly ( nodes , new C1 < ClusterNode , String > ( ) { @ Override public String apply ( ClusterNode n ) { return G . ignite ( n . id ( ) ) . name ( ) ; } } ) ; }
 @ Deprecated public static void debug ( Object msg ) { X . error ( debug@@ Prefix ( ) + msg ) ; }
 public static boolean is@@ Po@@ w2 ( int i ) { return i > 0 && ( i & ( i - 1 ) ) == 0 ; }
 public static < T extends Annotation > boolean has@@ Annotation ( Object o , Class < T > ann@@ Cls ) { return o != null && has@@ Annotation ( o . getClass ( ) , ann@@ Cls ) ; }
 public static String normalize@@ PackageName ( String packageName ) { if ( is@@ EmptyString ( packageName ) || ! packageName . endsWith ( " . " ) ) { return packageName ; } else { return packageName . substring ( 0 , packageName . length ( ) - 1 ) ; } }
 public static void reload@@ Changes ( ChangeSet cs ) throws Or@@ m@@ Exception { for ( Change@@ Data cd : cs . changes ( ) ) { cd . reload@@ Change ( ) ; cd . set@@ Patch@@ Sets ( null ) ; } }
 static int compare@@ List@@ Or@@ Set ( AbstractType < ? > element@@ s@@ Comparator , ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . has@@ Remaining ( ) || ! o2 . has@@ Remaining ( ) ) return o1 . has@@ Remaining ( ) ? 1 : o2 . has@@ Remaining ( ) ? - 1 : 0 ; ByteBuffer bb@@ 1 = o1 . duplicate ( ) ; ByteBuffer bb@@ 2 = o2 . duplicate ( ) ; int size1 = Collection@@ Serializer . read@@ CollectionSize ( bb@@ 1 , 3 ) ; int size2 = Collection@@ Serializer . read@@ CollectionSize ( bb@@ 2 , 3 ) ; for ( int i = 0 ; i < Math . min ( size1 , size2 ) ; i ++ ) { ByteBuffer v1 = Collection@@ Serializer . readValue ( bb@@ 1 , 3 ) ; ByteBuffer v2 = Collection@@ Serializer . readValue ( bb@@ 2 , 3 ) ; int cmp = element@@ s@@ Comparator . compare ( v1 , v2 ) ; if ( cmp != 0 ) return cmp ; } return size1 == size2 ? 0 : ( size1 < size2 ? - 1 : 1 ) ; }
 private static synchronized InetAddress reset@@ LocalHost ( ) throws IOException { loc@@ Host = null ; String sys@@ Loc@@ Host = Ignite@@ SystemProperties . getString ( IGN@@ ITE_@@ LOCAL_@@ HOST ) ; if ( sys@@ Loc@@ Host != null ) sys@@ Loc@@ Host = sys@@ Loc@@ Host . trim ( ) ; if ( ! F . isEmpty ( sys@@ Loc@@ Host ) ) loc@@ Host = InetAddress . getByName ( sys@@ Loc@@ Host ) ; else { List < NetworkInterface > it@@ fs = new ArrayList < > ( ) ; for ( NetworkInterface it@@ f : as@@ Iterable ( NetworkInterface . getNetwork@@ Interfaces ( ) ) ) it@@ fs . add ( it@@ f ) ; Collections . sort ( it@@ fs , new Comparator < NetworkInterface > ( ) { @ Override public int compare ( NetworkInterface it@@ f1 , NetworkInterface it@@ f2 ) { return it@@ f1 . getName ( ) . compareTo ( it@@ f2 . getName ( ) ) ; } } ) ; int reach@@ Timeout = 2000 ; for ( NetworkInterface it@@ f : it@@ fs ) { boolean found = false ; for ( InetAddress addr : as@@ Iterable ( it@@ f . get@@ Inet@@ Addresses ( ) ) ) { if ( ! addr . is@@ Loop@@ back@@ Address ( ) && ! addr . is@@ Link@@ Local@@ Address ( ) && reachable ( it@@ f , addr , reach@@ Timeout ) ) { loc@@ Host = addr ; found = true ; break ; } } if ( found ) break ; } } if ( loc@@ Host == null ) loc@@ Host = InetAddress . getLocal@@ Host ( ) ; return loc@@ Host ; }
 public static List < Long > to@@ Long@@ List ( @ Nullable long [ ] arr ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Long > ret = new ArrayList < > ( arr . length ) ; for ( long l : arr ) ret . add ( l ) ; return ret ; }
 public static void write@@ UTF@@ String@@ Nullable ( DataOutput out , @ Nullable String val ) throws IOException { if ( val != null ) { out . writeBoolean ( true ) ; out . write@@ UTF ( val ) ; } else out . writeBoolean ( false ) ; }
 public static String getFile@@ Contents ( String filePath ) throws IOException { FileInputStream file@@ InStream = new FileInputStream ( filePath ) ; return read@@ Content ( file@@ InStream ) ; }
 public static Ignite@@ Exception convert@@ Exception ( IgniteCheckedException e ) { Ignite@@ Client@@ Dis@@ connec@@ tedException e0 = e . getCause ( Ignite@@ Client@@ Dis@@ connec@@ tedException . class ) ; if ( e0 != null ) { assert e0 . re@@ connect@@ Future ( ) != null : e0 ; throw e0 ; } Ignite@@ Client@@ Dis@@ connected@@ CheckedException dis@@ connected@@ Err = e . getCause ( Ignite@@ Client@@ Dis@@ connected@@ CheckedException . class ) ; if ( dis@@ connected@@ Err != null ) { assert dis@@ connected@@ Err . re@@ connect@@ Future ( ) != null : dis@@ connected@@ Err ; e = dis@@ connected@@ Err ; } C1 < IgniteCheckedException , Ignite@@ Exception > converter = exception@@ Converters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof Ignite@@ Exception ) return ( Ignite@@ Exception ) e . getCause ( ) ; return new Ignite@@ Exception ( e . getMessage ( ) , e ) ; }
 public static long write@@ Version ( byte [ ] arr , long off , GridCache@@ Version ver ) { boolean ver@@ Ex = ver instanceof GridCache@@ Version@@ Ex ; UNSAFE . putBoolean ( arr , off ++ , ver@@ Ex ) ; if ( ver@@ Ex ) { GridCache@@ Version dr@@ Ver = ver . conflic@@ t@@ Version ( ) ; assert dr@@ Ver != null ; UNSAFE . putInt ( arr , off , dr@@ Ver . topology@@ Version ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , dr@@ Ver . node@@ Order@@ And@@ Dr@@ Id@@ Raw ( ) ) ; off += 4 ; UNSAFE . put@@ Long ( arr , off , dr@@ Ver . global@@ Time ( ) ) ; off += 8 ; UNSAFE . put@@ Long ( arr , off , dr@@ Ver . order ( ) ) ; off += 8 ; } UNSAFE . putInt ( arr , off , ver . topology@@ Version ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , ver . node@@ Order@@ And@@ Dr@@ Id@@ Raw ( ) ) ; off += 4 ; UNSAFE . put@@ Long ( arr , off , ver . global@@ Time ( ) ) ; off += 8 ; UNSAFE . put@@ Long ( arr , off , ver . order ( ) ) ; off += 8 ; return off ; }
 public static long bytesTo@@ Long ( byte [ ] bytes , int off ) { assert bytes != null ; int bytes@@ Cnt = Long . SIZE >> 3 ; if ( off + bytes@@ Cnt > bytes . length ) bytes@@ Cnt = bytes . length - off ; long res = 0 ; for ( int i = 0 ; i < bytes@@ Cnt ; i ++ ) { int shift = bytes@@ Cnt - i - 1 << 3 ; res |= ( 0xff@@ L & bytes [ off ++ ] ) << shift ; } return res ; }
 public static void run ( File dir , File props ) { new Msg@@ Class@@ Generator ( ) . generate ( dir , props ) ; }
 public static int short@@ To@@ Bytes ( short s , byte [ ] bytes , int off ) { return off + Grid@@ Client@@ Byte@@ Utils . short@@ To@@ Bytes ( s , bytes , off ) ; }
 public static void await@@ Qu@@ i@@ et ( Cyclic@@ Barrier barrier ) { boolean interrupted = false ; while ( true ) { try { barrier . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } catch ( Broken@@ Barrier@@ Exception ignored ) { break ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
 public static void register@@ All@@ Extensions ( com . google . protobuf . Extension@@ Registry registry ) { }
 public static void write@@ Collection ( ObjectOutput out , Collection < ? > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Object o : col ) out . writeObject ( o ) ; } else out . writeInt ( - 1 ) ; }
 private static Bitmap get@@ Bitmap ( final String asset@@ Path , final Context context ) { InputStream stream = null ; Bitmap bitmap = null ; try { stream = context . getAs@@ sets ( ) . open ( Hal@@ lig@@ ator@@ Activity . GRAP@@ HI@@ C_@@ ASSE@@ TS_@@ PATH + asset@@ Path ) ; bitmap = BitmapFactory . decode@@ Stream ( stream ) ; } catch ( IOException e ) { Log . e ( " Texture@@ Container@@ Provider " , " Exception " , e ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { Log . e ( " Texture@@ Container@@ Provider " , " Exception " , e ) ; } } return bitmap ; }
 @ Nullable public static Method c@@ tor@@ Factory ( ) { return C@@ TOR_@@ FACTORY ; }
 public static ObjectName make@@ MBean@@ Name ( @ Nullable String grid@@ Name , @ Nullable String grp , String name ) throws Malformed@@ Object@@ NameException { SB sb = new SB ( JM@@ X_@@ DOMAIN + ' : ' ) ; append@@ ClassLoader@@ Hash ( sb ) ; append@@ Jvm@@ Id ( sb ) ; if ( grid@@ Name != null && ! grid@@ Name . isEmpty ( ) ) sb . a ( " grid = " ) . a ( grid@@ Name ) . a ( ' , ' ) ; if ( grp != null ) sb . a ( " group = " ) . a ( grp ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
 public static boolean is@@ Windows@@ 8 ( ) { return win@@ 8 ; }
 public static void closeQuietly ( XML@@ StreamWriter writer ) { if ( writer == null ) { return ; } try { writer . close ( ) ; } catch ( XMLStreamException ignore ) { } }
 public static String gen@@ Dest@@ FolderPath ( String dest@@ Loc , String serviceName , String suffix@@ Path ) { StringBuilder dest@@ FolderPath = new StringBuilder ( ) ; dest@@ FolderPath . append ( to@@ OS@@ FilePath ( dest@@ Loc ) ) ; dest@@ FolderPath . append ( to@@ OS@@ FilePath ( suffix@@ Path ) ) ; dest@@ FolderPath . append ( serviceName ) ; return dest@@ FolderPath . toString ( ) ; }
 public static void shutdown@@ Now ( Class < ? > owner , @ Nullable ExecutorService exec , @ Nullable Ignite@@ Logger log ) { if ( exec != null ) { List < Runnable > tasks = exec . shutdown@@ Now ( ) ; if ( ! F . isEmpty ( tasks ) ) U . warn ( log , " Runnable ▁ tasks ▁ out@@ li@@ ved ▁ thread ▁ pool ▁ executor ▁ service ▁ [ owner = " + getSimpleName ( owner ) + " , ▁ tasks = " + tasks + ' ] ' ) ; try { exec . await@@ Termination ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ignored ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ executor ▁ service ▁ to ▁ stop . " ) ; exec . shutdown@@ Now ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } } }
 public static String make@@ First@@ Letter@@ Lower ( String str ) { if ( is@@ EmptyString ( str ) ) { return str ; } char first@@ Char = str . charAt ( 0 ) ; if ( Character . is@@ Letter ( first@@ Char ) && Character . is@@ UpperCase ( first@@ Char ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toLowerCase ( first@@ Char ) ; return String . valueOf ( chars ) ; } else { return str ; } }
 public static void quiet ( boolean err , Object ... objs ) { assert objs != null ; String time = SHORT_@@ DATE_@@ FMT . format ( new java . util . Date ( ) ) ; SB sb = new SB ( ) ; for ( Object obj : objs ) sb . a ( ' [ ' ) . a ( time ) . a ( " ] ▁ " ) . a ( obj . toString ( ) ) . a ( NL ) ; PrintStream ps = err ? System . err : System . out ; ps . print ( compact ( sb . toString ( ) ) ) ; }
 public static void warn ( @ Nullable Ignite@@ Logger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; warn ( log , s , s ) ; }
 public static < K , V , M extends Map < K , V > > M addAll ( M m , Ignite@@ Bi@@ Tuple < K , V > ... entries ) { for ( Ignite@@ Bi@@ Tuple < K , V > t : entries ) m . put ( t . get@@ 1 ( ) , t . get@@ 2 ( ) ) ; return m ; }
 public static IgniteCheckedException cast ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof Grid@@ Closure@@ Exception ) { t = ( ( Grid@@ Closure@@ Exception ) t ) . unwrap ( ) ; continue ; } if ( t instanceof IgniteCheckedException ) return ( IgniteCheckedException ) t ; if ( ! ( t instanceof Ignite@@ Exception ) || t . getCause ( ) == null ) return new IgniteCheckedException ( t ) ; assert t . getCause ( ) != null ; t = t . getCause ( ) ; } }
 public static void await@@ Qu@@ i@@ et ( CountDownLatch latch ) { boolean interrupted = false ; while ( true ) { try { latch . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
 public static String jdk@@ Name ( ) { return jdk@@ Name ; }
 public static final Safe@@ Implicit@@ Output@@ s@@ Function ANDROID_@@ LIBR@@ ARY_@@ IMPLICIT_@@ OUTPUT@@ S = new Safe@@ Implicit@@ Output@@ s@@ Function ( ) { @ Override public Iterable < String > get@@ Implicit@@ Outputs ( EventHandler eventHandler , Attribute@@ Map attributes ) { ImmutableList . Builder < Safe@@ Implicit@@ Output@@ s@@ Function > implicit@@ Outputs = ImmutableList . builder ( ) ; implicit@@ Outputs . add ( Android@@ Rule@@ Classes . ANDROID_@@ LIBR@@ ARY_@@ class_@@ JAR , Android@@ Rule@@ Classes . ANDROID_@@ LIBR@@ AR@@ Y@@ _SOURCE_@@ JAR , Android@@ Rule@@ Classes . ANDROID_@@ LIBR@@ ARY_@@ A@@ AR ) ; if ( Android@@ Resources . defin@@ es@@ Android@@ Resources ( attributes ) ) { implicit@@ Outputs . add ( Android@@ Rule@@ Classes . ANDROID_@@ JAV@@ A@@ _SOURCE_@@ JAR , Android@@ Rule@@ Classes . ANDROID_@@ R_@@ TXT , Android@@ Rule@@ Classes . ANDROID_@@ RESOUR@@ CES_@@ class_@@ JAR ) ; } return from@@ Functions ( implicit@@ Outputs . build ( ) ) . get@@ Implicit@@ Outputs ( eventHandler , attributes ) ; } }
 public static String gen@@ Dest@@ FolderPath ( String dest@@ Loc , String suffix@@ Loc ) { if ( is@@ EmptyString ( dest@@ Loc ) ) { return dest@@ Loc ; } String dest@@ Path = to@@ OS@@ FilePath ( dest@@ Loc ) ; if ( ! is@@ EmptyString ( suffix@@ Loc ) ) { dest@@ Path = dest@@ Path + to@@ OS@@ FilePath ( suffix@@ Loc ) ; } return dest@@ Path ; }
 public static byte direct@@ ProtocolVersion ( Grid@@ Ker@@ nal@@ Context ctx , UUID nodeId ) throws IgniteCheckedException { assert nodeId != null ; ClusterNode node = ctx . discovery ( ) . node ( nodeId ) ; if ( node == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ define ▁ communication ▁ protocol ▁ version ▁ " + " ( has ▁ node ▁ left ▁ topology ? ) : ▁ " + nodeId ) ; assert ! node . is@@ Local ( ) ; Byte attr = node . attribute ( Grid@@ Io@@ Manager . DIRECT_@@ PROTO_@@ VER_@@ ATTR ) ; byte rm@@ t@@ Proto@@ Ver = attr != null ? attr : 1 ; if ( rm@@ t@@ Proto@@ Ver < Grid@@ Io@@ Manager . DIRECT_@@ PROTO_@@ VER ) return rm@@ t@@ Proto@@ Ver ; else return Grid@@ Io@@ Manager . DIRECT_@@ PROTO_@@ VER ; }
 public static Grid@@ Peer@@ Deploy@@ Aware peer@@ Deploy@@ Aware@@ 0 ( Object obj ) { if ( obj instanceof Iterable ) return peer@@ Deploy@@ Aware@@ 0 ( ( Iterable ) obj ) ; if ( obj . getClass ( ) . isArray ( ) && ! U . is@@ Primitive@@ Array ( obj ) ) return peer@@ Deploy@@ Aware@@ 0 ( ( Object [ ] ) obj ) ; return peer@@ Deploy@@ Aware ( obj ) ; }
 @ Nullable public static Ignite@@ Uuid read@@ Grid@@ Uuid ( byte [ ] arr , long off ) { if ( UNSAFE . getBoolean ( arr , off ++ ) ) { long most = UNSAFE . getLong ( arr , off ) ; off += 8 ; long least = UNSAFE . getLong ( arr , off ) ; off += 8 ; UUID global@@ Id = new UUID ( most , least ) ; long loc@@ Id = UNSAFE . getLong ( arr , off ) ; return new Ignite@@ Uuid ( global@@ Id , loc@@ Id ) ; } return null ; }
 public static boolean is@@ Windows@@ N@@ t ( ) { return win@@ N@@ t ; }
 private static final Serializable@@ Assert ex@@ Comparator = new Serializable@@ Assert ( ) { public void assert@@ De@@ serialized ( Serializable initial , Serializable deserialized ) { Serialization@@ Test . THROW@@ ABLE_@@ COMPAR@@ ATOR . assert@@ De@@ serialized ( initial , deserialized ) ; Missing@@ Format@@ Width@@ Exception init@@ Ex = ( Missing@@ Format@@ Width@@ Exception ) initial ; Missing@@ Format@@ Width@@ Exception de@@ sr@@ Ex = ( Missing@@ Format@@ Width@@ Exception ) deserialized ; assertEquals ( " Format@@ Specifier " , init@@ Ex . get@@ Format@@ Specifier ( ) , de@@ sr@@ Ex . get@@ Format@@ Specifier ( ) ) ; } }
 private static void skip@@ Promo@@ ted@@ Index ( DataInput@@ Plus in , Version version ) throws IOException { int size = version . store@@ Rows ( ) ? ( int ) in . readUnsigned@@ VInt ( ) : in . readInt ( ) ; if ( size <= 0 ) return ; FileUtils . skip@@ Bytes@@ Fully ( in , size ) ; }
 public static JM@@ Exception j@@ m@@ Exception ( Throwable e ) { JM@@ Exception x = new JM@@ Exception ( ) ; x . initCause ( e ) ; return x ; }
 static public Data@@ Stream@@ Marshaller [ ] create@@ Marshall@@ er@@ Map ( Open@@ Wire@@ Format wire@@ Format ) { return marshaller ; }
 private static boolean has@@ Common@@ ClassLoader ( Object obj , Iterable < ? > c ) { assert obj != null ; assert c != null ; ClassLoader ldr = obj instanceof Grid@@ Peer@@ Deploy@@ Aware ? ( ( Grid@@ Peer@@ Deploy@@ Aware ) obj ) . classLoader ( ) : detect@@ ClassLoader ( obj . getClass ( ) ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String cl@@ sName = obj2 instanceof Grid@@ Peer@@ Deploy@@ Aware ? ( ( Grid@@ Peer@@ Deploy@@ Aware ) obj2 ) . deploy@@ Class ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! is@@ Load@@ able@@ By ( cl@@ sName , ldr ) ) { found = false ; break ; } } return found ; }
 public static void join ( Thread t ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { t . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static void qui@@ et@@ And@@ Info ( Ignite@@ Logger log , String msg ) { if ( log . is@@ Qu@@ i@@ et ( ) ) U . quiet ( false , msg ) ; if ( log . is@@ Info@@ Enabled ( ) ) log . info ( msg ) ; }
 public static Ignite@@ Logger logger ( Grid@@ Ker@@ nal@@ Context ctx , AtomicReference < Ignite@@ Logger > log@@ Ref , Class < ? > cls ) { Ignite@@ Logger log = log@@ Ref . get ( ) ; if ( log == null ) { log@@ Ref . compareAndSet ( null , ctx . log ( cls ) ) ; log = log@@ Ref . get ( ) ; } return log ; }
 @ VisibleForTesting static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > others ) { return overlapping ( sstable . first . token , sstable . last . token , others ) ; }
 ) public static Grid@@ Peer@@ Deploy@@ Aware peer@@ Deploy@@ Aware@@ 0 ( @ Nullable Object ... c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; boolean not@@ All@@ Nulls = false ; for ( Object obj : c ) { if ( obj != null ) { not@@ All@@ Nulls = true ; ClassLoader ldr = obj instanceof Grid@@ Peer@@ Deploy@@ Aware ? ( ( Grid@@ Peer@@ Deploy@@ Aware ) obj ) . classLoader ( ) : obj . getClass ( ) . getClassLoader ( ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String cl@@ sName = obj2 instanceof Grid@@ Peer@@ Deploy@@ Aware ? ( ( Grid@@ Peer@@ Deploy@@ Aware ) obj2 ) . deploy@@ Class ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! is@@ Load@@ able@@ By ( cl@@ sName , ldr ) ) { found = false ; break ; } } if ( found ) return peer@@ Deploy@@ Aware@@ 0 ( obj ) ; } } if ( not@@ All@@ Nulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peer@@ Deploy@@ Aware ( new Object [ 0 ] ) ; }
 public static String format@@ Min@@ s ( long mins ) { assert mins >= 0 ; if ( mins == 0 ) return " < ▁ 1 ▁ min " ; SB sb = new SB ( ) ; long dd = mins / 14@@ 40 ; if ( dd > 0 ) sb . a ( dd ) . a ( dd == 1 ? " ▁ day ▁ " : " ▁ days ▁ " ) ; mins %= 14@@ 40 ; long hh = mins / 60 ; if ( hh > 0 ) sb . a ( hh ) . a ( hh == 1 ? " ▁ hour ▁ " : " ▁ hours ▁ " ) ; mins %= 60 ; if ( mins > 0 ) sb . a ( mins ) . a ( mins == 1 ? " ▁ min ▁ " : " ▁ mins ▁ " ) ; return sb . toString ( ) . trim ( ) ; }
 public static boolean is@@ Windows@@ 2@@ k ( ) { return win@@ 2@@ k ; }
 public static GridCache@@ Version read@@ Version ( byte [ ] arr , long off , boolean ver@@ Ex ) { int top@@ Ver = UNSAFE . getInt ( arr , off ) ; off += 4 ; int node@@ Order@@ Dr@@ Id = UNSAFE . getInt ( arr , off ) ; off += 4 ; long global@@ Time = UNSAFE . getLong ( arr , off ) ; off += 8 ; long order = UNSAFE . getLong ( arr , off ) ; off += 8 ; GridCache@@ Version ver = new GridCache@@ Version ( top@@ Ver , node@@ Order@@ Dr@@ Id , global@@ Time , order ) ; if ( ver@@ Ex ) { top@@ Ver = UNSAFE . getInt ( arr , off ) ; off += 4 ; node@@ Order@@ Dr@@ Id = UNSAFE . getInt ( arr , off ) ; off += 4 ; global@@ Time = UNSAFE . getLong ( arr , off ) ; off += 8 ; order = UNSAFE . getLong ( arr , off ) ; ver = new GridCache@@ Version@@ Ex ( top@@ Ver , node@@ Order@@ Dr@@ Id , global@@ Time , order , ver ) ; } return ver ; }
 public static < K , V > HashMap < K , V > newHashMap ( int exp@@ Size ) { return new HashMap < > ( capacity ( exp@@ Size ) ) ; }
 public static Store@@ Writer create@@ Writer ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } try { LOGGER . log ( Level . INFO , " Initialize ▁ writer ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; File parent = file . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( parent . mkdirs ( ) ) { LOGGER . log ( Level . INFO , " Creating ▁ directories ▁ for ▁ path ▁ { 0 } " , file . getName ( ) ) ; } else { throw new RuntimeException ( String . format ( " Couldn ' t ▁ create ▁ directory ▁ % s " , parent ) ) ; } } return new Writer@@ Impl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
 public static File download@@ Url ( URL url , File file ) throws IOException { assert url != null ; assert file != null ; InputStream in = null ; OutputStream out = null ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof Https@@ URLConnection ) { Https@@ URLConnection https = ( Https@@ URLConnection ) conn ; https . set@@ Hostname@@ Verifier ( new Deployment@@ Hostname@@ Verifier ( ) ) ; SSLContext ctx = SSLContext . getInstance ( HTTP@@ S_@@ PROTOCOL ) ; ctx . init ( null , get@@ Trust@@ Managers ( ) , null ) ; https . set@@ SSLSocketFactory ( ctx . get@@ SocketFactory ( ) ) ; } in = conn . getInputStream ( ) ; if ( in == null ) throw new IOException ( " Failed ▁ to ▁ open ▁ connection : ▁ " + url . toString ( ) ) ; out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; copy ( in , out ) ; } catch ( NoSuchAlgorithmException | Key@@ ManagementException e ) { throw new IOException ( " Failed ▁ to ▁ open ▁ HTTP@@ s ▁ connection ▁ [ url = " + url . toString ( ) + " , ▁ msg = " + e + ' ] ' , e ) ; } finally { close ( in , null ) ; close ( out , null ) ; } return file ; }
 public static boolean is@@ Windows@@ 98 ( ) { return win@@ 98 ; }
 public static byte [ ] join ( byte [ ] ... bufs ) { int size = 0 ; for ( byte [ ] buf : bufs ) { size += buf . length ; } byte [ ] res = new byte [ size ] ; int position = 0 ; for ( byte [ ] buf : bufs ) { array@@ Copy ( buf , 0 , res , position , buf . length ) ; position += buf . length ; } return res ; }
 public static Operating@@ System@@ MXBean get@@ Os@@ M@@ x ( ) { return Management@@ Factory . get@@ Operating@@ System@@ MXBean ( ) ; }
 public static String to@@ Short@@ String ( Collection < ? extends ClusterNode > ns ) { SB sb = new SB ( " Grid ▁ nodes ▁ [ cnt = " + ns . size ( ) ) ; for ( ClusterNode n : ns ) sb . a ( " , ▁ " ) . a ( to@@ Short@@ String ( n ) ) ; return sb . a ( ' ] ' ) . toString ( ) ; }
 private static int to@@ Length ( long addr@@ And@@ Len ) { return ( int ) ( addr@@ And@@ Len & SIZE_@@ MASK ) ; }
 public static boolean join ( Iterable < ? extends Grid@@ Worker > ws , Ignite@@ Logger log ) { boolean retval = true ; if ( ws != null ) for ( Grid@@ Worker w : ws ) if ( ! join ( w , log ) ) retval = false ; return retval ; }
 public static Collection < Handler > add@@ Java@@ No@@ Op@@ Logger ( ) { Collection < Handler > saved@@ H@@ n@@ ds = new ArrayList < > ( ) ; Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . get@@ Handlers ( ) ) { log . remove@@ Handler ( h ) ; saved@@ H@@ n@@ ds . add ( h ) ; } Console@@ Handler h@@ nd = new Console@@ Handler ( ) ; h@@ nd . setLevel ( Level . OFF ) ; log . addHandler ( h@@ nd ) ; return saved@@ H@@ n@@ ds ; }
 public static < E > List < E > se@@ al@@ List ( Collection < E > c ) { return Collections . unmodifiableList ( new ArrayList < > ( c ) ) ; }
 public static ObjectName make@@ Cache@@ MBean@@ Name ( @ Nullable String grid@@ Name , @ Nullable String cacheName , String name ) throws Malformed@@ Object@@ NameException { SB sb = new SB ( JM@@ X_@@ DOMAIN + ' : ' ) ; append@@ ClassLoader@@ Hash ( sb ) ; append@@ Jvm@@ Id ( sb ) ; if ( grid@@ Name != null && ! grid@@ Name . isEmpty ( ) ) sb . a ( " grid = " ) . a ( grid@@ Name ) . a ( ' , ' ) ; cacheName = mask@@ Name ( cacheName ) ; sb . a ( " group = " ) . a ( cacheName ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
 public static boolean reachable ( NetworkInterface it@@ f , InetAddress addr , int reach@@ Timeout ) { try { return addr . is@@ Reachable ( it@@ f , 0 , reach@@ Timeout ) ; } catch ( IOException ignore ) { return false ; } }
 public static void writeTo@@ File ( String dest@@ Loc , String fileName , String contents ) throws IOException { Writer file@@ Writer = null ; try { file@@ Writer = getFile@@ Writer ( dest@@ Loc , fileName ) ; file@@ Writer . write ( contents ) ; } finally { closeQuietly ( file@@ Writer ) ; } }
 public static Ignite@@ Uuid bytesTo@@ Ignite@@ Uuid ( byte [ ] in , int off ) { long most = bytesTo@@ Long ( in , off ) ; long least = bytesTo@@ Long ( in , off + 8 ) ; long loc@@ Id = bytesTo@@ Long ( in , off + 16 ) ; return new Ignite@@ Uuid ( Ignite@@ Uuid@@ Cache . on@@ Ignite@@ Uuid@@ Read ( new UUID ( most , least ) ) , loc@@ Id ) ; }
 public static Le@@ ve@@ led@@ Manifest create ( ColumnFamily@@ Store cfs , int max@@ SSTable@@ Size , Iterable < SSTableReader > sst@@ ables , Size@@ Ti@@ ered@@ Compaction@@ Strategy@@ Options options ) { Le@@ ve@@ led@@ Manifest manifest = new Le@@ ve@@ led@@ Manifest ( cfs , max@@ SSTable@@ Size , options ) ; for ( SSTableReader ss@@ Table@@ Reader : sst@@ ables ) { manifest . add ( ss@@ Table@@ Reader ) ; } for ( int i = 1 ; i < manifest . getAll@@ Level@@ Size ( ) . length ; i ++ ) { manifest . re@@ pair@@ Overlapping@@ SST@@ ables ( i ) ; } return manifest ; }
 public static Encoding@@ Stats collect ( Row static@@ Row , Iterator < Row > rows , Deletion@@ Info dele@@ tion@@ Info ) { Collector collector = new Collector ( ) ; dele@@ tion@@ Info . collect@@ Stats ( collector ) ; if ( ! static@@ Row . isEmpty ( ) ) Rows . collect@@ Stats ( static@@ Row , collector ) ; while ( rows . hasNext ( ) ) Rows . collect@@ Stats ( rows . next ( ) , collector ) ; return collector . get ( ) ; }
 public static Intent create@@ Intent ( Context context , boolean login ) { Intent intent = new Intent ( context , Send@@ Login@@ Status@@ Service . class ) ; intent . putExtra ( KEY_@@ LOGIN , String . valueOf ( login ) ) ; return intent ; }
 private static double ro@@ unded@@ Heap@@ Size ( double heap , int precision ) { double rounded = new BigDecimal ( heap / ( 1024 * 1024 * 1024@@ d ) ) . round ( new Math@@ Context ( precision ) ) . doubleValue ( ) ; return rounded < 0.1 ? 0.1 : rounded ; }
 public static void main ( String [ ] args ) { junit . textu@@ i . TestRunner . run ( X@@ Graphics@@ 2D@@ R@@ Test . class ) ; }
 ) public static < T > T [ ] toArray ( Collection < ? extends T > c , T [ ] arr ) { T [ ] a = c . toArray ( arr ) ; assert a == arr ; return arr ; }
 public static boolean p2@@ p@@ Loader ( Object o ) { return o != null && p2@@ p@@ Loader ( o . getClass ( ) . getClassLoader ( ) ) ; }
 public static int [ ] unique ( int [ ] a , int a@@ Len , int [ ] b , int b@@ Len ) { assert a != null ; assert b != null ; assert is@@ Incre@@ asing@@ Array ( a , a@@ Len ) ; assert is@@ Incre@@ asing@@ Array ( b , b@@ Len ) ; int [ ] res = new int [ a@@ Len + b@@ Len ] ; int res@@ Len = 0 ; int i = 0 ; int j = 0 ; while ( i < a@@ Len && j < b@@ Len ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ res@@ Len ++ ] = a [ i ++ ] ; else res [ res@@ Len ++ ] = b [ j ++ ] ; } while ( i < a@@ Len ) res [ res@@ Len ++ ] = a [ i ++ ] ; while ( j < b@@ Len ) res [ res@@ Len ++ ] = b [ j ++ ] ; return copy@@ If@@ Exceeded ( res , res@@ Len ) ; }
 public static < V , F extends Function < V , Encoding@@ Stats > > Encoding@@ Stats merge ( List < V > values , F function ) { if ( values . size ( ) == 1 ) return function . apply ( values . get ( 0 ) ) ; Collector collector = new Collector ( ) ; for ( int i = 0 , i@@ size = values . size ( ) ; i < i@@ size ; i ++ ) { V v = values . get ( i ) ; Encoding@@ Stats stats = function . apply ( v ) ; if ( stats . min@@ Timestamp != TIMESTAMP_@@ EPOC@@ H ) collector . update@@ Timestamp ( stats . min@@ Timestamp ) ; if ( stats . min@@ Local@@ Deletion@@ Time != DELE@@ TION_@@ TIME_@@ EPOC@@ H ) collector . update@@ Local@@ Deletion@@ Time ( stats . min@@ Local@@ Deletion@@ Time ) ; if ( stats . min@@ TTL != TT@@ L_@@ EPOC@@ H ) collector . update@@ TTL ( stats . min@@ TTL ) ; } return collector . get ( ) ; }
 @ Nullable public static Constructor < ? > force@@ Empty@@ Constructor ( Class < ? > cls ) throws IgniteCheckedException { Constructor < ? > ctor = null ; try { return cls . getDeclared@@ Constructor ( ) ; } catch ( Exception ignore ) { Method c@@ tor@@ Fa@@ c = U . c@@ tor@@ Factory ( ) ; Object sun@@ Ref@@ Fa@@ c = U . sun@@ Reflection@@ Factory ( ) ; if ( c@@ tor@@ Fa@@ c != null && sun@@ Ref@@ Fa@@ c != null ) try { ctor = ( Constructor ) c@@ tor@@ Fa@@ c . invoke ( sun@@ Ref@@ Fa@@ c , cls , U . object@@ Constructor ( ) ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ object ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } } return ctor ; }
 public static void close ( @ Nullable URL@@ ClassLoader cls@@ L@@ dr , @ Nullable Ignite@@ Logger log ) { if ( cls@@ L@@ dr != null ) try { URL@@ ClassPath path = Shared@@ Sec@@ re@@ ts . getJava@@ Net@@ Access ( ) . get@@ URL@@ ClassPath ( cls@@ L@@ dr ) ; Field ld@@ r@@ Fl@@ d = path . getClass ( ) . getDeclaredField ( " loaders " ) ; ld@@ r@@ Fl@@ d . setAccessible ( true ) ; Iterable ld@@ rs = ( Iterable ) ld@@ r@@ Fl@@ d . get ( path ) ; for ( Object ldr : ld@@ rs ) if ( ldr . getClass ( ) . getName ( ) . endsWith ( " Jar@@ Loader " ) ) try { Field jar@@ Fl@@ d = ldr . getClass ( ) . getDeclaredField ( " jar " ) ; jar@@ Fl@@ d . setAccessible ( true ) ; ZipFile jar = ( ZipFile ) jar@@ Fl@@ d . get ( ldr ) ; jar . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static boolean is@@ Windows@@ 95 ( ) { return win@@ 95 ; }
 public static String os@@ Architecture ( ) { return os@@ Arch ; }
 public static List < String > get@@ Valid@@ Values ( ) { List < String > ans = Lists . newArrayList ( ) ; for ( Multi@@ dex@@ Mode mode : Multi@@ dex@@ Mode . values ( ) ) { ans . add ( mode . getAttributeValue ( ) ) ; } return ans ; }
 public static DataStream < Tuple@@ 3 < Integer , Long , String > > get@@ Small@@ 3@@ Tuple@@ DataSet ( Stream@@ ExecutionEnvironment env ) { List < Tuple@@ 3 < Integer , Long , String > > data = new ArrayList < > ( ) ; data . add ( new Tuple@@ 3 < > ( 1 , 1L , " Hi " ) ) ; data . add ( new Tuple@@ 3 < > ( 2 , 2L , " Hello " ) ) ; data . add ( new Tuple@@ 3 < > ( 3 , 2L , " Hello ▁ world " ) ) ; Collections . shuffle ( data ) ; return env . from@@ Collection ( data ) ; }
 public static BufferedReader getFile@@ Reader ( String dest@@ Dir , String fileName ) throws IOException { if ( is@@ EmptyString ( dest@@ Dir ) || is@@ EmptyString ( fileName ) ) { return null ; } File dir = create@@ Dir ( dest@@ Dir ) ; File inFile = new File ( dir , fileName ) ; Charset default@@ Charset = Charset . default@@ Charset ( ) ; FileInputStream file@@ InStream = new FileInputStream ( inFile ) ; InputStreamReader bw = new InputStreamReader ( file@@ InStream , default@@ Charset ) ; BufferedReader buff@@ Reader = new BufferedReader ( bw ) ; return buff@@ Reader ; }
 public static String [ ] getService@@ Locations ( Definition wsdl@@ Definition ) { List < String > locations = new ArrayList < String > ( ) ; Service wsdl@@ Service = ( Service ) wsdl@@ Definition . get@@ Services ( ) . values ( ) . iterator ( ) . next ( ) ; Map < ? , ? > wsdl@@ Ports = wsdl@@ Service . getP@@ orts ( ) ; for ( Iterator < ? > it = wsdl@@ Ports . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Port wsdl@@ Port = ( Port ) it . next ( ) ; Iterator < ? > it@@ Elements = wsdl@@ Port . get@@ Exten@@ sibility@@ Elements ( ) . iterator ( ) ; while ( it@@ Elements . hasNext ( ) ) { Object obj = it@@ Elements . next ( ) ; String wsdl@@ URI = null ; if ( obj instanceof SOAP@@ Address ) { SOAP@@ Address address = ( SOAP@@ Address ) obj ; wsdl@@ URI = address . getLocation@@ URI ( ) ; } else if ( obj instanceof SOAP@@ 12@@ Address ) { SOAP@@ 12@@ Address address = ( SOAP@@ 12@@ Address ) obj ; wsdl@@ URI = address . getLocation@@ URI ( ) ; } else if ( obj instanceof HTTP@@ Address ) { HTTP@@ Address address = ( HTTP@@ Address ) obj ; wsdl@@ URI = address . getLocation@@ URI ( ) ; } if ( ! is@@ EmptyString ( wsdl@@ URI ) ) locations . add ( wsdl@@ URI ) ; } } String arr [ ] = new String [ locations . size ( ) ] ; locations . toArray ( arr ) ; return arr ; }
 public static void qui@@ et@@ And@@ Warn ( Ignite@@ Logger log , Object msg ) { qui@@ et@@ And@@ Warn ( log , msg , msg ) ; }
 public static < K , V , M extends Map < K , V > > M addAll ( M m , Map . Entry < K , V > ... entries ) { for ( Map . Entry < K , V > e : entries ) m . put ( e . getKey ( ) , e . getValue ( ) ) ; return m ; }
 public static final Safe@@ Implicit@@ Output@@ s@@ Function ANDROID_@@ BINARY_@@ IMPLICIT_@@ OUTPUT@@ S = new Safe@@ Implicit@@ Output@@ s@@ Function ( ) { @ Override public Iterable < String > get@@ Implicit@@ Outputs ( EventHandler eventHandler , Attribute@@ Map rule ) { List < Safe@@ Implicit@@ Output@@ s@@ Function > functions = Lists . newArrayList ( ) ; functions . add ( Android@@ Rule@@ Classes . ANDROID_@@ BINARY_@@ AP@@ K ) ; functions . add ( Android@@ Rule@@ Classes . ANDROID_@@ BINARY_@@ UNSIGNED_@@ AP@@ K ) ; functions . add ( Android@@ Rule@@ Classes . ANDROID_@@ BINARY_@@ DEPLO@@ Y_@@ JAR ) ; if ( has@@ Pro@@ guard@@ Specs ( rule ) ) { functions . add ( Android@@ Rule@@ Classes . ANDROID_@@ BINARY_@@ PRO@@ GUARD_@@ JAR ) ; functions . add ( Java@@ Semantics . JAVA_@@ BINARY_@@ PRO@@ GUARD_@@ CONFIG ) ; if ( Pro@@ guard@@ Helper . gen@@ Pro@@ guard@@ Mapping ( rule ) ) { functions . add ( Java@@ Semantics . JAVA_@@ BINARY_@@ PRO@@ GUARD_@@ MAP ) ; } } return from@@ Functions ( functions ) . get@@ Implicit@@ Outputs ( eventHandler , rule ) ; } }
 @ Nullable public static UUID read@@ Uuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; return Ignite@@ Uuid@@ Cache . on@@ Ignite@@ Uuid@@ Read ( new UUID ( most , least ) ) ; } return null ; }
 public static boolean is@@ Vis@@ or@@ Node@@ Start@@ Property ( String name ) { return IGN@@ ITE_@@ SSH_@@ HOST . equals ( name ) || IGN@@ ITE_@@ SSH_@@ USER_@@ NAME . equals ( name ) ; }
 public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mt@@ d@@ Name , Class [ ] param@@ Types , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mt@@ d@@ Name != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuper@@ class ( ) ) { Method m@@ td ; try { m@@ td = c . getDeclared@@ Method ( mt@@ d@@ Name , param@@ Types ) ; } catch ( NoSuchMethodException ignored ) { continue ; } boolean accessible = m@@ td . is@@ Accessible ( ) ; T res ; try { m@@ td . setAccessible ( true ) ; res = ( T ) m@@ td . invoke ( obj , params ) ; } finally { if ( ! accessible ) m@@ td . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mt@@ d@@ Name = " + mt@@ d@@ Name + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mt@@ d@@ Name = " + mt@@ d@@ Name + " , ▁ cls = " + cls + ' ] ' ) ; }
 public static void close@@ Qu@@ i@@ et ( @ Nullable Selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException ignored ) { } }
 public static IgniteCheckedException exception@@ With@@ Sup@@ pressed ( String msg , @ Nullable Collection < Throwable > suppressed ) { IgniteCheckedException e = new IgniteCheckedException ( msg ) ; if ( suppressed != null ) { for ( Throwable th : suppressed ) e . add@@ Sup@@ pressed ( th ) ; } return e ; }
 public static Store@@ Writer create@@ Writer ( OutputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . info ( " Initialize ▁ writer ▁ from ▁ stream " ) ; return new Writer@@ Impl ( config , stream ) ; }
 public static void sleep ( long ms ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static String mask@@ Name ( @ Nullable String cacheName ) { return cacheName == null ? " default " : cacheName ; }
 public static < T > T static@@ Field ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Field field : cls . getDeclared@@ Fields ( ) ) if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . is@@ Accessible ( ) ; if ( ! accessible ) field . setAccessible ( true ) ; T val = ( T ) field . get ( null ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
 public static byte [ ] int@@ To@@ Bytes ( int i ) { return Grid@@ Client@@ Byte@@ Utils . int@@ To@@ Bytes ( i ) ; }
 public static void join ( Grid@@ Worker w ) throws Ignite@@ Interrup@@ ted@@ CheckedException { try { if ( w != null ) w . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new Ignite@@ Interrup@@ ted@@ CheckedException ( e ) ; } }
 public static String set@@ Or@@ List@@ To@@ JsonString ( ByteBuffer buffer , AbstractType element@@ sType , int protocol@@ Version ) { StringBuilder sb = new StringBuilder ( " [ " ) ; int size = Collection@@ Serializer . read@@ CollectionSize ( buffer , protocol@@ Version ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( i > 0 ) sb . append ( " , ▁ " ) ; sb . append ( element@@ sType . to@@ JSON@@ String ( Collection@@ Serializer . readValue ( buffer , protocol@@ Version ) , protocol@@ Version ) ) ; } return sb . append ( " ] " ) . toString ( ) ; }
 public static void close ( @ Nullable Context rsrc , @ Nullable Ignite@@ Logger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static ClassLoader detect@@ ClassLoader ( Class < ? > cls ) { return Grid@@ ClassLoader@@ Cache . classLoader ( cls ) ; }
 public static < T > Iterable < T > as@@ Iterable ( final Enumeration < T > e ) { return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { @ Override public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } @ SuppressWarnings ( { " Iterator@@ Next@@ Can@@ Not@@ Throw@@ NoSuchElementException " } ) @ Override public T next ( ) { return e . nextElement ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; }
 public static byte [ ] short@@ To@@ Bytes ( short s ) { return Grid@@ Client@@ Byte@@ Utils . short@@ To@@ Bytes ( s ) ; }
 public static short bytesTo@@ Short ( byte [ ] bytes , int off ) { assert bytes != null ; int bytes@@ Cnt = Short . SIZE >> 3 ; if ( off + bytes@@ Cnt > bytes . length ) bytes@@ Cnt = bytes . length - off ; short res = 0 ; for ( int i = 0 ; i < bytes@@ Cnt ; i ++ ) { int shift = bytes@@ Cnt - i - 1 << 3 ; res |= ( 0xff@@ L & bytes [ off ++ ] ) << shift ; } return res ; }
 public static Exception convert@@ Exception@@ No@@ Wrap ( IgniteCheckedException e ) { C1 < IgniteCheckedException , Ignite@@ Exception > converter = exception@@ Converters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof Ignite@@ Exception ) return ( Exception ) e . getCause ( ) ; return e ; }
 public static boolean dir@@ Exists ( String path ) { if ( is@@ EmptyString ( path ) ) { return false ; } File dir = new File ( path ) ; return dir . exists ( ) && dir . isDirectory ( ) ; }
 @ Nullable public static Object sun@@ Reflection@@ Factory ( ) { return SUN@@ _@@ REFLE@@ CT_@@ FACTORY ; }
 public static boolean is@@ EmptyString ( String str ) { return ( str == null || str . trim ( ) . length ( ) == 0 ) ; }
 @ Nullable public static < T > T first@@ NotNull ( @ Nullable T ... vals ) { if ( vals == null ) return null ; for ( T val : vals ) { if ( val != null ) return val ; } return null ; }
 public static long write@@ Grid@@ Uuid ( byte [ ] arr , long off , @ Nullable Ignite@@ Uuid uid ) { UNSAFE . putBoolean ( arr , off ++ , uid != null ) ; if ( uid != null ) { UNSAFE . put@@ Long ( arr , off , uid . global@@ Id ( ) . get@@ Most@@ Significant@@ Bits ( ) ) ; off += 8 ; UNSAFE . put@@ Long ( arr , off , uid . global@@ Id ( ) . get@@ Least@@ Significant@@ Bits ( ) ) ; off += 8 ; UNSAFE . put@@ Long ( arr , off , uid . local@@ Id ( ) ) ; off += 8 ; } return off ; }
 ) @ Deprecated public static void dump@@ Stack ( Thread t , PrintStream s ) { synchronized ( s ) { s . println ( " Dump@@ ing ▁ stack ▁ trace ▁ for ▁ thread : ▁ " + t ) ; for ( StackTraceElement trace : t . getStackTrace ( ) ) s . println ( " \t@@ at ▁ " + trace ) ; } }
 public static < T > ObjectName register@@ MBean ( MBeanServer mbean@@ S@@ rv , @ Nullable String grid@@ Name , @ Nullable String grp , String name , T impl , @ Nullable Class < T > it@@ f ) throws JM@@ Exception { assert mbean@@ S@@ rv != null ; assert name != null ; assert it@@ f != null ; Dynamic@@ MBean mbean = new Ignite@@ Standard@@ MXBean ( impl , it@@ f ) ; mbean . get@@ MBean@@ Info ( ) ; return mbean@@ S@@ rv . register@@ MBean ( mbean , make@@ MBean@@ Name ( grid@@ Name , grp , name ) ) . get@@ ObjectName ( ) ; }
 public static void write@@ Grid@@ Uuid ( DataOutput out , Ignite@@ Uuid uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . global@@ Id ( ) . get@@ Most@@ Significant@@ Bits ( ) ) ; out . writeLong ( uid . global@@ Id ( ) . get@@ Least@@ Significant@@ Bits ( ) ) ; out . writeLong ( uid . local@@ Id ( ) ) ; } }
 public static synchronized Collection < String > all@@ Local@@ MAC@@ s ( ) { List < String > macs = new ArrayList < > ( 3 ) ; try { Enumeration < NetworkInterface > it@@ fs = NetworkInterface . getNetwork@@ Interfaces ( ) ; if ( it@@ fs != null ) { for ( NetworkInterface it@@ f : as@@ Iterable ( it@@ fs ) ) { byte [ ] hw@@ Addr = it@@ f . getH@@ ard@@ ware@@ Address ( ) ; if ( hw@@ Addr != null && hw@@ Addr . length > 0 ) { String mac = byteArray@@ 2@@ HexString ( hw@@ Addr ) ; if ( ! macs . contains ( mac ) ) macs . add ( mac ) ; } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( macs ) ; return macs ; }
 @ Nullable public static File resolve@@ Ignite@@ Path ( String path ) { assert path != null ; String home = get@@ Ignite@@ Home ( ) ; if ( home != null ) { File file = new File ( home , path ) ; if ( file . exists ( ) ) return file ; } File file = new File ( path ) ; if ( file . exists ( ) ) return file ; return null ; }
 public static boolean is@@ Sol@@ ar@@ is@@ Spar@@ c ( ) { return sol@@ aris && spar@@ c ; }
 public static List < byte [ ] > read@@ Bytes@@ List ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size < 0 ) return null ; List < byte [ ] > res = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) res . add ( read@@ ByteArray ( in ) ) ; return res ; }
 public static List < Page@@ Data > set@@ List@@ Distance ( List < Page@@ Data > list , Page@@ Data pd ) { List < Page@@ Data > list@@ Return = new ArrayList < Page@@ Data > ( ) ; String user_@@ longitude = " " ; String user_@@ latitude = " " ; try { user_@@ longitude = pd . get ( " user _ longitude " ) . toString ( ) ; user_@@ latitude = pd . get ( " user _ latitude " ) . toString ( ) ; } catch ( Exception e ) { logger . error ( " 缺@@ 失@@ 参@@ 数 - - user _ long@@ itude@@ 和@@ user _ longitude " ) ; logger . error ( " lost ▁ param ： user _ longitude ▁ and ▁ user _ longitude " ) ; } Page@@ Data pd@@ Temp = new Page@@ Data ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { pd@@ Temp = list . get ( i ) ; String longitude = pd@@ Temp . get ( " longitude " ) . toString ( ) ; String latitude = pd@@ Temp . get ( " latitude " ) . toString ( ) ; String distance = Map@@ Distance . get@@ Distance ( user_@@ longitude , user_@@ latitude , longitude , latitude ) ; pd@@ Temp . put ( " distance " , distance ) ; pd@@ Temp . put ( " size " , distance . length ( ) ) ; list@@ Return . add ( pd@@ Temp ) ; } return list@@ Return ; }
 public static boolean is@@ Mac@@ Invalid@@ ArgumentError ( Exception e ) { return U . is@@ Mac@@ Os ( ) && e instanceof SocketException && e . getMessage ( ) != null && e . getMessage ( ) . toLowerCase ( ) . contains ( " invalid ▁ argument " ) ; }
 public static boolean is@@ Unix ( ) { return unix ; }
 public static Js@@ Array@@ Boolean wrap@@ Array ( boolean [ ] src@@ Array ) { Js@@ Array@@ Boolean result = JavaScript@@ Object . create@@ Array ( ) . cast ( ) ; for ( int i = 0 ; i < src@@ Array . length ; i ++ ) { result . set ( i , src@@ Array [ i ] ) ; } return result ; }
 public static void log ( @ Nullable Ignite@@ Logger log , Object long@@ Msg , Object short@@ Msg ) { assert long@@ Msg != null ; assert short@@ Msg != null ; if ( log != null ) { if ( log . is@@ Info@@ Enabled ( ) ) log . info ( compact ( long@@ Msg . toString ( ) ) ) ; } else quiet ( false , short@@ Msg ) ; }
 public static void async@@ LogError ( IgniteInternal@@ Future < ? > f , final Ignite@@ Logger log ) { if ( f != null ) f . listen ( new CI@@ 1 < IgniteInternal@@ Future < ? > > ( ) { @ Override public void apply ( IgniteInternal@@ Future < ? > f ) { try { f . get ( ) ; } catch ( IgniteCheckedException e ) { U . error ( log , " Failed ▁ to ▁ execute ▁ future : ▁ " + f , e ) ; } } } ) ; }
 @ Nullable public static Collection < Integer > read@@ Int@@ Collection ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Collection < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
 public static Writer getFile@@ Writer ( String dest@@ Dir , String fileName ) throws IOException { if ( is@@ EmptyString ( dest@@ Dir ) || is@@ EmptyString ( fileName ) ) { return null ; } File dir = create@@ Dir ( dest@@ Dir ) ; File outputFile = new File ( dir , fileName ) ; delete@@ File ( outputFile ) ; Charset default@@ Charset = Charset . default@@ Charset ( ) ; FileOutputStream file@@ OutStream = new FileOutputStream ( outputFile ) ; OutputStreamWriter bw = new OutputStreamWriter ( file@@ OutStream , default@@ Charset ) ; Writer buff@@ Writer = new BufferedWriter ( bw ) ; return buff@@ Writer ; }
 public static String jdk@@ Vendor ( ) { return jdk@@ Vendor ; }
 public static void error ( @ Nullable Ignite@@ Logger log , Object short@@ Msg , @ Nullable Throwable e ) { assert short@@ Msg != null ; String s = short@@ Msg . toString ( ) ; error ( log , s , s , e ) ; }
 public static void main ( String [ ] args ) { System . out . println ( " Hello ▁ World " ) ; }
 public static byte [ ] hex@@ String@@ 2@@ ByteArray ( String hex ) throws IllegalArgumentException { if ( hex . length ( ) % 2 != 0 ) hex = '0' + hex ; char [ ] chars = hex . toCharArray ( ) ; byte [ ] bytes = new byte [ chars . length / 2 ] ; int byte@@ Cnt = 0 ; for ( int i = 0 ; i < chars . length ; i += 2 ) { int new@@ Byte = 0 ; new@@ Byte |= hex@@ CharTo@@ Byte ( chars [ i ] ) ; new@@ Byte <<= 4 ; new@@ Byte |= hex@@ CharTo@@ Byte ( chars [ i + 1 ] ) ; bytes [ byte@@ Cnt ] = ( byte ) new@@ Byte ; byte@@ Cnt ++ ; } return bytes ; }
 @ Deprecated public static void dump@@ Stack ( String msg , PrintStream out ) { new Exception ( msg ) . printStackTrace ( out ) ; }
 public static void on@@ Grid@@ Stop ( ) throws InterruptedException { synchronized ( mux ) { if ( grid@@ Cnt == 0 ) return ; -- grid@@ Cnt ; Thread timer@@ 0 = timer ; if ( grid@@ Cnt == 0 && timer@@ 0 != null ) { timer = null ; timer@@ 0 . interrupt ( ) ; timer@@ 0 . join ( ) ; } } }
 public static String os@@ Jdk@@ String ( ) { return os@@ Jdk@@ Str ; }
 @ Nullable public static String get@@ Ignite@@ Home ( ) { Grid@@ Tuple < String > gg@@ Home@@ T@@ up = gg@@ Home ; String gg@@ Home@@ 0 ; if ( gg@@ Home@@ T@@ up == null ) { synchronized ( Ignite@@ Utils . class ) { gg@@ Home@@ T@@ up = gg@@ Home ; if ( gg@@ Home@@ T@@ up == null ) { gg@@ Home = F . t ( gg@@ Home@@ 0 = resolve@@ Project@@ Home ( ) ) ; if ( gg@@ Home@@ 0 != null ) System . setProperty ( IGN@@ ITE_@@ HOME , gg@@ Home@@ 0 ) ; } else gg@@ Home@@ 0 = gg@@ Home@@ T@@ up . get ( ) ; } } else gg@@ Home@@ 0 = gg@@ Home@@ T@@ up . get ( ) ; return gg@@ Home@@ 0 ; }
 public static void start@@ Lifecycle@@ Aware ( Iterable < ? > objs ) throws IgniteCheckedException { try { for ( Object obj : objs ) { if ( obj instanceof Lifecycle@@ Aware ) ( ( Lifecycle@@ Aware ) obj ) . start ( ) ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ start ▁ component : ▁ " + e , e ) ; } }
 public static Js@@ Array@@ Integer wrap@@ Array ( byte [ ] src@@ Array ) { Js@@ Array@@ Integer result = JavaScript@@ Object . create@@ Array ( ) . cast ( ) ; for ( int i = 0 ; i < src@@ Array . length ; i ++ ) { result . set ( i , src@@ Array [ i ] ) ; } return result ; }
 public static boolean is@@ Vis@@ or@@ Required@@ Property ( String name ) { return " java . version " . equals ( name ) || " java . vm . name " . equals ( name ) || " os . arch " . equals ( name ) || " os . name " . equals ( name ) || " os . version " . equals ( name ) ; }
 public static void dump@@ Stack ( @ Nullable Ignite@@ Logger log , String msg ) { U . error ( log , " Dump@@ ing ▁ stack . " , new Exception ( msg ) ) ; }
 public static String get@@ Folder@@ Path@@ Fro@@ mp@@ ack@@ age@@ Name ( String packageName ) { if ( packageName == null ) return null ; packageName = packageName . replace ( ' . ' , File . separator@@ Char ) ; return to@@ OS@@ FilePath ( packageName ) ; }
 static < T > Bounded@@ Source@@ Shard < T > of ( Bounded@@ Source < T > source ) { return new Auto@@ Value_@@ Bounded@@ Read@@ Evaluator@@ Fac@@ tory_@@ Bounded@@ Source@@ Shard < > ( source ) ; }
 private static void append@@ Jvm@@ Id ( SB sb ) { if ( getBoolean ( IGN@@ ITE_@@ M@@ BEAN_@@ APP@@ END_@@ JVM_@@ ID ) ) { String jvm@@ Id = Management@@ Factory . getRuntime@@ MXBean ( ) . getName ( ) ; sb . a ( " jvm@@ Id = " ) . a ( jvm@@ Id ) . a ( ' , ' ) ; } }
 public static int float@@ To@@ Bytes ( float f , byte [ ] bytes , int off ) { return int@@ To@@ Bytes ( Float . float@@ To@@ Int@@ Bits ( f ) , bytes , off ) ; }
 public static boolean is@@ FileExists ( String filePath ) { if ( is@@ EmptyString ( filePath ) ) { return false ; } File file = new File ( filePath ) ; return file . exists ( ) ; }
 public static ClassLoader grid@@ ClassLoader ( ) { return grid@@ ClassLoader ; }
 public static void closeQuietly ( FileHandler file@@ Handler ) { if ( file@@ Handler == null ) { return ; } file@@ Handler . close ( ) ; }
 public static synchronized boolean isLocal@@ Host@@ Changed ( ) throws IOException { InetAddress loc@@ Host@@ 0 = loc@@ Host ; return loc@@ Host@@ 0 != null && ! reset@@ LocalHost ( ) . equals ( loc@@ Host@@ 0 ) ; }
 @ Deprecated public static void debug ( Ignite@@ Logger log , String msg ) { log . info ( msg ) ; }
 public static boolean is@@ ParameterizedType ( Type type ) { return ( type instanceof ParameterizedType ) ; }
 public static Row@@ Index@@ Entry < Index@@ Helper . Index@@ Info > create ( long position , Deletion@@ Time dele@@ tion@@ Time , ColumnIndex index ) { assert index != null ; assert dele@@ tion@@ Time != null ; if ( index . columns@@ Index . size ( ) > 1 ) return new Indexed@@ Entry ( position , dele@@ tion@@ Time , index . partition@@ Header@@ Length , index . columns@@ Index ) ; else return new Row@@ Index@@ Entry < > ( position ) ; }
